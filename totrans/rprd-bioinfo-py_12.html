<html><head></head><body><section data-pdf-bookmark="Chapter 11. Finding a Protein Motif: Fetching Data and Using Regular Expressions" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch11">&#13;
<h1><span class="label">Chapter 11. </span>Finding a Protein Motif: Fetching Data and Using Regular Expressions</h1>&#13;
&#13;
&#13;
<p>We’ve spent quite a bit of time now looking for sequence motifs.<a data-primary="proteins" data-secondary="finding sequences with a motif" data-tertiary="about" data-type="indexterm" id="idm45963630444136"/>&#13;
As described in <a href="https://oreil.ly/EAp3i">the Rosalind MPRT challenge</a>, shared or conserved sequences in proteins imply shared functions.&#13;
In this exercise, I need to identify protein sequences that contain the N-glycosylation motif.&#13;
The input to the program is a list of protein IDs that will be used to download the sequences from <a href="https://www.uniprot.org">the UniProt website</a>.&#13;
After demonstrating how to manually and programmatically download the data, I’ll show how to find the motif using a regular expression and by writing a manual solution.</p>&#13;
&#13;
<p>You will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to programmatically fetch data from the internet</p>&#13;
</li>&#13;
<li>&#13;
<p>How to write a regular expression to find the N-glycosylation motif</p>&#13;
</li>&#13;
<li>&#13;
<p>How to manually find the N-glycosylation motif</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963630437032">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>All the code and tests for this program are located in the <em>11_mprt</em> directory.<a data-primary="proteins" data-secondary="finding sequences with a motif" data-tertiary="getting started" data-type="indexterm" id="idm45963630435240"/>&#13;
To begin, copy the first solution to the program <code>mprt.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 11_mprt&#13;
$ cp solution1_regex.py mprt.py</pre>&#13;
&#13;
<p>Inspect the usage:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./mprt.py -h&#13;
usage: mprt.py [-h] [-d DIR] FILE&#13;
&#13;
Find locations of N-glycosylation motif&#13;
&#13;
positional arguments:&#13;
  FILE                  Input text file of UniProt IDs <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
optional arguments:&#13;
  -h, --help            show this help message and exit&#13;
  -d DIR, --download_dir DIR <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
                        Directory for downloads (default: fasta)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The required positional argument is a file of protein IDs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The optional download directory name defaults to <em>fasta</em>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The input file will list protein IDs, one per line.&#13;
The protein IDs provided in the Rosalind example comprise the first test input file:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.txt&#13;
A2Z669&#13;
B5ZC00&#13;
P07204_TRBM_HUMAN&#13;
P20840_SAG1_YEAST</pre>&#13;
&#13;
<p>Run the program using this as the argument.&#13;
The output of the program lists each protein ID containing the N-glycosylation motif and the locations where it can be found:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./mprt.py tests/inputs/1.txt&#13;
B5ZC00&#13;
85 118 142 306 395&#13;
P07204_TRBM_HUMAN&#13;
47 115 116 382 409&#13;
P20840_SAG1_YEAST&#13;
79 109 135 248 306 348 364 402 485 501 614</pre>&#13;
&#13;
<p>After running the preceding command, you should see that the default <em>fasta</em> directory has been created.&#13;
Inside you should find four FASTA files.&#13;
All subsequent runs using these protein IDs will be faster as the cached data will be used unless you remove the download directory, for instance by running <strong><code>make clean</code></strong>.</p>&#13;
&#13;
<p>Take a look at the first two lines of each file using the command <strong><code>head -2</code></strong>.&#13;
The headers for some of the FASTA records are quite long so I’ve broken them here so they won’t wrap, but the actual headers must be on a single line:</p>&#13;
&#13;
<pre data-type="programlisting">$ head -2 fasta/*&#13;
==&gt; fasta/A2Z669.fasta &lt;==&#13;
&gt;sp|A2Z669|CSPLT_ORYSI CASP-like protein 5A2 OS=Oryza sativa subsp.&#13;
 indica OX=39946 GN=OsI_33147 PE=3 SV=1&#13;
MRASRPVVHPVEAPPPAALAVAAAAVAVEAGVGAGGGAAAHGGENAQPRGVRMKDPPGAP&#13;
&#13;
==&gt; fasta/B5ZC00.fasta &lt;==&#13;
&gt;sp|B5ZC00|SYG_UREU1 Glycine--tRNA ligase OS=Ureaplasma urealyticum&#13;
 serovar 10 (strain ATCC 33699 / Western) OX=565575 GN=glyQS PE=3 SV=1&#13;
MKNKFKTQEELVNHLKTVGFVFANSEIYNGLANAWDYGPLGVLLKNNLKNLWWKEFVTKQ&#13;
&#13;
==&gt; fasta/P07204_TRBM_HUMAN.fasta &lt;==&#13;
&gt;sp|P07204|TRBM_HUMAN Thrombomodulin OS=Homo sapiens OX=9606 GN=THBD PE=1 SV=2&#13;
MLGVLVLGALALAGLGFPAPAEPQPGGSQCVEHDCFALYPGPATFLNASQICDGLRGHLM&#13;
&#13;
==&gt; fasta/P20840_SAG1_YEAST.fasta &lt;==&#13;
&gt;sp|P20840|SAG1_YEAST Alpha-agglutinin OS=Saccharomyces cerevisiae&#13;
 (strain ATCC 204508 / S288c) OX=559292 GN=SAG1 PE=1 SV=2&#13;
MFTFLKIILWLFSLALASAININDITFSNLEITPLTANKQPDQGWTATFDFSIADASSIR</pre>&#13;
&#13;
<p>Run <strong><code>make test</code></strong> to see the kinds of tests your program should pass.&#13;
When you’re ready, start the program from scratch:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Find locations of N-glycosylation motif' mprt.py&#13;
Done, see new script "mprt.py".</pre>&#13;
&#13;
<p>You should define a positional file argument and an optional download directory as the arguments to the program:<a data-primary="arguments" data-secondary="download directory optional argument" data-type="indexterm" id="idm45963630410888"/></p>&#13;
&#13;
<pre data-type="programlisting">class Args(NamedTuple):&#13;
    """ Command-line arguments """&#13;
    file: TextIO <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
    download_dir: str <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
&#13;
def get_args() -&gt; Args:&#13;
    """Get command-line arguments"""&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Find location of N-glycosylation motif',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('file',&#13;
                        help='Input text file of UniProt IDs',&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('rt')) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-3" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
    parser.add_argument('-d',&#13;
                        '--download_dir',&#13;
                        help='Directory for downloads',&#13;
                        metavar='DIR',&#13;
                        type=str,&#13;
                        default='fasta') <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-4" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(args.file, args.download_dir)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>file</code> will be a filehandle.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>download_dir</code> will be a string.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-3" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Ensure the <code>file</code> argument is a readable text file.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-4" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The <code>download_dir</code> is an optional string with a reasonable default value.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Ensure your program can create the usage, then start by printing the protein IDs from the file.&#13;
Each ID is terminated by a newline, so I’ll use the <code>str.rstrip()</code> (<em>right strip</em>) method to remove any whitespace from the right side:<a data-primary="newline at end" data-secondary="rstrip() to remove" data-type="indexterm" id="idm45963630385960"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    for prot_id in map(str.rstrip, args.file):&#13;
        print(prot_id)</pre>&#13;
&#13;
<p>Run the program and make sure you see the protein IDs:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./mprt.py tests/inputs/1.txt&#13;
A2Z669&#13;
B5ZC00&#13;
P07204_TRBM_HUMAN&#13;
P20840_SAG1_YEAST</pre>&#13;
&#13;
<p>If you run <strong><code>pytest</code></strong>, you should pass the first three tests and fail the fourth.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Downloading Sequences Files on the Command Line" data-type="sect2"><div class="sect2" id="idm45963630381704">&#13;
<h2>Downloading Sequences Files on the Command Line</h2>&#13;
&#13;
<p>The next order of business is fetching the protein sequences.<a data-primary="proteins" data-secondary="finding sequences with a motif" data-tertiary="command line download of sequences" data-type="indexterm" id="ch11-urlx"/><a data-primary="downloading protein sequences" data-secondary="command line" data-type="indexterm" id="ch11-urly"/>&#13;
The UniProt information for each protein is found by substituting the <a data-primary="downloading protein sequences" data-secondary="UniProt URL" data-type="indexterm" id="idm45963630377368"/><a data-primary="proteins" data-secondary="finding sequences with a motif" data-tertiary="UniProt site" data-type="indexterm" id="idm45963630376408"/><a data-primary="resources" data-secondary="UniProt site for protein sequences" data-type="indexterm" id="idm45963630375176"/><a data-primary="proteins" data-secondary="UniProt site for protein sequences" data-type="indexterm" id="idm45963630374216"/><a data-primary="UniProt site for protein sequences" data-secondary="command line download" data-type="indexterm" id="ch11-url"/><a data-primary="proteins" data-secondary="UniProt site for protein sequences" data-tertiary="command line download" data-type="indexterm" id="ch11-urlz"/>protein ID into the URL <em>http://www.uniprot.org/uniprot/{uniprot_id}</em>.&#13;
I’ll change the program to print this string instead:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    for prot_id in map(str.rstrip, args.file):&#13;
        print(f'http://www.uniprot.org/uniprot/{prot_id}')</pre>&#13;
&#13;
<p>You should now see this output:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./mprt.py tests/inputs/1.txt&#13;
http://www.uniprot.org/uniprot/A2Z669&#13;
http://www.uniprot.org/uniprot/B5ZC00&#13;
http://www.uniprot.org/uniprot/P07204_TRBM_HUMAN&#13;
http://www.uniprot.org/uniprot/P20840_SAG1_YEAST</pre>&#13;
&#13;
<p>Paste the first URL into your web browser and inspect the page.&#13;
There is a wealth of data, all in a human-readable format.&#13;
Scroll down to the sequence, and you should see 203 amino acids.&#13;
It would be awful to have to parse this page to extract the sequence.&#13;
Luckily, I can append <em>.fasta</em> to the URL and get a FASTA file of the sequence.<a data-primary="UniProt site for protein sequences" data-secondary="FASTA files" data-type="indexterm" id="idm45963630366392"/><a data-primary="FASTA format" data-secondary="UniProt site for protein sequences" data-type="indexterm" id="idm45963630365432"/></p>&#13;
&#13;
<p>Before I show you how to download the sequences using Python, I think you should know how to do this using command-line tools.<a data-primary="Unix command line" data-secondary="downloading protein sequence files" data-type="indexterm" id="ch11-dwn"/><a data-primary="command line (Unix)" data-secondary="downloading protein sequence files" data-type="indexterm" id="ch11-dwn2"/>&#13;
From the command line, you can use <code>curl</code> (which you may need to install) to download the sequence.<a data-primary="command line (Unix)" data-secondary="curl to transfer server data" data-type="indexterm" id="idm45963630360776"/><a data-primary="Unix command line" data-secondary="curl to transfer server data" data-type="indexterm" id="idm45963630359816"/><a data-primary="curl to transfer server data" data-type="indexterm" id="idm45963630358856"/>&#13;
By default, this will print the contents of the file to <code>STDOUT</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ curl https://www.uniprot.org/uniprot/A2Z669.fasta&#13;
&gt;sp|A2Z669|CSPLT_ORYSI CASP-like protein 5A2 OS=Oryza sativa subsp.&#13;
 indica OX=39946 GN=OsI_33147 PE=3 SV=1&#13;
MRASRPVVHPVEAPPPAALAVAAAAVAVEAGVGAGGGAAAHGGENAQPRGVRMKDPPGAP&#13;
GTPGGLGLRLVQAFFAAAALAVMASTDDFPSVSAFCYLVAAAILQCLWSLSLAVVDIYAL&#13;
LVKRSLRNPQAVCIFTIGDGITGTLTLGAACASAGITVLIGNDLNICANNHCASFETATA&#13;
MAFISWFALAPSCVLNFWSMASR</pre>&#13;
&#13;
<p>You could either redirect this to a file:</p>&#13;
&#13;
<pre data-type="programlisting">$ curl https://www.uniprot.org/uniprot/A2Z669.fasta &gt; A2Z669.fasta</pre>&#13;
&#13;
<p>or use the <code>-o|--output</code> option to name the output file:</p>&#13;
&#13;
<pre data-type="programlisting">$ curl -o A2Z669.fasta https://www.uniprot.org/uniprot/A2Z669.fasta</pre>&#13;
&#13;
<p>You can also use <code>wget</code> (<em>web get</em>, which may also need to be installed) to download the sequence file like so:<a data-primary="wget (web get) to transfer server data" data-type="indexterm" id="idm45963630352104"/></p>&#13;
&#13;
<pre data-type="programlisting">$ wget https://www.uniprot.org/uniprot/A2Z669.fasta</pre>&#13;
&#13;
<p>Whichever tool you use, you should now have a file called <em>A2Z669.fasta</em> with the sequence data:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat A2Z669.fasta&#13;
&gt;sp|A2Z669|CSPLT_ORYSI CASP-like protein 5A2 OS=Oryza sativa subsp.&#13;
 indica OX=39946 GN=OsI_33147 PE=3 SV=1&#13;
MRASRPVVHPVEAPPPAALAVAAAAVAVEAGVGAGGGAAAHGGENAQPRGVRMKDPPGAP&#13;
GTPGGLGLRLVQAFFAAAALAVMASTDDFPSVSAFCYLVAAAILQCLWSLSLAVVDIYAL&#13;
LVKRSLRNPQAVCIFTIGDGITGTLTLGAACASAGITVLIGNDLNICANNHCASFETATA&#13;
MAFISWFALAPSCVLNFWSMASR</pre>&#13;
&#13;
<p>I know this is a book on Python, but it’s worth learning how to write a basic <code>bash</code> program.&#13;
Just as some stories can be told in a haiku and others are sprawling novels, some tasks are easily expressed using a few shell commands and others require thousands of lines of code in a more complex language.&#13;
Sometimes I can write 10 lines of <code>bash</code> to do what I need.&#13;
When I hit about 30 lines of <code>bash</code>, I generally move to Python or Rust.</p>&#13;
&#13;
<p>Here is how I could automate downloading the proteins with a <code>bash</code> script:<a data-primary="bash shell" data-secondary="downloading proteins automated" data-type="indexterm" id="idm45963630345576"/><a data-primary="automating" data-secondary="bash script to download proteins" data-type="indexterm" id="idm45963630344616"/></p>&#13;
&#13;
<pre data-type="programlisting">#!/usr/bin/env bash <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
if [[ $# -ne 1 ]]; then <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
    printf "usage: %s FILE\n" $(basename "$0") <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-3" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
    exit 1 <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-4" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
fi&#13;
&#13;
OUT_DIR="fasta" <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-5" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-5"><img alt="5" src="assets/5.png"/></a>&#13;
[[ ! -d "$OUT_DIR" ]] &amp;&amp; mkdir -p "$OUT_DIR" <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-6" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-6"><img alt="6" src="assets/6.png"/></a>&#13;
&#13;
while read -r PROT_ID; do <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-7" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-7"><img alt="7" src="assets/7.png"/></a>&#13;
    echo "$PROT_ID"   <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-8" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-8"><img alt="8" src="assets/8.png"/></a>&#13;
    URL="https://www.uniprot.org/uniprot/${PROT_ID}" <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-9" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-9"><img alt="9" src="assets/9.png"/></a>&#13;
    OUT_FILE="$OUT_DIR/${PROT_ID}.fasta" <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-10" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-10"><img alt="10" src="assets/10.png"/></a>&#13;
    wget -q -o "$OUT_FILE" "$URL" <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-11" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-11"><img alt="11" src="assets/11.png"/></a>&#13;
done &lt; $1 <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-12" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-12"><img alt="12" src="assets/12.png"/></a>&#13;
&#13;
echo "Done, see output in \"$OUT_DIR\"." <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-13" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-13"><img alt="13" src="assets/13.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The shebang (<code>#!</code>) should use the <code>env</code> (environment) to find <code>bash</code>.<a data-primary="#! (shebang)" data-primary-sortas="# shebang" data-type="indexterm" id="idm45963630312952"/><a data-primary="shebang (#!)" data-type="indexterm" id="idm45963630312008"/><a data-primary="environment variables" data-secondary="shebang (#!)" data-type="indexterm" id="idm45963630311336"/></p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Check that the number of arguments (<code>$#</code>) is <code>1</code>.<a data-primary="$# (number of arguments)" data-primary-sortas="# number of arguments" data-type="indexterm" id="idm45963630306824"/><a data-primary="arguments" data-secondary="$# (number of arguments)" data-type="indexterm" id="idm45963630305864"/></p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-3" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Print a usage statement using the program basename (<code>$0</code>).</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-4" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Exit with a nonzero value.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-5" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Define the output directory to be <em>fasta</em>. Note that in <code>bash</code> you can have no spaces around the <code>=</code> for variable assignment.<a data-primary="bash shell" data-secondary="no spaces around = in assignments" data-type="indexterm" id="idm45963630295048"/><a data-primary="equal signs" data-secondary="no spaces in bash shell assignments" data-type="indexterm" id="idm45963630294088"/></p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-6" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Create the output directory if it does not exist.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-7" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Read each line from the file into the <code>PROT_ID</code> variable.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-8" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Print the current protein ID so the user knows something is happening.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-9" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Construct the URL by using variable interpolation inside double quotes.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-10" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>Construct the output filename by combining the output directory and the protein ID.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-11" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-11"><img alt="11" src="assets/11.png"/></a></dt>&#13;
<dd><p>Call <code>wget</code> with the <code>-q</code> (quiet) flag to fetch the URL into the output file.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-12" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-12"><img alt="12" src="assets/12.png"/></a></dt>&#13;
<dd><p>This reads each line from the first positional argument (<code>$1</code>), which is the input filename.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-13" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO3-13"><img alt="13" src="assets/13.png"/></a></dt>&#13;
<dd><p>Let the user know the program has finished and where to find the output.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I can run this like so:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./fetch_fasta.sh tests/inputs/1.txt&#13;
A2Z669&#13;
B5ZC00&#13;
P07204_TRBM_HUMAN&#13;
P20840_SAG1_YEAST&#13;
Done, see output in "fasta".</pre>&#13;
&#13;
<p>Now there should be a <em>fasta</em> directory containing the four FASTA files.&#13;
One way to write the <code>mprt.py</code> program would be to fetch all the input files first using something like this and then provide the FASTA files as arguments.&#13;
This is a very common pattern in bioinformatics, and writing a shell script like this is a great way to document exactly how you retrieved the data for your analysis.&#13;
Be sure you always commit programs like this to your source repository, and consider adding a <em>Makefile</em> target with a name like <em>fasta</em> that is flush-left followed by a colon and the command on the next line indented with a single tab character:</p>&#13;
&#13;
<pre data-type="programlisting">fasta:&#13;
	./fetch_fasta.sh tests/inputs/1.txt</pre>&#13;
&#13;
<p>Now you should be able to run <strong><code>make fasta</code></strong> to automate the process of getting your data.&#13;
By writing the program to accept the input file as an argument rather than hard-coding it, I can use this program and multiple <em>Makefile</em> targets to automate the process of downloading many different datasets.&#13;
Reproducibility for the win.<a data-startref="ch11-url" data-type="indexterm" id="idm45963630263048"/><a data-startref="ch11-dwn" data-type="indexterm" id="idm45963630262376"/><a data-startref="ch11-dwn2" data-type="indexterm" id="idm45963630261704"/><a data-startref="ch11-url3" data-type="indexterm" id="idm45963630261032"/><a data-startref="ch11-urlx" data-type="indexterm" id="idm45963630260360"/><a data-startref="ch11-urly" data-type="indexterm" id="idm45963630259688"/><a data-startref="ch11-urlz" data-type="indexterm" id="idm45963630259016"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Downloading Sequences Files with Python" data-type="sect2"><div class="sect2" id="idm45963630258024">&#13;
<h2>Downloading Sequences Files with Python</h2>&#13;
&#13;
<p>I’ll translate the <code>bash</code> utility to Python now.<a data-primary="proteins" data-secondary="UniProt site for protein sequences" data-tertiary="Python download" data-type="indexterm" id="ch11-pydw2"/><a data-primary="proteins" data-secondary="finding sequences with a motif" data-tertiary="Python download of sequences" data-type="indexterm" id="ch11-pydw3"/><a data-primary="UniProt site for protein sequences" data-secondary="Python download" data-type="indexterm" id="ch11-pydw4"/><a data-primary="downloading protein sequences" data-secondary="Python" data-type="indexterm" id="ch11-pydw"/>&#13;
As you can see from the preceding program, there are several steps involved to fetch each sequence file.&#13;
I don’t want this to be a part of <code>main()</code> as it will clutter the program, so I’ll write a function for this:</p>&#13;
&#13;
<pre data-type="programlisting">def fetch_fasta(fh: TextIO, fasta_dir: str) -&gt; List[str]: <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Fetch the FASTA files into the download directory """&#13;
&#13;
    return [] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function will accept a filehandle for the protein IDs and a download directory name, and will return a list of the files that were downloaded or were already present. Be sure to add <code>typing.List</code> to your imports.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>For now, return an empty list.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I want to call it like this:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    files = fetch_fasta(args.file, args.download_dir)&#13;
    print('\n'.join(files))</pre>&#13;
&#13;
<p>Run your program and ensure it compiles and prints nothing.&#13;
Now add the following Python code to fetch the sequences.&#13;
You’ll need to import <code>os</code>, <code>sys</code>, and <a href="https://oreil.ly/nYSUM"><code>requests</code></a>, a library for making web requests:</p>&#13;
&#13;
<pre data-type="programlisting">def fetch_fasta(fh: TextIO, fasta_dir: str) -&gt; List[str]:&#13;
    """ Fetch the FASTA files into the download directory """&#13;
&#13;
    if not os.path.isdir(fasta_dir): <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
        os.makedirs(fasta_dir) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    files = [] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-3" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-3"><img alt="3" src="assets/3.png"/></a>&#13;
    for prot_id in map(str.rstrip, fh): <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-4" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-4"><img alt="4" src="assets/4.png"/></a>&#13;
        fasta = os.path.join(fasta_dir, prot_id + '.fasta') <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-5" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-5"><img alt="5" src="assets/5.png"/></a>&#13;
        if not os.path.isfile(fasta): <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-6" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-6"><img alt="6" src="assets/6.png"/></a>&#13;
            url = f'http://www.uniprot.org/uniprot/{prot_id}.fasta' <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-7" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-7"><img alt="7" src="assets/7.png"/></a>&#13;
            response = requests.get(url) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-8" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-8"><img alt="8" src="assets/8.png"/></a>&#13;
            if response.status_code == 200: <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-9" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-9"><img alt="9" src="assets/9.png"/></a>&#13;
                print(response.text, file=open(fasta, 'wt')) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-10" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-10"><img alt="10" src="assets/10.png"/></a>&#13;
            else:&#13;
                print(f'Error fetching "{url}": "{response.status_code}"',&#13;
                      file=sys.stderr) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-11" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-11"><img alt="11" src="assets/11.png"/></a>&#13;
                continue <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-12" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-12"><img alt="12" src="assets/12.png"/></a>&#13;
&#13;
        files.append(fasta) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-13" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-13"><img alt="13" src="assets/13.png"/></a>&#13;
&#13;
    return files <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-14" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-14"><img alt="14" src="assets/14.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create the output directory if it does not exist.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create the directory and any needed parent directories.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-3" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Initialize the return list of filenames.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-4" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Read each protein ID from the file.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-5" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Construct the output filename by combining the output directory plus the protein ID.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-6" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Check if the file already exists.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-7" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Construct the URL to the FASTA file.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-8" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Make a <em>GET</em> request for the file.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-9" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>A response code of 200 indicates success.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-10" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>Write the text of the response to the output file.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-11" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-11"><img alt="11" src="assets/11.png"/></a></dt>&#13;
<dd><p>Print a warning to <code>STDERR</code> that the file could not be fetched.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-12" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-12"><img alt="12" src="assets/12.png"/></a></dt>&#13;
<dd><p>Skip to the next iteration.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-13" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-13"><img alt="13" src="assets/13.png"/></a></dt>&#13;
<dd><p>Append the file to the return list.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-14" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO5-14"><img alt="14" src="assets/14.png"/></a></dt>&#13;
<dd><p>Return the files that now exist locally.</p></dd>&#13;
</dl>&#13;
<div data-type="warning" epub:type="warning">&#13;
<p><code>os.makedirs()</code> is an example of a function that will throw an exception if it fails.<a data-primary="errors" data-secondary="exceptions not caught" data-type="indexterm" id="idm45963630166168"/><a data-primary="exceptions not caught" data-type="indexterm" id="idm45963630165224"/><a data-primary="os module" data-secondary="makedirs" data-type="indexterm" id="idm45963630164552"/> This might happen due to the user having insufficient permissions to create a directory, or because of a disk error. What would be the point in my catching and handling such an error? If my program is unable to fix a problem, I feel it’s better to let it crash loudly, producing an error code and a stacktrace of what went wrong. A human would have to fix the underlying problems before the program could work. Catching and mishandling the exception would be far worse than letting the program crash.</p>&#13;
</div>&#13;
&#13;
<p>That logic almost exactly mirrors that of the <code>bash</code> program.&#13;
If you run your program again, there should be a <em>fasta</em> directory with the four files, and the program should print the names of the downloaded files:<a data-startref="ch11-pydw" data-type="indexterm" id="idm45963630161304"/><a data-startref="ch11-pydw2" data-type="indexterm" id="idm45963630160632"/><a data-startref="ch11-pydw3" data-type="indexterm" id="idm45963630159960"/><a data-startref="ch11-pydw4" data-type="indexterm" id="idm45963630159288"/></p>&#13;
&#13;
<pre data-type="programlisting">$ ./mprt.py tests/inputs/1.txt&#13;
fasta/A2Z669.fasta&#13;
fasta/B5ZC00.fasta&#13;
fasta/P07204_TRBM_HUMAN.fasta&#13;
fasta/P20840_SAG1_YEAST.fasta</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing a Regular Expression to Find the Motif" data-type="sect2"><div class="sect2" id="idm45963630157464">&#13;
<h2>Writing a Regular Expression to Find the Motif</h2>&#13;
&#13;
<p>The Rosalind page notes:<a data-primary="proteins" data-secondary="finding sequences with a motif" data-tertiary="regular expression to find motif" data-type="indexterm" id="idm45963630156120"/><a data-primary="regular expressions (regexes)" data-secondary="protein motif" data-type="indexterm" id="idm45963630154872"/></p>&#13;
<blockquote>&#13;
<p>To allow for the presence of its varying forms, a protein motif is represented by a shorthand as follows: <code>[XY]</code> means <em>either X or Y</em> and <code>{X}</code> means <em>any amino acid except X</em>. For example, the N-glycosylation motif is written as <code>N{P}[ST]{P}</code>.</p></blockquote>&#13;
&#13;
<p>The <a href="https://oreil.ly/aFwWe">Prosite website</a> is a database of protein domains, families, and functional sites.<a data-primary="proteins" data-secondary="finding sequences with a motif" data-tertiary="Prosite database" data-type="indexterm" id="idm45963630149592"/><a data-primary="proteins" data-secondary="Prosite database of protein information" data-type="indexterm" id="idm45963630148360"/>&#13;
The <a href="https://oreil.ly/VrQLl">details for the N-glycosylation motif</a> show a similar convention for the <em>consensus pattern</em> of <code>N-{P}-[ST]-{P}</code>.&#13;
Both patterns are extremely close to the regular expression shown in <a data-type="xref" href="#fig_11.1">Figure 11-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_11.1">&#13;
<img alt="mpfb 1101" src="assets/mpfb_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>A regular expression for the N-glycosylation protein motif</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this regex, the <code>N</code> indicates the literal character <em>N</em>.&#13;
The <code>[ST]</code> is a character class representing either the character <em>S</em> or <em>T</em>.&#13;
It’s the same as the regex <code>[GC]</code> I wrote in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a> to find either <em>G</em> or <em>C</em>.&#13;
The <code>[^P]</code> is a <em>negated</em> character class, which means it will match any character that is <em>not P</em>.</p>&#13;
&#13;
<p>Some people (OK, mostly me) like to represent regexes using the notation of finite state machines (FSMs), such as the one shown in <a data-type="xref" href="#fig_11.2">Figure 11-2</a>.<a data-primary="regular expressions (regexes)" data-secondary="finite state machine" data-type="indexterm" id="idm45963630134888"/><a data-primary="finite state machine (FSM)" data-secondary="regular expressions" data-type="indexterm" id="idm45963630133928"/>&#13;
Imagine the pattern entering on the left.&#13;
It first needs to find the letter <em>N</em> to proceed to the next step.&#13;
Next can be any character that is not the letter <em>P</em>.&#13;
After that, the graph has two alternate paths through the letters <em>S</em> or <em>T</em>, which must be followed again by a not-<em>P</em> character.&#13;
If the pattern makes it to the double circle, the match was successful.</p>&#13;
&#13;
<figure><div class="figure" id="fig_11.2">&#13;
<img alt="mpfb 1102" src="assets/mpfb_1102.png"/>&#13;
<h6><span class="label">Figure 11-2. </span>Graphical depiction of an FSM to identify the N-glycosylation motif</h6>&#13;
</div></figure>&#13;
&#13;
<p>In <a data-type="xref" href="ch08.html#ch08">Chapter 8</a>, I pointed out a problem when using regular expressions to find overlapping text.&#13;
There are no instances of this in the first test file, but another of the datasets I used to solve the problem did have two overlapping motifs.&#13;
Let me demonstrate in the REPL:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import re&#13;
&gt;&gt;&gt; regex = re.compile('N[^P][ST][^P]')</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>I’m using the <code>re.compile()</code> function here to force the regex engine to parse the pattern<a data-primary="regular expressions (regexes)" data-secondary="compile() function" data-type="indexterm" id="idm45963630124424"/> and create the necessary internal code to do the matching. This is similar to how compiled languages like C use source code that humans can edit and read into machine code that computers can directly execute. <a data-primary="regular expressions (regexes)" data-secondary="search() recompiling on each call" data-type="indexterm" id="idm45963630123112"/>This transformation happens once when you use <code>re.compile()</code>, whereas functions like <code>re.search()</code> must recompile the regex on each call.</p>&#13;
</div>&#13;
&#13;
<p>Here is the relevant portion of the protein sequence for <em>P07204_TRBM_HUMAN</em> that has the pattern starting at both the first and second positions (see <a data-type="xref" href="#fig_11.3">Figure 11-3</a>).&#13;
The <code>re.findall()</code> function shows that only the pattern starting at the first position is found:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'NNTSYS'&#13;
&gt;&gt;&gt; regex.findall(seq)&#13;
['NNTS']</pre>&#13;
&#13;
<figure><div class="figure" id="fig_11.3">&#13;
<img alt="mpfb 1103" src="assets/mpfb_1103.png"/>&#13;
<h6><span class="label">Figure 11-3. </span>This sequence contains two copies of the motif that overlap</h6>&#13;
</div></figure>&#13;
&#13;
<p>As in <a data-type="xref" href="ch08.html#ch08">Chapter 8</a>, the solution is to wrap the regex in a look-ahead assertion using <span class="keep-together"><code>?=(&lt;<em>pattern</em>&gt;</code>)</span>, which itself will need to be wrapped in capturing parentheses:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; regex = re.compile('(?=(N[^P][ST][^P]))')&#13;
&gt;&gt;&gt; regex.findall(seq)&#13;
['NNTS', 'NTSY']</pre>&#13;
&#13;
<p>I need to know the positions of the matches, which I can get from <code>re.finditer()</code>.<a data-primary="regular expressions (regexes)" data-secondary="finditer()" data-type="indexterm" id="idm45963630111096"/>&#13;
This will return a list of <code>re.Match</code> objects, each of which has a <code>match.start()</code> function that will return the zero-offset index of the match’s starting position.&#13;
I need to add 1 to report the position using 1-based counting:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [match.start() + 1 for match in regex.finditer(seq)]&#13;
[1, 2]</pre>&#13;
&#13;
<p>This should be enough for you to solve the rest of the problem.&#13;
Keep hacking until you pass all the tests.&#13;
Be sure to download a dataset from the Rosalind site and verify that your solution gives an answer that passes the test with that, too.&#13;
See if you can also write a version that doesn’t use regular expressions.&#13;
Go back and study the FSM model and think about how you can implement those ideas in Python code.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963630106824">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>I will present two variations to solve this problem.&#13;
Both use the same <code>get_args()</code> and <code>fetch_fasta()</code> functions shown previously.&#13;
The first uses a regular expression to find the motif, and the second imagines how to solve the problem in a horrible, desolate intellectual wasteland where regular expressions don’t exist.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Using a Regular Expression" data-type="sect2"><div class="sect2" id="idm45963630104216">&#13;
<h2>Solution 1: Using a Regular Expression</h2>&#13;
&#13;
<p>The following is my final solution using a regular expression.<a data-primary="proteins" data-secondary="finding sequences with a motif" data-tertiary="solution 1 regular expression" data-type="indexterm" id="ch11-prre"/><a data-primary="regular expressions (regexes)" data-secondary="protein motif" data-type="indexterm" id="ch11-prre2"/>&#13;
Be sure to import <code>re</code> and <code>Bio.SeqIO</code> for this:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    files = fetch_fasta(args.file, args.download_dir) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
    regex = re.compile('(?=(N[^P][ST][^P]))') <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    for file in files: <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-3" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-3"><img alt="3" src="assets/3.png"/></a>&#13;
        prot_id, _ = os.path.splitext(os.path.basename(file)) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-4" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-4"><img alt="4" src="assets/4.png"/></a>&#13;
        recs = SeqIO.parse(file, 'fasta') <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-5" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-5"><img alt="5" src="assets/5.png"/></a>&#13;
        if rec := next(recs): <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-6" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-6"><img alt="6" src="assets/6.png"/></a>&#13;
            if matches := list(regex.finditer(str(rec.seq))): <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-7" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-7"><img alt="7" src="assets/7.png"/></a>&#13;
                print(prot_id) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-8" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-8"><img alt="8" src="assets/8.png"/></a>&#13;
                print(*[match.start() + 1 for match in matches]) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-9" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-9"><img alt="9" src="assets/9.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Fetch the sequence files for the protein IDs in the given file. Put the files into the indicated download directory.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Compile the regex for the N-glycosylation motif.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-3" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Iterate through the files.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-4" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Get the protein ID from the basename of the file minus the file extension.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-5" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Create a lazy iterator to fetch the FASTA sequences from the file.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-6" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Attempt to retrieve the first sequence record from the iterator.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-7" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Coerce the sequence to a <code>str</code>, then try to find all the matches for the motif.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-8" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Print the protein ID.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-9" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO6-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Print all the matches, correcting to 1-based counting.</p></dd>&#13;
</dl>&#13;
&#13;
<p>In this solution, I used the <code>os.path.basename()</code> and <code>os.path.splitext()</code> functions.<a data-primary="os module" data-secondary="path.basename" data-type="indexterm" id="idm45963630053768"/><a data-primary="os module" data-secondary="path.splitext" data-type="indexterm" id="idm45963630052824"/><a data-primary="file input" data-secondary="path module" data-type="indexterm" id="idm45963630051880"/>&#13;
I often use these, so I want to make sure you understand exactly what they do.&#13;
I first introduced the <code>os.path.basename()</code> in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>.&#13;
This function will return the filename from a path that might include directories:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import os&#13;
&gt;&gt;&gt; basename = os.path.basename('fasta/B5ZC00.fasta')&#13;
&gt;&gt;&gt; basename&#13;
'B5ZC00.fasta'</pre>&#13;
&#13;
<p>The <code>os.path.splitext()</code> function will break a filename into the part before the file extension and the extension:<a data-primary="file extensions" data-type="indexterm" id="idm45963630047576"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; os.path.splitext(basename)&#13;
('B5ZC00', '.fasta')</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>File extensions can provide useful metadata about a file. For instance, your operating system may know to use Microsoft Excel to open files ending in <em>.xls</em> or <em>.xlsx</em>. <a data-primary="FASTA format" data-secondary="file extensions" data-type="indexterm" id="idm45963630044120"/>There are many conventions for FASTA extensions, including <em>.fasta</em>, <em>.fa</em>, <em>.fna</em> (for nucleotides), and <em>.faa</em> (for amino acids). You can put whatever extension you like on a FASTA file or none at all, but remember that a FASTA file is always plain text and needs no special application to view it. Also, just because a file has a FASTA-like extension does not necessarily mean it’s a FASTA file. <em>Caveat emptor</em>.</p>&#13;
</div>&#13;
&#13;
<p>In the preceding code, I don’t need the extension, so I assign it to the variable <code>_</code> (underscore), which is a convention indicating that I don’t intend to use the value.&#13;
I could also use a list slice to grab the first element from the function:<a data-startref="ch11-prre" data-type="indexterm" id="idm45963630039176"/><a data-startref="ch11-prre2" data-type="indexterm" id="idm45963630038504"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; os.path.splitext(basename)[0]&#13;
'B5ZC00'</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Writing a Manual Solution" data-type="sect2"><div class="sect2" id="idm45963630036760">&#13;
<h2>Solution 2: Writing a Manual Solution</h2>&#13;
&#13;
<p>If I were writing a program like this for production use, I would use a regular expression to find the motif.<a data-primary="proteins" data-secondary="finding sequences with a motif" data-tertiary="solution 2 manual find" data-type="indexterm" id="ch11-man"/>&#13;
In this context, though, I wanted to challenge myself to find a manual solution.&#13;
As usual, I want to write a function to encapsulate this idea, so I stub it out:</p>&#13;
&#13;
<pre data-type="programlisting">def find_motif(text: str) -&gt; List[int]: <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Find a pattern in some text """&#13;
&#13;
    return [] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function will take some text and return a list of integers where the motif can be found in the text.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>For now, return the empty list.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The biggest reason to have a function is to write a test where I encode examples I expect to match and fail:</p>&#13;
&#13;
<pre data-type="programlisting">def test_find_motif() -&gt; None:&#13;
    """ Test find_pattern """&#13;
&#13;
    assert find_motif('') == [] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert find_motif('NPTX') == [] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert find_motif('NXTP') == [] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-3" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-3"><img alt="3" src="assets/3.png"/></a>&#13;
    assert find_motif('NXSX') == [0] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-4" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-4"><img alt="4" src="assets/4.png"/></a>&#13;
    assert find_motif('ANXTX') == [1] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-5" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-5"><img alt="5" src="assets/5.png"/></a>&#13;
    assert find_motif('NNTSYS') == [0, 1] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-6" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-6"><img alt="6" src="assets/6.png"/></a>&#13;
    assert find_motif('XNNTSYS') == [1, 2] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-7" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-7"><img alt="7" src="assets/7.png"/></a>&#13;
    assert find_motif('XNNTSYSXNNTSYS') == [1, 2, 8, 9] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-8" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-8"><img alt="8" src="assets/8.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Ensure the function does not do something silly like raise an exception when given the empty string.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This should fail because it has a <em>P</em> in the second position.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-3" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This should fail because it has a <em>P</em> in the fourth position.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-4" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>This should find the motif at the beginning of the string.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-5" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>This should find the motif not at the beginning of the string.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-6" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>This should find overlapping motifs at the beginning of the string.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-7" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>This should find overlapping motifs not at the beginning of the string.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-8" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO8-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>This is a slightly more complicated pattern containing four copies of the motif.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I can add these functions to my <code>mprt.py</code> program and I can run <code>pytest</code> on that source code to ensure that the tests <em>do</em> fail as expected.&#13;
Now I need to write the <code>find_motif()</code> code that will pass these tests.&#13;
I decided I would again use k-mers, so I will bring in the <code>find_kmers()</code> function (and test it, of course, but I’ll omit that here) from Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#ch09">9</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch10.html#ch10">10</a>:</p>&#13;
&#13;
<pre data-type="programlisting">def find_kmers(seq: str, k: int) -&gt; List[str]:&#13;
    """ Find k-mers in string """&#13;
&#13;
    n = len(seq) - k + 1&#13;
    return [] if n &lt; 1 else [seq[i:i + k] for i in range(n)]</pre>&#13;
&#13;
<p>Since the motif is four characters long, I can use this to find all the 4-mers in a sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from solution2_manual import find_kmers&#13;
&gt;&gt;&gt; seq = 'NNTSYS'&#13;
&gt;&gt;&gt; find_kmers(seq, 4)&#13;
['NNTS', 'NTSY', 'TSYS']</pre>&#13;
&#13;
<p>I will also need their positions.&#13;
The <code>enumerate()</code> function I introduced in <a data-type="xref" href="ch08.html#ch08">Chapter 8</a> will provide both the indexes and values of the items in a sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(enumerate(find_kmers(seq, 4)))&#13;
[(0, 'NNTS'), (1, 'NTSY'), (2, 'TSYS')]</pre>&#13;
&#13;
<p>I can unpack each position and k-mer while iterating like so:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for i, kmer in enumerate(find_kmers(seq, 4)):&#13;
...     print(i, kmer)&#13;
...&#13;
0 NNTS&#13;
1 NTSY&#13;
2 TSYS</pre>&#13;
&#13;
<p>Take the first k-mer, <em>NNTS</em>.&#13;
One way to test for this pattern is to manually check each index:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; kmer = 'NNTS'&#13;
&gt;&gt;&gt; kmer[0] == 'N' and kmer[1] != 'P' and kmer[2] in 'ST' and kmer[3] != 'P'&#13;
True</pre>&#13;
&#13;
<p>I know the first two k-mers should match, and this is borne out:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for i, kmer in enumerate(find_kmers(seq, 4)):&#13;
...   kmer[0] == 'N' and kmer[1] != 'P' and kmer[2] in 'ST' and kmer[3] != 'P'&#13;
...&#13;
True&#13;
True&#13;
False</pre>&#13;
&#13;
<p>While effective, this is tedious.&#13;
I would like to hide this code in a function:</p>&#13;
&#13;
<pre data-type="programlisting">def is_match(seq: str) -&gt; bool:&#13;
    """ Find the N-glycosylation """&#13;
&#13;
    return len(seq) == 4 and (seq[0] == 'N' and seq[1] != 'P'&#13;
                              and seq[2] in 'ST' and seq[3] != 'P')</pre>&#13;
&#13;
<p>Here is a test I wrote for the function:</p>&#13;
&#13;
<pre data-type="programlisting">def test_is_match() -&gt; None:&#13;
    """ Test is_match """&#13;
&#13;
    assert not is_match('') <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert is_match('NASA') <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert is_match('NATA')&#13;
    assert not is_match('NATAN') <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-3" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-3"><img alt="3" src="assets/3.png"/></a>&#13;
    assert not is_match('NPTA') <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-4" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-4"><img alt="4" src="assets/4.png"/></a>&#13;
    assert not is_match('NASP') <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-5" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>If a function accepts a string parameter, I always test with an empty string.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The next two sequences should match.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-3" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This sequence is too long and should be rejected.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-4" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>This sequence has a <em>P</em> in the second position and should be rejected.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-5" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO9-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>This sequence has a <em>P</em> in the fourth position and should be rejected.</p></dd>&#13;
</dl>&#13;
&#13;
<p>That makes the code much more readable:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for i, kmer in enumerate(find_kmers(seq, 4)):&#13;
...     print(i, kmer, is_match(kmer))&#13;
...&#13;
0 NNTS True&#13;
1 NTSY True&#13;
2 TSYS False</pre>&#13;
&#13;
<p>I only want the k-mers that match.&#13;
I could write this using an <code>if</code> expression with a guard, which I showed in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.html#ch05">5</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.html#ch06">6</a>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; kmers = list(enumerate(find_kmers(seq, 4)))&#13;
&gt;&gt;&gt; [i for i, kmer in kmers if is_match(kmer)]&#13;
[0, 1]</pre>&#13;
&#13;
<p class="pagebreak-before">Or using the <code>starfilter()</code> function I showed in <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from iteration_utilities import starfilter&#13;
&gt;&gt;&gt; list(starfilter(lambda i, s: is_match(s), kmers))&#13;
[(0, 'NNTS'), (1, 'NTSY')]</pre>&#13;
&#13;
<p>I only want the first elements from each of the tuples, so I could use a <code>map()</code> to select those:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; matches = starfilter(lambda i, s: is_match(s), kmers)&#13;
&gt;&gt;&gt; list(map(lambda t: t[0], matches))&#13;
[0, 1]</pre>&#13;
&#13;
<p>For what it’s worth, Haskell uses tuples extensively and includes two handy functions in the prelude: <code>fst()</code> to get the first element from a 2-tuple, and <code>snd()</code> to get the second.<a data-primary="Haskell language" data-type="indexterm" id="idm45963629928888"/><a data-primary="tuples" data-secondary="fst() to get first element" data-type="indexterm" id="idm45963629928216"/><a data-primary="tuples" data-secondary="snd() to get second element" data-type="indexterm" id="idm45963629927256"/><a data-primary="fst() to get first tuple element" data-type="indexterm" id="idm45963629926296"/><a data-primary="snd() to get second tuple element" data-type="indexterm" id="idm45963629925608"/>&#13;
Be sure to import <code>typing.Tuple</code> for this code:</p>&#13;
&#13;
<pre data-type="programlisting">def fst(t: Tuple[Any, Any]) -&gt; Any:&#13;
    return t[0]&#13;
&#13;
def snd(t: Tuple[Any, Any]) -&gt; Any:&#13;
    return t[1]</pre>&#13;
&#13;
<p>With these functions, I can eliminate the <code>starfilter()</code> like this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(map(fst, filter(lambda t: is_match(snd(t)), kmers)))&#13;
[0, 1]</pre>&#13;
&#13;
<p>But notice a very subtle bug if I try to use the <code>filter()</code>/<code>starmap()</code> technique I’ve shown a couple of times:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from itertools import starmap&#13;
&gt;&gt;&gt; list(filter(None, starmap(lambda i, s: i if is_match(s) else None, kmers)))&#13;
[1]</pre>&#13;
&#13;
<p>It only returns the second match.&#13;
Why is that?&#13;
It’s due to using <code>None</code> as the predicate to <code>filter()</code>.&#13;
According to <code>help(filter)</code>, “If [the] function is <code>None</code>, return the items that are true.”&#13;
In <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>, I introduced the ideas of truthy and falsey values.&#13;
The Boolean values <code>True</code> and <code>False</code> are represented by the integer values <code>1</code> and <code>0</code>,<a data-primary="booleans" data-secondary="integers" data-type="indexterm" id="idm45963629914536"/><a data-primary="integers (int)" data-secondary="booleans as" data-type="indexterm" id="idm45963629913592"/><a data-primary="False (0)" data-type="indexterm" id="idm45963629912648"/><a data-primary="True (1)" data-type="indexterm" id="idm45963629911976"/> respectively; hence, the actual number zero (either <code>int</code> or <code>float</code>) is technically <code>False</code>, which means that any nonzero number is not-<code>False</code> or, if you will, truthy.&#13;
Python will evaluate many data types in a Boolean context to decide if they are truthy or falsey.</p>&#13;
&#13;
<p>In this case, using <code>None</code> as the predicate for <code>filter()</code> causes it to remove the number <code>0</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(filter(None, [1, 0, 2]))&#13;
[1, 2]</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>I came to Python from Perl and JavaScript, both of which also silently coerce values given different contexts, so I was not so surprised by this behavior. If you come from a language like Java, C, or Haskell that has stricter types, this is probably quite troubling. I often feel that Python is a very powerful language if you know exactly what you’re doing at all times. This is a high bar, so it’s extremely important when writing Python to use types and tests liberally.</p>&#13;
</div>&#13;
&#13;
<p>In the end, I felt the list comprehension was the easiest to read.&#13;
Here’s how I wrote my function to manually identify the protein motif:</p>&#13;
&#13;
<pre data-type="programlisting">def find_motif(text: str) -&gt; List[int]:&#13;
    """ Find a pattern in some text """&#13;
&#13;
    kmers = list(enumerate(find_kmers(text, 4))) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-1"><img alt="1" src="assets/1.png"/></a>&#13;
    return [i for i, kmer in kmers if is_match(kmer)] <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Get the positions and values of the 4-mers from the text.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO10-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Select those positions for the k-mers matching the motif.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Using this function is almost identical to how I used the regular expression, which is the point of hiding complexities behind functions:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    files = fetch_fasta(args.file, args.download_dir)&#13;
&#13;
    for file in files:&#13;
        prot_id, _ = os.path.splitext(os.path.basename(file))&#13;
        recs = SeqIO.parse(file, 'fasta')&#13;
        if rec := next(recs):&#13;
            if matches := find_motif(str(rec.seq)): <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-1" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-1"><img alt="1" src="assets/1.png"/></a>&#13;
                pos = map(lambda p: p + 1, matches) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-2" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-2"><img alt="2" src="assets/2.png"/></a>&#13;
                print('\n'.join([prot_id, ' '.join(map(str, pos))])) <a class="co" href="#callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-3" id="co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-1" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Try to find any matches to the motif.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-2" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The matches are a list of 0-based indexes, so add 1 to each.</p></dd>&#13;
<dt><a class="co" href="#co_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-3" id="callout_finding_a_protein_motif__fetching_data_and_using_regular_expressions_CO11-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Convert the integer values to strings and join them on spaces to print.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Although this works and was fun (your mileage may vary) to write, I would not want to use or maintain this code.<a data-startref="ch11-man" data-type="indexterm" id="idm45963629876968"/>&#13;
I hope it gives you a sense of how much work the regular expression is doing for us.&#13;
Regexes allow me to describe <em>what</em> I want, not <em>how</em> to <span class="keep-together">get it.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963629874104">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p><a href="http://elm.eu.org/elms">The Eukaryotic Linear Motifs database example</a> provides regexes to find motifs that define functional sites in proteins. Write a program to search for any occurrence of any pattern in a given set of FASTA files.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963629871752">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You can use command-line utilities like <code>curl</code> and <code>wget</code> to fetch data from the internet. Sometimes it makes sense to write a shell script for such tasks, and sometimes it’s better to encode this using a language like Python.</p>&#13;
</li>&#13;
<li>&#13;
<p>A regular expression can find the N-glycosylation motif, but it’s necessary to wrap it in a look-ahead assertion and capturing parentheses to find overlapping matches.</p>&#13;
</li>&#13;
<li>&#13;
<p>It’s possible to manually find the N-glycosylation motif, but it’s not easy.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>os.path.splitext()</code> function is useful when you need to separate a filename from the extension.</p>&#13;
</li>&#13;
<li>&#13;
<p>File extensions are conventions and may be unreliable.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>