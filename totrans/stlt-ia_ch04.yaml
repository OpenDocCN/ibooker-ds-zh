- en: 5 Sharing your apps with the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The various options available to share your app with users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an app to Streamlit Community Cloud for free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting an app to an external service like an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safeguarding your API keys and other secrets in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your app's dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The moment you first successfully run an app you've built from scratch is magical—it's
    when all the hours spent designing, developing, and refining finally pay off.
    You've guided it through multiple iterations, squashed bugs, and fine-tuned every
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: But what's next? Do you keep it hidden away on your local machine? Unless you've
    built something solely for your own use, the answer is probably no. To make your
    app truly useful, you need to get your app in the hands of your intended audience.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about making the leap from local development to global deployment.
    We'll briefly discuss the various paths you have available for sharing your apps.
    We'll then settle on one of them and walk through putting your app in production
    for the world to experience.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we'll cover key considerations involved in making your app public,
    such as safeguarding confidential information like API keys and managing your
    code's dependencies. As always, we'll take a practical approach through all of
    this, giving you direct hands-on experience with everything we discuss.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Deploying your apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've come a long way since we started out with Streamlit. Over the last three
    chapters, you've created three fully functional—dare I even say, *useful*—applications.
    However, you've been hiding your light under the proverbial bushel; no one else
    has experienced your craft. It's time to change that!
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1 What is deployment?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deploying an app loosely means making it available for other people to use.
    More specifically, it means hosting your application somewhere that your intended
    users can readily access.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from Chapter 4 that a Streamlit app consists of a backend server and
    a frontend that runs on a web browser. While the frontend makes requests to the
    server and shows you the results, it's the server that really runs the show.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the connection between the frontend and the server and thus load an
    app, the user has to navigate to the URL and port where the server is running.
    You've experienced this before; when you start an app with the `streamlit run`
    command, this is what the command actually does at the end—it opens up a web browser
    for you and navigates to a URL like "`https://localhost:8501`".
  prefs: []
  type: TYPE_NORMAL
- en: You could have done this manually, too. In fact, as long as your Streamlit server
    is running, opening the URL in a new browser tab or window creates a new connection
    to the server and a new instance of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying your app, then, involves starting and keeping a Streamlit server running,
    ready to accept new connections. Only, rather than you accessing your own app
    through the `localhost` URL, it'll be other people accessing it through a different
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: There are several approaches by which you can deploy an app. We'll discuss these
    briefly in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.2 Options for deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Depending on your requirements, how much money you''re willing to spend, and
    how much effort you''re willing to put in, there are multiple options you might
    consider for deployment. Let''s consider some of them briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: Running a server over your local network
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The simplest way to deploy your app is something you''ve already done each
    time you''ve run a Streamlit app. Recall that when you do this using the `streamlit
    run` command, a Streamlit server starts, and you can see output similar to the
    following in your terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we've seen many times at this point, the "local URL" here lets *you* access
    your app from the computer it's running on.
  prefs: []
  type: TYPE_NORMAL
- en: But if your machine is connected to a local network or even your home Wifi,
    other devices on the network can access it through the *network URL*.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try it out! If you're on Wifi (or a LAN) and have another device—like
    a smartphone or another computer—that's connected to the same Wifi / LAN, try
    running one of the apps you've created, note the network URL, and open it in the
    second device's web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, figure 5.1 shows what I saw when I opened my todo-list app from
    my phone connected to the same Wifi network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 Using the network URL of your Streamlit app to access it from a different
    device connected to the same network
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Getting this to work depends on how your network is set up. For instance, your
    firewall may block incoming traffic from other devices, thus preventing it from
    reaching your Streamlit server, or there may be other similar rules in place.
    Fixing such issues is outside the scope of this book, but you should be able to
    figure it out with some Googling or help from your network administrator.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of this method of deployment is that making changes and having
    them be visible to your users is as easy as editing your code; there are no extra
    steps!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some obvious limitations, however:'
  prefs: []
  type: TYPE_NORMAL
- en: It only works while the computer where you're running the Streamlit server is
    on and connected to the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It only allows devices connected to your local network to access your app, not
    the general public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Still, it can come in handy in a bunch of places. You could create apps for
    your household, for example, and share the link with your family. You could even
    use this type of deployment for basic non-business-critical apps at your workplace
    depending on how lenient your networking and security policies are.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a dedicated server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you're looking to make your Streamlit app available to a broader audience,
    setting up a dedicated server *may* be a logical step beyond local deployment.
    This involves using a separate physical or virtual machine that runs independently
    of your personal computer. By doing this, you can ensure your app is available
    around the clock and accessible to users outside your local network.
  prefs: []
  type: TYPE_NORMAL
- en: In this setup, you start by selecting a suitable server—this could be a repurposed
    extra computer you own or a new machine set up specifically for this purpose.
    After choosing a server-~-and installing Python and Streamlit on it-~-you would
    launch the Streamlit server for your app, and expose the correct port (e.g., port
    8501) to external traffic. You'll also need to handle network configuration to
    allow access, such as setting up port forwarding on your router if the server
    is behind a firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Operating a dedicated server can be a daunting undertaking that comes with many
    responsibilities, especially related to security. You would be responsible for
    configuring firewalls, maintaining and updating your server's operating system
    and software, etc.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of going this route is that you'll have complete control over
    your deployment, but on the flip side, it requires a lot of technical knowhow
    and probably more importantly, a big portion of your time.
  prefs: []
  type: TYPE_NORMAL
- en: If you simply want to let the general public use the app you've developed, I
    would recommend one of the remaining options that we'll discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to the cloud
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For greater scalability, reliability, and ease of access, you can use a cloud-based
    platform to deploy your app. This approach leverages the infrastructure of public
    cloud service providers—such as Amazon Web Services (AWS), Microsoft Azure, or
    Google Cloud—allowing you to host your app without the need for physical hardware.
    It provides numerous benefits, including automatic scaling to handle varying levels
    of traffic, robust security measures to protect your data, and high availability
    to ensure your app is accessible at all times.
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit of cloud deployment is that your cloud provider manages much
    of the infrastructure-related responsibilities associated with maintaining your
    application. This includes server maintenance and security updates, allowing you
    to focus on the development and improvement of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Many companies have already migrated, or are in the process of migrating, their
    internal applications to the cloud. If you're considering making your app available
    to users within your organization or to a broader audience, cloud deployment can
    be an efficient and effective solution. Collaborating with your cloud administrator
    or IT team will help ensure a smooth setup and integration process.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's important to note that using a cloud provider can be expensive
    as your app gets popular, since costs are usually based on the resources your
    app uses, which increases with the number of users accessing it.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 13 will discuss in detail how to deploy your app to public cloud platforms
    such as AWS and Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit Community Cloud
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: That leaves us with the option we'll be using for most of this book—Streamlit
    Community Cloud, a way to publish your apps to anyone who cares to use them, c*ompletely
    free of charge*.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit Community Cloud is run by Snowflake, the company that owns Streamlit.
    It prioritizes ease-of-use, and as the name suggests, is custom-built to run Streamlit
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Community Cloud does come with resource limitations, such as how much computational
    power, memory, and storage your app can use. If you cross those limits—say, if
    your app blows up in popularity—you may need to look at a different option, such
    as deployment to a paid cloud provider (see Chapter 13).
  prefs: []
  type: TYPE_NORMAL
- en: However, given that we're in the process of learning Streamlit, Community Cloud
    is ideal for our purposes. In the rest of this chapter, we'll go through how to
    deploy an app to it.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Deploying our to-do list app to Streamlit Community Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the previous section, Streamlit Community Cloud serves our deployment
    needs perfectly, since it's free, custom-built for Streamlit, and incredibly easy
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll deploy one of the apps we built previously—our to-do
    list app from Chapter 4—to Community Cloud, making it so that anyone with an internet
    connection can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.1 Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to Python and Streamlit itself, deploying an app to Streamlit Community
    Cloud requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git`, the popular version control tool that we discussed briefly in Chapter
    2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GitHub account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Streamlit Community Cloud account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting your GitHub account to Community Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you've never used `git` before and want to get acquainted with it, head over
    to Appendix B, which touches upon how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and setting up a GitHub account
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may have heard of GitHub, a web-based platform used for version control
    and collaborative software development. It uses `git`, a distributed version control
    system, to help developers track changes in their code, collaborate on projects,
    and manage versions of their software.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: GitHub and git are not to be confused with each other. git is the name of the
    version control system. and Git*Hub* is the most popular platform for hosting
    repositories created using git. You can use git with other hosting platforms,
    such as Bitbucket, though Streamlit Community Cloud does require GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: A link to a GitHub account is a pretty standard fixture on most developers'
    resume these days. Importantly for us, Streamlit Community Cloud expects that
    your app's code will be stored in a GitHub *repository*, which consists of a collection
    of files and directories along with their revision history.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by going to `github.com` and signing up for a new account. The sign-up
    process is pretty similar to what you would expect on other websites—you'll have
    to enter your email and verify it, create a username, and select a strong password.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've created your account, you'll need to enable your command-line to
    authenticate and push code to any repositories you make. There are several ways
    to do this, but we'll use Personal Access Tokens (PATs), which are alternatives
    to passwords meant for accessing GitHub through the command-line or an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, to get to the PAT creation screen, you can follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on your profile picture and then "Settings"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find and click on "Developer settings" in the side panel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click "Personal access tokens" > "Tokens (classic)"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select "Generate new token"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 5.2 shows this path visually (though of course GitHub may change how
    it's configured).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 How to get to the Personal Access Token generation page on GitHub
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the screen that opens up, make sure to select the "repo" scope, which gives
    you full control of repositories.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need to enter a note describing what the token is for (feel free
    to enter something like "Token to push Streamlit code") and an expiration.
  prefs: []
  type: TYPE_NORMAL
- en: Once a PAT expires, you won't be able to use it any more and will need to create
    another one, so choose accordingly. A shorter expiry is more secure-~-as it'll
    be valid for a smaller period if compromised-~-but also means you'll have to change
    it more frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 shows the selections you could make.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 The PAT creation screen on GitHub; make sure to select the "repo"
    scope
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Click "Generate token" to actually create it. GitHub will now show you the token
    you created. Copy it and store it somewhere safe, because you'll never be able
    to see it again!
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the PAT later when we're pushing our code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Streamlit Community Cloud account
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create a Community Cloud account, go to the Streamlit website, `https://streamlit.io/`,
    click "Sign up", and follow the instructions. I recommend siging up with your
    GitHub account.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're done, it should take you to a "dashboard" page.
  prefs: []
  type: TYPE_NORMAL
- en: If you didn't sign up with your GitHub account, you'll see an exclamation point
    next to "Workspaces" on the top left.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the case, you'll need to separately connect your GitHub account to
    Community Cloud. As of the time of writing, you can do this by clicking "Workspaces"
    and then "Connect GitHub account".
  prefs: []
  type: TYPE_NORMAL
- en: If you're already logged in to GitHub, you won't need to do anything else. If
    you aren't, you'll need to enter your GitHub account credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2.2 Deployment steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you''ve got your accounts set up, deploying your app is a three-step
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub repo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing your code to GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telling Community Cloud where to look for it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your app needs to connect to an external service, or if it needs specialized
    libraries, there are a couple more steps that we'll explore later in the chapter,
    but the above steps will work for the existing to-do list app that we built in
    Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: If you've already made `git` a part of your regular workflow as a developer
    (as we recommended in Chapter 2), you may already have created a repo and pushed
    your code into it, and can therefore skip ahead to the section "Telling Community
    Cloud where to find your app.”
  prefs: []
  type: TYPE_NORMAL
- en: If not, read the sections below in order.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub repo
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To start, sign in to your GitHub account. The button to create a new repo should
    be fairly obvious. If you've never created one before in this account, you should
    see a "Create repository" button as shown on the left of figure 5.4\. If you do
    have some repos already, it should instead display a list of your top repos and
    you can create a new one by clicking "New", as shown on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 Buttons to create a new repo on GitHub
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This should lead you to a page that asks you about the details of your new repo
    (see figure 5.5)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image005.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 The repository creation screen on GitHub
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can ignore most settings here—just make sure you give the repo a memorable
    name and choose "Public" for the visibility.
  prefs: []
  type: TYPE_NORMAL
- en: When you're done, click "Create repository.” You'll be taken to a screen with
    some instructions and importantly, the URL of your repo, as seen in figure 5.6.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image006.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 Your repo URL
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Make a note of this URL as you'll need it in the next section. If you need to,
    you can find this URL again later by navigating to your repo.
  prefs: []
  type: TYPE_NORMAL
- en: Your repository is now ready for you to put some code in!
  prefs: []
  type: TYPE_NORMAL
- en: Pushing your code to GitHub
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At this juncture, you have a *remote* GitHub repo, but your Streamlit app code
    is stored *locally*, on your computer. We'll now make this code available in your
    remote repo, a process called *pushing* your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal window and navigate to the directory that contains your to-do
    list app from Chapter 4, which consists of two files: `todo_list.py` and `task.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command to initialize this directory as a *local* Git repository
    (as opposed to the remote one on GitHub):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `git init` command creates an empty Git repo, setting up all the required
    files in a hidden subdirectory called `.git`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, type in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This adds the contents of the current directory to Git's *staging area*, which
    is a temporary holding place for changes you make to your code. You use the staging
    area to prepare the exact snapshot of the code you want to save.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to *commit* your changes, so enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command captures a snapshot of your code's current state, saving it in
    the local repository with a descriptive message about the changes.
  prefs: []
  type: TYPE_NORMAL
- en: The last step here is to actually copy your code to GitHub. For this, we'll
    first need to make your local Git repo aware of your remote repo on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetch the PAT you created in section 5.1.1 as well as the URL to your remote
    repo, and combine them to create a PAT-embedded GitHub URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if your PAT is `ghp_fLbbSwjMlw3gUs7fgRux8Ha3PIlG9w3ZY3zY` (not
    a real one) and your repo is `https://github.com/omnom-code2/streamlit-todo-list-app.git`,
    your PAT-embedded URL will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now add this URL as a *remote* to your local repo by typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'or in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This tells Git to add a remote repository with the alias "origin" to your local
    Git configuration, associating it with the specified PAT-embedded URL. This allows
    you to interact with the remote repository using that alias in future Git commands,
    and automatically uses the PAT for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, run the following command to perform the code push:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Pushes the local branch you're currently in (called "master" by default) to
    the remote repo you designated as "origin,” thus making your code available in
    the "master" branch of the remote repo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the default *upstream branch* (`-u` is shorthand for `-–set-upstream`)
    of your local repo to the "master" branch on the remote repo, so that in the future
    you can push your code with just `git push` without the `-u origin main`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We''re assuming here that the default branch that Git creates in your repo
    is called "master.” Some versions of Git use the name "main" instead. If you get
    an error when you use "master,” try replacing it with "main.” Your command would
    then become: "git push -u origin main". Alternatively, you can determine the name
    of the branch you''re on by typing "git branch" (your current branch will be highlighted),
    and use that.'
  prefs: []
  type: TYPE_NORMAL
- en: If you navigate to the repo you created on GitHub, you should now be able to
    see your code, as displayed in figure 5.7
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image007.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 Your repo in GitHub, after pushing your code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Git can be quite a complex tool to work with. What I just described in this
    section is really only the bare minimum of Git you need to know to deploy your
    code to Streamlit Community Cloud, but ideally, you should be using it as part
    of your regular development workflow, committing your code each time you complete
    a meaningful piece of work. This requires you to be familiar with the various
    Git commands and options. If you'd like to develop a good mental model for working
    with Git, check out the tutorial in Appendix B.
  prefs: []
  type: TYPE_NORMAL
- en: Telling Community Cloud where to find your code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We've set up our Streamlit code on GitHub. All we need now is to tell Streamlit
    Community Cloud where to look for it.
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your Community Cloud account at `streamlit.io` and click the "Create
    an app" button on the top right. If it asks you whether you already have an app,
    select the option that says you do.
  prefs: []
  type: TYPE_NORMAL
- en: This should take you to the "Deploy an app" page shown in figure 5.8.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image008.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 The app deployment screen on Streamlit Community Cloud
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Fill out the details of where you pushed your code, including:'
  prefs: []
  type: TYPE_NORMAL
- en: the GitHub repository you created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the branch you pushed your code to (e.g. `master` from `git push -u origin master`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the path to your app (this would be `todo_list.py` since that's the file you
    use in the `streamlit run` command, and it's located in the root directory of
    your repo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the App URL field, you can choose the address that people can use to access
    your app. Streamlit will suggest a default URL, but you can override it to something
    more meaningful. In figure 5.8, I chose `stmlit-todo-list-app-1.streamlit.app`.
  prefs: []
  type: TYPE_NORMAL
- en: There are some advanced settings available that we'll take a look at later in
    the chapter, but ignore them for now.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! Go ahead and click the "Deploy!" button.
  prefs: []
  type: TYPE_NORMAL
- en: After a minute or so, your app should be ready! Anyone with an internet connection
    can now visit the address you chose (`https://stmlit-todo-list-app-1.streamlit.app/`
    in this case) to run your to-do list app and get their life in order. You difference-maker,
    you!
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Deploying an app that uses an external service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the last section, deploying a simple app to Streamlit Community
    Cloud follows a logical path and is quite straightforward. Our to-do list app
    is "simple" in the sense that it is fairly self-contained.
  prefs: []
  type: TYPE_NORMAL
- en: For one thing, other than Streamlit and Python itself, it has no other libraries
    or software that it depends on. For another, it does not interact with any external
    service or API.
  prefs: []
  type: TYPE_NORMAL
- en: This is not going to be true for most practical apps you create. In the real
    world, you'll build software on top of software built by other people. Therefore,
    it's quite likely that your business logic will need third-party libraries that
    don't come pre-installed with Python.
  prefs: []
  type: TYPE_NORMAL
- en: You will also find that, often, your app needs to reach out to services on the
    internet to do something useful. In fact, it's almost inevitable. At some point,
    your app will need access to an English dictionary to check if a word entered
    by a user is valid, or currency exchange rates to show a price in a different
    currency, or news headlines from around the globe. In these cases, you'll usually
    need to sign up for and connect to some kind of Application Programming Interface
    (API) that provides the specific service you need.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll add some of this complexity to our existing to-do list
    app and see how to deploy the changes correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1 A quote-of-the-day to inspire users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine a user of your to-do list app starting their day. The sky is clear,
    the birds are chirping, and they have a clean slate in front of them. The *diem*
    is theirs to *carpe*. So, humming the spring portion of Vivaldi's *Four Seasons*,
    they begin adding their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Fast forward five minutes, and they've added the eighteenth thing they just
    remembered has to be done *today*. Shoulders sagging, your user is now vaguely
    humming the Darth Vader tune from Star Wars in their head, slowly realizing how
    much of an uphill climb the day is going to be.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we can't have that! What if our app could provide a word of comfort to
    the user in their time of need, a quote to motivate them? Might we not find a
    choice piece of wisdom to share with them—something like *"The secret of getting
    ahead is getting started"*—to inspire them to rise to the occasion?
  prefs: []
  type: TYPE_NORMAL
- en: Of course, some of your more cynical users will just throw their coffee mugs
    at the screen, but hey, you can't please everyone.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, let's think about what adding a quote-of-the-day to our app will
    entail. We could hardcode a bunch of quotes in our code, but that seems wasteful
    and not very scalable. Instead, we'll use a public API to obtain the quotes.
  prefs: []
  type: TYPE_NORMAL
- en: APIs and how to call them
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An API is really just a fancy term for a set of instructions that lets different
    pieces of software talk to each other. You might remember that in Chapter 3, we
    defined an "API" for the backend of our unit conversion app which was a *contract*
    that defined how our frontend was allowed to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: In general parlance, "API" means pretty much the same thing, except that rather
    than the contract between two parts of the same application, we're referring to
    the contract that defines how any piece of software is allowed to interact with
    a particular external service.
  prefs: []
  type: TYPE_NORMAL
- en: An API can be structured however its developer wants and the only perfect way
    to understand how to use it is to read the documentation. That said, there are
    some common *conventional* API patterns you'll encounter quite frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, you can *call* this type of API by sending an HTTP (or
    web) request to a URL that takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The base address is a common address that's part of every request sent to the
    API, whereas the endpoint is specific to the type of request you're making. For
    instance, a weather-related API might have `api.weathersite.com` as the base address,
    and `forecast` and `history` as the endpoints for weather predictions and past
    weather data respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You would normally customize your API request by passing key-value parameters
    either in the URL (in the case of a GET request) or as a request payload (in a
    POST request). You may also need to pass additional information, such as an API
    key, as HTTP headers. See the sidebar to learn more about how HTTP works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our weather example above, we might want to pass a date as a URL parameter
    to the API to get the forecast for that date, so that the URL becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The API would then return a response, often in a format called JSON (JavaScript
    Object Notation) that you can parse in your code to make sense of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the response might be something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Sidebar: How HTTP requests work'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: HTTP, which stands for HyperText Transfer Protocol, is the set of rules that
    define how messages are sent across the web. Think of it as the grammatical structure
    that computers use when they communicate over the web.
  prefs: []
  type: TYPE_NORMAL
- en: To communicate using HTTP (e.g. when a web browser wants to talk to a web server
    to retrieve a web page), an HTTP *client—*like a browser*—*sends properly formed
    HTTP *requests* to a web server. The server then returns an HTTP *response*, which
    may consist of an HTML file, or an image, or just some text, or pretty much anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP requests consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: a request line (for our purposes, let's just think of this as a URL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: some HTTP headers, which are key-value pairs providing additional information
    about how to handle the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an optional body, which contains data that the client wants to send to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several different types of HTTP requests, but by far the most common
    are GET and POST.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loosely speaking, GET requests are "lightweight" requests that don''t have
    a body. All of the information about the request is contained within the URL.
    Any data that needs to be sent to the server is encoded as key-value pairs and
    attached to the end of the URL like this: `?param1=value1&param2=value2...`'
  prefs: []
  type: TYPE_NORMAL
- en: When you enter a query in a search engine, that's usually a GET request. In
    fact, when you type a URL in your browser's address bar and press return, you're
    sending a GET request to that URL.
  prefs: []
  type: TYPE_NORMAL
- en: POST requests *do* have a body that contains additional information. This body
    is often called a *payload*, and may contain things like information entered into
    a web form, or an uploaded file.
  prefs: []
  type: TYPE_NORMAL
- en: The API Ninjas Quotes API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The API we'll be using is from a website called API Ninjas `(https://api-ninjas.com/)`.
    API Ninjas offers free APIs for a variety of services, such as real-time commodity
    prices, exchange rates, URL information lookups, face-detection in images, and
    much more.
  prefs: []
  type: TYPE_NORMAL
- en: They make money off the paid version of their APIs, which you have to use if
    you issue more than 10,000 calls a month. Since we're just learning, we can make
    do with much less than that, so we'll just use the free version. Specifically,
    we're interested in their Quotes API, which—according to their documentation—"provides
    a nearly endless amount of quotes from famous people throughout history."
  prefs: []
  type: TYPE_NORMAL
- en: To access it, you'll need to make an account with them. Head on over to `https://api-ninjas.com/`
    and sign up. As usual, you'll need to provide and verify your email and create
    a password.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're signed in, find your API key (you'll have one key that can access
    all their APIs), which is a set of characters that identifies you when you connect
    to the API. As I write this, there's a "Show API Key" button under "My Account".
    Make a note of the key.
  prefs: []
  type: TYPE_NORMAL
- en: Check the documentation at `https://api-ninjas.com/api/quotes` to get a sense
    of how to connect to the Quotes API.
  prefs: []
  type: TYPE_NORMAL
- en: The base URL here is `api.api-ninjas.com`, a common one shared across all of
    their APIs. The endpoint for the Quotes API is `/v1/quotes`, which "returns one
    (or more) random quotes".
  prefs: []
  type: TYPE_NORMAL
- en: The documentation also mentions that you can pass a category parameter that
    gives you a quote from a specific listed category. There's also a limit parameter
    that lets you specify how many quotes you want, but that's a paid feature that
    we won't use. By default, the API will return one quote which is all we need.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we want a quote from the category "friendship". We would send a GET
    request to the URL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As an experiment, try going to this URL in your browser (which, as the sidebar
    on HTTP requests mentions, sends a GET request). If everything''s working as intended,
    you should get an authentication error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's because we also need to provide the API key we noted earlier. The documentation
    mentions that this needs to be passed as an HTTP header by the name `X-Api-Key`.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll use a Python library called `requests`.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 Using the `requests` library to connect to an API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've seen, the API we'll be using to generate inspirational quotes is a
    web-based one, where calling it requires our code to send and receive messages
    via HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: We *could* do this with vanilla Python, but we'll instead use `requests`, which
    is the Python world's go-to library for HTTP communication. `requests` provides
    a lot of built-in functionality around handling HTTP `requests`, and has a more
    user-friendly set of tools than the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you''ll need to install `requests` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once that's done, verify that it's installed using `pip show requests`, which
    should display the version of `requests` you have, along with some other information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending an HTTP request using the `requests` module is quite easy: there are
    simple `get` and `post` methods we can use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To give this a shot, open up a Python shell (enter `python` or `python3` in
    the command line) and try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we're simply using the `requests.get` method to send the same request we
    sent through the browser earlier. This method returns an instance of the `Response`
    class, which encapsulates the HTTP server's response to our request.
  prefs: []
  type: TYPE_NORMAL
- en: We then access the `text` property of `response`, which gets the body of the
    response as a string. As you can see, the string is exactly what we got before
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned from the docs, we can pass our API key using the `X-Api-Key`
    header. The `requests.get` method accepts an argument called `headers` in the
    form of a regular Python dictionary, so let''s get that set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '#A Replace the "+4VJR…" with the API key you noted down earlier'
  prefs: []
  type: TYPE_NORMAL
- en: Looks like it's working now! When we passed along the API key we obtained from
    API Ninjas in the `X-Api-Key` header, we got back an actual quote from the API!
  prefs: []
  type: TYPE_NORMAL
- en: There's a lot more to the `requests` library than this. We'll encounter the
    module quite a few times in the remainder of this book, but if you'd like to learn
    more, check out the documentation at `https://requests.readthedocs.io/`.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3 Incorporating quotes in our app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have everything we need to add a quote-of-the-day feature to our to-do
    list app. Since this is quite a bit different from the core functionality of managing
    your to-dos, it probably makes sense to create a new file, `quotes.py`, for this.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we need a function, say `generate_quote`, that takes an API key
    and pulls a quote from the Quotes API.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.1 shows what `quotes.py` might look like.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.1 quotes.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We place `API_URL` and `CATEGORY` (set to "inspirational", which is one of the
    categories the API Ninjas documentation tells us we can use) at the top of the
    file as easily configurable constants so that if anyone needs to change them later,
    it's easy to do so without modifying the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the function, you may notice that instead of passing the category directly
    in the URL using the `?category=` notation, we''re doing something different;
    we''re creating a dictionary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'and passing that dictionary in the `params` argument of `requests.get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The other way works just as well, but this is more readable. Besides, if we
    ever need to send a POST request (using `requests.post`) instead, the `params`
    argument works there too, while you can't use the URL method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, rather than using `response.text` as we did in the Python shell earlier,
    we''re using `response.json()`. That''s because, from our earlier experiment in
    the shell, we know that the response from the API is in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: JSON is a format that lets you create arbitrary hierarchies of data using text.
    It's actually pretty easy for Python developers to read a blob of JSON data since
    the way you'd store the data in JSON is almost identical to the way you would
    encode that same data in a Python literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in the above value of `response.text`, you can probably tell that the data
    is encoded as a list (because of the square brackets) that contains one element:
    a dictionary with three keys: "quote", "author" and "category".'
  prefs: []
  type: TYPE_NORMAL
- en: '`response.text`, however, is a string. To be able to access the data easily
    in Python, we need to parse it into a Python object. That''s what the `response.json()`
    method does: it parses the textual body of the response into a Python object,
    assuming the text is JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the result of `response.json()`, we can treat it as a normal Python
    object. In this case, we know the data is a single-element list, so we use `response.json()[0]`
    to obtain the only element of the list, which is our three-key dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next portion checks if the request went through fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Every HTTP response comes with a status code that classifies the result of the
    request. You may have seen these before. A status code of 200 means "OK", the
    code 404 means "Not found" etc.
  prefs: []
  type: TYPE_NORMAL
- en: In the above snippet, the `if` statement verifies that the status code corresponds
    to a successful result, or in this case, that a quote was returned. `requests.codes`
    provides a more readable way to refer to specific HTTP status codes. `requests.codes.ok`
    just means the code 200.
  prefs: []
  type: TYPE_NORMAL
- en: If everything's fine, we construct a string with the quote itself, as well as
    the author, separated by "--". We use `quote_obj['quote']` and `quote_obj['author']`
    to extract these from the `quote_obj` dictionary we parsed the JSON result into.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if anything went wrong with the API call and the status code was *not*
    200, we fail gracefully by returning an evergreen motivational quote from Shia
    LaBeouf, one of the great philosophers of our time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `quotes.py` is complete, using it to create a quote to display in our
    main app is pretty simple. In `todo_list.py`, import the `generate_quotes` function
    at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to display the quote, call `generate_quote` with your API key right above
    where you''re showing the task completion metric, and put the result in an st.info
    box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As before, don't forget to replace the argument to `generate_quote` with your
    actual API key.
  prefs: []
  type: TYPE_NORMAL
- en: If you `streamlit run` your app at this point, you should see your quote-of-the-day
    show up as in figure 5.9.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image009.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 Quote-of-the-day in our to-do list app
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Great! That seems like our API call is working exactly as we intended! We can
    rest assured that if our user feels like giving up in the middle of organizing
    their day, they'll have a daily motivational quote to inspire them to stay strong.
  prefs: []
  type: TYPE_NORMAL
- en: But wait! Recall that Streamlit reruns your *entire* code each time any interaction
    takes place. That includes making an API call through `generate_quote`. Basically,
    each time your user adds a task, or marks something done, or basically does anything
    in the app, an API call is made and a new quote is generated. Forget quote-of-the-day,
    we're dealing with quote-of-the-click here.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you might be forgiven for wanting to chalk that up as "a feature,
    not a bug". But remember that we only have 10,000 free API calls available per
    month. If we keep pulling a quote every time the user clicks on anything, we'll
    burn through even that hefty quota pretty quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let''s make use of our old friend `st.session_state` from Chapter
    4\. Just as we saved our task list so it doesn''t get reset with every run, we''ll
    also save our quote so we only call the API once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '#A Again, replace the "+4VJR…" with the API key you noted down earlier'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now replace our earlier st.info line with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you try the app now, you'll see that the quote doesn't change when you add
    a task or do anything else in the app, only when you refresh the page.
  prefs: []
  type: TYPE_NORMAL
- en: So are we done? Well, not quite...
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.4 Accessing your API key safely with st.secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our app works just fine now, but it has a glaring security flaw. We just embedded
    our API key directly in the code.
  prefs: []
  type: TYPE_NORMAL
- en: If we now commit this code to a public GitHub repository, anyone will be able
    to see it and therefore find our API key! In this instance, with a free API, the
    stakes are pretty low, but imagine if you were paying for the API—either because
    you exhausted your free quota, or because you're using a different API that costs
    money!
  prefs: []
  type: TYPE_NORMAL
- en: Anyone who accesses your GitHub repo might—unwittingly or with malicious intent—set
    themselves loose on your API account, costing you hundreds or maybe even thousands
    of dollars.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It''s worth internalizing this rule right now: never store any secret information,
    whether it''s an API key or a password, or any other kind of credential, in your
    code—especially if the code is going to be publicly accessible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s the alternative then? How do we give our app access to our API key
    if we can''t put it in code? Generally speaking, there are a few ways to do this:
    you could put your key in an environment variable that''s stored securely on the
    server where your app is running. Another option is to use a secrets management
    service like AWS Secrets Manager or HashiCorp Vault which allow you to retrieve
    confidential info securely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Streamlit provides an easy way to keep your secrets safe: `st.secrets`.'
  prefs: []
  type: TYPE_NORMAL
- en: Like `st.session_state`, `st.secrets` is a dictionary-like structure that you
    can use to store secret information as key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: To make a value available to `st.secrets`, you put it in a special file called
    `secrets.toml`. While you're developing locally, Streamlit will pull values from
    the `secrets.toml` file. When you push your code, you take care to *not* push
    the `secrets.toml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you would configure the information directly into Streamlit Community
    Cloud, so that your deployed app can access it in production.
  prefs: []
  type: TYPE_NORMAL
- en: The secrets.toml file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the root folder of your local repository (where you ran `git init` earlier),
    create an empty directory called `.streamlit`, and under it, an empty text file
    called `secrets.toml`.
  prefs: []
  type: TYPE_NORMAL
- en: Next enter your API key in the file as shown in listing 5.2.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.2 secrets.toml
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As before, use your actual API key here.
  prefs: []
  type: TYPE_NORMAL
- en: The `.toml` format may be new to you. TOML stands for Tom's Obvious Minimal
    Language. It's a format for configuration files designed to be concise and easily
    readable by humans, and was originally created by a guy named—believe it or not—Tom.
  prefs: []
  type: TYPE_NORMAL
- en: '`.toml` files mostly consist of key-value pairs and support a range of simple
    and complex data types, including arrays and tables. They can be divided into
    sections denoted by square brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: The file shown in listing 5.2 has a single section, `quotes_api`, with a single
    key-value pair (with the key being `api_key`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to read it in Python (outside of Streamlit, you would usually do
    this using the `toml` module), it would map to the following nested dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In Streamlit, this is more or less what `st.secrets` would also contain.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can therefore now replace the part of `todo_list.py` that calls `generate_quote`
    with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At runtime, Streamlit will read our `secrets.toml` file to populate `st.secrets`
    as shown above, and we can use `st.secrets["quotes_api"]["api_key"]` to refer
    to the API key. Try it out—you'll see that your app is still able to fetch a quote
    from the API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Technically, the .streamlit directory should be located in the directory that
    you run the command "streamlit run <file_path>" from. For instance, if you're
    currently in a directory called "apps", your actual code is located in a folder
    called "todo_list_app", and the command you use to run your app is "streamlit
    run todo_list_app/todo_list.py", then the .streamlit folder should located in
    the "apps" folder, not in the "todo_list_app" folder. When you deploy your code
    to Streamlit Community Cloud, "streamlit run" will effectively be run from your
    repo root, which is why I suggested placing .streamlit there. While developing
    locally, if your local repo root is different from the folder you usually execute
    "streamlit run" from, you'll probably need to "cd" into the repo root to get this
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this, your `todo_list.py` file should be as shown in listing 5.3
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.3 The final state of todo_list.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 5.4 Deploying our changes to Streamlit Community Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally speaking, making changes to an already-deployed Streamlit app is simple.
    All you need to do is to commit your changes and use `git push` to push them to
    your GitHub repo, and Streamlit Community Cloud will automatically pick them up.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, given the most recent changes we''ve made to our app, in our case
    this process will be slightly more complicated. There are three complicating factors:'
  prefs: []
  type: TYPE_NORMAL
- en: We're now using an additional third-party library, requests, and we have to
    make sure the right version is installed in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to make sure we don't ever push `secrets.toml` to GitHub, even by accident
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we're not going to store our API key in the GitHub repo, we need to configure
    it in Community Cloud directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.4.1 Using a `requirements.txt` file to manage Python dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the things that can trip you up when you first start to publish your
    apps to the world is that you now have two *environments* to manage: your development
    environment (often simply called *dev*), which is in your laptop or whatever computer
    you''re using to code your app, and your production environment (called *prod*),
    which is in Streamlit Community Cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: To make sure the app that you've coded in dev works as expected in prod, you
    have to make sure that two two environments are configured in exactly the same
    way, or at least that *any differences between dev and prod are not relevant to
    your app*.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this means that your Python code that runs in prod should be exactly
    the same as what's running on your computer in dev, but that's not enough; your
    Python code may rely on software you didn't write yourself, such as the `requests`
    module in the case of our to-do list app, or indeed, Streamlit itself—this means
    that we also need to make sure that these *dependencies* of your app are the same
    in prod and dev, or at least that they don't differ in any ways that matter to
    your app's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if you use a feature of the requests library that was introduced
    in requests version 2.1.1 but the version of `requests` you have installed in
    prod is version 2.0.5, your app will run into errors in prod. To be sure your
    code won't break, you need to install `requests` version 2.1.1 or higher in prod.
    Technically, to be really sure your code won't break, you need to install exactly
    the version 2.1.1, as there's always a small possibility that the feature you
    used may be deprecated or removed in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Python world, we conventionally use a file called `requirements.txt`
    to prevent these kinds of discrepancies. The premise of `requirements.txt` is
    simple: each line in it represents a Python module and a string that specifies
    a version or a range of versions of that module that is compatible with your code.'
  prefs: []
  type: TYPE_NORMAL
- en: When fed into the `pip install` command (as `pip install -r requirements.txt`),
    `pip` will automatically go through the file and install the right versions of
    every module in it.
  prefs: []
  type: TYPE_NORMAL
- en: Streamlit Community Cloud knows what to do with a `requirements.txt` file, so
    if you add one to your GitHub repo, it will automatically install the libraries
    you need to make your app work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `requirements.txt` file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our app only has two outside dependencies—`streamlit` and `requests` (you can
    determine this by examining the import statements in all of your `.py` files).
    The contents of our `requirements.txt` file can therefore be quite simple as shown
    in listing 5.4
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.4 A simple requirements.txt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While this is a valid `requirements.txt`, it doesn't say anything about what
    versions we want installed.
  prefs: []
  type: TYPE_NORMAL
- en: One safe way to handle this would be to determine the versions of these libraries
    we have installed in dev and specify those exact versions in `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: you could type `pip show streamlit` and `pip show requests` to see (among other
    information) the versions of each library you have.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you could also enter the command `pip freeze > requirements.txt` to automatically
    create the `requirements.txt` file from the modules you have installed in dev—this,
    however, will include *every* module you have installed, regardless of whether
    you're importing them in your code. If you go this way, it might make sense to
    delete all the lines from the file except those that correspond to `streamlit`
    or `requests`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either way, once you've determined the right versions using `pip show` or already
    created the file using `pip freeze`, your `requirements.txt` file should look
    something like listing 5.5.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.5 A strict requirements.txt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We don't *have* to be this strict with the versions. We could instead allow
    any version of these libraries that are the same or higher than the ones we have
    installed. That way, we could allow our app to benefit from any under-the-hood
    improvements these libraries may make in the future, while still being *reasonably*
    sure it won't break. In this case, our file may look like listing 5.6.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.6 A this-version-or-higher requirements.txt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once you've got your file ready, save it to the root of your local Git repo.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You may notice that your app works fine in production even if you *don't* create
    a requirements.txt file. That's because Streamlit Community Cloud pre-installs
    the two libraries we're using here, i.e. streamlit and requests. Obviously the
    streamlit library is required for any app to function. Since the streamlit module
    actually depends on the requests module internally, requests is pre-installed
    too! Still, you'll undoubtedly encounter situations in the future where you need
    libraries other than those two, and you'll need a requirements.txt then. Even
    in the current case, you'll need this file to restrict the exact versions of these
    modules that are installed in prod.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2 Using .gitignore to protect secrets.toml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may be wondering about how using a `secrets.toml` file actually protects
    your API key from prying eyes—the key may not technically be in your Python code
    any more but it's still stored in a file next to your actual code. Well, the point
    is to keep `secrets.toml` around locally but to never commit it to our Git repo.
  prefs: []
  type: TYPE_NORMAL
- en: To make certain that we don't accidentally commit the `secrets.toml` file, we'll
    use a file called `.gitignore`.
  prefs: []
  type: TYPE_NORMAL
- en: '`.gitignore` is a simple text file located in the root of your repository that
    tells Git to ignore certain files and never commit them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the file doesn''t already exist, create an empty text file called `.gitignore`
    in the repo root. Then append the path to your `.streamlit` folder. Since the
    `.streamlit` folder should also be in the repo root, you would simply add the
    following to `.gitignore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you now do a `git add` or `git commit`, your `secrets.toml` file (and indeed,
    any file in the `.streamlit` directory) won't be committed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Git may already be tracking your .streamlit folder from before you added it
    to .gitignore. In this case, to remove it from Git''s index, you may have to enter
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: git rm -r --cached .streamlit/
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add your changes to Git, commit them with a message, and then push them to
    GitHub. You could use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can use the simple `git push` command above since you set the
    upstream of your branch to your remote repo earlier using `git push -u`.
  prefs: []
  type: TYPE_NORMAL
- en: Your changes should now be reflected in your production Streamlit app. Or should
    it? Navigate to your app's public URL now to see what's shown in figure 5.10.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image010.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 Our app throws an error since it's unable to access an API key
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Looks like there's a final bit of configuration we have to do before your app
    works okay.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.3 Configuring secrets in Community Cloud
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've taken pains to keep our API key secret but our app still needs it while
    it's running in prod. To enable this, we need to configure it in Streamlit Community
    Cloud where we've deployed our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this in the *App settings* screen on Community Cloud. You can access
    this screen in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: When you're on your deployed app's public URL, click "Manage app" on the bottom
    right (you can see it in figure 5.11), click the three vertical dots and then
    "Settings"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When logged in to Community Cloud on streamlit.io, click the three vertical
    dots next to your app in the list of apps, and click "Settings" from there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either way, once you have your App settings page open, click "Secrets" on the
    side panel to get to the screen shown in figure 5.11.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image011.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 The secrets configuration screen on Streamlit Community Cloud
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the textbox under "Secrets", simply copy and paste whatever you have in your
    `secrets.toml` file on your dev machine, and click "Save".
  prefs: []
  type: TYPE_NORMAL
- en: With that, you're all done! Go to your app's public URL again. It should now
    be fully functional, as seen in figure 5.12.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/05__image012.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 Your fully-functional app, deployed to production
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: By now, you should be equipped to build and share useful Streamlit apps with
    a public audience. In the next chapter, we'll explore a more advanced app focused
    on working with data.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deployment is the process of hosting and setting up your app so your intended
    users can access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple ways to deploy an app—you could simply run a server over
    your local network, set up a dedicated server, or use a cloud provider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can deploy an unlimited number of apps to Streamlit Community Cloud for
    free, subject to some resource usage limits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to Community Cloud involves creating a GitHub account, pushing your
    local code to a remote GitHub repo, and telling Community Cloud where to find
    your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can connect to external services through the HTTP protocol using a library
    called `requests`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conjunction with a `secrets.toml` file located within a `.streamlit` folder,
    `st.secrets` can be used to keep your credentials safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure to never commit your `secrets.toml` file—prevent accidents by adding
    it to `.gitignore`. Instead, use the App settings page on Streamlit Community
    Cloud to hold in production the information you store in `secrets.toml` locally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a `requirements.txt` file to specify the versions of various Python
    libraries your app depends on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying any changes you make to an already-deployed app on Community Cloud
    is as simple as pushing the changes to your remote GitHub repo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
