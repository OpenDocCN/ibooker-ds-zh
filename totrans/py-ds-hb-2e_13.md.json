["```py\nIn [1]: L = [3, 1, 4, 1, 5, 9, 2, 6]\n        sorted(L)  # returns a sorted copy\nOut[1]: [1, 1, 2, 3, 4, 5, 6, 9]\n```", "```py\nIn [2]: L.sort()  # acts in-place and returns None\n        print(L)\nOut[2]: [1, 1, 2, 3, 4, 5, 6, 9]\n```", "```py\nIn [3]: sorted('python')\nOut[3]: ['h', 'n', 'o', 'p', 't', 'y']\n```", "```py\nIn [4]: import numpy as np\n\n        x = np.array([2, 1, 4, 3, 5])\n        np.sort(x)\nOut[4]: array([1, 2, 3, 4, 5])\n```", "```py\nIn [5]: x.sort()\n        print(x)\nOut[5]: [1 2 3 4 5]\n```", "```py\nIn [6]: x = np.array([2, 1, 4, 3, 5])\n        i = np.argsort(x)\n        print(i)\nOut[6]: [1 0 3 2 4]\n```", "```py\nIn [7]: x[i]\nOut[7]: array([1, 2, 3, 4, 5])\n```", "```py\nIn [8]: rng = np.random.default_rng(seed=42)\n        X = rng.integers(0, 10, (4, 6))\n        print(X)\nOut[8]: [[0 7 6 4 4 8]\n         [0 6 2 0 5 9]\n         [7 7 7 7 5 1]\n         [8 4 5 3 1 9]]\n```", "```py\nIn [9]: # sort each column of X\n        np.sort(X, axis=0)\nOut[9]: array([[0, 4, 2, 0, 1, 1],\n               [0, 6, 5, 3, 4, 8],\n               [7, 7, 6, 4, 5, 9],\n               [8, 7, 7, 7, 5, 9]])\n```", "```py\nIn [10]: # sort each row of X\n         np.sort(X, axis=1)\nOut[10]: array([[0, 4, 4, 6, 7, 8],\n                [0, 0, 2, 5, 6, 9],\n                [1, 5, 7, 7, 7, 7],\n                [1, 3, 4, 5, 8, 9]])\n```", "```py\nIn [11]: x = np.array([7, 2, 3, 1, 6, 5, 4])\n         np.partition(x, 3)\nOut[11]: array([2, 1, 3, 4, 6, 5, 7])\n```", "```py\nIn [12]: np.partition(X, 2, axis=1)\nOut[12]: array([[0, 4, 4, 7, 6, 8],\n                [0, 0, 2, 6, 5, 9],\n                [1, 5, 7, 7, 7, 7],\n                [1, 3, 4, 5, 8, 9]])\n```", "```py\nIn [13]: X = rng.random((10, 2))\n```", "```py\nIn [14]: %matplotlib inline\n         import matplotlib.pyplot as plt\n         plt.style.use('seaborn-whitegrid')\n         plt.scatter(X[:, 0], X[:, 1], s=100);\n```", "```py\nIn [15]: dist_sq = np.sum((X[:, np.newaxis] - X[np.newaxis, :]) ** 2, axis=-1)\n```", "```py\nIn [16]: # for each pair of points, compute differences in their coordinates\n         differences = X[:, np.newaxis] - X[np.newaxis, :]\n         differences.shape\nOut[16]: (10, 10, 2)\n```", "```py\nIn [17]: # square the coordinate differences\n         sq_differences = differences ** 2\n         sq_differences.shape\nOut[17]: (10, 10, 2)\n```", "```py\nIn [18]: # sum the coordinate differences to get the squared distance\n         dist_sq = sq_differences.sum(-1)\n         dist_sq.shape\nOut[18]: (10, 10)\n```", "```py\nIn [19]: dist_sq.diagonal()\nOut[19]: array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])\n```", "```py\nIn [20]: nearest = np.argsort(dist_sq, axis=1)\n         print(nearest)\nOut[20]: [[0 9 3 5 4 8 1 6 2 7]\n          [1 7 2 6 4 8 3 0 9 5]\n          [2 7 1 6 4 3 8 0 9 5]\n          [3 0 4 5 9 6 1 2 8 7]\n          [4 6 3 1 2 7 0 5 9 8]\n          [5 9 3 0 4 6 8 1 2 7]\n          [6 4 2 1 7 3 0 5 9 8]\n          [7 2 1 6 4 3 8 0 9 5]\n          [8 0 1 9 3 4 7 2 6 5]\n          [9 0 5 3 4 8 6 1 2 7]]\n```", "```py\nIn [21]: K = 2\n         nearest_partition = np.argpartition(dist_sq, K + 1, axis=1)\n```", "```py\nIn [22]: plt.scatter(X[:, 0], X[:, 1], s=100)\n\n         # draw lines from each point to its two nearest neighbors\n         K = 2\n\n         for i in range(X.shape[0]):\n             for j in nearest_partition[i, :K+1]:\n                 # plot a line from X[i] to X[j]\n                 # use some zip magic to make it happen:\n                 plt.plot(*zip(X[j], X[i]), color='black')\n```"]