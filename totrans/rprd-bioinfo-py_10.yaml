- en: 'Chapter 9\. Overlap Graphs: Sequence Assembly Using Shared K-mers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章\. 重叠图：使用共享的K-mers进行序列组装
- en: A *graph* is a structure used to represent pairwise relationships between objects.
    As described in [the Rosalind GRPH challenge](https://oreil.ly/kDu52), the goal
    of this exercise is to find pairs of sequences that can be joined using an overlap
    from the end of one sequence to the beginning of another. The practical application
    of this would be to join short DNA reads into longer contiguous sequences (*contigs*)
    or even whole genomes. To begin, I’ll only be concerned about joining two sequences,
    but a second version of the program will use a graph structure that can join any
    number of sequences to approximate a complete assembly. In this implementation,
    the overlapping regions used to join sequences are required to be exact matches.
    Real-world assemblers must allow for variation in the size and composition of
    the overlapping sequences.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*图* 是用于表示对象间两两关系的结构。如[罗莎琳德 GRPH 挑战](https://oreil.ly/kDu52)所述，本练习的目标是找到可以通过从一个序列末端到另一个序列开端的重叠来连接的序列对。这在实践中可以应用于将短的DNA读取序列连接成更长的连续序列（*contigs*）甚至整个基因组。起初，我只关注连接两个序列，但程序的第二个版本将使用可以连接任意数量序列的图结构来近似完成组装。在此实现中，用于连接序列的重叠区域必须是精确匹配的。真实世界的组装器必须允许重叠序列的大小和组成的变化。'
- en: 'You will learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学到：
- en: How to use k-mers to create overlap graphs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用k-mers创建重叠图
- en: How to log runtime messages to a file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将运行时消息记录到文件中
- en: How to use `collections.defaultdict()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`collections.defaultdict()`
- en: How to use set intersection to find common elements between collections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用集合交集来查找集合之间的共同元素
- en: How to use `itertools.product()` to create Cartesian products of lists
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`itertools.product()`来创建列表的笛卡尔积
- en: How to use the `iteration_utilities.starfilter()` function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`iteration_utilities.starfilter()`函数
- en: How to use Graphviz to model and visualize graph structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Graphviz来建模和可视化图结构
- en: Getting Started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: 'The code and tests for this exercise are in the *09_grph* directory. Start
    by copying one of the solutions to the program `grph.py` and requesting the usage:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码和测试位于*09_grph*目录中。首先复制程序`grph.py`的解决方案，并请求用法：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-1)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-1)'
- en: The positional parameter is a required FASTA-formatted file of sequences.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数是一个必需的FASTA格式序列文件。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-2)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-2)'
- en: The `-k` option controls the length of the overlapping strings and defaults
    to `3`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`-k`选项控制重叠字符串的长度，默认为`3`。'
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-3)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-3)'
- en: This is a *flag* or Boolean parameter. Its value will be `True` when the argument
    is present, and `False` otherwise.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*标志*或布尔参数。当参数存在时，其值为`True`，否则为`False`。
- en: 'The sample input shown on the Rosalind page is also the content of the first
    sample input file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Rosalind 页面上显示的示例输入也是第一个示例输入文件的内容：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Rosalind problem always assumes an overlapping window of three bases. I
    see no reason for this parameter to be hardcoded, so my version includes a `k`
    parameter to indicate the size of the overlap window. When `k` is the default
    value of `3`, for instance, three pairs of the sequences can be joined:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 罗莎琳德问题始终假设一个三个碱基的重叠窗口。我认为没有理由将此参数硬编码，因此我的版本包含一个`k`参数，用于指示重叠窗口的大小。例如，默认值为`3`时，可以连接三对序列：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Figure 9-1](#fig_9.1) shows how these sequences overlap by three common bases.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](#fig_9.1)显示了这些序列如何通过三个共同碱基重叠。'
- en: '![mpfb 0901](assets/mpfb_0901.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0901](assets/mpfb_0901.png)'
- en: Figure 9-1\. Three pairs of sequences form overlap graphs when joining on 3-mers
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 当连接 3-mers 时，三对序列形成重叠图
- en: 'As shown in [Figure 9-2](#fig_9.2), only one of these pairs can be joined when
    the overlap window increases to four bases:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 9-2所示，当重叠窗口增加到四个碱基时，只有这些序列对中的一对可以连接。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![mpfb 0902](assets/mpfb_0902.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0902](assets/mpfb_0902.png)'
- en: Figure 9-2\. Only one pair of sequences forms an overlap graph when joining
    on 4-mers
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-2\. 当连接 4-mers 时，只有一对序列形成重叠图
- en: 'Finally, the `--debug` option is a *flag*, which is a Boolean parameter that
    has a `True` value when the argument is present and `False` otherwise. When present,
    this option instructs the program to print runtime logging messages to a file
    called *.log* in the current working directory. This is not a requirement of the
    Rosalind challenge, but I think it’s important for you to know how to log messages.
    To see it in action, run the program with the option:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`--debug` 选项是一个*标志*，当参数存在时具有 `True` 值，否则为 `False`。当存在时，此选项指示程序将运行时日志消息打印到当前工作目录中名为
    *.log* 的文件中。这不是 Rosalind 挑战的要求，但我认为你了解如何记录消息很重要。要看它如何运作，运行带有该选项的程序：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `--debug` flag can be placed before or after the positional argument, and
    `argparse` will correctly interpret its meaning. Other argument parsers require
    that all options and flags come before positional arguments. *Vive la différence.*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`--debug` 标志可以放在位置参数之前或之后，`argparse` 将正确解释其含义。其他参数解析器要求所有选项和标志在位置参数之前。*Vive
    la différence.*'
- en: 'There should now be a *.log* file with the following contents, the meaning
    of which will become more apparent later:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该有一个名为 *.log* 的文件，其内容如下，其含义将在稍后变得更加明显：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you understand how your program should work, start over with a new `grph.py`
    program:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了你的程序应该如何工作，从一个新的 `grph.py` 程序重新开始：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is how I define and validate the arguments:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我定义和验证参数的方法：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-1)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-1)'
- en: 'The `Args` class contains three fields: a `file` which is a filehandle; a `k`
    which should be a positive integer; and `debug`, which is a Boolean value.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Args` 类包含三个字段：一个是文件句柄 `file`；一个是应为正整数的 `k`；还有一个是布尔值 `debug`。'
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-2)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-2)'
- en: Use the `argparse.FileType` to ensure this is a readable text file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `argparse.FileType` 确保这是一个可读的文本文件。
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-3)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-3)'
- en: Define an integer argument that defaults to `3`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个默认为 `3` 的整数参数。
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-4)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-4)'
- en: Define a Boolean flag that will store a `True` value when present.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个布尔标志，当存在时将存储一个 `True` 值。
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-5)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-5)'
- en: Check if the `k` (overlap) value is negative.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `k`（重叠）值是否为负数。
- en: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-6)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-6)'
- en: Use `parser.error()` to kill the program and generate a useful error message.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `parser.error()` 终止程序并生成一个有用的错误消息。
- en: '[![7](assets/7.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-7)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-7)'
- en: Return the validated arguments.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 返回经过验证的参数。
- en: I would like to stress how much is happening in these lines to ensure that the
    arguments to the program are correct. Argument values should be validated *as
    soon as possible* after the program starts. I’ve encountered too many programs
    that, for instance, never validate a file argument and then, deep in the bowels
    of the program, attempt to open a nonexistent file and wind up throwing a cryptic
    exception that no mere mortal could debug. If you want *reproducible* programs,
    the first order of business is documenting and validating all the arguments.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调这些行中发生了多少事情，以确保程序的参数是正确的。参数值应该在程序启动后尽快验证。我遇到过太多的程序，例如从不验证文件参数，然后在程序深处尝试打开一个不存在的文件，结果抛出一个晦涩难解的异常，没有人能够调试。如果你想要*可重现*的程序，第一要务是记录和验证所有的参数。
- en: 'Modify your `main()` to the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你的 `main()` 如下：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run your program with the first test input file and verify that you see this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的程序与第一个测试输入文件，并验证你是否看到了这个：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Try running your program with invalid values for `k` and the file input, then
    run `**pytest**` to verify that your program passes the first four tests. The
    failing test expects three pairs of sequence IDs that can be joined, but the program
    printed the name of the input file. Before I talk about how to create overlap
    graphs, I want to introduce *logging* as this can prove useful for debugging a
    program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试用无效的`k`值和文件输入运行你的程序，然后运行`**pytest**`来验证你的程序是否通过了前四个测试。失败的测试期望有三对可以连接的序列ID，但程序输出了输入文件的名称。在我讲解如何创建重叠图之前，我想先介绍一下*日志记录*，因为这对于调试程序可能会很有用。
- en: Managing Runtime Messages with STDOUT, STDERR, and Logging
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用STDOUT、STDERR和日志管理运行时消息
- en: I’ve shown how to print strings and data structures to the console. You just
    did it by printing the input filename to verify that the program is working. Printing
    such messages while writing and debugging a program might be facetiously called
    *log-driven development*. This is a simple and effective way to debug a program
    going back decades.^([1](ch09.html#idm45963633006072))
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展示了如何将字符串和数据结构打印到控制台。你刚刚通过打印输入文件名来验证程序是否正常工作。在编写和调试程序时打印这样的消息可能会被戏称为*基于日志的开发*。这是几十年来调试程序的一种简单有效的方法。^([1](ch09.html#idm45963633006072))
- en: 'By default, `print()` will emit messages to `STDOUT` (*standard out*), which
    Python represents using `sys.stdout`. I can use the `print()` function’s `file`
    option to change this to `STDERR` (*standard error*) by indicating `sys.stderr`.
    Consider the following Python program:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`print()`会将消息发送到`STDOUT`（*标准输出*），Python使用`sys.stdout`来表示。我可以使用`print()`函数的`file`选项将其更改为`STDERR`（*标准错误*），方法是指定`sys.stderr`。考虑以下Python程序：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-1)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-1)'
- en: The default `file` value is `STDOUT`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`file`值是`STDOUT`。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-2)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-2)'
- en: I can specify standard out using the `file` option.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`file`选项来指定标准输出。
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-3)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-3)'
- en: This will print messages to standard error.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会将消息打印到标准错误。
- en: 'When I run this, it would appear that all output is printed to standard out:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行时，所有输出似乎都打印到标准输出：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `bash` shell, I can separate and capture the two streams, however, using
    file redirection with `>`. Standard out can be captured using the filehandle 1
    and standard error using 2. If you run the following command, you should see no
    output on the console:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bash` shell中，我可以使用文件重定向和`>`来分隔和捕获这两个流。标准输出可以使用文件句柄1捕获，标准错误可以使用2捕获。如果你运行以下命令，你应该在控制台上看不到任何输出：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There should now be two new files, one called *out* with the two lines that
    were printed to standard out:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该有两个新文件，一个名为*out*，其中包含打印到标准输出的两行：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'and another called *err* with the one line printed to standard error:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个称为*err*的文件，其中只有一行打印到标准错误输出：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Just knowing how to print to and capture these two filehandles may prove sufficient
    for your debugging efforts. However, there may be times when you want more levels
    of printing than two, and you may want to control where these messages are written
    from your code rather than by using shell redirection. Enter *logging*, a way
    to control whether, when, how, and where runtime messages are printed. The Python
    `logging` module handles all of this, so start by importing this module:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 仅了解如何打印和捕获这两个文件句柄可能足以满足你的调试需求。然而，有时候你可能需要比两个更多级别的打印，并且你可能希望通过代码控制这些消息被写入的位置，而不是使用shell重定向。这就是*日志记录*的作用，一种控制运行时消息何时、如何、何地打印的方法。Python的`logging`模块处理所有这些，所以首先导入该模块：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For this program, I’ll print debugging messages to a file called *.log* (in
    the current working directory) if the `--debug` flag is present. Modify your `main()`
    to this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个程序，如果存在`--debug`标志，我将调试消息打印到一个名为*.log*的文件中（在当前工作目录中）。将你的`main()`修改为以下内容：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-1)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-1)'
- en: This will *globally* affect all subsequent calls to the `logging` module’s functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将*全局*影响所有后续对`logging`模块函数的调用。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-2)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-2)'
- en: All output will be written to the file *.log* in the current working directory.
    I chose a filename starting with a dot so that it will normally be hidden from
    view.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有输出将写入当前工作目录中的*.log*文件。我选择了以点开头的文件名，因此通常不会显示在视图中。
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-3)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-3)'
- en: The output file will be opened with the `w` (*write*) option, meaning it will
    be *overwritten* on each run. Use the `a` mode to *append*, but be warned that
    the file will grow for every run and will never be truncated or removed except
    by you.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件将使用`w`（*写入*）选项打开，意味着每次运行时都将*覆盖*它。使用`a`模式来*追加*，但要注意每次运行文件都会增长，除非您手动截断或删除它。
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-4)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-4)'
- en: This sets the minimum logging level (see [Table 9-1](#table_9.1)). Messages
    at any level below the set level will be ignored.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了最低的日志记录级别（参见[表 9-1](#table_9.1)）。低于设置级别的消息将被忽略。
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-5)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-5)'
- en: Use the `logging.debug()` function to print a message to the log file when the
    logging level is set to `DEBUG` or higher.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`logging.debug()`函数在日志级别设置为`DEBUG`或更高时将消息打印到日志文件中。
- en: In the previous example, I used the older `printf()` style of formatting for
    the call to `logging.debug()`. The placeholders are noted with symbols like `%s`
    for a string, and the values to substitute are passed as arguments. You can also
    use `str.format()` and f-strings for the log message, but `pylint` may suggest
    you use the `printf()` style.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我使用了旧式的`printf()`格式化风格来调用`logging.debug()`。占位符用符号如`%s`表示字符串，需要替换的值作为参数传递。您也可以使用`str.format()`和f-strings进行日志消息格式化，但`pylint`可能建议您使用`printf()`风格。
- en: A key concept to logging is the notion of logging levels. As shown in [Table 9-1](#table_9.1),
    the *critical* level is the highest, and the *debug* level is the lowest (the
    *notset* level has certain particularities). To learn more, I recommend you read
    **`help(logging)`** in the REPL or [the module’s online documentation](https://oreil.ly/bWgOp).
    For this program, I’ll only use the lowest (debug) setting. When the `--debug`
    flag is present, the logging level is set to `logging.DEBUG` and all messages
    to `logging.debug()` are printed in the log file. When the flag is absent, the
    logging level is set to `logging.CRITICAL` and only messages logged with `logging.critical()`
    will pass through. You might think I should use the `logging.NOTSET` value, but
    note that this is lower than `logging.DEBUG` and so all debug messages would pass
    through.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录的一个关键概念是日志级别的概念。如[表 9-1](#table_9.1)所示，*严重*级别是最高的，*调试*级别是最低的（*未设置*级别具有特定特性）。要了解更多信息，建议您在REPL中阅读**`help(logging)`**或访问[模块的在线文档](https://oreil.ly/bWgOp)。对于此程序，我只会使用最低的（调试）设置。当存在`--debug`标志时，日志级别设置为`logging.DEBUG`，所有通过`logging.debug()`记录的消息都会打印在日志文件中。当标志不存在时，日志级别设置为`logging.CRITICAL`，只有通过`logging.critical()`记录的消息才会通过。您可能认为我应该使用`logging.NOTSET`值，但请注意，这比`logging.DEBUG`低，因此所有调试消息都会通过。
- en: Table 9-1\. The logging levels available in Python’s `logging` module
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1\. Python的`logging`模块中可用的日志级别
- en: '| Level | Numeric value |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 等级 | 数值 |'
- en: '| --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| CRITICAL | 50 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 严重 | 50 |'
- en: '| ERROR | 40 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 错误 | 40 |'
- en: '| WARNING | 30 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 警告 | 30 |'
- en: '| INFO | 20 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 信息 | 20 |'
- en: '| DEBUG | 10 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | 10 |'
- en: '| NOTSET | 0 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 未设置 | 0 |'
- en: 'To see this in action, run your program as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实际操作，请按以下步骤运行您的程序：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It would appear the program did nothing, but there should now be a *.log* file
    with the following contents:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎程序什么都没做，但现在应该有一个*.log*文件，内容如下：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the program again without the `--debug` flag, and note that the *.log* file
    is empty as it was overwritten when opened but no content was ever logged. If
    you were to use the typical print-based debugging technique, then you’d have to
    find and remove (or comment out) all the `print()` statements in your program
    to turn off your debugging. If, instead, you use `logging.debug()`, then you can
    debug your program while logging at the debug level and then deploy your program
    to only log critical messages. Further, you can write the log messages to various
    locations depending on the environment, and all of this happens *programmatically*
    inside your code rather than relying on shell redirection to put log messages
    into the right place.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行程序，但不带`--debug`标志，并注意*.log*文件为空，因为它在打开时被覆盖，但从未记录任何内容。如果您使用典型的基于打印的调试技术，则必须找到并删除（或注释掉）程序中的所有`print()`语句以关闭调试。相反，如果您使用`logging.debug()`，则可以在调试级别记录并部署程序以仅记录关键消息。此外，您可以根据环境将日志消息写入不同的位置，所有这些操作都是*程序化*地在您的代码中完成，而不是依赖于shell重定向将日志消息放入正确的位置。
- en: There are no tests to ensure your program creates log files. This is only to
    show you how to use logging. Note that calls to functions like `logging.critical()`
    and `logging.debug()` are controlled by the *global* scope of the `logging` module.
    I don’t generally like programs to be controlled by global settings, but this
    is one exception I’ll make, mostly because I don’t have a choice. I encourage
    you to liberally sprinkle `logging.debug()` calls throughout your code to see
    the kinds of output you can generate. Consider how you could use logging while
    writing a program on your laptop versus deploying it to a remote computing cluster
    to run unattended.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试来确保您的程序创建日志文件。这只是向您展示如何使用日志记录。请注意，对`logging.critical()`和`logging.debug()`等函数的调用由`logging`模块的*全局*范围控制。我通常不喜欢程序受全局设置控制，但这是我唯一的例外，主要是因为我别无选择。我鼓励您在代码中大量使用`logging.debug()`调用，以查看您可以生成的各种输出。考虑在您在笔记本电脑上编写程序和在远程计算集群上部署它以无人值守运行时如何使用日志记录。
- en: Finding Overlaps
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找重叠部分
- en: 'The next order of business is to read the input FASTA file. I first showed
    how to do this in [Chapter 5](ch05.html#ch05). Again I’ll use the `Bio.SeqIO`
    module for this by adding the following import:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的任务是读取输入的FASTA文件。我首先在[第5章](ch05.html#ch05)展示了如何做到这一点。再次，我将使用`Bio.SeqIO`模块通过添加以下导入来完成：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I can modify `main()` to the following (omitting any logging calls):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将`main()`修改为以下内容（省略任何日志调用）：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And then run this on the first input file to ensure the program works properly:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第一个输入文件上运行以确保程序正常工作：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In each exercise, I try to show how to write a program logically, step-by-step.
    I want you to learn to make very small changes to your program with some end goal
    in mind, then run your program to see the output. You should run the tests often
    to see what needs to be fixed, adding your own tests as you see fit. Also, consider
    making frequent commits of the program when it’s working well so you can revert
    if you end up breaking it. Taking small steps and running your program often are
    key elements to learning to code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个练习中，我尝试逐步逻辑地展示如何编写程序。我希望您学会进行非常小的更改以达到某个最终目标，然后运行您的程序以查看输出。您应该经常运行测试来查看需要修复的问题，并根据需要添加自己的测试。此外，请考虑在程序运行良好时频繁提交程序，以便在破坏程序时可以还原。采取小步骤并经常运行您的程序是学习编程的关键要素。
- en: 'Now think about how you might get the first and last *k* bases from each sequence.
    Could you use the code for extracting k-mers that I first showed in [Chapter 7](ch07.html#ch07)?
    For instance, try to get your program to print this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑如何从每个序列中获取第一个和最后一个*k*个碱基。您可以使用我在[第7章](ch07.html#ch07)中首次展示的提取k-mer的代码吗？例如，尝试让您的程序打印出这个：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Think about which *first* strings match which *end* strings. For instance, sequence
    0498 ends with *AAA*, and sequence 0442 starts with *AAA*. These are sequences
    that can be joined into an overlap graph.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 想想哪些*起始*字符串匹配哪些*结束*字符串。例如，序列 0498 以*AAA*结尾，而序列 0442 以*AAA*开头。这些序列可以连接成重叠图。
- en: 'Change the value of `k` to `4`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将`k`的值更改为`4`：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now you can see that only two sequences, 2391 and 2323, can be joined by their
    overlapping sequence *TTTT*. Vary `k` from `1` to `10` and examine the first and
    last regions. Do you have enough information to write a solution? If not, let’s
    keep thinking about this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，只有两个序列，2391和2323，可以通过它们的重叠序列*TTTT*连接起来。从`1`到`10`变化`k`并检查第一个和最后一个区域。你有足够的信息来编写解决方案吗？如果没有，让我们继续思考这个问题。
- en: Grouping Sequences by the Overlap
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过重叠来分组序列
- en: The `for` loop reads the sequences individually. While reading any one sequence
    to find the starting and ending overlap regions, I necessarily do not have enough
    information to say which other sequences can be joined. I’m going to have to create
    some data structure to hold the overlapping regions for *all* the sequences. Only
    then can I go back and figure out which ones can be joined. This gets at a key
    element of sequence assemblers—most need prodigious amounts of memory to gather
    all the information needed from all the input sequences, of which there may be
    millions to billions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环逐个读取序列。在读取任何一个序列以查找起始和结束重叠区域时，我必须没有足够的信息来说哪些其他序列可以连接起来。我将不得不创建一些数据结构来保存*所有*序列的重叠区域。只有这样我才能回过头来弄清楚哪些序列可以连接起来。这涉及到序列组装器的关键元素——大多数需要大量内存来收集来自所有输入序列的所有所需信息，这可能会有数百万到数十亿。'
- en: 'I chose to use two dictionaries, one for the *start* and one for the *end*
    regions. I decided the keys would be the *k*-length sequences, like *AAA* when
    `k` is `3`, and the values would be a list of the sequence IDs sharing this region.
    I can use string slices with the value `k` to extract these leading and trailing
    sequences:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用两个字典，一个用于*起始*区域，一个用于*结束*区域。我决定键将是*k*长度的序列，例如在`k`为`3`时为*AAA*，而值将是共享此区域的序列ID列表。我可以使用值`k`的字符串切片来提取这些前导和尾随序列：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-1)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-1)'
- en: A slice of the first `k` bases.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 取前`k`个碱基片段。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-2)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-2)'
- en: A slice of the last `k` bases, using negative indexing to start from the end
    of the sequence.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 取最后`k`个碱基片段，使用负索引从序列末尾开始。
- en: 'These are k-mers, which I used in the last chapter. They keep showing up, so
    it makes sense to write a `find_kmers()` function to extract k-mers from a sequence.
    I’ll start by defining the function’s signature:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是k-mer，在上一章中我用过。它们一直出现，因此编写一个`find_kmers()`函数来从序列中提取k-mer是合理的。我将从定义函数的签名开始：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-1)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-1)'
- en: The function will accept a string (the sequence) and an integer value `k` and
    will return a list of strings.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将接受一个字符串（序列）和一个整数值`k`，并返回一个字符串列表。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-2)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-2)'
- en: For now, return the empty list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前返回空列表。
- en: 'Now I write a test to imagine how I’d use this function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我写一个测试来想象如何使用这个函数：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-1)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-1)'
- en: Pass the empty string as the sequence to ensure the function returns the empty
    list.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将空字符串作为序列传递，以确保函数返回空列表。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-2)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-2)'
- en: Check all the values for `k` using a short sequence.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 检查所有使用短序列的`k`值。
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-3)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-3)'
- en: There are no 5-mers for a string of length 4.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个长度为4的字符串没有5-mers。
- en: 'Try writing your version before you read ahead. Here is the function I wrote:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前尝试编写你自己的版本。这是我写的函数：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-1)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-1)'
- en: Find the number `n` of *k*-length substrings in a string `seq`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 找到字符串 `seq` 中 *k* 长度子字符串的数量 `n`。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-2)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-2)'
- en: If `n` is a negative number, return the empty list; otherwise, return the k-mers
    using a list comprehension.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `n` 是负数，返回空列表；否则，使用列表推导返回 k-mer。
- en: 'Now I have a handy way to get the leading and trailing k-mers from a sequence:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了从序列中获取前导和尾随 k-mer 的便利方法：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-1)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-1)'
- en: The first element is the leading k-mer.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个元素是前导 k-mer。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-2)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-2)'
- en: The last element is the trailing k-mer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个元素是尾随 k-mer。
- en: 'The first and last k-mers give me the overlap sequences I need for the keys
    of my dictionary. I want the values of the dictionaries to be a list of the sequence
    IDs that share these k-mers. The `collections.defaultdict()` function I introduced
    in [Chapter 1](ch01.html#ch01) is a good one to use for this because it allows
    me to easily instantiate each dictionary entry with an empty list. I need to import
    it and the `pprint.pformat()` function for logging purposes, so I add the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和最后一个 k-mer 给我所需的键的重叠序列。我希望字典的值是共享这些 k-mer 的序列 ID 列表。我在 [第一章](ch01.html#ch01)
    中介绍的 `collections.defaultdict()` 函数很适合用于此，因为它允许我轻松地用空列表实例化每个字典条目。为了日志记录目的，我需要导入它和
    `pprint.pformat()` 函数，所以我添加如下内容：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is how I can use these ideas:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我如何应用这些想法：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-1)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-1)'
- en: Create dictionaries for the start and end regions that will have lists as the
    default values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建起始和结束区域的字典，其默认值为列表。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-2)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-2)'
- en: Iterate the FASTA records.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代 FASTA 记录。
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-3)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-3)'
- en: Coerce the `Seq` object to a string and find the k-mers. The `:=` syntax assigns
    the return value to `kmers`, then the `if` evaluates if `kmers` is truthy. If
    the function returns no kmers, then the following block will not execute.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 强制 `Seq` 对象转换为字符串并找到 k-mer。`:=` 语法将返回值分配给 `kmers`，然后 `if` 评估 `kmers` 是否为真值。如果函数没有返回
    kmers，则以下块不会执行。
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-4)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-4)'
- en: Use the first k-mer as a key into the `start` dictionary and append this sequence
    ID to the list.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个 k-mer 作为 `start` 字典的键，并将此序列 ID 添加到列表中。
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-5)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-5)'
- en: Do likewise for the `end` dictionary using the last k-mer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用最后一个 k-mer 对 `end` 字典进行操作。
- en: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-6)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-6)'
- en: Use the `pprint.pformat()` function to format the dictionaries for logging.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pprint.pformat()` 函数为日志格式化字典。
- en: I’ve used the `pprint.pprint()` function in earlier chapters to print complex
    data structures in a prettier format than the default `print()` function. I can’t
    use `pprint()` here because it would print to `STDOUT` (or `STDERR`). Instead,
    I need to format the data structure for the `logging.debug()` function to log.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前在较早的章节中使用了 `pprint.pprint()` 函数来打印复杂的数据结构，以比默认的 `print()` 函数更漂亮的格式输出。我不能在这里使用
    `pprint()`，因为它会打印到 `STDOUT`（或 `STDERR`）。相反，我需要为 `logging.debug()` 函数格式化数据结构以进行日志记录。
- en: 'Now run the program again with the first input and the `--debug` flag, then
    inspect the log file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行程序，使用第一个输入和 `--debug` 标志，然后检查日志文件：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-1)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-1)'
- en: A dictionary of the various starting sequences and the IDs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 各种起始序列和其 ID 的字典。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-2)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-2)'
- en: 'Three sequences start with *AAA*: 0498, 2391, and 0442.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 三个序列以 *AAA* 开始：0498、2391 和 0442。
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-3)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-3)'
- en: A dictionary of the various ending sequences and the IDs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 各种结束序列及其 ID 的字典。
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-4)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-4)'
- en: There is just one sequence ending with *AAA*, which is 0498.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 仅有一个以 *AAA* 结尾的序列，即 0498。
- en: 'The correct pairs for this input file and the overlapping 3-mers are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个输入文件和重叠的 3-mers，正确的序对如下：
- en: 'Rosalind_0498, Rosalind_2391: *AAA*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Rosalind_0498, Rosalind_2391: *AAA*'
- en: 'Rosalind_0498, Rosalind_0442: *AAA*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Rosalind_0498, Rosalind_0442: *AAA*'
- en: 'Rosalind_2391, Rosalind_2323: *TTT*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Rosalind_2391, Rosalind_2323: *TTT*'
- en: 'When you combine, for instance, the sequence ending with *AAA* (0498) with
    those starting with this sequence (0498, 2391, 0442), you wind up with the following
    pairs:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你将以 *AAA* 结尾的序列（0498）与以该序列开头的序列（0498、2391、0442）结合时，你会得到以下配对：
- en: Rosalind_0498, Rosalind_0498
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rosalind_0498, Rosalind_0498
- en: Rosalind_0498, Rosalind_2391
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rosalind_0498, Rosalind_2391
- en: Rosalind_0498, Rosalind_0442
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rosalind_0498, Rosalind_0442
- en: Since I can’t join a sequence to itself, the first pair is disqualified. Find
    the next *end* and *start* sequence in common, then iterate all the sequence pairs.
    I’ll leave you to finish this exercise by finding all the start and end keys that
    are in common and then combining all the sequence IDs to print the pairs that
    can be joined. The pairs can be in any order and still pass the tests. I just
    want to wish you good luck. We’re all counting on you.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我无法将一个序列与自身连接，所以第一对被取消资格。找到下一个共同的 *end* 和 *start* 序列，然后迭代所有序列对。我留给你完成这个练习，找出所有共同的起始和结束键，然后组合所有序列
    ID 以打印可以连接的序对。序对可以以任何顺序排列仍然通过测试。我只想祝你好运。我们都在依赖你。
- en: Solutions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: I have two variations to share with you. The first solves the Rosalind problem
    to show how to combine any two sequences. The second extends the graphs to create
    a full assembly of all the sequences.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我有两种变体与你分享。第一种解决了 Rosalind 问题，展示了如何组合任意两个序列。第二种扩展了图形以创建所有序列的完整组装。
- en: 'Solution 1: Using Set Intersections to Find Overlaps'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 1：使用集合交集查找重叠部分
- en: 'In the following solution, I introduce how to use set intersections to find
    the k-mers shared between the start and end dictionaries:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下解决方案中，我介绍如何使用集合交集来找到起始和结束字典之间共享的 k-mer：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-1)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-1)'
- en: Find the keys in common between the `start` and `end` dictionaries.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 `start` 和 `end` 字典之间的公共键。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-2)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-2)'
- en: Iterate through the pairs of the ending and starting sequences that are not
    equal to each other.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代不相等的结束和起始序列对。
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-3)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-3)'
- en: Print the pair of sequences.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 打印序列对。
- en: 'The last three lines took me a few attempts to write, so let me explain how
    I got there. Given these dictionaries:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三行让我尝试了几次才写出来，所以让我解释一下我是如何做到的。鉴于这些字典：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'I started with this idea:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我从这个想法开始：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-1)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-1)'
- en: Iterate over the k-mers (which are the *keys*) of the `end` dictionary.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代 `end` 字典的 k-mer（即 *keys*）。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-2)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-2)'
- en: See if this k-mer is in the `start` dictionary.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这个 k-mer 是否在`start`字典中。
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-3)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-3)'
- en: Iterate through each ending sequence ID for this k-mer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历每个 k-mer 的结束序列 ID。
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-4)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-4)'
- en: Iterate through each starting sequence ID for this k-mer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历每个 k-mer 的起始序列 ID。
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-5)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-5)'
- en: Make sure the sequences are not the same.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 确保序列不相同。
- en: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-6)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-6)'
- en: Print the sequence IDs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 打印序列 ID。
- en: 'While that works just fine, I let this sit for a while and came back to it,
    asking myself exactly what I was trying to do. The first two lines are trying
    to find the keys that are in common between the two dictionaries. Set intersection
    is an easier way to achieve this. If I use the `set()` function on a dictionary,
    it creates a set using the keys of the dictionary:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很有效，但我让它静置一段时间，然后回来，问自己我究竟想要做什么。前两行试图找到两个字典之间共同的键。使用集合交集可以更轻松地实现这一点。如果我在字典上使用`set()`函数，它将使用字典的键创建一个集合：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'I can then call the `set.intersection()` function to find the keys in common:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以调用`set.intersection()`函数来查找共同的键：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding code, the next lines find all the combinations of the ending
    and starting sequence IDs. This is more easily done using the `itertools.product()`
    function, which will create the Cartesian product of any number of lists. For
    example, consider the sequences that overlap on the k-mer *AAA*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，下一行找到所有结束和起始序列 ID 的组合。使用`itertools.product()`函数可以更容易地完成这个任务，它将创建任意数量列表的笛卡尔积。例如，考虑在
    k-mer *AAA* 上重叠的序列：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I want to exclude any pairs where the two values are the same. I could write
    a `filter()` for this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我想排除任何两个值相同的对。我可以为此编写一个`filter()`：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO14-1)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO14-1)'
- en: The `lambda` receives the pair `p` and checks that the zeroth and first elements
    are not equal.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`接收对`p`并检查零th和第一个元素不相等。'
- en: 'This works adequately, but I’m not satisfied with the code. I really hate that
    I can’t unpack the tuple values in the `lambda` to `filter()`. Immediately I started
    thinking about how the `itertools.starmap()` function I used in Chapters [6](ch06.html#ch06)
    and [8](ch08.html#ch08) can do this, so I searched the internet for *Python starfilter*
    and found the function [`iteration_utilities.starfilter()`](https://oreil.ly/c6KKV).
    I installed this module and imported the function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以，但我对这段代码不满意。我真的很讨厌不能在`lambda`中解包元组值。我立即开始思考在第[6](ch06.html#ch06)和第[8](ch08.html#ch08)章中使用的`itertools.starmap()`函数可以做到这一点，所以我搜索了互联网找到了`Python
    starfilter`函数[`iteration_utilities.starfilter()`](https://oreil.ly/c6KKV)。我安装了这个模块并导入了该函数：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is an improvement, but I can make it cleaner by using the `operator.ne()`
    (not equal) function, which will obviate the `lambda`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个改进，但我可以通过使用`operator.ne()`（不相等）函数来使它更清晰，这将消除`lambda`：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, I splat each of the pairs to make `print()` see the individual strings
    rather than the list container:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我展开每个对，使`print()`看到单独的字符串而不是列表容器：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'I could have shortened this even more, but I fear this gets a little too dense:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以进一步缩短这段代码，但我担心这会变得太密集：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the end, there’s a fair amount of code in the `main()` function that, in
    a larger program, I would probably move to a function with a unit test. In this
    case, the integration tests cover all the functionality, so it would be overkill.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main()`函数中有相当多的代码，在一个更大的程序中，我可能会将其移到一个带有单元测试的函数中。在这种情况下，集成测试覆盖了所有功能，所以这样做可能过于复杂。
- en: 'Solution 2: Using a Graph to Find All Paths'
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2：使用图形查找所有路径
- en: This next solution approximates a full assembly of the sequences using a graph
    to link all the overlapping sequences. While not part of the original challenge,
    it is, nonetheless, interesting to contemplate while also proving surprisingly
    simple to implement and even visualize. Since *GRPH* is the challenge name, it
    makes sense to investigate how to represent a graph in Python code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个解决方案通过图形近似地装配所有序列，以链接所有重叠的序列。虽然不是原始挑战的一部分，但思考起来非常有趣，而且实现起来甚至很简单。由于*GRPH*是挑战名称，探索如何在Python代码中表示图形是有意义的。
- en: I can manually align all the sequences as shown in [Figure 9-3](#fig_9.3). This
    reveals a graph structure where sequence Rosalind_0498 can join to either Rosalind_2391
    or Rosalind_0442, and there follows a chain from Rosalind_0498 to Rosalind_2391
    to Rosalind_2323.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以手动对齐所有序列，如[图9-3](#fig_9.3)所示。这揭示了一个图结构，其中序列 Rosalind_0498 可以连接到 Rosalind_2391
    或 Rosalind_0442，然后从 Rosalind_0498 到 Rosalind_2391 到 Rosalind_2323 形成链。
- en: '![mpfb 0903](assets/mpfb_0903.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0903](assets/mpfb_0903.png)'
- en: Figure 9-3\. All the sequences in the first input file can be joined using 3-mers
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-3。第一个输入文件中的所有序列都可以使用3-mer连接。
- en: To encode this, I use the [Graphviz tool](https://graphviz.org) both to represent
    and to visualize a graph structure. Note that you will need to install Graphviz
    on your machine for this to work. For instance, on macOS you can use the Homebrew
    package manager (**`brew install graphviz`**), while on Ubuntu Linux you can use
    **`apt install graphviz`**.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编码这一点，我使用[Graphviz工具](https://graphviz.org)来表示和可视化图形结构。请注意，您需要在计算机上安装Graphviz才能使用此功能。例如，在macOS上，您可以使用Homebrew软件包管理器（**`brew
    install graphviz`**），而在Ubuntu Linux上，您可以使用**`apt install graphviz`**。
- en: 'The output from Graphviz will be a text file in the [Dot language format](https://graphviz.org/doc/info/lang.html),
    which can be turned into a pictorial graph by the Graphviz `dot` tool. The second
    solution in the repository has options to control the output filename and whether
    the image should be opened:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Graphviz 的输出将是一个文本文件，格式为[Dot语言](https://graphviz.org/doc/info/lang.html)，可以通过Graphviz的`dot`工具转换为图形图。仓库中的第二个解决方案具有控制输出文件名和是否打开图像的选项：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-1)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-1)'
- en: The default output filename is *graph.txt*. A *.pdf* file will also be generated
    automatically, which is the visual rendition of the graph.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的输出文件名是*graph.txt*。还会自动生成一个*.pdf*文件，这是图形的可视化呈现。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-2)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-2)'
- en: This option controls whether the PDF should be opened automatically when the
    program finishes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项控制程序完成后是否自动打开PDF。
- en: 'If you run this program on the first test input, you will see the same output
    as before so that it will pass the test suite:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在第一个测试输入上运行此程序，您将看到与之前相同的输出，以便通过测试套件：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There should now also be a new output file called *1.txt* containing a graph
    structure encoded in the Dot language:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该还有一个新的输出文件叫做*1.txt*，其中包含使用Dot语言编码的图结构：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can use the `dot` program to turn this into a visualization. Here is a
    command to save the graph to a PNG file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`dot`程序将其转换为可视化。以下是一个将图形保存为PNG文件的命令：
- en: '[PRE46]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[Figure 9-4](#fig_9.4) shows the resulting visualization of the graph joining
    all the sequences in the first FASTA file, recapitulating the manual alignment
    from [Figure 9-3](#fig_9.3).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-4](#fig_9.4)展示了连接第一个FASTA文件中所有序列的图形的结果可视化，重新概括了从[图9-3](#fig_9.3)的手动对齐。'
- en: '![mpfb 0904](assets/mpfb_0904.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0904](assets/mpfb_0904.png)'
- en: Figure 9-4\. The output from the `dot` program showing an assembly of the sequences
    in the first input file when joined on 3-mers
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-4。`dot`程序的输出，显示了在连接3-mer时第一个输入文件中序列的装配。
- en: If you run the program with the `-v|--view` flag, this image should be shown
    automatically. In graph terminology, each sequence is a *node*, and the relationship
    between two sequences is an *edge*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`-v|--view`标志运行程序，此图像应该会自动显示。在图的术语中，每个序列是一个*节点*，两个序列之间的关系是一条*边*。
- en: 'Graphs may or may not have directionality. [Figure 9-4](#fig_9.4) includes
    arrows implying that there is a relationship that flows from one node to another;
    therefore, this is a *directed graph*. The following code shows how I create and
    visualize this graph. Note that I import `graphiz.Digraph` to create the directed
    graph and that this code omits the logging code that is part of the actual solution:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图可能具有方向性，也可能没有。[图 9-4](#fig_9.4) 包括箭头，表明存在从一个节点到另一个节点的关系；因此，这是一个*有向图*。以下代码显示了我如何创建和可视化此图。请注意，我导入
    `graphiz.Digraph` 来创建有向图，而此代码省略了实际解决方案中的日志记录代码：
- en: '[PRE47]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-1)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-1)'
- en: Create a directed graph.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个有向图。
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-2)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-2)'
- en: Iterate through the shared k-mers.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代共享的 k-mer。
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-3)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-3)'
- en: Find sequence pairs sharing a k-mer, and unpack the two sequence IDs into `s1`
    and `s2`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 查找共享 k-mer 的序列对，并将两个序列 ID 解包为 `s1` 和 `s2`。
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-4)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-4)'
- en: Print the output for the test.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 打印测试的输出。
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-5)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-5)'
- en: Add nodes for each sequence.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个序列添加节点。
- en: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-6)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-6)'
- en: Add an edge connecting the nodes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 添加连接节点的边缘。
- en: '[![7](assets/7.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-7)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-7)'
- en: Close the output filehandle so that the graph can write to the filename.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭输出文件句柄，以便图形可以写入文件名。
- en: '[![8](assets/8.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-8)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-8)'
- en: Write the graph structure to the output filename. Use the `view` option to open
    the image, depending on the `args.view` option.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将图结构写入输出文件名。根据 `args.view` 选项，使用 `view` 选项打开图像。
- en: These few lines of code have an outsized effect on the output of the program.
    For instance, [Figure 9-5](#fig_9.5) shows that this program can essentially create
    a full assembly of the 100 sequences in the second input file.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码对程序的输出有很大影响。例如，[图 9-5](#fig_9.5) 显示，该程序基本上可以创建第二个输入文件中 100 个序列的完整组装。
- en: '![mpfb 0905](assets/mpfb_0905.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0905](assets/mpfb_0905.png)'
- en: Figure 9-5\. The graph of the second test input file
  id: totrans-280
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-5\. 第二个测试输入文件的图形
- en: This image (though downsized to fit on the page) speaks volumes about the complexity
    and completeness of the data; for instance, the sequence pair in the upper-right
    corner—Rosalind_1144 and Rosalind_2208—cannot be joined to any other sequences.
    I would encourage you to try increasing `k` to `4` and inspecting the resulting
    graph to see a profoundly different result.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图像（虽然已缩小以适合页面）充分展示了数据的复杂性和完整性；例如，右上角的序列对——Rosalind_1144 和 Rosalind_2208——无法与任何其他序列连接。我鼓励您尝试将
    `k` 增加到 `4` 并检查生成的图形，看看会有非常不同的结果。
- en: Graphs are truly powerful data structures. As noted in the introduction to this
    chapter, graphs encode pairwise relationships. It’s amazing to see the assembly
    of the 100 sequences in [Figure 9-5](#fig_9.5) emerge with so few lines of code.
    While it’s possible to abuse Python lists and dictionaries to represent graphs,
    the Graphviz tool makes this much simpler.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图是真正强大的数据结构。正如本章介绍中指出的，图编码了成对关系。通过如此少量的代码看到 [图 9-5](#fig_9.5) 中 100 个序列的组装是令人惊讶的。虽然可能滥用
    Python 列表和字典来表示图，但 Graphviz 工具使这一切变得更简单。
- en: I used a directed graph for this exercise, but that wasn’t necessarily required.
    This could have been an undirected graph, too, but I like the arrows. I would
    note that you might encounter the term *directed acyclic graph* (DAG) to indicate
    a directed graph that has no cycles, which is when a node joins back to itself.
    Cycles might point to an incorrect assembly in the case of a linear genome but
    might be required for a circular genome, as in bacteria. If you find these ideas
    interesting, you should investigate De Bruijn graphs, which are often built from
    overlapping k-mers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个练习中使用了有向图，但这不一定是必需的。这也可以是无向图，但我喜欢箭头。我要注意的是，你可能会遇到术语 *有向无环图* (DAG)，表示没有循环的有向图，当一个节点指向自身时则形成循环。在线性基因组的情况下，循环可能指向不正确的组装，但在细菌的环形基因组中可能是必需的。如果你对这些想法感兴趣，应该调查一下
    De Bruijn 图，它们通常由重叠的 k-mer 构建。
- en: Going Further
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探索
- en: Add a Hamming distance option that will allow the overlapping sequence to have
    the indicated edit distance. That is, a distance of 1 will allow for the overlap
    of sequences with a single base difference.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个汉明距离选项，允许重叠序列具有指定的编辑距离。也就是说，距离为 1 允许具有单个碱基差异的序列重叠。
- en: Review
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Key points from this chapter:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要点：
- en: To find overlapping regions, I used k-mers to find the first and last *k* bases
    of each sequence.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找到重叠区域，我使用了 k-mer 来找到每个序列的前 *k* 个和最后 *k* 个碱基。
- en: The `logging` module makes it easy to turn on and off the logging of runtime
    messages to a file.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logging` 模块使得可以轻松地控制运行时消息的记录与关闭。'
- en: I used `defaultdict(list)` to create a dictionary that would auto-vivify any
    key not present with a default value of the empty list.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我使用 `defaultdict(list)` 创建了一个字典，当键不存在时会自动创建一个空列表作为默认值。
- en: Set intersection can find common elements between collections, such as the keys
    shared between two dictionaries.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合交集可以找到两个字典之间共享的键等公共元素。
- en: The `itertools.product()` function found all the possible pairs of sequences.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itertools.product()` 函数找到了所有可能的序列对。'
- en: The `iteration_utilities.starfilter()` function will splat the argument to the
    `lambda` for `filter()`, just as the `itertools.starmap()` function does for `map()`.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iteration_utilities.starfilter()` 函数将会解构 `filter()` 的参数，就像 `itertools.starmap()`
    函数对 `map()` 一样。'
- en: The Graphviz tool can efficiently represent and visualize complex graph structures.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graphviz 工具能高效地表示和可视化复杂的图结构。
- en: Graphs can be textually represented using the Dot language, and the `dot` program
    can generate visualizations of graphs in various formats.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图可以用 Dot 语言进行文本表示，而 `dot` 程序可以生成各种格式的图形化显示。
- en: Overlap graphs can be used to create a complete assembly of two or more sequences.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重叠图可用于创建两个或多个序列的完整组装。
- en: ^([1](ch09.html#idm45963633006072-marker)) Imagine debugging a program without
    even a console. In the 1950s, Claude Shannon was visiting Alan Turing’s lab in
    England. During their conversation, a horn began sounding at regular intervals.
    Turing said this indicated his code was stuck in a loop. Without a console, this
    was how he monitored the progress of his programs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#idm45963633006072-marker)) 想象一下在没有控制台的情况下调试程序。在1950年代，克劳德·香农访问了艾伦·图灵在英国实验室的实验室。在他们的对话期间，一只喇叭开始定期发声。图灵说这表明他的代码陷入了循环。在没有控制台的情况下，这是他监视程序进展的方式。
