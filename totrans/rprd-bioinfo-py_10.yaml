- en: 'Chapter 9\. Overlap Graphs: Sequence Assembly Using Shared K-mers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *graph* is a structure used to represent pairwise relationships between objects.
    As described in [the Rosalind GRPH challenge](https://oreil.ly/kDu52), the goal
    of this exercise is to find pairs of sequences that can be joined using an overlap
    from the end of one sequence to the beginning of another. The practical application
    of this would be to join short DNA reads into longer contiguous sequences (*contigs*)
    or even whole genomes. To begin, I’ll only be concerned about joining two sequences,
    but a second version of the program will use a graph structure that can join any
    number of sequences to approximate a complete assembly. In this implementation,
    the overlapping regions used to join sequences are required to be exact matches.
    Real-world assemblers must allow for variation in the size and composition of
    the overlapping sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use k-mers to create overlap graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to log runtime messages to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `collections.defaultdict()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use set intersection to find common elements between collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `itertools.product()` to create Cartesian products of lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `iteration_utilities.starfilter()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Graphviz to model and visualize graph structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code and tests for this exercise are in the *09_grph* directory. Start
    by copying one of the solutions to the program `grph.py` and requesting the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The positional parameter is a required FASTA-formatted file of sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `-k` option controls the length of the overlapping strings and defaults
    to `3`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a *flag* or Boolean parameter. Its value will be `True` when the argument
    is present, and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample input shown on the Rosalind page is also the content of the first
    sample input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Rosalind problem always assumes an overlapping window of three bases. I
    see no reason for this parameter to be hardcoded, so my version includes a `k`
    parameter to indicate the size of the overlap window. When `k` is the default
    value of `3`, for instance, three pairs of the sequences can be joined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 9-1](#fig_9.1) shows how these sequences overlap by three common bases.'
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0901](assets/mpfb_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Three pairs of sequences form overlap graphs when joining on 3-mers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As shown in [Figure 9-2](#fig_9.2), only one of these pairs can be joined when
    the overlap window increases to four bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 0902](assets/mpfb_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. Only one pair of sequences forms an overlap graph when joining
    on 4-mers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, the `--debug` option is a *flag*, which is a Boolean parameter that
    has a `True` value when the argument is present and `False` otherwise. When present,
    this option instructs the program to print runtime logging messages to a file
    called *.log* in the current working directory. This is not a requirement of the
    Rosalind challenge, but I think it’s important for you to know how to log messages.
    To see it in action, run the program with the option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `--debug` flag can be placed before or after the positional argument, and
    `argparse` will correctly interpret its meaning. Other argument parsers require
    that all options and flags come before positional arguments. *Vive la différence.*
  prefs: []
  type: TYPE_NORMAL
- en: 'There should now be a *.log* file with the following contents, the meaning
    of which will become more apparent later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you understand how your program should work, start over with a new `grph.py`
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I define and validate the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Args` class contains three fields: a `file` which is a filehandle; a `k`
    which should be a positive integer; and `debug`, which is a Boolean value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `argparse.FileType` to ensure this is a readable text file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Define an integer argument that defaults to `3`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a Boolean flag that will store a `True` value when present.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the `k` (overlap) value is negative.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `parser.error()` to kill the program and generate a useful error message.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the validated arguments.
  prefs: []
  type: TYPE_NORMAL
- en: I would like to stress how much is happening in these lines to ensure that the
    arguments to the program are correct. Argument values should be validated *as
    soon as possible* after the program starts. I’ve encountered too many programs
    that, for instance, never validate a file argument and then, deep in the bowels
    of the program, attempt to open a nonexistent file and wind up throwing a cryptic
    exception that no mere mortal could debug. If you want *reproducible* programs,
    the first order of business is documenting and validating all the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your `main()` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your program with the first test input file and verify that you see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Try running your program with invalid values for `k` and the file input, then
    run `**pytest**` to verify that your program passes the first four tests. The
    failing test expects three pairs of sequence IDs that can be joined, but the program
    printed the name of the input file. Before I talk about how to create overlap
    graphs, I want to introduce *logging* as this can prove useful for debugging a
    program.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Runtime Messages with STDOUT, STDERR, and Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve shown how to print strings and data structures to the console. You just
    did it by printing the input filename to verify that the program is working. Printing
    such messages while writing and debugging a program might be facetiously called
    *log-driven development*. This is a simple and effective way to debug a program
    going back decades.^([1](ch09.html#idm45963633006072))
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `print()` will emit messages to `STDOUT` (*standard out*), which
    Python represents using `sys.stdout`. I can use the `print()` function’s `file`
    option to change this to `STDERR` (*standard error*) by indicating `sys.stderr`.
    Consider the following Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The default `file` value is `STDOUT`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: I can specify standard out using the `file` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This will print messages to standard error.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I run this, it would appear that all output is printed to standard out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `bash` shell, I can separate and capture the two streams, however, using
    file redirection with `>`. Standard out can be captured using the filehandle 1
    and standard error using 2. If you run the following command, you should see no
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There should now be two new files, one called *out* with the two lines that
    were printed to standard out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'and another called *err* with the one line printed to standard error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Just knowing how to print to and capture these two filehandles may prove sufficient
    for your debugging efforts. However, there may be times when you want more levels
    of printing than two, and you may want to control where these messages are written
    from your code rather than by using shell redirection. Enter *logging*, a way
    to control whether, when, how, and where runtime messages are printed. The Python
    `logging` module handles all of this, so start by importing this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For this program, I’ll print debugging messages to a file called *.log* (in
    the current working directory) if the `--debug` flag is present. Modify your `main()`
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This will *globally* affect all subsequent calls to the `logging` module’s functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: All output will be written to the file *.log* in the current working directory.
    I chose a filename starting with a dot so that it will normally be hidden from
    view.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The output file will be opened with the `w` (*write*) option, meaning it will
    be *overwritten* on each run. Use the `a` mode to *append*, but be warned that
    the file will grow for every run and will never be truncated or removed except
    by you.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This sets the minimum logging level (see [Table 9-1](#table_9.1)). Messages
    at any level below the set level will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `logging.debug()` function to print a message to the log file when the
    logging level is set to `DEBUG` or higher.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, I used the older `printf()` style of formatting for
    the call to `logging.debug()`. The placeholders are noted with symbols like `%s`
    for a string, and the values to substitute are passed as arguments. You can also
    use `str.format()` and f-strings for the log message, but `pylint` may suggest
    you use the `printf()` style.
  prefs: []
  type: TYPE_NORMAL
- en: A key concept to logging is the notion of logging levels. As shown in [Table 9-1](#table_9.1),
    the *critical* level is the highest, and the *debug* level is the lowest (the
    *notset* level has certain particularities). To learn more, I recommend you read
    **`help(logging)`** in the REPL or [the module’s online documentation](https://oreil.ly/bWgOp).
    For this program, I’ll only use the lowest (debug) setting. When the `--debug`
    flag is present, the logging level is set to `logging.DEBUG` and all messages
    to `logging.debug()` are printed in the log file. When the flag is absent, the
    logging level is set to `logging.CRITICAL` and only messages logged with `logging.critical()`
    will pass through. You might think I should use the `logging.NOTSET` value, but
    note that this is lower than `logging.DEBUG` and so all debug messages would pass
    through.
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. The logging levels available in Python’s `logging` module
  prefs: []
  type: TYPE_NORMAL
- en: '| Level | Numeric value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| CRITICAL | 50 |'
  prefs: []
  type: TYPE_TB
- en: '| ERROR | 40 |'
  prefs: []
  type: TYPE_TB
- en: '| WARNING | 30 |'
  prefs: []
  type: TYPE_TB
- en: '| INFO | 20 |'
  prefs: []
  type: TYPE_TB
- en: '| DEBUG | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| NOTSET | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'To see this in action, run your program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It would appear the program did nothing, but there should now be a *.log* file
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Run the program again without the `--debug` flag, and note that the *.log* file
    is empty as it was overwritten when opened but no content was ever logged. If
    you were to use the typical print-based debugging technique, then you’d have to
    find and remove (or comment out) all the `print()` statements in your program
    to turn off your debugging. If, instead, you use `logging.debug()`, then you can
    debug your program while logging at the debug level and then deploy your program
    to only log critical messages. Further, you can write the log messages to various
    locations depending on the environment, and all of this happens *programmatically*
    inside your code rather than relying on shell redirection to put log messages
    into the right place.
  prefs: []
  type: TYPE_NORMAL
- en: There are no tests to ensure your program creates log files. This is only to
    show you how to use logging. Note that calls to functions like `logging.critical()`
    and `logging.debug()` are controlled by the *global* scope of the `logging` module.
    I don’t generally like programs to be controlled by global settings, but this
    is one exception I’ll make, mostly because I don’t have a choice. I encourage
    you to liberally sprinkle `logging.debug()` calls throughout your code to see
    the kinds of output you can generate. Consider how you could use logging while
    writing a program on your laptop versus deploying it to a remote computing cluster
    to run unattended.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Overlaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next order of business is to read the input FASTA file. I first showed
    how to do this in [Chapter 5](ch05.html#ch05). Again I’ll use the `Bio.SeqIO`
    module for this by adding the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I can modify `main()` to the following (omitting any logging calls):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And then run this on the first input file to ensure the program works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In each exercise, I try to show how to write a program logically, step-by-step.
    I want you to learn to make very small changes to your program with some end goal
    in mind, then run your program to see the output. You should run the tests often
    to see what needs to be fixed, adding your own tests as you see fit. Also, consider
    making frequent commits of the program when it’s working well so you can revert
    if you end up breaking it. Taking small steps and running your program often are
    key elements to learning to code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now think about how you might get the first and last *k* bases from each sequence.
    Could you use the code for extracting k-mers that I first showed in [Chapter 7](ch07.html#ch07)?
    For instance, try to get your program to print this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Think about which *first* strings match which *end* strings. For instance, sequence
    0498 ends with *AAA*, and sequence 0442 starts with *AAA*. These are sequences
    that can be joined into an overlap graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the value of `k` to `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now you can see that only two sequences, 2391 and 2323, can be joined by their
    overlapping sequence *TTTT*. Vary `k` from `1` to `10` and examine the first and
    last regions. Do you have enough information to write a solution? If not, let’s
    keep thinking about this.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping Sequences by the Overlap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `for` loop reads the sequences individually. While reading any one sequence
    to find the starting and ending overlap regions, I necessarily do not have enough
    information to say which other sequences can be joined. I’m going to have to create
    some data structure to hold the overlapping regions for *all* the sequences. Only
    then can I go back and figure out which ones can be joined. This gets at a key
    element of sequence assemblers—most need prodigious amounts of memory to gather
    all the information needed from all the input sequences, of which there may be
    millions to billions.
  prefs: []
  type: TYPE_NORMAL
- en: 'I chose to use two dictionaries, one for the *start* and one for the *end*
    regions. I decided the keys would be the *k*-length sequences, like *AAA* when
    `k` is `3`, and the values would be a list of the sequence IDs sharing this region.
    I can use string slices with the value `k` to extract these leading and trailing
    sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A slice of the first `k` bases.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A slice of the last `k` bases, using negative indexing to start from the end
    of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are k-mers, which I used in the last chapter. They keep showing up, so
    it makes sense to write a `find_kmers()` function to extract k-mers from a sequence.
    I’ll start by defining the function’s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function will accept a string (the sequence) and an integer value `k` and
    will return a list of strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: For now, return the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I write a test to imagine how I’d use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Pass the empty string as the sequence to ensure the function returns the empty
    list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Check all the values for `k` using a short sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: There are no 5-mers for a string of length 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try writing your version before you read ahead. Here is the function I wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the number `n` of *k*-length substrings in a string `seq`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: If `n` is a negative number, return the empty list; otherwise, return the k-mers
    using a list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I have a handy way to get the leading and trailing k-mers from a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first element is the leading k-mer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The last element is the trailing k-mer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and last k-mers give me the overlap sequences I need for the keys
    of my dictionary. I want the values of the dictionaries to be a list of the sequence
    IDs that share these k-mers. The `collections.defaultdict()` function I introduced
    in [Chapter 1](ch01.html#ch01) is a good one to use for this because it allows
    me to easily instantiate each dictionary entry with an empty list. I need to import
    it and the `pprint.pformat()` function for logging purposes, so I add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I can use these ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create dictionaries for the start and end regions that will have lists as the
    default values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate the FASTA records.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Coerce the `Seq` object to a string and find the k-mers. The `:=` syntax assigns
    the return value to `kmers`, then the `if` evaluates if `kmers` is truthy. If
    the function returns no kmers, then the following block will not execute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the first k-mer as a key into the `start` dictionary and append this sequence
    ID to the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Do likewise for the `end` dictionary using the last k-mer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO10-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `pprint.pformat()` function to format the dictionaries for logging.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve used the `pprint.pprint()` function in earlier chapters to print complex
    data structures in a prettier format than the default `print()` function. I can’t
    use `pprint()` here because it would print to `STDOUT` (or `STDERR`). Instead,
    I need to format the data structure for the `logging.debug()` function to log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the program again with the first input and the `--debug` flag, then
    inspect the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary of the various starting sequences and the IDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three sequences start with *AAA*: 0498, 2391, and 0442.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary of the various ending sequences and the IDs.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: There is just one sequence ending with *AAA*, which is 0498.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct pairs for this input file and the overlapping 3-mers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rosalind_0498, Rosalind_2391: *AAA*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rosalind_0498, Rosalind_0442: *AAA*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rosalind_2391, Rosalind_2323: *TTT*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you combine, for instance, the sequence ending with *AAA* (0498) with
    those starting with this sequence (0498, 2391, 0442), you wind up with the following
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: Rosalind_0498, Rosalind_0498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rosalind_0498, Rosalind_2391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rosalind_0498, Rosalind_0442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since I can’t join a sequence to itself, the first pair is disqualified. Find
    the next *end* and *start* sequence in common, then iterate all the sequence pairs.
    I’ll leave you to finish this exercise by finding all the start and end keys that
    are in common and then combining all the sequence IDs to print the pairs that
    can be joined. The pairs can be in any order and still pass the tests. I just
    want to wish you good luck. We’re all counting on you.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have two variations to share with you. The first solves the Rosalind problem
    to show how to combine any two sequences. The second extends the graphs to create
    a full assembly of all the sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using Set Intersections to Find Overlaps'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following solution, I introduce how to use set intersections to find
    the k-mers shared between the start and end dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Find the keys in common between the `start` and `end` dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the pairs of the ending and starting sequences that are not
    equal to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the pair of sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last three lines took me a few attempts to write, so let me explain how
    I got there. Given these dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'I started with this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over the k-mers (which are the *keys*) of the `end` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: See if this k-mer is in the `start` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each ending sequence ID for this k-mer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each starting sequence ID for this k-mer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the sequences are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO13-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the sequence IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'While that works just fine, I let this sit for a while and came back to it,
    asking myself exactly what I was trying to do. The first two lines are trying
    to find the keys that are in common between the two dictionaries. Set intersection
    is an easier way to achieve this. If I use the `set()` function on a dictionary,
    it creates a set using the keys of the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'I can then call the `set.intersection()` function to find the keys in common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the next lines find all the combinations of the ending
    and starting sequence IDs. This is more easily done using the `itertools.product()`
    function, which will create the Cartesian product of any number of lists. For
    example, consider the sequences that overlap on the k-mer *AAA*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'I want to exclude any pairs where the two values are the same. I could write
    a `filter()` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `lambda` receives the pair `p` and checks that the zeroth and first elements
    are not equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works adequately, but I’m not satisfied with the code. I really hate that
    I can’t unpack the tuple values in the `lambda` to `filter()`. Immediately I started
    thinking about how the `itertools.starmap()` function I used in Chapters [6](ch06.html#ch06)
    and [8](ch08.html#ch08) can do this, so I searched the internet for *Python starfilter*
    and found the function [`iteration_utilities.starfilter()`](https://oreil.ly/c6KKV).
    I installed this module and imported the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an improvement, but I can make it cleaner by using the `operator.ne()`
    (not equal) function, which will obviate the `lambda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I splat each of the pairs to make `print()` see the individual strings
    rather than the list container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'I could have shortened this even more, but I fear this gets a little too dense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the end, there’s a fair amount of code in the `main()` function that, in
    a larger program, I would probably move to a function with a unit test. In this
    case, the integration tests cover all the functionality, so it would be overkill.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Using a Graph to Find All Paths'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This next solution approximates a full assembly of the sequences using a graph
    to link all the overlapping sequences. While not part of the original challenge,
    it is, nonetheless, interesting to contemplate while also proving surprisingly
    simple to implement and even visualize. Since *GRPH* is the challenge name, it
    makes sense to investigate how to represent a graph in Python code.
  prefs: []
  type: TYPE_NORMAL
- en: I can manually align all the sequences as shown in [Figure 9-3](#fig_9.3). This
    reveals a graph structure where sequence Rosalind_0498 can join to either Rosalind_2391
    or Rosalind_0442, and there follows a chain from Rosalind_0498 to Rosalind_2391
    to Rosalind_2323.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0903](assets/mpfb_0903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3\. All the sequences in the first input file can be joined using 3-mers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To encode this, I use the [Graphviz tool](https://graphviz.org) both to represent
    and to visualize a graph structure. Note that you will need to install Graphviz
    on your machine for this to work. For instance, on macOS you can use the Homebrew
    package manager (**`brew install graphviz`**), while on Ubuntu Linux you can use
    **`apt install graphviz`**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from Graphviz will be a text file in the [Dot language format](https://graphviz.org/doc/info/lang.html),
    which can be turned into a pictorial graph by the Graphviz `dot` tool. The second
    solution in the repository has options to control the output filename and whether
    the image should be opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The default output filename is *graph.txt*. A *.pdf* file will also be generated
    automatically, which is the visual rendition of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This option controls whether the PDF should be opened automatically when the
    program finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this program on the first test input, you will see the same output
    as before so that it will pass the test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'There should now also be a new output file called *1.txt* containing a graph
    structure encoded in the Dot language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `dot` program to turn this into a visualization. Here is a
    command to save the graph to a PNG file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 9-4](#fig_9.4) shows the resulting visualization of the graph joining
    all the sequences in the first FASTA file, recapitulating the manual alignment
    from [Figure 9-3](#fig_9.3).'
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0904](assets/mpfb_0904.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4\. The output from the `dot` program showing an assembly of the sequences
    in the first input file when joined on 3-mers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you run the program with the `-v|--view` flag, this image should be shown
    automatically. In graph terminology, each sequence is a *node*, and the relationship
    between two sequences is an *edge*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphs may or may not have directionality. [Figure 9-4](#fig_9.4) includes
    arrows implying that there is a relationship that flows from one node to another;
    therefore, this is a *directed graph*. The following code shows how I create and
    visualize this graph. Note that I import `graphiz.Digraph` to create the directed
    graph and that this code omits the logging code that is part of the actual solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directed graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the shared k-mers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Find sequence pairs sharing a k-mer, and unpack the two sequence IDs into `s1`
    and `s2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the output for the test.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Add nodes for each sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Add an edge connecting the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Close the output filehandle so that the graph can write to the filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_overlap_graphs__sequence_assembly__span_class__keep_together__using_shared_k_mers__span__CO16-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Write the graph structure to the output filename. Use the `view` option to open
    the image, depending on the `args.view` option.
  prefs: []
  type: TYPE_NORMAL
- en: These few lines of code have an outsized effect on the output of the program.
    For instance, [Figure 9-5](#fig_9.5) shows that this program can essentially create
    a full assembly of the 100 sequences in the second input file.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0905](assets/mpfb_0905.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5\. The graph of the second test input file
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This image (though downsized to fit on the page) speaks volumes about the complexity
    and completeness of the data; for instance, the sequence pair in the upper-right
    corner—Rosalind_1144 and Rosalind_2208—cannot be joined to any other sequences.
    I would encourage you to try increasing `k` to `4` and inspecting the resulting
    graph to see a profoundly different result.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs are truly powerful data structures. As noted in the introduction to this
    chapter, graphs encode pairwise relationships. It’s amazing to see the assembly
    of the 100 sequences in [Figure 9-5](#fig_9.5) emerge with so few lines of code.
    While it’s possible to abuse Python lists and dictionaries to represent graphs,
    the Graphviz tool makes this much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: I used a directed graph for this exercise, but that wasn’t necessarily required.
    This could have been an undirected graph, too, but I like the arrows. I would
    note that you might encounter the term *directed acyclic graph* (DAG) to indicate
    a directed graph that has no cycles, which is when a node joins back to itself.
    Cycles might point to an incorrect assembly in the case of a linear genome but
    might be required for a circular genome, as in bacteria. If you find these ideas
    interesting, you should investigate De Bruijn graphs, which are often built from
    overlapping k-mers.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a Hamming distance option that will allow the overlapping sequence to have
    the indicated edit distance. That is, a distance of 1 will allow for the overlap
    of sequences with a single base difference.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: To find overlapping regions, I used k-mers to find the first and last *k* bases
    of each sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `logging` module makes it easy to turn on and off the logging of runtime
    messages to a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I used `defaultdict(list)` to create a dictionary that would auto-vivify any
    key not present with a default value of the empty list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set intersection can find common elements between collections, such as the keys
    shared between two dictionaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `itertools.product()` function found all the possible pairs of sequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `iteration_utilities.starfilter()` function will splat the argument to the
    `lambda` for `filter()`, just as the `itertools.starmap()` function does for `map()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Graphviz tool can efficiently represent and visualize complex graph structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphs can be textually represented using the Dot language, and the `dot` program
    can generate visualizations of graphs in various formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlap graphs can be used to create a complete assembly of two or more sequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch09.html#idm45963633006072-marker)) Imagine debugging a program without
    even a console. In the 1950s, Claude Shannon was visiting Alan Turing’s lab in
    England. During their conversation, a horn began sounding at regular intervals.
    Turing said this indicated his code was stuck in a loop. Without a console, this
    was how he monitored the progress of his programs.
  prefs: []
  type: TYPE_NORMAL
