- en: 'Chapter 7\. Translating mRNA into Protein: More Functional Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章\. mRNA翻译成蛋白质：更多的函数式编程
- en: According to the Central Dogma of molecular biology, *DNA makes mRNA, and mRNA
    makes protein*. In [Chapter 2](ch02.html#ch02), I showed how to transcribe DNA
    to mRNA, so now it’s time to translate mRNA into protein sequences. As described
    on [the Rosalind PROT page](https://oreil.ly/OgBcW), I now need to write a program
    that accepts a string of mRNA and produces an amino acid sequence. I will show
    several solutions using lists, `for` loops, list comprehensions, dictionaries,
    and higher-order functions, but I confess I’ll end with a Biopython function.
    Still, it will be tons of fun.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根据分子生物学的中心法则，*DNA生成mRNA，mRNA生成蛋白质*。在[第2章](ch02.html#ch02)中，我展示了如何将DNA转录成mRNA，现在是时候将mRNA翻译成蛋白质序列了。正如在[Rosalind
    PROT页面](https://oreil.ly/OgBcW)上描述的那样，现在我需要编写一个接受mRNA字符串并生成氨基酸序列的程序。我将展示几种解决方案，包括列表、`for`循环、列表推导、字典和高阶函数，但最后我会用Biopython函数结束。不过，这将会非常有趣。
- en: 'Mostly I’m going to focus on how to write, test, and compose small functions
    to create solutions. You’ll learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分时间我会专注于如何编写、测试和组合小函数来创建解决方案。你将学到：
- en: How to extract codons/k-mers from a sequence using string slices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用字符串切片从序列中提取密码子/K-mers
- en: How to use a dictionary as a lookup table
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用字典作为查找表
- en: How to translate a `for` loop into a list comprehension and a `map()` expression
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将`for`循环转换为列表推导和`map()`表达式
- en: How to use the `takewhile()` and `partial()` functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`takewhile()`和`partial()`函数
- en: How to use the `Bio.Seq` module to translate mRNA into proteins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`Bio.Seq`模块将mRNA翻译成蛋白质
- en: Getting Started
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: 'You will need to work in the *07_prot* directory for this exercise. I recommend
    you begin by copying the first solution to `prot.py` and asking for the usage:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在*07_prot*目录中工作。我建议你从将第一个解决方案复制到`prot.py`并要求用法开始：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The program requires an RNA sequence as a single positional argument. From
    here on, I’ll use the term *RNA*, but know that I mean *mRNA*. Here’s the result
    using the example string from the Rosalind page:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序需要一个RNA序列作为单个位置参数。从现在开始，我会使用术语*RNA*，但要知道我指的是*mRNA*。以下是使用Rosalind页面示例字符串的结果：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run **`make test`** to ensure the program works properly. When you feel you
    have a decent idea of how the program works, start from scratch:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**`make test`**确保程序正常工作。当你觉得你对程序的工作原理有了相当好的理解时，从头开始：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is how I define the parameters:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我定义参数的方式：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-1)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-1)'
- en: The only parameter is a string of mRNA.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的参数是一串mRNA。
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-2)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-2)'
- en: Define `rna` as a positional string.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`rna`作为一个位置字符串。
- en: 'Modify your arguments until the program will produce the correct usage, then
    modify your `main()` to print the incoming RNA string:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你的参数，直到程序能够产生正确的用法，然后修改你的`main()`函数以打印输入的RNA字符串：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Verify that it works:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 验证它是否有效：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run **`pytest`** or **`make test`** to see how you fare. Your program should
    pass the first two tests and fail the third, where the output should be the protein
    translation. If you think you can figure this out, go ahead with your solution.
    It’s perfectly fine to struggle. There’s no hurry, so take a few days if you need
    to. Be sure to incorporate naps and walks (diffuse thinking time) in addition
    to your focused coding time. If you need some help, read on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**`pytest`**或**`make test`**来查看你的表现。你的程序应该通过前两个测试，并且在第三个测试中失败，输出应该是蛋白质翻译。如果你认为你能解决这个问题，继续执行你的解决方案。挣扎是完全可以接受的。没有什么可着急的，所以如果需要的话可以多花几天时间。确保除了专注编码时间外，还包括小睡和散步（扩散思维时间）。如果需要帮助，请继续阅读。
- en: K-mers and Codons
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: K-mers和密码子
- en: So far you’ve seen many examples of how to iterate over the characters of a
    string, such as the bases of DNA. Here I need to group the bases of RNA into threes
    to read each *codon*, a sequence of three nucleotides that corresponds to an amino
    acid. There are 64 codons, as shown in [Table 7-1](#table_7.1).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了许多关于如何迭代字符串字符的例子，比如DNA的碱基。在这里，我需要将RNA的碱基分组成三个一组，以便读取每个密码子，即三个核苷酸序列，对应一个氨基酸。共有64个密码子，如[表 7-1](#table_7.1)所示。
- en: Table 7-1\. The RNA codon table describes how 3-mers/codons of RNA encode the
    22 amino acids
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 7-1\. RNA密码子表描述了RNA的三联体如何编码22种氨基酸
- en: '| AAA K | AAC N | AAG K | AAU N | ACA T |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| AAA K | AAC N | AAG K | AAU N | ACA T |'
- en: '| ACC T | ACG T | ACU T | AGA R | AGC S |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| ACC T | ACG T | ACU T | AGA R | AGC S |'
- en: '| AGG R | AGU S | AUA I | AUC I | AUG M |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| AGG R | AGU S | AUA I | AUC I | AUG M |'
- en: '| AUU I | CAA Q | CAC H | CAG Q | CAU H |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| AUU I | CAA Q | CAC H | CAG Q | CAU H |'
- en: '| CCA P | CCC P | CCG P | CCU P | CGA R |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| CCA P | CCC P | CCG P | CCU P | CGA R |'
- en: '| CGC R | CGG R | CGU R | CUA L | CUC L |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| CGC R | CGG R | CGU R | CUA L | CUC L |'
- en: '| CUG L | CUU L | GAA E | GAC D | GAG E |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| CUG L | CUU L | GAA E | GAC D | GAG E |'
- en: '| GAU D | GCA A | GCC A | GCG A | GCU A |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| GAU D | GCA A | GCC A | GCG A | GCU A |'
- en: '| GGA G | GGC G | GGG G | GGU G | GUA V |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| GGA G | GGC G | GGG G | GGU G | GUA V |'
- en: '| GUC V | GUG V | GUU V | UAC Y | UAU Y |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| GUC V | GUG V | GUU V | UAC Y | UAU Y |'
- en: '| UCA S | UCC S | UCG S | UCU S | UGC C |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| UCA S | UCC S | UCG S | UCU S | UGC C |'
- en: '| UGG W | UGU C | UUA L | UUC F | UUG L |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| UGG W | UGU C | UUA L | UUC F | UUG L |'
- en: '| UUU F | UAA Stop | UAG Stop | UGA Stop |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| UUU F | UAA 终止 | UAG 终止 | UGA 终止 |  |'
- en: 'Given some string of RNA:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一些RNA字符串：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I want to read the first three bases, *AUG*. As shown in [Figure 7-1](#fig_7.1),
    I can use a string slice to manually grab the characters from indexes 0 to 3 (remembering
    that the upper bound is not inclusive):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我想读取前三个碱基，*AUG*。如图[7-1](#fig_7.1)所示，我可以使用字符串切片从索引0到3手动抓取字符（请记住上界不包括在内）：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![mpfb 0701](assets/mpfb_0701.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0701](assets/mpfb_0701.png)'
- en: Figure 7-1\. Extracting codons from RNA using string slices
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1\. 使用字符串切片从RNA中提取密码子
- en: 'The next codon can be found by adding 3 to the start and stop positions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个密码子可通过将起始和停止位置加3来找到：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Can you see a pattern emerging? For the first number, I need to start at 0 and
    add 3. For the second number, I need to add 3 to the first number (see [Figure 7-2](#fig_7.2)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出出现了什么模式吗？对于第一个数字，我需要从0开始加3。对于第二个数字，我需要在第一个数字上加3（见图[7-2](#fig_7.2)）。
- en: '![mpfb 0702](assets/mpfb_0702.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0702](assets/mpfb_0702.png)'
- en: Figure 7-2\. Each slice is a function of the start positions of the codons,
    which can be found using the `range()` function
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2\. 每个切片是密码子起始位置的函数，可以使用`range()`函数找到
- en: 'I can handle the first part using the `range()` function, which can take one,
    two, or three arguments. Given just one argument, it will produce all the numbers
    from 0 up to but not including the given value. Note this is a lazy function which
    I’ll coerce with `list()`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`range()`函数处理第一部分，它可以接受一、两或三个参数。给定一个参数，它将生成从0到给定值但不包括给定值的所有数字。请注意这是一个惰性函数，我将使用`list()`来强制它：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Given two arguments, `range()` will assume the first is the start and the second
    is the stop:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个参数，`range()`将假定第一个是起始位置，第二个是停止位置：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A third argument will be interpreted as the step size. In [Chapter 3](ch03.html#ch03),
    I used `range()` with no start or stop positions and a step size of `-1` to reverse
    a string. In this case, I want to count from 0 up to the length of the RNA, stepping
    by 3. These are the starting positions for the codons:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数将被解释为步长。在[第三章](ch03.html#ch03)中，我使用`range()`没有起始或停止位置，步长为`-1`来反转字符串。在这种情况下，我想从0开始计数直到RNA的长度，步长为3。这些是密码子的起始位置：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I can use a list comprehension to generate the start and stop values as tuples.
    The stop positions are 3 more than the start positions. I’ll show just the first
    five:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用列表推导生成起始和停止值作为元组。停止位置比起始位置多3。这里仅展示前五个：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I can use those values to take slices of the RNA:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用这些值来对RNA进行切片：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The codons are subsequences of the RNA, and they are similar to *k-mers*. The
    *k* is the size, here 3, and *mer* is *a share* as in the word *polymer*. It’s
    common to refer to k-mers by their size, so here I might call these *3-mers*.
    The k-mers overlap by one character, so the window shifts right by one base. [Figure 7-3](#fig_7.3)
    shows the first seven 3-mers found in the first nine bases of the input RNA.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 密码子是RNA的子序列，类似于*k-mers*。这里的*k*是大小，为3，*mer*类似于*聚合物*中的*共享*。通常用k-mers的大小来指代它们，所以这里我可能称之为*3-mer*。k-mers重叠一个字符，所以窗口向右移动一个碱基。图[7-3](#fig_7.3)展示了输入RNA的前九个碱基中找到的前七个3-mer。
- en: '![mpfb 0703](assets/mpfb_0703.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0703](assets/mpfb_0703.png)'
- en: Figure 7-3\. All the 3-mers in the first nine bases of the RNA sequence
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-3\. RNA序列前九个碱基中的所有3-mer
- en: 'The number *n* of k-mers in any sequence *s* is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 任何序列*s*中k-mers的数量*n*为：
- en: <math alttext="n equals l e n left-parenthesis s right-parenthesis minus k plus
    1" display="block"><mrow><mi>n</mi> <mo>=</mo> <mi>l</mi> <mi>e</mi> <mi>n</mi>
    <mo>(</mo> <mi>s</mi> <mo>)</mo> <mo>-</mo> <mi>k</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="n equals l e n left-parenthesis s right-parenthesis minus k plus
    1" display="block"><mrow><mi>n</mi> <mo>=</mo> <mi>l</mi> <mi>e</mi> <mi>n</mi>
    <mo>(</mo> <mi>s</mi> <mo>)</mo> <mo>-</mo> <mi>k</mi> <mo>+</mo> <mn>1</mn></mrow></math>
- en: 'The length of this RNA sequence is 51, so it contains 49 3-mers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该RNA序列的长度为51，因此包含49个3-mer：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Except when considering multiframe translation, which I’ll show in [Chapter 14](ch14.html#ch14),
    codons do not overlap and so shift 3 positions (see [Figure 7-4](#fig_7.4)), leaving
    17 codons:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了考虑多帧翻译（我将在[第 14 章](ch14.html#ch14)中展示），密码子不重叠，因此每次移动 3 个位置（参见[图 7-4](#fig_7.4)），留下
    17 个密码子：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![mpfb 0704](assets/mpfb_0704.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0704](assets/mpfb_0704.png)'
- en: Figure 7-4\. Codons are nonoverlapping 3-mers
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-4\. 密码子是非重叠的 3-mers
- en: Translating Codons
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译密码子
- en: 'Now that you know how to extract the codons from the RNA, let’s consider how
    to translate a codon into a protein. The Rosalind page provides the following
    translation table:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何从 RNA 中提取密码子了，让我们考虑如何将密码子翻译成蛋白质。Rosalind 页面提供了以下翻译表：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A dictionary would be a natural data structure to look up a string like `AUG`
    to find that it translates to the protein `M`, which happens to be the codon that
    indicates the beginning of a protein sequence. I will leave it to you to incorporate
    this data into your program. For what it’s worth, I changed `Stop` to `*` in my
    dictionary for the stop codon, which indicates the end of the protein sequence.
    I called my dictionary `codon_to_aa`, and I can use it like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典来查找像 `AUG` 这样的字符串自然是一个合适的数据结构，以找到它翻译为蛋白质 `M`，这也正是表示蛋白质序列起始的密码子。我把字典中的 `Stop`
    改为 `*`，用于表示终止密码子，标志着蛋白质序列的结束。我把我的字典命名为 `codon_to_aa`，可以这样使用它：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `*` codon indicates where the translation ends and is often shown so you
    know that a stop was found and the protein is complete. For the purposes of passing
    the Rosalind tests, the stop should not be included in the output. Note that the
    stop codon may occur before the end of the RNA string. This should be enough hints
    for you to create a solution that passes the tests. Be sure to run **`pytest`**
    and **`make test`** to ensure your program is logically and stylistically correct.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 密码子表示翻译结束的位置，通常会显示以便你知道找到了终止并且蛋白质已完成。为了通过 Rosalind 的测试，输出中不应包含终止密码子。注意，终止密码子可能出现在
    RNA 字符串的末尾之前。这些提示应足够让你创建一个能通过测试的解决方案。确保运行 **`pytest`** 和 **`make test`** 以确保你的程序在逻辑上和风格上都是正确的。'
- en: Solutions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: In this section, I will show five variations on how to translate RNA into protein,
    moving from wholly manual solutions where I encode the RNA codon table with a
    dictionary to a single line of code that uses a function from Biopython. All solutions
    use the same `get_args()` as shown previously.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将展示将 RNA 翻译成蛋白质的五种变体，从完全手动解决方案（其中我使用字典对 RNA 密码子表进行编码）到使用 Biopython 函数的单行代码。所有解决方案都使用之前展示的相同
    `get_args()`。
- en: 'Solution 1: Using a for Loop'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 1：使用 for 循环
- en: 'Here is the whole of my first solution, which uses a `for` loop to iterate
    the codons to translate them via a dictionary:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我第一个解决方案的完整内容，它使用 `for` 循环来迭代密码子，并通过字典将其翻译为蛋白质：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-1)'
- en: Copy the incoming RNA, forcing to uppercase.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 复制传入的 RNA，并强制转换为大写。
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-2)'
- en: Create a codon/AA lookup table using a dictionary.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典创建密码子/氨基酸查找表。
- en: '[![3](assets/3.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-3)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-3)'
- en: Establish the size of `k` for finding k-mers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 确定用于查找 k-mer 的 `k` 的大小。
- en: '[![4](assets/4.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-4)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-4)'
- en: Initialize the protein sequence to the empty string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化蛋白质序列为空字符串。
- en: '[![5](assets/5.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-5)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-5)'
- en: Iterate through the codons of the RNA.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历 RNA 的密码子。
- en: '[![6](assets/6.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-6)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-6)'
- en: Use `dict.get()` to look up the amino acid for this codon, and return a dash
    if it is not found.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dict.get()` 查找这个密码子对应的氨基酸，并在找不到时返回短横线。
- en: '[![7](assets/7.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-7)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-7)'
- en: Check if this is the stop codon.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这是否为终止密码子。
- en: '[![8](assets/8.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-8)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-8)'
- en: Break out of the `for` loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 退出`for`循环。
- en: '[![9](assets/9.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-9)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-9)'
- en: Append the amino acid to the protein sequence.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将氨基酸追加到蛋白质序列中。
- en: '[![10](assets/10.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-10)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-10)'
- en: Print the protein sequence.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 打印蛋白质序列。
- en: 'Solution 2: Adding Unit Tests'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2：添加单元测试
- en: The first solution works adequately well and, for such a short program, has
    a decent organization. The problem is that short programs usually become long
    programs. It’s common to make functions longer and longer, so I’d like to show
    how I can break up the code in `main()` into a couple of smaller functions with
    tests. Generally speaking, I like to see a function fit into 50 lines or fewer
    on the high end. As for how short a function can be, I’m not opposed to a single
    line of code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案工作得相当好，对于如此简短的程序，它的组织也相当不错。问题在于，短程序通常会变成长程序。函数变得越来越长是很常见的，因此我想展示如何将`main()`中的代码拆分为几个更小的函数，并附带测试。一般来说，我喜欢看到一个函数在50行或更少的情况下适合，至于一个函数可以有多短，我不反对只有一行代码。
- en: 'My first intuition is to extract the code that finds the codons and make that
    into a function with a unit test. I can start by defining a placeholder for the
    function with a type signature that helps me think about what the function accepts
    as arguments and will return as a result:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我的第一直觉是提取找到密码子的代码，并将其变成一个带有单元测试的函数。我可以先定义一个函数的占位符，类型签名帮助我思考函数接受什么参数并返回什么结果：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-1)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-1)'
- en: The function will accept a string and will return a list of strings.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将接受一个字符串，并返回一个字符串列表。
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-2)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-2)'
- en: For now, just return an empty list.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只返回一个空列表。
- en: 'Next, I define a `test_codons()` function to imagine how it might work. Whenever
    I have a string as a function parameter, I try passing the empty string. (Whenever
    I have an integer as a function parameter, I try passing `0`.) Then I try other
    possible values and imagine what the function ought to do. As you can see, I’m
    making some judgment calls here by returning strings shorter than three bases.
    I only expect the function to break a string into substrings of *at least* three
    bases. There’s no reason to let perfect be the enemy of good enough here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我定义一个`test_codons()`函数来设想它可能如何工作。每当我有一个字符串作为函数参数时，我尝试传递空字符串。（每当我有一个整数作为函数参数时，我尝试传递`0`。）然后我尝试其他可能的值，并设想函数应该做什么。如你所见，我在这里做了一些判断调用，通过返回长度小于三个碱基的字符串。我只期望函数将一个字符串分解成至少三个碱基的子字符串。在这里，没有理由让完美成为好的敌人：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now to write the function that will satisfy these tests. If I move the relevant
    code from `main()` into the `codons()` function, I get this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写满足这些测试的函数。如果我将相关代码从`main()`移入`codons()`函数中，结果如下：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If I try running `pytest` on this program, I see it passes. Huzzah! Since the
    `for` loop is being used to build up a return list, it would be stylistically
    better to use a list comprehension:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我尝试在此程序上运行`pytest`，我看到它通过了。万岁！由于`for`循环用于构建返回列表，使用列表推导式在风格上更好：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a nice little function that is documented and tested and which will
    make the rest of the code more readable:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个精心编写和测试过的小函数，可以使代码其余部分更易读：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO4-1)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO4-1)'
- en: The complexity of finding the codons is hidden in a function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找密码子的复杂性隐藏在一个函数中。
- en: 'Further, this function (and its test) will now be easier to incorporate into
    another program. The simplest case would be to copy and paste these lines, but
    a better solution would be to share the function. Let me demonstrate using the
    REPL. If you have the `codons()` function in your `prot.py` program, then import
    the function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now you can execute the `codons()` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or you can import the entire `prot` module and call the function like so:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Python *programs* are also *modules* of reusable code. Sometimes you execute
    a source code file and it becomes a program, but there’s not a big distinction
    in Python between a program and a module. This is the meaning of the couplet at
    the end of all the programs:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-1)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: When a Python program is being *executed* as a program, the value of `__name__`
    is `__main__`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-2)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Call the `main()` function to start the program.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: When a Python module is being *imported* by another piece of code, then the
    `__name__` is the name of the module; for example, `prot` in the case of `prot.py`.
    If you simply called `main()` at the end of the program without checking the `__name__`,
    then it would be executed whenever your module is imported, which is not good.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: As you write more and more Python, you’ll likely find you’re solving some of
    the same problems repeatedly. It would be far better to share common solutions
    by writing functions that you share across projects rather than copy-pasting bits
    of code. Python makes it pretty easy to put reusable functions into modules and
    import them into other programs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Another Function and a List Comprehension'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `codons()` function is tidy and useful and makes the `main()` function
    easier to understand; however, all the code that’s left in `main()` is concerned
    with translating the protein. I’d like to hide this away in a `translate()` function,
    and here is the test I’d like to use:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-1)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: I usually test string parameters with the empty string.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-2)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Test for a single amino acid.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-3)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Test using a stop codon before the end of the sequence.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-4)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Notice that adjacent string literals are joined into a single string. This is
    a useful way to break long lines in source code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-5)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-5)'
- en: Test using the example from Rosalind.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自Rosalind的示例进行测试。
- en: 'I move all the code from `main()` into this, changing the `for` loop to a list
    comprehension and using a list slice to truncate the protein at the stop codon:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我将所有代码从`main()`移到这里，将`for`循环改为列表推导，并使用列表切片来截断蛋白质在终止密码子处：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-1)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-1)'
- en: Use a list comprehension to translate the list of codons to a list of amino
    acids.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导将密码子列表转换为氨基酸列表。
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-2)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-2)'
- en: See if the stop (`*`) codon is present in the list of amino acids.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 查看列表中是否存在终止（`*`）密码子。
- en: '[![3](assets/3.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-3)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-3)'
- en: Overwrite the amino acids using a list slice up to the index of the stop codon.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表切片覆盖氨基酸直到终止密码子的索引处。
- en: '[![4](assets/4.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-4)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-4)'
- en: Join the amino acids on the empty string and return the new protein sequence.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将氨基酸连接在空字符串上并返回新的蛋白质序列。
- en: 'To understand this, consider the following RNA sequence:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，请考虑以下RNA序列：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'I can use the `codons()` function to get the codons:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用 `codons()` 函数获取密码子：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And use a list comprehension to turn those into amino acids:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用列表推导将其转换为氨基酸：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'I can see the stop codon is present:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以看到终止密码子的存在：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'and so the sequence needs to be truncated at index 2:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以序列需要在索引 2 处截断：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'I can use a list slice to select up to the position of the stop codon. If no
    start position is supplied, then Python assumes the index 0:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用列表切片选择到终止密码子的位置。如果没有提供起始位置，则 Python 假定索引为 0：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, this list needs to be joined on the empty string:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要将这些列表连接为空字符串：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `main()` function incorporates the new function and makes for a very readable
    program:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数包含了新函数，使得程序非常易读：'
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is another instance where the unit test almost duplicates the integration
    test that verifies the program translates RNA into protein. The latter is still
    important as it ensures that the program works, produces documentation, handles
    the arguments, and so forth. As overengineered as this solution may seem, I want
    you to focus on how to break programs into smaller *functions* that you can understand,
    test, compose, and share.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个单位测试几乎重复集成测试的实例，后者仍然很重要，因为它确保程序能够工作，生成文档，处理参数等等。尽管这种解决方案可能显得过于工程化，但我希望你专注于如何将程序分解为更小的*函数*，以便理解、测试、组合和共享。
- en: 'Solution 4: Functional Programming with the map(), partial(), and takewhile()
    Functions'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 4：使用 `map()`、`partial()` 和 `takewhile()` 函数进行函数式编程
- en: For this next solution, I want to show how to rewrite some of the logic using
    three HOFs, `map()`, `partial()`, and `takewhile()`. [Figure 7-5](#fig_7.5) shows
    how the list comprehension can be rewritten as a `map()`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个解决方案，我想展示如何使用三个高阶函数 `map()`、`partial()` 和 `takewhile()` 重写一些逻辑。[图 7-5](#fig_7.5)
    显示列表推导如何被重写为 `map()`。
- en: '![mpfb 0705](assets/mpfb_0705.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0705](assets/mpfb_0705.png)'
- en: Figure 7-5\. A list comprehension can be rewritten as a `map()`
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. 列表推导可以被重写为 `map()`
- en: 'I can use `map()` to get the amino acid sequence. You may or may not feel this
    is easier to read than a list comprehension; the point is to understand that they
    are functionally equivalent, both transforming one list into a new list:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用 `map()` 获取氨基酸序列。你可能认为这比列表推导更容易阅读，也可能不认为；关键是理解它们在功能上是等效的，都将一个列表转换为一个新列表：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The code to find the stop codon and slice the list can be rewritten using the
    `itertools.takewhile()` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 找到终止密码子并切片列表的代码可以使用 `itertools.takewhile()` 函数重写：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As the name implies, this function will *take* elements from a sequence *while*
    the predicate is met. Once the predicate fails, the function stops producing values.
    Here the condition is that the residue is not `*` (stop):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名，此函数会在谓词满足时从序列中 *取* 元素。一旦谓词失败，函数就停止产生值。这里的条件是残留物不是 `*`（停止）：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you like using these kinds of HOFs, you can take this even further by using
    the `functools.partial()` function I showed in [Chapter 4](ch04.html#ch04). Here
    I want to partially apply the `operator.ne()` (not equal) function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用这些高阶函数，可以通过使用我在 [第四章](ch04.html#ch04) 中展示的 `functools.partial()` 函数更进一步。这里我想部分应用
    `operator.ne()`（不等于）函数：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `not_stop()` function needs one more string value before it can return
    a value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `not_stop()` 在返回值之前需要再加一个字符串值：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When I compose these functions, they almost read like an English sentence:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我组合这些函数时，它们几乎读起来像是一句英语句子：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is how I would write the `translate()` function with purely functional
    ideas:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我如何使用纯函数思想编写 `translate()` 函数的方式：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Solution 5: Using Bio.Seq.translate()'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 5：使用 Bio.Seq.translate()
- en: 'As promised, the last solution uses Biopython. In [Chapter 3](ch03.html#ch03),
    I used the `Bio.Seq.reverse_complement()` function, and here I can use `Bio.Seq.translate()`.
    First, import the `Bio.Seq` class:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如约，最后的解决方案使用了 Biopython。在 [第三章](ch03.html#ch03) 中，我使用了 `Bio.Seq.reverse_complement()`
    函数，这里可以使用 `Bio.Seq.translate()`。首先，导入 `Bio.Seq` 类：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then call the `translate()` function. Note that the stop codon is represented
    by `*`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用 `translate()` 函数。请注意，终止密码子用 `*` 表示：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By default, this function does not stop translation at the stop codon:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此函数不会在终止密码子处停止翻译：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you read `help(Seq.translate)` in the REPL, you’ll find the `to_stop` option
    to change this to the version expected by the Rosalind challenge:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 REPL 中阅读 `help(Seq.translate)`，你会发现 `to_stop` 选项可以将其更改为 Rosalind 挑战所期望的版本：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is how I put it all together:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我将所有内容整合在一起的方式：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is the solution I would recommend because it relies on the widely used
    Biopython module. While it was fun and enlightening to explore how to manually
    code a solution, it’s far better practice to use code that’s already been written
    and tested by a dedicated team of developers.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我推荐的解决方案，因为它依赖广泛使用的 Biopython 模块。虽然手动编写解决方案探索如何编码是有趣且启发性的，但更好的实践是使用已由专门开发团队编写和测试过的代码。
- en: Benchmarking
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: Which is the fastest solution? I can use the `hyperfine` benchmarking program
    I introduced in [Chapter 4](ch04.html#ch04) to compare the runtimes of the programs.
    Because this is such a short program, I decided to run each program at least 1,000
    times, as documented in the `bench.sh` program in the repository.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法最快？我可以使用我在 [第四章](ch04.html#ch04) 中介绍的 `hyperfine` 基准测试程序来比较程序的运行时间。因为这是一个非常简短的程序，我决定至少运行每个程序
    1,000 次，正如在仓库中的 `bench.sh` 程序中所记录的那样。
- en: Although the second solution runs the fastest, perhaps as much at 1.5 times
    faster than the Biopython version, I’d still recommend using the latter because
    this is a thoroughly documented and tested module that is widely used in the community.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第二种解决方案运行速度最快，可能比 Biopython 版本快多达 1.5 倍，但我仍然建议使用后者，因为这是一个在社区广泛使用并且有详细文档和测试的模块。
- en: Going Further
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更进一步
- en: Add a `--frame-shift` argument that defaults to `0` and allows values `0-2`
    (inclusive). Use the frameshift to start reading the RNA from an alternate position.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `--frame-shift` 参数，默认为 `0`，允许值为 `0-2`（包括）。使用帧移来从备用位置开始读取 RNA。
- en: Review
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: The focus of this chapter was really on how to write, test, and compose functions
    to solve the problem at hand. I wrote functions to find codons in a sequence and
    translate RNA. Then I showed how to use higher-order functions to compose other
    functions, and finally, I used an off-the-shelf function from Biopython.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点实际上是如何编写、测试和组合函数来解决手头的问题。我编写了用于查找序列中密码子和翻译 RNA 的函数。然后展示了如何使用高阶函数来组合其他函数，最后使用了
    Biopython 的现成函数。
- en: K-mers are all the *k*-length subsequences of a sequence.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: K-mers 是序列的 *k* 长度子序列。
- en: Codons are 3-mers that do not overlap in a particular frame.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码子是在特定框架中不重叠的 3-mer。
- en: Dictionaries are useful as lookup tables, such as for translating a codon to
    an amino acid.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典作为查找表格非常有用，比如将密码子翻译为氨基酸。
- en: A `for` loop, a list comprehension, and `map()` are all methods for transforming
    one sequence into another.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环、列表推导式和 `map()` 都是将一个序列转换为另一个的方法。'
- en: The `takewhile()` function is similar to the `filter()` function in accepting
    values from a sequence based on a predicate or test of the values.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takewhile()` 函数类似于 `filter()` 函数，根据值的谓词或测试从序列中接受值。'
- en: The `partial()` function allows one to partially apply the arguments to a function.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partial()` 函数允许将参数部分应用于一个函数。'
- en: The `Bio.Seq.translate()` function will translate an RNA sequence into a protein
    sequence.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bio.Seq.translate()` 函数将 RNA 序列翻译成蛋白质序列。'
