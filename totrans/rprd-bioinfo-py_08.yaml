- en: 'Chapter 7\. Translating mRNA into Protein: More Functional Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the Central Dogma of molecular biology, *DNA makes mRNA, and mRNA
    makes protein*. In [Chapter 2](ch02.html#ch02), I showed how to transcribe DNA
    to mRNA, so now it’s time to translate mRNA into protein sequences. As described
    on [the Rosalind PROT page](https://oreil.ly/OgBcW), I now need to write a program
    that accepts a string of mRNA and produces an amino acid sequence. I will show
    several solutions using lists, `for` loops, list comprehensions, dictionaries,
    and higher-order functions, but I confess I’ll end with a Biopython function.
    Still, it will be tons of fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mostly I’m going to focus on how to write, test, and compose small functions
    to create solutions. You’ll learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to extract codons/k-mers from a sequence using string slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a dictionary as a lookup table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to translate a `for` loop into a list comprehension and a `map()` expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `takewhile()` and `partial()` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `Bio.Seq` module to translate mRNA into proteins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to work in the *07_prot* directory for this exercise. I recommend
    you begin by copying the first solution to `prot.py` and asking for the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The program requires an RNA sequence as a single positional argument. From
    here on, I’ll use the term *RNA*, but know that I mean *mRNA*. Here’s the result
    using the example string from the Rosalind page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run **`make test`** to ensure the program works properly. When you feel you
    have a decent idea of how the program works, start from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I define the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The only parameter is a string of mRNA.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define `rna` as a positional string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your arguments until the program will produce the correct usage, then
    modify your `main()` to print the incoming RNA string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run **`pytest`** or **`make test`** to see how you fare. Your program should
    pass the first two tests and fail the third, where the output should be the protein
    translation. If you think you can figure this out, go ahead with your solution.
    It’s perfectly fine to struggle. There’s no hurry, so take a few days if you need
    to. Be sure to incorporate naps and walks (diffuse thinking time) in addition
    to your focused coding time. If you need some help, read on.
  prefs: []
  type: TYPE_NORMAL
- en: K-mers and Codons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far you’ve seen many examples of how to iterate over the characters of a
    string, such as the bases of DNA. Here I need to group the bases of RNA into threes
    to read each *codon*, a sequence of three nucleotides that corresponds to an amino
    acid. There are 64 codons, as shown in [Table 7-1](#table_7.1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. The RNA codon table describes how 3-mers/codons of RNA encode the
    22 amino acids
  prefs: []
  type: TYPE_NORMAL
- en: '| AAA K | AAC N | AAG K | AAU N | ACA T |'
  prefs: []
  type: TYPE_TB
- en: '| ACC T | ACG T | ACU T | AGA R | AGC S |'
  prefs: []
  type: TYPE_TB
- en: '| AGG R | AGU S | AUA I | AUC I | AUG M |'
  prefs: []
  type: TYPE_TB
- en: '| AUU I | CAA Q | CAC H | CAG Q | CAU H |'
  prefs: []
  type: TYPE_TB
- en: '| CCA P | CCC P | CCG P | CCU P | CGA R |'
  prefs: []
  type: TYPE_TB
- en: '| CGC R | CGG R | CGU R | CUA L | CUC L |'
  prefs: []
  type: TYPE_TB
- en: '| CUG L | CUU L | GAA E | GAC D | GAG E |'
  prefs: []
  type: TYPE_TB
- en: '| GAU D | GCA A | GCC A | GCG A | GCU A |'
  prefs: []
  type: TYPE_TB
- en: '| GGA G | GGC G | GGG G | GGU G | GUA V |'
  prefs: []
  type: TYPE_TB
- en: '| GUC V | GUG V | GUU V | UAC Y | UAU Y |'
  prefs: []
  type: TYPE_TB
- en: '| UCA S | UCC S | UCG S | UCU S | UGC C |'
  prefs: []
  type: TYPE_TB
- en: '| UGG W | UGU C | UUA L | UUC F | UUG L |'
  prefs: []
  type: TYPE_TB
- en: '| UUU F | UAA Stop | UAG Stop | UGA Stop |  |'
  prefs: []
  type: TYPE_TB
- en: 'Given some string of RNA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I want to read the first three bases, *AUG*. As shown in [Figure 7-1](#fig_7.1),
    I can use a string slice to manually grab the characters from indexes 0 to 3 (remembering
    that the upper bound is not inclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 0701](assets/mpfb_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Extracting codons from RNA using string slices
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The next codon can be found by adding 3 to the start and stop positions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Can you see a pattern emerging? For the first number, I need to start at 0 and
    add 3. For the second number, I need to add 3 to the first number (see [Figure 7-2](#fig_7.2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0702](assets/mpfb_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Each slice is a function of the start positions of the codons,
    which can be found using the `range()` function
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I can handle the first part using the `range()` function, which can take one,
    two, or three arguments. Given just one argument, it will produce all the numbers
    from 0 up to but not including the given value. Note this is a lazy function which
    I’ll coerce with `list()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Given two arguments, `range()` will assume the first is the start and the second
    is the stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A third argument will be interpreted as the step size. In [Chapter 3](ch03.html#ch03),
    I used `range()` with no start or stop positions and a step size of `-1` to reverse
    a string. In this case, I want to count from 0 up to the length of the RNA, stepping
    by 3. These are the starting positions for the codons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use a list comprehension to generate the start and stop values as tuples.
    The stop positions are 3 more than the start positions. I’ll show just the first
    five:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use those values to take slices of the RNA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The codons are subsequences of the RNA, and they are similar to *k-mers*. The
    *k* is the size, here 3, and *mer* is *a share* as in the word *polymer*. It’s
    common to refer to k-mers by their size, so here I might call these *3-mers*.
    The k-mers overlap by one character, so the window shifts right by one base. [Figure 7-3](#fig_7.3)
    shows the first seven 3-mers found in the first nine bases of the input RNA.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0703](assets/mpfb_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. All the 3-mers in the first nine bases of the RNA sequence
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The number *n* of k-mers in any sequence *s* is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="n equals l e n left-parenthesis s right-parenthesis minus k plus
    1" display="block"><mrow><mi>n</mi> <mo>=</mo> <mi>l</mi> <mi>e</mi> <mi>n</mi>
    <mo>(</mo> <mi>s</mi> <mo>)</mo> <mo>-</mo> <mi>k</mi> <mo>+</mo> <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The length of this RNA sequence is 51, so it contains 49 3-mers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Except when considering multiframe translation, which I’ll show in [Chapter 14](ch14.html#ch14),
    codons do not overlap and so shift 3 positions (see [Figure 7-4](#fig_7.4)), leaving
    17 codons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![mpfb 0704](assets/mpfb_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Codons are nonoverlapping 3-mers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Translating Codons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know how to extract the codons from the RNA, let’s consider how
    to translate a codon into a protein. The Rosalind page provides the following
    translation table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A dictionary would be a natural data structure to look up a string like `AUG`
    to find that it translates to the protein `M`, which happens to be the codon that
    indicates the beginning of a protein sequence. I will leave it to you to incorporate
    this data into your program. For what it’s worth, I changed `Stop` to `*` in my
    dictionary for the stop codon, which indicates the end of the protein sequence.
    I called my dictionary `codon_to_aa`, and I can use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `*` codon indicates where the translation ends and is often shown so you
    know that a stop was found and the protein is complete. For the purposes of passing
    the Rosalind tests, the stop should not be included in the output. Note that the
    stop codon may occur before the end of the RNA string. This should be enough hints
    for you to create a solution that passes the tests. Be sure to run **`pytest`**
    and **`make test`** to ensure your program is logically and stylistically correct.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I will show five variations on how to translate RNA into protein,
    moving from wholly manual solutions where I encode the RNA codon table with a
    dictionary to a single line of code that uses a function from Biopython. All solutions
    use the same `get_args()` as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using a for Loop'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the whole of my first solution, which uses a `for` loop to iterate
    the codons to translate them via a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the incoming RNA, forcing to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a codon/AA lookup table using a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Establish the size of `k` for finding k-mers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the protein sequence to the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the codons of the RNA.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `dict.get()` to look up the amino acid for this codon, and return a dash
    if it is not found.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if this is the stop codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Break out of the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Append the amino acid to the protein sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](assets/10.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO2-10)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the protein sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Adding Unit Tests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first solution works adequately well and, for such a short program, has
    a decent organization. The problem is that short programs usually become long
    programs. It’s common to make functions longer and longer, so I’d like to show
    how I can break up the code in `main()` into a couple of smaller functions with
    tests. Generally speaking, I like to see a function fit into 50 lines or fewer
    on the high end. As for how short a function can be, I’m not opposed to a single
    line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'My first intuition is to extract the code that finds the codons and make that
    into a function with a unit test. I can start by defining a placeholder for the
    function with a type signature that helps me think about what the function accepts
    as arguments and will return as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function will accept a string and will return a list of strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: For now, just return an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I define a `test_codons()` function to imagine how it might work. Whenever
    I have a string as a function parameter, I try passing the empty string. (Whenever
    I have an integer as a function parameter, I try passing `0`.) Then I try other
    possible values and imagine what the function ought to do. As you can see, I’m
    making some judgment calls here by returning strings shorter than three bases.
    I only expect the function to break a string into substrings of *at least* three
    bases. There’s no reason to let perfect be the enemy of good enough here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to write the function that will satisfy these tests. If I move the relevant
    code from `main()` into the `codons()` function, I get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If I try running `pytest` on this program, I see it passes. Huzzah! Since the
    `for` loop is being used to build up a return list, it would be stylistically
    better to use a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a nice little function that is documented and tested and which will
    make the rest of the code more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of finding the codons is hidden in a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, this function (and its test) will now be easier to incorporate into
    another program. The simplest case would be to copy and paste these lines, but
    a better solution would be to share the function. Let me demonstrate using the
    REPL. If you have the `codons()` function in your `prot.py` program, then import
    the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can execute the `codons()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can import the entire `prot` module and call the function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Python *programs* are also *modules* of reusable code. Sometimes you execute
    a source code file and it becomes a program, but there’s not a big distinction
    in Python between a program and a module. This is the meaning of the couplet at
    the end of all the programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: When a Python program is being *executed* as a program, the value of `__name__`
    is `__main__`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `main()` function to start the program.
  prefs: []
  type: TYPE_NORMAL
- en: When a Python module is being *imported* by another piece of code, then the
    `__name__` is the name of the module; for example, `prot` in the case of `prot.py`.
    If you simply called `main()` at the end of the program without checking the `__name__`,
    then it would be executed whenever your module is imported, which is not good.
  prefs: []
  type: TYPE_NORMAL
- en: As you write more and more Python, you’ll likely find you’re solving some of
    the same problems repeatedly. It would be far better to share common solutions
    by writing functions that you share across projects rather than copy-pasting bits
    of code. Python makes it pretty easy to put reusable functions into modules and
    import them into other programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Another Function and a List Comprehension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `codons()` function is tidy and useful and makes the `main()` function
    easier to understand; however, all the code that’s left in `main()` is concerned
    with translating the protein. I’d like to hide this away in a `translate()` function,
    and here is the test I’d like to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: I usually test string parameters with the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Test for a single amino acid.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Test using a stop codon before the end of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that adjacent string literals are joined into a single string. This is
    a useful way to break long lines in source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Test using the example from Rosalind.
  prefs: []
  type: TYPE_NORMAL
- en: 'I move all the code from `main()` into this, changing the `for` loop to a list
    comprehension and using a list slice to truncate the protein at the stop codon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a list comprehension to translate the list of codons to a list of amino
    acids.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: See if the stop (`*`) codon is present in the list of amino acids.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Overwrite the amino acids using a list slice up to the index of the stop codon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_translating_mrna_into_protein___span_class__keep_together__more_functional_programming__span__CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Join the amino acids on the empty string and return the new protein sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, consider the following RNA sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use the `codons()` function to get the codons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And use a list comprehension to turn those into amino acids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'I can see the stop codon is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'and so the sequence needs to be truncated at index 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use a list slice to select up to the position of the stop codon. If no
    start position is supplied, then Python assumes the index 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this list needs to be joined on the empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function incorporates the new function and makes for a very readable
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is another instance where the unit test almost duplicates the integration
    test that verifies the program translates RNA into protein. The latter is still
    important as it ensures that the program works, produces documentation, handles
    the arguments, and so forth. As overengineered as this solution may seem, I want
    you to focus on how to break programs into smaller *functions* that you can understand,
    test, compose, and share.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 4: Functional Programming with the map(), partial(), and takewhile()
    Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this next solution, I want to show how to rewrite some of the logic using
    three HOFs, `map()`, `partial()`, and `takewhile()`. [Figure 7-5](#fig_7.5) shows
    how the list comprehension can be rewritten as a `map()`.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0705](assets/mpfb_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. A list comprehension can be rewritten as a `map()`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I can use `map()` to get the amino acid sequence. You may or may not feel this
    is easier to read than a list comprehension; the point is to understand that they
    are functionally equivalent, both transforming one list into a new list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to find the stop codon and slice the list can be rewritten using the
    `itertools.takewhile()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name implies, this function will *take* elements from a sequence *while*
    the predicate is met. Once the predicate fails, the function stops producing values.
    Here the condition is that the residue is not `*` (stop):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you like using these kinds of HOFs, you can take this even further by using
    the `functools.partial()` function I showed in [Chapter 4](ch04.html#ch04). Here
    I want to partially apply the `operator.ne()` (not equal) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `not_stop()` function needs one more string value before it can return
    a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When I compose these functions, they almost read like an English sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I would write the `translate()` function with purely functional
    ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Solution 5: Using Bio.Seq.translate()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As promised, the last solution uses Biopython. In [Chapter 3](ch03.html#ch03),
    I used the `Bio.Seq.reverse_complement()` function, and here I can use `Bio.Seq.translate()`.
    First, import the `Bio.Seq` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then call the `translate()` function. Note that the stop codon is represented
    by `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, this function does not stop translation at the stop codon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If you read `help(Seq.translate)` in the REPL, you’ll find the `to_stop` option
    to change this to the version expected by the Rosalind challenge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I put it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is the solution I would recommend because it relies on the widely used
    Biopython module. While it was fun and enlightening to explore how to manually
    code a solution, it’s far better practice to use code that’s already been written
    and tested by a dedicated team of developers.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which is the fastest solution? I can use the `hyperfine` benchmarking program
    I introduced in [Chapter 4](ch04.html#ch04) to compare the runtimes of the programs.
    Because this is such a short program, I decided to run each program at least 1,000
    times, as documented in the `bench.sh` program in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Although the second solution runs the fastest, perhaps as much at 1.5 times
    faster than the Biopython version, I’d still recommend using the latter because
    this is a thoroughly documented and tested module that is widely used in the community.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a `--frame-shift` argument that defaults to `0` and allows values `0-2`
    (inclusive). Use the frameshift to start reading the RNA from an alternate position.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this chapter was really on how to write, test, and compose functions
    to solve the problem at hand. I wrote functions to find codons in a sequence and
    translate RNA. Then I showed how to use higher-order functions to compose other
    functions, and finally, I used an off-the-shelf function from Biopython.
  prefs: []
  type: TYPE_NORMAL
- en: K-mers are all the *k*-length subsequences of a sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Codons are 3-mers that do not overlap in a particular frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionaries are useful as lookup tables, such as for translating a codon to
    an amino acid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `for` loop, a list comprehension, and `map()` are all methods for transforming
    one sequence into another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `takewhile()` function is similar to the `filter()` function in accepting
    values from a sequence based on a predicate or test of the values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `partial()` function allows one to partially apply the arguments to a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Bio.Seq.translate()` function will translate an RNA sequence into a protein
    sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
