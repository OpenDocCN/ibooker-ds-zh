- en: Chapter 22\. Network Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your connections to all the things around you literally define who you are.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Aaron O’Connell
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Many interesting data problems can be fruitfully thought of in terms of *networks*,
    consisting of *nodes* of some type and the *edges* that join them.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, your Facebook friends form the nodes of a network whose edges
    are friendship relations. A less obvious example is the World Wide Web itself,
    with each web page a node and each hyperlink from one page to another an edge.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook friendship is mutual—if I am Facebook friends with you, then necessarily
    you are friends with me. In this case, we say that the edges are *undirected*.
    Hyperlinks are not—my website links to *whitehouse.gov*, but (for reasons inexplicable
    to me) *whitehouse.gov* refuses to link to my website. We call these types of
    edges *directed*. We’ll look at both kinds of networks.
  prefs: []
  type: TYPE_NORMAL
- en: Betweenness Centrality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html#introduction), we computed the key connectors in the
    DataSciencester network by counting the number of friends each user had. Now we
    have enough machinery to take a look at other approaches. We will use the same
    network, but now we’ll use `NamedTuple`s for the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the network ([Figure 22-1](#datasciencester_network_ch21)) comprised
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'and friendships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![The DataSciencester network.](assets/dsf2_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-1\. The DataSciencester network
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The friendships will be easier to work with as a `dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we left off we were dissatisfied with our notion of *degree centrality*,
    which didn’t really agree with our intuition about who the key connectors of the
    network were.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative metric is *betweenness centrality*, which identifies people who
    frequently are on the shortest paths between pairs of other people. In particular,
    the betweenness centrality of node *i* is computed by adding up, for every other
    pair of nodes *j* and *k*, the proportion of shortest paths between node *j* and
    node *k* that pass through *i*.
  prefs: []
  type: TYPE_NORMAL
- en: That is, to figure out Thor’s betweenness centrality, we’ll need to compute
    all the shortest paths between all pairs of people who aren’t Thor. And then we’ll
    need to count how many of those shortest paths pass through Thor. For instance,
    the only shortest path between Chi (`id` 3) and Clive (`id` 5) passes through
    Thor, while neither of the two shortest paths between Hero (`id` 0) and Chi (`id`
    3) does.
  prefs: []
  type: TYPE_NORMAL
- en: So, as a first step, we’ll need to figure out the shortest paths between all
    pairs of people. There are some pretty sophisticated algorithms for doing so efficiently,
    but (as is almost always the case) we will use a less efficient, easier-to-understand
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm (an implementation of breadth-first search) is one of the more
    complicated ones in the book, so let’s talk through it carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is a function that takes a `from_user` and finds *all* shortest paths
    to every other user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll represent a path as a `list` of user IDs. Since every path starts at `from_user`,
    we won’t include her ID in the list. This means that the length of the list representing
    the path will be the length of the path itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll maintain a dictionary called `shortest_paths_to` where the keys are user
    IDs and the values are lists of paths that end at the user with the specified
    ID. If there is a unique shortest path, the list will just contain that one path.
    If there are multiple shortest paths, the list will contain all of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll also maintain a queue called `frontier` that contains the users we want
    to explore in the order we want to explore them. We’ll store them as pairs `(prev_user,
    user)` so that we know how we got to each one. We initialize the queue with all
    the neighbors of `from_user`. (We haven’t talked about queues, which are data
    structures optimized for “add to the end” and “remove from the front” operations.
    In Python, they are implemented as `collections.deque`, which is actually a double-ended
    queue.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we explore the graph, whenever we find new neighbors that we don’t already
    know the shortest paths to, we add them to the end of the queue to explore later,
    with the current user as `prev_user`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we take a user off the queue, and we’ve never encountered that user before,
    we’ve definitely found one or more shortest paths to him—each of the shortest
    paths to `prev_user` with one extra step added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we take a user off the queue and we *have* encountered that user before,
    then either we’ve found another shortest path (in which case we should add it)
    or we’ve found a longer path (in which case we shouldn’t).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When no more users are left on the queue, we’ve explored the whole graph (or,
    at least, the parts of it that are reachable from the starting user) and we’re
    done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can put this all together into a (large) function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s compute all the shortest paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’re finally ready to compute betweenness centrality. For every pair of
    nodes *i* and *j*, we know the *n* shortest paths from *i* to *j*. Then, for each
    of those paths, we just add 1/n to the centrality of each node on that path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As shown in [Figure 22-2](#network_sized_by_betweenness), users 0 and 9 have
    centrality 0 (as neither is on any shortest path between other users), whereas
    3, 4, and 5 all have high centralities (as all three lie on many shortest paths).
  prefs: []
  type: TYPE_NORMAL
- en: '![The DataSciencester network sized by betweenness centrality.](assets/dsf2_2202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-2\. The DataSciencester network sized by betweenness centrality
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Generally the centrality numbers aren’t that meaningful themselves. What we
    care about is how the numbers for each node compare to the numbers for other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Another measure we can look at is *closeness centrality*. First, for each user
    we compute her *farness*, which is the sum of the lengths of her shortest paths
    to each other user. Since we’ve already computed the shortest paths between each
    pair of nodes, it’s easy to add their lengths. (If there are multiple shortest
    paths, they all have the same length, so we can just look at the first one.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'after which it’s very little work to compute closeness centrality ([Figure 22-3](#network_sized_by_closeness)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![The DataSciencester network sized by closeness centrality.](assets/dsf2_2203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-3\. The DataSciencester network sized by closeness centrality
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is much less variation here—even the very central nodes are still pretty
    far from the nodes out on the periphery.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw, computing shortest paths is kind of a pain. For this reason, betweenness
    and closeness centrality aren’t often used on large networks. The less intuitive
    (but generally easier to compute) *eigenvector centrality* is more frequently
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Eigenvector Centrality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to talk about eigenvector centrality, we have to talk about eigenvectors,
    and in order to talk about eigenvectors, we have to talk about matrix multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If *A* is an <math><mrow><mi>n</mi> <mo>×</mo> <mi>m</mi></mrow></math> matrix
    and *B* is an <math><mrow><mi>m</mi> <mo>×</mo> <mi>k</mi></mrow></math> matrix
    (notice that the second dimension of *A* is same as the first dimension of *B*),
    then their product *AB* is the <math><mrow><mi>n</mi> <mo>×</mo> <mi>k</mi></mrow></math>
    matrix whose (*i*,*j*)th entry is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper A Subscript i Baseline 1 Baseline upper B Subscript 1 j
    plus upper A Subscript i Baseline 2 Baseline upper B Subscript 2 j plus ellipsis
    plus upper A Subscript i m Baseline upper B Subscript m j" display="block"><mrow><msub><mi>A</mi>
    <mrow><mi>i</mi><mn>1</mn></mrow></msub> <msub><mi>B</mi> <mrow><mn>1</mn><mi>j</mi></mrow></msub>
    <mo>+</mo> <msub><mi>A</mi> <mrow><mi>i</mi><mn>2</mn></mrow></msub> <msub><mi>B</mi>
    <mrow><mn>2</mn><mi>j</mi></mrow></msub> <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <msub><mi>A</mi>
    <mrow><mi>i</mi><mi>m</mi></mrow></msub> <msub><mi>B</mi> <mrow><mi>m</mi><mi>j</mi></mrow></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: which is just the dot product of the *i*th row of *A* (thought of as a vector)
    with the *j*th column of *B* (also thought of as a vector).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this using the `make_matrix` function from [Chapter 4](ch04.html#linear_algebra):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If we think of an *m*-dimensional vector as an `(m, 1)` matrix, we can multiply
    it by an `(n, m)` matrix to get an `(n, 1)` matrix, which we can then think of
    as an *n*-dimensional vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means another way to think about an `(n, m)` matrix is as a linear mapping
    that transforms *m*-dimensional vectors into *n*-dimensional vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When *A* is a *square* matrix, this operation maps *n*-dimensional vectors to
    other *n*-dimensional vectors. It’s possible that, for some matrix *A* and vector
    *v*, when *A* operates on *v* we get back a scalar multiple of *v*—that is, that
    the result is a vector that points in the same direction as *v*. When this happens
    (and when, in addition, *v* is not a vector of all zeros), we call *v* an *eigenvector*
    of *A*. And we call the multiplier an *eigenvalue*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible way to find an eigenvector of *A* is by picking a starting vector
    *v*, applying `matrix_times_vector`, rescaling the result to have magnitude 1,
    and repeating until the process converges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By construction, the returned `guess` is a vector such that, when you apply
    `matrix_times_vector` to it and rescale it to have length 1, you get back a vector
    very close to itself—which means it’s an eigenvector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all matrices of real numbers have eigenvectors and eigenvalues. For example,
    the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'rotates vectors 90 degrees clockwise, which means that the only vector it maps
    to a scalar multiple of itself is a vector of zeros. If you tried `find_eigenvector(rotate)`
    it would run forever. Even matrices that have eigenvectors can sometimes get stuck
    in cycles. Consider the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This matrix maps any vector `[x, y]` to `[y, x]`. This means that, for example,
    `[1, 1]` is an eigenvector with eigenvalue 1\. However, if you start with a random
    vector with unequal coordinates, `find_eigenvector` will just repeatedly swap
    the coordinates forever. (Not-from-scratch libraries like NumPy use different
    methods that would work in this case.) Nonetheless, when `find_eigenvector` does
    return a result, that result is indeed an eigenvector.
  prefs: []
  type: TYPE_NORMAL
- en: Centrality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How does this help us understand the DataSciencester network? To start, we’ll
    need to represent the connections in our network as an `adjacency_matrix`, whose
    (*i*,*j*)th entry is either 1 (if user *i* and user *j* are friends) or 0 (if
    they’re not):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The eigenvector centrality for each user is then the entry corresponding to
    that user in the eigenvector returned by `find_eigenvector` ([Figure 22-4](#network_sized_by_eigenvector)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The DataSciencester network sized by eigenvector centrality.](assets/dsf2_2204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-4\. The DataSciencester network sized by eigenvector centrality
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For technical reasons that are way beyond the scope of this book, any nonzero
    adjacency matrix necessarily has an eigenvector, all of whose values are nonnegative.
    And fortunately for us, for this `adjacency_matrix` our `find_eigenvector` function
    finds it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Users with high eigenvector centrality should be those who have a lot of connections,
    and connections to people who themselves have high centrality.
  prefs: []
  type: TYPE_NORMAL
- en: Here users 1 and 2 are the most central, as they both have three connections
    to people who are themselves highly central. As we move away from them, people’s
    centralities steadily drop off.
  prefs: []
  type: TYPE_NORMAL
- en: On a network this small, eigenvector centrality behaves somewhat erratically.
    If you try adding or subtracting links, you’ll find that small changes in the
    network can dramatically change the centrality numbers. In a much larger network,
    this would not particularly be the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still haven’t motivated why an eigenvector might lead to a reasonable notion
    of centrality. Being an eigenvector means that if you compute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: the result is a scalar multiple of `eigenvector_centralities`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at how matrix multiplication works, `matrix_times_vector` produces
    a vector whose *i*th element is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: which is precisely the sum of the eigenvector centralities of the users connected
    to user *i*.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, eigenvector centralities are numbers, one per user, such that
    each user’s value is a constant multiple of the sum of his neighbors’ values.
    In this case centrality means being connected to people who themselves are central.
    The more centrality you are directly connected to, the more central you are. This
    is of course a circular definition—eigenvectors are the way of breaking out of
    the circularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of understanding this is by thinking about what `find_eigenvector`
    is doing here. It starts by assigning each node a random centrality. It then repeats
    the following two steps until the process converges:'
  prefs: []
  type: TYPE_NORMAL
- en: Give each node a new centrality score that equals the sum of its neighbors’
    (old) centrality scores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rescale the vector of centralities to have magnitude 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although the mathematics behind it may seem somewhat opaque at first, the calculation
    itself is relatively straightforward (unlike, say, betweenness centrality) and
    is pretty easy to perform on even very large graphs. (At least, if you use a real
    linear algebra library it’s easy to perform on large graphs. If you used our matrices-as-lists
    implementation you’d struggle.)
  prefs: []
  type: TYPE_NORMAL
- en: Directed Graphs and PageRank
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DataSciencester isn’t getting much traction, so the VP of Revenue considers
    pivoting from a friendship model to an endorsement model. It turns out that no
    one particularly cares which data scientists are *friends* with one another, but
    tech recruiters care very much which data scientists are *respected* by other
    data scientists.
  prefs: []
  type: TYPE_NORMAL
- en: In this new model, we’ll track endorsements `(source, target)` that no longer
    represent a reciprocal relationship, but rather that `source` endorses `target`
    as an awesome data scientist ([Figure 22-5](#datasciencester_network_endorsements)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The DataSciencester endorsement network.](assets/dsf2_2205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-5\. The DataSciencester network of endorsements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We’ll need to account for this asymmetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'after which we can easily find the `most_endorsed` data scientists and sell
    that information to recruiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, “number of endorsements” is an easy metric to game. All you need to
    do is create phony accounts and have them endorse you. Or arrange with your friends
    to endorse each other. (As users 0, 1, and 2 seem to have done.)
  prefs: []
  type: TYPE_NORMAL
- en: A better metric would take into account *who* endorses you. Endorsements from
    people who have a lot of endorsements should somehow count more than endorsements
    from people with few endorsements. This is the essence of the PageRank algorithm,
    used by Google to rank websites based on which other websites link to them, which
    other websites link to those, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: (If this sort of reminds you of the idea behind eigenvector centrality, it should.)
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplified version looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a total of 1.0 (or 100%) PageRank in the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initially this PageRank is equally distributed among nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At each step, a large fraction of each node’s PageRank is distributed evenly
    among its outgoing links.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At each step, the remainder of each node’s PageRank is distributed evenly among
    all nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compute page ranks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: PageRank ([Figure 22-6](#network_sized_by_pagerank)) identifies user 4 (Thor)
    as the highest-ranked data scientist.
  prefs: []
  type: TYPE_NORMAL
- en: '![The DataSciencester network sized by PageRank.](assets/dsf2_2206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-6\. The DataSciencester network sized by PageRank
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Even though Thor has fewer endorsements (two) than users 0, 1, and 2, his endorsements
    carry with them rank from their endorsements. Additionally, both of his endorsers
    endorsed only him, which means that he doesn’t have to divide their rank with
    anyone else.
  prefs: []
  type: TYPE_NORMAL
- en: For Further Exploration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are [many other notions of centrality](http://en.wikipedia.org/wiki/Centrality)
    besides the ones we used (although the ones we used are pretty much the most popular
    ones).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NetworkX](http://networkx.github.io/) is a Python library for network analysis.
    It has functions for computing centralities and for visualizing graphs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Gephi](https://gephi.org/) is a love-it/hate-it GUI-based network visualization
    tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
