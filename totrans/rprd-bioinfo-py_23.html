<html><head></head><body><section data-pdf-bookmark="Appendix B. Understanding $PATH and Installing Command-Line Programs" data-type="appendix" epub:type="appendix"><div class="appendix" id="app2_path">&#13;
<h1><span class="label">Appendix B. </span>Understanding $PATH and Installing Command-Line Programs</h1>&#13;
&#13;
&#13;
<p><code>PATH</code> is an environment variable that defines the directories that will be searched for a given command.<a data-primary="environment variables" data-secondary="PATH" data-type="indexterm" id="app2-path"/><a data-primary="PATH environment variable" data-type="indexterm" id="app2-path2"/><a data-primary="command line (Unix)" data-secondary="PATH environment variable" data-type="indexterm" id="app2-path3"/><a data-primary="Unix command line" data-secondary="PATH environment variable" data-type="indexterm" id="app2-path4"/><a data-primary="bash shell" data-secondary="PATH environment variable" data-type="indexterm" id="app2-path5"/>&#13;
That is, if I type <code>foo</code> and there’s no built-in command, shell function, command alias, or program anywhere in my <code>PATH</code> that the shell can execute as <strong><code>foo</code></strong>, I’ll be told this command cannot be found:<a data-primary="errors" data-secondary="command not found" data-type="indexterm" id="idm45963613583864"/></p>&#13;
&#13;
<pre data-type="programlisting">$ foo&#13;
-bash: foo: command not found</pre>&#13;
&#13;
<p>In Windows PowerShell, I can inspect the <code>PATH</code> with <strong><code>echo $env:Path</code></strong>, whereas on Unix platforms I use the command <strong><code>echo $PATH</code></strong>.&#13;
Both paths are printed as a long string with no spaces, listing all the directory names separated by semicolons on Windows or by colons on Unix.&#13;
If the operating system didn’t have some concept of a path, it would have to search <em>every directory</em> on the machine for a given command.&#13;
This could take minutes to hours, so it makes sense to restrict the searching to just a few directories.</p>&#13;
&#13;
<p>Following is my path on my Macintosh.&#13;
Note that I have to put a dollar sign (<code>$</code>) in front of the name to tell my shell (<code>bash</code>) that this is a variable and not the literal string <code>PATH</code>.&#13;
To make this more readable, I’ll use Perl to replace the colons with newlines.&#13;
Note that this command will only work on a Unix command line where Perl is installed:</p>&#13;
&#13;
<pre data-type="programlisting">$ echo $PATH | perl -pe 's/:/\n/g' <a class="co" href="#callout_understanding__path_and_installing_command_line_programs_CO1-1" id="co_understanding__path_and_installing_command_line_programs_CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
/Users/kyclark/.local/bin <a class="co" href="#callout_understanding__path_and_installing_command_line_programs_CO1-2" id="co_understanding__path_and_installing_command_line_programs_CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
/Library/Frameworks/Python.framework/Versions/3.9/bin <a class="co" href="#callout_understanding__path_and_installing_command_line_programs_CO1-3" id="co_understanding__path_and_installing_command_line_programs_CO1-3"><img alt="3" src="assets/3.png"/></a>&#13;
/usr/local/bin <a class="co" href="#callout_understanding__path_and_installing_command_line_programs_CO1-4" id="co_understanding__path_and_installing_command_line_programs_CO1-4"><img alt="4" src="assets/4.png"/></a>&#13;
/usr/bin <a class="co" href="#callout_understanding__path_and_installing_command_line_programs_CO1-5" id="co_understanding__path_and_installing_command_line_programs_CO1-5"><img alt="5" src="assets/5.png"/></a>&#13;
/bin&#13;
/usr/sbin&#13;
/sbin</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_understanding__path_and_installing_command_line_programs_CO1-1" id="callout_understanding__path_and_installing_command_line_programs_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The Perl substitute (<code>s//</code>) command replaces the first pattern (<code>:</code>) with the second (<code>\n</code>) globally (<code>g</code>).</p></dd>&#13;
<dt><a class="co" href="#co_understanding__path_and_installing_command_line_programs_CO1-2" id="callout_understanding__path_and_installing_command_line_programs_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This is a custom directory I usually create for installing my own programs.</p></dd>&#13;
<dt><a class="co" href="#co_understanding__path_and_installing_command_line_programs_CO1-3" id="callout_understanding__path_and_installing_command_line_programs_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This is where Python installed itself.</p></dd>&#13;
<dt><a class="co" href="#co_understanding__path_and_installing_command_line_programs_CO1-4" id="callout_understanding__path_and_installing_command_line_programs_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>This is a standard directory for user-installed software.</p></dd>&#13;
<dt><a class="co" href="#co_understanding__path_and_installing_command_line_programs_CO1-5" id="callout_understanding__path_and_installing_command_line_programs_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The rest are more standard directories for finding programs.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The directories will be searched in the order they are defined, so the order can be quite important. For instance, the Python path is listed before system paths so that when I type <strong><code>python3</code></strong> it will use the version found in my local Python directory <em>before</em> one that might have been preinstalled on my system.</p>&#13;
</div>&#13;
&#13;
<p>Notice that all the directory names in my <code>PATH</code> end in <em>bin</em>.&#13;
This is short for <em>binaries</em> and comes from the fact that many programs exist in a binary form.&#13;
For example, the source code for a C program is written in a pseudo-English language that is compiled into a machine-readable executable file.&#13;
The contents of this file are binary-encoded instructions that the operating system can execute.</p>&#13;
&#13;
<p>Python programs, by contrast, are usually installed as their source code files, which are executed by Python at runtime.<a data-primary="Python" data-secondary="installing Python programs" data-type="indexterm" id="idm45963613545880"/>&#13;
If you want to globally install one of your Python programs, I suggest you copy it to one of the directories that are already listed in your <code>PATH</code>.&#13;
For instance, <em>/usr/local/bin</em> is a typical directory for <em>local</em> installations of software by the user.&#13;
It’s such a common directory that it’s normally present in the <code>PATH</code>.&#13;
If you are working on your personal machine, like a laptop, where you have administrator privileges, you should be able to write new files into this location.</p>&#13;
&#13;
<p>For instance, if I wanted to be able to run the <code>dna.py</code> program from <a data-type="xref" href="ch01.html#ch01">Chapter 1</a> without providing the full path to the source code, I could copy it to a location in my <code>PATH</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cp 01_dna/dna.py /usr/local/bin</pre>&#13;
&#13;
<p>You may not have sufficient permissions to do this, however.&#13;
Unix systems were designed from the beginning to be <em>multitenant</em> operating systems, meaning that they support many different people using the system concurrently.&#13;
It’s important to keep users from writing and deleting files they shouldn’t, and so the OS may prevent you from writing <code>dna.py</code> to a directory that you don’t own.&#13;
If, for instance, you are <span class="keep-together">working</span> on a shared high-performance computing (HPC) system at a university, you certainly won’t have such privileges.</p>&#13;
&#13;
<p>When you cannot install into system directories, it’s easiest to create a location in your <code>HOME</code> directory for such files.&#13;
On my laptop, this is my <code>HOME</code> directory:</p>&#13;
&#13;
<pre data-type="programlisting">$ echo $HOME&#13;
/Users/kyclark</pre>&#13;
&#13;
<p>On almost all my systems, I create a <em>$HOME/.local</em> directory for installing programs.&#13;
Most shells interpret the tilde (<code>~</code>) as <code>HOME</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir ~/.local</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>By convention, files and directories that have names starting with a dot are normally hidden<a data-primary="dotfiles (.&lt;filename&gt;)" data-type="indexterm" id="idm45963613531192"/><a data-primary=".&lt;filename&gt; (dotfiles)" data-primary-sortas="# dotfiles" data-type="indexterm" id="idm45963613530520"/><a data-primary="Unix command line" data-secondary="ls command to list directory contents" data-type="indexterm" id="idm45963613529576"/><a data-primary="command line (Unix)" data-secondary="ls command to list directory contents" data-type="indexterm" id="idm45963613528616"/><a data-primary="ls command to list directory contents" data-type="indexterm" id="idm45963613527656"/> by the <code>ls</code> command. You can use <strong><code>ls -a</code></strong> to list <em>all</em> the contents of a directory. You may notice many other <em>dotfiles</em> that are used by various programs to persist options and program state. I like to call this <em>.local</em> so I won’t normally see it in my directory listing.</p>&#13;
</div>&#13;
&#13;
<p>Creating a directory in your <code>HOME</code> for software installations is especially useful when compiling programs from source, a very common operation in bioinformatics.&#13;
Most installations of this sort begin by using a <code>configure</code> program to gather information about your system, such as the location of your C compiler and such.&#13;
This program almost always has a <code>--prefix</code> option that I’ll set to this directory:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./configure --prefix=$HOME/.local</pre>&#13;
&#13;
<p>The resulting installation will put the binary compiled files into <em>$HOME/.local/bin</em>.&#13;
It might also install header files and manual pages and other supporting data into other directories in <em>$HOME/.local</em>.</p>&#13;
&#13;
<p>Wherever you decide to install local programs, you’ll need to ensure that your <code>PATH</code> is updated to search in that directory in addition to the others.&#13;
I tend to use the <code>bash</code> shell, and one of the dotfiles in my <code>HOME</code> is a file called <em>.bashrc</em> (or sometimes <em>.bash_profile</em> or even <em>.profile</em>).&#13;
I can add this line to put my custom directory first in the <code>PATH</code>:</p>&#13;
&#13;
<pre data-type="programlisting">export PATH=$HOME/.local/bin:$PATH</pre>&#13;
&#13;
<p>You may need something slightly different if you are using a different shell.&#13;
Recently macOS started using <code>zsh</code> (Z shell) as the default shell, or your HPC system might use another shell.&#13;
They all have the idea of <code>PATH</code> and all allow you to customize this in some manner.&#13;
On Windows, you can use this command to append the directory to your path:</p>&#13;
&#13;
<pre data-type="programlisting">&gt; $env:Path += ";~/.local/bin"</pre>&#13;
&#13;
<p>Here is how I can make the directory and copy the program:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir -p ~/.local/bin&#13;
$ cp 01_dna/dna.py ~/.local/bin</pre>&#13;
&#13;
<p>I should now be able to execute <strong><code>dna.py</code></strong> from any location on a Unix machine:</p>&#13;
&#13;
<pre data-type="programlisting">$ dna.py&#13;
usage: dna.py [-h] DNA&#13;
dna.py: error: the following arguments are required: DNA</pre>&#13;
&#13;
<p>Windows shells like <code>cmd.exe</code> and PowerShell don’t read and execute the shebang like Unix shells, so you are required to include the command <strong><code>python.exe</code></strong> or <strong><code>python3.exe</code></strong> before the program name:</p>&#13;
&#13;
<pre data-type="programlisting">&gt; python.exe C:\Users\kyclark\.local\bin\dna.py&#13;
usage: dna.py [-h] DNA&#13;
dna.py: error: the following arguments are required: DNA</pre>&#13;
<div data-type="warning" epub:type="warning">&#13;
<p>Be sure <code>python.exe --version</code> shows that you are using version 3 and not version 2.<a data-primary="Python" data-secondary="versions of Python" data-type="indexterm" id="idm45963613505320"/> You may need to install the latest version of Python. I have only shown Windows commands using <code>python.exe</code>, assuming this means Python 3, but you may need to use <code>python3.exe</code>, depending on your system.<a data-startref="app2-path" data-type="indexterm" id="idm45963613503176"/><a data-startref="app2-path2" data-type="indexterm" id="idm45963613502504"/><a data-startref="app2-path3" data-type="indexterm" id="idm45963613501832"/><a data-startref="app2-path4" data-type="indexterm" id="idm45963613501160"/><a data-startref="app2-path5" data-type="indexterm" id="idm45963613500488"/></p>&#13;
</div>&#13;
</div></section></body></html>