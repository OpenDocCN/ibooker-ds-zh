- en: 'Chapter 1\. Tetranucleotide Frequency: Counting Things'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章。四核苷酸频率：计数事物
- en: Counting the bases in DNA is perhaps the “Hello, World!” of bioinformatics.
    [The Rosalind DNA challenge](https://oreil.ly/maR31) describes a program that
    will take a sequence of DNA and print a count of how many *A*s, *C*s, *G*s, and
    *T*s are found. There are surprisingly many ways to count things in Python, and
    I’ll explore what the language has to offer. I’ll also demonstrate how to write
    a well-structured, documented program that validates its arguments as well as
    how to write and run tests to ensure the program works correctly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在生物信息学中，计算DNA中的碱基可能是“Hello, World!”。[Rosalind DNA挑战](https://oreil.ly/maR31)描述了一个程序，它将获取一段DNA序列并打印出发现的*A*、*C*、*G*和*T*的计数。在Python中计数事物有很多令人惊讶的方式，我将探索这种语言提供的内容。我还将演示如何编写结构良好、有文档化的程序，验证其参数以及编写和运行测试以确保程序正常工作。
- en: 'In this chapter, you’ll learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到：
- en: How to start a new program using `new.py`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`new.py`开始一个新程序
- en: How to define and validate command-line arguments using `argparse`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义和验证命令行参数使用`argparse`
- en: How to run a test suite using `pytest`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`pytest`运行测试套件
- en: How to iterate the characters of a string
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何迭代字符串的字符
- en: Ways to count elements in a collection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算集合中元素的方法
- en: How to create a decision tree using `if`/`elif` statements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`if`/`elif`语句创建决策树
- en: How to format strings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何格式化字符串
- en: Getting Started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: 'Before you start, be sure you have read [“Getting the Code and Tests”](preface01.html#gettingCodeandTests)
    in the Preface. Once you have a local copy of the code repository, change into
    the *01_dna* directory:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保您已阅读了[“获取代码和测试”](preface01.html#gettingCodeandTests)部分。一旦您有了代码仓库的本地副本，请切换到*01_dna*目录：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here you’ll find several `solution*.py` programs along with tests and input
    data you can use to see if the programs work correctly. To get an idea of how
    your program should work, start by copying the first solution to a program called
    `dna.py`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里您会找到几个`solution*.py`程序以及您可以用来查看程序是否正确工作的测试和输入数据。要了解您的程序应如何工作的概念，请从第一个解决方案复制到一个名为`dna.py`的程序：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now run the program with no arguments, or with the `-h` or `--help` flags.
    It will print usage documentation (note that *usage* is the first word of the
    output):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以无参数或使用`-h`或`--help`标志运行程序。它将打印使用文档（注意*usage*是输出的第一个词）：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you get an error like “permission denied,” you may need to run **`chmod +x
    dna.py`** to change the mode of the program by adding the executable bit.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到“权限被拒绝”的错误，请尝试运行**`chmod +x dna.py`**以添加可执行权限。
- en: This is one of the first elements of reproducibility. *Programs should provide
    documentation on how they work.* While it’s common to have something like a *README*
    file or even a paper to describe a program, the program itself must provide documentation
    on its parameters and outputs. I’ll show you how to use the `argparse` module
    to define and validate the arguments as well as to generate the documentation,
    meaning that there is no possibility that the usage statement generated by the
    program could be incorrect. Contrast this with how *README* files and change logs
    and the like can quickly fall out of sync with a program’s development, and I
    hope you’ll appreciate that this sort of documentation is quite effective.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是复制性的首要元素之一。*程序应提供关于其运行方式的文档。*虽然通常有类似于*README*文件或甚至是论文来描述一个程序，但程序本身必须提供关于其参数和输出的文档。我将向您展示如何使用`argparse`模块定义和验证参数，并生成文档，这意味着由程序生成的使用说明不可能是错误的。与*README*文件和更改日志等可能很快与程序开发脱节的情况形成对比，希望您能欣赏到这种文档的效果。
- en: 'You can see from the usage line that the program expects something like `DNA`
    as an argument, so let’s give it a sequence. As described on the Rosalind page,
    the program prints the counts for each of the bases *A*, *C*, *G*, and *T*, in
    that order and separated by a single space each:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从使用行看出，程序期望类似`DNA`的参数，因此让我们给它一个序列。正如在Rosalind页面上描述的那样，该程序按照顺序和用单个空格分隔的方式打印每个碱基*A*、*C*、*G*和*T*的计数：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you go to solve a challenge on the Rosalind.info website, the input for
    your program will be provided as a downloaded file; therefore, I’ll write the
    program so that it will also read the contents of a file. I can use the command
    **`cat`** (for *concatenate*) to print the contents of one of the files in the
    *tests/inputs* directory:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你前往解决**Rosalind.info**网站上的挑战时，程序的输入将作为下载文件提供；因此，我将编写程序以便它也能读取文件内容。我可以使用**`cat`**（*concatenate*的缩写）命令来打印*tests/inputs*目录中一个文件的内容。
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the same sequence shown in the example on the website. Accordingly,
    I know that the output of the program should be this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在网站示例中显示的相同序列。因此，我知道程序的输出应该是这样的：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Throughout the book, I’ll use the `pytest` tool to run the tests that ensure
    programs work as expected. When I run the command **`pytest`**, it will recursively
    search the current directory for tests and functions that look like tests. Note
    that you may need to run **`python3 -m pytest`** or **`pytest.exe`** if you are
    on Windows. Run this now, and you should see something like the following to indicate
    that the program passes all four of the tests found in the *tests/dna_test.py*
    file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将使用`pytest`工具来运行确保程序按预期工作的测试。当我运行**`pytest`**命令时，它将递归搜索当前目录以寻找看起来像测试的测试和函数。请注意，如果你在Windows上，你可能需要运行**`python3
    -m pytest`**或**`pytest.exe`**。现在运行它，你应该会看到类似以下的东西，表明程序通过了*tests/dna_test.py*文件中的所有四个测试：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A key element to testing software is that you *run your program with known inputs
    and verify that it produces the correct output*. While that may seem like an obvious
    idea, I’ve had to object to “testing” schemes that simply ran programs but never
    verified that they behaved correctly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的关键要素是*使用已知的输入运行程序并验证它是否产生正确的输出*。尽管这似乎是一个显而易见的想法，但我曾经反对仅仅运行程序而不验证其正确行为的“测试”方案。
- en: Creating the Program Using new.py
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`new.py`创建程序
- en: 'If you copied one of the solutions, as shown in the preceding section, then
    delete that program so you can start from scratch:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你复制了前面部分显示的解决方案之一，那么删除该程序，以便你可以从头开始：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Without looking at my solutions yet, I want you to try to solve this problem.
    If you think you have all the information you need, feel free to jump ahead and
    write your own version of `dna.py`, using `pytest` to run the provided tests.
    Keep reading if you want to go step-by-step with me to learn how to write the
    program and run the tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我的解决方案之前，请尝试解决这个问题。如果你认为你已经获得了所有需要的信息，请随意提前编写你自己版本的`dna.py`，使用`pytest`来运行提供的测试。如果你想一步步地与我学习如何编写程序和运行测试，请继续阅读。
- en: Every program in this book will accept some command-line argument(s) and create
    some output, like text on the command line or new files. I’ll always use the `new.py`
    program described in the Preface to start, but this is not a requirement. You
    can write your programs however you like, starting from whatever point you want,
    but your programs are expected to have the same features, such as generating usage
    statements and properly validating arguments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的每个程序都将接受一些命令行参数并创建一些输出，如命令行上的文本或新文件。我总是使用前言中描述的`new.py`程序来启动，但这不是必需的。你可以按照自己的喜好编写程序，从任何你想要的地方开始，但是你的程序应该具有相同的特性，如生成使用说明和正确验证参数。
- en: 'Create your `dna.py` program in the *01_dna* directory, as this contains the
    test files for the program. Here is how I will start the `dna.py` program. The
    `--purpose` argument will be used in the program’s documentation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在*01_dna*目录中创建你的`dna.py`程序，因为这包含程序的测试文件。这是我如何启动`dna.py`程序的方式。`--purpose`参数将用于程序的文档：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you run the new `dna.py` program, you will see that it defines many different
    types of arguments common to command-line programs:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行新的`dna.py`程序，你会看到它定义了许多与命令行程序常见的不同类型的参数：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-1)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-1)'
- en: The `--purpose` from `new.py` is used here to describe the program.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用`new.py`的`--purpose`来描述程序。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-2)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-2)'
- en: The program accepts a single positional string argument.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序接受一个单一的位置字符串参数。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-3)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-3)'
- en: The `-h` and `--help` flags are automatically added by `argparse` and will trigger
    the usage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`-h` 和 `--help` 标志是由 `argparse` 自动添加的，将触发使用说明。'
- en: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-4)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-4)'
- en: This is a named option with short (`-a`) and long (`--arg`) names for a string
    value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个命名选项，具有短 (`-a`) 和长 (`--arg`) 名称，用于字符串值。
- en: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-5)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-5)'
- en: This is a named option with short (`-i`) and long (`--int`) names for an integer
    value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个命名选项，具有短 (`-i`) 和长 (`--int`) 名称，用于整数值。
- en: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-6)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-6)'
- en: This is a named option with short (`-f`) and long (`--file`) names for a file
    argument.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个命名选项，具有短 (`-f`) 和长 (`--file`) 名称，用于文件参数。
- en: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-7)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO1-7)'
- en: This is a Boolean flag that will be `True` when either `-o` or `--on` is present
    and `False` when they are absent.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个布尔标志，当 `-o` 或 `--on` 存在时将为 `True`，当它们不存在时为 `False`。
- en: 'This program only needs the `str` positional argument, and you can use `DNA`
    for the `metavar` value to give some indication to the user as to the meaning
    of the argument. Delete all the other parameters. Note that you never define the
    `-h` and `--help` flags, as `argparse` uses those internally to respond to usage
    requests. See if you can modify your program until it will produce the usage that
    follows (if you can’t produce the usage just yet, don’t worry, I’ll show this
    in the next section):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序只需要 `str` 位置参数，并且你可以使用 `DNA` 作为 `metavar` 值，以便向用户指示参数的含义。删除所有其他参数。请注意，永远不要定义
    `-h` 和 `--help` 标志，因为 `argparse` 在内部使用它们来响应使用请求。看看你是否可以修改你的程序，直到它生成以下的使用情况（如果你暂时无法生成使用情况，请不要担心，我将在下一节中展示这个）：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you can manage to get this working, I’d like to point out that this program
    will accept exactly one positional argument. If you try running it with any other
    number of arguments, the program will immediately halt and print an error message:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够使其正常工作，我想指出这个程序将只接受一个位置参数。如果尝试使用其他数量的参数运行它，程序将立即停止并打印错误消息：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Likewise, the program will reject any unknown flags or options. With very few
    lines of code, you have built a documented program that validates the arguments
    to the program. That’s a very basic and important step toward reproducibility.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，该程序将拒绝任何未知的标志或选项。只需几行代码，你就建立了一个文档良好的程序，用于验证程序的参数。这是实现可重现性的一个非常基本且重要的步骤。
- en: Using argparse
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 argparse
- en: The program created by `new.py` uses the `argparse` module to define the program’s
    parameters, validate that the arguments are correct, and create the usage documentation
    for the user. The `argparse` module is a *standard* Python module, which means
    it’s always present. Other modules can also do these things, and you are free
    to use any method you like to handle this aspect of your program. Just be sure
    your programs can pass the tests.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`new.py` 创建的程序使用 `argparse` 模块来定义程序的参数，验证参数的正确性，并为用户创建使用文档。`argparse` 模块是 Python
    的*标准*模块，这意味着它总是存在的。其他模块也可以执行这些操作，你可以自由选择任何方法来处理程序的这个方面。只需确保你的程序能够通过测试。'
- en: 'I wrote a version of `new.py` for *Tiny Python Projects* that you can find
    in [the *bin* directory of that book’s GitHub repo](https://oreil.ly/7romb). That
    version is somewhat simpler than the version I want you to use. I’ll start by
    showing you a version of `dna.py` created using this earlier version of `new.py`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我为 *Tiny Python Projects* 写了一个 `new.py` 的版本，你可以在[该书的 GitHub 仓库的 *bin* 目录](https://oreil.ly/7romb)找到。那个版本比我要求你使用的版本要简单一些。我将首先向你展示使用这个早期版本
    `new.py` 创建的 `dna.py` 的一个版本：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-1)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-1)'
- en: The colloquial *shebang* (`#!`) tells the operating system to use the `env`
    command (*environment*) to find `python3` to execute the rest of the program.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 俗称的*shebang*（`#!`）告诉操作系统使用`env`命令（*environment*）来找到`python3`以执行程序的其余部分。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-2)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-2)'
- en: This is a *docstring* (documentation string) for the program or module as a
    whole.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个程序或模块的*文档字符串*（documentation string）。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-3)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-3)'
- en: I import the `argparse` module to handle command-line arguments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我导入`argparse`模块来处理命令行参数。
- en: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-4)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-4)'
- en: I always define a `get_args()` function to handle the `argparse` code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是定义一个`get_args()`函数来处理`argparse`代码。
- en: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-5)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-5)'
- en: This is a docstring for a function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数的文档字符串。
- en: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-6)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-6)'
- en: The `parser` object is used to define the program’s parameters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`parser`对象用于定义程序的参数。'
- en: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-7)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-7)'
- en: I define a `dna` argument, which will be positional because the name `dna` *does
    not* start with a dash. The `metavar` is a short description of the argument that
    will appear in the short usage. No other arguments are needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个`dna`参数，它将是位置参数，因为名称`dna`*不*以破折号开头。`metavar`是参数的简短描述，将出现在短使用说明中。不需要其他参数。
- en: '[![8](assets/8.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-8)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-8)'
- en: The function returns the results of parsing the arguments. The help flags or
    any problems with the arguments will cause `argparse` to print a usage statement/error
    messages and exit the program.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回解析参数的结果。帮助标志或参数错误将导致`argparse`打印使用说明或错误消息并退出程序。
- en: '[![9](assets/9.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-9)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-9)'
- en: All programs in the book will always start in the `main()` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有程序都将始于`main()`函数。
- en: '[![10](assets/10.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-10)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-10)'
- en: The first step in `main()` will always be to call `get_args()`. If this call
    succeeds, then the arguments must have been valid.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`中的第一步始终是调用`get_args()`。如果此调用成功，则参数必定是有效的。'
- en: '[![11](assets/11.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-11)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-11)'
- en: The `DNA` value is available in the `args.dna` attribute, as this is the name
    of the argument.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`DNA`值可以通过`args.dna`属性获得，因为这是参数的名称。'
- en: '[![12](assets/12.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-12)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO2-12)'
- en: This is a common idiom in Python programs to detect when the program is being
    executed (as opposed to being imported) and to execute the `main()` function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python程序中的常见习语，用于检测程序是否正在执行（而不是被导入），并执行`main()`函数。
- en: The shebang line is used by the Unix shell when the program is invoked as a
    program, like `./dna.py`. It does not work on Windows, where you are required
    to run **`python.exe dna.py`** to execute the program.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当以`./dna.py`这样的形式调用程序时，Unix shell会使用shebang行。在Windows上，你需要运行**`python.exe dna.py`**来执行该程序。
- en: While this code works completely adequately, the value returned from `get_args()`
    is an `argparse.Namespace` object that is *dynamically generated* when the program
    runs. That is, I am using code like `parser.add_argument()` to modify the structure
    of this object *at runtime*, so Python is unable to know positively *at compile
    time* what attributes will be available in the parsed arguments or what their
    types would be. While it may be obvious to you that there can only be a single,
    required string argument, there is not enough information in the code for Python
    to discern this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码完全正常工作，但从`get_args()`返回的值是一个在程序运行时*动态生成*的`argparse.Namespace`对象。也就是说，我正在使用像`parser.add_argument()`这样的代码在运行时修改这个对象的结构，因此Python无法在*编译时*确定解析参数中会有哪些属性或它们的类型。虽然你可能很明显只有一个必需的字符串参数，但代码中没有足够的信息让Python能够辨别这一点。
- en: To *compile* a program is to turn it into the machine code that a computer can
    execute. Some languages, like C, must be compiled separately before they can be
    run. Python programs are often compiled and run in one step, but there is still
    a compilation phase. Some errors can be caught at compilation, and others don’t
    turn up until runtime. For instance, syntax errors will prevent compilation. It
    is preferable to have compile-time errors over runtime errors.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 编译程序是将其转换为计算机可以执行的机器代码。某些语言（如C）必须在运行之前单独编译。Python程序通常在一步中编译并运行，但仍有编译阶段。有些错误可以在编译时捕获，而其他错误则直到运行时才会出现。例如，语法错误会阻止编译。最好在编译时有错误，而不是在运行时有错误。
- en: 'To see why this could be a problem, I’ll alter the `main()` function to introduce
    a type error. That is, I’ll intentionally misuse the *type* of the `args.dna`
    value. Unless otherwise stated, all argument values returned from the command
    line by `argparse` are strings. If I try to divide the string `args.dna` by the
    integer value 2, Python will raise an exception and crash the program at runtime:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么这可能是个问题，我将修改`main()`函数，引入一个类型错误。也就是说，我会故意误用`args.dna`值的*类型*。除非另有说明，通过`argparse`从命令行返回的所有参数值都是字符串。如果我试图将字符串`args.dna`除以整数值2，Python将引发异常并在运行时崩溃程序：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO3-1)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO3-1)'
- en: Dividing a string by an integer will produce an exception.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串除以整数会产生一个异常。
- en: 'If I run the program, it crashes as expected:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我运行程序，它会如预期地崩溃：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our big squishy brains know that this is an inevitable error waiting to happen,
    but Python can’t see the problem. What I need is a *static* definition of the
    arguments that cannot be modified when the program is run. Read on to see how
    type annotations and other tools can detect these sorts of bugs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大脑明白这是一个不可避免的错误，但Python看不到这个问题。我需要的是在程序运行时无法修改的*静态*参数定义。继续阅读，了解类型注解和其他工具如何检测这类错误。
- en: Tools for Finding Errors in the Code
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找代码中错误的工具
- en: The goal here is to write correct, reproducible programs in Python. Are there
    ways to spot and avoid problems like misusing a string in a numeric operation?
    The `python3` interpreter found no problems that prevented me from running the
    code. That is, the program is syntactically correct, so the code in the preceding
    section produces a *runtime error* because the error happens only when I execute
    the program. Years back I worked in a group where we joked, “If it compiles, ship
    it!” This is clearly a myopic approach when coding in Python.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是在Python中编写正确、可复现的程序。有没有办法发现并避免像在数值运算中误用字符串这样的问题？`python3`解释器没有找到阻止我运行代码的问题。也就是说，程序在语法上是正确的，因此在前一节中的代码产生了一个*运行时错误*，因为只有当我执行程序时才会出错。多年前我曾在一个团队工作，我们开玩笑说：“如果能编译通过，就发布吧！”这显然是一种短视的编码方式。
- en: 'I can use tools like linters and type checkers to find some kinds of problems
    in code. *Linters* are tools that check for program style and many kinds of errors
    beyond bad syntax. The [`pylint` tool](https://www.pylint.org) is a popular Python
    linter that I use almost every day. Can it find this problem? Apparently not,
    as it gives the biggest of thumbs-ups:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用诸如linters和类型检查器之类的工具来找出代码中的一些问题。*Linters*是一种检查程序风格和许多种错误的工具，超越了简单的语法错误。[`pylint`工具](https://www.pylint.org)是一个流行的Python
    linter，我几乎每天都在使用。它能找到这个问题吗？显然不能，因为它给出了最大的赞扬：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The [`flake8`](https://oreil.ly/b3Qtj) tool is another linter that I often use
    in combination with `pylint`, as it will report different kinds of errors. When
    I run `flake8 dna.py`, I get no output, which means it found no errors to report.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[`flake8`](https://oreil.ly/b3Qtj)工具是另一个我经常与`pylint`结合使用的检查器，因为它会报告不同类型的错误。当我运行`flake8
    dna.py`时，没有输出，这意味着它没有发现要报告的错误。'
- en: The [`mypy`](http://mypy-lang.org) tool is a static *type checker* for Python,
    meaning it is designed to find misused types such as trying to divide a string
    by a number. Neither `pylint` nor `flake8` is designed to catch type errors, so
    I cannot be legitimately surprised they missed the bug. So what does `mypy` have
    to say?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mypy`](http://mypy-lang.org)工具是 Python 的静态*类型检查器*，意味着它旨在发现诸如试图将字符串除以数字等错误使用类型的问题。`pylint`和`flake8`都不会捕获类型错误，所以我不能合理地惊讶它们错过了这个错误。那么`mypy`有什么要说的呢？'
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Well, that’s just a little disappointing; however, you must understand that
    `mypy` is failing to report a problem *because there is no type information*.
    That is, `mypy` has no information to say that dividing `args.dna` by 2 is wrong.
    I’ll fix that shortly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这有点令人失望；然而，你必须理解，`mypy`未能报告问题*是因为没有类型信息*。也就是说，`mypy`没有信息来表明将`args.dna`除以 2
    是错误的。我很快就会修复这个问题。
- en: Introducing Named Tuples
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入命名元组
- en: To avoid the problems with dynamically generated objects, all of the programs
    in this book will use a named tuple data structure to statically define the arguments
    from `get_args()`. *Tuples* are essentially immutable lists, and they are often
    used to represent record-type data structures in Python. There’s quite a bit to
    unpack with all that, so let’s step back to lists.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免动态生成对象带来的问题，本书中的所有程序都将使用命名元组数据结构来静态定义从`get_args()`获取的参数。*元组*本质上是不可变的列表，通常用于表示
    Python 中的记录型数据结构。这其中有很多内容需要理解，所以让我们先回到列表。
- en: To start, *lists* are ordered sequences of items. The items can be heterogeneous;
    in theory, this means all the items can be of different types, but in practice,
    mixing types is often a bad idea. I’ll use the `python3` REPL to demonstrate some
    aspects of lists. I recommend you use **`help(list)`** to read the documentation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*列表*是有序的项目序列。项目可以是异构的；理论上来说，这意味着所有项目可以是不同类型的，但实际上，混合类型通常是一个坏主意。我将使用`python3`
    REPL来演示列表的一些方面。我建议你使用**`help(list)`**阅读文档。
- en: 'Use empty square brackets (`[]`) to create an empty list that will hold some
    sequences:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空方括号（`[]`）创建一个空列表，用于保存一些序列：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `list()` function will also create a new, empty list:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`函数还将创建一个新的空列表：'
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Verify that this is a list by using the `type()` function to return the variable’s
    type:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`type()`函数返回变量的类型来验证这是一个列表：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lists have methods that will add values to the end of the list, like `list.append()`
    to add one value:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表有一些方法可以在列表末尾添加值，比如`list.append()`来添加一个值：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'and `list.extend()` to add multiple values:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 和`list.extend()`来添加多个值：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you type the variable by itself in the REPL, it will be evaluated and stringified
    into a textual representation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 REPL 中仅键入变量本身，它将被评估并转换为文本表示形式：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is basically the same thing that happens when you `print()` a variable:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是当你`print()`一个变量时发生的事情：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can modify any of the values *in-place* using the index. Remember that
    all indexing in Python is 0-based, so 0 is the first element. Change the first
    sequence to be `TCA`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用索引*原地*修改任何值。请记住，Python 中的所有索引都是从 0 开始的，因此 0 是第一个元素。将第一个序列改为`TCA`：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Verify that it was changed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 验证已更改：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Like lists, tuples are ordered sequences of possibly heterogeneous objects.
    Whenever you put commas between items in a series, you are creating a tuple:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表类似，元组是一种可能异构对象的有序序列。当你在一系列项目之间放置逗号时，你就创建了一个元组：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It’s typical to place parentheses around tuple values to make this more explicit:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的做法是在元组值周围加上括号，以使其更加明确：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Unlike lists, tuples cannot be changed once they are created. If you read `help(tuple)`,
    you will see that a tuple is a *built-in immutable sequence*, so I cannot add
    values:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不像列表，元组一旦创建就无法更改。如果你阅读`help(tuple)`，你会看到元组是一个*内置的不可变序列*，所以我无法添加值：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'or modify existing values:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或修改现有的值：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It’s fairly common in Python to use tuples to represent records. For instance,
    I might represent a `Sequence` having a unique ID and a string of bases:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，使用元组表示记录是相当常见的。例如，我可以表示一个`Sequence`，它有一个唯一的 ID 和一个碱基字符串：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'While it’s possible to use indexing to get the values from a tuple just as
    with lists, that’s awkward and error-prone. *Named tuples* allow me to assign
    names to the fields, which makes them more ergonomic to use. To use named tuples,
    I can import the `namedtuple()` function from the `collections` module:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以像使用列表一样使用索引从元组中获取值，但这样做很麻烦且容易出错。*命名元组*允许我为字段指定名称，这使得它们更加易于使用。要使用命名元组，可以从`collections`模块导入`namedtuple()`函数：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As shown in [Figure 1-2](#fig_1.2), I use the `namedtuple()` function to create
    the idea of a `Sequence` that has fields for the `id` and the `seq`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图1-2](#fig_1.2)所示，我使用`namedtuple()`函数创建了一个具有`id`和`seq`字段的`Sequence`的概念：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![mpfb 0102](assets/mpfb_0102.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0102](assets/mpfb_0102.png)'
- en: Figure 1-2\. The `namedtuple()` function generates a way to make objects of
    the class `Sequence` that have the fields `id` and `seq`
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-2\. `namedtuple()`函数生成一种方法，用于创建具有`id`和`seq`字段的`Sequence`类对象
- en: What exactly is `Sequence` here?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Sequence`究竟是什么？
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I’ve just created a new type. You might call the `Sequence()` function a *factory*
    because it’s a function used to generate new objects of the class `Sequence`.
    It’s a common naming convention for these factory functions and class names to
    be TitleCased to set them apart.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚创造了一个新的类型。你可以称`Sequence()`函数为*工厂*，因为它是用来生成`Sequence`类的新对象的函数。这是这些工厂函数和类名常见的命名约定，用以区分它们。
- en: 'Just as I can use the `list()` function to create a new list, I can use the
    `Sequence()` function to create a new `Sequence` object. I can pass the `id` and
    `seq` values *positionally* to match the order they are defined in the class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我可以使用`list()`函数创建一个新的列表一样，我可以使用`Sequence()`函数创建一个新的`Sequence`对象。我可以按位置传递`id`和`seq`值，以匹配它们在类中定义的顺序：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or I can use the field names and pass them as key/value pairs in any order
    I like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我可以使用字段名称，并按任意顺序将它们作为键/值对传递：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'While it’s possible to use indexes to access the ID and sequence:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以使用索引访问ID和序列：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '…the whole point of named tuples is to use the field names:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: …命名元组的整个意义在于使用字段名称：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The record’s values remain immutable:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的值保持不可变：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: I often want a guarantee that a value cannot be accidentally changed in my code.
    Python doesn’t have a way to declare that a variable is *constant* or immutable.
    Tuples are by default immutable, and I think it makes sense to represent the arguments
    to a program using a data structure that cannot be altered. The inputs are sacrosanct
    and should (almost) never be modified.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常希望在我的代码中保证一个值不会被意外改变。Python没有声明变量为*常量*或不可变的方式。元组默认是不可变的，我认为用一个不能被修改的数据结构来表示程序的输入是有道理的。这些输入是神圣的，几乎不应该被修改。
- en: Adding Types to Named Tuples
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为命名元组添加类型
- en: 'As nice as `namedtuple()` is, I can make it even better by importing the `NamedTuple`
    class from the `typing` module to use as the base class for the `Sequence`. Additionally,
    I can assign *types* to the fields using this syntax. Note the need to use an
    empty line in the REPL to indicate that the block is complete:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`namedtuple()`很好用，但通过从`typing`模块导入`NamedTuple`类，可以使其变得更好。此外，可以使用此语法为字段分配*类型*。请注意，在REPL中需要使用空行来指示块已完成：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `...` you see are line continuations. The REPL is showing that what’s been
    entered so far is not a complete expression. You need to enter a blank line to
    let the REPL know that you’re done with the code block.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的`...`是行继续符。REPL显示到目前为止输入的内容不是完整的表达式。您需要输入一个空行来告诉REPL您已经完成了代码块。
- en: 'As with the `namedtuple()` method, `Sequence` is a new type:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与`namedtuple()`方法一样，`Sequence`是一个新类型：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The code to instantiate a new `Sequence` object is the same:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个新的`Sequence`对象的代码是相同的：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'I can still access the fields by names:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然可以通过名称访问字段：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since I defined that both fields have `str` types, you might assume this would
    *not* work:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我定义了两个字段都是`str`类型，你可能会认为这样*不*会起作用：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I’m sorry to tell you that Python itself ignores the type information. You
    can see the `seq` field that I hoped would be a `str` is actually a `float`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 很抱歉告诉你，Python本身会忽略类型信息。你可以看到我希望是`str`的`seq`字段实际上是一个`float`：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So how does this help us? It doesn’t help me in the REPL, but adding types to
    my source code will allow type-checking tools like `mypy` to find such errors.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这对我们有什么帮助呢？它在REPL中对我没有帮助，但是在我的源代码中添加类型将允许像`mypy`这样的类型检查工具找到这些错误。
- en: Representing the Arguments with a NamedTuple
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名元组表示参数
- en: I want the data structure that represents the program’s arguments to include
    type information. As with the `Sequence` class, I can define a class that is derived
    from the `NamedTuple` type where I can *statically define the data structure with
    types*. I like to call this class `Args`, but you can call it whatever you like.
    I know this probably seems like driving a finishing nail with a sledgehammer,
    but trust me, this kind of detail will pay off in the future.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望表示程序参数的数据结构包括类型信息。与`Sequence`类一样，我可以定义一个派生自`NamedTuple`类型的类，在其中可以*静态定义带有类型的数据结构*。我喜欢称这个类为`Args`，但你可以根据喜好更改。我知道这可能看起来有点大材小用，但相信我，这种细节以后会有所回报。
- en: 'The latest `new.py` uses the `NamedTuple` class from the `typing` module. Here
    is how I suggest you define and represent the arguments:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的`new.py`使用了来自`typing`模块的`NamedTuple`类。我建议你这样定义和表示参数：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-1)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-1)'
- en: Import the `NamedTuple` class from the `typing` module.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从`typing`模块导入`NamedTuple`类。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-2)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-2)'
- en: Define a `class` for the arguments which is based on the `NamedTuple` class.
    See the following note.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为参数定义一个基于`NamedTuple`类的`class`。请参阅以下注释。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-3)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-3)'
- en: The class has a single field called `dna` that has the type `str`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类中有一个名为`dna`的单一字段，类型为`str`。
- en: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-4)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-4)'
- en: The type annotation on the `get_args()` function shows that it returns an object
    of the type `Args`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_args()`函数的类型注解显示它返回一个`Args`类型的对象。'
- en: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-5)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-5)'
- en: Parse the arguments as before.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 像以前一样解析参数。
- en: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-6)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-6)'
- en: Return a new `Args` object that contains the single value from `args.dna`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含`args.dna`单一值的新`Args`对象。
- en: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-7)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-7)'
- en: The `main()` function has no `return` statement, so it returns the default `None`
    value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数没有`return`语句，因此返回默认的`None`值。'
- en: '[![8](assets/8.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-8)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO4-8)'
- en: This is the type error from the earlier program.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是早期程序的类型错误。
- en: If you run `pylint` on this program, you may encounter the errors “Inheriting
    *NamedTuple*, which is not a class. (inherit-non-class)” and “Too few public methods
    (0/2) (too-few-public-methods).” You can disable these warnings by adding “inherit-non-class”
    and “too-few-public-methods” to the “disable” section of your *pylintrc* file,
    or use the *pylintrc* file included in the root of the GitHub repository.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个程序上运行`pylint`，可能会遇到错误“继承*NamedTuple*，这不是一个类（inherit-non-class）”和“太少的公共方法（0/2）（too-few-public-methods）”。你可以通过将“inherit-non-class”和“too-few-public-methods”添加到你的*pylintrc*文件的“disable”部分来禁用这些警告，或者使用GitHub仓库根目录中包含的*pylintrc*文件。
- en: 'If you run this program, you’ll see it still creates the same uncaught exception.
    Both `flake8` and `pylint` will continue to report that the program looks fine,
    but see what `mypy` tells me now:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你会看到它仍然会创建相同的未捕获异常。`flake8`和`pylint`都会继续报告程序看起来很好，但现在看看`mypy`告诉我的是什么：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The error message shows that there is a problem on line 32 with the operands,
    which are the arguments to the division (`/`) operator. I’m mixing string and
    integer values. Without the type annotations, `mypy` would be unable to find a
    bug. Without this warning from `mypy`, I’d have to run my program to find it,
    being sure to exercise the branch of code that contains the error. In this case,
    it’s all rather obvious and trivial, but in a much larger program with hundreds
    or thousands of lines of code (LOC) with many functions and logical branches (like
    `if`/`else`), I might not stumble upon this error. I rely on types and programs
    like `mypy` (and `pylint` and `flake8` and so on) to correct these kinds of errors
    rather than relying solely on tests, or worse, waiting for users to report bugs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息显示，在第 32 行存在问题，涉及除法 (`/`) 操作符的操作数。我混合了字符串和整数值。如果没有类型注解，`mypy` 将无法找到此错误。如果没有`mypy`
    的警告，我将不得不运行我的程序来找到它，确保执行包含错误的代码分支。在这种情况下，这一切都显而易见且微不足道，但在一个具有数百或数千行代码（LOC）、许多函数和逻辑分支（如
    `if`/`else`）的更大程序中，我可能不会偶然发现这个错误。我依赖于类型和像 `mypy`（还有 `pylint`、`flake8` 等）这样的程序来修正这些类型的错误，而不是仅依赖于测试，更糟糕的是等待用户报告错误。
- en: Reading Input from the Command Line or a File
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从命令行或文件读取输入
- en: When you attempt to prove that your program works on the Rosalind.info website,
    you will download a data file containing the input to your program. Usually, this
    data will be much larger than the sample data described in the problem. For instance,
    the example DNA string for this problem is 70 bases long, but the one I downloaded
    for one of my attempts was 910 bases.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当您试图证明您的程序在 Rosalind.info 网站上运行时，您将下载一个包含程序输入的数据文件。通常，此数据要比问题描述中的示例数据大得多。例如，此问题的示例
    DNA 字符串长度为 70 个碱基，但我下载的一个尝试的输入数据文件长度为 910 个碱基。
- en: Let’s make the program read input both from the command line and from a text
    file so that you don’t have to copy and paste the contents from a downloaded file.
    This is a common pattern I use, and I prefer to handle this option inside the
    `get_args()` function since this pertains to processing the command-line arguments.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序同时从命令行和文本文件中读取输入，这样您就不必从下载的文件中复制和粘贴内容。这是我常用的一种模式，我更喜欢在 `get_args()` 函数内处理此选项，因为这涉及处理命令行参数。
- en: 'First, correct the program so that it prints the `args.dna` value without the
    division:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修正程序，以便打印 `args.dna` 的值而不进行除法操作：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO5-1)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO5-1)'
- en: Remove the division type error.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 修复除法类型错误。
- en: 'Check that it works:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 检查它是否工作：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For this next part, you need to bring in the `os` module to interact with your
    operating system. Add `import os` to the other `import` statements at the top,
    then add these two lines to your `get_args()` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的部分，您需要引入 `os` 模块以与操作系统交互。在其他 `import` 语句顶部添加 `import os`，然后将这两行代码添加到您的
    `get_args()` 函数中：
- en: '[PRE49]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-1)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-1)'
- en: Check if the `dna` value is a file.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `dna` 值是否是一个文件。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-2)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO6-2)'
- en: Call `open()` to open a filehandle, then chain the `fh.read()` method to return
    a string, then chain the `str.rstrip()` method to remove trailing whitespace.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `open()` 打开文件句柄，然后链式调用 `fh.read()` 方法返回一个字符串，接着链式调用 `str.rstrip()` 方法删除尾部空白。
- en: The `fh.read()` function will read an *entire* file into a variable. In this
    case, the input file is small and so this should be fine, but it’s very common
    in bioinformatics to process files that are gigabytes in size. Using `read()`
    on a large file could crash your program or even your entire computer. Later I
    will show you how to read a file line-by-line to avoid this.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`fh.read()` 函数将整个文件读入一个变量中。在这种情况下，输入文件很小，所以这应该没问题，但在生物信息学中处理数千兆字节大小的文件是非常普遍的。在大文件上使用
    `read()` 可能会导致程序崩溃甚至整个计算机崩溃。稍后我将展示如何逐行读取文件以避免这种情况。'
- en: 'Now run your program with a string value to ensure it works:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行您的程序，以确保它能处理字符串值：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'and then use a text file as the argument:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将文本文件用作参数：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now you have a flexible program that reads input from two sources. Run **`mypy
    dna.py`** to make sure there are no problems.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个灵活的程序，可以从两个来源读取输入。运行**`mypy dna.py`**以确保没有问题。
- en: Testing Your Program
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试你的程序
- en: You know from the Rosalind description that given the input `ACGT`, the program
    should print `1 1 1 1` since that is the number of *A*s, *C*s, *G*s, and *T*s,
    respectively. In the *01_dna/tests* directory, there is a file called *dna_test.py*
    that contains tests for the `dna.py` program. I wrote these tests for you so you
    can see what it’s like to develop a program using a method to tell you with some
    certainty when your program is correct. The tests are really basic—given an input
    string, the program should print the correct counts for the four nucleotides.
    When the program reports the correct numbers, then it works.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你从罗莎琳描述中了解到，给定输入`ACGT`，程序应该打印`1 1 1 1`，因为这是*A*、*C*、*G*和*T*各自的数量。在*01_dna/tests*目录中，有一个名为*dna_test.py*的文件，其中包含对`dna.py`程序的测试。我为你编写了这些测试，这样你就可以看到使用一种方法开发程序，并能相当确信地告诉你程序是否正确的情况。这些测试非常基础——给定一个输入字符串，程序应该打印四种核苷酸的正确计数。当程序报告正确的数字时，它就正常工作了。
- en: Inside the *01_dna* directory, I’d like you to run **`pytest`** (or **`python3
    -m pytest`** or **`pytest.exe`** on Windows). The program will recursively search
    for all files with names that start with *test_* or end with *_test.py*. It will
    then run for any functions in these files that have names starting with *test_*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在*01_dna*目录中，我想让你运行**`pytest`**（或在Windows上运行**`python3 -m pytest`**或**`pytest.exe`**）。程序将递归搜索所有以*test_*开头或以*_test.py*结尾的文件，然后运行这些文件中以*test_*开头命名的函数。
- en: 'When you run **`pytest`**, you will see a lot of output, most of which is failing
    tests. To understand why these tests are failing, let’s look at the *tests/dna_test.py*
    module:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行**`pytest`**时，会看到大量输出，其中大多数是失败的测试。要理解为什么这些测试失败，让我们看一下*tests/dna_test.py*模块：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-1)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-1)'
- en: This is the docstring for the module.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该模块的文档字符串。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-2)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-2)'
- en: The standard `os` module will interact with the operating system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`os`模块将与操作系统进行交互。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-3)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-3)'
- en: The `platform` module is used to determine if this is being run on Windows.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`platform`模块来确定是否在Windows上运行。
- en: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-4)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-4)'
- en: From the `subprocess` module I import a function to run the `dna.py` program
    and capture the output and status.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我从`subprocess`模块导入一个函数，用于运行`dna.py`程序并捕获输出和状态。
- en: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-5)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-5)'
- en: These following lines are global variables for the program. I tend to avoid
    globals except in my tests. Here I want to define some values that I’ll use in
    the functions. I like to use UPPERCASE_NAMES to highlight the global visibility.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是程序的全局变量。我倾向于在我的测试中避免使用全局变量。在这里，我想定义一些将在函数中使用的值。我喜欢使用大写名称来突出显示全局可见性。
- en: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-6)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-6)'
- en: The `RUN` variable determines how to run the `dna.py` program. On Windows, the
    `python` command must be used to run a Python program, but on Unix platforms,
    the `dna.py` program can be directly executed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`变量确定如何运行`dna.py`程序。在Windows上，必须使用`python`命令来运行Python程序，但在Unix平台上，可以直接执行`dna.py`程序。'
- en: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-7)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO7-7)'
- en: The `TEST*` variables are tuples that define a file containing a string of DNA
    and the expected output from the program for that string.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEST*`变量是元组，定义了包含DNA字符串的文件以及该字符串的预期输出。'
- en: The `pytest` module will run the test functions in the order in which they are
    defined in the test file. I often structure my tests so that they progress from
    the simplest cases to more complex, so there’s usually no point in continuing
    after a failure. For instance, the first test is always that the program to test
    exists. If it doesn’t, then there’s no point in running more tests. I recommend
    you run `pytest` with the `-x` flag to stop on the first failing test along with
    the `-v` flag for verbose output.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`模块将按照测试文件中定义的顺序运行测试函数。我经常这样组织我的测试，从最简单的情况逐步进行，因此在失败后通常没有继续进行的必要。例如，第一个测试始终是检查要测试的程序是否存在。如果不存在，则没有继续运行更多测试的意义。我建议您在运行`pytest`时使用`-x`标志以在第一个失败的测试处停止，并使用`-v`标志以获取详细输出。'
- en: 'Let’s look at the first test. The function is called `test_exists()` so that
    `pytest` will find it. In the body of the function, I use one or more `assert`
    statements to check if some condition is *truthy*.^([1](ch01.html#idm45963636356152))
    Here I assert that the program `dna.py` exists. This is why your program must
    exist in this directory—otherwise it wouldn’t be found by the test:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个测试。函数名为`test_exists()`，这样`pytest`就能找到它。在函数体中，我使用一个或多个`assert`语句来检查某个条件是否*真实*。^([1](ch01.html#idm45963636356152))
    这里我断言程序`dna.py`存在。这就是为什么您的程序必须存在于此目录中——否则测试将找不到它的原因：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-1)'
- en: The function name must start with `test_` to be found by `pytest`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名必须以`test_`开头，以便`pytest`能够找到它。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-2)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO8-2)'
- en: The `os.path.exists()` function returns `True` if the given argument is a file.
    If it returns `False`, then the assertion fails and this test will fail.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.exists()`函数如果给定的参数是文件则返回`True`。如果返回`False`，则断言失败，此测试将失败。'
- en: 'The next test I write is always to check that the program will produce a usage
    statement for the `-h` and `--help` flags. The `subprocess.getstatusoutput()`
    function will run the `dna.py` program with the short and long help flags. In
    each case, I want to see that the program prints text starting with the word *usage:*.
    It’s not a perfect test. It doesn’t check that the documentation is accurate,
    only that it appears to be something that might be a usage statement. I don’t
    feel that every test needs to be completely exhaustive. Here’s the test:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写的下一个测试总是检查程序是否会为`-h`和`--help`标志生成使用语句。`subprocess.getstatusoutput()`函数将使用短和长帮助标志运行`dna.py`程序。在每种情况下，我希望看到程序打印以*usage:*开头的文本。这不是一个完美的测试。它不检查文档是否准确，只是看起来像是可能是使用语句。我不认为每个测试都需要完全详尽。以下是测试内容：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-1)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-1)'
- en: Iterate over the short and long help flags.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代短和长帮助标志。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-2)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-2)'
- en: Run the program with the argument and capture the return value and output.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数运行程序并捕获返回值和输出。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-3)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-3)'
- en: Verify that the program reports a successful exit value of 0.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 验证程序报告的成功退出值为0。
- en: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-4)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO9-4)'
- en: Assert that the lowercased output of the program starts with the text *usage:*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 断言程序输出的小写结果以*usage:*开头。
- en: Command-line programs usually indicate an error to the operating system by returning
    a nonzero value. If the program runs successfully, it ought to return a `0`. Sometimes
    that nonzero value may correlate to some internal error code, but often it just
    means that something went wrong. The programs I write will, likewise, always strive
    to report `0` for successful runs and some nonzero value when there are errors.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行程序通常通过返回非零值向操作系统指示错误。如果程序成功运行，应该返回`0`。有时这个非零值可能与某些内部错误代码相关联，但通常它只是表示出现了问题。我编写的程序也会力求在成功运行时报告`0`，在出现错误时报告某个非零值。
- en: 'Next, I want to ensure that the program will die when given no arguments:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我希望确保当没有给出参数时程序会退出：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-1)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-1)'
- en: Capture the return value and output from running the program with no arguments.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获运行程序时没有参数时的返回值和输出。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-2)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-2)'
- en: Verify that the return value is a nonzero failure code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 验证返回值为非零的失败代码。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-3)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO10-3)'
- en: Check that the output looks like a usage statement.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 检查输出是否像一个用法说明。
- en: At this point in testing, I know that I have a program with the correct name
    that can be run to produce documentation. This means that the program is at least
    syntactically correct, which is a decent place to start testing. If your program
    has typographical errors, then you’ll be forced to correct those to even get to
    this point.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试到这一点时，我知道我有一个程序，它的名称正确，可以运行以生成文档。这意味着程序至少在语法上是正确的，这是一个不错的起点进行测试。如果您的程序存在拼写错误，则必须在达到这一点之前进行更正。
- en: Running the Program to Test the Output
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行程序以测试输出
- en: Now I need to see if the program does what it’s supposed to do. There are many
    ways to test programs, and I like to use two basic approaches I call *inside-out*
    and *outside-in*. The inside-out approach starts at the level of testing individual
    functions inside a program. This is often called *unit* testing, as functions
    might be considered a basic unit of computing, and I’ll get to this in the solutions
    section. I’ll start with the outside-in approach. This means that I will run the
    program from the command line just as the user will run it. This is a holistic
    approach to check if the pieces of the code can work together to create the correct
    output, and so it’s sometimes called an *integration* test.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我需要看看程序是否按预期运行。测试程序有许多方法，我喜欢使用称为*inside-out*和*outside-in*的两种基本方法。*Inside-out*方法从测试程序内部的各个函数开始。这通常被称为*单元*测试，因为函数可以被认为是计算的基本单位，我将在解决方案部分详细介绍。我将从*outside-in*方法开始。这意味着我将像用户一样从命令行运行程序。这是一种整体方法，用来检查代码片段是否能够协同工作以创建正确的输出，因此有时被称为*集成*测试。
- en: 'The first such test will pass the DNA string as a command-line argument and
    check if the program produces the right counts formatted in the correct string:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个这样的测试将DNA字符串作为命令行参数传递，并检查程序是否产生正确格式的计数：
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-1)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-1)'
- en: Unpack the tuples into the `file` containing a string of DNA and the `expected`
    value from the program when run with this input.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 解压元组到包含DNA字符串和程序运行时此输入的`expected`值的`file`中。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-2)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-2)'
- en: Open the file and read the `dna` from the contents.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件并从内容中读取`dna`。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-3)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-3)'
- en: Run the program with the given DNA string using the function `subprocess.getstatusoutput()`,
    which gives me both the return value from the program and the text output (also
    called `STDOUT`, which is pronounced *standard out*).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数`subprocess.getstatusoutput()`运行给定的DNA字符串的程序，该函数给出程序的返回值和文本输出（也称为`STDOUT`，发音为*standard
    out*）。
- en: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-4)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-4)'
- en: Assert that the return value is `0`, which indicates success (or 0 errors).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 断言返回值为`0`，这表示成功（或0个错误）。
- en: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-5)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO11-5)'
- en: Assert that the output from the program is the string of numbers expected.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 断言程序的输出是预期的数字字符串。
- en: 'The next test is almost identical, but this time I’ll pass the filename as
    the argument to the program to verify that it correctly reads the DNA from a file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试几乎相同，但这次我将文件名作为程序的参数传递，以验证它是否正确地从文件中读取DNA：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO12-1)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO12-1)'
- en: The only difference from the first test is that I pass the filename instead
    of the contents of the file.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个测试的唯一区别是，我传递的是文件名而不是文件的内容。
- en: 'Now that you’ve looked at the tests, go back and run the tests again. This
    time, use **`pytest -xv`**, where the `-v` flag is for verbose output. Since both
    `-x` and `-v` are short flags, you can combine them like `-xv` or `-vx`. Read
    the output closely and notice that it’s trying to tell you that the program is
    printing the DNA sequence but that the test is expecting a sequence of numbers:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经查看了测试，请返回并再次运行测试。这次使用**`pytest -xv`**，其中`-v`标志用于详细输出。由于`-x`和`-v`都是短标志，你可以像`-xv`或`-vx`一样组合它们。仔细阅读输出并注意它试图告诉你程序正在打印DNA序列，但测试期望一个数字序列：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-1)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-1)'
- en: The `>` at the beginning of this line shows that this is the source of the error.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此行开头的`>`显示这是错误的来源。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-2)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO13-2)'
- en: The output from the program was the string `ACCGGGTTTT` but the expected value
    was `1 2 3 4`. Since these are not equal, an `AssertionError` exception is raised.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出是字符串`ACCGGGTTTT`，但期望值是`1 2 3 4`。由于它们不相等，引发了一个`AssertionError`异常。
- en: 'Let’s fix that. If you think you know how to finish the program, please jump
    right into your solution. First, perhaps try running your program to verify that
    it will report the correct number of *A*s:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修复一下。如果你认为你知道如何完成程序，请立即采用你的解决方案。首先，也许尝试运行你的程序来验证它是否会报告正确数量的*A*：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And then *C*s:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是*C*：
- en: '[PRE60]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: and so forth with *G*s and *T*s. Then run **`pytest`** to see if it passes all
    the tests.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以及继续进行*G*和*T*。然后运行**`pytest`**，看看是否通过了所有测试。
- en: After you have a working version, consider trying to find as many different
    ways as you can to get the same answer. This is called *refactoring* a program.
    You need to start with something that works correctly, and then you try to improve
    it. The improvements can be measured in many ways. Perhaps you find a way to write
    the same idea using less code, or maybe you find a solution that runs faster.
    No matter what metric you’re using, keep running **`pytest`** to ensure the program
    is correct.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 完成一份可用版本后，请考虑尝试尽可能多地寻找得到相同答案的不同方法。这被称为*重构*程序。你需要从能够正确工作的东西开始，然后尝试改进它。改进可以通过多种方式衡量。也许你找到了用更少的代码写相同想法的方法，或者也许你找到了运行更快的解决方案。无论你使用什么标准，都要继续运行**`pytest`**来确保程序是正确的。
- en: 'Solution 1: Iterating and Counting the Characters in a String'
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案1：迭代并计算字符串中的字符数
- en: 'If you don’t know where to start, I’ll work through the first solution with
    you. The goal is to travel through all the bases in the DNA string. So, first
    I need to create a variable called `dna` by assigning it some value in the REPL:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道从哪里开始，我将与你一起解决第一个解决方案。目标是遍历DNA字符串中的所有碱基。因此，首先我需要通过在REPL中分配一些值来创建一个名为`dna`的变量：
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Note that any value enclosed in quotes, whether single or double, is a string.
    Even a single character in Python is considered a string. I will often use the
    `type()` function to verify the type of a variable, and here I see that `dna`
    is of the class `str` (string):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何用引号括起来的值，无论是单引号还是双引号，都是字符串。在Python中，即使是单个字符也被视为字符串。我经常使用`type()`函数来验证变量的类型，这里我看到`dna`是`str`类（字符串类）：
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Type `help(str)` in the REPL to see all the wonderful things you can do with
    strings. This data type is especially important in genomics, where strings comprise
    so much of the data.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中键入`help(str)`以查看你可以在字符串上执行的所有精彩操作。在基因组学中，字符串作为数据的重要组成部分，这一数据类型尤为重要。
- en: 'In the parlance of Python, I want to *iterate* through the characters of a
    string, which in this case are the nucleotides of DNA. A `for` loop will do that.
    Python sees a string as an ordered sequence of characters, and a `for` loop will
    visit each character from beginning to end:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python术语中，我想*迭代*字符串的字符，这些字符在这种情况下是DNA的核苷酸。使用`for`循环可以做到这一点。Python将字符串视为有序的字符序列，`for`循环将从头到尾访问每个字符：
- en: '[PRE63]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-1)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-1)'
- en: Each character in the `dna` string will be copied into the `base` variable.
    You could call this `char`, or `c` for *character*, or whatever else you like.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`dna`字符串中的每个字符都将复制到`base`变量中。你可以称其为`char`，或者`c`表示*character*，或者其他你喜欢的名字。'
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-2)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO14-2)'
- en: Each call to `print()` will end with a newline, so you’ll see each base on a
    separate line.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`print()`都会以换行符结束，因此你会看到每个碱基占据一行。
- en: Later you will see that `for` loops can be used with lists and dictionaries
    and sets and lines in a file—basically any iterable data structure.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 后面你会看到`for`循环可以与列表、字典、集合和文件中的行一起使用——基本上任何可迭代的数据结构。
- en: Counting the Nucleotides
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计核苷酸
- en: 'Now that I know how to visit each base in the sequence, I need to count each
    base rather than printing it. That means I’ll need some variables to keep track
    of the numbers for each of the four nucleotides. One way to do this is to create
    four variables that hold integer counts, one for each base. I will *initialize*
    four variables for counting by setting their initial values to `0`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我知道如何访问序列中的每个碱基后，我需要计算每个碱基的数量而不是仅打印它们。这意味着我需要一些变量来跟踪每种四个核苷酸的数量。一种方法是创建四个整数计数的变量，每个变量对应一个碱基。我将通过将它们的初始值设置为`0`来*初始化*这四个计数变量：
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'I could write this in one line by using the tuple unpacking syntax that I showed
    earlier:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用我之前展示的元组解包语法来一行写完：
- en: '[PRE65]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'I need to look at each base and determine which variable to *increment*, making
    its value increase by 1. For instance, if the current `base` is a *C*, then I
    should increment the `count_c` variable. I could write this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要查看每个碱基并确定要*增加*的变量，使其值增加1。例如，如果当前的`base`是*C*，那么我应该增加`count_c`变量。我可以这样写：
- en: '[PRE66]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-1)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-1)'
- en: The `==` operator is used to compare two values for equality. Here I want to
    know if the current `base` is equal to the string `C`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符用于比较两个值是否相等。这里我想知道当前的`base`是否等于字符串`C`。'
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-2)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO15-2)'
- en: Set `count_c` equal to 1 greater than the current value.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将`count_c`设置为当前值加1。
- en: The `==` operator is used to compare two values for equality. It works to compare
    two strings or two numbers. I showed earlier that division with `/` will raise
    an exception if you mix strings and numbers. What happens if you mix types with
    this operator, for example `'3' == 3`? Is this a safe operator to use without
    first comparing the types?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符用于比较两个值是否相等。它用于比较两个字符串或两个数字。前面我展示了，如果混合字符串和数字，使用`/`会引发异常。如果你混合类型使用这个运算符会发生什么，例如
    `''3'' == 3`？在未比较类型的情况下，这是一个安全的运算符吗？'
- en: 'As shown in [Figure 1-3](#fig_1.3), a shorter way to increment a variable uses
    the `+=` operator to add whatever is on the righthand side (often noted as RHS)
    of the expression to whatever is on the lefthand side (or LHS):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如图1-3所示，使用`+=`运算符来增加变量的值是一种更短的方式，它将右侧的值（通常标记为RHS）添加到表达式的左侧（或LHS）的内容中。
- en: '![mpfb 0103](assets/mpfb_0103.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0103](assets/mpfb_0103.png)'
- en: Figure 1-3\. The `+=` operator will add the value on the righthand side to the
    variable on the lefthand side
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-3\. `+=`运算符将在左侧的变量上加上右侧的值
- en: 'Since I have four nucleotides to check, I need a way to combine three more
    `if` expressions. The syntax in Python for this is to use `elif` for *else if*
    and `else` for any final or default case. Here is a block of code I can enter
    in the program or the REPL that implements a simple decision tree:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我有四个核苷酸要检查，我需要一种方法来结合另外三个`if`表达式。Python中的语法是使用`elif`来表示*else if*，`else`表示最后的或默认情况。以下是一个可以输入到程序或REPL中的代码块，实现了一个简单的决策树：
- en: '[PRE67]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'I should end up with counts of 1, 2, 3, and 4 for each of the sorted bases:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该得到每个排序后的碱基的计数，分别为1、2、3和4：
- en: '[PRE68]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now I need to report the outcome to the user:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我需要向用户报告结果：
- en: '[PRE69]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'That is the exact output the program expects. Notice that `print()` will accept
    multiple values to print, and it inserts a space between each value. If you read
    `help(print)` in the REPL, you’ll find that you can change this with the `sep`
    argument:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是程序期望的确切输出。注意，`print()`函数接受多个值作为参数并在每个值之间插入一个空格。如果在REPL中阅读`help(print)`，你会发现可以使用`sep`参数来改变这个行为：
- en: '[PRE70]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `print()` function will also put a newline at the end of the output, and
    this can likewise be changed using the `end` option:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`函数还会在输出的末尾加上一个换行符，同样可以使用`end`选项来进行更改：'
- en: '[PRE71]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Writing and Verifying a Solution
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写和验证解决方案
- en: 'Using the preceding code, you should be able to create a program that passes
    all the tests. As you write, I would encourage you to regularly run `pylint`,
    `flake8`, and `mypy` to check your source code for potential errors. I would even
    go further and suggest you install the `pytest` extensions for these so that you
    can routinely incorporate such tests:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述代码，你应该能够创建一个通过所有测试的程序。在编写过程中，我建议你定期运行`pylint`、`flake8`和`mypy`来检查源代码中的潜在错误。我甚至建议你为这些工具安装`pytest`扩展，以便能够定期执行此类测试：
- en: '[PRE72]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Alternatively, I’ve placed a *requirements.txt* file in the root directory
    of the GitHub repo that lists various dependencies I’ll use throughout the book.
    You can install all these modules with the following command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我已经将*requirements.txt*文件放在GitHub仓库的根目录中，列出了我在整本书中将要使用的各种依赖项。你可以使用以下命令安装所有这些模块：
- en: '[PRE73]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'With those extensions, you can run the following command to run not only the
    tests defined in the *tests/dna_test.py* file but also tests for linting and type
    checking using these tools:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些扩展，你可以运行以下命令来执行不仅在*tests/dna_test.py*文件中定义的测试，还包括使用这些工具进行linting和类型检查的测试：
- en: '[PRE74]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Some tests are skipped when a cached version indicates nothing has changed since
    the last test. Run `pytest` with the `---cache-clear` option to force the tests
    to run. Also, you may find you fail linting tests if your code is not properly
    formatted or indented. You can automatically format your code using `yapf` or
    `black`. Most IDEs and editors will provide an auto-format option.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当缓存版本表明自上次测试以来没有任何更改时，某些测试将被跳过。使用`--cache-clear`选项强制运行测试。此外，如果代码格式不正确或缩进不正确，您可能会发现无法通过linting测试。您可以使用`yapf`或`black`自动格式化代码。大多数IDE和编辑器都会提供自动格式化选项。
- en: 'That’s a lot to type, so I’ve created a shortcut for you in the form of a *Makefile*
    in the directory:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这么多要打字，所以我在该目录中创建了一个*Makefile*的快捷方式供你使用：
- en: '[PRE75]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can learn more about these files by reading [Appendix A](app01.html#app1_makefiles).
    For now, it’s enough to understand that if you have `make` installed on your system,
    you can use the command **`make test`** to run the command in the `test` target
    of the *Makefile*. If you don’t have `make` installed or you don’t want to use
    it, that’s fine too, but I suggest you explore how a *Makefile* can be used to
    document and automate processes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读[附录 A](app01.html#app1_makefiles)来了解这些文件的更多信息。现在，了解到如果你的系统安装了`make`，你可以使用命令**`make
    test`**来运行*Makefile*中的`test`目标。如果你没有安装`make`或者不想使用它，也没关系，但我建议你探索一下*Makefile*如何用于文档化和自动化流程。
- en: There are many ways to write a passing version of `dna.py`, and I’d like to
    encourage you to keep exploring before you read the solutions. More than anything,
    I want to get you used to the idea of changing your program and then running the
    tests to see if it works. This is the cycle of *test-driven development*, where
    I first create some metric to decide when the program works correctly. In this
    instance, that is the *dna_test.py* program that is run by `pytest`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以编写`dna.py`的通过版本，我想鼓励你在阅读解决方案之前继续探索。最重要的是，我希望你习惯于修改你的程序然后运行测试来验证其工作。这就是*测试驱动开发*的循环，我首先创建某些度量标准来判断程序何时正确工作。在这种情况下，就是由`pytest`运行的*dna_test.py*程序。
- en: The tests ensure I don’t stray from the goal, and they also let me know when
    I’ve met the requirements of the program. They are the specifications (also called
    *specs*) made incarnate as a program that I can execute. How else would I ever
    know when a program worked or was finished? Or, as Louis Srygley puts it, “Without
    requirements or design, programming is the art of adding bugs to an empty text
    file.”
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 测试确保我不偏离目标，它们还让我知道何时满足程序的要求。它们是作为我可以执行的程序而具体化的规格（也称为*规格*）。否则，我怎么知道程序何时工作或何时完成呢？或者，正如路易斯·斯里格利所说的，“没有需求或设计，编程就是在一个空白文本文件中添加错误的艺术。”
- en: Testing is essential to creating reproducible programs. Unless you can absolutely
    and automatically prove the correctness and predictability of your program when
    run with both good and bad data, then you’re not writing good software.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于创建可复制的程序至关重要。除非您能绝对自动地证明在运行良好和坏数据时程序的正确性和可预测性，否则您不是在编写优秀的软件。
- en: Additional Solutions
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他解决方案
- en: The program I wrote earlier in this chapter is the *solution1_iter.py* version
    in the GitHub repo, so I won’t bother reviewing that version. I would like to
    show you several alternate solutions that progress from simpler to more complex
    ideas. Please do not take this to mean they progress from worse to better. All
    versions pass the tests, so they are all equally valid. The point is to explore
    what Python has to offer for solving common problems. Note I will omit code they
    all have in common, such as the `get_args()` function.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章早些时候写过的程序是GitHub仓库中的*solution1_iter.py*版本，所以我不会再复习那个版本了。我想向你展示几个替代方案，从简单到复杂的想法。请不要误以为它们从差到好递进。所有版本都通过了测试，所以它们都同样有效。重点是探索Python在解决常见问题时的各种可能性。请注意，我将省略它们共有的代码，例如`get_args()`函数。
- en: 'Solution 2: Creating a count() Function and Adding a Unit Test'
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2：创建一个`count()`函数并添加一个单元测试。
- en: The first variation I’d like to show will move all the code in the `main()`
    function that does the counting into a `count()` function. You can define this
    function anywhere in your program, but I generally like `get_args()` first, `main()`
    second, and then other functions after that but *before* the final couplet that
    calls `main()`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我想展示的第一个变体将把所有计数代码从`main()`函数中移到一个`count()`函数中。你可以在程序的任何地方定义这个函数，但我通常喜欢先写`get_args()`，然后是`main()`，然后是其他函数，最后是调用`main()`的最后一对语句之前。
- en: 'For the following function, you will also need to import the `typing.Tuple`
    value:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下函数，您还需要导入`typing.Tuple`值：
- en: '[PRE76]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-1)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-1)'
- en: The types show that the function takes a string and returns a tuple containing
    four integer values.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 类型显示该函数接受一个字符串，并返回一个包含四个整数值的元组。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-2)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-2)'
- en: This is the code from `main()` that did the counting.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从`main()`中进行计数的代码。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-3)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO16-3)'
- en: Return a tuple of the four counts.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个包含四个计数的元组。
- en: 'There are many reasons to move this code into a function. To start, this is
    a *unit* of computation—given a string of DNA, return the tetranucleotide frequency—so
    it makes sense to encapsulate it. This will make `main()` shorter and more readable,
    and it allows me to write a unit test for the function. Since the function is
    called `count()`, I like to call the unit test `test_count()`. I have placed this
    function inside the `dna.py` program just after the `count()` function rather
    than in the `dna_test.py` program just as a matter of convenience. For short programs,
    I tend to put my functions and unit tests together in the source code, but as
    projects grow larger, I will segregate unit tests into a separate module. Here’s
    the test function:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多理由将此代码移入函数中。首先，这是一个*计算单元*——给定一个DNA字符串，返回四核苷酸频率——因此封装它是有意义的。这将使`main()`更短更易读，并允许我为函数编写单元测试。由于函数名为`count()`，我喜欢将单元测试命名为`test_count()`。我将此函数放在了`dna.py`程序中，正好在`count()`函数后面，而不是放在`dna_test.py`程序中，这只是为了方便起见。对于简短的程序，我倾向于将函数和单元测试放在源代码中的一起，但随着项目变大，我会将单元测试分离到单独的模块中。以下是测试函数：
- en: '[PRE77]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-1)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-1)'
- en: The function name must start with `test_` to be found by `pytest`. The types
    here show that the test accepts no arguments and, because it has no `return` statement,
    returns the default `None` value.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名必须以 `test_` 开头，以便被 `pytest` 找到。这里的类型显示该测试不接受参数，并且因为没有 `return` 语句，返回默认值 `None`。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-2)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-2)'
- en: I like to test functions with both expected and unexpected values to ensure
    they return something reasonable. The empty string should return all zeros.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢用预期和意外的值来测试函数，以确保它们返回合理的结果。空字符串应该返回全部零值。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-3)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO17-3)'
- en: The rest of the tests ensure that each base is reported in the correct position.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的测试确保每个碱基在正确的位置上报告。
- en: 'To verify that my function works, I can use `pytest` on the `dna.py` program:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我的函数是否有效，我可以在 `dna.py` 程序上使用 `pytest`：
- en: '[PRE78]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The first test passes the empty string and expects to get all zeros for the
    counts. This is a judgment call, honestly. You might decide your program ought
    to complain to the user that there’s no input. That is, it’s possible to run the
    program using the empty string as the input, and this version will report the
    following:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试传递空字符串，并期望得到所有零的计数。这是一个判断调用，说实话。你可能决定你的程序应该向用户抱怨没有输入。也就是说，可以使用空字符串作为输入运行程序，而这个版本将报告如下：
- en: '[PRE79]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Likewise, if I passed an empty file, I’d get the same answer. Use the **`touch`**
    command to create an empty file:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我传递一个空文件，我会得到相同的答案。使用 **`touch`** 命令创建一个空文件：
- en: '[PRE80]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'On Unix systems, `/dev/null` is a special filehandle that returns nothing:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 系统上，`/dev/null` 是一个特殊的文件句柄，返回空值：
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You may feel that no input is an error and report it as such. The important
    thing about the test is that it forces me to think about it. For instance, should
    the `count()` function return zeros or raise an exception if it’s given an empty
    string? Should the program crash on empty input and exit with a nonzero status?
    These are decisions you will have to make for your programs.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得没有输入是一个错误，并报告它。测试的重要之处在于它迫使我考虑这个问题。例如，如果给定空字符串，`count()` 函数应该返回零还是引发异常？如果输入为空，程序应该崩溃并退出，还是以非零状态结束？这些都是你为程序需要做出的决定。
- en: 'Now that I have a unit test in the `dna.py` code, I can run `pytest` on that
    file to see if it passes:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我在 `dna.py` 代码中有了一个单元测试，我可以在该文件上运行 `pytest` 看它是否通过：
- en: '[PRE82]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: When I’m writing code, I like to write functions that do just one limited thing
    with as few parameters as possible. Then I like to write a test with a name like
    `test_` plus the function name, usually right after the function in the source
    code. If I find I have many of these kinds of unit tests, I might decide to move
    them to a separate file and have `pytest` execute that file.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编写代码时，我喜欢编写只做一件事情的函数，尽可能少的参数。然后我喜欢在源代码中函数的后面写一个类似 `test_` 加上函数名的命名测试。如果我发现我有很多这样的单元测试，我可能决定将它们移到一个单独的文件中，并让
    `pytest` 执行该文件。
- en: 'To use this new function, modify `main()` like so:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新函数，修改 `main()` 如下：
- en: '[PRE83]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-1)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-1)'
- en: Unpack the four values returned from `count()` into separate variables.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 将从 `count()` 返回的四个值解包到单独的变量中。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-2)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO18-2)'
- en: Use `str.format()` to create the output string.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `str.format()` 创建输出字符串。
- en: Let’s focus for a moment on Python’s `str.format()`. As shown in [Figure 1-4](#fig_1.4),
    the string `'{} {} {} {}'` is a template for the output I want to generate, and
    I’m calling the `str.format()` function *directly on a string literal*. This is
    a common idiom in Python that you’ll also see with the `str.join()` function.
    It’s important to remember that, in Python, even a literal string (one that literally
    exists inside your source code in quotes) is an *object* upon which you can call
    *methods*.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0104](assets/mpfb_0104.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4\. The `str.format()` function uses a template containing curly brackets
    to define placeholders that are filled in with the values of the arguments
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Every `{}` in the string template is a placeholder for some value that is provided
    as an argument to the function. When using this function, you need to ensure that
    you have the same number of placeholders as arguments. The arguments are inserted
    in the order in which they are provided. I’ll have much more to say about the
    `str.format()` function later.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m not required to unpack the tuple returned by the `count()` function. I
    can pass the entire tuple as the argument to the `str.format()` function if I
    *splat* it by adding an asterisk (`*`) to the front. This tells Python to expand
    the tuple into its values:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-1)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: The `counts` variable is a 4-tuple of the integer base counts.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO19-2)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: The `*counts` syntax will expand the tuple into the four values needed by the
    format string; otherwise, the tuple would be interpreted as a single value.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Since I use the `counts` variable only once, I could skip the assignment and
    shrink this to one line:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO20-1)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Pass the return value from `count()` directly to the `str.format()` method.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The first solution is arguably easier to read and understand, and tools like
    `flake8` would be able to spot when the number of `{}` placeholders does not match
    the number of variables. Simple, verbose, obvious code is often better than compact,
    clever code. Still, it’s good to know about tuple unpacking and splatting variables
    as I’ll use these in ideas in later programs.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Using str.count()'
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous `count()` function turns out to be quite verbose. I can write
    the function using a single line of code using the `str.count()` method. This
    function will count the number of times one string is found inside another string.
    Let me show you in the REPL:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If the string is not found, it will report `0`, making this safe to count all
    four nucleotides even when the input sequence is missing one or more bases:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Here is a new version of the `count()` function using this idea:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-1)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-1)'
- en: The signature is the same as before.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 签名与之前相同。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-2)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO21-2)'
- en: Call the `dna.count()` method for each of the four bases.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个四个碱基调用 `dna.count()` 方法。
- en: 'This code is much more succinct, and I can use the same unit test to verify
    that it’s correct. This is a key point: *functions should act like black boxes*.
    That is, I do not know or care what happens inside the box. Something goes in,
    an answer comes out, and I only really care that the answer is correct. I am free
    to change what happens inside the box so long as the contract to the outside—the
    parameters and return value—stays the same.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更加简洁，我可以使用相同的单元测试来验证它的正确性。这是一个关键点：*函数应该像黑匣子一样运行*。也就是说，我不知道或不关心盒子里面发生了什么。输入一些东西，得到一个答案，我只关心答案是否正确。只要外部的约定——参数和返回值保持不变，我可以自由地改变盒子里面发生的事情。
- en: 'Here’s another way to create the output string in the `main()` function using
    Python’s f-string syntax:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 Python 的 f-string 语法在 `main()` 函数中创建输出字符串的另一种方式：
- en: '[PRE89]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-1)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-1)'
- en: Unpack the tuple into each of the four counts.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 将元组解包为四个计数。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-2)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO22-2)'
- en: Use an f-string to perform variable interpolation.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 f-string 执行变量插值。
- en: It’s called an *f-string* because the `f` precedes the quotes. I use the mnemonic
    *format* to remind me this is to format a string. Python also has a *raw* string
    that is preceded with an `r`, which I’ll discuss later. All strings in Python—bare,
    f-, or r-strings—can be enclosed in single or double quotes. It makes no difference.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为 *f-string*，因为在引号之前有一个 `f`。我使用 *format* 这个助记符来提醒自己这是用来格式化字符串的。Python 还有一个
    *raw* 字符串，以 `r` 开头，稍后我会讨论它。Python 中的所有字符串——裸字符串、f-字符串或r-字符串——都可以用单引号或双引号括起来。这没有区别。
- en: 'With f-strings, the `{}` placeholders can perform *variable interpolation*,
    which is a 50-cent word that means turning a variable into its contents. Those
    curlies can even execute code. For instance, the `len()` function will return
    the length of a string and can be run inside the braces:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 f-string，`{}` 占位符可以执行 *变量插值*，这是一个术语，意味着将变量转换为其内容。这些大括号甚至可以执行代码。例如，`len()`
    函数将返回字符串的长度，并且可以在大括号内执行：
- en: '[PRE90]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: I usually find f-strings easier to read than the equivalent code using `str.format()`.
    Which you choose is mostly a stylistic decision. I would recommend whichever makes
    your code more readable.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常发现使用 `str.format()` 相比等效的代码更易读。选择哪种方式主要是风格上的决定。我建议选择能使你的代码更易读的那种方式。
- en: 'Solution 4: Using a Dictionary to Count All the Characters'
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 4：使用字典计算所有字符的数量
- en: 'So far I’ve discussed Python’s strings, lists, and tuples. This next solution
    introduces *dictionaries*, which are key/value stores. I’d like to show a version
    of the `count()` function that internally uses dictionaries so that I can hit
    on some important points to understand:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我讨论了 Python 的字符串、列表和元组。下一个解决方案介绍了 *字典*，它们是键/值存储。我想展示一个内部使用字典的 `count()`
    函数版本，这样我可以强调一些重要的理解点：
- en: '[PRE91]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-1)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-1)'
- en: Internally I’ll use a dictionary, but nothing changes about the function signature.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我会使用一个字典，但函数签名不会改变。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-2)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-2)'
- en: Initialize an empty dictionary to hold the `counts`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个空字典来存储`counts`。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-3)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-3)'
- en: Use a `for` loop to iterate through the sequence.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`循环遍历序列。
- en: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-4)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-4)'
- en: Check if the base does not yet exist in the dictionary.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字典中是否尚不存在这个碱基。
- en: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-5)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-5)'
- en: Initialize the value for this base to `0`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个碱基的值初始化为`0`。
- en: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-6)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-6)'
- en: Increment the count for this base by 1.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 增加这个碱基的计数1。
- en: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-7)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO23-7)'
- en: Use the `dict.get()` method to get each base’s count or the default of `0`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dict.get()`方法获取每个碱基的计数或默认值`0`。
- en: 'Again, the contract for this function—the type signature—hasn’t changed. It’s
    still a string in and 4-tuple of integers out. Inside the function, I’m going
    to use a dictionary that I’ll initialize using the empty curly brackets:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这个函数的契约——类型签名——没有改变。输入仍然是字符串，输出仍然是4个整数的元组。在函数内部，我将使用一个我将使用空花括号初始化的字典：
- en: '[PRE92]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'I could also use the `dict()` function. Neither is preferable:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以使用`dict()`函数。两者都没有优势：
- en: '[PRE93]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'I can use the `type()` function to check that this is a dictionary:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`type()`函数来检查这是否是一个字典：
- en: '[PRE94]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `isinstance()` function is another way to check the type of a variable:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`isinstance()`函数是检查变量类型的另一种方式：'
- en: '[PRE95]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'My goal is to create a dictionary that has each base as a *key* and the number
    of times it occurs as a *value*. For example, given the sequence `ACCGGGTTT`,
    I want `counts` to look like this:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我的目标是创建一个字典，其中每个碱基都作为*键*，其出现次数作为*值*。例如，对于序列`ACCGGGTTT`，我希望`counts`看起来像这样：
- en: '[PRE96]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'I can access any of the values using square brackets and a key name like so:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用方括号和键名访问任何一个值，如下所示：
- en: '[PRE97]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Python will raise a `KeyError` exception if I attempt to access a dictionary
    key that doesn’t exist:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试访问一个不存在的字典键，Python将引发`KeyError`异常：
- en: '[PRE98]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'I can use the `in` keyword to see if a key exists in a dictionary:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`in`关键字来查看字典中是否存在一个键：
- en: '[PRE99]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As I am iterating through each of the bases in the sequence, I need to see
    if a base exists in the `counts` dictionary. If it does not, I need to initialize
    it to `0`. Then I can safely use the `+=` assignment to increment the count for
    a base by 1:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 当我遍历序列中的每个碱基时，我需要查看`counts`字典中是否存在该碱基。如果不存在，我需要将其初始化为`0`。然后，我可以安全地使用`+=`操作符将碱基的计数增加1：
- en: '[PRE100]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Finally, I want to return a 4-tuple of the counts for each of the bases. You
    might think this would work:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想返回每个碱基的4元组计数。你可能会认为这会起作用：
- en: '[PRE101]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'But ask yourself what would happen if one of the bases was missing from the
    sequence. Would this pass the unit test I wrote? Definitely not. It would fail
    on the very first test using an empty string because it would generate a `KeyError`
    exception. The safe way to ask a dictionary for a value is to use the `dict.get()`
    method. If the key does not exist, then `None` will be returned:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请问自己，如果序列中缺少其中一个碱基会发生什么？这段代码能通过我编写的单元测试吗？肯定不行。因为空字符串的第一个测试将生成`KeyError`异常。安全地询问字典值的方法是使用`dict.get()`方法。如果键不存在，则返回`None`：
- en: '[PRE102]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `dict.get()` method accepts an optional second argument that is the default
    value to return when the key does not exist, so this is the safest way to return
    a 4-tuple of the base counts:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict.get()`方法接受一个可选的第二个参数，即在键不存在时返回的默认值，因此这是返回4个碱基计数的最安全方法：'
- en: '[PRE103]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: No matter what you write inside your `count()` function, ensure that it will
    pass the `test_count()` unit test.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在`count()`函数内写什么，确保它能通过`test_count()`单元测试。
- en: 'Solution 5: Counting Only the Desired Bases'
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案5：仅计算所需的碱基
- en: 'The previous solution will count every character in the input sequence, but
    what if I only want to count the four nucleotides? In this solution, I will initialize
    a dictionary with values of `0` for the wanted bases. I’ll need to also bring
    in `typing.Dict` to run this code:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的解决方案将计算输入序列中的每个字符，但如果我只想计算四个核苷酸呢？在这个解决方案中，我将初始化一个只包含所需碱基且值为`0`的字典。我还需要引入`typing.Dict`来运行这段代码：
- en: '[PRE104]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-1)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-1)'
- en: The signature now indicates I’ll be returning a dictionary that has strings
    for the keys and integers for the values.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的签名表明我将返回一个具有字符串键和整数值的字典。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-2)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-2)'
- en: Initialize the `counts` dictionary with the four bases as keys and values of
    `0`.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 使用四个碱基作为键和值为 `0` 的方式初始化 `counts` 字典。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-3)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-3)'
- en: Iterate through the bases.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历碱基。
- en: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-4)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-4)'
- en: Check if the base is found as a key in the `counts` dictionary.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 检查碱基是否作为键存在于 `counts` 字典中。
- en: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-5)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-5)'
- en: If so, increment the `counts` for this base by 1.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，则将此碱基的 `counts` 增加 1。
- en: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-6)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO24-6)'
- en: Return the `counts` dictionary.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `counts` 字典。
- en: 'Since the `count()` function is now returning a dictionary rather than a tuple,
    the `test_count()` function needs to change:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `count()` 函数现在返回的是一个字典而不是元组，需要更改 `test_count()` 函数：
- en: '[PRE105]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-1)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-1)'
- en: The returned dictionary will always have the keys `A`, `C`, `G`, and `T`. Even
    for the empty string, these keys will be present and set to `0`.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的字典将始终具有键 `A`、`C`、`G` 和 `T`。即使对于空字符串，这些键也会存在并设置为 `0`。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-2)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO25-2)'
- en: All the other tests have the same inputs, but now I check that the answer comes
    back as a dictionary.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他测试具有相同的输入，但现在我检查答案作为一个字典返回。
- en: 'When writing these tests, note that the order of the keys in the dictionaries
    is not important. The two dictionaries in the following code have the same content
    even though they were defined differently:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这些测试时，请注意字典中键的顺序不重要。以下代码中的两个字典内容相同，即使定义方式不同：
- en: '[PRE106]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: I would point out that the `test_count()` function tests the function to ensure
    it’s correct and also serves as documentation. Reading these tests helps me see
    the structure of the possible inputs and expected outputs from the function.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出 `test_count()` 函数测试函数以确保其正确性，并作为文档。阅读这些测试帮助我看到可能输入和函数预期输出的结构。
- en: 'Here’s how I need to change the `main()` function to use the returned dictionary:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我需要更改 `main()` 函数以使用返回的字典的方式：
- en: '[PRE107]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-1)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-1)'
- en: '`counts` is now a dictionary.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`counts` 现在是一个字典。'
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-2)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO26-2)'
- en: Use the `str.format()` method to create the output using the values from the
    dictionary.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `str.format()` 方法使用字典中的值创建输出。
- en: 'Solution 6: Using collections.defaultdict()'
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 6：使用 `collections.defaultdict()`
- en: 'I can rid my code of all the previous efforts to initialize dictionaries and
    check for keys and such by using the `defaultdict()` function from the `collections`
    module:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `collections` 模块中的 `defaultdict()` 函数，可以摆脱所有之前初始化字典和检查键等的工作：
- en: '[PRE108]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'When I use the `defaultdict()` function to create a new dictionary, I tell
    it the default type for the values. I no longer have to check for a key before
    using it because the `defaultdict` type will automatically create any key I reference
    using a representative value of the default type. For the case of counting the
    nucleotides, I want to use the `int` type:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当我使用 `defaultdict()` 函数创建一个新字典时，我告诉它值的默认类型。我不再需要在使用之前检查键，因为 `defaultdict` 类型将自动使用默认类型的代表值创建我引用的任何键。对于计数核苷酸的情况，我希望使用
    `int` 类型：
- en: '[PRE109]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The default `int` value will be `0`. Any reference to a nonexistent key will
    cause it to be created with a value of `0`:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`int`值将是`0`。对不存在的键的任何引用将导致它被创建为值`0`：
- en: '[PRE110]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This means I can instantiate and increment any base in one step:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我可以一步实例化并增加任何碱基：
- en: '[PRE111]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Here is how I could rewrite the `count()` function using this idea:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我如何使用这个思路重写`count()`函数的方式：
- en: '[PRE112]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-1)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-1)'
- en: The `counts` will be a `defaultdict` with integer values. The type annotation
    here is required by `mypy` so that it can be sure that the returned value is correct.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`counts`将是一个带有整数值的`defaultdict`。这里的类型注释是`mypy`所需的，以确保返回的值是正确的。'
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-2)'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO27-2)'
- en: I can safely increment the `counts` for this base.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以安全地增加这个碱基的`counts`。
- en: 'The `test_count()` function looks quite different. I can see at a glance that
    the answers are very different from the previous versions:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`test_count()`看起来相当不同。我一眼就能看出答案与先前版本非常不同：
- en: '[PRE113]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-1)'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-1)'
- en: Given an empty string, an empty dictionary will be returned.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个空字符串，将返回一个空字典。
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-2)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-2)'
- en: Notice that every character in the string is a key in the dictionary.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串中的每个字符都是字典中的一个键。
- en: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-3)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO28-3)'
- en: Only `A` is present, with a count of 1.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`A`存在，计数为1。
- en: 'Given the fact that the returned dictionary may not contain all the bases,
    the code in `main()` needs to use the `count.get()` method to retrieve each base’s
    frequency:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于返回的字典可能不包含所有碱基，`main()`中的代码需要使用`count.get()`方法来检索每个碱基的频率：
- en: '[PRE114]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-1)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-1)'
- en: The `counts` will be a dictionary that may not contain all of the nucleotides.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`counts`将是一个可能不包含所有核苷酸的字典。'
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-2)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO29-2)'
- en: It’s safest to use the `dict.get()` method with a default value of `0`.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dict.get()`方法并设置默认值为`0`是最安全的。
- en: 'Solution 7: Using collections.Counter()'
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案7：使用`collections.Counter()`
- en: Perfection is achieved, not when there is nothing more to add, but when there
    is nothing left to take away.
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完美是在无需添加任何内容时实现的，而是在无需再去除任何内容时实现的。
- en: ''
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Antoine de Saint-Exupéry
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 安托万·德·圣埃克絮佩里
- en: 'I don’t actually like the last three solutions all that much, but I needed
    to step through how to use a dictionary both manually and with `defaultdict()`
    so that you can appreciate the simplicity of using `collections.Counter()`:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我并不太喜欢最后三个解决方案，但我需要逐步介绍如何手动使用字典和`defaultdict()`，以及如何欣赏使用`collections.Counter()`的简便性：
- en: '[PRE115]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The best code is code you never write, and `Counter()` is a prepackaged function
    that will return a dictionary with the frequency of the items contained in the
    iterable you pass it. You might also hear this called a *bag* or a *multiset*.
    Here the iterable is a string composed of characters, and so I get back the same
    dictionary as in the last two solutions, but *having written no code*.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳代码是你永远不必写的代码，而`Counter()`是一个预打包的函数，它将返回一个包含你传递的可迭代对象中各项频率的字典。你可能也听说过这被称为*包*或*多集*。这里的可迭代对象是由字符组成的字符串，所以我得到的字典与前两个解决方案相同，但*没有编写任何代码*。
- en: 'It’s so simple that you could pretty much eschew the `count()` and `test_count()`
    functions and integrate it directly into your `main()`:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常简单，你几乎可以避开`count()`和`test_count()`函数，直接集成到你的`main()`中：
- en: '[PRE116]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-1)'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-1)'
- en: The `counts` will be a dictionary containing the frequencies of the characters
    in `args.dna`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`counts` 将是一个包含 `args.dna` 中字符频率的字典。'
- en: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-2)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_tetranucleotide_frequency___span_class__keep_together__counting_things__span__CO30-2)'
- en: It is still safest to use `dict.get()` as I cannot be certain that all the bases
    are present.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dict.get()` 仍然是最安全的，因为我不能确定所有碱基都存在。
- en: I could argue that this code belongs in a `count()` function and keep the tests,
    but the `Counter()` function is already tested and has a well-defined interface.
    I think it makes more sense to use this function inline.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以说这段代码应该放在一个 `count()` 函数中并保留测试，但 `Counter()` 函数已经经过测试并具有良好定义的接口。我认为直接使用这个函数更有意义。
- en: Going Further
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步探讨
- en: 'The solutions here only handle DNA sequences provided as UPPERCASE TEXT. It’s
    not unusual to see these sequences provided as lowercase letters. For instance,
    in plant genomics, it’s common to use lowercase bases to denote regions of repetitive
    DNA. Modify your program to handle both uppercase and lowercase input by doing
    the following:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解决方案仅处理以大写文本提供的 DNA 序列。看到这些序列用小写字母提供并不罕见。例如，在植物基因组学中，常用小写字母表示重复 DNA 区域。通过以下操作修改程序以处理大小写输入：
- en: Add a new input file that mixes case.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的输入文件，混合大小写。
- en: Add a test to *tests/dna_test.py* that uses this new file and specifies the
    expected counts insensitive to case.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *tests/dna_test.py* 中添加一个测试，使用这个新文件并指定对大小写不敏感的预期计数。
- en: Run the new test and ensure your program fails.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行新的测试，并确保您的程序失败。
- en: Alter the program until it will pass the new test and all of the previous tests.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改程序，直到它通过新的测试和所有以前的测试。
- en: The solutions that used dictionaries to count all available characters would
    appear to be more flexible. That is, some of the tests only account for the bases
    *A*, *C*, *G*, and *T*, but if the input sequence were encoded using [IUPAC codes](https://oreil.ly/qGfsO)
    to represent possible ambiguity in sequencing, then the program would have to
    be entirely rewritten. A program hard-coded to look only at the four nucleotides
    would also be useless for protein sequences that use a different alphabet. Consider
    writing a version of the program that will print two columns of output with each
    character that is found in the first column and the character’s frequency in the
    second. Allow the user to sort ascending or descending by either column.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典计算所有可用字符的解决方案似乎更灵活。也就是说，某些测试仅考虑 *A*、*C*、*G* 和 *T* 作为碱基，但如果输入序列使用 [IUPAC
    代码](https://oreil.ly/qGfsO) 表示测序中的可能歧义，那么程序将需要完全重写。一个仅硬编码查看四个核苷酸的程序也对使用不同字母表的蛋白质序列无用。考虑编写一个程序的版本，它将以每个找到的字符作为第一列并在第二列中打印字符的频率输出两列。允许用户按任一列升序或降序排序。
- en: Review
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'This was kind of a monster chapter. The following chapters will be a bit shorter,
    as I’ll build upon many of the foundational ideas I’ve covered here:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章有点庞大。接下来的章节将会稍短，因为我将在这里覆盖的许多基本思想上继续构建：
- en: You can use the `new.py` program to create the basic structure of a Python program
    that accepts and validates command-line arguments using `argparse`.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `new.py` 程序创建一个基本的 Python 程序结构，使用 `argparse` 接受和验证命令行参数。
- en: The `pytest` module will run all functions with names starting with `test_`
    and will report the results of how many tests pass.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest` 模块将运行所有以 `test_` 开头的函数，并报告通过了多少个测试。'
- en: Unit tests are for functions, and integration tests check if a program works
    as a whole.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试用于函数，集成测试检查程序作为整体是否工作。
- en: Programs like `pylint`, `flake8`, and `mypy` can find various kinds of errors
    in your code. You can also have `pytest` automatically run tests to see if your
    code passes these checks.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似 `pylint`、`flake8` 和 `mypy` 的程序可以找出代码中的各种错误。你还可以让 `pytest` 自动运行测试，看看你的代码是否通过了这些检查。
- en: Complicated commands can be stored as a target in a *Makefile* and executed
    using the `make` command.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的命令可以存储为 *Makefile* 中的一个目标，并使用 `make` 命令执行。
- en: You can create a decision tree using a series of `if`/`else` statements.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用一系列 `if`/`else` 语句创建决策树。
- en: There are many ways to count all the characters in a string. Using the `collections.Counter()`
    function is perhaps the simplest method to create a dictionary of letter frequencies.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多种方法可以计算字符串中所有字符的数量。使用 `collections.Counter()` 函数可能是创建字母频率字典的最简单方法。
- en: You can annotate variables and functions with types, and use `mypy` to ensure
    the types are used correctly.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以用类型注释变量和函数，并使用`mypy`来确保类型的正确使用。
- en: The Python REPL is an interactive tool for executing code examples and reading
    documentation.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python REPL是一个交互式工具，用于执行代码示例和阅读文档。
- en: The Python community generally follows style guidelines such as PEP8\. Tools
    like `yapf` and `black` can automatically format code according to these suggestions,
    and tools like `pylint` and `flake8` will report deviations from the guidelines.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python社区通常遵循诸如PEP8之类的风格指南。像`yapf`和`black`这样的工具可以根据这些建议自动格式化代码，而`pylint`和`flake8`等工具将报告与指南不符的偏差。
- en: Python strings, lists, tuples, and dictionaries are very powerful data structures,
    each with useful methods and copious documentation.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的字符串、列表、元组和字典是非常强大的数据结构，每种都有有用的方法和丰富的文档。
- en: You can create a custom, immutable, typed `class` derived from named tuples.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建一个自定义的、不可变的、基于命名元组的有类型`class`。
- en: You may be wondering which is the best of the seven solutions. As with many
    things in life, it depends. Some programs are shorter to write and easier to understand
    but may fare poorly when confronting large datasets. In [Chapter 2](ch02.html#ch02),
    I’ll show you how to *benchmark* programs, pitting them against each other in
    multiple runs using large inputs to determine which performs the best.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你正在想哪一个是七种解决方案中最好的。像生活中的许多事情一样，这取决于情况。有些程序写起来更短，更容易理解，但当面对大数据集时可能表现不佳。在[第2章](ch02.html#ch02)中，我将向你展示如何对比程序，使用大输入进行多次运行以确定哪一个性能最佳。
- en: ^([1](ch01.html#idm45963636356152-marker)) Boolean types are `True` or `False`,
    but many other data types are *truthy* or conversely *falsey*. The empty `str`
    (`""`) is falsey, so any nonempty string is truthy. The number `0` is falsey,
    so any nonzero value is truthy. An empty `list`, `set`, or `dict` is falsey, so
    any nonempty one of those is truthy.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#idm45963636356152-marker)) 布尔类型是`True`或`False`，但许多其他数据类型是*truthy*或反之*falsey*。空的`str`(`""`)是falsey，所以任何非空字符串是truthy。数字`0`是falsey，所以任何非零值是truthy。空的`list`、`set`或`dict`是falsey，所以任何非空的这些都是truthy。
