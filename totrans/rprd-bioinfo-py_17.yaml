- en: 'Chapter 15\. Seqmagique: Creating and Formatting Reports'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often in bioinformatics projects, you’ll find yourself staring at a directory
    full of sequence files, probably in FASTA or FASTQ format. You’ll probably want
    to start by getting an idea of the distribution of sequences in the files, such
    as how many are in each file and the average, minimum, and maximum lengths of
    the sequences. You need to know if any files are corrupted—maybe they didn’t transfer
    completely from your sequencing center—or if any samples have far fewer reads,
    perhaps indicating a bad sequencing run that needs to be redone. In this chapter,
    I’ll introduce some techniques for checking your sequence files using hashes and
    the [Seqmagick tool](https://oreil.ly/VI9gr). Then I’ll write a small utility
    to mimic part of Seqmagick to illustrate how to create formatted text tables.
    This program serves as a template for any program that needs to process all the
    records in a given set of files and produce a table of summary statistics.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install the `seqmagick` tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use MD5 hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `choices` in `argparse` to constrain arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `numpy` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to mock a filehandle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `tabulate` and `rich` modules to format output tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Seqmagick to Analyze Sequence Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`seqmagick` is a useful command-line utility for handling sequence files. This
    should have been installed along with the other Python modules if you followed
    the setup instructions in the Preface. If not, you can install it with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run **`seqmagick --help`**, you’ll see the tool offers many options.
    I only want to focus on the `info` subcommand. I can run this on the test input
    FASTA files in the *15_seqmagique* directory like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you will create a program called `seqmagique.py` (this should
    be pronounced with an exaggerated French accent) that will mimic this output.
    The point of the program is to provide a basic overview of the sequences in a
    given set of files so you can spot, for instance, a truncated or corrupted file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by copying the solution to `seqmagique.py` and requesting the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The program accepts one or more input files which should be in FASTA format.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This option controls the format of the output table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this program on the same files and note that the output is almost identical,
    except that I have omitted the `alignment` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--tablefmt` option controls how the output table is formatted. This is
    the first program you’ll write that constrains the value to a given list. To see
    this in action, use a bogus value like `blargh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then try a different table format, such as `simple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the program with other table styles and then try the test suite. Next, I’ll
    talk about getting data for our program to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Files Using MD5 Hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in most genomics projects will be transferring sequence files
    to some location where you can analyze them, and the first line of defense against
    data corruption is ensuring that the files were copied completely. The source
    of the files may be a sequencing center or a public repository like [GenBank](https://oreil.ly/2eaMj)
    or the [Sequence Read Archive (SRA)](https://oreil.ly/kGNCv). The files may arrive
    on a thumb drive, or you may download them from the internet. If the latter, you
    may find that your connection drops, causing some files to be truncated or corrupted.
    How can you find these types of errors?
  prefs: []
  type: TYPE_NORMAL
- en: One way to check that your files are complete is to compare the file sizes locally
    with those on the server. For instance, you can use the **`ls -l`** command to
    view the *long* listing of files where the file size, in bytes, is shown. For
    large sequence files, this is going to be a very large number, and you will have
    to manually compare the file sizes from the source to the destination, which is
    tedious and prone to error.
  prefs: []
  type: TYPE_NORMAL
- en: Another technique involves using a *hash* or *message digest* of the file, which
    is a signature of the file’s contents generated by a one-way cryptographic algorithm
    that creates a unique output for every possible input. Although there are many
    tools you can use to create a hash, I’ll focus on tools that use the MD5 algorithm.
    This algorithm was originally developed in the context of cryptography and security,
    but researchers have since identified numerous flaws that now make it suitable
    only for purposes such as verifying data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS, I can use **`md5`** to generate a 128-bit hash value from the contents
    of the first test input file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I can also use **`openssl`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On Linux, I use **`md5sum`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, no matter the tool or platform, the hash value is the same
    for the same input file. If I change even one bit of the input file, a different
    hash value will be generated. Conversely, if I find another file that generates
    the same hash value, then the contents of the two files are identical. For instance,
    the *empty.fa* file is a zero-length file I created for testing, and it has the
    following hash value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If I use the **`touch foo`** command to create another empty file, I’ll find
    it has the same signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s common for data providers to create a file of the checksums so that you
    can verify that your copies of the data are complete. I created a *tests/inputs/checksums.md5*
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It has the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `md5sum` tool has a `--check` option that I can use to automatically verify
    that the files match the checksums found in a given file. The macOS `md5` tool
    does not have an option for this, but you can use **`brew install md5sha1sum`**
    to install an equivalent `md5sum` tool that can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: MD5 checksums present more complete and easier ways to verify data integrity
    than manually checking file sizes. Although file digests are not directly part
    of this exercise, I feel it’s important to understand how to verify that you have
    complete and uncorrupted data before beginning any analyses.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should work in the *15_seqmagique* directory for this exercise. I’ll start
    the program as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'First I need to make the program accept one or more text files as positional
    parameters. I also want to create an option to control the output table format.
    Here is the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a positional parameter for one or more readable text files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define an option that uses `choices` to constrain the argument to a value in
    the list, making sure to define a reasonable `default` value.
  prefs: []
  type: TYPE_NORMAL
- en: Using `choices` for the `--tablefmt` really saves you quite a bit of work in
    validating user input. As shown in [“Using Seqmagick to Analyze Sequence Files”](#UsingSeqmagick),
    a bad value for the table format option will trigger a useful error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `main()` function to print the input filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And verify that this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The goal is to iterate through each file and print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs: []
  type: TYPE_NORMAL
- en: The filename
  prefs: []
  type: TYPE_NORMAL
- en: '`min_len`'
  prefs: []
  type: TYPE_NORMAL
- en: The length of the shortest sequence
  prefs: []
  type: TYPE_NORMAL
- en: '`max_len`'
  prefs: []
  type: TYPE_NORMAL
- en: The length of the longest sequence
  prefs: []
  type: TYPE_NORMAL
- en: '`avg_len`'
  prefs: []
  type: TYPE_NORMAL
- en: The average/mean length of all the sequences
  prefs: []
  type: TYPE_NORMAL
- en: '`num_seqs`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of sequences
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to have some real input files for the program, you can use
    the [`fastq-dump` tool](https://oreil.ly/Vmb0w) from NCBI to download sequences
    from the study [“Planktonic Microbial Communities from North Pacific Subtropical
    Gyre”](https://oreil.ly/aAGUA):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `--split-3` option will ensure that paired-end reads are correctly split
    into forward/reverse/unpaired reads. The `SAMN00000013` string is the accession
    of [one of the samples](https://oreil.ly/kBCQU) from the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Text Tables Using tabulate()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The output of the program will be a text table formatted using the `tabulate()`
    function from that module. Be sure to read the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I need to define the headers for the table, and I decided to use the same ones
    as Seqmagick (minus the `alignment` column):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first test file, *tests/inputs/1.fa*, has just one sequence of 50 bases,
    so the columns for this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The second test file, *tests/inputs/2.fa*, has five sequences ranging from
    49 bases to 79 with an average length of 64 bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tabulate()` function expects the table data to be passed positionally
    as a list of lists, and I can specify the `headers` as a keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, I can place the headers as the first row of data and indicate
    this is the location of the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the default table style for the `tabulate()` function is `simple`,
    but the `plain` format is what I need to match Seqmagick’s output. I can set this
    with the `tablefmt` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'One other thing to note is that the values in the `avg_len` column are being
    shown as integers but should be formatted as floating-point numbers to two decimal
    places. The `floatfmt` option controls this, using syntax similar to the f-string
    number formatting I’ve shown before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Your job is to process all the sequences in each file to find the statistics
    and print the final table. This should be enough for you to solve the problem.
    Don’t read ahead until you can pass all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ll present two solutions that both show the file statistics but differ in
    the formatting of the output. The first solution uses the `tabulate()` function
    to create an ASCII text table and the second uses the `rich` module to create
    a fancier table sure to impress your labmates and principal investigator (PI).
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Formatting with tabulate()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For my solution, I first decided to write a `process()` function that would
    handle each input file. Whenever I approach a problem that needs to handle some
    list of items, I prefer to focus on how to handle just one of the items. That
    is, rather than trying to find all the statistics for all the files, I first want
    to figure out how to find this information for just one file.
  prefs: []
  type: TYPE_NORMAL
- en: 'My function needs to return the filename and the four metrics: minimum/maximum/average
    sequence lengths, plus the number of sequences. Just as with the `Args` class,
    I like to create a type based on a `NamedTuple` for this so that I have a statically
    typed data structure that `mypy` can validate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I can define a function that returns this data structure. Note that I’m
    using the `numpy.mean()` function to get the average length. The `numpy` module
    offers many powerful mathematical operations to handle numeric data and is especially
    useful for multidimensional arrays and linear algebra functions. When importing
    the dependencies, it’s common to import the `numpy` module with the alias `np`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run **`help(np)`** in the REPL to read the documentation. Here’s how
    I wrote this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The function accepts a filehandle and returns a `FastaInfo` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use a list comprehension to read all the sequences from the filehandle. Use
    the `len()` function to return the length of each sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the file is available through the `fh.name` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `min()` function will return the minimum value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `max()` function will return the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `np.mean()` function will return the mean from a list of values. The `round()`
    function is used to round this floating-point value to two significant digits.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The number of sequences is the length of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO4-8)'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no sequences, return zeros for all the values.
  prefs: []
  type: TYPE_NORMAL
- en: As always, I want to write a unit test for this. While it’s true that the integration
    tests I wrote cover this part of the program, I want to show how you can write
    a unit test for a function that reads a file. Rather than relying on actual files,
    I’ll create a *mock* or fake filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use the `io.StringIO()` function to create an object that behaves like
    a filehandle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the data from the first input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a mock filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the lines of the mock filehandle.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the line which has a newline (`\n`), so use `end=''` to leave off an additional
    newline.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a slight problem, though, because the `process()` function calls the
    `fh.name` attribute to get the input filename, which will raise an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, there’s another way to create a mock filehandle using Python’s standard
    `unittest` module. While I favor the `pytest` module for almost everything I write,
    the `unittest` module has been around for a long time and is another capable framework
    for writing and running tests. In this case, I need to import the [`uni⁠t​test.mock.mock_open()`
    function.](https://oreil.ly/EGvXh) Here is how I can create a mock filehandle
    with the data from the first test file. I use `read_data` to define the data that
    will be returned by the `fh.read()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the context of testing, I don’t care about the filename, only that this
    returns a string and does not throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'While I often place my unit tests in the same modules as the functions they
    test, in this instance, I’d rather put this into a separate `unit.py` module to
    keep the main program shorter. I wrote the test to handle an empty file, a file
    with one sequence, and a file with more than one sequence (which are also reflected
    in the three input test files). Presumably, if the function works for these three
    cases, it should work for all others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `mock_open()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `process()` function I’m testing.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A mock empty filehandle that should have zeros for all the values.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A single sequence with three bases.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO6-5)'
  prefs: []
  type: TYPE_NORMAL
- en: A filehandle with two sequences of three and four bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use **`pytest`** to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I use my `process()` function in `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Process all the input files into a list of `FastaInfo` objects (tuples).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the table headers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `tabulate()` function to print a formatted output table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this program, I run it with the following inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: The empty file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file with one sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file with two sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the input files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start, I run all these with the default table style. Then I need to verify
    that all 10 of the table styles are created correctly. Combining all the possible
    test inputs with all the table styles creates a high degree of *cyclomatic complexity*—the
    number of different ways that parameters can be combined.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, I first need to manually verify that my program is working correctly.
    Then I need to generate sample outputs for each of the combinations I intend to
    test. I wrote the following `bash` script to create an *out* file for a given
    combination of an input file and possibly a table style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The program being tested.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The directory for the input files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The input files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program using the three input files and the default table style.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with two of the input files and all the table styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests in *tests/seqmagique_test.py* will run the program with a given file
    and will compare the output to one of the *out* files in the *tests/inputs* directory.
    At the top of this module, I define the input and output files like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'I define a `run()` function in the module to run the program with the input
    file and compare the actual output to the expected output. This is a basic pattern
    you could copy for testing any program’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Read the expected output from the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with the given input file using the default table style.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the return value is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the output was the expected value.
  prefs: []
  type: TYPE_NORMAL
- en: 'I use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Splat the tuple to pass the two values positionally to the `run()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test suite also checks the table styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define a list of all possible styles.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the two nonempty files.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each style.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The output file is the name of the input file plus the style and the extension
    *.out*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO11-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Check that the file exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO11-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Read the expected value from the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO11-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Randomly choose the short or long flag to test.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO11-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with the flag option, style, and file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO11-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the program ran without error and produces the correct output.
  prefs: []
  type: TYPE_NORMAL
- en: If I make a change such that the program no longer creates the same output as
    before, these tests should catch it. This is a *regression* test, where I am comparing
    how a program works now to how it previously worked. That is, a failure to produce
    the same output would be considered a regression. While my test suite isn’t completely
    exhaustive, it covers enough combinations that I feel confident the program is
    correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Formatting with rich'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this second solution I want to show a different way to create the output
    table, using the `rich` module to track the processing of the input files and
    make a fancier output table. [Figure 15-1](#fig_15.1) shows how the output looks.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 1501](assets/mpfb_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. The progress indicator and output table using the `rich` module
    are fancier
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'I still process the files in the same way, so the only difference is in creating
    the output. I first need to import the needed functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how I use these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the table to hold the data. The Name column is a standard, left-justified
    string field. All the others need to be right-justified and require a custom `Column`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each filehandle using the `track()` function to create a progress
    bar for the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Process the file to get the statistics.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Add the file’s statistics to the table. Note that all the values must be strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_seqmagique__creating__span_class__keep_together__and_formatting_reports__span__CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Console` object, and use it to print the output.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `seqmagick` tool has many other useful options. Implement your own versions
    of as many as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key points from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `seqmagick` tool provides many ways to examine sequence files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many ways to verify that your input files are complete and not corrupted,
    from examining file sizes to using message digests such as MD5 hashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `choices` option for `argparse` parameters will force the user to select
    a value from a given list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tabulate` and `rich` modules can create text tables of data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `numpy` module is useful for many mathematical operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `io.StringIO()` and `unittest.mock.mock_open()` functions offer two ways
    to mock a filehandle for testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regression testing verifies that a program continues to work as it did before.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
