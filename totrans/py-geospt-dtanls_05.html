<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 5. OpenStreetMap: Accessing Geospatial Data with OSMnx" data-type="chapter" epub:type="chapter"><div class="chapter" id="openstreetmap_accessing_geospatial_data">
<h1><span class="label">Chapter 5. </span>OpenStreetMap: Accessing <span class="keep-together">Geospatial Data with OSMnx</span></h1>
<p><a href="https://oreil.ly/UWkLH">OpenStreetMap (OSM)</a> is an editable geographic database of the entire world built by volunteers with an auspicious goal: to create geographic data and distribute it to all of us for free. <a contenteditable="false" data-primary="OpenStreetMap (OSM)" data-type="indexterm" id="ix_OSM"/>You have interacted with OSM already on your smartphone if you use GPS for directions—or any location-enabled device.<a contenteditable="false" data-primary="OSMnx package" data-type="indexterm" id="idm45433741332080"/> Python offers a package called <a href="https://oreil.ly/CR2vV">OSMnx</a> that lets urban planners and a wide variety of other users create street networks and interact with and analyze otherwise “hidden” geographic information. You can find walkable, drivable, or bikeable urban networks for your own personal use or for research, such as to study characteristics of urban environments. Robust analytics reveal infrastructure frameworks that disclose inefficiencies when analyzing the network and interrelated nature of roadways, for example.<a contenteditable="false" data-primary="OSM" data-see="OpenStreetMap" data-type="indexterm" id="idm45433741329744"/></p>
<p>Personally, I think street networks are works of art. But their real use, which is perhaps underutilized, is adding geometric shapes to your built infrastructure. You can add buildings (hospitals, schools, and grocery stores, for example), parks, and other dataframes categorized as edges, buildings, and areas. The term <em>building</em> is defined loosely, and there is a Wiki for <a href="https://oreil.ly/ZuB1n">building tags</a>. A great resource to find place names is <a href="https://oreil.ly/tmo4M">OSM Nominatim</a>. You can also add points of interest, elevations, and much more.<a contenteditable="false" data-primary="OSM Nominatim" data-type="indexterm" id="idm45433741324272"/></p>
<p>At first glance, OSMnx may seem a bit technical and complicated. But as you build street networks with OSM in this chapter, you’ll learn to apply and interact with this powerful, customizable package.</p>
<section data-pdf-bookmark="A Conceptual Model of OpenStreetMap" data-type="sect1"><div class="sect1" id="a_conceptual_model_of_openstreetmap">
<h1>A Conceptual Model of OpenStreetMap</h1>
<p>The <a href="https://oreil.ly/pPT7s">OSM database</a> contains more than 80,000 tag keys and 600 relation types, so you can define the appropriate granularity for your map.<a contenteditable="false" data-primary="OpenStreetMap (OSM)" data-secondary="conceptual model of" data-type="indexterm" id="ix_OSMcncpt"/> In this chapter, you will learn how to access these features, customize them, add them to your map, and perform analyses. For example, you can identify a location and explore the distribution of agricultural, commercial, or residential land use. (A snapshot of different land-use values you can access by querying the database is shown in <a data-type="xref" href="#some_of_the_tags_available_in_the_osm_d">Figure 5-2</a>, later in this section.) Understanding the distribution of land use in an area may be important if you are interested in how much flooding occurs there or how to calculate storm runoff. <a contenteditable="false" data-primary="tags" data-secondary="in OSM database" data-secondary-sortas="OSM" data-type="indexterm" id="idm45433743035712"/>The most popular tags in the database as of this writing include data about buildings, highways, land surface, and waterways.</p>
<p>OSM’s structure has a few rules, but they are relatively straightforward. For example, nodes can be arbitrary (<em>hashable</em>) Python objects, with both nodes and edges as optional key/value attributes. <a contenteditable="false" data-primary="objects" data-secondary="hashable Python objects in OSM" data-type="indexterm" id="idm45433741316784"/><a contenteditable="false" data-primary="hashable objects" data-type="indexterm" id="idm45433741315248"/>To view these optional values in their entirety, head over to either OSM <a href="https://oreil.ly/XDg2a">map features</a> or <a href="https://oreil.ly/oOkoG">tag info</a> (or follow along in the text).</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="is_hashable_the_same_as_immutablequesti">
<h5>Is Hashable the Same as Immutable?</h5>
<p>You may recall immutable objects as being values that do not change. <a contenteditable="false" data-primary="hashable objects" data-secondary="immutable objects versus" data-type="indexterm" id="idm45433741310384"/><a contenteditable="false" data-primary="immutable versus hashable objects" data-type="indexterm" id="idm45433741309040"/>Their value is set, and you cannot edit them—think tuples, like lists of days of the week, months of the year, and so forth.</p>
<p>If something is hashable, you can call <code>hash()</code>, and its value will not change during its lifetime. This is important when creating <code>key=value</code>.</p>
</div></aside>
<p>You can put a mutable object (like a list) inside a tuple. The tuple is still immutable, but you can change the list inside it, so it’s not hashable.</p>
<section data-pdf-bookmark="Tags" data-type="sect2"><div class="sect2" id="tags">
<h2>Tags</h2>
<p>OSM applies <a contenteditable="false" data-primary="OpenStreetMap (OSM)" data-secondary="conceptual model of" data-tertiary="tags" data-type="indexterm" id="idm45433741304400"/>a <em>tag</em> made up of a key-value pair. You will see these defined in the code cells we will write in this chapter.<a contenteditable="false" data-primary="key-value pairs" data-secondary="in OSM tags" data-secondary-sortas="OSM" data-type="indexterm" id="idm45433741301056"/> Their format is a <em>key</em> and its corresponding <em>value</em>, formatted as <code>key=value</code>. For example, if your key for a location is set to <code>highway</code> and the value is <code>residential</code>, you can tell that this is a road where people live.</p>
<p>Here are a few examples of tags:</p>
<pre data-type="programlisting">
surface=asphalt
highway=residential
building=commercial </pre>
<p>Depending on what you’re looking for, this level of granularity may be useful in your data exploration. I have used these tags to explore impervious surfaces in urban settings, for example.<a contenteditable="false" data-primary="impervious land cover" data-type="indexterm" id="idm45433741339056"/> Impervious surfaces tend to trap heat, and places with a lot of them tend to have higher rates of flooding—important information when comparing the characteristics of different neighborhoods. As another example, you might simply want a map of all the buildings in a neighborhood. The default value <code>buildings="all"</code> will then be uploaded. We’ll look at the utility of including tags in the code examples and sample Notebook for this chapter.</p>
<p>OSMnx extracts OSM data and creates a routable <a href="https://networkx.github.io">Python NetworkX</a> object for working with complex networks. This is needed to convert edges and nodes from OSM, as shown in <a data-type="xref" href="#a_map_of_the_walkable_street_network_in">Figure 5-1</a>, to links and junctions characteristic of routable networks. These routable maps are a network with features like travel time, speed limit, and shortest distance between locations allowing routing.</p>
<figure><div class="figure" id="a_map_of_the_walkable_street_network_in"><img alt="A map of the walkable street network in Manhattan’s Chelsea neighborhood" height="488" src="assets/pgda_0501.png" width="462"/>
<h6><span class="label">Figure 5-1. </span>A map of the walkable street network in Manhattan’s Chelsea neighborhood</h6>
</div></figure>
<p>OSMnx automates several mapping capabilities, including downloads of geometries like states, cities, neighborhoods, building footprints, customized street networks, and topology. In addition, OSMnx has built-in capabilities for analysis based on the foundation of graph theory.<a contenteditable="false" data-primary="graph theory" data-type="indexterm" id="idm45433741293968"/> Simply defined, <em>graph theory</em> represents connections between elements and their locations within spatial networks, including both nodes and edges. The NetworkX integration allows you to customize nodes and edges to hold a variety of data, images, graph algorithms, and network structures for analysis. Instead of solely geographic coordinates, vast amounts of information are stored for each location. We will begin exploring the types of data shortly. First, here’s a brief introduction to what’s under the hood.</p>
</div></section>
<section data-pdf-bookmark="Multidigraphs" data-type="sect2"><div class="sect2" id="multidigraphs">
<h2>Multidigraphs</h2>
<p><a data-type="xref" href="#a_map_of_the_walkable_street_network_in">Figure 5-1</a> shows edges between nodes. This is a preview of what we will build later in this chapter. The nodes are corners connected by street segments, which are weighted by length in this example. (You could also weight them by travel time, for example). This is one way to calculate the shortest paths between two places.<a contenteditable="false" data-primary="multidigraphs" data-type="indexterm" id="idm45433741311504"/><a contenteditable="false" data-primary="OpenStreetMap (OSM)" data-secondary="conceptual model of" data-tertiary="multidigraphs" data-type="indexterm" id="idm45433741325024"/></p>
<p>The data you are going to request in the next section will be in the format of a NetworkX multidigraph. <em>Multidigraphs</em> are abstract representations of objects or elements with multiple edges between the same nodes. They are directional, reflecting, for example, whether traffic on a specific city street is one-way or flows in both directions.<a contenteditable="false" data-primary="digraphs" data-type="indexterm" id="idm45433741278288"/> Digraphs have edges that point from node to node, but not necessarily in both directions. Once you have multiple edges in parallel, you have a multidigraph.</p>
<p>OSM is a <em>wiki</em>, an open source, editable geographic database. Its conceptual model includes <em>nodes</em> that define <a contenteditable="false" data-primary="nodes (OSM)" data-type="indexterm" id="idm45433741385776"/>points in space, <em>ways</em> defining linear <a contenteditable="false" data-primary="ways (OSM)" data-type="indexterm" id="idm45433741273904"/>features and boundaries, and <em>relations</em> that explain how nodes and ways work together.<a contenteditable="false" data-primary="relations (OSM)" data-type="indexterm" id="idm45433741272144"/> Think of a <em>node</em> as like a coordinate defined by latitude and longitude, with the <em>way</em> representing a<a contenteditable="false" data-primary="polylines" data-type="indexterm" id="idm45433741270592"/> list of nodes (called a <em>polyline</em>), or the boundaries of a polygon.</p>
<p>You might initially think of these spatial networks as simple planes, but there are plenty of nonplanar structures such as bridges, tunnels, and a variety of grade-separated structures like expressways, on- and off-ramps, and overpasses. You can evaluate these using topological measures<a contenteditable="false" data-primary="metric structures" data-type="indexterm" id="idm45433742794720"/> and <em>metric structures</em>, or length and area described in spatial units (such as meters). <a contenteditable="false" data-primary="land use tags in OSM" data-type="indexterm" id="idm45433742790048"/><a contenteditable="false" data-primary="tags" data-secondary="in OSM database to describe land use" data-secondary-sortas="OSM" data-type="indexterm" id="idm45433741264144"/>The wiki description defines the relationship between the land-use tag and the values available to be assigned to a key, as shown in <a data-type="xref" href="#some_of_the_tags_available_in_the_osm_d">Figure 5-2</a>.</p>
<p>Geographical data questions are often defined based on a specific location and usually have real-world implications. They often involve things like land use, road surfaces, number and types of buildings, or locations of community facilities, such as museums, bars, or internet access. For example, your data question might be something like:</p>
<ul>
<li>
<p>How many supermarkets are there in the seventh ward of Washington, DC?</p>
</li>
<li>
<p>How many green spaces or parks are located in a particular neighborhood?</p>
</li>
<li>
<p>How walkable is Chicago, Illinois?</p>
</li>
</ul>
<figure><div class="figure" id="some_of_the_tags_available_in_the_osm_d"><img alt="Some of the tags available in the OSM database to describe land use" height="1756" src="assets/pgda_0502.png" width="2338"/>
<h6><span class="label">Figure 5-2. </span>Some of the tags available in the OSM database to describe land use</h6>
</div></figure>
<p>First, let’s install OSM.<a contenteditable="false" data-primary="OpenStreetMap (OSM)" data-secondary="conceptual model of" data-startref="ix_OSMcncpt" data-type="indexterm" id="idm45433741256000"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Installing OSMnx" data-type="sect1"><div class="sect1" id="installing_osmnx">
<h1>Installing OSMnx</h1>
<p>Install OSMnx to a unique environment within your terminal.<a contenteditable="false" data-primary="OSMnx package" data-secondary="installing" data-type="indexterm" id="idm45433741251360"/> As I’ve noted before, I create different environments as a simple way to address dependencies and updates. Another lesson learned the hard way: if you need to update the package, delete and reinstall it into your environment.<a contenteditable="false" data-primary="Conda environment, creating" data-type="indexterm" id="idm45433741279088"/> I often delete environments after specific projects because they can take up significant space on your hard drive if you create them willy-nilly and let them sit there once no longer needed. This is easier if you name them with specificity. This seems to be the only way to be certain you have all of the dependencies also updated. If you receive a message in your code that a function has been deprecated, return to the <a href="https://oreil.ly/MZLFQ">user reference files</a> for clarification.</p>
<p>In your terminal, enter:</p>
<pre data-type="programlisting">
conda create -name OSM
conda activate OSM
conda install -c conda-forge osmnx
conda install -c conda-forge matplotlib
conda install -c conda-forge descartes 
conda install -c conda-forge shapely 
conda install -c conda-forge jupyter
conda install -c conda-forge jupyter_contrib_nbextensions</pre>
<p>You’ll be using OSMnx to retrieve the OSM data and matplotlib library to interact with and visualize your data.<a contenteditable="false" data-primary="matplotlib" data-type="indexterm" id="idm45433741776560"/></p>
<p>If you want to see the packages you’ve installed alongside OSMnx, after <code>conda activate env</code>, enter <code><strong>conda list</strong></code> into the terminal. If you forget the name of your environment, you can write <code><strong>conda env list</strong></code> and view all of them. Here, I’ve created a unique environment called <code>OSM</code>:</p>
<pre data-type="programlisting">
<span>(ox) MacBook-Pro</span><span>-8</span><span>:~ bonnymcclain$ conda list</span>
# packages in environment at <strong>/Users/bonnymcclain/opt/miniconda3/envs/OSM</strong>:</pre>
<p>When you are ready to launch a Notebook, type <code><strong>jupyter notebook</strong></code> into your terminal, and a Notebook will open.</p>
</div></section>
<section data-pdf-bookmark="Choosing a Location" data-type="sect1"><div class="sect1" id="choosing_a_location">
<h1>Choosing a Location</h1>
<p>To pass <code>place_name</code>, OSMnx uses OSM Nominatim API.<a contenteditable="false" data-primary="OSM Nominatim" data-type="indexterm" id="idm45433741236464"/><a contenteditable="false" data-primary="OSMnx package" data-secondary="choosing a location" data-type="indexterm" id="idm45433741235424"/> The <a href="https://oreil.ly/AZvAG">Nominatim Documentation</a> includes an API reference guide to search for geocoding (see <a data-type="xref" href="#using_nominatim_to_query_an_api_request">Figure 5-3</a>). If you enter incorrect information (for example, if you’re seeking a neighborhood by name but misspell it), you will likely get an error.<a contenteditable="false" data-primary="Nominatim" data-see="OSM Nominatim" data-type="indexterm" id="idm45433741233104"/> Open <a href="https://oreil.ly/AP9Sd">Nominatim</a>, and you will be taken to a debugging interface for the search engine that will look for the place you are requesting. I start there to make sure I am querying correctly.</p>
<figure><div class="figure" id="using_nominatim_to_query_an_api_request"><img alt="Using Nominatim to query an API request for place_name" height="842" src="assets/pgda_0503.png" width="1648"/>
<h6><span class="label">Figure 5-3. </span>Using Nominatim to query an API request for <code>place_name</code></h6>
</div></figure>
<p>Although you can add a place name as a string, it is best to check Nominatim and see how the location is listed to avoid conflicting or incorrect data. For example, I was looking for Brentwood, California, and got an error, so I ran it through Nominatim. It turned out that the boundaries were different for Brentwood as a neighborhood and for Brentwood’s administrative boundaries—and then there’s Brentwood Heights. I needed to make a minor adjustment in how I referred to the neighborhood.</p>
<p>This will make more sense when we begin working with these relationships. Refer to the <a href="https://oreil.ly/ZY8Nr">OSMnx documentation</a> for more, but you can also query directly inside of your code cell.</p>
<p>Let’s say you want a detailed street map of Los Angeles. In the following code, you’ll begin by importing the required packages: osmnx and matplotlib. Include <code>place_name</code> and set it equal to the desired location (within quotation marks in code). If you’re looking at something more specific than city and state, the more detail you include, the better. Run the following code (it may take some time):</p>
<pre data-type="programlisting">
import osmnx as ox
import networkx as nx
import matplotlib.pyplot as plt #installs with osmnx

# download/model a street network for some city then visualize it
G = ox.graph_from_place("Los Angeles,California,United States", 
network_type="drive")
fig, ax = ox.plot_graph(G,figsize=(20,20),bgcolor='#FFFFFF',
    node_color='black', node_size=0)</pre>
<p>Functions are written in the format <code>ox.module_name.function_name()</code>. <a contenteditable="false" data-primary="functions" data-secondary="in OSMnx" data-secondary-sortas="OSMnx" data-type="indexterm" id="idm45433741758112"/>The previous code snippet references the <code>osmnx.graph</code> module and the <code>graph_from_place</code> function. Most functions can be called with <code>ox.function_name()</code> only.<a contenteditable="false" data-primary="ox.function_name function" data-type="indexterm" id="idm45433741404736"/> This will retrieve the geocoded information from <code>Los Angeles,California,United States</code>, along with drivable-street-network data within the boundaries (<a data-type="xref" href="#street_networks_in_the_municipality_of">Figure 5-4</a>).</p>
<p>Go ahead and pick a smaller location if you prefer. Larger cities are resource intensive and may take a few minutes to load. Later in the chapter we will explore Culver City, California.</p>
<p>Place your cursor inside the parenthesis in your code where the ☞ icon is pointing. Here is the snippet isolated for clarity:</p>
<pre data-type="programlisting">
G = ox.graph_from_place(☞"Los Angeles,California")</pre>
<p>While your cursor is inside the parentheses, select Tab + Shift on your keyboard.</p>
<figure><div class="figure" id="street_networks_in_the_municipality_of"><img alt="Street networks in the municipality of Los Angeles, generated by OSMnx" height="1047" src="assets/pgda_0504.png" width="916"/>
<h6><span class="label">Figure 5-4. </span>Street networks in the municipality of Los Angeles, generated by OSMnx</h6>
</div></figure>
<p>Let’s see what parameters are possible!<a contenteditable="false" data-primary="parameters" data-secondary="functions in OSMnx" data-type="indexterm" id="idm45433741215616"/></p>
<p>For example, <a data-type="xref" href="#discovering_arguments_available_within">Figure 5-5</a> displays the characteristics of the signature. This is a list of the arguments, and they need to match the arguments listed in the signature of the function. Try the different options and see how the map changes.</p>
<figure><div class="figure" id="discovering_arguments_available_within"><img alt="Discovering arguments available within functions" height="287" src="assets/pgda_0505.png" width="876"/>
<h6><span class="label">Figure 5-5. </span>Discovering arguments available within functions</h6>
</div></figure>
<p class="pagebreak-before less_space">The <code>network_type</code> options for the <a contenteditable="false" data-primary="network_type parameter for functions in OSMnx" data-type="indexterm" id="idm45433741209664"/>function shown in <a data-type="xref" href="#discovering_arguments_available_within">Figure 5-5</a> are:</p>
<dl>
<dt><code>drive</code></dt>
<dd>Drivable public streets (not service roads)</dd>
<dt><code>drive_service</code></dt>
<dd>Drivable public streets, including service roads</dd>
<dt><code>walk</code></dt>
<dd>All streets and paths that pedestrians can use (ignores one-way directionality by always connecting adjacent nodes with reciprocal directed edges)</dd>
<dt><code>bike</code></dt>
<dd>All streets and paths that cyclists can use</dd>
<dt><code>all</code></dt>
<dd>All (nonprivate) OSM streets and paths</dd>
<dt><code>all_private</code></dt>
<dd>All OSM streets and paths, including private access</dd>
</dl>
</div></section>
<section data-pdf-bookmark="Understanding Arguments and Parameters" data-type="sect1"><div class="sect1" id="understanding_arguments_and_parameters">
<h1>Understanding Arguments and Parameters</h1>
<p>Have you ever heard <a contenteditable="false" data-primary="OSMnx package" data-secondary="arguments and parameters" data-type="indexterm" id="ix_OSMnxargpar"/>the expression, “Nobody is coming to save you”? <a contenteditable="false" data-primary="parameters" data-secondary="understanding in OSM" data-type="indexterm" id="ix_params"/><a contenteditable="false" data-primary="arguments" data-type="indexterm" id="ix_args"/>I am convinced it was first uttered by a data scientist. When your code won’t execute (and, trust me, that isn’t an “if” so much as a “when”), you will need to go read the user documentation. That might be documentation about the package itself or perhaps a GitHub repository. Features and arguments are deprecated and updated with newer versions. Knowing how to find them is an important skill to develop.</p>
<p>If you scroll down past the parameters, you will notice customizations of these variables in the code snippets. I can’t include every function and associated argument here, but let’s take some examples. Select the inverted chevron in the upper right corner to display the contents of the box (^, as shown in <a data-type="xref" href="#discovering_arguments_available_within">Figure 5-5</a>). Scroll down and you will see a section called “Docstring.”</p>
<p><em>Docstrings</em> provide quick information about a class, function, or method. <a contenteditable="false" data-primary="Docstrings" data-type="indexterm" id="idm45433741522704"/>I look here for hints on how to formulate my query. When you need additional information about a function, return your cursor inside the parentheses and select Tab + Shift. Here is an example of the type of documentation available:</p>
<pre data-type="programlisting">
Docstring:
Create graph from OSM within the boundaries of some geocodable place(s).

The query must be geocodable and OSM must have polygon boundaries for the geocode 
result. If OSM does not have a polygon for this place, you can instead get its 
street network using the graph_from_address function, which geocodes the place 
name to a point and gets the network within some distance of that point.

If OSM does have polygon boundaries for this place but you’re not finding it, 
try to vary the query string, pass in a structured query dict, or vary the 
which_result argument to use a different geocode result. If you know the OSM ID 
of the place, you can retrieve its boundary polygon using the geocode_to_gdf 
function, then pass it to the graph_from_polygon function.</pre>
<p>As you continue to scroll down in the interface, you will see a “Parameters” section. This section provides information about data types and how to complete the query. Not all parameters are needed, depending on your query. If you leave some parameters out, the defaults will be displayed.</p>
<p>Take another look at the code snippet you used to generate the Los Angeles map in <a data-type="xref" href="#street_networks_in_the_municipality_of">Figure 5-4</a>. This map requires entering information for the <code>network_type</code> parameter: in this case, <code>network_type="drive"</code>. The function takes a string (hence the quotation marks), and the options are listed and must be within parentheses. Here they are, as listed in the documentation:</p>
<pre data-type="programlisting">
Parameters
----------
<strong>query</strong> : string or dict or list
    the query or queries to geocode to get place boundary polygon(s)
<strong>network_type</strong> : string {"all_private", "all", "bike", "drive", "drive_service", 
"walk"}
    what type of street network to get if custom_filter is None
<strong>simplify</strong> : bool
    if True, simplify graph topology with the `simplify_graph` function
<strong>retain_all</strong> : bool
    if True, return the entire graph even if it is not connected.
    otherwise, retain only the largest weakly connected component.
truncate_by_edge : bool
    if True, retain nodes outside boundary polygon if at least one of
    node's neighbors is within the polygon
which_result : int
    which geocoding result to use. if None, auto-select the first
    (Multi)Polygon or raise an error if OSM doesn't return one.
buffer_dist : float
    distance to buffer around the place geometry, in meters
clean_periphery : bool
    if True, buffer 500m to get a graph larger than requested, then
    simplify, then truncate it to requested spatial boundaries
custom_filter : string
    a custom ways filter to be used instead of the network_type 
    presets  e.g., '["power"~"line"]' or 
    '["highway"~"motorway|trunk"]'. Also pass in a network_type that 
    is in settings.bidirectional_network_types if you want graph 
    to be fully bi-directional.</pre>
</div></section>
<section data-pdf-bookmark="Calculating Travel Times" data-type="sect1"><div class="sect1" id="calculating_travel_times">
<h1>Calculating Travel Times</h1>
<p>A popular type of data question involves travel time: <em>how long will it take to get from point A to point B?<a contenteditable="false" data-primary="OSMnx package" data-secondary="arguments and parameters" data-startref="ix_OSMnxargpar" data-type="indexterm" id="idm45433741180784"/><a contenteditable="false" data-primary="parameters" data-secondary="understanding in OSM" data-startref="ix_params" data-type="indexterm" id="idm45433741178944"/><a contenteditable="false" data-primary="arguments" data-startref="ix_args" data-type="indexterm" id="idm45433741177296"/></em><a contenteditable="false" data-primary="OSMnx package" data-secondary="calculating travel times" data-type="indexterm" id="ix_OSMnxcalctrvl"/><a contenteditable="false" data-primary="travel times, calculating" data-type="indexterm" id="ix_trvltm"/></p>
<p>To answer this kind of question, you can plot <em>networks</em> (where edges intersect) and calculate <em>free-flow travel time</em>, using the imputed maximum speed allowed on a specific highway type.<a contenteditable="false" data-primary="free-flow travel time" data-type="indexterm" id="idm45433741170544"/><a contenteditable="false" data-primary="networks" data-type="indexterm" id="idm45433741169568"/> In other words, when considering the maximum speed on a road, the time calculated to drive the distance is defined as <em>free-flow</em>. The <code>osmnx.speed</code> module calculates speed and travel times by providing<a contenteditable="false" data-primary="osmn.speed module" data-type="indexterm" id="idm45433741167472"/> kilometers per hour as <code>speed_kph</code> edge attributes. <a contenteditable="false" data-primary="speed_kph edge attributes" data-type="indexterm" id="idm45433741166544"/>Complex networks are formed from the connections between nodes and edges. Analyzing these structures with the NetworkX Python package allows you to view a node as an element and the connection between nodes as an edge to study their relationship.<a contenteditable="false" data-primary="NetworkX package ( Python)" data-type="indexterm" id="idm45433741755520"/></p>
<p>Let’s try running a function to calculate travel time:</p>
<pre data-type="programlisting">
ox.speed.add_edge_speeds(G, hwy_speeds=<strong>None</strong>, fallback=<strong>None</strong>, precision=<span>1</span>)
ox.speed.add_edge_travel_times(G, precision=<span>1</span>)</pre>
<p>Notice that you have four inputs here. Let’s break these down and look at how the OSM documentation defines them:</p>
<dl>
<dt><code>G</code></dt>
<dd>The input graph</dd>
<dt><code>hwy_speeds</code></dt>
<dd>The mean speed value of all edges in highway type (if empty)</dd>
<dt><code>f</code><code>allback</code></dt>
<dd>A backup speed, in case the road type has no preexisting value</dd>
<dt><code>p</code><code>recision</code></dt>
<dd>Rounding to the desired decimal precision</dd>
</dl>
<p>Only <code>G</code>, the NetworkX MultiGraph, is being passed into the function. <a contenteditable="false" data-primary="shortest distance between points" data-type="indexterm" id="idm45433741153216"/>If the origin (<code>orig</code>) and destination (<code>dest</code>) are both specified, you’ll get a single list of nodes in a shortest path from the source to the target. These routes are distinct, to show how you can plot <code>travel_times</code> and <code>edge_speeds</code> to find the shortest routes between destinations.</p>
<p>You are setting weight to equal <code>w</code> instead of the default none. Here’s what it looks like:</p>
<pre data-type="programlisting">
G = ox.add_edge_speeds(G)
G = ox.add_edge_travel_times(G)

w = <span>'travel_time'</span>
orig, dest = list(G)[<span>10</span>], list(G)[<span>-10</span>]
route1 = nx.shortest_path(G, orig, dest, weight=w)
orig, dest = list(G)[<span>0</span>], list(G)[<span>-1</span>]
route2 = nx.shortest_path(G, orig, dest, weight=w)
orig, dest = list(G)[<span>-100</span>], list(G)[<span>100</span>]
route3 = nx.shortest_path(G, orig, dest, weight=w)

routes = [route1, route2, route3]
rc = [<span>'r'</span>, <span>'y'</span>, <span>'c'</span>]
fig, ax = ox.plot_graph_routes(G, routes, route_colors=rc, route_linewidth=<span>6</span>, 
figsize=(<span>30</span>, <span>30</span>),node_size=<span>0</span>,bgcolor=<span>'#FFFFFF'</span>)</pre>
<p><a data-type="xref" href="#calculating_the_shortest_distance_betwe">Figure 5-6</a> uses OSMnx’s color options as well. <em>Color options</em> can be described as attribute values for each edge in a path. <em>Attribute values</em> can represent a property, such as data about how the graph was constructed, the color of the vertices when the graph is plotted, or simply the weights of the edges in a weighted graph. In <a data-type="xref" href="#calculating_the_shortest_distance_betwe">Figure 5-6</a>, the routes are represented by different colors.</p>
<figure><div class="figure" id="calculating_the_shortest_distance_betwe"><img alt="Calculating the shortest distance between points in Los Angeles by computing weighted travel times" height="1569" src="assets/pgda_0506.png" width="1372"/>
<h6><span class="label">Figure 5-6. </span>Calculating the shortest distance between points in Los Angeles by computing weighted travel times</h6>
</div></figure>
<p>The full street network does consume resources, so let’s select a specific neighborhood to get a more manageable visualization to query. In the code snippet that follows, I designated Culver City, California, to include all the private roads within the city limits (see <a data-type="xref" href="#a_neighborhood_level_street_network_map">Figure 5-7</a>):</p>
<pre data-type="programlisting">
place_name = <span>'Culver City, California, United States'</span>
G = ox.graph_from_place(place_name, clean_periphery=<strong>False</strong>,
network_type=<span>"all_private"</span>)
fig, ax = ox.plot_graph(G,figsize=(<span>7</span>,<span>7</span>),bgcolor=<span>'#FFFFFF'</span>,
     node_color=<span>"b"</span>,node_size=<span>3</span>)</pre>
<figure><div class="figure" id="a_neighborhood_level_street_network_map"><img alt="A neighborhood-level street network map of Culver City, California" height="386" src="assets/pgda_0507.png" width="431"/>
<h6><span class="label">Figure 5-7. </span>A neighborhood-level street network map of Culver City, California</h6>
</div></figure>
<p>If you are <a contenteditable="false" data-primary="neighborhood-level street network map" data-type="indexterm" id="idm45433741134736"/>curious about colorizing nodes or edges, you can explore <a href="https://oreil.ly/zjof8"><code>key:colour</code></a> options on the OSM wiki page or in the user reference documentation. <a data-type="xref" href="#key_color_options_in_osm_left_parenthes">Figure 5-8</a> shows the most common color codes but is certainly not exhaustive. The color variation is somewhat self-explanatory, but you can refer to the exact color on the <a href="https://oreil.ly/zjof8">OSM wiki</a>. I find the chart useful to grab the color codes I use most frequently.</p>
<figure><div class="figure" id="key_color_options_in_osm_left_parenthes"><img alt="Key color options in OSM (not exhaustive, but a handy reference)" height="517" src="assets/pgda_0508.png" width="1348"/>
<h6><span class="label">Figure 5-8. </span>Key color options in OSM (not exhaustive, but a handy reference)</h6>
</div></figure>
<p>You have built a few street networks and maps in OSMnx. Now let’s see what additional information you can extract.<a contenteditable="false" data-primary="travel times, calculating" data-startref="ix_trvltm" data-type="indexterm" id="idm45433741127072"/><a contenteditable="false" data-primary="OSMnx package" data-secondary="calculating travel times" data-startref="ix_OSMnxcalctrvl" data-type="indexterm" id="idm45433741125840"/></p>
</div></section>
<section data-pdf-bookmark="Basic Statistical Measures in OSMnx" data-type="sect1"><div class="sect1" id="basic_statistical_measures_in_osmnx">
<h1>Basic Statistical Measures in OSMnx</h1>
<p>Visualizing street networks is meaningful, but the OSMnx framework also allows you to generate descriptive geometric and topological measures.<a contenteditable="false" data-primary="statistical measures in OSMnx" data-type="indexterm" id="ix_statmeas"/><a contenteditable="false" data-primary="OSMnx package" data-secondary="basic statistical measures in" data-type="indexterm" id="ix_OSMnxstatmeas"/> Topographic measures can offer insights like the average number of nodes per street.</p>
<section data-pdf-bookmark="Circuity" data-type="sect2"><div class="sect2" id="circuity">
<h2>Circuity</h2>
<p>To introduce the concept<a contenteditable="false" data-primary="circuity" data-type="indexterm" id="idm45433741117056"/> of circuity, let’s calculate <a contenteditable="false" data-primary="statistical measures in OSMnx" data-secondary="circuity" data-type="indexterm" id="idm45433741115264"/>the average <a contenteditable="false" data-primary="OSMnx package" data-secondary="basic statistical measures in" data-tertiary="circuity" data-type="indexterm" id="idm45433741113728"/>circuity in Manhattan and compare it to Staten Island. <em>Circuity</em> is the ratio of network distances to straight-line distances. Circuity is an important measure in urban networks; it indicates transportation efficiencies and may also show inequities between different geographic areas and populations. Circuity averages differ in different neighborhoods, on different subway routes, and with the length and time of travel. Researchers used circuity as part of a study that found a correlation between <a href="https://oreil.ly/7qGjF">subway turnstile entries in New York City and COVID-19 cases and deaths</a> between March and May 2020.</p>
<p>How circuitous your journey from point A to point B is, compared to other journeys, relies on a variety of factors, such as land-use systems, the design of transportation options, hubs, and cost. Network distances like circuity are calculated based on the actual grid and layout of a city, instead of “as the crow flies”—that is, a simple straight line between two points. You can always assume that actual distances to locations are quite a bit farther.</p>
<p class="pagebreak-before less_space">I will repeat the import details in case you are moving between different sections. There is a new line in the code:</p>
<pre data-type="programlisting">
 %matplotlib inline</pre>
<p>The % character indicates this is a Python “magic function.” The <a contenteditable="false" data-primary="Python" data-secondary="magic functions" data-type="indexterm" id="idm45433741762736"/>argument<a contenteditable="false" data-primary="magic functions (Python)" data-type="indexterm" id="idm45433741734096"/> is the line that follows:</p>
<pre data-type="programlisting">
ox.__version__</pre>
<p>These <em>magic functions</em> (or dunder methods) with double underscores provide additional functionality.<a contenteditable="false" data-primary="matplotlib" data-secondary="displaying plotting command inline in Jupyter Notebook" data-type="indexterm" id="idm45433741100800"/> In this example, matplotlib will display the plotting command within the Jupyter Notebook right below the code.</p>
<p>Parentheses are not needed. This places the plotting output inside the Jupyter Notebook beneath the coding cell:</p>
<pre data-type="programlisting">
<strong>import</strong> osmnx <strong>as</strong> ox
<strong>import</strong> networkx <strong>as</strong> nx
<strong>import</strong> matplotlib.pyplot <strong>as</strong> plt <span>#installs with osmnx</span>
<strong>import</strong> pandas <strong>as</strong> pd
%matplotlib inline
ox.__version__</pre>
<p>Here is a value for travel in Manhattan, which has a robust transportation framework:</p>
<pre data-type="programlisting">
# get the network for Manhattan, calculate its basic stats and show the average 
circuity<span>
stats = ox.basic_stats(ox.graph_from_place(</span><span>"Manhattan,New York,United States"</span><span>))
stats[</span><span>"circuity_avg"</span><span>]</span></pre>
<p>The output is 1.0366712806100773.</p>
<p>You can now compare this value to other boroughs. Lower circuity values indicate higher efficiency. The other four boroughs of New York City present different transportation challenges. Traveling within Staten Island, for instance, is 4% less direct than traveling within Manhattan, as the output of the following code indicates:</p>
<pre data-type="programlisting">
# get the network for Staten Island, calculate its basic stats and show the 
average circuity<span>
stats = ox.basic_stats(ox.graph_from_place(</span><span>"Staten Island,New York,United States"</span><span>))
stats[</span><span>"circuity_avg"</span><span>]</span></pre>
<p>This output is 1.0732034499369911.</p>
</div></section>
<section data-pdf-bookmark="Network Analysis: Circuity in Paris, France" data-type="sect2"><div class="sect2" id="network_analysis_circuity_in_pariscomma">
<h2>Network Analysis: Circuity in Paris, France</h2>
<p>Let’s have a little fun and explore Paris, specifically, part of its urban infrastructure—the roadways. <a contenteditable="false" data-primary="OSMnx package" data-secondary="basic statistical measures in" data-tertiary="network analysis, circuity in Paris, France" data-type="indexterm" id="idm45433741085456"/><a contenteditable="false" data-primary="statistical measures in OSMnx" data-secondary="network analysis, circuity in Paris, France" data-type="indexterm" id="idm45433741259440"/><a contenteditable="false" data-primary="circuity" data-secondary="network analysis of circuity in Paris, France" data-type="indexterm" id="idm45433741086352"/><a contenteditable="false" data-primary="networks" data-secondary="analysis, circuity in Paris, France" data-type="indexterm" id="idm45433741082256"/>First, let’s calculate circuity:</p>
<pre data-type="programlisting">
stats = ox.basic_stats(ox.graph_from_place(<span>"Paris, France"</span>))
stats[<span>"circuity_avg"</span>]</pre>
<p>And the output: 1.0377408863844562.</p>
<p>Viewing the network statistics for a place is as simple as updating the place name (according to the Nominatim standards of OSM) and running the cell. The street network is then loaded, along with the area in square meters. Let’s get Paris’s street network and area:</p>
<pre data-type="programlisting">
<span># get street network, and area in square meters</span>
place = <span>"Paris, France"</span>
gdf = ox.geocode_to_gdf(place)
area = ox.project_gdf(gdf).unary_union.area
G = ox.graph_from_place(place, network_type=<span>"drive"</span>)</pre>
<p>Now let’s calculate and merge the statistics:</p>
<pre data-type="programlisting">
<span># calculate basic stats, merge them, and display</span>
stats = ox.basic_stats(G, area=area)
pd.Series(stats)</pre>
<p>The counts of streets and networks are stored as nested dictionaries inside the statistics dictionary. The following code unpacks those nested dictionaries and then converts them to a pandas dataframe:</p>
<pre data-type="programlisting">
<span># unpack dicts into individual keys:values</span>
stats = ox.basic_stats(G, area=area)
<strong>for</strong> k, count <strong>in</strong> stats[<span>"streets_per_node_counts"</span>].items():
    stats[<span>"{}way_int_count"</span>.format(k)] = count
<strong>for</strong> k, proportion <strong>in</strong> stats[<span>"streets_per_node_proportions"</span>].items():
    stats[<span>"{}way_int_prop"</span>.format(k)] = proportion
<span># delete the no longer needed dict elements</span>
<strong>del</strong> stats[<span>"streets_per_node_counts"</span>]
<strong>del</strong> stats[<span>"streets_per_node_proportions"</span>]

<span># load as a pandas dataframe</span>
pd.DataFrame(pd.Series(stats, name=<span>"value"</span>)).round(<span>3</span>)</pre>
<p>This example is probably more granular than most of what you’ll need, but I want you to see the data you can use to calculate measures such as shortest distance.<sup><a data-type="noteref" href="ch05.xhtml#ch01fn9" id="ch01fn9-marker">1</a></sup></p>
<p>At a glance, you can determine the number of streets emerging from each node. If you are interested in density, you can count the number of intersections or meters of linear street distance.<a contenteditable="false" data-primary="linear street distance" data-type="indexterm" id="idm45433741062624"/> Specifically, <em>linear street distance</em> represents a sum of total street length in an undirected representation of a network, meaning directionality (one-way and two-way streets) is not captured. That information is important for driving directions but not as important for walking directions.</p>
</div></section>
<section data-pdf-bookmark="Betweenness Centrality" data-type="sect2"><div class="sect2" id="betweenness_centrality">
<h2>Betweenness Centrality</h2>
<p>Let’s ask a data question: <em>how long is the average Parisian street?</em> <a contenteditable="false" data-primary="statistical measures in OSMnx" data-secondary="betweenness centrality" data-type="indexterm" id="ix_statmeasbtwncen"/><a contenteditable="false" data-primary="OSMnx package" data-secondary="basic statistical measures in" data-tertiary="betweenness centrality" data-type="indexterm" id="ix_OSMnxstatmeasbtwn"/>Average street length is a nice linear proxy for block size.<a contenteditable="false" data-primary="housing prices and walkability" data-type="indexterm" id="idm45433741052528"/><a contenteditable="false" data-primary="betweenness centrality" data-type="indexterm" id="ix_btwn"/><a contenteditable="false" data-primary="walkability" data-type="indexterm" id="idm45433741050176"/> These measures provide urban-planning information about walkability and housing prices; for instance, a smaller block size translates to higher walkability and higher home prices.<a contenteditable="false" data-primary="networks" data-secondary="statistics for Paris, France" data-type="indexterm" id="idm45433742211664"/> <a data-type="xref" href="#network_statistics_for_the_city_of_pari">Figure 5-9</a> shows the overall output of our statistics.</p>
<p><em>Betweenness centrality</em> measures how central a location or node is within a larger network or neighborhood. You can see that in Paris, the area with the highest betweenness centrality has 11% of all the shortest paths running through its boundaries. What does this tell us? Shorter road segments typically cluster around central business districts or historical districts or serve as conduits for navigating throughout a city.</p>
<figure><div class="figure" id="network_statistics_for_the_city_of_pari"><img alt="Network statistics for the city of Paris, France" height="808" src="assets/pgda_0509.png" width="428"/>
<h6><span class="label">Figure 5-9. </span>Network statistics for the city of Paris, France</h6>
</div></figure>
<p>How important is the node?<a contenteditable="false" data-primary="nodes (OSM)" data-secondary="in betweenness centrality calculations" data-secondary-sortas="betweenness" data-type="indexterm" id="idm45433742501376"/> Think about a chain of command where information has to travel through a single person to be dispensed to the rest of the organization. If only 11% of the information has to pass through it, then in general, it isn’t critical to the flow through the network. You can see the max node as a small red dot in the lefthand image (A) in <a data-type="xref" href="#left_parenthesisaright_parenthesis_digr">Figure 5-10</a>. In the following code cell, the shortest path between the nodes is calculated. The parameter weight considers the edge attribute length. The function will return the betweenness centrality:</p>
<pre data-type="programlisting">
<span># calculate betweenness with a digraph of G (ie, no parallel edges)</span>
bc = nx.betweenness_centrality(ox.get_digraph(G), weight=<span>"length"</span>)
max_node, max_bc = max(bc.items(), key=<strong>lambda</strong> x: x[<span>1</span>])
max_node, max_bc</pre>
<p>The output is <code>(332476877, 0.1128095261389006)</code>.</p>
<figure><div class="figure" id="left_parenthesisaright_parenthesis_digr"><img alt="(A) Digraph (max node) of betweenness in Paris highlighting the maximum node of betweenness centrality; (B) Visualizing every node in the graph" height="492" src="assets/pgda_0510.png" width="1441"/>
<h6><span class="label">Figure 5-10. </span>(A) Digraph (max node) of betweenness in Paris highlighting the maximum node of betweenness centrality; (B) Visualizing every node in the graph</h6>
</div></figure>
<p>Node color (<code>nc</code>) will retrieve a node <a contenteditable="false" data-primary="digraphs" data-secondary="max node of betweenness in Paris, France" data-type="indexterm" id="idm45433741121520"/>with the highest centrality and observe the result in the graph object shown in <a data-type="xref" href="#left_parenthesisaright_parenthesis_digr">Figure 5-10</a>. Node size (<code>ns</code>) is calculated as well. You can adjust these values based on your desired visualization:</p>
<pre data-type="programlisting">
nc = [<span>"r"</span> <strong>if</strong> node == max_node <strong>else</strong> <span>"grey"</span> <strong>for</strong> node <strong>in</strong> G.nodes]
ns = [<span>100</span> <strong>if</strong> node == max_node <strong>else</strong> <span>15</span> <strong>for</strong> node <strong>in</strong> G.nodes]
fig, ax = ox.plot_graph(G, node_size=ns, node_color=nc, node_zorder=<span>5</span>)
plt.show()</pre>
<p>Next, try adding color to every node, to visualize 11% of all shortest paths relative to all nodes in <a data-type="xref" href="#left_parenthesisaright_parenthesis_digr">Figure 5-10</a> (B):</p>
<pre data-type="programlisting">
<span># add the betweenness centrality values as new node attributes, then plot</span>
nx.set_node_attributes(G, bc, <span>"bc"</span>)
nc = ox.plot.get_node_colors_by_attr(G, <span>"bc"</span>, cmap=<span>"plasma"</span>)
fig, ax = ox.plot_graph(
    G,
    node_color=nc,
    node_size=<span>30</span>,
    node_zorder=<span>2</span>,
    edge_linewidth=<span>0.2</span>,
    edge_color=<span>"w"</span>,
)</pre>
<p>When observing street networks visually, it can be a challenge to identify important nodes and measures of centrality. Plotting the node attributes gives you an easily identifiable region for a deeper review. What other features are located nearby? How might this influence the values we observe at this node?<a contenteditable="false" data-primary="OSMnx package" data-secondary="basic statistical measures in" data-startref="ix_OSMnxstatmeasbtwn" data-tertiary="betweenness centrality" data-type="indexterm" id="idm45433741535952"/><a contenteditable="false" data-primary="statistical measures in OSMnx" data-secondary="betweenness centrality" data-startref="ix_statmeasbtwncen" data-type="indexterm" id="idm45433742049696"/><a contenteditable="false" data-primary="betweenness centrality" data-startref="ix_btwn" data-type="indexterm" id="idm45433741017264"/></p>
</div></section>
<section data-pdf-bookmark="Network Types" data-type="sect2"><div class="sect2" id="network_types">
<h2>Network Types</h2>
<p>How about we stick around in France a little longer?<a contenteditable="false" data-primary="OSMnx package" data-secondary="basic statistical measures in" data-tertiary="network types" data-type="indexterm" id="idm45433741013424"/><a contenteditable="false" data-primary="statistical measures in OSMnx" data-secondary="network types" data-type="indexterm" id="idm45433741011616"/><a contenteditable="false" data-primary="networks" data-secondary="types of in OSM" data-type="indexterm" id="idm45433741010240"/><a contenteditable="false" data-primary="Jupyter Notebooks" data-secondary="import function, repeating for OSMnx and related packages" data-type="indexterm" id="idm45433741008864"/> In Jupyter Notebooks, I often repeat the import functions for simplicity, to avoid scrolling up and down when running or rerunning a section. I will do the same thing here:</p>
<pre data-type="programlisting">
<strong>import</strong> osmnx <strong>as</strong> ox
<strong>import</strong> networkx <strong>as</strong> nx
<strong>import</strong> geopandas <strong>as</strong> gpd
<strong>import</strong> matplotlib.pyplot <strong>as</strong> plt
plt.style.use(<span>'default'</span>)
<strong>import</strong> pandas <strong>as</strong> pd</pre>
<p>There are a few network types to explore. The most common are <code>walk</code>, <code>bike</code>, and <code>drive</code>, or you can even explore <code>all</code>. Some of those options can be quite congested in a city like Paris. Let’s try <code>drive</code> and explore what that measures. Generate the figure in your Notebook:</p>
<pre data-type="programlisting">
place_name = <span>"Paris, France"</span>
graph = ox.graph_from_place(place_name, network_type=<span>'drive'</span>)
fig, ax = ox.plot_graph(graph)</pre>
<p>You want edges (streets), so you will <a contenteditable="false" data-primary="edges in OSM" data-type="indexterm" id="idm45433740997040"/>need to create a variable:</p>
<pre data-type="programlisting">
edges = ox.graph_to_gdfs(graph, nodes=<strong>False</strong>, edges=<strong>True</strong>)</pre>
<p>What type of columns?<a contenteditable="false" data-primary="columns in drive network" data-type="indexterm" id="idm45433740993824"/> What is the projection? The following code cells provide this information:</p>
<pre data-type="programlisting">
edges.columns</pre>
<p>The output is:</p>
<pre data-type="programlisting">
Index(['osmid', 'name', 'highway', 'maxspeed', 'oneway', 'reversed', 'length',
       'lanes', 'geometry', 'junction', 'width', 'bridge', 'tunnel', 'access',
       'ref'],
      dtype='object')</pre>
<p>You also will need to know <a contenteditable="false" data-primary="CRS (coordinate reference system)" data-type="indexterm" id="idm45433740989984"/>the CRS to identify location in geographic space:</p>
<pre data-type="programlisting">
edges.crs</pre>
<p>And the output:</p>
<pre data-type="programlisting">
&lt;Geographic 2D CRS: EPSG:4326&gt;
Name: WGS 84
Axis Info [ellipsoidal]:
- Lat[north]: Geodetic latitude (degree)
- Lon[east]: Geodetic longitude (degree)
Area of Use:
- name: World.
- bounds: (-180.0, -90.0, 180.0, 90.0)
Datum: World Geodetic System 1984 ensemble
- Ellipsoid: WGS 84
- Prime Meridian: Greenwich</pre>
<p>I am a visual person, so I like to see the column headings with a sample of the data. Set that up next:</p>
<pre data-type="programlisting">
edges.head()</pre>
<p>Now you can run the following code for a summary of the types of roads and how they are classified:</p>
<pre data-type="programlisting">
print(edges[<span>'highway'</span>].value_counts())</pre>
<p>Here is the output:</p>
<pre data-type="programlisting">
residential                                  8901
primary                                      2984
tertiary                                     2548
secondary                                    2542
unclassified                                  648
living_street                                 458
trunk_link                                    194
trunk                                         146
primary_link                                  118
[residential, living_street]                   41
secondary_link                                 37
[unclassified, residential]                    30
tertiary_link                                  20
motorway_link                                  16
…</pre>
<p>OSM contains information about roadways that you can access for a wide variety of uses. The infrastructure of any location or city can provide information about how easy it is to access transportation into and out of that location, which might influence the social nature of neighborhoods, communities, and larger networks of populations.<a contenteditable="false" data-primary="statistical measures in OSMnx" data-startref="ix_statmeas" data-type="indexterm" id="idm45433752398640"/><a contenteditable="false" data-primary="OSMnx package" data-secondary="basic statistical measures in" data-startref="ix_OSMnxstatmeas" data-type="indexterm" id="idm45433740981904"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Customizing Your Neighborhood Maps" data-type="sect1"><div class="sect1" id="customizing_your_neighborhood_maps">
<h1>Customizing Your Neighborhood Maps</h1>
<p>Let’s look at how you can create, customize, automatically download, and compare street network maps.<a contenteditable="false" data-primary="OSMnx package" data-secondary="customizing neighborhood maps" data-type="indexterm" id="ix_OSMnxcusngbh"/><a contenteditable="false" data-primary="neighborhood maps, customizing in OSMnx" data-type="indexterm" id="ix_neighbmp"/> For this exercise, we’ll travel back to Culver City and generate a neighborhood map.</p>
<section data-pdf-bookmark="Geometries from Place" data-type="sect2"><div class="sect2" id="geometries_from_place">
<h2>Geometries from Place</h2>
<p>The following code generates the map of <a contenteditable="false" data-primary="neighborhood maps, customizing in OSMnx" data-secondary="geometries from place" data-type="indexterm" id="idm45433740971312"/>Culver City, California, in <a data-type="xref" href="#using_place_to_call_a_specific_geometry">Figure 5-11</a>; including the tag <code>building</code> will add building footprints to the map:</p>
<pre data-type="programlisting">
place = <span>"Culver City, California"</span>
tags = {<span>"building"</span>: <strong>True</strong>}
gdf = ox.geometries_from_place(place, tags={'building':True})
gdf.shape</pre>
<p>I am defaulting to <code>#FFFFFF</code> (white) as a background color to make the map more easily printable:</p>
<pre data-type="programlisting">
fig, ax = ox.plot_geometries(gdf, figsize=(<span>10</span>, <span>10</span>),bgcolor=<span>'#FFFFFF'</span>)</pre>
<p>Go ahead and see what you can create. <a data-type="xref" href="#using_place_to_call_a_specific_geometry">Figure 5-11</a> shows the city geometry with building footprints.</p>
<figure><div class="figure" id="using_place_to_call_a_specific_geometry"><img alt="Using place to call a specific geometry by location in OSMnx for Culver City, California" height="574" src="assets/pgda_0511.png" width="643"/>
<h6><span class="label">Figure 5-11. </span>Using place to call a specific geometry by location in OSMnx for Culver City, California</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Geometries from Address" data-type="sect2"><div class="sect2" id="geometries_from_address">
<h2>Geometries from Address</h2>
<p>Perhaps you have geographic coordinates for a location.<a contenteditable="false" data-primary="geometries_from_address function" data-type="indexterm" id="ix_geomaddr"/> You can explore that location by passing those coordinates to the <code>geometries_from_address</code> function (<a data-type="xref" href="#viewing_amsterdam_in_the_netherlands_by">Figure 5-12</a>). All of the geometries will transform to the CRS you select. <a contenteditable="false" data-primary="CRS (coordinate reference system)" data-secondary="geometries transforming to" data-type="indexterm" id="idm45433740953440"/>For example, the projected coordinate system for the Netherlands is EPSG:28992.</p>
<p>Here is the code that generates the map in <a data-type="xref" href="#viewing_amsterdam_in_the_netherlands_by">Figure 5-12</a>:</p>
<pre data-type="programlisting">
gdf=ox.geometries.geometries_from_address((52.3716,4.9005),dist=15000, 
tags={'natural':'water','highway':''})
gdf.to_crs(epsg=28992, inplace=True)
gdf.plot(figsize=(16,16))
gdf.plot(figsize=(16,16))</pre>
<figure><div class="figure" id="viewing_amsterdam_in_the_netherlands_by"><img alt="Viewing Amsterdam in the Netherlands by geographic coordinates and EPSG projection" height="708" src="assets/pgda_0512.png" width="938"/>
<h6><span class="label">Figure 5-12. </span>Viewing Amsterdam in the Netherlands by geographic coordinates and EPSG projection</h6>
</div></figure>
<p>You can also change the arguments to explore other geographies. Make sure to change the projection for the highest level of accuracy. (As a friendly reminder: the Earth is not a perfect sphere, so you need to select the best <a contenteditable="false" data-primary="map projections" data-secondary="selecting for neighborhood map in OSMnx" data-type="indexterm" id="idm45433740949536"/>projection for the geographical area of interest to minimize distortion.) The following code includes additional tags:</p>
<pre data-type="programlisting">
<span>gdf=ox.geometries.geometries_from_address((</span>'Manhattan, NY'<span>),dist=</span>15000<span>, 
    tags={</span>'natural'<span>:</span>'water'<span>,</span>'building'<span>:</span>'commercial'<span>,</span>'landuse'<span>:</span>'commercial'<span>,</span>
    'landuse'<span>:</span>'residential'<span>,</span>'highway'<span>:</span>'unclassified'<span>,</span>'highway'<span>:</span>'primary'<span>})
gdf.to_crs(epsg=</span>2263<span>,inplace=<strong>True</strong>)
gdf.plot(figsize=(</span>20<span>,</span>29<span>))</span></pre>
<p><a data-type="xref" href="#using_tags_to_add_features_to_a_map">Figure 5-13</a> shows the output of this code. <a contenteditable="false" data-primary="tags" data-secondary="using to add features to a map in OSMnx" data-type="indexterm" id="idm45433740936160"/>Thanks to the tags, this map shows water, commercial buildings, commercial and residential land use, and highways. These tags are explorative. See what happens with different combinations.</p>
<figure><div class="figure" id="using_tags_to_add_features_to_a_map"><img alt="Using tags to add features to a map" height="1606" src="assets/pgda_0513.png" width="978"/>
<h6><span class="label">Figure 5-13. </span>Using tags to add features to a map</h6>
</div></figure>
<p>In the next example, you’ll use <code>custom_filter</code> to query specific ways to include in your graph, such as <code>motorway</code>. <a contenteditable="false" data-primary="filtering data" data-secondary="custom_filter in OSM" data-type="indexterm" id="idm45433740930464"/>Specifying what you want with <code>custom_filter</code> will significantly reduce the resources needed to assemble the graph.</p>
<p>The terms <code>motorway_link</code> and <code>trunk_link</code> have specific meanings in OSM (as <a href="https://oreil.ly/DHjM8">OpenStreetMap Wiki</a> explains). <a contenteditable="false" data-primary="motorway_link (OSM)" data-type="indexterm" id="idm45433740926448"/><a contenteditable="false" data-primary="trunk_link (OSM)" data-type="indexterm" id="idm45433740925520"/>They describe how highways are connected: on- and off-ramps, for example (see <a data-type="xref" href="#motorways_in_madrid_using_a_custom_filt">Figure 5-14</a>).</p>
<p>Input the following code:</p>
<pre data-type="programlisting">
cf = <span>'["highway"~"motorway|motorway_link|trunk|trunk_link"]'</span>
G = ox.graph_from_place(<span>"Madrid"</span>, network_type=<span>"drive"</span>, custom_filter=cf)
fig, ax = ox.plot_graph(G, node_size=<span>3</span>,node_color=<span>'black'</span>,edge_linewidth=<span>3</span>,
bgcolor=<span>'#FFFFFF'</span>)</pre>
<p>The <code>custom_filter</code> (<code>cf</code>) requires a <code>network_type</code> preset <a contenteditable="false" data-primary="networks" data-secondary="network_type preset for custom_filter" data-type="indexterm" id="idm45433740916976"/>like <code>"highway"~"motorway"</code>. We want highways that are also motorways and the binary OR (|) operator in Python. The argument addresses both values, motorways and trunks (the ramps for entering and entering highways).</p>
<p>The output (<a data-type="xref" href="#motorways_in_madrid_using_a_custom_filt">Figure 5-14</a>) shows a map of only motorways, this time in Madrid, Spain.</p>
<figure><div class="figure" id="motorways_in_madrid_using_a_custom_filt"><img alt="Motorways in Madrid using a custom filter (cf) to query only motorways" height="484" src="assets/pgda_0514.png" width="444"/>
<h6><span class="label">Figure 5-14. </span>Motorways in Madrid using a custom filter (<code>cf</code>) to query only motorways</h6>
</div></figure>
<p class="pagebreak-before less_space">To appreciate the <a contenteditable="false" data-primary="building footprints, adding to map" data-type="indexterm" id="idm45433740910144"/>motorway map in context, you can readily bring up a more detailed map of Madrid with building footprints (<a data-type="xref" href="#building_footprints_in_madridcomma_spai">Figure 5-15</a>) using the following code:</p>
<pre data-type="programlisting">
place = <span>"Madrid, Spain"</span>
tags = {<span>"building"</span>: <strong>True</strong>}
gdf = ox.geometries_from_place(place, tags)
fig, ax = ox.plot_footprints(gdf, figsize=(<span>20</span>, <span>20</span>),alpha=<span>1</span>,color=<span>'black'</span>,
bgcolor=<span>'#FFFFFF'</span>,save=<strong>True</strong>,filepath=<span>'settings.imgs_folder/image.png'</span>,show=<strong>True</strong>,
dpi=<span>600</span>)</pre>
<p>Notice that <code>save</code> is set to <code>True</code>. It is important to save your files. I am using the default <code>filepath</code>, but you can specify a precise folder or location, such as your Downloads folder.</p>
<figure><div class="figure" id="building_footprints_in_madridcomma_spai"><img alt="Building footprints in Madrid, Spain" height="959" src="assets/pgda_0515.png" width="966"/>
<h6><span class="label">Figure 5-15. </span>Building footprints in Madrid, Spain</h6>
</div></figure>
<p><a data-type="xref" href="#the_networkx_function_brings_all_the_ne">Figure 5-16</a> is an example of downloading<a contenteditable="false" data-primary="networkx function" data-type="indexterm" id="idm45433740895904"/> the whole network (<code>network_type="drive"</code>) in the absence of a filter or customization. These renderings can be quite artistic and are often integrated into cartography and mapmaking or commercial products. Run this code to generate the map:</p>
<pre data-type="programlisting">
<strong>import</strong> osmnx <strong>as</strong> ox
<strong>import</strong> networkx <strong>as</strong> nx
<strong>import</strong> matplotlib.pyplot <strong>as</strong> plt
%matplotlib inline 
place_name = <span>'Madrid,Spain'</span>
G = ox.graph_from_place(place_name,network_type=<span>"drive"</span>)
fig, ax = ox.plot_graph(G,figsize=(<span>20</span>,<span>20</span>),bgcolor=<span>'#FFFFFF'</span>,
    node_color=<span>'black'</span>, node_size=<span>0</span>)</pre>
<figure><div class="figure" id="the_networkx_function_brings_all_the_ne"><img alt="The networkx function brings all the networks into the graph" height="1047" src="assets/pgda_0516.png" width="964"/>
<h6><span class="label">Figure 5-16. </span>The <code>networkx</code> function brings all the networks into the graph</h6>
</div></figure>
<p>The last graph in this chapter is created with a <a contenteditable="false" data-primary="network_type parameter for functions in OSMnx" data-secondary="network_type=“all”" data-type="indexterm" id="idm45433740896368"/>different value for <code>network_type="all"</code>. <a data-type="xref" href="#madridcomma_spaincomma_observed_in_netw">Figure 5-17</a> shows what happens to the output if you change the geocode queries by swapping out the strings (<code>all_private</code>, <code>all</code>, <code>bike</code>, <code>drive</code>, <code>drive_service</code>, <code>walk</code>):</p>
<pre data-type="programlisting">
G = ox.graph_from_place(
    "Madrid, Spain",network_type="all",
    retain_all=False,
    truncate_by_edge=True,
    simplify=True,
    
)

fig, ax = ox.plot_graph(G, figsize=(20, 20),node_size=0, edge_color="#111111", 
edge_linewidth=0.7,bgcolor='#FFFFFF')</pre>
<figure><div class="figure" id="madridcomma_spaincomma_observed_in_netw"><img alt="Madrid, Spain, observed in network_type=“all” in OSMnx" height="877" src="assets/pgda_0517.png" width="783"/>
<h6><span class="label">Figure 5-17. </span>Madrid, Spain, observed in <code>network_type="all"</code> in OSMnx</h6>
</div></figure>
<p>You can experiment by choosing the other <code>network_type</code> options and observing how the output changes.<a contenteditable="false" data-primary="geometries_from_address function" data-startref="ix_geomaddr" data-type="indexterm" id="idm45433740873936"/><a contenteditable="false" data-primary="OSMnx package" data-secondary="customizing neighborhood maps" data-startref="ix_OSMnxcusngbh" data-type="indexterm" id="idm45433740872704"/><a contenteditable="false" data-primary="neighborhood maps, customizing in OSMnx" data-startref="ix_neighbmp" data-type="indexterm" id="idm45433740871088"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Working with QuickOSM in QGIS" data-type="sect1"><div class="sect1" id="working_with_quickosm_in_qgis">
<h1>Working with QuickOSM in QGIS</h1>
<p>You got acquainted with QGIS in <a data-type="xref" href="ch03.xhtml#qgis_exploring_pyqgis_and_native_algori">Chapter 3</a>, and I want to point out briefly that you can also use QGIS to interact with OSM data.<a contenteditable="false" data-primary="OpenStreetMap (OSM)" data-secondary="working with QuickOSM in QGIS" data-type="indexterm" id="idm45433740866496"/><a contenteditable="false" data-primary="QGIS" data-secondary="working with QuickOSM" data-type="indexterm" id="idm45433740865232"/><a contenteditable="false" data-primary="QuickOSM, working with in QGIS" data-type="indexterm" id="idm45433740863856"/> QuickOSM in QGIS works similarly within a GUI. Open QGIS and select Vector in the toolbar, and you will see a “Quick query” option for Quick OSM (<a data-type="xref" href="#integrating_osm_keyvalue_pairs_in_qgis">Figure 5-18</a>). QuickOSM allows you to run these quick queries in the console and display results directly on a canvas.</p>
<p>Getting access to the<a contenteditable="false" data-primary="key-value pairs" data-secondary="OSM, integrating in QGIS" data-type="indexterm" id="idm45433740860608"/> level of data in GIS format within QGIS allows you to select a variety of amenities to include in a single map layer. This is an opportunity to explore <code>key:value</code> relationships outside of a Notebook as your data questions grow in scope.</p>
<figure><div class="figure" id="integrating_osm_keyvalue_pairs_in_qgis"><img alt="Integrating OSM key:value pairs in QGIS" height="572" src="assets/pgda_0518.png" width="1015"/>
<h6><span class="label">Figure 5-18. </span>Integrating OSM <code>key:value</code> pairs in QGIS</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id00018">
<h1>Summary</h1>
<p>In this chapter, you explored OpenStreetMap and learned how to generate street networks across the world as well as to use functions to calculate travel times, circuity, and other important measures.</p>
<p>OSM contains a wealth of open source geospatial data that you can access, model, project, visualize, and use to explore real-world street networks, points of interest, building locations, elevations, and more. <a contenteditable="false" data-primary="OpenStreetMap (OSM)" data-startref="ix_OSM" data-type="indexterm" id="idm45433740914800"/>I hope you will continue to play with it. Now I want to show you how to integrate this new skill with another tool, the ArcGIS Python API.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn9"><sup><a href="ch05.xhtml#ch01fn9-marker">1</a></sup> If you would like the details behind these calculations and a case study, see Boeing, G. 2017. “OSMnx: New Methods for Acquiring, Constructing, Analyzing, and Visualizing Complex Street Networks.” <em>Computers, Environment and Urban Systems,</em> 65: 126–139. <a href="https://doi.org/10.1016/j.compenvurbsys.2017.05.004"><em>https://doi.org/10.1016/j.compenvurbsys.2017.05.004</em></a>. The user reference also provides a summary of the dictionary with attributes included.</p></div></div></section></div></body></html>