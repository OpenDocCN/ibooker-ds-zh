<html><head></head><body><section data-pdf-bookmark="Chapter 13. Working with Text" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch-text">&#13;
<h1><span class="label">Chapter 13. </span>Working with Text</h1>&#13;
&#13;
<p>Data<a contenteditable="false" data-primary="text" data-type="indexterm" id="ix_text_ch13"/> can reside not just as numbers but also in words: names of dog breeds, restaurant violation descriptions, street addresses, speeches, blog posts, internet reviews, and much more. To organize and analyze information contained in text, we often need to do some of the following tasks:</p>&#13;
&#13;
<dl class="simple myst">&#13;
	<dt>Convert text into a standard format</dt>&#13;
	<dd>&#13;
	<p>This is also referred<a contenteditable="false" data-primary="canonicalizing text" data-type="indexterm" id="id1484"/> to as <em>canonicalizing text</em>. For example, we might need to convert characters to lowercase, use common spellings and abbreviations, or remove punctuation and blank spaces.</p>&#13;
	</dd>&#13;
	<dt>Extract a piece of text to create a feature</dt>&#13;
	<dd>&#13;
	<p>As an example, a string might contain a date embedded in it, and we want to pull it out from the string to create a date feature.</p>&#13;
	</dd>&#13;
	<dt>Transform text into features</dt>&#13;
	<dd>&#13;
	<p>We might want to encode particular words or phrases as 0-1 features to indicate their presence in a string.</p>&#13;
	</dd>&#13;
	<dt>Analyze text</dt>&#13;
	<dd>&#13;
	<p>In order to compare entire documents at once, we can transform a document into a vector of word counts.</p>&#13;
	</dd>&#13;
</dl>&#13;
&#13;
<p>This chapter introduces common techniques for working with text data. We show how simple string manipulation tools are often all we need to put text in a standard form or extract portions of strings. We also introduce regular expressions for more general and robust pattern matching. To demonstrate these text operations we use several examples. We first introduce these examples and describe the work we want to do to prepare the text for analysis.</p>&#13;
&#13;
&#13;
<section data-pdf-bookmark="Examples of Text and Tasks" data-type="sect1"><div class="sect1" id="examples-of-text-and-tasks">&#13;
<h1>Examples of Text and Tasks</h1>&#13;
&#13;
<p>For each type of task just introduced, we provide a motivating example. These examples are based on real tasks that we have carried out, but to focus on the concept, we’ve reduced the data to snippets.</p>&#13;
&#13;
<section data-pdf-bookmark="Convert Text into a Standard Format" data-type="sect2"><div class="sect2" id="convert-text-into-a-standard-format">&#13;
<h2>Convert Text into a Standard Format</h2>&#13;
&#13;
<p>Let’s say we want to study<a contenteditable="false" data-primary="text" data-secondary="converting to standard format" data-type="indexterm" id="id1485"/><a contenteditable="false" data-primary="standard format, converting text to" data-type="indexterm" id="id1486"/> connections between population demographics and election results. To do this, we’ve taken election data from Wikipedia and population data from the US Census Bureau. The granularity of the data is at the county level, and we need to use the county names to join the tables. Unfortunately, the county names in these two tables don’t always match:</p>&#13;
&#13;
<div class="cell tag_remove-input docutils container">&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>County</th>&#13;
			<th>State</th>&#13;
			<th>Voted</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>De Witt County</td>&#13;
			<td>IL</td>&#13;
			<td>97.8</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Lac qui Parle County</td>&#13;
			<td>MN</td>&#13;
			<td>98.8</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Lewis and Clark County</td>&#13;
			<td>MT</td>&#13;
			<td>95.2</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>3</strong></td>&#13;
			<td>St John the Baptist Parish</td>&#13;
			<td>LA</td>&#13;
			<td>52.6</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>County</th>&#13;
			<th>State</th>&#13;
			<th>Population</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>DeWitt</td>&#13;
			<td>IL</td>&#13;
			<td class="right">16,798</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Lac Qui Parle</td>&#13;
			<td>MN</td>&#13;
			<td class="right">8,067</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Lewis &amp; Clark</td>&#13;
			<td>MT</td>&#13;
			<td class="right">55,716</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>3</strong></td>&#13;
			<td>St. John the Baptist</td>&#13;
			<td>LA</td>&#13;
			<td class="right">43,044</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>We can’t join the tables until we clean the strings to have a common format for county names. We need to change the case of characters, use common spellings and abbreviations, and address punctuation.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Extract a Piece of Text to Create a Feature" data-type="sect2"><div class="sect2" id="extract-a-piece-of-text-to-create-a-feature">&#13;
<h2>Extract a Piece of Text to Create a Feature</h2>&#13;
&#13;
<p>Text data<a contenteditable="false" data-primary="text" data-secondary="extracting text to create feature" data-type="indexterm" id="id1487"/>  sometimes has a lot of structure, especially when it was generated by a computer. As an example, the following is a web server’s log entry. Notice how the entry has multiple pieces of data, but the pieces don’t have a consistent delimiter—for instance, the date appears in square brackets, but other parts of the data appear in quotes and parentheses:</p>&#13;
&#13;
<div class="highlight-default notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
<span>169.237.46.168</span> <span>-</span> <span>-</span>&#13;
<span>[</span><span>26</span><span>/</span><span>Jan</span><span>/</span><span>2004</span><span>:</span><span>10</span><span>:</span><span>47</span><span>:</span><span>58</span> <span>-</span><span>0800</span><span>]</span><span>"GET /stat141/Winter04 HTTP/1.1"</span> <span>301</span> <span>328</span>&#13;
<span>"http://anson.ucdavis.edu/courses"</span>&#13;
<span>"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.1.4322)"</span>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Even though the file format doesn’t align with one of the simple formats we saw in <a class="reference internal" data-type="xref" href="ch08.html#ch-files">Chapter 8</a>, we can use text processing techniques to extract pieces of text to create features.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Transform Text into Features" data-type="sect2"><div class="sect2" id="transform-text-into-features">&#13;
<h2>Transform Text into Features</h2>&#13;
&#13;
<p>In <a class="reference internal" data-type="xref" href="ch09.html#ch-wrangling">Chapter 9</a>, we created<a contenteditable="false" data-primary="features and feature types" data-secondary="and text transformation" data-secondary-sortas="text transformation" data-type="indexterm" id="id1488"/> a categorical feature based on the content of the strings. There, we examined the descriptions of restaurant violations and we created nominal variables for the presence of particular words. We’ve displayed a few example violations here:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
	unclean or degraded floors walls or ceilings&#13;
	inadequate and inaccessible handwashing facilities&#13;
	inadequately cleaned or sanitized food contact surfaces&#13;
	wiping cloths not clean or properly stored or inadequate sanitizer&#13;
	foods not protected from contamination&#13;
	unclean nonfood contact surfaces&#13;
	unclean or unsanitary food contact surfaces&#13;
	unclean hands or improper use of gloves&#13;
	inadequate washing facilities or equipment&#13;
	</pre>&#13;
&#13;
<p>These new features can be used in an analysis of food safety scores. Previously, we made simple features that marked whether a description contained a word like <em>glove</em> or <em>hair</em>. In this chapter, we more formally introduce the regular expression tools that we used to create these features.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Text Analysis" data-type="sect2"><div class="sect2" id="text-analysis">&#13;
<h2>Text Analysis</h2>&#13;
&#13;
<p>Sometimes<a contenteditable="false" data-primary="text" data-secondary="analysis of" data-type="indexterm" id="id1489"/> we want to compare entire documents. For example, the US president gives a State of the Union speech every year. Here are the first few lines of the very first speech:</p>&#13;
&#13;
<div class="highlight-default notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
*** &#13;
&#13;
State of the Union Address&#13;
George Washington&#13;
January 8, 1790&#13;
&#13;
Fellow-Citizens of the Senate and House of Representatives:&#13;
I embrace with great satisfaction the opportunity which now presents itself&#13;
of congratulating you on the present favorable prospects of our public …&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>We might wonder: How have the State of the Union speeches changed over time? Do different political parties focus on different topics or use different language in their speeches? To answer these questions, we can transform<a contenteditable="false" data-primary="numeric data" data-secondary="transforming text data to" data-type="indexterm" id="id1490"/><a contenteditable="false" data-primary="transformations" data-secondary="text data to numeric data" data-type="indexterm" id="id1491"/> the speeches into a numeric form that lets us use statistics to compare them.</p>&#13;
&#13;
<p>These examples serve to illustrate the ideas of string manipulation, regular expressions, and text analysis. We start with describing simple string manipulation.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="String Manipulation" data-type="sect1"><div class="sect1" id="string-manipulation">&#13;
<h1>String Manipulation</h1>&#13;
&#13;
<p>There are a handful of basic string<a contenteditable="false" data-primary="strings" data-secondary="manipulation tools" data-type="indexterm" id="ix_string_man_tool"/><a contenteditable="false" data-primary="text" data-secondary="string manipulation" data-type="indexterm" id="ix_text_string"/> manipulation tools that we use a lot when we work with text:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p>Transform uppercase characters to lowercase (or vice versa).</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Replace a substring with another or delete the substring.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Split a string into pieces at a particular character.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Slice a string at specified locations.</p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>We show how we can combine these basic operations to clean up the county names data. Remember that we have two tables that we want to join, but the county names are written inconsistently.</p>&#13;
&#13;
<p>Let’s start by converting the county names to a standard format.</p>&#13;
&#13;
<section data-pdf-bookmark="Converting Text to a Standard Format with Python String Methods" data-type="sect2"><div class="sect2" id="converting-text-to-a-standard-format-with-python-string-methods">&#13;
<h2>Converting Text to a Standard Format with Python String Methods</h2>&#13;
&#13;
<p>We need to address<a contenteditable="false" data-primary="text" data-secondary="standard format, converting to" data-type="indexterm" id="id1492"/> the following inconsistencies between the county names in the two tables:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p>Capitalization: <code>qui</code> versus <code>Qui</code>.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Omission of words: <code>County</code> and <code>Parish</code> are absent from the <code>census</code> table.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Different abbreviation conventions: <code>&amp;</code> versus <code>and</code>.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Different punctuation conventions: <code>St.</code> versus <code>St</code>.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Use of whitespace: <code>DeWitt</code> versus <code>De <span class="pre">Witt</span></code>.</p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>When we clean text, it’s often easiest to first convert all of the characters to lowercase. It’s easier to work entirely with lowercase characters than to try to track combinations of uppercase and lowercase. Next, we want to fix inconsistent words by replacing <code>&amp;</code> with <code>and</code> and removing <code>County</code> and <code>Parish</code>. Finally, we need to fix up punctuation and whitespace inconsistencies.</p>&#13;
&#13;
<p>With just two Python string methods, <code>lower</code> and <code>replace</code>, we can take all of these actions and clean the county names. These are combined into a method called <code>clean_county</code>:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="k">def</code></span><code> </code><span><code class="nf">clean_county</code></span><span><code class="p">(</code></span><span><code class="n">county</code></span><span><code class="p">)</code><code class="p">:</code></span><code>&#13;
</code><code>    </code><span><code class="k">return</code></span><code> </code><span><code class="p">(</code></span><span><code class="n">county</code></span><code>&#13;
</code><code>            </code><span><code class="o">.</code></span><span><code class="n">lower</code></span><span><code class="p">(</code><code class="p">)</code></span><code>&#13;
</code><code>            </code><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">county</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>            </code><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">parish</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>            </code><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">&amp;</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">and</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>            </code><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">.</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>            </code><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1"> </code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">'</code></span><span><code class="p">)</code><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Although simple, these methods are the primitives that we can piece together to form more complex string operations. These methods are conveniently defined on all Python strings and do not require importing other modules. It is worth familiarizing yourself with <a class="reference external" href="https://oreil.ly/YWl9d">the complete list of string methods</a>, but we describe a few of the most commonly used methods<a contenteditable="false" data-primary="strings" data-secondary="Python methods" data-type="indexterm" id="id1493"/><a contenteditable="false" data-primary="Python" data-secondary="string methods" data-type="indexterm" id="id1494"/> in <a class="reference internal" data-type="xref" href="#string-methods">Table 13-1</a>.</p>&#13;
&#13;
<table id="string-methods">&#13;
	<caption><span class="label">Table 13-1. </span><span>String methods</span></caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th class="head">Method</th>&#13;
			<th class="head">Description</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><code>str.lower()</code></td>&#13;
			<td>&#13;
			<p>Returns a copy of a string with all letters converted to lowercase</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>str.replace(a, <span class="pre">b)</span></code></td>&#13;
			<td>&#13;
			<p>Replaces all instances of the substring <code>a</code> in <code>str</code> with substring <code>b</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>str.strip()</code></td>&#13;
			<td>&#13;
			<p>Removes leading and trailing whitespace from <code>str</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>str.split(a)</code></td>&#13;
			<td>&#13;
			<p>Returns substrings of <code>str</code> split at a substring <code>a</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>str[x:y]</code></td>&#13;
			<td>&#13;
			<p>Slices <code>str</code>, returning indices x (inclusive) to y (not inclusive)</p>&#13;
			</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>We next verify that the <code>clean_county</code> method produces matching county names:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="p">(</code><code class="p">[</code></span><span><code class="n">clean_county</code></span><span><code class="p">(</code></span><span><code class="n">county</code></span><span><code class="p">)</code></span><code> </code><span><code class="k">for</code></span><code> </code><span><code class="n">county</code></span><code> </code><span><code class="ow">in</code></span><code> </code><span><code class="n">election</code></span><span><code class="p">[</code></span><span><code class="s1">'</code><code class="s1">County</code><code class="s1">'</code></span><span><code class="p">]</code><code class="p">]</code><code class="p">,</code></span><code>&#13;
</code><code> </code><span><code class="p">[</code></span><span><code class="n">clean_county</code></span><span><code class="p">(</code></span><span><code class="n">county</code></span><span><code class="p">)</code></span><code> </code><span><code class="k">for</code></span><code> </code><span><code class="n">county</code></span><code> </code><span><code class="ow">in</code></span><code> </code><span><code class="n">census</code></span><span><code class="p">[</code></span><span><code class="s1">'</code><code class="s1">County</code><code class="s1">'</code></span><span><code class="p">]</code><code class="p">]</code><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
(['dewitt', 'lacquiparle', 'lewisandclark', 'stjohnthebaptist'],&#13;
 ['dewitt', 'lacquiparle', 'lewisandclark', 'stjohnthebaptist'])&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Since the county names now have consistent representations, we can successfully join the two tables.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="String Methods in pandas" data-type="sect2"><div class="sect2" id="string-methods-in-pandas">&#13;
<h2>String Methods in pandas</h2>&#13;
&#13;
<p>In the preceding code<a contenteditable="false" data-primary="pandas library" data-secondary="string methods" data-type="indexterm" id="id1495"/><a contenteditable="false" data-primary="strings" data-secondary="pandas methods" data-type="indexterm" id="id1496"/>, we used a loop to transform each county name. The <code>pandas</code> <code>Series</code> objects provide a convenient way to apply string methods to each item in the series.</p>&#13;
&#13;
<p>The <code>.str</code> property on <code>pandas</code> <code>Series</code> exposes the same Python string methods. Calling a method on the <code>.str</code> property calls the method on each item in the series. This allows us to transform each string in the series without using a loop. We save the transformed counties back into their originating tables. First we transform the county names in the election table:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">election</code></span><span><code class="p">[</code></span><span><code class="s1">'</code><code class="s1">County</code><code class="s1">'</code></span><span><code class="p">]</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="p">(</code></span><span><code class="n">election</code></span><span><code class="p">[</code></span><span><code class="s1">'</code><code class="s1">County</code><code class="s1">'</code></span><span><code class="p">]</code></span><code>&#13;
</code><code> </code><span><code class="o">.</code></span><span><code class="n">str</code></span><span><code class="o">.</code></span><span><code class="n">lower</code></span><span><code class="p">(</code><code class="p">)</code></span><code>&#13;
</code><code> </code><span><code class="o">.</code></span><span><code class="n">str</code></span><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">parish</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code> </code><span><code class="o">.</code></span><span><code class="n">str</code></span><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">county</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code> </code><span><code class="o">.</code></span><span><code class="n">str</code></span><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">&amp;</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">and</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code> </code><span><code class="o">.</code></span><span><code class="n">str</code></span><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">.</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">regex</code></span><span><code class="o">=</code></span><span><code class="kc">False</code></span><span><code class="p">)</code></span><code>&#13;
</code><code> </code><span><code class="o">.</code></span><span><code class="n">str</code></span><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1"> </code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">'</code></span><span><code class="p">)</code><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>We also transform the names in the census table so that the two tables contain the same representations of the county names. We can join these tables:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">election</code></span><span><code class="o">.</code></span><span><code class="n">merge</code></span><span><code class="p">(</code></span><span><code class="n">census</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">on</code></span><span><code class="o">=</code></span><span><code class="p">[</code></span><span><code class="s1">'</code><code class="s1">County</code><code class="s1">'</code></span><span><code class="p">,</code></span><span><code class="s1">'</code><code class="s1">State</code><code class="s1">'</code></span><span><code class="p">]</code><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>County</th>&#13;
			<th>State</th>&#13;
			<th>Voted</th>&#13;
			<th>Population</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>dewitt</td>&#13;
			<td>IL</td>&#13;
			<td>97.8</td>&#13;
			<td class="right">16,798</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>lacquiparle</td>&#13;
			<td>MN</td>&#13;
			<td>98.8</td>&#13;
			<td class="right">8,067</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>lewisandclark</td>&#13;
			<td>MT</td>&#13;
			<td>95.2</td>&#13;
			<td class="right">55,716</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>3</strong></td>&#13;
			<td>stjohnthebaptist</td>&#13;
			<td>LA</td>&#13;
			<td>52.6</td>&#13;
			<td class="right">43,044</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Note that we merged on two columns: the county name and the state. We did this because some states have counties with the same name. For example, California and New York both have a county called King.</p>&#13;
</div>&#13;
&#13;
<p>To see the complete list of string methods, we recommend looking at the <a class="reference external" href="https://oreil.ly/Fb34C">Python documentation on <code>str</code> methods</a> and the <a class="reference external" href="https://oreil.ly/njVi3"><code>pandas</code> documentation for the <code>.str</code> accessor</a>. We did the canonicalization task using only <code>str.lower()</code> and multiple calls to <code>str.replace()</code>. Next, we extract text with another string method, <code>str.split()</code>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Splitting Strings to Extract Pieces of Text" data-type="sect2"><div class="sect2" id="splitting-strings-to-extract-pieces-of-text">&#13;
<h2>Splitting Strings to Extract Pieces of Text</h2>&#13;
&#13;
<p>Let’s say we want to extract<a contenteditable="false" data-primary="splitting strings to extract text pieces" data-type="indexterm" id="id1497"/><a contenteditable="false" data-primary="strings" data-secondary="splitting to extract text" data-type="indexterm" id="id1498"/> the date from the web server’s log entry:</p>&#13;
&#13;
<div class="cell tag_remove-output docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">log_entry</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell tag_remove-input docutils container">&#13;
<div class="cell_output docutils container">&#13;
<div class="output stream highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
169.237.46.168 - - [26/Jan/2004:10:47:58 -0800]"GET /stat141/Winter04 HTTP/1.1"&#13;
301 328 "http://anson.ucdavis.edu/courses""Mozilla/4.0 (compatible; MSIE 6.0;&#13;
Windows NT 5.0; .NET CLR 1.1.4322)"&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>String splitting can help us home in on the pieces of information that form the date. For example, when we split the string on the left bracket, we get two strings:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">log_entry</code></span><span><code class="o">.</code></span><span><code class="n">split</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">[</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
['169.237.46.168 - - ',&#13;
 '26/Jan/2004:10:47:58 -0800]"GET /stat141/Winter04 HTTP/1.1" 301 328 "http://anson.ucdavis.edu/courses""Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.1.4322)"']&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>The second string has the date information, and to get the day, month, and year, we can split that string on a colon:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">log_entry</code></span><span><code class="o">.</code></span><span><code class="n">split</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">[</code><code class="s1">'</code></span><span><code class="p">)</code><code class="p">[</code></span><span><code class="mi">1</code></span><span><code class="p">]</code></span><span><code class="o">.</code></span><span><code class="n">split</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">:</code><code class="s1">'</code></span><span><code class="p">)</code><code class="p">[</code></span><span><code class="mi">0</code></span><span><code class="p">]</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
'26/Jan/2004'&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>To separate out the day, month, and year, we can split on the forward slash. Altogether we split the original string three times, each time keeping only the pieces we are interested in:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="p">(</code></span><span><code class="n">log_entry</code></span><span><code class="o">.</code></span><span><code class="n">split</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">[</code><code class="s1">'</code></span><span><code class="p">)</code><code class="p">[</code></span><span><code class="mi">1</code></span><span><code class="p">]</code></span><code>&#13;
</code><code> </code><span><code class="o">.</code></span><span><code class="n">split</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">:</code><code class="s1">'</code></span><span><code class="p">)</code><code class="p">[</code></span><span><code class="mi">0</code></span><span><code class="p">]</code></span><code>&#13;
</code><code> </code><span><code class="o">.</code></span><span><code class="n">split</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">/</code><code class="s1">'</code></span><span><code class="p">)</code><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
['26', 'Jan', '2004']&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>By repeatedly using <code>split()</code>, we can extract many of the parts of the log entry. But this approach is complicated—if we wanted to also get the hour, minute, second, and time zone of the activity, we would need to use <code>split()</code> six times in total. There’s a simpler way to extract these parts:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="kn">import</code></span><code> </code><span><code class="nn">re</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pattern</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="sa">r</code></span><span><code class="s1">'</code><code class="s1">[ </code><code class="s1">\</code><code class="s1">[/:</code><code class="s1">\</code><code class="s1">]]</code><code class="s1">'</code></span><code> </code><code>&#13;
</code><span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">split</code></span><span><code class="p">(</code></span><span><code class="n">pattern</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">log_entry</code></span><span><code class="p">)</code><code class="p">[</code></span><span><code class="mi">4</code></span><span><code class="p">:</code></span><span><code class="mi">11</code></span><span><code class="p">]</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
['26', 'Jan', '2004', '10', '47', '58', '-0800']&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>This alternative approach uses a powerful tool called a regular expression, which we cover in the next section<a contenteditable="false" data-primary="" data-startref="ix_string_man_tool" data-type="indexterm" id="id1499"/><a contenteditable="false" data-primary="" data-startref="ix_text_string" data-type="indexterm" id="id1500"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Regular Expressions" data-type="sect1"><div class="sect1" id="regular-expressions">&#13;
<h1>Regular Expressions</h1>&#13;
&#13;
<p><em>Regular expressions</em> (or <em>regex</em> for short) are special patterns<a contenteditable="false" data-primary="regular expressions (regex)" data-type="indexterm" id="ix_regex_ch13"/><a contenteditable="false" data-primary="strings" data-secondary="regular expressions" data-type="indexterm" id="ix_string_regex"/><a contenteditable="false" data-primary="text" data-secondary="regular expressions" data-type="indexterm" id="ix_text_regex_ch13"/> that we use to match parts of strings. Think about the format of a Social Security number (SSN) like <code>134-42-2012</code>. To describe this format, we might say that SSNs consist of three digits, then a dash, two digits, another dash, then four digits. Regexes let us capture this pattern in code. Regexes give us a compact and powerful way to describe this pattern of digits and dashes. The syntax of regular expressions is fortunately quite simple to learn; we introduce nearly all of the syntax in this section alone.</p>&#13;
&#13;
<p>As we introduce the concepts, we tackle some of the examples described in an earlier section and show how to carry out the tasks with regular expressions. Almost all programming languages have a library to match patterns using regular expressions, making regular expressions useful in any programming language. We use some of the common methods available in the Python built-in <code>re</code> module to accomplish the tasks from the examples. These methods are summarized in <a class="reference internal" data-type="xref" href="#regex-methods">Table 13-7</a> at the end of this section, where the basic usage and return value are briefly described. Since we only cover a few of the most commonly used methods, you may find it useful to consult <a class="reference external" href="https://oreil.ly/IXWol">the official documentation on the <code>re</code> module</a> as well.</p>&#13;
&#13;
<p>Regular expressions are based on searching a string one character (aka <em>literal</em>) at a time for a pattern. We call this notion <em>concatenation of literals</em>.</p>&#13;
&#13;
<section data-pdf-bookmark="Concatenation of Literals" data-type="sect2"><div class="sect2" id="concatenation-of-literals">&#13;
<h2>Concatenation of Literals</h2>&#13;
&#13;
<p>Concatenation<a contenteditable="false" data-primary="regular expressions (regex)" data-secondary="concatenation of literals" data-type="indexterm" id="ix_regex_con_lit"/><a contenteditable="false" data-primary="concatenation of literals" data-type="indexterm" id="ix_concat_lit"/> is best explained with a basic example. Suppose we are looking for the pattern <code>cat</code> in the string <code>cards <span class="pre">scatter!</span></code>. <a class="reference internal" data-type="xref" href="#fig-regex-literals">Figure 13-1</a> contains a diagram that shows how the search proceeds through the string one character at a time. Notice that a “c” is found in the first position, followed by “a,” but not “t,” so the search backs up to the second character in the string and begins searching for a “c” again. The pattern “cat” is found within the string <code>cards <span class="pre">scatter!</span></code> in positions 8–10. Once you get the hang of this process, you can move on to the richer set of patterns; they all follow this basic paradigm.</p>&#13;
&#13;
<figure><div class="figure" id="fig-regex-literals"><img src="assets/leds_1301.png"/>&#13;
<h6><span class="label">Figure 13-1. </span>To match literal patterns, the regex engine moves along the string and checks one literal at a time for a match of the entire pattern. Notice that the pattern is found within the word <code>scatters</code> and that a partial match is found in <code>cards</code>.</h6>&#13;
</div></figure>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In the preceding example, we observe that regular expressions can match patterns that appear anywhere in the input string. In Python, this behavior differs depending on the method used to match the regex—some methods only return a match if the regex appears at the start of the string; other methods return a match anywhere in the string.</p>&#13;
</div>&#13;
&#13;
<p>These richer patterns are made of character classes and metacharacters like wildcards. We describe them in the subsections that follow.</p>&#13;
&#13;
<section data-pdf-bookmark="Character classes" data-type="sect3"><div class="sect3" id="character-classes">&#13;
<h3>Character classes</h3>&#13;
&#13;
<p>We can make patterns<a contenteditable="false" data-primary="classes, character" data-type="indexterm" id="id1501"/><a contenteditable="false" data-primary="character classes" data-type="indexterm" id="id1502"/> more flexible by using a <em>character class</em> (also known as a <em>character set</em>), which lets us specify a collection of equivalent characters to match. This allows us to create more relaxed matches. To create a character class, wrap the set of desired characters in brackets <code>[ <span class="pre">]</span></code>. For example, the pattern <code>[0123456789]</code> means “match any literal within the brackets”—in this case, any single digit. Then, the following regular expression matches three digits:</p>&#13;
&#13;
<div class="highlight-default notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
<span>[</span><span>0123456789</span><span>][</span><span>0123456789</span><span>][</span><span>0123456789</span><span>]</span>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>This is such a commonly used character class that there is a shorthand notation for the range of digits, <code>[0-9]</code>. Character classes allow us to create a regex for SSNs:</p>&#13;
&#13;
<div class="highlight-default notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
<span>[</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>]</span><span>-</span><span>[</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>]</span><span>-</span><span>[</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>]</span>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Two other ranges that are commonly used in character classes are <code>[a-z]</code> for lowercase and <code>[A-Z]</code> for uppercase letters. We can combine ranges with other equivalent characters and use partial ranges. For example, <code>[a-cX-Z27]</code> is equivalent to the character class <code>[abcXYZ27]</code>.</p>&#13;
&#13;
<p>Let’s return to our original pattern <code>cat</code> and modify it to include two character classes:</p>&#13;
&#13;
<div class="highlight-default notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
<span>c</span><span>[</span><span>oa</span><span>][</span><span>td</span><span>]</span>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>This pattern matches <code>cat</code>, but it also matches <code>cot</code>, <code>cad</code>, and <code>cod</code>:</p>&#13;
&#13;
<div class="cell tag_remove-input docutils container">&#13;
<div class="cell_output docutils container">&#13;
<div class="output stream highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
  Regex: c[oa][td]&#13;
   Text: The <span>cat</span> eats <span>cod</span>, <span>cad</span>s, and <span>cot</span>s, but not coats.&#13;
Matches:     ***      ***  ***       ***                 &#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>The idea of moving through the string one character at a time still remains the core notion, but now there’s a bit more flexibility in which literal is considered a match.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Wildcard character" data-type="sect3"><div class="sect3" id="wildcard-character">&#13;
<h3>Wildcard character</h3>&#13;
&#13;
<p>When we really<a contenteditable="false" data-primary="wildcard character" data-type="indexterm" id="id1503"/> don’t care what the literal is, we can specify this with <code>.</code>, the period character. This matches any character except a newline.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Negated character classes" data-type="sect3"><div class="sect3" id="negated-character-classes">&#13;
<h3>Negated character classes</h3>&#13;
&#13;
<p>A <em>negated character class</em> matches<a contenteditable="false" data-primary="negated character classes" data-type="indexterm" id="id1504"/> any character <em>except</em> those between the square brackets. To create a negated character class, place the caret symbol as the first character after the left square bracket. For example, <code>[^0-9]</code> matches any character except a digit.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Shorthands for character classes" data-type="sect3"><div class="sect3" id="shorthands-for-character-classes">&#13;
<h3>Shorthands for character classes</h3>&#13;
&#13;
<p>Some character<a contenteditable="false" data-primary="shorthands for character classes, regular expressions" data-type="indexterm" id="id1505"/> sets are so common that there are shorthands for them. For example, <code>\d</code> is short for <code>[0-9]</code>. We can use this shorthand to simplify our search for SSN:</p>&#13;
&#13;
<div class="highlight-default notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
\<span>d</span>\<span>d</span>\<span>d</span><span>-</span>\<span>d</span>\<span>d</span><span>-</span>\<span>d</span>\<span>d</span>\<span>d</span>\<span>d</span>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Our regular expression for SSNs isn’t quite bulletproof. If the string has extra digits at the beginning or end of the pattern we’re looking for, then we still get a match. Note that we add the <code>r</code> character before the quotes to create a raw string, which makes regexes easier to write:</p>&#13;
&#13;
<div class="cell tag_remove-input docutils container">&#13;
<div class="cell_output docutils container">&#13;
<div class="output stream highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
  Regex: \d\d\d-\d\d-\d\d\d\d&#13;
   Text: My other number is 6<span>382-13-3842</span>0.&#13;
Matches:                     ***********  &#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>We can remedy the situation with a different sort of metacharacter: one that matches a word boundary.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Anchors and boundaries" data-type="sect3"><div class="sect3" id="anchors-and-boundaries">&#13;
<h3>Anchors and boundaries</h3>&#13;
&#13;
<p>At times<a contenteditable="false" data-primary="anchors, text" data-type="indexterm" id="id1506"/><a contenteditable="false" data-primary="boundaries, text" data-type="indexterm" id="id1507"/> we want to match a position before, after, or between characters. One example is to locate the beginning or end of a string; these are called <em>anchors</em>. Another is to locate the beginning or end of a word, which we call a <em>boundary</em>. The metacharacter <code>\b</code> denotes the boundary of a word. It has 0 length, and it matches whitespace or punctuation on the boundary of the pattern. We can use it to fix our regular expression for SSNs:</p>&#13;
&#13;
<div class="cell tag_remove-input docutils container">&#13;
<div class="cell_output docutils container">&#13;
<div class="output stream highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
  Regex: \d\d\d-\d\d-\d\d\d\&#13;
   Text: My other number is 6382-13-38420.&#13;
Matches:                                  &#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell tag_remove-input docutils container">&#13;
<div class="cell_output docutils container">&#13;
<div class="output stream highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
  Regex: \b\d\d\d-\d\d-\d\d\d\d\b&#13;
   Text: My reeeal number is <span>382-13-3842</span>.&#13;
Matches:                     *********** &#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Escaping metacharacters" data-type="sect3"><div class="sect3" id="escaping-metacharacters">&#13;
<h3>Escaping metacharacters</h3>&#13;
&#13;
<p>We have now seen several special characters<a contenteditable="false" data-primary="escaping metacharacters" data-type="indexterm" id="id1508"/><a contenteditable="false" data-primary="metacharacters" data-type="indexterm" id="id1509"/>, called <em>metacharacters</em>: <code>[</code> and <code>]</code> denote a character class, <code>^</code> switches to a negated character class, <code>.</code> represents any character, and <code>-</code> denotes a range. But sometimes we might want to create a pattern that matches one of these literals. When this happens, we must escape it with a backslash. For example, we can match the literal left bracket character using the regex <code>\[</code>:</p>&#13;
&#13;
<div class="cell tag_remove-input docutils container">&#13;
<div class="cell_output docutils container">&#13;
<div class="output stream highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
  Regex: \[&#13;
   Text: Today is <span>[</span>2022/01/01]&#13;
Matches:          *           &#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Next, we show how quantifiers can help create a more compact and clear regular expression for SSNs<a contenteditable="false" data-primary="" data-startref="ix_regex_con_lit" data-type="indexterm" id="id1510"/><a contenteditable="false" data-primary="" data-startref="ix_concat_lit" data-type="indexterm" id="id1511"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Quantifiers" data-type="sect2"><div class="sect2" id="quantifiers">&#13;
<h2>Quantifiers</h2>&#13;
&#13;
<p>To create a regex<a contenteditable="false" data-primary="regular expressions (regex)" data-secondary="quantifiers" data-type="indexterm" id="id1512"/><a contenteditable="false" data-primary="quantifiers, regular expressions" data-type="indexterm" id="id1513"/> to match SSNs, we wrote:</p>&#13;
&#13;
<div class="highlight-default notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
\<span>b</span><span>[</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>]</span><span>-</span><span>[</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>]</span><span>-</span><span>[</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>][</span><span>0</span><span>-</span><span>9</span><span>]</span>\<span>b</span>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>This matches a “word” consisting of three digits, a dash, two more digits, a dash, and four more digits.</p>&#13;
&#13;
<p>Quantifiers allow us to match multiple consecutive appearances of a literal. We specify the number of repetitions by placing the number in curly braces <code>{ <span class="pre">}</span></code>.</p>&#13;
&#13;
<p>Let’s use Python’s built-in <code>re</code> module for matching this pattern:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="kn">import</code></span><code> </code><span><code class="nn">re</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">ssn_re</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="sa">r</code></span><span><code class="s1">'</code><code class="s1">\</code><code class="s1">b[0-9]</code></span><span><code class="si">{3}</code></span><span><code class="s1">-[0-9]</code></span><span><code class="si">{2}</code></span><span><code class="s1">-[0-9]</code></span><span><code class="si">{4}</code></span><span><code class="s1">\</code><code class="s1">b</code><code class="s1">'</code></span><code>&#13;
</code><span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">findall</code></span><span><code class="p">(</code></span><span><code class="n">ssn_re</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">My SSN is 382-34-3840.</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
['382-34-3840']&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Our pattern shouldn’t match phone numbers. Let’s try it:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">findall</code></span><span><code class="p">(</code></span><span><code class="n">ssn_re</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">My phone is 382-123-3842.</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
[]&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>A quantifier always modifies the character or character class to its immediate left. <a class="reference internal" data-type="xref" href="#quantifier-ex">Table 13-2</a> shows the complete syntax for quantifiers.</p>&#13;
&#13;
<table id="quantifier-ex">&#13;
	<caption><span class="label">Table 13-2. </span><span>Quantifier examples</span></caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th class="head">Quantifier</th>&#13;
			<th class="head">Meaning</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>{m, n}</td>&#13;
			<td>&#13;
			<p>Match the preceding character m to n times.</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>{m}</td>&#13;
			<td>&#13;
			<p>Match the preceding character exactly m times.</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>{m,}</td>&#13;
			<td>&#13;
			<p>Match the preceding character at least m times.</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>{,n}</td>&#13;
			<td>&#13;
			<p>Match the preceding character at most n times.</p>&#13;
			</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>Some commonly used quantifiers have a shorthand, as shown in <a class="reference internal" data-type="xref" href="#short-quantifiers">Table 13-3</a>.</p>&#13;
&#13;
<table id="short-quantifiers">&#13;
	<caption><span class="label">Table 13-3. </span><span>Shorthand quantifiers</span></caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th class="head">Symbol</th>&#13;
			<th class="head">Quantifier</th>&#13;
			<th class="head">Meaning</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><code>*</code></td>&#13;
			<td>&#13;
			<p>{0,}</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>Match the preceding character 0 or more times.</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>+</code></td>&#13;
			<td>&#13;
			<p>{1,}</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>Match the preceding character 1 or more times.</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>?</code></td>&#13;
			<td>&#13;
			<p>{0,1}</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>Match the preceding character 0 or 1 time.</p>&#13;
			</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>Quantifiers are greedy and will return the longest match possible. This sometimes results in surprising behavior. Since an SSN starts and ends with a digit, we might think the following shorter regex will be a simpler approach for finding SSNs. Can you figure out what went wrong in the matching?</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">ssn_re_dot</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="sa">r</code></span><span><code class="s1">'</code><code class="s1">[0-9].+[0-9]</code><code class="s1">'</code></span><code>&#13;
</code><span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">findall</code></span><span><code class="p">(</code></span><span><code class="n">ssn_re_dot</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">My SSN is 382-34-3842 and hers is 382-34-3333.</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
['382-34-3842 and hers is 382-34-3333']&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Notice that we use the metacharacter <code>.</code> to match any character. In many cases, using a more specific character class prevents these false “overmatches.” Our earlier pattern that includes word boundaries does this:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre class="pagebreak-before less_space" data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">findall</code></span><span><code class="p">(</code></span><span><code class="n">ssn_re</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">My SSN is 382-34-3842 and hers is 382-34-3333.</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
['382-34-3842', '382-34-3333']&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Some platforms allow you to turn off greedy matching and use <em>lazy</em> matching, which returns the shortest string.</p>&#13;
&#13;
<p>Literal concatenation and quantifiers are two of the core concepts in regular expressions. Next, we introduce two more core concepts: alternation and grouping.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Alternation and Grouping to Create Features" data-type="sect2"><div class="sect2" id="alternation-and-grouping-to-create-features">&#13;
<h2>Alternation and Grouping to Create Features</h2>&#13;
&#13;
<p>Character<a contenteditable="false" data-primary="regular expressions (regex)" data-secondary="alternation to create features" data-type="indexterm" id="id1514"/><a contenteditable="false" data-primary="regular expressions (regex)" data-secondary="grouping to create features" data-type="indexterm" id="id1515"/><a contenteditable="false" data-primary="features and feature types" data-secondary="grouping to create" data-type="indexterm" id="id1516"/><a contenteditable="false" data-primary="features and feature types" data-secondary="alternation to create" data-type="indexterm" id="id1517"/><a contenteditable="false" data-primary="grouping in data tables" data-secondary="creating features with" data-type="indexterm" id="id1518"/><a contenteditable="false" data-primary="alternation to create features" data-type="indexterm" id="id1519"/> classes let us match multiple options for a single literal. We can use alternation to match multiple options for a group of literals. For instance, in the food safety example in <a class="reference internal" data-type="xref" href="ch09.html#ch-wrangling">Chapter 9</a>, we marked violations related to body parts by seeing if the violation had the substring <code>hand</code>, <code>nail</code>, <code>hair</code>, or <code>glove</code>. We can use the <code>|</code> character in a regex to specify this alteration:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">body_re</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="sa">r</code></span><span><code class="s2">"</code><code class="s2">hand|nail|hair|glove</code><code class="s2">"</code></span><code>&#13;
</code><span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">findall</code></span><span><code class="p">(</code></span><span><code class="n">body_re</code></span><span><code class="p">,</code></span><code> </code><span><code class="s2">"</code><code class="s2">unclean hands or improper use of gloves</code><code class="s2">"</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
['hand', 'glove']&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">findall</code></span><span><code class="p">(</code></span><span><code class="n">body_re</code></span><span><code class="p">,</code></span><code> </code><span><code class="s2">"</code><code class="s2">Unsanitary employee garments hair or nails</code><code class="s2">"</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
['hair', 'nail']&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>With parentheses we can locate parts of a pattern, which are called <em>regex groups</em>. For example, we can use regex groups to extract the day, month, year, and time from the web server log entry:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="c1"># This pattern matches the entire timestamp</code></span><code>&#13;
</code><span><code class="n">time_re</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="sa">r</code></span><span><code class="s2">"</code><code class="s2">\</code><code class="s2">[[0-9]</code></span><span><code class="si">{2}</code></span><span><code class="s2">/[a-zA-z]</code></span><span><code class="si">{3}</code></span><span><code class="s2">/[0-9]</code></span><span><code class="si">{4}</code></span><span><code class="s2">:[0-9:</code><code class="s2">\</code><code class="s2">- ]*</code><code class="s2">\</code><code class="s2">]</code><code class="s2">"</code></span><code>&#13;
</code><span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">findall</code></span><span><code class="p">(</code></span><span><code class="n">time_re</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">log_entry</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
['[26/Jan/2004:10:47:58 -0800]']&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="c1"># Same regex, but we use parens to make regex groups...</code></span><code>&#13;
</code><span><code class="n">time_re</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="sa">r</code></span><span><code class="s2">"</code><code class="s2">\</code><code class="s2">[([0-9]</code></span><span><code class="si">{2}</code></span><span><code class="s2">)/([a-zA-z]</code></span><span><code class="si">{3}</code></span><span><code class="s2">)/([0-9]</code></span><span><code class="si">{4}</code></span><span><code class="s2">):([0-9:</code><code class="s2">\</code><code class="s2">- ]*)</code><code class="s2">\</code><code class="s2">]</code><code class="s2">"</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="c1"># ...which tells findall() to split up the match into its groups</code></span><code>&#13;
</code><span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">findall</code></span><span><code class="p">(</code></span><span><code class="n">time_re</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">log_entry</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
[('26', 'Jan', '2004', '10:47:58 -0800')]&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>As we can see, <code>re.findall</code> returns a list of tuples containing the individual components of the date and time of the web log.</p>&#13;
&#13;
<p>We have introduced a lot of terminology, so in the next section we bring it all together into a set of tables for easy reference.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Reference Tables" data-type="sect2"><div class="sect2" id="reference-tables">&#13;
<h2>Reference Tables</h2>&#13;
&#13;
<p>We conclude<a contenteditable="false" data-primary="reference tables, regular expressions" data-type="indexterm" id="ix_regex_ref_table2"/><a contenteditable="false" data-primary="regular expressions (regex)" data-secondary="reference tables" data-type="indexterm" id="ix_regex_ref_table"/> this section with a few tables that summarize order of operation, metacharacters, and shorthands for character classes. We also provide tables summarizing the handful of methods in the <code>re</code> Python library that we have used in this section.</p>&#13;
&#13;
<p>The four basic operations for regular expressions—concatenation, quantifying, alternation, and grouping—have an order of precedence, which we make explicit in <a class="reference internal" data-type="xref" href="#regex-order">Table 13-4</a>.</p>&#13;
&#13;
<table id="regex-order">&#13;
	<caption><span class="label">Table 13-4. </span><span>Order of operations</span></caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th class="head">Operation</th>&#13;
			<th class="head">Order</th>&#13;
			<th class="head">Example</th>&#13;
			<th class="head">Matches</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>Concatenation</td>&#13;
			<td>&#13;
			<p>3</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>cat</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>cat</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Alternation</td>&#13;
			<td>&#13;
			<p>4</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>cat|mouse</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>cat</code> and <code>mouse</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Quantifying</td>&#13;
			<td>&#13;
			<p>2</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>cat?</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>ca</code> and <code>cat</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Grouping</td>&#13;
			<td>&#13;
			<p>1</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>c(at)?</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>c</code> and <code>cat</code></p>&#13;
			</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p><a class="reference internal" data-type="xref" href="#regex-meta">Table 13-5</a> provides a list of the metacharacters introduced in this section<a contenteditable="false" data-primary="metacharacters" data-type="indexterm" id="id1520"/>, plus a few more. The column labeled “Doesn’t match” gives examples of strings that the example regexes don’t match.</p>&#13;
&#13;
<table id="regex-meta">&#13;
	<caption><span class="label">Table 13-5. </span><span>Metacharacters</span></caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th class="head">Char</th>&#13;
			<th class="head">Description</th>&#13;
			<th class="head">Example</th>&#13;
			<th class="head">Matches</th>&#13;
			<th class="head">Doesn’t match</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>.</td>&#13;
			<td>&#13;
			<p>Any character except \n</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>...</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>abc</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>ab</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>[ ]</td>&#13;
			<td>&#13;
			<p>Any character inside brackets</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>[cb.]ar</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>car<br/>&#13;
			.ar</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>jar</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>[^ ]</td>&#13;
			<td>&#13;
			<p>Any character <em>not</em> inside brackets</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>[^b]ar</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>car<br/>&#13;
			par</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>bar<br/>&#13;
			ar</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>*</td>&#13;
			<td>&#13;
			<p>≥ 0 or more of previous symbol, shorthand for {0,}</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>[pb]*ark</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>bbark<br/>&#13;
			ark</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>dark</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>+</td>&#13;
			<td>&#13;
			<p>≥ 1 or more of previous symbol, shorthand for {1,}</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>[pb]+ark</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>bbpark<br/>&#13;
			bark</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>dark<br/>&#13;
			ark</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>?</td>&#13;
			<td>&#13;
			<p>0 or 1 of previous symbol, shorthand for {0,1}</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>s?he</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>she<br/>&#13;
			he</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>the</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>{<em>n</em>}</td>&#13;
			<td>&#13;
			<p>Exactly <em>n</em> of previous symbol</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>hello{3}</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>hellooo</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>hello</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>|</td>&#13;
			<td>&#13;
			<p>Pattern before or after bar</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>we|[ui]s</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>we<br/>&#13;
			us<br/>&#13;
			is</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>es<br/>&#13;
			e<br/>&#13;
			s</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>\</td>&#13;
			<td>&#13;
			<p>Escape next character</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>\[hi\]</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>[hi]</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>hi</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>^</td>&#13;
			<td>&#13;
			<p>Beginning of line</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>^ark</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>ark two</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>dark</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>$</td>&#13;
			<td>&#13;
			<p>End of line</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>ark$</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>noahs ark</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>noahs arks</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>\b</td>&#13;
			<td>&#13;
			<p>Word boundary</p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>ark\b</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p>ark of noah</p>&#13;
			</td>&#13;
			<td>&#13;
			<p>noahs arks</p>&#13;
			</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>Additionally, in <a class="reference internal" data-type="xref" href="#regex-shorthand">Table 13-6</a>, we provide shorthands for some commonly used character sets. These shorthands<a contenteditable="false" data-primary="character classes" data-type="indexterm" id="id1521"/> don’t need <code>[ <span class="pre">]</span></code>.</p>&#13;
&#13;
<table id="regex-shorthand">&#13;
	<caption><span class="label">Table 13-6. </span><span>Character class shorthands </span></caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th class="head">Description</th>&#13;
			<th class="head">Bracket form</th>&#13;
			<th class="head">Shorthand</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>Alphanumeric character</td>&#13;
			<td>&#13;
			<p><code>[a-zA-Z0-9_]</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>\w</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Not an alphanumeric character</td>&#13;
			<td>&#13;
			<p><code>[^a-zA-Z0-9_]</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>\W</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Digit</td>&#13;
			<td>&#13;
			<p><code>[0-9]</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>\d</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Not a digit</td>&#13;
			<td>&#13;
			<p><code>[^0-9]</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>\D</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Whitespace</td>&#13;
			<td>&#13;
			<p><code>[\t\n\f\r\p{Z}]</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>\s</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Not whitespace</td>&#13;
			<td>&#13;
			<p><code>[^\t\n\f\r\p{z}]</code></p>&#13;
			</td>&#13;
			<td>&#13;
			<p><code>\S</code></p>&#13;
			</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>We used the following methods in <code>re</code> in this chapter. The names of the methods are indicative of the functionality they perform: <em>search</em> or <em>match</em> a pattern in a string; <em>find all</em> cases of a pattern in a string; <em>sub</em>stitute all occurrences of a pattern with a substring; and <em>split</em> a string into pieces at the pattern. Each requires a pattern and string to be specified, and some have extra arguments. <a class="reference internal" data-type="xref" href="#regex-methods">Table 13-7</a> provides the format of the method usage and a description of the return<a contenteditable="false" data-primary="regular expressions (regex)" data-secondary="methods" data-type="indexterm" id="id1522"/> value.</p>&#13;
&#13;
<table id="regex-methods">&#13;
	<caption><span class="label">Table 13-7. </span><span>Regular expression methods</span></caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th class="width-40">Method</th>&#13;
			<th class="width-40">Return value</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><code>re.search(pattern, <span class="pre">string)</span></code></td>&#13;
			<td>&#13;
			<p>Match object if the pattern is found anywhere in the string, otherwise <code>None</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>re.match(pattern, <span class="pre">string)</span></code></td>&#13;
			<td>&#13;
			<p>Match object if the pattern is found at the beginning of the string, otherwise <code>None</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>re.findall(pattern, <span class="pre">string)</span></code></td>&#13;
			<td>&#13;
			<p>List of all matches of <code>pattern</code> in <code>string</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>re.sub(pattern, <span class="pre">replacement,</span> <span class="pre">string)</span></code></td>&#13;
			<td>&#13;
			<p>String where all occurrences of <code>pattern</code> are replaced by <code>replacement</code> in the <code>string</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>re.split(pattern, <span class="pre">string)</span></code></td>&#13;
			<td>&#13;
			<p>List of the pieces of <code>string</code> around the occurrences of <code>pattern</code></p>&#13;
			</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>As we saw in the previous<a contenteditable="false" data-primary="pandas library" data-secondary="regular expressions" data-type="indexterm" id="id1523"/> section, <code>pandas</code> <code>Series</code> objects have a <code>.str</code> property that supports string manipulation using Python string methods. Conveniently, the <code>.str</code> property also supports some functions from the <code>re</code> module. <a class="reference internal" data-type="xref" href="#regex-pandas">Table 13-8</a> shows the analogous functionality from <a class="reference internal" data-type="xref" href="#regex-methods">Table 13-7</a> of the <code>re</code> methods. Each requires a pattern. See <a class="reference external" href="https://oreil.ly/aHJRz">the <code>pandas</code> docs</a> for a complete list of string methods.</p>&#13;
&#13;
<table id="regex-pandas">&#13;
	<caption><span class="label">Table 13-8. </span><span>Regular expressions in <code>pandas</code></span></caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th class="width-40">Method</th>&#13;
			<th class="width-40">Return value</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><code>str.contains(pattern, <span class="pre">regex=True)</span></code></td>&#13;
			<td>&#13;
			<p>Series of booleans indicating whether the <code>pattern</code> is found</p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>str.findall(pattern, <span class="pre">regex=True)</span></code></td>&#13;
			<td>&#13;
			<p>List of all matches of <code>pattern</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>str.replace(pattern, <span class="pre">replacement,</span> <span class="pre">regex=True)</span></code></td>&#13;
			<td>&#13;
			<p>Series with all matching occurrences of <code>pattern</code> replaced by <code>replacement</code></p>&#13;
			</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><code>str.split(pattern, <span class="pre">regex=True)</span></code></td>&#13;
			<td>&#13;
			<p>Series of lists of strings around given <code>pattern</code></p>&#13;
			</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>Regular expressions are a powerful tool, but they’re somewhat notorious for being difficult to read and debug. We close with some advice for using regexes:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p>Develop your regular expression on simple test strings to see what the pattern matches.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>If a pattern matches nothing, try weakening it by dropping part of the pattern. Then tighten it incrementally to see how the matching evolves. (Online regex-checking tools can be very helpful here.)</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Make the pattern only as specific as it needs to be for the data at hand.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Use raw strings whenever possible for cleaner patterns, especially when a pattern includes a backslash.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>When you have lots of long strings, consider using compiled patterns because they can be faster to match (see <code>compile()</code> in the <code>re</code> library).</p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>In the next section, we carry out an example text analysis. We clean the data using regular expressions and string manipulation, convert the text into quantitative data, and analyze the text via these derived quantities<a contenteditable="false" data-primary="" data-startref="ix_text_regex_ch13" data-type="indexterm" id="id1524"/><a contenteditable="false" data-primary="" data-startref="ix_regex_ref_table2" data-type="indexterm" id="id1525"/><a contenteditable="false" data-primary="" data-startref="ix_regex_ref_table" data-type="indexterm" id="id1526"/><a contenteditable="false" data-primary="" data-startref="ix_string_regex" data-type="indexterm" id="id1527"/><a contenteditable="false" data-primary="" data-startref="ix_regex_ch13" data-type="indexterm" id="id1528"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Text Analysis" data-type="sect1"><div class="sect1" id="text-analysis2">&#13;
<h1>Text Analysis</h1>&#13;
&#13;
<p>So far, we’ve used Python methods<a contenteditable="false" data-primary="text" data-secondary="analysis of" data-type="indexterm" id="ix_text_anal"/><a contenteditable="false" data-primary="text mining" data-type="indexterm" id="ix_text_mine"/> and regular expressions to clean short text fields and strings. In this section, we analyze entire documents using a technique called <em>text mining</em>, which transforms free-form text into a quantitative representation to uncover meaningful patterns and insights.</p>&#13;
&#13;
<p>Text mining is a deep topic. Instead of a comprehensive treatment, we introduce a few key ideas through an example, where we analyze the State of the Union speeches from 1790 to 2022. Every year, the US president gives a State of the Union speech to Congress. These speeches talk about current events in the country and make recommendations for Congress to consider. <a class="reference external" href="https://oreil.ly/JbpO4">The American Presidency Project</a> makes these speeches available online.</p>&#13;
&#13;
<p>Let’s begin by opening the file that has all of the speeches:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="kn">from</code></span><code> </code><span><code class="nn">pathlib</code></span><code> </code><span><code class="kn">import</code></span><code> </code><span><code class="n">Path</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">text</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">Path</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">data/stateoftheunion1790-2022.txt</code><code class="s1">'</code></span><span><code class="p">)</code></span><span><code class="o">.</code></span><span><code class="n">read_text</code></span><span><code class="p">(</code><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>At the beginning of this chapter, we saw that each speech in the data begins with a line with three asterisks: <code>***</code>. We can use a regular expression to count the number of times the string <code>***</code> appears:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="kn">import</code></span><code> </code><span><code class="nn">re</code></span><code>&#13;
</code><span><code class="n">num_speeches</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="nb">len</code></span><span><code class="p">(</code></span><span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">findall</code></span><span><code class="p">(</code></span><span><code class="sa">r</code></span><span><code class="s2">"</code><code class="s2">\</code><code class="s2">*</code><code class="s2">\</code><code class="s2">*</code><code class="s2">\</code><code class="s2">*</code><code class="s2">"</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">text</code></span><span><code class="p">)</code><code class="p">)</code></span><code>&#13;
</code><span><code class="nb">print</code></span><span><code class="p">(</code></span><span><code class="sa">f</code></span><span><code class="s1">'</code><code class="s1">There are </code></span><span><code class="si">{</code></span><span><code class="n">num_speeches</code></span><span><code class="si">}</code></span><span><code class="s1"> speeches total</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output stream highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
There are 232 speeches total&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>In text analysis<a contenteditable="false" data-primary="documents in text analysis" data-type="indexterm" id="id1529"/>, a <em>document</em> refers to a single piece of text that we want to analyze. Here, each speech is a document. We split apart the <code>text</code> variable into its individual documents:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">records</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">text</code></span><span><code class="o">.</code></span><span><code class="n">split</code></span><span><code class="p">(</code></span><span><code class="s2">"</code><code class="s2">***</code><code class="s2">"</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Then we can put the speeches into a dataframe:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="k">def</code></span><code> </code><span><code class="nf">extract_parts</code></span><span><code class="p">(</code></span><span><code class="n">speech</code></span><span><code class="p">)</code><code class="p">:</code></span><code>&#13;
</code><code>    </code><span><code class="n">speech</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">speech</code></span><span><code class="o">.</code></span><span><code class="n">strip</code></span><span><code class="p">(</code><code class="p">)</code></span><span><code class="o">.</code></span><span><code class="n">split</code></span><span><code class="p">(</code></span><span><code class="s1">'</code></span><span><code class="se">\n</code></span><span><code class="s1">'</code></span><span><code class="p">)</code><code class="p">[</code></span><span><code class="mi">1</code></span><span><code class="p">:</code><code class="p">]</code></span><code>&#13;
</code><code>    </code><span><code class="p">[</code></span><span><code class="n">name</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">date</code></span><span><code class="p">,</code></span><code> </code><span><code class="o">*</code></span><span><code class="n">lines</code></span><span><code class="p">]</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">speech</code></span><code>&#13;
</code><code>    </code><span><code class="n">body</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'</code></span><span><code class="se">\n</code></span><span><code class="s1">'</code></span><span><code class="o">.</code></span><span><code class="n">join</code></span><span><code class="p">(</code></span><span><code class="n">lines</code></span><span><code class="p">)</code></span><span><code class="o">.</code></span><span><code class="n">strip</code></span><span><code class="p">(</code><code class="p">)</code></span><code>&#13;
</code><code>    </code><span><code class="k">return</code></span><code> </code><span><code class="p">[</code></span><span><code class="n">name</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">date</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">body</code></span><span><code class="p">]</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="k">def</code></span><code> </code><span><code class="nf">read_speeches</code></span><span><code class="p">(</code><code class="p">)</code><code class="p">:</code></span><code>&#13;
</code><code>    </code><span><code class="k">return</code></span><code> </code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">DataFrame</code></span><span><code class="p">(</code><code class="p">[</code></span><span><code class="n">extract_parts</code></span><span><code class="p">(</code></span><span><code class="n">l</code></span><span><code class="p">)</code></span><code> </code><span><code class="k">for</code></span><code> </code><span><code class="n">l</code></span><code> </code><span><code class="ow">in</code></span><code> </code><span><code class="n">records</code></span><span><code class="p">[</code></span><span><code class="mi">1</code></span><span><code class="p">:</code><code class="p">]</code><code class="p">]</code><code class="p">,</code></span><code>&#13;
</code><code>                        </code><span><code class="n">columns</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="p">[</code></span><span><code class="s2">"</code><code class="s2">name</code><code class="s2">"</code></span><span><code class="p">,</code></span><code> </code><span><code class="s2">"</code><code class="s2">date</code><code class="s2">"</code></span><span><code class="p">,</code></span><code> </code><span><code class="s2">"</code><code class="s2">text</code><code class="s2">"</code></span><span><code class="p">]</code><code class="p">)</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">df</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">read_speeches</code></span><span><code class="p">(</code><code class="p">)</code></span><code>&#13;
</code><span><code class="n">df</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>name</th>&#13;
			<th>date</th>&#13;
			<th>text</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>George Washington</td>&#13;
			<td>January 8, 1790</td>&#13;
			<td>Fellow-Citizens of the Senate and House of Rep...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>George Washington</td>&#13;
			<td>December 8, 1790</td>&#13;
			<td>Fellow-Citizens of the Senate and House of Rep...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>George Washington</td>&#13;
			<td>October 25, 1791</td>&#13;
			<td>Fellow-Citizens of the Senate and House of Rep...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>229</strong></td>&#13;
			<td>Donald J. Trump</td>&#13;
			<td>February 4, 2020</td>&#13;
			<td>Thank you very much. Thank you. Thank you very...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>230</strong></td>&#13;
			<td>Joseph R. Biden, Jr.</td>&#13;
			<td>April 28, 2021</td>&#13;
			<td>Thank you. Thank you. Thank you. Good to be ba...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>231</strong></td>&#13;
			<td>Joseph R. Biden, Jr.</td>&#13;
			<td>March 1, 2022</td>&#13;
			<td>Madam Speaker, Madam Vice President, our First...</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>232 rows × 3 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before less_space">Now that we have the speeches loaded into a dataframe, we want to transform the speeches to see how they have changed over time. Our basic idea is to look at the words in the speeches—if two speeches contain very different words, our analysis should tell us that. With some kind of measure of document similarity, we can see how the speeches differ from one another.</p>&#13;
&#13;
<p>There are a few problems in the documents that we need to take care of first:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p>Capitalization shouldn’t matter: <code>Citizens</code> and <code>citizens</code> should be considered the same word. We can address this by lowercasing the text.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>There are unspoken remarks in the text: <code>[laughter]</code> points out where the audience laughed, but these shouldn’t count as part of the speech. We can address this by using a regex to remove text within brackets: <code>\[[^\]]+\]</code>. Remember that <code>\[</code> and <code>\]</code> match the literal left and right brackets, and <code>[^\]]</code> matches any character that isn’t a right bracket.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>We should take out characters that aren’t letters or whitespace: some speeches talk about finances, but a dollar amount shouldn’t count as a word. We can use the regex <code>[^a-z\s]</code> to remove these characters. This regex matches any character that isn’t a lowercase letter (<code>a-z</code>) or a whitespace character (<code>\s</code>):</p>&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="k">def</code></span><code> </code><span><code class="nf">clean_text</code></span><span><code class="p">(</code></span><span><code class="n">df</code></span><span><code class="p">)</code><code class="p">:</code></span><code>&#13;
</code><code>    </code><span><code class="n">bracket_re</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">compile</code></span><span><code class="p">(</code></span><span><code class="sa">r</code></span><span><code class="s1">'</code><code class="s1">\</code><code class="s1">[[^</code><code class="s1">\</code><code class="s1">]]+</code><code class="s1">\</code><code class="s1">]</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>    </code><span><code class="n">not_a_word_re</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">re</code></span><span><code class="o">.</code></span><span><code class="n">compile</code></span><span><code class="p">(</code></span><span><code class="sa">r</code></span><span><code class="s1">'</code><code class="s1">[^a-z</code><code class="s1">\</code><code class="s1">s]</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>    </code><span><code class="n">cleaned</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="p">(</code></span><span><code class="n">df</code></span><span><code class="p">[</code></span><span><code class="s1">'</code><code class="s1">text</code><code class="s1">'</code></span><span><code class="p">]</code></span><span><code class="o">.</code></span><span><code class="n">str</code></span><span><code class="o">.</code></span><span><code class="n">lower</code></span><span><code class="p">(</code><code class="p">)</code></span><code>&#13;
</code><code>               </code><span><code class="o">.</code></span><span><code class="n">str</code></span><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="n">bracket_re</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">regex</code></span><span><code class="o">=</code></span><span><code class="kc">True</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>               </code><span><code class="o">.</code></span><span><code class="n">str</code></span><span><code class="o">.</code></span><span><code class="n">replace</code></span><span><code class="p">(</code></span><span><code class="n">not_a_word_re</code></span><span><code class="p">,</code></span><code> </code><span><code class="s1">'</code><code class="s1"> </code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">regex</code></span><span><code class="o">=</code></span><span><code class="kc">True</code></span><span><code class="p">)</code><code class="p">)</code></span><code>&#13;
</code><code>    </code><span><code class="k">return</code></span><code> </code><span><code class="n">df</code></span><span><code class="o">.</code></span><span><code class="n">assign</code></span><span><code class="p">(</code></span><span><code class="n">text</code></span><span><code class="o">=</code></span><span><code class="n">cleaned</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">df</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="p">(</code></span><span><code class="n">read_speeches</code></span><span><code class="p">(</code><code class="p">)</code></span><code>&#13;
</code><code>      </code><span><code class="o">.</code></span><span><code class="n">pipe</code></span><span><code class="p">(</code></span><span><code class="n">clean_text</code></span><span><code class="p">)</code><code class="p">)</code></span><code>&#13;
</code><span><code class="n">df</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>name</th>&#13;
			<th>date</th>&#13;
			<th>text</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<th>0</th>&#13;
			<td>George Washington</td>&#13;
			<td>January 8, 1790</td>&#13;
			<td>fellow citizens of the senate and house of rep...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<th>1</th>&#13;
			<td>George Washington</td>&#13;
			<td>December 8, 1790</td>&#13;
			<td>fellow citizens of the senate and house of rep...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<th>2</th>&#13;
			<td>George Washington</td>&#13;
			<td>October 25, 1791</td>&#13;
			<td>fellow citizens of the senate and house of rep...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<th>...</th>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<th>229</th>&#13;
			<td>Donald J. Trump</td>&#13;
			<td>February 4, 2020</td>&#13;
			<td>thank you very much thank you thank you very...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<th>230</th>&#13;
			<td>Joseph R. Biden, Jr.</td>&#13;
			<td>April 28, 2021</td>&#13;
			<td>thank you thank you thank you good to be ba...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<th>231</th>&#13;
			<td>Joseph R. Biden, Jr.</td>&#13;
			<td>March 1, 2022</td>&#13;
			<td>madam speaker madam vice president our first...</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>232 rows × 3 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
<p class="pagebreak-before less_space">Next, we look at some more complex issues:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p><em>Stop words</em> like <code>is</code>, <code>and</code>, <code>the</code>, and <code>but</code> appear<a contenteditable="false" data-primary="" data-startref="stop words, removing from text" data-type="indexterm" id="id1530"/> so often that we would like to just remove them.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p><code>argue</code> and <code>arguing</code> should count as the same word, even though they appear differently in the text. To address this, we’ll use <em>word stemming</em>, which transforms both words to <code>argu</code>.</p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>To handle these issues<a contenteditable="false" data-primary="nltk library" data-type="indexterm" id="id1531"/>, we can use built-in methods from <a class="reference external" href="https://www.nltk.org">the <code>nltk</code> library</a>.</p>&#13;
&#13;
<p>Finally, we transform<a contenteditable="false" data-primary="word vectors" data-type="indexterm" id="id1532"/> the speeches into <em>word vectors</em>. A word vector represents a document using a vector of numbers. For example, one basic type of word vector counts up how many times each word appears in the text, as depicted in <a class="reference internal" data-type="xref" href="#fig-word-vectors">Figure 13-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-word-vectors"><img src="assets/leds_1302.png"/>&#13;
<h6><span class="label">Figure 13-2. </span>Bag-of-words vectors for three small example documents</h6>&#13;
</div></figure>&#13;
&#13;
<p>This simple transform<a contenteditable="false" data-primary="term frequency-inverse document frequency (tf-idf)" data-type="indexterm" id="id1533"/><a contenteditable="false" data-primary="tf-idf transform" data-type="indexterm" id="id1534"/><a contenteditable="false" data-primary="scikit-learn library" data-secondary="bag-of-words transform" data-type="indexterm" id="id1535"/><a contenteditable="false" data-primary="bag-of-words transform" data-type="indexterm" id="id1536"/> is called <em>bag-of-words</em>, and we apply it on all of our speeches. Then we calculate the <em>term frequency-inverse document frequency</em> (<em>tf-idf</em> for short) to normalize the counts and measure the rareness of a word. The tf-idf puts more weight on words that only appear in a few documents. The idea is that if just a few documents mention the word <em>sanction</em>, say, then this word is extra useful for distinguishing documents from each other. <a class="reference external" href="https://oreil.ly/3A6a5">The <code>scikit-learn</code> library</a> has a complete description of the transform and an implementation, which we use.</p>&#13;
&#13;
<p>After applying these transforms, we have a two-dimensional array, <code>speech_vectors</code>. Each row of this array is one speech transformed into a vector:</p>&#13;
&#13;
<div class="cell tag_remove-output docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="kn">import</code></span><code> </code><span><code class="nn">nltk</code></span><code>&#13;
</code><span><code class="n">nltk</code></span><span><code class="o">.</code></span><span><code class="n">download</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">stopwords</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><span><code class="n">nltk</code></span><span><code class="o">.</code></span><span><code class="n">download</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">punkt</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="kn">from</code></span><code> </code><span><code class="nn">nltk</code><code class="nn">.</code><code class="nn">stem</code><code class="nn">.</code><code class="nn">porter</code></span><code> </code><span><code class="kn">import</code></span><code> </code><span><code class="n">PorterStemmer</code></span><code>&#13;
</code><span><code class="kn">from</code></span><code> </code><span><code class="nn">sklearn</code><code class="nn">.</code><code class="nn">feature_extraction</code><code class="nn">.</code><code class="nn">text</code></span><code> </code><span><code class="kn">import</code></span><code> </code><span><code class="n">TfidfVectorizer</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">stop_words</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="nb">set</code></span><span><code class="p">(</code></span><span><code class="n">nltk</code></span><span><code class="o">.</code></span><span><code class="n">corpus</code></span><span><code class="o">.</code></span><span><code class="n">stopwords</code></span><span><code class="o">.</code></span><span><code class="n">words</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">english</code><code class="s1">'</code></span><span><code class="p">)</code><code class="p">)</code></span><code>&#13;
</code><span><code class="n">porter_stemmer</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">PorterStemmer</code></span><span><code class="p">(</code><code class="p">)</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="k">def</code></span><code> </code><span><code class="nf">stemming_tokenizer</code></span><span><code class="p">(</code></span><span><code class="n">document</code></span><span><code class="p">)</code><code class="p">:</code></span><code>&#13;
</code><code>    </code><span><code class="k">return</code></span><code> </code><span><code class="p">[</code></span><span><code class="n">porter_stemmer</code></span><span><code class="o">.</code></span><span><code class="n">stem</code></span><span><code class="p">(</code></span><span><code class="n">word</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>            </code><span><code class="k">for</code></span><code> </code><span><code class="n">word</code></span><code> </code><span><code class="ow">in</code></span><code> </code><span><code class="n">nltk</code></span><span><code class="o">.</code></span><span><code class="n">word_tokenize</code></span><span><code class="p">(</code></span><span><code class="n">document</code></span><span><code class="p">)</code></span><code>&#13;
</code><code>            </code><span><code class="k">if</code></span><code> </code><span><code class="n">word</code></span><code> </code><span><code class="ow">not</code></span><code> </code><span><code class="ow">in</code></span><code> </code><span><code class="n">stop_words</code></span><span><code class="p">]</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">tfidf</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">TfidfVectorizer</code></span><span><code class="p">(</code></span><span><code class="n">tokenizer</code></span><span><code class="o">=</code></span><span><code class="n">stemming_tokenizer</code></span><span><code class="p">)</code></span><code>&#13;
</code><span><code class="n">speech_vectors</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">tfidf</code></span><span><code class="o">.</code></span><span><code class="n">fit_transform</code></span><span><code class="p">(</code></span><span><code class="n">df</code></span><span><code class="p">[</code></span><span><code class="s1">'</code><code class="s1">text</code><code class="s1">'</code></span><span><code class="p">]</code><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">speech_vectors</code></span><span><code class="o">.</code></span><span><code class="n">shape</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_plain highlight-myst-ansi notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
(232, 13211)&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>We have 232 speeches<a contenteditable="false" data-primary="principal component analysis" data-type="indexterm" id="id1537"/>, and each speech was transformed into a length-13,211 vector. To visualize these speeches, we use a technique called <em>principal component analysis</em> to represent the data table of 13,211 features by a new set of features that are orthogonal to one another. The first vector accounts for the maximum variation in the original features, the second for the maximum variance that is orthogonal to the first, and so on. Often the first two components, which we can plot as pairs of points, reveal clusters and outliers.</p>&#13;
&#13;
<p>Next, we plot the first two principal components. Each point is one speech, and we’ve colored the points according to the year of the speech. Points that are close together represent similar speeches, and points that are far away from one another represent dissimilar speeches:</p>&#13;
&#13;
<figure class="informal"><div class="figure"><img src="assets/leds_13in01.png"/>&#13;
&#13;
</div></figure>&#13;
&#13;
<p>We see a clear difference in speeches over time—speeches given in the 1800s used very different words than speeches given after 2000. It’s also interesting to see that the speeches cluster tightly in the same time period. This suggests that speeches within the same period sound relatively similar, even though the speakers were from different political parties.</p>&#13;
&#13;
<p>This section gave a whirlwind introduction to text analysis. We used text manipulation tools from previous sections to clean up the presidential speeches. Then we used more advanced techniques like stemming, the tf-idf transform, and principal component analysis to compare speeches. Although we don’t have enough space in this book to cover all of these techniques in detail, we hope that this section piqued your interest in the exciting world of text analysis<a contenteditable="false" data-primary="" data-startref="ix_text_mine" data-type="indexterm" id="id1538"/><a contenteditable="false" data-primary="" data-startref="ix_text_anal" data-type="indexterm" id="id1539"/>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="sec-text-summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter introduced techniques for working with text to clean and analyze data, including string manipulation, regular expressions, and document analysis. Text data has rich information about how people live, work, and think. But this data is also hard for computers to use—think about all the creative ways people manage to spell the same word. The techniques in this chapter let us correct typos, extract features from logs, and compare documents.</p>&#13;
&#13;
<p>We don’t recommend you use regular expressions to:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p>Parse hierarchical structures such as JSON or HTML; use a parser instead</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Search for complex properties, like palindromes and balanced parentheses</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Validate a complex feature, such as a valid email address</p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>Regular expressions, while powerful, are terrible at these types of tasks. However, in our experience, even the basics of text manipulation can enable all sorts of interesting analyses—a little bit goes a long way.</p>&#13;
&#13;
<p>We have one final caution about regular expressions: they can be computationally expensive. You will want to consider the trade-offs between these concise, clear expressions and the overhead they create if they’re being put into production code<a contenteditable="false" data-primary="" data-startref="ix_text_ch13" data-type="indexterm" id="id1540"/>.</p>&#13;
&#13;
<p>The next chapter considers other sorts of data, such as data in binary formats, and the highly structured text of JSON and HTML. Our focus will be on loading these data into dataframes and other Python data structures.</p>&#13;
</div></section>&#13;
</div></section></body></html>