- en: Chapter 3\. Simulation and Data Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we develop the basic theoretical foundation needed to reason
    about how data is sampled and the implications on bias and variance. We build
    this foundation not on the dry equations of classic statistics but on the story
    of an urn filled with marbles. We use the computational tools of simulation to
    reason about the properties of selecting marbles from the urn and what they tell
    us about data collection in the real world. We connect the simulation process
    to common statistical distributions (the dry equations), but the basic tools of
    simulation enable us to go beyond what can be directly modeled using equations.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we study how the pollsters failed to predict the outcome of the
    US presidential election in 2016\. Our simulation study uses the actual votes
    cast in Pennsylvania. We simulate the sampling variation for a poll of these six
    million voters to uncover how response bias can skew polls and see how simply
    collecting more data would not have helped.
  prefs: []
  type: TYPE_NORMAL
- en: In a second simulation study, we examine a controlled experiment that demonstrated
    the efficacy of a COVID-19 vaccine but also launched a heated debate on the relative
    efficacy of vaccines. Abstracting the experiment to an urn model gives us a tool
    for studying assignment variation in randomized controlled experiments. Through
    simulation, we find the expected outcome of the clinical trial. Our simulation,
    along with careful examination of the data scope, debunks claims of vaccine ineffectiveness.
  prefs: []
  type: TYPE_NORMAL
- en: A third example uses simulation to imitate a measurement process. When we compare
    the fluctuations in our artificial measurements of air quality to real measurements,
    we can evaluate the appropriateness of the urn to model fluctuations in air quality
    measurements. This comparison creates the backdrop against which we calibrate
    PurpleAir monitors so that they can more accurately measure air quality in times
    of low humidity, like during fire season.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we tackle some of the most significant data debates of our time,
    we first start small, very small, with the story of a few marbles sitting in an
    urn.
  prefs: []
  type: TYPE_NORMAL
- en: The Urn Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The urn model was developed by Jacob Bernoulli in the early 1700s as a way
    to model the process of selecting items from a population. The urn model shown
    in [Figure 3-1](#sample-urn) gives a visual depiction of the process of randomly
    sampling marbles from an urn. Five marbles were originally in the urn: three black
    and two white. The diagram shows that two draws were made: first a white marble
    was drawn and then a black marble.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Diagram of two marbles being drawn, without replacement, from an
    urn
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To set up an urn model, we first need to make a few decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of marbles in the urn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The color (or label) on each marble
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of marbles to draw from the urn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we also need to decide on the sampling process. For our process, we
    mix the marbles in the urn, and as we select a marble for our sample, we can choose
    to record the color and return the marble to the urn (with replacement), or set
    aside the marble so that it cannot be drawn again (without replacement).
  prefs: []
  type: TYPE_NORMAL
- en: 'These decisions make up the parameters of our model. We can adapt the urn model
    to describe many real-world situations by our choice for these parameters. To
    illustrate, consider the example in [Figure 3-1](#sample-urn). We can *simulate*
    the draw of two marbles from our urn without replacement between draws using `numpy`’s
    `random.choice` method. The `numpy` library supports functions for arrays, which
    can be particularly useful for data science:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we set the `replace` argument to `False` to indicate that once we
    sample a marble, we don’t return it to the urn.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic setup, we can get approximate answers to questions about the
    kinds of samples we would expect to see. What is the chance that our sample contains
    marbles of only one color? Does the chance change if we return each marble after
    selecting it? What if we changed the number of marbles in the urn? What if we
    draw more marbles from the urn? What happens if we repeat the process many times?
  prefs: []
  type: TYPE_NORMAL
- en: The answers to these questions are fundamental to our understanding of data
    collection. We can build from these basic skills to simulate the urn and apply
    simulation techniques to real-world problems that can’t be easily solved with
    classic probability equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can use simulation to easily estimate the fraction of samples
    where both marbles that we draw match in color. In the following code, we run
    10,000 rounds of sampling two marbles from our urn. Using these samples, we can
    directly compute the proportion of samples with matching marbles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We just carried out a *simulation study*. Our call to `np.random.choice` imitates
    the chance process of drawing two marbles from the urn without replacement. Each
    call to `np.random.choice` gives us one possible sample. In a simulation study,
    we repeat this chance process many times (`10_000` in this case) to get a whole
    bunch of samples. Then we use the typical behavior of these samples to reason
    about what we might expect to get from the chance process. While this might seem
    like a contrived example (it is), consider if we replaced the marbles with people
    on a dating service, replaced the colors with more complex attributes, and perhaps
    used a neural network to score a match, and you can start to see the foundation
    of much more sophisticated analysis.
  prefs: []
  type: TYPE_NORMAL
- en: So far we have focused on the sample, but we are often interested in the relationship
    between the sample we might observe and what it can tell us about the “population”
    of marbles that were originally in the urn.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can draw an analogy to data scope from [Chapter 2](ch02.html#ch-data-scope):
    a set of marbles drawn from the urn is a *sample*, and the collection of all marbles
    placed in the urn is the *access frame*, which in this situation we take to be
    the same as the *population*. This blurring of the difference between the access
    frame and the population points to the gap between simulation and reality. Simulations
    tend to simplify models. Nonetheless, they can give helpful insights to real-world
    phenomena.'
  prefs: []
  type: TYPE_NORMAL
- en: The urn model, where we do not replace the marbles between draws, is a common
    selection method called the *simple random sample*. We describe this method and
    other sampling techniques based on it next.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling Designs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of drawing marbles without replacement from an urn is equivalent
    to a simple random sample. *In a simple random sample, every sample has the same
    chance of being selected.* While the method name has the word *simple* in it,
    constructing a simple random sample is often anything, but simple and in many
    cases is also the best sampling procedure. Plus, if we are being honest, it can
    also be a little confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand this sampling method, we return to the urn model. Consider
    an urn with seven marbles. Instead of coloring the marbles, we label each uniquely
    with a letter `A` through `G`. Since each marble has a different label, we can
    more clearly identify all possible samples that we might get. Let’s select three
    marbles from the urn without replacement, and use the `itertools` library to generate
    the list of all combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our list shows that there are 35 unique sets of three marbles. We could have
    drawn each of these sets six different ways. For example, the set <math><mo fence="false"
    stretchy="false">{</mo> <mi>A</mi> <mo>,</mo> <mi>B</mi> <mo>,</mo> <mi>C</mi>
    <mo fence="false" stretchy="false">}</mo></math> can be sampled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this small example, we can get a complete picture of all the ways in which
    we can draw any three marbles from the urn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since each set of three marbles from the population of seven is equally likely
    to occur, the chance of any one particular sample must be <math><mn>1</mn> <mrow><mo>/</mo></mrow>
    <mn>35</mn></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow>
    <mo stretchy="false">(</mo> <mi>A</mi> <mi>B</mi> <mi>C</mi> <mo stretchy="false">)</mo>
    <mo>=</mo> <mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow> <mo
    stretchy="false">(</mo> <mtext>ABD</mtext> <mo stretchy="false">)</mo> <mo>=</mo>
    <mo>⋯</mo> <mo>=</mo> <mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow>
    <mo stretchy="false">(</mo> <mtext>EFG</mtext> <mo stretchy="false">)</mo> <mo>=</mo>
    <mfrac><mn>1</mn> <mn>35</mn></mfrac></math>
  prefs: []
  type: TYPE_NORMAL
- en: We use the special symbol <math><mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow></math>
    to stand for “probability” or “chance,” and we read the statement <math><mrow><mrow><mi
    mathvariant="double-struck">P</mi></mrow></mrow> <mo stretchy="false">(</mo> <mi>A</mi>
    <mi>B</mi> <mi>C</mi> <mo stretchy="false">)</mo></math> as “the chance the sample
    contains the marbles labeled A, B, and C in any order.”
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the enumeration of all of the possible samples from the urn to answer
    additional questions about this chance process. For example, to find the chance
    that marble <math><mi>A</mi></math> is in the sample, we can add up the chance
    of all samples that contain <math><mi>A</mi></math> . There are 15 of them, so
    the chance is:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow>
    <mo stretchy="false">(</mo> <mrow><mi>A</mi>  <mi>i</mi> <mi>s</mi>  <mi>i</mi>
    <mi>n</mi>  <mi>t</mi> <mi>h</mi> <mi>e</mi>  <mi>s</mi> <mi>a</mi> <mi>m</mi>
    <mi>p</mi> <mi>l</mi> <mi>e</mi></mrow> <mo stretchy="false">)</mo> <mo>=</mo>
    <mfrac><mn>15</mn> <mn>35</mn></mfrac> <mo>=</mo> <mfrac><mn>3</mn> <mn>7</mn></mfrac></math>
  prefs: []
  type: TYPE_NORMAL
- en: When it’s too difficult to list and count all of the possible samples, we can
    use simulation to help understand this chance process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Many people mistakenly think that the defining property of a simple random sample
    is that every unit has an equal chance of being in the sample. However, this is
    not the case. A simple random sample of <math><mi>n</mi></math> units from a population
    of <math><mi>N</mi></math> means that every possible collection of <math><mi>n</mi></math>
    of the <math><mi>N</mi></math> units has the same chance of being selected. A
    slight variant of this is the *simple random sample with replacement*, where the
    units/marbles are returned to the urn after each draw. This method also has the
    property that every sample of <math><mi>n</mi></math> units from a population
    of <math><mi>N</mi></math> is equally likely to be selected. The difference, though,
    is that there are more possible sets of <math><mi>n</mi></math> units because
    the same marble can appear more than once in the sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple random sample (and its corresponding urn) is the main building block
    for more complex survey designs. We briefly describe two of the more widely used
    designs:'
  prefs: []
  type: TYPE_NORMAL
- en: Stratified sampling
  prefs: []
  type: TYPE_NORMAL
- en: Divide the population into nonoverlapping groups, called *strata* (one group
    is called a *stratum* and more than one are strata), and then take a simple random
    sample from each. This is like having a separate urn for each stratum and drawing
    marbles from each urn, independently. The strata do not have to be the same size,
    and we need not take the same number of marbles from each.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster sampling
  prefs: []
  type: TYPE_NORMAL
- en: Divide the population into nonoverlapping subgroups, called *clusters*, take
    a simple random sample of the clusters, and include all of the units in a cluster
    in the sample. We can think of this as a simple random sample from one urn that
    contains large marbles that are themselves containers of small marbles. (The large
    marbles need not have the same number of marbles in them.) When opened, the sample
    of large marbles turns into the sample of small marbles. (Clusters tend to be
    smaller than strata.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we might organize our seven marbles, labeled <math><mi>A</mi></math>
    – <math><mi>G</mi></math> , into three clusters, <math><mo stretchy="false">(</mo>
    <mi>A</mi> <mo>,</mo> <mi>B</mi> <mo stretchy="false">)</mo></math> , <math><mo
    stretchy="false">(</mo> <mi>C</mi> <mo>,</mo> <mi>D</mi> <mo stretchy="false">)</mo></math>
    , and <math><mo stretchy="false">(</mo> <mi>E</mi> <mo>,</mo> <mi>F</mi> <mo>,</mo>
    <mi>G</mi> <mo stretchy="false">)</mo></math> . Then, a cluster sample of size
    one has an equal chance of drawing any of the three clusters. In this scenario,
    each marble has the same chance of being in the sample:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left right" columnspacing="0em
    2em" displaystyle="true" rowspacing="3pt"><mtr><mtd><mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow>
    <mo stretchy="false">(</mo> <mrow><mi>A</mi>  <mtext>in sample</mtext></mrow>
    <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo> <mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow>
    <mo stretchy="false">(</mo> <mtext>cluster</mtext>  <mrow><mo stretchy="false">(</mo>
    <mi>A</mi> <mo>,</mo> <mi>B</mi> <mo stretchy="false">)</mo>  <mtext>chosen</mtext></mrow>
    <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr>
    <mtr><mtd><mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow> <mo
    stretchy="false">(</mo> <mrow><mi>B</mi>  <mtext>in sample</mtext></mrow> <mo
    stretchy="false">)</mo></mtd> <mtd><mo>=</mo> <mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow>
    <mo stretchy="false">(</mo> <mtext>cluster</mtext>  <mrow><mo stretchy="false">(</mo>
    <mi>A</mi> <mo>,</mo> <mi>B</mi> <mo stretchy="false">)</mo>  <mtext>chosen</mtext></mrow>
    <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr>
    <mtr><mtd><mrow><mo>⋮</mo></mrow></mtd></mtr> <mtr><mtd><mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow>
    <mo stretchy="false">(</mo> <mrow><mi>G</mi>  <mtext>in sample</mtext></mrow>
    <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo> <mrow><mrow><mi mathvariant="double-struck">P</mi></mrow></mrow>
    <mo stretchy="false">(</mo> <mtext>cluster</mtext>  <mrow><mo stretchy="false">(</mo>
    <mi>E</mi> <mo>,</mo> <mi>F</mi> <mo>,</mo> <mi>G</mi> <mo stretchy="false">)</mo>  <mtext>chosen</mtext></mrow>
    <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo> <mfrac><mn>1</mn> <mn>3</mn></mfrac></mtd></mtr></mtable></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'But every combination of elements is not equally likely: it is not possible
    for the sample to include both <math><mi>A</mi></math> and <math><mi>C</mi></math>
    , because they are in different clusters.'
  prefs: []
  type: TYPE_NORMAL
- en: Often, we are interested in a summary of the sample; in other words, we are
    interested in a *statistic*. For any sample, we can calculate the statistic, and
    the urn model helps us find the distribution of possible values that statistic
    may take on. Next, we examine the distribution of a statistic for our simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling Distribution of a Statistic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we are interested in testing the failure pressure of a new fuel tank
    design for a rocket. It’s expensive to carry out the pressure tests since we need
    to destroy the fuel tank, and we may need to test more than one fuel tank to address
    variations in manufacturing.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the urn model to choose the prototypes to be tested, and we can summarize
    our test results by the proportion of prototypes that fail the test. The urn model
    provides us the knowledge that each of the samples has the same chance of being
    selected, and so the pressure test results are representative of the population.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the example simple, let’s say we have seven fuel tanks that are labeled
    like the marbles from before. Let’s see what happens when tanks <math><mi>A</mi></math>
    , <math><mi>B</mi></math> , <math><mi>D</mi></math> , and <math><mi>F</mi></math>
    fail the pressure test, if chosen, and tanks <math><mi>C</mi></math> , <math><mi>E</mi></math>
    , and <math><mi>G</mi></math> pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each sample of three marbles, we can find the proportion of failures according
    to how many of these four defective prototypes are in the sample. We give a few
    examples of this calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Sample | ABC | BCE | BDF | CEG |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Proportion | 2/3 | 1/3 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Since we are drawing three marbles from the urn, the only possible sample proportions
    are <math><mn>0</mn></math> , <math><mn>1</mn> <mrow><mo>/</mo></mrow> <mn>3</mn></math>
    , <math><mn>2</mn> <mrow><mo>/</mo></mrow> <mn>3</mn></math> , and <math><mn>1</mn></math>
    , and for each triple, we can calculate its corresponding proportion. There are
    four samples that give us all failed tests (a sample proportion of 1). These are
    <math><mi>A</mi> <mi>B</mi> <mi>D</mi></math> , <math><mi>A</mi> <mi>B</mi> <mi>F</mi></math>
    , <math><mi>A</mi> <mi>D</mi> <mi>F</mi></math> , and <math><mi>B</mi> <mi>D</mi>
    <mi>F</mi></math> , so the chance of observing a sample proportion of 1 is <math><mn>4</mn>
    <mrow><mo>/</mo></mrow> <mn>35</mn></math> . We can summarize the distribution
    of values for the sample proportion into a table, which we call the *sampling
    distribution* of the proportion:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Proportion of failures | No. of samples | Fraction of samples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1/35 <math><mo>≈</mo> <mn>0.03</mn></math> |'
  prefs: []
  type: TYPE_TB
- en: '| 1/3 | 12 | 12/35 <math><mo>≈</mo> <mn>0.34</mn></math> |'
  prefs: []
  type: TYPE_TB
- en: '| 2/3 | 18 | 18/35 <math><mo>≈</mo> <mn>0.51</mn></math> |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 4 | 4/35 <math><mo>≈</mo> <mn>0.11</mn></math> |'
  prefs: []
  type: TYPE_TB
- en: '| Total | 35 | 1 |'
  prefs: []
  type: TYPE_TB
- en: While these calculations are relatively straightforward, we can approximate
    them through a simulation study. To do this, we take samples of three from our
    population over and over—say 10,000 times. For each sample, we calculate the proportion
    of failures. That gives us 10,000 simulated sample proportions. The table of the
    simulated proportions should come close to the sampling distribution. We confirm
    this with a simulation study.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating the Sampling Distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simulation can be a powerful tool to understand complex random processes. In
    our example of seven fuel tanks, we are able to consider all possible samples
    from the corresponding urn model. However, in situations with large populations
    and samples and more complex sampling processes, it may not be tractable to directly
    compute the chance of certain outcomes. In these situations, we often turn to
    simulation to provide accurate estimates of the quantities we can’t compute directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set up the problem of finding the sampling distribution of the proportion
    of failures in a simple random sample of three fuel tanks as an urn model. Since
    we are interested in whether or not the tank fails, we use 1 to indicate a failure
    and 0 to indicate a pass, giving us an urn with marbles labeled as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have encoded the tanks <math><mi>A</mi></math> through <math><mi>G</mi></math>
    using 1 for fail and 0 for pass, so we can take the mean of the sample to get
    the proportion of failures in a sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In a simulation study, we repeat the sampling process thousands of times to
    get thousands of proportions, and then we estimate the sampling distribution of
    the proportion from what we get in our simulation. Here, we construct 10,000 samples
    (and so 10,000 proportions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can study these 10,000 sample proportions and match our findings against
    what we calculated already using the complete enumeration of all 35 possible samples.
    We expect the simulation results to be close to our earlier calculations because
    we have repeated the sampling process many, many times. That is, we want to compare
    the fraction of the 10,000-sample proportion that is 0, <math><mn>1</mn> <mrow><mo>/</mo></mrow>
    <mn>3</mn></math> , <math><mn>2</mn> <mrow><mo>/</mo></mrow> <mn>3</mn></math>
    , and 1 to those we computed exactly; those fractions are <math><mn>1</mn> <mrow><mo>/</mo></mrow>
    <mn>35</mn></math> , <math><mn>12</mn> <mrow><mo>/</mo></mrow> <mn>35</mn></math>
    , <math><mn>18</mn> <mrow><mo>/</mo></mrow> <mn>35</mn></math> , and <math><mn>4</mn>
    <mrow><mo>/</mo></mrow> <mn>35</mn></math> , or about <math><mn>0.03</mn></math>
    , <math><mn>0.34</mn></math> , <math><mn>0.51</mn></math> , and <math><mn>0.11</mn></math>
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Proportion of failures | Fraction of samples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 0.00 | 0.03 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 0.33 | 0.35 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 0.67 | 0.51 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | 1.00 | 0.11 |'
  prefs: []
  type: TYPE_TB
- en: The simulation results are very close to the exact chances that we calculated
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Simulation studies leverage random number generators to sample many outcomes
    from a random process. In a sense, simulation studies convert complex random processes
    into data that we can readily analyze using the broad set of computational tools
    we cover in this book. While simulation studies typically do not provide definitive
    proof of a particular hypothesis, they can provide important evidence. In many
    situations, simulation is the most accurate estimation process we have.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing marbles from an urn with 0s and 1s is such a popular framework for understanding
    randomness that this chance process has been given a formal name, *hypergeometr**ic
    distribution*, and most software provides functionality to rapidly carry out simulations
    of this process. In the next section, we simulate the hypergeometric distribution
    of the fuel tank example.
  prefs: []
  type: TYPE_NORMAL
- en: Simulation with the Hypergeometric Distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using `random.choice`, we can use `numpy`’s `random.hypergeometric`
    to simulate drawing marbles from the urn and counting the number of failures.
    The `random.hypergeometric` method is optimized for the 0-1 urn and allows us
    to ask for 10,000 simulations in one call. For completeness, we repeat our simulation
    study and calculate the empirical proportions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: (We don’t think that a pass is “bad”; it’s just a naming convention to call
    the type you want to count “good” and the other “bad.”)
  prefs: []
  type: TYPE_NORMAL
- en: 'We tally the fraction of the 10,000 samples with 0, 1, 2, or 3 failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Number of failures | Fraction of samples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 0 | 0.03 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1 | 0.34 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 2 | 0.52 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | 3 | 0.11 |'
  prefs: []
  type: TYPE_TB
- en: 'You might have asked yourself already: since the hypergeometric is so popular,
    why not provide the exact distribution of the possible values? In fact, we can
    calculate these exactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Number of failures | Fraction of samples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 0 | 0.03 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1 | 0.34 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 2 | 0.51 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | 3 | 0.11 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Whenever possible, it’s a good idea to use the functionality provided in a third-party
    package for simulating from a named distribution, such as the random number generators
    offered in `numpy`, rather than writing your own function. It’s best to take advantage
    of efficient and accurate code that others have developed. That said, building
    from scratch on occasion can help you gain an understanding of an algorithm, so
    we recommend trying it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the two most common chance processes are those that arise from counting
    the number of 1s drawn from a 0-1 urn: drawing without replacement is the *hypergeometric*
    distribution and drawing with replacement is the *binomial* distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: While this simulation was so simple that we could have used `hypergeom.pmf`
    to directly compute our distribution, we wanted to demonstrate the intuition that
    a simulation study can reveal. The approach we take in this book is to develop
    an understanding of chance processes based on simulation studies. However, we
    do formalize the notion of a probability distribution of a statistic (like the
    proportion of fails in a sample) in [Chapter 17](ch17.html#ch-inf-pred-theory).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have simulation as a tool for understanding accuracy, we can revisit
    the election example from [Chapter 2](ch02.html#ch-data-scope) and carry out a
    post-election study of what might have gone wrong with the voter polls. This simulation
    study imitates drawing more than a thousand marbles (voters who participate in
    the poll) from an urn of six million. We can examine potential sources of bias
    and the variation in the polling results, and we can carry out a what-if analysis
    where we examine how the predictions might have gone if a larger number of draws
    from the urn were taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Simulating Election Poll Bias and Variance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2016, nearly every prediction for the outcome of the US presidential election
    was wrong. This was a historic level of prediction error that shocked the statistics
    and data science communities. Here, we examine why nearly every political poll
    was so confident and yet also so wrong. This story both illustrates the power
    of simulation and reveals the hubris of data and the challenge of bias.
  prefs: []
  type: TYPE_NORMAL
- en: The president of the United States is chosen by the Electoral College, not by
    popular vote. Each state is allotted a certain number of votes to cast in the
    Electoral College according to the size of its population. Typically, whomever
    wins the popular vote in a state receives all of the Electoral College votes for
    that state. With the aid of polls conducted in advance of the election, pundits
    identify “battleground” states where the election is expected to be close and
    the Electoral College votes might swing the election.
  prefs: []
  type: TYPE_NORMAL
- en: In 2016, pollsters correctly predicted the election outcome in 46 of the 50
    states. Not bad! After all, for those 46 states, Donald Trump received 231 and
    Hillary Clinton received 232 Electoral College votes—nearly a tie, with Clinton
    having a very narrow lead. Unfortunately, the remaining four states, Florida,
    Michigan, Pennsylvania, and Wisconsin, were identified as battleground states
    and accounted for a total of 75 votes. The margins of the popular vote in these
    four states were narrow. For example, in Pennsylvania, Trump received 48.18% and
    Clinton received 47.46% of the 6,165,478 votes cast. Such narrow margins can make
    it hard to predict the outcome given the sample sizes that the polls used. But
    there was an even greater challenge hidden in the survey process itself.
  prefs: []
  type: TYPE_NORMAL
- en: Many experts have studied the 2016 election results to dissect and identify
    what went wrong. According to the [American Association for Public Opinion Research](https://oreil.ly/4FWW2),
    one online, opt-in poll adjusted its polling results for the education of the
    respondents but used only three broad categories (high school or less, some college,
    and college graduate). The pollsters found that if they had separated out respondents
    with advanced degrees from those with college degrees, then they would have reduced
    Clinton’s estimated percentage by 0.5 points. In other words, after the fact,
    they were able to identify an education bias where highly educated voters tended
    to be more willing to participate in polls. This bias matters because these voters
    also tended to prefer Clinton over Trump.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how people actually voted, we can carry out a simulation study
    like [Manfred te Grotenhuis et al.’s](https://oreil.ly/hOSC2), which imitates
    election polling under different scenarios to help develop intuition for accuracy,
    bias, and variance.^([1](ch03.html#id743)) We can simulate and compare the polls
    for Pennsylvania under two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: People surveyed didn’t change their minds, didn’t hide who they voted for, and
    were representative of those who voted on election day.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People with a higher education were more likely to respond, which led to a bias
    for Clinton.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our ultimate goal is to understand the frequency with which a poll incorrectly
    calls the election for Hillary Clinton when a sample is collected with absolutely
    no bias and when there is a small amount of nonresponse bias. We begin by setting
    up the urn model for the first scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The Pennsylvania Urn Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our urn model for carrying out a poll of Pennsylvania voters is an after-the-fact
    situation where we use the outcome of the election. The urn has 6,165,478 marbles
    in it, one for each voter. Like with our tiny population, we write on each marble
    the candidate that they voted for, draw 1,500 marbles from the urn (1,500 is a
    typical size for these polls), and tally the votes for Trump, Clinton, and any
    other candidate. From the tally, we can calculate Trump’s lead over Clinton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we care only about Trump’s lead over Clinton, we can lump together all
    votes for other candidates. This way, each marble has one of three possible votes:
    Trump, Clinton, or Other. We can’t ignore the “Other” category, because it impacts
    the size of the lead. Let’s divvy up the voter counts between these three groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of the urn model has three types of marbles in it. It is a bit
    more complex than the hypergeometric distribution, but it is still common enough
    to have a named distribution: the *multivariate hypergeometric*. In Python, the
    urn model with more than two types of marbles is implemented by the `scipy.stats.multivariate_hypergeom.rvs`
    method. The function returns the number of each type of marble drawn from the
    urn. We call the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, each time we call `multivariate_hypergeom.rvs` we get a different
    sample and counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to compute Trump’s lead for each sample: <math><mo stretchy="false">(</mo>
    <msub><mi>n</mi> <mi>T</mi></msub> <mo>−</mo> <msub><mi>n</mi> <mi>C</mi></msub>
    <mo stretchy="false">)</mo> <mrow><mo>/</mo></mrow> <mi>n</mi></math> , where
    <math><msub><mi>n</mi> <mi>T</mi></msub></math> is the number of Trump votes in
    the sample and <math><msub><mi>n</mi> <mi>C</mi></msub></math> the number for
    Clinton. If the lead is positive, then the sample shows a win for Trump.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We know the actual lead was 0.4818 – 0.4746 = 0.0072\. To get a sense of the
    variation in the poll, we can simulate the chance process of drawing from the
    urn over and over and examine the values that we get in return. Now we can simulate
    100,000 polls of 1,500 voters from the votes cast in Pennsylvania:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'On average, the polling results show Trump with close to a 0.7% lead, as expected
    given the composition of the more than six million votes cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, many times the lead in a sample was negative, meaning Clinton was
    the winner for that sample of voters. The following histogram shows the sampling
    distribution of Trump’s advantage in Pennsylvania for a sample of 1,500 voters.
    The vertical dashed line at 0 shows that more often than not, Trump is called,
    but there are many times when the poll of 1,500 shows Clinton in the lead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_03in01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the 100,0000 simulated polls, we find Trump a victor about 60% of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In other words, a sample will correctly predict Trump’s victory *even if the
    sample was collected with absolutely no bias* about 60% of the time. And this
    unbiased sample will be wrong about 40% of the time.
  prefs: []
  type: TYPE_NORMAL
- en: We have used the urn model to study the variation in a simple poll, and we found
    how a poll’s prediction might look if there was no bias in our selection process
    (the marbles are indistinguishable, and every possible collection of 1,500 marbles
    out of the more than six million marbles is equally likely). Next, we see what
    happens when a little bias enters the mix.
  prefs: []
  type: TYPE_NORMAL
- en: An Urn Model with Bias
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to Grotenhuis, “In a perfect world, polls sample from the population
    of voters, who would state their political preference perfectly clearly and then
    vote accordingly.”^([2](ch03.html#id752)) That’s the simulation study that we
    just performed. In reality, it is often difficult to control for every source
    of bias.
  prefs: []
  type: TYPE_NORMAL
- en: 'We investigate here the effect of a small education bias on the polling results.
    Specifically, we examine the impacts of a 0.5% bias in favor of Clinton. This
    bias essentially means that we see a distorted picture of voter preferences in
    our poll. Instead of 47.46% votes for Clinton, we have 47.96%, and we have 48.18
    – 0.5 = 47.68% for Trump. We adjust the proportions of marbles in the urn to reflect
    this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When we carry out the simulation study again, this time with the biased urn,
    we find a quite different result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_03in02.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, Trump would have a positive lead in about 45% of the polls. Notice that
    the histograms from the two simulations are similar in shape. They are symmetric
    with tails of reasonable length. That is, they appear to roughly follow the normal
    curve. The second histogram is shifted slightly to the left, which reflects the
    nonresponse bias we introduced. Would increasing the sample size have helped?
    We investigate this topic next.
  prefs: []
  type: TYPE_NORMAL
- en: Conducting Larger Polls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our simulation study we can gain insight on the impact of a larger poll
    on the sample lead. For example, we can try a sample size of 12,000, eight times
    the size of the actual poll, and run 100,000 simulations for both the unbiased
    and biased scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The simulation shows that Trump’s lead is detected in only about one-third
    of the simulated biased scenario. The spread of the histogram of these results
    is narrower than the spread when only 1,500 voters were polled. Unfortunately,
    it has narrowed in on the wrong value. We haven’t overcome the bias; we just have
    a more accurate picture of the biased situation. Big data has not come to the
    rescue. Additionally, larger polls have other problems. They are often harder
    to conduct because pollsters are working with limited resources, and efforts that
    could go into improving the data scope are being redirected to expanding the poll:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_03in03.png)'
  prefs: []
  type: TYPE_IMG
- en: After the fact, with multiple polls for the same election, we can detect bias.
    In a [post-election analysis](http://dx.doi.org/10.1080/01621459.2018.1448823)
    of over 4,000 polls for 600 state-level, gubernatorial, senatorial, and presidential
    elections, researchers found that, on average, election polls exhibit a bias of
    about 1.5 percentage points, which helps explain why so many polls got it wrong.
  prefs: []
  type: TYPE_NORMAL
- en: When the margin of victory is relatively small, as it was in 2016, a larger
    sample size reduces the sampling error, but unfortunately, if there is bias, then
    the predictions are close to the biased estimate. If the bias pushes the prediction
    from one candidate (Trump) to another (Clinton), then we have a “surprise” upset.
    Pollsters develop voter selection schemes that attempt to reduce bias, like the
    separation of voters’ preference by education level. But, as in this case, it
    can be difficult, even impossible, to account for new, unexpected sources of bias.
    Polls are still useful, but we need to acknowledge the issues with bias and do
    a better job at reducing it.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we used the urn model to study a simple random sample in polling.
    Another common use of the urn is in randomized controlled experiments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Simulating a Randomized Trial for a Vaccine'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a drug trial, volunteers for the trial receive either the new treatment or
    a placebo (a fake treatment), and researchers control the assignment of volunteers
    to the treatment and placebo groups. In a *randomized controlled experiment*,
    they use a chance process to make this assignment. Scientists essentially use
    an urn model to select the subjects for the treatment and control (those given
    the placebo groups). We can simulate the chance mechanism of the urn to better
    understand variation in the outcome of an experiment and the meaning of efficacy
    in clinical trials.
  prefs: []
  type: TYPE_NORMAL
- en: In March 2021, Detroit Mayor Mike Duggan made [national news](https://oreil.ly/kB757)
    when he turned down a shipment of over 6,000 Johnson & Johnson (J&J) vaccine doses,
    stating that the citizens of his city should “get the best.” The mayor was referring
    to the efficacy rate of the vaccine, which was reported to be about 66%. In comparison,
    Moderna and Pfizer both reported efficacy rates of about 95% for their vaccines.
  prefs: []
  type: TYPE_NORMAL
- en: On the surface, Duggan’s reasoning seems valid, but the scopes of the three
    clinical trials are not comparable, meaning direct comparisons of the experimental
    results are problematic. Moreover, the [CDC](https://oreil.ly/25Pok) considers
    a 66% efficacy rate quite good, which is why it was given emergency approval.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the points of scope and efficacy in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that when we evaluate the scope of the data, we consider the who, when,
    and where of the study. For the Johnson & Johnson clinical trial, the participants:'
  prefs: []
  type: TYPE_NORMAL
- en: Included adults age 18 and over, where roughly 40% had preexisting conditions
    associated with an increased risk for getting severe COVID-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enrolled in the study from October to November 2020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Came from eight countries across three continents, including the US and South
    Africa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The participants in the Moderna and Pfizer trials were primarily from the US,
    roughly 40% had preexisting conditions, and the trial took place earlier, over
    summer 2020\. The timing and location of the trials make them difficult to compare.
    Cases of COVID-19 were at a low point in the summer in the US, but they rose rapidly
    in the late fall. Also, a variant of the virus that was more contagious was spreading
    rapidly in South Africa at the time of the J&J trial.
  prefs: []
  type: TYPE_NORMAL
- en: Each clinical trial was designed to test a vaccine against the situation of
    no vaccine under similar circumstances through the random assignment of subjects
    to treatment and control groups. While the scope from one trial to the next is
    quite different, the randomization within a trial keeps the scope of the treatment
    and control groups roughly the same. This enables meaningful comparisons between
    groups in the same trial. The scope was different enough across the three vaccine
    trials to make direct comparisons of the three trials problematic.
  prefs: []
  type: TYPE_NORMAL
- en: In the trial carried out for the [J&J vaccine](https://oreil.ly/epz0T), 43,738
    people were enrolled. These participants were split into two groups at random.
    Half received the new vaccine, and the other half received a placebo, such as
    a saline solution. Then everyone was followed for 28 days to see whether they
    contracted COVID-19.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of information was recorded on each patient, such as their age, race,
    and sex, and in addition whether they caught COVID-19, including the severity
    of the disease. At the end of 28 days, the researchers found 468 cases of COVID-19,
    with 117 of these in the treatment group and 351 in the control group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The random assignment of patients to treatment and control gives the scientists
    a framework to assess the effectiveness of the vaccine. The typical reasoning
    goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin with the assumption that the vaccine is ineffective.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So the 468 who caught COVID-19 would have caught it whether or not they received
    the vaccine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And the remaining 43,270 people in the trial who did not get sick would have
    remained healthy whether or not they received the vaccine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The split of 117 sick people in treatment and 351 in control was solely due
    to the chance process in assigning participants to treatment or control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can set up an urn model that reflects this scenario and then study, via simulation,
    the behavior of the experimental results.
  prefs: []
  type: TYPE_NORMAL
- en: The Urn Model for Random Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our urn has 43,738 marbles, one for each person in the clinical trial. Since
    there were 468 cases of COVID-19 among them, we label 468 marbles with a 1 and
    the remaining 43,270 with a 0\. We draw half the marbles (21,869) from the urn
    to receive the treatment, and the remaining half receive the placebo. The key
    result of the experiment is simply the count of the number of marbles marked 1
    that were randomly drawn from the urn.
  prefs: []
  type: TYPE_NORMAL
- en: We can simulate this process to get a sense of how likely it would be under
    these assumptions to draw at most 117 marbles marked 1 from the urn. Since we
    draw half of the marbles from the urn, we would expect about half of the 468,
    or 234, to be drawn. The simulation study gives us a sense of the variation that
    might result from the random assignment process. That is, the simulation can give
    us an approximate chance that the trials would result in so few cases of the virus
    in the treatment group.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Several key assumptions enter into this urn model, such as the assumption that
    the vaccine is ineffective. It’s important to keep track of the reliance on these
    assumptions because our simulation study gives us an approximation of the rarity
    of an outcome like the one observed only under these key assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we can simulate the urn model using the hypergeometric probability
    distribution, rather than having to program the chance process from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_03in04.png)'
  prefs: []
  type: TYPE_IMG
- en: In our simulation, we repeated the process of random assignment to the treatment
    group 500,000 times. Indeed, we found that not one of the 500,000 simulations
    had 117 or fewer cases. It would be an extremely rare event to see so few cases
    of COVID-19 if in fact the vaccine was not effective.
  prefs: []
  type: TYPE_NORMAL
- en: After the problems with comparing drug trials that have different scopes and
    the efficacy for preventing severe cases of COVID-19 was explained, Mayor Duggan
    retracted his original statement, saying, “I have full confidence that the Johnson
    & Johnson vaccine is both safe and effective.”^([3](ch03.html#id760))
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has shown that:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a chance process in the assignment of subjects to treatments in clinical
    trials can help us answer what-if scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering data scope can help us determine whether it is reasonable to compare
    figures from different datasets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating the draw of marbles from an urn is a useful abstraction for studying
    the possible outcomes from survey samples and controlled experiments. The simulation
    works because it imitates the chance mechanism used to select a sample or to assign
    people to a treatment. In settings where we measure natural phenomena, our measurements
    tend to follow a similar chance process. As described in [Chapter 2](ch02.html#ch-data-scope),
    instruments typically have an error associated with them, and we can use an urn
    to represent the variability in measuring an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Measuring Air Quality'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Across the US, [sensors to measure air pollution are widely used](https://oreil.ly/t6JzZ)
    by individuals, community groups, and state and local air monitoring agencies.
    For example, on two days in September 2020, approximately 600,000 Californians
    and 500,000 Oregonians viewed PurpleAir’s map as fire spread through their states
    and evacuations were planned. ([PurpleAir](https://www2.purpleair.com) creates
    air quality maps from crowdsourced data that streams in from its sensors.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The sensors measure the amount of particulate matter in the air that has a
    diameter smaller than 2.5 micrometers (the unit of measurement is micrograms per
    cubic meter: μg/m³). The measurements recorded are the average concentrations
    over two minutes. While the level of particulate matter changes over the course
    of a day as, for example, people commute to and from work, there are certain times
    of the day, like at midnight, when we expect the two-minute averages to change
    little in a half hour. If we examine the measurements taken during these times
    of the day, we can get a sense of the combined variability in the instrument recordings
    and the mixing of particles in the air.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyone can access sensor measurements from PurpleAir’s site. The site provides
    a download tool, and data are available for any sensor that appears on PurpleAir’s
    map. We downloaded data from one sensor over a 24-hour period and selected three
    half-hour time intervals spread throughout the day where the readings were roughly
    constant over the 30-minute period. This gave us three sets of 15 two-minute averages,
    for a total of 45 measurements:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | aq2.5 | time | hour | meds | diff30 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 6.14 | 2022-04-01 00:01:10 UTC | 0 | 5.38 | 0.59 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 5.00 | 2022-04-01 00:03:10 UTC | 0 | 5.38 | -0.55 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 5.29 | 2022-04-01 00:05:10 UTC | 0 | 5.38 | -0.26 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **42** | 7.55 | 2022-04-01 19:27:20 UTC | 19 | 8.55 | -1.29 |'
  prefs: []
  type: TYPE_TB
- en: '| **43** | 9.47 | 2022-04-01 19:29:20 UTC | 19 | 8.55 | 0.63 |'
  prefs: []
  type: TYPE_TB
- en: '| **44** | 8.55 | 2022-04-01 19:31:20 UTC | 19 | 8.55 | -0.29 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Line plots can give us a sense of variation in the measurements. In one 30-minute
    period, we expect the measurements to be roughly the same, with the exception
    of minor variations from the particles moving in the air and the measurement error
    of the instrument:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_03in05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The plot shows us how the air quality worsens throughout the day, but in each
    of these half-hour intervals, the air quality is roughly constant at 5.4, 6.6,
    and 8.6 μg/m³ at midnight, 11 a.m., and 7 p.m., respectively. We can think of
    the data scope as follows: at this particular location in a specific half-hour
    time interval, there is an average particle concentration in the air surrounding
    the sensor. This concentration is our target, and our instrument, the sensor,
    takes many measurements that form a sample from the access frame. (See [Chapter 2](ch02.html#ch-data-scope)
    for the dartboard analogy of this process.) If the instrument is working properly,
    the measurements are centered on the target: the 30-minute average.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better sense of the variation in a half-hour interval, we can examine
    the differences of the measurements from the median for the corresponding half
    hour. The distribution of these “errors” is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_03in06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The histogram shows us that the typical fluctuations in measurements are often
    less than 0.5 μg/m³ and rarely greater than 1 μg/m³. With instruments, we often
    consider their *relative standard error*, which is the standard deviation as a
    percentage of the mean. The standard deviation of these 45 deviations is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Given that the hourly measurements range from 5 to 9 μg/m³, the relative error
    is 8% to 12%, which is reasonably accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the urn model to simulate the variability in this measurement process.
    We place in the urn the deviations of the measurements from their 30-minute medians
    for all 45 readings, and we simulate a 30-minute air quality sequence of measurements
    by drawing 15 times *with replacement* from the urn and adding the deviations
    drawn to a hypothetical 30-minute average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a line plot for this artificial set of measurements to our earlier
    line plots, and compare it to the three real ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_03in07.png)'
  prefs: []
  type: TYPE_IMG
- en: The shape of the line plot from the simulated data is similar to the others,
    which indicates that our model for the measurement process is reasonable. Unfortunately,
    what we don’t know is whether the measurements are close to the true air quality.
    To detect bias in the instrument, we need to make comparisons against a more accurate
    instrument or take measurements in a protected environment where the air has a
    known quantity of particulate matter. In fact, [researchers](https://oreil.ly/Xkvh0)
    have found that low humidity can distort the readings so that they are too high.
    In [Chapter 12](ch12.html#ch-pa), we carry out a more comprehensive analysis of
    the PurpleAir sensor data and calibrate the instruments to improve their accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used the analogy of drawing marbles from an urn to model
    random sampling from populations and random assignment of subjects to treatments
    in experiments. This framework enables us to run simulation studies for hypothetical
    surveys, experiments, or other chance processes in order to study their behavior.
    We found the chance of observing particular results from a clinical trial under
    the assumption that the treatment was not effective, and we studied the support
    for Clinton and Trump with samples based on actual votes cast in the election.
    These simulation studies enabled us to quantify the typical deviations in the
    chance process and to approximate the distribution of summary statistics, like
    Trump’s lead over Clinton. These simulation studies revealed the sampling distribution
    of a statistic and helped us answer questions about the likelihood of observing
    results like ours under the urn model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The urn model reduces to a few basics: the number of marbles in the urn, what
    is written on each marble, the number of marbles to draw from the urn, and whether
    or not they are replaced between draws. From there, we can simulate increasingly
    complex data designs. However, the crux of the urn’s usefulness is the mapping
    from the data design to the urn. If samples are not randomly drawn, subjects are
    not randomly assigned to treatments, or measurements are not made on well-calibrated
    equipment, then this framework falls short in helping us understand our data and
    make decisions. On the other hand, we also need to remember that the urn is a
    simplification of the actual data collection process. If in reality there is bias
    in data collection, then the randomness we observe in the simulation doesn’t capture
    the complete picture. Too often, data scientists wave these annoyances aside and
    address only the variability described by the urn model. That was one of the main
    problems in the surveys predicting the outcome of the 2016 US presidential election.'
  prefs: []
  type: TYPE_NORMAL
- en: In each of these examples, the summary statistics that we have studied were
    given to us as part of the example. In the next chapter, we address the question
    of how to choose a summary statistic to represent the data.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.html#id743-marker)) Manfred te Grotenhuis et al., “Better Poll Sampling
    Would Have Cast More Doubt on the Potential for Hillary Clinton to Win the 2016
    Election” *London School of Economics*, February 1, 2018.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch03.html#id752-marker)) Grotenhuis et al., “Better Poll Sampling Would
    Have Cast More Doubt on the Potential for Hillary Clinton to Win the 2016 Election.”
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch03.html#id760-marker)) Unfortunately, despite the vaccine’s efficacy,
    the US Food and Drug Administration limited the use of the J&J vaccine in May
    2022 due to a heightened risk of developing rare and potentially life-threatening
    blood clots.
  prefs: []
  type: TYPE_NORMAL
