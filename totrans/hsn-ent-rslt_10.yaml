- en: Chapter 10\. Privacy-Preserving Record Linkage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have seen how to resolve entities via exact and probabilistic
    matching techniques, using both local compute and cloud-based solutions. The first
    step in these matching processes is to assemble the data sources onto a single
    platform for comparison. Where the data sources to be resolved share a common
    owner, or can be freely shared in their entirety for the purposes of matching,
    then centralized processing is the most efficient approach.
  prefs: []
  type: TYPE_NORMAL
- en: However, data sources can often be sensitive, and privacy considerations may
    preclude unrestricted sharing with another party. This chapter considers how privacy-preserving
    record linkage techniques can be used to perform basic entity resolution across
    data sources held separately by two parties. In particular, we will consider private
    set intersection as a practical means to identify entities known to both parties
    without either side disclosing their full dataset to the other.
  prefs: []
  type: TYPE_NORMAL
- en: An Introduction to Private Set Intersection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Private set intersection (PSI) is a cryptographic technique that allows the
    intersection between two overlapping sets of information, held by two different
    parties, to be identified without revealing the nonintersecting elements to either
    counterparty.
  prefs: []
  type: TYPE_NORMAL
- en: For example, as shown in [Figure 10-1](#fig-10-1), the intersection between
    Set A, owned by Alice, and Set B, owned by Bob, can be identified as comprising
    elements 4 and 5 without revealing Bob’s knowledge of entities 6, 7, or 8 to Alice
    or Alice’s knowledge of 1, 2, or 3 to Bob.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Private set intersection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once this intersection is known, we can combine the information held by both
    Alice and Bob about resolved entities 4 and 5 to allow us to make better decisions
    about how to handle these entities. This technique is commonly applied in a single
    direction, say between Alice (acting as a client) and Bob (acting as a server),
    where Alice learns the intersecting elements but Bob learns nothing about Alice’s
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Example Use Case for PSI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A financial institution in a privacy jurisdiction might wish to see whether
    any of its customers are shared with another organization without revealing the
    identity of its customers. The sharing organization is willing to disclose the
    individuals they have in common but is not willing to divulge its full customer
    list.
  prefs: []
  type: TYPE_NORMAL
- en: This is the approach we will examine in this chapter, where the sets of information
    are lists of entities held by both parties, and the client is trying to establish
    whether the server holds information on an entity in their set without revealing
    any of their entities in the process. This perhaps sounds like magic, but bear
    with me!
  prefs: []
  type: TYPE_NORMAL
- en: How PSI Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a client/server setting where the server is happy to share its dataset with
    the client, the simplest solution for the client to discover the intersection
    is simply for the server to send a full copy of its dataset to the client, who
    can then perform the matching process in private. The client learns which matching
    elements are also held by the server and can build a fuller picture of the common
    entities while the server learns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this full disclosure approach is often not possible, either because
    the size of the server dataset exceeds the capacity of the client device or because
    while the server is willing to reveal the existence of, and information describing,
    the intersecting elements it has in common with the client, it is not willing
    or permitted to divulge the entire set.
  prefs: []
  type: TYPE_NORMAL
- en: If full sharing from server to client is not possible, then a commonly proposed
    solution, often referred to as *naive PSI*, is for both parties to apply the same
    mapping function to each of the elements in their datasets. The server then shares
    its transformed values with the client who can compare these processed values
    with their own equivalents to find the intersection and then look up the corresponding
    original element using the matching client reference as a key. A *cryptographic
    hash function* is often used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic Hash Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A cryptographic hash function is a hash algorithm (a map of an arbitrary binary
    string to a binary string of a fixed size). SHA-256 is a commonly used cryptographic
    hash that generates a 256-bit value, known as a digest.
  prefs: []
  type: TYPE_NORMAL
- en: Although efficient, this hash-based approach can potentially be exploited by
    the client to attempt to discover the full server dataset. One possible attack
    is for the client to prepare a comprehensive table of original and transformed
    values, match this inclusive set against all the received server values, and then
    look up the original values in the table, thereby reconstructing the full server
    dataset. When a hash function is used to perform the mapping, this precomputed
    lookup table is called a rainbow table.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we will continue our search for a stronger cryptographic solution.
    Over the years, several different cryptographic techniques have been employed
    to implement PSI solutions. The first class of algorithms used public key cryptography
    to secure the exchange so that only the client could decrypt the matching elements
    and discover the intersection. This approach is highly efficient in the bandwidth
    required between the client and the server but at the expense of longer runtimes
    to compute the intersection.
  prefs: []
  type: TYPE_NORMAL
- en: Generic secure computation circuits have also been applied to the PSI problem,
    as have oblivious transfer techniques. More recently, fully homomorphic encryption
    schemes have been proposed to enable approximate, as well as exact, matching to
    take place.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this book, we will consider the original public key technique,
    proposed by Catherine Meadows in 1986 using the *Elliptic Curve Diffie-Hellman*
    (ECDH) protocol.^([1](ch10.html#id612)) We won’t delve into the details or the
    mathematics behind the encryption and decryption process. If you’d like to understand
    this subject in more detail, I recommend *Learning Digital Identity* by Phillip
    J. Windley (O’Reilly) as a good primer.
  prefs: []
  type: TYPE_NORMAL
- en: PSI Protocol Based on ECDH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic PSI protocol works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The client encrypts its data elements, using a commutative encryption scheme,
    with its secret key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends the server their encrypted elements. This reveals the number
    of distinct elements in the client dataset but nothing else to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server then further encrypts the client-encrypted values, using a new secret
    key unique to this request, and sends these values back to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client then exploits the commutative properties of the encryption scheme
    to allow it to decrypt the all-server elements received from the server, effectively
    removing the original encryption it applied, but leaving the elements encrypted
    by the server secret key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server encrypts all the elements in its dataset using the same scheme and
    secret key created for this request and sends the encrypted values to the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client can then compare the full set of encrypted server elements, received
    at step 5, with the members of its own set, now encrypted only by the server key
    from step 4, to determine the intersection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This protocol is shown in [Figure 10-2](#fig-10-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'In its basic form, this protocol means that the entire server dataset is sent
    to the client, in encrypted form, in response to each client query. This volume
    of data could be prohibitive, in either compute or space requirements. However,
    we can employ encoding techniques to drastically reduce the volume of data we
    have to exchange, at the price of introducing a small percentage of false positives.
    We will consider two techniques: Bloom filters and Golomb-coded sets (GCSs). Simple
    examples to illustrate the encoding process are provided in *Chapter10GCSBloomExamples.ipynb*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. PSI protocol
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Bloom Filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Bloom filters* are a probabilistic data structure that can very efficiently
    store, and allow us to confirm, the presence of a data element in a set. An empty
    Bloom filter is a bit array whose bits are initialized to 0\. To add an item to
    the filter, the data element is processed by a number of hash functions; the output
    of each maps to a bit position in the filter, which is then set to 1.'
  prefs: []
  type: TYPE_NORMAL
- en: To test whether a new data element is in the set, we simply check whether the
    bit positions corresponding to its hashed values are all set to 1\. If they are,
    then the new element is probably already present in the set. I say probably because
    it’s possible that those bits may have been set independently to represent other
    values, resulting in a false positive. What we can be sure of though is that if
    any of the bits are not set to 1, then our new element is not present in the set;
    i.e., there are no false negatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The likelihood of a false positive depends on the length of the filter, the
    number of hash functions, and the number of elements in the dataset. These can
    be optimized as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper B l o o m f i l t e r l e n g t h left-parenthesis b i
    t s right-parenthesis equals left ceiling StartFraction minus m a x normal bar
    e l e m e n t s times log Subscript 2 Baseline left-parenthesis f p r right-parenthesis
    Over 8 times ln 2 EndFraction right ceiling times 8"><mrow><mi>B</mi> <mi>l</mi>
    <mi>o</mi> <mi>o</mi> <mi>m</mi> <mi>f</mi> <mi>i</mi> <mi>l</mi> <mi>t</mi> <mi>e</mi>
    <mi>r</mi> <mi>l</mi> <mi>e</mi> <mi>n</mi> <mi>g</mi> <mi>t</mi> <mi>h</mi> <mrow><mo>(</mo>
    <mi>b</mi> <mi>i</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>⌈</mo>
    <mfrac><mrow><mo>-</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>×</mo><msub><mo
    form="prefix">log</mo> <mn>2</mn></msub> <mrow><mo>(</mo><mi>f</mi><mi>p</mi><mi>r</mi><mo>)</mo></mrow></mrow>
    <mrow><mn>8</mn><mo>×</mo><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac> <mo>⌉</mo></mrow>
    <mo>×</mo> <mn>8</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f p r equals f a l s e p o s i t i v e r a t e"><mrow><mi>f</mi>
    <mi>p</mi> <mi>r</mi> <mo>=</mo> <mi>f</mi> <mi>a</mi> <mi>l</mi> <mi>s</mi> <mi>e</mi>
    <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi> <mi>e</mi>
    <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="m a x normal bar e l e m e n t s equals max left-parenthesis
    n u m normal bar c l i e n t normal bar i n p u t s comma n u m normal bar s e
    r v e r normal bar i n p u t s right-parenthesis"><mrow><mi>m</mi> <mi>a</mi>
    <mi>x</mi> <mo>_</mo> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <mi>t</mi> <mi>s</mi> <mo>=</mo> <mo form="prefix" movablelimits="true">max</mo>
    <mo>(</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>c</mi> <mi>l</mi> <mi>i</mi>
    <mi>e</mi> <mi>n</mi> <mi>t</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi> <mi>p</mi> <mi>u</mi>
    <mi>t</mi> <mi>s</mi> <mo>,</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>s</mi>
    <mi>e</mi> <mi>r</mi> <mi>v</mi> <mi>e</mi> <mi>r</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi>
    <mi>p</mi> <mi>u</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper N u m b e r h a s h f u n c t i o n s equals left ceiling
    minus log Subscript 2 Baseline left-parenthesis f p r right-parenthesis right
    ceiling"><mrow><mi>N</mi> <mi>u</mi> <mi>m</mi> <mi>b</mi> <mi>e</mi> <mi>r</mi>
    <mi>h</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi>
    <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>s</mi> <mo>=</mo> <mo>⌈</mo> <mo>-</mo>
    <msub><mo form="prefix">log</mo> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>f</mi>
    <mi>p</mi> <mi>r</mi> <mo>)</mo></mrow> <mo>⌉</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Using a Bloom filter to encode and return the encrypted server values, as opposed
    to returning the full set of raw encrypted values, allows us to reduce this set
    representation to a practical size the client can handle. The client can then
    apply the same Bloom encoding process to check if any of the elements of its set
    (encrypted by the server) are present in the filter.
  prefs: []
  type: TYPE_NORMAL
- en: Bloom filter example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s progressively build a simple Bloom filter to illustrate the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we incrementally add decimal values 217, 354, and 466 to a Bloom filter
    of length 32 bits using 4 hash iterations. Suppose the hash iteration is calculated
    according to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper H a s h Baseline 1 equals upper S upper H upper A Baseline
    256 left-parenthesis upper E n c r y p t e d v a l u e p r e f i x e d b y 1 right-parenthesis
    percent-sign 32"><mrow><mi>H</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mn>1</mn>
    <mo>=</mo> <mi>S</mi> <mi>H</mi> <mi>A</mi> <mn>256</mn> <mo>(</mo> <mi>E</mi>
    <mi>n</mi> <mi>c</mi> <mi>r</mi> <mi>y</mi> <mi>p</mi> <mi>t</mi> <mi>e</mi> <mi>d</mi>
    <mi>v</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mi>p</mi> <mi>r</mi> <mi>e</mi>
    <mi>f</mi> <mi>i</mi> <mi>x</mi> <mi>e</mi> <mi>d</mi> <mi>b</mi> <mi>y</mi> <mn>1</mn>
    <mo>)</mo> <mo>%</mo> <mn>32</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper H a s h Baseline 2 equals upper S upper H upper A Baseline
    256 left-parenthesis upper E n c r y p t e d v a l u e p r e f i x e d b y 2 right-parenthesis
    percent-sign 32"><mrow><mi>H</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mn>2</mn>
    <mo>=</mo> <mi>S</mi> <mi>H</mi> <mi>A</mi> <mn>256</mn> <mo>(</mo> <mi>E</mi>
    <mi>n</mi> <mi>c</mi> <mi>r</mi> <mi>y</mi> <mi>p</mi> <mi>t</mi> <mi>e</mi> <mi>d</mi>
    <mi>v</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mi>p</mi> <mi>r</mi> <mi>e</mi>
    <mi>f</mi> <mi>i</mi> <mi>x</mi> <mi>e</mi> <mi>d</mi> <mi>b</mi> <mi>y</mi> <mn>2</mn>
    <mo>)</mo> <mo>%</mo> <mn>32</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper H a s h upper V a l u e equals left-parenthesis upper H
    a s h Baseline 1 plus upper I t e r a t i o n n u m b e r times upper H a s h
    Baseline 2 right-parenthesis percent-sign 32"><mrow><mi>H</mi> <mi>a</mi> <mi>s</mi>
    <mi>h</mi> <mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mo>=</mo> <mo>(</mo>
    <mi>H</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mn>1</mn> <mo>+</mo> <mi>I</mi> <mi>t</mi>
    <mi>e</mi> <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>n</mi>
    <mi>u</mi> <mi>m</mi> <mi>b</mi> <mi>e</mi> <mi>r</mi> <mo>×</mo> <mi>H</mi> <mi>a</mi>
    <mi>s</mi> <mi>h</mi> <mn>2</mn> <mo>)</mo> <mo>%</mo> <mn>32</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: then we progressively build the Bloom filter in [Table 10-1](#table-10-1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1\. Bloom filter example
  prefs: []
  type: TYPE_NORMAL
- en: '| Encrypted value | Hash iteration | Hash value (Range'
  prefs: []
  type: TYPE_NORMAL
- en: 0-31) | Bloom filter (Positions 0–31, right to left) |
  prefs: []
  type: TYPE_NORMAL
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Empty filter | 00000000000000000000000000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 217 | 0 | 24 | 0000000**1**000000000000000000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 19 | 000000010000**1**0000000000000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | ***14*** | 00000001000010000**1**00000000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 9 | 0000000100001000010000**1**000000000 |'
  prefs: []
  type: TYPE_TB
- en: '| 354 | 0 | 5 | 00000001000010000100001000**1**00000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 4 | 000000010000100001000010001**1**0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 3 | 0000000100001000010000100011**1**000 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2 | 00000001000010000100001000111**1**00 |'
  prefs: []
  type: TYPE_TB
- en: '| 466 | 0 | ***14*** | 00000001000010000**1**00001000111100 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 18 | 0000000100001**1**000100001000111100 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 22 | 000000010**1**0011000100001000111100 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 26 | 00000**1**01010011000100001000111100 |'
  prefs: []
  type: TYPE_TB
- en: '| Completed filter | 00000101010011000100001000111100 |'
  prefs: []
  type: TYPE_TB
- en: Here we can see a collision where the first hash iteration of the third value
    sets the bit in position 14 to 1, although it’s already been set to 1 previously
    by the third iteration of the first value.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if all the bit positions corresponding to the hash iterations for
    a new value were already set to 1, then it would appear that element was in the
    dataset when in fact it wasn’t. For example, if we want to test if the value decimal
    14 is in the server dataset, we compute its hash values as shown in [Table 10-2](#table-10-2).
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2\. Bloom filter test
  prefs: []
  type: TYPE_NORMAL
- en: '| Test value | Hash iteration | Hash value (Range'
  prefs: []
  type: TYPE_NORMAL
- en: 0–31) | Bloom filter (Positions 0–31, right to left) | Bit check |
  prefs: []
  type: TYPE_NORMAL
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Bloom filter | 00000**1**010**1**0011000**1**00001000111**1**00 |   |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 0 | 22 | 000000000**1**0000000000000000000000 | True |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 | 00000000000000000000000000000**1**00 | True |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *14* | 00000000000000000**1**00000000000000 | True |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 26 | 00000**1**00000000000000000000000000 | True |'
  prefs: []
  type: TYPE_TB
- en: From this simple example, we would erroneously conclude that the value 14 is
    in the server data when it isn’t. Clearly, a longer Bloom filter length is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Golomb-Coded Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Golomb-coded sets* (GCS), like Bloom filters, are a probabilistic data structure
    that can offer an even more efficient way of encoding the presence of elements
    in a dataset. To construct a GCS representation of a dataset, we first hash the
    original data elements into a set of hash values within a set range.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hash range is calculated as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction upper H a s h r a n g e equals m a x normal bar
    e l e m e n t s Over f p r EndFraction"><mfrac><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi></mrow>
    <mrow><mi>f</mi><mi>p</mi><mi>r</mi></mrow></mfrac></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'As before:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="f p r equals f a l s e p o s i t i v e r a t e"><mrow><mi>f</mi>
    <mi>p</mi> <mi>r</mi> <mo>=</mo> <mi>f</mi> <mi>a</mi> <mi>l</mi> <mi>s</mi> <mi>e</mi>
    <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi> <mi>e</mi>
    <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="m a x normal bar e l e m e n t s equals max left-parenthesis
    n u m normal bar c l i e n t normal bar i n p u t s comma n u m normal bar s e
    r v e r normal bar i n p u t s right-parenthesis"><mrow><mi>m</mi> <mi>a</mi>
    <mi>x</mi> <mo>_</mo> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <mi>t</mi> <mi>s</mi> <mo>=</mo> <mo form="prefix" movablelimits="true">max</mo>
    <mo>(</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>c</mi> <mi>l</mi> <mi>i</mi>
    <mi>e</mi> <mi>n</mi> <mi>t</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi> <mi>p</mi> <mi>u</mi>
    <mi>t</mi> <mi>s</mi> <mo>,</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>s</mi>
    <mi>e</mi> <mi>r</mi> <mi>v</mi> <mi>e</mi> <mi>r</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi>
    <mi>p</mi> <mi>u</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'We then sort these hash values in ascending order and calculate a divisor that
    represents the geometric range of values. If this divisor is chosen to be a power
    of 2, then this variant is called Rice encoding and can be calculated from the
    ascending list as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper G upper C upper S normal bar d i v i s o r normal bar p
    o w e r normal bar o f normal bar 2 equals max left-parenthesis 0 comma r o u
    n d left-parenthesis minus l o g 2 left-parenthesis minus l o g 2 left-parenthesis
    1.0 minus p r o b right-parenthesis right-parenthesis right-parenthesis"><mrow><mi>G</mi>
    <mi>C</mi> <mi>S</mi> <mo>_</mo> <mi>d</mi> <mi>i</mi> <mi>v</mi> <mi>i</mi> <mi>s</mi>
    <mi>o</mi> <mi>r</mi> <mo>_</mo> <mi>p</mi> <mi>o</mi> <mi>w</mi> <mi>e</mi> <mi>r</mi>
    <mo>_</mo> <mi>o</mi> <mi>f</mi> <mo>_</mo> <mn>2</mn> <mo>=</mo> <mo form="prefix"
    movablelimits="true">max</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>r</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mrow><mo>(</mo> <mo>-</mo> <mi>l</mi> <mi>o</mi>
    <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mo>-</mo> <mi>l</mi> <mi>o</mi>
    <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn>
    <mo>-</mo> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="p r o b equals StartFraction 1 Over a v g EndFraction"><mrow><mi>p</mi>
    <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="a v g equals StartFraction left-parenthesis l a s t normal bar
    e l e m e n t normal bar i n normal bar a s c e n d i n g normal bar l i s t plus
    1 right-parenthesis Over n u m b e r normal bar e l e m e n t s normal bar i n
    normal bar a s c e n d i n g normal bar l i s t EndFraction"><mrow><mi>a</mi>
    <mi>v</mi> <mi>g</mi> <mo>=</mo> <mfrac><mrow><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>_</mo><mi>i</mi><mi>n</mi><mo>_</mo><mi>a</mi><mi>s</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>_</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>_</mo><mi>i</mi><mi>n</mi><mo>_</mo><mi>a</mi><mi>s</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>_</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compute the differences between consecutive values, removing any 0-value
    differences, and divide these delta hash values by 2 to the power of the GCS divisor
    previously calculated. This division yields a quotient and a remainder. To complete
    the encoding, we represent the quotient using unary coding and the remainder in
    binary, padded to the maximum length using 0s.
  prefs: []
  type: TYPE_NORMAL
- en: Each element is encoded in this manner and the bits concatenated together to
    form the GCS structure. To check for a given element in the structure, we scan
    through the bits, reconstructing each element in turn from the unary quotient
    and binary remainder, and then progressively sum the difference values we obtain
    to reconstruct the original hashed values, which we can compare against the hash
    of our test value.
  prefs: []
  type: TYPE_NORMAL
- en: As with Bloom filters, there is a possibility of a false positive due to a hash
    collision, the probability of which depends on the size of the hash range and
    number of elements to be encoded. Again, false negatives aren’t possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a short example.
  prefs: []
  type: TYPE_NORMAL
- en: GCS example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start with the same encrypted values 217, 354, and 466 and a hash range of decimal
    128\. We calculate the SHA256 hash for these values (as bytes) and then divide
    by the hash range to obtain a remainder between 0 and 127. This gives us the values
    shown in [Table 10-4](#table-10-4).
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-4\. GCS hash value calculation
  prefs: []
  type: TYPE_NORMAL
- en: '| Encrypted value | SHA256 hash of encrypted value (hex) | Hash value range
    0-127 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 217 | 16badfc6202cb3f8889e0f2779b19218af4cbb736e56acadce8148aba9a7a9f8 |
    120 |'
  prefs: []
  type: TYPE_TB
- en: '| 354 | 09a1b036b82baba3177d83c27c1f7d0beacaac6de1c5fdcc9680c49f638c5fb9 |
    57 |'
  prefs: []
  type: TYPE_TB
- en: '| 466 | 826e27285307a923759de350de081d6218a04f4cff82b20c5ddaa8c60138c066 |
    102 |'
  prefs: []
  type: TYPE_TB
- en: Sorting the reduced-range hash values into ascending order we have 57, 102,
    and 120\. The delta values are therefore 57 (57–0), 45 (102–57), and 18 (120–102).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our divisor power we calculate as:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="a v g equals StartFraction 120 plus 1 Over 3 EndFraction almost-equals
    40.33"><mrow><mi>a</mi> <mi>v</mi> <mi>g</mi> <mo>=</mo> <mfrac><mrow><mn>120</mn><mo>+</mo><mn>1</mn></mrow>
    <mn>3</mn></mfrac> <mo>≈</mo> <mn>40</mn> <mo>.</mo> <mn>33</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="p r o b equals StartFraction 1 Over 40.33 EndFraction almost-equals
    0.02479"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>=</mo> <mfrac><mn>1</mn>
    <mrow><mn>40</mn><mo>.</mo><mn>33</mn></mrow></mfrac> <mo>≈</mo> <mn>0</mn> <mo>.</mo>
    <mn>02479</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper G upper C upper S normal bar d i v i s o r normal bar p
    o w e r normal bar o f normal bar 2 equals max left-parenthesis 0 comma r o u
    n d left-parenthesis minus l o g 2 left-parenthesis minus l o g 2 left-parenthesis
    1.0 minus 0.02479 right-parenthesis right-parenthesis right-parenthesis equals
    5"><mrow><mi>G</mi> <mi>C</mi> <mi>S</mi> <mo>_</mo> <mi>d</mi> <mi>i</mi> <mi>v</mi>
    <mi>i</mi> <mi>s</mi> <mi>o</mi> <mi>r</mi> <mo>_</mo> <mi>p</mi> <mi>o</mi> <mi>w</mi>
    <mi>e</mi> <mi>r</mi> <mo>_</mo> <mi>o</mi> <mi>f</mi> <mo>_</mo> <mn>2</mn> <mo>=</mo>
    <mo form="prefix" movablelimits="true">max</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo>
    <mi>r</mi> <mi>o</mi> <mi>u</mi> <mi>n</mi> <mi>d</mi> <mrow><mo>(</mo> <mo>-</mo>
    <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mo>-</mo>
    <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mn>1</mn>
    <mo>.</mo> <mn>0</mn> <mo>-</mo> <mn>0</mn> <mo>.</mo> <mn>02479</mn> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Using a divisor parameter of 32 ( <math alttext="2 Superscript 5"><msup><mn>2</mn>
    <mn>5</mn></msup></math> ), we can encode these values as shown in [Table 10-5](#table-10-5).
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-5\. GCS binary and unary encoding
  prefs: []
  type: TYPE_NORMAL
- en: '| Delta hash value'
  prefs: []
  type: TYPE_NORMAL
- en: range 0–127 | Quotient (/32) | Remainder (%32) | Remainder (binary 5 bits) |
    Unary quotient (R to L with 0s) | GCS encoded |
  prefs: []
  type: TYPE_NORMAL
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 57 | 1  | 25 | 11001 | 10 | 1100110 |'
  prefs: []
  type: TYPE_TB
- en: '| 45 | 1 | 13 | 01101 | 10 | 0110110 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 0 | 18 | 10010 | 1 | 100101 |'
  prefs: []
  type: TYPE_TB
- en: 'Together, last to first, left to right, the set is encoded as: 10010101101101100110.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Using the PSI Process'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand the basic PSI process, let’s apply it to the challenge
    of identifying the companies present in the list published by the UK MCA and also
    present in the Companies House register. If we consider the MCA as the client
    party and Companies House as the server party, then we can examine how to find
    those MCA companies that are present on the Companies House register without revealing
    the contents of the MCA list to Companies House.
  prefs: []
  type: TYPE_NORMAL
- en: '*Please note that this example is for illustration purposes only.*'
  prefs: []
  type: TYPE_NORMAL
- en: Environment Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the PSI process is computationally intensive, we will use Google Cloud to
    temporarily provide us with the infrastructure to run this example.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html#chapter_6), we standardized the MCA and Companies House
    register datasets and saved them as standardized and cleansed CSV files. In [Chapter 7](ch07.html#chapter_7),
    we uploaded these files onto a Google Cloud Storage bucket. For the purposes of
    this chapter, we will imagine that these datasets are held by two separate parties.
  prefs: []
  type: TYPE_NORMAL
- en: We will transfer these files to a single data science workbench instance on
    GCP upon which we will run both the server and client to illustrate the intersection
    process. This example can be easily extended to run on two different machines
    to illustrate the distinct server and client roles and the separation of data.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin, we select Workbench from the AI Platform menu on the Google Cloud
    console. To create the environment we select User-Managed Notebooks (as opposed
    to Managed Notebook) as this option will allow us to install the packages we need.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to select Create New. From here we can rename the notebook
    to a name of our choice. Under the Environment section, select the basic Python3
    option, then click Create. As in [Chapter 7](ch07.html#chapter_7), you can change
    the region and zone settings if you wish or accept the defaults. If (optionally)
    you select “IAM and security,” you’ll note that root access to the virtual machine
    will be granted.
  prefs: []
  type: TYPE_NORMAL
- en: Costs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be aware that once you create a new Workbench environment, you begin to incur
    costs, both when the instance is running and disk space costs even when the instance
    is stopped. By default the Workbench instance creates 2 × 100 GB disks!
  prefs: []
  type: TYPE_NORMAL
- en: '*It is your responsibility to ensure that the instance is stopped and/or deleted
    to avoid incurring unexpected costs.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once your instance is created, you’ll be able to click Open JupyterLab to open
    a local window to a JupyterLab environment hosted on your new GCP Workbench.^([2](ch10.html#id626))
    From here, we can select Terminal under Other to open a terminal window to configure
    our environment.
  prefs: []
  type: TYPE_NORMAL
- en: The PSI package we are going to use is released and distributed by the OpenMined
    community.
  prefs: []
  type: TYPE_NORMAL
- en: OpenMined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenMined is an open source community whose goal is to make the world more privacy
    preserving by lowering the barrier-to-entry to private AI technologies. Their
    PSI repository provides a Private Set Intersection Cardinality protocol based
    on ECDH and Bloom filters.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the OpenMined PSI package is available [online](https://oreil.ly/XaKJs).
    From this site we can download a prebuilt distribution compatible with a Google
    Cloud Workbench (currently an x86 64-bit virtual machine running Debian 11 OS)
    that we can readily install (option 1). Alternatively, if you prefer to use a
    different environment or build the package yourself, you can (option 2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: Prebuilt PSI package'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a PSI directory and switch into this location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the link address for the compatible Python distribution and use wget to
    download. Currently, this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Option 2: Build PSI package'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the terminal prompt we clone the repository for the OpenMined psi package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next switch into the psi directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the psi package from the repository source we need to install the
    appropriate version of the build package, Bazel. Use wget to acquire the appropriate
    prebuilt Debian release package from the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Install this package as root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we use Bazel to build the Python distribution, a wheel file, with the
    necessary dependencies. This step may take a few moments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have built the wheel archive, then we can use a Python utility provided
    by OpenMined to rename the file to reflect the environment it supports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The rename utility will output the path and name of the renamed file. We now
    need to install this newly renamed package from the provided path, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, this installation may take a few moments but once it’s complete we have
    the building blocks we need to execute a PSI on our sample problem data.
  prefs: []
  type: TYPE_NORMAL
- en: Server install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once our psi package is installed, one more thing we will need is a basic client/server
    framework to handle the matching requests. For this purpose we use the Flask lightweight
    microframework that we can install using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this install is complete, we can navigate up from the psi directory so
    that we can copy across our example files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the flask server and run the `Chapter10Server` Python script, we use
    the following at a terminal tab prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The server will take a few moments to start as it reads in the Companies House
    dataset and assembles the entities into a list of concatenated `CompanyName` and
    `Postcode` strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is ready to process requests, it will display the following at the
    command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Server Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the server code by opening the Python file *Chapter10Server.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We start by importing the PSI package we installed and then the `flask` and
    `pandas` functions we need.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set the desired false positive rate (`fpr`) and the number of client
    inputs we will check in each request. Together these parameters are used to calculate
    the length of the Bloom filter and hash range used in GCS encoding.
  prefs: []
  type: TYPE_NORMAL
- en: We then read in the cleansed Companies House records that we transferred from
    our Cloud Storage bucket earlier, specifying that we ignore null values. We then
    create a list of server items by concatenating each of the `CompanyName` and `Postcode`
    values together, separated by a space. This allows us to check for an exact name
    and postcode match per entity.
  prefs: []
  type: TYPE_NORMAL
- en: To allow us to examine the encoding protocols in detail using a more manageable
    server set, I’ve selected two entities from the MCA list and manually created
    their cleansed name and postcode strings as an alternative set of server items.
    *To use the full Companies House dataset instead, just remove the comment marker
    (leading `#`) from the list creation statement to override the `server_items`:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainder of the server file defines a class to hold the server key and
    then creates the `key` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Flask web application allows us to respond to both GET and POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server responds to a POST request to the `/match` path by creating a new
    server key and a `psirequest` object. We then parse the data within the POST request,
    process (i.e., encrypt) the received data using the new key and then serialize
    these processed values before returning them to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After a match request has been processed, the server can then respond to client
    GET requests for the different encoding schemes: raw encrypted values, Bloom filter,
    and GCS. In each case, we reuse the key created during the match request and we
    supply the desired false positive rate and number of items in each client request
    so that we can configure the Bloom and GCS options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Client Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The notebook containing the client code is *Chapter10Client.ipynb*, beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As with the server setup, we read in the cleansed MCA company details, create
    a client key, encrypt, and then serialize for transmission to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to serialization, the first few lines of the `psirequest` look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the serialized encrypted values as message content in a POST request
    to the `/match` URL path, indicating in the header that the content we are passing
    is a protobuf structure. The server response, containing the server-encrypted
    versions of the client encrypted values, is then parsed into a `response` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using raw encrypted server values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To retrieve the raw encrypted server values, the client sends a request to
    the `/rawsetup` URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have selected to use just the two test entries in the server setup file,
    then we can expect only two encrypted elements in the setup response. The values
    will depend on the server key, but the structure will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then calculate the intersection from the server values in the `rawsetup`
    structure and the `client` values in the `psiresponse` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the list index of the matching entities, in this simple case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then look up the corresponding client entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Success! We have resolved these entities between the client and server records, exact-matching
    `CompanyName` and `Postcode` attributes, without revealing the client items to
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bloom filter–encoded encrypted server values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s examine how we would use a Bloom filter to encode the set of server
    encrypted values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we submit a request via the `/bloomsetup` path, we get an output that looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The server calculates the number of bits in the filter according to the formula
    in the Bloom filters section. We can re-create this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The false positive rate is set at 1 in 100 per query with a batch size of 100
    client items to check at a time, giving an overall (corrected) fpr of 0.0001\.
    For our very basic example, `max_elements` is also equal to 100\. This gives us
    a Bloom filter bit length of 1920:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This gives us 14 hash functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reproduce the Bloom filter by processing the raw encrypted server elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can compare our filter against the filter bits returned by the server
    when assembled in the same order and converted to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Using GCS-encoded encrypted server values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let’s examine how we would use GCS to encode the set of server-encrypted
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we submit a request via the `/gcssetup` path, we get an output that looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To reproduce these values, we can apply the formulas in the preceding PSI section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the hash range of 1000000.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Bloom filter, we can reproduce the GCS structure by processing the
    raw encrypted server elements. First, we hash the raw encrypted server values
    into the `gcs_hash_range`, sort in ascending order, and calculate the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can calculate the GCS divisor as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us a divisor of 17, which we can then use to calculate the quotient
    and remainder before we encode these in unary and binary, respectively. We concatenate
    these bit patterns together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we pad out the encoded string to be a multiple of 8 so that we can
    match against the returned GCS bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Full MCA and Companies House Sample Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen the end-to-end PSI entity matching process using a tiny
    server dataset of only two items, we’re ready to use the full Companies House
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the *Chapter10Server.py* file and uncomment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'and then stop (Ctrl+C or Cmd-C) and restart the Flask server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now we can restart the client kernel and rerun the notebook to get the full
    intersection between the MCA and Companies House data, resolving the entities
    on `CompanyName` and `Postcode`.
  prefs: []
  type: TYPE_NORMAL
- en: We can request either a raw, Bloom, or GCS response. Allow approximately 10
    minutes for the server to process and return. *I suggest you skip over the steps
    to reproduce the Bloom/GCS structures as these could take quite a while*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jumping to calculate the intersection then gives us 45 exact matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Tidy Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember to stop and delete your User-Managed Notebook and any associated disks
    to avoid ongoing charges!
  prefs: []
  type: TYPE_NORMAL
- en: This PSI example has shown how we can resolve entities between two parties even
    if one party cannot share their data with the other. In this basic example, we
    have been able to look for simultaneous exact matches on only two attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In certain situations, exact matching may be sufficient. However, when approximate
    matching is needed, and at least one party is prepared to share partial matches,
    we need a more sophisticated approach that is beyond the scope of this book. There
    is ongoing research into the practicality of using fully homomorphic encryption
    to enable privacy-preserving fuzzy matching, which would open up a wider field
    of potential use cases for this technique.^([3](ch10.html#id637))
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned how to use Private Set Intersection to resolve entities
    between two parties without either party revealing their full dataset. We saw
    how to use compressed data representations to reduce the volume of data we needed
    to pass between the two parties at the price of introducing a small percentage
    of false positives.
  prefs: []
  type: TYPE_NORMAL
- en: We noted that these techniques can be readily applied to exact matching scenarios
    but that more advanced approximate or probabilistic matching remains a challenge
    and a subject of active research.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch10.html#id612-marker)) Meadows, Catherine, “A More Efficient Cryptographic
    Matchmaking Protocol for Use in the Absence of a Continuously Available Third
    Party,” *1986 IEEE Symposium on Security and Privacy*, Oakland, CA, USA, 1986,
    pp. 134, *https://doi.org/10.1109/SP.1986.10022*.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch10.html#id626-marker)) You may need to allow pop-ups on your local browser.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch10.html#id637-marker)) See the patent “Compact fuzzy private matching
    using a fully-homomorphic encryption scheme,” [*https://patents.google.com/patent/US20160119119*](https://patents.google.com/patent/US20160119119).
  prefs: []
  type: TYPE_NORMAL
