- en: Chapter 10\. Privacy-Preserving Record Linkage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章\. 隐私保护记录链接
- en: In previous chapters, we have seen how to resolve entities via exact and probabilistic
    matching techniques, using both local compute and cloud-based solutions. The first
    step in these matching processes is to assemble the data sources onto a single
    platform for comparison. Where the data sources to be resolved share a common
    owner, or can be freely shared in their entirety for the purposes of matching,
    then centralized processing is the most efficient approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经看到如何通过精确匹配和概率匹配技术解析实体，既使用本地计算又使用基于云的解决方案。这些匹配过程的第一步是将数据源汇集到一个平台上进行比较。当需要解析的数据源由一个共同的所有者拥有，或者可以完全共享以进行匹配，那么集中处理是最有效的方法。
- en: However, data sources can often be sensitive, and privacy considerations may
    preclude unrestricted sharing with another party. This chapter considers how privacy-preserving
    record linkage techniques can be used to perform basic entity resolution across
    data sources held separately by two parties. In particular, we will consider private
    set intersection as a practical means to identify entities known to both parties
    without either side disclosing their full dataset to the other.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据源往往可能是敏感的，隐私考虑可能阻止与另一方的无限制共享。本章考虑了如何使用隐私保护的记录链接技术，在两个独立持有数据源的各方之间执行基本的实体解析。特别是，我们将考虑私有集合交集作为识别双方已知实体的实际手段，而不会向任一方透露其完整数据集。
- en: An Introduction to Private Set Intersection
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有集合交集简介
- en: Private set intersection (PSI) is a cryptographic technique that allows the
    intersection between two overlapping sets of information, held by two different
    parties, to be identified without revealing the nonintersecting elements to either
    counterparty.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 私有集合交集（PSI）是一种加密技术，允许识别由两个不同方持有的重叠信息集合之间的交集，而不向任何一方透露非交集元素。
- en: For example, as shown in [Figure 10-1](#fig-10-1), the intersection between
    Set A, owned by Alice, and Set B, owned by Bob, can be identified as comprising
    elements 4 and 5 without revealing Bob’s knowledge of entities 6, 7, or 8 to Alice
    or Alice’s knowledge of 1, 2, or 3 to Bob.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如图 [10-1](#fig-10-1) 所示，Alice 拥有的集合 A 和 Bob 拥有的集合 B 的交集可以被确定为由元素 4 和 5 组成，而不会向
    Alice 透露 Bob 对实体 6、7 或 8 的了解，或向 Bob 透露 Alice 对 1、2 或 3 的了解。
- en: '![](assets/hoer_1001.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_1001.png)'
- en: Figure 10-1\. Private set intersection
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. 私有集合交集
- en: Once this intersection is known, we can combine the information held by both
    Alice and Bob about resolved entities 4 and 5 to allow us to make better decisions
    about how to handle these entities. This technique is commonly applied in a single
    direction, say between Alice (acting as a client) and Bob (acting as a server),
    where Alice learns the intersecting elements but Bob learns nothing about Alice’s
    dataset.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了这个交集，我们可以结合 Alice 和 Bob 关于解析实体 4 和 5 的信息，以便更好地决定如何处理这些实体。这种技术通常在单一方向上应用，比如
    Alice（作为客户端）和 Bob（作为服务器），Alice 了解交集元素，但 Bob 不了解 Alice 的数据集。
- en: Example Use Case for PSI
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSI 的示例用例
- en: A financial institution in a privacy jurisdiction might wish to see whether
    any of its customers are shared with another organization without revealing the
    identity of its customers. The sharing organization is willing to disclose the
    individuals they have in common but is not willing to divulge its full customer
    list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐私法域中的金融机构可能希望查看其客户是否与另一组织共享，而不透露其客户的身份。分享组织愿意透露他们共同拥有的个体，但不愿透露其完整的客户名单。
- en: This is the approach we will examine in this chapter, where the sets of information
    are lists of entities held by both parties, and the client is trying to establish
    whether the server holds information on an entity in their set without revealing
    any of their entities in the process. This perhaps sounds like magic, but bear
    with me!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章将要讨论的方法，其中信息集是由双方持有的实体列表，客户端试图确定服务器是否持有其集合中实体的信息，而在此过程中不会透露任何自己的实体。这听起来可能像是魔术，但请跟我一起来！
- en: How PSI Works
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PSI 的工作原理
- en: In a client/server setting where the server is happy to share its dataset with
    the client, the simplest solution for the client to discover the intersection
    is simply for the server to send a full copy of its dataset to the client, who
    can then perform the matching process in private. The client learns which matching
    elements are also held by the server and can build a fuller picture of the common
    entities while the server learns nothing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器愿意与客户端共享其数据集的客户端/服务器设置中，客户端发现交集的最简单解决方案是让服务器向客户端发送其数据集的完整副本，然后客户端可以在私下执行匹配过程。客户端了解哪些匹配元素也由服务器持有，并且可以构建更完整的共同实体图片，而服务器则不知情。
- en: In practice, this full disclosure approach is often not possible, either because
    the size of the server dataset exceeds the capacity of the client device or because
    while the server is willing to reveal the existence of, and information describing,
    the intersecting elements it has in common with the client, it is not willing
    or permitted to divulge the entire set.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这种完全披露的方法通常是不可能的，要么是因为服务器数据集的大小超过了客户端设备的容量，要么是因为虽然服务器愿意透露与客户端共有的交集元素的存在和信息描述，但不愿意或不允许透露整个集合。
- en: If full sharing from server to client is not possible, then a commonly proposed
    solution, often referred to as *naive PSI*, is for both parties to apply the same
    mapping function to each of the elements in their datasets. The server then shares
    its transformed values with the client who can compare these processed values
    with their own equivalents to find the intersection and then look up the corresponding
    original element using the matching client reference as a key. A *cryptographic
    hash function* is often used for this purpose.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器无法完全与客户端共享数据，那么一个常见的解决方案通常被提议，通常称为*朴素PSI*，即双方对其数据集中的每个元素应用相同的映射函数。然后服务器将其转换后的值与客户端共享，客户端可以将这些处理过的值与自己的相等值进行比较，以找到交集，然后使用匹配的客户端参考作为键查找相应的原始元素。*密码哈希函数*经常用于此目的。
- en: Cryptographic Hash Functions
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码哈希函数
- en: A cryptographic hash function is a hash algorithm (a map of an arbitrary binary
    string to a binary string of a fixed size). SHA-256 is a commonly used cryptographic
    hash that generates a 256-bit value, known as a digest.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希函数是一种哈希算法（将任意二进制字符串映射到固定大小的二进制字符串）。SHA-256是一种常用的密码哈希函数，生成一个256位的值，称为摘要。
- en: Although efficient, this hash-based approach can potentially be exploited by
    the client to attempt to discover the full server dataset. One possible attack
    is for the client to prepare a comprehensive table of original and transformed
    values, match this inclusive set against all the received server values, and then
    look up the original values in the table, thereby reconstructing the full server
    dataset. When a hash function is used to perform the mapping, this precomputed
    lookup table is called a rainbow table.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然高效，但基于哈希的这种方法潜在地可以被客户端利用来尝试发现完整的服务器数据集。一个可能的攻击是客户端准备一个包含原始值和转换值的综合表，将此全面集合与所有接收到的服务器值进行匹配，然后在表中查找原始值，从而重建完整的服务器数据集。当使用哈希函数执行映射时，这种预先计算的查找表被称为彩虹表。
- en: For this reason, we will continue our search for a stronger cryptographic solution.
    Over the years, several different cryptographic techniques have been employed
    to implement PSI solutions. The first class of algorithms used public key cryptography
    to secure the exchange so that only the client could decrypt the matching elements
    and discover the intersection. This approach is highly efficient in the bandwidth
    required between the client and the server but at the expense of longer runtimes
    to compute the intersection.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，出于这个原因，我们将继续寻找更强的密码解决方案。多年来，已经采用了几种不同的密码技术来实现PSI解决方案。第一类算法使用公钥加密来保护交换，以便只有客户端能够解密匹配元素并发现交集。这种方法在客户端和服务器之间所需的带宽效率非常高，但计算交集的运行时间较长。
- en: Generic secure computation circuits have also been applied to the PSI problem,
    as have oblivious transfer techniques. More recently, fully homomorphic encryption
    schemes have been proposed to enable approximate, as well as exact, matching to
    take place.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通用安全计算电路也已应用于PSI问题，无意识传输技术也是如此。最近，完全同态加密方案被提出，以实现近似和精确匹配。
- en: For the purposes of this book, we will consider the original public key technique,
    proposed by Catherine Meadows in 1986 using the *Elliptic Curve Diffie-Hellman*
    (ECDH) protocol.^([1](ch10.html#id612)) We won’t delve into the details or the
    mathematics behind the encryption and decryption process. If you’d like to understand
    this subject in more detail, I recommend *Learning Digital Identity* by Phillip
    J. Windley (O’Reilly) as a good primer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的目的，我们将考虑由 Catherine Meadows 在 1986 年提出的原始公钥技术，使用 *椭圆曲线 Diffie-Hellman*（ECDH）协议。^([1](ch10.html#id612))
    我们不会深入探讨加密和解密过程的细节或数学。如果您想更详细地了解这个主题，我推荐阅读 Phillip J. Windley 的 *Learning Digital
    Identity*（O’Reilly）作为一个很好的入门书。
- en: PSI Protocol Based on ECDH
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 ECDH 的 PSI 协议
- en: 'The basic PSI protocol works like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 PSI 协议工作方式如下：
- en: The client encrypts its data elements, using a commutative encryption scheme,
    with its secret key.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端使用可交换的加密方案和自己的秘钥对数据元素进行加密。
- en: The client sends the server their encrypted elements. This reveals the number
    of distinct elements in the client dataset but nothing else to the server.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将它们的加密元素发送给服务器。这向服务器透露了客户端数据集中不同元素的数量，但不透露其他任何信息。
- en: The server then further encrypts the client-encrypted values, using a new secret
    key unique to this request, and sends these values back to the client.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后服务器进一步使用新的与此请求唯一的秘钥对客户端加密的值进行加密，并将这些值发送回客户端。
- en: The client then exploits the commutative properties of the encryption scheme
    to allow it to decrypt the all-server elements received from the server, effectively
    removing the original encryption it applied, but leaving the elements encrypted
    by the server secret key.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后客户端利用加密方案的可交换属性，允许其解密从服务器接收的所有服务器元素，有效地去除其应用的原始加密，但保留服务器秘钥加密的元素。
- en: The server encrypts all the elements in its dataset using the same scheme and
    secret key created for this request and sends the encrypted values to the client.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器使用为此请求创建的相同方案和秘钥加密其数据集中的所有元素，并将加密值发送给客户端。
- en: The client can then compare the full set of encrypted server elements, received
    at step 5, with the members of its own set, now encrypted only by the server key
    from step 4, to determine the intersection.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后客户端可以比较在第 5 步接收到的完整的服务器加密元素与自己的集合成员，现在仅由第 4 步的服务器秘钥加密，以确定交集。
- en: This protocol is shown in [Figure 10-2](#fig-10-2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此协议显示在 [Figure 10-2](#fig-10-2) 中。
- en: 'In its basic form, this protocol means that the entire server dataset is sent
    to the client, in encrypted form, in response to each client query. This volume
    of data could be prohibitive, in either compute or space requirements. However,
    we can employ encoding techniques to drastically reduce the volume of data we
    have to exchange, at the price of introducing a small percentage of false positives.
    We will consider two techniques: Bloom filters and Golomb-coded sets (GCSs). Simple
    examples to illustrate the encoding process are provided in *Chapter10GCSBloomExamples.ipynb*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在其基本形式中，此协议意味着对于每个客户端查询，整个服务器数据集以加密形式发送给客户端。这些数据量可能是禁止的，无论是计算还是空间需求。但是，我们可以使用编码技术大幅减少我们需要交换的数据量，以较小的误报率为代价。我们将考虑两种技术：Bloom
    filters 和 Golomb-coded sets (GCSs)。提供了用于说明编码过程的简单示例 *Chapter10GCSBloomExamples.ipynb*。
- en: '![](assets/hoer_1002.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hoer_1002.png)'
- en: Figure 10-2\. PSI protocol
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 10-2\. PSI 协议
- en: Bloom Filters
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布隆过滤器
- en: '*Bloom filters* are a probabilistic data structure that can very efficiently
    store, and allow us to confirm, the presence of a data element in a set. An empty
    Bloom filter is a bit array whose bits are initialized to 0\. To add an item to
    the filter, the data element is processed by a number of hash functions; the output
    of each maps to a bit position in the filter, which is then set to 1.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bloom filters* 是一种能够非常高效地存储和确认数据元素是否存在于集合中的概率数据结构。一个空的 Bloom 过滤器是一个位数组，其位被初始化为
    0。要向过滤器添加项目，需要通过多个哈希函数处理数据元素；每个哈希函数的输出映射到过滤器中的一个位位置，然后将该位置设置为 1。'
- en: To test whether a new data element is in the set, we simply check whether the
    bit positions corresponding to its hashed values are all set to 1\. If they are,
    then the new element is probably already present in the set. I say probably because
    it’s possible that those bits may have been set independently to represent other
    values, resulting in a false positive. What we can be sure of though is that if
    any of the bits are not set to 1, then our new element is not present in the set;
    i.e., there are no false negatives.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试新数据元素是否在集合中，我们只需检查其哈希值所对应的位位置是否全部设为1。如果是，则新元素可能已经存在于集合中。我说“可能”，因为这些位可能独立设置来表示其他值，导致假阳性。但可以确定的是，如果任何位不是设为1，则我们的新元素不在集合中；即，没有假阴性。
- en: 'The likelihood of a false positive depends on the length of the filter, the
    number of hash functions, and the number of elements in the dataset. These can
    be optimized as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假阳性的可能性取决于过滤器的长度、哈希函数的数量以及数据集中的元素数量。可以优化如下：
- en: <math alttext="upper B l o o m f i l t e r l e n g t h left-parenthesis b i
    t s right-parenthesis equals left ceiling StartFraction minus m a x normal bar
    e l e m e n t s times log Subscript 2 Baseline left-parenthesis f p r right-parenthesis
    Over 8 times ln 2 EndFraction right ceiling times 8"><mrow><mi>B</mi> <mi>l</mi>
    <mi>o</mi> <mi>o</mi> <mi>m</mi> <mi>f</mi> <mi>i</mi> <mi>l</mi> <mi>t</mi> <mi>e</mi>
    <mi>r</mi> <mi>l</mi> <mi>e</mi> <mi>n</mi> <mi>g</mi> <mi>t</mi> <mi>h</mi> <mrow><mo>(</mo>
    <mi>b</mi> <mi>i</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>⌈</mo>
    <mfrac><mrow><mo>-</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>×</mo><msub><mo
    form="prefix">log</mo> <mn>2</mn></msub> <mrow><mo>(</mo><mi>f</mi><mi>p</mi><mi>r</mi><mo>)</mo></mrow></mrow>
    <mrow><mn>8</mn><mo>×</mo><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac> <mo>⌉</mo></mrow>
    <mo>×</mo> <mn>8</mn></mrow></math>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper B l o o m f i l t e r l e n g t h left-parenthesis b i
    t s right-parenthesis equals left ceiling StartFraction minus m a x normal bar
    e l e m e n t s times log Subscript 2 Baseline left-parenthesis f p r right-parenthesis
    Over 8 times ln 2 EndFraction right ceiling times 8"><mrow><mi>B</mi> <mi>l</mi>
    <mi>o</mi> <mi>o</mi> <mi>m</mi> <mi>f</mi> <mi>i</mi> <mi>l</mi> <mi>t</mi> <mi>e</mi>
    <mi>r</mi> <mi>l</mi> <mi>e</mi> <mi>n</mi> <mi>g</mi> <mi>t</mi> <mi>h</mi> <mrow><mo>(</mo>
    <mi>b</mi> <mi>i</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>⌈</mo>
    <mfrac><mrow><mo>-</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>×</mo><msub><mo
    form="prefix">log</mo> <mn>2</mn></msub> <mrow><mo>(</mo><mi>f</mi><mi>p</mi><mi>r</mi><mo>)</mo></mrow></mrow>
    <mrow><mn>8</mn><mo>×</mo><mo form="prefix">ln</mo><mn>2</mn></mrow></mfrac> <mo>⌉</mo></mrow>
    <mo>×</mo> <mn>8</mn></mrow></math>
- en: where
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: <math alttext="f p r equals f a l s e p o s i t i v e r a t e"><mrow><mi>f</mi>
    <mi>p</mi> <mi>r</mi> <mo>=</mo> <mi>f</mi> <mi>a</mi> <mi>l</mi> <mi>s</mi> <mi>e</mi>
    <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi> <mi>e</mi>
    <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi></mrow></math>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f p r equals f a l s e p o s i t i v e r a t e"><mrow><mi>f</mi>
    <mi>p</mi> <mi>r</mi> <mo>=</mo> <mi>f</mi> <mi>a</mi> <mi>l</mi> <mi>s</mi> <mi>e</mi>
    <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi> <mi>e</mi>
    <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi></mrow></math>
- en: <math alttext="m a x normal bar e l e m e n t s equals max left-parenthesis
    n u m normal bar c l i e n t normal bar i n p u t s comma n u m normal bar s e
    r v e r normal bar i n p u t s right-parenthesis"><mrow><mi>m</mi> <mi>a</mi>
    <mi>x</mi> <mo>_</mo> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <mi>t</mi> <mi>s</mi> <mo>=</mo> <mo form="prefix" movablelimits="true">max</mo>
    <mo>(</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>c</mi> <mi>l</mi> <mi>i</mi>
    <mi>e</mi> <mi>n</mi> <mi>t</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi> <mi>p</mi> <mi>u</mi>
    <mi>t</mi> <mi>s</mi> <mo>,</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>s</mi>
    <mi>e</mi> <mi>r</mi> <mi>v</mi> <mi>e</mi> <mi>r</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi>
    <mi>p</mi> <mi>u</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo></mrow></math>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="m a x normal bar e l e m e n t s equals max left-parenthesis
    n u m normal bar c l i e n t normal bar i n p u t s comma n u m normal bar s e
    r v e r normal bar i n p u t s right-parenthesis"><mrow><mi>m</mi> <mi>a</mi>
    <mi>x</mi> <mo>_</mo> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <mi>t</mi> <mi>s</mi> <mo>=</mo> <mo form="prefix" movablelimits="true">max</mo>
    <mo>(</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>c</mi> <mi>l</mi> <mi>i</mi>
    <mi>e</mi> <mi>n</mi> <mi>t</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi> <mi>p</mi> <mi>u</mi>
    <mi>t</mi> <mi>s</mi> <mo>,</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>s</mi>
    <mi>e</mi> <mi>r</mi> <mi>v</mi> <mi>e</mi> <mi>r</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi>
    <mi>p</mi> <mi>u</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo></mrow></math>
- en: and
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: <math alttext="upper N u m b e r h a s h f u n c t i o n s equals left ceiling
    minus log Subscript 2 Baseline left-parenthesis f p r right-parenthesis right
    ceiling"><mrow><mi>N</mi> <mi>u</mi> <mi>m</mi> <mi>b</mi> <mi>e</mi> <mi>r</mi>
    <mi>h</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi>
    <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>s</mi> <mo>=</mo> <mo>⌈</mo> <mo>-</mo>
    <msub><mo form="prefix">log</mo> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>f</mi>
    <mi>p</mi> <mi>r</mi> <mo>)</mo></mrow> <mo>⌉</mo></mrow></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper N u m b e r h a s h f u n c t i o n s equals left ceiling
    minus log Subscript 2 Baseline left-parenthesis f p r right-parenthesis right
    ceiling"><mrow><mi>N</mi> <mi>u</mi> <mi>m</mi> <mi>b</mi> <mi>e</mi> <mi>r</mi>
    <mi>h</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mi>f</mi> <mi>u</mi> <mi>n</mi> <mi>c</mi>
    <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>s</mi> <mo>=</mo> <mo>⌈</mo> <mo>-</mo>
    <msub><mo form="prefix">log</mo> <mn>2</mn></msub> <mrow><mo>(</mo> <mi>f</mi>
    <mi>p</mi> <mi>r</mi> <mo>)</mo></mrow> <mo>⌉</mo></mrow></math>
- en: Using a Bloom filter to encode and return the encrypted server values, as opposed
    to returning the full set of raw encrypted values, allows us to reduce this set
    representation to a practical size the client can handle. The client can then
    apply the same Bloom encoding process to check if any of the elements of its set
    (encrypted by the server) are present in the filter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布隆过滤器来编码并返回加密服务器值，而不是返回完整的原始加密值集合，使得客户端可以将这些集合中的元素应用相同的布隆编码过程来检查是否存在。
- en: Bloom filter example
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布隆过滤器示例
- en: Let’s progressively build a simple Bloom filter to illustrate the process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步构建一个简单的布隆过滤器来说明这个过程。
- en: 'Say we incrementally add decimal values 217, 354, and 466 to a Bloom filter
    of length 32 bits using 4 hash iterations. Suppose the hash iteration is calculated
    according to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们逐步向长度为 32 位的布隆过滤器中使用 4 次哈希迭代添加十进制值 217、354 和 466。假设哈希迭代按照以下方式计算：
- en: <math alttext="upper H a s h Baseline 1 equals upper S upper H upper A Baseline
    256 left-parenthesis upper E n c r y p t e d v a l u e p r e f i x e d b y 1 right-parenthesis
    percent-sign 32"><mrow><mi>H</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mn>1</mn>
    <mo>=</mo> <mi>S</mi> <mi>H</mi> <mi>A</mi> <mn>256</mn> <mo>(</mo> <mi>E</mi>
    <mi>n</mi> <mi>c</mi> <mi>r</mi> <mi>y</mi> <mi>p</mi> <mi>t</mi> <mi>e</mi> <mi>d</mi>
    <mi>v</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mi>p</mi> <mi>r</mi> <mi>e</mi>
    <mi>f</mi> <mi>i</mi> <mi>x</mi> <mi>e</mi> <mi>d</mi> <mi>b</mi> <mi>y</mi> <mn>1</mn>
    <mo>)</mo> <mo>%</mo> <mn>32</mn></mrow></math>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper H a s h Baseline 1 equals upper S upper H upper A Baseline
    256 left-parenthesis upper E n c r y p t e d v a l u e p r e f i x e d b y 1 right-parenthesis
    percent-sign 32"><mrow><mi>H</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mn>1</mn>
    <mo>=</mo> <mi>S</mi> <mi>H</mi> <mi>A</mi> <mn>256</mn> <mo>(</mo> <mi>E</mi>
    <mi>n</mi> <mi>c</mi> <mi>r</mi> <mi>y</mi> <mi>p</mi> <mi>t</mi> <mi>e</mi> <mi>d</mi>
    <mi>v</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mi>p</mi> <mi>r</mi> <mi>e</mi>
    <mi>f</mi> <mi>i</mi> <mi>x</mi> <mi>e</mi> <mi>d</mi> <mi>b</mi> <mi>y</mi> <mn>1</mn>
    <mo>)</mo> <mo>%</mo> <mn>32</mn></mrow></math>
- en: <math alttext="upper H a s h Baseline 2 equals upper S upper H upper A Baseline
    256 left-parenthesis upper E n c r y p t e d v a l u e p r e f i x e d b y 2 right-parenthesis
    percent-sign 32"><mrow><mi>H</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mn>2</mn>
    <mo>=</mo> <mi>S</mi> <mi>H</mi> <mi>A</mi> <mn>256</mn> <mo>(</mo> <mi>E</mi>
    <mi>n</mi> <mi>c</mi> <mi>r</mi> <mi>y</mi> <mi>p</mi> <mi>t</mi> <mi>e</mi> <mi>d</mi>
    <mi>v</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mi>p</mi> <mi>r</mi> <mi>e</mi>
    <mi>f</mi> <mi>i</mi> <mi>x</mi> <mi>e</mi> <mi>d</mi> <mi>b</mi> <mi>y</mi> <mn>2</mn>
    <mo>)</mo> <mo>%</mo> <mn>32</mn></mrow></math>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper H a s h Baseline 2 equals upper S upper H upper A Baseline
    256 left-parenthesis upper E n c r y p t e d v a l u e p r e f i x e d b y 2 right-parenthesis
    percent-sign 32"><mrow><mi>H</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mn>2</mn>
    <mo>=</mo> <mi>S</mi> <mi>H</mi> <mi>A</mi> <mn>256</mn> <mo>(</mo> <mi>E</mi>
    <mi>n</mi> <mi>c</mi> <mi>r</mi> <mi>y</mi> <mi>p</mi> <mi>t</mi> <mi>e</mi> <mi>d</mi>
    <mi>v</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mi>p</mi> <mi>r</mi> <mi>e</mi>
    <mi>f</mi> <mi>i</mi> <mi>x</mi> <mi>e</mi> <mi>d</mi> <mi>b</mi> <mi>y</mi> <mn>2</mn>
    <mo>)</mo> <mo>%</mo> <mn>32</mn></mrow></math>
- en: and
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: <math alttext="upper H a s h upper V a l u e equals left-parenthesis upper H
    a s h Baseline 1 plus upper I t e r a t i o n n u m b e r times upper H a s h
    Baseline 2 right-parenthesis percent-sign 32"><mrow><mi>H</mi> <mi>a</mi> <mi>s</mi>
    <mi>h</mi> <mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mo>=</mo> <mo>(</mo>
    <mi>H</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mn>1</mn> <mo>+</mo> <mi>I</mi> <mi>t</mi>
    <mi>e</mi> <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>n</mi>
    <mi>u</mi> <mi>m</mi> <mi>b</mi> <mi>e</mi> <mi>r</mi> <mo>×</mo> <mi>H</mi> <mi>a</mi>
    <mi>s</mi> <mi>h</mi> <mn>2</mn> <mo>)</mo> <mo>%</mo> <mn>32</mn></mrow></math>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper H a s h upper V a l u e equals left-parenthesis upper H
    a s h Baseline 1 plus upper I t e r a t i o n n u m b e r times upper H a s h
    Baseline 2 right-parenthesis percent-sign 32"><mrow><mi>H</mi> <mi>a</mi> <mi>s</mi>
    <mi>h</mi> <mi>V</mi> <mi>a</mi> <mi>l</mi> <mi>u</mi> <mi>e</mi> <mo>=</mo> <mo>(</mo>
    <mi>H</mi> <mi>a</mi> <mi>s</mi> <mi>h</mi> <mn>1</mn> <mo>+</mo> <mi>I</mi> <mi>t</mi>
    <mi>e</mi> <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>i</mi> <mi>o</mi> <mi>n</mi> <mi>n</mi>
    <mi>u</mi> <mi>m</mi> <mi>b</mi> <mi>e</mi> <mi>r</mi> <mo>×</mo> <mi>H</mi> <mi>a</mi>
    <mi>s</mi> <mi>h</mi> <mn>2</mn> <mo>)</mo> <mo>%</mo> <mn>32</mn></mrow></math>
- en: then we progressively build the Bloom filter in [Table 10-1](#table-10-1).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们逐步在[表 10-1](#table-10-1)中构建布隆过滤器。
- en: Table 10-1\. Bloom filter example
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1\. 布隆过滤器示例
- en: '| Encrypted value | Hash iteration | Hash value (Range'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '| 加密值 | 哈希迭代 | 哈希值（范围'
- en: 0-31) | Bloom filter (Positions 0–31, right to left) |
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 0-31) | 布隆过滤器（位置 0–31，从右到左） |
- en: '| --- | --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Empty filter | 00000000000000000000000000000000 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 空过滤器 | 00000000000000000000000000000000 |'
- en: '| 217 | 0 | 24 | 0000000**1**000000000000000000000000 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 217 | 0 | 24 | 0000000**1**000000000000000000000000 |'
- en: '| 1 | 19 | 000000010000**1**0000000000000000000 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 19 | 000000010000**1**0000000000000000000 |'
- en: '| 2 | ***14*** | 00000001000010000**1**00000000000000 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 2 | ***14*** | 00000001000010000**1**00000000000000 |'
- en: '| 3 | 9 | 0000000100001000010000**1**000000000 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 9 | 0000000100001000010000**1**000000000 |'
- en: '| 354 | 0 | 5 | 00000001000010000100001000**1**00000 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 354 | 0 | 5 | 00000001000010000100001000**1**00000 |'
- en: '| 1 | 4 | 000000010000100001000010001**1**0000 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 4 | 000000010000100001000010001**1**0000 |'
- en: '| 2 | 3 | 0000000100001000010000100011**1**000 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 3 | 0000000100001000010000100011**1**000 |'
- en: '| 3 | 2 | 00000001000010000100001000111**1**00 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2 | 00000001000010000100001000111**1**00 |'
- en: '| 466 | 0 | ***14*** | 00000001000010000**1**00001000111100 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 466 | 0 | ***14*** | 00000001000010000**1**00001000111100 |'
- en: '| 1 | 18 | 0000000100001**1**000100001000111100 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 18 | 0000000100001**1**000100001000111100 |'
- en: '| 2 | 22 | 000000010**1**0011000100001000111100 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 22 | 000000010**1**0011000100001000111100 |'
- en: '| 3 | 26 | 00000**1**01010011000100001000111100 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 26 | 00000**1**01010011000100001000111100 |'
- en: '| Completed filter | 00000101010011000100001000111100 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 完成的过滤器 | 00000101010011000100001000111100 |'
- en: Here we can see a collision where the first hash iteration of the third value
    sets the bit in position 14 to 1, although it’s already been set to 1 previously
    by the third iteration of the first value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以看到一种碰撞，即第三个值的第一个哈希迭代将位置 14 的位设置为1，尽管它已经被第一个值的第三次迭代先前设置为1。
- en: Similarly, if all the bit positions corresponding to the hash iterations for
    a new value were already set to 1, then it would appear that element was in the
    dataset when in fact it wasn’t. For example, if we want to test if the value decimal
    14 is in the server dataset, we compute its hash values as shown in [Table 10-2](#table-10-2).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果对于新值的哈希迭代所对应的所有位位置已经设为1，则会误以为元素已经存在于数据集中，而实际上并非如此。例如，如果我们想测试值十进制 14 是否在服务器数据集中，我们计算其哈希值如[表
    10-2](#table-10-2)所示。
- en: Table 10-2\. Bloom filter test
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-2\. 布隆过滤器测试
- en: '| Test value | Hash iteration | Hash value (Range'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '| 测试值 | 哈希迭代 | 哈希值（范围'
- en: 0–31) | Bloom filter (Positions 0–31, right to left) | Bit check |
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 0–31) | 布隆过滤器（位置0–31，从右到左） | 位检查 |
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Bloom filter | 00000**1**010**1**0011000**1**00001000111**1**00 |   |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 布隆过滤器 | 00000**1**010**1**0011000**1**00001000111**1**00 |   |'
- en: '| 14 | 0 | 22 | 000000000**1**0000000000000000000000 | True |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 0 | 22 | 000000000**1**0000000000000000000000 | True |'
- en: '| 1 | 2 | 00000000000000000000000000000**1**00 | True |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 2 | 00000000000000000000000000000**1**00 | True |'
- en: '| 2 | *14* | 00000000000000000**1**00000000000000 | True |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *14* | 00000000000000000**1**00000000000000 | True |'
- en: '| 3 | 26 | 00000**1**00000000000000000000000000 | True |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 26 | 00000**1**00000000000000000000000000 | True |'
- en: From this simple example, we would erroneously conclude that the value 14 is
    in the server data when it isn’t. Clearly, a longer Bloom filter length is needed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个简单的例子中，我们错误地得出结论，即服务器数据中存在值14，实际并非如此。显然，需要更长的布隆过滤器长度。
- en: Golomb-Coded Sets
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Golomb编码集
- en: '*Golomb-coded sets* (GCS), like Bloom filters, are a probabilistic data structure
    that can offer an even more efficient way of encoding the presence of elements
    in a dataset. To construct a GCS representation of a dataset, we first hash the
    original data elements into a set of hash values within a set range.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*Golomb编码集*（GCS），像布隆过滤器一样，是一种能够提供数据集中元素存在更高效方式的概率性数据结构。为了构建数据集的GCS表示，我们首先将原始数据元素哈希成一组在设定范围内的哈希值。'
- en: 'The hash range is calculated as:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希范围计算如下：
- en: <math alttext="StartFraction upper H a s h r a n g e equals m a x normal bar
    e l e m e n t s Over f p r EndFraction"><mfrac><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi></mrow>
    <mrow><mi>f</mi><mi>p</mi><mi>r</mi></mrow></mfrac></math>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="StartFraction upper H a s h r a n g e equals m a x normal bar
    e l e m e n t s Over f p r EndFraction"><mfrac><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi></mrow>
    <mrow><mi>f</mi><mi>p</mi><mi>r</mi></mrow></mfrac></math>
- en: 'As before:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样：
- en: <math alttext="f p r equals f a l s e p o s i t i v e r a t e"><mrow><mi>f</mi>
    <mi>p</mi> <mi>r</mi> <mo>=</mo> <mi>f</mi> <mi>a</mi> <mi>l</mi> <mi>s</mi> <mi>e</mi>
    <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi> <mi>e</mi>
    <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi></mrow></math>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="f p r equals f a l s e p o s i t i v e r a t e"><mrow><mi>f</mi>
    <mi>p</mi> <mi>r</mi> <mo>=</mo> <mi>f</mi> <mi>a</mi> <mi>l</mi> <mi>s</mi> <mi>e</mi>
    <mi>p</mi> <mi>o</mi> <mi>s</mi> <mi>i</mi> <mi>t</mi> <mi>i</mi> <mi>v</mi> <mi>e</mi>
    <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi></mrow></math>
- en: <math alttext="m a x normal bar e l e m e n t s equals max left-parenthesis
    n u m normal bar c l i e n t normal bar i n p u t s comma n u m normal bar s e
    r v e r normal bar i n p u t s right-parenthesis"><mrow><mi>m</mi> <mi>a</mi>
    <mi>x</mi> <mo>_</mo> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <mi>t</mi> <mi>s</mi> <mo>=</mo> <mo form="prefix" movablelimits="true">max</mo>
    <mo>(</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>c</mi> <mi>l</mi> <mi>i</mi>
    <mi>e</mi> <mi>n</mi> <mi>t</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi> <mi>p</mi> <mi>u</mi>
    <mi>t</mi> <mi>s</mi> <mo>,</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>s</mi>
    <mi>e</mi> <mi>r</mi> <mi>v</mi> <mi>e</mi> <mi>r</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi>
    <mi>p</mi> <mi>u</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo></mrow></math>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="m a x normal bar e l e m e n t s equals max left-parenthesis
    n u m normal bar c l i e n t normal bar i n p u t s comma n u m normal bar s e
    r v e r normal bar i n p u t s right-parenthesis"><mrow><mi>m</mi> <mi>a</mi>
    <mi>x</mi> <mo>_</mo> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>m</mi> <mi>e</mi> <mi>n</mi>
    <mi>t</mi> <mi>s</mi> <mo>=</mo> <mo form="prefix" movablelimits="true">max</mo>
    <mo>(</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>c</mi> <mi>l</mi> <mi>i</mi>
    <mi>e</mi> <mi>n</mi> <mi>t</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi> <mi>p</mi> <mi>u</mi>
    <mi>t</mi> <mi>s</mi> <mo>,</mo> <mi>n</mi> <mi>u</mi> <mi>m</mi> <mo>_</mo> <mi>s</mi>
    <mi>e</mi> <mi>r</mi> <mi>v</mi> <mi>e</mi> <mi>r</mi> <mo>_</mo> <mi>i</mi> <mi>n</mi>
    <mi>p</mi> <mi>u</mi> <mi>t</mi> <mi>s</mi> <mo>)</mo></mrow></math>
- en: 'We then sort these hash values in ascending order and calculate a divisor that
    represents the geometric range of values. If this divisor is chosen to be a power
    of 2, then this variant is called Rice encoding and can be calculated from the
    ascending list as:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按升序排序这些哈希数值并计算代表几何值范围的除数。如果选择的除数是2的幂，则称此变体为Rice编码，并可从升序列表计算如下：
- en: <math alttext="upper G upper C upper S normal bar d i v i s o r normal bar p
    o w e r normal bar o f normal bar 2 equals max left-parenthesis 0 comma r o u
    n d left-parenthesis minus l o g 2 left-parenthesis minus l o g 2 left-parenthesis
    1.0 minus p r o b right-parenthesis right-parenthesis right-parenthesis"><mrow><mi>G</mi>
    <mi>C</mi> <mi>S</mi> <mo>_</mo> <mi>d</mi> <mi>i</mi> <mi>v</mi> <mi>i</mi> <mi>s</mi>
    <mi>o</mi> <mi>r</mi> <mo>_</mo> <mi>p</mi> <mi>o</mi> <mi>w</mi> <mi>e</mi> <mi>r</mi>
    <mo>_</mo> <mi>o</mi> <mi>f</mi> <mo>_</mo> <mn>2</mn> <mo>=</mo> <mo form="prefix"
    movablelimits="true">max</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>r</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mrow><mo>(</mo> <mo>-</mo> <mi>l</mi> <mi>o</mi>
    <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mo>-</mo> <mi>l</mi> <mi>o</mi>
    <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn>
    <mo>-</mo> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>)</mo></mrow></mrow></math>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper G upper C upper S normal bar d i v i s o r normal bar p
    o w e r normal bar o f normal bar 2 equals max left-parenthesis 0 comma r o u
    n d left-parenthesis minus l o g 2 left-parenthesis minus l o g 2 left-parenthesis
    1.0 minus p r o b right-parenthesis right-parenthesis right-parenthesis"><mrow><mi>G</mi>
    <mi>C</mi> <mi>S</mi> <mo>_</mo> <mi>d</mi> <mi>i</mi> <mi>v</mi> <mi>i</mi> <mi>s</mi>
    <mi>o</mi> <mi>r</mi> <mo>_</mo> <mi>p</mi> <mi>o</mi> <mi>w</mi> <mi>e</mi> <mi>r</mi>
    <mo>_</mo> <mi>o</mi> <mi>f</mi> <mo>_</mo> <mn>2</mn> <mo>=</mo> <mo form="prefix"
    movablelimits="true">max</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo> <mi>r</mi> <mi>o</mi>
    <mi>u</mi> <mi>n</mi> <mi>d</mi> <mrow><mo>(</mo> <mo>-</mo> <mi>l</mi> <mi>o</mi>
    <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mo>-</mo> <mi>l</mi> <mi>o</mi>
    <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mn>1</mn> <mo>.</mo> <mn>0</mn>
    <mo>-</mo> <mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>)</mo></mrow></mrow></math>
- en: where
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: <math alttext="p r o b equals StartFraction 1 Over a v g EndFraction"><mrow><mi>p</mi>
    <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></mfrac></mrow></math>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p r o b equals StartFraction 1 Over a v g EndFraction"><mrow><mi>p</mi>
    <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>=</mo> <mfrac><mn>1</mn> <mrow><mi>a</mi><mi>v</mi><mi>g</mi></mrow></mfrac></mrow></math>
- en: <math alttext="a v g equals StartFraction left-parenthesis l a s t normal bar
    e l e m e n t normal bar i n normal bar a s c e n d i n g normal bar l i s t plus
    1 right-parenthesis Over n u m b e r normal bar e l e m e n t s normal bar i n
    normal bar a s c e n d i n g normal bar l i s t EndFraction"><mrow><mi>a</mi>
    <mi>v</mi> <mi>g</mi> <mo>=</mo> <mfrac><mrow><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>_</mo><mi>i</mi><mi>n</mi><mo>_</mo><mi>a</mi><mi>s</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>_</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>_</mo><mi>i</mi><mi>n</mi><mo>_</mo><mi>a</mi><mi>s</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>_</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow></mfrac></mrow></math>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="a v g equals StartFraction left-parenthesis l a s t normal bar
    e l e m e n t normal bar i n normal bar a s c e n d i n g normal bar l i s t plus
    1 right-parenthesis Over n u m b e r normal bar e l e m e n t s normal bar i n
    normal bar a s c e n d i n g normal bar l i s t EndFraction"><mrow><mi>a</mi>
    <mi>v</mi> <mi>g</mi> <mo>=</mo> <mfrac><mrow><mo>(</mo><mi>l</mi><mi>a</mi><mi>s</mi><mi>t</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>_</mo><mi>i</mi><mi>n</mi><mo>_</mo><mi>a</mi><mi>s</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>_</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>+</mo><mn>1</mn><mo>)</mo></mrow>
    <mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo>_</mo><mi>e</mi><mi>l</mi><mi>e</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>s</mi><mo>_</mo><mi>i</mi><mi>n</mi><mo>_</mo><mi>a</mi><mi>s</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>_</mo><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow></mfrac></mrow></math>
- en: Next, we compute the differences between consecutive values, removing any 0-value
    differences, and divide these delta hash values by 2 to the power of the GCS divisor
    previously calculated. This division yields a quotient and a remainder. To complete
    the encoding, we represent the quotient using unary coding and the remainder in
    binary, padded to the maximum length using 0s.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算连续值之间的差异，移除任何值为0的差异，并将这些增量哈希值除以先前计算的GCS除数的2次方。这种除法产生商和余数。为了完成编码，我们使用一元编码表示商，使用二进制表示余数，并使用0填充到最大长度。
- en: Each element is encoded in this manner and the bits concatenated together to
    form the GCS structure. To check for a given element in the structure, we scan
    through the bits, reconstructing each element in turn from the unary quotient
    and binary remainder, and then progressively sum the difference values we obtain
    to reconstruct the original hashed values, which we can compare against the hash
    of our test value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素都以这种方式编码，并将位连接在一起形成GCS结构。要在结构中检查给定元素，我们通过位扫描来逐个重建每个元素，从而逐步累加我们获取的差值，以重建我们可以与测试值哈希进行比较的原始哈希值。
- en: As with Bloom filters, there is a possibility of a false positive due to a hash
    collision, the probability of which depends on the size of the hash range and
    number of elements to be encoded. Again, false negatives aren’t possible.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与布隆过滤器一样，由于哈希碰撞的可能性，存在误报的可能性，其概率取决于哈希范围的大小和要编码的元素数量。再次强调，不存在误报。
- en: Let’s consider a short example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简短的例子。
- en: GCS example
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GCS示例
- en: Start with the same encrypted values 217, 354, and 466 and a hash range of decimal
    128\. We calculate the SHA256 hash for these values (as bytes) and then divide
    by the hash range to obtain a remainder between 0 and 127. This gives us the values
    shown in [Table 10-4](#table-10-4).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从相同的加密数值217、354和466以及十进制128的哈希范围开始。我们计算这些数值的SHA256哈希（作为字节），然后除以哈希范围以获得介于0和127之间的余数。这给出了在[表10-4](#table-10-4)中显示的数值。
- en: Table 10-4\. GCS hash value calculation
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 表10-4\. GCS哈希值计算
- en: '| Encrypted value | SHA256 hash of encrypted value (hex) | Hash value range
    0-127 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 加密数值 | 加密数值的SHA256哈希（十六进制） | 哈希值范围0-127 |'
- en: '| --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 217 | 16badfc6202cb3f8889e0f2779b19218af4cbb736e56acadce8148aba9a7a9f8 |
    120 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 217 | 16badfc6202cb3f8889e0f2779b19218af4cbb736e56acadce8148aba9a7a9f8 |
    120 |'
- en: '| 354 | 09a1b036b82baba3177d83c27c1f7d0beacaac6de1c5fdcc9680c49f638c5fb9 |
    57 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 354 | 09a1b036b82baba3177d83c27c1f7d0beacaac6de1c5fdcc9680c49f638c5fb9 |
    57 |'
- en: '| 466 | 826e27285307a923759de350de081d6218a04f4cff82b20c5ddaa8c60138c066 |
    102 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 466 | 826e27285307a923759de350de081d6218a04f4cff82b20c5ddaa8c60138c066 |
    102 |'
- en: Sorting the reduced-range hash values into ascending order we have 57, 102,
    and 120\. The delta values are therefore 57 (57–0), 45 (102–57), and 18 (120–102).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将减少范围哈希值按升序排序，我们有57、102和120。因此，增量值为57（57–0）、45（102–57）和18（120–102）。
- en: 'Our divisor power we calculate as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算的除数幂为：
- en: <math alttext="a v g equals StartFraction 120 plus 1 Over 3 EndFraction almost-equals
    40.33"><mrow><mi>a</mi> <mi>v</mi> <mi>g</mi> <mo>=</mo> <mfrac><mrow><mn>120</mn><mo>+</mo><mn>1</mn></mrow>
    <mn>3</mn></mfrac> <mo>≈</mo> <mn>40</mn> <mo>.</mo> <mn>33</mn></mrow></math>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="a v g equals StartFraction 120 plus 1 Over 3 EndFraction almost-equals
    40.33"><mrow><mi>a</mi> <mi>v</mi> <mi>g</mi> <mo>=</mo> <mfrac><mrow><mn>120</mn><mo>+</mo><mn>1</mn></mrow>
    <mn>3</mn></mfrac> <mo>≈</mo> <mn>40</mn> <mo>.</mo> <mn>33</mn></mrow></math>
- en: <math alttext="p r o b equals StartFraction 1 Over 40.33 EndFraction almost-equals
    0.02479"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>=</mo> <mfrac><mn>1</mn>
    <mrow><mn>40</mn><mo>.</mo><mn>33</mn></mrow></mfrac> <mo>≈</mo> <mn>0</mn> <mo>.</mo>
    <mn>02479</mn></mrow></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="p r o b equals StartFraction 1 Over 40.33 EndFraction almost-equals
    0.02479"><mrow><mi>p</mi> <mi>r</mi> <mi>o</mi> <mi>b</mi> <mo>=</mo> <mfrac><mn>1</mn>
    <mrow><mn>40</mn><mo>.</mo><mn>33</mn></mrow></mfrac> <mo>≈</mo> <mn>0</mn> <mo>.</mo>
    <mn>02479</mn></mrow></math>
- en: <math alttext="upper G upper C upper S normal bar d i v i s o r normal bar p
    o w e r normal bar o f normal bar 2 equals max left-parenthesis 0 comma r o u
    n d left-parenthesis minus l o g 2 left-parenthesis minus l o g 2 left-parenthesis
    1.0 minus 0.02479 right-parenthesis right-parenthesis right-parenthesis equals
    5"><mrow><mi>G</mi> <mi>C</mi> <mi>S</mi> <mo>_</mo> <mi>d</mi> <mi>i</mi> <mi>v</mi>
    <mi>i</mi> <mi>s</mi> <mi>o</mi> <mi>r</mi> <mo>_</mo> <mi>p</mi> <mi>o</mi> <mi>w</mi>
    <mi>e</mi> <mi>r</mi> <mo>_</mo> <mi>o</mi> <mi>f</mi> <mo>_</mo> <mn>2</mn> <mo>=</mo>
    <mo form="prefix" movablelimits="true">max</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo>
    <mi>r</mi> <mi>o</mi> <mi>u</mi> <mi>n</mi> <mi>d</mi> <mrow><mo>(</mo> <mo>-</mo>
    <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mo>-</mo>
    <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mn>1</mn>
    <mo>.</mo> <mn>0</mn> <mo>-</mo> <mn>0</mn> <mo>.</mo> <mn>02479</mn> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn></mrow></math>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper G upper C upper S normal bar d i v i s o r normal bar p
    o w e r normal bar o f normal bar 2 equals max left-parenthesis 0 comma r o u
    n d left-parenthesis minus l o g 2 left-parenthesis minus l o g 2 left-parenthesis
    1.0 minus 0.02479 right-parenthesis right-parenthesis right-parenthesis equals
    5"><mrow><mi>G</mi> <mi>C</mi> <mi>S</mi> <mo>_</mo> <mi>d</mi> <mi>i</mi> <mi>v</mi>
    <mi>i</mi> <mi>s</mi> <mi>o</mi> <mi>r</mi> <mo>_</mo> <mi>p</mi> <mi>o</mi> <mi>w</mi>
    <mi>e</mi> <mi>r</mi> <mo>_</mo> <mi>o</mi> <mi>f</mi> <mo>_</mo> <mn>2</mn> <mo>=</mo>
    <mo form="prefix" movablelimits="true">max</mo> <mo>(</mo> <mn>0</mn> <mo>,</mo>
    <mi>r</mi> <mi>o</mi> <mi>u</mi> <mi>n</mi> <mi>d</mi> <mrow><mo>(</mo> <mo>-</mo>
    <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mo>-</mo>
    <mi>l</mi> <mi>o</mi> <msub><mi>g</mi> <mn>2</mn></msub> <mrow><mo>(</mo> <mn>1</mn>
    <mo>.</mo> <mn>0</mn> <mo>-</mo> <mn>0</mn> <mo>.</mo> <mn>02479</mn> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>)</mo></mrow> <mo>=</mo> <mn>5</mn></mrow></math>
- en: Using a divisor parameter of 32 ( <math alttext="2 Superscript 5"><msup><mn>2</mn>
    <mn>5</mn></msup></math> ), we can encode these values as shown in [Table 10-5](#table-10-5).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用除数参数32（<math alttext="2 Superscript 5"><msup><mn>2</mn> <mn>5</mn></msup></math>），我们可以将这些值编码如[表格10-5](#table-10-5)所示。
- en: Table 10-5\. GCS binary and unary encoding
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表格10-5\. GCS二进制和一进制编码
- en: '| Delta hash value'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '| Delta hash value'
- en: range 0–127 | Quotient (/32) | Remainder (%32) | Remainder (binary 5 bits) |
    Unary quotient (R to L with 0s) | GCS encoded |
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 范围0–127 | 商（/32） | 余数（%32） | 余数（二进制5位） | 一元商（从右到左带0的） | GCS编码 |
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 57 | 1  | 25 | 11001 | 10 | 1100110 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 57 | 1  | 25 | 11001 | 10 | 1100110 |'
- en: '| 45 | 1 | 13 | 01101 | 10 | 0110110 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 45 | 1 | 13 | 01101 | 10 | 0110110 |'
- en: '| 18 | 0 | 18 | 10010 | 1 | 100101 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 0 | 18 | 10010 | 1 | 100101 |'
- en: 'Together, last to first, left to right, the set is encoded as: 10010101101101100110.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后到第一个，从左到右，集合编码为：10010101101101100110。
- en: 'Example: Using the PSI Process'
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：使用PSI过程
- en: Now that we understand the basic PSI process, let’s apply it to the challenge
    of identifying the companies present in the list published by the UK MCA and also
    present in the Companies House register. If we consider the MCA as the client
    party and Companies House as the server party, then we can examine how to find
    those MCA companies that are present on the Companies House register without revealing
    the contents of the MCA list to Companies House.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了基本的PSI过程，让我们将其应用到识别英国MCA列表和Companies House注册中存在的公司的挑战上。如果我们将MCA视为客户方，Companies
    House视为服务器方，那么我们可以研究如何找到那些MCA公司在Companies House注册中存在而不向Companies House透露MCA列表的内容。
- en: '*Please note that this example is for illustration purposes only.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，此示例仅供说明目的。*'
- en: Environment Setup
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境设置
- en: As the PSI process is computationally intensive, we will use Google Cloud to
    temporarily provide us with the infrastructure to run this example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PSI过程需要大量计算资源，我们将使用Google Cloud暂时提供基础设施来运行这个例子。
- en: In [Chapter 6](ch06.html#chapter_6), we standardized the MCA and Companies House
    register datasets and saved them as standardized and cleansed CSV files. In [Chapter 7](ch07.html#chapter_7),
    we uploaded these files onto a Google Cloud Storage bucket. For the purposes of
    this chapter, we will imagine that these datasets are held by two separate parties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html#chapter_6)中，我们对MCA和Companies House注册数据集进行了标准化，并将它们保存为经过标准化和清理的CSV文件。在[第7章](ch07.html#chapter_7)中，我们将这些文件上传到了Google
    Cloud Storage存储桶中。在本章中，我们将假设这些数据集由两个独立的方当中持有。
- en: We will transfer these files to a single data science workbench instance on
    GCP upon which we will run both the server and client to illustrate the intersection
    process. This example can be easily extended to run on two different machines
    to illustrate the distinct server and client roles and the separation of data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些文件传输到一个单一的数据科学工作台实例上，在该实例上我们将运行服务器和客户端以演示交集过程。这个例子可以轻松扩展到在两台不同的机器上运行，以展示服务器和客户端角色的分离以及数据的分离。
- en: Google Cloud setup
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google Cloud设置
- en: To begin, we select Workbench from the AI Platform menu on the Google Cloud
    console. To create the environment we select User-Managed Notebooks (as opposed
    to Managed Notebook) as this option will allow us to install the packages we need.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们在Google Cloud控制台的AI平台菜单中选择工作台。为了创建环境，我们选择用户管理的笔记本（而不是托管笔记本），因为这个选项将允许我们安装我们需要的包。
- en: The first step is to select Create New. From here we can rename the notebook
    to a name of our choice. Under the Environment section, select the basic Python3
    option, then click Create. As in [Chapter 7](ch07.html#chapter_7), you can change
    the region and zone settings if you wish or accept the defaults. If (optionally)
    you select “IAM and security,” you’ll note that root access to the virtual machine
    will be granted.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是选择创建新的。从这里，我们可以将笔记本重命名为我们选择的名称。在环境部分，选择基本的Python3选项，然后点击创建。如同[第7章](ch07.html#chapter_7)中一样，如果您希望或接受默认设置，可以更改区域和区域设置。如果（可选）选择“IAM和安全性”，您将注意到将授予虚拟机的根访问权限。
- en: Costs
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成本
- en: Be aware that once you create a new Workbench environment, you begin to incur
    costs, both when the instance is running and disk space costs even when the instance
    is stopped. By default the Workbench instance creates 2 × 100 GB disks!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦创建了新的Workbench环境，您将开始产生费用，无论实例是否正在运行，磁盘空间成本都会产生费用，即使实例停止时也是如此。默认情况下，Workbench实例会创建2个100
    GB的磁盘！
- en: '*It is your responsibility to ensure that the instance is stopped and/or deleted
    to avoid incurring unexpected costs.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*您有责任确保停止或删除实例，以避免产生意外费用。*'
- en: Once your instance is created, you’ll be able to click Open JupyterLab to open
    a local window to a JupyterLab environment hosted on your new GCP Workbench.^([2](ch10.html#id626))
    From here, we can select Terminal under Other to open a terminal window to configure
    our environment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了您的实例后，您将能够点击“打开JupyterLab”以打开一个本地窗口，访问托管在新的GCP Workbench上的JupyterLab环境。^([2](ch10.html#id626))
    从这里，我们可以在“其他”下选择“终端”以打开终端窗口来配置我们的环境。
- en: The PSI package we are going to use is released and distributed by the OpenMined
    community.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的PSI包由OpenMined社区发布和分发。
- en: OpenMined
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenMined
- en: OpenMined is an open source community whose goal is to make the world more privacy
    preserving by lowering the barrier-to-entry to private AI technologies. Their
    PSI repository provides a Private Set Intersection Cardinality protocol based
    on ECDH and Bloom filters.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: OpenMined是一个开源社区，旨在通过降低进入私人AI技术的门槛来使世界更加隐私保护。他们的PSI存储库提供了基于ECDH和Bloom过滤器的私人集交集基数协议。
- en: At the time of writing, the OpenMined PSI package is available [online](https://oreil.ly/XaKJs).
    From this site we can download a prebuilt distribution compatible with a Google
    Cloud Workbench (currently an x86 64-bit virtual machine running Debian 11 OS)
    that we can readily install (option 1). Alternatively, if you prefer to use a
    different environment or build the package yourself, you can (option 2).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，OpenMined PSI包可以在[线上](https://oreil.ly/XaKJs)获取。从该网站我们可以下载与Google Cloud
    Workbench兼容的预构建发行版（当前是运行Debian 11操作系统的x86 64位虚拟机），我们可以方便地安装（选项1）。或者，如果您更喜欢使用不同的环境或自行构建该包，则可以选择（选项2）。
- en: 'Option 1: Prebuilt PSI package'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项1：预构建PSI包
- en: 'Create a PSI directory and switch into this location:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个PSI目录并切换到该位置：
- en: '[PRE0]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Copy the link address for the compatible Python distribution and use wget to
    download. Currently, this would be:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 复制兼容Python发行版的链接地址，并使用wget进行下载。目前的链接是：
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Install the package as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 安装该软件包如下：
- en: '[PRE2]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Option 2: Build PSI package'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项2：构建PSI包
- en: 'At the terminal prompt we clone the repository for the OpenMined psi package:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端提示符下，我们克隆OpenMined psi包的存储库：
- en: '[PRE3]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next switch into the psi directory:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后切换到psi目录：
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To build the psi package from the repository source we need to install the
    appropriate version of the build package, Bazel. Use wget to acquire the appropriate
    prebuilt Debian release package from the GitHub repository:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要从存储库源代码构建psi包，我们需要安装适当版本的构建包Bazel。使用wget获取GitHub存储库中适当的预构建Debian发行版软件包：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Install this package as root:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以root身份安装此软件包：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next we use Bazel to build the Python distribution, a wheel file, with the
    necessary dependencies. This step may take a few moments:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Bazel构建Python发行版，即一个wheel文件，具备必要的依赖项。这一步可能需要几分钟：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once we have built the wheel archive, then we can use a Python utility provided
    by OpenMined to rename the file to reflect the environment it supports:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了wheel归档文件，我们可以使用OpenMined提供的Python工具将文件重命名以反映它支持的环境：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The rename utility will output the path and name of the renamed file. We now
    need to install this newly renamed package from the provided path, for example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名实用程序将输出重命名文件的路径和名称。我们现在需要从提供的路径安装这个新命名的包，例如：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, this installation may take a few moments but once it’s complete we have
    the building blocks we need to execute a PSI on our sample problem data.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，此安装可能需要几分钟，但一旦完成，我们就拥有了执行样本问题数据上PSI所需的基本组件。
- en: Server install
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器安装
- en: 'Once our psi package is installed, one more thing we will need is a basic client/server
    framework to handle the matching requests. For this purpose we use the Flask lightweight
    microframework that we can install using pip:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了psi包，我们还需要一个基本的客户端/服务器框架来处理匹配请求。为此，我们使用Flask轻量级微框架，可以使用pip安装：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once this install is complete, we can navigate up from the psi directory so
    that we can copy across our example files:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以从psi目录上级导航，以便复制我们的示例文件：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To start the flask server and run the `Chapter10Server` Python script, we use
    the following at a terminal tab prompt:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动flask服务器并运行`Chapter10Server` Python脚本，我们可以在终端选项卡提示符中使用以下命令：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The server will take a few moments to start as it reads in the Companies House
    dataset and assembles the entities into a list of concatenated `CompanyName` and
    `Postcode` strings.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动需要一些时间，因为它正在读取Companies House数据集并将实体组装成一系列连接的`CompanyName`和`Postcode`字符串。
- en: 'Once it is ready to process requests, it will display the following at the
    command prompt:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备好处理请求，它将在命令提示符下显示以下内容：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Server Code
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器代码
- en: 'Let’s look at the server code by opening the Python file *Chapter10Server.py*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过打开Python文件*Chapter10Server.py*来查看服务器代码：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We start by importing the PSI package we installed and then the `flask` and
    `pandas` functions we need.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入安装的PSI包，然后是我们需要的`flask`和`pandas`函数。
- en: Next, we set the desired false positive rate (`fpr`) and the number of client
    inputs we will check in each request. Together these parameters are used to calculate
    the length of the Bloom filter and hash range used in GCS encoding.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置所需的误报率（`fpr`）和每个请求中将检查的客户端输入数。这些参数一起用于计算在GCS编码中使用的Bloom过滤器和哈希范围的长度。
- en: We then read in the cleansed Companies House records that we transferred from
    our Cloud Storage bucket earlier, specifying that we ignore null values. We then
    create a list of server items by concatenating each of the `CompanyName` and `Postcode`
    values together, separated by a space. This allows us to check for an exact name
    and postcode match per entity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们读取我们之前从云存储桶传输的经过清理的Companies House记录，指定忽略空值。然后，我们通过连接每个`CompanyName`和`Postcode`值（用空格分隔）来创建服务器项目列表。这使我们能够检查每个实体的精确名称和邮政编码匹配。
- en: To allow us to examine the encoding protocols in detail using a more manageable
    server set, I’ve selected two entities from the MCA list and manually created
    their cleansed name and postcode strings as an alternative set of server items.
    *To use the full Companies House dataset instead, just remove the comment marker
    (leading `#`) from the list creation statement to override the `server_items`:*
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许我们详细检查编码协议，我从MCA列表中选择了两个实体，并手动创建了它们的经过清理的名称和邮政编码字符串，作为服务器项目的另一组替代集。*要使用完整的Companies
    House数据集，只需从列表创建语句的注释标记（前导`#`）中删除以覆盖`server_items`：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The remainder of the server file defines a class to hold the server key and
    then creates the `key` object:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器文件的其余部分定义了一个保存服务器密钥的类，然后创建了`key`对象：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Flask web application allows us to respond to both GET and POST requests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Web应用程序允许我们响应GET和POST请求。
- en: 'The server responds to a POST request to the `/match` path by creating a new
    server key and a `psirequest` object. We then parse the data within the POST request,
    process (i.e., encrypt) the received data using the new key and then serialize
    these processed values before returning them to the client:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应`/match`路径的POST请求时，会创建新的服务器密钥和一个`psirequest`对象。然后我们解析POST请求中的数据，使用新密钥处理（即加密）接收到的数据，然后在返回给客户端之前对这些处理后的值进行序列化。
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After a match request has been processed, the server can then respond to client
    GET requests for the different encoding schemes: raw encrypted values, Bloom filter,
    and GCS. In each case, we reuse the key created during the match request and we
    supply the desired false positive rate and number of items in each client request
    so that we can configure the Bloom and GCS options:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完匹配请求后，服务器可以响应客户端对不同编码方案的GET请求：原始加密值、Bloom过滤器和GCS。在每种情况下，我们重用在匹配请求期间创建的密钥，并提供所需的误报率和每个客户端请求中的项目数，以便我们可以配置Bloom和GCS选项。
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Client Code
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端代码
- en: 'The notebook containing the client code is *Chapter10Client.ipynb*, beginning:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 包含客户端代码的笔记本是*Chapter10Client.ipynb*，开始如下：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As with the server setup, we read in the cleansed MCA company details, create
    a client key, encrypt, and then serialize for transmission to the server.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务器设置一样，我们读取经过清理的MCA公司详细信息，创建客户端密钥，加密，然后序列化以传输到服务器。
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Prior to serialization, the first few lines of the `psirequest` look like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化之前，`psirequest`的前几行如下所示：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We include the serialized encrypted values as message content in a POST request
    to the `/match` URL path, indicating in the header that the content we are passing
    is a protobuf structure. The server response, containing the server-encrypted
    versions of the client encrypted values, is then parsed into a `response` object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将序列化的加密值作为消息内容包含在POST请求中，请求的路径为`/match`，并在头部指示我们传递的内容是一个protobuf结构。然后，服务器响应包含客户端加密值的服务器加密版本，并被解析为`response`对象：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using raw encrypted server values
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用原始加密服务器值
- en: 'To retrieve the raw encrypted server values, the client sends a request to
    the `/rawsetup` URL path:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索原始加密的服务器值，客户端发送请求到`/rawsetup` URL路径：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we have selected to use just the two test entries in the server setup file,
    then we can expect only two encrypted elements in the setup response. The values
    will depend on the server key, but the structure will look something like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择仅在服务器设置文件中使用两个测试条目，则可以预期设置响应中仅有两个加密元素。值将取决于服务器密钥，但结构将类似于此：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can then calculate the intersection from the server values in the `rawsetup`
    structure and the `client` values in the `psiresponse` structure:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以计算`rawsetup`结构中的服务器值和`psiresponse`结构中的客户端值的交集：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This gives us the list index of the matching entities, in this simple case:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们匹配实体的列表索引，在这个简单的情况中：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then look up the corresponding client entities:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以查找相应的客户端实体：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Success! We have resolved these entities between the client and server records, exact-matching
    `CompanyName` and `Postcode` attributes, without revealing the client items to
    the server.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已在客户端和服务器记录之间解析了这些实体，确切匹配`CompanyName`和`Postcode`属性，而不向服务器透露客户端项目。
- en: Using Bloom filter–encoded encrypted server values
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用布隆过滤器编码的加密服务器值
- en: 'Now let’s examine how we would use a Bloom filter to encode the set of server
    encrypted values:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用布隆过滤器对编码的服务器加密值进行编码：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we submit a request via the `/bloomsetup` path, we get an output that looks
    like:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过`/bloomsetup`路径提交请求，我们会得到一个类似的输出：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The server calculates the number of bits in the filter according to the formula
    in the Bloom filters section. We can re-create this as:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器根据布隆过滤器部分中的公式计算过滤器中的位数。我们可以重新创建如下：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The false positive rate is set at 1 in 100 per query with a batch size of 100
    client items to check at a time, giving an overall (corrected) fpr of 0.0001\.
    For our very basic example, `max_elements` is also equal to 100\. This gives us
    a Bloom filter bit length of 1920:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 错误阳性率设置为每次查询100个客户端项目的100中的1，因此总体（修正后）的fpr为0.0001。对于我们非常基本的示例，`max_elements`也等于100。这给我们一个布隆过滤器位长度为1920：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This gives us 14 hash functions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们14个哈希函数。
- en: 'We can reproduce the Bloom filter by processing the raw encrypted server elements:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过处理原始加密服务器元素来复现布隆过滤器：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we can compare our filter against the filter bits returned by the server
    when assembled in the same order and converted to a string:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当以相同顺序组装并转换为字符串时，我们可以将我们的过滤器与服务器返回的过滤器比较：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using GCS-encoded encrypted server values
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GCS编码的加密服务器值
- en: Finally, let’s examine how we would use GCS to encode the set of server-encrypted
    values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何使用GCS对编码的服务器加密值进行编码。
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we submit a request via the `/gcssetup` path, we get an output that looks
    like:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过`/gcssetup`路径提交请求，我们会得到一个类似的输出：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To reproduce these values, we can apply the formulas in the preceding PSI section:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要复现这些值，我们可以应用上述PSI部分中的公式：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This gives us the hash range of 1000000.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们1000000的哈希范围。
- en: 'As with Bloom filter, we can reproduce the GCS structure by processing the
    raw encrypted server elements. First, we hash the raw encrypted server values
    into the `gcs_hash_range`, sort in ascending order, and calculate the differences:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与布隆过滤器类似，我们可以通过处理原始加密服务器元素来复现GCS结构。首先，我们将原始加密服务器值哈希到`gcs_hash_range`中，按升序排序，并计算差值：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we can calculate the GCS divisor as:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算GCS除数如下：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This gives us a divisor of 17, which we can then use to calculate the quotient
    and remainder before we encode these in unary and binary, respectively. We concatenate
    these bit patterns together:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个除数为17，然后我们可以使用它来计算商和余数，分别在一元和二元中编码这些位模式。我们将这些位模式连接在一起：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we pad out the encoded string to be a multiple of 8 so that we can
    match against the returned GCS bits:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们填充编码字符串，使其成为8的倍数，以便与返回的GCS比特匹配：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Full MCA and Companies House Sample Example
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完整的MCA和Companies House样本示例
- en: Now that we have seen the end-to-end PSI entity matching process using a tiny
    server dataset of only two items, we’re ready to use the full Companies House
    dataset.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到了使用仅包含两个项目的微小服务器数据集进行端到端PSI实体匹配过程的结尾，我们准备使用完整的Companies House数据集。
- en: 'Open the *Chapter10Server.py* file and uncomment:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*Chapter10Server.py*文件并取消注释：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and then stop (Ctrl+C or Cmd-C) and restart the Flask server:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后停止（Ctrl+C或Cmd-C）并重新启动Flask服务器：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we can restart the client kernel and rerun the notebook to get the full
    intersection between the MCA and Companies House data, resolving the entities
    on `CompanyName` and `Postcode`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以重新启动客户端内核并重新运行笔记本，以获取MCA和Companies House数据的完整交集，解析`CompanyName`和`Postcode`上的实体。
- en: We can request either a raw, Bloom, or GCS response. Allow approximately 10
    minutes for the server to process and return. *I suggest you skip over the steps
    to reproduce the Bloom/GCS structures as these could take quite a while*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以请求原始、Bloom或GCS响应。请允许服务器大约10分钟来处理并返回。*我建议您跳过重现Bloom/GCS结构的步骤，因为这可能需要很长时间*。
- en: 'Jumping to calculate the intersection then gives us 45 exact matches:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转计算交集然后给出我们45个精确匹配项：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Tidy Up
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整理
- en: Remember to stop and delete your User-Managed Notebook and any associated disks
    to avoid ongoing charges!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 记得停止并删除您的用户管理笔记本和任何关联磁盘，以避免持续收费！
- en: This PSI example has shown how we can resolve entities between two parties even
    if one party cannot share their data with the other. In this basic example, we
    have been able to look for simultaneous exact matches on only two attributes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本PSI示例展示了如何在两个当事方之间解析实体，即使其中一方无法与另一方共享其数据。在这个基本示例中，我们能够仅查找两个属性的同时精确匹配。
- en: In certain situations, exact matching may be sufficient. However, when approximate
    matching is needed, and at least one party is prepared to share partial matches,
    we need a more sophisticated approach that is beyond the scope of this book. There
    is ongoing research into the practicality of using fully homomorphic encryption
    to enable privacy-preserving fuzzy matching, which would open up a wider field
    of potential use cases for this technique.^([3](ch10.html#id637))
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，精确匹配可能足够。但是，当需要近似匹配时，并且至少有一方准备分享部分匹配时，我们需要一种更复杂的方法，这超出了本书的范围。目前正在研究使用全同态加密实现隐私保护模糊匹配的实用性，这将为该技术开辟更广泛的潜在用例领域。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned how to use Private Set Intersection to resolve entities
    between two parties without either party revealing their full dataset. We saw
    how to use compressed data representations to reduce the volume of data we needed
    to pass between the two parties at the price of introducing a small percentage
    of false positives.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用私有集合交集来解析两个当事方之间的实体，而双方都不需透露其完整数据集。我们看到了如何使用压缩数据表示来减少需要在两个当事方之间传递的数据量，尽管会引入少量误报。
- en: We noted that these techniques can be readily applied to exact matching scenarios
    but that more advanced approximate or probabilistic matching remains a challenge
    and a subject of active research.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，这些技术可以轻松应用于精确匹配场景，但更高级的近似或概率匹配仍然是一个挑战，也是积极研究的课题。
- en: ^([1](ch10.html#id612-marker)) Meadows, Catherine, “A More Efficient Cryptographic
    Matchmaking Protocol for Use in the Absence of a Continuously Available Third
    Party,” *1986 IEEE Symposium on Security and Privacy*, Oakland, CA, USA, 1986,
    pp. 134, *https://doi.org/10.1109/SP.1986.10022*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#id612-marker)) Meadows, Catherine，“用于在没有连续可用第三方的情况下使用的更有效的加密匹配协议”，*1986
    IEEE安全与隐私研讨会*，美国加利福尼亚州奥克兰，1986年，第134页，*https://doi.org/10.1109/SP.1986.10022*。
- en: ^([2](ch10.html#id626-marker)) You may need to allow pop-ups on your local browser.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.html#id626-marker)) 您可能需要在本地浏览器上允许弹出窗口。
- en: ^([3](ch10.html#id637-marker)) See the patent “Compact fuzzy private matching
    using a fully-homomorphic encryption scheme,” [*https://patents.google.com/patent/US20160119119*](https://patents.google.com/patent/US20160119119).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.html#id637-marker)) 请参阅专利“使用全同态加密方案进行紧凑模糊私有匹配”，[*https://patents.google.com/patent/US20160119119*](https://patents.google.com/patent/US20160119119)。
