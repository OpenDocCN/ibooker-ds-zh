- en: Chapter 6\. Working with Dataframes Using pandas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。使用pandas处理数据框
- en: 'Data scientists work with data stored in tables. This chapter introduces *dataframes*,
    one of the most widely used ways to represent data tables. We also introduce `pandas`,
    the standard Python package for working with dataframes. Here is an example of
    a dataframe that holds information about popular dog breeds:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家处理存储在表格中的数据。本章介绍了“数据框架”，这是表示数据表的最常用方式之一。我们还介绍了`pandas`，这是处理数据框架的标准Python包。以下是一个包含有关流行狗品种信息的数据框架示例：
- en: '|   | grooming | food_cost | kids | size |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | grooming | food_cost | kids | size |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| breed |   |   |   |   |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| breed |   |   |   |   |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Labrador Retriever** | weekly | 466.0 | high | medium |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| **拉布拉多寻回犬** | 每周 | 466.0 | 高 | 中型 |'
- en: '| **German Shepherd** | weekly | 466.0 | medium | large |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| **德国牧羊犬** | 每周 | 466.0 | 中等 | 大型 |'
- en: '| **Beagle** | daily | 324.0 | high | small |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| **比格犬** | 每天 | 324.0 | 高 | 小型 |'
- en: '| **Golden Retriever** | weekly | 466.0 | high | medium |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **金毛寻回犬** | 每周 | 466.0 | 高 | 中型 |'
- en: '| **Yorkshire Terrier** | daily | 324.0 | low | small |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **约克夏梗** | 每天 | 324.0 | 低 | 小型 |'
- en: '| **Bulldog** | weekly | 466.0 | medium | medium |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **英国斗牛犬** | 每周 | 466.0 | 中等 | 中型 |'
- en: '| **Boxer** | weekly | 466.0 | high | medium |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **拳师犬** | 每周 | 466.0 | 高 | 中型 |'
- en: In a dataframe, each row represents a single record—in this case, a single dog
    breed. Each column represents a feature about the record—for example, the grooming
    column represents how often each dog breed needs to be groomed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据框中，每行代表一个单独的记录——在本例中是一个狗品种。每列代表记录的一个特征——例如，grooming列表示每个狗品种需要多频繁地梳理。
- en: Dataframes have labels for both columns and rows. For instance, this dataframe
    has a column labeled grooming and a row labeled German Shepherd. The columns and
    rows of a dataframe are ordered—we can refer to the Labrador Retriever row as
    the first row of the dataframe.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框架具有列和行的标签。例如，此数据框架具有一个标记为grooming的列和一个标记为德国牧羊犬的行。数据框架的列和行是有序的——我们可以将拉布拉多寻回犬行称为数据框架的第一行。
- en: Within a column, data have the same type. For instance, the cost of food contains
    numbers, and the size of the dog consists of categories. But data types can be
    different within a row.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在列内，数据具有相同的类型。例如，食物成本包含数字，狗的大小由类别组成。但是在行内，数据类型可以不同。
- en: Because of these properties, dataframes enable all sorts of useful operations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些属性，数据框架使得各种有用的操作成为可能。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Data scientists often find themselves working with people from different backgrounds
    who use different terms. For instance, computer scientists say that the columns
    of a dataframe represent *features* of the data, while statisticians call them
    *variables* instead.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家经常发现自己与使用不同背景的人合作。例如，计算机科学家说数据框中的列表示数据的“特征”，而统计学家则称之为“变量”。
- en: Other times, people use the same term to refer to slightly different ideas.
    *Data types* in a programming sense refers to how a computer stores data internally.
    For instance, the `size` column has a string data type in Python. But from a statistical
    point of view, the type of the `size` column is ordered categorical data (ordinal
    data). We talk more about this specific distinction in [Chapter 10](ch10.html#ch-eda).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，人们使用同一个术语来指代略有不同的概念。在编程中，“数据类型”指的是计算机如何在内部存储数据。例如，Python中的`size`列具有字符串数据类型。但从统计学的角度来看，`size`列的类型是有序分类数据（序数数据）。我们在[第10章](ch10.html#ch-eda)中详细讨论了这种具体区别。
- en: 'In this chapter, we introduce common dataframe operations. Data scientists
    use the `pandas` library when working with dataframes in Python. First, we explain
    the main objects that `pandas` provides: the `DataFrame` and `Series` classes.
    Then we show how to use `pandas` to perform common data manipulation tasks, like
    slicing, filtering, sorting, grouping, and joining.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了常见的数据框架操作。数据科学家在Python中处理数据框架时使用`pandas`库。首先，我们解释了`pandas`提供的主要对象：`DataFrame`和`Series`类。然后，我们展示如何使用`pandas`执行常见的数据操作任务，如切片、过滤、排序、分组和连接。
- en: Subsetting
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子集
- en: This section introduces operations for taking subsets of dataframes. When data
    scientists first read in a dataframe, they often want to subset the specific data
    that they plan to use. For example, a data scientist can *slice* out the 10 relevant
    features from a dataframe with hundreds of columns. Or they can *filter* a dataframe
    to remove rows with incomplete data. For the rest of this chapter, we demonstrate
    dataframe operations using a dataframe of baby names.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了对数据框进行子集操作的操作。当数据科学家首次读取数据框时，他们通常希望获取计划使用的特定数据子集。例如，数据科学家可以从包含数百列的数据框中*切片*出10个相关特征。或者，他们可以*过滤*数据框以删除包含不完整数据的行。在本章的其余部分，我们使用一个婴儿姓名的数据框来演示数据框操作。
- en: Data Scope and Question
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据范围和问题
- en: 'There’s a [2021 *New York Times* article](https://oreil.ly/qL1dt) that talks
    about Prince Harry and Meghan Markle’s unique choice for their new baby daughter’s
    name: Lilibet. The article has an interview with Pamela Redmond, an expert on
    baby names, who talks about interesting trends in how people name their kids.
    For example, she says that names that start with the letter L have become very
    popular in recent years, while names that start with the letter J were most popular
    in the 1970s and 1980s. Are these claims reflected in data? We can use `pandas`
    to find out.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有一篇[2021年《纽约时报》文章](https://oreil.ly/qL1dt)讨论了哈里王子和梅根·马克尔为他们的新生女儿选择的独特姓名“莉莉贝特”。文章中采访了婴儿姓名专家帕梅拉·雷德蒙德，她谈到了人们如何给孩子取名的有趣趋势。例如，她说以字母“L”开头的名字近年来变得非常流行，而以字母“J”开头的名字在上世纪70年代和80年代最受欢迎。这些说法在数据中反映出来吗？我们可以使用`pandas`来找出答案。
- en: 'First, we import the package as `pd`, the canonical abbreviation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将包导入为`pd`，这是它的常用缩写：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have a dataset of baby names stored in a comma-separated values (CSV) file
    called *babynames.csv*. We use the `pd.read_csv` function to read the file as
    a `pandas.DataFrame` object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个婴儿姓名数据集，存储在名为*babynames.csv*的逗号分隔值（CSV）文件中。我们使用`pd.read_csv`函数将文件读取为`pandas.DataFrame`对象：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 利亚姆 | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 诺亚 | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 奥利弗 | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | 维罗纳 | F | 5 | 1880 |'
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | 维尔蒂 | F | 5 | 1880 |'
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | 威尔玛 | F | 5 | 1880 |'
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The data in the `baby` table comes from the [US Social Security Administration
    (SSA)](https://oreil.ly/EhTlP), which records the baby name and birth sex for
    birth certificate purposes. The SSA makes the baby names data available on its
    website. We’ve loaded this data into the `baby` table.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`baby`表中的数据来自[美国社会保障局（SSA）](https://oreil.ly/EhTlP)，记录了出生证明目的的婴儿姓名和出生性别。SSA将婴儿姓名数据提供在其网站上。我们已将此数据加载到`baby`表中。'
- en: 'The SSA website has a [page](https://oreil.ly/jzCVF) that describes the data
    in more detail. We won’t go in depth in this chapter about the data’s limitations,
    but we’ll point out this relevant information from the website:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SSA网站有一个[页面](https://oreil.ly/jzCVF)，详细描述了数据。在本章中，我们不会深入讨论数据的限制，但我们将指出网站上有关此相关信息：
- en: All names are from Social Security card applications for births that occurred
    in the United States after 1879\. Note that many people born before 1937 never
    applied for a Social Security card, so their names are not included in our data.
    For others who did apply, our records may not show the place of birth, and again
    their names are not included in our data.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有姓名均来自于1879年后在美国出生的社会保障卡申请。请注意，许多1937年之前出生的人从未申请过社会保障卡，因此他们的姓名不包含在我们的数据中。对于那些申请过的人，我们的记录可能不显示出生地，同样，他们的姓名也不包含在我们的数据中。
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All data are from a 100% sample of our records on Social Security card applications
    as of March 2021.
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有数据都来自我们2021年3月社会保障卡申请记录的100％样本。
- en: It’s also important to point out that at the time of this writing, the SSA dataset
    only provides the binary options of male and female. We hope that in the future,
    national datasets like this one will provide more inclusive options.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，重要的一点是指出，SSA数据集仅提供了男性和女性的二进制选项。我们希望将来像这样的国家数据集能够提供更多包容性选项。
- en: Dataframes and Indices
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框和索引
- en: Let’s examine the `baby` dataframe in more detail. A dataframe has rows and
    columns. Every row and column has a label, as highlighted in [Figure 6-1](#fig-baby-labels).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看 `baby` 数据帧。数据帧有行和列。每行和列都有一个标签，如 [图 6-1](#fig-baby-labels) 中所示。
- en: '![baby-labels](assets/leds_0601.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![baby-labels](assets/leds_0601.png)'
- en: Figure 6-1\. The `baby` dataframe has labels for both rows and columns (boxed)
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. `baby` 数据帧为行和列都设置了标签（框起来的）
- en: By default, `pandas` assigns row labels as incrementing numbers starting from
    0\. In this case, the data at the row labeled `0` and column labeled `Name` has
    the data `'Liam'`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`pandas` 分配的行标签从 0 开始递增。在这种情况下，标记为 `0` 的行和标记为 `Name` 的列的数据为 `'Liam'`。
- en: Dataframes can also have strings as row labels. [Figure 6-2](#fig-dog-labels)
    shows a dataframe of dog data where the row labels are strings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数据帧的行标签也可以是字符串。[图 6-2](#fig-dog-labels) 显示了一个狗数据的数据帧，其中行标签是字符串。
- en: '![dog-labels](assets/leds_0602.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![dog-labels](assets/leds_0602.png)'
- en: Figure 6-2\. Row labels in dataframes can also be strings, as in this example,
    in which each row is labeled using the dog breed name
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 数据帧中的行标签也可以是字符串，例如本例中，每行都使用狗品种名称进行标记
- en: The row labels have a special name. We call them the *index* of a dataframe,
    and `pandas` stores the row labels in a special `pd.Index` object. We won’t discuss
    the `pd.Index` object since it’s less common to manipulate the index itself. For
    now, it’s important to remember that even though the index looks like a column
    of data, the index really represents row labels, not data. For instance, the dataframe
    of dog breeds has four columns of data, not five, since the index doesn’t count
    as a column.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 行标签有一个特殊的名称。我们称之为数据帧的 *索引*，`pandas` 将行标签存储在特殊的 `pd.Index` 对象中。我们暂时不讨论 `pd.Index`
    对象，因为不常操作索引本身。但现在重要的是要记住，即使索引看起来像数据的一列，索引实际上代表行标签，而不是数据。例如，狗品种的数据帧有四列数据，而不是五列，因为索引不算作列。
- en: Slicing
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: '*Slicing* is an operation that creates a new dataframe by taking a subset of
    rows or columns out of another dataframe. Think about slicing a tomato—slices
    can go both vertically and horizontally. To take slices of a dataframe in `pandas`,
    we use the `.loc` and `.iloc` properties. Let’s start with `.loc`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*切片* 是通过从另一个数据帧中取出部分行或列来创建一个新数据帧的操作。想象一下切西红柿——切片可以在垂直和水平方向上进行。在 `pandas` 中进行数据帧切片时，我们使用
    `.loc` 和 `.iloc` 属性。让我们从 `.loc` 开始。'
- en: 'Here’s the full `baby` dataframe:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的 `baby` 数据帧：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | F | 5 | 1880 |'
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | F | 5 | 1880 |'
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | F | 5 | 1880 |'
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`.loc` lets us select rows and columns using their labels. For example, to
    get the data in the row labeled `1` and column labeled `Name`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`.loc` 允许我们使用它们的标签选择行和列。例如，要获取标记为 `1` 的行和标记为 `Name` 的列中的数据：'
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Warning
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Notice that `.loc` needs square brackets; running `baby.loc(1, 'Name')` will
    result in an error.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`.loc` 需要使用方括号；运行 `baby.loc(1, 'Name')` 将导致错误。
- en: 'To slice out multiple rows or columns, we can use Python slice syntax instead
    of individual values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了切片多行或列，我们可以使用 Python 切片语法，而不是单独的值：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|   | Name | Sex | Count |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count |'
- en: '| --- | --- | --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 |'
- en: '| **1** | Noah | M | 18252 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 |'
- en: '| **2** | Oliver | M | 14147 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 |'
- en: '| **3** | Elijah | M | 13034 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **3** | Elijah | M | 13034 |'
- en: 'To get an entire column of data, we can pass an empty slice as the first argument:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取整列数据，我们可以将空切片作为第一个参数传递：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that the output of this doesn’t look like a dataframe, and it’s not.
    Selecting out a single row or column of a dataframe produces a `pd.Series` object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个输出看起来不像一个数据帧，因为它不是。选择数据帧的单行或单列会产生一个 `pd.Series` 对象：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What’s the difference between a `pd.Series` object and a `pd.DataFrame` object?
    Essentially, a `pd.DataFrame` is two-dimensional—it has rows and columns and represents
    a table of data. A `pd.Series` is one-dimensional—it represents a list of data.
    `pd.Series` and `pd.DataFrame` objects have many methods in common, but they really
    represent two different things. Confusing the two can cause bugs and confusion.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是`pd.Series`对象和`pd.DataFrame`对象的区别？本质上，`pd.DataFrame`是二维的——它有行和列，代表着数据表。`pd.Series`是一维的——它代表着数据列表。`pd.Series`和`pd.DataFrame`对象有许多共同的方法，但它们实际上代表着两种不同的东西。混淆两者可能会导致错误和混乱。
- en: 'To select specific columns of a dataframe, pass a list into `.loc`. Here’s
    the original dataframe:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择数据帧的特定列，请将列表传递给`.loc`。以下是原始数据帧：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|   | 名字 | 性别 | 数量 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | F | 5 | 1880 |'
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | F | 5 | 1880 |'
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | F | 5 | 1880 |'
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|   | Name | Year |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|   | 名字 | 年份 |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Liam | 2020 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | 2020 |'
- en: '| **1** | Noah | 2020 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | 2020 |'
- en: '| **2** | Oliver | 2020 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | 2020 |'
- en: '| **...** | ... | ... |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **2020719** | Verona | 1880 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | 1880 |'
- en: '| **2020720** | Vertie | 1880 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | 1880 |'
- en: '| **2020721** | Wilma | 1880 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | 1880 |'
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Selecting columns is very common, so there’s a shorthand:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 选择列非常常见，所以有一种简便写法：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|   | Name | Count |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|   | 名字 | 数量 |'
- en: '| --- | --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Liam | 19659 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | 19659 |'
- en: '| **1** | Noah | 18252 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | 18252 |'
- en: '| **2** | Oliver | 14147 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | 14147 |'
- en: '| **...** | ... | ... |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **2020719** | Verona | 5 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | 5 |'
- en: '| **2020720** | Vertie | 5 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | 5 |'
- en: '| **2020721** | Wilma | 5 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | 5 |'
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Slicing using `.iloc` works similarly to `.loc`, except that `.iloc` uses the
    *positions* of rows and columns rather than labels. It’s easiest to show the difference
    between `.iloc` and `.loc` when the dataframe index has strings, so for demonstration
    purposes, let’s look at a dataframe with information on dog breeds:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.iloc`切片与`.loc`类似，不同之处在于`.iloc`使用行和列的*位置*而不是标签。当数据帧索引具有字符串时，演示时最容易显示`.iloc`和`.loc`之间的差异，所以让我们看一个有关狗品种信息的数据帧：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|   | grooming | food_cost | kids | size |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|   | 美容 | 食品成本 | 孩子 | 尺寸 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| breed |   |   |   |   |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 品种 |   |   |   |   |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Labrador Retriever** | weekly | 466.0 | high | medium |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **拉布拉多猎犬** | 每周 | 466.0 | 高 | 中等 |'
- en: '| **German Shepherd** | weekly | 466.0 | medium | large |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **德国牧羊犬** | 每周 | 466.0 | 中等 | 大型 |'
- en: '| **Beagle** | daily | 324.0 | high | small |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **猎犬** | 每日 | 324.0 | 高 | 小型 |'
- en: '| **Golden Retriever** | weekly | 466.0 | high | medium |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **金毛寻回犬** | 每周 | 466.0 | 高 | 中等 |'
- en: '| **Yorkshire Terrier** | daily | 324.0 | low | small |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **约克夏梗** | 每日 | 324.0 | 低 | 小型 |'
- en: '| **Bulldog** | weekly | 466.0 | medium | medium |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **斗牛犬** | 每周 | 466.0 | 中等 | 中等 |'
- en: '| **Boxer** | weekly | 466.0 | high | medium |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **拳师犬** | 每周 | 466.0 | 高 | 中等 |'
- en: 'To get the first three rows and the first two columns by position, use `.iloc`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过位置获取前三行和前两列，请使用`.iloc`：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|   | grooming | food_cost |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|   | 美容 | 食品成本 |'
- en: '| --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| breed |   |   |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 品种 |   |   |'
- en: '| --- | --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Labrador Retriever** | weekly | 466.0 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **拉布拉多猎犬** | 每周 | 466.0 |'
- en: '| **German Shepherd** | weekly | 466.0 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **德国牧羊犬** | 每周 | 466.0 |'
- en: '| **Beagle** | daily | 324.0 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **猎犬** | 每日 | 324.0 |'
- en: 'The same operation using `.loc` requires us to use the dataframe labels:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.loc`进行相同操作需要使用数据帧标签：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|   | grooming | food_cost |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|   | 美容 | 食品成本 |'
- en: '| --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| breed |   |   |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 品种 |   |   |'
- en: '| --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Labrador Retriever** | weekly | 466.0 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **拉布拉多猎犬** | 每周 | 466.0 |'
- en: '| **German Shepherd** | weekly | 466.0 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **德国牧羊犬** | 每周 | 466.0 |'
- en: '| **Beagle** | daily | 324.0 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **猎犬** | 每日 | 324.0 |'
- en: Next, we’ll look at filtering rows.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何过滤行。
- en: Filtering Rows
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤行
- en: So far, we’ve shown how to use `.loc` and `.iloc` to slice a dataframe using
    labels and positions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了如何使用`.loc`和`.iloc`使用标签和位置来切片数据帧。
- en: However, data scientists often want to *filter* rows—they want to take subsets
    of rows using some criteria. Let’s say we want to find the most popular baby names
    in 2020\. To do this, we can filter rows to keep only the rows where the `Year`
    is 2020.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据科学家通常希望*筛选*行——他们希望使用某些条件获取行的子集。假设我们要找到2020年最流行的婴儿名字。为此，我们可以筛选行，仅保留`Year`为2020的行。
- en: To filter, we’d like to check whether each value in the `Year` column is equal
    to 1970 and then keep only those rows.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要筛选，我们想要检查`Year`列中的每个值是否等于1970，然后仅保留这些行。
- en: 'To compare each value in `Year`, we slice out the column and make a boolean
    comparison (this is similar to what we’d do with a `numpy` array). Here’s the
    dataframe for reference:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较`Year`中的每个值，我们切出列并进行布尔比较（这与我们在`numpy`数组中所做的类似）。以下是参考数据框：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | F | 5 | 1880 |'
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | F | 5 | 1880 |'
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | F | 5 | 1880 |'
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice that a boolean comparison on a `Series` gives a `Series` of booleans.
    This is nearly equivalent to writing:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对`Series`进行布尔比较会生成布尔`Series`。这几乎等同于：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But the boolean comparison is easier to write and much faster to execute than
    a `for` loop.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但布尔比较比`for`循环更容易编写，执行起来也更快。
- en: 'Now we tell `pandas` to keep only the rows where the comparison evaluated to
    `True`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在告诉`pandas`仅保留评估为`True`的行：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **31267** | Zylynn | F | 5 | 2020 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **31267** | Zylynn | F | 5 | 2020 |'
- en: '| **31268** | Zynique | F | 5 | 2020 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **31268** | Zynique | F | 5 | 2020 |'
- en: '| **31269** | Zynlee | F | 5 | 2020 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **31269** | Zynlee | F | 5 | 2020 |'
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Passing a `Series` of booleans into `.loc` only keeps rows where the `Series`
    has a `True` value.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将布尔`Series`传递到`.loc`中，仅保留`Series`具有`True`值的行。
- en: 'Filtering has a shorthand. This computes the same table as the preceding snippet
    without using `.loc`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选有简写方式。这将计算与前面代码段相同的表，但不使用`.loc`：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **31267** | Zylynn | F | 5 | 2020 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **31267** | Zylynn | F | 5 | 2020 |'
- en: '| **31268** | Zynique | F | 5 | 2020 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **31268** | Zynique | F | 5 | 2020 |'
- en: '| **31269** | Zynlee | F | 5 | 2020 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **31269** | Zynlee | F | 5 | 2020 |'
- en: '[PRE33]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, to find the most common names in 2020, sort the dataframe by `Count`
    in descending order. Wrapping a long expression in parentheses lets us easily
    add line breaks to make it more readable:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了找到2020年最常见的名字，请按降序排列数据框中的`Count`。将较长的表达式用括号括起来，可以轻松添加换行符，使其更易读：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **13911** | Emma | F | 15581 | 2020 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **13911** | Emma | F | 15581 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **13912** | Ava | F | 13084 | 2020 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| **13912** | Ava | F | 13084 | 2020 |'
- en: '| **3** | Elijah | M | 13034 | 2020 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **3** | Elijah | M | 13034 | 2020 |'
- en: '| **13913** | Charlotte | F | 13003 | 2020 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| **13913** | Charlotte | F | 13003 | 2020 |'
- en: We see that Liam, Noah, and Emma were the most popular baby names in 2020.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，Liam、Noah 和 Emma 是2020年最受欢迎的婴儿名字。
- en: 'Example: How Recently Has Luna Become a Popular Name?'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：Luna 最近成为热门名字吗？
- en: 'The *New York Times* article mentions that the name Luna was almost nonexistent
    before 2000 but has since grown to become a very popular name for girls. When
    exactly did Luna become popular? We can check this using slicing and filtering.
    When approaching a data manipulation task, we recommend breaking the problem down
    into smaller steps. For example, we could think:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*纽约时报*的文章提到，Luna这个名字在2000年之前几乎不存在，但此后已成为女孩们非常流行的名字。Luna究竟在何时变得流行？我们可以使用切片和筛选来检查。在解决数据处理任务时，我们建议将问题分解为较小的步骤。例如，我们可以这样思考：'
- en: 'Filter: keep only rows with `''Luna''` in the `Name` column.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 筛选：仅保留`Name`列中含有`'Luna'`的行。
- en: 'Filter: keep only rows with `''F''` in the `Sex` column.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 筛选：仅保留`Sex`列中含有`'F'`的行。
- en: 'Slice: keep the `Count` and `Year` columns.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切片：保留`Count`和`Year`列。
- en: 'Now it’s a matter of translating each step into code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需要将每个步骤翻译成代码即可：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|   | Count | Year |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|   | 计数 | 年份 |'
- en: '| --- | --- | --- |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **13923** | 7770 | 2020 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| **13923** | 7770 | 2020 |'
- en: '| **45366** | 7772 | 2019 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| **45366** | 7772 | 2019 |'
- en: '| **77393** | 6929 | 2018 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| **77393** | 6929 | 2018 |'
- en: '| **...** | ... | ... |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **2014083** | 17 | 1883 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **2014083** | 17 | 1883 |'
- en: '| **2018187** | 18 | 1881 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **2018187** | 18 | 1881 |'
- en: '| **2020223** | 15 | 1880 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **2020223** | 15 | 1880 |'
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this book, we use a library called `plotly` for plotting. We won’t cover
    plotting in depth here since we talk more about it in [Chapter 11](ch11.html#ch-viz).
    For now, we use `px.line()` to make a simple line plot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用一个叫做`plotly`的库进行绘图。我们不会在这里深入讨论绘图，因为我们在[第11章](ch11.html#ch-viz)中更多地谈论了它。现在，我们使用`px.line()`制作一个简单的折线图：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](assets/leds_06in01.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in01.png)'
- en: It’s just as the article says. Luna wasn’t popular at all until the year 2000
    or so. In other words, if someone tells you that their name is Luna, you can take
    a pretty good guess at their age even without any other information about them!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 就像文章所说的那样。Luna在2000年左右几乎不流行。换句话说，即使没有关于他们的其他任何信息，如果有人告诉你他们的名字是Luna，你也可以很好地猜到他们的年龄！
- en: 'Just for fun, here’s the same plot for the name Siri:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 纯属娱乐，这里是同样的Siri名字的图表：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](assets/leds_06in02.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in02.png)'
- en: Tip
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using `.query` is similar to using `.loc` with a boolean series. `query()` has
    more restrictions on filtering but can be convenient as a shorthand.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.query`类似于使用带有布尔系列的`.loc`。`query()`在过滤上有更多的限制，但可以作为一种简写方便使用。
- en: 'Why might the popularity have dropped so suddenly after 2010? Well, Siri happens
    to be the name of Apple’s voice assistant and was introduced in 2011\. Let’s draw
    a line for the year 2011 and take a look:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在2010年后突然变得不那么受欢迎呢？嗯，Siri恰好是苹果的语音助手的名字，于2011年推出。让我们在2011年划一条线，看看：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](assets/leds_06in03.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in03.png)'
- en: It looks like parents don’t want their kids to be confused when other people
    say “Hey Siri” to their phones.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来家长们不希望其他人对他们的手机说“嘿 Siri”时让他们的孩子感到困惑。
- en: In this section, we introduced dataframes in `pandas`. We covered the common
    ways that data scientists subset dataframes—slicing with labels and filtering
    using a boolean condition. In the next section, we explain how to aggregate rows
    together.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们介绍了`pandas`中的数据框。我们涵盖了数据科学家对数据框进行子集切片和使用布尔条件进行筛选的常见方式。在下一节中，我们将解释如何将行聚合在一起。
- en: Aggregating
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: This section introduces operations for aggregating rows in a dataframe. Data
    scientists aggregate rows together to make summaries of data. For instance, a
    dataset containing daily sales can be aggregated to show monthly sales instead.
    This section introduces *grouping* and *pivoting*, two common operations for aggregating
    data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了数据框中行聚合的操作。数据科学家将行聚合在一起以对数据进行摘要。例如，包含每日销售额的数据集可以聚合以显示月销售额。本节介绍了*分组*和*透视*，这两种常见的聚合数据操作。
- en: 'We work with the baby names data, as introduced in the previous section:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用上一节介绍的婴儿姓名数据：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|   | 名字 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | 男 | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | 男 | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | 男 | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | 女 | 5 | 1880 |'
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | 女 | 5 | 1880 |'
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | 女 | 5 | 1880 |'
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Basic Group-Aggregate
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的分组聚合
- en: 'Let’s say we want to find out the total number of babies born as recorded in
    this data. This is simply the sum of the `Count` column:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找出记录在案的总出生婴儿数。这只是 `Count` 列的总和：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summing up the name counts is one simple way to aggregate the data—it combines
    data from multiple rows.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 汇总姓名计数是一种简单的聚合数据的方式——它将多行的数据合并。
- en: 'But let’s say we instead want to answer a more interesting question: are US
    births trending upward over time? To answer this question, we can sum the `Count`
    column within each year rather than taking the sum over the entire dataset. In
    other words, we split the data into groups based on `Year`, then sum the `Count`
    values within each group. This process is depicted in [Figure 6-3](#fig-groupby-births).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们想回答一个更有趣的问题：美国出生率是否随时间而上升？为了回答这个问题，我们可以在每年内对 `Count` 列求和，而不是在整个数据集上进行求和。换句话说，我们根据
    `Year` 将数据分组，然后在每个组内对 `Count` 值求和。这个过程在 [图 6-3](#fig-groupby-births) 中有所描述。
- en: '![fig:groupby-births](assets/leds_0603.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![fig:groupby-births](assets/leds_0603.png)'
- en: Figure 6-3\. A depiction of grouping and then aggregating for example data
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 描述了示例数据的分组和聚合过程
- en: 'We call this operation *grouping* followed by *aggregating*. In `pandas`, we
    write:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个操作称为*分组*，然后是*聚合*。在`pandas`中，我们这样写：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that the code is nearly the same as the nongrouped version, except that
    it starts with a call to `.groupby('Year')`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码几乎与未分组版本相同，只是以 `.groupby('Year')` 开始。
- en: 'The result is a `pd.Series` with the total number of babies born for each year
    in the data. Notice that the index of this series contains the unique `Year` values.
    Now we can plot the counts over time:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个 `pd.Series`，其中包含数据集中每年出生的总婴儿数。请注意，该系列的索引包含唯一的 `Year` 值。现在我们可以绘制随时间变化的计数：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](assets/leds_06in04.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in04.png)'
- en: What do we see in this plot? First, we notice that there seem to be suspiciously
    few babies born before 1920\. One likely explanation is that the SSA was created
    in 1935, so its data for prior births could be less complete.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张图中我们看到了什么？首先，我们注意到1920年之前出生的婴儿似乎非常少。一个可能的解释是社会保障局成立于1935年，因此其之前的出生数据可能不够完整。
- en: We also notice the dip when World War II began in 1939, and the postwar baby
    boomer era from 1946 to 1964.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到了1939年第二次世界大战爆发时的下降以及1946年至1964年间的战后婴儿潮时期。
- en: 'Here’s the basic recipe for grouping in `pandas`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在`pandas`中进行分组的基本步骤：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Example: Using .value_counts()'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：使用`.value_counts()`
- en: 'One of the more common dataframe tasks is to count the number of times every
    unique item in a column appears. For example, we might be interested in the number
    of times each name appears in the following `classroom` dataframe:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框中更常见的任务之一是计算列中每个唯一项出现的次数。例如，我们可能对以下 `classroom` 数据框中每个姓名出现的次数感兴趣：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|   | name |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|   | 姓名 |'
- en: '| --- | --- |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **0** | Eden |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Eden |'
- en: '| **1** | Sachit |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Sachit |'
- en: '| **2** | Eden |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Eden |'
- en: '| **3** | Sachit |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| **3** | Sachit |'
- en: '| **4** | Sachit |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **4** | Sachit |'
- en: '| **5** | Luke |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| **5** | Luke |'
- en: 'One way to do this is to use our grouping recipe with the `.size()` aggregation
    function:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的一种方式是使用我们的分组步骤和`.size()` 聚合函数：
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This operation is so common that `pandas` provides a shorthand—the `.value_counts()`
    method for `pd.Series` objects:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作非常常见，`pandas`提供了一个简写——`.value_counts()` 方法用于 `pd.Series` 对象：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: By default, the `.value_counts()` method will sort the resulting series from
    highest to lowest number, making it convenient to see the most and least common
    values. We point out this method because we use it often in other chapters of
    the book.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`.value_counts()` 方法会对结果系列按照从最高到最低的顺序进行排序，方便查看最常见和最不常见的值。我们提到这个方法是因为在书的其他章节中经常使用它。
- en: Grouping on Multiple Columns
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在多列上进行分组
- en: 'We pass multiple columns into `.groupby` as a list to group by multiple columns
    at once. This is useful when we need to further subdivide our groups. For example,
    we can group by both year and sex to see how many male and female babies were
    born over time:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个列作为列表传递给 `.groupby` 方法，以一次性对多列进行分组。当需要进一步细分我们的组时，这非常有用。例如，我们可以按年份和性别对数据进行分组，以查看随时间变化的男女婴儿出生数：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice how the code closely follows the grouping recipe.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码如何紧随分组的步骤。
- en: 'The `counts_by_year_and_sex` series has what we call a multilevel index with
    two levels, one for each column that was grouped. It’s a bit easier to see if
    we convert the series to a dataframe. The result only has one column:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`counts_by_year_and_sex` 系列具有我们称之为多级索引的两个级别，一个用于每列进行的分组。如果我们将系列转换为数据框，则更容易看到结果只有一列：'
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|   |   | Count |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|   |   | 数量 |'
- en: '| --- | --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Year | Sex |   |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 年份 | 性别 |   |'
- en: '| --- | --- | --- |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **1880** | **F** | 83929 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **1880** | **F** | 83929 |'
- en: '| **M** | 110490 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **M** | 110490 |'
- en: '| **1881** | **F** | 85034 |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **1881** | **F** | 85034 |'
- en: '| **...** | **...** | ... |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **...** | **...** | ... |'
- en: '| **2019** | **M** | 1785527 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **2019** | **M** | 1785527 |'
- en: '| **2020** | **F** | 1581301 |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **2020** | **F** | 1581301 |'
- en: '| **M** | 1706423 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **M** | 1706423 |'
- en: '[PRE56]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'There are two levels to the index because we grouped by two columns. It can
    be a bit tricky to work with multilevel indices, so we can reset the index to
    go back to a dataframe with a single index:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 索引有两个级别，因为我们按两列进行了分组。多级索引可能有点棘手，所以我们可以重置索引，回到具有单个索引的 dataframe：
- en: '[PRE57]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|   | Year | Sex | Count |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|   | 年份 | 性别 | 数量 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **0** | 1880 | F | 83929 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 1880 | F | 83929 |'
- en: '| **1** | 1880 | M | 110490 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 1880 | M | 110490 |'
- en: '| **2** | 1881 | F | 85034 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 1881 | F | 85034 |'
- en: '| **...** | ... | ... | ... |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... |'
- en: '| **279** | 2019 | M | 1785527 |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **279** | 2019 | M | 1785527 |'
- en: '| **280** | 2020 | F | 1581301 |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| **280** | 2020 | F | 1581301 |'
- en: '| **281** | 2020 | M | 1706423 |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| **281** | 2020 | M | 1706423 |'
- en: '[PRE58]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Custom Aggregation Functions
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义聚合函数
- en: 'After grouping, `pandas` gives us flexible ways to aggregate the data. So far,
    we’ve seen how to use `.sum()` after grouping:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 分组后，`pandas` 为我们提供了灵活的方法来聚合数据。到目前为止，我们已经看到了如何在分组后使用 `.sum()`：
- en: '[PRE59]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`pandas` also supplies other aggregation functions, like `.mean()`, `.size()`,
    and `.first()`. Here’s the same grouping using `.max()`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` 还提供其他聚合函数，如 `.mean()`、`.size()` 和 `.first()`。下面是使用 `.max()` 进行相同分组的示例：'
- en: '[PRE61]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: But sometimes `pandas` doesn’t have the exact aggregation function we want to
    use. In these cases, we can define and use a custom aggregation function. `pandas`
    lets us do this through `.agg(fn)`, where `fn` is a function that we define.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时 `pandas` 并没有我们想要使用的确切聚合函数。在这些情况下，我们可以定义并使用自定义聚合函数。`pandas` 通过 `.agg(fn)`
    让我们能够做到这一点，其中 `fn` 是我们定义的函数。
- en: 'For instance, if we want to find the difference between the largest and smallest
    values within each group (the range of the data), we could first define a function
    called `data_range`, then pass that function into `.agg()`. The input to this
    function is a `pd.Series` object containing a single column of data. It gets called
    once for each group:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要找出每个组中最大值和最小值之间的差异（数据的范围），我们可以首先定义一个名为 `data_range` 的函数，然后将该函数传递给 `.agg()`。这个函数的输入是一个包含一列数据的
    `pd.Series` 对象。它会对每个组调用一次：
- en: '[PRE63]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We start by defining a `count_unique` function that counts the number of unique
    values in a series. Then we pass that function into `.agg()`. Since this function
    is short, we could use a lambda instead:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个 `count_unique` 函数，用于计算系列中唯一值的数量。然后我们将该函数传递给 `.agg()`。由于这个函数很短，我们可以使用
    lambda 表达式代替：
- en: '[PRE65]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '![](assets/leds_06in05.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in05.png)'
- en: We see that the number of unique names has generally increased over time, even
    though the number of babies born annually has plateaued since the 1960s.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，尽管自1960年代以来每年出生的婴儿数量已经趋于稳定，但独特名称的数量总体上还是在增加的。
- en: Pivoting
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据透视
- en: 'Pivoting is essentially a convenient way to arrange the results of a group
    and aggregation when grouping with two columns. Earlier in this section we grouped
    the baby names data by year and sex:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 数据透视基本上是在使用两列进行分组时，方便地安排分组和聚合结果的一种方法。在本节的前面，我们将婴儿姓名数据按年份和性别分组：
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '|   |   | Count |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|   |   | 数量 |'
- en: '| --- | --- | --- |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Year | Sex |   |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 年份 | 性别 |   |'
- en: '| --- | --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **1880** | **F** | 83929 |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **1880** | **F** | 83929 |'
- en: '| **M** | 110490 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **M** | 110490 |'
- en: '| **1881** | **F** | 85034 |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **1881** | **F** | 85034 |'
- en: '| **...** | **...** | ... |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **...** | **...** | ... |'
- en: '| **2019** | **M** | 1785527 |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **2019** | **M** | 1785527 |'
- en: '| **2020** | **F** | 1581301 |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **2020** | **F** | 1581301 |'
- en: '| **M** | 1706423 |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| **M** | 1706423 |'
- en: '[PRE69]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This produces a `pd.Series` with the counts. We can also imagine the same data
    with the `Sex` index level “pivoted” to the columns of a dataframe. It’s easier
    to see with an example:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个包含计数的 `pd.Series`。我们还可以想象相同的数据，将 `Sex` 索引级别“透视”到 dataframe 的列中。通过一个例子更容易理解：
- en: '[PRE70]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '| Sex | F | M |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 性别 | F | M |'
- en: '| --- | --- | --- |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Year |   |   |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 年份 |   |   |'
- en: '| --- | --- | --- |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **1880** | 83929 | 110490 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **1880** | 83929 | 110490 |'
- en: '| **1881** | 85034 | 100738 |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **1881** | 85034 | 100738 |'
- en: '| **1882** | 99699 | 113686 |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **1882** | 99699 | 113686 |'
- en: '| **...** | ... | ... |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **2018** | 1676884 | 1810309 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| **2018** | 1676884 | 1810309 |'
- en: '| **2019** | 1651911 | 1785527 |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| **2019** | 1651911 | 1785527 |'
- en: '| **2020** | 1581301 | 1706423 |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| **2020** | 1581301 | 1706423 |'
- en: '[PRE71]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-377
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As we can see in `mf_pivot` table, dataframe indexes can also be named. To read
    the output, it’s important to notice that the dataframe has two columns, M and
    F, stored in an index named Sex. Likewise, the dataframe has 141 rows, each with
    their own label. These labels are stored in an index named Year. Here, Sex and
    Year are the names of the dataframe indexes, and are not row or column labels
    themselves.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在`mf_pivot`表中所见，数据框的索引也可以命名。为了阅读输出，重要的是注意数据框有两列，M和F，存储在名为Sex的索引中。同样，数据框有141行，每行有自己的标签。这些标签存储在名为Year的索引中。这里，Sex和Year是数据框索引的名称，不是行或列标签本身。
- en: Notice that the data values are identical in the pivot table and the table produced
    with `.groupby()`; the values are just arranged differently. Pivot tables are
    useful for quickly summarizing data using two attributes and are often seen in
    articles and papers.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在透视表和使用`.groupby()`生成的表中，数据值是相同的；只是排列方式不同。透视表可以使用两个属性快速汇总数据，通常出现在文章和论文中。
- en: 'The `px.line()` function also happens to work well with pivot tables, since
    the function draws one line for each column of data in the table:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`px.line()`也能很好地与透视表配合使用，因为该函数在表中的每一列数据上绘制一条线：
- en: '[PRE72]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![](assets/leds_06in06.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in06.png)'
- en: This section covered common ways to aggregate data in `pandas` using the `.groupby()`
    function with one or more columns, or using the `pd.pivot_table()` function. In
    the next section, we’ll explain how to join dataframes together.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了使用`pandas`中的`.groupby()`函数以及一个或多个列使用`pd.pivot_table()`函数对数据进行聚合的常见方法。在下一节中，我们将解释如何将数据框连接在一起。
- en: Joining
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: Data scientists very frequently want to *join* two or more dataframes together
    in order to connect data values across dataframes. For instance, an online bookstore
    might have one dataframe with the books each user has ordered and a second dataframe
    with the genres of each book. By joining the two dataframes together, the data
    scientist can see what genres each user prefers.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家经常希望*连接*两个或多个数据框，以便跨数据框连接数据值。例如，一个在线书店可能有一个数据框，其中包含每位用户订购的书籍，以及一个包含每本书流派的第二个数据框。通过将这两个数据框连接起来，数据科学家可以看到每位用户偏爱哪些流派。
- en: We’ll continue looking at the baby names data. We’ll use joins to check some
    trends mentioned in the [*New York Times* article about baby names](https://oreil.ly/qL1dt).
    The article talks about how certain categories of names have become more or less
    popular over time. For instance, it mentions that mythological names like Julius
    and Cassius have become popular, while baby boomer names like Susan and Debbie
    have become less popular. How has the popularity of these categories changed over
    time?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续查看婴儿姓名数据。我们将使用连接来检查[*纽约时报*关于婴儿姓名的文章](https://oreil.ly/qL1dt)中提到的一些趋势。文章讨论了某些类别的姓名如何随时间变得更受欢迎或不受欢迎。例如，它提到了神话般的姓名如Julius和Cassius变得流行，而婴儿潮时期的姓名如Susan和Debbie则变得不那么流行。这些类别的流行度随时间的变化如何？
- en: 'We’ve taken the names and categories in the *NYT* article and put them in a
    small dataframe:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*纽约时报*文章中的名称和类别放入了一个小数据框中：
- en: '[PRE73]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|   | nyt_name | category |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|   | nyt_name | category |'
- en: '| --- | --- | --- |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Lucifer | forbidden |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Lucifer | forbidden |'
- en: '| **1** | Lilith | forbidden |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Lilith | forbidden |'
- en: '| **2** | Danger | forbidden |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Danger | forbidden |'
- en: '| **...** | ... | ... |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... |'
- en: '| **20** | Venus | celestial |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| **20** | Venus | celestial |'
- en: '| **21** | Celestia | celestial |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| **21** | Celestia | celestial |'
- en: '| **22** | Skye | celestial |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| **22** | Skye | celestial |'
- en: '[PRE74]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To see how popular the categories of names are, we join the `nyt` dataframe
    with the `baby` dataframe to get the name counts from `baby`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看名称类别的流行程度，我们将`nyt`数据框与`baby`数据框连接以从`baby`获取名称计数：
- en: '[PRE75]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | F | 5 | 1880 |'
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | F | 5 | 1880 |'
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | F | 5 | 1880 |'
- en: '[PRE76]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For intuition, we can imagine going down each row in `baby` and asking: is
    this name in the `nyt` table? If so, then add the value in the `category` column
    to the row. This is the basic idea behind a join. Let’s look at a few examples
    on smaller dataframes first.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 对于直觉，我们可以想象在 `baby` 的每一行中进行以下询问：这个名称是否在 `nyt` 表中？如果是，那么将 `category` 列的值添加到该行。这就是连接背后的基本思想。让我们首先看一些较小数据框的示例。
- en: Inner Joins
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内连接
- en: 'We start by making smaller versions of the `baby` and `nyt` tables so that
    it’s easier to see what happens when we join tables together:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先制作 `baby` 和 `nyt` 表的较小版本，这样在连接表格时更容易看到发生的情况：
- en: '[PRE77]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '|   | nyt_name | category |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '|   | nyt_name | category |'
- en: '| --- | --- | --- |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Karen | boomer |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Karen | 战斗者 |'
- en: '| **1** | Julius | mythology |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Julius | 神话 |'
- en: '| **2** | Freya | mythology |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Freya | 神话 |'
- en: '[PRE78]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Noah | M | 18252 | 2020 |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Noah | M | 18252 | 2020 |'
- en: '| **1** | Julius | M | 960 | 2020 |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Julius | M | 960 | 2020 |'
- en: '| **2** | Karen | M | 6 | 2020 |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Karen | M | 6 | 2020 |'
- en: '| **3** | Karen | F | 325 | 2020 |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| **3** | Karen | F | 325 | 2020 |'
- en: '| **4** | Noah | F | 305 | 2020 |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| **4** | Noah | F | 305 | 2020 |'
- en: 'To join tables in `pandas`, we’ll use the `.merge()` method:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `pandas` 中连接表，我们将使用 `.merge()` 方法：
- en: '[PRE79]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|   | 名称 | 性别 | 计数 | 年份 | nyt_name | category |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Julius | M | 960 | 2020 | Julius | mythology |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Julius | M | 960 | 2020 | Julius | 神话 |'
- en: '| **1** | Karen | M | 6 | 2020 | Karen | boomer |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Karen | M | 6 | 2020 | Karen | boomer |'
- en: '| **2** | Karen | F | 325 | 2020 | Karen | boomer |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| **   | **2** | Karen | F | 325 | 2020 | Karen | boomer |'
- en: Notice that the new table has the columns of both the `baby_small` and `nyt_small`
    tables. The rows with the name `Noah` are gone. And the remaining rows have their
    matching `category` from `nyt_small`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，新表具有 `baby_small` 和 `nyt_small` 表的列。名称为 `Noah` 的行已消失。其余行从 `nyt_small` 中获得了匹配的
    `category`。
- en: Note
  id: totrans-436
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Readers should also be aware that `pandas` has a `.join()` method for joining
    two dataframes together. However, the `.merge()` method has more flexibility for
    how the dataframes are joined, which is why we focus on `.merge()`. We encourage
    readers to consult the `pandas` documentation for the exact difference between
    the two.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 读者还应注意，`pandas` 具有 `.join()` 方法用于将两个数据框连接在一起。然而，`.merge()` 方法在数据框连接方面更加灵活，因此我们专注于
    `.merge()`。我们鼓励读者查阅 `pandas` 文档，了解这两者之间的确切区别。
- en: When we join two tables together, we tell `pandas` the column(s) from each table
    that we want to use to make the join (the `left_on` and `right_on` arguments).
    `pandas` matches rows together when the values in the joining columns match, as
    shown in [Figure 6-4](#fig-inner-join).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将两个表连接在一起时，我们告诉 `pandas` 我们要使用哪些列（`left_on` 和 `right_on` 参数）来进行连接。当连接列中的值匹配时，`pandas`
    将行进行匹配，如图[6-4](#fig-inner-join)所示。
- en: '![inner-join](assets/leds_0604.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![内连接](assets/leds_0604.png)'
- en: Figure 6-4\. To join, `pandas` matches rows using the values in the `Name` and
    `nyt_name` columns, dropping rows that don’t have matching values
  id: totrans-440
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-4。要进行连接，`pandas` 使用 `Name` 和 `nyt_name` 列中的值进行行匹配，删除没有匹配值的行。
- en: By default, `pandas` does an *inner join*. If either table has rows that don’t
    have matches in the other table, `pandas` drops those rows from the result. In
    this case, the `Noah` rows in `baby_small` don’t have matches in `nyt_small`,
    so they are dropped. Also, the `Freya` row in `nyt_small` doesn’t have matches
    in `baby_small`, so it’s dropped as well. Only the rows with a match in both tables
    stay in the final result.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`pandas` 执行*内连接*。如果任一表中的行在另一表中没有匹配项，`pandas` 将从结果中删除这些行。在本例中，`baby_small`
    中的 `Noah` 行在 `nyt_small` 中没有匹配项，因此被删除。同样，`nyt_small` 中的 `Freya` 行也没有在 `baby_small`
    中找到匹配项，因此也被删除。只有在两个表中都有匹配项的行才会留在最终结果中。
- en: Left, Right, and Outer Joins
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 左连接、右连接和外连接
- en: We sometimes want to keep rows without a match instead of dropping them entirely.
    There are other types of joins—left, right, and outer—that keep rows even when
    they don’t have a match.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望保留没有匹配项的行，而不是完全删除它们。还有其他类型的连接——左连接、右连接和外连接——即使在没有匹配项时也会保留行。
- en: In a *left join*, rows in the left table without a match are kept in the final
    result, as shown in [Figure 6-5](#fig-left-join).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在*左连接*中，保留左表中没有匹配项的行，如图[6-5](#fig-left-join)所示。
- en: '![left-join](assets/leds_0605.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![左连接](assets/leds_0605.png)'
- en: Figure 6-5\. In a left join, rows in the left table that don’t have matching
    values are kept
  id: totrans-446
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-5。在左连接中，保留左表中没有匹配值的行
- en: 'To do a left join in `pandas`, use `how=''left''` in the call to `.merge()`:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`pandas`中进行左连接，调用`.merge()`时使用`how='left'`参数：
- en: '[PRE80]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year | nyt_name | category |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Noah | M | 18252 | 2020 | NaN | NaN |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Noah | M | 18252 | 2020 | NaN | NaN |'
- en: '| **1** | Julius | M | 960 | 2020 | Julius | mythology |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Julius | M | 960 | 2020 | Julius | mythology |'
- en: '| **2** | Karen | M | 6 | 2020 | Karen | boomer |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Karen | M | 6 | 2020 | Karen | boomer |'
- en: '| **3** | Karen | F | 325 | 2020 | Karen | boomer |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| **3** | Karen | F | 325 | 2020 | Karen | boomer |'
- en: '| **4** | Noah | F | 305 | 2020 | NaN | NaN |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| **4** | Noah | F | 305 | 2020 | NaN | NaN |'
- en: Notice that the `Noah` rows are kept in the final table. Since those rows didn’t
    have a match in the `nyt_small` dataframe, the join leaves `NaN` values in the
    `nyt_name` and `category` columns. Also, notice that the `Freya` row in `nyt_small`
    is still dropped.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Noah`行在最终表中被保留。由于这些行在`nyt_small`数据框中没有匹配，连接在`nyt_name`和`category`列中留下`NaN`值。同时注意，`nyt_small`中的`Freya`行仍然被丢弃。
- en: 'A *right join* works similarly to the left join, except that nonmatching rows
    in the right table are kept instead of the left table:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '*右连接*与左连接类似，但保留右表中没有匹配的行而不是左表：'
- en: '[PRE81]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year | nyt_name | category |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Karen | M | 6.0 | 2020.0 | Karen | boomer |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Karen | M | 6.0 | 2020.0 | Karen | boomer |'
- en: '| **1** | Karen | F | 325.0 | 2020.0 | Karen | boomer |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Karen | F | 325.0 | 2020.0 | Karen | boomer |'
- en: '| **2** | Julius | M | 960.0 | 2020.0 | Julius | mythology |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Julius | M | 960.0 | 2020.0 | Julius | mythology |'
- en: '| **3** | NaN | NaN | NaN | NaN | Freya | mythology |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| **3** | NaN | NaN | NaN | NaN | Freya | mythology |'
- en: 'Finally, an *outer join* keeps rows from both tables even when they don’t have
    a match:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*外连接*保留两个表中的行，即使它们没有匹配：
- en: '[PRE82]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year | nyt_name | category |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Noah | M | 18252.0 | 2020.0 | NaN | NaN |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Noah | M | 18252.0 | 2020.0 | NaN | NaN |'
- en: '| **1** | Noah | F | 305.0 | 2020.0 | NaN | NaN |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | F | 305.0 | 2020.0 | NaN | NaN |'
- en: '| **2** | Julius | M | 960.0 | 2020.0 | Julius | mythology |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Julius | M | 960.0 | 2020.0 | Julius | mythology |'
- en: '| **3** | Karen | M | 6.0 | 2020.0 | Karen | boomer |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| **3** | Karen | M | 6.0 | 2020.0 | Karen | boomer |'
- en: '| **4** | Karen | F | 325.0 | 2020.0 | Karen | boomer |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| **4** | Karen | F | 325.0 | 2020.0 | Karen | boomer |'
- en: '| **5** | NaN | NaN | NaN | NaN | Freya | mythology |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| **5** | NaN | NaN | NaN | NaN | Freya | mythology |'
- en: 'Example: Popularity of NYT Name Categories'
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：纽约时报名字类别的流行程度
- en: 'Now let’s return to the full dataframes `baby` and `nyt`. `.head()` slices
    out the first few rows, which is convenient for saving space:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到完整的数据框`baby`和`nyt`。`.head()`用于获取前几行数据，节省空间：
- en: '[PRE83]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '[PRE84]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|   | nyt_name | category |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '|   | nyt_name | category |'
- en: '| --- | --- | --- |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **0** | Lucifer | forbidden |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Lucifer | forbidden |'
- en: '| **1** | Lilith | forbidden |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Lilith | forbidden |'
- en: 'We want to know how the popularity of name categories in `nyt` has changed
    over time. To answer this question:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要了解`nyt`中名字类别的流行度随时间的变化。为了回答这个问题：
- en: Inner join `baby` with `nyt`.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`baby`和`nyt`进行内连接。
- en: Group the table by `category` and `Year`.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表按`category`和`Year`分组。
- en: 'Aggregate the counts using a sum:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用求和对计数进行聚合：
- en: '[PRE85]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '|   | category | Year | Count |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '|   | category | Year | Count |'
- en: '| --- | --- | --- | --- |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **0** | boomer | 1880 | 292 |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| **0** | boomer | 1880 | 292 |'
- en: '| **1** | boomer | 1881 | 298 |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| **1** | boomer | 1881 | 298 |'
- en: '| **2** | boomer | 1882 | 326 |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| **2** | boomer | 1882 | 326 |'
- en: '| **...** | ... | ... | ... |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... |'
- en: '| **647** | mythology | 2018 | 2944 |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| **647** | mythology | 2018 | 2944 |'
- en: '| **648** | mythology | 2019 | 3320 |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| **648** | mythology | 2019 | 3320 |'
- en: '| **649** | mythology | 2020 | 3489 |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| **649** | mythology | 2020 | 3489 |'
- en: '[PRE86]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now we can plot the popularity of `boomer` names and `mythology` names:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以绘制`boomer`名字和`mythology`名字的流行度：
- en: '![](assets/leds_06in07.png)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in07.png)'
- en: As the *NYT* article claims, baby boomer names have become less popular since
    2000, while mythology names have become more popular.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 据*纽约时报*文章称，自2000年以来，婴儿潮一代的名字变得不太流行，而神话名字则变得更受欢迎。
- en: 'We can also plot the popularities of all the categories at once. Take a look
    at the following plots and see whether they support the claims made in the *New
    York Times* article:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以一次性绘制所有类别的流行度。查看下面的图表，看看它们是否支持*纽约时报*文章中的观点：
- en: '![](assets/leds_06in08.png)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in08.png)'
- en: In this section, we introduced joins for dataframes. When joining dataframes
    together, we match rows using the `.merge()` function. It’s important to consider
    the type of join (inner, left, right, or outer) when joining dataframes. In the
    next section, we’ll explain how to transform values in a dataframe.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了数据框的连接操作。当将数据框连接在一起时，我们使用`.merge()`函数匹配行。在连接数据框时，考虑连接的类型（内部、左侧、右侧或外部）是很重要的。在下一节中，我们将解释如何转换数据框中的值。
- en: Transforming
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换中
- en: 'Data scientists transform dataframe columns when they need to change each value
    in a feature in the same way. For example, if a feature contains heights of people
    in feet, a data scientist might want to transform the heights to centimeters.
    In this section, we’ll introduce *apply*, an operation that transforms columns
    of data using a user-defined function:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据科学家需要以相同的方式更改特征中的每个值时，他们会转换数据框列。例如，如果一个特征包含以英尺表示的人的身高，数据科学家可能希望将身高转换为厘米。在本节中，我们将介绍*apply*，这是一种使用用户定义函数转换数据列的操作：
- en: '[PRE87]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '|   | Name | Sex | Count | Year |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 |'
- en: '| **1** | Noah | M | 18252 | 2020 |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 |'
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | F | 5 | 1880 |'
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | F | 5 | 1880 |'
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | F | 5 | 1880 |'
- en: '[PRE88]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In the baby names *New York Times* article, Pamela mentions that names starting
    with the letter L or K became popular after 2000\. On the other hand, names starting
    with the letter J peaked in popularity in the 1970s and 1980s and dropped off
    in popularity since. We can verify these claims using the `baby` dataset.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在*纽约时报*的婴儿名字文章中，帕梅拉提到，以字母L或K开头的名字在2000年后变得流行。另一方面，以字母J开头的名字在1970年代和1980年代达到了流行高峰，但自那以后流行度下降。我们可以使用`baby`数据集验证这些说法。
- en: 'We approach this problem using the following steps:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下步骤解决这个问题：
- en: Transform the `Name` column into a new column that contains the first letters
    of each value in `Name`.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Name`列转换为一个新列，其中包含每个`Name`值的第一个字母。
- en: Group the dataframe by the first letter and year.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据第一个字母和年份对数据框进行分组。
- en: Aggregate the name counts by summing.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过求和聚合名称计数。
- en: To complete the first step, we’ll *apply* a function to the `Name` column.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成第一步，我们将*应用*一个函数到`Name`列。
- en: Apply
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用
- en: '`pd.Series` objects contain an `.apply()` method that takes in a function and
    applies it to each value in the series. For instance, to find the lengths of each
    name, we apply the `len` function:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series`对象包含一个`.apply()`方法，该方法接受一个函数并将其应用于系列中的每个值。例如，要找出每个名称的长度，我们应用`len`函数：'
- en: '[PRE89]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To extract the first letter of each name, we define a custom function and pass
    it into `.apply()`. The argument to the function is an individual value in the
    series:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取每个名称的第一个字母，我们定义一个自定义函数，并将其传递给`.apply()`。函数的参数是系列中的一个单独值：
- en: '[PRE91]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Using `.apply()` is similar to using a `for` loop. The preceding code is roughly
    equivalent to writing:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.apply()`类似于使用`for`循环。前面的代码大致相当于写成：
- en: '[PRE93]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now we can assign the first letters to a new column in the dataframe:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将首字母分配给数据框中的新列：
- en: '[PRE94]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '|   | Name | Sex | Count | Year | Firsts |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '|   | Name | Sex | Count | Year | Firsts |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **0** | Liam | M | 19659 | 2020 | L |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| **0** | Liam | M | 19659 | 2020 | L |'
- en: '| **1** | Noah | M | 18252 | 2020 | N |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| **1** | Noah | M | 18252 | 2020 | N |'
- en: '| **2** | Oliver | M | 14147 | 2020 | O |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| **2** | Oliver | M | 14147 | 2020 | O |'
- en: '| **...** | ... | ... | ... | ... | ... |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... | ... |'
- en: '| **2020719** | Verona | F | 5 | 1880 | V |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| **2020719** | Verona | F | 5 | 1880 | V |'
- en: '| **2020720** | Vertie | F | 5 | 1880 | V |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| **2020720** | Vertie | F | 5 | 1880 | V |'
- en: '| **2020721** | Wilma | F | 5 | 1880 | W |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| **2020721** | Wilma | F | 5 | 1880 | W |'
- en: '[PRE95]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Note
  id: totrans-548
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'To create a new column in a dataframe, you might also encounter this syntax:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据框中创建一个新列，您可能还会遇到以下语法：
- en: '[PRE96]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This mutates the `baby` table by adding a new column called `Firsts`. In the
    preceding code, we use `.assign()`, which doesn’t mutate the `baby` table itself;
    it creates a new dataframe instead. Mutating dataframes isn’t wrong but can be
    a common source of bugs. Because of this, we’ll mostly use `.assign()` in this
    book.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这会通过添加一个名为 `Firsts` 的新列来改变 `baby` 表。在前面的代码中，我们使用了 `.assign()`，它不会改变 `baby` 表本身，而是创建了一个新的数据框。改变数据框并不是错误的，但可能是错误的常见源泉。因此，在本书中，我们大多数情况下会使用
    `.assign()`。
- en: 'Example: Popularity of “L” Names'
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例： “L” 开头名字的流行程度
- en: 'Now we can use the `letters` dataframe to see the popularity of first letters
    over time:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `letters` 数据框来查看首字母随时间变化的流行程度：
- en: '[PRE97]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '|   | Firsts | Year | Count |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '|   | Firsts | Year | Count |'
- en: '| --- | --- | --- | --- |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **0** | A | 1880 | 16740 |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| **0** | A | 1880 | 16740 |'
- en: '| **1** | A | 1881 | 16257 |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| **1** | A | 1881 | 16257 |'
- en: '| **2** | A | 1882 | 18790 |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| **2** | A | 1882 | 18790 |'
- en: '| **...** | ... | ... | ... |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... |'
- en: '| **3638** | Z | 2018 | 55996 |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| **3638** | Z | 2018 | 55996 |'
- en: '| **3639** | Z | 2019 | 55293 |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| **3639** | Z | 2019 | 55293 |'
- en: '| **3640** | Z | 2020 | 54011 |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| **3640** | Z | 2020 | 54011 |'
- en: '[PRE98]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '![](assets/leds_06in09.png)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in09.png)'
- en: The plot shows that L names were popular in the 1960s, dipped in the decades
    after, but have indeed resurged in popularity since 2000.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表显示，在1960年代，“L”开头的名字很流行，在此后的几十年里有所下降，但自2000年以来确实重新流行起来。
- en: What about J names?
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，“J” 开头的名字怎么样？
- en: '[PRE100]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '![](assets/leds_06in10.png)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_06in10.png)'
- en: The *NYT* article says that J names were popular in the 1970s and ’80s. The
    plot agrees and shows that they have become less popular since 2000.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '*纽约时报* 的文章指出，“J”开头的名字在1970年代和80年代很流行。图表也证实了这一点，并显示自2000年以来它们变得不那么流行。'
- en: The Price of Apply
  id: totrans-572
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`.apply()` 的代价'
- en: The power of `.apply()` is its flexibility—you can call it with any function
    that takes in a single data value and outputs a single data value.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`.apply()` 的强大之处在于其灵活性——你可以用任何接受单个数据值并输出单个数据值的函数来调用它。'
- en: 'Its flexibility has a price, though. Using `.apply()` can be slow, since `pandas`
    can’t optimize arbitrary functions. For example, using `.apply()` for numeric
    calculations is much slower than using vectorized operations directly on `pd.Series`
    objects:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它的灵活性也有一个代价。使用 `.apply()` 可能会很慢，因为 `pandas` 不能优化任意函数。例如，对于数值计算，使用 `.apply()`
    比直接在 `pd.Series` 对象上使用向量化操作要慢得多：
- en: '[PRE101]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The version using `.apply()` is 30 times slower! For numeric operations in particular,
    we recommend operating on `pd.Series` objects directly.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `.apply()` 的版本要慢30倍！特别是对于数值计算，我们建议直接在 `pd.Series` 对象上进行向量化操作。
- en: In this section, we introduced data transformations. To transform values in
    a dataframe, we commonly use the `.apply()` and `.assign()` functions. In the
    next section, we’ll compare dataframes with other ways to represent and manipulate
    data tables.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了数据转换。为了在数据框中转换值，我们通常使用 `.apply()` 和 `.assign()` 函数。在下一节中，我们将比较数据框与其他表示和操作数据表的方法。
- en: How Are Dataframes Different from Other Data Representations?
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据框与其他数据表示方式有何不同？
- en: Dataframes are just one way to represent data stored in a table. In practice,
    data scientists encounter many other types of data tables, like spreadsheets,
    matrices, and relations. In this section, we’ll compare and contrast the dataframe
    with other representations to explain why dataframes have become so widely used
    for data analysis. We’ll also point out scenarios where other representations
    might be more appropriate.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框只是表示表中存储数据的一种方式。在实践中，数据科学家会遇到许多其他类型的数据表，如电子表格、矩阵和关系表。在本节中，我们将比较数据框与其他表示方式，解释为什么数据框在数据分析中如此广泛使用。我们还将指出其他表示方式可能更合适的场景。
- en: Dataframes and Spreadsheets
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框和电子表格
- en: Spreadsheets are computer applications in which users can enter data in a grid
    and use formulas to perform calculations. One well-known example today is Microsoft
    Excel, although spreadsheets date back to at least 1979 with [VisiCalc](https://doi.org/10.1109/MAHC.2007.4338439).
    Spreadsheets make it easy to see and directly manipulate data since spreadsheet
    formulas can automatically recalculate results whenever the data change. In contrast,
    dataframe code typically needs to be manually rerun when datasets are updated.
    These properties make spreadsheets highly popular—by [a 2005 estimate](https://doi.org/10.1109/VLHCC.2005.34),
    there are over 55 million spreadsheet users compared to 3 million professional
    programmers in industry.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格是计算机应用程序，用户可以在网格中输入数据并使用公式进行计算。今天一个众所周知的例子是微软Excel，尽管电子表格可以追溯到至少1979年的[VisiCalc](https://doi.org/10.1109/MAHC.2007.4338439)。电子表格使得直接查看和操作数据变得很容易，因为电子表格公式可以在数据更改时自动重新计算结果。相比之下，数据框代码通常需要在数据集更新时手动重新运行。这些特性使得电子表格非常受欢迎——根据[2005年的估计](https://doi.org/10.1109/VLHCC.2005.34)，有超过5500万的电子表格用户，而行业中只有300万专业程序员。
- en: Dataframes have several key advantages over spreadsheets. Writing dataframe
    code in a computational notebook like Jupyter naturally produces a data lineage.
    Someone who opens the notebook can see the input files for the notebook and how
    the data were changed. Spreadsheets do not make a data lineage visible; if a person
    manually edits data values in a cell, it can be difficult for future users to
    see which values were manually edited and how they were edited. Dataframes can
    handle larger datasets than spreadsheets, and users can also use distributed programming
    tools to work with huge datasets that would be very hard to load into a spreadsheet.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框比电子表格有几个关键优势。在类似Jupyter的计算笔记本中编写数据框代码会自然地产生数据谱系。打开笔记本的人可以看到笔记本的输入文件以及数据是如何更改的。电子表格不显示数据谱系；如果一个人手动编辑单元格中的数据值，将很难让未来的用户看到哪些值是手动编辑的以及如何编辑的。数据框可以处理比电子表格更大的数据集，用户还可以使用分布式编程工具来处理很难加载到电子表格中的大数据集。
- en: Dataframes and Matrices
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框和矩阵
- en: 'A matrix is a two-dimensional array of data used primarily for linear algebra
    operations. In this next example, <math><mrow><mi mathvariant="bold">X</mi></mrow></math>
    is a matrix with three rows and two columns:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是用于线性代数操作的二维数据数组。在下一个例子中，<math><mrow><mi mathvariant="bold">X</mi></mrow></math>是一个具有三行两列的矩阵：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable displaystyle="true" rowspacing="3pt"><mtr><mtd><mrow><mi
    mathvariant="bold">X</mi></mrow> <mo>=</mo> <mrow><mo>[</mo> <mtable columnalign="center"
    columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr></mtable> <mo>]</mo></mrow></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable displaystyle="true" rowspacing="3pt"><mtr><mtd><mrow><mi
    mathvariant="bold">X</mi></mrow> <mo>=</mo> <mrow><mo>[</mo> <mtable columnalign="center"
    columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr></mtable> <mo>]</mo></mrow></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: Matrices are mathematical objects defined by the operators that they allow.
    For instance, matrices can be added or multiplied together. Matrices also have
    a transpose. These operators have very useful properties that data scientists
    rely on for statistical modeling.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是由它们允许的运算符定义的数学对象。例如，矩阵可以相加或相乘。矩阵也有转置。这些运算符具有数据科学家在统计建模中依赖的非常有用的特性。
- en: One important difference between a matrix and a dataframe is that when matrices
    are treated as mathematical objects, they can only contain numbers. Dataframes,
    on the other hand, can also have other types of data, like text. This makes dataframes
    more useful for loading and processing raw data that may contain all kinds of
    data types. In practice, data scientists often load data into dataframes, then
    manipulate the data into matrix form. In this book, we’ll generally use dataframes
    for exploratory data analysis and data cleaning, then process the data into matrices
    for machine learning models.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵和数据框之间的一个重要区别是，当矩阵被视为数学对象时，它们只能包含数字。另一方面，数据框还可以包含文本等其他类型的数据。这使得数据框更适合加载和处理可能包含各种数据类型的原始数据。实际上，数据科学家经常将数据加载到数据框中，然后将数据处理成矩阵形式。在本书中，我们通常使用数据框进行探索性数据分析和数据清洗，然后将数据处理成矩阵形式用于机器学习模型。
- en: Note
  id: totrans-591
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Data scientists refer to matrices not only as mathematical objects but also
    as program objects. For instance, the R programming language has a matrix object,
    while in Python we could represent a matrix using a two-dimensional `numpy` array.
    Matrices as implemented in Python and R can contain other data types besides numbers,
    but they lose mathematical properties when doing so. This is yet another example
    of how domains can refer to different things with the same term.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家将矩阵称为数学对象，也称为程序对象。例如，R编程语言有一个矩阵对象，而在Python中，我们可以使用二维的`numpy`数组表示矩阵。在Python和R中实现的矩阵可以包含除了数字以外的其他数据类型，但这样做会丧失数学属性。这是领域可以用同一术语指称不同事物的另一个例子。
- en: Dataframes and Relations
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据框和关系
- en: A relation is a data table representation used in database systems, especially
    SQL systems like SQLite and PostgreSQL. (We cover relations and SQL in [Chapter 7](ch07.html#ch-sql).)
    Relations share many similarities with dataframes; both use rows to represent
    records and columns to represent features. Both have column names, and data within
    a column have the same type.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 关系是数据库系统中使用的数据表表示形式，特别是像SQLite和PostgreSQL这样的SQL系统。（我们在[第7章](ch07.html#ch-sql)中介绍了关系和SQL。）关系与数据框架有许多相似之处；它们都使用行来表示记录，列来表示特征。两者都有列名，并且列内的数据具有相同的类型。
- en: One key advantage of dataframes is that they don’t *require* rows to represent
    records and columns to represent features. Many times, raw data don’t come in
    a convenient format that can directly be put into a relation. In these scenarios,
    data scientists use the dataframe to load and process data since dataframes are
    more flexible in this regard. Often, data scientists will load raw data into a
    dataframe, then process the data into a format that can easily be stored in a
    relation.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框架的一个关键优势在于，它们不*需要*行来表示记录，也不需要列来表示特征。许多时候，原始数据并不以直接放入关系中的方便格式出现。在这些情况下，数据科学家使用数据框架来加载和处理数据，因为数据框架在这方面更加灵活。通常，数据科学家会将原始数据加载到数据框架中，然后处理数据，使其能够轻松地存储在关系中。
- en: One key advantage that relations have over dataframes is that relations are
    used by relational database systems like [PostgreSQL](https://oreil.ly/3zXyH),
    which have highly useful features for data storage and management. Consider a
    data scientist at a company that runs a large social media website. The database
    might hold data that is far too large to read into a `pandas` dataframe all at
    once; instead, data scientists use SQL queries to subset and aggregate data since
    database systems are more capable of handling large datasets. Also, website users
    constantly update their data by making posts, uploading pictures, and editing
    their profiles. Here, database systems let data scientists reuse their existing
    SQL queries to update their analyses with the latest data rather than having to
    repeatedly download large CSV files.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库系统（如[PostgreSQL](https://oreil.ly/3zXyH)）比数据框架具有的一个关键优势在于，它们具有非常有用的数据存储和管理功能。考虑一家运营大型社交媒体网站的数据科学家。数据库可能包含的数据量太大，无法一次性读入`pandas`数据框架；因此，数据科学家使用SQL查询来子集化和聚合数据，因为数据库系统更能处理大型数据集。此外，网站用户通过发布帖子、上传图片和编辑个人资料不断更新其数据。在这种情况下，数据库系统让数据科学家能够重复使用现有的SQL查询更新他们的分析，而不是反复下载大型CSV文件。
- en: Summary
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explained what dataframes are, why they’re useful, and how
    to work with them using `pandas` code. Subsetting, aggregating, joining, and transforming
    are useful in nearly every data analysis. We’ll rely on these operations often
    in the rest of the book, especially in Chapters [8](ch08.html#ch-files), [9](ch09.html#ch-wrangling),
    and [10](ch10.html#ch-eda).
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了数据框架是什么，它们为什么有用，以及如何使用`pandas`代码与它们一起工作。子集化、聚合、连接和转换几乎在每个数据分析中都是有用的。在本书的其余部分中，特别是第[8](ch08.html#ch-files)、第[9](ch09.html#ch-wrangling)和第[10](ch10.html#ch-eda)章中，我们将经常依赖这些操作。
