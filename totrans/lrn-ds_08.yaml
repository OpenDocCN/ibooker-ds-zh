- en: Chapter 6\. Working with Dataframes Using pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data scientists work with data stored in tables. This chapter introduces *dataframes*,
    one of the most widely used ways to represent data tables. We also introduce `pandas`,
    the standard Python package for working with dataframes. Here is an example of
    a dataframe that holds information about popular dog breeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | grooming | food_cost | kids | size |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| breed |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Labrador Retriever** | weekly | 466.0 | high | medium |'
  prefs: []
  type: TYPE_TB
- en: '| **German Shepherd** | weekly | 466.0 | medium | large |'
  prefs: []
  type: TYPE_TB
- en: '| **Beagle** | daily | 324.0 | high | small |'
  prefs: []
  type: TYPE_TB
- en: '| **Golden Retriever** | weekly | 466.0 | high | medium |'
  prefs: []
  type: TYPE_TB
- en: '| **Yorkshire Terrier** | daily | 324.0 | low | small |'
  prefs: []
  type: TYPE_TB
- en: '| **Bulldog** | weekly | 466.0 | medium | medium |'
  prefs: []
  type: TYPE_TB
- en: '| **Boxer** | weekly | 466.0 | high | medium |'
  prefs: []
  type: TYPE_TB
- en: In a dataframe, each row represents a single record—in this case, a single dog
    breed. Each column represents a feature about the record—for example, the grooming
    column represents how often each dog breed needs to be groomed.
  prefs: []
  type: TYPE_NORMAL
- en: Dataframes have labels for both columns and rows. For instance, this dataframe
    has a column labeled grooming and a row labeled German Shepherd. The columns and
    rows of a dataframe are ordered—we can refer to the Labrador Retriever row as
    the first row of the dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: Within a column, data have the same type. For instance, the cost of food contains
    numbers, and the size of the dog consists of categories. But data types can be
    different within a row.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these properties, dataframes enable all sorts of useful operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Data scientists often find themselves working with people from different backgrounds
    who use different terms. For instance, computer scientists say that the columns
    of a dataframe represent *features* of the data, while statisticians call them
    *variables* instead.
  prefs: []
  type: TYPE_NORMAL
- en: Other times, people use the same term to refer to slightly different ideas.
    *Data types* in a programming sense refers to how a computer stores data internally.
    For instance, the `size` column has a string data type in Python. But from a statistical
    point of view, the type of the `size` column is ordered categorical data (ordinal
    data). We talk more about this specific distinction in [Chapter 10](ch10.html#ch-eda).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we introduce common dataframe operations. Data scientists
    use the `pandas` library when working with dataframes in Python. First, we explain
    the main objects that `pandas` provides: the `DataFrame` and `Series` classes.
    Then we show how to use `pandas` to perform common data manipulation tasks, like
    slicing, filtering, sorting, grouping, and joining.'
  prefs: []
  type: TYPE_NORMAL
- en: Subsetting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section introduces operations for taking subsets of dataframes. When data
    scientists first read in a dataframe, they often want to subset the specific data
    that they plan to use. For example, a data scientist can *slice* out the 10 relevant
    features from a dataframe with hundreds of columns. Or they can *filter* a dataframe
    to remove rows with incomplete data. For the rest of this chapter, we demonstrate
    dataframe operations using a dataframe of baby names.
  prefs: []
  type: TYPE_NORMAL
- en: Data Scope and Question
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s a [2021 *New York Times* article](https://oreil.ly/qL1dt) that talks
    about Prince Harry and Meghan Markle’s unique choice for their new baby daughter’s
    name: Lilibet. The article has an interview with Pamela Redmond, an expert on
    baby names, who talks about interesting trends in how people name their kids.
    For example, she says that names that start with the letter L have become very
    popular in recent years, while names that start with the letter J were most popular
    in the 1970s and 1980s. Are these claims reflected in data? We can use `pandas`
    to find out.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the package as `pd`, the canonical abbreviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a dataset of baby names stored in a comma-separated values (CSV) file
    called *babynames.csv*. We use the `pd.read_csv` function to read the file as
    a `pandas.DataFrame` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The data in the `baby` table comes from the [US Social Security Administration
    (SSA)](https://oreil.ly/EhTlP), which records the baby name and birth sex for
    birth certificate purposes. The SSA makes the baby names data available on its
    website. We’ve loaded this data into the `baby` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SSA website has a [page](https://oreil.ly/jzCVF) that describes the data
    in more detail. We won’t go in depth in this chapter about the data’s limitations,
    but we’ll point out this relevant information from the website:'
  prefs: []
  type: TYPE_NORMAL
- en: All names are from Social Security card applications for births that occurred
    in the United States after 1879\. Note that many people born before 1937 never
    applied for a Social Security card, so their names are not included in our data.
    For others who did apply, our records may not show the place of birth, and again
    their names are not included in our data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All data are from a 100% sample of our records on Social Security card applications
    as of March 2021.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s also important to point out that at the time of this writing, the SSA dataset
    only provides the binary options of male and female. We hope that in the future,
    national datasets like this one will provide more inclusive options.
  prefs: []
  type: TYPE_NORMAL
- en: Dataframes and Indices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s examine the `baby` dataframe in more detail. A dataframe has rows and
    columns. Every row and column has a label, as highlighted in [Figure 6-1](#fig-baby-labels).
  prefs: []
  type: TYPE_NORMAL
- en: '![baby-labels](assets/leds_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. The `baby` dataframe has labels for both rows and columns (boxed)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, `pandas` assigns row labels as incrementing numbers starting from
    0\. In this case, the data at the row labeled `0` and column labeled `Name` has
    the data `'Liam'`.
  prefs: []
  type: TYPE_NORMAL
- en: Dataframes can also have strings as row labels. [Figure 6-2](#fig-dog-labels)
    shows a dataframe of dog data where the row labels are strings.
  prefs: []
  type: TYPE_NORMAL
- en: '![dog-labels](assets/leds_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Row labels in dataframes can also be strings, as in this example,
    in which each row is labeled using the dog breed name
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The row labels have a special name. We call them the *index* of a dataframe,
    and `pandas` stores the row labels in a special `pd.Index` object. We won’t discuss
    the `pd.Index` object since it’s less common to manipulate the index itself. For
    now, it’s important to remember that even though the index looks like a column
    of data, the index really represents row labels, not data. For instance, the dataframe
    of dog breeds has four columns of data, not five, since the index doesn’t count
    as a column.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Slicing* is an operation that creates a new dataframe by taking a subset of
    rows or columns out of another dataframe. Think about slicing a tomato—slices
    can go both vertically and horizontally. To take slices of a dataframe in `pandas`,
    we use the `.loc` and `.iloc` properties. Let’s start with `.loc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full `baby` dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`.loc` lets us select rows and columns using their labels. For example, to
    get the data in the row labeled `1` and column labeled `Name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that `.loc` needs square brackets; running `baby.loc(1, 'Name')` will
    result in an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To slice out multiple rows or columns, we can use Python slice syntax instead
    of individual values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Elijah | M | 13034 |'
  prefs: []
  type: TYPE_TB
- en: 'To get an entire column of data, we can pass an empty slice as the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the output of this doesn’t look like a dataframe, and it’s not.
    Selecting out a single row or column of a dataframe produces a `pd.Series` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What’s the difference between a `pd.Series` object and a `pd.DataFrame` object?
    Essentially, a `pd.DataFrame` is two-dimensional—it has rows and columns and represents
    a table of data. A `pd.Series` is one-dimensional—it represents a list of data.
    `pd.Series` and `pd.DataFrame` objects have many methods in common, but they really
    represent two different things. Confusing the two can cause bugs and confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To select specific columns of a dataframe, pass a list into `.loc`. Here’s
    the original dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting columns is very common, so there’s a shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | 19659 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | 18252 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | 14147 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | 5 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Slicing using `.iloc` works similarly to `.loc`, except that `.iloc` uses the
    *positions* of rows and columns rather than labels. It’s easiest to show the difference
    between `.iloc` and `.loc` when the dataframe index has strings, so for demonstration
    purposes, let’s look at a dataframe with information on dog breeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|   | grooming | food_cost | kids | size |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| breed |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Labrador Retriever** | weekly | 466.0 | high | medium |'
  prefs: []
  type: TYPE_TB
- en: '| **German Shepherd** | weekly | 466.0 | medium | large |'
  prefs: []
  type: TYPE_TB
- en: '| **Beagle** | daily | 324.0 | high | small |'
  prefs: []
  type: TYPE_TB
- en: '| **Golden Retriever** | weekly | 466.0 | high | medium |'
  prefs: []
  type: TYPE_TB
- en: '| **Yorkshire Terrier** | daily | 324.0 | low | small |'
  prefs: []
  type: TYPE_TB
- en: '| **Bulldog** | weekly | 466.0 | medium | medium |'
  prefs: []
  type: TYPE_TB
- en: '| **Boxer** | weekly | 466.0 | high | medium |'
  prefs: []
  type: TYPE_TB
- en: 'To get the first three rows and the first two columns by position, use `.iloc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|   | grooming | food_cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| breed |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Labrador Retriever** | weekly | 466.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **German Shepherd** | weekly | 466.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **Beagle** | daily | 324.0 |'
  prefs: []
  type: TYPE_TB
- en: 'The same operation using `.loc` requires us to use the dataframe labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|   | grooming | food_cost |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| breed |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Labrador Retriever** | weekly | 466.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **German Shepherd** | weekly | 466.0 |'
  prefs: []
  type: TYPE_TB
- en: '| **Beagle** | daily | 324.0 |'
  prefs: []
  type: TYPE_TB
- en: Next, we’ll look at filtering rows.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Rows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve shown how to use `.loc` and `.iloc` to slice a dataframe using
    labels and positions.
  prefs: []
  type: TYPE_NORMAL
- en: However, data scientists often want to *filter* rows—they want to take subsets
    of rows using some criteria. Let’s say we want to find the most popular baby names
    in 2020\. To do this, we can filter rows to keep only the rows where the `Year`
    is 2020.
  prefs: []
  type: TYPE_NORMAL
- en: To filter, we’d like to check whether each value in the `Year` column is equal
    to 1970 and then keep only those rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare each value in `Year`, we slice out the column and make a boolean
    comparison (this is similar to what we’d do with a `numpy` array). Here’s the
    dataframe for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that a boolean comparison on a `Series` gives a `Series` of booleans.
    This is nearly equivalent to writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: But the boolean comparison is easier to write and much faster to execute than
    a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we tell `pandas` to keep only the rows where the comparison evaluated to
    `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **31267** | Zylynn | F | 5 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **31268** | Zynique | F | 5 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **31269** | Zynlee | F | 5 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Passing a `Series` of booleans into `.loc` only keeps rows where the `Series`
    has a `True` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filtering has a shorthand. This computes the same table as the preceding snippet
    without using `.loc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **31267** | Zylynn | F | 5 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **31268** | Zynique | F | 5 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **31269** | Zynlee | F | 5 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to find the most common names in 2020, sort the dataframe by `Count`
    in descending order. Wrapping a long expression in parentheses lets us easily
    add line breaks to make it more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **13911** | Emma | F | 15581 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **13912** | Ava | F | 13084 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Elijah | M | 13034 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **13913** | Charlotte | F | 13003 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: We see that Liam, Noah, and Emma were the most popular baby names in 2020.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: How Recently Has Luna Become a Popular Name?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *New York Times* article mentions that the name Luna was almost nonexistent
    before 2000 but has since grown to become a very popular name for girls. When
    exactly did Luna become popular? We can check this using slicing and filtering.
    When approaching a data manipulation task, we recommend breaking the problem down
    into smaller steps. For example, we could think:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Filter: keep only rows with `''Luna''` in the `Name` column.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Filter: keep only rows with `''F''` in the `Sex` column.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Slice: keep the `Count` and `Year` columns.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now it’s a matter of translating each step into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **13923** | 7770 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **45366** | 7772 | 2019 |'
  prefs: []
  type: TYPE_TB
- en: '| **77393** | 6929 | 2018 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2014083** | 17 | 1883 |'
  prefs: []
  type: TYPE_TB
- en: '| **2018187** | 18 | 1881 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020223** | 15 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this book, we use a library called `plotly` for plotting. We won’t cover
    plotting in depth here since we talk more about it in [Chapter 11](ch11.html#ch-viz).
    For now, we use `px.line()` to make a simple line plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_06in01.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s just as the article says. Luna wasn’t popular at all until the year 2000
    or so. In other words, if someone tells you that their name is Luna, you can take
    a pretty good guess at their age even without any other information about them!
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for fun, here’s the same plot for the name Siri:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_06in02.png)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using `.query` is similar to using `.loc` with a boolean series. `query()` has
    more restrictions on filtering but can be convenient as a shorthand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why might the popularity have dropped so suddenly after 2010? Well, Siri happens
    to be the name of Apple’s voice assistant and was introduced in 2011\. Let’s draw
    a line for the year 2011 and take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_06in03.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks like parents don’t want their kids to be confused when other people
    say “Hey Siri” to their phones.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced dataframes in `pandas`. We covered the common
    ways that data scientists subset dataframes—slicing with labels and filtering
    using a boolean condition. In the next section, we explain how to aggregate rows
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section introduces operations for aggregating rows in a dataframe. Data
    scientists aggregate rows together to make summaries of data. For instance, a
    dataset containing daily sales can be aggregated to show monthly sales instead.
    This section introduces *grouping* and *pivoting*, two common operations for aggregating
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We work with the baby names data, as introduced in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Basic Group-Aggregate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we want to find out the total number of babies born as recorded in
    this data. This is simply the sum of the `Count` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Summing up the name counts is one simple way to aggregate the data—it combines
    data from multiple rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s say we instead want to answer a more interesting question: are US
    births trending upward over time? To answer this question, we can sum the `Count`
    column within each year rather than taking the sum over the entire dataset. In
    other words, we split the data into groups based on `Year`, then sum the `Count`
    values within each group. This process is depicted in [Figure 6-3](#fig-groupby-births).'
  prefs: []
  type: TYPE_NORMAL
- en: '![fig:groupby-births](assets/leds_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. A depiction of grouping and then aggregating for example data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We call this operation *grouping* followed by *aggregating*. In `pandas`, we
    write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the code is nearly the same as the nongrouped version, except that
    it starts with a call to `.groupby('Year')`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is a `pd.Series` with the total number of babies born for each year
    in the data. Notice that the index of this series contains the unique `Year` values.
    Now we can plot the counts over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_06in04.png)'
  prefs: []
  type: TYPE_IMG
- en: What do we see in this plot? First, we notice that there seem to be suspiciously
    few babies born before 1920\. One likely explanation is that the SSA was created
    in 1935, so its data for prior births could be less complete.
  prefs: []
  type: TYPE_NORMAL
- en: We also notice the dip when World War II began in 1939, and the postwar baby
    boomer era from 1946 to 1964.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the basic recipe for grouping in `pandas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Using .value_counts()'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the more common dataframe tasks is to count the number of times every
    unique item in a column appears. For example, we might be interested in the number
    of times each name appears in the following `classroom` dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '|   | name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Eden |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Sachit |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Eden |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Sachit |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | Sachit |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | Luke |'
  prefs: []
  type: TYPE_TB
- en: 'One way to do this is to use our grouping recipe with the `.size()` aggregation
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation is so common that `pandas` provides a shorthand—the `.value_counts()`
    method for `pd.Series` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `.value_counts()` method will sort the resulting series from
    highest to lowest number, making it convenient to see the most and least common
    values. We point out this method because we use it often in other chapters of
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping on Multiple Columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We pass multiple columns into `.groupby` as a list to group by multiple columns
    at once. This is useful when we need to further subdivide our groups. For example,
    we can group by both year and sex to see how many male and female babies were
    born over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the code closely follows the grouping recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `counts_by_year_and_sex` series has what we call a multilevel index with
    two levels, one for each column that was grouped. It’s a bit easier to see if
    we convert the series to a dataframe. The result only has one column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '|   |   | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Year | Sex |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **1880** | **F** | 83929 |'
  prefs: []
  type: TYPE_TB
- en: '| **M** | 110490 |'
  prefs: []
  type: TYPE_TB
- en: '| **1881** | **F** | 85034 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | **...** | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2019** | **M** | 1785527 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020** | **F** | 1581301 |'
  prefs: []
  type: TYPE_TB
- en: '| **M** | 1706423 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two levels to the index because we grouped by two columns. It can
    be a bit tricky to work with multilevel indices, so we can reset the index to
    go back to a dataframe with a single index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Year | Sex | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1880 | F | 83929 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 1880 | M | 110490 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 1881 | F | 85034 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **279** | 2019 | M | 1785527 |'
  prefs: []
  type: TYPE_TB
- en: '| **280** | 2020 | F | 1581301 |'
  prefs: []
  type: TYPE_TB
- en: '| **281** | 2020 | M | 1706423 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Custom Aggregation Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After grouping, `pandas` gives us flexible ways to aggregate the data. So far,
    we’ve seen how to use `.sum()` after grouping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`pandas` also supplies other aggregation functions, like `.mean()`, `.size()`,
    and `.first()`. Here’s the same grouping using `.max()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: But sometimes `pandas` doesn’t have the exact aggregation function we want to
    use. In these cases, we can define and use a custom aggregation function. `pandas`
    lets us do this through `.agg(fn)`, where `fn` is a function that we define.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we want to find the difference between the largest and smallest
    values within each group (the range of the data), we could first define a function
    called `data_range`, then pass that function into `.agg()`. The input to this
    function is a `pd.Series` object containing a single column of data. It gets called
    once for each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by defining a `count_unique` function that counts the number of unique
    values in a series. Then we pass that function into `.agg()`. Since this function
    is short, we could use a lambda instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_06in05.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the number of unique names has generally increased over time, even
    though the number of babies born annually has plateaued since the 1960s.
  prefs: []
  type: TYPE_NORMAL
- en: Pivoting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pivoting is essentially a convenient way to arrange the results of a group
    and aggregation when grouping with two columns. Earlier in this section we grouped
    the baby names data by year and sex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '|   |   | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Year | Sex |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **1880** | **F** | 83929 |'
  prefs: []
  type: TYPE_TB
- en: '| **M** | 110490 |'
  prefs: []
  type: TYPE_TB
- en: '| **1881** | **F** | 85034 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | **...** | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2019** | **M** | 1785527 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020** | **F** | 1581301 |'
  prefs: []
  type: TYPE_TB
- en: '| **M** | 1706423 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces a `pd.Series` with the counts. We can also imagine the same data
    with the `Sex` index level “pivoted” to the columns of a dataframe. It’s easier
    to see with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '| Sex | F | M |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Year |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **1880** | 83929 | 110490 |'
  prefs: []
  type: TYPE_TB
- en: '| **1881** | 85034 | 100738 |'
  prefs: []
  type: TYPE_TB
- en: '| **1882** | 99699 | 113686 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2018** | 1676884 | 1810309 |'
  prefs: []
  type: TYPE_TB
- en: '| **2019** | 1651911 | 1785527 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020** | 1581301 | 1706423 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see in `mf_pivot` table, dataframe indexes can also be named. To read
    the output, it’s important to notice that the dataframe has two columns, M and
    F, stored in an index named Sex. Likewise, the dataframe has 141 rows, each with
    their own label. These labels are stored in an index named Year. Here, Sex and
    Year are the names of the dataframe indexes, and are not row or column labels
    themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the data values are identical in the pivot table and the table produced
    with `.groupby()`; the values are just arranged differently. Pivot tables are
    useful for quickly summarizing data using two attributes and are often seen in
    articles and papers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `px.line()` function also happens to work well with pivot tables, since
    the function draws one line for each column of data in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_06in06.png)'
  prefs: []
  type: TYPE_IMG
- en: This section covered common ways to aggregate data in `pandas` using the `.groupby()`
    function with one or more columns, or using the `pd.pivot_table()` function. In
    the next section, we’ll explain how to join dataframes together.
  prefs: []
  type: TYPE_NORMAL
- en: Joining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data scientists very frequently want to *join* two or more dataframes together
    in order to connect data values across dataframes. For instance, an online bookstore
    might have one dataframe with the books each user has ordered and a second dataframe
    with the genres of each book. By joining the two dataframes together, the data
    scientist can see what genres each user prefers.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll continue looking at the baby names data. We’ll use joins to check some
    trends mentioned in the [*New York Times* article about baby names](https://oreil.ly/qL1dt).
    The article talks about how certain categories of names have become more or less
    popular over time. For instance, it mentions that mythological names like Julius
    and Cassius have become popular, while baby boomer names like Susan and Debbie
    have become less popular. How has the popularity of these categories changed over
    time?
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve taken the names and categories in the *NYT* article and put them in a
    small dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '|   | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Lucifer | forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Lilith | forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Danger | forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **20** | Venus | celestial |'
  prefs: []
  type: TYPE_TB
- en: '| **21** | Celestia | celestial |'
  prefs: []
  type: TYPE_TB
- en: '| **22** | Skye | celestial |'
  prefs: []
  type: TYPE_TB
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how popular the categories of names are, we join the `nyt` dataframe
    with the `baby` dataframe to get the name counts from `baby`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'For intuition, we can imagine going down each row in `baby` and asking: is
    this name in the `nyt` table? If so, then add the value in the `category` column
    to the row. This is the basic idea behind a join. Let’s look at a few examples
    on smaller dataframes first.'
  prefs: []
  type: TYPE_NORMAL
- en: Inner Joins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by making smaller versions of the `baby` and `nyt` tables so that
    it’s easier to see what happens when we join tables together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '|   | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Julius | mythology |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Freya | mythology |'
  prefs: []
  type: TYPE_TB
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Julius | M | 960 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Karen | M | 6 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Karen | F | 325 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | Noah | F | 305 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: 'To join tables in `pandas`, we’ll use the `.merge()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Julius | M | 960 | 2020 | Julius | mythology |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Karen | M | 6 | 2020 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Karen | F | 325 | 2020 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: Notice that the new table has the columns of both the `baby_small` and `nyt_small`
    tables. The rows with the name `Noah` are gone. And the remaining rows have their
    matching `category` from `nyt_small`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Readers should also be aware that `pandas` has a `.join()` method for joining
    two dataframes together. However, the `.merge()` method has more flexibility for
    how the dataframes are joined, which is why we focus on `.merge()`. We encourage
    readers to consult the `pandas` documentation for the exact difference between
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: When we join two tables together, we tell `pandas` the column(s) from each table
    that we want to use to make the join (the `left_on` and `right_on` arguments).
    `pandas` matches rows together when the values in the joining columns match, as
    shown in [Figure 6-4](#fig-inner-join).
  prefs: []
  type: TYPE_NORMAL
- en: '![inner-join](assets/leds_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. To join, `pandas` matches rows using the values in the `Name` and
    `nyt_name` columns, dropping rows that don’t have matching values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, `pandas` does an *inner join*. If either table has rows that don’t
    have matches in the other table, `pandas` drops those rows from the result. In
    this case, the `Noah` rows in `baby_small` don’t have matches in `nyt_small`,
    so they are dropped. Also, the `Freya` row in `nyt_small` doesn’t have matches
    in `baby_small`, so it’s dropped as well. Only the rows with a match in both tables
    stay in the final result.
  prefs: []
  type: TYPE_NORMAL
- en: Left, Right, and Outer Joins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We sometimes want to keep rows without a match instead of dropping them entirely.
    There are other types of joins—left, right, and outer—that keep rows even when
    they don’t have a match.
  prefs: []
  type: TYPE_NORMAL
- en: In a *left join*, rows in the left table without a match are kept in the final
    result, as shown in [Figure 6-5](#fig-left-join).
  prefs: []
  type: TYPE_NORMAL
- en: '![left-join](assets/leds_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. In a left join, rows in the left table that don’t have matching
    values are kept
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To do a left join in `pandas`, use `how=''left''` in the call to `.merge()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Noah | M | 18252 | 2020 | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Julius | M | 960 | 2020 | Julius | mythology |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Karen | M | 6 | 2020 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Karen | F | 325 | 2020 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | Noah | F | 305 | 2020 | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: Notice that the `Noah` rows are kept in the final table. Since those rows didn’t
    have a match in the `nyt_small` dataframe, the join leaves `NaN` values in the
    `nyt_name` and `category` columns. Also, notice that the `Freya` row in `nyt_small`
    is still dropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *right join* works similarly to the left join, except that nonmatching rows
    in the right table are kept instead of the left table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Karen | M | 6.0 | 2020.0 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Karen | F | 325.0 | 2020.0 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Julius | M | 960.0 | 2020.0 | Julius | mythology |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | NaN | NaN | NaN | NaN | Freya | mythology |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, an *outer join* keeps rows from both tables even when they don’t have
    a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Noah | M | 18252.0 | 2020.0 | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | F | 305.0 | 2020.0 | NaN | NaN |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Julius | M | 960.0 | 2020.0 | Julius | mythology |'
  prefs: []
  type: TYPE_TB
- en: '| **3** | Karen | M | 6.0 | 2020.0 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **4** | Karen | F | 325.0 | 2020.0 | Karen | boomer |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | NaN | NaN | NaN | NaN | Freya | mythology |'
  prefs: []
  type: TYPE_TB
- en: 'Example: Popularity of NYT Name Categories'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s return to the full dataframes `baby` and `nyt`. `.head()` slices
    out the first few rows, which is convenient for saving space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '|   | nyt_name | category |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Lucifer | forbidden |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Lilith | forbidden |'
  prefs: []
  type: TYPE_TB
- en: 'We want to know how the popularity of name categories in `nyt` has changed
    over time. To answer this question:'
  prefs: []
  type: TYPE_NORMAL
- en: Inner join `baby` with `nyt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group the table by `category` and `Year`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Aggregate the counts using a sum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '|   | category | Year | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | boomer | 1880 | 292 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | boomer | 1881 | 298 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | boomer | 1882 | 326 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **647** | mythology | 2018 | 2944 |'
  prefs: []
  type: TYPE_TB
- en: '| **648** | mythology | 2019 | 3320 |'
  prefs: []
  type: TYPE_TB
- en: '| **649** | mythology | 2020 | 3489 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can plot the popularity of `boomer` names and `mythology` names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_06in07.png)'
  prefs: []
  type: TYPE_IMG
- en: As the *NYT* article claims, baby boomer names have become less popular since
    2000, while mythology names have become more popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also plot the popularities of all the categories at once. Take a look
    at the following plots and see whether they support the claims made in the *New
    York Times* article:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_06in08.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we introduced joins for dataframes. When joining dataframes
    together, we match rows using the `.merge()` function. It’s important to consider
    the type of join (inner, left, right, or outer) when joining dataframes. In the
    next section, we’ll explain how to transform values in a dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data scientists transform dataframe columns when they need to change each value
    in a feature in the same way. For example, if a feature contains heights of people
    in feet, a data scientist might want to transform the heights to centimeters.
    In this section, we’ll introduce *apply*, an operation that transforms columns
    of data using a user-defined function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | F | 5 | 1880 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In the baby names *New York Times* article, Pamela mentions that names starting
    with the letter L or K became popular after 2000\. On the other hand, names starting
    with the letter J peaked in popularity in the 1970s and 1980s and dropped off
    in popularity since. We can verify these claims using the `baby` dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'We approach this problem using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Transform the `Name` column into a new column that contains the first letters
    of each value in `Name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Group the dataframe by the first letter and year.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Aggregate the name counts by summing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To complete the first step, we’ll *apply* a function to the `Name` column.
  prefs: []
  type: TYPE_NORMAL
- en: Apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pd.Series` objects contain an `.apply()` method that takes in a function and
    applies it to each value in the series. For instance, to find the lengths of each
    name, we apply the `len` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the first letter of each name, we define a custom function and pass
    it into `.apply()`. The argument to the function is an individual value in the
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `.apply()` is similar to using a `for` loop. The preceding code is roughly
    equivalent to writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can assign the first letters to a new column in the dataframe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Name | Sex | Count | Year | Firsts |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | Liam | M | 19659 | 2020 | L |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | Noah | M | 18252 | 2020 | N |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | Oliver | M | 14147 | 2020 | O |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **2020719** | Verona | F | 5 | 1880 | V |'
  prefs: []
  type: TYPE_TB
- en: '| **2020720** | Vertie | F | 5 | 1880 | V |'
  prefs: []
  type: TYPE_TB
- en: '| **2020721** | Wilma | F | 5 | 1880 | W |'
  prefs: []
  type: TYPE_TB
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To create a new column in a dataframe, you might also encounter this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: This mutates the `baby` table by adding a new column called `Firsts`. In the
    preceding code, we use `.assign()`, which doesn’t mutate the `baby` table itself;
    it creates a new dataframe instead. Mutating dataframes isn’t wrong but can be
    a common source of bugs. Because of this, we’ll mostly use `.assign()` in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Popularity of “L” Names'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can use the `letters` dataframe to see the popularity of first letters
    over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '|   | Firsts | Year | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | A | 1880 | 16740 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | A | 1881 | 16257 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | A | 1882 | 18790 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **3638** | Z | 2018 | 55996 |'
  prefs: []
  type: TYPE_TB
- en: '| **3639** | Z | 2019 | 55293 |'
  prefs: []
  type: TYPE_TB
- en: '| **3640** | Z | 2020 | 54011 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_06in09.png)'
  prefs: []
  type: TYPE_IMG
- en: The plot shows that L names were popular in the 1960s, dipped in the decades
    after, but have indeed resurged in popularity since 2000.
  prefs: []
  type: TYPE_NORMAL
- en: What about J names?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_06in10.png)'
  prefs: []
  type: TYPE_IMG
- en: The *NYT* article says that J names were popular in the 1970s and ’80s. The
    plot agrees and shows that they have become less popular since 2000.
  prefs: []
  type: TYPE_NORMAL
- en: The Price of Apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The power of `.apply()` is its flexibility—you can call it with any function
    that takes in a single data value and outputs a single data value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its flexibility has a price, though. Using `.apply()` can be slow, since `pandas`
    can’t optimize arbitrary functions. For example, using `.apply()` for numeric
    calculations is much slower than using vectorized operations directly on `pd.Series`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The version using `.apply()` is 30 times slower! For numeric operations in particular,
    we recommend operating on `pd.Series` objects directly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced data transformations. To transform values in
    a dataframe, we commonly use the `.apply()` and `.assign()` functions. In the
    next section, we’ll compare dataframes with other ways to represent and manipulate
    data tables.
  prefs: []
  type: TYPE_NORMAL
- en: How Are Dataframes Different from Other Data Representations?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dataframes are just one way to represent data stored in a table. In practice,
    data scientists encounter many other types of data tables, like spreadsheets,
    matrices, and relations. In this section, we’ll compare and contrast the dataframe
    with other representations to explain why dataframes have become so widely used
    for data analysis. We’ll also point out scenarios where other representations
    might be more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Dataframes and Spreadsheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spreadsheets are computer applications in which users can enter data in a grid
    and use formulas to perform calculations. One well-known example today is Microsoft
    Excel, although spreadsheets date back to at least 1979 with [VisiCalc](https://doi.org/10.1109/MAHC.2007.4338439).
    Spreadsheets make it easy to see and directly manipulate data since spreadsheet
    formulas can automatically recalculate results whenever the data change. In contrast,
    dataframe code typically needs to be manually rerun when datasets are updated.
    These properties make spreadsheets highly popular—by [a 2005 estimate](https://doi.org/10.1109/VLHCC.2005.34),
    there are over 55 million spreadsheet users compared to 3 million professional
    programmers in industry.
  prefs: []
  type: TYPE_NORMAL
- en: Dataframes have several key advantages over spreadsheets. Writing dataframe
    code in a computational notebook like Jupyter naturally produces a data lineage.
    Someone who opens the notebook can see the input files for the notebook and how
    the data were changed. Spreadsheets do not make a data lineage visible; if a person
    manually edits data values in a cell, it can be difficult for future users to
    see which values were manually edited and how they were edited. Dataframes can
    handle larger datasets than spreadsheets, and users can also use distributed programming
    tools to work with huge datasets that would be very hard to load into a spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: Dataframes and Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A matrix is a two-dimensional array of data used primarily for linear algebra
    operations. In this next example, <math><mrow><mi mathvariant="bold">X</mi></mrow></math>
    is a matrix with three rows and two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable displaystyle="true" rowspacing="3pt"><mtr><mtd><mrow><mi
    mathvariant="bold">X</mi></mrow> <mo>=</mo> <mrow><mo>[</mo> <mtable columnalign="center"
    columnspacing="1em" rowspacing="4pt"><mtr><mtd><mn>1</mn></mtd> <mtd><mn>0</mn></mtd></mtr>
    <mtr><mtd><mn>0</mn></mtd> <mtd><mn>4</mn></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mn>0</mn></mtd></mtr></mtable> <mo>]</mo></mrow></mtd></mtr></mtable></mtd></mtr></mtable></math>
  prefs: []
  type: TYPE_NORMAL
- en: Matrices are mathematical objects defined by the operators that they allow.
    For instance, matrices can be added or multiplied together. Matrices also have
    a transpose. These operators have very useful properties that data scientists
    rely on for statistical modeling.
  prefs: []
  type: TYPE_NORMAL
- en: One important difference between a matrix and a dataframe is that when matrices
    are treated as mathematical objects, they can only contain numbers. Dataframes,
    on the other hand, can also have other types of data, like text. This makes dataframes
    more useful for loading and processing raw data that may contain all kinds of
    data types. In practice, data scientists often load data into dataframes, then
    manipulate the data into matrix form. In this book, we’ll generally use dataframes
    for exploratory data analysis and data cleaning, then process the data into matrices
    for machine learning models.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Data scientists refer to matrices not only as mathematical objects but also
    as program objects. For instance, the R programming language has a matrix object,
    while in Python we could represent a matrix using a two-dimensional `numpy` array.
    Matrices as implemented in Python and R can contain other data types besides numbers,
    but they lose mathematical properties when doing so. This is yet another example
    of how domains can refer to different things with the same term.
  prefs: []
  type: TYPE_NORMAL
- en: Dataframes and Relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A relation is a data table representation used in database systems, especially
    SQL systems like SQLite and PostgreSQL. (We cover relations and SQL in [Chapter 7](ch07.html#ch-sql).)
    Relations share many similarities with dataframes; both use rows to represent
    records and columns to represent features. Both have column names, and data within
    a column have the same type.
  prefs: []
  type: TYPE_NORMAL
- en: One key advantage of dataframes is that they don’t *require* rows to represent
    records and columns to represent features. Many times, raw data don’t come in
    a convenient format that can directly be put into a relation. In these scenarios,
    data scientists use the dataframe to load and process data since dataframes are
    more flexible in this regard. Often, data scientists will load raw data into a
    dataframe, then process the data into a format that can easily be stored in a
    relation.
  prefs: []
  type: TYPE_NORMAL
- en: One key advantage that relations have over dataframes is that relations are
    used by relational database systems like [PostgreSQL](https://oreil.ly/3zXyH),
    which have highly useful features for data storage and management. Consider a
    data scientist at a company that runs a large social media website. The database
    might hold data that is far too large to read into a `pandas` dataframe all at
    once; instead, data scientists use SQL queries to subset and aggregate data since
    database systems are more capable of handling large datasets. Also, website users
    constantly update their data by making posts, uploading pictures, and editing
    their profiles. Here, database systems let data scientists reuse their existing
    SQL queries to update their analyses with the latest data rather than having to
    repeatedly download large CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained what dataframes are, why they’re useful, and how
    to work with them using `pandas` code. Subsetting, aggregating, joining, and transforming
    are useful in nearly every data analysis. We’ll rely on these operations often
    in the rest of the book, especially in Chapters [8](ch08.html#ch-files), [9](ch09.html#ch-wrangling),
    and [10](ch10.html#ch-eda).
  prefs: []
  type: TYPE_NORMAL
