- en: Chapter 2\. R for Pythonistas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. R for Pythonistas
- en: Rick J. Scavetta
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Rick J. Scavetta
- en: Welcome, brave Pythonista, to the world of the useR^([1](ch02.xhtml#idm45127464940616))!
    In this chapter our goal is to introduce you to R’s core features and try to address
    some of the confusing bits that you’ll encounter along the way. Thus, it’s useful
    to mention what we’re *not* going to do.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎，勇敢的 Python 程序员，来到 useR 的世界^([1](ch02.xhtml#idm45127464940616))！在本章中，我们的目标是介绍
    R 的核心特性，并试图解决你在学习过程中可能遇到的一些困惑。因此，提到我们*不*打算做什么是有用的。
- en: First, we’re not writing for the naïve data scientist. If you want to learn
    R from scratch, there are many wonderful resources available; too many to name.
    We encourage you to explore them and choose those which suit your needs and learning
    style. Here, we’ll bring up topics and concerns that may confuse the complete
    novice. We’ll take some detours to explain topics that we hope will specifically
    help the friendly Pythonista to adapt to R more easily.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们不是为天真的数据科学家编写的。如果你想从零开始学习 R，有很多优秀的资源可供选择；太多了，无法一一列举。我们鼓励你去探索它们，并选择适合你需求和学习风格的资源。在这里，我们将提出可能会让完全的新手感到困惑的话题和问题。我们会绕道解释一些话题，希望能够帮助友好的
    Python 程序员更轻松地适应 R。
- en: Second, this is not a bilingual dictionary, you’ll find that in Appendix A,
    but without context it’s not really useful. Here, we want to take you through
    a journey of exploRation and undeRstanding. We want you to get a *feel* for R
    so that you begin to *think* R, becoming bilingual. Thus, for the sake of narrative,
    we may introduce some items much later than when writing for a complete novice.
    Nonetheless, we hope that you’ll return back to this chapter when you need to
    remind yourself of how to do familiar tasks in a new language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这不是一本双语词典，你可以在附录 A 中找到它，但是没有上下文，它并不是真正有用的。在这里，我们希望带领你踏上一段探索和理解的旅程。我们希望你能够对
    R 有一种*感觉*，以便开始*思考* R，变得双语。因此，为了叙述的完整性，我们可能会在写给完全新手的时候介绍一些项目远比其他时候晚得多的东西。尽管如此，我们希望当你需要在新语言中执行熟悉的任务时，能够回到这一章。
- en: Third, This is not a comprehensive guide. Once you crack the R coconut, you’ll
    get plenty of enjoyment exploring the language deeper to address your specific
    needs as they arise. As we mentioned in the first part of the book, the R community
    is diverse, friendly, welcoming — and helpful! We’re convinced it’s one of the
    less *tech-bro* cultures out there. To get an idea of the community, you can follow
    `#rstats` on [Twitter](https://twitter.com/search?q=%23RStats).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，这不是一本全面的指南。一旦你掌握了 R，你就会发现探索更深层次的语言以满足你特定需求的乐趣无穷。正如我们在本书的第一部分中提到的那样，R 社区是多样化的，友好的，欢迎你的——而且乐于助人！我们相信这是少数不那么*技术兄弟*的文化之一。要了解社区的情况，你可以在
    [Twitter](https://twitter.com/search?q=%23RStats) 上关注 `#rstats`。
- en: Up and running with R
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 R
- en: To follow the exercises in this chapter, you can either access R online using
    RStudio Cloud or install R and RStudio locally. RStudio Cloud is a platform providing
    access to an R instance (via an RStudio IDE) and allows you to upload your own
    data and share projects. We’ll cover both methods in the following paragraphs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本章中完成练习，你可以在 RStudio Cloud 中访问 R，也可以在本地安装 R 和 RStudio。RStudio Cloud 是一个提供访问
    R 实例（通过 RStudio IDE）的平台，它允许你上传自己的数据并分享项目。我们将在接下来的段落中介绍这两种方法。
- en: To use RStudio Cloud, make an account at [*http://rstudio.cloud/*](http://rstudio.cloud/)
    and then navigate to our [publically-available project](https://rstudio.cloud/project/2534578).
    Make sure to save a copy of the project in your workspace so that you have your
    own copy, you’ll see the link in the header.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 RStudio Cloud，请在[*http://rstudio.cloud/*](http://rstudio.cloud/) 上创建一个账户，然后转到我们的[公开项目](https://rstudio.cloud/project/2534578)。确保在你的工作空间中保存项目的副本，这样你就有了自己的副本，你会在页眉中看到链接。
- en: Your RStudio session should look like figure [Figure 2-1](#RStudio_cloud). Open
    `ch02-r4py/r4py.R` and that’s it! You’re ready to follow along with all the examples.
    To execute commands press `ctrl` + `enter` (or `cmd` + `enter`).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 RStudio 会话应该看起来像[图 2-1](#RStudio_cloud)中的样子。打开`ch02-r4py/r4py.R`，就这样！你已经准备好跟着所有的例子了。要执行命令，请按下`ctrl`
    + `enter`（或 `cmd` + `enter`）。
- en: '![](Images/prds_0201.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0201.png)'
- en: Figure 2-1\. Our project in RStudio Cloud.
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 我们在 RStudio Cloud 中的项目。
- en: 'To run R locally, you’ll find it’s available with the Anaconda distribution,
    if you use that, otherwise you can install it directly. First download and install
    R for your operating system from [*https://www.r-project.org/*](https://www.r-project.org/).
    R `v4.0` was released on in June 2020 and in contrast to Python v3.x, is backwards
    compatible, with a few notable exceptions. We’ll assume you’re running at least
    R `4.0.0`: “Taking Off Again”. Each release gets a name inspired by Peanuts (the
    classic comic strip and film franchise featuring Charlie Brown, Snoopy and co.).
    Which is a nice personal touch, I think. Next, install the RStudio Desktop IDE
    from [*https://rstudio.com/*](https://rstudio.com/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地运行 R，您会发现它可以在 Anaconda 发行版中使用，如果您使用的是该发行版，否则您可以直接安装它。首先从[*https://www.r-project.org/*](https://www.r-project.org/)为您的操作系统下载并安装
    R。R `v4.0` 于 2020 年 6 月发布，与 Python v3.x 相比，它具有向后兼容性，但也有一些显著的例外。我们假设您至少正在运行 R `4.0.0`：“再次起飞”。每个发布版都得到一个受花生漫画（经典的漫画和电影系列，由查理·布朗，史努比等主演）启发的名称。我认为这是一个不错的个人化的触摸。接下来，从[*https://rstudio.com/*](https://rstudio.com/)安装
    RStudio Desktop IDE。
- en: Finally, set up a project to work on. This is a bit different from a virtual
    environnement, which we’ll discuss later on. There are two typical ways to make
    a project with pre-existing files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置一个要处理的项目。这与虚拟环境有些不同，我们稍后会讨论。有两种典型的方式可以使用预先存在的文件创建项目。
- en: First, if you’re using `git`, you’ll be happy to know that RStudio is also a
    basic `git` GUI client. In RStudio, select `File > New project > Version Control
    > Git` and enter the repository URL `[*https://github.com/moderndatadesign/PyR4MDS*](https://github.com/moderndatadesign/PyR4MDS)`.
    The project directory name will use the repo name automatically. Choose where
    you want to store the repo and click “Create Project”.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果您使用 `git`，您会很高兴地知道 RStudio 也是一个基本的 `git` 图形用户界面客户端。在 RStudio 中，选择 `File
    > New project > Version Control > Git` 并输入存储库 URL `[*https://github.com/moderndatadesign/PyR4MDS*](https://github.com/moderndatadesign/PyR4MDS)`。项目目录名称将自动使用存储库名称。选择您希望存储存储库的位置，然后单击“创建项目”。
- en: Second, if you’re not using `git`, you can just download and unzip the repo
    from `[*https://github.com/moderndatadesign/PyR4MDS*](https://github.com/moderndatadesign/PyR4MDS)`.
    In RStudio, select `File > Existing Directory` and navigate to the downloaded
    directory. A new R project file, `*.Rproj` will be created in that directory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果您不使用 `git`，您可以直接下载并解压来自[*https://github.com/moderndatadesign/PyR4MDS*](https://github.com/moderndatadesign/PyR4MDS)的存储库。在
    RStudio 中，选择 `File > Existing Directory` 并导航到下载的目录。在该目录中将创建一个新的 R 项目文件 `*.Rproj`。
- en: Your RStudio session should look like figure [Figure 2-2](#RStudio_basic). Open
    `ch02-r4py/r4py.R` and that’s it! You’re ready to follow along with all the examples.
    To execute commands press `ctrl` + `enter` (or `cmd` + `enter`).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 RStudio 会话应该看起来像图 [图 2-2](#RStudio_basic)。打开 `ch02-r4py/r4py.R`，就这样！您已准备好跟随所有示例进行操作。要执行命令，请按
    `ctrl` + `enter`（或 `cmd` + `enter`）。
- en: '![](Images/prds_0202.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0202.png)'
- en: Figure 2-2\. Our project in RStudio.
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 我们在 RStudio 中的项目。
- en: Projects and packages
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目和包
- en: We could begin exploring R by using a built in data set, and diving right into
    the Tidyverse (introduced in [Chapter 1](ch01.xhtml#ch01)) but I want to step
    back for a second, take a deep breath, and begin our story at the beginning. Let’s
    begin by reading in a simple csv file. For this, we’re going to use a data set
    that is actually already available in R in the `ggplot2` package. For our purposes,
    we’re less bothered with the actual analysis than how it’s being done in R. I’ve
    provided the dataset as a file in the book [repository](https://github.com/moderndatadesign/PyR4MDS).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用内置数据集开始探索 R，并直接深入 Tidyverse（在[第 1 章](ch01.xhtml#ch01)介绍），但我想稍作停顿，深呼吸，并从头开始我们的故事。让我们先读取一个简单的
    csv 文件。为此，我们将使用 `ggplot2` 包中实际上已经可用的数据集。对于我们的目的，我们对实际分析不太关心，而是关心它在 R 中的执行方式。我已在书籍的[存储库](https://github.com/moderndatadesign/PyR4MDS)中提供了数据集作为文件。
- en: If you set up your project correctly (see above) all you’ll need to execute
    is the following command. If this command doesn’t work, don’t worry, we’ll return
    to it shortly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确设置了项目（参见上文），您只需要执行以下命令即可。如果此命令不起作用，请不要担心，我们很快会回到这个问题。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Just like in Python, single (`''`) and double (`""`) quotation marks are interchangeable,
    although there is a preference for double quotation marks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Python 中一样，单引号 (`''`) 和双引号 (`""`) 是可以互换的，尽管双引号更受欢迎。
- en: You should now have the file imported and available as an object in your global
    environment, where your user-defined objects are found. The first thing you’ll
    notice is that the environment pane of RStudio will display the object and already
    give some summary information. This lovely, simple touch is similar to the Jupyter
    notebook extension for VScode (see [Chapter 3](ch03.xhtml#ch04)), which also lets
    you view your environment. Although this is a standard feature in RStudio, viewing
    a list of objects when scripting in Python, or many languages for that matter,
    is not typical. Clicking the little blue arrow beside the object name will reveal
    a text description (see fig. [Figure 2-3](#RStudio_pulldown)).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文件已导入并作为对象出现在你的全局环境中，你的自定义对象也在其中。你会注意到的第一件事是 RStudio 的环境面板将显示该对象并提供一些摘要信息。这种可爱而简单的设计类似于
    VScode 的 Jupyter 笔记本扩展（参见 [Chapter 3](ch03.xhtml#ch04)），它也允许你查看你的环境。虽然这在 RStudio
    中是一个标准功能，但在 Python 编写脚本时查看对象列表，或者许多其他语言中，这并不常见。点击对象名称旁边的小蓝箭头将显示文本描述（参见图 [Figure 2-3](#RStudio_pulldown)）。
- en: '![](Images/prds_0203.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0203.png)'
- en: Figure 2-3\. A pulldown of a data frame.
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-3\. 数据框的下拉菜单。
- en: Clicking on the name will open it up in an Excel-like viewer (see fig. [Figure 2-4](#RStudio_table)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 点击名称将在类似 Excel 的查看器中打开它（参见图 [Figure 2-4](#RStudio_table)）。
- en: '![](Images/prds_0204.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/prds_0204.png)'
- en: Figure 2-4\. A data frame in table view.
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-4\. 表格视图中的数据框。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The RStudio viewer is much nicer than Excel, since it only loads into memory
    what you’re seeing on the screen. You can search for specific text and filter
    your data here, so it’s a handy tool for getting a peek at your data.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: RStudio 的查看器比 Excel 更好，因为它只在内存中加载你屏幕上看到的内容。你可以搜索特定文本并筛选数据，因此这是一个方便的工具，用来窥探你的数据。
- en: Although these are nice features, some useRs consider them to be a bit too much
    GUI^([2](ch02.xhtml#idm45127464718424)) and a bit too little IDE^([3](ch02.xhtml#idm45127464717736)).
    Pythonistas would mostly agree and some criticize the user experience of RStudio
    because of this. I partly, agree, since I’ve seen how it can encourage bad practices.
    For example, to import your data set, you could have also clicked on the “import
    dataset…” button. This can be convenient if you’re having a really hard time parsing
    through the file’s structure, but it leads to undocumented, non-reproducible actions
    which are extremely frustrating since scripts/projects will not be self-contained.
    The command to import the file will be executed in the console, and visible in
    the history panel, but it will *not* appear in the script unless you explicitly
    copy it. This results in object in the environment which are not defined in the
    script. However, remember that RStudio is not R. You can use R with other text
    editors (for example the [ESS](https://ess.r-project.org/) (“emacs speaks statistics”)
    extension for emacs).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些功能很好，一些用户认为它们有点过于 GUI^([2](ch02.xhtml#idm45127464718424)) 且有点过于不够 IDE^([3](ch02.xhtml#idm45127464717736))。Python
    爱好者大多数会同意，有些人因此批评 RStudio 的用户体验。我部分同意，因为我看到它可能会鼓励一些不良实践。例如，要导入数据集，你也可以点击“导入数据集…”按钮。如果你在解析文件结构时遇到困难，这可能很方便，但会导致未记录的、不可重现的操作，这非常令人沮丧，因为脚本/项目将不是自包含的。执行导入文件的命令将在控制台中执行，并在历史面板中可见，但除非你明确复制它，否则它不会出现在脚本中。这会导致环境中存在脚本未定义的对象。然而，请记住，RStudio
    不等同于 R。你可以在其他文本编辑器中使用 R（例如 [ESS](https://ess.r-project.org/)（“emacs speaks statistics”）扩展的
    emacs）。
- en: 'If you couldn’t import your data with the above command, either (i) the file
    doesn’t exist in that directory, or (ii) you’re working in the wrong *working
    directory*, which is more likely. You may be tempted to write something terrible,
    like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法使用上述命令导入数据，要么（i）该文件不存在于该目录中，要么（ii）你正在错误的 *工作目录* 中工作，后者更有可能。你可能会被诱导写出像这样糟糕的东西：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll be familiar with avoiding the use of hard-coded paths when using virtual
    environments with Python. Using relative paths, as we did earlier, ensures that
    our file directory contains all necessary data files. Neither the working directory
    nor the project are virtual environments, but they are nonetheless very handy,
    so let’s check them out!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Python 的虚拟环境时，避免使用硬编码路径会更加熟悉。像我们之前所做的那样使用相对路径，确保我们的文件目录包含所有必要的数据文件。工作目录和项目都不是虚拟环境，但它们仍然非常方便，所以让我们来了解一下吧！
- en: The working directory is the first place R looks for a file. When you use R
    projects, the working directory is wherever you have the `*.Rproj` file. Thus,
    `ch02-r4py` is a sub-directory in our working directory. It doesn’t matter what
    the working directory is called or where it is. You can move the entire project
    anywhere on your computer and it will still *just work* once you open the project
    (the `*.Rproj` file) in RStudio.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 工作目录是 R 查找文件的第一个地方。当您使用 R 项目时，工作目录就是您拥有 `*.Rproj` 文件的位置。因此，`ch02-r4py` 是我们工作目录中的一个子目录。工作目录的名称或位置无关紧要。只要在
    RStudio 中打开项目（`*.Rproj` 文件），整个项目可以移动到计算机上的任何位置，它依然能够*正常工作*。
- en: Warning
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'If you’re not using R projects, then your working directory will likely be
    your home directory, displayed as `project: (None)` in RStudio. This is terrible
    because you’ll have to specify the entire path to your file instead of just the
    sub-directories within your project. You’ll find the command `getwd()` to *get*,
    and `setwd()` to *set* the working directory in many outdated tutorials. Please
    don’t use these commands! They result in the same problems of hard-coding full
    file paths.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您没有使用 R 项目，那么您的工作目录可能是您的主目录，在 RStudio 中显示为 `project: (None)`。这很糟糕，因为您将不得不指定文件的完整路径，而不仅仅是项目中的子目录。您会发现命令
    `getwd()` *获取*和 `setwd()` *设置*工作目录在许多过时的教程中。请不要使用这些命令！它们会导致硬编码完整文件路径的相同问题。'
- en: Let’s return to our command `diamonds <- read.csv("ch02-r4py/data/diamonds.csv")`.
    You’ll already notice some things that will confuse and/or aggravate the seasoned
    Pythonista. Three things in particular stand out.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的命令 `diamonds <- read.csv("ch02-r4py/data/diamonds.csv")`。您已经注意到一些会让经验丰富的
    Python 爱好者感到困惑或激怒的事情。有三件事情特别显眼。
- en: First, notice that it’s common place, and even preferred, to use `<-` as the
    assign operator in R. You can use `=`, as in Python, and indeed you’ll see prominent
    and experienced useRs do this, but `<-` is more explicit as *assign to object*
    since `=` is also used to assign values to arguments in function calls, and we
    all know how much Pythonistas love being explicit!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，在 R 中通常使用 `<-` 作为赋值操作符是普遍且甚至更受欢迎的。您可以像在 Python 中那样使用 `=`，事实上您会看到一些有经验的用户这样做，但
    `<-` 更加明确，因为 `=` 也用于在函数调用中为参数分配值，而 Python 爱好者都喜欢明确！
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: The `<-` assign operator is actually a legacy operator stemming from the pre-standardized
    QWERTY keyboard where the `<-` didn’t mean *move the cursor one space to the left*
    but literally, make `<-` appear.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`<-` 赋值操作符实际上是一个传统操作符，起源于标准化前的 QWERTY 键盘，其中 `<-` 并不意味着*将光标向左移动一个空格*，而是字面上使
    `<-` 出现。'
- en: Second, notice that the function name is `read.csv()`, nope, that’s not a typo.
    `csv()` is not a *method* of object *read*, nor is it a *function* of *module*
    `read`. Both are completely acceptable interpretations if this was a Python command.
    In R, with a few, but notable, exceptions, `.` doesn’t mean anything special.
    It’s a bit annoying if you’re used to more OOP^([4](ch02.xhtml#idm45127465528184))-oriented
    languages where `.` is a special character.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，请注意函数名称是 `read.csv()`，不，这不是打字错误。`csv()` 不是对象 `read` 的*方法*，也不是 `read` *模块*
    的*函数*。如果这是一个 Python 命令，这两种解释都是完全可以接受的。在 R 中，除了一些明显的例外，`.` 并不具有特殊意义。如果您习惯于更面向对象的语言，其中
    `.` 是一个特殊字符，这有点令人恼火。
- en: Finally, you’ll notice that we didn’t initialize any packages to accomplish
    this task. The `read.*()` function variants are a part of base R. Interestingly,
    there are newer and more convenient ways of reading in files if these functions
    don’t satisfy your needs. e.g. the `read_csv()` function is in the `readr` package.
    We know you’re excited to see that `_`!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们没有初始化任何包来完成此任务。`read.*()` 函数变体是基本 R 的一部分。有趣的是，如果这些函数不能满足您的需求，还有更新更便捷的读取文件的方法。例如
    `read_csv()` 函数在 `readr` 包中。我们知道您很兴奋看到那个 `_`！
- en: In general, when you see simple functions with `.` these are old base R functions
    created when nobody worried that it would be confusing to have `.` in the names.
    Functions from the newer Tidyverse packages, e.g. `readr`, tend to use `_` (see
    [Chapter 1](ch01.xhtml#ch01)). They basically do the same thing, but with some
    slight tweaks to make them more user-friendly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当您看到带有 `.` 的简单函数时，这些都是旧的基础 R 函数，创建时没有人担心名称中包含 `.` 会引起混淆。来自较新 Tidyverse
    包的函数，例如 `readr`，倾向于使用 `_`（见[第1章](ch01.xhtml#ch01)）。它们基本上做同样的事情，但稍作调整，使它们更加用户友好。
- en: Let’s see this in action with `readr`. Just like in Python, you’ll need to *install*
    the package. This is typically done directly in the R console, there is no `pip`
    equivalent in R.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`readr`实现这一点。就像在Python中一样，你需要*安装*这个包。这通常是在R控制台中直接完成的，R中没有`pip`的等价物。
- en: 'Use the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In RStudio, you can install packages by using to the “Packages” panel in the
    lower-right pane and clicking on the “Install” button. Type in `tidyverse` and
    make sure that the “install all dependencies” box is checked and click OK. If
    you go this route, refrain from clicking on the checkboxes beside the names of
    the installed packages. This will initialize the package, but not record it in
    your script.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在RStudio中，你可以通过在右下角面板中的“Packages”面板上点击“Install”按钮来安装包。输入`tidyverse`，确保选中“install
    all dependencies”框，并点击OK。如果你选择这种方式，请不要点击已安装包名称旁边的复选框。这将初始化包，但不会将其记录在你的脚本中。
- en: This will by default install packages and their dependencies from CRAN, the
    repository of official R packages. Official packages have undergone quality control
    and are hosted on mirrored servers around the world. The first time you do this,
    you’ll be asked to choose a mirror site to install from. For the most part it
    doesn’t matter which one you choose. You’ll see a lot of red text as the core
    Tidyverse packages and all their dependencies are installed. This is mostly just
    a convenient way to get lots of useful packages installed all at once.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将从CRAN安装包及其依赖项，CRAN是官方R包的存储库。官方包经过质量控制，并托管在全球镜像服务器上。第一次这样做时，系统将要求你选择一个镜像站点进行安装。大部分情况下，选择哪一个并不重要。在核心Tidyverse包和它们的所有依赖项安装过程中，你会看到很多红色文本。这主要是一种方便的方式，一次性安装许多有用的包。
- en: The most common problem in installing packages is to not have write permission
    in the packages directory. This will prompt you to create a personal library.
    You can always check where your packages are installed by using
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 安装包最常见的问题是在包目录中没有写权限。这会提示你创建一个个人图书馆。你可以随时通过以下方式检查你的包安装在哪里
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you have a personal library, it will be shown here in the second position.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个个人图书馆，它将显示在第二个位置。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In contrast to Pythonistas, who tend to use virtual environments, useRs typically
    install a package once, making it available system-wide. After many false starts
    in trying to implement a solution for project-specific libraries in R, the current
    favorite is the `renv` [package](https://rstudio.github.io/renv/articles/renv.html),
    i.e. *R environments*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与Pythonistas相比，他们倾向于使用虚拟环境，而R用户通常只安装一次包，使其在整个系统范围内可用。在尝试为R实现项目特定库的解决方案多次失败后，当前的首选是`renv`
    [包](https://rstudio.github.io/renv/articles/renv.html)，即*R环境*。
- en: As in Python, after installing a package, it needs to be initialized in each
    new R session. When we say *initialize*, or *load*, a package, what we’re really
    saying is “use the `library()` function to *load* an installed package and then
    *attach* it to the namespace, i.e. the global environment”. All your packages
    comprise your *library*, hence `library()`. The core suite of packages in the
    Tidyverse can be loaded using `library(tidyverse)`. That is commonplace, and for
    the most part not a problem, but you may want to get into the habit of loading
    only those packages that you actually require instead of filling up your environment
    needlessly. Let’s start with `readr`, which contains the `read_csv()` function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python类似，在安装包后，需要在每个新的R会话中初始化它。当我们说*初始化*或*加载*一个包时，我们实际上是指“使用`library()`函数*加载*一个已安装的包，然后*附加*它到命名空间，即全局环境”。所有你的包组成你的*库*，因此使用`library()`。可以使用`library(tidyverse)`加载Tidyverse的核心套件包。这是常见的做法，大部分时间没有问题，但你可能希望养成只加载实际需要的包而不是不必要地填充环境的习惯。让我们从包含`read_csv()`函数的`readr`开始。
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the equivalent of:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Although R uses OOP, it’s mostly operating in the background, hence you’ll
    never see strange aliases for packages like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管R使用面向对象编程（OOP），但大部分时间是在后台操作，因此你永远不会看到像这样的包的奇怪别名：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That’s just a foreign concept in R. After you have *attached* the package all
    functions and datasets in that package are available in your global environment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这在R中只是一个外来概念。在*附加*包之后，该包中的所有函数和数据集都可在全局环境中使用。
- en: Warning
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: This calls to mind another legacy function that you may see floating around.
    You must absolutely avoid `attach()` (and for the most part its counterpart `detach()`).
    This function allows you to *attach* an object to your global environment, much
    like how we attached a package. Thus, you can call elements within the object
    directly, without first specifying the object name explicitly, like how we call
    functions within a package without having to explicitly call the package name
    every time. The reason this has fallen out of favor is that you’re likely to have
    many data objects that you want to access, so conflicting names are likely to
    be an issue (i.e. leading to *masking* of objects). Plus, it’s just not explicit.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起另一个可能会漂浮的遗留函数。你必须绝对避免使用 `attach()`（以及大部分情况下的配对函数 `detach()`）。这个函数允许你将一个对象
    *attach* 到你的全局环境中，就像我们附加一个包一样。因此，你可以直接调用对象中的元素，而不必显式指定对象名称，就像我们在不必每次显式调用包名称的情况下调用包中的函数一样。这种方法不再流行的原因是你可能会有许多想要访问的数据对象，因此可能会出现名称冲突问题（即对象
    *masking*）。另外，这种方法也不够明确。
- en: 'I want to address one other issue with loading packages before we continue.
    You’ll often see:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想解决另一个加载包的问题。你经常会看到：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`require()` will load an installed package and also return a `TRUE/FALSE` based
    on success. This is useful for testing if a package exists, and so should be reserved
    for those instances where that is necessary. For the most part you want to use
    `library()`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`require()` 函数将加载一个已安装的包，并基于成功与否返回 `TRUE/FALSE`。这对于测试包是否存在很有用，因此应该仅在必要时使用。大多数情况下，你应该使用
    `library()`。'
- en: Alright, let’s read in our data set again, this time using `read_csv()` to make
    some simple comparisons between the two methods.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们再次读取我们的数据集，这次使用 `read_csv()` 进行一些简单的比较。
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You’ll notice that we’re afforded a more detailed account of what’s happened.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们得到了一个更详细的描述发生了什么。
- en: As we mentioned earlier, Tidyverse design choices tend to be more user-friendly
    than older processes they update. This output tells us the column names of our
    tabular data and their types (see [Table 2-2](#data_types)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Tidyverse 的设计选择往往比其更新的老流程更加用户友好。此输出告诉我们表格数据的列名及其类型（参见 [Table 2-2](#data_types)）。
- en: Also note that the current trend in R is to use snake case, underscores (“_”)
    between words and only lower case letters. Although there has classically been
    poor adherence to a style guide in R, the [Advanced R book](http://adv-r.had.co.nz/Style.html)
    offers good suggestions. Google also attempted to promote an [R style guide](https://google.github.io/styleguide/Rguide.html),
    but it doesn’t seem that the community is very strict on this issue. This is in
    contrast to a strict adherence to the PEP 8 Style Guide for Python Code, authored
    by Guido van Rossum and released in the early days of Python.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: R 语言当前的趋势是使用蛇形命名法，单词间用下划线（“_”）分隔，并且只使用小写字母。尽管在 R 中一直以来都存在风格指南的不严格遵循，但是 [Advanced
    R 书籍](http://adv-r.had.co.nz/Style.html) 提供了很好的建议。Google 也试图推广一个 [R 风格指南](https://google.github.io/styleguide/Rguide.html)，但似乎社区对此并不十分严格。这与
    Python 的 PEP 8 风格指南形成对比，后者由 Python 创始人 Guido van Rossum 在 Python 早期发布时编写。
- en: The triumph of tibbles
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tibbles 的胜利
- en: 'So far, we’ve imported our data twice, using two different commands. This was
    done so that you can see some of how R works under-the-hood and some typical behavior
    of the Tidyverse versus base package. We already mentioned that you can click
    on the object in the Environment Viewer to look at it, but it’s also typical to
    just print it to the console. You may be tempted to execute:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经两次导入了我们的数据，使用了两种不同的命令。这样做是为了让你看到 R 在幕后的工作方式以及 Tidyverse 与基础包的一些典型行为。我们已经提到，你可以点击环境查看器中的对象来查看它，但通常也会将其打印到控制台。你可能会试图执行：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But the `print()` function is not necessary except in specific cases, like
    within a `for` loop. As with a Jupyter notebook, you can just execute the object
    name, e.g.:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `print()` 函数在特定情况下是不必要的，比如在 `for` 循环内。与 Jupyter 笔记本类似，你可以直接执行对象名称，例如：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will print the object to the console. We won’t reproduce it here, but
    if you do execute the above command, you’ll notice that this is not a nice output!
    Indeed, one wonders why the default output allows so much to be printed to the
    console in interactive mode. Now try with the data frame we read in using `read_csv()`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把对象打印到控制台。我们不会在这里复制它，但如果你执行上面的命令，你会注意到这不是一个好的输出！确实，人们会想知道为什么默认输出在交互模式下允许如此多的内容打印到控制台。现在尝试使用`read_csv()`读取的数据帧：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wow! That’s a much nicer output than the default base R version. We have a
    neat little table with the names of the columns on one row, and 3-letter codes
    for the data types below that in `<>`. We only see the first 10 rows and then
    a note telling us how much we’re not seeing. If there were too many columns for
    our screen, we’d see them listed at the bottom. Give that a try, set your console
    output to be very narrow and execute the command again:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这比默认的基本R版本要好得多。我们有一个整齐的小表，第一行是列名，下面是`<>`中的数据类型的3个字母代码。我们只看到前10行，然后有一个告诉我们有多少行未显示的注释。如果我们的屏幕有太多列，我们将在底部看到它们列出来。试试吧，将你的控制台输出设置得非常窄，然后再次执行命令：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Base R was already pretty good for Exploratory Data Analysis (EDA), but this
    is next level convenience. So what happened? Actually understanding this is pretty
    important, but first we want to highlight two other interesting points.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的R已经对探索性数据分析（EDA）非常好了，但这是下一个级别的便利。那么发生了什么？实际理解这一点非常重要，但首先我们想要强调另外两个有趣的点。
- en: 'First, notice that we didn’t need to load all of `readr` to gain access to
    the `read_csv()` function. We could have left out `library(readr)` and just used:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，我们不需要加载整个`readr`包来访问`read_csv()`函数。我们可以省略`library(readr)`，直接使用：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The double-colon operator `::` is used to access functions within a package.
    It’s akin to:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 双冒号操作符`::`用于访问包中的函数。类似于：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You’ll see `::` used when useRs know that they’ll only need one very specific
    function from a package, or that functions in two packages may conflict with each
    other, so they want to avoid attaching an entire package to their namespace.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户知道他们只需要一个非常特定的函数来自一个包时，或者两个包中的函数可能会冲突时，他们会使用`::`。这样可以避免将整个包附加到其命名空间中。
- en: Second, this is the first time we see actual data in R and we can tell right
    away that numbering begins with 1! (and why wouldn’t it?).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这是我们第一次在R中看到实际数据，并且我们立即可以看到编号从1开始！（为什么不呢？）。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Just as an aside for printing objects to the screen. You’ll often see round
    brackets around an entire expression. This just means to execute the expression
    and print the object to the screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，打印对象到屏幕上时经常会看到整个表达式周围有圆括号。这只是执行表达式并将对象打印到屏幕上的意思。
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It mostly just clutters up commands. Unless it’s necessary, just explicitly
    call the object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它大多数时候只是混乱了命令。除非有必要，否则就直接调用对象。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Plus, it’s easier to just comment out (use ctrl+shift+c in RStudio) the print
    line instead of having to go back and remove all those extra brackets.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，只需注释掉（在RStudio中使用ctrl+shift+c）打印行，而不是回去删除所有这些额外的括号，会更容易一些。
- en: 'Ok, so let’s get to the heart of what’s happening here. Why do `diamonds` and
    `diamonds_2` *look* so different when printed to the console. Answering this question
    will help us to understand a bit about how R handles objects. To answer this question,
    let’s take a look at the class of these objects:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们来看看这里发生了什么。为什么在打印到控制台时`diamonds`和`diamonds_2`看起来如此不同。回答这个问题将帮助我们理解一下R如何处理对象。为了回答这个问题，让我们看看这些对象的类：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You’ll be familiar with a `data.frame` from `pandas.DataFrame` (ok, can we just
    admit that a `pandas` `DataFrame` is just a Python implementation of an R `data.frame`?).
    But using the Tidyverse `read_csv()` function produced an object with three additional
    classes. The two to mention here are the sub-class `tbl_df` and the class `tbl`,
    the two go hand-in-hand for defining a *tibble* (hence `tbl`) which has a data
    frame structure `tbl_df`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你会从`pandas.DataFrame`中熟悉`data.frame`（好吧，我们能承认`pandas`的`DataFrame`只是R中`data.frame`的一个Python实现吗？）。但使用Tidyverse的`read_csv()`函数生成了一个具有三个额外类的对象。在这里要提到的两个是子类`tbl_df`和类`tbl`，这两者共同定义了一个*tibble*（因此`tbl`），它具有`data.frame`结构的特性`tbl_df`。
- en: Tibbles are a core feature of the Tidyverse and have many perks over base R
    objects. For example, printing to the console. Recall that calling an object name
    is just a shortcut for calling `print()`. `print()` in turn has a method to handle
    data frames and now that we’ve attached the `readr` package, it now has a method
    to handle objects of class `tbl_df`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Tibbles 是 Tidyverse 的核心特性，在基本的 R 对象上有很多优势。例如，打印到控制台。回想一下，调用对象名称只是调用 `print()`
    的快捷方式。`print()` 反过来又有一个处理数据框的方法，现在我们已经加载了 `readr` 包，它现在有一个处理 `tbl_df` 类对象的方法。
- en: So here we see OOP principles operating in the background implicitly handling
    object classes and calling the methods appropriate to a given class. Convenient!
    Confusing? Implicit! I can see why Pythonistas get annoyed, but once you get over
    it, you see that you can just get on with your work without too much hassle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在后台，我们看到 OOP 原则隐式地处理对象类并调用适用于给定类的方法。方便！令人困惑吗？隐式！我能理解为什么 Python 程序员会感到恼火，但一旦你克服了这个问题，你会发现你可以轻松地继续工作，而不会遇到太多麻烦。
- en: A word about types and exploring
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有关类型和探索的一些说明
- en: Let’s take a deeper look at our data and see how R stores and handles data.
    A data frame is a 2-dimensional heterogenous data structure. It sounds simple,
    but let’s break it down a bit further.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地研究一下我们的数据，看看 R 是如何存储和处理数据的。数据框是一个二维异构数据结构。听起来很简单，但让我们进一步解释一下。
- en: Table 2-1\. Example Dataframe
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. 示例数据框
- en: '| Name | Number of dimensions | Type of data |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 维度数 | 数据类型 |'
- en: '| --- | --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Vector | 1 | Homogeneous |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 向量 | 1 | 同质 |'
- en: '| List | 1 | Heterogeneous |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | 1 | 异构 |'
- en: '| Data Frame | 2 | Heterogeneous |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 数据框 | 2 | 异构 |'
- en: '| Matrix | 2 | Homogeneous |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 矩阵 | 2 | 同质 |'
- en: '| Array | n | Homogeneous |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | n | 同质 |'
- en: Vectors are the most basic form of data storage. They are 1-dimensional and
    homogeneous. That is, one element after another, where every element is of the
    same type. It’s like a 1-dimensional `numpy` array composed solely of scalars.
    We don’t refer to scalars in R, that’s just a 1-element long vector. There are
    many *types* in R, and 4 commonly-used “user-defined atomic vector types”. The
    term “atomic” already tells us that it doesn’t get any more basic than what we
    find in [Table 2-2](#data_types).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是最基本的数据存储形式。它们是一维的和同质的。也就是说，一个接一个地存储每个元素，每个元素都是相同类型的。这就像是一个一维的 `numpy` 数组，由标量组成。我们不在
    R 中引用标量，那只是一个长度为 1 的向量。R 中有许多 *类型*，以及 4 个常用的“用户定义的原子向量类型”。术语“原子”已经告诉我们，这已经是我们在
    [Table 2-2](#data_types) 中找到的最基本的东西了。
- en: Table 2-2\. Data Types
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 数据类型
- en: '| Type | Data frame shorthand | Tibble shorthand | Description |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 数据框简写 | Tibble 简写 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Logical | logi | <lgl> | Binary TRUE/FALSE, T/F, 1/0 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑 | logi | <lgl> | 二进制 TRUE/FALSE, T/F, 1/0 |'
- en: '| Integer | int | <int> | Whole numbers from [-Inf,Inf] |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | int | <int> | 整数从 [-Inf,Inf] |'
- en: '| Double | num | <dbl> | Real numbers from [-Inf,Inf] |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 双精度 | num | <dbl> | 实数从 [-Inf,Inf] |'
- en: '| Character | chr | <chr> | All alpha-numeric characters, including white spaces.
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | chr | <chr> | 所有字母数字字符，包括空格。 |'
- en: The two other, less common, user-defined atomic vector types are `raw` and `complex`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两种较不常见的用户定义的原子向量类型是 `raw` 和 `complex`。
- en: Vectors are fundamental building blocks. There are a few things to note about
    vectors, so let’s get that out of the way before we return to the workhorse of
    data science, the beloved data frame.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是基本的构建块。关于向量有几件事情需要注意，所以让我们先搞清楚这些再回到数据科学的工作马车，那就是心爱的数据框。
- en: 'The four user-defined atomic vector types listed in [Table 2-2](#data_types)
    are ordered according to increasing levels of information content. When you create
    a vector, R will try to find the lowest information-content type that can encompass
    all the information in that vector. e.g. logical:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 根据信息内容的递增顺序排列了 [Table 2-2](#data_types) 中列出的四种用户定义的原子向量类型。当你创建一个向量时，R 会尝试找到能够包含该向量中所有信息的最低信息内容类型。例如，逻辑：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`logical`, is R’s equivalent of `bool`, but is very rarely referred to as boolean
    or binary. Also, note that `T` and `F` are not in themselves reserved terms in
    R, and so they are not recommended for logical vectors, although they are valid.
    Use `TRUE` and `FALSE` instead. Let’s take a look at numbers:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`logical` 是 R 中的 `bool` 等价物，但很少被称为布尔或二进制。另外，请注意 `T` 和 `F` 本身不是 R 中的保留术语，因此不建议用于逻辑向量，尽管它们是有效的。请使用
    `TRUE` 和 `FALSE`。让我们来看一下数字：'
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: R will automatically convert between double and integer as needed. Math is performed
    primarily using double-precision, which is reflected in the data frame shorthand
    for double being displayed as `numeric`. Unless you explicitly need to restrict
    a number to be a true integer, then numeric/double will be fine. If you do want
    to restrict values to be integer, you can *coerce* them to a specific type using
    one of the `as.*()` function, or use the `L` suffix to specify that a number must
    be an integer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: R 将根据需要自动在双精度和整数之间进行转换。主要使用双精度进行数学运算，这在数据框中用 `numeric` 的简写显示出来。除非您明确需要将数字限制为真正的整数，否则
    numeric/double 就足够了。如果确实需要将值限制为整数，可以使用 `as.*()` 函数强制转换为特定类型，或者使用 `L` 后缀指定数字必须是整数。
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Characters are R’s version of strings. You’ll know this as `str` in Python,
    which is, confusingly, a common R function, `str()`, which gives the *structure*
    of an object. Characters are also frequently referred to as strings in R, including
    in arguments and package names, which is an unfortunate inconsistency.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是 R 中的字符串版本。你可能知道 Python 中的 `str`，这在 R 中是一个常见的函数 `str()`，它显示对象的*结构*。字符在 R
    中也经常被称为字符串，包括在参数和包名称中，这是一个不幸的不一致性。
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Putting these together in a vanilla data frame using `data.frame()` or using
    the more recently developed tibble using `tibble()`, gives us:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们放在使用 `data.frame()` 创建的基本数据框中，或者使用使用 `tibble()` 创建的更近期开发的 tibble 中，得到：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice we get the nice output from `print()` since it’s a tibble. When we look
    at the *structure*, we’ll see some confusing features:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于它是一个 tibble，我们从 `print()` 中得到了漂亮的输出。当我们查看*结构*时，我们会看到一些令人困惑的特性：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`str()` a classic base package function and gives some bare bones output, it’s
    similar to what you’ll see when you click on the reveal arrow beside the objects
    name in the environment panel. The first row gives the object’s class (which we
    already saw above). S3 refers to the specific OOP system that this object uses,
    which in this case is the most basic and un-strict OOP system.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()` 是一个经典的基础包函数，提供一些基本的输出，类似于在环境面板中点击对象名称旁边的显示箭头时看到的内容。第一行给出了对象的类别（我们上面已经看到了）。S3
    指的是此对象使用的特定面向对象编程系统，本例中是最基本和最宽松的面向对象编程系统。'
- en: Alternatively, we can also use the Tidyverse `glimpse()` function, from the
    `dplyr` package.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用 Tidyverse 中 `dplyr` 包的 `glimpse()` 函数。
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that [Table 2-2](#data_types) also states the short hand `num` which
    does not appear in the output of `glimpse()`. This refers to the the “numeric”
    class, which refers to either double (for double-precision floating-point numbers)
    or integer type.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[表 2-2](#data_types) 还指出了缩写 `num`，在 `glimpse()` 的输出中并没有出现。这指的是“numeric”类别，它可以是双精度浮点数或整数类型。
- en: The above examples showed us that a `data.frame` is a heterogenous, 2-dimensional
    collection of homogeneous 1-dimensional vectors, each having the same length.
    We’ll get to why R prints all those dollar signs below (and no, it has nothing
    to do with your salary!)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例告诉我们，`data.frame` 是一个异构的、二维的、每个长度相同的同质一维向量集合。我们将解释为什么 R 在下面打印所有这些美元符号（不，这与你的工资无关！）
- en: Naming (internal) things
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名（内部）事物
- en: 'We already mentioned that snake case is the current trend in naming objects
    in R. However, naming columns in a data frame is a different beast altogether
    since we just inherit names from the first line of the source file. Data frames
    in base R, obtained e.g. using the `read.*()` family of functions or manually
    created using the `data.frame()` function doesn’t allow for any “illegal” characters.
    Illegal characters include all white spaces and all reserved characters in R,
    e.g.:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，蛇形命名法是目前 R 中命名对象的当前趋势。但是，命名数据框中的列名则完全不同，因为我们只是从源文件的第一行继承了名称。基础 R 中的数据框，例如使用
    `read.*()` 函数系列获取的或者使用 `data.frame()` 函数手动创建的，不允许使用任何“非法”字符。非法字符包括所有空格和所有在 R 中保留的字符，例如：
- en: Arithmetic operators (`+`, `-`, `/`, `*`, etc.),
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符（`+`, `-`, `/`, `*`, 等），
- en: Logical operators (`&`, `|`, etc.),
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符（`&`, `|`, 等），
- en: Relational operators (`==`, `!=`, `>`, `<`, etc.)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符（`==`, `!=`, `>`, `<`, 等）
- en: Brackets, (`[`, `(`, `{`, `<` and their closers)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号 (`[`, `(`, `{`, `<` 及其关闭符)
- en: 'In addition, although they can *contain* numbers, they can’t *begin* with numbers.
    Let’s see what happens:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管它们可以包含数字，但不能以数字开头。让我们看看会发生什么：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All the illegal characters have been replaced with `.`! I know, right? R is
    *really* having a good time mocking you OOP obsessives! On top of that, any variable
    that began with a number is now prefaced with an `X`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有非法字符都被替换为`。`！我知道，没错吧？R真的很喜欢嘲笑你这些OOP狂热者！此外，以数字开头的任何变量现在都以`X`开头。
- en: So what about importing a file with no header?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何导入没有标题的文件？
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In base R, if we don’t have any header, the given names are `V` for “variable”
    followed by the number of that column.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在base R中，如果没有任何标题，给定的名称是`V`，表示“变量”，后面是该列的数字。
- en: 'The same file read in with one of the `readr::read_*()` family of functions
    or created with `tibble()` will maintain illegal characters! This seems trivial,
    but it’s actually a serious critique of the Tidyverse and it’s something to pay
    close attention to if you start meddling in other people’s scripts. Let’s look:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`readr::read_*()`函数中的一个或使用`tibble()`创建的相同文件将保留非法字符！这似乎微不足道，但实际上这是对Tidyverse的严肃批评，如果你开始干预别人的脚本，这是需要密切关注的问题。让我们看看：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice the paired back-ticks for the column `Weight (g)` and `5-day check`?
    You now need to use this to escape the illegal characters. Perhaps this makes
    for more informative commands, since you have the full name, but you’ll likely
    want to maintain short and informative column names anyways. Information about
    the unit (e.g. g for weight) is extraneous information that belongs in a data
    set legend.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到用于列`Weight (g)`和`5-day check`的反引号了吗？现在您需要使用它来转义非法字符。也许这会使命令更具信息性，因为您有完整的名称，但无论如何，您可能仍希望保持简短和具有信息性的列名。关于单位（例如重量的克）的信息是不必要的附加信息，应包含在数据集的图例中。
- en: 'Not only that, but the names given to header-less datasets are also different:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，无头数据集的名称也不同：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instead of `V` we get `X`! This takes us back to the Tidyverse as a distinct
    dialect in R. If you inherit a script entirely in base R, you’ll have a tricky
    time if you just start throwing in Tidyverse functions with wild abandon. It’s
    like asking for a Berliner^([5](ch02.xhtml#idm45127460342008)) in a Berlin bakery!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不再使用`V`，而是使用`X`！这将我们带回到Tidyverse作为R中的一个独特方言。如果您继承了一个完全基于base R的脚本，如果您随意开始添加Tidyverse函数，那么您会遇到麻烦。这就像在柏林面包店要求柏林人^([5](ch02.xhtml#idm45127460342008))一样！
- en: Lists
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are another common data structure, but they’re not exactly what you expect
    form a Python list, so the naming can be confusing. Actually, we’ve already encountered
    lists in our very short R journey. That’s because ``data.frame`s are a specific
    class of type `list``. Yup, you heard that right.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是另一种常见的数据结构，但它们与Python列表并不完全相同，因此命名可能会令人困惑。事实上，在我们非常短暂的R之旅中，我们已经遇到了列表。这是因为``data.frame`是`list`类型的特定类。是的，你没听错。
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Table 2-1](#example_dataframe) tells us that a list is a 1-dimensional, heterogenous
    object. What that means is that every element in this 1-dimensional object can
    be a different type, indeed lists can contain not only vectors, but other lists,
    data frames, matrices, and on and on. In the case that each element is a vector
    of the same length, we end up with tabular data that is then class `data.frame`.
    Pretty convenient, right? Typically, you’ll encounter lists as the output from
    statistical tests, let’s take a look.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2-1](#example_dataframe)告诉我们，列表是一种一维的、异质的对象。这意味着这个一维对象中的每个元素可以是不同类型的，实际上列表不仅可以包含向量，还可以包含其他列表、数据框、矩阵等等。如果每个元素是相同长度的向量，我们最终得到的是类`data.frame`的表格数据。非常方便，对吧？通常，您会遇到列表作为统计测试的输出，让我们来看看。'
- en: 'The `PlantGrowth` data frame is a built-in object in R. It contains two variables
    (i.e. elements in the list, aka columns in the tabular data): `weight` and `group`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlantGrowth`数据框是R中的内置对象。它包含两个变量（即列表中的元素，也称为表格数据中的列）：`weight`和`group`。'
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The data set describes the dry plant `weight` (in grams, thank you data legend)
    of 30 observations (i.e. individual plants, aka rows in the tabular data) grown
    under one of three conditions described in `groups`: `ctrl`, `trt1`, and `trt2`.
    the convenient `glimpse()` function doesn’t show us these three groups, but the
    classic `str()` does:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集描述了30个观察值（即单个植物，也称为表格数据中的行）在`groups`描述的三种条件下生长的干燥植物`weight`（以克计，感谢数据图例）。方便的`glimpse()`函数并不显示这三组，但经典的`str()`函数却能显示：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you’re getting nervous about `<fct>` and `Factor w/ 3 levels`, just hang
    tight — we’ll talk about that after we’re done with lists.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`<fct>`和`Factor w/ 3 levels`感到紧张，那么请耐心等待，我们将在讨论列表之后讨论这个问题。
- en: 'alright, let’s get to some tests. We may want to define a linear model for
    `weight` described by `group`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们进行一些测试。我们可能想要为`weight`由`group`描述定义一个线性模型：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`lm()` is a foundational and flexible function for defining linear models in
    R. Our model is written in *formula notation*, where `weight ~ group` is `y ~
    x`. You’ll recognize the `~` as the standard symbol for “described by” in statistics.
    The output is a type `list` of class `lm`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`lm()`是在R中定义线性模型的基础性和灵活性函数。我们的模型以*公式符号*书写，其中`weight ~ group`是`y ~ x`。你会认出`~`作为统计学中“由...描述”的标准符号。输出是一个类`lm`的`list`类型：'
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are two things that we want to remind you of and build on here.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有两件事情我们想要提醒你并进行拓展。
- en: 'First, remember that we mentioned that a data frame is a collection of vectors
    of the same length? Now we see that that just means that it’s a special class
    of a type list, where each *element* is a vector of the same length. We can access
    a named element within a list using the `$` notation:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，记住我们提到过数据框是相同长度的向量集合？现在我们看到，这只是意味着它是一个特殊类型的列表，其中每个*元素*都是相同长度的向量。我们可以使用`$`符号访问列表中的命名元素：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice the way it’s printed, along a row, and the beginning of each row begins
    with a `[]` with an index position in there. (we already mentioned that R begins
    indexing at 1, right?) In RStudio, you’ll get an autocomplete list of column names
    after typing `$`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它的打印方式，沿着一行，并且每行的开头都以`[]`开头，其中包含一个索引位置。（我们已经提到过R从1开始索引了，对吗？）在RStudio中，键入`$`后，你将得到一个列名的自动完成列表。
- en: 'We can also access a named element within a list using the same notation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用相同的符号访问列表中的命名元素：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can see how a list is such a nice way to store the results of a statistical
    test since we have lots of different kinds of output. e.g. `coefficients`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到列表是存储统计测试结果的一种很好的方式，因为我们有很多不同类型的输出。例如`系数`：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: is a *named* 3-element long numeric vector. (although its elements are named,
    the `$` operator is invalid for atomic vectors, but we have some other tricks
    up our sleeve, of course — see indexing with `[]` below). We didn’t get into the
    details, but you may be aware that given our data we expect to have three coefficients
    (estimates) in our model.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个*命名*的3元素长的数值向量。（虽然它的元素被命名了，但是对于原子向量，`$`运算符无效，但是我们当然还有其他的技巧——见下面的用`[]`进行索引）。我们没有深入讨论细节，但你可能意识到，鉴于我们的数据，我们期望在我们的模型中有三个系数（估计）。
- en: 'Consider `residuals`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`残差`：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: They are stored in a named 30-element long numerical vector (remember we had
    30 observations). So lists are pretty convenient for storing heterogenous data
    and you’ll see them quite often in R, although there is a concerted effort in
    the Tidyverse towards data frames and their variants thereof.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它们存储在一个命名的30元素长的数值向量中（记住我们有30个观测）。所以列表对于存储异构数据非常方便，在R中你会经常见到它们，尽管Tidyverse致力于数据框架及其变体。
- en: 'Second, remember we mentioned that the `.` mostly doesn’t have any special
    meaning. Well here’s one of the exceptions where the `.` does actually have a
    meaning. Probably the most common use is when it specifies *all* when defining
    a model. Here, since other than the `weight` column, `PlantGrowth` only had one
    other column, we could have written:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，记住我们提到`.`在大多数情况下并没有特殊含义。嗯，这是一个例外，`.`确实有含义的一个例外。可能最常见的用法是在定义模型时指定*所有*。在这里，除了`weight`列外，`PlantGrowth`只有一个其他列，我们可以写成：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A note on variable types. By using `y ~ x` formula, we’re say that x is the
    “independent” or the “predictor” variable(s) and y is “dependent” on x, or the
    “response” to the predictor.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量类型的说明。通过使用`y ~ x`的公式，我们在说x是“独立”的或者“预测”变量，而y则是依赖于x，或者是对预测的“响应”。
- en: It’s not really necessary, since we only have one independent variable here,
    but in some cases it’s convenient. The `ToothGrowth` dataset has a similar experimental
    set up, but we’re measuring the length of tooth growth under two conditions, a
    specific supplement (`supp`) and its dosage (`dose`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是真正必要的，因为我们这里只有一个自变量，但在某些情况下很方便。`ToothGrowth`数据集有一个类似的实验设置，但我们在两种条件下测量牙齿生长的长度，一种是特定的补充剂(`supp`)和其剂量(`dose`)。
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But like always, being explicit has it’s advantages, such as defining more
    precise models:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但像以往一样，明确地表达有其优点，比如定义更精确的模型：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Can you spot the difference between the two outputs? Specifying interactions
    is done with the `*`^([6](ch02.xhtml#idm45127459652296))
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现两个输出之间的区别吗？指定相互作用是用`*`进行的^([6](ch02.xhtml#idm45127459652296))
- en: The facts about factors
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于因子的事实
- en: Alright, the last thing we need to clear up before we continue is the phenomena
    of the `factor`. Factors are akin to the pandas `category` type in Python. They
    are a wonderful and useful class in R. For the most part they exist and you won’t
    have cause to worry about them, but do be aware, since their uses and misuses
    will make your life a dream or a misery, respectively. Let’s take a look.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们在继续之前需要澄清的最后一件事是`因素`的现象。因素类似于 Python 中的 pandas `category` 类型。它们是 R 中一个精彩且有用的类。在大多数情况下，它们存在，你不需要担心它们，但要注意，因为它们的使用和误用会使你的生活成为梦想或悲惨。让我们来看看。
- en: 'The name “factor” is very much a statistics term, we may refer to them as categorical
    variables, as Python does, but you’ll also see them referred to as qualitative
    and discrete variables, in text books and also in specific R packages, like `RColorBrewer`
    and `ggplot2`, respectively. Although these terms all refer to the same *kind*
    of variable, when we say factor in R, we’re referring to a *class of type integer*.
    It’s like how `data`.frame is a *class of type list*. Observe:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 名称“因素”在统计学术语中非常常见，我们可以将它们称为分类变量，就像 Python 一样，但你也会看到它们被称为定性和离散变量，无论是在教科书中还是在特定的
    R 包中，比如`RColorBrewer`和`ggplot2`。虽然这些术语都指的是相同*类型*的变量，但当我们在 R 中说因素时，我们指的是*整数类型的类*。这就像`data`.frame
    是*列表类型的类*一样。观察：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can easily identify a factor because in both the output from `str()` (see
    above) and in plain vector formatting, the levels will be stated:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻易地识别因素，因为在`str()`的输出（见上文）和普通的向量格式化中，级别会被说明：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The levels are statisticians’ names for what are commonly called “groups”. Another
    give-away is that, although we have characters, they are not enclosed in quotation
    marks! This is very curious since we can actually treat them as characters, even
    though the are type integer (see [Table 2-2](#data_types)). You may be interested
    to look at the internal structure of an object using `dput()`. Here we can see
    that we have an integer vector `c(1L, ...)` and two *attributes*, the `label`
    and the `class`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 级别是统计学家们称为“组”的名称。另一个特征是，虽然我们有字符，但它们没有用引号括起来！这非常奇怪，因为我们实际上可以将它们视为字符，即使它们是整数类型的（参见[表 2-2](#data_types)）。您可能会对使用`dput()`查看对象的内部结构感兴趣。在这里，我们可以看到我们有一个整数向量`c(1L,
    ...)`和两个*属性*，标签和类。
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The labels define the names of each *level* in the factor and are mapped to
    the integers, `1` being `ctrl`, and so on. So when we print to the screen we only
    see the names, not the integers. This commonly accepted to be a legacy use case
    from the days when memory was expensive and it made sense to save an integer many
    times over instead of a potentially long character vector.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 标签定义了因素中每个*级别*的名称，并映射到整数，`1`是`ctrl`，依此类推。所以当我们打印到屏幕上时，我们只看到名称，而不是整数。这通常被接受为是从内存昂贵的时代遗留下来的用例，当时多次保存整数而不是潜在的长字符向量是有意义的。
- en: 'So far, the only kind of factor we saw was really describing a nominal variable
    (a categorical variable with no order), but we have a nice solution for ordinal
    variables also. Check out this variable from the diamonds data set:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的唯一一种因素实际上是描述名义变量的（没有顺序的分类变量），但我们也有一个很好的解决方案来处理序数变量。看看来自钻石数据集的这个变量：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The levels have an order, in the sense that D comes before E, and so on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 级别有一定的顺序，即 D 在 E 之前，依此类推。
- en: How to find… stuff
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何找… 东西
- en: 'Alright, by now we saw how R stores data and various subtleties that you’ll
    need to keep in mind, in particular things that may trip up a Pythonista. Let’s
    move onto logical expressions and indexing, which is to say: how to find… stuff?'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，到目前为止，我们已经看到了 R 如何存储数据以及您需要牢记的各种微妙之处，特别是可能会让 Python 开发者出错的事情。让我们继续逻辑表达式和索引，也就是说：如何找…
    东西？
- en: Logical expressions are combinations of relational operators, which *ask* yes/no
    questions of *comparison*, and logical operators, which *combine* those yes/no
    questions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑表达式是关系运算符的组合，它们*询问*是/否的*比较*问题，以及逻辑运算符，它们*组合*这些是/否的问题。
- en: 'Let’s begin with a vector:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个向量开始：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This simply asks which of our diamonds are more expensive than $18,000\. There
    are three key things to always keep in mind here.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是问我们的钻石中哪些比$18,000更贵。这里有三个关键要记住的事情。
- en: First, the length of the shorter object, here the unassigned numeric vector
    `18000` (1-element long) will be “recycled” over the entire length of the longer
    vector, here the `price` column from the `diamonds` data frame accessed with the
    `$` notation, (53,940 elements). In Python you may refer to this as broadcasting,
    when using `numpy` arrays, and vectorization as a distinct function. In R, we
    simply refer to both as vectorization, or vector recycling.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，较短对象的长度，这里是未分配的数值向量`18000`（1个元素长），将“循环使用”整个较长向量的长度，这里是通过`$`符号访问的`diamonds`数据框中的`price`列（53,940个元素）。在Python中，您可能将其称为广播，当使用`numpy`数组时，并将向量化作为一个单独的函数。在R中，我们简单地将这两者都称为向量化，或向量循环。
- en: Second, this means that the output vector is the same length as the length of
    the longest vector, here `53,940` elements.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这意味着输出向量的长度与最长向量的长度相同，这里是`53,940`个元素。
- en: Third, anytime you see a relational or logical operator, you know that the output
    vector will *always* be a logical vector. Remember logical as in `TRUE/FALSE`,
    not logical as in Mr. Spock.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，每当你看到关系运算符或逻辑运算符时，你知道输出向量将*始终*是逻辑向量。记住逻辑值是`TRUE/FALSE`，不是像斯波克先生那样的逻辑。
- en: 'If you want to combine questions you’ll have to combine two complete questions,
    such as really expensive and small diamonds (classy!):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想结合问题，你需要结合两个完整的问题，比如真的昂贵和小的钻石（高雅！）：
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that all three key points above hold true. When I introduced the atomic
    vector types, I failed to mention that logical is also defined by `1` and `0`.
    This means we can do math on logical vectors, which is very convenient. How many
    expensive little diamonds do we have?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述所有三个关键点仍然成立。当我介绍原子向量类型时，我没有提到逻辑也可以被定义为`1`和`0`。这意味着我们可以对逻辑向量进行数学运算，这非常方便。我们有多少昂贵的小钻石？
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: (Not enough if I’m being honest). What proportion of my data set do they represent?
    Just divide by the total number of observations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: （老实说还不够）。它们代表我的数据集的比例是多少？只需除以总观察数即可。
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So that’s asking and combining questions. Let’s take a look at indexing using
    []. You’re already familiar with [], but we feel that they are more straight-forward
    in R right out of the box. Here’s a summary:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这是询问和结合问题。让我们来看一下使用`[]`进行索引。你已经很熟悉`[]`，但我们觉得在R中它们更直接。以下是总结：
- en: Table 2-3\. Indexing
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-3\. 索引
- en: '| Use | Data object | Result |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 用途 | 数据对象 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| xx[i] | Vector | Vector of only `i` elements |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| xx[i] | 向量 | 只包含`i`个元素的向量 |'
- en: '| xx | List, Data frame, tibble | The `i` element extracted from a list |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| xx | 列表、数据框、tibble | 从列表中提取的第`i`个元素 |'
- en: '| xx[i] | List, Data frame, tibble | The `i` element maintaining the original
    structure |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| xx[i] | 列表、数据框、tibble | 维持原始结构的第`i`个元素 |'
- en: '| xx[i,j] | Data frame, tibble or matrix | The `i` rows and `j` columns of
    a data frame, tibble or matrix |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| xx[i,j] | 数据框、tibble或矩阵 | 数据框、tibble或矩阵的`i`行和`j`列 |'
- en: '| xx[i,j,k] | Array | The `i` rows, `j` columns and `k` dimension of an array
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| xx[i,j,k] | 数组 | 数组的`i`行、`j`列和`k`维度 |'
- en: '`i`, `j`, and `k` are 1 of 3 different types of vector which can be used inside
    `[]`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`、`j`和`k`是可以在`[]`内部使用的三种不同类型的向量之一：'
- en: An integer vector
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整数向量
- en: A logical vector, or
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个逻辑向量，或者
- en: A character vector containing names, if the elements are named.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果元素有名称，则包含名称的字符向量。
- en: This should be familiar to you already from Python. For integer and logical
    vectors, these can be unassigned vectors, or object or functions that resolve
    to integer or logical vectors. Numbers don’t need to be type integer, although
    whole numbers are clearer. Using numeric/double rounds *down* to the nearest whole
    number, but try to avoid using real numbers when indexing, unless it serves a
    purpose.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说应该已经很熟悉了，就像在Python中一样。对于整数和逻辑向量，它们可以是未分配的向量，或者是解析为整数或逻辑向量的对象或函数。数字不需要是整数类型，尽管整数更清晰。使用数字/双倍会*向下*舍入到最接近的整数，但除非有目的，否则尽量避免在索引时使用实数。
- en: Let’s begin with integers. We’ll take another little detour here to discuss
    the omnipresent `:` operator, which won’t do what your Pythonista brain tells
    you it should should do. We’ll begin with a built-in character vector, `letters`,
    which is the same as having a column in a data frame, like `PlantGrowth$weight`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从整数开始。我们在这里又稍作一小跳，讨论一下无处不在的`:`运算符，它不会像你的Pythonista大脑告诉你的那样运行。我们将从内置字符向量`letters`开始，它与在数据框中拥有列一样，例如`PlantGrowth$weight`。
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So that’s pretty straight-forward. How about counting backwards?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这非常直接了。如何倒数计数呢？
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Nope, that’s not happening, the `-` means to exclude an element, *not* to count
    backwards, but it was a nice try. We can also exclude a range of values:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不会发生，`-`意味着排除一个元素，*而不是*倒数计数，但这是一个不错的尝试。我们也可以排除一系列的值：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'and of course index a range of values:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以索引一系列的值：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: And remember, we can combine this with anything that will give us an integer
    vector. `length()` will tell us how many elements we have in our vector, and `lhs:rhs`
    is short hand for the function `seq(from = lhs, to = rhs, by = 1)`, which creates
    a sequence of values in incremental steps of `by`, in this case defaulting to
    1.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 并且记住，我们可以将这个方法与任何可以给我们整数向量的东西结合起来。`length()`会告诉我们向量中有多少元素，而`lhs:rhs`是函数`seq(from
    = lhs, to = rhs, by = 1)`的简写，它会创建一系列的值，增量步长为`by`，在这种情况下默认为1。
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So that means you always need an lhs and an rhs when using `:`. It’s a pity,
    but this isn’t going to work:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在使用`:`时，你总是需要一个`lhs`和一个`rhs`。很遗憾，但这并不起作用：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Using the `[]` inappropriately gives rise to a legendary and mysterious error
    message in R:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，错误地使用`[]`会产生一个传奇而神秘的错误消息：
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Can you tell where we went wrong? `df` and `t` are not defined data storage
    objects that we can index! They are functions and thus they must be followed by
    `()` where we provide the arguments. `[]` are always used to *subset* and these
    functions, `df()` and `t()` are functions of type closure, which are *not* subsettable.
    So it’s a pretty clear error message actually, and a good reminder to not call
    objects using ambiguous, short names, or indeed to get confused between functions
    and data storage objects.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你能告诉我们哪里出错了吗？`df`和`t`不是定义的数据存储对象，我们可以对其进行索引！它们是函数，因此必须跟随`()`，其中我们提供参数。`[]`总是用于*子集*，而这些函数`df()`和`t()`是闭包类型的函数，*不能*进行子集操作。所以实际上这是一个非常明确的错误消息，并且提醒我们不要使用含糊不清的简短名称来调用对象，或者混淆函数和数据存储对象。
- en: That’s all fine a good, but you’re probably aware that the true power in indexing
    comes from using logical vectors to index specific `TRUE` elements, just like
    using type `bool` in Python. The most common way of obtaining a logical vector
    for indexing is to use a logical expression (see above). This is exactly what
    happens with *masking* in `numpy`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但你可能知道索引的真正威力来自于使用逻辑向量来索引特定的`TRUE`元素，就像在Python中使用类型`bool`一样。获取用于索引的逻辑向量的最常见方法是使用逻辑表达式（见上文）。这正是`numpy`中*掩码*的用法。
- en: So what are the colors of those fancy diamonds?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些花式钻石的颜色是什么？
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here, we’re using price and carat to find the colors of the diamonds that we’re
    interested in. Not surprisingly, they are the best color classifications. You
    may find it annoying that you have to write `diamonds$` repeatedly, but we would
    argue that it just makes it more explicit, and it’s what happens when we reference
    `pandas` `Series` in Python. Since we’re indexing a vector we get a vector as
    output. Let’s turn to data frames. We could have written the above indexing command
    as:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用价格和克拉来找到我们感兴趣的钻石的颜色。毫不奇怪，它们是最好的颜色分类。你可能会觉得反复写`diamonds$`很烦人，但我们会认为这样做更明确，这就是我们在Python中引用`pandas`的`Series`时发生的事情。由于我们正在索引一个向量，我们得到的输出也是一个向量。让我们转向数据框架。我们可以把上面的索引命令写成：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As you would expect, in `` [i,j]` ``, `i` always refers to the *rows* (observations),
    and `j` always refers to *columns* (variables). Notice that we also mixed two
    different types of input, but it works because they were in different parts of
    the expression. We use a logical vector that is as long as the data frame’s number
    of observations (thank you vector recycling) to obtain all the `TRUE` rows, and
    then we used a character vector to extract a named element, recall that each column
    in a data frame is a named element. This is a really typical formulation in R.
    The output is a data frame, specifically a tibble, since we used indexing on the
    diamonds data frame, and not on a specific 1-dimensional vector therein. Not to
    get bogged down with the topic, but it is worth noting that if we didn’t have
    a tibble, indexing for a single column (in `j`) would return a vector:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，在`` [i,j]` ` `中，`i`总是指*行*（观察值），而`j`总是指*列*（变量）。请注意，我们还混合了两种不同类型的输入，但它们在表达式的不同部分工作是因为它们。我们使用一个逻辑向量，其长度与数据框架的观测数相同（感谢向量回收），以获取所有`TRUE`行，然后我们使用一个字符向量来提取一个命名元素，回想一下数据框架中的每一列都是一个命名元素。这在R中是一个非常典型的表达方式。输出是一个数据框架，具体来说是一个tibble，因为我们在钻石数据框架上使用了索引，而不是在特定的一维向量上。不要被这个主题困扰，但值得注意的是，如果我们没有一个tibble，对单列进行索引（在`j`中）会返回一个向量：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is indeed confusing and highlights that necessity to always be aware of
    the class of our data object. The Tidyverse tries to address some of this by maintaining
    data frames even in those instances where base R prefers to revert to a vector.
    The Tidyverse functions for indexing, shown below, makes things easier (the base
    package shorthand, `subset()`, works much in the same way, but `filter()` works
    better when used in a Tidyverse context.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实令人困惑，并突显了我们始终要意识到数据对象的类别的必要性。Tidyverse试图通过保持数据框架来解决其中一些问题，即使在基础R更倾向于回退到向量的情况下也是如此。下面显示的Tidyverse索引函数使事情变得更简单（基础包的简写`subset()`在大致上也是这样，但在Tidyverse上下文中使用`filter()`更有效）。
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We introduced the principles behind the Tidyverse in the first part of the
    book, and now we’re seeing it in action. The `%>%` above allows us to *unnest*
    objects and functions. For example, we could have written:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书的第一部分介绍了Tidyverse的原理，现在我们看到它的实际应用。上面的`%>%`允许我们*展开*对象和函数。例如，我们可以这样写：
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: That has the format of a long, nested function that is quite difficult to follow.
    We can pronounce `%>%` as “and then” and thus read the entire command above as
    “Take the diamonds data set and then filter using these criteria and then select
    only these columns”. This goes a long way in helping us to literally read and
    understand code and is why `dplyr` is described as the *Grammar of Data Analysis*.
    Objects, like tibbles, are the nouns, `%>%` is our punctuation, and functions
    are the verbs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个长而嵌套的函数格式，很难理解。我们可以把`%>%`读作“然后”，因此可以将上面的整个命令读作“取出diamonds数据集，然后根据这些条件进行过滤，然后仅选择这些列”。这在帮助我们理解和阅读代码方面有很大帮助，这也是为什么`dplyr`被描述为*数据分析的语法*。对象，如tibbles，是名词，`%>%`是我们的标点符号，函数是动词。
- en: Table 2-4\. Function description
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-4\. 函数描述
- en: '| Function | Works on | Description |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 作用对象 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `select()` | 列 | 使用名称或辅助函数提取仅这些列 |'
- en: '| `filter()` | rows | Use a logical vector to retain only TRUE rows |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `filter()` | 行 | 使用逻辑向量保留仅为TRUE的行 |'
- en: '| `arrange()` | rows | Reorder rows according to values in a specific column
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `arrange()` | 行 | 根据特定列中的值重新排序行 |'
- en: '| `select()` | columns | Use a name or a helper function to extract only those
    columns |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `summarise()` | columns | Apply aggregation functions to a column |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `summarise()` | 列 | 对列应用聚合函数 |'
- en: '| `mutate()` | columns | Apply transformation functions to a column |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `mutate()` | 列 | 对列应用转换函数 |'
- en: The five most important verbs in `dplyr` are listed in [Table 2-4](#function_description).
    We already saw `filter()` and `select()` in action, so let’s take a look at applying
    functions with `summarise()` and `mutate()`. `summarise()` is used to apply an
    *aggregation* function, which returns a single value, like the mean, `mean()`,
    or standard deviation, `sd()`. It’s common to see `summarise()` used in combination
    with the `group_by()` function. In our analogy of grammatical elements, `group_by()`
    is an adverb, it modifies how a verb operates. In the example below, we use `group_by()`
    to add a `Group` attribute to our data frame and the functions applied in summarise
    are thus group-specific. It’s just like the `.groupby()` method for `pandas` `DataFrames`!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr`中五个最重要的动词在[表 2-4](#function_description)中列出。我们已经看到`filter()`和`select()`在实际操作中的应用，接下来让我们看看如何使用`summarise()`和`mutate()`应用函数。`summarise()`用于应用*聚合*函数，返回单个值，如平均值`mean()`或标准偏差`sd()`。通常会看到`summarise()`与`group_by()`函数结合使用。在我们的语法元素类比中，`group_by()`是一个副词，它修改动词的操作方式。在下面的例子中，我们使用`group_by()`向我们的数据框添加一个`Group`属性，因此在`summarise`中应用的函数是特定于组的。就像`pandas`的`DataFrame`中的`.groupby()`方法一样！'
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`mutate()` is used to apply a *transformation* function, which returns as many
    outputs as inputs. In these cases it’s not unusual to use both Tidyverse syntax
    and native `[]` in combination to index specific values. For example, this data
    set contains the area under irrigation (thousands of hectares) for different regions
    of the world at four different time points.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutate()` 用于应用*转换*函数，该函数返回与输入相同数量的输出。在这些情况下，结合使用Tidyverse语法和原生的`[]`索引特定值并不罕见。例如，该数据集包含了世界不同地区在四个不同时间点的灌溉面积（千公顷）。'
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We may want to measure the area fold-change relative to 1980 for each region.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望针对每个地区相对于1980年的面积折变进行测量。
- en: '[PRE67]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Just like with `mutate()` we can add more transformations, like the percentage
    change over each time point:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`mutate()`一样，我们可以添加更多的转换，比如每个时间点的百分比变化：
- en: '[PRE68]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Reiterations redo
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复
- en: Notice that we didn’t need any looping in the above examples. You may have intuitively
    wanted to apply a `for loop` to calculate aggregation or transformation functions
    for each region, but it’s not necessary. Avoiding for loops is somewhat of a past
    time in R, and is found in the base package with the apply family of functions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上述示例中我们没有需要循环的地方。你可能本能地想应用`for循环`来计算每个区域的聚合或转换函数，但这并不必要。在R中避免for循环有点像过去的一种消遣，并且在基础包中使用`apply`家族的函数时可以发现这一点。
- en: 'Because vectorization is so fundamental to R, there’s a bit of an unofficial
    contest to see how few for loops you can write. We imagine some useRs have a wall
    sign: “Days since last for loop:” like factories have for accidents.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于向量化对于R非常重要，因此有一个非正式的竞赛，看看你能写多少少的for循环。我们想象一些用户可能有一个墙上的标志：“距上次for循环的天数：”就像工厂对事故的记录一样。
- en: This means there are some very old methods for reiterating tasks, along with
    some newer methods which make the process more convenient.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着有一些非常古老的方法来重复任务，以及一些更新的方法使这一过程更加方便。
- en: Table 2-5\. Base package `apply` family
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-5。基础包`apply`家族
- en: '| Function | Use |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 用途 |'
- en: '| --- | --- |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `apply()` | Apply a function to each row or column of a matrix or data frame
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `apply()` | 将函数应用于矩阵或数据框的每一行或列 |'
- en: '| `lapply()` | Apply a function to each element in a list |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `lapply()` | 将函数应用于列表中的每个元素 |'
- en: '| `sapply()` | Simplify the output of `lapply()` |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `sapply()` | 简化`lapply()`的输出 |'
- en: '| `mapply()` | The multivariate version of `sapply()` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `mapply()` | `sapply()`的多变量版本'
- en: '| `tapply()` | Apply a function to values defined by an index |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `tapply()` | 对由索引定义的值应用函数 |'
- en: '| `emapply()` | Apply a function to values in an environment |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `emapply()` | 在环境中应用函数 |'
- en: 'The old school method relies on the apply family of functions, listed in [Table 2-5](#baseapply).
    Except for `apply()` pronounce them all as the first letter and then apply, hence
    “t apply” not “tapply”. There’s a bit of a trend to disavow these workhorses of
    reiteration but you’ll still see them a lot, so they’re worth getting familiar
    with. Doing so will also help you to appreciate why the Tidyverse arose. As an
    example, let’s return to the aggregation functions we applied to the `PlantGrowth`
    data frame above. In the apply family of functions, we could have used:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 老派方法依赖于`apply`家族的函数，列在[表2-5](#baseapply)中。除了`apply()`，其他的发音都是第一个字母然后再加上apply，因此是“t
    apply”而不是“tapply”。有一点趋势是摒弃这些重复性的工作马，但你仍然会经常看到它们，因此熟悉它们是值得的。这样做还将帮助您理解为什么Tidyverse会出现。例如，让我们回到我们对上面的`PlantGrowth`数据框应用的聚合函数。在apply函数族中，我们可以使用：
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You can imagine reading this as “take the weight column from the `PlantGrowth`
    data set, split the values according to the label in the group column in the `PlantGrowth`
    data set and then apply the mean function to each group of values and then return
    a named vector”.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象这样读取，“从`PlantGrowth`数据集中取出重量列，根据组列中的标签分割值，然后对每组值应用均值函数，然后返回一个命名向量”。
- en: Can you see how tedious this is if you want to add more functions on there?
    Named vectors can be convenient, but also, they are not really a typical way that
    you want to store important data.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在那里添加更多的功能，你可以看到这是多么繁琐吗？命名向量可能很方便，但它们并不是你想要存储重要数据的典型方式。
- en: 'One attempt to simplify this process was implemented in `plyr`, the precursor
    to `dplyr`. `plyr` is pronounced *plyer* like the small multifunctional hand-held
    tool. We use it as such:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 试图简化这一过程的一种尝试在`plyr`中实现，这是`dplyr`的前身。`plyr`的发音类似于多功能手持工具“*plyer*”。我们使用它如下：
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is still sometimes used today, but has mostly been superseded by a data
    frame-centric version of the package, hence the d in `dplyr` (say d-plyer):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些方法今天仍然有时会被使用，但它们大多已被数据框架为中心的包所取代，因此在`dplyr`中有个d（读作d-plyer）：
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'But to be clear, we could have returned a data frame with other very old functions:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 但是要明确，我们也可以使用其他非常古老的函数返回一个数据框：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Wow, what a great function, right? This thing is super old! You’ll still see
    it around, and why not, once you wrap your head around it it’s elegant and gets
    the job done, even though it still only applies one function. However, the ongoing
    push to use a unified Tidyverse framework, which is easier to read and arguably
    easier to learn, means the ancient arts are fading into the background.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这是一个很棒的函数，不是吗？这个东西真的很古老！你仍然会看到它的身影，为什么不呢，一旦你掌握了它，它就是优雅而有效的，即使它仍然只应用一个函数。然而，倾向于使用更统一的Tidyverse框架来进行阅读和学习，这意味着古老的方法正在逐渐淡出。
- en: These functions existed since the early days of R and reflect, intuitively,
    what statisticians do **all the time**. The *split* data into chunks, defined
    by some property (rows, columns, categorical variables, objects), then they *apply*
    some kind of action (plotting, hypothesis testing, modelling, etc.) and then they
    *combine* the output together in some way (data frame, list, etc.). The process
    is sometimes called Split-Apply-Combine. Realizing that this process kept repeating
    itself, started to make things clearer to the community of how to start thinking
    about data and indeed, how to actually organize data. From this the idea of “tidy”
    data was born^([7](ch02.xhtml#idm45127457621704)).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数自 R 早期就存在，直观地反映了统计学家们 **一直在做的事情**。它们将数据*分割*成由某些属性定义的块（行、列、分类变量、对象），然后*应用*某种操作（绘图、假设检验、建模等），最后以某种方式*组合*输出（数据框、列表等）。这个过程有时被称为“分割-应用-组合”。意识到这个过程的重复性开始让社区清楚如何开始思考数据，以及如何组织数据。从而诞生了“整洁”数据的概念^([7](ch02.xhtml#idm45127457621704-marker))。
- en: As a last example of iterations, you’re probably familiar with the python `map()`
    function. An analogous function can be found in the Tidyverse `purrr` package.
    This is convenient for reiterating over lists or elements in a vector but it beyond
    the scope of this book.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 作为迭代的最后一个例子，你可能熟悉 Python 中的 `map()` 函数。在 Tidyverse 的 `purrr` 包中可以找到类似的函数。这对于在列表或向量中重复迭代非常方便，但超出了本书的范围。
- en: Final thoughts
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后思考
- en: In Python, you often hear about *the* Python way (“Pythonic”). This means the
    proper Python syntax and the preferred method to perform a specific action. This
    doesn’t really exist in R; there are many ways to go about the same thing and
    people will use all variety! Plus, they’ll often mix dialects. Although some dialects
    are easier to read than others, this hybridization can make it harder to get into
    the language.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你经常听到 *Pythonic* 这个词。这意味着适当的 Python 语法和执行特定操作的首选方法。这在 R 中并不存在；有很多方法可以达到同样的效果，人们会使用各种方案！此外，他们经常混合使用不同的方言。尽管有些方言比其他方言更容易阅读，但这种混合可能会增加语言的学习难度。
- en: Added to this is the constant tweaking of an expanding Tidyverse. Functions
    are tagged as experimental, dormant, maturing, stable, questioning, superseded,
    and archived. Couple that with relative lax standards for project-specific package
    management or for the use of virtual environments, and you can imagine a certain
    amount of growing frustration.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 加之不断调整的扩展 Tidyverse。函数被标记为实验性的、休眠的、成熟的、稳定的、有问题的、被取代的和归档的。再加上项目特定包管理或虚拟环境使用的相对宽松标准，你可以想象出一定程度的不满和挫折感。
- en: R officially celebrated its 20th birthday in 2020, and it’s roots are much older
    than that. Yet, it sometimes feels like R is currently experiencing a teenage
    growth spurt. It’s trying to figure out how it suddenly got a lot bigger and can
    be both awkward and cool at the same time. Blending the different R dialects will
    take you a long way in discovering its full potential.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: R 正式在 2020 年庆祝其成立 20 周年，其根源比这要古老得多。然而，有时候感觉 R 正处于青少年的快速成长期。它正试图弄清楚自己是如何突然变得更加庞大的，同时也可能显得既笨拙又酷。融合不同的
    R 方言将帮助你更深入地发现其全部潜力。
- en: ^([1](ch02.xhtml#idm45127464940616-marker)) *useR!* is the annual R conference
    and also a series of books by publisher Springer.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#idm45127464940616-marker)) *useR!* 是每年一度的 R 会议，也是由 Springer
    出版的一系列书籍。
- en: ^([2](ch02.xhtml#idm45127464718424-marker)) “Graphical User Interface”
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#idm45127464718424-marker)) “图形用户界面”
- en: ^([3](ch02.xhtml#idm45127464717736-marker)) “Integrated Development Environment”
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.xhtml#idm45127464717736-marker)) “集成开发环境”
- en: ^([4](ch02.xhtml#idm45127465528184-marker)) Object oriented programming
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.xhtml#idm45127465528184-marker)) 面向对象编程
- en: '^([5](ch02.xhtml#idm45127460342008-marker)) Berliner (noun): In Berlin, a resident
    of the city. Everywhere else: a tasty jelly-filled, sugar-powered donut.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.xhtml#idm45127460342008-marker)) 柏林人（名词）：在柏林，是该市的居民。在其他地方：一种美味的果冻填充、糖粉涂抹的甜甜圈。
- en: ^([6](ch02.xhtml#idm45127459652296-marker)) But we’ll leave a detailed exposition
    of model definitions for the interested reader to explore.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.xhtml#idm45127459652296-marker)) 但我们将详细阐述模型定义的内容留给有兴趣的读者去探索。
- en: ^([7](ch02.xhtml#idm45127457621704-marker)) If you want to read more about the
    topic, check out Hadley Wickham’s paper [here](https://vita.had.co.nz/papers/tidy-data.pdf)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.xhtml#idm45127457621704-marker)) 如果你想进一步了解这个主题，可以查阅 Hadley Wickham
    的论文 [这里](https://vita.had.co.nz/papers/tidy-data.pdf)
