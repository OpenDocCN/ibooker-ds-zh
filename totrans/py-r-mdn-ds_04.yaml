- en: Chapter 2\. R for Pythonistas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rick J. Scavetta
  prefs: []
  type: TYPE_NORMAL
- en: Welcome, brave Pythonista, to the world of the useR^([1](ch02.xhtml#idm45127464940616))!
    In this chapter our goal is to introduce you to R’s core features and try to address
    some of the confusing bits that you’ll encounter along the way. Thus, it’s useful
    to mention what we’re *not* going to do.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’re not writing for the naïve data scientist. If you want to learn
    R from scratch, there are many wonderful resources available; too many to name.
    We encourage you to explore them and choose those which suit your needs and learning
    style. Here, we’ll bring up topics and concerns that may confuse the complete
    novice. We’ll take some detours to explain topics that we hope will specifically
    help the friendly Pythonista to adapt to R more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this is not a bilingual dictionary, you’ll find that in Appendix A,
    but without context it’s not really useful. Here, we want to take you through
    a journey of exploRation and undeRstanding. We want you to get a *feel* for R
    so that you begin to *think* R, becoming bilingual. Thus, for the sake of narrative,
    we may introduce some items much later than when writing for a complete novice.
    Nonetheless, we hope that you’ll return back to this chapter when you need to
    remind yourself of how to do familiar tasks in a new language.
  prefs: []
  type: TYPE_NORMAL
- en: Third, This is not a comprehensive guide. Once you crack the R coconut, you’ll
    get plenty of enjoyment exploring the language deeper to address your specific
    needs as they arise. As we mentioned in the first part of the book, the R community
    is diverse, friendly, welcoming — and helpful! We’re convinced it’s one of the
    less *tech-bro* cultures out there. To get an idea of the community, you can follow
    `#rstats` on [Twitter](https://twitter.com/search?q=%23RStats).
  prefs: []
  type: TYPE_NORMAL
- en: Up and running with R
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the exercises in this chapter, you can either access R online using
    RStudio Cloud or install R and RStudio locally. RStudio Cloud is a platform providing
    access to an R instance (via an RStudio IDE) and allows you to upload your own
    data and share projects. We’ll cover both methods in the following paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: To use RStudio Cloud, make an account at [*http://rstudio.cloud/*](http://rstudio.cloud/)
    and then navigate to our [publically-available project](https://rstudio.cloud/project/2534578).
    Make sure to save a copy of the project in your workspace so that you have your
    own copy, you’ll see the link in the header.
  prefs: []
  type: TYPE_NORMAL
- en: Your RStudio session should look like figure [Figure 2-1](#RStudio_cloud). Open
    `ch02-r4py/r4py.R` and that’s it! You’re ready to follow along with all the examples.
    To execute commands press `ctrl` + `enter` (or `cmd` + `enter`).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Our project in RStudio Cloud.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To run R locally, you’ll find it’s available with the Anaconda distribution,
    if you use that, otherwise you can install it directly. First download and install
    R for your operating system from [*https://www.r-project.org/*](https://www.r-project.org/).
    R `v4.0` was released on in June 2020 and in contrast to Python v3.x, is backwards
    compatible, with a few notable exceptions. We’ll assume you’re running at least
    R `4.0.0`: “Taking Off Again”. Each release gets a name inspired by Peanuts (the
    classic comic strip and film franchise featuring Charlie Brown, Snoopy and co.).
    Which is a nice personal touch, I think. Next, install the RStudio Desktop IDE
    from [*https://rstudio.com/*](https://rstudio.com/).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, set up a project to work on. This is a bit different from a virtual
    environnement, which we’ll discuss later on. There are two typical ways to make
    a project with pre-existing files.
  prefs: []
  type: TYPE_NORMAL
- en: First, if you’re using `git`, you’ll be happy to know that RStudio is also a
    basic `git` GUI client. In RStudio, select `File > New project > Version Control
    > Git` and enter the repository URL `[*https://github.com/moderndatadesign/PyR4MDS*](https://github.com/moderndatadesign/PyR4MDS)`.
    The project directory name will use the repo name automatically. Choose where
    you want to store the repo and click “Create Project”.
  prefs: []
  type: TYPE_NORMAL
- en: Second, if you’re not using `git`, you can just download and unzip the repo
    from `[*https://github.com/moderndatadesign/PyR4MDS*](https://github.com/moderndatadesign/PyR4MDS)`.
    In RStudio, select `File > Existing Directory` and navigate to the downloaded
    directory. A new R project file, `*.Rproj` will be created in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: Your RStudio session should look like figure [Figure 2-2](#RStudio_basic). Open
    `ch02-r4py/r4py.R` and that’s it! You’re ready to follow along with all the examples.
    To execute commands press `ctrl` + `enter` (or `cmd` + `enter`).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Our project in RStudio.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Projects and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could begin exploring R by using a built in data set, and diving right into
    the Tidyverse (introduced in [Chapter 1](ch01.xhtml#ch01)) but I want to step
    back for a second, take a deep breath, and begin our story at the beginning. Let’s
    begin by reading in a simple csv file. For this, we’re going to use a data set
    that is actually already available in R in the `ggplot2` package. For our purposes,
    we’re less bothered with the actual analysis than how it’s being done in R. I’ve
    provided the dataset as a file in the book [repository](https://github.com/moderndatadesign/PyR4MDS).
  prefs: []
  type: TYPE_NORMAL
- en: If you set up your project correctly (see above) all you’ll need to execute
    is the following command. If this command doesn’t work, don’t worry, we’ll return
    to it shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Just like in Python, single (`''`) and double (`""`) quotation marks are interchangeable,
    although there is a preference for double quotation marks.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have the file imported and available as an object in your global
    environment, where your user-defined objects are found. The first thing you’ll
    notice is that the environment pane of RStudio will display the object and already
    give some summary information. This lovely, simple touch is similar to the Jupyter
    notebook extension for VScode (see [Chapter 3](ch03.xhtml#ch04)), which also lets
    you view your environment. Although this is a standard feature in RStudio, viewing
    a list of objects when scripting in Python, or many languages for that matter,
    is not typical. Clicking the little blue arrow beside the object name will reveal
    a text description (see fig. [Figure 2-3](#RStudio_pulldown)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. A pulldown of a data frame.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Clicking on the name will open it up in an Excel-like viewer (see fig. [Figure 2-4](#RStudio_table)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/prds_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. A data frame in table view.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The RStudio viewer is much nicer than Excel, since it only loads into memory
    what you’re seeing on the screen. You can search for specific text and filter
    your data here, so it’s a handy tool for getting a peek at your data.
  prefs: []
  type: TYPE_NORMAL
- en: Although these are nice features, some useRs consider them to be a bit too much
    GUI^([2](ch02.xhtml#idm45127464718424)) and a bit too little IDE^([3](ch02.xhtml#idm45127464717736)).
    Pythonistas would mostly agree and some criticize the user experience of RStudio
    because of this. I partly, agree, since I’ve seen how it can encourage bad practices.
    For example, to import your data set, you could have also clicked on the “import
    dataset…” button. This can be convenient if you’re having a really hard time parsing
    through the file’s structure, but it leads to undocumented, non-reproducible actions
    which are extremely frustrating since scripts/projects will not be self-contained.
    The command to import the file will be executed in the console, and visible in
    the history panel, but it will *not* appear in the script unless you explicitly
    copy it. This results in object in the environment which are not defined in the
    script. However, remember that RStudio is not R. You can use R with other text
    editors (for example the [ESS](https://ess.r-project.org/) (“emacs speaks statistics”)
    extension for emacs).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you couldn’t import your data with the above command, either (i) the file
    doesn’t exist in that directory, or (ii) you’re working in the wrong *working
    directory*, which is more likely. You may be tempted to write something terrible,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You’ll be familiar with avoiding the use of hard-coded paths when using virtual
    environments with Python. Using relative paths, as we did earlier, ensures that
    our file directory contains all necessary data files. Neither the working directory
    nor the project are virtual environments, but they are nonetheless very handy,
    so let’s check them out!
  prefs: []
  type: TYPE_NORMAL
- en: The working directory is the first place R looks for a file. When you use R
    projects, the working directory is wherever you have the `*.Rproj` file. Thus,
    `ch02-r4py` is a sub-directory in our working directory. It doesn’t matter what
    the working directory is called or where it is. You can move the entire project
    anywhere on your computer and it will still *just work* once you open the project
    (the `*.Rproj` file) in RStudio.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you’re not using R projects, then your working directory will likely be
    your home directory, displayed as `project: (None)` in RStudio. This is terrible
    because you’ll have to specify the entire path to your file instead of just the
    sub-directories within your project. You’ll find the command `getwd()` to *get*,
    and `setwd()` to *set* the working directory in many outdated tutorials. Please
    don’t use these commands! They result in the same problems of hard-coding full
    file paths.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s return to our command `diamonds <- read.csv("ch02-r4py/data/diamonds.csv")`.
    You’ll already notice some things that will confuse and/or aggravate the seasoned
    Pythonista. Three things in particular stand out.
  prefs: []
  type: TYPE_NORMAL
- en: First, notice that it’s common place, and even preferred, to use `<-` as the
    assign operator in R. You can use `=`, as in Python, and indeed you’ll see prominent
    and experienced useRs do this, but `<-` is more explicit as *assign to object*
    since `=` is also used to assign values to arguments in function calls, and we
    all know how much Pythonistas love being explicit!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `<-` assign operator is actually a legacy operator stemming from the pre-standardized
    QWERTY keyboard where the `<-` didn’t mean *move the cursor one space to the left*
    but literally, make `<-` appear.
  prefs: []
  type: TYPE_NORMAL
- en: Second, notice that the function name is `read.csv()`, nope, that’s not a typo.
    `csv()` is not a *method* of object *read*, nor is it a *function* of *module*
    `read`. Both are completely acceptable interpretations if this was a Python command.
    In R, with a few, but notable, exceptions, `.` doesn’t mean anything special.
    It’s a bit annoying if you’re used to more OOP^([4](ch02.xhtml#idm45127465528184))-oriented
    languages where `.` is a special character.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll notice that we didn’t initialize any packages to accomplish
    this task. The `read.*()` function variants are a part of base R. Interestingly,
    there are newer and more convenient ways of reading in files if these functions
    don’t satisfy your needs. e.g. the `read_csv()` function is in the `readr` package.
    We know you’re excited to see that `_`!
  prefs: []
  type: TYPE_NORMAL
- en: In general, when you see simple functions with `.` these are old base R functions
    created when nobody worried that it would be confusing to have `.` in the names.
    Functions from the newer Tidyverse packages, e.g. `readr`, tend to use `_` (see
    [Chapter 1](ch01.xhtml#ch01)). They basically do the same thing, but with some
    slight tweaks to make them more user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see this in action with `readr`. Just like in Python, you’ll need to *install*
    the package. This is typically done directly in the R console, there is no `pip`
    equivalent in R.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In RStudio, you can install packages by using to the “Packages” panel in the
    lower-right pane and clicking on the “Install” button. Type in `tidyverse` and
    make sure that the “install all dependencies” box is checked and click OK. If
    you go this route, refrain from clicking on the checkboxes beside the names of
    the installed packages. This will initialize the package, but not record it in
    your script.
  prefs: []
  type: TYPE_NORMAL
- en: This will by default install packages and their dependencies from CRAN, the
    repository of official R packages. Official packages have undergone quality control
    and are hosted on mirrored servers around the world. The first time you do this,
    you’ll be asked to choose a mirror site to install from. For the most part it
    doesn’t matter which one you choose. You’ll see a lot of red text as the core
    Tidyverse packages and all their dependencies are installed. This is mostly just
    a convenient way to get lots of useful packages installed all at once.
  prefs: []
  type: TYPE_NORMAL
- en: The most common problem in installing packages is to not have write permission
    in the packages directory. This will prompt you to create a personal library.
    You can always check where your packages are installed by using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you have a personal library, it will be shown here in the second position.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In contrast to Pythonistas, who tend to use virtual environments, useRs typically
    install a package once, making it available system-wide. After many false starts
    in trying to implement a solution for project-specific libraries in R, the current
    favorite is the `renv` [package](https://rstudio.github.io/renv/articles/renv.html),
    i.e. *R environments*.
  prefs: []
  type: TYPE_NORMAL
- en: As in Python, after installing a package, it needs to be initialized in each
    new R session. When we say *initialize*, or *load*, a package, what we’re really
    saying is “use the `library()` function to *load* an installed package and then
    *attach* it to the namespace, i.e. the global environment”. All your packages
    comprise your *library*, hence `library()`. The core suite of packages in the
    Tidyverse can be loaded using `library(tidyverse)`. That is commonplace, and for
    the most part not a problem, but you may want to get into the habit of loading
    only those packages that you actually require instead of filling up your environment
    needlessly. Let’s start with `readr`, which contains the `read_csv()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the equivalent of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Although R uses OOP, it’s mostly operating in the background, hence you’ll
    never see strange aliases for packages like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That’s just a foreign concept in R. After you have *attached* the package all
    functions and datasets in that package are available in your global environment.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This calls to mind another legacy function that you may see floating around.
    You must absolutely avoid `attach()` (and for the most part its counterpart `detach()`).
    This function allows you to *attach* an object to your global environment, much
    like how we attached a package. Thus, you can call elements within the object
    directly, without first specifying the object name explicitly, like how we call
    functions within a package without having to explicitly call the package name
    every time. The reason this has fallen out of favor is that you’re likely to have
    many data objects that you want to access, so conflicting names are likely to
    be an issue (i.e. leading to *masking* of objects). Plus, it’s just not explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to address one other issue with loading packages before we continue.
    You’ll often see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`require()` will load an installed package and also return a `TRUE/FALSE` based
    on success. This is useful for testing if a package exists, and so should be reserved
    for those instances where that is necessary. For the most part you want to use
    `library()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Alright, let’s read in our data set again, this time using `read_csv()` to make
    some simple comparisons between the two methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that we’re afforded a more detailed account of what’s happened.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, Tidyverse design choices tend to be more user-friendly
    than older processes they update. This output tells us the column names of our
    tabular data and their types (see [Table 2-2](#data_types)).
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the current trend in R is to use snake case, underscores (“_”)
    between words and only lower case letters. Although there has classically been
    poor adherence to a style guide in R, the [Advanced R book](http://adv-r.had.co.nz/Style.html)
    offers good suggestions. Google also attempted to promote an [R style guide](https://google.github.io/styleguide/Rguide.html),
    but it doesn’t seem that the community is very strict on this issue. This is in
    contrast to a strict adherence to the PEP 8 Style Guide for Python Code, authored
    by Guido van Rossum and released in the early days of Python.
  prefs: []
  type: TYPE_NORMAL
- en: The triumph of tibbles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve imported our data twice, using two different commands. This was
    done so that you can see some of how R works under-the-hood and some typical behavior
    of the Tidyverse versus base package. We already mentioned that you can click
    on the object in the Environment Viewer to look at it, but it’s also typical to
    just print it to the console. You may be tempted to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'But the `print()` function is not necessary except in specific cases, like
    within a `for` loop. As with a Jupyter notebook, you can just execute the object
    name, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the object to the console. We won’t reproduce it here, but
    if you do execute the above command, you’ll notice that this is not a nice output!
    Indeed, one wonders why the default output allows so much to be printed to the
    console in interactive mode. Now try with the data frame we read in using `read_csv()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow! That’s a much nicer output than the default base R version. We have a
    neat little table with the names of the columns on one row, and 3-letter codes
    for the data types below that in `<>`. We only see the first 10 rows and then
    a note telling us how much we’re not seeing. If there were too many columns for
    our screen, we’d see them listed at the bottom. Give that a try, set your console
    output to be very narrow and execute the command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Base R was already pretty good for Exploratory Data Analysis (EDA), but this
    is next level convenience. So what happened? Actually understanding this is pretty
    important, but first we want to highlight two other interesting points.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, notice that we didn’t need to load all of `readr` to gain access to
    the `read_csv()` function. We could have left out `library(readr)` and just used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The double-colon operator `::` is used to access functions within a package.
    It’s akin to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see `::` used when useRs know that they’ll only need one very specific
    function from a package, or that functions in two packages may conflict with each
    other, so they want to avoid attaching an entire package to their namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this is the first time we see actual data in R and we can tell right
    away that numbering begins with 1! (and why wouldn’t it?).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just as an aside for printing objects to the screen. You’ll often see round
    brackets around an entire expression. This just means to execute the expression
    and print the object to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It mostly just clutters up commands. Unless it’s necessary, just explicitly
    call the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Plus, it’s easier to just comment out (use ctrl+shift+c in RStudio) the print
    line instead of having to go back and remove all those extra brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, so let’s get to the heart of what’s happening here. Why do `diamonds` and
    `diamonds_2` *look* so different when printed to the console. Answering this question
    will help us to understand a bit about how R handles objects. To answer this question,
    let’s take a look at the class of these objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You’ll be familiar with a `data.frame` from `pandas.DataFrame` (ok, can we just
    admit that a `pandas` `DataFrame` is just a Python implementation of an R `data.frame`?).
    But using the Tidyverse `read_csv()` function produced an object with three additional
    classes. The two to mention here are the sub-class `tbl_df` and the class `tbl`,
    the two go hand-in-hand for defining a *tibble* (hence `tbl`) which has a data
    frame structure `tbl_df`.
  prefs: []
  type: TYPE_NORMAL
- en: Tibbles are a core feature of the Tidyverse and have many perks over base R
    objects. For example, printing to the console. Recall that calling an object name
    is just a shortcut for calling `print()`. `print()` in turn has a method to handle
    data frames and now that we’ve attached the `readr` package, it now has a method
    to handle objects of class `tbl_df`.
  prefs: []
  type: TYPE_NORMAL
- en: So here we see OOP principles operating in the background implicitly handling
    object classes and calling the methods appropriate to a given class. Convenient!
    Confusing? Implicit! I can see why Pythonistas get annoyed, but once you get over
    it, you see that you can just get on with your work without too much hassle.
  prefs: []
  type: TYPE_NORMAL
- en: A word about types and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take a deeper look at our data and see how R stores and handles data.
    A data frame is a 2-dimensional heterogenous data structure. It sounds simple,
    but let’s break it down a bit further.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Example Dataframe
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Number of dimensions | Type of data |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Vector | 1 | Homogeneous |'
  prefs: []
  type: TYPE_TB
- en: '| List | 1 | Heterogeneous |'
  prefs: []
  type: TYPE_TB
- en: '| Data Frame | 2 | Heterogeneous |'
  prefs: []
  type: TYPE_TB
- en: '| Matrix | 2 | Homogeneous |'
  prefs: []
  type: TYPE_TB
- en: '| Array | n | Homogeneous |'
  prefs: []
  type: TYPE_TB
- en: Vectors are the most basic form of data storage. They are 1-dimensional and
    homogeneous. That is, one element after another, where every element is of the
    same type. It’s like a 1-dimensional `numpy` array composed solely of scalars.
    We don’t refer to scalars in R, that’s just a 1-element long vector. There are
    many *types* in R, and 4 commonly-used “user-defined atomic vector types”. The
    term “atomic” already tells us that it doesn’t get any more basic than what we
    find in [Table 2-2](#data_types).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Data Types
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Data frame shorthand | Tibble shorthand | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Logical | logi | <lgl> | Binary TRUE/FALSE, T/F, 1/0 |'
  prefs: []
  type: TYPE_TB
- en: '| Integer | int | <int> | Whole numbers from [-Inf,Inf] |'
  prefs: []
  type: TYPE_TB
- en: '| Double | num | <dbl> | Real numbers from [-Inf,Inf] |'
  prefs: []
  type: TYPE_TB
- en: '| Character | chr | <chr> | All alpha-numeric characters, including white spaces.
    |'
  prefs: []
  type: TYPE_TB
- en: The two other, less common, user-defined atomic vector types are `raw` and `complex`.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors are fundamental building blocks. There are a few things to note about
    vectors, so let’s get that out of the way before we return to the workhorse of
    data science, the beloved data frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four user-defined atomic vector types listed in [Table 2-2](#data_types)
    are ordered according to increasing levels of information content. When you create
    a vector, R will try to find the lowest information-content type that can encompass
    all the information in that vector. e.g. logical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`logical`, is R’s equivalent of `bool`, but is very rarely referred to as boolean
    or binary. Also, note that `T` and `F` are not in themselves reserved terms in
    R, and so they are not recommended for logical vectors, although they are valid.
    Use `TRUE` and `FALSE` instead. Let’s take a look at numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: R will automatically convert between double and integer as needed. Math is performed
    primarily using double-precision, which is reflected in the data frame shorthand
    for double being displayed as `numeric`. Unless you explicitly need to restrict
    a number to be a true integer, then numeric/double will be fine. If you do want
    to restrict values to be integer, you can *coerce* them to a specific type using
    one of the `as.*()` function, or use the `L` suffix to specify that a number must
    be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Characters are R’s version of strings. You’ll know this as `str` in Python,
    which is, confusingly, a common R function, `str()`, which gives the *structure*
    of an object. Characters are also frequently referred to as strings in R, including
    in arguments and package names, which is an unfortunate inconsistency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting these together in a vanilla data frame using `data.frame()` or using
    the more recently developed tibble using `tibble()`, gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we get the nice output from `print()` since it’s a tibble. When we look
    at the *structure*, we’ll see some confusing features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`str()` a classic base package function and gives some bare bones output, it’s
    similar to what you’ll see when you click on the reveal arrow beside the objects
    name in the environment panel. The first row gives the object’s class (which we
    already saw above). S3 refers to the specific OOP system that this object uses,
    which in this case is the most basic and un-strict OOP system.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can also use the Tidyverse `glimpse()` function, from the
    `dplyr` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that [Table 2-2](#data_types) also states the short hand `num` which
    does not appear in the output of `glimpse()`. This refers to the the “numeric”
    class, which refers to either double (for double-precision floating-point numbers)
    or integer type.
  prefs: []
  type: TYPE_NORMAL
- en: The above examples showed us that a `data.frame` is a heterogenous, 2-dimensional
    collection of homogeneous 1-dimensional vectors, each having the same length.
    We’ll get to why R prints all those dollar signs below (and no, it has nothing
    to do with your salary!)
  prefs: []
  type: TYPE_NORMAL
- en: Naming (internal) things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already mentioned that snake case is the current trend in naming objects
    in R. However, naming columns in a data frame is a different beast altogether
    since we just inherit names from the first line of the source file. Data frames
    in base R, obtained e.g. using the `read.*()` family of functions or manually
    created using the `data.frame()` function doesn’t allow for any “illegal” characters.
    Illegal characters include all white spaces and all reserved characters in R,
    e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators (`+`, `-`, `/`, `*`, etc.),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical operators (`&`, `|`, etc.),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational operators (`==`, `!=`, `>`, `<`, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brackets, (`[`, `(`, `{`, `<` and their closers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, although they can *contain* numbers, they can’t *begin* with numbers.
    Let’s see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: All the illegal characters have been replaced with `.`! I know, right? R is
    *really* having a good time mocking you OOP obsessives! On top of that, any variable
    that began with a number is now prefaced with an `X`.
  prefs: []
  type: TYPE_NORMAL
- en: So what about importing a file with no header?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In base R, if we don’t have any header, the given names are `V` for “variable”
    followed by the number of that column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same file read in with one of the `readr::read_*()` family of functions
    or created with `tibble()` will maintain illegal characters! This seems trivial,
    but it’s actually a serious critique of the Tidyverse and it’s something to pay
    close attention to if you start meddling in other people’s scripts. Let’s look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice the paired back-ticks for the column `Weight (g)` and `5-day check`?
    You now need to use this to escape the illegal characters. Perhaps this makes
    for more informative commands, since you have the full name, but you’ll likely
    want to maintain short and informative column names anyways. Information about
    the unit (e.g. g for weight) is extraneous information that belongs in a data
    set legend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only that, but the names given to header-less datasets are also different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `V` we get `X`! This takes us back to the Tidyverse as a distinct
    dialect in R. If you inherit a script entirely in base R, you’ll have a tricky
    time if you just start throwing in Tidyverse functions with wild abandon. It’s
    like asking for a Berliner^([5](ch02.xhtml#idm45127460342008)) in a Berlin bakery!
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are another common data structure, but they’re not exactly what you expect
    form a Python list, so the naming can be confusing. Actually, we’ve already encountered
    lists in our very short R journey. That’s because ``data.frame`s are a specific
    class of type `list``. Yup, you heard that right.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 2-1](#example_dataframe) tells us that a list is a 1-dimensional, heterogenous
    object. What that means is that every element in this 1-dimensional object can
    be a different type, indeed lists can contain not only vectors, but other lists,
    data frames, matrices, and on and on. In the case that each element is a vector
    of the same length, we end up with tabular data that is then class `data.frame`.
    Pretty convenient, right? Typically, you’ll encounter lists as the output from
    statistical tests, let’s take a look.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PlantGrowth` data frame is a built-in object in R. It contains two variables
    (i.e. elements in the list, aka columns in the tabular data): `weight` and `group`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The data set describes the dry plant `weight` (in grams, thank you data legend)
    of 30 observations (i.e. individual plants, aka rows in the tabular data) grown
    under one of three conditions described in `groups`: `ctrl`, `trt1`, and `trt2`.
    the convenient `glimpse()` function doesn’t show us these three groups, but the
    classic `str()` does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you’re getting nervous about `<fct>` and `Factor w/ 3 levels`, just hang
    tight — we’ll talk about that after we’re done with lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'alright, let’s get to some tests. We may want to define a linear model for
    `weight` described by `group`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`lm()` is a foundational and flexible function for defining linear models in
    R. Our model is written in *formula notation*, where `weight ~ group` is `y ~
    x`. You’ll recognize the `~` as the standard symbol for “described by” in statistics.
    The output is a type `list` of class `lm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There are two things that we want to remind you of and build on here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, remember that we mentioned that a data frame is a collection of vectors
    of the same length? Now we see that that just means that it’s a special class
    of a type list, where each *element* is a vector of the same length. We can access
    a named element within a list using the `$` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Notice the way it’s printed, along a row, and the beginning of each row begins
    with a `[]` with an index position in there. (we already mentioned that R begins
    indexing at 1, right?) In RStudio, you’ll get an autocomplete list of column names
    after typing `$`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also access a named element within a list using the same notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how a list is such a nice way to store the results of a statistical
    test since we have lots of different kinds of output. e.g. `coefficients`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: is a *named* 3-element long numeric vector. (although its elements are named,
    the `$` operator is invalid for atomic vectors, but we have some other tricks
    up our sleeve, of course — see indexing with `[]` below). We didn’t get into the
    details, but you may be aware that given our data we expect to have three coefficients
    (estimates) in our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider `residuals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: They are stored in a named 30-element long numerical vector (remember we had
    30 observations). So lists are pretty convenient for storing heterogenous data
    and you’ll see them quite often in R, although there is a concerted effort in
    the Tidyverse towards data frames and their variants thereof.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, remember we mentioned that the `.` mostly doesn’t have any special
    meaning. Well here’s one of the exceptions where the `.` does actually have a
    meaning. Probably the most common use is when it specifies *all* when defining
    a model. Here, since other than the `weight` column, `PlantGrowth` only had one
    other column, we could have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A note on variable types. By using `y ~ x` formula, we’re say that x is the
    “independent” or the “predictor” variable(s) and y is “dependent” on x, or the
    “response” to the predictor.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not really necessary, since we only have one independent variable here,
    but in some cases it’s convenient. The `ToothGrowth` dataset has a similar experimental
    set up, but we’re measuring the length of tooth growth under two conditions, a
    specific supplement (`supp`) and its dosage (`dose`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But like always, being explicit has it’s advantages, such as defining more
    precise models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the difference between the two outputs? Specifying interactions
    is done with the `*`^([6](ch02.xhtml#idm45127459652296))
  prefs: []
  type: TYPE_NORMAL
- en: The facts about factors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, the last thing we need to clear up before we continue is the phenomena
    of the `factor`. Factors are akin to the pandas `category` type in Python. They
    are a wonderful and useful class in R. For the most part they exist and you won’t
    have cause to worry about them, but do be aware, since their uses and misuses
    will make your life a dream or a misery, respectively. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name “factor” is very much a statistics term, we may refer to them as categorical
    variables, as Python does, but you’ll also see them referred to as qualitative
    and discrete variables, in text books and also in specific R packages, like `RColorBrewer`
    and `ggplot2`, respectively. Although these terms all refer to the same *kind*
    of variable, when we say factor in R, we’re referring to a *class of type integer*.
    It’s like how `data`.frame is a *class of type list*. Observe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily identify a factor because in both the output from `str()` (see
    above) and in plain vector formatting, the levels will be stated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The levels are statisticians’ names for what are commonly called “groups”. Another
    give-away is that, although we have characters, they are not enclosed in quotation
    marks! This is very curious since we can actually treat them as characters, even
    though the are type integer (see [Table 2-2](#data_types)). You may be interested
    to look at the internal structure of an object using `dput()`. Here we can see
    that we have an integer vector `c(1L, ...)` and two *attributes*, the `label`
    and the `class`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The labels define the names of each *level* in the factor and are mapped to
    the integers, `1` being `ctrl`, and so on. So when we print to the screen we only
    see the names, not the integers. This commonly accepted to be a legacy use case
    from the days when memory was expensive and it made sense to save an integer many
    times over instead of a potentially long character vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, the only kind of factor we saw was really describing a nominal variable
    (a categorical variable with no order), but we have a nice solution for ordinal
    variables also. Check out this variable from the diamonds data set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The levels have an order, in the sense that D comes before E, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to find… stuff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alright, by now we saw how R stores data and various subtleties that you’ll
    need to keep in mind, in particular things that may trip up a Pythonista. Let’s
    move onto logical expressions and indexing, which is to say: how to find… stuff?'
  prefs: []
  type: TYPE_NORMAL
- en: Logical expressions are combinations of relational operators, which *ask* yes/no
    questions of *comparison*, and logical operators, which *combine* those yes/no
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This simply asks which of our diamonds are more expensive than $18,000\. There
    are three key things to always keep in mind here.
  prefs: []
  type: TYPE_NORMAL
- en: First, the length of the shorter object, here the unassigned numeric vector
    `18000` (1-element long) will be “recycled” over the entire length of the longer
    vector, here the `price` column from the `diamonds` data frame accessed with the
    `$` notation, (53,940 elements). In Python you may refer to this as broadcasting,
    when using `numpy` arrays, and vectorization as a distinct function. In R, we
    simply refer to both as vectorization, or vector recycling.
  prefs: []
  type: TYPE_NORMAL
- en: Second, this means that the output vector is the same length as the length of
    the longest vector, here `53,940` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Third, anytime you see a relational or logical operator, you know that the output
    vector will *always* be a logical vector. Remember logical as in `TRUE/FALSE`,
    not logical as in Mr. Spock.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to combine questions you’ll have to combine two complete questions,
    such as really expensive and small diamonds (classy!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Notice that all three key points above hold true. When I introduced the atomic
    vector types, I failed to mention that logical is also defined by `1` and `0`.
    This means we can do math on logical vectors, which is very convenient. How many
    expensive little diamonds do we have?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: (Not enough if I’m being honest). What proportion of my data set do they represent?
    Just divide by the total number of observations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'So that’s asking and combining questions. Let’s take a look at indexing using
    []. You’re already familiar with [], but we feel that they are more straight-forward
    in R right out of the box. Here’s a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-3\. Indexing
  prefs: []
  type: TYPE_NORMAL
- en: '| Use | Data object | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| xx[i] | Vector | Vector of only `i` elements |'
  prefs: []
  type: TYPE_TB
- en: '| xx | List, Data frame, tibble | The `i` element extracted from a list |'
  prefs: []
  type: TYPE_TB
- en: '| xx[i] | List, Data frame, tibble | The `i` element maintaining the original
    structure |'
  prefs: []
  type: TYPE_TB
- en: '| xx[i,j] | Data frame, tibble or matrix | The `i` rows and `j` columns of
    a data frame, tibble or matrix |'
  prefs: []
  type: TYPE_TB
- en: '| xx[i,j,k] | Array | The `i` rows, `j` columns and `k` dimension of an array
    |'
  prefs: []
  type: TYPE_TB
- en: '`i`, `j`, and `k` are 1 of 3 different types of vector which can be used inside
    `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: An integer vector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A logical vector, or
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A character vector containing names, if the elements are named.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This should be familiar to you already from Python. For integer and logical
    vectors, these can be unassigned vectors, or object or functions that resolve
    to integer or logical vectors. Numbers don’t need to be type integer, although
    whole numbers are clearer. Using numeric/double rounds *down* to the nearest whole
    number, but try to avoid using real numbers when indexing, unless it serves a
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with integers. We’ll take another little detour here to discuss
    the omnipresent `:` operator, which won’t do what your Pythonista brain tells
    you it should should do. We’ll begin with a built-in character vector, `letters`,
    which is the same as having a column in a data frame, like `PlantGrowth$weight`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So that’s pretty straight-forward. How about counting backwards?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Nope, that’s not happening, the `-` means to exclude an element, *not* to count
    backwards, but it was a nice try. We can also exclude a range of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'and of course index a range of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: And remember, we can combine this with anything that will give us an integer
    vector. `length()` will tell us how many elements we have in our vector, and `lhs:rhs`
    is short hand for the function `seq(from = lhs, to = rhs, by = 1)`, which creates
    a sequence of values in incremental steps of `by`, in this case defaulting to
    1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'So that means you always need an lhs and an rhs when using `:`. It’s a pity,
    but this isn’t going to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `[]` inappropriately gives rise to a legendary and mysterious error
    message in R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Can you tell where we went wrong? `df` and `t` are not defined data storage
    objects that we can index! They are functions and thus they must be followed by
    `()` where we provide the arguments. `[]` are always used to *subset* and these
    functions, `df()` and `t()` are functions of type closure, which are *not* subsettable.
    So it’s a pretty clear error message actually, and a good reminder to not call
    objects using ambiguous, short names, or indeed to get confused between functions
    and data storage objects.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all fine a good, but you’re probably aware that the true power in indexing
    comes from using logical vectors to index specific `TRUE` elements, just like
    using type `bool` in Python. The most common way of obtaining a logical vector
    for indexing is to use a logical expression (see above). This is exactly what
    happens with *masking* in `numpy`.
  prefs: []
  type: TYPE_NORMAL
- en: So what are the colors of those fancy diamonds?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’re using price and carat to find the colors of the diamonds that we’re
    interested in. Not surprisingly, they are the best color classifications. You
    may find it annoying that you have to write `diamonds$` repeatedly, but we would
    argue that it just makes it more explicit, and it’s what happens when we reference
    `pandas` `Series` in Python. Since we’re indexing a vector we get a vector as
    output. Let’s turn to data frames. We could have written the above indexing command
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As you would expect, in `` [i,j]` ``, `i` always refers to the *rows* (observations),
    and `j` always refers to *columns* (variables). Notice that we also mixed two
    different types of input, but it works because they were in different parts of
    the expression. We use a logical vector that is as long as the data frame’s number
    of observations (thank you vector recycling) to obtain all the `TRUE` rows, and
    then we used a character vector to extract a named element, recall that each column
    in a data frame is a named element. This is a really typical formulation in R.
    The output is a data frame, specifically a tibble, since we used indexing on the
    diamonds data frame, and not on a specific 1-dimensional vector therein. Not to
    get bogged down with the topic, but it is worth noting that if we didn’t have
    a tibble, indexing for a single column (in `j`) would return a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is indeed confusing and highlights that necessity to always be aware of
    the class of our data object. The Tidyverse tries to address some of this by maintaining
    data frames even in those instances where base R prefers to revert to a vector.
    The Tidyverse functions for indexing, shown below, makes things easier (the base
    package shorthand, `subset()`, works much in the same way, but `filter()` works
    better when used in a Tidyverse context.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We introduced the principles behind the Tidyverse in the first part of the
    book, and now we’re seeing it in action. The `%>%` above allows us to *unnest*
    objects and functions. For example, we could have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: That has the format of a long, nested function that is quite difficult to follow.
    We can pronounce `%>%` as “and then” and thus read the entire command above as
    “Take the diamonds data set and then filter using these criteria and then select
    only these columns”. This goes a long way in helping us to literally read and
    understand code and is why `dplyr` is described as the *Grammar of Data Analysis*.
    Objects, like tibbles, are the nouns, `%>%` is our punctuation, and functions
    are the verbs.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-4\. Function description
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Works on | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `filter()` | rows | Use a logical vector to retain only TRUE rows |'
  prefs: []
  type: TYPE_TB
- en: '| `arrange()` | rows | Reorder rows according to values in a specific column
    |'
  prefs: []
  type: TYPE_TB
- en: '| `select()` | columns | Use a name or a helper function to extract only those
    columns |'
  prefs: []
  type: TYPE_TB
- en: '| `summarise()` | columns | Apply aggregation functions to a column |'
  prefs: []
  type: TYPE_TB
- en: '| `mutate()` | columns | Apply transformation functions to a column |'
  prefs: []
  type: TYPE_TB
- en: The five most important verbs in `dplyr` are listed in [Table 2-4](#function_description).
    We already saw `filter()` and `select()` in action, so let’s take a look at applying
    functions with `summarise()` and `mutate()`. `summarise()` is used to apply an
    *aggregation* function, which returns a single value, like the mean, `mean()`,
    or standard deviation, `sd()`. It’s common to see `summarise()` used in combination
    with the `group_by()` function. In our analogy of grammatical elements, `group_by()`
    is an adverb, it modifies how a verb operates. In the example below, we use `group_by()`
    to add a `Group` attribute to our data frame and the functions applied in summarise
    are thus group-specific. It’s just like the `.groupby()` method for `pandas` `DataFrames`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`mutate()` is used to apply a *transformation* function, which returns as many
    outputs as inputs. In these cases it’s not unusual to use both Tidyverse syntax
    and native `[]` in combination to index specific values. For example, this data
    set contains the area under irrigation (thousands of hectares) for different regions
    of the world at four different time points.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We may want to measure the area fold-change relative to 1980 for each region.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with `mutate()` we can add more transformations, like the percentage
    change over each time point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Reiterations redo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice that we didn’t need any looping in the above examples. You may have intuitively
    wanted to apply a `for loop` to calculate aggregation or transformation functions
    for each region, but it’s not necessary. Avoiding for loops is somewhat of a past
    time in R, and is found in the base package with the apply family of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because vectorization is so fundamental to R, there’s a bit of an unofficial
    contest to see how few for loops you can write. We imagine some useRs have a wall
    sign: “Days since last for loop:” like factories have for accidents.'
  prefs: []
  type: TYPE_NORMAL
- en: This means there are some very old methods for reiterating tasks, along with
    some newer methods which make the process more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-5\. Base package `apply` family
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `apply()` | Apply a function to each row or column of a matrix or data frame
    |'
  prefs: []
  type: TYPE_TB
- en: '| `lapply()` | Apply a function to each element in a list |'
  prefs: []
  type: TYPE_TB
- en: '| `sapply()` | Simplify the output of `lapply()` |'
  prefs: []
  type: TYPE_TB
- en: '| `mapply()` | The multivariate version of `sapply()` |'
  prefs: []
  type: TYPE_TB
- en: '| `tapply()` | Apply a function to values defined by an index |'
  prefs: []
  type: TYPE_TB
- en: '| `emapply()` | Apply a function to values in an environment |'
  prefs: []
  type: TYPE_TB
- en: 'The old school method relies on the apply family of functions, listed in [Table 2-5](#baseapply).
    Except for `apply()` pronounce them all as the first letter and then apply, hence
    “t apply” not “tapply”. There’s a bit of a trend to disavow these workhorses of
    reiteration but you’ll still see them a lot, so they’re worth getting familiar
    with. Doing so will also help you to appreciate why the Tidyverse arose. As an
    example, let’s return to the aggregation functions we applied to the `PlantGrowth`
    data frame above. In the apply family of functions, we could have used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You can imagine reading this as “take the weight column from the `PlantGrowth`
    data set, split the values according to the label in the group column in the `PlantGrowth`
    data set and then apply the mean function to each group of values and then return
    a named vector”.
  prefs: []
  type: TYPE_NORMAL
- en: Can you see how tedious this is if you want to add more functions on there?
    Named vectors can be convenient, but also, they are not really a typical way that
    you want to store important data.
  prefs: []
  type: TYPE_NORMAL
- en: 'One attempt to simplify this process was implemented in `plyr`, the precursor
    to `dplyr`. `plyr` is pronounced *plyer* like the small multifunctional hand-held
    tool. We use it as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This is still sometimes used today, but has mostly been superseded by a data
    frame-centric version of the package, hence the d in `dplyr` (say d-plyer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'But to be clear, we could have returned a data frame with other very old functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Wow, what a great function, right? This thing is super old! You’ll still see
    it around, and why not, once you wrap your head around it it’s elegant and gets
    the job done, even though it still only applies one function. However, the ongoing
    push to use a unified Tidyverse framework, which is easier to read and arguably
    easier to learn, means the ancient arts are fading into the background.
  prefs: []
  type: TYPE_NORMAL
- en: These functions existed since the early days of R and reflect, intuitively,
    what statisticians do **all the time**. The *split* data into chunks, defined
    by some property (rows, columns, categorical variables, objects), then they *apply*
    some kind of action (plotting, hypothesis testing, modelling, etc.) and then they
    *combine* the output together in some way (data frame, list, etc.). The process
    is sometimes called Split-Apply-Combine. Realizing that this process kept repeating
    itself, started to make things clearer to the community of how to start thinking
    about data and indeed, how to actually organize data. From this the idea of “tidy”
    data was born^([7](ch02.xhtml#idm45127457621704)).
  prefs: []
  type: TYPE_NORMAL
- en: As a last example of iterations, you’re probably familiar with the python `map()`
    function. An analogous function can be found in the Tidyverse `purrr` package.
    This is convenient for reiterating over lists or elements in a vector but it beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Final thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, you often hear about *the* Python way (“Pythonic”). This means the
    proper Python syntax and the preferred method to perform a specific action. This
    doesn’t really exist in R; there are many ways to go about the same thing and
    people will use all variety! Plus, they’ll often mix dialects. Although some dialects
    are easier to read than others, this hybridization can make it harder to get into
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: Added to this is the constant tweaking of an expanding Tidyverse. Functions
    are tagged as experimental, dormant, maturing, stable, questioning, superseded,
    and archived. Couple that with relative lax standards for project-specific package
    management or for the use of virtual environments, and you can imagine a certain
    amount of growing frustration.
  prefs: []
  type: TYPE_NORMAL
- en: R officially celebrated its 20th birthday in 2020, and it’s roots are much older
    than that. Yet, it sometimes feels like R is currently experiencing a teenage
    growth spurt. It’s trying to figure out how it suddenly got a lot bigger and can
    be both awkward and cool at the same time. Blending the different R dialects will
    take you a long way in discovering its full potential.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.xhtml#idm45127464940616-marker)) *useR!* is the annual R conference
    and also a series of books by publisher Springer.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.xhtml#idm45127464718424-marker)) “Graphical User Interface”
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.xhtml#idm45127464717736-marker)) “Integrated Development Environment”
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.xhtml#idm45127465528184-marker)) Object oriented programming
  prefs: []
  type: TYPE_NORMAL
- en: '^([5](ch02.xhtml#idm45127460342008-marker)) Berliner (noun): In Berlin, a resident
    of the city. Everywhere else: a tasty jelly-filled, sugar-powered donut.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.xhtml#idm45127459652296-marker)) But we’ll leave a detailed exposition
    of model definitions for the interested reader to explore.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch02.xhtml#idm45127457621704-marker)) If you want to read more about the
    topic, check out Hadley Wickham’s paper [here](https://vita.had.co.nz/papers/tidy-data.pdf)
  prefs: []
  type: TYPE_NORMAL
