<html><head></head><body><section data-pdf-bookmark="Chapter 10. Finding the Longest Shared Subsequence: Finding K-mers, Writing Functions, and Using Binary Search" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch10">&#13;
<h1><span class="label">Chapter 10. </span>Finding the Longest Shared Subsequence: Finding K-mers, Writing Functions, and Using Binary Search</h1>&#13;
&#13;
&#13;
<p>As described in <a href="https://oreil.ly/SONgC">the Rosalind LCSM challenge</a>, the goal of this exercise is to find the longest substring that is shared by all sequences in a given FASTA file.<a data-primary="subsequences" data-secondary="longest shared" data-tertiary="about" data-type="indexterm" id="idm45963630895496"/><a data-primary="longest shared subsequence" data-secondary="about" data-type="indexterm" id="idm45963630894280"/><a data-primary="FASTA format" data-secondary="finding longest shared subsequence" data-type="indexterm" id="idm45963630893320"/>&#13;
In <a data-type="xref" href="ch08.html#ch08">Chapter 8</a>, <span class="keep-together">I was</span> searching for a given motif in some sequences.&#13;
In this challenge, I don’t know <em>a priori</em> that any shared motif is present—much less the size or composition of it—so I’ll just look for any length of sequence that is present in every sequence.&#13;
This is a challenging exercise that brings together many ideas I’ve shown in earlier chapters.&#13;
I’ll use the solutions to explore algorithm design, functions, tests, and code organization.</p>&#13;
&#13;
<p>You will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to use k-mers to find shared subsequences</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use <code>itertools.chain()</code> to concatenate lists of lists</p>&#13;
</li>&#13;
<li>&#13;
<p>How and why to use a binary search</p>&#13;
</li>&#13;
<li>&#13;
<p>One way to maximize a function</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use the <code>key</code> option with <code>min()</code> and <code>max()</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963630882552">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>All the code and tests for this challenge are in the <em>10_lcsm</em> directory.<a data-primary="longest shared subsequence" data-secondary="getting started" data-type="indexterm" id="idm45963630880776"/><a data-primary="subsequences" data-secondary="longest shared" data-tertiary="getting started" data-type="indexterm" id="idm45963630879816"/>&#13;
Start by copying the first solution to the <code>lcsm.py</code> program and asking for help:</p>&#13;
&#13;
<pre data-type="programlisting">$ cp solution1_kmers_imperative.py lcsm.py&#13;
$ ./lcsm.py -h&#13;
usage: lcsm.py [-h] FILE&#13;
&#13;
Longest Common Substring&#13;
&#13;
positional arguments:&#13;
  FILE        Input FASTA&#13;
&#13;
optional arguments:&#13;
  -h, --help  show this help message and exit</pre>&#13;
&#13;
<p>The only required argument is a single positional file of FASTA-formatted DNA sequences.&#13;
As with other programs that accept files, the program will reject invalid or unreadable input.&#13;
The following is the first input I’ll use.&#13;
The longest common subsequences in these sequences are <em>CA</em>, <em>TA</em>, and <em>AC</em>, with the last shown in bold in the output:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.fa&#13;
&gt;Rosalind_1&#13;
GATT<strong>AC</strong>A&#13;
&gt;Rosalind_2&#13;
TAG<strong>AC</strong>CA&#13;
&gt;Rosalind_3&#13;
AT<strong>AC</strong>A</pre>&#13;
&#13;
<p>Any of these answers are acceptable.&#13;
Run the program with the first test input and see that it randomly selects one of the acceptable 2-mers:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./lcsm.py tests/inputs/1.fa&#13;
CA</pre>&#13;
&#13;
<p>The second test input is much larger, and you’ll notice that the program takes significantly longer to find the answer.&#13;
On my laptop, it takes almost 40 seconds.&#13;
In the solutions, I’ll show you a way to significantly decrease the runtime using a binary search:</p>&#13;
&#13;
<pre data-type="programlisting">$ time ./lcsm.py tests/inputs/2.fa&#13;
GCCTTTTGATTTTAACGTTTATCGGGTGTAGTAAGATTGCGCGCTAATTCCAATAAACGTATGGAGGACATTCCCCGT&#13;
&#13;
real	0m39.244s&#13;
user	0m33.708s&#13;
sys	0m6.202s</pre>&#13;
&#13;
<p>Although not a requirement of the challenge, I’ve included one input file that contains no shared subsequences for which the program should create a suitable response:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./lcsm.py tests/inputs/none.fa&#13;
No common subsequence.</pre>&#13;
&#13;
<p>Start the <code>lcsm.py</code> program from scratch:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Longest Common Substring' lcsm.py&#13;
Done, see new script "lcsm.py".</pre>&#13;
&#13;
<p>Define the arguments like so:</p>&#13;
&#13;
<pre data-type="programlisting">class Args(NamedTuple): <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-1" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Command-line arguments """&#13;
    file: TextIO&#13;
&#13;
&#13;
def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Longest Common Substring',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('file', <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-2" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
                        help='Input FASTA',&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('rt'))&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(args.file) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-3" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-1" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The only input to this program is a FASTA-formatted file.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-2" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Define a single <code>file</code> argument.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-3" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Return the <code>Args</code> object containing the open filehandle.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Then update the <code>main()</code> function to print the incoming filename:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(args.file.name)</pre>&#13;
&#13;
<p>Verify that you see the correct usage and that the program correctly prints the <span class="keep-together">filename:</span></p>&#13;
&#13;
<pre data-type="programlisting">$ ./lcsm.py tests/inputs/1.fa&#13;
tests/inputs/1.fa</pre>&#13;
&#13;
<p>At this point, your program should pass the first three tests.&#13;
If you think you know how to complete the program, have at it.&#13;
If you want a prod in the right direction, read on.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Finding the Shortest Sequence in a FASTA File" data-type="sect2"><div class="sect2" id="idm45963630845224">&#13;
<h2>Finding the Shortest Sequence in a FASTA File</h2>&#13;
&#13;
<p>Reading a FASTA file should be familiar by now.<a data-primary="FASTA format" data-secondary="finding shortest sequence" data-type="indexterm" id="idm45963630843864"/><a data-primary="shortest sequence in FASTA file" data-type="indexterm" id="idm45963630842904"/><a data-primary="longest shared subsequence" data-secondary="shortest sequence in FASTA file" data-type="indexterm" id="idm45963630842216"/>&#13;
I’ll use <code>Bio.SeqIO.parse()</code> as before.<a data-primary="FASTA format" data-secondary="parsing with Bio.SeqIO" data-type="indexterm" id="idm45963630840632"/><a data-primary="Biopython library" data-secondary="Bio.SeqIO" data-tertiary="FASTA parsed" data-type="indexterm" id="idm45963630839688"/>&#13;
My first idea on this problem was to find shared k-mers while maximizing for <code>k</code>.&#13;
The longest subsequence can be no longer than the shortest sequence in the file, so I decided to start with <code>k</code> equal to that.&#13;
Finding the shortest sequence requires that I first scan through <em>all</em> the records.&#13;
To review how to do this, the <code>Bio.SeqIO.parse()</code> function returns an iterator that gives me access to each FASTA record:<a data-primary="Biopython library" data-secondary="Bio.SeqIO" data-tertiary="iterating through records" data-type="indexterm" id="idm45963630836200"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from Bio import SeqIO&#13;
&gt;&gt;&gt; fh = open('./tests/inputs/1.fa')&#13;
&gt;&gt;&gt; recs = SeqIO.parse(fh, 'fasta')&#13;
&gt;&gt;&gt; type(recs)&#13;
&lt;class 'Bio.SeqIO.FastaIO.FastaIterator'&gt;</pre>&#13;
&#13;
<p>I can use the <code>next()</code> function I first showed in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a> to force the iterator to produce the next value, the type of which is <code>SeqRecord</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rec = next(recs)&#13;
&gt;&gt;&gt; type(rec)&#13;
&lt;class 'Bio.SeqRecord.SeqRecord'&gt;</pre>&#13;
&#13;
<p>In addition to the sequence itself, the FASTA record contains metadata such as the sequence ID, name, and such:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rec&#13;
SeqRecord(seq=Seq('GATTACA'),&#13;
          id='Rosalind_1',&#13;
          name='Rosalind_1',&#13;
          description='Rosalind_1',&#13;
          dbxrefs=[])</pre>&#13;
&#13;
<p>The read information is wrapped in a <code>Seq</code> object, which has many interesting and useful methods you can explore in the REPL using <strong><code>help(rec.seq)</code></strong>.<a data-primary="Seq object" data-type="indexterm" id="idm45963630828136"/>&#13;
I’m only interested in the raw sequence, so I can use the <code>str()</code> function to coerce it to a string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; str(rec.seq)&#13;
'GATTACA'</pre>&#13;
&#13;
<p>I need all the sequences in a list so that I can find the length of the shortest one.&#13;
I can use a list comprehension to read the entire file into a list since I’ll be using these many times:<a data-primary="list comprehension" data-secondary="reading file into list" data-type="indexterm" id="idm45963630825432"/><a data-primary="file input" data-secondary="reading file into list" data-type="indexterm" id="idm45963630824488"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; fh = open('./tests/inputs/1.fa') <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-1" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
&gt;&gt;&gt; seqs = [str(rec.seq) for rec in SeqIO.parse(fh, 'fasta')] <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-2" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
&gt;&gt;&gt; seqs&#13;
['GATTACA', 'TAGACCA', 'ATACA']</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-1" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Reopen the filehandle or the existing filehandle will continue from the second read.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-2" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create a list, coercing each record’s sequence to a string.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>Sequence files may hold millions of reads, and storing them in a list could easily <a data-primary="file input" data-secondary="reading file into list" data-tertiary="memory issues" data-type="indexterm" id="idm45963630811352"/><a data-primary="memory issues" data-secondary="reading files" data-type="indexterm" id="idm45963630810136"/>exceed the available memory and crash your machine. (Ask me how I know.) The problem is that I need all the sequences in the next step to find the subsequence that is common to all of them. I have several <em>Makefile</em> targets that will use the <code>genseq.py</code> program in the <em>10_lcsm</em> directory to generate large FASTA inputs with a common motif for you to test. This program works adequately for the datasets provided by Rosalind.</p>&#13;
</div>&#13;
&#13;
<p>The same idea can be expressed using the <code>map()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; fh = open('./tests/inputs/1.fa')&#13;
&gt;&gt;&gt; seqs = list(map(lambda rec: str(rec.seq), SeqIO.parse(fh, 'fasta')))&#13;
&gt;&gt;&gt; seqs&#13;
['GATTACA', 'TAGACCA', 'ATACA']</pre>&#13;
&#13;
<p>To find the length of the shortest sequence, I need to find the lengths of all the sequences, which I can do using a list comprehension:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [len(seq) for seq in seqs]&#13;
[7, 7, 5]</pre>&#13;
&#13;
<p>I prefer the shorter way to write this using a <code>map()</code>:<a data-primary="map() function transforming" data-secondary="finding shortest sequence" data-type="indexterm" id="idm45963630803160"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(map(len, seqs))&#13;
[7, 7, 5]</pre>&#13;
&#13;
<p>Python has built-in <code>min()</code> and <code>max()</code> functions that will return the minimum or maximum value from a list:<a data-primary="min() function" data-type="indexterm" id="idm45963630800056"/><a data-primary="max() function" data-type="indexterm" id="idm45963630799384"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; min(map(len, seqs))&#13;
5&#13;
&gt;&gt;&gt; max(map(len, seqs))&#13;
7</pre>&#13;
&#13;
<p>So the shortest sequence is equal to the minimum of the lengths:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; shortest = min(map(len, seqs))&#13;
&gt;&gt;&gt; shortest&#13;
5</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Extracting K-mers from a Sequence" data-type="sect2"><div class="sect2" id="idm45963630796392">&#13;
<h2>Extracting K-mers from a Sequence</h2>&#13;
&#13;
<p>The longest shared subsequence can be no longer than the shortest sequence and must be shared by all the reads.&#13;
Therefore, my next step is to find all the k-mers in all the sequences, starting with <code>k</code> equal to the length of the shortest sequence (<code>5</code>).<a data-primary="k-mers" data-secondary="extracting all k-mers in sequences" data-type="indexterm" id="idm45963630793976"/>&#13;
In <a data-type="xref" href="ch09.html#ch09">Chapter 9</a> I wrote a <code>find_kmers()</code> function and test, so I’ll copy that code into this program.&#13;
Remember to import <code>typing.List</code> for this:</p>&#13;
&#13;
<pre data-type="programlisting">def find_kmers(seq: str, k: int) -&gt; List[str]:&#13;
    """ Find k-mers in string """&#13;
&#13;
    n = len(seq) - k + 1&#13;
    return [] if n &lt; 1 else [seq[i:i + k] for i in range(n)]&#13;
&#13;
&#13;
def test_find_kmers() -&gt; None:&#13;
    """ Test find_kmers """&#13;
&#13;
    assert find_kmers('', 1) == []&#13;
    assert find_kmers('ACTG', 1) == ['A', 'C', 'T', 'G']&#13;
    assert find_kmers('ACTG', 2) == ['AC', 'CT', 'TG']&#13;
    assert find_kmers('ACTG', 3) == ['ACT', 'CTG']&#13;
    assert find_kmers('ACTG', 4) == ['ACTG']&#13;
    assert find_kmers('ACTG', 5) == []</pre>&#13;
&#13;
<p>One logical approach is to start with the maximum possible value of <code>k</code> and count down, stopping when I find a k-mer shared by all the sequences.&#13;
So far I’ve only used the <code>range()</code> function to count up.&#13;
Can I reverse the start and stop values to count down?&#13;
Apparently not.&#13;
If the start value is greater than the stop value, then <code>range()</code> will produce an empty list:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(range(shortest, 0))&#13;
[]</pre>&#13;
&#13;
<p>When reading codons in <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>, I mentioned that the <code>range()</code> function accepts up to three arguments, the last of which is the <em>step</em>, which I used there to jump three bases at a time.&#13;
Here I need to use a step of <code>-1</code> to count down.<a data-primary="range() function" data-secondary="counting down" data-type="indexterm" id="idm45963630784312"/>&#13;
Remember that the stop value is not included:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(range(shortest, 0, -1))&#13;
[5, 4, 3, 2, 1]</pre>&#13;
&#13;
<p>Another way to count backward is to count up and reverse the results:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(reversed(range(1, shortest + 1)))&#13;
[5, 4, 3, 2, 1]</pre>&#13;
&#13;
<p>Either way, I want to iterate over decreasing values of <code>k</code> until I find a k-mer that is shared by all the sequences.&#13;
A sequence might contain multiple copies of the same k-mer, so it’s important to make the result unique by using the <code>set()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from lcsm import find_kmers&#13;
&gt;&gt;&gt; from pprint import pprint&#13;
&gt;&gt;&gt; for k in range(shortest, 0, -1):&#13;
...     print(f'==&gt; {k} &lt;==')&#13;
...     pprint([set(find_kmers(s, k)) for s in seqs])&#13;
...&#13;
==&gt; 5 &lt;==&#13;
[{'TTACA', 'GATTA', 'ATTAC'}, {'TAGAC', 'AGACC', 'GACCA'}, {'ATACA'}]&#13;
==&gt; 4 &lt;==&#13;
[{'ATTA', 'TTAC', 'TACA', 'GATT'},&#13;
 {'GACC', 'AGAC', 'TAGA', 'ACCA'},&#13;
 {'TACA', 'ATAC'}]&#13;
==&gt; 3 &lt;==&#13;
[{'ACA', 'TAC', 'GAT', 'ATT', 'TTA'},&#13;
 {'AGA', 'TAG', 'CCA', 'ACC', 'GAC'},&#13;
 {'ACA', 'ATA', 'TAC'}]&#13;
==&gt; 2 &lt;==&#13;
[{'AC', 'AT', 'CA', 'TA', 'TT', 'GA'},&#13;
 {'AC', 'CA', 'CC', 'TA', 'AG', 'GA'},&#13;
 {'AC', 'AT', 'CA', 'TA'}]&#13;
==&gt; 1 &lt;==&#13;
[{'G', 'C', 'T', 'A'}, {'G', 'C', 'T', 'A'}, {'C', 'T', 'A'}]</pre>&#13;
&#13;
<p>Can you see a way to use this idea to count all the k-mers for each value of <code>k</code>?&#13;
Look for k-mers that have a frequency matching the number of sequences.&#13;
If you find more than one, print any one of them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963630776696">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>The two variations for this program use the same basic logic to find the longest shared subsequence.&#13;
The first version proves to scale poorly as the input size increases because it uses a stepwise, linear approach to iterating over every possible <code>k</code>-length of sequence.&#13;
The second version introduces a binary search to find a good starting value for <code>k</code> and then initiates a hill-climbing search to discover a maximum value <span class="keep-together">for <code>k</code>.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Counting Frequencies of K-mers" data-type="sect2"><div class="sect2" id="idm45963630772984">&#13;
<h2>Solution 1: Counting Frequencies of K-mers</h2>&#13;
&#13;
<p>In the previous section, I got as far as finding all the k-mers in the sequences for values of <code>k</code>, starting with the shortest sequence and moving down to <code>1</code>.<a data-primary="longest shared subsequence" data-secondary="solution 1 frequencies of k-mers" data-type="indexterm" id="ch10-kfreq"/><a data-primary="subsequences" data-secondary="longest shared" data-tertiary="solution 1 frequencies of k-mers" data-type="indexterm" id="ch10-kfreq2"/><a data-primary="k-mers" data-secondary="counting frequencies of" data-type="indexterm" id="ch10-kfreq3"/><a data-primary="counting things in strings" data-secondary="k-mer frequencies" data-type="indexterm" id="ch10-kfreq4"/>&#13;
Here I’ll start with <code>k</code> equal to <code>5</code>, which was the length of the shortest sequence in the first FASTA file:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; fh = open('./tests/inputs/1.fa')&#13;
&gt;&gt;&gt; seqs = [str(rec.seq) for rec in SeqIO.parse(fh, 'fasta')]&#13;
&gt;&gt;&gt; shortest = min(map(len, seqs))&#13;
&gt;&gt;&gt; kmers = [set(find_kmers(seq, shortest)) for seq in seqs]&#13;
&gt;&gt;&gt; kmers&#13;
[{'TTACA', 'GATTA', 'ATTAC'}, {'TAGAC', 'AGACC', 'GACCA'}, {'ATACA'}]</pre>&#13;
&#13;
<p>I need a way to count how many times each k-mer appears across all the sequences.&#13;
One approach is to use <code>collections.Counter()</code>, which I first showed in <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>:<a data-primary="Counter() function" data-type="indexterm" id="idm45963630761480"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from collections import Counter&#13;
&gt;&gt;&gt; counts = Counter()</pre>&#13;
&#13;
<p>I can iterate over each set of k-mers from the sequences and use the <code>Counter.update()</code> method to add them:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for group in kmers:&#13;
...     counts.update(group)&#13;
...&#13;
&gt;&gt;&gt; pprint(counts)&#13;
Counter({'TTACA': 1,&#13;
         'GATTA': 1,&#13;
         'ATTAC': 1,&#13;
         'TAGAC': 1,&#13;
         'AGACC': 1,&#13;
         'GACCA': 1,&#13;
         'ATACA': 1})</pre>&#13;
&#13;
<p>Or I could concatenate the many lists of k-mers together into a single list using <span class="keep-together"><code>itertools.chain()</code></span>:<a data-primary="lists" data-secondary="concatenating together" data-type="indexterm" id="idm45963630756808"/><a data-primary="concatenating lists together" data-type="indexterm" id="idm45963630755864"/><a data-primary="chain() function to concatenate lists" data-type="indexterm" id="idm45963630755176"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from itertools import chain&#13;
&gt;&gt;&gt; list(chain.from_iterable(kmers))&#13;
['TTACA', 'GATTA', 'ATTAC', 'TAGAC', 'AGACC', 'GACCA', 'ATACA']</pre>&#13;
&#13;
<p>Using this as the input for the <code>Counter()</code> produces the same collection, showing that each 5-mer is unique, occurring once each:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; counts = Counter(chain.from_iterable(kmers))&#13;
&gt;&gt;&gt; pprint(counts)&#13;
Counter({'TTACA': 1,&#13;
         'GATTA': 1,&#13;
         'ATTAC': 1,&#13;
         'TAGAC': 1,&#13;
         'AGACC': 1,&#13;
         'GACCA': 1,&#13;
         'ATACA': 1})</pre>&#13;
&#13;
<p>The <code>Counter()</code> is a regular dictionary underneath, which means I have access to all the dictionary methods.&#13;
I want to iterate through the keys and values as pairs using the <code>dict.items()</code> method to find where the count of the k-mers is equal to the number of sequences:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; n = len(seqs)&#13;
&gt;&gt;&gt; candidates = []&#13;
&gt;&gt;&gt; for kmer, count in counts.items():&#13;
...     if count == n:&#13;
...         candidates.append(kmer)&#13;
...&#13;
&gt;&gt;&gt; candidates&#13;
[]</pre>&#13;
&#13;
<p>When <code>k</code> is <code>5</code>, there are no candidate sequences, so I need to try with a smaller value.&#13;
Since I know the right answer is <code>2</code>, I’ll rerun this code with <code>k=2</code> to produce this <span class="keep-together">dictionary:</span></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; k = 2&#13;
&gt;&gt;&gt; kmers = [set(find_kmers(seq, k)) for seq in seqs]&#13;
&gt;&gt;&gt; counts = Counter(chain.from_iterable(kmers))&#13;
&gt;&gt;&gt; pprint(counts)&#13;
Counter({'CA': 3,&#13;
         'AC': 3,&#13;
         'TA': 3,&#13;
         'GA': 2,&#13;
         'AT': 2,&#13;
         'TT': 1,&#13;
         'AG': 1,&#13;
         'CC': 1})</pre>&#13;
&#13;
<p>From this, I find three candidate 2-mers have a frequency of 3, which equals the number of sequences:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; candidates = []&#13;
&gt;&gt;&gt; for kmer, count in counts.items():&#13;
...     if count == n:&#13;
...         candidates.append(kmer)&#13;
...&#13;
&gt;&gt;&gt; candidates&#13;
['CA', 'AC', 'TA']</pre>&#13;
&#13;
<p>It doesn’t matter which of the candidates I choose, so I’ll use the <code>random.choice()</code> function which returns one value from a list of choices:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import random&#13;
&gt;&gt;&gt; random.choice(candidates)&#13;
'AC'</pre>&#13;
&#13;
<p>I like where this is going, so I’d like to put it into a function so I can test it:</p>&#13;
&#13;
<pre data-type="programlisting">def common_kmers(seqs: List[str], k: int) -&gt; List[str]:&#13;
    """ Find k-mers common to all sequences """&#13;
&#13;
    kmers = [set(find_kmers(seq, k)) for seq in seqs]&#13;
    counts = Counter(chain.from_iterable(kmers))&#13;
    n = len(seqs) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-1" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
    return [kmer for kmer, freq in counts.items() if freq == n] <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-2" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-1" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Find the number of sequences.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-2" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Return the k-mers having a frequency equal to the number of sequences.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This makes for a pretty readable <code>main()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">import random&#13;
import sys&#13;
&#13;
&#13;
def main() -&gt; None:&#13;
    args = get_args()&#13;
    seqs = [str(rec.seq) for rec in SeqIO.parse(args.file, 'fasta')] <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-1" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
    shortest = min(map(len, seqs)) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-2" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    for k in range(shortest, 0, -1): <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-3" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-3"><img alt="3" src="assets/3.png"/></a>&#13;
        if kmers := common_kmers(seqs, k): <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-4" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-4"><img alt="4" src="assets/4.png"/></a>&#13;
            print(random.choice(kmers)) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-5" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-5"><img alt="5" src="assets/5.png"/></a>&#13;
            sys.exit(0) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-6" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-6"><img alt="6" src="assets/6.png"/></a>&#13;
&#13;
    print('No common subsequence.') <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-7" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-7"><img alt="7" src="assets/7.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-1" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Read all the sequences into a list.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-2" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Find the length of the shortest sequence.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-3" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Count down from the shortest sequence.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-4" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Find all the common k-mers using this value of <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-5" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>If any k-mers are found, print a random selection.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-6" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Exit the program using an exit value of <code>0</code> (no errors).</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-7" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO4-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>If I make it to this point, inform the user there is no shared sequence.<a data-primary="status report printed at end of execution" data-secondary="shared subsequences" data-type="indexterm" id="idm45963630694168"/></p></dd>&#13;
</dl>&#13;
&#13;
<p>In the preceding code, I’m again using the walrus operator (<code>:=</code>) I introduced in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a> to <a data-primary="equal signs" data-secondary=":= (variable assignment and testing)" data-secondary-sortas="# variable assignment" data-type="indexterm" id="idm45963630691256"/><a data-primary=":= (variable assignment and testing)" data-primary-sortas="# variable assignment" data-type="indexterm" id="idm45963630690024"/><a data-primary="variables" data-secondary=":= (assignment and testing)" data-secondary-sortas="# assignment and testing" data-type="indexterm" id="idm45963630689064"/><a data-primary="walrus operator (:=)" data-type="indexterm" id="idm45963630687816"/>first assign the result of calling <code>common_kmers()</code> to the variable <code>kmers</code> and then evaluate <code>kmers</code> for truthiness.&#13;
Python will only enter the next block if <code>kmers</code> is truthy, meaning there were common k-mers found for this value of <code>k</code>.&#13;
Before the addition of this language feature, I would have had to write the assignment and evaluation on two lines, like so:<a data-startref="ch10-kfreq" data-type="indexterm" id="idm45963630684520"/><a data-startref="ch10-kfreq2" data-type="indexterm" id="idm45963630683848"/><a data-startref="ch10-kfreq3" data-type="indexterm" id="idm45963630683176"/><a data-startref="ch10-kfreq4" data-type="indexterm" id="idm45963630682504"/></p>&#13;
&#13;
<pre data-type="programlisting">kmers = common_kmers(seqs, k)&#13;
if kmers:&#13;
    print(random.choice(kmers))</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Speeding Things Up with a Binary Search" data-type="sect2"><div class="sect2" id="idm45963630680744">&#13;
<h2>Solution 2: Speeding Things Up with a Binary Search</h2>&#13;
&#13;
<p>As noted in the opening section of this chapter, this solution grows much slower as the size of the inputs increases.<a data-primary="longest shared subsequence" data-secondary="solution 2 binary search faster" data-type="indexterm" id="ch10-binsh"/><a data-primary="subsequences" data-secondary="longest shared" data-tertiary="solution 2 binary search faster" data-type="indexterm" id="ch10-binsh2"/><a data-primary="binary search" data-type="indexterm" id="ch10-binsh3"/><a data-primary="recursion" data-secondary="binary search" data-type="indexterm" id="ch10-binsh4"/><a data-primary="searches, linear versus binary" data-secondary="binary search" data-type="indexterm" id="ch10-binshx"/>&#13;
One way to track the progress of the program is to put a <code>print(k)</code> statement at the beginning of the <code>for</code> loop.<a data-primary="debugging" data-secondary="print() to track progress" data-type="indexterm" id="idm45963630672056"/><a data-primary="print() function" data-secondary="tracking program progress" data-type="indexterm" id="idm45963630671096"/>&#13;
Run this with the second input file, and you’ll see that it starts counting down from 1,000 and doesn’t reach the correct value for <code>k</code> until it hits 78.</p>&#13;
&#13;
<p>Counting backward by 1 is taking too long.&#13;
If your friend asked you to guess a number between 1 and 1,000, you wouldn’t start at 1,000 and keep guessing 1 less each time your friend said, “Too high.”&#13;
It’s much faster (and better for your friendship) to guess 500.&#13;
If your friend chose 453, they’d say “Too high,” so you’d be wise to choose 250.&#13;
They’d reply, “Too low,” and you’d keep splitting the differences between your last high and low guesses until you found the right answer.&#13;
This is a <em>binary search</em>, and it’s a great way to quickly find the location of a wanted value from a sorted list of values.</p>&#13;
&#13;
<p>To understand this better, I’ve included a program in the <em>10_lcsm</em> directory called <code>binsearch.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./binsearch.py -h&#13;
usage: binsearch.py [-h] -n int -m int&#13;
&#13;
Binary Search&#13;
&#13;
optional arguments:&#13;
  -h, --help         show this help message and exit&#13;
  -n int, --num int  The number to guess (default: None)&#13;
  -m int, --max int  The maximum range (default: None)</pre>&#13;
&#13;
<p>The following is the relevant portion of the program.&#13;
You can read the source code for the argument definitions if you like.&#13;
The <code>binary_search()</code> function is recursive, like one solution to the Fibonacci sequence problem from <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>.&#13;
Note that the search values must be sorted for binary searches to work, which the <code>range()</code> function provides:<a data-primary="binary search" data-secondary="sorted values" data-type="indexterm" id="idm45963630663160"/></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    nums = list(range(args.maximum + 1))&#13;
    pos = binary_search(args.num, nums, 0, args.maximum)&#13;
    print(f'Found {args.num}!' if pos &gt; 0 else f'{args.num} not present.')&#13;
&#13;
&#13;
def binary_search(x: int, xs: List[int], low: int, high: int) -&gt; int:&#13;
    print(f'{low:4} {high:4}', file=sys.stderr)&#13;
&#13;
    if high &gt;= low: <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-1" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
        mid = (high + low) // 2 <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-2" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
        if xs[mid] == x: <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-3" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-3"><img alt="3" src="assets/3.png"/></a>&#13;
            return mid&#13;
&#13;
        if xs[mid] &gt; x: <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-4" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-4"><img alt="4" src="assets/4.png"/></a>&#13;
            return binary_search(x, xs, low, mid - 1) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-5" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-5"><img alt="5" src="assets/5.png"/></a>&#13;
&#13;
        return binary_search(x, xs, mid + 1, high) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-6" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-6"><img alt="6" src="assets/6.png"/></a>&#13;
&#13;
    return -1 <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-7" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-7"><img alt="7" src="assets/7.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-1" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The base case to exit the recursion is when this is false.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-2" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The midpoint is halfway between <code>high</code> and <code>low</code>, using floor division.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-3" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Return the midpoint if the element is in the middle.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-4" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>See if the value at the midpoint is greater than the desired value.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-5" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Search the lower values.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-6" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Search the higher values.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-7" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO5-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>The value was not found.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The names <code>x</code> and <code>xs</code> in the <code>binary_search()</code> function are meant to be singular and plural. In my head, I pronounce them <em>ex</em> and <em>exes</em>. This kind of notation is common in purely functional programming because I’m not trying to describe what kind of value <code>x</code> is. It could be a string or a number or anything. The important point is that <code>xs</code> is some collection of comparable values all of the same type.</p>&#13;
</div>&#13;
&#13;
<p>I included some <code>print()</code> statements so that, running with the previous numbers, you can see how <code>low</code> and <code>high</code> finally converge on the target number in 10 steps:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./binsearch.py -n 453 -m 1000&#13;
   0 1000&#13;
   0  499&#13;
 250  499&#13;
 375  499&#13;
 438  499&#13;
 438  467&#13;
 453  467&#13;
 453  459&#13;
 453  455&#13;
 453  453&#13;
Found 453!</pre>&#13;
&#13;
<p>It takes just eight iterations to determine the number is not present:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./binsearch.py -n 453 -m 100&#13;
   0  100&#13;
  51  100&#13;
  76  100&#13;
  89  100&#13;
  95  100&#13;
  98  100&#13;
 100  100&#13;
 101  100&#13;
453 not present.</pre>&#13;
&#13;
<p>The binary search can tell me if a value occurs in a list of values, but this is not quite my problem.&#13;
While I’m reasonably sure there will be at least a 2- or 1-mer in common in most datasets, I have included one file that has none:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/none.fa&#13;
&gt;Rosalind_1&#13;
GGGGGGG&#13;
&gt;Rosalind_2&#13;
AAAAAAAA&#13;
&gt;Rosalind_3&#13;
CCCC&#13;
&gt;Rosalind_4&#13;
TTTTTTTT</pre>&#13;
&#13;
<p>If there is an acceptable value for <code>k</code>, then I need to find the <em>maximum</em> value.&#13;
I decided to use the binary search to find a starting point for a hill-climbing search to find the maximum value.&#13;
First I’ll show <code>main()</code>, and then I’ll break down the other functions:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    seqs = [str(rec.seq) for rec in SeqIO.parse(args.file, 'fasta')] <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-1" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
    shortest = min(map(len, seqs)) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-2" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
    common = partial(common_kmers, seqs) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-3" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-3"><img alt="3" src="assets/3.png"/></a>&#13;
    start = binary_search(common, 1, shortest) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-4" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    if start &gt;= 0: <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-5" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-5"><img alt="5" src="assets/5.png"/></a>&#13;
        candidates = [] <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-6" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-6"><img alt="6" src="assets/6.png"/></a>&#13;
        for k in range(start, shortest + 1): <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-7" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-7"><img alt="7" src="assets/7.png"/></a>&#13;
            if kmers := common(k): <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-8" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-8"><img alt="8" src="assets/8.png"/></a>&#13;
                candidates.append(random.choice(kmers)) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-9" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-9"><img alt="9" src="assets/9.png"/></a>&#13;
            else:&#13;
                break <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-10" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-10"><img alt="10" src="assets/10.png"/></a>&#13;
&#13;
        print(max(candidates, key=len)) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-11" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-11"><img alt="11" src="assets/11.png"/></a>&#13;
    else:&#13;
        print('No common subsequence.') <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-12" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-12"><img alt="12" src="assets/12.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-1" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Get a list of the sequences as strings.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-2" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Find the length of the shortest sequence.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-3" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Partially apply the <code>common_kmers()</code> function with the <code>seqs</code> input.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-4" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Use the binary search to find a starting point for the given function, using <code>1</code> for the lowest value of <code>k</code> and the shortest sequence length for the maximum.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-5" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Check that the binary search found something useful.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-6" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Initialize a list of the candidate values.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-7" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Start the hill climbing with the binary search result.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-8" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Check if there are common k-mers.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-9" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>If so, randomly add one to the list of candidates.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-10" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>If there are no common k-mers, break out of the loop.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-11" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-11"><img alt="11" src="assets/11.png"/></a></dt>&#13;
<dd><p>Choose the candidate sequence having the longest length.<a data-primary="status report printed at end of execution" data-secondary="shared subsequences" data-type="indexterm" id="idm45963630556312"/></p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-12" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO6-12"><img alt="12" src="assets/12.png"/></a></dt>&#13;
<dd><p>Let the user know that there is no answer.</p></dd>&#13;
</dl>&#13;
&#13;
<p>While there are many things to explain in the preceding code, I want to highlight the call to <code>max()</code>.&#13;
I showed earlier that this function will return the maximum value from a list.&#13;
Normally you might think to use this on a list of numbers:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; max([4, 2, 8, 1])&#13;
8</pre>&#13;
&#13;
<p>In the preceding code, I want to find the longest string in a list.&#13;
I can <code>map()</code> the <code>len()</code> function to find their lengths:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs = ['A', 'CC', 'GGGG', 'TTT']&#13;
&gt;&gt;&gt; list(map(len, seqs))&#13;
[1, 2, 4, 3]</pre>&#13;
&#13;
<p>This shows that the third sequence, <em>GGGG</em>, is the longest.&#13;
The <code>max()</code> function accepts an optional <code>key</code> argument, which is a function to apply to each element before comparing.<a data-primary="max() function" data-secondary="optional argument of function to apply" data-type="indexterm" id="idm45963630546504"/>&#13;
If I use the <code>len()</code> function, then <code>max()</code> correctly identifies the longest sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; max(seqs, key=len)&#13;
'GGGG'</pre>&#13;
&#13;
<p>Let’s take a look at how I modified the <code>binary_search()</code> function to suit my needs:</p>&#13;
&#13;
<pre data-type="programlisting">def binary_search(f: Callable, low: int, high: int) -&gt; int: <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-1" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Binary search """&#13;
&#13;
    hi, lo = f(high), f(low) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-2" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
    mid = (high + low) // 2 <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-3" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
    if hi and lo: <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-4" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-4"><img alt="4" src="assets/4.png"/></a>&#13;
        return high&#13;
&#13;
    if lo and not hi: <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-5" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-5"><img alt="5" src="assets/5.png"/></a>&#13;
        return binary_search(f, low, mid)&#13;
&#13;
    if hi and not lo: <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-6" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-6"><img alt="6" src="assets/6.png"/></a>&#13;
        return binary_search(f, mid, high)&#13;
&#13;
    return -1 <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-7" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-7"><img alt="7" src="assets/7.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-1" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function takes another function <code>f()</code> along with <code>low</code> and <code>high</code> values as arguments. In this instance, the function <code>f()</code> will return the common k-mers,  but the function can perform any calculation you like.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-2" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Call the function <code>f()</code> with the highest and lowest values for <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-3" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Find the midpoint value of <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-4" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>If the function <code>f()</code> found common k-mers for both the high and low <code>k</code> values, return the highest k.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-5" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>If the high <code>k</code> found no k-mers but the low value did, recursively call the function searching in the lower values of <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-6" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>If the low <code>k</code> found no k-mers but the high value did, recursively call the function searching in the higher values of <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-7" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO7-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Return <code>-1</code> to indicate no k-mers were found using the <code>high</code> and <code>low</code> arguments to <code>f()</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here is the test I wrote for this:</p>&#13;
&#13;
<pre data-type="programlisting">def test_binary_search() -&gt; None:&#13;
    """ Test binary_search """&#13;
&#13;
    seqs1 = ['GATTACA', 'TAGACCA', 'ATACA'] <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-1" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
    f1 = partial(common_kmers, seqs1) <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-2" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert binary_search(f1, 1, 5) == 2 <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-3" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
    seqs2 = ['GATTACTA', 'TAGACTCA', 'ATACTA'] <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-4" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-4"><img alt="4" src="assets/4.png"/></a>&#13;
    f2 = partial(common_kmers, seqs2)&#13;
    assert binary_search(f2, 1, 6) == 3 <a class="co" href="#callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-5" id="co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-1" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>These are the sequences I’ve been using that have three shared 2-mers.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-2" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Define a function to find the k-mers in the first set of sequences.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-3" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The search finds a <code>k</code> of <code>2</code> which is the right answer.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-4" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The same sequences as before but now with a shared 3-mer.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-5" id="callout_finding_the_longest_shared_subsequence__finding_k_mers__writing_functions__and_using_binary_search_CO8-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The search finds a <code>k</code> of <code>3</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Unlike the previous binary search, my version won’t (necessarily) return the <em>exact</em> answer, just a decent starting point.&#13;
If there are no shared sequences for any size <code>k</code>, then I let the user know:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./solution2_binary_search.py tests/inputs/none.fa&#13;
No common subsequence.</pre>&#13;
&#13;
<p>If there is a shared subsequence, this version runs significantly faster—perhaps as much as 28 times faster:</p>&#13;
&#13;
<pre data-type="programlisting">$ hyperfine -L prg ./solution1_kmers_functional.py,./solution2_binary_search.py\&#13;
  '{prg} tests/inputs/2.fa'&#13;
Benchmark #1: ./solution1_kmers_functional.py tests/inputs/2.fa&#13;
  Time (mean ± σ):     40.686 s ±  0.443 s    [User: 35.208 s, System: 6.042 s]&#13;
  Range (min … max):   40.165 s … 41.349 s    10 runs&#13;
&#13;
Benchmark #2: ./solution2_binary_search.py tests/inputs/2.fa&#13;
  Time (mean ± σ):      1.441 s ±  0.037 s    [User: 1.903 s, System: 0.255 s]&#13;
  Range (min … max):    1.378 s …  1.492 s    10 runs&#13;
&#13;
Summary&#13;
  './solution2_binary_search.py tests/inputs/2.fa' ran&#13;
   28.24 ± 0.79 times faster than './solution1_kmers_functional.py&#13;
   tests/inputs/2.fa'</pre>&#13;
&#13;
<p>When I was searching from the maximum <code>k</code> value and iterating down, I was performing a <em>linear</em> search through all the possible values.<a data-primary="binary search" data-secondary="linear search versus" data-type="indexterm" id="idm45963630466824"/><a data-primary="searches, linear versus binary" data-type="indexterm" id="idm45963630465880"/>&#13;
This means the time to search grows in proportion (linearly) to the number <em>n</em> of values.&#13;
A binary search, by contrast, grows at a rate of log <em>n</em>.&#13;
It’s common to talk about the runtime growth of algorithms using <em>Big O</em> notation, so you might see binary search described as O(log <em>n</em>), <a data-primary="Big O notation" data-type="indexterm" id="idm45963630463032"/><a data-primary="runtime growth of algorithms in Big O notation" data-type="indexterm" id="idm45963630462360"/>whereas linear searching is O(<em>n</em>)—which is much worse.<a data-startref="ch10-binsh" data-type="indexterm" id="idm45963630461016"/><a data-startref="ch10-binsh2" data-type="indexterm" id="idm45963630460344"/><a data-startref="ch10-binsh3" data-type="indexterm" id="idm45963630459672"/><a data-startref="ch10-binsh4" data-type="indexterm" id="idm45963630459000"/><a data-startref="ch10-binshx" data-type="indexterm" id="idm45963630458328"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963630457176">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>As with the suggestion in <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>, add a Hamming distance option that will allow for the indicated number of differences when deciding on a shared k-mer.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963630454600">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>K-mers can be used to find conserved regions of sequences.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lists of lists can be combined into a single list using <code>itertools.chain()</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A binary search can be used on sorted values to find a value more quickly than searching through the list linearly.</p>&#13;
</li>&#13;
<li>&#13;
<p>Hill climbing is one way to maximize the input to a function.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>key</code> option for <code>min()</code> and <code>max()</code> is a function that is applied to the values before comparing them.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>