- en: 2 Encoding geographies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How to use the results-driven approach to tackle a real problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making analytical decisions in the face of uncertainty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you have been introduced to the results-driven approach, let’s apply
    it to a real data science task. We will tackle a real-world problem and apply
    the results-driven method to it. It is a template for approaching the other projects
    and any other project you encounter in the future.
  prefs: []
  type: TYPE_NORMAL
- en: All the projects and data are available at [https://davidasboth.com/book-code](https://davidasboth.com/book-code)
    for you to attempt them yourself. There, you will find both the dataset for the
    project and the same example solution presented in the chapter in the form of
    a Jupyter notebook.
  prefs: []
  type: TYPE_NORMAL
- en: A note on Jupyter notebooks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Jupyter is a development environment that allows the mixing of code and accompanying
    text in the form of notebooks. Notebook files let you read the text and run the
    code directly within the document. They are popular for education and data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: The notebooks accompanying the book collect the code snippets from each chapter
    into a single document where the code is also runnable. Sites such as GitHub even
    let you view the notebooks in the browser without requiring Jupyter to be installed.
    See the appendix for instructions on how to install Python to run the code yourself.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter’s project, let’s examine an example task that analysts encounter,
    which at first glance might seem simple enough—encoding geography.
  prefs: []
  type: TYPE_NORMAL
- en: '2.1 Project 1: Identifying customer geographies'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at the project in which we will extract location information from
    free text to better understand our customer base. As an analyst for ProWidget
    Systems, a UK-based B2B (business-to-business) retailer, you’ve been asked to
    report on spending volumes for London-based customers versus those based in the
    rest of the United Kingdom. The board has supplied a high-level data extract containing
    all customers’ addresses and their total spending to date. They want to know
  prefs: []
  type: TYPE_NORMAL
- en: Which UK cities are currently underserved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether their customers are primarily London based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this were a sanitized tutorial, your data would likely have a column called
    `city`, and your task would be more about the technical steps required to group
    the data by city and summarize it using an appropriate metric. Perhaps you would
    take the total spending from all London-based customers and compare it against
    the same figure from other major cities in the United Kingdom or all data where
    the `city` column is not London. Perhaps you would choose to show the distribution
    instead to get a more detailed picture of the difference. Either way, your choice
    is more about the specific *technical* steps required to get an answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare this to answering the same question as an analyst in a real business.
    For instance, in this project, the available data is not organized cleanly enough
    to have a `city` column: we only have a single `customer` `address` column, which
    may or may not contain the city somewhere within it. The address data for this
    project comes from Companies House, an executive agency sponsored by the UK government’s
    Department for Business and Trade. The original public data, which I modified
    for this exercise, is available at [https://mng.bz/mGxr](https://mng.bz/mGxr).'
  prefs: []
  type: TYPE_NORMAL
- en: Before doing any analysis, we need to decide how to identify what city an address
    relates to. We will follow the results-driven process laid out in chapter 1 to
    do this and get an answer for our stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Real business case: Finding new leads with address data'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: As a data scientist, one data-driven tool I built was a map of all our customers
    combined with a list of all companies in the United Kingdom that were in a relevant
    industry to be our potential customers. The sales team used this map to identify
    prospective customers in the local area whenever they went to visit an existing
    customer.
  prefs: []
  type: TYPE_NORMAL
- en: The project involved combining our own customer data with the government’s official
    public list of companies, and the bulk of the work was sanitizing address data
    in both lists so they could be compared, which is why that is the topic of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1.1 Data dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step in understanding what’s in a dataset is to read the data dictionary
    or ask for one if it wasn’t provided. You may ultimately need to write one yourself.
    One of the ways the real world differs from this book’s projects is that I provide
    well-documented data dictionaries. Don’t get used to it! Table 2.1 shows the data
    dictionary for the supplied data, and figure 2.1 shows a snapshot of the first
    few rows.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 A snapshot of the first few rows of customer address data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Table 2.1 Data dictionary for the customer address dataset
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Column | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `company_id`  | A unique identifier for each customer company in the dataset  |'
  prefs: []
  type: TYPE_TB
- en: '| `address`  | A single field to store the customer address  |'
  prefs: []
  type: TYPE_TB
- en: '| `total_spend`  | The total amount this customer has spent to date (in GBP)  |'
  prefs: []
  type: TYPE_TB
- en: Now that we have our problem statement and have seen the available data, it
    is time to start our results-driven process to arrive at a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '2.2 An example solution: Finding London'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, I will dive into an example solution, focusing on the steps
    of the results-driven approach, as well as the details of solving the problem.
    You may wish to attempt this problem yourself before going further or use this
    chapter to get a feel for the structure of the rest of the projects. As for most
    solutions I provide, the code itself will be written in Python, primarily using
    the `pandas` library. While code snippets will be used to explain the example
    solution, I will focus discussions on the conceptual solution and less on the
    code specifics. The solution will have three parts: setting up the problem statement
    and the data, creating the first iteration of a solution, and reviewing the work
    and deciding on further steps.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.1 Setting ourselves up for success
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![figure](../Images/2-unnumb-1.png)'
  prefs: []
  type: TYPE_IMG
- en: The first step is to ensure we understand the problem. In this case, we know
    we need to use our customer address data to calculate the total spending by city
    across the United Kingdom and come up with an answer for how London customers
    compare with the rest of the country. If we encountered multiple metrics in the
    data, such as the number of transactions a customer has made or how long they
    have been a customer, we would need to clarify the purpose of the question with
    our stakeholders so that we know which metrics to focus on.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the data provided does not contain this ambiguity; it is clear
    we are focusing on spending patterns across two predefined geographic areas. However,
    had our stakeholders asked us about which areas are underserved in general, we
    would also seek to understand whether we should look at data at a city level or
    a different level of granularity.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-unnumb-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The crucial step in any analysis is to think of where we are going. What form
    will a minimum viable answer take? In this example, our stakeholders have two
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Are different cities underserved?* This requires us to calculate total customer
    spending by city and find cities with the lowest customer spending.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How does London compare to the rest of the United Kingdom?* This can then
    be answered from the output of the first answer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a minimum viable answer to exist, we need to add a `city` column to our
    data, which we will extract from the address. This will allow us to have a breakdown
    of spending by city, meaning we could take the row for London and compare it against
    the rest of the table. As for the final output, a table or a bar chart will suffice
    for both cases. It may seem obvious, but knowing the exact format of our output
    will guide us toward a relevant solution, which is a table containing one row
    per city and an associated total spending figure.
  prefs: []
  type: TYPE_NORMAL
- en: '*![figure](../Images/2-unnumb-3.png)'
  prefs: []
  type: TYPE_NORMAL
- en: To tackle any analytical question, we need to know what data is required to
    answer it. To get city-level customer figures, we need data on which city each
    customer belongs to. This requires that each customer record has a `city` column,
    or at least some sort of address data, against it. We know in this case that an
    address field has been provided, so we have sufficient data to attempt the problem,
    even if we are unsure at this stage whether we can get a satisfactory answer.
    In this step, we also decide on additional data sources we might need. In this
    case, it might be to enhance the accuracy of our address data. Our first iteration
    should usually focus on the data we already have, and additional data sources
    can be considered in future iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-unnumb-4.png)'
  prefs: []
  type: TYPE_IMG
- en: The step of acquiring data should not be underestimated. Entire data science
    initiatives have failed because the data science team never received any usable
    data to analyze. The obstacles to obtaining data are not technical but organizational,
    and it is one aspect of the real world we won’t simulate. Throughout the projects,
    you will not need to find any data yourself; it will be provided. It will not
    always be easy to clean, but you will not spend any time emailing someone in your
    organization and hoping for their goodwill to send you a data extract!
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.2 Creating the first iteration of a solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![figure](../Images/2-unnumb-5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By this point, we have established the problem statement and obtained all necessary
    data. It is now time to explore the dataset before extracting the city component
    of each address and summarizing customer spending data by city. Let’s start by
    importing the necessary libraries and reading in the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output is `(100000, 3)`, meaning we have a total of 100,000 rows of data
    and the three columns we saw in the data dictionary. Before extracting any city
    data, we should check for missing values.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating missing values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Depending on your tool of choice, attempting to extract data from empty addresses
    may yield errors. The output of the following code snippet is shown in figure
    2.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/2-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 A table showing the number of missing values per column
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can see there are 968 missing addresses, which is just under 1% of our rows.
    Since we have no way of knowing the addresses of those missing customers just
    from the data provided, we can safely drop these rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What percentage of rows is acceptable to drop will depend on the context, but
    losing 1% due to missing key information is fine. If, say, 10% of our customers
    had missing addresses, we might want to examine why.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is a point where analyses might diverge. The missing address data
    could either be kept and categorized simply as “Other” or, if we had more customer-related
    data, we may choose to spend the time looking up a customer’s address elsewhere
    to get a more complete dataset.
  prefs: []
  type: TYPE_NORMAL
- en: There are many places in an analysis where there is no definitive right decision,
    only different decisions based on different assumptions. Because of this, your
    analysis will diverge from mine at various points. Figure 2.3 illustrates this
    branching of possible paths in a diagram, which I will use heavily to reiterate
    this point.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 The first step of the analysis and its alternative paths visualized
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are two types of shapes: steps and decisions. Steps represent sequential
    tasks to be undertaken in the analysis. These come from the original action plan
    but may also be informed by what we find in the data. Decisions represent places
    where the analysis might diverge, depending on the assumptions and choices made.
    Your analysis will not necessarily contain the same steps or the same decisions
    as mine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we are exploring our columns, we should also check if our `total_spend`
    column contains any strange values, such as negatives. The output of the following
    code snippet is shown in figure 2.4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/2-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 Summary statistics of the `total_spend` column
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As the figure shows, the values range from 0 to just under £12,000 with no
    negative values. Now that we have seen our data, we need to decide on an approach
    to extract the information about cities. Let’s think back to our two stakeholder
    questions: “Are different cities underserved?” and “How does London compare to
    the rest of the United Kingdom?” The second question is a subset of the first.
    That is, once you have a dataset of customer spending by city, it is easy to compare
    London against other cities. To solve one question means solving the other, so
    if we start by focusing on identifying addresses in London first, we can find
    the nuances and edge cases of how addresses are represented.'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting city column from addresses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before deciding on a method, we should look at some sample addresses. The following
    code prints the first five addresses, the output of which is shown in figure 2.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/2-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 Five sample addresses
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can already notice some patterns, as well as some potential pitfalls. From
    our limited sample, it appears that addresses end with the postcode, but sometimes
    London addresses contain a line for England, and sometimes they don’t. This means
    we cannot rely on looking at a specific row of an address to give us the city,
    which is useful information.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about looking for the string “London” to identify customers in London?
    Would that be sufficient? Probably not. You would end up including people who
    live on “London Road” in other towns, for a start. Examining the data, we can
    see that address lines are separated by a comma and a new line character, so looking
    for `"LONDON,"` could alleviate this particular problem. Note the extra comma
    in the search string. Our rule could simply be the following: if one of the rows
    of an address is “London,” then that address is a London one. In our sample, all
    addresses were uppercase, but we should not assume this will be the case for all
    100,000 rows, so we should ensure they are all uppercase ourselves. To compare
    our cleaned address data with the original, we will create a new column to store
    the cleaned version. It is usually a good idea to keep data in its raw form somewhere
    to reference as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have ensured that the casing is consistent, we can investigate
    the difference between looking for `"LONDON"` and `"LONDON,"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these lines of code is `21,768` and `20,831`, respectively, which
    means nearly 1,000 rows are no longer selected when we add the commas. Those are
    the addresses that contain the word London, but we assume are not, in fact, in
    the city of London (e.g., addresses on London Road). We have already seen from
    our sample addresses that we cannot rely on the position of a row to decide where
    the city component is. However, there may only be a finite number of address structures.
    Let’s look at how many addresses consist of how many rows. The output of this
    code is shown in figure 2.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Splits an address into a list of substrings (i.e., separate the rows)'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Counts the length of each list (i.e., the number of rows in the address)'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Now counts how many addresses are made of how many rows'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 Distribution of address lengths
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We can observe that some addresses consist of only one or two lines, and some
    have as many as six. In theory, if every three-line, four-line, five-line, and
    so forth address is consistent, we could come up with a rule to extract the city
    slightly differently from each. We should also examine some of these shorter addresses
    to see what they look like. The output of this code is shown in figures 2.7 and
    2.8, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Looks at five random rows that have only two lines of address. The random_state
    parameter ensures we get the same results each time for reproducibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 All the one-line addresses in our data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '![figure](../Images/2-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 A sample of five rows of two-line address data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: These figures show the variability of our data. Some rows are simply a city,
    Falkirk; there are entirely missing addresses referring us to a parent registry;
    and we also have PO Box addresses. It is unlikely we can come up with a rule to
    extract cities purely based on their position in the lines of an address without
    writing a lot of bespoke code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s remind ourselves of our goal: our immediate task is to create a `city`
    column, and we now have to decide how to proceed. One option is to take our London-finding
    example and extend it by explicitly looking for city names in the `address` column.
    This would require a comprehensive list of cities in the United Kingdom, which
    is not an impossible task. Such lists exist—for example, the list available at
    [https://mng.bz/5gKB](https://mng.bz/5gKB) is provided by the UK government. In
    this case, we would still need to decide what to do with addresses that fall outside
    of these cities. Do we simply label them “Other”? For a first iteration, this
    may suffice, as the question was specifically asking about cities, not towns or
    villages.'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use the postcode component of each address and look it
    up against a national postcode database, which we would have to obtain and ensure
    we are allowed to use. This might be a more accurate method but would require
    additional work, such as identifying the postcode component of each address in
    the first place.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we should err on the side of less effort for our first iteration,
    so we will attempt to use the list of cities in the UK provided by the UK government.
    The web page consists of a bulleted list of cities for each country of the United
    Kingdom, an extract of which is shown in figure 2.9.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 An extract of the UK government's web page listing all the cities
    in the United Kingdom
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are multiple ways to extract these into a code-friendly form. The simplest
    one is to copy and paste the bullet points from the website directly into Excel,
    so each city is on a separate line, and then import and clean the data in our
    code. The quickest option isn’t always to write code! However, for full reproducibility,
    you may want to automate that step. Obtaining this data manually will suit us
    here since we don’t expect the list of UK cities to change very often. This raw
    data is provided in the accompanying materials as a separate file called `cities.csv`.
    The first few rows of this data are shown in figure 2.10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/2-10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 The first few rows of city data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are clearly some aspects of this data to clean before using it as a definitive
    list of cities. First, the country headings were included as rows in the data,
    so the values `England`, `Scotland`, `Wales`, and `Northern` `Ireland` need to
    be removed. Then, the trailing asterisk `*` character also needs to be trimmed,
    and the remaining city names should be uppercased to match our address data. Figure
    2.11 shows a sample of our final, cleaned city list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/2-11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 A sample of our cleaned, definitive city list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we have our definitive list of cities, we can use it to create the
    `city` column. Figure 2.12 shows the work we have done so far and the alternatives
    in our most recent step.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-12.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 Diagram of the analysis so far after two main steps
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Creating a city column
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use our city list to tag an address with a particular city if that city
    name and an additional comma are found somewhere in the address. Using figure
    2.11 as an example, we will assume that an address that contains the substring
    `"BATH,"` is an address in the city of Bath, so the value in the `city` column
    will be `"BATH"`. Anything where this newly created `city` column doesn’t have
    a value, where none of the city names was found in the address, will be categorized
    as `"OTHER"`. The following code achieves this, and figure 2.13 shows the latest
    state of our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/2-13.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 An extract of the data with a newly added `city` column
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we have our new `city` column, we need to explore it to see which cities
    our customers are in and what proportion of our customers we weren’t able to allocate
    to a city based on their address.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the new city column
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Based on figure 2.13, it looks like we have correctly categorized the London
    and Bristol addresses from the first five rows, and put the rest in the “Other”
    category. We can now do our first piece of analysis by counting how many customers
    appear in each city, according to our categorization. Let’s look at the top 20,
    which are shown in figure 2.14:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/2-14.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 The top 20 cities by number of customers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Over half of our data is in the “Other” category, which means half of our customer
    base is established outside of major cities. This is an important insight to communicate
    to our stakeholders. Let’s look at some addresses from this category, as shown
    in figure 2.15:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![figure](../Images/2-15.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 A sample of addresses whose city is categorized as “Other”
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Some of these addresses relate to towns, but there is an address in Twickenham,
    which is a suburban district in London. While the address did not contain the
    word “London,” that customer should be categorized as being London based. We can
    already see some of the shortfalls of our chosen approach. At this point, we note
    them down and may consider tackling them in a future iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Note  Unless you have knowledge of UK geography, you may miss these instances
    of London addresses without the word “London” in them. This highlights how important
    domain knowledge is for an analyst and why you should work closely with domain
    experts.
  prefs: []
  type: TYPE_NORMAL
- en: 'One sanity check at this point is to see how many unique cities are in the
    government data and our tagged address data. Depending on the business, we might
    assume that we have at least one customer in every major UK city, and we can verify
    this. A Python trick is to create a unique set of the government’s city list and
    the list of unique cities in our new `city` column and subtract one set from the
    other. This will give us the difference between the lists, that is, cities that
    appear in the government list but not in our address data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Subtracting sets in Python means finding items in one list that aren’t in
    another.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this code is the string `{''KINGSTON-UPON-HULL''}`, which tells
    us that the city Kingston-upon-Hull is not in the `city` column of our customer
    address data. This either means we have no customers there, which is not impossible
    given its population is only around 250,000, or there is something else going
    on. The city is usually abbreviated to just “Hull,” which again is a case of applying
    specific domain knowledge to the problem, so let’s look for that in our address
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code tells us there are 284 relevant records. We can manually
    update our `city` column to fix this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let’s again review our analysis so far. The work we have done and the alternative
    steps are shown in figure 2.16.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-16.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 The current progress of our analysis
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can now finally take a look at spending figures by city using the newly created
    `city` column.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing spending by city
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The hard work was getting the data into the correct format; the analysis itself
    is a simple grouping and aggregation. The output chart is shown in figure 2.17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Defines a function to show figures in millions'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Sorts by descending total spending to get the top 20 highest spenders (required
    for the analysis)'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Now sorts in the opposite direction to make our horizontal bar chart have
    the highest numbers at the top (required for the Python plot)'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-17.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 Total customer spending by city
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It is clear that the “Other” category dominates. As we have seen before, our
    customers are just as likely to be based outside of a major city. This is partly
    down to how cities are defined in the United Kingdom. There are only 76 that are
    officially called “cities,” but there are many “towns” with significant populations.
    This distinction between towns and cities partly explains why the “Other” category
    is so large.
  prefs: []
  type: TYPE_NORMAL
- en: Another observation is that London does indeed come out as the top city in terms
    of customer spending, as well as the number of customers. The next largest cities
    in terms of spending, Manchester and Birmingham, are also the next largest by
    population. The top cities in both this chart and our customer volume calculation
    in figure 2.14 generally correspond to the top cities by population. Leeds is
    perhaps lower than you would expect based on its population, but there is no reason
    customer spending figures should correlate perfectly with population.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final inquiry is to compare London against the rest of the United Kingdom.
    We can take this to mean either “all of the United Kingdom that isn’t London”
    or “all major cities except London.” We should calculate both figures and decide
    how to report our findings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The output of this code tells us the total spending across our customers was
    £490M. This breaks down into £103M for London customers and £387M for the rest
    of the United Kingdom. If we look at all major cities outside London, the total
    is £119M. That is, if we compare London to other cities, we can see that our London
    customers generate nearly as much revenue as all other major cities combined.
    It does appear that our customer base is London-centric.
  prefs: []
  type: TYPE_NORMAL
- en: This gets us our minimum viable answer, except we haven’t fully answered the
    question of whether certain cities are underserved. Figure 2.17 shows us that
    the largest cities produce the highest amount of customer spend. To understand
    whether a city is being underserved, we would need to know more about what we
    would base that on. This would require a conversation with our stakeholders to
    understand whether they are missing any cities they expected to see among the
    highest-spending ones shown in figure 2.17\. Before we move on, let’s review all
    the steps we took in this analysis (figure 2.18).
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-18.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 The final analysis steps visualized
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At the end of this process, we have our minimum viable answer, and we’re ready
    to bring it to our stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2.3 Review and future steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![figure](../Images/2-unnumb-6.png)'
  prefs: []
  type: TYPE_IMG
- en: After cleaning our data and extracting city information, we have arrived at
    an answer to our analytical questions. Our customers spend the most in bigger
    cities since there are generally more customers in larger cities, and London generates
    nearly as much income as all the other cities combined. This insight, coupled
    with the table in figure 2.14 and the chart from figure 2.17, would fit on one
    or two slides to present to our stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: When presenting, we should be clear about the caveats of our analysis; namely,
    that not all addresses are in a format that allows us to extract the city correctly,
    at least with the method we have chosen. Another caveat is we have used the government’s
    list of cities, which excludes larger towns that our stakeholders may be interested
    in. We would make it clear to our stakeholders that further work is possible to
    make our city-level figures more accurate. However, we would need to understand
    the business value of spending more time arriving at a more accurate figure when
    it might not change the overall result.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/2-unnumb-7.png)'
  prefs: []
  type: TYPE_IMG
- en: After presenting our results, our stakeholders may want us to continue the analysis
    and get a more comprehensive answer. What could we do to improve our solution?
    Perhaps, as we have discussed, we could identify the city or town an address refers
    to by identifying the postcode. Well, for that, we need a comprehensive list of
    UK postcodes, the assumption that all values in the “customer address” field contain
    postcodes, and the assumption that we can find the postcode every time. Another
    option is to expand our current city list to include towns above a certain population.
    However, this would not solve the problem where sometimes the name of the city
    or town is not in the address.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to send these addresses to a third-party geocoding system,
    such as the Google Maps API, which would find the best match for an address we
    provide, and the resulting data would contain a field for the town/city that we
    could use. However, this particular option raises privacy concerns. Do we want
    to send all our customers’ addresses to a third party? Are we even allowed to
    do that?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we could augment our data with population statistics or even demographic
    information about each city or town. This could help us understand whether there
    are cities where customers are spending less than expected based on their city’s
    population and are, therefore, being underserved. This was one of our stakeholders’
    initial concerns, and this would be one way to address it further.
  prefs: []
  type: TYPE_NORMAL
- en: You can start to see how many additional considerations are involved in solving
    a real business problem. This is why it is vital to arrive at a viable solution
    as soon as possible so that these additional possibilities are only considered
    if there is tangible business value in doing so. The value of any further work
    should be decided in collaboration with key stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Further project ideas with this data'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In each project chapter, I encourage you to think of other possible research
    questions to answer with this data, unrelated to the specific chapter project.
    This is an exercise to help you make your solution really your own and let it
    stand out in a portfolio. Here are some ideas to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: What do customer spending figures look like at different levels of granularity?
    You would need to either dig down into subcity levels, such as boroughs, or figure
    out how to group addresses that belong to the same geographic region (e.g., South
    West England).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you identify business addresses and consider comparing customers with private
    addresses versus those with business addresses?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augment your geographic analysis with population figures or other demographics.
    Are there any patterns, such as a relationship between the wealth of an area and
    the amount of customer spend? You could also calculate “spending per capita” for
    each city and see if that varies across the country.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.3 How to use the rest of the book
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter introduced both a specific example of the results-driven approach
    in practice and the format of all the projects. Each project throughout your career
    will require you to
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you understand the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about the end goal you are working toward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider whether you have the right data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the caveats you would need to flag when presenting your findings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document what further work is possible once you have arrived at a minimum viable
    answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of this book’s projects addresses a different topic you will encounter
    in real-world analytical projects, and they will all follow the same flow as the
    one in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a results-driven approach helps focus on the specific problem you are
    solving.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part of the results-driven approach is to ensure you understand the problem
    before starting the analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Envisioning the end result at the start creates a goal to work toward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple possible approaches to extracting the city part of a free-type
    address, each with its pros and cons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyses will diverge depending on the choices and assumptions made; therefore,
    it is possible to get different, but still correct, results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even seemingly smaller tasks, such as extracting city information from address
    data, benefit from a results-driven approach by helping focus on a valuable outcome.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
