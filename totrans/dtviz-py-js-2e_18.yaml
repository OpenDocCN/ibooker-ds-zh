- en: Chapter 13\. RESTful Data with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“A Simple Data API with Flask”](ch12.xhtml#sect_flask_api), we saw how to
    build a very simple data API with Flask and Dataset. For many simple data visualizations
    this kind of quick and dirty API is fine, but as the data demands become more
    advanced it helps to have an API that respects some conventions for retrieval
    and, sometimes, creation, update and delete.^([1](ch13.xhtml#idm45607759687920))
    In [“Using Python to Consume Data from a Web API”](ch05.xhtml#getting_data_webapis),
    we covered the types of web API and why RESTful^([2](ch13.xhtml#idm45607759685936))
    APIs are acquiring a well-deserved prominence. In this chapter, we’ll see how
    easy it is to combine a few Flask libraries into a flexible RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: The Tools for a RESTful Job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As seen in [“A Simple Data API with Flask”](ch12.xhtml#sect_flask_api), the
    basics of a data API are pretty simple. It needs a server, which accepts HTTP
    requests such as GET to retrieve or more advanced verbs like POST (to add) or
    DELETE. These requests are on routes like `api/winners` that are then dealt with
    by functions provided. In these functions data is retrieved from a backend database,
    possibly filtered using data parameters (e.g., strings like `?category=comic&name=Groucho`
    appended to the URL calls). This data then needs to be returned or serialized
    in some requested format, pretty much always JSON-based. For this round trip of
    data, the Flask/Python ecosystem provides some perfect libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Flask to do the server work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Flask SQLAlchemy](https://oreil.ly/NVldl), a Flask extension that integrates
    [SQLAlchemy](https://sqlalchemy.org), our preferred Python SQL library with object-relational
    mapper (ORM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Flask-Marshmallow](https://oreil.ly/Vbgq3), a Flask extension that adds support
    for [marshmallow](https://oreil.ly/AIySU), a powerful Python library for object
    serialization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can install the required extensions with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Saving the Cleaned Datasets”](ch09.xhtml#sect_saving_cleaned_dataset),
    we saw how easy it is to save a pandas DataFrame to SQL using the `to_sql` method.
    This is a very convenient way to store a DataFrame, but the table produced lacks
    a [primary key field](https://oreil.ly/x4OM6), which uniquely specifies a table
    row. It’s good form to have a primary key, and for the purposes of creating or
    deleting rows via our Web API, is pretty much essential. For this reason we’ll
    create our SQL table by another route.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we build an SQLite database with SQLAlchemy, adding a primary-key ID
    to the winners table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the all-important primary key to disambiguate our winners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are going to store the dates as strings to limit any problems
    serializing datetime objects. We’ll convert those DataFrame columns before committing
    the rows to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now iterate through our DataFrame’s rows, adding them to the database
    as dictionary records and then commit all of them, relatively efficiently, as
    one transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With our well-formed database to hand, let’s see how to easily serve it with
    Flask.
  prefs: []
  type: TYPE_NORMAL
- en: A Flask RESTful Data Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will be a standard Flask server, similar to the one seen in [“Serving
    Data with Flask”](ch12.xhtml#sect_serving_data_with_flask). First, we import the
    standard Flask modules along with the SQLALchemy and marshmallow extensions and
    create our Flask app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now some database-specific declarations, initializing SQLAlchemy with the Flask
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `db` instance to define our winners table, subclassed from
    the base declarative model. This matches the schema used to create the winners
    table in the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Serializing with marshmallow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'marshmallow is a really useful little Python library that does one job and
    does it well. To quote [the documentation](https://oreil.ly/kLTVF):'
  prefs: []
  type: TYPE_NORMAL
- en: marshmallow is an ORM/ODM/framework-agnostic library for converting complex
    datatypes, such as objects, to and from native Python datatypes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: marshmallow uses Schemas, similar to SQLALchemy’s, to enable deserializing input
    data to app-level objects and validation of that input data. For our purposes
    here its key asset is its ability to take data from our SQLite database, provided
    by SQLAlchemy, and turn it into JSON-compliant data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Flask-Marshmallow we first create a marshmallow instance (`ma`), initialized
    with the Flask app. We then use this to create a marshmallow schema, using the
    SQLAlchemy `Winner` model as its base. The schema also has a `fields` property
    that allows you to specify which (database) fields to serialize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The database fields to serialize.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We declare two schema instances, one for returning single records and one for
    multiple records.
  prefs: []
  type: TYPE_NORMAL
- en: Adding our RESTful API Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now the backbone is in place, let’s craft a few Flask routes to define a small
    RESTful API. For a first test, we’ll make a route that returns all the Nobel winners
    in our database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Database query for all rows in the winners table.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The marshmallow schema for many rows takes the all-winners result and serializes
    it to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll test the API with some command-line curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So we now have an API endpoint to return all the winners. What about being
    able to retrieve individuals by ID (our primary key for the winners table)? To
    do this, we retrieve the ID from the API call, using Flask’s route pattern-matching,
    and use it to make a specific database query. We then serialize this to JSON using
    our single-row marshmallow schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Flask-SQLAlchemy provides a default 404 error message, which can be serialized
    to JSON by marshmallow if the query is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing with curl shows the expected single JSON object returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Being able to retrieve all the winners on a single API call isn’t particularly
    useful. Let’s add the ability to filter those results with some arguments provided
    on the request. These arguments are the ones found on the URL query string, starting
    with a `?` and separated by `&`s, which follows the endpoint, e.g., `http://nobel.net/api/winners?category=Physics&year=1980`.
    Flask provides a `request.args` object that has a `to_dict` method, returning
    a dictionary of URL arguments.^([3](ch13.xhtml#idm45607758626448)) We can use
    this to specify our data table filters, which can be applied as key-value pairs
    using SQLAlchemy’s `to_filter` method, which can be applied to queries. Here’s
    a simple implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: These are the fields we will allow filtering on.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We iterate through the filter fields provided and use the valid ones to create
    our filter dictionary. Here we use a Python [dictionary comprehension](https://oreil.ly/wmy3c)
    to construct the `args` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_restful_data_with_flask_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Use Python’s dictionary unpacking to specify method parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test our filtering abilty with curl, using the `-d` (data) arguments
    to specify our query parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We now have fairly fine-grained filtering on our winners dataset, and for many
    data visualizations, that would be enough to provide a large, user-driven dataset,
    fetching data from the RESTful API as required. The ability to post or create
    data entries from the API or a web form is one of those requirements that crops
    up now and again and is a good *to know*. It means you can use the API as a central
    data pool and add to it from various locations. It’s also very easy to do with
    Flask and our extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Posting Data to the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask routes take an optional `methods` argument, which specifies the HTTP verbs
    accepted. The GET verb is the default, but by setting it to POST we can post data
    to this route with the packet available on the `request` object, in this case
    as JSON encoded data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add another `/winners` endpoint, with a `methods` array containing `POST`,
    then use the JSON data to make a `winner_data` dict that is used to create an
    entry in the winners table. This is then added to the database session and finally
    committed. The new entry is returned using marshmallow’s serializing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing with curl returns the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The input data is a JSON encoded string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps more useful for data management is an API endpoint enabling a winner’s
    data to be updated. For this we can use the HTTP PATCH verb called on an individual
    URL. As with the POST to create a new winner, we cycle through the `request.json`
    dictionary and use any valid fields, in this case all available to marshmallow’s
    serializer, to update the attributes of the winner by ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use this API patch point to update, for the purposes of demonstration,
    the name and prize year of a Nobel winner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The original details.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we have built a useful, targeted API able to fetch data according
    to fine-grained filters and update or create winners. If you wanted to add more
    endpoints covering a few more database tables, the Flask routing boilerplate and
    associated methods can get a little messy. Flask MethodViews provide a way of
    encapsulating our endpoint API calls in a single class instance, making things
    cleaner and more extendible. It’s easy to transfer our existing API to MethodViews
    and the reduced cognitive load will pay off as your APIs get more involved.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the API with MethodViews
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can reuse the bulk of our API’s code, and shifting it to MethodViews loses
    a pleasing amount of boilerplate too. MethodViews encapsulate endpoints and their
    associated HTTP verbs (GET, POST, etc.) in a single class instance, which can
    be easily extended and adapted. To shift our winners table to a dedicated resource,
    we can just lift the existing Flask route methods into a `MethodView` class and
    make a few minor adjustments. First, we’ll need to import the `MethodView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQLAlchemy model and marshmallow schemas don’t need changing. Now we create
    a `MethodView` instance for our winners collection with methods for the relevant
    HTTP verbs. We can reuse the existing route methods. We then use the Flask app’s
    `add_url_rule` method to provide an endpoint, which the view will handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To create HTTP methods for individual table entries follows the same pattern.
    We’ll add a delete method for good measure. Successful HTTP deletes should return
    the 204 (no content) HTTP code and an empty content package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The named, pattern-matched arguments are passed to all the MethodViews methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use curl to delete one of our winners, specifying a verbose output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By using MethodViews on dedicated endpoints, we cut out a lot of Flask’s routing
    boilerplate and make the codebase easier to work with and extend. By way of example,
    let’s see how to add a very handy API feature, the ability to paginate or chunk
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Paginating the Data Returns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have large datasets and anticipate large result sets, the ability to
    receive that data in paginated chunks is a very useful API feature; for many use
    cases, a vital one.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy has a handy `paginate` method that can be called on queries to return
    pages of data of a specified page size. To add pagination to our winners API,
    we just need to add a couple of query parameters to specify the page and page
    size. We’ll use `_page` and `_page-size` and prefix them with an underscore to
    distinguish them from any filter queries we may apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the adapted `get` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The pagination parameters with sensible defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Here we use SQLAlchemy’s `paginate` method with our `page` and `per_page` pagination
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_restful_data_with_flask_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We return our paginated results and anything else that makes sense. In the `pagination`
    dict we provide useful feedback—the page being returned and the size of the total
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_restful_data_with_flask_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this function to add some handy URLs to fetch previous or next pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'By convention it’s useful to return URL endpoints for previous and next pages,
    to allow easy consumption of the total dataset. We have a little `make_pagination_links`
    function for this, which adds these convenient URLs to the pagination dictionary.
    We’ll use Python’s *urllib* library to construct our URL’s query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll remake our query string from the filter queries, e.g., `&category=Chemistry&year=1976`.
    *urllib*’s parse module turns the filters dict into a correctly formatted URL
    query.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Add previous and next page URLs where applicable, appending any filter queries
    to the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use curl to test our paginated data. We’ll add a filter to get all the
    Nobel Prize–winning physicists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a first page, so no previous pages are available, but the next page’s
    URL is provided to allow easy consumption of the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A results array containing the first 20 physicists in the winners table.
  prefs: []
  type: TYPE_NORMAL
- en: With powerful libraries like marshmallow integrated as Flask extensions, it’s
    easy enough to roll your own API without needing to resort to a dedicated RESTful
    Flask library which, experience suggests, might not be around too long.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the API Remotely with Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a local development data server like the one we just built is great for
    prototyping, testing data flow, and all number of dataviz things dealing with
    datasets too large to comfortably be consumed as a JSON (or equivalent) file.
    But it does mean that anyone trying out visualization needs to run a local data
    server, which is just one more thing to think about. This is where it can be very
    useful to put the data server on the web as a remote resource. There are various
    ways this can be done, but possibly the favorite among Pythonistas, including
    myself, is [Heroku](https://oreil.ly/V4Q6h), a cloud service that makes deploying
    a Flask server pretty trivial. Let’s demo this by putting our Nobel data server
    on the web.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll need to create a [free Heroku account](https://signup.heroku.com).
    You’ll then need to install the [Heroku client tools](https://oreil.ly/wutXG)
    for your OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the tools installed, you can log into Heroku by running `login` from the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’re logged in, we’re going to create a Heroku app and deploy it to the
    web. First, we create an app directory (*heroku_api*) and put our Flask API *api_rest.py*
    file in it. We’ll also need a Procfile, a *requirements.txt* file, and the `nobel_winners_cleaned_api.db`
    SQLite database to be served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The Procfile is used by Heroku to know what and how to deploy. In this case
    we’re going to use Python’s [Gunicorn WSGI HTTP server](https://oreil.ly/yBTdb)
    to negotiate web traffic with our Flask app and run it as a Heroku app. The Procfile
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the Procfile, Heroku needs to know the Python libraries to install
    for the app. These are found in the *requirements.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With the Heroku config files in place, we can create a Heroku app by running
    `create` from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll now use `git` to initialize a Git directory and add the existing files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With `git` initialized, we just create our Heroku app:^([4](ch13.xhtml#idm45607756688512))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To deploy to Heroku is now just a `git push` away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Every time you make changes to the local codebase, just push them to Heroku
    and the site will update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test the API with curl by getting the first page of the Physics winners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: CORS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to consume the API from a web browser, we’ll need to handle [Cross-Origin
    Resource Sharing (CORS)](https://oreil.ly/ECpu0) constraints on server data requests.
    We’ll use a Flask CORS extension and run it in default, allowing requests from
    any domain to access the data server. This just requires adding a couple of lines
    to our Flask app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The [Flask-CORS library](https://oreil.ly/bCKME) can be used to specify which
    domains are allowed to access which resources. We’re allowing general access here.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the API Using JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the data server from a web app/page, we just use `fetch` to request
    the data. This example consumes all the paginated data by continuing to fetch
    pages until the `next_page` property is an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The data coming from the server is asynchronous, so we use async functions to
    consume it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`await`](https://oreil.ly/EWHec) waits for the asynchronous Promise to resolve
    itself, providing its value.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_restful_data_with_flask_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: We convert the response data to JSON, passing it on the next `then` call, which
    returns the server data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JS call outputs the expected result to console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We now have a web-based RESTful data API that can be accessed from anywhere
    (subject to our CORS restrictions). As you’ve seen, the low overhead and ease
    of use make Heroku hard to beat. It’s been going a while and has become a very
    refined setup.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope this chapter has demonstrated that with a handful of powerful extensions
    it’s easy to roll your own RESTful API. It would take a lot more work and a few
    tests to make it industrial standard, but for most dataviz assignments this API
    would provide the ability to deal with large datasets and allow the user free
    exploration. At the very least it shows how easy it is to throw together a development
    server, allowing you to quickly test out visualization approaches for user-refined
    datasets. Dashboards is one area where this kind of remote fetching of data is
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to easily deploy the API remotely with Heroku means large datasets
    can be sliced and diced without having to run local data servers—perfect for demonstrating
    ambitious dataviz to clients or colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch13.xhtml#idm45607759687920-marker)) These create, read, update and delete
    methods form the [CRUD acronym](https://oreil.ly/0AkAw).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch13.xhtml#idm45607759685936-marker)) Essentially, RESTful means resources
    being identified by a stateless, cacheable URI/URL and manipulated by HTTP verbs
    such as GET or POST. See [Wikipedia’s take](https://oreil.ly/l0QhB) and this [Stack
    Overflow thread](https://oreil.ly/6zxhv) for a little debate.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch13.xhtml#idm45607758626448-marker)) Technically URL query strings form
    a multidictionary, which allows multiple occurrences of the same key. For the
    purposes of our API we expect to have only one instance of each key, making conversion
    to a dictionary fine.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch13.xhtml#idm45607756688512-marker)) You can do this from the Heroku
    dashboard and then use `git remote - <app_name>` to attach the current Git directory
    to the app.
  prefs: []
  type: TYPE_NORMAL
