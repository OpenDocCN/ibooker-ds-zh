- en: Chapter 13\. RESTful Data with Flask
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。使用 Flask 构建 RESTful 数据
- en: In [“A Simple Data API with Flask”](ch12.xhtml#sect_flask_api), we saw how to
    build a very simple data API with Flask and Dataset. For many simple data visualizations
    this kind of quick and dirty API is fine, but as the data demands become more
    advanced it helps to have an API that respects some conventions for retrieval
    and, sometimes, creation, update and delete.^([1](ch13.xhtml#idm45607759687920))
    In [“Using Python to Consume Data from a Web API”](ch05.xhtml#getting_data_webapis),
    we covered the types of web API and why RESTful^([2](ch13.xhtml#idm45607759685936))
    APIs are acquiring a well-deserved prominence. In this chapter, we’ll see how
    easy it is to combine a few Flask libraries into a flexible RESTful API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[“使用 Flask 构建简单数据 API”](ch12.xhtml#sect_flask_api)一节中所见，我们看到如何使用 Flask 和
    Dataset 构建一个非常简单的数据 API。对于许多简单的数据可视化来说，这种快速而简陋的 API 是可以接受的，但随着数据需求变得更加复杂，有一个遵循一些检索和有时创建、更新和删除的惯例的
    API 会更有帮助。^([1](ch13.xhtml#idm45607759687920)) 在[“使用 Python 从 Web API 消费数据”](ch05.xhtml#getting_data_webapis)一章中，我们介绍了
    Web API 的类型及为什么 RESTful^([2](ch13.xhtml#idm45607759685936)) API 正在获得应有的重视。在本章中，我们将看到将几个
    Flask 库组合成一个灵活的 RESTful API 是多么简单。
- en: The Tools for a RESTful Job
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful 作业工具
- en: 'As seen in [“A Simple Data API with Flask”](ch12.xhtml#sect_flask_api), the
    basics of a data API are pretty simple. It needs a server, which accepts HTTP
    requests such as GET to retrieve or more advanced verbs like POST (to add) or
    DELETE. These requests are on routes like `api/winners` that are then dealt with
    by functions provided. In these functions data is retrieved from a backend database,
    possibly filtered using data parameters (e.g., strings like `?category=comic&name=Groucho`
    appended to the URL calls). This data then needs to be returned or serialized
    in some requested format, pretty much always JSON-based. For this round trip of
    data, the Flask/Python ecosystem provides some perfect libraries:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[“使用 Flask 构建简单数据 API”](ch12.xhtml#sect_flask_api)一节中所见，数据 API 的基础非常简单。它需要一个接受
    HTTP 请求的服务器，例如 GET 请求用于检索数据或更高级的动词如 POST（用于添加）或 DELETE。这些请求位于诸如`api/winners`的路由上，然后由提供的函数处理。在这些函数中，数据从后端数据库中检索出来，可能会使用数据参数进行过滤（例如，像`?category=comic&name=Groucho`这样的字符串附加到
    URL 调用中）。然后，这些数据需要以某种请求的格式返回或序列化，几乎总是基于 JSON。对于这种数据的往返，Flask/Python 生态系统提供了一些完美的库：
- en: Flask to do the server work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask 执行服务器工作
- en: '[Flask SQLAlchemy](https://oreil.ly/NVldl), a Flask extension that integrates
    [SQLAlchemy](https://sqlalchemy.org), our preferred Python SQL library with object-relational
    mapper (ORM)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Flask SQLAlchemy](https://oreil.ly/NVldl)是一个 Flask 扩展，将我们首选的 Python SQL 库与对象关系映射器（ORM）SQLAlchemy集成。'
- en: '[Flask-Marshmallow](https://oreil.ly/Vbgq3), a Flask extension that adds support
    for [marshmallow](https://oreil.ly/AIySU), a powerful Python library for object
    serialization'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Flask-Marshmallow](https://oreil.ly/Vbgq3)是一个 Flask 扩展，添加了对[marshmallow](https://oreil.ly/AIySU)的支持，这是一个功能强大的
    Python 对象序列化库。'
- en: 'You can install the required extensions with `pip`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`pip`安装所需的扩展：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating the Database
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库
- en: In [“Saving the Cleaned Datasets”](ch09.xhtml#sect_saving_cleaned_dataset),
    we saw how easy it is to save a pandas DataFrame to SQL using the `to_sql` method.
    This is a very convenient way to store a DataFrame, but the table produced lacks
    a [primary key field](https://oreil.ly/x4OM6), which uniquely specifies a table
    row. It’s good form to have a primary key, and for the purposes of creating or
    deleting rows via our Web API, is pretty much essential. For this reason we’ll
    create our SQL table by another route.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“保存清理后的数据集”](ch09.xhtml#sect_saving_cleaned_dataset)一节中，我们看到使用`to_sql`方法将
    pandas DataFrame 存储到 SQL 中是多么简单。这是一种非常方便的存储 DataFrame 的方式，但生成的表缺少一个[主键字段](https://oreil.ly/x4OM6)，这个字段唯一地指定表中的行。拥有主键是一个良好的习惯，而且对于通过我们的
    Web API 创建或删除行来说几乎是必需的。因此，我们将通过另一种方式创建我们的 SQL 表。
- en: 'First, we build an SQLite database with SQLAlchemy, adding a primary-key ID
    to the winners table:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 SQLAlchemy 构建了一个 SQLite 数据库，并向获奖者表添加了主键 ID。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO1-1)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO1-1)'
- en: We specify the all-important primary key to disambiguate our winners.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了至关重要的主键来消除获奖者之间的歧义。
- en: 'Note that we are going to store the dates as strings to limit any problems
    serializing datetime objects. We’ll convert those DataFrame columns before committing
    the rows to the database:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将日期存储为字符串以限制序列化日期时间对象时可能出现的任何问题。在提交行到数据库之前，我们将转换这些 DataFrame 列：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now iterate through our DataFrame’s rows, adding them to the database
    as dictionary records and then commit all of them, relatively efficiently, as
    one transaction:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以迭代我们 DataFrame 的行，将它们作为字典记录添加到数据库中，然后将它们相对高效地作为一个事务提交：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With our well-formed database to hand, let’s see how to easily serve it with
    Flask.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们成形完善的数据库，让我们看看如何使用 Flask 轻松地提供它。
- en: A Flask RESTful Data Server
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask RESTful 数据服务器
- en: 'This will be a standard Flask server, similar to the one seen in [“Serving
    Data with Flask”](ch12.xhtml#sect_serving_data_with_flask). First, we import the
    standard Flask modules along with the SQLALchemy and marshmallow extensions and
    create our Flask app:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个标准的 Flask 服务器，类似于 [“使用 Flask 服务数据”](ch12.xhtml#sect_serving_data_with_flask)
    中看到的那个。首先，我们导入标准的 Flask 模块，以及 SQLALchemy 和 marshmallow 扩展，并创建我们的 Flask 应用程序：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now some database-specific declarations, initializing SQLAlchemy with the Flask
    app:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一些特定于数据库的声明，使用 Flask 应用程序初始化 SQLAlchemy：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now use the `db` instance to define our winners table, subclassed from
    the base declarative model. This matches the schema used to create the winners
    table in the last section:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `db` 实例来定义我们的获胜者表，从基本声明模型继承而来。这与上一节中用来创建获胜者表的 schema 匹配：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Serializing with marshmallow
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 marshmallow 进行序列化
- en: 'marshmallow is a really useful little Python library that does one job and
    does it well. To quote [the documentation](https://oreil.ly/kLTVF):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: marshmallow 是一个非常有用的小型 Python 库，做一件事并且做得很好。引用 [文档](https://oreil.ly/kLTVF) 的话说：
- en: marshmallow is an ORM/ODM/framework-agnostic library for converting complex
    datatypes, such as objects, to and from native Python datatypes.
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: marshmallow 是一个用于将复杂数据类型（如对象）转换为原生 Python 数据类型的 ORM/ODM/框架无关的库。
- en: marshmallow uses Schemas, similar to SQLALchemy’s, to enable deserializing input
    data to app-level objects and validation of that input data. For our purposes
    here its key asset is its ability to take data from our SQLite database, provided
    by SQLAlchemy, and turn it into JSON-compliant data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: marshmallow 使用类似于 SQLAlchemy 的 schema，可以将输入数据反序列化为应用程序级别的对象，并验证该输入数据。在这里，它的关键优势是能够从由
    SQLAlchemy 提供的我们的 SQLite 数据库中获取数据，并将其转换为符合 JSON 规范的数据。
- en: 'To use Flask-Marshmallow we first create a marshmallow instance (`ma`), initialized
    with the Flask app. We then use this to create a marshmallow schema, using the
    SQLAlchemy `Winner` model as its base. The schema also has a `fields` property
    that allows you to specify which (database) fields to serialize:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Flask-Marshmallow，我们首先创建一个 marshmallow 实例 (`ma`)，并初始化 Flask 应用程序。然后，我们使用它创建一个
    marshmallow schema，使用 SQLAlchemy 的 `Winner` 模型作为其基础。该 schema 还有一个 `fields` 属性，允许您指定要序列化的（数据库）字段：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO2-1)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO2-1)'
- en: The database fields to serialize.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要序列化的数据库字段。
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO2-2)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_restful_data_with_flask_CO2-2)'
- en: We declare two schema instances, one for returning single records and one for
    multiple records.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个 schema 实例，一个用于返回单个记录，另一个用于多个记录。
- en: Adding our RESTful API Routes
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加我们的 RESTful API 路由
- en: 'Now the backbone is in place, let’s craft a few Flask routes to define a small
    RESTful API. For a first test, we’ll make a route that returns all the Nobel winners
    in our database table:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在骨架已经搭好，让我们创建一些 Flask 路由来定义一个小型的 RESTful API。作为第一次测试，我们将创建一个路由，返回我们数据库表中的所有诺贝尔获奖者：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO3-1)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO3-1)'
- en: Database query for all rows in the winners table.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 获得获胜者表中所有行的数据库查询。
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO3-2)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_restful_data_with_flask_CO3-2)'
- en: The marshmallow schema for many rows takes the all-winners result and serializes
    it to JSON.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将许多行的 marshmallow schema 获取所有获胜者的结果并将其序列化为 JSON。
- en: 'We’ll test the API with some command-line curl:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些命令行 curl 测试 API：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So we now have an API endpoint to return all the winners. What about being
    able to retrieve individuals by ID (our primary key for the winners table)? To
    do this, we retrieve the ID from the API call, using Flask’s route pattern-matching,
    and use it to make a specific database query. We then serialize this to JSON using
    our single-row marshmallow schema:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个 API 端点来返回所有的获胜者。那么，如何通过 ID（我们的获胜者表的主键）来检索个体呢？为此，我们从 API 调用中检索 ID，使用
    Flask 的路由模式匹配，并将其用于进行特定的数据库查询。然后，我们使用我们的单行 marshmallow schema 将其序列化为 JSON：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO4-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO4-1)'
- en: Flask-SQLAlchemy provides a default 404 error message, which can be serialized
    to JSON by marshmallow if the query is invalid.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-SQLAlchemy提供了一个默认的404错误消息，如果查询无效，则可以通过marshmallow序列化为JSON。
- en: 'Testing with curl shows the expected single JSON object returned:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用curl测试显示预期的单个JSON对象返回：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Being able to retrieve all the winners on a single API call isn’t particularly
    useful. Let’s add the ability to filter those results with some arguments provided
    on the request. These arguments are the ones found on the URL query string, starting
    with a `?` and separated by `&`s, which follows the endpoint, e.g., `http://nobel.net/api/winners?category=Physics&year=1980`.
    Flask provides a `request.args` object that has a `to_dict` method, returning
    a dictionary of URL arguments.^([3](ch13.xhtml#idm45607758626448)) We can use
    this to specify our data table filters, which can be applied as key-value pairs
    using SQLAlchemy’s `to_filter` method, which can be applied to queries. Here’s
    a simple implementation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在单个API调用中检索所有获奖者并不特别有用。让我们增加通过请求中提供的一些参数来过滤这些结果的功能。这些参数可以在URL查询字符串上找到，以`?`开头并以`&`分隔，跟随端点，例如`http://nobel.net/api/winners?category=Physics&year=1980`。Flask提供了一个`request.args`对象，具有一个`to_dict`方法，返回URL参数的字典。^([3](ch13.xhtml#idm45607758626448))
    我们可以使用这个方法来指定我们的数据表过滤器，这可以作为键值对应用于SQLAlchemy的`to_filter`方法，这个方法可以应用于查询。这是一个简单的实现：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO5-1)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO5-1)'
- en: These are the fields we will allow filtering on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们允许进行过滤的字段。
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO5-2)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_restful_data_with_flask_CO5-2)'
- en: We iterate through the filter fields provided and use the valid ones to create
    our filter dictionary. Here we use a Python [dictionary comprehension](https://oreil.ly/wmy3c)
    to construct the `args` dictionary.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历提供的过滤字段，并使用有效的字段创建我们的过滤器字典。在这里，我们使用Python的[字典推导](https://oreil.ly/wmy3c)构建`args`字典。
- en: '[![3](assets/3.png)](#co_restful_data_with_flask_CO5-3)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_restful_data_with_flask_CO5-3)'
- en: Use Python’s dictionary unpacking to specify method parameters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的字典解包来指定方法参数。
- en: 'Let’s test our filtering abilty with curl, using the `-d` (data) arguments
    to specify our query parameters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用curl测试我们的过滤能力，使用`-d`（数据）参数来指定我们的查询参数：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We now have fairly fine-grained filtering on our winners dataset, and for many
    data visualizations, that would be enough to provide a large, user-driven dataset,
    fetching data from the RESTful API as required. The ability to post or create
    data entries from the API or a web form is one of those requirements that crops
    up now and again and is a good *to know*. It means you can use the API as a central
    data pool and add to it from various locations. It’s also very easy to do with
    Flask and our extensions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对获奖者数据集进行了相当细粒度的过滤，对于许多数据可视化来说，这足以提供一个大的、用户驱动的数据集，根据需要从RESTful API获取数据。通过API或Web表单发布或创建数据条目是那些偶尔出现并且很好掌握的要求之一。这意味着您可以将API用作中央数据池，并从各个位置添加到其中。在Flask和我们的扩展中，这也很容易实现。
- en: Posting Data to the API
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向API提交数据
- en: Flask routes take an optional `methods` argument, which specifies the HTTP verbs
    accepted. The GET verb is the default, but by setting it to POST we can post data
    to this route with the packet available on the `request` object, in this case
    as JSON encoded data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Flask路由接受一个可选的`methods`参数，指定接受的HTTP动词。GET动词是默认的，但通过将其设置为POST，我们可以使用`request`对象上可用的数据包将数据提交到此路由中，此处为JSON编码数据。
- en: 'We add another `/winners` endpoint, with a `methods` array containing `POST`,
    then use the JSON data to make a `winner_data` dict that is used to create an
    entry in the winners table. This is then added to the database session and finally
    committed. The new entry is returned using marshmallow’s serializing:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了另一个`/winners`端点，其中包含一个`methods`数组，其中包含`POST`，然后使用JSON数据创建一个`winner_data`字典，用于在获奖者表中创建条目。然后将其添加到数据库会话中，最后提交。使用marshmallow进行序列化返回新条目：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Testing with curl returns the expected result:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用curl测试返回预期结果：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO6-1)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO6-1)'
- en: The input data is a JSON encoded string.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输入数据是一个JSON编码的字符串。
- en: 'Perhaps more useful for data management is an API endpoint enabling a winner’s
    data to be updated. For this we can use the HTTP PATCH verb called on an individual
    URL. As with the POST to create a new winner, we cycle through the `request.json`
    dictionary and use any valid fields, in this case all available to marshmallow’s
    serializer, to update the attributes of the winner by ID:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据管理可能更有用的是一个API端点，允许更新获奖者的数据。为此，我们可以使用 HTTP PATCH 动词调用单个URL。与用于创建新获奖者的 POST
    相同，我们会遍历 `request.json` 字典，并使用任何有效的字段，在本例中，所有字段都可以由 marshmallow 的序列化器使用，以更新获奖者的属性按ID排序：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here we use this API patch point to update, for the purposes of demonstration,
    the name and prize year of a Nobel winner:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用此API修补点来更新，以演示为目的，一个诺贝尔奖获得者的姓名和奖励年份：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO7-1)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO7-1)'
- en: The original details.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 原始细节。
- en: At this point we have built a useful, targeted API able to fetch data according
    to fine-grained filters and update or create winners. If you wanted to add more
    endpoints covering a few more database tables, the Flask routing boilerplate and
    associated methods can get a little messy. Flask MethodViews provide a way of
    encapsulating our endpoint API calls in a single class instance, making things
    cleaner and more extendible. It’s easy to transfer our existing API to MethodViews
    and the reduced cognitive load will pay off as your APIs get more involved.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了一个有用的、有针对性的API，能够根据精细的过滤条件获取数据，并更新或创建获奖者。如果您想要添加更多覆盖几个数据库表的端点，Flask
    路由的样板代码和相关方法可能会有些混乱。Flask MethodViews 提供了一种方式，将我们的端点API调用封装在单个类实例中，使得代码更清晰、更易于扩展。将现有的API转移到
    MethodViews 并减少认知负荷，将在API变得更加复杂时获得回报。
- en: Extending the API with MethodViews
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MethodViews 扩展API
- en: 'We can reuse the bulk of our API’s code, and shifting it to MethodViews loses
    a pleasing amount of boilerplate too. MethodViews encapsulate endpoints and their
    associated HTTP verbs (GET, POST, etc.) in a single class instance, which can
    be easily extended and adapted. To shift our winners table to a dedicated resource,
    we can just lift the existing Flask route methods into a `MethodView` class and
    make a few minor adjustments. First, we’ll need to import the `MethodView` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复使用我们API的大部分代码，并将其转移到 MethodViews 中也减少了相当数量的样板。MethodViews 将端点及其关联的HTTP动词（GET、POST等）封装在单个类实例中，可以轻松扩展和适应。要将我们的获奖者表转移到一个专用资源中，我们只需将现有的Flask路由方法提升到一个
    `MethodView` 类中，并进行一些小的调整。首先，我们需要导入 `MethodView` 类：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The SQLAlchemy model and marshmallow schemas don’t need changing. Now we create
    a `MethodView` instance for our winners collection with methods for the relevant
    HTTP verbs. We can reuse the existing route methods. We then use the Flask app’s
    `add_url_rule` method to provide an endpoint, which the view will handle:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 模型和 marshmallow schemas 无需更改。现在我们为获奖者集合创建一个 `MethodView` 实例，包含相关HTTP动词的方法。我们可以重用现有的路由方法。然后，我们使用
    Flask 应用的 `add_url_rule` 方法提供一个端点，这个视图将处理它：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To create HTTP methods for individual table entries follows the same pattern.
    We’ll add a delete method for good measure. Successful HTTP deletes should return
    the 204 (no content) HTTP code and an empty content package:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个表条目创建HTTP方法遵循相同的模式。我们会添加一个删除方法以确保万无一失。成功的HTTP删除应该返回 204（无内容）HTTP代码和一个空的内容包：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO8-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO8-1)'
- en: The named, pattern-matched arguments are passed to all the MethodViews methods.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命名的、模式匹配的参数都会传递给所有 MethodViews 方法。
- en: 'Let’s use curl to delete one of our winners, specifying a verbose output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 curl 删除其中一位获奖者，指定详细输出：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using MethodViews on dedicated endpoints, we cut out a lot of Flask’s routing
    boilerplate and make the codebase easier to work with and extend. By way of example,
    let’s see how to add a very handy API feature, the ability to paginate or chunk
    data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在专用端点上使用 MethodViews，我们可以减少大量 Flask 路由的样板代码，并使代码库更易于使用和扩展。举个例子，让我们看看如何添加一个非常方便的API功能，即分页或分块数据的能力。
- en: Paginating the Data Returns
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页数据返回
- en: If you have large datasets and anticipate large result sets, the ability to
    receive that data in paginated chunks is a very useful API feature; for many use
    cases, a vital one.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有大型数据集并预计有大量结果集，接收分页数据的能力是一个非常有用的API特性；对于许多用例来说，这是一个至关重要的特性。
- en: SQLAlchemy has a handy `paginate` method that can be called on queries to return
    pages of data of a specified page size. To add pagination to our winners API,
    we just need to add a couple of query parameters to specify the page and page
    size. We’ll use `_page` and `_page-size` and prefix them with an underscore to
    distinguish them from any filter queries we may apply.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy有一个方便的`paginate`方法，可以在查询上调用以返回指定页面大小的数据页面。 要将分页添加到我们的获奖者API中，我们只需添加几个查询参数来指定页面和页面大小。
    我们将使用 `_page` 和 `_page-size`，并在前面加上下划线以区分它们与我们可能应用的任何过滤器查询。
- en: 'Here’s the adapted `get` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调整过的`get`方法：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO9-1)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO9-1)'
- en: The pagination parameters with sensible defaults.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 具有合理默认值的分页参数。
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO9-2)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_restful_data_with_flask_CO9-2)'
- en: Here we use SQLAlchemy’s `paginate` method with our `page` and `per_page` pagination
    variables.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用SQLAlchemy的`paginate`方法以及我们的`page`和`per_page`分页变量。
- en: '[![3](assets/3.png)](#co_restful_data_with_flask_CO9-3)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_restful_data_with_flask_CO9-3)'
- en: We return our paginated results and anything else that makes sense. In the `pagination`
    dict we provide useful feedback—the page being returned and the size of the total
    dataset.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回我们的分页结果和其他有意义的内容。 在`pagination`字典中，我们提供有用的反馈 - 返回的页面和总数据集的大小。
- en: '[![4](assets/4.png)](#co_restful_data_with_flask_CO9-4)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_restful_data_with_flask_CO9-4)'
- en: We’ll use this function to add some handy URLs to fetch previous or next pages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用此函数添加一些方便的URL以获取上一页或下一页。
- en: 'By convention it’s useful to return URL endpoints for previous and next pages,
    to allow easy consumption of the total dataset. We have a little `make_pagination_links`
    function for this, which adds these convenient URLs to the pagination dictionary.
    We’ll use Python’s *urllib* library to construct our URL’s query string:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，返回上一页和下一页的URL端点非常有用，以便轻松访问整个数据集。 我们有一个小小的`make_pagination_links`函数来实现这一点，它将这些便捷的URL添加到分页字典中。
    我们将使用Python的 *urllib* 库构建我们的URL查询字符串：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO10-1)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO10-1)'
- en: We’ll remake our query string from the filter queries, e.g., `&category=Chemistry&year=1976`.
    *urllib*’s parse module turns the filters dict into a correctly formatted URL
    query.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从过滤查询重新生成我们的查询字符串，例如，`&category=Chemistry&year=1976`。 *urllib* 的解析模块将过滤器字典转换为正确格式的URL查询。
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO10-2)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_restful_data_with_flask_CO10-2)'
- en: Add previous and next page URLs where applicable, appending any filter queries
    to the result.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在适用的情况下添加上一页和下一页的URL，将任何过滤查询附加到结果中。
- en: 'Let’s use curl to test our paginated data. We’ll add a filter to get all the
    Nobel Prize–winning physicists:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用curl来测试我们的分页数据。 我们将添加一个筛选器以获取所有诺贝尔物理学奖获得者：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO11-1)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO11-1)'
- en: This is a first page, so no previous pages are available, but the next page’s
    URL is provided to allow easy consumption of the data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一页，因此没有可用的上一页，但提供了下一页的URL，以便轻松消费数据。
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO11-2)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_restful_data_with_flask_CO11-2)'
- en: A results array containing the first 20 physicists in the winners table.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在获奖者表中包含前20位物理学家的结果数组。
- en: With powerful libraries like marshmallow integrated as Flask extensions, it’s
    easy enough to roll your own API without needing to resort to a dedicated RESTful
    Flask library which, experience suggests, might not be around too long.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 借助像marshmallow这样强大的库作为Flask扩展集成，很容易制作自己的API，而无需求助于专门的RESTful Flask库，根据经验表明，这可能不会长期存在。
- en: Deploying the API Remotely with Heroku
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Heroku远程部署API
- en: Having a local development data server like the one we just built is great for
    prototyping, testing data flow, and all number of dataviz things dealing with
    datasets too large to comfortably be consumed as a JSON (or equivalent) file.
    But it does mean that anyone trying out visualization needs to run a local data
    server, which is just one more thing to think about. This is where it can be very
    useful to put the data server on the web as a remote resource. There are various
    ways this can be done, but possibly the favorite among Pythonistas, including
    myself, is [Heroku](https://oreil.ly/V4Q6h), a cloud service that makes deploying
    a Flask server pretty trivial. Let’s demo this by putting our Nobel data server
    on the web.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有像我们刚刚构建的本地开发数据服务器一样的服务器非常适合用于原型设计、测试数据流以及处理数据集过大以至于无法舒适地作为JSON（或等效）文件消耗的各种数据可视化任务。但这意味着任何尝试可视化的人都需要运行一个本地数据服务器，这只是需要考虑的又一件事情。这就是将数据服务器作为远程资源放在网络上的非常有用之处。有各种方法可以做到这一点，但可能是Pythonista们最喜欢的方式之一（包括我自己），是使用[Heroku](https://oreil.ly/V4Q6h)，这是一个使得部署Flask服务器非常简单的云服务。让我们通过将我们的诺贝尔数据服务器放在网络上来演示这一点。
- en: First, you’ll need to create a [free Heroku account](https://signup.heroku.com).
    You’ll then need to install the [Heroku client tools](https://oreil.ly/wutXG)
    for your OS.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要创建一个[免费的Heroku账号](https://signup.heroku.com)。然后，您需要为您的操作系统安装[Heroku客户端工具](https://oreil.ly/wutXG)。
- en: 'With the tools installed, you can log into Heroku by running `login` from the
    command line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这些工具后，您可以通过从命令行运行`login`来登录Heroku：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now you’re logged in, we’re going to create a Heroku app and deploy it to the
    web. First, we create an app directory (*heroku_api*) and put our Flask API *api_rest.py*
    file in it. We’ll also need a Procfile, a *requirements.txt* file, and the `nobel_winners_cleaned_api.db`
    SQLite database to be served:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已登录，我们将创建一个Heroku应用程序并将其部署到网络上。首先，我们创建一个应用目录（*heroku_api*），并将我们的Flask API
    *api_rest.py*文件放入其中。我们还需要一个Procfile文件，一个*requirements.txt*文件，以及`nobel_winners_cleaned_api.db`
    SQLite数据库来提供服务：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Procfile is used by Heroku to know what and how to deploy. In this case
    we’re going to use Python’s [Gunicorn WSGI HTTP server](https://oreil.ly/yBTdb)
    to negotiate web traffic with our Flask app and run it as a Heroku app. The Procfile
    looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Procfile用于告诉Heroku如何以及如何部署。在这种情况下，我们将使用Python的[Gunicorn WSGI HTTP服务器](https://oreil.ly/yBTdb)来处理与我们的Flask应用程序的Web流量，并将其作为Heroku应用程序运行。Procfile如下所示：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As well as the Procfile, Heroku needs to know the Python libraries to install
    for the app. These are found in the *requirements.txt* file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Procfile外，Heroku还需要知道要为应用程序安装的Python库。这些库在*requirements.txt*文件中找到：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the Heroku config files in place, we can create a Heroku app by running
    `create` from the command line.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件已就位后，我们可以通过从命令行运行`create`来创建一个Heroku应用程序。
- en: 'We’ll now use `git` to initialize a Git directory and add the existing files:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`git`来初始化Git目录并添加现有文件：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With `git` initialized, we just create our Heroku app:^([4](ch13.xhtml#idm45607756688512))
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用初始化的`git`，我们只需创建我们的Heroku应用程序：^([4](ch13.xhtml#idm45607756688512))
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To deploy to Heroku is now just a `git push` away:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，部署到Heroku只需一次`git push`：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Every time you make changes to the local codebase, just push them to Heroku
    and the site will update.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每次您对本地代码库进行更改时，只需将它们推送到Heroku，网站就会更新。
- en: 'Let’s test the API with curl by getting the first page of the Physics winners:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用curl测试API，获取物理学获奖者的第一页：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: CORS
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CORS
- en: 'In order to consume the API from a web browser, we’ll need to handle [Cross-Origin
    Resource Sharing (CORS)](https://oreil.ly/ECpu0) constraints on server data requests.
    We’ll use a Flask CORS extension and run it in default, allowing requests from
    any domain to access the data server. This just requires adding a couple of lines
    to our Flask app:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Web浏览器中使用API，我们需要处理[跨源资源共享（CORS）](https://oreil.ly/ECpu0)对服务器数据请求的限制。我们将使用Flask
    CORS扩展，并以默认方式运行，允许来自任何域的请求访问数据服务器。这只需要向我们的Flask应用程序添加几行代码：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The [Flask-CORS library](https://oreil.ly/bCKME) can be used to specify which
    domains are allowed to access which resources. We’re allowing general access here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[Flask-CORS库](https://oreil.ly/bCKME)可用于指定允许访问哪些资源的域。在这里，我们允许一般访问。'
- en: Consuming the API Using JavaScript
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript消耗API
- en: 'To use the data server from a web app/page, we just use `fetch` to request
    the data. This example consumes all the paginated data by continuing to fetch
    pages until the `next_page` property is an empty string:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要从网页应用/页面使用数据服务器，我们只需使用`fetch`请求数据。这个示例通过继续获取页面来消耗所有分页数据，直到`next_page`属性为空字符串为止：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_restful_data_with_flask_CO12-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_restful_data_with_flask_CO12-1)'
- en: The data coming from the server is asynchronous, so we use async functions to
    consume it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器传来的数据是异步的，因此我们使用异步函数来消费它。
- en: '[![2](assets/2.png)](#co_restful_data_with_flask_CO12-3)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_restful_data_with_flask_CO12-3)'
- en: '[`await`](https://oreil.ly/EWHec) waits for the asynchronous Promise to resolve
    itself, providing its value.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[`await`](https://oreil.ly/EWHec) 等待异步 Promise 自行解决，提供其值。'
- en: '[![3](assets/3.png)](#co_restful_data_with_flask_CO12-4)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_restful_data_with_flask_CO12-4)'
- en: We convert the response data to JSON, passing it on the next `then` call, which
    returns the server data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将响应数据转换为 JSON，将其传递给下一个 `then` 调用，该调用返回服务器数据。
- en: 'The JS call outputs the expected result to console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JS 调用将期望的结果输出到控制台：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We now have a web-based RESTful data API that can be accessed from anywhere
    (subject to our CORS restrictions). As you’ve seen, the low overhead and ease
    of use make Heroku hard to beat. It’s been going a while and has become a very
    refined setup.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一个基于 Web 的 RESTful 数据 API，可以从任何地方访问（受到我们的 CORS 限制）。正如你所见，低开销和易用性使得 Heroku
    难以匹敌。它已经运行了一段时间，已经成为一个非常精细的设置。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope this chapter has demonstrated that with a handful of powerful extensions
    it’s easy to roll your own RESTful API. It would take a lot more work and a few
    tests to make it industrial standard, but for most dataviz assignments this API
    would provide the ability to deal with large datasets and allow the user free
    exploration. At the very least it shows how easy it is to throw together a development
    server, allowing you to quickly test out visualization approaches for user-refined
    datasets. Dashboards is one area where this kind of remote fetching of data is
    expected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这一章已经展示了，通过几个强大的扩展，很容易就能自己搭建 RESTful API。要使其达到工业标准，需要更多的工作和一些测试，但对于大多数数据可视化任务来说，该
    API 将提供处理大型数据集并允许用户自由探索的能力。至少它展示了快速测试用户精细调整数据集的可视化方法有多么容易。仪表板是这种远程获取数据的预期应用之一。
- en: The ability to easily deploy the API remotely with Heroku means large datasets
    can be sliced and diced without having to run local data servers—perfect for demonstrating
    ambitious dataviz to clients or colleagues.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Heroku 轻松部署 API 的能力意味着大型数据集可以在不运行本地数据服务器的情况下切割和切块——非常适合向客户或同事演示雄心勃勃的数据可视化。
- en: ^([1](ch13.xhtml#idm45607759687920-marker)) These create, read, update and delete
    methods form the [CRUD acronym](https://oreil.ly/0AkAw).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch13.xhtml#idm45607759687920-marker)) 这些创建、读取、更新和删除方法构成了[CRUD首字母缩写](https://oreil.ly/0AkAw)。
- en: ^([2](ch13.xhtml#idm45607759685936-marker)) Essentially, RESTful means resources
    being identified by a stateless, cacheable URI/URL and manipulated by HTTP verbs
    such as GET or POST. See [Wikipedia’s take](https://oreil.ly/l0QhB) and this [Stack
    Overflow thread](https://oreil.ly/6zxhv) for a little debate.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch13.xhtml#idm45607759685936-marker)) 本质上，RESTful 意味着资源由无状态、可缓存的 URI/URL
    标识，并由 GET 或 POST 等 HTTP 动词进行操作。参见[维基百科的解释](https://oreil.ly/l0QhB)和这个[Stack Overflow
    的讨论](https://oreil.ly/6zxhv)。
- en: ^([3](ch13.xhtml#idm45607758626448-marker)) Technically URL query strings form
    a multidictionary, which allows multiple occurrences of the same key. For the
    purposes of our API we expect to have only one instance of each key, making conversion
    to a dictionary fine.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch13.xhtml#idm45607758626448-marker)) 从技术上讲，URL 查询字符串形成了一个多字典，允许同一个键有多个出现。对于我们的
    API，我们期望每个键只有一个实例，因此转换为字典是可以的。
- en: ^([4](ch13.xhtml#idm45607756688512-marker)) You can do this from the Heroku
    dashboard and then use `git remote - <app_name>` to attach the current Git directory
    to the app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch13.xhtml#idm45607756688512-marker)) 你可以从 Heroku 仪表板执行此操作，然后使用 `git remote
    - <app_name>` 将当前 Git 目录附加到应用上。
