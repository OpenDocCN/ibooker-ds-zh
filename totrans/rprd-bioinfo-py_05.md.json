["```py\n$ cd 04_fib/\n$ cp solution1_list.py fib.py\n```", "```py\n$ ./fib.py -h\nusage: fib.py [-h] generations litter\n\nCalculate Fibonacci\n\npositional arguments:\n  generations  Number of generations\n  litter       Size of litter per generation\n\noptional arguments:\n  -h, --help   show this help message and exit\n```", "```py\n$ ./fib.py foo\nusage: fib.py [-h] generations litter\nfib.py: error: argument generations: invalid int value: 'foo'\n```", "```py\n$ echo Hello\nHello\n$ echo $?\n0\n```", "```py\n$ ./fib.py foo\nusage: fib.py [-h] generations litter\nfib.py: error: argument generations: invalid int value: 'foo'\n$ echo $?\n2\n```", "```py\n$ ./fib.py 5 3.2\nusage: fib.py [-h] generations litter\nfib.py: error: argument litter: invalid int value: '3.2'\n```", "```py\n$ ./fib.py -3 2\nusage: fib.py [-h] generations litter\nfib.py: error: generations \"-3\" must be between 1 and 40 ![1](assets/1.png)\n$ ./fib.py 5 10\nusage: fib.py [-h] generations litter\nfib.py: error: litter \"10\" must be between 1 and 5 ![2](assets/2.png)\n```", "```py\nimport argparse\nfrom typing import NamedTuple\n\nclass Args(NamedTuple):\n    \"\"\" Command-line arguments \"\"\"\n    generations: int ![1](assets/1.png)\n    litter: int ![2](assets/2.png)\n\ndef get_args() -> Args:\n    \"\"\" Get command-line arguments \"\"\"\n\n    parser = argparse.ArgumentParser(\n        description='Calculate Fibonacci',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument('gen', ![3](assets/3.png)\n                        metavar='generations',\n                        type=int, ![4](assets/4.png)\n                        help='Number of generations')\n\n    parser.add_argument('litter', ![5](assets/5.png)\n                        metavar='litter',\n                        type=int,\n                        help='Size of litter per generation')\n\n    args = parser.parse_args() ![6](assets/6.png)\n\n    if not 1 <= args.gen <= 40: ![7](assets/7.png)\n        parser.error(f'generations \"{args.gen}\" must be between 1 and 40') ![8](assets/8.png)\n\n    if not 1 <= args.litter <= 5: ![9](assets/9.png)\n        parser.error(f'litter \"{args.litter}\" must be between 1 and 5') ![10](assets/10.png)\n\n    return Args(generations=args.gen, litter=args.litter) ![11](assets/11.png)\n```", "```py\n$ new.py -fp 'Calculate Fibonacci' fib.py\nDone, see new script \"fib.py\".\n```", "```py\ndef main() -> None:\n    args = get_args()\n    print(f'generations = {args.generations}')\n    print(f'litter = {args.litter}')\n```", "```py\n$ ./fib.py 1 2\ngenerations = 1\nlitter = 2\n```", "```py\n$ pytest -xv\n========================== test session starts ==========================\n...\ntests/fib_test.py::test_exists PASSED                             [ 14%]\ntests/fib_test.py::test_usage PASSED                              [ 28%]\ntests/fib_test.py::test_bad_generations PASSED                    [ 42%]\ntests/fib_test.py::test_bad_litter PASSED                         [ 57%]\ntests/fib_test.py::test_1 FAILED                                  [ 71%] ![1](assets/1.png)\n\n=============================== FAILURES ================================\n________________________________ test_1 _________________________________\n\n    def test_1():\n        \"\"\"runs on good input\"\"\"\n\n        rv, out = getstatusoutput(f'{RUN} 5 3') ![2](assets/2.png)\n        assert rv == 0\n>       assert out == '19' ![3](assets/3.png)\nE       AssertionError: assert 'generations = 5\\nlitter = 3' == '19' ![4](assets/4.png)\nE         - 19    ![5](assets/5.png)\nE         + generations = 5 ![6](assets/6.png)\nE         + litter = 3\n\ntests/fib_test.py:60: AssertionError\n======================== short test summary info ========================\nFAILED tests/fib_test.py::test_1 - AssertionError: assert 'generations...\n!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!\n====================== 1 failed, 4 passed in 0.38s ======================\n```", "```py\n>>> fib = [0, 1]\n```", "```py\n>>> fib[-1]\n1\n```", "```py\n>>> fib[-2]\n0\n```", "```py\n>>> litter = 1\n>>> fib[-2] * litter\n0\n```", "```py\n>>> fib.append((fib[-2] * litter) + fib[-1])\n>>> fib\n[0, 1, 1]\n```", "```py\n>>> fib.append((fib[-2] * litter) + fib[-1])\n>>> fib\n[0, 1, 1, 2]\n```", "```py\n>>> fib = [0, 1]\n>>> litter = 1\n>>> generations = 5\n>>> for _ in range(generations - 1):\n...     fib.append((fib[-2] * litter) + fib[-1])\n...\n>>> fib\n[0, 1, 1, 2, 3, 5]\n```", "```py\ndef main() -> None:\n    args = get_args()\n\n    fib = [0, 1] ![1](assets/1.png)\n    for _ in range(args.generations - 1): ![2](assets/2.png)\n        fib.append((fib[-2] * args.litter) + fib[-1]) ![3](assets/3.png)\n\n    print(fib[-1]) ![4](assets/4.png)\n```", "```py\ndef main() -> None:\n    args = get_args()\n\n    def fib(n: int) -> int: ![1](assets/1.png)\n        nums = [0, 1] ![2](assets/2.png)\n        for _ in range(n - 1): ![3](assets/3.png)\n            nums.append((nums[-2] * args.litter) + nums[-1]) ![4](assets/4.png)\n        return nums[-1] ![5](assets/5.png)\n\n    print(fib(args.generations)) ![6](assets/6.png)\n```", "```py\ndef main() -> None:\n    args = get_args()\n\n    print(fib(args.generations, args.litter)) ![1](assets/1.png)\n\ndef fib(n: int, litter: int) -> int: ![2](assets/2.png)\n    nums = [0, 1]\n    for _ in range(n - 1):\n        nums.append((nums[-2] * litter) + nums[-1])\n\n    return nums[-1]\n```", "```py\ndef fib(k: int) -> Generator[int, None, None]: ![1](assets/1.png)\n    x, y = 0, 1 ![2](assets/2.png)\n    yield x ![3](assets/3.png)\n\n    while True: ![4](assets/4.png)\n        yield y ![5](assets/5.png)\n        x, y = y * k, x + y ![6](assets/6.png)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    gen = fib(args.litter) ![1](assets/1.png)\n    seq = [next(gen) for _ in range(args.generations + 1)] ![2](assets/2.png)\n    print(seq[-1]) ![3](assets/3.png)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    gen = fib(args.litter)\n    answer = 0 ![1](assets/1.png)\n    for _ in range(args.generations + 1): ![2](assets/2.png)\n        answer = next(gen) ![3](assets/3.png)\n    print(answer) ![4](assets/4.png)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    seq = list(islice(fib(args.litter), args.generations + 1)) ![1](assets/1.png)\n    print(seq[-1]) ![2](assets/2.png)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    print(list(islice(fib(args.litter), args.generations + 1))[-1])\n```", "```py\ndef main() -> None:\n    args = get_args()\n\n    def fib(n: int) -> int: ![1](assets/1.png)\n        return 1 if n in (1, 2) \\ ![2](assets/2.png)\n            else fib(n - 2) * args.litter + fib(n - 1) ![3](assets/3.png)\n\n    print(fib(args.generations)) ![4](assets/4.png)\n```", "```py\n$ for n in 10 20 30 40;\n> do echo \"==> $n <==\" && time ./solution3_recursion.py $n 1\n> done\n==> 10 <==\n55\n\nreal\t0m0.045s\nuser\t0m0.032s\nsys\t0m0.011s\n==> 20 <==\n6765\n\nreal\t0m0.041s\nuser\t0m0.031s\nsys\t0m0.009s\n==> 30 <==\n832040\n\nreal\t0m0.292s\nuser\t0m0.281s\nsys\t0m0.009s\n==> 40 <==\n102334155\n\nreal\t0m31.629s\nuser\t0m31.505s\nsys\t0m0.043s\n```", "```py\ndef memoize(f: Callable) -> Callable: ![1](assets/1.png)\n    \"\"\" Memoize a function \"\"\"\n\n    cache = {} ![2](assets/2.png)\n\n    def memo(x): ![3](assets/3.png)\n        if x not in cache: ![4](assets/4.png)\n            cache[x] = f(x) ![5](assets/5.png)\n        return cache[x] ![6](assets/6.png)\n\n    return memo ![7](assets/7.png)\n```", "```py\ndef main() -> None:\n    args = get_args()\n\n    def fib(n: int) -> int:\n        return 1 if n in (1, 2) else fib(n - 2) * args.litter + fib(n - 1)\n\n    fib = memoize(fib) ![1](assets/1.png)\n\n    print(fib(args.generations))\n```", "```py\ndef main() -> None:\n    args = get_args()\n\n    @memoize ![1](assets/1.png)\n    def fib(n: int) -> int:\n        return 1 if n in (1, 2) else fib(n - 2) * args.litter + fib(n - 1)\n\n    print(fib(args.generations))\n```", "```py\nfrom functools import lru_cache\n```", "```py\ndef main() -> None:\n    args = get_args()\n\n    @lru_cache() ![1](assets/1.png)\n    def fib(n: int) -> int:\n        return 1 if n in (1, 2) else fib(n - 2) * args.litter + fib(n - 1)\n\n    print(fib(args.generations))\n```", "```py\n$ for py in ./solution1_list.py ./solution2_generator_islice.py \\\n./solution3_recursion_lru_cache.py; do echo $py && time $py 40 5; done\n./solution1_list.py\n148277527396903091\n\nreal\t0m0.070s\nuser\t0m0.043s\nsys\t0m0.016s\n./solution2_generator_islice.py\n148277527396903091\n\nreal\t0m0.049s\nuser\t0m0.033s\nsys\t0m0.013s\n./solution3_recursion_lru_cache.py\n148277527396903091\n\nreal\t0m0.041s\nuser\t0m0.030s\nsys\t0m0.010s\n```", "```py\n$ hyperfine -L prg ./solution1_list.py,./solution2_generator_islice.py,\\\n./solution3_recursion_lru_cache.py '{prg} 40 5' --prepare 'rm -rf __pycache__'\nBenchmark #1: ./solution1_list.py 40 5\n  Time (mean ± σ):      38.1 ms ±   1.1 ms    [User: 28.3 ms, System: 8.2 ms]\n  Range (min … max):    36.6 ms …  42.8 ms    60 runs\n\nBenchmark #2: ./solution2_generator_islice.py 40 5\n  Time (mean ± σ):      38.0 ms ±   0.6 ms    [User: 28.2 ms, System: 8.1 ms]\n  Range (min … max):    36.7 ms …  39.2 ms    66 runs\n\nBenchmark #3: ./solution3_recursion_lru_cache.py 40 5\n  Time (mean ± σ):      37.9 ms ±   0.6 ms    [User: 28.1 ms, System: 8.1 ms]\n  Range (min … max):    36.6 ms …  39.4 ms    65 runs\n\nSummary\n  './solution3_recursion_lru_cache.py 40 5' ran\n    1.00 ± 0.02 times faster than './solution2_generator_islice.py 40 5'\n    1.01 ± 0.03 times faster than './solution1_list.py 40 5'\n```", "```py\ndef test_bad_n():\n    \"\"\" Dies when n is bad \"\"\"\n\n    n = random.choice(list(range(-10, 0)) + list(range(41, 50))) ![1](assets/1.png)\n    k = random.randint(1, 5) ![2](assets/2.png)\n    rv, out = getstatusoutput(f'{RUN} {n} {k}') ![3](assets/3.png)\n    assert rv != 0 ![4](assets/4.png)\n    assert out.lower().startswith('usage:') ![5](assets/5.png)\n    assert re.search(f'n \"{n}\" must be between 1 and 40', out) ![6](assets/6.png)\n```", "```py\n>>> import random\n```", "```py\n>>> random.randint(1, 5)\n2\n>>> random.randint(1, 5)\n5\n```", "```py\n>>> random.choice(list(range(-10, 0)) + list(range(41, 50)))\n46\n>>> random.choice(list(range(-10, 0)) + list(range(41, 50)))\n-1\n```", "```py\ndef test_2():\n    \"\"\" Runs on good input \"\"\"\n\n    rv, out = getstatusoutput(f'{RUN} 30 4') ![1](assets/1.png)\n    assert rv == 0 ![2](assets/2.png)\n    assert out == '436390025825' ![3](assets/3.png)\n```", "```py\n$ cat Makefile\n.PHONY: test\n\ntest:\n\tpython3 -m pytest -xv --flake8 --pylint --mypy fib.py tests/fib_test.py\n\nall:\n    ../bin/all_test.py fib.py\n```", "```py\n#!/usr/bin/env python3\n\"\"\" Run the test suite on all solution*.py \"\"\"\n\nimport argparse\nimport os\nimport re\nimport shutil\nimport sys\nfrom subprocess import getstatusoutput\nfrom functools import partial\nfrom typing import NamedTuple\n\nclass Args(NamedTuple):\n    \"\"\" Command-line arguments \"\"\"\n    program: str ![1](assets/1.png)\n    quiet: bool ![2](assets/2.png)\n\n# --------------------------------------------------\ndef get_args() -> Args:\n    \"\"\" Get command-line arguments \"\"\"\n\n    parser = argparse.ArgumentParser(\n        description='Run the test suite on all solution*.py',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument('program', metavar='prg', help='Program to test') ![3](assets/3.png)\n\n    parser.add_argument('-q', '--quiet', action='store_true', help='Be quiet') ![4](assets/4.png)\n\n    args = parser.parse_args()\n\n    return Args(args.program, args.quiet)\n```", "```py\ndef main() -> None:\n    args = get_args()\n    cwd = os.getcwd() ![1](assets/1.png)\n    solutions = list( ![2](assets/2.png)\n        filter(partial(re.match, r'solution.*\\.py'), os.listdir(cwd))) ![3](assets/3.png)\n\n    for solution in sorted(solutions): ![4](assets/4.png)\n        print(f'==> {solution} <==')\n        shutil.copyfile(solution, os.path.join(cwd, args.program)) ![5](assets/5.png)\n        subprocess.run(['chmod', '+x', args.program], check=True) ![6](assets/6.png)\n        rv, out = getstatusoutput('make test') ![7](assets/7.png)\n        if rv != 0: ![8](assets/8.png)\n            sys.exit(out) ![9](assets/9.png)\n\n        if not args.quiet: ![10](assets/10.png)\n            print(out)\n\n    print('Done.') ![11](assets/11.png)\n```", "```py\nexit(status=None, /)\n    Exit the interpreter by raising SystemExit(status).\n\n    If the status is omitted or None, it defaults to zero (i.e., success).\n    If the status is an integer, it will be used as the system exit status.\n    If it is another kind of object, it will be printed and the system\n    exit status will be one (i.e., failure).\n```", "```py\n>>> import os\n>>> files = os.listdir()\n```", "```py\n>>> from pprint import pprint\n>>> pprint(files)\n['solution3_recursion_memoize_decorator.py',\n 'solution2_generator_for_loop.py',\n '.pytest_cache',\n 'Makefile',\n 'solution2_generator_islice.py',\n 'tests',\n '__pycache__',\n 'fib.py',\n 'README.md',\n 'solution3_recursion_memoize.py',\n 'bench.html',\n 'solution2_generator.py',\n '.mypy_cache',\n '.gitignore',\n 'solution1_list.py',\n 'solution3_recursion_lru_cache.py',\n 'solution3_recursion.py']\n```", "```py\n>>> import re\n>>> re.match(r'solution.*\\.py', 'solution1.py')\n<re.Match object; span=(0, 12), match='solution1.py'>\n```", "```py\n>>> type(re.match(r'solution.*\\.py', 'fib.py'))\n<class 'NoneType'>\n```", "```py\n>>> pprint(list(filter(lambda name: re.match(r'solution.*\\.py', name), files)))\n['solution3_recursion_memoize_decorator.py',\n 'solution2_generator_for_loop.py',\n 'solution2_generator_islice.py',\n 'solution3_recursion_memoize.py',\n 'solution2_generator.py',\n 'solution1_list.py',\n 'solution3_recursion_lru_cache.py',\n 'solution3_recursion.py']\n```", "```py\n>>> import operator\n>>> operator.add(1, 2)\n3\n```", "```py\n>>> from functools import partial\n>>> succ = partial(op.add, 1)\n```", "```py\n>>> succ(3)\n4\n>>> succ(succ(3))\n5\n```", "```py\n>>> f = partial(re.match, r'solution.*\\.py')\n```", "```py\n>>> type(f('solution1.py'))\n<class 're.Match'>\n>>> type(f('fib.py'))\n<class 'NoneType'>\n```", "```py\n>>> f()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: match() missing 1 required positional argument: 'string'\n```", "```py\n>>> pprint(list(filter(f, files)))\n['solution3_recursion_memoize_decorator.py',\n 'solution2_generator_for_loop.py',\n 'solution2_generator_islice.py',\n 'solution3_recursion_memoize.py',\n 'solution2_generator.py',\n 'solution1_list.py',\n 'solution3_recursion_lru_cache.py',\n 'solution3_recursion.py']\n```"]