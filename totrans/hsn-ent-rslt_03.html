<html><head></head><body><section data-pdf-bookmark="Chapter 3. Text Matching" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_3">&#13;
<h1><span class="label">Chapter 3. </span>Text Matching</h1>&#13;
&#13;
<p>As<a contenteditable="false" data-primary="text matching" data-secondary="approximate (fuzzy matching)" data-type="indexterm" id="id371"/> we saw in <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, once our data is cleansed and consistently formatted, we can find matching entities by checking for exact matches between their data attributes. If the data is of high quality, and if the attribute values are nonrepetitive, then checking for equivalence is straightforward. However, this is rarely the case with real-world data.</p>&#13;
&#13;
<p>We can increase our likelihood of matching all relevant records by using<a contenteditable="false" data-primary="matching" data-secondary="fuzzy matching" data-type="indexterm" id="id372"/><a contenteditable="false" data-primary="fuzzy matching" data-type="indexterm" id="id373"/><a contenteditable="false" data-primary="approximate (fuzzy) matching techniques" data-type="indexterm" id="id374"/> <em>approximate</em> (often referred to as <em>fuzzy</em>) <em>matching techniques</em>. For numerical values, we can set a tolerance on how close the values need to be. For example, a date of birth might be matched if it’s within a few days or a location might be matched if its coordinates are within a certain distance apart. For textual data, we can look for similarities and differences between strings that could arise accidentally.</p>&#13;
&#13;
<p>Of course, by accepting nonexact matches as equivalent we open up the possibility of matching records incorrectly.</p>&#13;
&#13;
<p>In this chapter, we will introduce some frequently used text matching techniques and then apply them to our sample problem to see if this can improve our entity resolution performance.</p>&#13;
&#13;
<section data-pdf-bookmark="Edit Distance Matching" data-type="sect1"><div class="sect1" id="id22">&#13;
<h1>Edit Distance Matching</h1>&#13;
&#13;
<p>For<a contenteditable="false" data-primary="text matching" data-secondary="edit distance matching" data-type="indexterm" id="TMedit03"/> matching text, one of the most useful approximate matching techniques is to measure the<a contenteditable="false" data-primary="edit distance" data-type="indexterm" id="id375"/> <em>edit distance</em> between two strings. The edit distance is the minimum number of operations to transform one string into the other. This metric can therefore be used to assess the likelihood that two strings do actually describe the same attribute, even if they were recorded differently.</p>&#13;
&#13;
<p>The first, and most universally applicable, approximate matching technique we will consider is the Levenshtein distance.</p>&#13;
&#13;
<section data-pdf-bookmark="Levenshtein Distance" data-type="sect2"><div class="sect2" id="id23">&#13;
<h2>Levenshtein Distance</h2>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="Levenshtein distance" data-type="indexterm" id="id376"/> <em>Levenshtein distance</em> is a well-known edit distance metric named after its creator, Soviet mathematician Vladimir Levenshtein.</p>&#13;
&#13;
<p>The Levenshtein distance between two strings, a and b (of length |a| and |b|, respectively), is given by lev(a,b), where</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="l e v left-parenthesis a comma b right-parenthesis equals StartLayout Enlarged left-brace 1st Row  StartAbsoluteValue a EndAbsoluteValue if StartAbsoluteValue b EndAbsoluteValue equals 0 comma 2nd Row  StartAbsoluteValue b EndAbsoluteValue if StartAbsoluteValue a EndAbsoluteValue equals 0 comma 3rd Row  l e v left-parenthesis t a i l left-parenthesis a right-parenthesis comma t a i l left-parenthesis b right-parenthesis right-parenthesis if a left-bracket 0 right-bracket equals b left-bracket 0 right-bracket comma 4th Row  1 plus m i n StartLayout Enlarged left-brace 1st Row  l e v left-parenthesis t a i l left-parenthesis a right-parenthesis comma b right-parenthesis 2nd Row  l e v left-parenthesis a comma t a i l left-parenthesis b right-parenthesis right-parenthesis otherwise 3rd Row  l e v left-parenthesis t a i l left-parenthesis a right-parenthesis comma t a i l left-parenthesis b right-parenthesis right-parenthesis EndLayout EndLayout">&#13;
  <mrow>&#13;
    <mi>l</mi>&#13;
    <mi>e</mi>&#13;
    <mi>v</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>a</mi>&#13;
      <mo>,</mo>&#13;
      <mi>b</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mfenced close="" open="{" separators="">&#13;
      <mtable>&#13;
        <mtr>&#13;
          <mtd columnalign="left">&#13;
            <mrow>&#13;
              <mo>|</mo>&#13;
              <mi>a</mi>&#13;
              <mo>|</mo>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mtext>if</mtext>&#13;
              <mspace width="4.pt"/>&#13;
              <mo>|</mo>&#13;
              <mi>b</mi>&#13;
              <mo>|</mo>&#13;
              <mo>=</mo>&#13;
              <mn>0</mn>&#13;
              <mo>,</mo>&#13;
            </mrow>&#13;
          </mtd>&#13;
        </mtr>&#13;
        <mtr>&#13;
          <mtd columnalign="left">&#13;
            <mrow>&#13;
              <mo>|</mo>&#13;
              <mi>b</mi>&#13;
              <mo>|</mo>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mtext>if</mtext>&#13;
              <mspace width="4.pt"/>&#13;
              <mo>|</mo>&#13;
              <mi>a</mi>&#13;
              <mo>|</mo>&#13;
              <mo>=</mo>&#13;
              <mn>0</mn>&#13;
              <mo>,</mo>&#13;
            </mrow>&#13;
          </mtd>&#13;
        </mtr>&#13;
        <mtr>&#13;
          <mtd columnalign="left">&#13;
            <mrow>&#13;
              <mi>l</mi>&#13;
              <mi>e</mi>&#13;
              <mi>v</mi>&#13;
              <mo>(</mo>&#13;
              <mi>t</mi>&#13;
              <mi>a</mi>&#13;
              <mi>i</mi>&#13;
              <mi>l</mi>&#13;
              <mo>(</mo>&#13;
              <mi>a</mi>&#13;
              <mo>)</mo>&#13;
              <mo>,</mo>&#13;
              <mi>t</mi>&#13;
              <mi>a</mi>&#13;
              <mi>i</mi>&#13;
              <mi>l</mi>&#13;
              <mo>(</mo>&#13;
              <mi>b</mi>&#13;
              <mo>)</mo>&#13;
              <mo>)</mo>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="0.166667em"/>&#13;
              <mspace width="0.166667em"/>&#13;
              <mspace width="0.166667em"/>&#13;
              <mspace width="0.166667em"/>&#13;
              <mspace width="0.166667em"/>&#13;
              <mspace width="0.166667em"/>&#13;
              <mspace width="0.166667em"/>&#13;
              <mspace width="0.166667em"/>&#13;
              <mtext>if</mtext>&#13;
              <mspace width="4.pt"/>&#13;
              <mi>a</mi>&#13;
              <mo>[</mo>&#13;
              <mn>0</mn>&#13;
              <mo>]</mo>&#13;
              <mo>=</mo>&#13;
              <mi>b</mi>&#13;
              <mo>[</mo>&#13;
              <mn>0</mn>&#13;
              <mo>]</mo>&#13;
              <mo>,</mo>&#13;
            </mrow>&#13;
          </mtd>&#13;
        </mtr>&#13;
        <mtr>&#13;
          <mtd columnalign="left">&#13;
            <mrow>&#13;
              <mn>1</mn>&#13;
              <mo>+</mo>&#13;
              <mi>m</mi>&#13;
              <mi>i</mi>&#13;
              <mi>n</mi>&#13;
              <mfenced close="" open="{" separators="">&#13;
                <mtable>&#13;
                  <mtr>&#13;
                    <mtd columnalign="left">&#13;
                      <mrow>&#13;
                        <mi>l</mi>&#13;
                        <mi>e</mi>&#13;
                        <mi>v</mi>&#13;
                        <mo>(</mo>&#13;
                        <mi>t</mi>&#13;
                        <mi>a</mi>&#13;
                        <mi>i</mi>&#13;
                        <mi>l</mi>&#13;
                        <mo>(</mo>&#13;
                        <mi>a</mi>&#13;
                        <mo>)</mo>&#13;
                        <mo>,</mo>&#13;
                        <mi>b</mi>&#13;
                        <mo>)</mo>&#13;
                      </mrow>&#13;
                    </mtd>&#13;
                  </mtr>&#13;
                  <mtr>&#13;
                    <mtd columnalign="left">&#13;
                      <mrow>&#13;
                        <mi>l</mi>&#13;
                        <mi>e</mi>&#13;
                        <mi>v</mi>&#13;
                        <mo>(</mo>&#13;
                        <mi>a</mi>&#13;
                        <mo>,</mo>&#13;
                        <mi>t</mi>&#13;
                        <mi>a</mi>&#13;
                        <mi>i</mi>&#13;
                        <mi>l</mi>&#13;
                        <mo>(</mo>&#13;
                        <mi>b</mi>&#13;
                        <mo>)</mo>&#13;
                        <mo>)</mo>&#13;
                        <mspace width="2.em"/>&#13;
                        <mspace width="2.em"/>&#13;
                        <mspace width="0.166667em"/>&#13;
                        <mspace width="0.166667em"/>&#13;
                        <mspace width="0.166667em"/>&#13;
                        <mspace width="0.166667em"/>&#13;
                        <mspace width="0.166667em"/>&#13;
                        <mspace width="0.277778em"/>&#13;
                        <mspace width="0.277778em"/>&#13;
                        <mspace width="0.277778em"/>&#13;
                        <mspace width="0.277778em"/>&#13;
                        <mtext>otherwise</mtext>&#13;
                      </mrow>&#13;
                    </mtd>&#13;
                  </mtr>&#13;
                  <mtr>&#13;
                    <mtd columnalign="left">&#13;
                      <mrow>&#13;
                        <mi>l</mi>&#13;
                        <mi>e</mi>&#13;
                        <mi>v</mi>&#13;
                        <mo>(</mo>&#13;
                        <mi>t</mi>&#13;
                        <mi>a</mi>&#13;
                        <mi>i</mi>&#13;
                        <mi>l</mi>&#13;
                        <mo>(</mo>&#13;
                        <mi>a</mi>&#13;
                        <mo>)</mo>&#13;
                        <mo>,</mo>&#13;
                        <mi>t</mi>&#13;
                        <mi>a</mi>&#13;
                        <mi>i</mi>&#13;
                        <mi>l</mi>&#13;
                        <mo>(</mo>&#13;
                        <mi>b</mi>&#13;
                        <mo>)</mo>&#13;
                        <mo>)</mo>&#13;
                      </mrow>&#13;
                    </mtd>&#13;
                  </mtr>&#13;
                </mtable>&#13;
              </mfenced>&#13;
            </mrow>&#13;
          </mtd>&#13;
        </mtr>&#13;
      </mtable>&#13;
    </mfenced>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Here, the tail of some string x is a string of all but the first character of x, and x[n] is the nth character of the string x, counting from 0.</p>&#13;
&#13;
<p>Opening the <em>Chapter3.ipynb</em> notebook, we can see how this works in practice. Fortunately, we don’t have to code the Levenshtein algorithm ourselves—the<a contenteditable="false" data-primary="Python" data-secondary="Jellyfish package" data-type="indexterm" id="id377"/><a contenteditable="false" data-primary="Jellyfish" data-type="indexterm" id="id378"/> Jellyfish Python package has an implementation we can use. This library also contains a number of other fuzzy and phonetic string-matching functions.</p>&#13;
&#13;
<div data-type="note" epub:type="note">&#13;
  <h1>Jellyfish</h1>&#13;
&#13;
<p><a href="https://github.com/jamesturk/jellyfish">Jellyfish</a> is a Python library for approximate and<a contenteditable="false" data-primary="matching" data-secondary="phonetic matching" data-type="indexterm" id="id379"/><a contenteditable="false" data-primary="phonetic matching" data-type="indexterm" id="id380"/> phonetic matching of strings.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
<p>If you don’t have this package installed, you can use a<a contenteditable="false" data-primary="Jupyter Notebook" data-type="indexterm" id="id381"/><a contenteditable="false" data-primary="Python" data-secondary="pip package manager" data-type="indexterm" id="id382"/><a contenteditable="false" data-primary="pip package manager" data-type="indexterm" id="id383"/><a contenteditable="false" data-primary="package managers" data-type="indexterm" id="id384"/> Jupyter Notebook magic command <code>%pip</code> to install it before importing:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
%pip install jellyfish&#13;
import jellyfish as jf</pre>&#13;
&#13;
<div data-type="warning" epub:type="warning">&#13;
<h1>Kernel Restart</h1>&#13;
&#13;
<p>After<a contenteditable="false" data-primary="kernel restarts" data-type="indexterm" id="id385"/><a contenteditable="false" data-primary="Python" data-secondary="kernel restarts" data-type="indexterm" id="id386"/> installing a new Python package, you may need to restart the kernel and rerun the notebook.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">We<a contenteditable="false" data-primary="misspelling errors" data-type="indexterm" id="id387"/><a contenteditable="false" data-primary="spelling mistakes/errors" data-type="indexterm" id="id388"/> can then calculate the edit distance metric to examine how a common misspelling error might be measured:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
<strong>jf.levenshtein_distance('Michael','Micheal')</strong>&#13;
2</pre>&#13;
&#13;
<p>Logically, the Levenshtein algorithm iterates character by character through the characters of the two strings, from first to last, incrementing the distance score if the characters do not match. In this case as the M, i, c, and h characters all match, the first time we increment the distance score is when we encounter the mismatch of letters a and e on the fifth character. At this point we then iterate through three variants of the remaining characters, selecting the minimum score between residual strings:</p>&#13;
&#13;
<ul class="simplelist">&#13;
	<li>“el” and “ael”</li>&#13;
<li>“ael” and “al”</li>&#13;
<li>“el” and “al”</li>&#13;
</ul>&#13;
&#13;
<p>All three options also have a mismatch on the next character, incrementing the score again. Repeating the process on each option generates three more suboptions, the last of which is a simple match between the final “l” of each string, for a total minimum score of 2.</p>&#13;
&#13;
<p>I leave it as an exercise for the reader to work through the remaining options, all of which produce the same score of 2.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Jaro Similarity" data-type="sect2"><div class="sect2" id="id24">&#13;
<h2>Jaro Similarity</h2>&#13;
&#13;
<p>An<a contenteditable="false" data-primary="Jaro similarity" data-type="indexterm" id="id389"/> alternative method of assessing the similarity of strings was suggested by Matthew Jaro in 1989. Wikipedia gives the formula as follows.</p>&#13;
&#13;
<p>The Jaro similarity <em>sim<sub>j</sub></em> of two strings <em>s<sub>1</sub></em> and <em>s<sub>2</sub></em> is</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="s i m Subscript j Baseline equals StartLayout Enlarged left-brace 1st Row  0 if m equals 0 2nd Row  one-third left-parenthesis StartFraction m Over StartAbsoluteValue s 1 EndAbsoluteValue EndFraction plus StartFraction m Over StartAbsoluteValue s 2 EndAbsoluteValue EndFraction plus StartFraction m minus t Over m EndFraction right-parenthesis otherwise EndLayout">&#13;
  <mrow>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <msub><mi>m</mi> <mi>j</mi> </msub>&#13;
    <mo>=</mo>&#13;
    <mfenced close="" open="{" separators="">&#13;
      <mtable>&#13;
        <mtr>&#13;
          <mtd columnalign="left">&#13;
            <mrow>&#13;
              <mn>0</mn>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="2.em"/>&#13;
              <mspace width="0.166667em"/>&#13;
              <mtext>if</mtext>&#13;
              <mspace width="0.166667em"/>&#13;
              <mi>m</mi>&#13;
              <mo>=</mo>&#13;
              <mn>0</mn>&#13;
            </mrow>&#13;
          </mtd>&#13;
        </mtr>&#13;
        <mtr>&#13;
          <mtd columnalign="left">&#13;
            <mrow>&#13;
              <mfrac><mn>1</mn> <mn>3</mn></mfrac>&#13;
              <mspace width="4pt"/>&#13;
              <mrow>&#13;
                <mo>(</mo>&#13;
                <mfrac><mi>m</mi> <mrow><mrow><mo>|</mo></mrow><msub><mi>s</mi> <mn>1</mn> </msub><mrow><mo>|</mo></mrow></mrow></mfrac>&#13;
                <mo>+</mo>&#13;
                <mfrac><mi>m</mi> <mrow><mrow><mo>|</mo></mrow><msub><mi>s</mi> <mn>2</mn> </msub><mrow><mo>|</mo></mrow></mrow></mfrac>&#13;
                <mo>+</mo>&#13;
                <mfrac><mrow><mi>m</mi><mo>-</mo><mi>t</mi></mrow> <mi>m</mi></mfrac>&#13;
                <mo>)</mo>&#13;
              </mrow>&#13;
              <mspace width="2.em"/>&#13;
              <mtext>otherwise</mtext>&#13;
            </mrow>&#13;
          </mtd>&#13;
        </mtr>&#13;
      </mtable>&#13;
    </mfenced>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>where:</p>&#13;
&#13;
<ul>&#13;
<li><p>|<em>s<sub>i</sub></em>| is the length of the string <em>s<sub>i</sub></em></p></li>&#13;
&#13;
<li><p><em>m</em> is the number of matching characters (see below)</p></li>&#13;
&#13;
<li><p><em>t</em> is the number of transpositions (see below)</p></li>&#13;
&#13;
<li><p>Jaro similarity score is 0 if the strings do not match at all, and 1 if they are an exact match.</p></li>&#13;
</ul>&#13;
&#13;
<p>In the first step, each character of <em>s<sub>1</sub></em> is compared with all its matching characters in <em>s<sub>2</sub></em>. Two characters from <em>s<sub>1</sub></em> and <em>s<sub>2</sub></em>, respectively, are considered matching only if they are the same and not farther than <math alttext="left floor StartFraction m a x left-parenthesis s 1 comma s 2 right-parenthesis Over 2 EndFraction right floor minus 1">&#13;
  <mrow>&#13;
    <mo>⌊</mo>&#13;
    <mfrac><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><msub><mi>s</mi> <mn>1</mn> </msub><mo>,</mo><msub><mi>s</mi> <mn>2</mn> </msub><mo>)</mo></mrow> <mn>2</mn></mfrac>&#13;
    <mo>⌋</mo>&#13;
    <mo>-</mo>&#13;
    <mn>1</mn>&#13;
  </mrow>&#13;
</math> characters apart. If no matching characters are found, then the strings are not similar and the algorithm terminates by returning Jaro similarity score 0. If nonzero matching characters are found, the next step is to find the number of transpositions. Transposition is the number of matching characters that are not in the right order divided by two.</p>&#13;
&#13;
<p>Again we can use the Jellyfish library to calculate this for us:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
<strong>jf.jaro_similarity('Michael','Micheal')</strong>&#13;
0.9523809523809524</pre>&#13;
&#13;
<p>Here the value is calculated as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="StartAbsoluteValue s 1 EndAbsoluteValue equals StartAbsoluteValue s 2 EndAbsoluteValue equals 7 left-parenthesis length of both strings right-parenthesis">&#13;
  <mrow>&#13;
    <mrow>&#13;
      <mo>|</mo>&#13;
    </mrow>&#13;
    <msub><mi>s</mi> <mn>1</mn> </msub>&#13;
    <mrow>&#13;
      <mo>|</mo>&#13;
      <mo>=</mo>&#13;
      <mo>|</mo>&#13;
    </mrow>&#13;
    <msub><mi>s</mi> <mn>2</mn> </msub>&#13;
    <mrow>&#13;
      <mo>|</mo>&#13;
      <mo>=</mo>&#13;
      <mn>7</mn>&#13;
      <mspace width="4.pt"/>&#13;
      <mtext>(length</mtext>&#13;
      <mspace width="4.pt"/>&#13;
      <mtext>of</mtext>&#13;
      <mspace width="4.pt"/>&#13;
      <mtext>both</mtext>&#13;
      <mspace width="4.pt"/>&#13;
      <mtext>strings)</mtext>&#13;
    </mrow>&#13;
  </mrow>&#13;
</math><br/>&#13;
<math alttext="m equals 7 left-parenthesis all characters match right-parenthesis">&#13;
  <mrow>&#13;
    <mi>m</mi>&#13;
    <mo>=</mo>&#13;
    <mn>7</mn>&#13;
    <mspace width="4.pt"/>&#13;
    <mtext>(all</mtext>&#13;
    <mspace width="4.pt"/>&#13;
    <mtext>characters</mtext>&#13;
    <mspace width="4.pt"/>&#13;
    <mtext>match)</mtext>&#13;
  </mrow>&#13;
</math><br/>&#13;
<math alttext="t equals 1 left-parenthesis a and e transposition right-parenthesis">&#13;
  <mrow>&#13;
    <mi>t</mi>&#13;
    <mo>=</mo>&#13;
    <mn>1</mn>&#13;
    <mspace width="4.pt"/>&#13;
    <mtext>(a</mtext>&#13;
    <mspace width="4.pt"/>&#13;
    <mtext>and</mtext>&#13;
    <mspace width="4.pt"/>&#13;
    <mtext>e</mtext>&#13;
    <mspace width="4.pt"/>&#13;
    <mtext>transposition)</mtext>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>Therefore, the Jaro similarity value is calculated as:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="equals one-third left-parenthesis seven-sevenths plus seven-sevenths plus StartFraction left-parenthesis 7 minus 1 right-parenthesis Over 7 EndFraction right-parenthesis equals StartFraction 20 Over 21 EndFraction equals 0.9523809523809524 period">&#13;
  <mrow>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>1</mn> <mn>3</mn></mfrac>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mfrac><mn>7</mn> <mn>7</mn></mfrac>&#13;
      <mo>+</mo>&#13;
      <mfrac><mn>7</mn> <mn>7</mn></mfrac>&#13;
      <mo>+</mo>&#13;
      <mfrac><mrow><mo>(</mo><mn>7</mn><mo>-</mo><mn>1</mn><mo>)</mo></mrow> <mn>7</mn></mfrac>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>20</mn> <mn>21</mn></mfrac>&#13;
    <mo>=</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>9523809523809524</mn>&#13;
    <mo>.</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>In both the Levenshtein and Jaro methods all the characters in a string contribute equally to the score. Often, however, when matching names, the first few characters are more significant. Therefore, if they are the same, they are more likely to indicate equivalence. To recognize this, a modification of the Jaro similarity was proposed by William E. Winkler in 1990.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Jaro-Winkler Similarity" data-type="sect2"><div class="sect2" id="id25">&#13;
<h2>Jaro-Winkler Similarity</h2>&#13;
&#13;
<p>Jaro-Winkler similarity<a contenteditable="false" data-primary="Jaro-Winkler similarity" data-type="indexterm" id="id390"/> uses a prefix scale <em>p</em> that gives more favorable ratings to strings that match from the beginning for a set prefix length <em>l</em>. Given two strings <em>s<sub>1</sub></em> and <em>s<sub>2</sub></em> their Jaro-Winkler similarity <em>sim<sub>w</sub></em> is <em>sim<sub>w</sub></em> = <em>sim<sub>j</sub></em> + <em>lp</em>(1 − <em>sim<sub>j</sub></em>), where:</p>&#13;
&#13;
<ul>&#13;
 <li><p><em>sim<sub>j</sub></em> is the Jaro similarity for <em>s</em><sub>1</sub> and <em>s</em><sub>2</sub>.</p></li>&#13;
&#13;
<li><p><em>l</em> is the length of common prefix at the start of the string up to a maximum of four characters.</p></li>&#13;
&#13;
<li><p><em>p</em> is a constant scaling factor for how much the score is adjusted upward for having common prefixes.</p></li>&#13;
&#13;
<li class="pagebreak-before"><p><em>p</em> should not exceed 0.25 (i.e., 1/4, with 4 being the maximum length of the prefix being considered); otherwise the similarity could become larger than 1.</p></li>&#13;
&#13;
<li><p>The standard value for this constant in Winkler’s work is <em>p</em> = 0.1.</p></li></ul>&#13;
&#13;
<p>Using this metric:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
<strong>jf.jaro_winkler_similarity('Michael','Micheal')</strong>&#13;
&#13;
0.9714285714285714</pre>&#13;
&#13;
<p>which is calculated as follows:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="equals StartFraction 20 Over 21 EndFraction plus 4 times 0.1 times left-parenthesis 1 minus StartFraction 20 Over 21 EndFraction right-parenthesis equals 0.9714285714285714">&#13;
  <mrow>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>20</mn> <mn>21</mn></mfrac>&#13;
    <mo>+</mo>&#13;
    <mn>4</mn>&#13;
    <mo>×</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>1</mn>&#13;
    <mo>×</mo>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mn>1</mn>&#13;
      <mo>-</mo>&#13;
      <mfrac><mn>20</mn> <mn>21</mn></mfrac>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mn>0</mn>&#13;
    <mo>.</mo>&#13;
    <mn>9714285714285714</mn>&#13;
  </mrow>&#13;
</math></p>&#13;
</div>&#13;
&#13;
<p>where:</p>&#13;
&#13;
&#13;
<ul>&#13;
<li><p><em>sim<sub>j</sub></em> = <math alttext="StartFraction 20 Over 21 EndFraction">&#13;
  <mfrac><mn>20</mn> <mn>21</mn></mfrac>&#13;
</math></p></li>&#13;
<li><p><em>l</em> = 4 (common prefix of “Mich”)</p></li>&#13;
&#13;
<li><p><em>p</em> = 0.1 (standard value)</p></li>&#13;
</ul>&#13;
&#13;
<p>It is worth noting that Jaro-Winkler similarity measures are case sensitive, so:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
<strong>jf.jaro_winkler_similarity('michael','MICHAEL')</strong>&#13;
0</pre>&#13;
&#13;
<p>A<a contenteditable="false" data-primary="lower case, converting to" data-type="indexterm" id="id391"/><a contenteditable="false" data-primary="case sensitivity" data-type="indexterm" id="id392"/> common practice is therefore to convert strings to lowercase before<a contenteditable="false" data-primary="" data-startref="TMedit03" data-type="indexterm" id="id393"/> matching.</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
<strong>jf.jaro_winkler_similarity('michael'.lower(),'MICHAEL'.lower())</strong>&#13;
1.0</pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Phonetic Matching" data-type="sect1"><div class="sect1" id="id26">&#13;
<h1>Phonetic Matching</h1>&#13;
&#13;
<p>An<a contenteditable="false" data-primary="text matching" data-secondary="phonetic matching" data-type="indexterm" id="id394"/><a contenteditable="false" data-primary="phonetic matching" data-type="indexterm" id="id395"/><a contenteditable="false" data-primary="matching" data-secondary="phonetic matching" data-type="indexterm" id="id396"/> alternative to edit distance matching is to compare how similarly words are pronounced. Most of these phonetic algorithms are based on English pronunciation, of which two of the most popular are <em>Metaphone</em> and <em>Match Rating Approach</em> (<em>MRA</em>).</p>&#13;
&#13;
<section data-pdf-bookmark="Metaphone" data-type="sect2"><div class="sect2" id="id27">&#13;
<h2>Metaphone</h2>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="Metaphone algorithm" data-type="indexterm" id="id397"/> Metaphone algorithm encodes each word into a sequence of letters from the set of “0BFHJKLMNPRSTWXY” where 0 represents the “th” sound and X represents “sh” or “ch.” For example, using the Jellyfish package, we can see <code>'michael'</code> is reduced to <code>'MXL'</code> as is <code>'michel'</code>.</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
<strong>jf.metaphone('michael')</strong>&#13;
MXL</pre>&#13;
&#13;
<p>This transformation produces a common key that can then be exact-matched to determine equivalence.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Match Rating Approach" data-type="sect2"><div class="sect2" id="id28">&#13;
<h2>Match Rating Approach</h2>&#13;
&#13;
<p>The<a contenteditable="false" data-primary="Match Rating Approach (MRA)" data-type="indexterm" id="id398"/><a contenteditable="false" data-primary="MRA (Match Rating Approach)" data-type="indexterm" id="id399"/> MRA phonetic algorithm was developed in the late 1970s. Like Metaphone, it uses a set of rules to encode a word into a simplified phonetic representation. A set of comparison rules are then used to assess similarity, which is evaluated against a minimum threshold derived from their combined lengths to determine whether there is a match.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Comparing the Techniques" data-type="sect1"><div class="sect1" id="id112">&#13;
<h1>Comparing the Techniques</h1>&#13;
&#13;
<p>To<a contenteditable="false" data-primary="text matching" data-secondary="comparing techniques" data-type="indexterm" id="id400"/> compare the edit distance and phonetic similarity techniques, let’s examine how well they evaluate common misspellings and abbreviations of Michael:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
mylist = ['Michael','Micheal','Michel','Mike','Mick']&#13;
combs = []&#13;
&#13;
import itertools&#13;
&#13;
for a, b in itertools.combinations(mylist, 2):&#13;
   combs.append([a,b,&#13;
      jf.jaro_similarity(a,b),&#13;
      jf.jaro_winkler_similarity(a, b),   &#13;
      jf.levenshtein_distance(a,b),&#13;
      jf.match_rating_comparison(a,b),&#13;
      (jf.metaphone(a)==jf.metaphone(b))])&#13;
&#13;
pd.DataFrame(combs, columns=['Name1','Name2','Jaro','JaroWinkler','Levenshtein',&#13;
 'Match Rating','Metaphone'])</pre>&#13;
&#13;
<p>This gives us the results shown in <a data-type="xref" href="#table-3-1">Table 3-1</a>.</p>&#13;
&#13;
<table id="table-3-1">&#13;
	<caption><span class="label">Table 3-1. </span>Text matching comparison</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col"><strong>Name1</strong></th>&#13;
			<th scope="col"><strong>Name2</strong></th>&#13;
			<th scope="col"><strong>Jaro</strong></th>&#13;
			<th scope="col"><strong>Jaro-Winkler</strong></th>&#13;
			<th scope="col"><strong>Levenshtein</strong></th>&#13;
			<th scope="col"><strong>Match rating</strong></th>&#13;
			<th scope="col"><strong>Metaphone</strong></th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>Michael</td>&#13;
			<td>Micheal</td>&#13;
			<td>0.952381</td>&#13;
			<td>0.971429</td>&#13;
			<td>2</td>&#13;
			<td>True</td>&#13;
			<td>True</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Michael</td>&#13;
			<td>Michel</td>&#13;
			<td>0.952381</td>&#13;
			<td>0.971429</td>&#13;
			<td>1</td>&#13;
			<td>True</td>&#13;
			<td>True</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Michael</td>&#13;
			<td>Mike</td>&#13;
			<td>0.726190</td>&#13;
			<td>0.780952</td>&#13;
			<td>4</td>&#13;
			<td>False</td>&#13;
			<td>False</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Michael</td>&#13;
			<td>Mick</td>&#13;
			<td>0.726190</td>&#13;
			<td>0.808333</td>&#13;
			<td>4</td>&#13;
			<td>True</td>&#13;
			<td>False</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Micheal</td>&#13;
			<td>Michel</td>&#13;
			<td>0.952381</td>&#13;
			<td>0.971429</td>&#13;
			<td>1</td>&#13;
			<td>True</td>&#13;
			<td>True</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Micheal</td>&#13;
			<td>Mike</td>&#13;
			<td>0.726190</td>&#13;
			<td>0.780952</td>&#13;
			<td>4</td>&#13;
			<td>False</td>&#13;
			<td>False</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Micheal</td>&#13;
			<td>Mick</td>&#13;
			<td>0.726190</td>&#13;
			<td>0.780952</td>&#13;
			<td>4</td>&#13;
			<td>True</td>&#13;
			<td>False</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Michel</td>&#13;
			<td>Mike</td>&#13;
			<td>0.750000</td>&#13;
			<td>0.808333</td>&#13;
			<td>3</td>&#13;
			<td>False</td>&#13;
			<td>False</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Michel</td>&#13;
			<td>Mick</td>&#13;
			<td>0.750000</td>&#13;
			<td>0.825000</td>&#13;
			<td>3</td>&#13;
			<td>True</td>&#13;
			<td>False</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Mike</td>&#13;
			<td>Mick</td>&#13;
			<td>0.833333</td>&#13;
			<td>0.866667</td>&#13;
			<td>2</td>&#13;
			<td>True</td>&#13;
			<td>True</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>As we can see just from this trivial example, there is a fair degree of consistency between the techniques but there is no single approach that is clearly superior in all cases. Many other string matching techniques have been developed that have their individuals strengths. For the purposes of this book, we will use the Jaro-Winkler algorithm because it performs well in matching names due to its bias toward the initial characters, which tend to be more significant. It is also widely supported in the data backends we will use.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Sample Problem" data-type="sect1"><div class="sect1" id="id29">&#13;
<h1>Sample Problem</h1>&#13;
&#13;
<p>In <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, we matched two lists of members of the UK House of Commons to explore a proposed correlation between<a contenteditable="false" data-primary="social media presence" data-type="indexterm" id="id401"/> social media presence and reelection. We used exact string matches to establish equivalence between the <code>Constituency</code>, <code>Firstname</code>, and <code>Lastname</code> attributes of the members.</p>&#13;
&#13;
<p>We found 628 true positive matches. But differences between the names meant we didn’t find non-exact matches, giving us nine false negatives. Let’s see if by using a string similarity metric we can improve our performance. We start by loading the unmatched records that we saved in <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, as shown in <a data-type="xref" href="#fig-3-1">Figure 3-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-3-1"><img alt="" class="iimagesch03ch03unmatchedpng" src="assets/hoer_0301.png"/>&#13;
<h6><span class="label">Figure 3-1. </span>Unmatched population</h6>&#13;
</div></figure>&#13;
&#13;
<p>Using the <code>apply</code> function, we can calculate the<a contenteditable="false" data-primary="Jaro-Winkler similarity" data-type="indexterm" id="id402"/> Jaro-Winkler similarity metric to compare the first names and last names between the two datasets. We use the Jaro-Winkler algorithm to take advantage of its better performance in matching names:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
df_w_un['Firstname_jaro'] = df_w_un.apply(&#13;
    lambda x: jf.jaro_winkler_similarity(x.Firstname_w, x.Firstname_t), axis=1)&#13;
&#13;
df_w_un['Lastname_jaro'] = df_w_un.apply(&#13;
    lambda x: jf.jaro_winkler_similarity(x.Lastname_w, x.Lastname_t), axis=1)</pre>&#13;
&#13;
<p>We<a contenteditable="false" data-primary="attributes" data-secondary="applying thresholds to" data-type="indexterm" id="id403"/> can then apply a threshold of 0.8 on both <code>Firstname</code> and <code>Lastname</code> attributes, giving us six matches, as shown in <a data-type="xref" href="#fig-3-2">Figure 3-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-3-2"><img alt="" class="iimagesch03ch03jaromatchpng" src="assets/hoer_0302.png"/>&#13;
<h6><span class="label">Figure 3-2. </span>Jaro-Winkler match population</h6>&#13;
</div></figure>&#13;
&#13;
<p>Not bad! We have now identified another six of the nine potential matches we previously missed. If we raise the threshold to 0.9 we would have found only two additional matches; if we lowered our threshold to 0.4, all would have matched all nine.</p>&#13;
&#13;
<p>As a reminder, in <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, we used an exact match on constituency. Then, to identify the unmatched population, we selected those records where either the first name or last name did not match. This allowed us to differentiate between true negatives arising from by-elections and false negatives, where we needed a more flexible matching technique. However, we rarely have a high-cardinality categorical variable like constituency to help us, so we need to consider how we would match these entities on name only.</p>&#13;
&#13;
<p>In this scenario, we can no longer use the simple merge method on exact attribute matches to join our datasets. Instead, we need to manually construct a<a contenteditable="false" data-primary="joins/joining" data-secondary="manual" data-type="indexterm" id="id404"/> joint dataset with every possible combination of records and then apply our similarity function to each pair of first name and last name to see which are sufficiently similar. We can then discount those combinations with equivalence scores below a chosen threshold. Clearly, this method can result in a record from the first dataset matching with more than one record from the second.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Full Similarity Comparison" data-type="sect1"><div class="sect1" id="id30">&#13;
<h1>Full Similarity Comparison</h1>&#13;
&#13;
<p>Picking<a contenteditable="false" data-primary="text matching" data-secondary="full similarity comparison" data-type="indexterm" id="TMfullsim03"/> up the cleansed datasets from <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, we can generate all the record combinations by using the cross-merge function. This generates a row for every name combination between the datasets, producing 650 × 650 = 422,500 records:</p>&#13;
&#13;
<pre class="pagebreak-before" data-type="programlisting">&#13;
df_w = pd.read_csv('mps_wiki_clean.csv')&#13;
df_t = pd.read_csv('mps_they_clean.csv')&#13;
cross = df_w.merge(df_t, how='cross',suffixes=('_w', '_t'))&#13;
cross.head(n=5)</pre>&#13;
&#13;
<p><a data-type="xref" href="#fig-3-3">Figure 3-3</a> shows the first few records in the<a contenteditable="false" data-primary="Wikipedia data" data-secondary="cross-product dataset" data-type="indexterm" id="id405"/><a contenteditable="false" data-primary="TheyWorkForYou data" data-secondary="cross-product dataset" data-type="indexterm" id="id406"/> cross-product dataset.</p>&#13;
&#13;
<figure><div class="figure" id="fig-3-3"><img alt="" class="iimagesch03ch03crosspng" src="assets/hoer_0303.png"/>&#13;
<h6><span class="label">Figure 3-3. </span>Wikipedia, TheyWorkForYou cross-product</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can then calculate the<a contenteditable="false" data-primary="Jaro-Winkler similarity" data-type="indexterm" id="id407"/> Jaro-Winkler similarity metrics for both first name and last name on each row. Applying a threshold of 0.8 allows us to determine for each row whether these values approximately match:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
cross['Firstname_jaro'] = cross.apply(lambda x: True if &#13;
    jf.jaro_winkler_similarity(x.Firstname_w, x.Firstname_t);0.8 &#13;
    else False, axis=1)&#13;
&#13;
cross['Lastname_jaro'] = cross.apply(lambda x: True if &#13;
    jf.jaro_winkler_similarity(x.Lastname_w, x.Lastname_t);0.8 &#13;
    else False, axis=1)</pre>&#13;
&#13;
<p>We can then select records where both the <code>Firstname</code> and <code>Lastname</code> attributes are approximately equivalent to our prospective matches. We can check whether these are correct by using the <code>Constituency</code> attribute to verify our results. We know that when the constituency doesn’t match we aren’t referring to the same member of Parliament.</p>&#13;
&#13;
<p>So let’s see how many true positive matches we have now:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
tp = cross[(cross['Firstname_jaro'] &amp; cross['Lastname_jaro']) &amp; &#13;
    (cross['Constituency_w']==cross['Constituency_t'])]&#13;
&#13;
len(tp)&#13;
634</pre>&#13;
&#13;
<p>These true positives include the 628 exact matches from <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a> plus the 6 approximate matches we identified earlier. But let’s see how many false positives we have picked up where the name attributes are approximately equivalent but the <code>Constituency</code> doesn’t match:</p>&#13;
&#13;
<pre class="pagebreak-before" data-type="programlisting">&#13;
fp = cross[(cross['Firstname_jaro'] &amp; cross['Lastname_jaro']) &amp; &#13;
    (cross['Constituency_w']!=cross['Constituency_t'])]&#13;
&#13;
len(fp)&#13;
19</pre>&#13;
&#13;
<p>Let’s take a look at a few of these 19 mismatching records in <a data-type="xref" href="#fig-3-4">Figure 3-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-3-4"><img alt="" class="iimagesch03ch03falsepositivespng" src="assets/hoer_0304.png"/>&#13;
<h6><span class="label">Figure 3-4. </span>Full match false positives</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can see that there is a similarity between these names although they do not refer to the same individual. These mismatches are the price we pay for adopting a similarity match to maximize our number of true positives.</p>&#13;
&#13;
<p>We can also examine the candidates we rejected by examining where the constituency matches but either the first name or last name doesn’t. We have to inspect these manually to determine whether they are true or false negatives.</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
fntn = cross[(~cross['Firstname_jaro'] | ~cross['Lastname_jaro']) &amp; &#13;
    (cross['Constituency_w']==cross['Constituency_t'])]&#13;
&#13;
len(fntn)&#13;
16</pre>&#13;
&#13;
<p><a data-type="xref" href="#fig-3-5">Figure 3-5</a> shows these 16 negative match records.</p>&#13;
&#13;
<p>Within the 16 negatives we can see the 13 by-election constituencies we declared as true negatives in <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>, plus 3 false negatives in the constituencies of Burton, South West Norfolk, and Newton Abbot, where the names are sufficiently different that their Jaro-Winkler match score falls below our 0.8 threshold.<a contenteditable="false" data-primary="" data-startref="TMfullsim03" data-type="indexterm" id="id408"/></p>&#13;
&#13;
<figure><div class="figure" id="fig-3-5"><img alt="" class="iimagesch03ch03negativespng" src="assets/hoer_0305.png"/>&#13;
<h6><span class="label">Figure 3-5. </span>Full match true and false negatives</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Measuring Performance" data-type="sect1"><div class="sect1" id="id31">&#13;
<h1>Measuring Performance</h1>&#13;
&#13;
<p>Now<a contenteditable="false" data-primary="text matching" data-secondary="measuring performance" data-type="indexterm" id="id409"/><a contenteditable="false" data-primary="performance, measuring" data-secondary="text matching" data-type="indexterm" id="id410"/><a contenteditable="false" data-primary="recall" data-type="indexterm" id="id411"/><a contenteditable="false" data-primary="precision" data-type="indexterm" id="id412"/><a contenteditable="false" data-primary="accuracy" data-type="indexterm" id="id413"/> let’s consider how our performance compares to the exact-only matching in <a data-type="xref" href="ch02.html#chapter_2">Chapter 2</a>:</p>&#13;
&#13;
<div data-type="equation">&#13;
<p><math alttext="upper R e c a l l equals StartFraction upper T upper P Over left-parenthesis upper T upper P plus upper F upper N right-parenthesis EndFraction equals StartFraction 634 Over left-parenthesis 634 plus 3 right-parenthesis EndFraction almost-equals 99.2 percent-sign">&#13;
  <mrow>&#13;
    <mi>R</mi>&#13;
    <mi>e</mi>&#13;
    <mi>c</mi>&#13;
    <mi>a</mi>&#13;
    <mi>l</mi>&#13;
    <mi>l</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>T</mi><mi>P</mi></mrow> <mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>634</mn> <mrow><mo>(</mo><mn>634</mn><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>99</mn>&#13;
    <mo>.</mo>&#13;
    <mn>2</mn>&#13;
    <mo>%</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper P r e c i s i o n equals StartFraction upper T upper P Over left-parenthesis upper T upper P plus upper F upper P right-parenthesis EndFraction equals StartFraction 634 Over left-parenthesis 634 plus 19 right-parenthesis EndFraction almost-equals 97 percent-sign">&#13;
  <mrow>&#13;
    <mi>P</mi>&#13;
    <mi>r</mi>&#13;
    <mi>e</mi>&#13;
    <mi>c</mi>&#13;
    <mi>i</mi>&#13;
    <mi>s</mi>&#13;
    <mi>i</mi>&#13;
    <mi>o</mi>&#13;
    <mi>n</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>T</mi><mi>P</mi></mrow> <mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mn>634</mn> <mrow><mo>(</mo><mn>634</mn><mo>+</mo><mn>19</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>97</mn>&#13;
    <mo>%</mo>&#13;
  </mrow>&#13;
</math></p>&#13;
&#13;
<p><math alttext="upper A c c u r a c y equals StartFraction left-parenthesis upper T upper P plus upper T upper N right-parenthesis Over left-parenthesis upper T upper P plus upper T upper N plus upper F upper P plus upper F upper N right-parenthesis EndFraction equals StartFraction left-parenthesis 634 plus 13 right-parenthesis Over left-parenthesis 634 plus 13 plus 19 plus 3 right-parenthesis EndFraction almost-equals 96.7 percent-sign">&#13;
  <mrow>&#13;
    <mi>A</mi>&#13;
    <mi>c</mi>&#13;
    <mi>c</mi>&#13;
    <mi>u</mi>&#13;
    <mi>r</mi>&#13;
    <mi>a</mi>&#13;
    <mi>c</mi>&#13;
    <mi>y</mi>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo>)</mo></mrow> <mrow><mo>(</mo><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi><mo>)</mo></mrow></mfrac>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mo>(</mo><mn>634</mn><mo>+</mo><mn>13</mn><mo>)</mo></mrow> <mrow><mo>(</mo><mn>634</mn><mo>+</mo><mn>13</mn><mo>+</mo><mn>19</mn><mo>+</mo><mn>3</mn><mo>)</mo></mrow></mfrac>&#13;
    <mo>≈</mo>&#13;
    <mn>96</mn>&#13;
    <mo>.</mo>&#13;
    <mn>7</mn>&#13;
    <mo>%</mo>&#13;
  </mrow>&#13;
</math></p></div>&#13;
&#13;
<p class="pagebreak-after">We can see in <a data-type="xref" href="#table-3-2">Table 3-2</a> that introducing a similarity threshold instead of demanding an exact match has improved our recall. In other words, we have missed fewer true matches, but at the expense of declaring a few incorrect matches, which reduces our precision and our overall accuracy.</p>&#13;
&#13;
<table id="table-3-2">&#13;
	<caption><span class="label">Table 3-2. </span>Exact versus approximate matching performance</caption>&#13;
	<thead>&#13;
		<tr>&#13;
			<th scope="col"> </th>&#13;
			<th scope="col"><strong>Exact match</strong></th>&#13;
			<th scope="col"><strong>Approximate match</strong></th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td>Precision</td>&#13;
			<td>100%</td>&#13;
			<td>97%</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Recall</td>&#13;
			<td>98.6%</td>&#13;
			<td>99.2%</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td>Accuracy</td>&#13;
			<td>98.5%</td>&#13;
			<td>96.7%</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<p>In this simple example, we set a threshold of 0.8 for both first name and last name, and we demanded that both attributes exceed this score for use to declare a match. This assigned the same importance to both attributes, but perhaps a match on first name isn’t as strong as a match on last name?</p>&#13;
&#13;
<p>Let’s have a look at how much repetition we see in both first names and last names in the<a contenteditable="false" data-primary="Wikipedia data" data-secondary="repetition in" data-type="indexterm" id="id414"/> Wikipedia dataset:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
<strong>df_w['Firstname'].value_counts().mean()</strong>&#13;
1.8950437317784257&#13;
&#13;
<strong>df_w['Lastname'].value_counts().mean()</strong>&#13;
1.1545293072824157</pre>&#13;
&#13;
<p>In this dataset, each <code>Firstname</code> is found, on average, 1.89 times versus 1.15 times for each <code>Lastname</code>. Therefore we could say that a <code>Lastname</code> match is 64% (1.89/1.15) more differentiating than a <code>Firstname</code> match. In the next chapter, we will examine how we can use probabilistic techniques to weight the importance of each attribute and combine these to produce an overall match confidence score.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id246">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we have explored how to use approximate matching techniques to assess the degree of equivalence between two attributes. We examined several algorithms for approximate text matching and set an equivalence threshold above which we declared a match.</p>&#13;
&#13;
<p>We saw how approximate matching can help us to find true positive matches we would otherwise miss but at the price of some false positives that we had to discount manually. We saw how the equivalence threshold we set affects this trade-off in performance.</p>&#13;
&#13;
<p>Finally, we considered whether we should give equal weight to matching attributes that have different levels of uniqueness when we are evaluating whether two records refer to the same entity.</p>&#13;
</div></section>&#13;
</div></section></body></html>