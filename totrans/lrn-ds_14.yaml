- en: Chapter 11\. Data Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As data scientists, we create data visualizations in order to understand our
    data and explain our analyses to other people. A plot should have a message, and
    it’s our job to communicate this message as clearly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html#ch-eda), we connected the choice of a statistical
    graph to the kind of data being plotted; we also introduced many standard plots
    and showed how to read them. In this chapter, we discuss the principles of effective
    data visualization that make it easier for our audience to grasp the message in
    our plot. We talk about how to choose scales for axes, handle large amounts of
    data with smoothing and aggregation, facilitate meaningful comparisons, incorporate
    study design, and add contextual information. We also show how to create plots
    using `plotly`, a popular package for plotting in Python.
  prefs: []
  type: TYPE_NORMAL
- en: One tricky part about writing a chapter on data visualization is that software
    packages for visualization change all the time, so any code we display can quickly
    get out of date. Because of this, some books avoid code entirely. We instead strike
    a balance, where we cover high-level data visualization principles that are broadly
    useful. Then we separately include practical plotting code to implement these
    principles. When new software becomes available, readers can still use our principles
    to guide the creation of their visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Scale to Reveal Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 10](ch10.html#ch-eda), we explored prices for houses sold in the
    San Francisco Bay Area between 2003 and 2009\. Let’s revisit that example and
    take a look at a histogram of sale prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in01.png)'
  prefs: []
  type: TYPE_IMG
- en: While this plot accurately displays the data, most of the visible bins are crammed
    into the left side of the plot. This makes it hard to understand the distribution
    of prices.
  prefs: []
  type: TYPE_NORMAL
- en: Through data visualization, we want to reveal important features of the data,
    like the shape of a distribution and the relationship between two or more features.
    As this example shows, after we produce an initial plot, there are still other
    aspects we need to consider. In this section, we cover *principles of scale* that
    help us decide how to adjust the axis limits, place tick marks, and apply transformations.
    We begin by examining when and how we might adjust a plot to reduce empty space;
    in other words, we try to fill the data region of our plot with data.
  prefs: []
  type: TYPE_NORMAL
- en: Filling the Data Region
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we can see from the histogram of sale prices, it’s hard to read a distribution
    when most of the data appear in a small portion of the plotting region. When this
    happens, important features of the data, like multiple modes and skewness, can
    be obscured. A similar issue happens for scatterplots. When all the points are
    bunched together in the corner of a scatterplot, it’s hard to see the shape of
    the distribution and therefore glean any insights the shape would impart.
  prefs: []
  type: TYPE_NORMAL
- en: This issue can crop up when there are a few unusually large observations. In
    order to get a better view of the main portion of the data, we can drop those
    observations from the plot by adjusting the x- or y-axis limits, or we can remove
    the outlier values from the data before plotting. In either case, we mention this
    exclusion in the caption or on the plot itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use this idea to improve the histogram of sale prices. In the side-by-side
    plots that follow, we clip the data by changing the limits of the x-axis. On the
    left, we’ve excluded houses that cost over $2 million. The shape of the distribution
    for the bulk of the houses is much clearer in this plot. For instance, we can
    more easily observe the skewness and a smaller secondary mode. On the right, we
    separately show detail in the long right tail of the distribution (see it larger
    [online](https://oreil.ly/lVDrE)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in02.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the x-axis in the left plot includes 0, but the x-axis in the right
    plot begins at $2M. We consider when to include or exclude 0 on an axis next.
  prefs: []
  type: TYPE_NORMAL
- en: Including Zero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We often don’t need to include 0 on an axis, especially if including it makes
    it difficult to fill the data region. For example, let’s make a scatterplot of
    average longevity plotted against average height for dog breeds. (This dataset
    was first introduced in [Chapter 10](ch10.html#ch-eda); it includes several features
    for 172 breeds.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in03.png)'
  prefs: []
  type: TYPE_IMG
- en: The x-axis of the plot on the left starts at 10 cm since all dogs are at least
    that tall, and similarly, the y-axis begins at 6 years. The scatterplot on the
    right includes 0 on both axes. This pushes the data up to the top of the data
    region and leaves empty space that doesn’t help us see the linear relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some cases where we usually want to include 0\. For bar charts, including
    0 is important so that the heights of the bars directly relate to the data values.
    As an example, we’ve created two bar charts that compare the longevity of dog
    breeds. The left plot includes 0, but the right plot doesn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in04.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s easy to incorrectly conclude from the right plot that small breeds live
    twice as long as large breeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also typically want to include 0 when working with proportions, since proportions
    range from 0 to 1\. The following plot shows the proportion of breeds in each
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in05.png)'
  prefs: []
  type: TYPE_IMG
- en: In both the bar and dot plots, including 0 makes it easier for you to accurately
    compare the relative sizes of the categories.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, when we adjusted axes, we essentially dropped data from our plotting
    region. While this is a useful strategy when a handful of observations are unusually
    large (or small), it is less effective with skewed distributions. In this situation,
    we often need to transform the data to gain a better view of its shape.
  prefs: []
  type: TYPE_NORMAL
- en: Revealing Shape Through Transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common way to adjust scale is to transform the data or the plot’s axes.
    We use transformations for skewed data so that it is easier to inspect the distribution.
    And when the transformation produces a symmetric distribution, the symmetry carries
    with it useful properties for modeling (see [Chapter 15](ch15.html#ch-linear)).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to transform data, but the log transformation tends
    to be especially useful. For instance, in the following charts we reproduced two
    histograms of San Francisco house sale prices. The top histogram is the original
    data. For the histogram below, we took the log (base 10) of the prices before
    plotting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in06.png)'
  prefs: []
  type: TYPE_IMG
- en: The log transformation makes the distribution of prices more symmetric. Now
    we can more easily see important features of the distribution, like the mode at
    around <math><msup><mn>10</mn> <mrow><mn>5.85</mn></mrow></msup></math> , which
    is about 700,000, and the secondary mode near <math><msup><mn>10</mn> <mrow><mn>5.55</mn></mrow></msup></math>
    , or 350,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside of using the log transform is that the actual values aren’t as
    intuitive—in this example, we needed to convert the values back to dollars to
    understand the sale price. Therefore, we often favor transforming the axis to
    a log scale, rather than the data. This way, we can see the original values on
    the axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in07.png)'
  prefs: []
  type: TYPE_IMG
- en: This histogram with its log-scaled x-axis essentially shows the same shape as
    the histogram of the transformed data. But since the axis is displayed in the
    original units, we can directly read off the location of the modes in dollars.
    Note that the bins get narrower to the right because the bin widths are equal
    on the USD scale but plotted on the log USD scale. Also note that <math><mi>μ</mi></math>
    on the y-axis is <math><msup><mn>10</mn> <mrow><mo>−</mo> <mn>6</mn></mrow></msup></math>
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The log transform can also reveal shape in scatterplots. Here, we’ve plotted
    building size on the x-axis and lot size on the y-axis. It’s hard to see the shape
    in this plot since many of the points are crammed along the bottom of the data
    region:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, when we use a log scale for both the x- and y-axes, the shape of the
    relationship is much easier to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in09.png)'
  prefs: []
  type: TYPE_IMG
- en: With the transformed axes, we can see that the lot size increases roughly linearly
    with building size (on the log scale). The log transformation pulls large values—values
    that are orders of magnitude larger than others—in toward the center. This transformation
    can help fill the data region and uncover hidden structure, as we saw for both
    the distribution of house price and the relationship between house size and lot
    size.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to setting the limits of an axis and transforming an axis, we also
    want to consider the aspect ratio of the plot—the length compared to the width.
    Adjusting the aspect ratio is called *banking*, and in the next section, we show
    how banking can help reveal relationships between features.
  prefs: []
  type: TYPE_NORMAL
- en: Banking to Decipher Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With scatterplots, we try to choose scales so that the relationship between
    the two features roughly follows a 45-degree line. This scaling is called *banking
    to 45 degrees*. It makes it easier to see shape and trends because our eyes can
    more easily pick up deviations from a line this way. As an example of this, we’ve
    reproduced the plot that shows longevity of dog breeds against height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in10.png)'
  prefs: []
  type: TYPE_IMG
- en: The scatterplot has been banked to 45 degrees, and we can more easily see how
    the data roughly follow a line and where they deviate a bit at the extremes.
  prefs: []
  type: TYPE_NORMAL
- en: While banking to 45 degrees helps us see whether or not the data follow a linear
    relationship, when there is clear curvature it can be hard to figure out the form
    of the relationship. When this happens, we try transformations that will get the
    data to fall along a straight line (see, for example, [Figure 11-1](#example-transforms)).
    The log transformation can be useful in uncovering the general form of curvilinear
    relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Revealing Relationships Through Straightening
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We often use scatter plots to look at the relationship between two features.
    For instance, here we’ve plotted height against weight for the dog breeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in11.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that taller dogs weigh more, but this relationship isn’t linear.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it looks like two variables have a nonlinear relationship, it’s useful
    to try applying a log scale to the x-axis, y-axis, or both. Let’s look for a linear
    relationship in the scatterplot with transformed axes. Here we re-created the
    plot of weight by height for dog breeds, but this time we applied a log scale
    to the y-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in12.png)'
  prefs: []
  type: TYPE_IMG
- en: This plot shows a roughly linear relationship, and in this case, we say that
    there’s a log–linear relationship between dog weight and height.
  prefs: []
  type: TYPE_NORMAL
- en: In general, when we see a linear relationship after transforming one or both
    axes, we can use [Table 11-1](#tab-transform-rels) to reveal what relationship
    the original variables have (in the table, a and b are constants). We make these
    transformations because it is easier for us to see if points fall along a line
    than to see if they follow a power law compared to an exponential.
  prefs: []
  type: TYPE_NORMAL
- en: Table 11-1\. Relationships between two variables when transformations are applied
  prefs: []
  type: TYPE_NORMAL
- en: '| x-axis | y-axis | Relationship | Also known as |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| No transform | No transform | Linear: <math><mi>y</mi> <mo>=</mo> <mi>a</mi>
    <mi>x</mi> <mo>+</mo> <mi>b</mi></math> | Linear |'
  prefs: []
  type: TYPE_TB
- en: '| Log–scale | No transform | Log: <math><mi>y</mi> <mo>=</mo> <mi>a</mi> <mi>log</mi>
    <mo>⁡</mo> <mi>x</mi> <mo>+</mo> <mi>b</mi></math> | Linear–log |'
  prefs: []
  type: TYPE_TB
- en: '| No transform | Log–scale | Exponential: <math><mi>y</mi> <mo>=</mo> <mi>b</mi>
    <msup><mi>a</mi> <mi>x</mi></msup></math> | Log–linear |'
  prefs: []
  type: TYPE_TB
- en: '| Log–scale | Log–scale | Power: <math><mi>y</mi> <mo>=</mo> <mi>b</mi> <msup><mi>x</mi>
    <mi>a</mi></msup></math> | Log–log |'
  prefs: []
  type: TYPE_TB
- en: As [Table 11-1](#tab-transform-rels) shows, the log transform can reveal several
    common types of relationships. Because of this, the log transform is considered
    the jackknife of transformations. As another, albeit artificial, example, the
    leftmost plot in [Figure 11-1](#example-transforms) reveals a curvilinear relationship
    between *x* and *y*. The middle plot shows a different curvilinear relationship
    between *log(y)* and *x*; this plot also appears nonlinear. A further log transformation,
    at the far right, displays a plot of *log(y)* against *log(x)*. This plot confirms
    that the data have a log–log (or power) relationship because the transformed points
    fall along a line.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. Scatterplots showing how log transforms can “straighten” a curvilinear
    relationship between two variables
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Adjusting scale is an important practice in data visualization. While the log
    transform is versatile, it doesn’t handle all situations where skew or curvature
    occurs. For example, at times the values are all roughly the same order of magnitude
    and the log transformation has little impact. Another transformation to consider
    is the square root transformation, which is often useful for count data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at principles of smoothing, which we use when we
    need to visualize lots of data.
  prefs: []
  type: TYPE_NORMAL
- en: Smoothing and Aggregating Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we have lots of data, we often don’t want to plot all of the individual
    data points. The following scatter plot shows data from [Cherry Blossom](https://www.cherryblossom.org),
    an annual 10-mile race that takes place in Washington, DC, in April, when the
    cherry trees are in bloom. These data were scraped from the race’s website and
    include official times and other information for all registered male runners from
    1999 to 2012\. We’ve plotted the runners’ ages on the x-axis and race times on
    the y-axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in13.png)'
  prefs: []
  type: TYPE_IMG
- en: This scatterplot contains over 70,000 points. With so many points, many of them
    overlap. This is a common problem called *overplotting*. In this case, overplotting
    prevents us from seeing how time and age are related. About the only thing that
    we can see in this plot is a group of very young runners, which points to possible
    issues with data quality. To address overplotting, we use smoothing techniques
    that aggregate data before plotting.
  prefs: []
  type: TYPE_NORMAL
- en: Smoothing Techniques to Uncover Shape
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The histogram is a familiar type of plot that uses smoothing. A histogram aggregates
    data values by putting points into bins and plotting one bar for each bin. Smoothing
    here means that we cannot differentiate the location of individual points in a
    bin: the points are smoothly allocated across their bins. With histograms, the
    area of a bin corresponds to the percentage (or count or proportion) of points
    in the bin. (Often the bins are equal in width, and we take a shortcut to label
    the height of a bin as the proportion.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following histogram plots the distribution of lifespans for dog breeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in14.png)'
  prefs: []
  type: TYPE_IMG
- en: Above this histogram is a rug plot that draws a single line for every data value.
    We can see in the tallest bin that even a small amount of data can cause overplotting
    in the rug plot. By smoothing out the points in the rug plot, the histogram reveals
    the general shape of the distribution. In this case, we see that many breeds have
    a longevity of about 12 years. For more on how to read and interpret histograms,
    see [Chapter 10](ch10.html#ch-eda).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common smoothing technique is *kernel density estimation* (KDE). A
    KDE plot shows the distribution using a smooth curve rather than bars. In the
    following plot, we show the same histogram of dog longevity with a KDE curve overlaid.
    The KDE curve has a similar shape as the histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in15.png)'
  prefs: []
  type: TYPE_IMG
- en: It might come as a surprise to think of a histogram as a smoothing method. Both
    the KDE and histogram aim to help us see important features in the distribution
    of values. Similar smoothing techniques can be used with scatterplots. This is
    the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Smoothing Techniques to Uncover Relationships and Trends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can find high-density regions of a scatterplot by binning data, like in
    a histogram. The following plot remakes the earlier scatterplot of the Cherry
    Blossom race times against age. This plot uses hexagonal bins to aggregate points
    together, and then shades the hexagons based on how many points fall in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in16.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the high-density region in the 25-to-40 age group, signified by the dark
    region in the plot. The plot shows us that many of the runners in this age range
    complete the race in around 5,000 seconds (about 80 minutes). (Note that we drop
    the dubious young runners from this plot.) We can also see upward curvature in
    the region corresponding to the 40-to-60 age group, which indicates that these
    runners are generally slower than those in the 25-to-40 age group. This plot is
    similar to a heat map, where the higher-density regions are conveyed through hotter
    or brighter colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kernel density estimation also works in two dimensions. When we use KDE in
    two dimensions, we typically plot the contours of the resulting three-dimensional
    shape, and we read the plot like a topographical map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in17.png)'
  prefs: []
  type: TYPE_IMG
- en: This two-dimensional KDE gives similar insights as the shaded squares of the
    previous plot. We see a high concentration of runners in the 25-to-40 age group,
    and these runners have times that appear to be roughly 5,000 seconds. Smoothing
    lets us get a better picture when there’s lots of data because it can reveal the
    locations of highly concentrated data values and the shape of these high-concentration
    regions. These regions may be impossible to see otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another smoothing approach that is often more informative smooths the y-values
    for points with a similar x-value. To explain, let’s group together runners with
    similar ages, using five-year increments: 20–25, 25–30, 30–35, and so on. Then,
    for each five-year bin of runners, we average their race times, plot the average
    time for each group, and connect the points to form a “curve”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in18.png)'
  prefs: []
  type: TYPE_IMG
- en: This plot shows once again that runners in the 25-to-40 age range have typical
    run times of about 5,400 seconds. It also shows that older runners took longer
    to complete the race on average (not really a surprise, but it wasn’t nearly as
    evident in the earlier plots). The dip in times for runners under age 20 and the
    flattening of the curve at age 80 may simply be the result of fewer and fitter
    runners in these groups. Another smoothing technique uses kernel smoothing similar
    to the KDE. We don’t go into the details here.
  prefs: []
  type: TYPE_NORMAL
- en: The binning and kernel smoothing techniques rely on a tuning parameter that
    specifies the width of the bin or the spread of the kernel, and we often need
    to specify this parameter when making a histogram, KDE, or smooth curve. This
    is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Smoothing Techniques Need Tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve seen how smoothing is useful for plotting, we turn to the issue
    of tuning. For histograms, the width of the bins or, for equal-width bins, the
    number of bins affects the look of the histogram. The left histogram of longevity
    shown here has a few wide bins, and the right histogram has many narrow bins (see
    it larger [online](https://oreil.ly/SmLYq)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in19.png)'
  prefs: []
  type: TYPE_IMG
- en: In both histograms, it’s hard to see the shape of the distribution. With a few
    wide bins (the plot on the left), we have oversmoothed the distribution, which
    makes it impossible to discern modes and tails. On the other hand, too many bins
    (the plot on the right) gives a plot that’s little better than a rug plot. KDE
    plots have a parameter called the *bandwidth* that works similarly to the bin
    width of a histogram.
  prefs: []
  type: TYPE_NORMAL
- en: Most histogram and KDE software automatically chooses the bin width for the
    histogram and the bandwidth for the kernel. However, these parameters often need
    a bit of fiddling to create the most useful plot. When you create visualizations
    that rely on tuning parameters, it’s important to try a few different values before
    settling on one.
  prefs: []
  type: TYPE_NORMAL
- en: A different approach to data reduction is to examine quantiles. This is the
    topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing Distributions to Quantiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We found in [Chapter 10](ch10.html#ch-eda) that while box plots aren’t as informative
    as histograms, they can be useful when comparing the distributions of many groups
    at once. A box plot reduces the data to a few essential features based on the
    data quartiles. More generally, quantiles (the lower quartile, median, and upper
    quartile are the 25th, 50th, and 75th quantiles) can provide a useful reduction
    in the data when comparing distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When two distributions are roughly similar in shape, it can be hard to compare
    them with histograms. For instance, the histograms that follow show the price
    distributions for two- and four-bedroom houses in the San Francisco housing data.
    The distributions look roughly similar in shape. But a plot of their quantiles
    handily compares the distributions’ center, spread, and tails (see it larger [online](https://oreil.ly/zVagW)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can compare quantiles with a *quantile–quantile* plot, called *q–q plot*
    for short. To make this plot, we first compute percentiles (also called quantiles)
    for both the two- and four-bedroom distributions of price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|   | percentile | br2 | br4 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **0** | 1 | 1.50e+05 | 2.05e+05 |'
  prefs: []
  type: TYPE_TB
- en: '| **1** | 2 | 1.82e+05 | 2.50e+05 |'
  prefs: []
  type: TYPE_TB
- en: '| **2** | 3 | 2.03e+05 | 2.75e+05 |'
  prefs: []
  type: TYPE_TB
- en: '| **...** | ... | ... | ... |'
  prefs: []
  type: TYPE_TB
- en: '| **96** | 97 | 1.04e+06 | 1.75e+06 |'
  prefs: []
  type: TYPE_TB
- en: '| **97** | 98 | 1.20e+06 | 1.95e+06 |'
  prefs: []
  type: TYPE_TB
- en: '| **98** | 99 | 1.44e+06 | 2.34e+06 |'
  prefs: []
  type: TYPE_TB
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we plot the matching percentiles on a scatterplot. We usually also show
    the reference line y = x to help with the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in21.png)'
  prefs: []
  type: TYPE_IMG
- en: When the quantile points fall along a line, the variables have similarly shaped
    distributions. Lines parallel to the reference indicate a difference in center,
    lines with slopes other than 1 indicate a difference in spread, and curvature
    indicates a difference in shape. From the preceding q–q plot, we see that the
    distribution of price for four-bedroom houses is similar in shape to the two-bedroom
    distribution, except for a shift of about $100K and a slightly longer right tail
    (indicated by the upward bend for large values). Reading a q–q plot takes practice.
    Once you get the hang of it, though, it can be a handy way to compare distributions.
    Notice that the housing data have over 100,000 observations, and the q–q plot
    has reduced the data to 99 percentiles. This data reduction is quite useful. However,
    we don’t always want to use smoothers. This is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: When Not to Smooth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Smoothing and aggregating can help us see important features and relationships,
    but when we have only a handful of observations, smoothing techniques can be misleading.
    With just a few observations, we prefer rug plots over histograms, box plots,
    and density curves, and we use scatterplots rather than smooth curves and density
    contours. This may seem obvious, but when we have a large amount of data, the
    amount of data in a subgroup can quickly dwindle. This phenomenon is an example
    of the *curse of dimensionality*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common misuses of smoothing happens with box plots. As an example,
    here is a collection of seven box plots of longevity, one for each of seven types
    of dog breed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of these box plots have as few as two or three observations. The strip
    plot that follows is a preferable visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in23.png)'
  prefs: []
  type: TYPE_IMG
- en: In this plot, we can still compare the groups, but we also see the exact values
    in each group. Now we can tell that there are only three breeds in the non-sporting
    group; the impression of a skewed distribution, based on the box plot, reads too
    much into the shape of the box.
  prefs: []
  type: TYPE_NORMAL
- en: This section introduced the problem of overplotting, where we have overlapping
    points because of a large dataset. To address this issue, we introduced smoothing
    techniques that aggregate data. We saw two common examples of smoothing—binning
    and kernel smoothing—and applied them in the one- and two-dimensional settings.
    In one dimension, these are histograms and kernel density curves, respectively,
    and they both help us see the shape of a distribution. In two dimensions, we found
    it useful to smooth y-values while keeping x-values fixed in order to visualize
    trends. We addressed the need to tune the smoothing amount to get more informative
    histograms and density curves, and we cautioned against smoothing with too few
    data.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other ways to reduce overplotting in scatter plots. For instance,
    we can make the dots partially transparent so that overlapping points appear darker.
    If many observations have the same values (like when longevity is rounded to the
    nearest year), then we can add a small amount of random noise to the values to
    reduce the amount of overplotting. This procedure is called *jittering*, and it
    is used in the strip plot of longevity. Transparency and jittering are convenient
    for medium-sized data. However, they don’t work well for large datasets since
    plotting all the points still overwhelms the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The quantile–quantile plot we introduced offers one way to compare distributions
    with far fewer points; another is to use side-by-side box plots and yet another
    is to overlay KDE curves in the same plot. We often aim to compare distributions
    and relationships across subsets (or groups) of data, and we next discuss several
    design principles that facilitate meaningful comparisons for a variety of plot
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Facilitating Meaningful Comparisons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same data can be visualized in many different ways, and deciding which plot
    to make can be daunting. Generally speaking, our plot should help a reader make
    meaningful comparisons. In this section, we go over several useful principles
    that can improve the clarity of our plots.
  prefs: []
  type: TYPE_NORMAL
- en: Emphasize the Important Difference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever we make a plot that compares groups, we consider whether the plot emphasizes
    the important difference. As a rule of thumb, it’s easier for readers to see differences
    when plotted objects are aligned in ways that make these comparisons easier to
    read. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: The [US Bureau of Labor Statistics](https://oreil.ly/b0YMJ) publishes data on
    income. We took the 2020 median full-time-equivalent weekly earnings for people
    over age 25 and plotted them. We split people into groups by education level and
    sex:^([1](ch11.html#id1365))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These bar plots show that earnings increase with more education. But arguably,
    a more interesting comparison is between men and women of the same education level.
    We can group the bars differently to focus instead on this comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This plot is much better; we can more easily compare the earnings of men and
    women for each level of education. However, we can make this difference even clearer
    using vertical alignment. Instead of bars, we use dots for groups of men and women
    that align vertically at each education level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This plot more clearly reveals an important difference: the earnings gap between
    men and women grows with education. We considered three plots that visualize the
    same data, but they differ in how readily we can see the message in the plot.
    We prefer the last one because it aligns the income differences vertically, making
    them easier to compare.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in making all three plots, we ordered the education categories from
    the least to greatest number of years of education. This ordering makes sense
    because education level is ordinal. When we compare nominal categories, we use
    other approaches to ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Ordering Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With ordinal features, we keep the categories in their natural order when we
    make plots, but the same principle does not apply for nominal features. Instead,
    we choose an ordering that helps us make comparisons. With bar plots, it’s a good
    practice to order the bars according to their height, while for box plots and
    strip plots, we typically order the boxes/strips according to medians.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two bar plots that follow each compare the mean lifespan for types of dog
    breeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in27.png)'
  prefs: []
  type: TYPE_IMG
- en: The plot on the left orders the bars alphabetically. We prefer the plot on the
    right because it orders the bars by longevity, which makes it easier to compare
    longevity across the categories. We don’t have to bounce back and forth or squint
    to guess whether herding breeds have a shorter lifespan than toy breeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, the following two sets of box plots each compare the distribution
    of sale price for houses in different cities in the San Francisco East Bay area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in28.png)'
  prefs: []
  type: TYPE_IMG
- en: We prefer the plot on the right since it has boxes ordered according to the
    median price for each city. Again, this ordering makes it easier to compare distributions
    across groups, in this case cities. We see that the lower quartile and median
    price in Albany and Walnut Creek are roughly the same, but the prices in Walnut
    Creek have a greater right skew.
  prefs: []
  type: TYPE_NORMAL
- en: When possible, ordering bars in a bar plot by height and boxes in a box plot
    by median makes it easier for us to make comparisons across groups. Another technique
    used for presenting grouped data is stacking. We describe stacking in the next
    section and provide examples to convince you to steer away from this sort of plot.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Stacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The figure that follows shows a stacked bar plot in which there is one bar
    for each city and these bars are divided according to the proportion of houses
    sold that have from one to eight or more bedrooms. This is called a *stacked bar
    plot*. The bar plot is based on a cross-tabulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| br | 1.0 | 2.0 | 3.0 | 4.0 | 5.0 | 6.0 | 7.0 | 8.0 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| city |   |   |   |   |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Albany** | 1.21e-01 | 0.56 | 0.25 | 0.05 | 9.12e-03 | 1.01e-03 | 2.03e-03
    | 4.05e-03 |'
  prefs: []
  type: TYPE_TB
- en: '| **Berkeley** | 6.91e-02 | 0.38 | 0.31 | 0.16 | 4.44e-02 | 1.42e-02 | 6.48e-03
    | 7.23e-03 |'
  prefs: []
  type: TYPE_TB
- en: '| **El Cerrito** | 1.81e-02 | 0.34 | 0.47 | 0.14 | 2.20e-02 | 6.48e-03 | 0.00e+00
    | 6.48e-04 |'
  prefs: []
  type: TYPE_TB
- en: '| **Piedmont** | 8.63e-03 | 0.22 | 0.40 | 0.26 | 9.50e-02 | 1.29e-02 | 7.19e-03
    | 1.44e-03 |'
  prefs: []
  type: TYPE_TB
- en: '| **Richmond** | 3.60e-02 | 0.36 | 0.42 | 0.15 | 2.52e-02 | 7.21e-03 | 7.72e-04
    | 7.72e-04 |'
  prefs: []
  type: TYPE_TB
- en: '| **Walnut Creek** | 1.16e-01 | 0.35 | 0.30 | 0.18 | 4.37e-02 | 5.08e-03 |
    4.12e-04 | 2.75e-04 |'
  prefs: []
  type: TYPE_TB
- en: 'Each bar in the plot has the same height of 1 because the segments represent
    the proportion of houses with one or more bedrooms in a city and so add to 1 or
    100% (see it in color [online](https://oreil.ly/cIba_)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in29.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s easy to compare the proportion of one-bedroom houses in each of the cities
    by simply scanning across the top of the first segment in each column. But the
    comparison of four-bedroom houses is more difficult. The bottoms of the segments
    are not aligned horizontally, so our eyes must judge the lengths of segments that
    move up and down across the plot. This up-and-down movement is called *jiggling
    the baseline*. (We recognize that with so many colors, this plot does not render
    well in grayscale, but our goal is to steer you away from plots like this one
    and the next, so we have kept all of the colors for those of you reading the online
    version.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Stacked line plots are even more difficult to read because we have to judge
    the gap between curves as they jiggle up and down. The following plot shows [carbon
    dioxide (CO[2]) emissions](https://oreil.ly/kjk9N) from 1950 to 2012 for the 10
    highest emitters (see it in color [online](https://oreil.ly/VUyuz)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the lines are stacked on top of each other, it’s very hard to see how
    the emissions for a particular country have changed and it’s hard to compare countries.
    Instead, we can plot each country’s line without stacking, as the next plot illustrates
    (see it in color [online](https://oreil.ly/erWuU)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in31.png)'
  prefs: []
  type: TYPE_IMG
- en: Now it’s much easier to see changes for individual countries and to compare
    countries because we need judge only y-axis positions rather than short vertical
    segments with different baselines. We also used a log scale on the y-axis. We
    can now see that some countries have had flat rates of growth in CO[2] emissions,
    such as the United States and Japan, while others have increased much more quickly,
    like China and India, and Germany has slowed its CO[2] emissions. These aspects
    were nearly impossible to detect when each country’s baseline jiggled across the
    plot.
  prefs: []
  type: TYPE_NORMAL
- en: In both of these plots, to make it easier to tell one country from the next,
    we have used different line types and colors. Choosing colors to facilitate comparisons
    relies on many considerations. This is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a Color Palette
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Choosing colors also plays an important role in data visualization. We want
    to avoid overly bright or dark colors so that we don’t strain the reader’s eyes.
    We should also avoid color palettes that might be difficult for colorblind people—7%
    to 10% of people (mostly males) are red-green colorblind.
  prefs: []
  type: TYPE_NORMAL
- en: For categorical data, we want to use a color palette that can clearly distinguish
    between categories. One example is shown at the top in [Figure 11-2](#three-palettes).
    From top to bottom, these palettes are qualitative for categorical data, diverging
    for numeric data where you want to draw attention to both large and small values,
    and sequential for numeric data where you want to emphasize either large or small
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_1102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. Three printer-friendly palettes from ColorBrewer 2.0 (see it in
    color [online](https://oreil.ly/0ub2H))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For numeric data, we want to use a sequential color palette that emphasizes
    one side of the spectrum more than the other or a diverging color palette that
    equally emphasizes both ends of the spectrum and deemphasizes the middle. A sequential
    palette is shown at the bottom and a diverging palette is shown in the middle
    of [Figure 11-2](#three-palettes).
  prefs: []
  type: TYPE_NORMAL
- en: We choose a sequential palette when we want to emphasize either low or high
    values, like cancer rates. We choose a diverging palette when we want to emphasize
    both extremes, like for two-party election results.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to choose a perceptually uniform color palette. By this we mean
    that when a data value is doubled, the color in the visualization looks twice
    as colorful to the human eye. We also want to avoid colors that create an afterimage
    when we look from one part of the graph to another, colors of different intensities
    that make one attribute appear more important than another, and colors that colorblind
    people have trouble distinguishing between. We strongly recommend using a palette
    or a palette generator made specifically for data visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Plots are meant to be examined for long periods of time, so we should choose
    colors that don’t impede the reader’s ability to carefully study a plot. Even
    more so, the use of color should not be gratuitous—colors should represent information.
    On a related note, people typically have trouble distinguishing between more than
    about seven colors, so we limit the number of colors in a plot. Finally, colors
    can appear quite different when printed on paper in grayscale than when viewed
    on a computer screen. When we choose colors, we keep in mind how our plots will
    be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Making accurate comparisons in a visualization is such an important goal that
    researchers have studied how well people perceive differences in colors and other
    plotting features such as angles and lengths. This is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for Comparisons in Plots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Researchers have studied how accurately people can read information displayed
    in different types of plots. They have found the following ordering, from most
    to least accurately judged:'
  prefs: []
  type: TYPE_NORMAL
- en: Positions along a common scale, like in a rug plot, strip plot, or dot plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positions on identical, nonaligned scales, like in a bar plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Length, like in a stacked bar plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angle and slope, like in a pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Area, like in a stacked line plot or bubble chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume and density, like in a three-dimensional bar plot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color saturation and hue, like when overplotting with semitransparent points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, here is a pie chart that shows the proportion of houses sold
    in San Francisco that have from one to eight or more bedrooms, and a bar chart
    with the same proportions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in32.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s hard to judge the angles in the pie chart, and the annotations with the
    actual percentages are needed. We also lose the natural ordering of the number
    of bedrooms. The bar chart doesn’t suffer from these issues.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are exceptions to any rule. Multiple pie charts with only two
    or three slices in each pie can provide effective visualizations. For example,
    a set of pie charts of the proportion of two-bedroom houses sold in each of six
    cities in the San Francisco East Bay Area, ordered according to the proportion,
    can be an impactful visualization. Yet, sticking with a bar chart will generally
    always be at least as clear as any pie chart.
  prefs: []
  type: TYPE_NORMAL
- en: Given these guidelines, we recommend sticking to position and length for making
    comparisons. Readers can more accurately judge comparisons based on position or
    length, rather than angle, area, volume, or color. But, if we want to add additional
    information to a plot, we often use color, symbols, and line styles, in addition
    to position and length. We have shown several examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We next turn to the topic of data design and how to reflect the aspects of when,
    where, and how the data were collected in a visualization. This is a subtle but
    important topic. If we ignore the data scope, we can get very misleading plots.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating the Data Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create a visualization, it’s important to consider the data scope, especially
    the data design (see [Chapter 2](ch02.html#ch-data-scope)). Considering the question
    of how the data were collected can impact our plot choice and the comparisons
    we portray. These considerations include the time and place where the data were
    collected and the design used to select a sample. We look at a few examples of
    how the data scope can inform the visualizations we make.
  prefs: []
  type: TYPE_NORMAL
- en: Data Collected Over Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When data are collected over time, we typically make a line plot that puts
    timestamps on the x-axis and a feature of interest on the y-axis to look for trends
    in time. As an example, let’s revisit the data on San Francisco housing prices.
    These data were collected from 2003 through 2008 and show the crash in 2008/2009
    of the [US housing bubble](https://oreil.ly/PUPiQ). Since time is a key aspect
    of the scope of these data, let’s visualize sale price as a time series. Our earlier
    explorations showed that sale price is highly skewed, so let’s work with percentiles
    rather than averages. We plot the median price (this is a form of smoothing we
    saw earlier in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This plot shows the rise in prices from 2003 to 2007 and the fall in 2008\.
    But we can show more information by plotting a few additional percentiles instead
    of just the median. Let’s draw separate lines for the 10th, 30th, 50th (median),
    70th, and 90th percentile sale prices. When we examine prices over time, we typically
    need to adjust for inflation so that the comparisons are on the same footing.
    In addition to adjusting for inflation, let’s plot the prices relative to the
    starting price in 2003 for each of the percentiles. This means that all the lines
    start at y = 1 in 2003\. (A value of 1.5 for the 90th percentile in 2006 indicates
    that the sale price is 1.5 times the 90th percentile in 2003.) This normalization
    lets us see how the housing crash affected home owners in the different parts
    of the market:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in34.png)'
  prefs: []
  type: TYPE_IMG
- en: When we follow the 10th percentile line plot over time, we see that it increases
    quickly in 2005, stays high relative to its 2003 value for a few years, and then
    drops earlier and more quickly than the other percentiles. This tells us that
    the less expensive houses, such as starter homes, suffered greater volatility
    and lost much more value in the housing market crash. In contrast, higher-end
    homes were affected less by the crash; at the end of 2008, the 90th percentile
    home prices were still higher than the 2003 prices. Applying this bit of domain
    knowledge helps reveal trends in the data that we might otherwise miss, and shows
    how we can use the data design to improve a visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The housing data are an example of observational data that form a complete census
    in a geographic region over a specific period of time. Next we consider another
    observational study where self-selection and the time period impact the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Observational Studies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to be particularly cautious with data that do not form a census or
    scientific sample. We should also take care with cross-sectional studies, whether
    from a census or scientific sample. For this example, we revisit the data from
    the Cherry Blossom 10-mile run. Earlier in this chapter, we made a smoothed curve
    to examine the relationship between race time and age. We reproduce this plot
    here to highlight a potential pitfall in interpretation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in35.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s tempting to look at this plot and conclude that, for instance, a runner
    at age 60 can typically expect to take an additional 600 seconds to finish the
    run than when they were 40\. However, this is a *cross-sectional* study, not a
    *longitudinal* study. The study does not follow people over time; instead, it
    gets a snapshot of a cross-section of people. The 60-year-old runners represented
    in the plot are different people than the 40-year-old runners. These two groups
    could be different in ways that affect the relationship between race time and
    age. As a group, the 60-year-olds in the race are likely to be fitter for their
    age than the 40-year-olds. In other words, the data design doesn’t let us make
    conclusions about individual runners. The visualization isn’t wrong, but we need
    to be careful about the conclusions we draw from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design is even more complex because we have race results from many years.
    Each year forms a cohort, a group of racers, and from one year to the next, the
    cohort changes. We create a visualization that makes this message clear by comparing
    runners in different race years. Here, we’ve separately plotted lines for the
    runners in 1999, 2005, and 2010:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in36.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that the median race times in 2010 are higher at every age group than
    the times for the runners in 2005, and in turn, the times are higher for the runners
    in 2005 than for the runners in 1999\. It’s interesting that race times have slowed
    over the years. This is quite likely due to the increased popularity of the race,
    where there is higher participation from novice runners in more recent years.
    This example has shown how we need to be aware of the data scope when interpreting
    patterns. We also need to keep data scope in mind with scientific studies. This
    is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Unequal Sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a scientific study, we must consider the sample design because it can impact
    our plots. Some samples draw individuals at unequal rates, and this needs to be
    accounted for in our visualizations. We saw an example of a scientific study in
    [Chapter 8](ch08.html#ch-files) and [Chapter 9](ch09.html#ch-wrangling): the Drug
    Abuse Warning Network (DAWN) survey. These data are from a complex randomized
    study of drug-related emergency room visits, and each record comes with a weight
    that we must use in order to accurately represent the emergency room visits in
    the population. The two bar plots that follow show the distribution of the type
    of ER visit. (See them larger [online](https://oreil.ly/LYAol).) The one on the
    left doesn’t use the survey weights and the one on the right does:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in37.png)'
  prefs: []
  type: TYPE_IMG
- en: In the unweighted bar plot, the “Other” category is as frequent as the “Adverse
    reaction” category. However, when weighted, “Other” drops to about two-thirds
    of “Adverse reaction.” Ignoring sampling weights can give a misleading presentation
    of a distribution. Whether for a histogram, bar plot, box plot, two-dimensional
    contour, or smooth curve, we need to use the weights to get a representative plot.
    Another aspect of the data scope that can impact our choice of plots is where
    the data are collected, which is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Geographic Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When our data contains geographic information like latitude and longitude,
    we should consider making a map, in addition to the typical plots. For example,
    the following map shows the locations for US air quality sensors, which is the
    focus of the case study in [Chapter 12](ch12.html#ch-pa):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in38.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that there are many more points in California and the Eastern Seaboard.
    A simple histogram of air quality with data from all of these sensors would misrepresent
    the distribution of air quality in the US. To incorporate the spatial aspect into
    the distribution, we can add air quality measurements to the map with different
    color markers, and we can facet the histograms of air quality by location.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to plotting features like bars, color, and line styles, we also
    have the option to add text with contextual information to make our plot more
    informative. This is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have used text in our graphs throughout this chapter to provide meaningful
    axis labels that include units of measurement, tick-mark labels for categories,
    and titles. This is a good practice when sharing a visualization more broadly.
    A good goal is to include enough context in a plot that it can stand alone—a reader
    should be able to get the gist of the plot without needing to search for explanation
    elsewhere. That said, every element of a statistical graph should have a purpose.
    Superfluous text or plot features, often referred to as *chartjunk*, should be
    eliminated. In this section, we provide a brief overview of ways we can add helpful
    context to our plots and an example where we create a publication-ready plot by
    adding context.
  prefs: []
  type: TYPE_NORMAL
- en: Text context includes *labels* and *captions*. It is a good practice to consistently
    use informative labels on tick marks and axes. For example, axis labels often
    benefit from including units of measurement. Graphs should contain titles and
    legends when needed. Informative labels are especially important for plots that
    other people will see and interpret. However, even when we’re doing exploratory
    data analysis just for us, we often want to include enough context that when we
    later return to an analysis we can easily figure out what we plotted.
  prefs: []
  type: TYPE_NORMAL
- en: Captions serve several purposes. They describe what has been plotted and orient
    the reader. Captions also point out important features of the plot and comment
    on their implications. It’s OK for the caption to repeat information found in
    the text. Readers often skim a publication and focus on section headings and visualizations,
    so plot captions should be self-contained.
  prefs: []
  type: TYPE_NORMAL
- en: '*Reference markers* bring additional context to the plotting region. Reference
    points and lines that provide benchmarks, historical values, and other external
    information help form comparisons and interpretations. For example, we often add
    a reference line with slope 1 to a quantile–quantile plot. We might also add a
    vertical line on a time-series plot to mark a special event, like a natural disaster.'
  prefs: []
  type: TYPE_NORMAL
- en: The following example demonstrates how to add these context elements to a plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: 100m Sprint Times'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following figure shows the race times in the men’s 100-meter sprint since
    1968\. These data include only races that were electronically timed and held outdoors
    in normal wind conditions, and the times included are only for those runners who
    came in under 10 seconds. The plot is a basic scatterplot showing race time against
    year. Beginning with this plot, we augment it to create a plot featured in a [FiveThirtyEight
    article](https://oreil.ly/pxHr4) about the 100-meter sprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in39.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we want to prepare a plot for others to read, we consider the takeaway
    message. In this case, our main message is twofold: the best runners have been
    getting faster over the past 50 years, and Usain Bolt’s remarkable record time
    of 9.58 seconds set in 2009 remains untouched. (In fact, the second-best race
    time also belongs to Bolt.) We provide context to this plot by adding a title
    that directly states the main takeaway, units of measurement in the y-axis label,
    and annotations to key points in the scatterplot, including the two best race
    times that belong to Usain Bolt. In addition, we add a horizontal reference line
    at 10 seconds to clarify that only times below 10 seconds are plotted, and we
    use a special symbol for the world record time to draw the reader’s attention
    to this crucial point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/leds_11in40.png)'
  prefs: []
  type: TYPE_IMG
- en: These bits of context describe what we have plotted, help readers see the main
    takeaway, and point out several interesting features in the data. The plot can
    now be a useful part of a slideshow, technical report, or social media post. In
    our experience, people who look at our data analyses remember our plots, not paragraphs
    of text or equations. It’s important to go the extra mile and add context to the
    plots we prepare for others.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we move on to specifics on how to create plots using the
    `plotly` Python package.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Plots Using plotly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we cover the basics of the `plotly` Python package, the main
    tool we use in this book to create plots.
  prefs: []
  type: TYPE_NORMAL
- en: The `plotly` package has several advantages over other plotting libraries. It
    creates interactive plots rather than static images. When you create a plot in
    `plotly`, you can pan and zoom to see parts of the plot that are too small to
    see normally. You can also hover over plot elements, like the symbols in a scatterplot,
    to see the raw data values. Also, `plotly` can save plots using the SVG file format,
    which means that images appear sharp even when zoomed in. If you’re reading this
    chapter in a PDF or paper copy of the book, we used this feature to render plot
    images. Finally, it has a simple “express” API for creating basic plots, which
    helps when you’re doing exploratory analysis and want to quickly create many plots.
  prefs: []
  type: TYPE_NORMAL
- en: We go over the fundamentals of `plotly` in this section. We recommend using
    the [official `plotly` documentation](https://plotly.com/python) if you encounter
    something that isn’t covered here.
  prefs: []
  type: TYPE_NORMAL
- en: Figure and Trace Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every plot in `plotly` is wrapped in a `Figure` object. `Figure` objects keep
    track of what to draw. For instance, a single `Figure` can draw a scatterplot
    on the left and a line plot on the right. `Figure` objects also keep track of
    the plot layout, which includes the plot’s size, title, legend, and annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `plotly.express` module provides a concise API for making plots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `plotly.express` in the following code to make a scatterplot of weight
    against height for the data on dog breeds. Notice that the return value from `.scatter()`
    is a `Figure` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying a `Figure` object renders it to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This particular `Figure` holds one plot, but `Figure` objects can hold any
    number of plots. Here, we create a facet of three scatterplots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in42.png)'
  prefs: []
  type: TYPE_IMG
- en: These three plots are stored in `Trace` objects. However, we try to avoid manipulating
    `Trace` objects manually. Instead, `plotly` provides functions that automatically
    create faceted subplots, like the `px.scatter` function we used here. Now that
    we have seen how to make a simple plot, we next show how to modify plots.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We often need to change a figure’s layout. For instance, we might want to adjust
    the figure’s margins or the axis range. We can use the `Figure.update_layout()`
    method to do this. In the facet scatterplot that we made, the title is cut off
    because the plot doesn’t have large enough margins. We can correct this with `Figure.update_layout()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in43.png)'
  prefs: []
  type: TYPE_IMG
- en: The `.update_layout()` method lets us modify any property of a layout. This
    includes the plot title (`title`), margins (`margins` dictionary), and whether
    to display a legend (`showlegend`). The `plotly` documentation has the full list
    of [layout properties](https://oreil.ly/aBLxx).
  prefs: []
  type: TYPE_NORMAL
- en: '`Figure` objects also have `.update_xaxes()` and `.update_yaxes()` functions,
    which are similar to `.update_layout()`. These two functions let us modify properties
    of the axes, like the axis limits (`range`), number of ticks (`nticks`), and axis
    label (`title`). Here, we adjust the range of the y-axis and change the title
    on the x-axis. We also add a title to the plot and update the layout so that the
    title is not cut off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in44.png)'
  prefs: []
  type: TYPE_IMG
- en: The `plotly` package comes with many plotting methods; we describe several of
    them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `plotly` methods includes line plots, scatterplots, bar plots, box plots,
    and histograms. The API is similar for each type of plot. The dataframe is the
    first argument. Then we can specify a column of the dataframe to place on the
    x-axis and a column to place on the y-axis using the `x` and `y` keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with a line plot of median time each year for the runners in the Cherry
    Blossom race:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we make a bar plot of average longevity for different size dog breeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Plotting methods in `plotly` also contain arguments for making facet plots.
    We can facet using color on the same plot, plotting symbol, or line style. Or
    we can facet into multiple subplots. Following are examples of each. We first
    make a scatterplot of height and weight of dog breeds and use different plotting
    symbols and colors to facet within the plot by size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next plot shows side-by-side histograms of longevity for each breed size.
    Here we facet by columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in48.png)'
  prefs: []
  type: TYPE_IMG
- en: For the complete list of plotting functions, see the main documentation for
    [`plotly`](https://oreil.ly/GxvpT) or [`plotly.express`](https://oreil.ly/DhU9j),
    the submodule of `plotly` that we primarily use in the book.
  prefs: []
  type: TYPE_NORMAL
- en: To add context to a plot, we use the `plotly` annotation methods; these are
    described next.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Figure.add_annotation()` method places annotations on a `plotly` figure.
    These annotations are line segments with text and an optional arrow. The location
    of the arrow is set using the `x` and `y` parameters, and we can shift the text
    from its default position using the `ax` and `ay` parameters. Here, we annotate
    the scatter diagram with information about one of the points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/leds_11in49.png)'
  prefs: []
  type: TYPE_IMG
- en: This section covered the basics of creating plots using the `plotly` Python
    package. We introduced the `Figure` object, which is the object `plotly` uses
    to store plots and their layouts. We covered the basic plot types that `plotly`
    makes available, and a few ways to customize plots by adjusting the layout and
    axes and by adding annotations. In the next section, we briefly compare `plotly`
    to other common tools for creating visualizations in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Other Tools for Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many software packages and tools for creating data visualizations.
    In this book, we primarily use `plotly`. But it’s worth knowing about a few other
    commonly used tools. In this section, we compare `plotly` to `matplotlib` and
    to the grammar of graphics tools.
  prefs: []
  type: TYPE_NORMAL
- en: matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library [`matplotlib`](https://matplotlib.org/) is one of the first data
    visualization tools created for Python. Because of this, it is widely used and
    has a large ecosystem of packages. Notably, the built-in plotting methods for
    `pandas DataFrames` make plots using `matplotlib`. One popular package that builds
    on top of `matplotlib` is called [`seaborn`](https://seaborn.pydata.org). Compared
    to `matplotlib` alone, `seaborn` provides a much simpler API to create statistical
    plots, like dot plots with confidence intervals. In fact, `seaborn`’s API was
    used as an inspiration for `plotly`’s API. If you look at `plotly` code and `seaborn`
    code side by side, you’ll find that the methods to create basic plots use similar
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of using `matplotlib` is its popularity. It’s relatively easy
    to find help creating or fine-tuning plots online because many existing projects
    use it. For this book, the main advantage of using `plotly` is that the plots
    we create are interactive. Plots in `matplotlib` are usually static images, which
    don’t allow for panning, zooming, or hovering over marks. Still, we expect that
    `matplotlib` will continue to be used for data analyses. In fact, several of the
    plots in this book were made using `seaborn` and `matplotlib` because `plotly`
    doesn’t yet support all the plots we want to make.
  prefs: []
  type: TYPE_NORMAL
- en: Grammar of Graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [grammar of graphics](https://dl.acm.org/doi/book/10.5555/1088896) is a
    theory developed by Lee Wilkinson for creating data visualizations. The basic
    idea is to use common building blocks for making plots. For instance, a bar plot
    and a dot plot are nearly identical, except that a bar plot draws rectangles and
    a dot plot draws points. This idea is captured in the grammar of graphics, which
    would say that a bar plot and a dot plot differ only in their “geometry” component.
    The grammar of graphics is an elegant system that we can use to describe nearly
    every kind of plot we wish to make.
  prefs: []
  type: TYPE_NORMAL
- en: This system is implemented in the popular plotting libraries [`ggplot2`](https://ggplot2.tidyverse.org)
    for the R programming language and [`Vega`](https://vega.github.io/vega) for JavaScript.
    [`Vega-Altair`](https://altair-viz.github.io), a Python package, provides a way
    to create `Vega` plots using Python, and we encourage interested readers to look
    over its documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Using a grammar of graphics tool like `Vega-Altair` enables flexibility in visualizations.
    And like `plotly`, `altair` also creates interactive visualizations. However,
    the Python API for these tools can be less straightforward than `plotly`’s API.
    In this book, we don’t typically need plots outside of what `plotly` is capable
    of creating, so we have opted for `plotly`’s simpler API.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more plotting tools for Python that we’ve left out for brevity.
    But for the purposes of this book, relying on `plotly` provides a useful balance
    of interactivity and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we analyze a dataset, we use visualizations to uncover patterns in the
    data that are difficult to detect otherwise. Data visualization is an iterative
    process. We create a plot, then decide whether to make adjustments or choose an
    entirely new type of plot. This chapter covered principles that we use to make
    these decisions.
  prefs: []
  type: TYPE_NORMAL
- en: We started by covering principles of scale, and saw how adjusting the scale
    by changing or transforming plot axes can reveal hidden structure in the data.
    We then discussed smoothing and aggregating techniques that help us work with
    large datasets that would otherwise result in overplotting. To facilitate meaningful
    comparisons, we applied principles of perception, like aligning baselines to make
    lines, bars, and points easier to compare. We showed how to take the data design
    into account to improve visualizations. And we saw how adding context to a plot
    helps a reader understand our message.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you should be able to create a plot and understand what
    kinds of adjustments would make the plot more effective. As you learn how to make
    informative visualizations, be patient and iterate. None of us make the perfect
    plot on the first try, and as we make discoveries in an analysis, we continue
    to refine our plots. Then, when it comes time to present our findings to others,
    we sift through our work to get the few plots that best convince our future reader
    of the correctness and importance of our analysis. This can even lead to the creation
    of a new plot that better conveys our findings, which we iteratively develop.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we walk through an extended case study that combines everything
    we’ve learned in the book so far. We hope that you find yourself surprised by
    how much you can already do.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch11.html#id1365-marker)) US government surveys still collect data based
    on a binary definition of gender, but progress is being made. For example, starting
    in 2022, US citizens are allowed to select an “X” as their gender marker on their
    passport application.
  prefs: []
  type: TYPE_NORMAL
