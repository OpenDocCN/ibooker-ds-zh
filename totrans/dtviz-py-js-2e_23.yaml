- en: Chapter 17\. Introducing D3—​The Story of a Bar Chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 16](ch16.xhtml#chapter_building_viz), we imagined our Nobel Prize
    visualization by breaking it into component elements. In this chapter, I will
    gently introduce you to D3 by showing you how to build the bar chart we need ([Figure 17-1](#target_barchart)).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1701](assets/dpj2_1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. This chapter’s target bar chart
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: D3 is much more than a charting library. It’s a library you use to build charting
    libraries, among other things. So why am I introducing you to D3 by way of that
    ultra-conventional visualization, the bar chart? First, because there should be
    a little thrill in crafting one from scratch for the first time, having total
    control over the look and feel of the chart and being unconstrained by whatever
    prejudices a particular charting library has. And second, because it just happens
    to be a great way to cover the fundamental elements of D3, particularly data joining
    and the enter-exit-remove update pattern, now nicely encapsulated by D3’s newish
    `join` method. If you get those fundamentals in place, you’re well on your way
    to employing the full power and expressivity D3 offers, and producing something
    more novel than a bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using some of the webdev covered in [Chapter 4](ch04.xhtml#chapter_webdev101),
    particularly the SVG graphics that are D3’s specialty (see [“Scalable Vector Graphics”](ch04.xhtml#sect_svg)).
    You can try out the code snippets using an online editor like [CodePen’s](https://codepen.io)
    or [VizHub’s](https://vizhub.com) (which also has a huge number of curated dataviz
    examples).
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin building the bar chart, let’s consider its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Framing the Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A bar chart has three key components: the axes, legends, and labels, and, of
    course, the bars. As we’re producing a modern, interactive bar chart component,
    we’ll need the axes and bars to transform in response to user interaction—​namely,
    filtering the set of prize winners via the top selectors (see [Figure 15-1](ch15.xhtml#imagine_ui)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll build the chart one step at a time, ending with D3 transitions, which
    can make your D3 creations more engaging and attractive. But first we’ll cover
    the basics of D3:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting DOM elements in your web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting and setting their attributes, properties, and styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appending and inserting DOM elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these basics firmly in place, we’ll move on to the joys of data binding,
    where D3 begins to flex its muscles.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Selections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selections are the backbone of D3\. Using jQuery-like CSS selectors, D3 can
    select and manipulate individual and grouped DOM elements. All D3 chained operations
    begin by selecting a DOM element or set of elements using the `select` and `selectAll`
    methods. `select` returns the first matching element; `selectAll` returns the
    set of matching elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-2](#d3bar_selections) shows examples of D3 selections, using the
    `select` and `selectAll` methods. These selections are used to change the `height`
    attribute of one or more bars. The `select` method returns the first `rect` (ID
    `barL`) with class `bar`, whereas `selectAll` can return any combination of the
    `rect`s depending on the query provided.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1702](assets/dpj2_1702.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-2\. Selecting elements and changing attributes: three rectangles
    are built with the initial HTML. Selections are then made and the height attributes
    of one or more bars are adjusted.'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to setting attributes (the named strings on the DOM elements; e.g.,
    `id` or `class`), D3 allows you to set elements’ CSS styles, properties (e.g.,
    whether a checkbox is checked), text, and HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-3](#d3bar_selects) shows all the ways in which a DOM element can
    be changed with D3\. With these few methods, you can achieve pretty much any look
    and feel you want.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1703](assets/dpj2_1703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-3\. Changing a DOM element with D3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 17-4](#d3bar_setting_bar) shows how we can apply CSS styling by adding
    a class to the element or directly setting a style. We first select the middle
    bar using its ID `barM`. The `classed` method is then used to apply a yellow highlight
    (see the CSS) and the `height` attribute set to 50 px. The `style` method is then
    used to apply a red fill to the bar directly.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1704](assets/dpj2_1704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-4\. Setting attributes and style
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'D3’s `text` method sets the text content of applicable DOM tags, such as `div`,
    `p`, `h*` headers, and SVG text elements. To see the `text` method in action,
    let’s create a little title placeholder with some HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 17-5](#d3bar_text) (before) shows the resulting browser page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create a `fancy-title` CSS class with a large, bold font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use D3 to select the title header, add the `fancy-title` class to
    it, and then set its text to My Bar Chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 17-5](#d3bar_text) (after) shows the resulting enlarged and emboldened
    title.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1705](assets/dpj2_1705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-5\. Setting text and style with D3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to setting the properties of DOM elements, we can use selections
    to get those properties. Leaving out the second argument to one of the methods
    listed in [Figure 17-3](#d3bar_selects) allows you to get information about the
    web page’s setup.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-6](#d3bar_getter_bar) shows how to get the key properties from an
    SVG rectangle. As we’ll see, getting attributes like `width` and `height` from
    an SVG element can be very useful for programmatic adaptation and adjustment.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1706](assets/dpj2_1706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-6\. Getting a `rect` bar’s details
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 17-7](#d3bar_getter_text) demonstrates the `html` and `text` getter
    methods. After creating a little list (ID `silly-list`), we use D3 to select it
    and get various properties. The `html` method returns the HTML of the list’s child
    `<li>` tags, while the `text` method returns the text contained in the list, with
    the HTML tags stripped. Note that for parent tags, the formatting of any text
    returned is a little messy, but maybe good enough for a string search or two.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1707](assets/dpj2_1707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-7\. Getting HTML and text from a `list` tag
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So far we’ve been manipulating the attributes, styles, and properties of existing
    DOM elements. This is a useful skill, but D3 comes into its own when we start
    creating DOM elements programmatically using its `append` and `insert` methods.
    Let’s look at these now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding DOM Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen how to select and manipulate the attributes, styles, and properties
    of DOM elements. Now we’ll see how D3 allows us to append and insert elements,
    programmatically adapting the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a little HTML skeleton containing a `nobel-bar` placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The *script.js* file is where we’ll add our bar chart’s JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set the size of the `nobel-bar` element with a little CSS, placed in
    *style.css*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Usually the first thing one does when creating a chart with D3 is to provide
    an SVG frame for it. This involves appending an `<svg>` canvas element to a `div`
    chartholder and then appending a `<g>` group to the `<svg>` to hold specific chart
    elements (in our case, the chart bars). This group has margins to accommodate
    axes, axes labels, and titles.
  prefs: []
  type: TYPE_NORMAL
- en: Conventionally, you will specify the margin of your chart in a `margin` object
    and then use that and the CSS-specified width and height of the chart container
    to derive the width and height of your chart group. The required JavaScript looks
    like [Example 17-1](#d3bar_dimensions_code).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-1\. Getting our bar chart’s dimensions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the bounding rectangle for our Nobel bar chart’s panel, using it to set
    the width and height of its bar container group.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the width and height of our bar group in hand, we use D3 to build our
    chart’s frame, appending the required `<svg>` and `<g>` tags and specifying the
    size of the SVG canvas and translation of the bar group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the HTML of the `nobel-bar` content block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The resulting SVG framework is shown in [Figure 17-8](#d3bar_frame). The `<svg>`
    element’s width and height are the sum of its child group and the surrounding
    margins. The child group is offset using `transform` to translate it `margin.left`
    pixels to the right and `margin.top` pixels down (by SVG convention, in the positive
    y direction).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1708](assets/dpj2_1708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-8\. Building our bar chart’s frame
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'With our frame in place, let’s use `append` to add a few bars. We’ll use a
    little dummy data: an array of objects with the top slice of Nobel Prize–winning
    countries by prize number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To build a crude bar chart,^([1](ch17.xhtml#idm45607747286016)) we can iterate
    through the `nobelData` array, appending a bar to the chart group as we go. [Example 17-2](#d3bar_10bars_crude_code)
    demonstrates this. After building a basic frame for our chart, we iterate through
    the `nobelData` array, using the `value` fields to set the bar’s height and y-position.
    [Figure 17-9](#d3bar_10bars) shows how the object values are used to append bars
    to our chart group. Note that because SVG uses a downward y-axis, you have to
    displace the bars by the height of the bar chart minus that of the bar in order
    to put the bar chart the right way up. As we’ll see later, by using D3’s scales,
    we can limit such geometric bookkeeping.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-2\. Building a crude bar chart with `append`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterates through each of the objects in `nobelData`, the `forEach` method providing
    object and array index to an anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1709](assets/dpj2_1709.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-9\. Programming a basic bar chart with D3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The other way in which D3 can add elements to the DOM tree is with its `insert`
    method. `insert` works like `append` but adds a second selector argument to allow
    you to place elements before a particular position in an sequence of tags, such
    as at the beginning of an ordered list. [Figure 17-10](#d3bar_insert) demonstrates
    the use of `insert`: list items in the `silly-list` are selected just like `append`
    and then a second argument (e.g., `'':first-child''`) specifies the element to
    insert before.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1710](assets/dpj2_1710.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-10\. Using D3’s `insert` method to add list items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For SVG elements, positioned directly within their parent group using x and
    y coordinates, `insert` might seem redundant. But, as discussed in [“Layering
    and Transparency”](ch04.xhtml#sect_svg_layering), DOM ordering is important in
    SVG as elements are layered, meaning that the last element in the DOM tree overlays
    any previous. We’ll see an example of this in [Chapter 19](ch19.xhtml#chapter_d3_maps)
    where we have a grid overlay (or `graticule`) for our world map. We want this
    grid to be drawn above all other map elements so use `insert` to place those elements
    before it.
  prefs: []
  type: TYPE_NORMAL
- en: Our crude bar chart in [Figure 17-9](#d3bar_10bars) is crying out for a little
    refinement. Let’s see how we can improve things, first with D3’s powerful `scale`
    objects and then with D3’s biggest idea, data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Example 17-2](#d3bar_10bars_crude_code), we built a basic, no-frills bar
    chart with D3\. This chart had a number of problems. First, looping through the
    data array is a bit clunky. What if we wanted to adapt the dataset for our chart?
    We’d need some way of adding or removing bars in response and then updating the
    resulting bars with the new data and redrawing everything. We’d also need to keep
    scaling the bar dimensions in x and y to reflect the different number of bars
    and a different maximum bar value. That’s quite a lot of bookkeeping already,
    and things could get messy fast. Also, where do we keep the changing datasets?
    Every data-driven change to our chart would require passing the dataset around
    and then constructing a loop to iterate over elements. It feels as if the data
    exists outside the chained D3 workflow when it really needs to be integral to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to elegantly integrating our dataset with D3 lies in the concept
    of data binding, D3’s biggest idea. The scaling problems are sorted by one of
    D3’s most useful utility libraries: scale. We’ll take a look at these now and
    then unleash the power of D3 with some data binding.'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring Up with D3’s Scales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fundamental idea behind D3’s scales is a mapping from an input domain to
    an output range. This simple procedure can remove a lot of the persnickety aspects
    of building charts, visualizations, and the like. As you get more comfortable
    with scales, you’ll find more and more situations where you can apply them. Mastering
    them is a key component to relaxed, effortless D3.
  prefs: []
  type: TYPE_NORMAL
- en: 'D3 provides a lot of scales, dividing them into three main categories: quantitative,
    ordinal, and time^([2](ch17.xhtml#idm45607747116736)) scales. There are exotic
    mappings to suit most conceivable situations, but you’ll probably find yourself
    using the linear and ordinal scales much of the time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In use, D3 scales can appear slightly strange because they are part object,
    part function. What this means is that after creating your scale, you can call
    various methods on it to set its properties (e.g., `domain` to set its domain),
    but you can also call it as a function with a domain argument to return a range
    value. The following example should make the distinction clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the scale’s `domain` and `range` methods to map from 0 → 1 to 0 → 100.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We call the scale like a function with a domain argument of `0.5`, returning
    a range value of `50`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the two main D3 scales, the quantitative and the ordinal, showing
    how we use them to build our bar chart as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Quantitative Scales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A D3 quantitative scale you’ll usually employ when building line charts, bar
    charts, scatter plots, and the like is `linear`, mapping a continuous domain to
    a continuous range. For example, we want our bar heights to be a linear function
    of the `nobelData` values. The range of values to be mapped to is between the
    maximum and minimum height of the bars in pixels (400 pixels to 0 pixels) and
    the domain to be mapped from is between the smallest conceivable value (0) and,
    in our case, the largest value in the array (336 US winners). In the following
    code, we first use D3’s `max` method to get the largest value in our `nobelData`
    array, using that to specify the end of our domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If there’s a chance, as is common with JSON encoded data, that the value is
    a string, prefixing *+* coerces it to a number.
  prefs: []
  type: TYPE_NORMAL
- en: One little trick to note is that our range decreases from its maximum. This
    is because we want to use it to specify a positive displacement along the SVG
    downward y-axis in order to make the bar chart’s y-axis point upward (i.e., the
    smaller the bar height, the larger the y displacement required). Conversely, you
    can see that the largest bar (the US winners tally) isn’t displaced at all (see
    [Figure 17-11](#d3bar_scales_y)).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1711](assets/dpj2_1711.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-11\. Using D3’s linear scale to fix the domain and range of our bar
    chart’s y-axis
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We’re using the simplest possible linear scale for our bar chart’s y-axis,
    mapping from one numeric range to another, but D3’s linear scales can do a lot
    more. The key to understanding this is D3’s `interpolate` method.^([3](ch17.xhtml#idm45607747099392))
    This takes two values and returns an `interpolator` between them. So, for the
    range of our `yScale` in [Figure 17-11](#d3bar_scales_y), `interpolate` returns
    a numeric `interpolator` for the values `400` and `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Interpolators have a default domain of [0,1].
  prefs: []
  type: TYPE_NORMAL
- en: The `interpolate` method can deal with more than just numbers. Strings, color
    codes, and even objects are handled sensibly. You can also specify more than two
    numbers for your domain array—just make sure that domain and range arrays are
    the same size.^([4](ch17.xhtml#idm45607746591792)) We can combine these two facts
    to create a useful colormap:^([5](ch17.xhtml#idm45607746591168))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'D3’s linear scales have a lot of useful utility methods and rich functionality.
    The numeric maps will probably be your workhorse scale, but I recommend reading
    the [D3 docs](https://oreil.ly/lZy94) to fully appreciate how flexible the linear
    scales are. On that web page, you’ll find D3’s other quantitative scales, to suit
    almost every quantitative occasion:'
  prefs: []
  type: TYPE_NORMAL
- en: Power scales, similar to linear but with exponential transform (e.g., `sqrt`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log scales, similar to linear but with logarithmic transform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantize scales, a variant of linear with a discrete range; that is, although
    the input is continuous, the output is divided into segments or buckets (e.g.,
    [1, 2, 3, 4, 5]).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantile scales, often used for color palettes, are similar to quantize scales
    but have discrete or bucketed domains as well as ranges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity scales, linear with the same domain and range (fairly esoteric).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantitative scales are great for manipulating continuously valued quantities,
    but often we want to get values based on a discrete domain (e.g., names or categories).
    D3 has a specialized set of ordinal scales to meet this need.
  prefs: []
  type: TYPE_NORMAL
- en: Ordinal Scales
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ordinal scales take an array of values as their domain and map these to discrete
    or continuous ranges, producing a single mapped value for each. To explicitly
    create a one-to-one mapping, we use the scale’s `range` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of our bar chart, we want to map an array of indices to a continuous
    range, to provide our bars’ x-coordinates. For this, we can use the band scale
    `scaleBand` `range` or the `rangeRound` methods, the latter snapping output values
    to individual pixels. Here, we use `rangeRound` to map an array of numbers to
    a continuous range, rounding to integer pixel values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In building our original crude bar chart ([Example 17-2](#d3bar_10bars_crude_code)),
    we used a `barWidth` variable to size the bars. Implementing padding between the
    bars would have required a padding variable and necessary adjustments to `barWidth`
    and the bar positions. With our new ordinal band scale, we get these things for
    free, removing the fiddly bookkeeping. Calling the `xScale`’s `bandwidth` method
    provides the calculated bar widths. We can also use the scale’s `padding` method
    to specify the padding between the bars as a fraction of the space occupied by
    each bar. The `bandwidth` value is adjusted accordingly. Here are some examples
    of this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Stores the scale with a fixed domain; useful if we anticipate the range changing.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`rangeRound` snaps (rounds) the output values to integers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We specify a padding (`p`) factor of `0.1` * allocated bar(`B`)-space.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-12](#d3bar_scales_x) shows our bar chart’s band x-scale with a padding
    factor of `0.1`. The continuous range is 600 (pixels), which is the width of the
    bar chart, and the domain is an array of integers representing the individual
    bars. As shown, providing `xScale` with a bar’s index number returns its position
    on the x-axis.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1712](assets/dpj2_1712.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-12\. Setting the domain and range of our bar chart’s x-scale, using
    a padding factor of 0.1
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Armed with our D3 scales, let’s turn to D3’s central concept, binding data to
    the DOM in order to drive changes to it.
  prefs: []
  type: TYPE_NORMAL
- en: Unleashing the Power of D3 with Data Binding/Joining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: D3 stands for *Data-Driven Documents*, and up to now we haven’t really been
    driving with our data. In order to unleash D3, we need to embrace its big idea,
    which is binding or joining (both terms are used online) the data in our dataset
    to its respective DOM elements and updating the web page (document) based on this
    integration. This small step of joining data to the DOM enables a huge amount
    of functionality when combined with the most powerful D3 methods, `enter` and
    `exit`.
  prefs: []
  type: TYPE_NORMAL
- en: After a number of iterations, D3 (version 5 and above) now provides the `join`
    method, which considerably simplifies the use of `enter` and `exit`. The `join`
    method will be the focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In order to interpret the thousands of examples online that use the older `enter`,
    `exit`, `remove` update patterns, it helps to know a little more about what’s
    going on under the hood when D3 joins data. See [Appendix A](app01.xhtml#appendix)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the DOM with Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I think it’s fair to say that using D3 to update the DOM with new data has
    not been particularly easy to grasp historically (footnote: You really appreciate
    this when you try to teach it or write a book chapter on it). There have been
    a number of implementations such as the [general update pattern](https://oreil.ly/sYrAG)
    that have themselves gone through a number of incompatible forms. This means a
    lot of popular examples on the web, using older version of D3, will steer you
    down the wrong path.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although you may anticipate building one-off charts, with a single data-binding
    process, it’s good to get into the habit of asking yourself, “What if I need to
    change the data dynamically?” If the answer is not immediately obvious, you have
    probably implemented a bad D3 design. Catching yourself in the act means you can
    do a little code audit and make the necessary changes before things start to deteriorate.
    It’s good to kick yourself out of this habit, but also, because D3 is somewhat
    of a craft skill, constantly reaffirming that best practice will pay off when
    you need it.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that recent versions of D3 have solidified the basic methods
    and made them a lot simpler as well. So employing `enter`, `exit`, and `remove`,
    the three key D3 methods used in data-joining, can now be done with a single `join`
    method, which has sensible defaults. In this section, we’ll see how to use these
    four methods to update our bar chart in response to new data, in this case Nobel
    Prize–winning countries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the most fundamental concept behind D3 is that of the data-join. In
    essence, a dataset (usually an array of data objects) is used to create some visual
    elements, e.g., the rectangular bars of a bar chart. Any change to this data is
    reflected in a changing visualization, e.g., the number of bars in the bar chart
    or the heights or placement of existing bars. We can break this operation into
    three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a visual element for any data without one using `enter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the attributes and styles of these and, if required, any existing elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove any old visual elements that no longer have any data joined to them using
    the `exit` and `remove` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whereas in the past D3 required you to implement the update pattern yourself,
    using `enter`, `exit`, and (briefly) a `merge` method, the new [`join`](https://oreil.ly/4mg8b)
    method combines these methods in one user-friendly package. Often you can just
    call it with a single argument, specifying the visual element to be joined to
    the data (e.g., an SVG rect or circle), but it also has more fine-grained control,
    allowing you to pass in `enter`, `exit`, and `update` callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how easy it now is to join data and visual elements by joining some
    horizontal bars, constructed of SVG rectangles, to our dummy Nobel dataset. We’ll
    join the following dataset to the group of rectangles and use it to create some
    horizontal bars. You can find a working code example in [CodePen](https://oreil.ly/YOnzx).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use a little HTML and CSS to create an SVG group to put the bars in and
    a bar class with blue fill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With data and HTML scaffold to hand, let’s see D3’s `join` in action. We’ll
    create an `updateBars` function that will accept a data array of key-value countries
    and join it to some SVG rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: The `updateBars` function accepts a data array and first adds it to a selection
    of class `'bar'` using the `data` method. As seen in [Example 17-3](#d3_update_bars),
    it then joins this `bars` selection to some SVG rectangles, using the `join` method.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-3\. Joining our country data to some SVG bars
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This joins all existing bars data to SVG `rect` elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`join` returns all existing `rect`s, which we then update using their joined
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After calling the `join` method, D3 is doing the sensible thing, using `enter`,
    `exit`, and `remove` to keep the data and visual elements in sync. Let’s demonstrate
    this by calling the `updateBars` function a few times with changing data. First,
    we’ll slice the first four members of our Nobel dataset and use those to update
    the bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That produces the bars shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 17in01](assets/dpj2_17in01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let’s update the data-join, using only the first two members of the Nobel
    data array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 17in02](assets/dpj2_17in02.png)'
  prefs: []
  type: TYPE_IMG
- en: Calling this method produces the two bars shown in the preceding image. Behind
    the scenes, D3’s bookkeeping has removed the redundant rectangles which, with
    a smaller dataset, are no longer joined to any data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s go the other way and see what happens if we use a bigger dataset,
    this time the first six members of the Nobel array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 17in03](assets/dpj2_17in03.png)'
  prefs: []
  type: TYPE_IMG
- en: Once again, D3 does the expected thing (see preceding image), this time appending
    new rectangles to join to the new data objects.
  prefs: []
  type: TYPE_NORMAL
- en: Having demonstrated that D3’s join successfully keeps data and visual elements
    in sync, adding and removing rectangles as required, we have the basis for our
    Nobel bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the Bar Chart Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let’s put together what we’ve currently learned in this chapter and build
    the main elements of our bar chart. We’ll be putting D3’s scales to good use here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll select the container for our bar chart by ID *#nobel-bar* and
    use its dimensions (from `boundingClientRectangle`) and some margin settings to
    get the width and height of the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll set our scales using the width and height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll create our SVG chart group using width, height, and margins and store
    it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With our HTML and SVG scaffold in place, let’s adapt the `updateBars` function
    (see [Example 17-3](#d3_update_bars)) to respond to changes in our real Nobel
    data. The update function will receive a data array of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: On being called with new data, the `updateBarchart` function first filters out
    any zero prize-winning countries and then updates the x and y scale domains to
    reflect the number of bars/countries and the maximum prizes won, as seen in [Example 17-4](#update_bar_chart).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-4\. Updating the bar chart
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With updated scales we can use a data-join to create the bars necessary for
    the data provided. This is essentially the same as the function shown in [Example 17-3](#d3_update_bars)
    but using scales to size the bars and with a customized `entry` method, to add
    a class and left-padding to newly minted bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We customize the `enter` method to add a `` bar` `` class to the rectangle.
    Note that we need to return the `enter` object to use after the `join` call.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a bar chart that responds to changes in the data, initiated in this
    case by the user. Filtering the data for all Chemistry prizes shows the result
    in [Figure 17-13](#d3_final_chart). Although lacking a few crucial elements, the
    hard work has been done building a bar chart. Now let’s add axes and some cool
    transitional effects to make the finishing touches.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1713](assets/dpj2_1713.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-13\. Final bar chart
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Axes and Labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a working update pattern, we will add the axes and axes labels
    that any self-respecting bar chart needs.
  prefs: []
  type: TYPE_NORMAL
- en: D3 doesn’t offer a lot in the way of high-level chart elements, encouraging
    you to roll your own. But it does provide a convenient `axis` object, which takes
    the sting out of having to craft the SVG elements yourself. It’s easy to use and,
    as you would expect, plays nicely with our data update patterns, allowing for
    axes ticks and labels that change in response to the data presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to define our x and y axes, we need to know what ranges and domains
    we want our axes to represent. In our case, it’s the same one as the ranges and
    domains of our x and y scales, so we supply these to the axes’ `scale` method.
    D3 axes also allow you to specify their orientation, which will fix the relative
    position of ticks and tick labels. With our bar chart, we want the x-axis on the
    bottom and the y-axis on the left. Our ordinal x-axis will have a label for each
    bar, but with our y-axis, the choice of tick numbers is arbitrary. Ten seems like
    a reasonable number, so we set that using the `ticks` method. The following code
    shows how we declare our bar chart’s axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We want the format of our tick labels to change with our chosen metric, per
    capita or absolute. Per capita produces a very small number that is best represented
    in exponential form (e.g., 0.000005 → 5e-6). The `tickFormat` method allows you
    to take the data value at each tick and return the desired tick string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also need a little bit of CSS to style the axes correctly, removing the
    default `fill`, setting the stroke color to black, and making the shape render
    crisply. We’ll also specify the font size and family while we’re at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `axis` generators, we need a couple of SVG groups to hold
    the axes they produce. Let’s add these to our main `svg` selector as groups with
    sensible class names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: By SVG’s convention, y is measured from the top down, so we want our *bottom*-oriented
    x-axis translated from the chart’s top by *height* pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our bar chart’s axes have fixed ranges (the width and height of the chart),
    but their domains will change as the user filters the dataset. For example, the
    number of (country) bars will be reduced if the user filters the data by Economics
    category: this will change the domain of the ordinal x-scale (number of bars)
    and the quantitative y-scale (maximum number of winners). We want the displayed
    axes to change with these changing domains, with a nice transition for good measure.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 17-5](#d3bar_axes_code) shows how the axes are updated. First, we
    update our scale domains using the new data (A). These new scale domains are reflected
    when the axes generators (which are linked to them) are called on their respective
    axis groups.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-5\. Updating our bar chart’s axes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the D3 `axis` on our x-axis group element builds all the necessary axis
    SVG in it, including ticks and tick labels. D3 `axis` uses an internal update
    pattern to enable transitions to newly bound data.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: After creating the x-axis, we perform some SVG manipulations of the text labels
    generated. First, we select the `text` elements of the axis, the tick labels.
    We then place their text anchors at the end of the element and shift their position
    a bit. This is because the text is rotated about its anchor and we want to rotate
    about the end of the country labels, now positioned under the tick lines. The
    result of our manipulations is shown in [Figure 17-16](#d3bar_x_axis). Note that
    without rotating our labels, they would merge into one another.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1716](assets/dpj2_1716.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-16\. Reoriented tick labels on the x-axis
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now that we have our working axes, let’s add a little label to the x-axis and
    then see how the bar chart copes with our real data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A left padding constant, in pixels, to make way for the y-axis label.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Rotates the text anticlockwise to the upright position.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`dy` is a relative coordinate [relative to the *y* coordinate just specified
    (6)]. By using the `em` unit (relative to font size), we can make handy adjustments
    to the text margin and baseline.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-17](#d3bar_update_lit) shows the result of filtering our Nobel Prize
    winners dataset for Chemistry winners, using our category selector filter. The
    bar widths increase to reflect the reduced number of countries, and both axes
    adapt to the new dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1717](assets/dpj2_1717.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-17\. The Nobel Prize bar chart before and after we apply the category
    filter for Chemistry winners
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We now have a working bar chart, using the update pattern to adjust itself as
    the user-driven dataset changes. But although it’s functional, the transition
    in response to data change is visually stark, even jarring. One way to make the
    change much more engaging and even informative would be to have the chart update
    continuously over a short time period, with preserved country bars moving from
    their old to new position while simultaneously adapting their height and width.
    Such continuous transitions really add life to a visualization and are seen in
    many of the most impressive D3 pieces. The good news is that transitions are tightly
    integrated into D3’s workflow, which means you can achieve these cool visual effects
    for the cost of a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it stands, our bar chart is perfectly functional. It responds to data changes
    by adding or removing bar elements and then updating them using the new data.
    But the immediate change from one reflection of the data to another feels a little
    stark and visually jarring.
  prefs: []
  type: TYPE_NORMAL
- en: D3’s transitions provide the ability to smooth the visual update of our elements,
    making them change continuously over a set time period. This can be both aesthetically
    appealing and, on occasion, informative.^([7](ch17.xhtml#idm45607744290752)) The
    important thing is that D3 transitions can be very engaging for the user, which
    is reason enough to want to master them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-18](#d3bar_transitions) shows the effect we are aiming at. When
    the bar chart is updated with a newly selected dataset, we want the bars of any
    countries present before and after the transition to morph smoothly from their
    old to new positions and dimensions.^([8](ch17.xhtml#idm45607744288976)) So in
    [Figure 17-18](#d3bar_transitions) the bar for France grows from start to finish
    over the course of the transition—​say, a couple of seconds—​with intermediate
    bars of increasing width and height. The axes ticks and labels will adapt too
    as the x and y scales change.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1718](assets/dpj2_1718.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-18\. Smooth bar transitions on update
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The effect shown in [Figure 17-18](#d3bar_transitions) is surprisingly easy
    to achieve but involves understanding the precise way data is joined in D3\. By
    default, when new data is bound to existing DOM elements, it is done by array
    index. [Figure 17-19](#d3bar_data_index) shows how this works, using our selected
    bars as an example. The first bar (B0), previously bound to the USA’s data, is
    now bound to France’s. It stays in first position and updates its size and tick
    label. Essentially, the USA’s bar becomes France’s.^([9](ch17.xhtml#idm45607744282224))
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1719](assets/dpj2_1719.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-19\. By default, new data is joined by index
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In order to get continuity during our transitions (i.e., for the USA bar to
    move to its new position while changing to its new height and width), we need
    the new data to be bound by a unique key, not the index. D3 allows you to specify
    a function as a second argument to the `data` method, which returns a key from
    the object data to use to bind the new data to the correct respective bars, assuming
    they still exist. [Figure 17-20](#d3bar_data_key) shows how this is done. Now,
    the first bar (0) is bound to the new USA data, changing its position by index
    as well as its width and height to that of the new American bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1720](assets/dpj2_1720.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-20\. Using an object key to join new data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Joining the data by key gives us the correct start and endpoints for our national
    bars. Now all we need is a way to create a smooth transition between them. We
    can do this by using a couple of D3’s coolest methods, `transition` and `duration`.
    By calling these before we change our bar dimension and position attributes, D3
    magically performs a smooth transition between them, as shown in [Figure 17-18](#d3bar_transitions).
    Adding transitions to our bar chart update requires only a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A transition with duration of two seconds, which is our `TRANS_DURATION` constant
    of 2000 (ms).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the data object’s `code` property to make the continuous data-joins.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `x`, `y`, `width`, and `height` attributes will be smoothly morphed from
    current values to those defined here.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions will work on most obvious attributes and styles of an existing DOM
    element.^([10](ch17.xhtml#idm45607744053184))
  prefs: []
  type: TYPE_NORMAL
- en: The transitions just shown perform a smooth change of the attributes from starting
    point to end goal, but D3 allows for a lot of tuning for these effects. You can,
    for example, use the `delay` method to specify the time before the transition
    starts. This delay can also be a function of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most useful extra transitioning method is `ease`, which allows
    you to specify the way in which the elements’ attributes are updated over the
    transition’s duration. The default easing function is [`CubicInOut`](https://oreil.ly/zP5FO),
    but you can also specify things like `quad`, which speeds things up as the transition
    progresses, or `bounce` and `elastic`, which do pretty much what it says on the
    tin, giving a bouncy feel to the change. There’s also `sin`, which speeds up at
    the beginning and slows down toward the end. See [*easings.net*](https://easings.net)
    for a nice description of different easing functions and [observablehq](https://oreil.ly/crI0I)
    for a comprehensive runthrough of D3’s easing functions, assisted by interactive
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: If the easing functions available to D3 don’t suit your needs or you’re feeling
    particularly ambitious, as with most things D3 you can roll your own to fit any
    subtle requirements. The `tween` method provides the fine-grained control you
    might need.
  prefs: []
  type: TYPE_NORMAL
- en: With a working `join`-based update pattern and some cool transitions, we have
    completed our Nobel-viz bar chart. There’s always room for refinement, but this
    bar chart will more than do the job. Let’s summarize what we’ve learned in this
    rather large chapter before moving on to the other components of our Nobel Prize
    visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Bar Chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the bar chart module is imported, it appends a callback function to the
    callbacks array in the core module. When data is updated in response to user interaction,
    this callback function is called and the bar chart updated with new country data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_introducing_d3__8212___8203_the_story_of_a_bar_chart_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This anonymous function is called in the core module when data is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a large and quite challenging chapter. D3 isn’t the easiest library
    to learn, but I have smoothed the learning curve by breaking things down into
    digestible chunks. Take your time absorbing the fundamental ideas and, crucially,
    start setting yourself little objectives to stretch your D3 knowledge. I think
    D3 is very much an art form and, more than most libraries, one learns while doing.
  prefs: []
  type: TYPE_NORMAL
- en: The key elements to understanding D3 and applying it effectively are the update
    pattern and the data binding involved. If you understand this at a fundamental
    level, most of D3’s other pyrotechnics slot nicely into place. Focus on the `data`,
    `enter`, `exit`, and `remove` methods and make sure you really understand what’s
    going on. It’s the only way to advance from much of the cut-and-paste style of
    D3 programming, which is initially productive (there being so many cool examples
    out there), but will eventually frustrate. Use your browser’s developer console
    (currently Chrome and Chromium have the best tools here) to inspect DOM elements,
    to see what data is bound to them via the `__data__` variable. If it doesn’t match
    your expectations, you’ll learn a lot by finding out why.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a pretty good grounding in D3’s core techniques. In the
    next chapter, we’ll aim to challenge those new skills with a rather more ambitious
    chart, our Nobel Prize timeline.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch17.xhtml#idm45607747286016-marker)) We’ll be dealing with axes, labels,
    and the like later in the chapter when we put D3 into top gear and start binding
    data.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch17.xhtml#idm45607747116736-marker)) See [D3’s GitHub page](https://oreil.ly/xiKUs)
    for a comprehensive list.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch17.xhtml#idm45607747099392-marker)) See [the D3 docs](https://oreil.ly/2IXaF)
    for full details.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch17.xhtml#idm45607746591792-marker)) D3 will truncate whichever is bigger.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch17.xhtml#idm45607746591168-marker)) D3 has many built-in colormaps and
    sophisticated color handling with RGB, HCL, etc. We’ll see a few of these in action
    in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch17.xhtml#idm45607745078384-marker)) Axes follow a similar pattern to
    that proposed by Mike Bostock in [*Towards Reusable Charts*](https://oreil.ly/FOEoe),
    using the JavaScript objects’ [`call`](https://oreil.ly/4vVp3) method to build
    HTML on the selected DOM element(s).
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch17.xhtml#idm45607744290752-marker)) For example, when we change our
    measurement of Nobel Prize wins by country from absolute to per capita, the large
    amount of movement displayed as the country bars change their order emphasizes
    the difference between the two metrics.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch17.xhtml#idm45607744288976-marker)) In animation and computer graphics
    circles, this effect is known as *tweening* (see [this Wikipedia page](https://oreil.ly/vr9QY)).
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch17.xhtml#idm45607744282224-marker)) See Mike Bostock’s nice demonstration
    of object constancy at [his site](https://oreil.ly/QZuYK).
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch17.xhtml#idm45607744053184-marker)) Transitions only apply to existing
    elements—you can’t fade in the creation of a DOM element, for example. You could,
    however, fade it in and out using the `opacity` CSS style.
  prefs: []
  type: TYPE_NORMAL
