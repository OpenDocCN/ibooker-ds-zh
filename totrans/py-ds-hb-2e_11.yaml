- en: Chapter 9\. Comparisons, Masks, and Boolean Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the use of Boolean masks to examine and manipulate values
    within NumPy arrays. Masking comes up when you want to extract, modify, count,
    or otherwise manipulate values in an array based on some criterion: for example,
    you might wish to count all values greater than a certain value, or remove all
    outliers that are above some threshold. In NumPy, Boolean masking is often the
    most efficient way to accomplish these types of tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Counting Rainy Days'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you have a series of data that represents the amount of precipitation
    each day for a year in a given city. For example, here we’ll load the daily rainfall
    statistics for the city of Seattle in 2015, using Pandas (see [Part III](part03.xhtml#section-0300-introduction-to-pandas)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The array contains 365 values, giving daily rainfall in millimeters from January
    1 to December 31, 2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first quick visualization, let’s look at the histogram of rainy days in
    [Figure 9-1](#fig_0206-boolean-arrays-and-masks_files_in_output_6_0), which was
    generated using Matplotlib (we will explore this tool more fully in [Part IV](part04.xhtml#section-0400-introduction-to-matplotlib)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![output 6 0](assets/output_6_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Histogram of 2015 rainfall in Seattle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This histogram gives us a general idea of what the data looks like: despite
    the city’s rainy reputation, the vast majority of days in Seattle saw near zero
    measured rainfall in 2015\. But this doesn’t do a good job of conveying some information
    we’d like to see: for example, how many rainy days were there in the year? What
    was the average precipitation on those rainy days? How many days were there with
    more than 10 mm of rainfall?'
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to this would be to answer these questions by hand: we could loop
    through the data, incrementing a counter each time we see values in some desired
    range. But for reasons discussed throughout this chapter, such an approach is
    very inefficient from the standpoint of both time writing code and time computing
    the result. We saw in [Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs)
    that NumPy’s ufuncs can be used in place of loops to do fast element-wise arithmetic
    operations on arrays; in the same way, we can use other ufuncs to do element-wise
    *comparisons* over arrays, and we can then manipulate the results to answer the
    questions we have. We’ll leave the data aside for now, and discuss some general
    tools in NumPy to use *masking* to quickly answer these types of questions.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Operators as Ufuncs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs) introduced
    ufuncs, and focused in particular on arithmetic operators. We saw that using `+`,
    `-`, `*`, `/`, and other operators on arrays leads to element-wise operations.
    NumPy also implements comparison operators such as `<` (less than) and `>` (greater
    than) as element-wise ufuncs. The result of these comparison operators is always
    an array with a Boolean data type. All six of the standard comparison operations
    are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to do an element-wise comparison of two arrays, and to
    include compound expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the case of arithmetic operators, the comparison operators are implemented
    as ufuncs in NumPy; for example, when you write `x < 3`, internally NumPy uses
    `np.less(x, 3)`. A summary of the comparison operators and their equivalent ufuncs
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Equivalent ufunc | Operator | Equivalent ufunc |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `==` | `np.equal` | `!=` | `np.not_equal` |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | `np.less` | `<=` | `np.less_equal` |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | `np.greater` | `>=` | `np.greater_equal` |'
  prefs: []
  type: TYPE_TB
- en: 'Just as in the case of arithmetic ufuncs, these will work on arrays of any
    size and shape. Here is a two-dimensional example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In each case, the result is a Boolean array, and NumPy provides a number of
    straightforward patterns for working with these Boolean results.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Boolean Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given a Boolean array, there are a host of useful operations you can do. We’ll
    work with `x`, the two-dimensional array we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Counting Entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To count the number of `True` entries in a Boolean array, `np.count_nonzero`
    is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that there are eight array entries that are less than 6\. Another way
    to get at this information is to use `np.sum`; in this case, `False` is interpreted
    as `0`, and `True` is interpreted as `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit of `np.sum` is that, like with other NumPy aggregation functions,
    this summation can be done along rows or columns as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This counts the number of values less than 6 in each row of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we’re interested in quickly checking whether any or all the values are `True`,
    we can use (you guessed it) `np.any` or `np.all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`np.all` and `np.any` can be used along particular axes as well. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here all the elements in the third row are less than 8, while this is not the
    case for others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a quick warning: as mentioned in [Chapter 7](ch07.xhtml#section-0204-computation-on-arrays-aggregates),
    Python has built-in `sum`, `any`, and `all` functions. These have a different
    syntax than the NumPy versions, and in particular will fail or produce unintended
    results when used on multidimensional arrays. Be sure that you are using `np.sum`,
    `np.any`, and `np.all` for these examples!'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already seen how we might count, say, all days with less than 20 mm of
    rain, or all days with more than 10 mm of rain. But what if we want to know how
    many days there were with more than 10 mm and less than 20 mm of rain? We can
    accomplish this with Python’s *bitwise logic operators*, `&`, `|`, `^`, and `~`.
    Like with the standard arithmetic operators, NumPy overloads these as ufuncs that
    work element-wise on (usually Boolean) arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can address this sort of compound question as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that there were 16 days with rainfall of between 10 and 20 millimeters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parentheses here are important. Because of operator precedence rules, with
    the parentheses removed this expression would be evaluated as follows, which results
    in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s demonstrate a more complicated expression. Using De Morgan’s laws, we
    can compute the same result in a different manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Combining comparison operators and Boolean operators on arrays can lead to a
    wide range of efficient logical operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the bitwise Boolean operators and their equivalent
    ufuncs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Equivalent ufunc | Operator | Equivalent ufunc |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | `np.bitwise_and` |  | `np.bitwise_or` |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | `np.bitwise_xor` | `~` | `np.bitwise_not` |'
  prefs: []
  type: TYPE_TB
- en: 'Using these tools, we can start to answer many of the questions we might have
    about our weather data. Here are some examples of results we can compute when
    combining Boolean operations with aggregations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Boolean Arrays as Masks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section we looked at aggregates computed directly on Boolean
    arrays. A more powerful pattern is to use Boolean arrays as masks, to select particular
    subsets of the data themselves. Let’s return to our `x` array from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we want an array of all values in the array that are less than, say,
    5\. We can obtain a Boolean array for this condition easily, as we’ve already
    seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to *select* these values from the array, we can simply index on this Boolean
    array; this is known as a *masking* operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What is returned is a one-dimensional array filled with all the values that
    meet this condition; in other words, all the values in positions at which the
    mask array is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are then free to operate on these values as we wish. For example, we can
    compute some relevant statistics on our Seattle rain data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: By combining Boolean operations, masking operations, and aggregates, we can
    very quickly answer these sorts of questions about our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Keywords and/or Versus the Operators &/|
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common point of confusion is the difference between the keywords `and` and
    `or` on the one hand, and the operators `&` and `|` on the other. When would you
    use one versus the other?
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is this: `and` and `or` operate on the object as a whole, while
    `&` and `|` operate on the elements within the object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use `and` or `or`, it is equivalent to asking Python to treat the
    object as a single Boolean entity. In Python, all nonzero integers will evaluate
    as `True`. Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When you use `&` and `|` on integers, the expression operates on the bitwise
    representation of the element, applying the *and* or the *or* to the individual
    bits making up the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the corresponding bits of the binary representation are compared
    in order to yield the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have an array of Boolean values in NumPy, this can be thought of as
    a string of bits where `1 = True` and `0 = False`, and `&` and `|` will operate
    similarly to in the preceding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you use `or` on these arrays it will try to evaluate the truth or falsehood
    of the entire array object, which is not a well-defined value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when evaluating a Boolean expression on a given array, you should
    use `|` or `&` rather than `or` or `and`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to evaluate the truth or falsehood of the entire array will give the
    same `ValueError` we saw previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'So, remember this: `and` and `or` perform a single Boolean evaluation on an
    entire object, while `&` and `|` perform multiple Boolean evaluations on the content
    (the individual bits or bytes) of an object. For Boolean NumPy arrays, the latter
    is nearly always the desired operation.'
  prefs: []
  type: TYPE_NORMAL
