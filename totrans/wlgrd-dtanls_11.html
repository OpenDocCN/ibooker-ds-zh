<html><head></head><body>
<div id="sbo-rt-content"><div class="readable-text" id="p1">
<h1 class="readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">12</span></span> <span class="chapter-title-text">Iterating on someone else’s work: Data preparation</span></h1>
</div>
<div class="introduction-summary">
<h3 class="introduction-header sigil_not_in_toc">This chapter covers</h3>
<ul>
<li class="readable-text" id="p2">Continuing the work of another analyst</li>
<li class="readable-text" id="p3">Investigating and verifying an existing analysis</li>
<li class="readable-text" id="p4">Preparing event-level data to be suitable for user-level segmentation</li>
</ul>
</div>
<div class="readable-text" id="p5">
<p>Every analyst will need to continue someone else’s work at some point. This “someone” might be a past version of you from months ago. The process for working on the second version of a project is the same as starting from scratch.</p>
</div>
<div class="readable-text intended-text" id="p6">
<p>Because we will own this new version, we still need to understand the problem, look at the available data, and so on, even if someone else has already done it. In this project, you will get the opportunity to practice taking over from someone else. Another analyst has prepared the minimum viable answer to a stakeholder question, on which you will iterate.</p>
</div>
<div class="readable-text intended-text" id="p7">
<p>The specific topic of this chapter is one that is also common in the real world: segmentation. Most businesses have questions in the form of “How are some things similar to other things?” where the thing in question could be anything from a product to a customer to an entire geographic area.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p8">
<h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Real business case: Segmenting customers based on buying activity</h5>
</div>
<div class="readable-text" id="p9">
<p>The specific methods required to segment customers will come in handy for segmenting anything. For example, one project I worked on was identifying customers who bought similar used cars at auction. Having a notion of buyer similarity meant we could find more buyers to whom we could proactively recommend upcoming auctions. Being able to invite buyers to an auction because we know they buy similar stock led to more productive conversations and more eyes on our auctioned cars.</p>
</div>
</div>
<div class="readable-text" id="p10">
<p>The process for finding similar entities, what we refer to here as “segmentation,” is the same regardless of the type of entity. In this chapter specifically, you will practice segmenting mobile users into groups based on their app usage activity. You will work with event-level data and continue the work of another analyst who has already completed an iteration of the project.</p>
</div>
<div class="readable-text" id="p11">
<h2 class="readable-text-h2" id="sigil_toc_id_147"><span class="num-string">12.1</span> Finding similar entities</h2>
</div>
<div class="readable-text" id="p12">
<p>The problem of segmentation appears in many places. The typical use case is finding customers who are similar to each other based on characteristics such as demographics or behavior. A business may also want to apply segmentation to its product catalog to categorize and simplify its offering.</p>
</div>
<div class="readable-text intended-text" id="p13">
<p>In each case, the outcome is that different actions will be taken for different segments. Users in different financial segments will be targeted with different banking products. Products that are grouped into a segment may be recommended alongside each other to the end user. Recommendation engines make heavy use of the notion of user and product similarity.</p>
</div>
<div class="readable-text intended-text" id="p14">
<p>In machine learning, segmentation, or clustering, is an example of unsupervised learning. This means that, unlike supervised prediction problems, we don’t have examples of the “truth,” that is, actual customer segments against which to compare our results. Our ability to measure how good our segments are is, therefore, limited. The evaluation of these segments is usually done subjectively by human experts instead.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p15">
<h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Supervised vs. unsupervised learning</h5>
</div>
<div class="readable-text" id="p16">
<p>In machine learning, the difference between supervised and unsupervised learning is whether we have historical examples of correct predictions against which to compare our model’s predictions.</p>
</div>
<div class="readable-text" id="p17">
<p>If we are predicting the price of a house based on its properties, we need training data that includes both the properties of the houses and the prices they sold for. This is <em>supervised</em> learning because we can compare our model’s predictions to actual values, thus supervising our prediction model.</p>
</div>
<div class="readable-text" id="p18">
<p>In <em>unsupervised</em> learning, we do not have such past examples. There are no correct answers to compare against. Instead, we are trying to find patterns of some sort in</p>
</div>
<div class="readable-text" id="p19">
<p>our data, which we then evaluate more subjectively. Customer segmentation falls neatly into this latter category.</p>
</div>
</div>
<div class="readable-text" id="p20">
<p>In any similarity problem, there are certain factors to consider when deciding on our approach:</p>
</div>
<ul>
<li class="readable-text" id="p21"> What action will we take when we have our groups? This is the most important question to ask since it motivates the entire project. </li>
<li class="readable-text" id="p22"> What features are important when determining similarity? Do we care about users who live in the same area or who have similar purchasing patterns? </li>
<li class="readable-text" id="p23"> On a related note, do we have redundant features? If we’re segmenting cars, we don’t want to include their top speed in both kilometers and miles per hour. One variable to measure a particular concept is enough. </li>
<li class="readable-text" id="p24"> How many groups do we believe we will find? We may not have an exact number, but even a ballpark will help. </li>
<li class="readable-text" id="p25"> How will we evaluate the outcome of the segmentation? Usually, this is done with the help of domain experts. </li>
</ul>
<div class="readable-text" id="p26">
<p>In this project, in addition to these factors, we will also want a checklist of actions for how to continue the previous analyst’s work.</p>
</div>
<div class="readable-text" id="p27">
<h2 class="readable-text-h2" id="sigil_toc_id_148"><span class="num-string">12.2</span> Continuing someone else’s work</h2>
</div>
<div class="readable-text" id="p28">
<p>In a situation where we are continuing someone else’s work, the first step should be to replicate their findings whether or not the original source code is available. The reasons for this are</p>
</div>
<ul>
<li class="readable-text" id="p29"> Having our own version of the previous pipeline means we can more easily make changes to it. </li>
<li class="readable-text" id="p30"> Recreating someone else’s work checks for mistakes, not with the purpose of blaming anyone, but to verify that their steps did what they said they did. </li>
<li class="readable-text" id="p31"> We also want to verify the assumptions present in the previous analyst’s work. It’s possible they made incorrect assumptions or even just different assumptions to the ones we’d make. Being explicit about these assumptions gives everyone clarity. </li>
<li class="readable-text" id="p32"> Replicating the work puts us in a better position to understand the details of the project, the limitations, and what further steps are possible. Looking at someone else’s work briefly is not the same as getting into the weeds ourselves. </li>
</ul>
<div class="readable-text" id="p33">
<p>If we consider these factors before we start work, then, combined with our results-driven approach, we will be well equipped for the project to succeed.</p>
</div>
<div class="callout-container sidebar-container">
<div class="readable-text" id="p34">
<h5 class="callout-container-h5 readable-text-h5 sigil_not_in_toc">Collaborating with others</h5>
</div>
<div class="readable-text" id="p35">
<p>In this project, you are indirectly collaborating with another analyst by continuing their work. You won’t always be the only analyst on a project; there will be times when you share the work with other analysts. Being an effective collaborator means</p>
</div>
<ul>
<li class="readable-text" id="p36"> Communicating your work to other technical colleagues </li>
<li class="readable-text" id="p37"> Applying best practices to your work to make your code easier to work with </li>
<li class="readable-text" id="p38"> Consistently looking for ways to improve and learn from others </li>
</ul>
<div class="readable-text" id="p39">
<p>To hone these skills, you can contribute to open source projects or spend time looking at other people’s work.</p>
</div>
</div>
<div class="readable-text intended-text" id="p40">
<p>Let’s now take a look at this chapter’s project.</p>
</div>
<div class="readable-text" id="p41">
<h2 class="readable-text-h2" id="sigil_toc_id_149"><span class="num-string">12.3</span> Project 8: Finding customer segments from mobile activity</h2>
</div>
<div class="readable-text" id="p42">
<p>In this project, we will look at mobile phone activity to identify groups of similar customers. We will examine the problem statement, the available data, the project deliverables, and the tools you will need to attempt the project.</p>
</div>
<div class="readable-text intended-text" id="p43">
<p>The data is available for you to attempt the project yourself at <a href="https://davidasboth.com/book-code">https://davidasboth.com/book-code</a>. You will find the files that you can use for the project, including the previous analyst’s work on which we will build, as well as the example solution in the form of a Jupyter notebook.</p>
</div>
<div class="readable-text" id="p44">
<h3 class="readable-text-h3" id="sigil_toc_id_150"><span class="num-string">12.3.1</span> Problem statement</h3>
</div>
<div class="readable-text" id="p45">
<p>You’re working for AppEcho Insights, an analytics company focused on mobile user behavior. They analyze data on how users use their phones and provide insights to mobile phone manufacturers and app developers. Their latest initiative is customer segmentation. They want to understand whether there are groups of users who behave in a similar way. Knowing these user segments would be useful as their clients could target entire user bases with different initiatives. For example, they could market productivity tips to casual users or insights on extending battery life to heavy users.</p>
</div>
<div class="readable-text intended-text" id="p46">
<p>A previous analyst already performed a basic segmentation of the user base and presented their findings to the stakeholders. Unfortunately, they left the company after that, and their code was lost. Your manager has asked you to work on a second version of the analysis, using the results of the first as a starting point.</p>
</div>
<div class="readable-text intended-text" id="p47">
<p>The conclusion of the first version was that it is possible to segment customers based on the number of apps they use and the average length of their browsing sessions. The analyst proposed six unique customer categories and assigned them personas, such as “casual users” and “power users.” Your stakeholders want the second version of the segmentation to be more complex and include more features. They’d like to focus on the following:</p>
</div>
<ul>
<li class="readable-text" id="p48"> The types of apps that people use. For example, do some customers use their phones more for social media than others? </li>
<li class="readable-text" id="p49"> Look at temporal patterns. Do users prefer to browse their phones at different times of the day? </li>
<li class="readable-text" id="p50"> Potentially use a more suitable segmentation method (e.g., an algorithm that can handle grouping users based on multiple dimensions). </li>
</ul>
<div class="readable-text" id="p51">
<p>They have provided you with the dataset of mobile events and the presentation the initial analyst delivered. The dataset consists of individual mobile events, such as a user opening or closing a mobile app. There are only a few columns, but it is possible to extract rich behavioral information. The events are timestamped, so the temporal element can also be analyzed. See chapters 8 and 9 for more details about working with time data.</p>
</div>
<div class="readable-text print-book-callout" id="p52">
<p><span class="print-book-callout-head">NOTE</span>  The data was originally taken from <a href="https://github.com/aliannejadi/LSApp">https://github.com/aliannejadi/LSApp</a>. Thank you to Mohammad Aliannejadi for permission to use the data.</p>
</div>
<div class="readable-text" id="p53">
<p>Both the data and presentation files are in the supplementary materials. Your task will be to review the analyst’s work and continue the project to answer your stakeholders’ questions.</p>
</div>
<div class="readable-text" id="p54">
<h3 class="readable-text-h3" id="sigil_toc_id_151"><span class="num-string">12.3.2</span> Data dictionary</h3>
</div>
<div class="readable-text" id="p55">
<p>As always, a key initial step is to take a look at the available data. Table 12.1 shows the data dictionary.</p>
</div>
<div class="browsable-container browsable-table-container framemaker-table-container" id="p56">
<h5 class="browsable-container-h5 sigil_not_in_toc"><span class="num-string">Table 12.1</span> Data dictionary</h5>
<table>
<thead>
<tr>
<th>
<div>
         Column 
       </div></th>
<th>
<div>
         Definition 
       </div></th>
</tr>
</thead>
<tbody>
<tr>
<td>  User ID <br/></td>
<td>  A user’s unique identifier. <br/></td>
</tr>
<tr>
<td>  Session ID <br/></td>
<td>  Uniquely identifies a user’s activity session. <br/></td>
</tr>
<tr>
<td>  Timestamp <br/></td>
<td>  Date and time of an individual event. <br/></td>
</tr>
<tr>
<td>  App name <br/></td>
<td>  The name of the app in use. <br/></td>
</tr>
<tr>
<td>  Event type <br/></td>
<td>  The type of the event that took place. Values are one of the following: “Opened,” “Closed,” “User Interaction,” or “Broken.” <br/></td>
</tr>
</tbody>
</table>
</div>
<div class="readable-text" id="p57">
<p>Now that we have seen what’s available, let’s look at the outcomes of this project.</p>
</div>
<div class="readable-text" id="p58">
<h3 class="readable-text-h3" id="sigil_toc_id_152"><span class="num-string">12.3.3</span> Desired outcomes</h3>
</div>
<div class="readable-text" id="p59">
<p>Our stakeholders want a more in-depth analysis and customer segments based on more dimensions. Our solution should consist of a recreation of the initial analysis followed by our own improvements. The final output is the definition of our user segments, meaning what factors describe each segment and which users belong to which group.</p>
</div>
<div class="readable-text" id="p60">
<h3 class="readable-text-h3" id="sigil_toc_id_153"><span class="num-string">12.3.4</span> Required tools</h3>
</div>
<div class="readable-text" id="p61">
<p>In the example solution, I use Python and the <code>pandas</code> library for data exploration, <code>matplotlib</code> for visualization, and <code>scikit-learn</code> for clustering. To complete this project, you will need a tool that can</p>
</div>
<ul>
<li class="readable-text" id="p62"> Load a dataset from a CSV or similar </li>
<li class="readable-text" id="p63"> Perform basic data manipulation tasks, such as sorting, grouping, and reshaping data </li>
<li class="readable-text" id="p64"> Create data visualizations </li>
<li class="readable-text" id="p65"> Perform segmentation (e.g., with a clustering algorithm) </li>
</ul>
<div class="readable-text" id="p66">
<p>You can decide to perform the segmentation “by hand,” meaning decide on what values of your dimensions make up the groups. However, this becomes increasingly difficult to do manually after two to three dimensions, which is why I recommend choosing a tool that can apply a relevant algorithm.</p>
</div>
<div class="readable-text intended-text" id="p67">
<p>Let’s now see how we might approach this problem step by step using our results-driven framework.</p>
</div>
<div class="readable-text" id="p68">
<h2 class="readable-text-h2" id="sigil_toc_id_154"><span class="num-string">12.4</span> Applying the results-driven method to creating the second iteration of a customer segmentation</h2>
</div>
<div class="readable-text" id="p69">
<p>Let’s look at a results-driven approach to this problem and formulate our action plan.</p>
</div>
<div class="browsable-container figure-container" id="p70">
<img alt="figure" height="175" src="../Images/12-unnumb-1.png" width="529"/>
</div>
<div class="readable-text intended-text" id="p71">
<p><em><span class="aframe-location"/></em>The problem statement is clear: allocate users to distinct segments. Beyond this, what we also need to understand is the work the previous analyst has already done. Only then can we understand exactly what our task is. Recreating the analyst’s work is also crucial. First, we need to ensure we can replicate their results and verify their assumptions, but in this case, we also need to have the code available as the original was lost.</p>
</div>
<div class="browsable-container figure-container" id="p72">
<img alt="figure" height="175" src="../Images/12-unnumb-2.png" width="529"/>
</div>
<div class="readable-text" id="p73">
<p><em><span class="aframe-location"/></em>Starting at the end, in this case, means answering the questions posed in section 12.1. How many groups should there be? What kind of groups make sense in light of what our stakeholders want to do with the output? They want to be able to target different user groups with different offerings, so our evaluation of the user groups should be made with that in mind.</p>
</div>
<div class="browsable-container figure-container" id="p74">
<img alt="figure" height="175" src="../Images/12-unnumb-3.png" width="529"/>
</div>
<div class="readable-text" id="p75">
<p><em><span class="aframe-location"/></em>In this instance, the data has been identified for us. However, we should also think about ways to enhance this data. Can we extract more information from the data, or are there external sources we could join on?</p>
</div>
<div class="browsable-container figure-container" id="p76">
<img alt="figure" height="175" src="../Images/12-unnumb-4.png" width="529"/>
</div>
<div class="readable-text" id="p77">
<p><em><span class="aframe-location"/></em>The data has been downloaded for us in its raw form. Again, however, we could enhance it. We will review some ideas for enhancement in the example solution.</p>
</div>
<div class="browsable-container figure-container" id="p78">
<img alt="figure" height="175" src="../Images/12-unnumb-5.png" width="529"/>
</div>
<div class="readable-text" id="p79">
<p><em><span class="aframe-location"/></em>The segmentation process resembles any data analysis problem, for the most part:</p>
</div>
<ul>
<li class="readable-text" id="p80"> We will start by exploring the data, looking for missing and incorrect values, outliers, and so on. </li>
<li class="readable-text" id="p81"> Next, we will investigate which features our records vary along. That is, do some features have more variance than others? If all customers live in the same geographic area, there is no need to include geography as one of the dimensions on which to segment them. </li>
<li class="readable-text" id="p82"> We also want to visualize our data along the different dimensions in the hope of discovering obvious groups. In large, complex datasets, this is unlikely, but we might find outlier groups, such as a few customers who spend a lot more than the others. </li>
<li class="readable-text" id="p83"> The final two steps are unique to the segmentation problem. First, we will choose which dimensions to segment on and apply a clustering algorithm. Different algorithms exist for different use cases, some of which are discussed in the example solution. </li>
<li class="readable-text" id="p84"> Then, we will evaluate the results. We will do this by analyzing the groups to see if they meaningfully differ from one another. One way to do this is to assign group labels or personas to each group. If we can give each group a unique description, the results will be more useful than if we have created multiple segments with the same characteristics. </li>
</ul>
<div class="readable-text" id="p85">
<p>This step will be done once we have an allocation for each user, that is, know which of our newly created groups they belong to.</p>
</div>
<div class="browsable-container figure-container" id="p86">
<img alt="figure" height="175" src="../Images/12-unnumb-6.png" width="529"/>
</div>
<div class="readable-text" id="p87">
<p><em><span class="aframe-location"/></em>The presentation from the previous iteration was a short slide deck. We could consider creating a similar presentation as an output. At the very least, we should have all the same ingredients to hand: a list of the final groups, the number of users in each group, and what characteristics describe each group.</p>
</div>
<div class="browsable-container figure-container" id="p88">
<img alt="figure" height="175" src="../Images/12-unnumb-7.png" width="529"/>
</div>
<div class="readable-text" id="p89">
<p><em><span class="aframe-location"/></em>Since this will be the second iteration of the project, we should make recommendations to our stakeholders about additional steps that could be taken after our version is finished. Clearly, this is an important company initiative, which we can support by providing suggestions for further work if our stakeholders decide to allocate more resources.</p>
</div>
<div class="readable-text" id="p90">
<h2 class="readable-text-h2" id="sigil_toc_id_155"><span class="num-string">12.5</span> An example solution: Creating customer segments</h2>
</div>
<div class="readable-text" id="p91">
<p>Now, let’s walk through an example solution. As always, I strongly recommend attempting the project yourself first.</p>
</div>
<div class="readable-text intended-text" id="p92">
<p>As for the action plan, first, we will attempt to recreate the initial analysis. Next, we will investigate the additional features requested by our stakeholders before finally grouping our customers into new segments and analyzing these groups.</p>
</div>
<div class="readable-text" id="p93">
<h3 class="readable-text-h3" id="sigil_toc_id_156"><span class="num-string">12.5.1</span> Recreating someone else’s analysis</h3>
</div>
<div class="readable-text" id="p94">
<p>In this first part, we will review the slides presented by the previous analyst and attempt to replicate their findings. Slide 4 contains some summary metrics, which is where we should start. Figure 12.1 shows the slide in question.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p95">
<img alt="figure" height="389" src="../Images/12-1.png" width="917"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.1</span> Slide 4 from the original presentation, showing summary metrics</h5>
</div>
<div class="readable-text" id="p96">
<p>Our first task is to verify that we can recreate these metrics.</p>
</div>
<div class="readable-text" id="p97">
<h4 class="readable-text-h4 sigil_not_in_toc">Verifying reported metrics</h4>
</div>
<div class="readable-text" id="p98">
<p>First, we’ll read in the data with the following code, and a preview of the rows is shown in figure 12.2. Note that the data is in the .tsv format, meaning values are separated by a tab character, not a comma:</p>
</div>
<div class="browsable-container listing-container" id="p99">
<div class="code-area-container">
<pre class="code-area">import pandas as pd
import matplotlib.pyplot as plt

app_data = pd.read_csv(
    "./data/lsapp.tsv.gz",
    sep="\t",     <span class="aframe-location"/> #1
    names=["user_id", "session_id", "timestamp",
           "app_name", "event_type"],    <span class="aframe-location"/> #2
    parse_dates=["timestamp"],     <span class="aframe-location"/> #3
    skiprows=1    <span class="aframe-location"/> #4
)
print(app_data.shape)
app_data.head()</pre>
<div class="code-annotations-overlay-container">
     #1 Specifies the separator as the tab character
     <br/>#2 Gives the data specific column names
     <br/>#3 Explicitly converts the timestamp column to a date type
     <br/>#4 Ignores the original column headers since we’re supplying our own
     <br/>
</div>
</div>
</div>
<div class="browsable-container figure-container" id="p100">
<img alt="figure" height="322" src="../Images/12-2.png" width="900"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.2</span> A snapshot of the raw data</h5>
</div>
<div class="readable-text" id="p101">
<p>The output of the code tells us that there are over three million rows of data, and the snapshot tells us that we have one row per app event, which is when the user opens or closes an app. Let’s now investigate the claims on the appendix slide, which say that missing data and events tagged as broken were dropped. The slide in question is shown in figure 12.3.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p102">
<img alt="figure" height="172" src="../Images/12-3.png" width="412"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.3</span> The relevant part of the appendix from the slides, showing additional data cleaning steps</h5>
</div>
<div class="readable-text" id="p103">
<p>To investigate these additional data cleaning steps, the following code investigates missing data and produces the output in figure 12.4:</p>
</div>
<div class="browsable-container listing-container" id="p104">
<div class="code-area-container">
<pre class="code-area">app_data.isnull().sum()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p105">
<img alt="figure" height="203" src="../Images/12-4.png" width="223"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.4</span> The result of investigating missing data</h5>
</div>
<div class="readable-text" id="p106">
<p>This figure shows there is one missing value in each column. Regardless of whether those missing values are in the same record, it’s safe to drop missing data as it makes up a negligible percentage of our dataset:</p>
</div>
<div class="browsable-container listing-container" id="p107">
<div class="code-area-container">
<pre class="code-area">app_data = app_data.dropna()</pre>
</div>
</div>
<div class="readable-text" id="p108">
<p>Figure 12.2 also shows that user ID and session ID, which should typically be integers, are treated as decimal values. This is because the version of the <code>pandas</code> library I’m using does not have a nullable integer type. It is not crucial to convert this column to an integer, but we will do it to be explicit and avoid any confusion. Figure 12.5 verifies that all the columns have the correct data type:</p>
</div>
<div class="browsable-container listing-container" id="p109">
<div class="code-area-container">
<pre class="code-area">app_data["user_id"] = app_data["user_id"].astype(int)
app_data["session_id"] = app_data["session_id"].astype(int)

app_data.dtypes<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p110">
<img alt="figure" height="185" src="../Images/12-5.png" width="378"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.5</span> The corrected data types in our dataset</h5>
</div>
<div class="readable-text" id="p111">
<p>Before verifying the summary metrics on the slides, let’s investigate the “Broken” event type that, according to the appendix, was dropped. The following code looks at the distribution of event type as a percentage of the entire data, and the result is shown in figure 12.6:</p>
</div>
<div class="browsable-container listing-container" id="p112">
<div class="code-area-container">
<pre class="code-area">app_data["event_type"].value_counts(normalize=True)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p113">
<img alt="figure" height="147" src="../Images/12-6.png" width="418"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.6</span> Percentage breakdown of each event type</h5>
</div>
<div class="readable-text" id="p114">
<p>This figure tells us that only 0.1% of our data is a “Broken” event. We don’t have a lot of context about what this means, so we will agree with the initial analysis and drop these records using the following code.</p>
</div>
<div class="browsable-container listing-container" id="p115">
<div class="code-area-container">
<pre class="code-area">app_data = app_data[app_data["event_type"] != "Broken"]</pre>
</div>
</div>
<div class="readable-text" id="p116">
<p>Before we go further, let’s start building up our diagram of the process we are following. Figure 12.7 shows what we have done so far and where the analysis might have diverged.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p117">
<img alt="figure" height="374" src="../Images/12-7.png" width="927"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.7</span> The first step in recreating the initial analysis</h5>
</div>
<div class="readable-text" id="p118">
<p>Let’s now verify that, as per the “Dataset at a glance” slide in figure 12.1, we have 292 users, 87 unique apps, events spanning eight months, and three distinct event types. First, we verify the number of users:</p>
</div>
<div class="browsable-container listing-container" id="p119">
<div class="code-area-container">
<pre class="code-area">app_data["user_id"].nunique()</pre>
</div>
</div>
<div class="readable-text" id="p120">
<p>This code returns 292, as expected. Now, we verify the number of distinct apps:</p>
</div>
<div class="browsable-container listing-container" id="p121">
<div class="code-area-container">
<pre class="code-area">app_data["app_name"].nunique()</pre>
</div>
</div>
<div class="readable-text" id="p122">
<p>Again, we get the expected value of 87. Let’s now look at the date range in our data:</p>
</div>
<div class="browsable-container listing-container" id="p123">
<div class="code-area-container">
<pre class="code-area">app_data["timestamp"].agg(["min", "max"])</pre>
</div>
</div>
<div class="readable-text" id="p124">
<p>The output tells us the data spans September 2017 to May 2018, which is approximately eight months, as stated on the slides. We also know there are three event types since there were four when we first investigated them, and we dropped one of them entirely. The next step is to recreate some of the underlying data behind the charts in the slides.</p>
</div>
<div class="readable-text intended-text" id="p125">
<p>First, there is a slide showing the number of sessions per user, as shown in figure 12.8.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p126">
<img alt="figure" height="508" src="../Images/12-8.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.8</span> A slide from the original presentation showing the distribution of the number of sessions per user</h5>
</div>
<div class="readable-text intended-text" id="p127">
<p>Number of sessions per user seems like a useful metric to calculate as it is a proxy for how active a user is. To do this, we’ll create a DataFrame where, for each user, we count how many unique sessions they have in the data. We will then explore the distribution of this measure. The following code creates this DataFrame, and the output showing its descriptive statistics is presented in figure 12.9:</p>
</div>
<div class="browsable-container listing-container" id="p128">
<div class="code-area-container">
<pre class="code-area">sessions_per_user = (
    app_data
    .groupby("user_id")
    ["session_id"]
    .nunique()    
)

sessions_per_user.describe()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p129">
<img alt="figure" height="256" src="../Images/12-9.png" width="395"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.9</span> Descriptive statistics of the number of sessions per user</h5>
</div>
<div class="readable-text" id="p130">
<p>This tells us that the median number of sessions per user is 95, but there were users with a single session all the way to a user with over 5,000. Let’s see this distribution visually to better understand both the spread and where the data is concentrated. The following code creates the histogram shown in figure 12.10:</p>
</div>
<div class="browsable-container listing-container" id="p131">
<div class="code-area-container">
<pre class="code-area">fig, axis = plt.subplots()

sessions_per_user.hist(bins=20, ax=axis)

axis.set(
    title="Sessions per user",
    xlabel="Number of sessions",
    ylabel="Frequency"
)

plt.show()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p132">
<img alt="figure" height="613" src="../Images/12-10.png" width="782"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.10</span> Distribution of number of sessions per user</h5>
</div>
<div class="readable-text" id="p133">
<p>As we might have expected from the descriptive statistics, the distribution tells us most users have few sessions, with a long tail stretching to users with thousands. The initial analysis didn’t mention what the profiles of those prolific users look like, so let’s investigate them. Before we do that, let’s update our diagram to document the process so far. Figure 12.11 shows the latest version.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p134">
<img alt="figure" height="165" src="../Images/12-11.png" width="360"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.11</span> The steps we have taken so far</h5>
</div>
<div class="readable-text" id="p135">
<p>From this point, we will go beyond the results presented in the slides and into our own analysis. Let’s now look at the data for the user with the highest number of sessions. The following code finds the users with the most sessions, and the output is shown in figure 12.12:</p>
</div>
<div class="browsable-container listing-container" id="p136">
<div class="code-area-container">
<pre class="code-area">sessions_per_user.sort_values(ascending=False).head(5)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p137">
<img alt="figure" height="204" src="../Images/12-12.png" width="379"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.12</span> The users with the most unique sessions</h5>
</div>
<div class="readable-text" id="p138">
<p>The following code extracts the raw data for the user with the most sessions: user 138. A snapshot of their data is shown in figure 12.13:</p>
</div>
<div class="browsable-container listing-container" id="p139">
<div class="code-area-container">
<pre class="code-area">app_data[app_data["user_id"] == 138].head(10)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p140">
<img alt="figure" height="553" src="../Images/12-13.png" width="958"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.13</span> A snapshot of the activity of the user with the most sessions</h5>
</div>
<div class="readable-text" id="p141">
<p>It looks like the data for this user starts with them using various apps at around 5:30 a.m. One noticeable aspect of this data is that it starts with an “Opened” event followed immediately by a “Closed” event and then another “Opened” event, all for the same app. Is this information relevant or redundant? In the example in figure 12.13, we have some exact duplicates, namely, the first and third rows. Let’s see how big this problem is.</p>
</div>
<div class="readable-text" id="p142">
<h4 class="readable-text-h4 sigil_not_in_toc">Investigating duplicate event records</h4>
</div>
<div class="readable-text" id="p143">
<p>The following code calculates the proportion of records that are exact duplicates:</p>
</div>
<div class="browsable-container listing-container" id="p144">
<div class="code-area-container">
<pre class="code-area">app_data.duplicated().sum() / len(app_data)</pre>
</div>
</div>
<div class="readable-text" id="p145">
<p>The output is 0.597, meaning nearly 60% of our data is an exact duplicate of another row. That means a record with the same user ID, same session ID, and the same event type occurring for the same app at the same time.</p>
</div>
<div class="readable-text intended-text" id="p146">
<p>This result could potentially require a lot of work to investigate and clear up, so before we do anything, let’s consider whether duplicates are a problem for the specific analysis we want to conduct. We are interested in</p>
</div>
<ul>
<li class="readable-text" id="p147"> What types of apps do people use? If we are counting things like the number of unique apps per user, duplicates won’t be a problem. </li>
<li class="readable-text" id="p148"> When do people use their phones? Unfortunately, having duplicate records would skew the results because we may accidentally inflate some parts of the day versus others if there happen to be more duplicates at different times of the day. </li>
</ul>
<div class="readable-text" id="p149">
<p>We, therefore, can’t ignore the fact there are duplicates. We need to take stock of our possible options instead:</p>
</div>
<ul>
<li class="readable-text" id="p150"> We could simply drop duplicate records. What would happen if we did this for the example in figure 12.13? We would end up with an “Opened” event followed by two “Closed” events. The “Closed” events wouldn’t be duplicates as they occurred at different times. Dropping exact duplicates is too basic and would cause additional problems. </li>
<li class="readable-text" id="p151"> Another option is to drop pairs of “Opened” and “Closed” events that occurred at the same time. However, this assumes that an “Opened” event always has a corresponding “Closed” event, which may not hold in practice. </li>
<li class="readable-text" id="p152"> We could also think about the problem differently. As it stands, we are not interested in the single-event level but in summarizing behavior at the user level. This means that we could say that “Closed” events are less informative. If a user opens five apps in a browsing session, we would know that even without the presence of “Closed” events. </li>
</ul>
<div class="readable-text" id="p153">
<p>The idea that “Closed” events are informationally redundant is quite appealing, so let’s go with that approach. The following code drops events that are “Closed” and calculates the percentage of records we dropped, as well as the percentage of exact duplicates in the remaining data:</p>
</div>
<div class="browsable-container listing-container" id="p154">
<div class="code-area-container">
<pre class="code-area">closed_dropped = app_data.loc[app_data["event_type"] != "Closed", :]

print(len(closed_dropped))
print(len(closed_dropped) / len(app_data))
print(closed_dropped.duplicated().sum() / len(closed_dropped))</pre>
</div>
</div>
<div class="readable-text" id="p155">
<p>The outputs of these three commands are 1,987,090, 0.54, and 0.599. This means we have just under 2 million records remaining out of an initial 3.7 million, which is about half our original data. It also tells us that we still have nearly 60% exact duplicates. Now, an exact duplicate is entirely redundant for our purposes, so we can drop those, too. The following code does this and calculates how much data we have left:</p>
</div>
<div class="browsable-container listing-container" id="p156">
<div class="code-area-container">
<pre class="code-area">app_data_reduced = closed_dropped.drop_duplicates()
len(app_data_reduced)</pre>
</div>
</div>
<div class="readable-text" id="p157">
<p>We are left with just under 800,000 records. It is unusual to drop so much data as part of an analysis, but in this case, it was justified. Figure 12.14 shows the process so far, including the choices we have just made.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p158">
<img alt="figure" height="574" src="../Images/12-14.png" width="667"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.14</span> The process so far, including choices about handling duplicate data</h5>
</div>
<div class="readable-text" id="p159">
<p>Having cleaned up a lot of duplication, let’s reexamine our data. The following code examines the first few rows, which are shown in figure 12.15:</p>
</div>
<div class="browsable-container listing-container" id="p160">
<div class="code-area-container">
<pre class="code-area">app_data_reduced.head(10)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p161">
<img alt="figure" height="568" src="../Images/12-15.png" width="959"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.15</span> Example events after duplicate records were removed</h5>
</div>
<div class="readable-text" id="p162">
<p>This latest figure shows a new challenge. There are sequential instances of a user opening Minesweeper, sometimes only a few seconds apart. What could this mean?</p>
</div>
<ul>
<li class="readable-text" id="p163"> Was the user constantly changing their mind about whether they wanted to play? </li>
<li class="readable-text" id="p164"> Was the user trying to open the app, but it kept crashing? </li>
<li class="readable-text" id="p165"> Are these artifacts of how the data was collected/collated? </li>
</ul>
<div class="readable-text" id="p166">
<p>We would need more information to know for sure.</p>
</div>
<div class="readable-text" id="p167">
<h4 class="readable-text-h4 sigil_not_in_toc">Handling related pairs of event records</h4>
</div>
<div class="readable-text" id="p168">
<p>As it stands, we must make a choice about what, if anything, to do about this kind of repetition:</p>
</div>
<ul>
<li class="readable-text" id="p169"> We could assume that multiple repeated events related to an app are actually a single instance of the user using that app. In the case of someone opening Minesweeper 10 times in the data followed by opening another app, we could treat that as 2 events instead of 11. </li>
<li class="readable-text" id="p170"> We could look at the time difference between interactions of the same app and remove interactions that are too short. This requires us to strictly define “too short,” which is a strong built-in assumption. </li>
<li class="readable-text" id="p171"> We could also ignore this problem entirely. Again, we are interested in user-level and session-level metrics, not individual event-level ones. If we define the length of a user session by the difference between when it started and ended, it doesn’t matter what happened in between as the user was interacting with their phone one way or another. </li>
</ul>
<div class="readable-text" id="p172">
<p>Thinking about this in a results-driven way, we can answer our stakeholders’ questions about app types and user browsing times without explicitly handling these instances of users opening and closing apps in quick succession. Since we’re making another choice, we’ll add that to our diagram, the latest version of which is shown in figure 12.16.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p173">
<img alt="figure" height="678" src="../Images/12-16.png" width="684"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.16</span> Our latest progress after investigating various types of duplicate event</h5>
</div>
<div class="readable-text" id="p174">
<p>Now that we’ve handled the duplication issue, we can recreate the chart from the slides relating to the average session length of each user. This is shown in figure 12.17.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p175">
<img alt="figure" height="915" src="../Images/12-17.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.17</span> A slide from the original presentation showing the distribution of users’ average session length</h5>
</div>
<div class="readable-text intended-text" id="p176">
<p>To recreate this, we need to create a DataFrame of individual sessions and their length. First, we need to establish whether a session<span class="aframe-location"/> ID is unique to a user. If session 1 can only ever relate to user 0, we can simply group by the session ID; otherwise, we must include the user ID to distinguish between two different users’ sessions, both with an ID of 1. The following code looks for session IDs that belong to more than one user:</p>
</div>
<div class="browsable-container listing-container" id="p177">
<div class="code-area-container">
<pre class="code-area">(
    app_data_reduced
    .groupby("session_id")
    ["user_id"]
    .nunique()
    .loc[lambda x: x &gt; 1]
)</pre>
</div>
</div>
<div class="readable-text" id="p178">
<p>The output of this code is an empty <code>pandas</code> <code>Series</code>, meaning there are no session IDs across multiple users. Therefore, the session ID is unique to a user. Now, we can create the DataFrame of sessions that we need. The following code does this and produces the DataFrame, which is previewed in figure 12.18:</p>
</div>
<div class="browsable-container listing-container" id="p179">
<div class="code-area-container">
<pre class="code-area">sessions = (
    app_data_reduced
    .groupby(["user_id", "session_id"])
    .agg(start=("timestamp", "min"),
         end=("timestamp", "max"))
    .reset_index()
    .assign(
        duration_mins=lambda _df: (_df["end"] - _df["start"]).dt.seconds/60
    )
)

sessions.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p180">
<img alt="figure" height="257" src="../Images/12-18.png" width="788"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.18</span> A snapshot of user sessions and their duration in minutes</h5>
</div>
<div class="readable-text" id="p181">
<p>This DataFrame contains one row per user session, so grouping by user ID and averaging the session duration gives us the data we need to produce the chart from the slides. The following code does this and produces the chart in figure 12.19:</p>
</div>
<div class="browsable-container listing-container" id="p182">
<div class="code-area-container">
<pre class="code-area">fig, axis = plt.subplots()

avg_session_by_user = (
    sessions
    .groupby("user_id")
    ["duration_mins"]
    .median()
)

(
    avg_session_by_user
    .hist(bins=20, ax=axis)
)

axis.set(
    title="Distribution of users' average session length \
(one data point = 1 user)",
    xlabel="Session duration (minutes)",
    ylabel="Frequency"
)

plt.show()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p183">
<img alt="figure" height="534" src="../Images/12-19.png" width="722"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.19</span> The distribution of users’ average session lengths</h5>
</div>
<div class="readable-text" id="p184">
<p>This result tells us that most users’ sessions last less than 2 minutes but with a long tail. There are sessions that are even over 10 minutes in duration. You might notice that this chart doesn’t exactly match the one in the slides, as shown by the difference between figures 12.17 and 12.19. That is because we have chosen to drop “Closed” events and have therefore already diverged from the initial analysis. That’s fine because we are making different assumptions and thus coming to different conclusions.</p>
</div>
<div class="readable-text intended-text" id="p185">
<p>Our particular approach might skew results slightly if there are sessions that end in a “Closed” event because we’d underestimate how long those sessions are. However, since our primary goal is to look at what kinds of apps people use in a session and what time those sessions occur, the initial “Opened” event is sufficient.</p>
</div>
<div class="readable-text intended-text" id="p186">
<p>We have recreated the relevant parts of the original analysis, but before moving on to our stakeholders’ questions, let’s recap the process. The latest diagram is shown in figure 12.20.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p187">
<img alt="figure" height="808" src="../Images/12-20.png" width="746"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.20</span> The process of reproducing the original analysis</h5>
</div>
<div class="readable-text intended-text" id="p188">
<p>Let’s move on to the next part of the analysis, answering our stakeholders’ new questions about the users.</p>
</div>
<div class="readable-text" id="p189">
<h3 class="readable-text-h3" id="sigil_toc_id_157"><span class="num-string">12.5.2</span> Analyzing event data to learn about customer behavior</h3>
</div>
<div class="readable-text" id="p190">
<p>Now that we have verified the findings of the original analysis, we can move on to our stakeholders’ new questions. The first one was about what time people use their phones and whether this would be a useful dimension for clustering.</p>
</div>
<div class="readable-text" id="p191">
<h4 class="readable-text-h4 sigil_not_in_toc">Analyzing timestamps to learn about browsing behavior</h4>
</div>
<div class="readable-text" id="p192">
<p>To investigate when people use their phones, we need a definition of what counts as “usage time.” That is, do we care about the times that every single data point occurred? Probably not because a group of “Opened” and “Closed” events close together in time should count as one example of a user using their phone around that time.</p>
</div>
<div class="readable-text intended-text" id="p193">
<p>That means we could use the start time from the session-level DataFrame created earlier. The following code creates a column to extract the hour component of the dates so we can isolate just the hour in which browsing began. Then, we plot the distribution of these “start hours,” the result of which is shown in figure 12.21:</p>
</div>
<div class="browsable-container listing-container" id="p194">
<div class="code-area-container">
<pre class="code-area">sessions["hour"] = sessions["start"].dt.hour

(
    sessions["hour"]
    .value_counts()
    .sort_index()
    .plot(kind="bar")
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p195">
<img alt="figure" height="554" src="../Images/12-21.png" width="722"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.21</span> The distribution of when users start their browsing sessions</h5>
</div>
<div class="readable-text" id="p196">
<p>This chart tells us that most browsing sessions start in the late afternoon/early evening, with a dip in the early hours of the day. What it doesn’t tell us is whether there are users who behave differently to this general trend. For that, we need to calculate what the most common starting hour, or part of the day, is for each user.</p>
</div>
<div class="readable-text print-book-callout" id="p197">
<p><span class="print-book-callout-head">Note</span>  In this section, we will explore the temporal aspect of this data. If you’re interested in more examples of working with time series data, see chapters 8 and 9.</p>
</div>
<div class="readable-text" id="p198">
<p>Let’s now calculate the most common starting hour for each user. We can use the statistical mode for this, which simply returns the most common value. However, we need to decide what happens if there is a tie. What if someone’s most common browsing time is both 8 a.m. and 5 p.m.? There is no reason to prefer one or the other, so we will leave both values in. Therefore, that user will be represented twice, which may skew the results by overrepresenting some users, but it will also retain valuable information.</p>
</div>
<div class="readable-text intended-text" id="p199">
<p>The following code defines a function to return possibly multiple values of the mode for each user and then applies it to the DataFrame. A snapshot of the resulting DataFrame is shown in figure 12.22:</p>
</div>
<div class="browsable-container listing-container" id="p200">
<div class="code-area-container">
<pre class="code-area">def get_modes(group):
    mode_hours = group['hour'].mode()    <span class="aframe-location"/> #1
    return pd.DataFrame(
        {
            'user_id': group['user_id'].iloc[0],
            'most_frequent_hour': mode_hours
        }
    )

most_frequent_hours = (
    sessions
    .groupby("user_id")
    .apply(get_modes)    <span class="aframe-location"/> #2
    .rename(columns={"user_id": "duplicate_user_id"})
    .reset_index()
    .drop(columns=["level_1", "duplicate_user_id"])    <span class="aframe-location"/> #3
)

most_frequent_hours.head()<span class="aframe-location"/></pre>
<div class="code-annotations-overlay-container">
     #1 Calculates the mode, possibly returning multiple values
     <br/>#2 Applies this function and extracts all the most common starting hours
     <br/>#3 Cleans up unnecessary columns created by grouping and aggregating
     <br/>
</div>
</div>
</div>
<div class="browsable-container figure-container" id="p201">
<img alt="figure" height="300" src="../Images/12-22.png" width="390"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.22</span> A snapshot of the most common starting hour for users’ browsing sessions</h5>
</div>
<div class="readable-text" id="p202">
<p>As shown in figure 12.22, there are instances of a user having multiple most frequent start times, such as user 0, who browses equally frequently around 4 p.m. and 10 p.m. From this data, we can now look at the distribution of the newly created <code>most_ frequent_hour</code> column to understand whether there are users who prefer different times in the day for using their phones. The following code investigates this and produces the chart in figure 12.23:</p>
</div>
<div class="browsable-container listing-container" id="p203">
<div class="code-area-container code-area-with-html">
<pre class="code-area">fig, axis = plt.subplots()

(
    most_frequent_hours
    ["most_frequent_hour"]
    .value_counts()
    .sort_index()
    .plot
    .bar(ax=axis)
)

axis.set(
    title="Distribution of most common starting time
<span class="">↪</span> for users' browsing sessions",
    xlabel="Hour",
    ylabel="Frequency"
)

plt.show()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p204">
<img alt="figure" height="503" src="../Images/12-23.png" width="677"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.23</span> Distribution of users’ most common browsing times</h5>
</div>
<div class="readable-text" id="p205">
<p>What this chart tells us is that there are distinct groups of users who prefer to browse in the morning around 6 a.m., at lunchtime around 1 p.m., or at 5 p.m. in the evening, with another peak starting at midnight.</p>
</div>
<div class="readable-text" id="p206">
<p>Before we move on to decide how to use this information in our user segments, let’s add this to our growing diagram of our analysis, which is shown in figure 12.24.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p207">
<img alt="figure" height="619" src="../Images/12-24.png" width="1009"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.24</span> The process diagram, including the start of part 2 of the analysis</h5>
</div>
<div class="readable-text intended-text" id="p208">
<p>We could use the data shown in figure 12.22 as a dimension in our segments, that is, the actual most common start hour for a user. However, there would be two problems:</p>
</div>
<ul>
<li class="readable-text" id="p209"> Some users would have multiple rows, which will not work for a segmentation problem. </li>
<li class="readable-text" id="p210"> Some hours of the day are very similar, that is, it doesn’t matter if a user started their browsing at 4 p.m. or 5 p.m. </li>
</ul>
<div class="readable-text" id="p211">
<p>We want to find distinct user groups so we can group these similar times together instead. We could have done this up front, that is, grouped different parts of the day together into “morning,” “midday,” and so on, and investigated the distribution of those categories. However, we would have made assumptions about which hours are similar in terms of mobile usage. By looking at the distribution of individual hours first, we can create groups that closely match what we find in the data.</p>
</div>
<div class="readable-text" id="p212">
<h4 class="readable-text-h4 sigil_not_in_toc">Creating customer labels based on browsing patterns</h4>
</div>
<div class="readable-text" id="p213">
<p>Looking at the chart in figure 12.23, we could conclude there are anywhere between two and five “peaks,” which could act as different parts of the day. The choice of how many categories to use will be somewhat subjective. Let’s go with <span class="aframe-location"/>four categories, as this might fit the data best without creating too many user segments down the line. Our groups will be</p>
</div>
<ul>
<li class="readable-text" id="p214"> Night owls, who tend to browse between 9 p.m. and 3 a.m. (inclusive) </li>
<li class="readable-text" id="p215"> Early morning users, who tend to browse between 4 a.m. and 9 a.m. (inclusive) </li>
<li class="readable-text" id="p216"> Midday users, who tend to browse between 10 a.m. and 2 p.m. (inclusive) </li>
<li class="readable-text" id="p217"> Late-day users, who tend to browse between 3 p.m. and 8 p.m. (inclusive) </li>
</ul>
<div class="readable-text" id="p218">
<p>Let’s create these groups and investigate how many users are in each group. The following code does the categorization and produces the output in figure 12.25:</p>
</div>
<div class="browsable-container listing-container" id="p219">
<div class="code-area-container code-area-with-html">
<pre class="code-area">bins = [-1, 3, 9, 14, 20]
labels = ['night_owl', 'early_morning_browser',
          'midday_browser', 'late_day_browser']

most_frequent_hours["category"] = (
    pd.cut(
        most_frequent_hours["most_frequent_hour"],
        bins=bins,
        labels=labels,
        ordered=True
    )
)

most_frequent_hours.loc[
<span class="">↪</span> most_frequent_hours["most_frequent_hour"].isin([21, 22, 23]),
<span class="">↪</span> "category"] = "night_owl"  <span class="aframe-location"/> #1

most_frequent_hours.head()<span class="aframe-location"/></pre>
<div class="code-annotations-overlay-container">
     #1 Fixes additional night owl values
     <br/>
</div>
</div>
</div>
<div class="browsable-container figure-container" id="p220">
<img alt="figure" height="280" src="../Images/12-25.png" width="596"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.25</span> Users’ most common browsing hours grouped into four categories</h5>
</div>
<div class="readable-text" id="p221">
<p>Now, we can investigate the membership in these groups. The following code calculates the distribution and produces the output shown in figure 12.26.</p>
</div>
<div class="browsable-container listing-container" id="p222">
<div class="code-area-container">
<pre class="code-area">(
    most_frequent_hours["category"]
    .value_counts()
    .sort_index()
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p223">
<img alt="figure" height="142" src="../Images/12-26.png" width="348"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.26</span> Distribution of the categories of users’ browsing sessions</h5>
</div>
<div class="readable-text" id="p224">
<p>Let’s now use this dataset to create a one-hot encoded representation of these categories, that is, one binary column to indicate membership in each category. Crucially, a user can be in multiple categories, as shown in figure 12.25. See chapter 6 for more examples of this in practice. The following code creates the one-hot encoding and produces the start of a user-level dataset, which we will use for segmentation. A snapshot of this new dataset is shown in figure 12.27:</p>
</div>
<div class="browsable-container listing-container" id="p225">
<div class="code-area-container">
<pre class="code-area">users = (
    pd.get_dummies(     <span class="aframe-location"/> #1
        most_frequent_hours.drop(columns=["most_frequent_hour"]),
        columns=["category"],
        prefix="time"
    )
    .groupby("user_id")
    .max()
    .reset_index()
)

users.head()<span class="aframe-location"/></pre>
<div class="code-annotations-overlay-container">
     #1 get_dummies created the one-hot encoded columns.
     <br/>
</div>
</div>
</div>
<div class="browsable-container figure-container" id="p226">
<img alt="figure" height="271" src="../Images/12-27.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.27</span> A snapshot of user-level data showing which browsing time categories users belong to</h5>
</div>
<div class="readable-text" id="p227">
<p>We have now created a dataset that we can add additional columns to and run the segmentation algorithm on. Before we move on to the next stakeholder question, which is about what types of apps people use, let’s update our diagram of the work done so far. The latest version is shown in figure 12.28.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p228">
<img alt="figure" height="619" src="../Images/12-28.png" width="1009"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.28</span> The process so far, including grouping people into categories based on when they browse</h5>
</div>
<div class="readable-text intended-text" id="p229">
<p>We can now move on to our next stakeholder question about what types of apps people use.</p>
</div>
<div class="readable-text" id="p230">
<h4 class="readable-text-h4 sigil_not_in_toc">Using AI to label data</h4>
</div>
<div class="readable-text" id="p231">
<p>Our stakeholders want us to investigate what types of apps people use and potentially use that information in the segmentation. However, we do not have data on app type directly, just a list of app names. This is a clear example of more information being contained in the raw data than we might think at first. A domain expert could easily categorize each app name into some broader category. This is a perfect use case for AI to augment our work.</p>
</div>
<div class="readable-text intended-text" id="p232">
<p>There are over 80 distinct app names to categorize. It’s doable but repetitive to do by hand, so let’s ask an AI to do it. We can use the following code snippet to get the app names as a list to pass to the AI tool:</p>
</div>
<div class="browsable-container listing-container" id="p233">
<div class="code-area-container">
<pre class="code-area">print(app_data_reduced["app_name"].unique())</pre>
</div>
</div>
<div class="readable-text" id="p234">
<p>The following prompt, asking ChatGPT to categorize the app names for us, generates the output shown in figure 12.29.</p>
</div>
<div class="readable-text" id="p235">
<blockquote>
<div>
     I will provide a list of mobile application names. To the best of your ability, group them into logical categories, e.g., email, social media, web browser, mobile games, etc. I’d like the response as a table with columns 
     <em>'app_name'</em> and 
     <em>'category'</em>. If you are unsure what category an app belongs to, put “Unknown.” Here is the list of app names: &lt;app names follow&gt;. 
     <span class="aframe-location"/>
</div>
</blockquote>
</div>
<div class="browsable-container figure-container" id="p236">
<img alt="figure" height="482" src="../Images/12-29.png" width="1023"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.29</span> Part of ChatGPT’s response to categorize app names into broader categories</h5>
</div>
<div class="readable-text print-book-callout" id="p237">
<p><span class="print-book-callout-head">Note</span>  It is important to note that these tools don’t always produce the same output for the same prompt. They are also evolving all the time, so you will almost certainly get a different output than I do for the same prompt. This is a feature of the analytics process, not a bug.</p>
</div>
<div class="readable-text" id="p238">
<p>Once we are satisfied with the output, we can specifically request the data as a CSV file and merge it into our own data. The following code achieves this, and a snapshot is shown in figure 12.30:</p>
</div>
<div class="browsable-container listing-container" id="p239">
<div class="code-area-container">
<pre class="code-area">categories = pd.read_csv("./data/App_Categories.csv",
                         skiprows=1,
                         names=["app_name", "app_category"])
print(categories.shape)
categories.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p240">
<img alt="figure" height="267" src="../Images/12-30.png" width="594"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.30</span> A snapshot of the categorization data produced by ChatGPT</h5>
</div>
<div class="readable-text" id="p241">
<p>Let’s add this latest step to our process diagram, the latest version of which is shown in figure 12.31.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p242">
<img alt="figure" height="766" src="../Images/12-31.png" width="1009"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.31</span> The latest diagram of our steps, including ChatGPT’s categorization of apps</h5>
</div>
<div class="readable-text" id="p243">
<p>Let’s now see the distribution of this category data. The following code calculates this and produces the output in figure 12.32:</p>
</div>
<div class="browsable-container listing-container" id="p244">
<div class="code-area-container">
<pre class="code-area">categories["app_category"].value_counts()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p245">
<img alt="figure" height="800" src="../Images/12-32.png" width="419"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.32</span> Distribution of newly created app categories</h5>
</div>
<div class="readable-text" id="p246">
<p>There are a couple of things to notice here. One is that there are a few “Unknown” values, which we should investigate and manually categorize. The second is that there are quite a lot of categories, probably too many to be useful. First, let’s resolve the “Unknown” values. The following code investigates these values, and they are shown in figure 12.33:</p>
</div>
<div class="browsable-container listing-container" id="p247">
<div class="code-area-container">
<pre class="code-area">categories[categories["app_category"] == "Unknown"]<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p248">
<img alt="figure" height="269" src="../Images/12-33.png" width="395"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.33</span> App names that ChatGPT could not categorize</h5>
</div>
<div class="readable-text" id="p249">
<p>We can manually categorize these with a bit of research and some code snippets. The following code updates the category of these specific app names:</p>
</div>
<div class="browsable-container listing-container" id="p250">
<div class="code-area-container code-area-with-html">
<pre class="code-area">categories.loc[categories["app_name"]=="MUIQ Survey App", "app_category"]
<span class="">↪</span> = "Survey"
categories.loc[categories["app_name"]=="SurveyCow", "app_category"]
<span class="">↪</span> = "Survey"
categories.loc[categories["app_name"]=="Reward Stash", "app_category"]
<span class="">↪</span> = "Rewards"
categories.loc[categories["app_name"]=="Movie Play Box", "app_category"]
<span class="">↪</span> = "Video Streaming"
categories.loc[categories["app_name"]=="MetroZone", "app_category"]
<span class="">↪</span> = "Utility"</pre>
</div>
</div>
<div class="readable-text" id="p251">
<p>Now, let’s handle the second problem, which is that ChatGPT created too many categories. We can choose to ask ChatGPT to revise its categorization and ask for fewer columns, or we could use ChatGPT’s categories as subcategories and define main categories ourselves. It’s a personal choice, but it shouldn’t take too long to do this ourselves, and that way, we have the categorization code ready if we decide to change the categories later.</p>
</div>
<div class="readable-text" id="p252">
<h4 class="readable-text-h4 sigil_not_in_toc">Reviewing AI-created data labels</h4>
</div>
<div class="readable-text" id="p253">
<p>One <code>pandas</code> trick is to use the <code>map</code> method to map categories to new ones based on a dictionary. We don’t want to type this dictionary out ourselves, but we can write a bit of code to print the categories in the required format, which we copy and paste into our main mapping code. The following code prints the existing categories in the right format, leaving space for the new category alongside. The output is shown in figure 12.34, so you can see how it would be pasted to create the code snippet that follows later:</p>
</div>
<div class="browsable-container listing-container" id="p254">
<div class="code-area-container">
<pre class="code-area">for category in sorted(categories["app_category"].unique()):
    print(f"'{category}': '',")<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p255">
<img alt="figure" height="827" src="../Images/12-34.png" width="429"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.34</span> Our categories in a format required by a Python dictionary</h5>
</div>
<div class="readable-text" id="p256">
<p>Now, we can use this output to create the following code, which updates each existing category with its new categorization. We will keep the existing category column as a subcategory, so we have two levels of app category hierarchy. Figure 12.35 shows a snapshot of the categories dataset after these updates:</p>
</div>
<div class="browsable-container listing-container" id="p257">
<div class="code-area-container code-area-with-html">
<pre class="code-area">categories = categories.rename(columns={"app_category": "app_subcategory"})

category_map = {
    'Advertising': 'Money',
    'App Marketplace': 'Entertainment',
    'Cloud Storage': 'Utility',
    'Communication': 'Social',
    'Email': 'Social',
    'Finance': 'Money',
    'Health': 'Social',
    'Messaging': 'Social',
    'Mobile Games': 'Entertainment',
    'Music Streaming': 'Entertainment',
    'Navigation': 'Utility',
    'News': 'Social',
    'Note Taking': 'Utility',
    'Online Shopping': 'Money',
    'Photo Editing': 'Utility',
    'Photo Management': 'Utility',
    'Podcasts': 'Entertainment',
    'Productivity': 'Utility',
    'Rewards': 'Money',
    'Social Media': 'Social',
    'Social Media/Messaging': 'Social',
    'Survey': 'Money',
    'Utility': 'Utility',
    'Video Streaming': 'Entertainment',
    'Web Browser': 'Browsing',
    'Web Browser/Search Engine': 'Browsing'
}

categories["app_category"]
<span class="">↪</span> = categories["app_subcategory"].map(category_map)
categories.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p258">
<img alt="figure" height="261" src="../Images/12-35.png" width="720"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.35</span> A snapshot of the categories data after applying our new categorization</h5>
</div>
<div class="readable-text" id="p259">
<p>Before we merge this back into the main app data, let’s review our process by updating our diagram. The latest version is shown in figure 12.36.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p260">
<img alt="figure" height="884" src="../Images/12-36.png" width="1009"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.36</span> The latest process, including a review of ChatGPT’s categorization</h5>
</div>
<div class="readable-text" id="p261">
<p>Now, it’s time to merge these categories back to our original data and see how people use these various app types. The following code joins the event-level app data to the app categories, creating merged data, a snapshot of which is shown in figure 12.37.</p>
</div>
<div class="browsable-container listing-container" id="p262">
<div class="code-area-container">
<pre class="code-area">app_data_merged = app_data_reduced.merge(
    categories,
    on="app_name")
assert len(app_data_reduced) ==  len(app_data_merged)     <span class="aframe-location"/> #1
app_data_merged.head()<span class="aframe-location"/></pre>
<div class="code-annotations-overlay-container">
     #1 Raises an error message if we don’t have the same number of rows after the merge
     <br/>
</div>
</div>
</div>
<div class="browsable-container figure-container" id="p263">
<img alt="figure" height="248" src="../Images/12-37.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.37</span> A snapshot of the app data merged with app categories</h5>
</div>
<div class="readable-text" id="p264">
<p>From this data, we want to find each user’s most common app category. After that, we will investigate whether there are ties, that is, users who have more than one category as their most common.</p>
</div>
<div class="readable-text" id="p265">
<h4 class="readable-text-h4 sigil_not_in_toc">Analyzing newly created category labels</h4>
</div>
<div class="readable-text" id="p266">
<p>The following code calculates the top categories per user, and a snapshot of the output is shown in figure 12.38. Note that <code>pandas</code> creates a column called <code>level_1</code> because the mode function could return multiple values, as it did when we looked at app usage times:</p>
</div>
<div class="browsable-container listing-container" id="p267">
<div class="code-area-container">
<pre class="code-area">top_categories = (
    app_data_merged
    .groupby("user_id")
    ["app_category"]
    .apply(pd.Series.mode)
    .reset_index()
)

top_categories.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p268">
<img alt="figure" height="279" src="../Images/12-38.png" width="383"/>
</div>
<div class="browsable-container figure-container" id="p269">
<img alt="figure" height="279" src="../Images/12-38.png" width="383"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.38</span> A snapshot of the “most common category per user” dataset</h5>
</div>
<div class="readable-text" id="p270">
<p>From this data, we can investigate whether there are users with multiple categories as their most common. We can use this <code>level_1</code> column that <code>pandas</code> created to filter our data. Anything with a value of zero means the user’s top category, so values greater than zero mean a user has multiple top categories. The following code investigates this and produces the output in figure 12.39:</p>
</div>
<div class="browsable-container listing-container" id="p271">
<div class="code-area-container">
<pre class="code-area">top_categories[top_categories["level_1"] &gt; 0]<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p272">
<img alt="figure" height="167" src="../Images/12-39.png" width="395"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.39</span> Users with more than one top app category</h5>
</div>
<div class="readable-text" id="p273">
<p>Let’s examine these users in more detail and see if we can decide how to proceed. The following code retrieves all records for these users and produces the output in figure 12.40:</p>
</div>
<div class="browsable-container listing-container" id="p274">
<div class="code-area-container">
<pre class="code-area">top_categories[top_categories["user_id"].isin([35, 223, 132])]<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p275">
<img alt="figure" height="333" src="../Images/12-40.png" width="395"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.40</span> All category data for users with more than one top category</h5>
</div>
<div class="readable-text" id="p276">
<p>We can either remove one of those categories per user or record our data the same way we did with app times, that is, users would be allowed more than one top category. As there are only three affected users in this case, we will investigate whether we could drop one of their top categories. How do we decide which of the two categories to drop? Let’s first look at the underlying data for the user with ID 35. The following code retrieves the data for that user at an individual app level, which is then shown in figure 12.41:</p>
</div>
<div class="browsable-container listing-container" id="p277">
<div class="code-area-container">
<pre class="code-area">(
    app_data_merged[app_data_merged["user_id"] == 35]
    .groupby(["app_category", "app_name"])
    .size()
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p278">
<img alt="figure" height="277" src="../Images/12-41.png" width="487"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.41</span> User 35’s app usage by category and app name</h5>
</div>
<div class="readable-text" id="p279">
<p>This user used the Settings app quite heavily, which contributed to the “Utility” category being joint top for them. We don’t have more detailed information about why this user kept opening their phone settings. We can use what we have to decide if it’s more relevant that the user uses the “Social” apps most frequently. We will drop the necessary record for this user to have “Social” as their only top category. User 132 also had “Utility” as their joint top category, so for the same reason, we’ll drop that record as well. The following code cleans up the data for these two users:</p>
</div>
<div class="browsable-container listing-container" id="p280">
<div class="code-area-container">
<pre class="code-area">top_categories = (
    top_categories
    .drop(
        index=top_categories[
            (top_categories["user_id"].isin([35, 132]))
            &amp; (top_categories["app_category"] == "Utility")
            ].index
    )
)</pre>
</div>
</div>
<div class="readable-text" id="p281">
<p>Finally, let’s look at user 223 and decide whether they better fit a “Social” or “Browsing” category. The following code looks at their data at an app level and produces the output shown in figure 12.42:</p>
</div>
<div class="browsable-container listing-container" id="p282">
<div class="code-area-container">
<pre class="code-area">(
    app_data_merged[app_data_merged["user_id"] == 223]
    .groupby(["app_category", "app_name"])
    .size()
)<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p283">
<img alt="figure" height="281" src="../Images/12-42.png" width="474"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.42</span> App-level usage data for user 223</h5>
</div>
<div class="readable-text" id="p284">
<p>This one is trickier to categorize because they make heavy use of social apps but also frequently use the Google app. However, that could mean multiple things, some of which might not fit under “Browsing,” so we’ll decide that this user better fits the “Social” label. The following code removes the necessary record. We then retest the data to verify there are no users with multiple “top app category” records:</p>
</div>
<div class="browsable-container listing-container" id="p285">
<div class="code-area-container">
<pre class="code-area">top_categories = (
    top_categories
    .drop(
        index=top_categories[
            (top_categories["user_id"] == 223)
            &amp; (top_categories["app_category"] == "Browsing")
            ].index
    )
)
top_categories["user_id"].value_counts().loc[lambda x: x &gt; 1]</pre>
</div>
</div>
<div class="readable-text" id="p286">
<p>The output of that latest snippet is an empty list, meaning we no longer have users with multiple top app categories. We can now create the indicator variables required for our clustering algorithm. The following code creates these indicator variables and produces the output in figure 12.43:</p>
</div>
<div class="browsable-container listing-container" id="p287">
<div class="code-area-container">
<pre class="code-area">top_categories = (
    pd.get_dummies(
        top_categories,
        columns=["app_category"]
    ).drop(
        columns=["level_1"]
    )
)

top_categories.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p288">
<img alt="figure" height="212" src="../Images/12-43.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.43</span> The one-hot encoded version of our “top app category by user” data</h5>
</div>
<div class="readable-text" id="p289">
<p>The data in this format is ready to be joined to the user-level data that we created in figure 12.27. Before merging the two datasets, let’s review our progress so far. The latest diagram of our analysis is shown in figure 12.44.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p290">
<img alt="figure" height="1026" src="../Images/12-44.png" width="1009"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.44</span> The latest progress in our analysis</h5>
</div>
<div class="readable-text" id="p291">
<p>We have investigated the data relating to our stakeholder questions. Now, we will merge the most frequent app category data and the most frequent browsing time data to build up our user-level dataset. We will also create and include columns from the initial analysis and have a user-level dataset ready for segmentation.</p>
</div>
<div class="readable-text" id="p292">
<h4 class="readable-text-h4 sigil_not_in_toc">Creating a user-level dataset for segmentation</h4>
</div>
<div class="readable-text" id="p293">
<p>So far, we have one user-level dataset of what times people tend to use their phones the most and another that contains the most frequent app category per user. We’ll join these together and then add other metrics. The following code merges the two datasets, and a snapshot of the merged data is shown in figure 12.45:</p>
</div>
<div class="browsable-container listing-container" id="p294">
<div class="code-area-container">
<pre class="code-area">size_before = len(users)
users = users.merge(top_categories, on="user_id")
size_after = len(users)
assert size_before == size_after
users.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p295">
<img alt="figure" height="526" src="../Images/12-45.png" width="1100"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.45</span> A snapshot of the user-level data so far</h5>
</div>
<div class="readable-text" id="p296">
<p>The initial analysis involved the number of unique apps used per user and the average length of their browsing sessions to segment the users. There is no reason not to keep these metrics in there, so let’s recreate them and join them to our current dataset. We will also add “number of sessions” as a proxy for how heavily a user uses their phone since, otherwise, that aspect of usage is not captured in any of our variables.</p>
</div>
<div class="readable-text intended-text" id="p297">
<p>First, we can add columns relating to the number of apps and sessions straight from the raw app data. The following code counts the number of unique apps and sessions per user and produces a dataset, a snapshot of which is shown in figure 12.46:</p>
</div>
<div class="browsable-container listing-container" id="p298">
<div class="code-area-container">
<pre class="code-area">user_metrics = (
    app_data_merged
    .groupby(["user_id"])
    .agg(
        number_of_apps=("app_name", "nunique"),
        number_of_sessions=("session_id", "nunique")
    )
    .reset_index()
)

user_metrics.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p299">
<img alt="figure" height="250" src="../Images/12-46.png" width="495"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.46</span> A user-level dataset counting the number of unique apps and sessions per user</h5>
</div>
<div class="readable-text" id="p300">
<p>Let’s now join this table to the dataset we created in figure 12.45. The following code achieves this:</p>
</div>
<div class="browsable-container listing-container" id="p301">
<div class="code-area-container">
<pre class="code-area">size_before = len(users)
users = users.merge(user_metrics, on="user_id")
size_after = len(users)
assert size_before == size_after</pre>
</div>
</div>
<div class="readable-text" id="p302">
<p>To add the average session length, we need to turn to the session-level data we created earlier in section 12.5.1. We will group it by user ID and calculate the median duration of each session per user. The following code does this and produces a dataset, a snapshot of which is shown in figure 12.47:</p>
</div>
<div class="browsable-container listing-container" id="p303">
<div class="code-area-container">
<pre class="code-area">avg_sessions = (
    sessions
    .groupby("user_id")
    .agg(avg_session_length=("duration_mins", "median"))
    .reset_index()
)

avg_sessions.head()<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p304">
<img alt="figure" height="275" src="../Images/12-47.png" width="345"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.47</span> Average session duration per user</h5>
</div>
<div class="readable-text" id="p305">
<p>Our final step before segmentation is to merge this table into the main user-level data. The following code does this, and figure 12.48 shows all the columns in the data we will use for segmentation:</p>
</div>
<div class="browsable-container listing-container" id="p306">
<div class="code-area-container">
<pre class="code-area">size_before = len(users)
users = users.merge(avg_sessions, on="user_id")
size_after = len(users)
assert size_before == size_after

users.columns<span class="aframe-location"/></pre>
</div>
</div>
<div class="browsable-container figure-container" id="p307">
<img alt="figure" height="181" src="../Images/12-48.png" width="1000"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.48</span> All the columns we will use to segment users</h5>
</div>
<div class="readable-text" id="p308">
<p>Let’s export this user-level data directly to the next chapter’s folder so we can start the segmentation process directly from this dataset:</p>
</div>
<div class="browsable-container listing-container" id="p309">
<div class="code-area-container">
<pre class="code-area">users.to_parquet("../chapter-13/data/users.parquet", index=False)</pre>
</div>
</div>
<div class="readable-text" id="p310">
<p>Before moving on to the segmentation part in the next chapter, let’s review everything we’ve done so far.</p>
</div>
<div class="readable-text" id="p311">
<h3 class="readable-text-h3" id="sigil_toc_id_158"><span class="num-string">12.5.3</span> Project progress so far</h3>
</div>
<div class="readable-text" id="p312">
<p>Let’s recap the progress on this project:</p>
</div>
<ul>
<li class="readable-text" id="p313"> We started by investigating the work behind the initial presentation and verified the summary statistics that were presented. </li>
<li class="readable-text" id="p314"> We continued the analysis by diving deeper into user behavior and concluded that there are distinct groups of people who use their phones at different times. </li>
<li class="readable-text" id="p315"> We used generative AI to categorize app names into broader app categories. </li>
<li class="readable-text" id="p316"> We used these app categories to identify different user behaviors based on what apps a user uses the most. </li>
<li class="readable-text" id="p317"> Finally, we exported a user-level dataset ready for segmentation in the next phase. </li>
</ul>
<div class="readable-text" id="p318">
<p>Figure 12.49 shows the entire process up to this point.<span class="aframe-location"/></p>
</div>
<div class="browsable-container figure-container" id="p319">
<img alt="figure" height="1259" src="../Images/12-49.png" width="1009"/>
<h5 class="figure-container-h5 sigil_not_in_toc"><span class="num-string">Figure 12.49</span> Parts 1 and 2 of the analysis before segmentation starts</h5>
</div>
<div class="readable-text intended-text" id="p320">
<p>In the following chapter, we will use the exported user-level data to segment users into distinct groups to answer our stakeholders’ questions.</p>
</div>
<div class="readable-text" id="p321">
<h2 class="readable-text-h2" id="sigil_toc_id_159">Summary</h2>
</div>
<ul>
<li class="readable-text" id="p322"> Continuing someone else’s work starts with retracing their steps. </li>
<li class="readable-text" id="p323"> Recreating the initial analysis helps us understand the problem and find any errors. </li>
<li class="readable-text" id="p324"> When continuing someone else’s work, their assumptions and decisions should be checked and verified. </li>
</ul>
</div></body></html>