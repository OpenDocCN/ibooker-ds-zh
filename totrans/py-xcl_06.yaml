- en: Chapter 4\. NumPy Foundations
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall from [Chapter 1](index_split_007.html#filepos32075), NumPy
    is the core package for scientific computing in Python, providing support for
    array-based calculations and linear algebra. As NumPy is the backbone of pandas,
    I am going to introduce its basics in this chapter: after explaining what a NumPy
    array is, we will look into vectorization and broadcasting, two important concepts
    that allow you to write concise mathematical code and that you will find again
    in pandas. After that, we’re going to see why NumPy offers special functions called
    universal functions before we wrap this chapter up by learning how to get and
    set values of an array and by explaining the difference between a view and a copy
    of a NumPy array. Even if we will hardly use NumPy directly in this book, knowing
    its basics will make it easier to learn pandas in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with NumPy
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll learn about one- and two-dimensional NumPy arrays and
    what’s behind the technical terms vectorization, broadcasting, and universal function.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy Array
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform array-based calculations with nested lists, as we met them in the
    last chapter, you would have to write some sort of loop. For example, to add a
    number to every element in a nested list, you can use the following nested list
    comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``1``]:``matrix``=``[[``1``,``2``,``3``],``[``4``,``5``,``6``],``[``7``,``8``,``9``]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``2``]:``[[``i``+``1``for``i``in``row``]``for``row``in``matrix``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[2]: [[2, 3, 4], [5, 6, 7], [8, 9, 10]]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This isn’t very readable and more importantly, if you do this with big arrays,
    looping through each element becomes very slow. Depending on your use case and
    the size of the arrays, calculating with NumPy arrays instead of Python lists
    can make your calculations from a couple of times to around a hundred times faster.
    NumPy achieves this performance by making use of code that was written in C or
    Fortran—these are compiled programming languages that are much faster than Python.
    A NumPy array is an N-dimensional array for homogenous data. Homogenous means
    that all elements in the array need to be of the same data type. Most commonly,
    you are dealing with one- and two-dimensional arrays of floats as schematically
    displayed in [Figure 4-1](#filepos439974).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. A one-dimensional and two-dimensional NumPy array
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a one- and two-dimensional array to work with throughout this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``3``]:``# First, let''s import NumPy``import``numpy``as``np`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``4``]:``# Constructing an array with a simple list results in a 1d array``array1``=``np``.``array``([``10``,``100``,``1000.``])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``5``]:``# Constructing an array with a nested list results in a 2d array``array2``=``np``.``array``([[``1.``,``2.``,``3.``],``[``4.``,``5.``,``6.``]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ARRAY DIMENSION
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It’s important to note the difference between a one- and two-dimensional array:
    a one-dimensional array has only one axis and hence does not have an explicit
    column or row orientation. While this behaves like arrays in VBA, you may have
    to get used to it if you come from a language like MATLAB, where one-dimensional
    arrays always have a column or row orientation.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Even if `array1` consists of integers except for the last element (which is
    a float), the homogeneity of NumPy arrays forces the data type of the array to
    be `float64`, which is capable of accommodating all elements. To learn about an
    array’s data type, access its `dtype` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``6``]:``array1``.``dtype`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[6]: dtype(''float64'')`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since `dtype` gives you back `float64` instead of `float` which we met in the
    last chapter, you may have guessed that NumPy uses its own numerical data types,
    which are more granular than Python’s data types. This usually isn’t an issue
    though, as most of the time, conversion between the different data types in Python
    and NumPy happens automatically. If you ever need to explicitly convert a NumPy
    data type to one of Python’s basic data types, simply use the corresponding constructor
    (I will say more about accessing an element from an array shortly):'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``7``]:``float``(``array1``[``0``])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[7]: 10.0`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For a full list of NumPy’s data types, see the [NumPy docs](https://oreil.ly/irDyH).
    With NumPy arrays, you can write simple code to perform array-based calculations,
    as we will see next.
  prefs: []
  type: TYPE_NORMAL
- en: Vectorization and Broadcasting
  prefs: []
  type: TYPE_NORMAL
- en: 'If you build the sum of a scalar and a NumPy array, NumPy will perform an element-wise
    operation, which means that you don’t have to loop through the elements yourself.
    The NumPy community refers to this as vectorization. It allows you to write concise
    code, practically representing the mathematical notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``8``]:``array2``+``1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[8]: array([[2., 3., 4.],                [5., 6., 7.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SCALAR
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Scalar refers to a basic Python data type like a float or a string. This is
    to differentiate them from data structures with multiple elements like lists and
    dictionaries or one- and two-dimensional NumPy arrays.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The same principle applies when you work with two arrays: NumPy performs the
    operation element-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``9``]:``array2``*``array2`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[9]: array([[ 1.,  4.,  9.],                [16., 25., 36.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you use two arrays with different shapes in an arithmetic operation, NumPy
    extends—if possible—the smaller array automatically across the larger array so
    that their shapes become compatible. This is called broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``10``]:``array2``*``array1`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[10]: array([[  10.,  200., 3000.],                 [  40.,  500., 6000.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To perform matrix multiplications or dot products, use the `@` operator:[1](#filepos482316)
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``11``]:``array2``@``array2``.``T``# array2.T is a shortcut for array2.transpose()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[11]: array([[14., 32.],                 [32., 77.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don’t be intimidated by the terminology I’ve introduced in this section such
    as scalar, vectorization, or broadcasting! If you have ever worked with arrays
    in Excel, this should all feel very natural as shown in [Figure 4-2](#filepos453704).
    The screenshot is taken from array_calculations.xlsx, which you will find in the
    xl directory of the companion repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Array-based calculations in Excel
  prefs: []
  type: TYPE_NORMAL
- en: You know now that arrays perform arithmetic operations element-wise, but how
    can you apply a function on every element in an array? This is what universal
    functions are here for.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Functions (ufunc)
  prefs: []
  type: TYPE_NORMAL
- en: 'Universal functions (ufunc) work on every element in a NumPy array. For example,
    if you use Python’s standard square root function from the `math` module on a
    NumPy array, you will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``12``]:``import``math`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``13``]:``math``.``sqrt``(``array2``)``# This will raise en Error`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last) <ipython-input-13-5c37e8f41094>
    in <module> ----> 1 math.sqrt(array2)  # This will raise en Error  TypeError:
    only size-1 arrays can be converted to Python scalars`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You could, of course, write a nested loop to get the square root of every element,
    then build a NumPy array again from the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``14``]:``np``.``array``([[``math``.``sqrt``(``i``)``for``i``in``row``]``for``row``in``array2``])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[14]: array([[1.        , 1.41421356, 1.73205081],                 [2.       
    , 2.23606798, 2.44948974]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This will work in cases where NumPy doesn’t offer a ufunc and the array is
    small enough. However, if NumPy has a ufunc, use it, as it will be much faster
    with big arrays—apart from being easier to type and read:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``15``]:``np``.``sqrt``(``array2``)`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[15]: array([[1.        , 1.41421356, 1.73205081],                 [2.       
    , 2.23606798, 2.44948974]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Some of NumPy’s ufuncs, like `sum`, are additionally available as array methods:
    if you want the sum of each column, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``16``]:``array2``.``sum``(``axis``=``0``)``# Returns a 1d array`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[16]: array([5., 7., 9.])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The argument `axis=0` refers to the axis along the rows while `axis=1` refers
    to the axis along the columns, as depicted in [Figure 4-1](#filepos439974). Leaving
    the `axis` argument away sums up the whole array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``17``]:``array2``.``sum``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[17]: 21.0`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You will meet more NumPy ufuncs throughout this book, as they can be used with
    pandas DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve always worked with the entire array. The next section shows you
    how to manipulate parts of an array and introduces a few helpful array constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Manipulating Arrays
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start this section by getting and setting specific elements of an array
    before introducing a few useful array constructors, including one to create pseudorandom
    numbers that you could use for a Monte Carlo simulation. I’ll wrap this section
    up by explaining the difference between a view and a copy of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and Setting Array Elements
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, I showed you how to index and slice lists to get access
    to specific elements. When you work with nested lists like `matrix` from the first
    example in this chapter, you can use chained indexing: `matrix[0][0]` will get
    you the first element of the first row. With NumPy arrays, however, you provide
    the index and slice arguments for both dimensions in a single pair of square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy_array``[``row_selection``,``column_selection``]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For one-dimensional arrays, this simplifies to `numpy_array[selection]`. When
    you select a single element, you will get back a scalar; otherwise, you will get
    back a one- or two-dimensional array. Remember that slice notation uses a start
    index (included) and an end index (excluded) with a colon in between, as in `start:end`.
    By leaving away the start and end index, you are left with a colon, which therefore
    stands for all rows or all columns in a two-dimensional array. I have visualized
    a few examples in [Figure 4-3](#filepos465331), but you may also want to give
    [Figure 4-1](#filepos439974) another look, as the indices and axes are labeled
    there. Remember, by slicing a column or row of a two-dimensional array, you end
    up with a one-dimensional array, not with a two-dimensional column or row vector!
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Selecting elements of a NumPy array
  prefs: []
  type: TYPE_NORMAL
- en: 'Play around with the examples shown in [Figure 4-3](#filepos465331) by running
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``18``]:``array1``[``2``]``# Returns a scalar`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[18]: 1000.0`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``19``]:``array2``[``0``,``0``]``# Returns a scalar`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[19]: 1.0`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``20``]:``array2``[:,``1``:]``# Returns a 2d array`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[20]: array([[2., 3.],                 [5., 6.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``21``]:``array2``[:,``1``]``# Returns a 1d array`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[21]: array([2., 5.])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``22``]:``array2``[``1``,``:``2``]``# Returns a 1d array`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[22]: array([4., 5.])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So far, I have constructed the sample arrays by hand, i.e., by providing numbers
    in a list. But NumPy also offers a few useful functions to construct arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Useful Array Constructors
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy offers a few ways to construct arrays that will also be helpful to create
    pandas DataFrames, as we will see in [Chapter 5](index_split_015.html#filepos482650).
    One way to easily create arrays is to use the `arange` function. This stands for
    array range and is similar to the built-in `range` that we met in the previous
    chapter—with the difference that `arange` returns a NumPy array. Combining it
    with `reshape` allows us to quickly generate an array with the desired dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``23``]:``np``.``arange``(``2``*``5``)``.``reshape``(``2``,``5``)``#
    2 rows, 5 columns`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[23]: array([[0, 1, 2, 3, 4],                 [5, 6, 7, 8, 9]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Another common need, for example for Monte Carlo simulations, is to generate
    arrays of normally distributed pseudorandom numbers. NumPy makes this easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``24``]:``np``.``random``.``randn``(``2``,``3``)``# 2 rows, 3 columns`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[24]: array([[-0.30047275, -1.19614685, -0.13652283],                 [
    1.05769357,  0.03347978, -1.2153504 ]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Other helpful constructors worth exploring are `np.ones` and `np.zeros` to create
    arrays with ones and zeros, respectively, and `np.eye` to create an identity matrix.
    We’ll come across some of these constructors again in the next chapter, but for
    now, let’s learn about the difference between a view and a copy of a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: View vs. Copy
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays return views when you slice them. This means that you are working
    with a subset of the original array without copying the data. Setting a value
    on a view will therefore also change the original array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`In``[``25``]:``array2`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[25]: array([[1., 2., 3.],                 [4., 5., 6.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``26``]:``subset``=``array2``[:,``:``2``]``subset`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[26]: array([[1., 2.],                 [4., 5.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``27``]:``subset``[``0``,``0``]``=``1000`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``28``]:``subset`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[28]: array([[1000.,    2.],                 [   4.,    5.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`In``[``29``]:``array2`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Out[29]: array([[1000.,    2.,    3.],                 [   4.,    5.,    6.]])`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If that’s not what you want, you would have to change `In [26]` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`subset``=``array2``[:,``:``2``]``.``copy``()`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Working on a copy will leave the original array unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I showed you how to work with NumPy arrays and what’s behind
    expressions such as vectorization and broadcasting. Putting these technical terms
    aside, working with arrays should feel quite intuitive given that they follow
    the mathematical notation very closely. While NumPy is an incredibly powerful
    library, there are two main issues when you want to use it for data analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: The whole NumPy array needs to be of the same data type. This, for example,
    means that you can’t perform any of the arithmetic operations we did in this chapter
    when your array contains a mix of text and numbers. As soon as text is involved,
    the array will have the data type `object`, which will not allow mathematical
    operations.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using NumPy arrays for data analysis makes it hard to know what each column
    or row refers to because you typically select columns via their position, such
    as in `array2[:, 1]`.
  prefs:
  - PREF_UL
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: pandas has solved these issues by providing smarter data structures on top of
    NumPy arrays. What they are and how they work is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[1  ](#filepos452023) If it’s been a while since your last linear algebra class,
    you can skip this example—matrix multiplication is not something this book builds
    upon.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
