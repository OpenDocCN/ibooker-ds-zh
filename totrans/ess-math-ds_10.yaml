- en: Appendix B. Exercise Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 62.6738 is rational because it has a finite number of decimal places, and therefore
    can be expressed as a fraction 626738 / 10000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <math alttext="10 Superscript 7 Baseline 10 Superscript negative 5 Baseline
    equals 10 Superscript 7 plus negative 5 Baseline equals 10 squared equals 100"><mrow><msup><mn>10</mn>
    <mn>7</mn></msup> <msup><mn>10</mn> <mrow><mo>-</mo><mn>5</mn></mrow></msup> <mo>=</mo>
    <msup><mn>10</mn> <mrow><mn>7</mn><mo>+</mo><mo>-</mo><mn>5</mn></mrow></msup>
    <mo>=</mo> <msup><mn>10</mn> <mn>2</mn></msup> <mo>=</mo> <mn>100</mn></mrow></math>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="10 Superscript 7 Baseline 10 Superscript negative 5 Baseline
    equals 10 Superscript 7 plus negative 5 Baseline equals 10 squared equals 100"><mrow><msup><mn>10</mn>
    <mn>7</mn></msup> <msup><mn>10</mn> <mrow><mo>-</mo><mn>5</mn></mrow></msup> <mo>=</mo>
    <msup><mn>10</mn> <mrow><mn>7</mn><mo>+</mo><mo>-</mo><mn>5</mn></mrow></msup>
    <mo>=</mo> <msup><mn>10</mn> <mn>2</mn></msup> <mo>=</mo> <mn>100</mn></mrow></math>
- en: <math alttext="81 Superscript one-half"><msup><mn>81</mn> <mfrac><mn>1</mn>
    <mn>2</mn></mfrac></msup></math> = <math alttext="StartRoot left-parenthesis EndRoot
    81 right-parenthesis equals 9"><mrow><msqrt><mo>(</mo></msqrt> <mrow><mn>81</mn>
    <mo>)</mo> <mo>=</mo> <mn>9</mn></mrow></mrow></math>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="81 Superscript one-half"><msup><mn>81</mn> <mfrac><mn>1</mn>
    <mn>2</mn></mfrac></msup></math> = <math alttext="StartRoot left-parenthesis EndRoot
    81 right-parenthesis equals 9"><mrow><msqrt><mo>(</mo></msqrt> <mrow><mn>81</mn>
    <mo>)</mo> <mo>=</mo> <mn>9</mn></mrow></mrow></math>
- en: <math alttext="25 Superscript three-halves Baseline equals left-parenthesis
    25 Superscript 1 slash 2 Baseline right-parenthesis cubed equals 5 cubed equals
    125"><mrow><msup><mn>25</mn> <mfrac><mn>3</mn> <mn>2</mn></mfrac></msup> <mo>=</mo>
    <msup><mrow><mo>(</mo><msup><mn>25</mn> <mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup>
    <mo>)</mo></mrow> <mn>3</mn></msup> <mo>=</mo> <msup><mn>5</mn> <mn>3</mn></msup>
    <mo>=</mo> <mn>125</mn></mrow></math>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <math alttext="25 Superscript three-halves Baseline equals left-parenthesis
    25 Superscript 1 slash 2 Baseline right-parenthesis cubed equals 5 cubed equals
    125"><mrow><msup><mn>25</mn> <mfrac><mn>3</mn> <mn>2</mn></mfrac></msup> <mo>=</mo>
    <msup><mrow><mo>(</mo><msup><mn>25</mn> <mrow><mn>1</mn><mo>/</mo><mn>2</mn></mrow></msup>
    <mo>)</mo></mrow> <mn>3</mn></msup> <mo>=</mo> <msup><mn>5</mn> <mn>3</mn></msup>
    <mo>=</mo> <mn>125</mn></mrow></math>
- en: 'The resulting amount would be $1,161.47\. The Python script is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The resulting amount would be $1161.83\. The Python script is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The derivative calculates to 6*x*, which would make the slope at *x* = 3 to
    be 18\. The SymPy code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The area under the curve between 0 and 2 is 10\. The SymPy code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 0.3 × 0.4 = 0.12; refer to [“Joint Probabilities”](ch02.xhtml#jointprobsect).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (1 – 0.3) + 0.4 – (.03 × 0.4) = 0.98; refer to [“Union Probabilities”](ch02.xhtml#unionprobsect)
    and remember we are looking for *NO RAIN* so subtract that probability from 1.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0.3 × 0.2 = 0.06; refer to [“Conditional Probability and Bayes’ Theorem”](ch02.xhtml#condprobsect).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following Python code calculates an answer of 0.822, adding up the probabilities
    of 50 or more passengers who do not show up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the beta distribution shown in the following SciPy code, get the area
    up to 0.5 and subtract it from 1.0\. Result is about 0.98, so this coin is highly
    unlikely to be fair.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mean is 1.752 and the standard deviation is approximately 0.02135\. The
    Python code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the CDF to get the value between 30 and 20 months, which is an area of
    about 0.06\. The Python code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There’s a 99% probability the average filament diameter for a roll is between
    1.7026 and 1.7285\. The Python code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The marketing campaign worked with a p-value of 0.01888\. The Python code is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vector lands on [2, 3]. The Python code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Vector lands on [0, -3]. The Python code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Determinant is 2.0\. The Python code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Yes, because matrix multiplication allows us to combine several matrices into
    a single matrix representing one consolidated transformation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*x* = 19.8, *y* = –5.4, *z* = –6\. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Yes, it is linearly dependent. Although we have some floating point imprecision
    with NumPy, the determinant is effectively 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get around the floating point issues, use SymPy and you will get 0:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many tools and approaches to perform a linear regression as we learned
    in [Chapter 5](ch05.xhtml#ch05), but here is the solution using scikit-learn.
    The slope is 1.75919315 and the intercept is 4.69359655.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We get a high correlation of 0.92421 and a test value of 23.8355 with a statistically
    significant range of ±1.9844\. This correlation is definitely useful and statistically
    significant. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At <math alttext="x equals 50"><mrow><mi>x</mi> <mo>=</mo> <mn>50</mn></mrow></math>
    , the prediction interval is between 50.79 and 134.51\. The code is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The testing datasets do moderately well when split into thirds and evaluated
    with k-fold, where *k* = 3\. You will get a mean of roughly 0.83 in MSE and a
    standard deviation of 0.03 across the three datasets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The accuracy is extremely high when you run this through scikit-learn. When
    I run it, I get at least 99.9% accuracy on average with the test folds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The confusion matrix will yield an extremely high number of true positives
    and true negatives, and very few false positives and false negatives. Run this
    code and you will see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An interactive shell for testing user-input colors is shown next. Consider testing
    black (0,0,0) and white (255,255,255) to see if dark and light fonts respectively
    are predicted correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Yes, the logistic regression is very effective at predicting light or dark fonts
    for a given background color. Not only is the accuracy extremely high, but the
    confusion matrix has high numbers in the top-right to bottom-left diagonal with
    lower numbers in the other cells.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s obviously a lot of experimenting and alchemy you can try with different
    hidden layers, activation functions, different testing dataset sizes, and so on.
    I tried to use one hidden layer with three nodes with a ReLU activation, and I
    struggled to get good predictions on my testing dataset. The confusion matrices
    and accuracy were consistently poor and any configuration changes I ran did just
    as poorly.
  prefs: []
  type: TYPE_NORMAL
- en: The reasons the neural network is probably failing are 1) the testing dataset
    is far too small for a neural network (which are extremely data-hungry) and 2)
    there are simpler and more effective models like logistic regression for this
    type of problem. That’s not to say you can’t find a configuration that will work,
    but you have to be careful not to p-hack your way to a good result that overfits
    to the little training and testing data you have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the scikit-learn code I used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
