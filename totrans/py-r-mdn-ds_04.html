<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. R for Pythonistas"><div class="chapter" id="ch03">
<h1><span class="label">Chapter 2. </span>R for Pythonistas</h1>


<p class="byline">Rick J. Scavetta</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45127464942728">
<h5>A note for Early Release readers</h5>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>
</div></aside>

<p>Welcome, brave Pythonista, to the world of the useR<sup><a data-type="noteref" id="idm45127464940616-marker" href="ch02.xhtml#idm45127464940616">1</a></sup>! In this chapter our goal is to introduce you to R’s core features and try to address some of the confusing bits that you’ll encounter along the way. Thus, it’s useful to mention what we’re <em>not</em> going to do.</p>

<p>First, we’re not writing for the naïve data scientist. If you want to learn R from scratch, there are many wonderful resources available; too many to name. We encourage you to explore them and choose those which suit your needs and learning style. Here, we’ll bring up topics and concerns that may confuse the complete novice. We’ll take some detours to explain topics that we hope will specifically help the friendly Pythonista to adapt to R more easily.</p>

<p>Second, this is not a bilingual dictionary, you’ll find that in Appendix A, but without context it’s not really useful. Here, we want to take you through a journey of exploRation and undeRstanding. We want you to get a <em>feel</em> for R so that you begin to <em>think</em> R, becoming bilingual. Thus, for the sake of narrative, we may introduce some items much later than when writing for a complete novice. Nonetheless, we hope that you’ll return back to this chapter when you need to remind yourself of how to do familiar tasks in a new language.</p>

<p>Third, This is not a comprehensive guide. Once you crack the R coconut, you’ll get plenty of enjoyment exploring the language deeper to address your specific needs as they arise. As we mentioned in the first part of the book, the R community is diverse, friendly, welcoming — and helpful! We’re convinced it’s one of the less <em>tech-bro</em> cultures out there. To get an idea of the community, you can follow <code>#rstats</code> on <a href="https://twitter.com/search?q=%23RStats">Twitter</a>.</p>






<section data-type="sect1" data-pdf-bookmark="Up and running with R"><div class="sect1" id="idm45127464933784">
<h1>Up and running with R</h1>

<p>To follow the exercises in this chapter, you can either access R online using RStudio Cloud or install R and RStudio locally. RStudio Cloud is a platform providing access to an R instance (via an RStudio IDE) and allows you to upload your own data and share projects. We’ll cover both methods in the following paragraphs.</p>

<p>To use RStudio Cloud, make an account at <a href="http://rstudio.cloud/"><em class="hyperlink">http://rstudio.cloud/</em></a> and then navigate to our <a href="https://rstudio.cloud/project/2534578">publically-available project</a>. Make sure to save a copy of the project in your workspace so that you have your own copy, you’ll see the link in the header.</p>

<p>Your RStudio session should look like figure <a data-type="xref" href="#RStudio_cloud">Figure 2-1</a>. Open <code>ch02-r4py/r4py.R</code> and that’s it! You’re ready to follow along with all the examples. To execute commands press <code>ctrl</code> + <code>enter</code> (or <code>cmd</code> + <code>enter</code>).</p>

<figure><div id="RStudio_cloud" class="figure">
<img src="Images/prds_0201.png" alt="" width="3584" height="2240"/>
<h6><span class="label">Figure 2-1. </span>Our project in RStudio Cloud.</h6>
</div></figure>

<p>To run R locally, you’ll find it’s available with the Anaconda distribution, if you use that, otherwise you can install it directly. First download and install R for your operating system from <a href="https://www.r-project.org/"><em class="hyperlink">https://www.r-project.org/</em></a>. R <code>v4.0</code> was released on in June 2020 and in contrast to Python v3.x, is backwards compatible, with a few notable exceptions. We’ll assume you’re running at least R <code>4.0.0</code>: “Taking Off Again”. Each release gets a name inspired by Peanuts (the classic comic strip and film franchise featuring Charlie Brown, Snoopy and co.). Which is a nice personal touch, I think. Next, install the RStudio Desktop IDE from <a href="https://rstudio.com/"><em class="hyperlink">https://rstudio.com/</em></a>.</p>

<p>Finally, set up a project to work on. This is a bit different from a virtual environnement, which we’ll discuss later on. There are two typical ways to make a project with pre-existing files.</p>

<p>First, if you’re using <code>git</code>, you’ll be happy to know that RStudio is also a basic <code>git</code> GUI client. In RStudio, select <code>File &gt; New project &gt; Version Control &gt; Git</code> and enter the repository URL <code><a href="https://github.com/moderndatadesign/PyR4MDS"><em class="hyperlink">https://github.com/moderndatadesign/PyR4MDS</em></a></code>. The project directory name will use the repo name automatically. Choose where you want to store the repo and click “Create Project”.</p>

<p>Second, if you’re not using <code>git</code>, you can just download and unzip the repo from <code><a href="https://github.com/moderndatadesign/PyR4MDS"><em class="hyperlink">https://github.com/moderndatadesign/PyR4MDS</em></a></code>. In RStudio, select <code>File &gt; Existing Directory</code> and navigate to the downloaded directory. A new R project file, <code>*.Rproj</code> will be created in that directory.</p>

<p>Your RStudio session should look like figure <a data-type="xref" href="#RStudio_basic">Figure 2-2</a>. Open <code>ch02-r4py/r4py.R</code> and that’s it! You’re ready to follow along with all the examples. To execute commands press <code>ctrl</code> + <code>enter</code> (or <code>cmd</code> + <code>enter</code>).</p>

<figure><div id="RStudio_basic" class="figure">
<img src="Images/prds_0202.png" alt="" width="3584" height="2240"/>
<h6><span class="label">Figure 2-2. </span>Our project in RStudio.</h6>
</div></figure>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Projects and packages"><div class="sect1" id="idm45127464933128">
<h1>Projects and packages</h1>

<p>We could begin exploring R by using a built in data set, and diving right into the Tidyverse (introduced in <a data-type="xref" href="ch01.xhtml#ch01">Chapter 1</a>) but I want to step back for a second, take a deep breath, and begin our story at the beginning. Let’s begin by reading in a simple csv file. For this, we’re going to use a data set that is actually already available in R in the <code>ggplot2</code> package. For our purposes, we’re less bothered with the actual analysis than how it’s being done in R. I’ve provided the dataset as a file in the book <a href="https://github.com/moderndatadesign/PyR4MDS">repository</a>.</p>

<p>If you set up your project correctly (see above) all you’ll need to execute is the following command. If this command doesn’t work, don’t worry, we’ll return to it shortly.</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">diamonds</code> <code class="o">&lt;-</code> <code class="nf">read.csv</code><code class="p">(</code><code class="s">"ch02-r4py/data/diamonds.csv"</code><code class="p">)</code></pre>

<p>Just like in Python, single (<code>''</code>) and double (<code>""</code>) quotation marks are interchangeable, although there is a preference for double quotation marks.</p>

<p>You should now have the file imported and available as an object in your global environment, where your user-defined objects are found. The first thing you’ll notice is that the environment pane of RStudio will display the object and already give some summary information. This lovely, simple touch is similar to the Jupyter notebook extension for VScode (see <a data-type="xref" href="ch03.xhtml#ch04">Chapter 3</a>), which also lets you view your environment. Although this is a standard feature in RStudio, viewing a list of objects when scripting in Python, or many languages for that matter, is not typical. Clicking the little blue arrow beside the object name will reveal a text description (see fig. <a data-type="xref" href="#RStudio_pulldown">Figure 2-3</a>).</p>

<figure><div id="RStudio_pulldown" class="figure">
<img src="Images/prds_0203.png" alt="" width="3584" height="2240"/>
<h6><span class="label">Figure 2-3. </span>A pulldown of a data frame.</h6>
</div></figure>

<p>Clicking on the name will open it up in an Excel-like viewer (see fig. <a data-type="xref" href="#RStudio_table">Figure 2-4</a>).</p>

<figure><div id="RStudio_table" class="figure">
<img src="Images/prds_0204.png" alt="" width="3584" height="2240"/>
<h6><span class="label">Figure 2-4. </span>A data frame in table view.</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The RStudio viewer is much nicer than Excel, since it only loads into memory what you’re seeing on the screen. You can search for specific text and filter your data here, so it’s a handy tool for getting a peek at your data.</p>

<p>Although these are nice features, some useRs consider them to be a bit too much GUI<sup><a data-type="noteref" id="idm45127464718424-marker" href="ch02.xhtml#idm45127464718424">2</a></sup> and a bit too little IDE<sup><a data-type="noteref" id="idm45127464717736-marker" href="ch02.xhtml#idm45127464717736">3</a></sup>. Pythonistas would mostly agree and some criticize the user experience of RStudio because of this. I partly, agree, since I’ve seen how it can encourage bad practices. For example, to import your data set, you could have also clicked on the “import dataset…” button. This can be convenient if you’re having a really hard time parsing through the file’s structure, but it leads to undocumented, non-reproducible actions which are extremely frustrating since scripts/projects will not be self-contained. The command to import the file will be executed in the console, and visible in the history panel, but it will <em>not</em> appear in the script unless you explicitly copy it. This results in object in the environment which are not defined in the script. However, remember that RStudio is not R. You can use R with other text editors (for example the <a href="https://ess.r-project.org/">ESS</a> (“emacs speaks statistics”) extension for emacs).</p>
</div>

<p>If you couldn’t import your data with the above command, either (i) the file doesn’t exist in that directory, or (ii) you’re working in the wrong <em>working directory</em>, which is more likely. You may be tempted to write something terrible, like this:</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">diamonds</code> <code class="o">&lt;-</code> <code class="nf">read.csv</code><code class="p">(</code><code class="s">"ch02-r4py/data/diamonds.csv"</code><code class="p">)</code></pre>

<p>You’ll be familiar with avoiding the use of hard-coded paths when using virtual environments with Python. Using relative paths, as we did earlier, ensures that our file directory contains all necessary data files. Neither the working directory nor the project are virtual environments, but they are nonetheless very handy, so let’s check them out!</p>

<p>The working directory is the first place R looks for a file. When you use R projects, the working directory is wherever you have the <code>*.Rproj</code> file. Thus, <code>ch02-r4py</code> is a sub-directory in our working directory. It doesn’t matter what the working directory is called or where it is. You can move the entire project anywhere on your computer and it will still <em>just work</em> once you open the project (the <code>*.Rproj</code> file) in RStudio.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you’re not using R projects, then your working directory will likely be your home directory, displayed as <code>project: (None)</code> in RStudio. This is terrible because you’ll have to specify the entire path to your file instead of just the sub-directories within your project. You’ll find the command <code>getwd()</code> to <em>get</em>, and <code>setwd()</code> to <em>set</em> the working directory in many outdated tutorials. Please don’t use these commands! They result in the same problems of hard-coding full file paths.</p>
</div>

<p>Let’s return to our command <code>diamonds &lt;- read.csv("ch02-r4py/data/diamonds.csv")</code>. You’ll already notice some things that will confuse and/or aggravate the seasoned Pythonista. Three things in particular stand out.</p>

<p>First, notice that it’s common place, and even preferred, to use <code>&lt;-</code> as the assign operator in R. You can use <code>=</code>, as in Python, and indeed you’ll see prominent and experienced useRs do this, but <code>&lt;-</code> is more explicit as <em>assign to object</em> since <code>=</code> is also used to assign values to arguments in function calls, and we all know how much Pythonistas love being explicit!</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>&lt;-</code> assign operator is actually a legacy operator stemming from the pre-standardized QWERTY keyboard where the <code>&lt;-</code> didn’t mean <em>move the cursor one space to the left</em> but literally, make <code>&lt;-</code> appear.</p>
</div>

<p>Second, notice that the function name is <code>read.csv()</code>, nope, that’s not a typo. <code>csv()</code> is not a <em>method</em> of object <em>read</em>, nor is it a <em>function</em> of <em>module</em> <code>read</code>. Both are completely acceptable interpretations if this was a Python command. In R, with a few, but notable, exceptions, <code>.</code> doesn’t mean anything special. It’s a bit annoying if you’re used to more OOP<sup><a data-type="noteref" id="idm45127465528184-marker" href="ch02.xhtml#idm45127465528184">4</a></sup>-oriented languages where <code>.</code> is a special character.</p>

<p>Finally, you’ll notice that we didn’t initialize any packages to accomplish this task. The <code>read.*()</code> function variants are a part of base R. Interestingly, there are newer and more convenient ways of reading in files if these functions don’t satisfy your needs. e.g. the <code>read_csv()</code> function is in the <code>readr</code> package. We know you’re excited to see that <code>_</code>!</p>

<p>In general, when you see simple functions with <code>.</code> these are old base R functions created when nobody worried that it would be confusing to have <code>.</code> in the names. Functions from the newer Tidyverse packages, e.g.  <code>readr</code>, tend to use <code>_</code> (see <a data-type="xref" href="ch01.xhtml#ch01">Chapter 1</a>). They basically do the same thing, but with some slight tweaks to make them more user-friendly.</p>

<p>Let’s see this in action with <code>readr</code>. Just like in Python, you’ll need to <em>install</em> the package. This is typically done directly in the R console, there is no <code>pip</code> equivalent in R.</p>

<p>Use the following command:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">install.packages</code><code class="p">(</code><code class="s">"tidyverse"</code><code class="p">)</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In RStudio, you can install packages by using to the “Packages” panel in the lower-right pane and clicking on the “Install” button. Type in <code>tidyverse</code> and make sure that the “install all dependencies” box is checked and click OK. If you go this route, refrain from clicking on the checkboxes beside the names of the installed packages. This will initialize the package, but not record it in your script.</p>
</div>

<p>This will by default install packages and their dependencies from CRAN, the repository of official R packages. Official packages have undergone quality control and are hosted on mirrored servers around the world. The first time you do this, you’ll be asked to choose a mirror site to install from. For the most part it doesn’t matter which one you choose.  You’ll see a lot of red text as the core Tidyverse packages and all their dependencies are installed. This is mostly just a convenient way to get lots of useful packages installed all at once.</p>

<p>The most common problem in installing packages is to not have write permission in the packages directory. This will prompt you to create a personal library. You can always check where your packages are installed by using</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">.libPaths</code><code class="p">()</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"/Library/Frameworks/R.framework/Versions/4.0/Resources/library"</code></pre>

<p>If you have a personal library, it will be shown here in the second position.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In contrast to Pythonistas, who tend to use virtual environments, useRs typically install a package once, making it available system-wide. After many false starts in trying to implement a solution for project-specific libraries in R, the current favorite is the <code>renv</code> <a href="https://rstudio.github.io/renv/articles/renv.html">package</a>, i.e. <em>R environments</em>.</p>
</div>

<p>As in Python, after installing a package, it needs to be initialized in each new R session. When we say <em>initialize</em>, or <em>load</em>, a package, what we’re really saying is “use the <code>library()</code> function to <em>load</em> an installed package and then <em>attach</em> it to the namespace, i.e. the global environment”. All your packages comprise your <em>library</em>, hence <code>library()</code>. The core suite of packages in the Tidyverse can be loaded using <code>library(tidyverse)</code>. That is commonplace, and for the most part not a problem, but you may want to get into the habit of loading only those packages that you actually require instead of filling up your environment needlessly. Let’s start with <code>readr</code>, which contains the <code>read_csv()</code> function.</p>

<pre data-type="programlisting" data-code-language="r"><code class="c1"># R</code>
<code class="nf">library</code><code class="p">(</code><code class="n">readr</code><code class="p">)</code></pre>

<p>This is the equivalent of:</p>

<pre data-type="programlisting" data-code-language="python"><code class="c1"># Python equivalent</code>
<code class="kn">import</code> <code class="nn">readr</code></pre>

<p>Although R uses OOP, it’s mostly operating in the background, hence you’ll never see strange aliases for packages like:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">readr</code> <code class="kn">as</code> <code class="nn">rr</code></pre>

<p>That’s just a foreign concept in R. After you have <em>attached</em> the package all functions and datasets in that package are available in your global environment.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>This calls to mind another legacy function that you may see floating around. You must absolutely avoid <code>attach()</code> (and for the most part its counterpart <code>detach()</code>). This function allows you to <em>attach</em> an object to your global environment, much like how we attached a package. Thus, you can call elements within the object directly, without first specifying the object name explicitly, like how we call functions within a package without having to explicitly call the package name every time. The reason this has fallen out of favor is that you’re likely to have many data objects that you want to access, so conflicting names are likely to be an issue (i.e. leading to <em>masking</em> of objects). Plus, it’s just not explicit.</p>
</div>

<p>I want to address one other issue with loading packages before we continue. You’ll often see:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">require</code><code class="p">(</code><code class="n">readr</code><code class="p">)</code></pre>

<p><code>require()</code> will load an installed package and also return a <code>TRUE/FALSE</code> based on success. This is useful for testing if a package exists, and so should be reserved for those instances where that is necessary. For the most part you want to use <code>library()</code>.</p>

<p>Alright, let’s read in our data set again, this time using <code>read_csv()</code> to make some simple comparisons between the two methods.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds_2</code> <code class="o">&lt;-</code> <code class="nf">read_csv</code><code class="p">(</code><code class="s">"R4Py/diamonds.csv"</code><code class="p">)</code>
<code class="n">Parsed</code> <code class="n">with</code> <code class="n">column</code> <code class="n">specification</code><code class="o">:</code>
<code class="nf">cols</code><code class="p">(</code>
  <code class="n">carat</code> <code class="o">=</code> <code class="nf">col_double</code><code class="p">(),</code>
  <code class="n">cut</code> <code class="o">=</code> <code class="nf">col_character</code><code class="p">(),</code>
  <code class="n">color</code> <code class="o">=</code> <code class="nf">col_character</code><code class="p">(),</code>
  <code class="n">clarity</code> <code class="o">=</code> <code class="nf">col_character</code><code class="p">(),</code>
  <code class="n">depth</code> <code class="o">=</code> <code class="nf">col_double</code><code class="p">(),</code>
  <code class="n">table</code> <code class="o">=</code> <code class="nf">col_double</code><code class="p">(),</code>
  <code class="n">price</code> <code class="o">=</code> <code class="nf">col_double</code><code class="p">(),</code>
  <code class="n">x</code> <code class="o">=</code> <code class="nf">col_double</code><code class="p">(),</code>
  <code class="n">y</code> <code class="o">=</code> <code class="nf">col_double</code><code class="p">(),</code>
  <code class="n">z</code> <code class="o">=</code> <code class="nf">col_double</code><code class="p">()</code>
<code class="p">)</code></pre>

<p>You’ll notice that we’re afforded a more detailed account of what’s happened.</p>

<p>As we mentioned earlier, Tidyverse design choices tend to be more user-friendly than older processes they update. This output tells us the column names of our tabular data and their types (see <a data-type="xref" href="#data_types">Table 2-2</a>).</p>

<p>Also note that the current trend in R is to use snake case, underscores (“_”) between words and only lower case letters. Although there has classically been poor adherence to a style guide in R, the <a href="http://adv-r.had.co.nz/Style.html">Advanced R book</a> offers good suggestions. Google also attempted to promote an <a href="https://google.github.io/styleguide/Rguide.html">R style guide</a>, but it doesn’t seem that the community is very strict on this issue. This is in contrast to a strict adherence to the PEP 8 Style Guide for Python Code, authored by Guido van Rossum and released in the early days of Python.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="The triumph of tibbles"><div class="sect1" id="idm45127464904856">
<h1>The triumph of tibbles</h1>

<p>So far, we’ve imported our data twice, using two different commands. This was done so that you can see some of how R works under-the-hood and some typical behavior of the Tidyverse versus base package. We already mentioned that you can click on the object in the Environment Viewer to look at it, but it’s also typical to just print it to the console. You may be tempted to execute:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">print</code><code class="p">(</code><code class="n">diamonds</code><code class="p">)</code></pre>

<p>But the <code>print()</code> function is not necessary except in specific cases, like within a <code>for</code> loop. As with a Jupyter notebook, you can just execute the object name, e.g.:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds</code></pre>

<p>This will print the object to the console. We won’t reproduce it here, but if you do execute the above command, you’ll notice that this is not a nice output! Indeed, one wonders why the default output allows so much to be printed to the console in interactive mode. Now try with the data frame we read in using <code>read_csv()</code>:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds_2</code>
<code class="c1"># A tibble: 53,940 x 10</code>
   <code class="n">carat</code> <code class="n">cut</code>       <code class="n">color</code> <code class="n">clarity</code> <code class="n">depth</code> <code class="n">table</code> <code class="n">price</code>     <code class="n">x</code>     <code class="n">y</code>     <code class="n">z</code>
   <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code>     <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code>   <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code>
 <code class="m">1</code> <code class="m">0.23</code>  <code class="n">Ideal</code>     <code class="n">E</code>     <code class="n">SI2</code>      <code class="m">61.5</code>    <code class="m">55</code>   <code class="m">326</code>  <code class="m">3.95</code>  <code class="m">3.98</code>  <code class="m">2.43</code>
 <code class="m">2</code> <code class="m">0.21</code>  <code class="n">Premium</code>   <code class="n">E</code>     <code class="n">SI1</code>      <code class="m">59.8</code>    <code class="m">61</code>   <code class="m">326</code>  <code class="m">3.89</code>  <code class="m">3.84</code>  <code class="m">2.31</code>
 <code class="m">3</code> <code class="m">0.23</code>  <code class="n">Good</code>      <code class="n">E</code>     <code class="n">VS1</code>      <code class="m">56.9</code>    <code class="m">65</code>   <code class="m">327</code>  <code class="m">4.05</code>  <code class="m">4.07</code>  <code class="m">2.31</code>
 <code class="m">4</code> <code class="m">0.290</code> <code class="n">Premium</code>   <code class="n">I</code>     <code class="n">VS2</code>      <code class="m">62.4</code>    <code class="m">58</code>   <code class="m">334</code>  <code class="m">4.2</code>   <code class="m">4.23</code>  <code class="m">2.63</code>
 <code class="m">5</code> <code class="m">0.31</code>  <code class="n">Good</code>      <code class="n">J</code>     <code class="n">SI2</code>      <code class="m">63.3</code>    <code class="m">58</code>   <code class="m">335</code>  <code class="m">4.34</code>  <code class="m">4.35</code>  <code class="m">2.75</code>
 <code class="m">6</code> <code class="m">0.24</code>  <code class="n">Very</code> <code class="n">Good</code> <code class="n">J</code>     <code class="n">VVS2</code>     <code class="m">62.8</code>    <code class="m">57</code>   <code class="m">336</code>  <code class="m">3.94</code>  <code class="m">3.96</code>  <code class="m">2.48</code>
 <code class="m">7</code> <code class="m">0.24</code>  <code class="n">Very</code> <code class="n">Good</code> <code class="n">I</code>     <code class="n">VVS1</code>     <code class="m">62.3</code>    <code class="m">57</code>   <code class="m">336</code>  <code class="m">3.95</code>  <code class="m">3.98</code>  <code class="m">2.47</code>
 <code class="m">8</code> <code class="m">0.26</code>  <code class="n">Very</code> <code class="n">Good</code> <code class="n">H</code>     <code class="n">SI1</code>      <code class="m">61.9</code>    <code class="m">55</code>   <code class="m">337</code>  <code class="m">4.07</code>  <code class="m">4.11</code>  <code class="m">2.53</code>
 <code class="m">9</code> <code class="m">0.22</code>  <code class="n">Fair</code>      <code class="n">E</code>     <code class="n">VS2</code>      <code class="m">65.1</code>    <code class="m">61</code>   <code class="m">337</code>  <code class="m">3.87</code>  <code class="m">3.78</code>  <code class="m">2.49</code>
<code class="m">10</code> <code class="m">0.23</code>  <code class="n">Very</code> <code class="n">Good</code> <code class="n">H</code>     <code class="n">VS1</code>      <code class="m">59.4</code>    <code class="m">61</code>   <code class="m">338</code>  <code class="m">4</code>     <code class="m">4.05</code>  <code class="m">2.39</code>
<code class="c1"># … with 53,930 more rows</code></pre>

<p>Wow! That’s a much nicer output than the default base R version. We have a neat little table with the names of the columns on one row, and 3-letter codes for the data types below that in <code>&lt;&gt;</code>. We only see the first 10 rows and then a note telling us how much we’re not seeing. If there were too many columns for our screen, we’d see them listed at the bottom. Give that a try, set your console output to be very narrow and execute the command again:</p>

<pre data-type="programlisting" data-code-language="r"><code class="c1"># A tibble: 53,940 x 10</code>
   <code class="n">carat</code> <code class="n">cut</code>     <code class="n">color</code> <code class="n">clarity</code>
   <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code>   <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code>
 <code class="m">1</code> <code class="m">0.23</code>  <code class="n">Ideal</code>   <code class="n">E</code>     <code class="n">SI2</code>
 <code class="m">2</code> <code class="m">0.21</code>  <code class="n">Premium</code> <code class="n">E</code>     <code class="n">SI1</code>
 <code class="m">3</code> <code class="m">0.23</code>  <code class="n">Good</code>    <code class="n">E</code>     <code class="n">VS1</code>
 <code class="m">4</code> <code class="m">0.290</code> <code class="n">Premium</code> <code class="n">I</code>     <code class="n">VS2</code>
 <code class="m">5</code> <code class="m">0.31</code>  <code class="n">Good</code>    <code class="n">J</code>     <code class="n">SI2</code>
 <code class="m">6</code> <code class="m">0.24</code>  <code class="n">Very</code> <code class="n">G</code>… <code class="n">J</code>     <code class="n">VVS2</code>
 <code class="m">7</code> <code class="m">0.24</code>  <code class="n">Very</code> <code class="n">G</code>… <code class="n">I</code>     <code class="n">VVS1</code>
 <code class="m">8</code> <code class="m">0.26</code>  <code class="n">Very</code> <code class="n">G</code>… <code class="n">H</code>     <code class="n">SI1</code>
 <code class="m">9</code> <code class="m">0.22</code>  <code class="n">Fair</code>    <code class="n">E</code>     <code class="n">VS2</code>
<code class="m">10</code> <code class="m">0.23</code>  <code class="n">Very</code> <code class="n">G</code>… <code class="n">H</code>     <code class="n">VS1</code>
<code class="c1"># … with 53,930 more rows,</code>
<code class="c1">#   and 6 more variables:</code>
<code class="c1">#   depth &lt;dbl&gt;, table &lt;dbl&gt;,</code>
<code class="c1">#   price &lt;dbl&gt;, x &lt;dbl&gt;,</code>
<code class="c1">#   y &lt;dbl&gt;, z &lt;dbl&gt;</code></pre>

<p>Base R was already pretty good for Exploratory Data Analysis (EDA), but this is next level convenience. So what happened? Actually understanding this is pretty important, but first we want to highlight two other interesting points.</p>

<p>First, notice that we didn’t need to load all of <code>readr</code> to gain access to the <code>read_csv()</code> function. We could have left out <code>library(readr)</code> and just used:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds_2</code> <code class="o">&lt;-</code> <code class="n">readr</code><code class="o">::</code><code class="nf">read_csv</code><code class="p">(</code><code class="s">"R4Py/diamonds.csv"</code><code class="p">)</code></pre>

<p>The double-colon operator <code>::</code> is used to access functions within a package. It’s akin to:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">pandas</code> <code class="kn">import</code> <code class="n">read_csv</code></pre>

<p>You’ll see <code>::</code> used when useRs know that they’ll only need one very specific function from a package, or that functions in two packages may conflict with each other, so they want to avoid attaching an entire package to their namespace.</p>

<p>Second, this is the first time we see actual data in R and we can tell right away that numbering begins with 1! (and why wouldn’t it?).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Just as an aside for printing objects to the screen. You’ll often see round brackets around an entire expression. This just means to execute the expression and print the object to the screen.</p>

<pre data-type="programlisting" data-code-language="r"><code class="p">(</code><code class="n">aa</code> <code class="o">&lt;-</code> <code class="m">8</code><code class="p">)</code></pre>

<p>It mostly just clutters up commands. Unless it’s necessary, just explicitly call the object.</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">aa</code> <code class="o">&lt;-</code> <code class="m">8</code>
<code class="n">aa</code></pre>

<p>Plus, it’s easier to just comment out (use ctrl+shift+c in RStudio) the print line instead of having to go back and remove all those extra brackets.</p>
</div>

<p>Ok, so let’s get to the heart of what’s happening here. Why do <code>diamonds</code> and <code>diamonds_2</code> <em>look</em> so different when printed to the console. Answering this question will help us to understand a bit about how R handles objects. To answer this question, let’s take a look at the class of these objects:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">class</code><code class="p">(</code><code class="n">diamonds</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"data.frame"</code></pre>

<pre data-type="programlisting" data-code-language="r"><code class="nf">class</code><code class="p">(</code><code class="n">diamonds_2</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"spec_tbl_df"</code> <code class="s">"tbl_df"</code>      <code class="s">"tbl"</code>         <code class="s">"data.frame"</code></pre>

<p>You’ll be familiar with a <code>data.frame</code> from <code>pandas.DataFrame</code> (ok, can we just admit that a <code>pandas</code> <code>DataFrame</code> is just a Python implementation of an R <code>data.frame</code>?). But using the Tidyverse <code>read_csv()</code> function produced an object with three additional classes. The two to mention here are the sub-class <code>tbl_df</code> and the class <code>tbl</code>, the two go hand-in-hand for defining a <em>tibble</em> (hence <code>tbl</code>) which has a data frame structure <code>tbl_df</code>.</p>

<p>Tibbles are a core feature of the Tidyverse and have many perks over base R objects. For example, printing to the console. Recall that calling an object name is just a shortcut for calling <code>print()</code>. <code>print()</code> in turn has a method to handle data frames and now that we’ve attached the <code>readr</code> package, it now has a method to handle objects of class <code>tbl_df</code>.</p>

<p>So here we see OOP principles operating in the background implicitly handling object classes and calling the methods appropriate to a given class. Convenient! Confusing? Implicit! I can see why Pythonistas get annoyed, but once you get over it, you see that you can just get on with your work without too much hassle.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="A word about types and exploring"><div class="sect1" id="idm45127464226024">
<h1>A word about types and exploring</h1>

<p>Let’s take a deeper look at our data and see how R stores and handles data. A data frame is a 2-dimensional heterogenous data structure. It sounds simple, but let’s break it down a bit further.</p>
<table id="example_dataframe">
<caption><span class="label">Table 2-1. </span>Example Dataframe</caption>
<thead>
<tr>
<th>Name</th>
<th>Number of dimensions</th>
<th>Type of data</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Vector</p></td>
<td><p>1</p></td>
<td><p>Homogeneous</p></td>
</tr>
<tr>
<td><p>List</p></td>
<td><p>1</p></td>
<td><p>Heterogeneous</p></td>
</tr>
<tr>
<td><p>Data Frame</p></td>
<td><p>2</p></td>
<td><p>Heterogeneous</p></td>
</tr>
<tr>
<td><p>Matrix</p></td>
<td><p>2</p></td>
<td><p>Homogeneous</p></td>
</tr>
<tr>
<td><p>Array</p></td>
<td><p>n</p></td>
<td><p>Homogeneous</p></td>
</tr>
</tbody>
</table>

<p>Vectors are the most basic form of data storage. They are 1-dimensional and homogeneous. That is, one element after another, where every element is of the same type. It’s like a 1-dimensional <code>numpy</code> array composed solely of scalars. We don’t refer to scalars in R, that’s just a 1-element long vector. There are many <em>types</em> in R, and 4 commonly-used “user-defined atomic vector types”. The term “atomic” already tells us that it doesn’t get any more basic than what we find in <a data-type="xref" href="#data_types">Table 2-2</a>.</p>
<table id="data_types">
<caption><span class="label">Table 2-2. </span>Data Types</caption>
<thead>
<tr>
<th>Type</th>
<th>Data frame shorthand</th>
<th>Tibble shorthand</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Logical</p></td>
<td><p>logi</p></td>
<td><p>&lt;lgl&gt;</p></td>
<td><p>Binary TRUE/FALSE, T/F, 1/0</p></td>
</tr>
<tr>
<td><p>Integer</p></td>
<td><p>int</p></td>
<td><p>&lt;int&gt;</p></td>
<td><p>Whole numbers from [-Inf,Inf]</p></td>
</tr>
<tr>
<td><p>Double</p></td>
<td><p>num</p></td>
<td><p>&lt;dbl&gt;</p></td>
<td><p>Real numbers from [-Inf,Inf]</p></td>
</tr>
<tr>
<td><p>Character</p></td>
<td><p>chr</p></td>
<td><p>&lt;chr&gt;</p></td>
<td><p>All alpha-numeric characters, including white spaces.</p></td>
</tr>
</tbody>
</table>

<p>The two other, less common, user-defined atomic vector types are <code>raw</code> and <code>complex</code>.</p>

<p>Vectors are fundamental building blocks. There are a few things to note about vectors, so let’s get that out of the way before we return to the workhorse of data science, the beloved data frame.</p>

<p>The four user-defined atomic vector types listed in <a data-type="xref" href="#data_types">Table 2-2</a> are ordered according to increasing levels of information content. When you create a vector, R will try to find the lowest information-content type that can encompass all the information in that vector. e.g. logical:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">a</code> <code class="o">&lt;-</code> <code class="nf">c</code><code class="p">(</code><code class="kc">TRUE</code><code class="p">,</code> <code class="kc">FALSE</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nf">typeof</code><code class="p">(</code><code class="n">a</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"logical"</code></pre>

<p><code>logical</code>, is R’s equivalent of <code>bool</code>, but is very rarely referred to as boolean or binary. Also, note that <code>T</code> and <code>F</code> are not in themselves reserved terms in R, and so they are not recommended for logical vectors, although they are valid. Use <code>TRUE</code> and <code>FALSE</code> instead. Let’s take a look at numbers:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">b</code> <code class="o">&lt;-</code> <code class="nf">c</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nf">typeof</code><code class="p">(</code><code class="n">b</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"double"</code></pre>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">c</code> <code class="o">&lt;-</code> <code class="nf">c</code><code class="p">(</code><code class="m">3.14</code><code class="p">,</code> <code class="m">6.8</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nf">typeof</code><code class="p">(</code><code class="n">c</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"double"</code></pre>

<p>R will automatically convert between double and integer as needed. Math is performed primarily using double-precision, which is reflected in the data frame shorthand for double being displayed as <code>numeric</code>. Unless you explicitly need to restrict a number to be a true integer, then numeric/double will be fine. If you do want to restrict values to be integer, you can <em>coerce</em> them to a specific type using one of the <code>as.*()</code> function, or use the <code>L</code> suffix to specify that a number must be an integer.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">b</code> <code class="o">&lt;-</code> <code class="nf">as.integer</code><code class="p">(</code><code class="nf">c</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">))</code>
<code class="o">&gt;</code> <code class="nf">typeof</code><code class="p">(</code><code class="n">b</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"integer"</code></pre>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">b</code> <code class="o">&lt;-</code> <code class="nf">c</code><code class="p">(</code><code class="m">1L</code><code class="p">,</code> <code class="m">2L</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nf">typeof</code><code class="p">(</code><code class="n">b</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"integer"</code></pre>

<p>Characters are R’s version of strings. You’ll know this as <code>str</code> in Python, which is, confusingly, a common R function, <code>str()</code>, which gives the <em>structure</em> of an object. Characters are also frequently referred to as strings in R, including in arguments and package names, which is an unfortunate inconsistency.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">d</code> <code class="o">&lt;-</code> <code class="nf">c</code><code class="p">(</code><code class="s">"a"</code><code class="p">,</code> <code class="s">"b"</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nf">typeof</code><code class="p">(</code><code class="n">d</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"character"</code></pre>

<p>Putting these together in a vanilla data frame using <code>data.frame()</code> or using the more recently developed tibble using <code>tibble()</code>, gives us:</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">my_tibble</code> <code class="o">&lt;-</code> <code class="nf">tibble</code><code class="p">(</code><code class="n">a</code> <code class="o">=</code> <code class="nf">c</code><code class="p">(</code><code class="bp">T</code><code class="p">,</code> <code class="bp">F</code><code class="p">),</code>
                    <code class="n">b</code> <code class="o">=</code> <code class="nf">c</code><code class="p">(</code><code class="m">1L</code><code class="p">,</code> <code class="m">2L</code><code class="p">),</code>
                    <code class="n">c</code> <code class="o">=</code> <code class="nf">c</code><code class="p">(</code><code class="m">3.14</code><code class="p">,</code> <code class="m">6.8</code><code class="p">),</code>
                    <code class="n">d</code> <code class="o">=</code> <code class="nf">c</code><code class="p">(</code><code class="s">"a"</code><code class="p">,</code> <code class="s">"b"</code><code class="p">))</code>
<code class="n">my_tibble</code></pre>

<pre data-type="programlisting" data-code-language="r"><code class="c1"># A tibble: 2 x 4</code>
  <code class="n">a</code>         <code class="n">b</code>     <code class="n">c</code> <code class="n">d</code>
  <code class="o">&lt;</code><code class="n">lgl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">int</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code>
<code class="m">1</code> <code class="kc">TRUE</code>      <code class="m">1</code>  <code class="m">3.14</code> <code class="n">a</code>
<code class="m">2</code> <code class="kc">FALSE</code>     <code class="m">2</code>  <code class="m">6.8</code>  <code class="n">b</code></pre>

<p>Notice we get the nice output from <code>print()</code> since it’s a tibble. When we look at the <em>structure</em>, we’ll see some confusing features:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">str</code><code class="p">(</code><code class="n">my_tibble</code><code class="p">)</code>
<code class="n">tibble</code> <code class="p">[</code><code class="m">2</code> × <code class="m">4</code><code class="nf">] </code><code class="p">(</code><code class="n">S3</code><code class="o">:</code> <code class="n">tbl_df</code><code class="o">/</code><code class="n">tbl</code><code class="o">/</code><code class="n">data.frame</code><code class="p">)</code>
 <code class="o">$</code> <code class="n">a</code><code class="o">:</code> <code class="n">logi</code> <code class="p">[</code><code class="m">1</code><code class="o">:</code><code class="m">2</code><code class="p">]</code> <code class="kc">TRUE</code> <code class="kc">FALSE</code>
 <code class="o">$</code> <code class="n">b</code><code class="o">:</code> <code class="n">int</code> <code class="p">[</code><code class="m">1</code><code class="o">:</code><code class="m">2</code><code class="p">]</code> <code class="m">1</code> <code class="m">2</code>
 <code class="o">$</code> <code class="n">c</code><code class="o">:</code> <code class="n">num</code> <code class="p">[</code><code class="m">1</code><code class="o">:</code><code class="m">2</code><code class="p">]</code> <code class="m">3.14</code> <code class="m">6.8</code>
 <code class="o">$</code> <code class="n">d</code><code class="o">:</code> <code class="n">chr</code> <code class="p">[</code><code class="m">1</code><code class="o">:</code><code class="m">2</code><code class="p">]</code> <code class="s">"a"</code> <code class="s">"b"</code></pre>

<p><code>str()</code> a classic base package function and gives some bare bones output, it’s similar to what you’ll see when you click on the reveal arrow beside the objects name in the environment panel. The first row gives the object’s class (which we already saw above). S3 refers to the specific OOP system that this object uses, which in this case is the most basic and un-strict OOP system.</p>

<p>Alternatively, we can also use the Tidyverse <code>glimpse()</code> function, from the <code>dplyr</code> package.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">library</code><code class="p">(</code><code class="n">dplyr</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nf">glimpse</code><code class="p">(</code><code class="n">my_tibble</code><code class="p">)</code>
<code class="n">Rows</code><code class="o">:</code> <code class="m">2</code>
<code class="n">Columns</code><code class="o">:</code> <code class="m">4</code>
<code class="o">$</code> <code class="n">a</code> <code class="o">&lt;</code><code class="n">lgl</code><code class="o">&gt;</code> <code class="kc">TRUE</code><code class="p">,</code> <code class="kc">FALSE</code>
<code class="o">$</code> <code class="n">b</code> <code class="o">&lt;</code><code class="n">int</code><code class="o">&gt;</code> <code class="m">1</code><code class="p">,</code> <code class="m">2</code>
<code class="o">$</code> <code class="n">c</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="m">3.14</code><code class="p">,</code> <code class="m">6.80</code>
<code class="o">$</code> <code class="n">d</code> <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code> <code class="s">"a"</code><code class="p">,</code> <code class="s">"b"</code></pre>

<p>Notice that <a data-type="xref" href="#data_types">Table 2-2</a> also states the short hand <code>num</code> which does not appear in the output of <code>glimpse()</code>. This refers to the the “numeric” class, which refers to either double (for double-precision floating-point numbers) or integer type.</p>

<p>The above examples showed us that a <code>data.frame</code> is a heterogenous, 2-dimensional collection of homogeneous 1-dimensional vectors, each having the same length. We’ll get to why R prints all those dollar signs below (and no, it has nothing to do with your salary!)</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Naming (internal) things"><div class="sect1" id="idm45127463904680">
<h1>Naming (internal) things</h1>

<p>We already mentioned that snake case is the current trend in naming objects in R. However, naming columns in a data frame is a different beast altogether since we just inherit names from the first line of the source file. Data frames in base R, obtained e.g. using the <code>read.*()</code> family of functions or manually created using the <code>data.frame()</code> function doesn’t allow for any “illegal” characters. Illegal characters include all white spaces and all reserved characters in R, e.g.:</p>

<ul>
<li>
<p>Arithmetic operators (<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, etc.),</p>
</li>
<li>
<p>Logical operators (<code>&amp;</code>, <code>|</code>, etc.),</p>
</li>
<li>
<p>Relational operators (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, etc.)</p>
</li>
<li>
<p>Brackets, (<code>[</code>, <code>(</code>, <code>{</code>, <code>&lt;</code> and their closers)</p>
</li>
</ul>

<p>In addition, although they can <em>contain</em> numbers, they can’t <em>begin</em> with numbers. Let’s see what happens:</p>

<pre data-type="programlisting" data-code-language="r"><code class="c1"># Base package version</code>
<code class="nf">data.frame</code><code class="p">(</code><code class="s">"Weight (g)"</code> <code class="o">=</code> <code class="m">15</code><code class="p">,</code>
           <code class="s">"Group"</code> <code class="o">=</code> <code class="s">"trt1"</code><code class="p">,</code>
           <code class="s">"5-day check"</code> <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
  <code class="n">Weight..g.</code> <code class="n">Group</code> <code class="n">X5.day.check</code>
<code class="m">1</code>         <code class="m">15</code>  <code class="n">trt1</code>         <code class="kc">TRUE</code></pre>

<p>All the illegal characters have been replaced with <code>.</code>! I know, right? R is <em>really</em> having a good time mocking you OOP obsessives! On top of that, any variable that began with a number is now prefaced with an <code>X</code>.</p>

<p>So what about importing a file with no header?</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds_base_nohead</code> <code class="o">&lt;-</code> <code class="nf">read.csv</code><code class="p">(</code><code class="s">"ch02-r4py/data/diamonds_noheader.csv"</code><code class="p">,</code> <code class="n">header</code> <code class="o">=</code> <code class="bp">F</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nf">names</code><code class="p">(</code><code class="n">diamonds_base_nohead</code><code class="p">)</code>
 <code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"V1"</code>  <code class="s">"V2"</code>  <code class="s">"V3"</code>  <code class="s">"V4"</code>  <code class="s">"V5"</code>  <code class="s">"V6"</code>  <code class="s">"V7"</code>  <code class="s">"V8"</code>  <code class="s">"V9"</code>  <code class="s">"V10"</code></pre>

<p>In base R, if we don’t have any header, the given names are <code>V</code> for “variable” followed by the number of that column.</p>

<p>The same file read in with one of the <code>readr::read_*()</code> family of functions or created with <code>tibble()</code> will maintain illegal characters! This seems trivial, but it’s actually a serious critique of the Tidyverse and it’s something to pay close attention to if you start meddling in other people’s scripts. Let’s look:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">tibble</code><code class="p">(</code><code class="s">"Weight (g)"</code> <code class="o">=</code> <code class="m">15</code><code class="p">,</code>
<code class="o">+</code>            <code class="s">"Group"</code> <code class="o">=</code> <code class="s">"trt1"</code><code class="p">,</code>
<code class="o">+</code>            <code class="s">"5-day check"</code> <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
<code class="c1"># A tibble: 1 x 3</code>
  <code class="nf">`Weight </code><code class="p">(</code><code class="n">g</code><code class="p">)</code><code class="n">` Group `</code><code class="m">5</code><code class="o">-</code><code class="n">day</code> <code class="n">check`</code>
         <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">lgl</code><code class="o">&gt;</code>
<code class="m">1</code>           <code class="m">15</code> <code class="n">trt1</code>  <code class="kc">TRUE</code></pre>

<p>Notice the paired back-ticks for the column <code>Weight (g)</code> and <code>5-day check</code>? You now need to use this to escape the illegal characters. Perhaps this makes for more informative commands, since you have the full name, but you’ll likely want to maintain short and informative column names anyways. Information about the unit (e.g. g for weight) is extraneous information that belongs in a data set legend.</p>

<p>Not only that, but the names given to header-less datasets are also different:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds_tidy_nohead</code> <code class="o">&lt;-</code> <code class="nf">read_csv</code><code class="p">(</code><code class="s">"ch02-r4py/data/diamonds_noheader.csv"</code><code class="p">,</code> <code class="n">col_names</code> <code class="o">=</code> <code class="bp">F</code><code class="p">)</code>
<code class="o">&gt;</code> <code class="nf">names</code><code class="p">(</code><code class="n">diamonds_tidy_nohead</code><code class="p">)</code>
 <code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"X1"</code>  <code class="s">"X2"</code>  <code class="s">"X3"</code>  <code class="s">"X4"</code>  <code class="s">"X5"</code>  <code class="s">"X6"</code>  <code class="s">"X7"</code>  <code class="s">"X8"</code>  <code class="s">"X9"</code>  <code class="s">"X10"</code></pre>

<p>Instead of <code>V</code> we get <code>X</code>! This takes us back to the Tidyverse as a distinct dialect in R. If you inherit a script entirely in base R, you’ll have a tricky time if you just start throwing in Tidyverse functions with wild abandon. It’s like asking for a Berliner<sup><a data-type="noteref" id="idm45127460342008-marker" href="ch02.xhtml#idm45127460342008">5</a></sup> in a Berlin bakery!</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Lists"><div class="sect1" id="idm45127460609976">
<h1>Lists</h1>

<p>Lists are another common data structure, but they’re not exactly what you expect form a Python list, so the naming can be confusing. Actually, we’ve already encountered lists in our very short R journey. That’s because <code>data.frame`s are a specific class of type `list</code>. Yup, you heard that right.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">typeof</code><code class="p">(</code><code class="n">my_tibble</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"list"</code></pre>

<p><a data-type="xref" href="#example_dataframe">Table 2-1</a> tells us that a list is a 1-dimensional, heterogenous object. What that means is that every element in this 1-dimensional object can be a different type, indeed lists can contain not only vectors, but other lists, data frames, matrices, and on and on. In the case that each element is a vector of the same length, we end up with tabular data that is then class <code>data.frame</code>. Pretty convenient, right? Typically, you’ll encounter lists as the output from statistical tests, let’s take a look.</p>

<p>The <code>PlantGrowth</code> data frame is a built-in object in R. It contains two variables (i.e. elements in the list, aka columns in the tabular data): <code>weight</code> and <code>group</code>.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">glimpse</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="p">)</code>
<code class="n">Rows</code><code class="o">:</code> <code class="m">30</code>
<code class="n">Columns</code><code class="o">:</code> <code class="m">2</code>
<code class="o">$</code> <code class="n">weight</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="m">4.17</code><code class="p">,</code> <code class="m">5.58</code><code class="p">,</code> <code class="m">5.18</code><code class="p">,</code> <code class="m">6.11</code><code class="p">,</code> <code class="m">4.50</code><code class="p">,</code> <code class="m">4.6</code>…
<code class="o">$</code> <code class="n">group</code>  <code class="o">&lt;</code><code class="n">fct</code><code class="o">&gt;</code> <code class="n">ctrl</code><code class="p">,</code> <code class="n">ctrl</code><code class="p">,</code> <code class="n">ctrl</code><code class="p">,</code> <code class="n">ctrl</code><code class="p">,</code> <code class="n">ctrl</code><code class="p">,</code> <code class="n">ctr</code>…</pre>

<p>The data set describes the dry plant <code>weight</code> (in grams, thank you data legend) of 30 observations (i.e. individual plants, aka rows in the tabular data) grown under one of three conditions described in <code>groups</code>: <code>ctrl</code>, <code>trt1</code>, and <code>trt2</code>. the convenient <code>glimpse()</code> function doesn’t show us these three groups, but the classic <code>str()</code> does:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">str</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="p">)</code>
<code class="s">'data.frame'</code><code class="o">:</code>	<code class="m">30</code> <code class="n">obs.</code> <code class="n">of</code>  <code class="m">2</code> <code class="n">variables</code><code class="o">:</code>
 <code class="o">$</code> <code class="n">weight</code><code class="o">:</code> <code class="n">num</code>  <code class="m">4.17</code> <code class="m">5.58</code> <code class="m">5.18</code> <code class="m">6.11</code> <code class="m">4.5</code> <code class="m">4.61</code> <code class="m">5.17</code> <code class="m">4.53</code> <code class="m">5.33</code> <code class="m">5.14</code> <code class="kc">...</code>
 <code class="o">$</code> <code class="n">group</code> <code class="o">:</code> <code class="n">Factor</code> <code class="n">w</code><code class="o">/</code> <code class="m">3</code> <code class="n">levels</code> <code class="s">"ctrl"</code><code class="p">,</code><code class="s">"trt1"</code><code class="p">,</code><code class="n">..</code><code class="o">:</code> <code class="m">1</code> <code class="m">1</code> <code class="m">1</code> <code class="m">1</code> <code class="m">1</code> <code class="m">1</code> <code class="m">1</code> <code class="m">1</code> <code class="m">1</code> <code class="m">1</code> <code class="kc">...</code></pre>

<p>If you’re getting nervous about <code>&lt;fct&gt;</code> and <code>Factor w/ 3 levels</code>, just hang tight — we’ll talk about that after we’re done with lists.</p>

<p>alright, let’s get to some tests. We may want to define a linear model for <code>weight</code> described by <code>group</code>:</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">pg_lm</code> <code class="o">&lt;-</code> <code class="nf">lm</code><code class="p">(</code><code class="n">weight</code> <code class="o">~</code> <code class="n">group</code><code class="p">,</code> <code class="n">data</code> <code class="o">=</code> <code class="n">PlantGrowth</code><code class="p">)</code></pre>

<p><code>lm()</code> is a foundational and flexible function for defining linear models in R. Our model is written in <em>formula notation</em>, where <code>weight ~ group</code> is <code>y ~ x</code>. You’ll recognize the <code>~</code> as the standard symbol for “described by” in statistics. The output is a type <code>list</code> of class <code>lm</code>:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">typeof</code><code class="p">(</code><code class="n">pg_lm</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"list"</code>
<code class="o">&gt;</code> <code class="nf">class</code><code class="p">(</code><code class="n">pg_lm</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"lm"</code></pre>

<p>There are two things that we want to remind you of and build on here.</p>

<p>First, remember that we mentioned that a data frame is a collection of vectors of the same length? Now we see that that just means that it’s a special class of a type list, where each <em>element</em> is a vector of the same length. We can access a named element within a list using the <code>$</code> notation:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">names</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"weight"</code> <code class="s">"group"</code>
<code class="o">&gt;</code> <code class="n">PlantGrowth</code><code class="o">$</code><code class="n">weight</code>
 <code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="m">4.17</code> <code class="m">5.58</code> <code class="m">5.18</code> <code class="m">6.11</code> <code class="m">4.50</code> <code class="m">4.61</code> <code class="m">5.17</code> <code class="m">4.53</code> <code class="m">5.33</code> <code class="m">5.14</code> <code class="m">4.81</code> <code class="m">4.17</code> <code class="m">4.41</code> <code class="m">3.59</code>
<code class="p">[</code><code class="m">15</code><code class="p">]</code> <code class="m">5.87</code> <code class="m">3.83</code> <code class="m">6.03</code> <code class="m">4.89</code> <code class="m">4.32</code> <code class="m">4.69</code> <code class="m">6.31</code> <code class="m">5.12</code> <code class="m">5.54</code> <code class="m">5.50</code> <code class="m">5.37</code> <code class="m">5.29</code> <code class="m">4.92</code> <code class="m">6.15</code>
<code class="p">[</code><code class="m">29</code><code class="p">]</code> <code class="m">5.80</code> <code class="m">5.26</code></pre>

<p>Notice the way it’s printed, along a row, and the beginning of each row begins with a <code>[]</code> with an index position in there. (we already mentioned that R begins indexing at 1, right?) In RStudio, you’ll get an autocomplete list of column names after typing <code>$</code>.</p>

<p>We can also access a named element within a list using the same notation:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">names</code><code class="p">(</code><code class="n">pg_lm</code><code class="p">)</code>
 <code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"coefficients"</code>  <code class="s">"residuals"</code>     <code class="s">"effects"</code>       <code class="s">"rank"</code>
 <code class="p">[</code><code class="m">5</code><code class="p">]</code> <code class="s">"fitted.values"</code> <code class="s">"assign"</code>        <code class="s">"qr"</code>            <code class="s">"df.residual"</code>
 <code class="p">[</code><code class="m">9</code><code class="p">]</code> <code class="s">"contrasts"</code>     <code class="s">"xlevels"</code>       <code class="s">"call"</code>          <code class="s">"terms"</code>
<code class="p">[</code><code class="m">13</code><code class="p">]</code> <code class="s">"model"</code></pre>

<p>You can see how a list is such a nice way to store the results of a statistical test since we have lots of different kinds of output. e.g. <code>coefficients</code>:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">pg_lm</code><code class="o">$</code><code class="nf">coefficients</code>
<code class="p">(</code><code class="n">Intercept</code><code class="p">)</code>   <code class="n">grouptrt1</code>   <code class="n">grouptrt2</code>
      <code class="m">5.032</code>      <code class="m">-0.371</code>       <code class="m">0.494</code></pre>

<p>is a <em>named</em> 3-element long numeric vector. (although its elements are named, the <code>$</code> operator is invalid for atomic vectors, but we have some other tricks up our sleeve, of course — see indexing with <code>[]</code> below). We didn’t get into the details, but you may be aware that given our data we expect to have three coefficients (estimates) in our model.</p>

<p>Consider <code>residuals</code>:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">pg_lm</code><code class="o">$</code><code class="n">residuals</code>
     <code class="m">1</code>      <code class="m">2</code>      <code class="m">3</code>      <code class="m">4</code>      <code class="m">5</code>      <code class="m">6</code>      <code class="m">7</code>      <code class="m">8</code>      <code class="m">9</code>     <code class="m">10</code>
<code class="m">-0.862</code>  <code class="m">0.548</code>  <code class="m">0.148</code>  <code class="m">1.078</code> <code class="m">-0.532</code> <code class="m">-0.422</code>  <code class="m">0.138</code> <code class="m">-0.502</code>  <code class="m">0.298</code>  <code class="m">0.108</code>
    <code class="m">11</code>     <code class="m">12</code>     <code class="m">13</code>     <code class="m">14</code>     <code class="m">15</code>     <code class="m">16</code>     <code class="m">17</code>     <code class="m">18</code>     <code class="m">19</code>     <code class="m">20</code>
 <code class="m">0.149</code> <code class="m">-0.491</code> <code class="m">-0.251</code> <code class="m">-1.071</code>  <code class="m">1.209</code> <code class="m">-0.831</code>  <code class="m">1.369</code>  <code class="m">0.229</code> <code class="m">-0.341</code>  <code class="m">0.029</code>
    <code class="m">21</code>     <code class="m">22</code>     <code class="m">23</code>     <code class="m">24</code>     <code class="m">25</code>     <code class="m">26</code>     <code class="m">27</code>     <code class="m">28</code>     <code class="m">29</code>     <code class="m">30</code>
 <code class="m">0.784</code> <code class="m">-0.406</code>  <code class="m">0.014</code> <code class="m">-0.026</code> <code class="m">-0.156</code> <code class="m">-0.236</code> <code class="m">-0.606</code>  <code class="m">0.624</code>  <code class="m">0.274</code> <code class="m">-0.266</code></pre>

<p>They are stored in a named 30-element long numerical vector (remember we had 30 observations). So lists are pretty convenient for storing heterogenous data and you’ll see them quite often in R, although there is a concerted effort in the Tidyverse towards data frames and their variants thereof.</p>

<p>Second, remember we mentioned that the <code>.</code> mostly doesn’t have any special meaning. Well here’s one of the exceptions where the <code>.</code> does actually have a meaning. Probably the most common use is when it specifies <em>all</em> when defining a model. Here, since other than the <code>weight</code> column, <code>PlantGrowth</code> only had one other column, we could have written:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">lm</code><code class="p">(</code><code class="n">weight</code> <code class="o">~</code> <code class="n">.,</code> <code class="n">data</code> <code class="o">=</code> <code class="n">PlantGrowth</code><code class="p">)</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A note on variable types. By using <code>y ~ x</code> formula, we’re say that x is the “independent” or the “predictor” variable(s) and y is “dependent” on x, or the “response” to the predictor.</p>
</div>

<p>It’s not really necessary, since we only have one independent variable here, but in some cases it’s convenient. The <code>ToothGrowth</code> dataset has a similar experimental set up, but we’re measuring the length of tooth growth under two conditions, a specific supplement (<code>supp</code>) and its dosage (<code>dose</code>).</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">lm</code><code class="p">(</code><code class="n">len</code> <code class="o">~</code> <code class="n">.,</code> <code class="n">data</code> <code class="o">=</code> <code class="n">ToothGrowth</code><code class="p">)</code>
<code class="c1"># is the same as</code>
<code class="nf">lm</code><code class="p">(</code><code class="n">len</code> <code class="o">~</code> <code class="n">supp</code> <code class="o">+</code> <code class="n">dose</code><code class="p">,</code> <code class="n">data</code> <code class="o">=</code> <code class="n">ToothGrowth</code><code class="p">)</code></pre>

<p>But like always, being explicit has it’s advantages, such as defining more precise models:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">lm</code><code class="p">(</code><code class="n">len</code> <code class="o">~</code> <code class="n">supp</code> <code class="o">*</code> <code class="n">dose</code><code class="p">,</code> <code class="n">data</code> <code class="o">=</code> <code class="n">ToothGrowth</code><code class="p">)</code></pre>

<p>Can you spot the difference between the two outputs? Specifying interactions is done with the `*`<sup><a data-type="noteref" id="idm45127459652296-marker" href="ch02.xhtml#idm45127459652296">6</a></sup></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="The facts about factors"><div class="sect1" id="idm45127460340424">
<h1>The facts about factors</h1>

<p>Alright, the last thing we need to clear up before we continue is the phenomena of the <code>factor</code>. Factors are akin to the pandas <code>category</code> type in Python. They are a wonderful and useful class in R. For the most part they exist and you won’t have cause to worry about them, but do be aware, since their uses and misuses will make your life a dream or a misery, respectively. Let’s take a look.</p>

<p>The name “factor” is very much a statistics term, we may refer to them as categorical variables, as Python does, but you’ll also see them referred to as qualitative and discrete variables, in text books and also in specific R packages, like <code>RColorBrewer</code> and <code>ggplot2</code>, respectively. Although these terms all refer to the same <em>kind</em> of variable, when we say factor in R, we’re referring to a <em>class of type integer</em>. It’s like how <code>data</code>.frame is a <em>class of type list</em>. Observe:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">typeof</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="o">$</code><code class="n">group</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"integer"</code>
<code class="o">&gt;</code> <code class="nf">class</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="o">$</code><code class="n">group</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"factor"</code></pre>

<p>You can easily identify a factor because in both the output from <code>str()</code> (see above) and in plain vector formatting, the levels will be stated:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">PlantGrowth</code><code class="o">$</code><code class="n">group</code>
 <code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="n">ctrl</code> <code class="n">ctrl</code> <code class="n">ctrl</code> <code class="n">ctrl</code> <code class="n">ctrl</code> <code class="n">ctrl</code> <code class="n">ctrl</code> <code class="n">ctrl</code> <code class="n">ctrl</code> <code class="n">ctrl</code>
 <code class="p">[</code><code class="m">11</code><code class="p">]</code> <code class="n">trt1</code> <code class="n">trt1</code> <code class="n">trt1</code> <code class="n">trt1</code> <code class="n">trt1</code> <code class="n">trt1</code> <code class="n">trt1</code> <code class="n">trt1</code> <code class="n">trt1</code> <code class="n">trt1</code>
 <code class="p">[</code><code class="m">21</code><code class="p">]</code> <code class="n">trt2</code> <code class="n">trt2</code> <code class="n">trt2</code> <code class="n">trt2</code> <code class="n">trt2</code> <code class="n">trt2</code> <code class="n">trt2</code> <code class="n">trt2</code> <code class="n">trt2</code> <code class="n">trt2</code>
<code class="n">Levels</code><code class="o">:</code> <code class="n">ctrl</code> <code class="n">trt1</code> <code class="n">trt2</code></pre>

<p>The levels are statisticians’ names for what are commonly called “groups”. Another give-away is that, although we have characters, they are not enclosed in quotation marks! This is very curious since we can actually treat them as characters, even though the are type integer (see <a data-type="xref" href="#data_types">Table 2-2</a>). You may be interested to look at the internal structure of an object using <code>dput()</code>. Here we can see that we have an integer vector <code>c(1L, ...)</code> and two <em>attributes</em>, the <code>label</code> and the <code>class</code>.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">dput</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="o">$</code><code class="n">group</code><code class="p">)</code>
<code class="nf">structure</code><code class="p">(</code><code class="nf">c</code><code class="p">(</code><code class="m">1L</code><code class="p">,</code> <code class="m">1L</code><code class="p">,</code> <code class="m">1L</code><code class="p">,</code> <code class="m">1L</code><code class="p">,</code> <code class="m">1L</code><code class="p">,</code> <code class="m">1L</code><code class="p">,</code> <code class="m">1L</code><code class="p">,</code> <code class="m">1L</code><code class="p">,</code> <code class="m">1L</code><code class="p">,</code> <code class="m">1L</code><code class="p">,</code>
            <code class="m">2L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code>
            <code class="m">3L</code><code class="p">,</code> <code class="m">3L</code><code class="p">,</code> <code class="m">3L</code><code class="p">,</code> <code class="m">3L</code><code class="p">,</code> <code class="m">3L</code><code class="p">,</code> <code class="m">3L</code><code class="p">,</code> <code class="m">3L</code><code class="p">,</code> <code class="m">3L</code><code class="p">,</code> <code class="m">3L</code><code class="p">,</code> <code class="m">3L</code><code class="p">),</code>
          <code class="n">.Label</code> <code class="o">=</code> <code class="nf">c</code><code class="p">(</code><code class="s">"ctrl"</code><code class="p">,</code> <code class="s">"trt1"</code><code class="p">,</code> <code class="s">"trt2"</code><code class="p">),</code>
          <code class="n">class</code> <code class="o">=</code> <code class="s">"factor"</code><code class="p">)</code></pre>

<p>The labels define the names of each <em>level</em> in the factor and are mapped to the integers, <code>1</code> being <code>ctrl</code>, and so on. So when we print to the screen we only see the names, not the integers. This commonly accepted to be a legacy use case from the days when memory was expensive and it made sense to save an integer many times over instead of a potentially long character vector.</p>

<p>So far, the only kind of factor we saw was really describing a nominal variable (a categorical variable with no order), but we have a nice solution for ordinal variables also. Check out this variable from the diamonds data set:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">color</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="n">E</code> <code class="n">E</code> <code class="n">E</code> <code class="n">I</code> <code class="n">J</code> <code class="n">J</code> <code class="n">I</code> <code class="n">H</code> <code class="n">E</code> <code class="n">H</code> <code class="n">..</code>
<code class="n">Levels</code><code class="o">:</code> <code class="n">D</code> <code class="o">&lt;</code> <code class="n">E</code> <code class="o">&lt;</code> <code class="bp">F</code> <code class="o">&lt;</code> <code class="n">G</code> <code class="o">&lt;</code> <code class="n">H</code> <code class="o">&lt;</code> <code class="n">I</code> <code class="o">&lt;</code> <code class="n">J</code></pre>

<p>The levels have an order, in the sense that D comes before E, and so on.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="How to find… stuff"><div class="sect1" id="idm45127459264920">
<h1>How to find… stuff</h1>

<p>Alright, by now we saw how R stores data and various subtleties that you’ll need to keep in mind, in particular things that may trip up a Pythonista. Let’s move onto logical expressions and indexing, which is to say: how to find… stuff?</p>

<p>Logical expressions are combinations of relational operators, which <em>ask</em> yes/no questions of <em>comparison</em>, and logical operators, which <em>combine</em> those yes/no questions.</p>

<p>Let’s begin with a vector:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">price</code> <code class="o">&gt;</code> <code class="m">18000</code>
   <code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code>
   <code class="kc">...</code></pre>

<p>This simply asks which of our diamonds are more expensive than $18,000. There are three key things to always keep in mind here.</p>

<p>First, the length of the shorter object, here the unassigned numeric vector <code>18000</code> (1-element long) will be “recycled” over the entire length of the longer vector, here the <code>price</code> column from the <code>diamonds</code> data frame accessed with the <code>$</code> notation, (53,940 elements). In Python you may refer to this as broadcasting, when using <code>numpy</code> arrays, and vectorization as a distinct function. In R, we simply refer to both as vectorization, or vector recycling.</p>

<p>Second, this means that the output vector is the same length as the length of the longest vector, here <code>53,940</code> elements.</p>

<p>Third, anytime you see a relational or logical operator, you know that the output vector will <em>always</em> be a logical vector. Remember logical as in <code>TRUE/FALSE</code>, not logical as in Mr. Spock.</p>

<p>If you want to combine questions you’ll have to combine two complete questions, such as really expensive and small diamonds (classy!):</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">price</code> <code class="o">&gt;</code> <code class="m">18000</code> <code class="o">&amp;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">carat</code> <code class="o">&lt;</code> <code class="m">1.5</code>
   <code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code> <code class="kc">FALSE</code>
   <code class="kc">...</code></pre>

<p>Notice that all three key points above hold true. When I introduced the atomic vector types, I failed to mention that logical is also defined by <code>1</code> and <code>0</code>. This means we can do math on logical vectors, which is very convenient. How many expensive little diamonds do we have?</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">sum</code><code class="p">(</code><code class="n">diamonds</code><code class="o">$</code><code class="n">price</code> <code class="o">&gt;</code> <code class="m">18000</code> <code class="o">&amp;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">carat</code> <code class="o">&lt;</code> <code class="m">1.5</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="m">9</code></pre>

<p>(Not enough if I’m being honest). What proportion of my data set do they represent? Just divide by the total number of observations.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">sum</code><code class="p">(</code><code class="n">diamonds</code><code class="o">$</code><code class="n">price</code> <code class="o">&gt;</code> <code class="m">18000</code> <code class="o">&amp;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">carat</code> <code class="o">&lt;</code> <code class="m">1.5</code><code class="p">)</code><code class="o">/</code><code class="nf">nrow</code><code class="p">(</code><code class="n">diamonds</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="m">0.0001668521</code></pre>

<p>So that’s asking and combining questions. Let’s take a look at indexing using []. You’re already familiar with [], but we feel that they are more straight-forward in R right out of the box. Here’s a summary:</p>
<table id="indexing">
<caption><span class="label">Table 2-3. </span>Indexing</caption>
<thead>
<tr>
<th>Use</th>
<th>Data object</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>xx[i]</p></td>
<td><p>Vector</p></td>
<td><p>Vector of only <code>i</code> elements</p></td>
</tr>
<tr>
<td><p>xx<a id="i"/></p></td>
<td><p>List, Data frame, tibble</p></td>
<td><p>The <code>i</code> element extracted from a list</p></td>
</tr>
<tr>
<td><p>xx[i]</p></td>
<td><p>List, Data frame, tibble</p></td>
<td><p>The <code>i</code> element maintaining the original structure</p></td>
</tr>
<tr>
<td><p>xx[i,j]</p></td>
<td><p>Data frame, tibble or matrix</p></td>
<td><p>The <code>i</code> rows and <code>j</code> columns of a data frame, tibble or matrix</p></td>
</tr>
<tr>
<td><p>xx[i,j,k]</p></td>
<td><p>Array</p></td>
<td><p>The <code>i</code> rows, <code>j</code> columns and <code>k</code> dimension of an array</p></td>
</tr>
</tbody>
</table>

<p><code>i</code>, <code>j</code>, and <code>k</code> are 1 of 3 different types of vector which can be used inside <code>[]</code>:</p>
<ol>
<li>
<p>An integer vector</p>
</li>
<li>
<p>A logical vector, or</p>
</li>
<li>
<p>A character vector containing names, if the elements are named.</p>
</li>

</ol>

<p>This should be familiar to you already from Python. For integer and logical vectors, these can be unassigned vectors, or object or functions that resolve to integer or logical vectors. Numbers don’t need to be type integer, although whole numbers are clearer. Using numeric/double rounds <em>down</em> to the nearest whole number, but try to avoid using real numbers when indexing, unless it serves a purpose.</p>

<p>Let’s begin with integers. We’ll take another little detour here to discuss the omnipresent <code>:</code> operator, which won’t do what your Pythonista brain tells you it should should do. We’ll begin with a built-in character vector, <code>letters</code>, which is the same as having a column in a data frame, like <code>PlantGrowth$weight</code>.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="kc">letters</code><code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="c1"># The 1st element (indexing begins at 1)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"a"</code></pre>

<p>So that’s pretty straight-forward. How about counting backwards?</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="kc">letters</code><code class="p">[</code><code class="m">-4</code><code class="p">]</code> <code class="c1"># Everything except the 4th element,</code>
<code class="o">&gt;</code> <code class="c1"># (*not* the fourth element, counting backwards!)</code>
 <code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"a"</code> <code class="s">"b"</code> <code class="s">"c"</code> <code class="s">"e"</code> <code class="s">"f"</code> <code class="s">"g"</code> <code class="s">"h"</code> <code class="kc">...</code></pre>

<p>Nope, that’s not happening, the <code>-</code> means to exclude an element, <em>not</em> to count backwards, but it was a nice try. We can also exclude a range of values:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="kc">letters</code><code class="p">[</code><code class="o">-</code><code class="p">(</code><code class="m">1</code><code class="o">:</code><code class="m">20</code><code class="p">)]</code> <code class="c1"># Exclude elements 1 through 20</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"u"</code> <code class="s">"v"</code> <code class="s">"w"</code> <code class="s">"x"</code> <code class="s">"y"</code> <code class="s">"z"</code></pre>

<p>and of course index a range of values:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="kc">letters</code><code class="p">[</code><code class="m">23</code><code class="o">:</code><code class="m">26</code><code class="p">]</code> <code class="c1"># The 23rd to the 26th element</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"w"</code> <code class="s">"x"</code> <code class="s">"y"</code> <code class="s">"z"</code></pre>

<p>And remember, we can combine this with anything that will give us an integer vector. <code>length()</code> will tell us how many elements we have in our vector, and <code>lhs:rhs</code> is short hand for the function <code>seq(from = lhs, to = rhs, by = 1)</code>, which creates a sequence of values in incremental steps of <code>by</code>, in this case defaulting to 1.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code>    <code class="c1"># The 23rd to the last element</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"w"</code> <code class="s">"x"</code> <code class="s">"y"</code> <code class="s">"z"</code></pre>

<p>So that means you always need an lhs and an rhs when using <code>:</code>. It’s a pity, but this isn’t going to work:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="kc">letters</code><code class="p">[</code><code class="m">23</code><code class="o">:</code><code class="p">]</code> <code class="c1"># error</code></pre>

<p>Using the <code>[]</code> inappropriately gives rise to a legendary and mysterious error message in R:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">df</code><code class="p">[</code><code class="m">1</code><code class="p">]</code>
<code class="n">Error</code> <code class="n">in</code> <code class="n">df</code><code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">:</code> <code class="n">object</code> <code class="n">of</code> <code class="n">type</code> <code class="s">'closure'</code> <code class="n">is</code> <code class="n">not</code> <code class="n">subsettable</code>
<code class="o">&gt;</code> <code class="n">t</code><code class="p">[</code><code class="m">6</code><code class="p">]</code>
<code class="n">Error</code> <code class="n">in</code> <code class="n">t</code><code class="p">[</code><code class="m">6</code><code class="p">]</code> <code class="o">:</code> <code class="n">object</code> <code class="n">of</code> <code class="n">type</code> <code class="s">'closure'</code> <code class="n">is</code> <code class="n">not</code> <code class="n">subsettable</code></pre>

<p>Can you tell where we went wrong? <code>df</code> and <code>t</code> are not defined data storage objects that we can index! They are functions and thus they must be followed by <code>()</code> where we provide the arguments. <code>[]</code> are always used to <em>subset</em> and these functions, <code>df()</code> and <code>t()</code> are functions of type closure, which are <em>not</em> subsettable. So it’s a pretty clear error message actually, and a good reminder to not call objects using ambiguous, short names, or indeed to get confused between functions and data storage objects.</p>

<p>That’s all fine a good, but you’re probably aware that the true power in indexing comes from using logical vectors to index specific <code>TRUE</code> elements, just like using type <code>bool</code> in Python. The most common way of obtaining a logical vector for indexing is to use a logical expression (see above). This is exactly what happens with <em>masking</em> in <code>numpy</code>.</p>

<p>So what are the colors of those fancy diamonds?</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">color</code><code class="p">[</code><code class="n">diamonds</code><code class="o">$</code><code class="n">price</code> <code class="o">&gt;</code> <code class="m">18000</code> <code class="o">&amp;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">carat</code> <code class="o">&lt;</code> <code class="m">1.5</code><code class="p">]</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="n">D</code> <code class="n">D</code> <code class="n">D</code> <code class="n">D</code> <code class="bp">F</code> <code class="n">D</code> <code class="bp">F</code> <code class="bp">F</code> <code class="n">E</code>
<code class="n">Levels</code><code class="o">:</code> <code class="n">D</code> <code class="o">&lt;</code> <code class="n">E</code> <code class="o">&lt;</code> <code class="bp">F</code> <code class="o">&lt;</code> <code class="n">G</code> <code class="o">&lt;</code> <code class="n">H</code> <code class="o">&lt;</code> <code class="n">I</code> <code class="o">&lt;</code> <code class="n">J</code></pre>

<p>Here, we’re using price and carat to find the colors of the diamonds that we’re interested in. Not surprisingly, they are the best color classifications. You may find it annoying that you have to write <code>diamonds$</code> repeatedly, but we would argue that it just makes it more explicit, and it’s what happens when we reference <code>pandas</code> <code>Series</code> in Python. Since we’re indexing a vector we get a vector as output. Let’s turn to data frames. We could have written the above indexing command as:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds</code><code class="p">[</code><code class="n">diamonds</code><code class="o">$</code><code class="n">price</code> <code class="o">&gt;</code> <code class="m">18000</code> <code class="o">&amp;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">carat</code> <code class="o">&lt;</code> <code class="m">1.5</code><code class="p">,</code> <code class="s">"color"</code><code class="p">]</code>
<code class="c1"># A tibble: 9 x 1</code>
  <code class="n">color</code>
  <code class="o">&lt;</code><code class="n">ord</code><code class="o">&gt;</code>
<code class="m">1</code> <code class="n">D</code>
<code class="m">2</code> <code class="n">D</code>
<code class="m">3</code> <code class="n">D</code>
<code class="m">4</code> <code class="n">D</code>
<code class="m">5</code> <code class="bp">F</code>
<code class="m">6</code> <code class="n">D</code>
<code class="m">7</code> <code class="bp">F</code>
<code class="m">8</code> <code class="bp">F</code>
<code class="m">9</code> <code class="n">E</code></pre>

<p>As you would expect, in <code>[i,j]`</code>, <code>i</code> always refers to the <em>rows</em> (observations), and <code>j</code> always refers to <em>columns</em> (variables). Notice that we also mixed two different types of input, but it works because they were in different parts of the expression. We use a logical vector that is as long as the data frame’s number of observations (thank you vector recycling) to obtain all the <code>TRUE</code> rows, and then we used a character vector to extract a named element, recall that each column in a data frame is a named element. This is a really typical formulation in R. The output is a data frame, specifically a tibble, since we used indexing on the diamonds data frame, and not on a specific 1-dimensional vector therein. Not to get bogged down with the topic, but it is worth noting that if we didn’t have a tibble, indexing for a single column (in <code>j</code>) would return a vector:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">class</code><code class="p">(</code><code class="n">diamonds</code><code class="p">)</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="s">"data.frame"</code>
<code class="o">&gt;</code> <code class="n">diamonds</code><code class="p">[</code><code class="n">diamonds</code><code class="o">$</code><code class="n">price</code> <code class="o">&gt;</code> <code class="m">18000</code> <code class="o">&amp;</code> <code class="n">diamonds</code><code class="o">$</code><code class="n">carat</code> <code class="o">&lt;</code> <code class="m">1.5</code><code class="p">,</code> <code class="s">"color"</code><code class="p">]</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="n">D</code> <code class="n">D</code> <code class="n">D</code> <code class="n">D</code> <code class="bp">F</code> <code class="n">D</code> <code class="bp">F</code> <code class="bp">F</code> <code class="n">E</code>
<code class="n">Levels</code><code class="o">:</code> <code class="n">D</code> <code class="o">&lt;</code> <code class="n">E</code> <code class="o">&lt;</code> <code class="bp">F</code> <code class="o">&lt;</code> <code class="n">G</code> <code class="o">&lt;</code> <code class="n">H</code> <code class="o">&lt;</code> <code class="n">I</code> <code class="o">&lt;</code> <code class="n">J</code></pre>

<p>This is indeed confusing and highlights that necessity to always be aware of the class of our data object. The Tidyverse tries to address some of this by maintaining data frames even in those instances where base R prefers to revert to a vector. The Tidyverse functions for indexing, shown below, makes things easier (the base package shorthand, <code>subset()</code>, works much in the same way, but <code>filter()</code> works better when used in a Tidyverse context.)</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">diamonds</code> <code class="o">%&gt;%</code>
<code class="o">+</code>   <code class="nf">filter</code><code class="p">(</code><code class="n">price</code> <code class="o">&gt;</code> <code class="m">18000</code><code class="p">,</code> <code class="n">carat</code> <code class="o">&lt;</code> <code class="m">1.5</code><code class="p">)</code> <code class="o">%&gt;%</code>
<code class="o">+</code>   <code class="nf">select</code><code class="p">(</code><code class="n">color</code><code class="p">)</code>
<code class="c1"># A tibble: 9 x 1</code>
  <code class="n">color</code>
  <code class="o">&lt;</code><code class="n">ord</code><code class="o">&gt;</code>
<code class="m">1</code> <code class="n">D</code>
<code class="m">2</code> <code class="n">D</code>
<code class="m">3</code> <code class="n">D</code>
<code class="m">4</code> <code class="n">D</code>
<code class="m">5</code> <code class="bp">F</code>
<code class="m">6</code> <code class="n">D</code>
<code class="m">7</code> <code class="bp">F</code>
<code class="m">8</code> <code class="bp">F</code>
<code class="m">9</code> <code class="n">E</code></pre>

<p>We introduced the principles behind the Tidyverse in the first part of the book, and now we’re seeing it in action. The <code>%&gt;%</code> above allows us to <em>unnest</em> objects and functions. For example, we could have written:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">select</code><code class="p">(</code><code class="nf">filter</code><code class="p">(</code><code class="n">diamonds</code><code class="p">,</code> <code class="n">price</code> <code class="o">&gt;</code> <code class="m">18000</code><code class="p">,</code> <code class="n">carat</code> <code class="o">&lt;</code> <code class="m">1.5</code><code class="p">),</code> <code class="n">color</code><code class="p">)</code></pre>

<p>That has the format of a long, nested function that is quite difficult to follow. We can pronounce <code>%&gt;%</code> as “and then” and thus read the entire command above as “Take the diamonds data set and then filter using these criteria and then select only these columns”. This goes a long way in helping us to literally read and understand code and is why <code>dplyr</code> is described as the <em>Grammar of Data Analysis</em>. Objects, like tibbles, are the nouns, <code>%&gt;%</code> is our punctuation, and functions are the verbs.</p>
<table id="function_description">
<caption><span class="label">Table 2-4. </span>Function description</caption>
<thead>
<tr>
<th>Function</th>
<th>Works on</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>filter()</code></p></td>
<td><p>rows</p></td>
<td><p>Use a logical vector to retain only TRUE rows</p></td>
</tr>
<tr>
<td><p><code>arrange()</code></p></td>
<td><p>rows</p></td>
<td><p>Reorder rows according to values in a specific column</p></td>
</tr>
<tr>
<td><p><code>select()</code></p></td>
<td><p>columns</p></td>
<td><p>Use a name or a helper function to extract only those columns</p></td>
</tr>
<tr>
<td><p><code>summarise()</code></p></td>
<td><p>columns</p></td>
<td><p>Apply aggregation functions to a column</p></td>
</tr>
<tr>
<td><p><code>mutate()</code></p></td>
<td><p>columns</p></td>
<td><p>Apply transformation functions to a column</p></td>
</tr>
</tbody>
</table>

<p>The five most important verbs in <code>dplyr</code> are listed in <a data-type="xref" href="#function_description">Table 2-4</a>. We already saw <code>filter()</code> and <code>select()</code> in action, so let’s take a look at applying functions with <code>summarise()</code> and <code>mutate()</code>. <code>summarise()</code> is used to apply an <em>aggregation</em> function, which returns a single value, like the mean, <code>mean()</code>, or standard deviation, <code>sd()</code>. It’s common to see <code>summarise()</code> used in combination with the <code>group_by()</code> function. In our analogy of grammatical elements, <code>group_by()</code> is an adverb, it modifies how a verb operates. In the example below, we use <code>group_by()</code> to add a <code>Group</code> attribute to our data frame and the functions applied in summarise are thus group-specific. It’s just like the <code>.groupby()</code> method for <code>pandas</code> <code>DataFrames</code>!</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">PlantGrowth</code> <code class="o">%&gt;%</code>
<code class="o">+</code>   <code class="nf">group_by</code><code class="p">(</code><code class="n">group</code><code class="p">)</code> <code class="o">%&gt;%</code>
<code class="o">+</code>   <code class="nf">summarise</code><code class="p">(</code><code class="n">avg</code> <code class="o">=</code> <code class="nf">mean</code><code class="p">(</code><code class="n">weight</code><code class="p">),</code>
<code class="o">+</code>             <code class="n">stdev</code> <code class="o">=</code> <code class="nf">sd</code><code class="p">(</code><code class="n">weight</code><code class="p">))</code>
<code class="nf">`summarise</code><code class="p">()</code><code class="n">` ungrouping output (override with `.groups`</code> <code class="n">argument</code><code class="p">)</code>
<code class="c1"># A tibble: 3 x 3</code>
  <code class="n">group</code>   <code class="n">avg</code> <code class="n">stdev</code>
  <code class="o">&lt;</code><code class="n">fct</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code>
<code class="m">1</code> <code class="n">ctrl</code>   <code class="m">5.03</code> <code class="m">0.583</code>
<code class="m">2</code> <code class="n">trt1</code>   <code class="m">4.66</code> <code class="m">0.794</code>
<code class="m">3</code> <code class="n">trt2</code>   <code class="m">5.53</code> <code class="m">0.443</code></pre>

<p><code>mutate()</code> is used to apply a <em>transformation</em> function, which returns as many outputs as inputs. In these cases it’s not unusual to use both Tidyverse syntax and native <code>[]</code> in combination to index specific values. For example, this data set contains the area under irrigation (thousands of hectares) for different regions of the world at four different time points.</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">irrigation</code> <code class="o">&lt;-</code> <code class="nf">read_csv</code><code class="p">(</code><code class="s">"R4Py/irrigation.csv"</code><code class="p">)</code>
<code class="n">Parsed</code> <code class="n">with</code> <code class="n">column</code> <code class="n">specification</code><code class="o">:</code>
<code class="nf">cols</code><code class="p">(</code>
  <code class="n">region</code> <code class="o">=</code> <code class="nf">col_character</code><code class="p">(),</code>
  <code class="n">year</code> <code class="o">=</code> <code class="nf">col_double</code><code class="p">(),</code>
  <code class="n">area</code> <code class="o">=</code> <code class="nf">col_double</code><code class="p">()</code>
<code class="p">)</code>
<code class="o">&gt;</code> <code class="n">irrigation</code>
<code class="c1"># A tibble: 16 x 3</code>
   <code class="n">region</code>      <code class="n">year</code>  <code class="n">area</code>
   <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code>      <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code>
 <code class="m">1</code> <code class="n">Africa</code>      <code class="m">1980</code>   <code class="m">9.3</code>
 <code class="m">2</code> <code class="n">Africa</code>      <code class="m">1990</code>  <code class="m">11</code>
 <code class="m">3</code> <code class="n">Africa</code>      <code class="m">2000</code>  <code class="m">13.2</code>
 <code class="m">4</code> <code class="n">Africa</code>      <code class="m">2007</code>  <code class="m">13.6</code>
 <code class="m">5</code> <code class="n">Europe</code>      <code class="m">1980</code>  <code class="m">18.8</code>
 <code class="m">6</code> <code class="n">Europe</code>      <code class="m">1990</code>  <code class="m">25.3</code>
 <code class="m">7</code> <code class="n">Europe</code>      <code class="m">2000</code>  <code class="m">26.7</code>
 <code class="m">8</code> <code class="n">Europe</code>      <code class="m">2007</code>  <code class="m">26.3</code>
<code class="kc">...</code></pre>

<p>We may want to measure the area fold-change relative to 1980 for each region.</p>

<pre data-type="programlisting" data-code-language="r"><code class="n">irrigation</code> <code class="o">%&gt;%</code>
  <code class="nf">group_by</code><code class="p">(</code><code class="n">region</code><code class="p">)</code> <code class="o">%&gt;%</code>
  <code class="nf">mutate</code><code class="p">(</code><code class="n">area_std_1980</code> <code class="o">=</code> <code class="n">area</code><code class="o">/</code><code class="n">area</code><code class="p">[</code><code class="n">year</code> <code class="o">==</code> <code class="m">1980</code><code class="p">])</code>
<code class="c1"># A tibble: 16 x 4</code>
<code class="c1"># Groups:   region [4]</code>
   <code class="n">region</code>      <code class="n">year</code>  <code class="n">area</code> <code class="n">area_std_1980</code>
   <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code>      <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code>         <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code>
 <code class="m">1</code> <code class="n">Africa</code>      <code class="m">1980</code>   <code class="m">9.3</code>          <code class="m">1</code>
 <code class="m">2</code> <code class="n">Africa</code>      <code class="m">1990</code>  <code class="m">11</code>            <code class="m">1.18</code>
 <code class="m">3</code> <code class="n">Africa</code>      <code class="m">2000</code>  <code class="m">13.2</code>          <code class="m">1.42</code>
 <code class="m">4</code> <code class="n">Africa</code>      <code class="m">2007</code>  <code class="m">13.6</code>          <code class="m">1.46</code>
 <code class="m">5</code> <code class="n">Europe</code>      <code class="m">1980</code>  <code class="m">18.8</code>          <code class="m">1</code>
 <code class="m">6</code> <code class="n">Europe</code>      <code class="m">1990</code>  <code class="m">25.3</code>          <code class="m">1.35</code>
 <code class="m">7</code> <code class="n">Europe</code>      <code class="m">2000</code>  <code class="m">26.7</code>          <code class="m">1.42</code>
 <code class="m">8</code> <code class="n">Europe</code>      <code class="m">2007</code>  <code class="m">26.3</code>          <code class="m">1.40</code>
 <code class="kc">...</code></pre>

<p>Just like with <code>mutate()</code> we can add more transformations, like the percentage change over each time point:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="n">irrigation</code> <code class="o">&lt;-</code> <code class="n">irrigation</code> <code class="o">%&gt;%</code>
<code class="o">+</code>   <code class="nf">group_by</code><code class="p">(</code><code class="n">region</code><code class="p">)</code> <code class="o">%&gt;%</code>
<code class="o">+</code>   <code class="nf">mutate</code><code class="p">(</code><code class="n">area_std_1980</code> <code class="o">=</code> <code class="n">area</code><code class="o">/</code><code class="n">area</code><code class="p">[</code><code class="n">year</code> <code class="o">==</code> <code class="m">1980</code><code class="p">],</code>
<code class="o">+</code>          <code class="n">area_per_change</code> <code class="o">=</code> <code class="nf">c</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="nf">diff</code><code class="p">(</code><code class="n">area</code><code class="p">)</code><code class="o">/</code><code class="n">area</code><code class="p">[</code><code class="o">-</code><code class="nf">length</code><code class="p">(</code><code class="n">area</code><code class="p">)]</code> <code class="o">*</code> <code class="m">100</code><code class="p">))</code>
<code class="o">&gt;</code> <code class="n">irrigation</code>
<code class="c1"># A tibble: 16 x 5</code>
<code class="c1"># Groups:   region [4]</code>
   <code class="n">region</code>      <code class="n">year</code>  <code class="n">area</code> <code class="n">area_std_1980</code> <code class="n">area_per_change</code>
   <code class="o">&lt;</code><code class="n">chr</code><code class="o">&gt;</code>      <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code> <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code>         <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code>           <code class="o">&lt;</code><code class="n">dbl</code><code class="o">&gt;</code>
 <code class="m">1</code> <code class="n">Africa</code>      <code class="m">1980</code>   <code class="m">9.3</code>          <code class="m">1</code>               <code class="m">0</code>
 <code class="m">2</code> <code class="n">Africa</code>      <code class="m">1990</code>  <code class="m">11</code>            <code class="m">1.18</code>           <code class="m">18.3</code>
 <code class="m">3</code> <code class="n">Africa</code>      <code class="m">2000</code>  <code class="m">13.2</code>          <code class="m">1.42</code>           <code class="m">20.0</code>
 <code class="m">4</code> <code class="n">Africa</code>      <code class="m">2007</code>  <code class="m">13.6</code>          <code class="m">1.46</code>            <code class="m">3.03</code>
 <code class="m">5</code> <code class="n">Europe</code>      <code class="m">1980</code>  <code class="m">18.8</code>          <code class="m">1</code>               <code class="m">0</code>
 <code class="m">6</code> <code class="n">Europe</code>      <code class="m">1990</code>  <code class="m">25.3</code>          <code class="m">1.35</code>           <code class="m">34.6</code>
 <code class="m">7</code> <code class="n">Europe</code>      <code class="m">2000</code>  <code class="m">26.7</code>          <code class="m">1.42</code>            <code class="m">5.53</code>
 <code class="m">8</code> <code class="n">Europe</code>      <code class="m">2007</code>  <code class="m">26.3</code>          <code class="m">1.40</code>           <code class="m">-1.50</code>
 <code class="kc">...</code></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Reiterations redo"><div class="sect1" id="idm45127459353208">
<h1>Reiterations redo</h1>

<p>Notice that we didn’t need any looping in the above examples. You may have intuitively wanted to apply a <code>for loop</code> to calculate aggregation or transformation functions for each region, but it’s not necessary. Avoiding for loops is somewhat of a past time in R, and is found in the base package with the apply family of functions.</p>

<p>Because vectorization is so fundamental to R, there’s a bit of an unofficial contest to see how few for loops you can write. We imagine some useRs have a wall sign: “Days since last for loop:” like factories have for accidents.</p>

<p>This means there are some very old methods for reiterating tasks, along with some newer methods which make the process more convenient.</p>
<table id="baseapply">
<caption><span class="label">Table 2-5. </span>Base package <code>apply</code> family</caption>
<thead>
<tr>
<th>Function</th>
<th>Use</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>apply()</code></p></td>
<td><p>Apply a function to each row or column of a matrix or data frame</p></td>
</tr>
<tr>
<td><p><code>lapply()</code></p></td>
<td><p>Apply a function to each element in a list</p></td>
</tr>
<tr>
<td><p><code>sapply()</code></p></td>
<td><p>Simplify the output of <code>lapply()</code></p></td>
</tr>
<tr>
<td><p><code>mapply()</code></p></td>
<td><p>The multivariate version of <code>sapply()</code></p></td>
</tr>
<tr>
<td><p><code>tapply()</code></p></td>
<td><p>Apply a function to values defined by an index</p></td>
</tr>
<tr>
<td><p><code>emapply()</code></p></td>
<td><p>Apply a function to values in an environment</p></td>
</tr>
</tbody>
</table>

<p>The old school method relies on the apply family of functions, listed in <a data-type="xref" href="#baseapply">Table 2-5</a>. Except for <code>apply()</code> pronounce them all as the first letter and then apply, hence “t apply” not “tapply”. There’s a bit of a trend to disavow these workhorses of reiteration but you’ll still see them a lot, so they’re worth getting familiar with. Doing so will also help you to appreciate why the Tidyverse arose. As an example, let’s return to the aggregation functions we applied to the <code>PlantGrowth</code> data frame above. In the apply family of functions, we could have used:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">tapply</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="o">$</code><code class="n">weight</code><code class="p">,</code> <code class="n">PlantGrowth</code><code class="o">$</code><code class="n">group</code><code class="p">,</code> <code class="n">mean</code><code class="p">)</code>
 <code class="n">ctrl</code>  <code class="n">trt1</code>  <code class="n">trt2</code>
<code class="m">5.032</code> <code class="m">4.661</code> <code class="m">5.526</code>
<code class="o">&gt;</code> <code class="nf">tapply</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="o">$</code><code class="n">weight</code><code class="p">,</code> <code class="n">PlantGrowth</code><code class="o">$</code><code class="n">group</code><code class="p">,</code> <code class="n">sd</code><code class="p">)</code>
     <code class="n">ctrl</code>      <code class="n">trt1</code>      <code class="n">trt2</code>
<code class="m">0.5830914</code> <code class="m">0.7936757</code> <code class="m">0.4425733</code></pre>

<p>You can imagine reading this as “take the weight column from the <code>PlantGrowth</code> data set, split the values according to the label in the group column in the <code>PlantGrowth</code> data set and then apply the mean function to each group of values and then return a named vector”.</p>

<p>Can you see how tedious this is if you want to add more functions on there? Named vectors can be convenient, but also, they are not really a typical way that you want to store important data.</p>

<p>One attempt to simplify this process was implemented in <code>plyr</code>, the precursor to <code>dplyr</code>. <code>plyr</code> is pronounced <em>plyer</em> like the small multifunctional hand-held tool. We use it as such:</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">library</code><code class="p">(</code><code class="n">plyr</code><code class="p">)</code>

<code class="nf">ddply</code><code class="p">(</code><code class="n">PlantGrowth</code><code class="p">,</code> <code class="s">"group"</code><code class="p">,</code> <code class="n">summarize</code><code class="p">,</code>
      <code class="n">avg</code> <code class="o">=</code> <code class="nf">mean</code><code class="p">(</code><code class="n">weight</code><code class="p">))</code></pre>

<p>This is still sometimes used today, but has mostly been superseded by a data frame-centric version of the package, hence the d in <code>dplyr</code> (say d-plyer):</p>

<pre data-type="programlisting" data-code-language="r"><code class="nf">library</code><code class="p">(</code><code class="n">dplyr</code><code class="p">)</code>
<code class="n">PlantGrowth</code> <code class="o">%&gt;%</code>
  <code class="nf">group_by</code><code class="p">(</code><code class="n">group</code><code class="p">)</code> <code class="o">%&gt;%</code>
  <code class="nf">summarize</code><code class="p">(</code><code class="n">avg</code> <code class="o">=</code> <code class="nf">mean</code><code class="p">(</code><code class="n">weight</code><code class="p">))</code></pre>

<p>But to be clear, we could have returned a data frame with other very old functions:</p>

<pre data-type="programlisting" data-code-language="r"><code class="o">&gt;</code> <code class="nf">aggregate</code><code class="p">(</code><code class="n">weight</code> <code class="o">~</code> <code class="n">group</code><code class="p">,</code> <code class="n">PlantGrowth</code><code class="p">,</code> <code class="n">mean</code><code class="p">)</code>
  <code class="n">group</code> <code class="n">weight</code>
<code class="m">1</code>  <code class="n">ctrl</code>  <code class="m">5.032</code>
<code class="m">2</code>  <code class="n">trt1</code>  <code class="m">4.661</code>
<code class="m">3</code>  <code class="n">trt2</code>  <code class="m">5.526</code></pre>

<p>Wow, what a great function, right? This thing is super old! You’ll still see it around, and why not, once you wrap your head around it it’s elegant and gets the job done, even though it still only applies one function. However, the ongoing push to use a unified Tidyverse framework, which is easier to read and arguably easier to learn, means the ancient arts are fading into the background.</p>

<p>These functions existed since the early days of R and reflect, intuitively, what statisticians do <strong>all the time</strong>. The <em>split</em> data into chunks, defined by some property (rows, columns, categorical variables, objects), then they <em>apply</em> some kind of action (plotting, hypothesis testing, modelling, etc.) and then they <em>combine</em> the output together in some way (data frame, list, etc.). The process is sometimes called Split-Apply-Combine. Realizing that this process kept repeating itself, started to make things clearer to the community of how to start thinking about data and indeed, how to actually organize data. From this the idea of “tidy” data was born<sup><a data-type="noteref" id="idm45127457621704-marker" href="ch02.xhtml#idm45127457621704">7</a></sup>.</p>

<p>As a last example of iterations, you’re probably familiar with the python <code>map()</code> function. An analogous function can be found in the Tidyverse <code>purrr</code> package. This is convenient for reiterating over lists or elements in a vector but it beyond the scope of this book.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Final thoughts"><div class="sect1" id="idm45127459352616">
<h1>Final thoughts</h1>

<p>In Python, you often hear about <em>the</em> Python way (“Pythonic”). This means the proper Python syntax and the preferred method to perform a specific action. This doesn’t really exist in R; there are many ways to go about the same thing and people will use all variety! Plus, they’ll often mix dialects. Although some dialects are easier to read than others, this hybridization can make it harder to get into the language.</p>

<p>Added to this is the constant tweaking of an expanding Tidyverse. Functions are tagged as experimental, dormant, maturing, stable, questioning, superseded, and archived. Couple that with relative lax standards for project-specific package management or for the use of virtual environments, and you can imagine a certain amount of growing frustration.</p>

<p>R officially celebrated its 20th birthday in 2020, and it’s roots are much older than that. Yet, it sometimes feels like R is currently experiencing a teenage growth spurt. It’s trying to figure out how it suddenly got a lot bigger and can be both awkward and cool at the same time. Blending the different R dialects will take you a long way in discovering its full potential.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45127464940616"><sup><a href="ch02.xhtml#idm45127464940616-marker">1</a></sup> <em>useR!</em> is the annual R conference and also a series of books by publisher Springer.</p><p data-type="footnote" id="idm45127464718424"><sup><a href="ch02.xhtml#idm45127464718424-marker">2</a></sup> “Graphical User Interface”</p><p data-type="footnote" id="idm45127464717736"><sup><a href="ch02.xhtml#idm45127464717736-marker">3</a></sup> “Integrated Development Environment”</p><p data-type="footnote" id="idm45127465528184"><sup><a href="ch02.xhtml#idm45127465528184-marker">4</a></sup> Object oriented programming</p><p data-type="footnote" id="idm45127460342008"><sup><a href="ch02.xhtml#idm45127460342008-marker">5</a></sup> Berliner (noun): In Berlin, a resident of the city. Everywhere else: a tasty jelly-filled, sugar-powered donut.</p><p data-type="footnote" id="idm45127459652296"><sup><a href="ch02.xhtml#idm45127459652296-marker">6</a></sup> But we’ll leave a detailed exposition of model definitions for the interested reader to explore.</p><p data-type="footnote" id="idm45127457621704"><sup><a href="ch02.xhtml#idm45127457621704-marker">7</a></sup> If you want to read more about the topic, check out Hadley Wickham’s paper <a href="https://vita.had.co.nz/papers/tidy-data.pdf">here</a></p></div></div></section></div></body></html>