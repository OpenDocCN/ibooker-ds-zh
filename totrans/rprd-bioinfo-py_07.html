<html><head></head><body><section data-pdf-bookmark="Chapter 6. Finding the Hamming Distance: Counting Point Mutations" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch06">&#13;
<h1><span class="label">Chapter 6. </span>Finding the Hamming Distance: <span class="keep-together">Counting Point Mutations</span></h1>&#13;
&#13;
&#13;
<p>The Hamming distance, named after the same Richard Hamming mentioned in the Preface, is the number of edits required to change one string into another.<a data-primary="Hamming distance determination" data-secondary="about" data-type="indexterm" id="idm45963634376920"/><a data-primary="Hamming, Richard" data-type="indexterm" id="idm45963634375960"/>&#13;
It’s one metric for gauging sequence similarity.&#13;
I have written a couple of other metrics for this, starting in <a data-type="xref" href="ch01.html#ch01">Chapter 1</a> with tetranucleotide frequency and continuing in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a> with GC content.<a data-primary="GC content determination" data-secondary="about" data-type="indexterm" id="idm45963634373336"/><a data-primary="tetranucleotide frequency" data-secondary="about" data-type="indexterm" id="idm45963634372376"/>&#13;
While the latter can be practically informative as coding regions tend to be GC-rich, tetranucleotide frequency falls pretty short of being useful.&#13;
For example, the sequences <em>AAACCCGGGTTT</em> and <em>CGACGATATGTC</em> are wildly different yet produce the same base frequencies:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./dna.py AAACCCGGGTTT&#13;
3 3 3 3&#13;
$ ./dna.py CGACGATATGTC&#13;
3 3 3 3</pre>&#13;
&#13;
<p>Taken alone, tetranucleotide frequency makes these sequences seem identical, but it’s quite obvious that they would produce entirely different protein sequences and so would be functionally unlike.&#13;
<a data-type="xref" href="#fig_6.1">Figure 6-1</a> depicts an alignment of the 2 sequences indicating that only 3 of the 12 bases are shared, meaning they are only 25% similar.</p>&#13;
&#13;
<figure><div class="figure" id="fig_6.1">&#13;
<img alt="mpfb 0601" src="assets/mpfb_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>An alignment of two sequences with vertical bars showing matching bases</h6>&#13;
</div></figure>&#13;
&#13;
<p>Another way to express this is to say that 9 of the 12 bases need to be changed to turn one of the sequences into the other.&#13;
This is the Hamming distance, and it’s somewhat equivalent in bioinformatics to single-nucleotide polymorphisms (SNPs, pronounced <em>snips</em>) or single-nucleotide variations (SNVs, pronounced <em>snivs</em>).<a data-primary="single-nucleotide polymorphisms (SNPs)" data-type="indexterm" id="idm45963634364088"/><a data-primary="single-nucleotide variations (SNVs)" data-type="indexterm" id="idm45963634363400"/>&#13;
This algorithm only accounts for the change of one base to another value and falls far short of something like sequence alignment that can identify insertions and deletions.&#13;
For instance, <a data-type="xref" href="#fig_6.2">Figure 6-2</a> shows that the sequences <em>AAACCCGGGTTT</em> and <em>AACCCGGGTTTA</em> are 92% similar when aligned (on the left), as they differ by a single base.&#13;
The Hamming distance (on the right), though, shows only 8 bases are in common, which means they are only 66% similar.</p>&#13;
&#13;
<figure><div class="figure" id="fig_6.2">&#13;
<img alt="mpfb 0602" src="assets/mpfb_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>The alignment of these sequences shows them to be nearly identical, while the Hamming distance finds they’re only 66% similar</h6>&#13;
</div></figure>&#13;
&#13;
<p>This program will always compare strings strictly from their beginnings, which limits the practical application to real-world bioinformatics.&#13;
Still, it turns out that this naïve algorithm is a useful metric for sequence similarity, and writing the implementation presents many interesting solutions in Python.</p>&#13;
&#13;
<p>In this chapter, you will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to use the <code>abs()</code> and <code>min()</code> functions</p>&#13;
</li>&#13;
<li>&#13;
<p>How to combine the elements from two lists of possibly unequal lengths</p>&#13;
</li>&#13;
<li>&#13;
<p>How to write <code>map()</code> using <code>lambda</code> or existing functions</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use functions from the <code>operator</code> module</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use the <code>itertools.starmap()</code> function</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963634349256">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>You should work in the <em>06_hamm</em> directory of the repository.<a data-primary="Hamming distance determination" data-secondary="getting started" data-type="indexterm" id="idm45963634347496"/>&#13;
I suggest you start by getting a feel for how the solutions work, so copy one of them to the <code>hamm.py</code> program and request the help:</p>&#13;
&#13;
<pre data-type="programlisting">$ cp solution1_abs_iterate.py hamm.py&#13;
$ ./hamm.py -h&#13;
usage: hamm.py [-h] str str&#13;
&#13;
Hamming distance&#13;
&#13;
positional arguments:&#13;
  str         Sequence 1&#13;
  str         Sequence 2&#13;
&#13;
optional arguments:&#13;
  -h, --help  show this help message and exit</pre>&#13;
&#13;
<p>The program requires two positional arguments, which are the two sequences to compare, and the program should print the Hamming distance.&#13;
For example, I would need to make seven edits to change one of these sequences to the other:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./hamm.py GAGCCTACTAACGGGAT CATCGTAATGACGGCCT&#13;
7</pre>&#13;
&#13;
<p>Run the tests (either with <strong><code>pytest</code></strong> or <strong><code>make test</code></strong>) to see a passing suite.&#13;
Once you feel you understand what’s expected, remove this file and start from scratch:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Hamming distance' hamm.py&#13;
Done, see new script "hamm.py".</pre>&#13;
&#13;
<p>Define the parameters so that the program requires two positional arguments which are the two sequences:</p>&#13;
&#13;
<pre data-type="programlisting">import argparse&#13;
from typing import NamedTuple&#13;
&#13;
&#13;
class Args(NamedTuple): <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Command-line arguments """&#13;
    seq1: str&#13;
    seq2: str&#13;
&#13;
&#13;
# --------------------------------------------------&#13;
def get_args():&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Hamming distance',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('seq1', metavar='str', help='Sequence 1') <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-2" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    parser.add_argument('seq2', metavar='str', help='Sequence 2')&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(args.seq1, args.seq2) <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-3" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The program arguments will have two string values for the two sequences.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-2" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The two sequences are required positional string values.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-3" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Instantiate the <code>Args</code> object using the two sequences.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The order in which you define positional parameters must match the order in which the arguments are provided on the command line. That is, the first positional parameter will hold the first positional argument, the second positional parameter will match the second positional argument, etc. The order in which you define optional parameters does not matter, and optional parameters may be defined before or after positional parameters.</p>&#13;
</div>&#13;
&#13;
<p>Change the <code>main()</code> function to print the two sequence:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    print(args.seq1, args.seq2)</pre>&#13;
&#13;
<p>By this point, you should have a program that prints the usage, validates that the user supplies two sequences, and prints the sequences:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./hamm.py GAGCCTACTAACGGGAT CATCGTAATGACGGCCT&#13;
GAGCCTACTAACGGGAT CATCGTAATGACGGCCT</pre>&#13;
&#13;
<p>If you run <strong><code>pytest -xvv</code></strong> (the two <code>v</code>s increase the verbosity of the output), you should find that the program passes the first three tests.&#13;
It should fail <code>test_input1</code> with a message like the following:</p>&#13;
&#13;
<pre data-type="programlisting">=================================== FAILURES ===================================&#13;
_________________________________ test_input1 __________________________________&#13;
&#13;
    def test_input1() -&gt; None:&#13;
        """ Test with input1 """&#13;
&#13;
&gt;       run(INPUT1)&#13;
&#13;
tests/hamm_test.py:47:&#13;
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _&#13;
&#13;
file = './tests/inputs/1.txt' <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    def run(file: str) -&gt; None:&#13;
        """ Run with input """&#13;
&#13;
        assert os.path.isfile(file)&#13;
        seq1, seq2, expected = open(file).read().splitlines() <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-2" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
        rv, out = getstatusoutput(f'{RUN} {seq1} {seq2}') <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-3" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
        assert rv == 0&#13;
&gt;       assert out.rstrip() == expected <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-4" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
E       AssertionError: assert 'GAGCCTACTAACGGGAT CATCGTAATGACGGCCT' == '7' <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-5" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-5"><img alt="5" src="assets/5.png"/></a>&#13;
E         - 7&#13;
E         + GAGCCTACTAACGGGAT CATCGTAATGACGGCCT&#13;
&#13;
tests/hamm_test.py:40: AssertionError&#13;
=========================== short test summary info ============================&#13;
FAILED tests/hamm_test.py::test_input1 - AssertionError: assert 'GAGCCTACTAAC...&#13;
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!&#13;
========================= 1 failed, 3 passed in 0.27s ==========================</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The inputs for the test come from the file <em>./tests/inputs/1.txt</em>.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-2" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The file is opened and read for the two sequences and the expected result.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-3" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The program is run with the two sequences.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-4" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The <code>assert</code> fails when it finds the output from the program does not match the expected answer.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-5" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Specifically, the program printed the two sequences when it should have printed <code>7</code>.</p></dd>&#13;
</dl>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterating the Characters of Two Strings" data-type="sect2"><div class="sect2" id="idm45963634289592">&#13;
<h2>Iterating the Characters of Two Strings</h2>&#13;
&#13;
<p>Now to find the Hamming distance between the two sequences.<a data-primary="Hamming distance determination" data-secondary="iterating characters of two strings" data-type="indexterm" id="idm45963634288232"/>&#13;
To start, consider these two sequences:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq1, seq2 = 'AC', 'ACGT'</pre>&#13;
&#13;
<p>The distance is 2 because you would either need to add <em>GT</em> to the first sequence or remove <em>GT</em> from the second sequence to make them the same.&#13;
I would suggest that the baseline distance is the difference in their lengths.&#13;
Note that the Rosalind challenge assumes two strings of equal lengths, but I want to use this exercise to consider strings of different lengths.</p>&#13;
&#13;
<p>Depending on the order in which you do the subtraction, you might end up with a negative number:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; len(seq1) - len(seq2)&#13;
-2</pre>&#13;
&#13;
<p>Use the <code>abs()</code> function to get the absolute value:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; distance = abs(len(seq1) - len(seq2))&#13;
&gt;&gt;&gt; distance&#13;
2</pre>&#13;
&#13;
<p class="pagebreak-before">Now I will consider how to iterate the characters they have in common.&#13;
I can use the <code>min()</code> function to find the length of the shorter sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; min(len(seq1), len(seq2))&#13;
2</pre>&#13;
&#13;
<p>And I can use this with the <code>range()</code> function to get the indexes of the common <span class="keep-together">characters:</span></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for i in range(min(len(seq1), len(seq2))):&#13;
...     print(seq1[i], seq2[i])&#13;
...&#13;
A A&#13;
C C</pre>&#13;
&#13;
<p>When these two characters are <em>not</em> equal, the <code>distance</code> variable should be incremented because I would have to change one of the values to match the other.&#13;
Remember that the Rosalind challenge always compares the two sequences from their beginnings.&#13;
For instance, the sequences <em>ATTG</em> and <em>TTG</em> differ by one base, as I can either remove <em>A</em> from the first or add it to the second to make them match, but the rules of this particular challenge would say that the correct answer is 3:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./hamm.py ATTG TTG&#13;
3</pre>&#13;
&#13;
<p>I believe this should be enough information for you to craft a solution that passes the test suite.&#13;
Once you have a working solution, explore some other ways you might write your algorithm, and keep checking your work using the test suite.&#13;
In addition to running the tests via <strong><code>pytest</code></strong>, be sure to use the <strong><code>make test</code></strong> option to verify that your code also passes the various linting and type-checking tests.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963634271224">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>This section works through eight variations on how to find the Hamming distance, starting with an entirely manual calculation that takes several lines of code and ending with a solution that combines several functions in a single line.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Iterating and Counting" data-type="sect2"><div class="sect2" id="idm45963634269544">&#13;
<h2>Solution 1: Iterating and Counting</h2>&#13;
&#13;
<p>The first solution follows from the suggestions in the previous section:<a data-primary="Hamming distance determination" data-secondary="solution 1 iterate and count" data-type="indexterm" id="idm45963634268168"/></p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    seq1, seq2 = args.seq1, args.seq2 <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    l1, l2 = len(seq1), len(seq2) <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-2" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
    distance = abs(l1 - l2) <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-3" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
    for i in range(min(l1, l2)): <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-4" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
        if seq1[i] != seq2[i]: <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-5" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-5"><img alt="5" src="assets/5.png"/></a>&#13;
            distance += 1 <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-6" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-6"><img alt="6" src="assets/6.png"/></a>&#13;
&#13;
    print(distance) <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-7" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-7"><img alt="7" src="assets/7.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Copy the two sequences into variables.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-2" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Since I’ll use the lengths more than once, I store them in variables.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-3" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The base distance is the difference between the two lengths.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-4" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Use the shorter length to find the indexes in common.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-5" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Check the letters at each position.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-6" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Increment the distance by 1.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-7" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Print the distance.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This solution is very explicit, laying out every individual step needed to compare all the characters of two strings.&#13;
The following solutions will start to shorten many of the steps, so be sure you are comfortable with exactly what I’ve shown here.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Creating a Unit Test" data-type="sect2"><div class="sect2" id="idm45963634231768">&#13;
<h2>Solution 2: Creating a Unit Test</h2>&#13;
&#13;
<p>The first solution leaves me feeling vaguely uncomfortable because the code to calculate the Hamming distance should be in a function with tests.<a data-primary="Hamming distance determination" data-secondary="solution 2 unit test" data-type="indexterm" id="idm45963634230328"/><a data-primary="unit testing" data-secondary="Hamming distance determination" data-type="indexterm" id="idm45963634229368"/>&#13;
I’ll start by creating a function called <code>hamming()</code> after the <code>main()</code> function.&#13;
As a matter of style, I like to put <code>get_args()</code> first so I can read it immediately when I open the program.&#13;
My <code>main()</code> function always comes second, and all other functions and tests after that.</p>&#13;
&#13;
<p>I’ll start by imagining the inputs and output of my function:</p>&#13;
&#13;
<pre data-type="programlisting">def hamming(seq1: str, seq2: str) -&gt; int: <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Calculate Hamming distance """&#13;
&#13;
    return 0 <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-2" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function will accept two strings as positional arguments and will return an integer.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-2" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>To start, the function will always return <code>0</code>.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>I want to stress the fact that the function does not <em>print</em> the answer but rather <em>returns it as a result</em>. If you wrote this function to <code>print()</code> the distance, you would not be able to write a unit test. You would have to rely entirely on the integration test that looks to see if the program prints the correct answer. As much as possible, I would encourage you to write pure functions that act only on the arguments and have no side effects. Printing is a side effect, and, while the program does need to print the answer eventually, this function’s job is solely to return an integer when given two strings.</p>&#13;
</div>&#13;
&#13;
<p>I’ve already shown a few test cases I can encode.&#13;
Feel free to add other tests of your own devising:</p>&#13;
&#13;
<pre data-type="programlisting">def test_hamming() -&gt; None:&#13;
    """ Test hamming """&#13;
&#13;
    assert hamming('', '') == 0 <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert hamming('AC', 'ACGT') == 2 <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-2" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert hamming('GAGCCTACTAACGGGAT', 'CATCGTAATGACGGCCT') == 7 <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-3" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>I always think it’s good practice to send empty strings for string inputs.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-2" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The difference is due only to length.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-3" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This is the example from the documentation.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I’m aware that this may seem a bit extreme, because this function is essentially the entire program.&#13;
I’m almost duplicating the integration test, I know, but I’m using this to point out best practices for writing programs.&#13;
The <code>hamming()</code> function is a good unit of code, and it belongs in a function with a test.&#13;
In a much larger program, this would be one of perhaps dozens to hundreds of other functions, and each should be <em>encapsulated</em>, <em>documented</em>, and <em>tested</em>.</p>&#13;
&#13;
<p>Following test-driven principles, run <strong><code>pytest</code></strong> on the program to ensure that the test fails:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -v hamm.py&#13;
========================== test session starts ==========================&#13;
...&#13;
&#13;
hamm.py::test_hamming FAILED                                      [100%]&#13;
&#13;
=============================== FAILURES ================================&#13;
_____________________________ test_hamming ______________________________&#13;
&#13;
    def test_hamming() -&gt; None:&#13;
        """ Test hamming """&#13;
&#13;
        assert hamming('', '') == 0&#13;
&gt;       assert hamming('AC', 'ACGT') == 2&#13;
E       assert 0 == 2&#13;
E         +0&#13;
E         -2&#13;
&#13;
hamm.py:69: AssertionError&#13;
======================== short test summary info ========================&#13;
FAILED hamm.py::test_hamming - assert 0 == 2&#13;
=========================== 1 failed in 0.13s ===========================</pre>&#13;
&#13;
<p>Now copy the code from <code>main()</code> to fix the function:</p>&#13;
&#13;
<pre data-type="programlisting">def hamming(seq1: str, seq2: str) -&gt; int:&#13;
    """ Calculate Hamming distance """&#13;
&#13;
    l1, l2 = len(seq1), len(seq2)&#13;
    distance = abs(l1 - l2)&#13;
&#13;
    for i in range(min(l1, l2)):&#13;
        if seq1[i] != seq2[i]:&#13;
            distance += 1&#13;
&#13;
    return distance</pre>&#13;
&#13;
<p>Verify that your function is correct:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -v hamm.py&#13;
========================== test session starts ==========================&#13;
...&#13;
&#13;
hamm.py::test_hamming PASSED                                      [100%]&#13;
&#13;
=========================== 1 passed in 0.02s ===========================</pre>&#13;
&#13;
<p>You can incorporate it into your <code>main()</code> function like so:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    print(hamming(args.seq1, args.seq2))  <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO6-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO6-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO6-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Print the return value from the function for the two given sequences.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This hides the complexity of the program inside a named, documented, tested unit, shortening the main body of the program and improving the readability.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: Using the zip() Function" data-type="sect2"><div class="sect2" id="idm45963634179064">&#13;
<h2>Solution 3: Using the zip() Function</h2>&#13;
&#13;
<p>The following solution uses the <code>zip()</code> function to combine the elements from two sequences.<a data-primary="Hamming distance determination" data-secondary="solution 2 zip()" data-type="indexterm" id="idm45963634177256"/><a data-primary="zip() function combining sequences" data-type="indexterm" id="idm45963634176296"/><a data-primary="tuples" data-secondary="zip() function combining" data-type="indexterm" id="idm45963634175608"/>&#13;
The result is a list of tuples containing the characters from each position (see <a data-type="xref" href="#fig_6.3">Figure 6-3</a>).&#13;
Note that <code>zip()</code> is another lazy function, so I’ll use <code>list()</code> to coerce the values in the REPL:<a data-primary="lazy functions" data-secondary="zip()" data-type="indexterm" id="idm45963634172648"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(zip('ABC', '123'))&#13;
[('A', '1'), ('B', '2'), ('C', '3')]</pre>&#13;
&#13;
<figure><div class="figure" id="fig_6.3">&#13;
<img alt="mpfb 0603" src="assets/mpfb_0603.png"/>&#13;
<h6><span class="label">Figure 6-3. </span>The tuples are composed of characters in common positions</h6>&#13;
</div></figure>&#13;
&#13;
<p>If I use the <em>AC</em> and <em>ACGT</em> sequences, you’ll notice that <code>zip()</code> stops with the shorter sequence, as shown in <a data-type="xref" href="#fig_6.4">Figure 6-4</a>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(zip('AC', 'ACGT'))&#13;
[('A', 'A'), ('C', 'C')]</pre>&#13;
&#13;
<figure><div class="figure" id="fig_6.4">&#13;
<img alt="mpfb 0604" src="assets/mpfb_0604.png"/>&#13;
<h6><span class="label">Figure 6-4. </span>The <code>zip()</code> function will stop at the shortest sequence</h6>&#13;
</div></figure>&#13;
&#13;
<p>I can use a <code>for</code> loop to iterate over each pair.&#13;
So far in my <code>for</code> loops, I’ve used a single variable to represent each element in a list like this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for tup in zip('AC', 'ACGT'):&#13;
...     print(tup)&#13;
...&#13;
('A', 'A')&#13;
('C', 'C')</pre>&#13;
&#13;
<p>In <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>, I showed how to <em>unpack</em> the values from a tuple into separate variables.&#13;
The Python <code>for</code> loop allows me to unpack each tuple into the two characters, like so:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for char1, char2 in zip('AC', 'ACGT'):&#13;
...     print(char1, char2)&#13;
...&#13;
A A&#13;
C C</pre>&#13;
&#13;
<p>The <code>zip()</code> function obviates a couple of lines from the first implementation:</p>&#13;
&#13;
<pre class="pagebreak-before" data-type="programlisting">def hamming(seq1: str, seq2: str) -&gt; int:&#13;
    """ Calculate Hamming distance """&#13;
&#13;
    distance = abs(len(seq1) - len(seq2)) <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    for char1, char2 in zip(seq1, seq2): <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-2" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
        if char1 != char2: <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-3" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-3"><img alt="3" src="assets/3.png"/></a>&#13;
            distance += 1 <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-4" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    return distance</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Start with the absolute difference of the lengths.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-2" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use <code>zip()</code> to pair up the characters of the two strings.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-3" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Check if the two characters are not equal.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-4" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Increment the distance.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 4: Using the zip_longest() Function" data-type="sect2"><div class="sect2" id="idm45963634135160">&#13;
<h2>Solution 4: Using the zip_longest() Function</h2>&#13;
&#13;
<p>The next solution imports the <code>zip_longest()</code> function from the <code>itertools</code> module.<a data-primary="Hamming distance determination" data-secondary="solution 4 zip_longest()" data-type="indexterm" id="idm45963634132920"/><a data-primary="zip_longest() function" data-type="indexterm" id="idm45963634131944"/>&#13;
As the name implies, it will zip the lists to the length of the longest list.&#13;
<a data-type="xref" href="#fig_6.5">Figure 6-5</a> shows that the function will insert <code>None</code> values when a shorter sequence has been exhausted:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from itertools import zip_longest&#13;
&gt;&gt;&gt; list(zip_longest('AC', 'ACGT'))&#13;
[('A', 'A'), ('C', 'C'), (None, 'G'), (None, 'T')]</pre>&#13;
&#13;
<figure><div class="figure" id="fig_6.5">&#13;
<img alt="mpfb 0605" src="assets/mpfb_0605.png"/>&#13;
<h6><span class="label">Figure 6-5. </span>The <code>zip_longest()</code> function will stop at the longest sequence</h6>&#13;
</div></figure>&#13;
&#13;
<p>I no longer need to start by subtracting the lengths of the sequences.&#13;
Instead, I’ll initialize a <code>distance</code> variable to <code>0</code> and then use <code>zip_longest()</code> to create tuples of bases to compare:</p>&#13;
&#13;
<pre data-type="programlisting">def hamming(seq1: str, seq2: str) -&gt; int:&#13;
    """ Calculate Hamming distance """&#13;
&#13;
    distance = 0 <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
    for char1, char2 in zip_longest(seq1, seq2): <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-2" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-2"><img alt="2" src="assets/2.png"/></a>&#13;
        if char1 != char2: <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-3" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-3"><img alt="3" src="assets/3.png"/></a>&#13;
            distance += 1 <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-4" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    return distance</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize the distance to <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-2" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Zip to the longest sequence.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-3" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Compare the characters.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-4" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Increment the counter.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 5: Using a List Comprehension" data-type="sect2"><div class="sect2" id="idm45963634103336">&#13;
<h2>Solution 5: Using a List Comprehension</h2>&#13;
&#13;
<p>All the solutions up to this point have used a <code>for</code> loop.<a data-primary="Hamming distance determination" data-secondary="solution 5 list comprehension" data-type="indexterm" id="idm45963634101544"/><a data-primary="list comprehension" data-secondary="Hamming distance determination" data-type="indexterm" id="idm45963634100568"/>&#13;
I hope you’re starting to anticipate that I’m going to show you how to convert this into a list comprehension next.&#13;
When the goal is to create a new list or reduce a list of values to some answer, it’s often shorter and preferable to use a list comprehension.</p>&#13;
&#13;
<p>The first version is going to use an <code>if</code> expression to return a <code>1</code> if the two characters are the same or a <code>0</code> if they are not:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq1, seq2, = 'GAGCCTACTAACGGGAT', 'CATCGTAATGACGGCCT'&#13;
&gt;&gt;&gt; [1 if c1 != c2 else 0 for c1, c2 in zip_longest(seq1, seq2)]&#13;
[1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0]</pre>&#13;
&#13;
<p>The Hamming distance, then, is the sum of these:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sum([1 if c1 != c2 else 0 for c1, c2 in zip_longest(seq1, seq2)])&#13;
7</pre>&#13;
&#13;
<p>Another way to express this idea is to only produce the <code>1</code>s by using a <em>guard</em> clause, which is a conditional statement at the end of the list comprehension that decides whether or not a particular element is allowed:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; ones = [1 for c1, c2 in zip_longest(seq1, seq2) if c1 != c2] <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO9-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO9-1"><img alt="1" src="assets/1.png"/></a>&#13;
&gt;&gt;&gt; ones&#13;
[1, 1, 1, 1, 1, 1, 1]&#13;
&gt;&gt;&gt; sum(ones)&#13;
7</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO9-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>if</code> statement is the guard that will produce the value <code>1</code> if the two characters are not equal.</p></dd>&#13;
</dl>&#13;
&#13;
<p>You could also use the Boolean/integer coercion I showed in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, where each <code>True</code> value will be treated as <code>1</code> and <code>False</code> is <code>0</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; bools = [c1 != c2 for c1, c2 in zip_longest(seq1, seq2)]&#13;
&gt;&gt;&gt; bools&#13;
[True, False, True, False, True, False, False, True, False, True, False,&#13;
False, False, False, True, True, False]&#13;
&gt;&gt;&gt; sum(bools)&#13;
7</pre>&#13;
&#13;
<p>Any of these ideas will reduce the function to a single line of code that passes the tests:</p>&#13;
&#13;
<pre data-type="programlisting">def hamming(seq1: str, seq2: str) -&gt; int:&#13;
    """ Calculate Hamming distance """&#13;
&#13;
    return sum([c1 != c2 for c1, c2 in zip_longest(seq1, seq2)])</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 6: Using the filter() Function" data-type="sect2"><div class="sect2" id="idm45963634080792">&#13;
<h2>Solution 6: Using the filter() Function</h2>&#13;
&#13;
<p>Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04">4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.html#ch05">5</a> show that a list comprehension with a guard can also be expressed using the <code>filter()</code> function.<a data-primary="Hamming distance determination" data-secondary="solution 6 filter()" data-type="indexterm" id="idm45963634076440"/><a data-primary="filter() function" data-secondary="Hamming distance determination" data-type="indexterm" id="idm45963634075480"/>&#13;
The syntax is a little ugly because Python doesn’t allow the unpacking of the tuples from <code>zip_longest()</code> into separate variables.&#13;
That is, I want to write a <code>lambda</code> that unpacks <code>char1</code> and <code>char2</code> into separate variables, but this is not possible:<a data-primary="lambda keyword" data-secondary="Hamming distance determination" data-type="indexterm" id="idm45963634072424"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(filter(lambda char1, char2: char1 != char2, zip_longest(seq1, seq2)))&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
TypeError: &lt;lambda&gt;() missing 1 required positional argument: 'char2'</pre>&#13;
&#13;
<p>Instead, I will usually call the <code>lambda</code> variable <code>tup</code> or <code>t</code> to remind me this is a tuple.&#13;
I will use the positional tuple notation to compare the element in the zeroth position to the element in the first position.&#13;
<code>filter()</code> will only produce those tuples where the elements are different:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq1, seq2 = 'AC', 'ACGT'&#13;
&gt;&gt;&gt; list(filter(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))&#13;
[(None, 'G'), (None, 'T')]</pre>&#13;
&#13;
<p>The Hamming distance then is the length of this list.&#13;
Note that the <code>len()</code> function will not prompt <code>filter()</code> to produce values:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; len(filter(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
TypeError: object of type 'filter' has no len()</pre>&#13;
&#13;
<p>This is one of those instances where the code must use <code>list()</code> to force the lazy <span class="keep-together"><code>filter()</code></span> function to generate the results.&#13;
Here is how I can incorporate these ideas:</p>&#13;
&#13;
<pre data-type="programlisting">def hamming(seq1: str, seq2: str) -&gt; int:&#13;
    """ Calculate Hamming distance """&#13;
&#13;
    distance = filter(lambda t: t[0] != t[1], zip_longest(seq1, seq2)) <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-1"><img alt="1" src="assets/1.png"/></a>&#13;
    return len(list((distance))) <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-2" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use <code>filter()</code> to find tuple pairs of different characters.</p></dd>&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-2" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Return the length of the resulting list.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 7: Using the map() Function with zip_longest()" data-type="sect2"><div class="sect2" id="idm45963634051432">&#13;
<h2>Solution 7: Using the map() Function with zip_longest()</h2>&#13;
&#13;
<p>This solution uses <code>map()</code> instead of <code>filter()</code> only to show you that the same inability to unpack the tuples also applies.<a data-primary="Hamming distance determination" data-secondary="solution 7 map() with zip_longest()" data-type="indexterm" id="idm45963634049144"/><a data-primary="map() function transforming" data-secondary="Hamming distance determination" data-type="indexterm" id="idm45963634048168"/><a data-primary="zip_longest() function" data-type="indexterm" id="idm45963634047192"/>&#13;
I’d like to use <code>map()</code> to produce a list of Boolean values indicating whether the character pairs match or not:<a data-primary="booleans" data-secondary="map() transforming matching pairs into" data-type="indexterm" id="idm45963634045832"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq1, seq2 = 'AC', 'ACGT'&#13;
&gt;&gt;&gt; list(map(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))&#13;
[False, False, True, True]</pre>&#13;
&#13;
<p>The <code>lambda</code> is identical to the one to <code>filter()</code> that was used as the <em>predicate</em> to determine which elements are allowed to pass.<a data-primary="lambda keyword" data-secondary="Hamming distance determination" data-type="indexterm" id="idm45963634042216"/>&#13;
Here the code <em>transforms</em> the elements into the result of applying the <code>lambda</code> function to the arguments, as shown in <a data-type="xref" href="#fig_6.6">Figure 6-6</a>.&#13;
Remember that <code>map()</code> will always return the same number of elements it consumes, but <code>filter()</code> may return fewer or none at all.</p>&#13;
&#13;
<figure><div class="figure" id="fig_6.6">&#13;
<img alt="mpfb 0606" src="assets/mpfb_0606.png"/>&#13;
<h6><span class="label">Figure 6-6. </span>The <code>map()</code> function transforms each tuple into a Boolean value representing the inequality of the two elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>I can sum these Booleans to get the number of mismatched pairs:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq1, seq2, = 'GAGCCTACTAACGGGAT', 'CATCGTAATGACGGCCT'&#13;
&gt;&gt;&gt; sum(map(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))&#13;
7</pre>&#13;
&#13;
<p>Here is the function with this idea:</p>&#13;
&#13;
<pre data-type="programlisting">def hamming(seq1: str, seq2: str) -&gt; int:&#13;
    """ Calculate Hamming distance """&#13;
&#13;
    return sum(map(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))</pre>&#13;
&#13;
<p>Even though these functions have gone from 10 or more lines of code to a single line, it still makes sense for this to be a function with a descriptive name and tests.&#13;
Eventually, you’ll start creating modules of reusable code to share across your projects.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 8: Using the starmap() and operator.ne() Functions" data-type="sect2"><div class="sect2" id="idm45963634032120">&#13;
<h2>Solution 8: Using the starmap() and operator.ne() Functions</h2>&#13;
&#13;
<p>I confess that I showed the last few solutions solely to build up to this last solution.&#13;
Let me start by showing how I can assign a <code>lambda</code> to a variable:<a data-primary="Hamming distance determination" data-secondary="solution 8 starmap() and operator.ne()" data-type="indexterm" id="idm45963634030216"/><a data-primary="lambda keyword" data-secondary="Hamming distance determination" data-type="indexterm" id="idm45963634029240"/><a data-primary="lambda keyword" data-secondary="assigned to variable" data-type="indexterm" id="idm45963634028280"/><a data-primary="variables" data-secondary="lambda assigned to" data-type="indexterm" id="idm45963634027336"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; not_same = lambda t: t[0] != t[1]</pre>&#13;
&#13;
<p>This is not recommended syntax, and <code>pylint</code> will definitely fail your code on this and recommend a <code>def</code> instead:</p>&#13;
&#13;
<pre data-type="programlisting">def not_same(t):&#13;
    return t[0] != t[1]</pre>&#13;
&#13;
<p>Both will create a function called <code>not_same()</code> that will accept a tuple and return whether the two elements are the same:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; not_same(('A', 'A'))&#13;
False&#13;
&gt;&gt;&gt; not_same(('A', 'T'))&#13;
True</pre>&#13;
&#13;
<p>If, however, I wrote the function to accept two positional arguments, the same error I saw before would crop up:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; not_same = lambda a, b: a != b&#13;
&gt;&gt;&gt; list(map(not_same, zip_longest(seq1, seq2)))&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
TypeError: &lt;lambda&gt;() missing 1 required positional argument: 'b'</pre>&#13;
&#13;
<p>What I need is a version of <code>map()</code> that can splat the incoming tuple (as I first showed in <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>) by adding <code>*</code> (<em>star</em>, <em>asterisk</em>, or <em>splat</em>) to the tuple to expand it into its elements, which is exactly what the function <code>itertools.starmap()</code> does (see <a data-type="xref" href="#fig_6.7">Figure 6-7</a>):<a data-primary="* (splat a tuple)" data-primary-sortas="# splat a tuple" data-type="indexterm" id="idm45963634015352"/><a data-primary="splatting a tuple (*)" data-type="indexterm" id="idm45963634014408"/><a data-primary="starmap() function" data-type="indexterm" id="idm45963634013736"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from itertools import zip_longest, starmap&#13;
&gt;&gt;&gt; seq1, seq2 = 'AC', 'ACGT'&#13;
&gt;&gt;&gt; list(starmap(not_same, zip_longest(seq1, seq2)))&#13;
[False, False, True, True]</pre>&#13;
&#13;
<figure><div class="figure" id="fig_6.7">&#13;
<img alt="mpfb 0607" src="assets/mpfb_0607.png"/>&#13;
<h6><span class="label">Figure 6-7. </span>The <code>starmap()</code> function applies a splat to the incoming tuple to turn it into the two values that the <code>lambda</code> expects</h6>&#13;
</div></figure>&#13;
&#13;
<p>But wait, there’s more!&#13;
I don’t even need to write my own <code>not_same()</code> function because I already have <code>operator.ne()</code> (not equal), which I usually write using the <code>!=</code> operator:<a data-primary="operator.ne (!=)" data-type="indexterm" id="idm45963634007288"/><a data-primary="!= (operator.ne)" data-primary-sortas="# operator.ne" data-type="indexterm" id="idm45963634006616"/><a data-primary="equal signs" data-secondary="!= (operator.ne)" data-secondary-sortas="# operator.ne" data-type="indexterm" id="idm45963634005672"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import operator&#13;
&gt;&gt;&gt; operator.ne('A', 'A')&#13;
False&#13;
&gt;&gt;&gt; operator.ne('A', 'T')&#13;
True</pre>&#13;
&#13;
<p>An <em>operator</em> is a special binary function (accepting two arguments) where the function name is usually some symbol like <code>+</code> that sits between the arguments.&#13;
In the case of <code>+</code>, Python has to decide if this means <code>operator.add()</code>:<a data-primary="operators" data-type="indexterm" id="idm45963634001288"/><a data-primary="functions" data-secondary="operators" data-type="indexterm" id="idm45963634000616"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 1 + 2&#13;
3&#13;
&gt;&gt;&gt; operator.add(1, 2)&#13;
3</pre>&#13;
&#13;
<p>or <code>operator.concat()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; 'AC' + 'GT'&#13;
'ACGT'&#13;
&gt;&gt;&gt; operator.concat('AC', 'GT')&#13;
'ACGT'</pre>&#13;
&#13;
<p>The point is that I already have an existing function that expects two arguments and returns whether they are equal, and I can use <code>starmap()</code> to properly expand the tuples into the needed arguments:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq1, seq2 = 'AC', 'ACGT'&#13;
&gt;&gt;&gt; list(starmap(operator.ne, zip_longest(seq1, seq2)))&#13;
[False, False, True, True]</pre>&#13;
&#13;
<p>As before, the Hamming distance is the sum of the unmatched pairs:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq1, seq2, = 'GAGCCTACTAACGGGAT', 'CATCGTAATGACGGCCT'&#13;
&gt;&gt;&gt; sum(starmap(operator.ne, zip_longest(seq1, seq2)))&#13;
7</pre>&#13;
&#13;
<p>To see it in action:</p>&#13;
&#13;
<pre data-type="programlisting">def hamming(seq1: str, seq2: str) -&gt; int:&#13;
    """ Calculate Hamming distance """&#13;
&#13;
    return sum(starmap(operator.ne, zip_longest(seq1, seq2))) <a class="co" href="#callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO11-1" id="co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO11-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO11-1" id="callout_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO11-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Zip the sequences, transform the tuples to Boolean comparisons, and sum.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This final solution relies entirely on fitting four functions that I didn’t write.&#13;
I believe the best code is code you don’t write (or test or document).&#13;
While I prefer this purely functional solution, you may feel this code is overly clever.&#13;
You should use whatever version you’ll be able to understand a year later.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963633986232">&#13;
<h1>Going Further</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Without looking at the source code, write a version of <code>zip_longest()</code>. Be sure to start with a test, then write the function that satisfies the test.</p>&#13;
</li>&#13;
<li>&#13;
<p>Expand your program to handle more than two input sequences. Have your program print the Hamming distance between every pair of sequences. That means the program will print <em>n</em> choose <em>k</em> numbers which will be <em>n</em>! / <em>k</em>!(<em>n</em> – <em>k</em>)!. For three sequences, your program will print 3! / (2!(3 – 2)!) = 6 / 2 = 3 distance pairs.</p>&#13;
</li>&#13;
<li>&#13;
<p>Try writing a sequence alignment algorithm that will show there is, for instance, just one difference between the sequences <em>AAACCCGGGTTT</em> and <em>AACCCGGGTTTA</em>.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963633977448">&#13;
<h1>Review</h1>&#13;
&#13;
<p>This was a rather deep rabbit hole to go down just to find the Hamming distance, but it highlights lots of interesting bits about Python functions:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The built-in <code>zip()</code> function will combine two or more lists into a list of tuples, grouping elements at common positions. It stops at the shortest sequence, so use the <code>itertools.zip_longest()</code> function if you want to go to the longest sequence.</p>&#13;
</li>&#13;
<li>&#13;
<p>Both <code>map()</code> and <code>filter()</code> apply a function to some iterable of values. The <code>map()</code> function will return a new sequence transformed by the function, while <code>filter()</code> will only return those elements that return a truthy value when the function is applied.</p>&#13;
</li>&#13;
<li>&#13;
<p>The function passed to <code>map()</code> and <code>filter()</code> can be an anonymous function created by <code>lambda</code> or an existing function.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>operator</code> module contains many functions like <code>ne()</code> (not equal) that can be used with <code>map()</code> and <code>filter()</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>functools.starmap()</code> function works just like <code>map()</code> but will splat the function’s incoming values to expand them into a list of values.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>