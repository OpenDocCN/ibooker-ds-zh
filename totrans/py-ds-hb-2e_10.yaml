- en: 'Chapter 8\. Computation on Arrays: Broadcasting'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw in [Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs)
    how NumPy’s universal functions can be used to *vectorize* operations and thereby
    remove slow Python loops. This chapter discusses *broadcasting*: a set of rules
    by which NumPy lets you apply binary operations (e.g., addition, subtraction,
    multiplication, etc.) between arrays of different sizes and shapes.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Broadcasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall that for arrays of the same size, binary operations are performed on
    an element-by-element basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Broadcasting allows these types of binary operations to be performed on arrays
    of different sizes—for example, we can just as easily add a scalar (think of it
    as a zero-dimensional array) to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can think of this as an operation that stretches or duplicates the value
    `5` into the array `[5, 5, 5]`, and adds the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can similarly extend this idea to arrays of higher dimension. Observe the
    result when we add a one-dimensional array to a two-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here the one-dimensional array `a` is stretched, or broadcasted, across the
    second dimension in order to match the shape of `M`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these examples are relatively easy to understand, more complicated cases
    can involve broadcasting of both arrays. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Just as before we stretched or broadcasted one value to match the shape of the
    other, here we’ve stretched *both* `a` and `b` to match a common shape, and the
    result is a two-dimensional array! The geometry of these examples is visualized
    in [Figure 8-1](#fig_images_in_0205-broadcasting).
  prefs: []
  type: TYPE_NORMAL
- en: 'The light boxes represent the broadcasted values. This way of thinking about
    broadcasting may raise questions about its efficiency in terms of memory use,
    but worry not: NumPy broadcasting does not actually copy the broadcasted values
    in memory. Still, this can be a useful mental model as we think about broadcasting.'
  prefs: []
  type: TYPE_NORMAL
- en: '![02.05 broadcasting](assets/02.05-broadcasting.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Visualization of NumPy broadcasting (adapted from a source published
    in the [astroML documentation](http://astroml.org) and used with permission)^([1](ch08.xhtml#idm45858801111664))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Rules of Broadcasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Broadcasting in NumPy follows a strict set of rules to determine the interaction
    between the two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: Rule 1
  prefs: []
  type: TYPE_NORMAL
- en: If the two arrays differ in their number of dimensions, the shape of the one
    with fewer dimensions is *padded* with ones on its leading (left) side.
  prefs: []
  type: TYPE_NORMAL
- en: Rule 2
  prefs: []
  type: TYPE_NORMAL
- en: If the shape of the two arrays does not match in any dimension, the array with
    shape equal to 1 in that dimension is stretched to match the other shape.
  prefs: []
  type: TYPE_NORMAL
- en: Rule 3
  prefs: []
  type: TYPE_NORMAL
- en: If in any dimension the sizes disagree and neither is equal to 1, an error is
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: To make these rules clear, let’s consider a few examples in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting Example 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we want to add a two-dimensional array to a one-dimensional array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s consider an operation on these two arrays, which have the following shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M.shape` is `(2, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a.shape` is `(3,)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We see by rule 1 that the array `a` has fewer dimensions, so we pad it on the
    left with ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M.shape` remains `(2, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a.shape` becomes `(1, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By rule 2, we now see that the first dimension disagrees, so we stretch this
    dimension to match:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M.shape` remains `(2, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a.shape` becomes `(2, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The shapes now match, and we see that the final shape will be `(2, 3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Broadcasting Example 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s take a look at an example where both arrays need to be broadcast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we’ll start by determining the shapes of the arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a.shape` is `(3, 1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b.shape` is `(3,)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rule 1 says we must pad the shape of `b` with ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a.shape` remains `(3, 1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b.shape` becomes `(1, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And rule 2 tells us that we must upgrade each of these `1`s to match the corresponding
    size of the other array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a.shape` becomes `(3, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b.shape` becomes `(3, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because the results match, these shapes are compatible. We can see this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Broadcasting Example 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at an example in which the two arrays are not compatible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a slightly different situation than in the first example: the
    matrix `M` is transposed. How does this affect the calculation? The shapes of
    the arrays are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M.shape` is `(3, 2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a.shape` is `(3,)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, rule 1 tells us that we must pad the shape of `a` with ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M.shape` remains `(3, 2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a.shape` becomes `(1, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By rule 2, the first dimension of `a` is then stretched to match that of `M`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`M.shape` remains `(3, 2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a.shape` becomes `(3, 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we hit rule 3—the final shapes do not match, so these two arrays are incompatible,
    as we can observe by attempting this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the potential confusion here: you could imagine making `a` and `M` compatible
    by, say, padding `a`’s shape with ones on the right rather than the left. But
    this is not how the broadcasting rules work! That sort of flexibility might be
    useful in some cases, but it would lead to potential areas of ambiguity. If right-side
    padding is what you’d like, you can do this explicitly by reshaping the array
    (we’ll use the `np.newaxis` keyword introduced in [Chapter 5](ch05.xhtml#section-0202-the-basics-of-numpy-arrays)
    for this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'While we’ve been focusing on the `+` operator here, these broadcasting rules
    apply to *any* binary ufunc. For example, here is the `logaddexp(a, b)` function,
    which computes `log(exp(a) + exp(b))` with more precision than the naive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For more information on the many available universal functions, refer to [Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs).
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting in Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Broadcasting operations form the core of many examples you’ll see throughout
    this book. We’ll now take a look at some instances of where they can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Centering an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.xhtml#section-0203-computation-on-arrays-ufuncs), we saw
    that ufuncs allow a NumPy user to remove the need to explicitly write slow Python
    loops. Broadcasting extends this ability. One commonly seen example in data science
    is subtracting the row-wise mean from an array of data. Imagine we have an array
    of 10 observations, each of which consists of 3 values. Using the standard convention
    (see [Chapter 38](ch38.xhtml#section-0502-introducing-scikit-learn)), we’ll store
    this in a <math alttext="10 times 3"><mrow><mn>10</mn> <mo>×</mo> <mn>3</mn></mrow></math>
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compute the mean of each column using the `mean` aggregate across the
    first dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can center the `X` array by subtracting the mean (this is a broadcasting
    operation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To double-check that we’ve done this correctly, we can check that the centered
    array has a mean near zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To within machine precision, the mean is now zero.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting a Two-Dimensional Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One place that broadcasting often comes in handy is in displaying images based
    on two-dimensional functions. If we want to define a function <math alttext="z
    equals f left-parenthesis x comma y right-parenthesis"><mrow><mi>z</mi> <mo>=</mo>
    <mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></math>
    , broadcasting can be used to compute the function across the grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use Matplotlib to plot this two-dimensional array, shown in [Figure 8-2](#fig_0205-computation-on-arrays-broadcasting_files_in_output_52_0)
    (these tools will be discussed in full in [Chapter 28](ch28.xhtml#section-0404-density-and-contour-plots)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![output 52 0](assets/output_52_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Visualization of a 2D array
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The result is a compelling visualization of the two-dimensional function.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.xhtml#idm45858801111664-marker)) Code to produce this plot can be
    found in the online [appendix](https://oreil.ly/gtOaU).
  prefs: []
  type: TYPE_NORMAL
