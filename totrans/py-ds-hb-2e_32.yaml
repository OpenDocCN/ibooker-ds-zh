- en: Chapter 28\. Density and Contour Plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes it is useful to display three-dimensional data in two dimensions
    using contours or color-coded regions. There are three Matplotlib functions that
    can be helpful for this task: `plt.contour` for contour plots, `plt.contourf`
    for filled contour plots, and `plt.imshow` for showing images. This chapter looks
    at several examples of using these. We’ll start by setting up the notebook for
    plotting and importing the functions we will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Visualizing a Three-Dimensional Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first example demonstrates a contour plot using a function <math alttext="z
    equals f left-parenthesis x comma y right-parenthesis"><mrow><mi>z</mi> <mo>=</mo>
    <mi>f</mi> <mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo>)</mo></mrow></math>
    , using the following particular choice for <math alttext="f"><mi>f</mi></math>
    (we’ve seen this before in [Chapter 8](ch08.xhtml#section-0205-computation-on-arrays-broadcasting),
    when we used it as a motivating example for array broadcasting):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A contour plot can be created with the `plt.contour` function. It takes three
    arguments: a grid of *x* values, a grid of *y* values, and a grid of *z* values.
    The *x* and *y* values represent positions on the plot, and the *z* values will
    be represented by the contour levels. Perhaps the most straightforward way to
    prepare such data is to use the `np.meshgrid` function, which builds two-dimensional
    grids from one-dimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s look at this with a standard line-only contour plot (see [Figure 28-1](#fig_0404-density-and-contour-plots_files_in_output_9_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![output 9 0](assets/output_9_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-1\. Visualizing three-dimensional data with contours
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that when a single color is used, negative values are represented by
    dashed lines and positive values by solid lines. Alternatively, the lines can
    be color-coded by specifying a colormap with the `cmap` argument. Here we’ll also
    specify that we want more lines to be drawn, at 20 equally spaced intervals within
    the data range, as shown in [Figure 28-2](#fig_0404-density-and-contour-plots_files_in_output_11_0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![output 11 0](assets/output_11_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-2\. Visualizing three-dimensional data with colored contours
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here we chose the `RdGy` (short for *Red–Gray*) colormap, which is a good choice
    for divergent data: (i.e., data with positive and negative variation around zero).
    Matplotlib has a wide range of colormaps available, which you can easily browse
    in IPython by doing a tab completion on the `plt.cm` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our plot is looking nicer, but the spaces between the lines may be a bit distracting.
    We can change this by switching to a filled contour plot using the `plt.contourf`
    function, which uses largely the same syntax as `plt.contour`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we’ll add a `plt.colorbar` command, which creates an additional
    axis with labeled color information for the plot (see [Figure 28-3](#fig_0404-density-and-contour-plots_files_in_output_13_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![output 13 0](assets/output_13_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-3\. Visualizing three-dimensional data with filled contours
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The colorbar makes it clear that the black regions are “peaks,” while the red
    regions are “valleys.”
  prefs: []
  type: TYPE_NORMAL
- en: 'One potential issue with this plot is that it is a bit splotchy: the color
    steps are discrete rather than continuous, which is not always what is desired.
    This could be remedied by setting the number of contours to a very high number,
    but this results in a rather inefficient plot: Matplotlib must render a new polygon
    for each step in the level. A better way to generate a smooth representation is
    to use the `plt.imshow` function, which offers the `interpolation` argument to
    generate a smooth two-dimensional representation of the data (see [Figure 28-4](#fig_0404-density-and-contour-plots_files_in_output_15_0)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![output 15 0](assets/output_15_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-4\. Representing three-dimensional data as an image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are a few potential gotchas with `plt.imshow`, however:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t accept an *x* and *y* grid, so you must manually specify the *extent*
    [*xmin*, *xmax*, *ymin*, *ymax*] of the image on the plot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default it follows the standard image array definition where the origin is
    in the upper left, not in the lower left as in most contour plots. This must be
    changed when showing gridded data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will automatically adjust the axis aspect ratio to match the input data;
    this can be changed with the `aspect` argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it can sometimes be useful to combine contour plots and image plots.
    For example, here we’ll use a partially transparent background image (with transparency
    set via the `alpha` parameter) and overplot contours with labels on the contours
    themselves, using the `plt.clabel` function (see [Figure 28-5](#fig_0404-density-and-contour-plots_files_in_output_18_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![output 18 0](assets/output_18_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-5\. Labeled contours on top of an image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The combination of these three functions—`plt.contour`, `plt.contourf`, and
    `plt.imshow`—gives nearly limitless possibilities for displaying this sort of
    three-dimensional data within a two-dimensional plot. For more information on
    the options available in these functions, refer to their docstrings. If you are
    interested in three-dimensional visualizations of this type of data, see [Chapter 35](ch35.xhtml#section-0412-three-dimensional-plotting).
  prefs: []
  type: TYPE_NORMAL
- en: Histograms, Binnings, and Density
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple histogram can be a great first step in understanding a dataset. Earlier,
    we saw a preview of Matplotlib’s histogram function (discussed in [Chapter 9](ch09.xhtml#section-0206-boolean-arrays-and-masks)),
    which creates a basic histogram in one line, once the normal boilerplate imports
    are done (see [Figure 28-6](#fig_0405-histograms-and-binnings_files_in_output_3_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![output 3 0](assets/output_3_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-6\. A simple histogram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `hist` function has many options to tune both the calculation and the display;
    here’s an example of a more customized histogram, shown in [Figure 28-7](#fig_0405-histograms-and-binnings_files_in_output_5_0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![output 5 0](assets/output_5_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-7\. A customized histogram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `plt.hist` docstring has more information on other available customization
    options. I find this combination of `histtype='stepfilled'` along with some transparency
    `alpha` to be helpful when comparing histograms of several distributions (see
    [Figure 28-8](#fig_0405-histograms-and-binnings_files_in_output_7_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![output 7 0](assets/output_7_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-8\. Overplotting multiple histograms^([1](ch28.xhtml#idm45858759342144))
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you are interested in computing, but not displaying, the histogram (that
    is, counting the number of points in a given bin), you can use the `np.histogram`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Two-Dimensional Histograms and Binnings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we create histograms in one dimension by dividing the number line into
    bins, we can also create histograms in two dimensions by dividing points among
    two-dimensional bins. We’ll take a brief look at several ways to do this. Let’s
    start by defining some data—an `x` and `y` array drawn from a multivariate Gaussian
    distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'plt.hist2d: Two-Dimensional Histogram'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One straightforward way to plot a two-dimensional histogram is to use Matplotlib’s
    `plt.hist2d` function (see [Figure 28-9](#fig_0405-histograms-and-binnings_files_in_output_13_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![output 13 0](assets/output_13_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-9\. A two-dimensional histogram with plt.hist2d
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Just like `plt.hist`, `plt.hist2d` has a number of extra options to fine-tune
    the plot and the binning, which are nicely outlined in the function docstring.
    Further, just as `plt.hist` has a counterpart in `np.histogram`, `plt.hist2d`
    has a counterpart in `np.histogram2d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For the generalization of this histogram binning when there are more than two
    dimensions, see the `np.histogramdd` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'plt.hexbin: Hexagonal Binnings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two-dimensional histogram creates a tesselation of squares across the axes.
    Another natural shape for such a tesselation is the regular hexagon. For this
    purpose, Matplotlib provides the `plt.hexbin` routine, which represents a two-dimensional
    dataset binned within a grid of hexagons (see [Figure 28-10](#fig_0405-histograms-and-binnings_files_in_output_18_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![output 18 0](assets/output_18_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-10\. A two-dimensional histogram with plt.hexbin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`plt.hexbin` has a number of additional options, including the ability to specify
    weights for each point and to change the output in each bin to any NumPy aggregate
    (mean of weights, standard deviation of weights, etc.).'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel Density Estimation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common method for estimating and representing densities in multiple
    dimensions is *kernel density estimation* (KDE). This will be discussed more fully
    in [Chapter 49](ch49.xhtml#section-0513-kernel-density-estimation), but for now
    I’ll simply mention that KDE can be thought of as a way to “smear out” the points
    in space and add up the result to obtain a smooth function. One extremely quick
    and simple KDE implementation exists in the `scipy.stats` package. Here is a quick
    example of using KDE (see [Figure 28-11](#fig_0405-histograms-and-binnings_files_in_output_21_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![output 21 0](assets/output_21_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 28-11\. A kernel density representation of a distribution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: KDE has a smoothing length that effectively slides the knob between detail and
    smoothness (one example of the ubiquitous bias–variance trade-off). The literature
    on choosing an appropriate smoothing length is vast; `gaussian_kde` uses a rule
    of thumb to attempt to find a nearly optimal smoothing length for the input data.
  prefs: []
  type: TYPE_NORMAL
- en: Other KDE implementations are available within the SciPy ecosystem, each with
    its own strengths and weaknesses; see, for example, `sklearn.neighbors.KernelDensity`
    and `statsmodels.nonparametric.KDEMultivariate`.
  prefs: []
  type: TYPE_NORMAL
- en: For visualizations based on KDE, using Matplotlib tends to be overly verbose.
    The Seaborn library, discussed in [Chapter 36](ch36.xhtml#section-0414-visualization-with-seaborn),
    provides a much more compact API for creating KDE-based visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch28.xhtml#idm45858759342144-marker)) A full-color version of this figure
    can be found on [GitHub](https://oreil.ly/PDSH_GitHub).
  prefs: []
  type: TYPE_NORMAL
