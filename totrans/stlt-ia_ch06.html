<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>chapter-7</title>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
 </head>
 <body>
  <div class="readable-text " id="p1"> 
   <h1 class=" readable-text-h1"><span class="chapter-title-numbering"><span class="num-string">7</span></span> The CEO Strikes Back: Supercharging our dashboard</h1>
  </div>
  <div class="introduction-summary"> 
   <h3>This chapter covers</h3>
   <ul> 
    <li class="readable-text" id="p2">Critically evaluating an app and resolving user feedback</li>
    <li class="readable-text" id="p3">Adding flexibility to Streamlit visualizations</li>
    <li class="readable-text" id="p4">Improving usability by making commonly-used features easy to access</li>
    <li class="readable-text" id="p5">Creating modal dialogs in Streamlit</li>
    <li class="readable-text" id="p6">Using query parameters to enable deeplinks in a Streamlit app</li>
   </ul>
  </div>
  <div class="readable-text " id="p7"> 
   <p>When Python was first released, it lacked many of the features we rely on today. The Python we know and love has been carefully refined over the years—and that process is still ongoing. A big part of this evolution comes from the feedback of developers who actively build with the language.</p>
  </div>
  <div class="readable-text  intended-text" id="p8"> 
   <p>Indeed, no software is perfect at launch. Instead, it is refined over time, with a bugfix here and a new feature added there. The projects we build in this book are no exception.</p>
  </div>
  <div class="readable-text  intended-text" id="p9"> 
   <p>In the previous chapter, we created a metrics dashboard for a company called Note n' Nib. In this one, we'll skip forward and see how users responded. We'll use their opinions and comments to revisit our app in a critical light and improve it. As we go through this process, we'll learn more about Streamlit visualizations, introduce modal dialogs and query parameters, and understand how to program an advanced, flexible dashboard.</p>
  </div>
  <div class="readable-text  intended-text" id="p10"> 
   <p>If Chapter 6 was about <em>launching</em> a dashboard based on user requirements, Chapter 7 is about <em>landing</em> it, addressing our users' concerns and iterating on the app to ensure quality and satisfaction.</p>
  </div>
  <div class="readable-text" id="p11"> 
   <h2 class=" readable-text-h2">7.1 Feedback on the dashboard</h2>
  </div>
  <div class="readable-text " id="p12"> 
   <p>The dashboard you built in the last chapter has made waves at Note n' Nib. For the first time, the company's executives can look up updated sales numbers, compare performance between products, and analyze trends on their own, without having to enlist help from Engineering.</p>
  </div>
  <div class="readable-text  intended-text" id="p13"> 
   <p>The CEO has requested that all staff meetings start with a review of the key sales metrics, which means that the top brass is now intimately familiar with your dashboard. Of course, with that kind of attention comes increased scrutiny, and you're not entirely surprised when, one Monday afternoon a few weeks after launch, you find an email from the CEO in your inbox.</p>
  </div>
  <div class="readable-text  intended-text" id="p14"> 
   <p>The email contains collated feedback about your dashboard from the higher-ups—essentially a wishlist of additional features for you to implement.</p>
  </div>
  <div class="readable-text  intended-text" id="p15"> 
   <p>Well, there goes the rest of your week. You're excited about the work, though, since you get to play with Streamlit some more! Over the course of this chapter, we'll inspect and resolve each item of feedback.</p>
  </div>
  <div class="readable-text" id="p16"> 
   <h2 class=" readable-text-h2">7.2 Granularity in the time series chart</h2>
  </div>
  <div class="readable-text " id="p17"> 
   <p>The first bullet point in the email reads: "The time chart is useful in reviewing a few days of data, but it's hard to make sense of for longer periods".</p>
  </div>
  <div class="readable-text  intended-text" id="p18"> 
   <p>Recall that our dashboard has a line chart showing a selected metric's evolution over time. For smaller date ranges (about a month or so), it works reasonably well (see the left side of figure 7.1), but for longer ones (say a year or more), it looks like the right side.</p>
  </div>
  <div class="browsable-container figure-container" id="p19">  
   <img src="../Images/ch07__image001.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.1 The day granularity in the existing time chart works for small time frames like a month (left) but not for longer time frames (right)</h5>
  </div>
  <div class="readable-text " id="p20"> 
   <p>All the data is there, but there's so much of it that it's overwhelming. When considering <em>years</em> of data, we don't need to plot a single point for every date in the range.</p>
  </div>
  <div class="readable-text  intended-text" id="p21"> 
   <p>You can see how doing so increases the number of individual markers in the chart; if we're observing a date range of two years, that's 365 x 2 = 730 points—far too many to interpret.</p>
  </div>
  <div class="readable-text  intended-text" id="p22"> 
   <p>So, how do we address this? A granularity of a single day is too much over a longer time horizon, but if we have a shorter date range, like a week or a month, it's reasonable. For longer ranges, we would probably want one marker for a week, a month, or perhaps even a year.</p>
  </div>
  <div class="readable-text  intended-text" id="p23"> 
   <p>The easiest solution would be to allow the user to pick the granularity they want. Let's tackle this now.</p>
  </div>
  <div class="readable-text" id="p24"> 
   <h3 class=" readable-text-h3">7.2.1 Enabling different time grains</h3>
  </div>
  <div class="readable-text " id="p25"> 
   <p>To enable weekly, monthly, and yearly granularities, we first have to ensure our data <em>has</em> those fields, which it doesn't currently. Once we do, we'll be able to aggregate each metric to the right grain.</p>
  </div>
  <div class="readable-text  intended-text" id="p26"> 
   <p>Recall that the flow of data in our app starts with the <kbd>load_data</kbd> function in <kbd>data_loader.py</kbd>, which obtains the data from an external source, currently a CSV file.</p>
  </div>
  <div class="readable-text  intended-text" id="p27"> 
   <p>This is followed by <kbd>prep_data</kbd> in <kbd>data_wrangling.py</kbd> where we rename the columns and add the <kbd>Day</kbd> field. This is also where we need to make changes to incorporate the other grains we want.</p>
  </div>
  <div class="readable-text  intended-text" id="p28"> 
   <p>Go ahead and edit <kbd>prep_data</kbd> so it now looks like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p29"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">@st.cache_data(show_spinner="Reading sales data...", ttl="1d")
def prep_data() -&gt; pd.DataFrame:
  df = clean_column_names(load_data())
  df['Day'] = pd.to_datetime(df['Date'])
  <b>df['Week'] = df['Day'].dt.to_period('W').dt.to_timestamp()</b>
<b>  df['Month'] = df['Day'].dt.to_period('M').dt.to_timestamp()</b>
<b>  df['Year'] = df['Day'].dt.to_period('Y').dt.to_timestamp()</b>
  return df</pre>
   </div>
  </div>
  <div class="readable-text " id="p30"> 
   <p>We're adding three new columns to the Pandas dataframe: <kbd>Week</kbd>, <kbd>Month</kbd> and <kbd>Year</kbd>. To obtain each field, we start with the <kbd>Day</kbd> column (<kbd>df['Day']</kbd>), convert it to a period, and then convert the result to a timestamp. Consider one such statement:</p>
  </div>
  <div class="browsable-container listing-container" id="p31"> 
   <div class="code-area-container"> 
    <pre class="code-area"> df['Month'] = df['Day'].dt.to_period('M').dt.to_timestamp()</pre>
   </div>
  </div>
  <div class="readable-text " id="p32"> 
   <p><kbd>.dt</kbd> here is used to access the date/time-related properties of the column in an element-wise manner. <kbd>to_period('M')</kbd> converts the <kbd>Day</kbd> column into a monthly "period" type internal to Pandas, representing a whole month rather than a specific point in time.</p>
  </div>
  <div class="readable-text  intended-text" id="p33"> 
   <p>We then use a second <kbd>.dt</kbd> accessor to get the date/time properties of the transformed column, and finally <kbd>.to_timestamp()</kbd> to convert each monthly period into a date representing the start of the month.</p>
  </div>
  <div class="readable-text  intended-text" id="p34"> 
   <p>For instance, if one of the elements we're operating on in <kbd>df['Day']</kbd> is the date <kbd>2024-07-12</kbd>, we end up with the date <kbd>2024-07-01</kbd>, the start of the corresponding month.</p>
  </div>
  <div class="readable-text  intended-text" id="p35"> 
   <p>The other two statements that create the <kbd>Week</kbd> and <kbd>Year</kbd> columns are analogous, adding dates representing the start of the week and the year respectively.</p>
  </div>
  <div class="readable-text  intended-text" id="p36"> 
   <p>Elsewhere in the code—specifically within (other) functions in <kbd>data_wrangling.py</kbd> and <kbd>time_series_chart.py</kbd>—we've been treating <kbd>Day</kbd> as a hardcoded column name. Once we have these other columns, all we need to do in the backend is to introduce a variable to represent the grain instead.</p>
  </div>
  <div class="readable-text  intended-text" id="p37"> 
   <p>So, the function <kbd>get_metric_time_series</kbd> from <kbd>data_wrangling.py</kbd> would now look like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p38"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">def get_metric_time_series(df, metric, <b>grain</b>):
  grouped = df.groupby(<b>grain</b>)
  data = grouped.apply(metric.func, include_groups=False).reset_index()
  data.columns = [<b>grain</b>, 'Value']
  return data</pre>
   </div>
  </div>
  <div class="readable-text " id="p39"> 
   <p>And<kbd> get_time_series_chart</kbd> (in <kbd>time_series_chart.py</kbd>) becomes:</p>
  </div>
  <div class="browsable-container listing-container" id="p40"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">def get_time_series_chart(df, metric, <b>grain</b>):
  data = get_metric_time_series(df, metric, <b>grain</b>)
  fig = go.Figure()
  fig.add_trace(
    go.Scatter(x=data[<b>grain</b>], y=data['Value'], mode='lines+markers')
  )
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
  fig.update_layout(
    title=f"{metric.title}",
    xaxis_title=<b>grain</b>,
    yaxis_title=metric.title
  )
  return fig</pre>
   </div>
  </div>
  <div class="readable-text " id="p41"> 
   <p>In both cases, we're making the same changes: adding <kbd>grain</kbd> as a new parameter in the function, and replacing <kbd>'Day'</kbd> wherever it occurs to <kbd>grain</kbd>.</p>
  </div>
  <div class="readable-text" id="p42"> 
   <h3 class=" readable-text-h3">7.2.2 Creating a time grain selector</h3>
  </div>
  <div class="readable-text " id="p43"> 
   <p>Now that we've wired up the functions that ultimately generate the time series chart to handle <kbd>grain</kbd> as a variable, we need to provide the user with a way to select what grain they want.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p44"> 
   <h4 class=" readable-text-h4">st.select_slider</h4>
  </div>
  <div class="readable-text " id="p45"> 
   <p>Let's use a new Streamlit widget for this: <kbd>st.select_slider</kbd>, another selection element. <kbd>st.select_slider</kbd> is a cross between<kbd> st.selectbox</kbd>, which lets you pick a single value from a dropdown, and <kbd>st.slider</kbd>, which lets you choose a numeric value.</p>
  </div>
  <div class="readable-text  intended-text" id="p46"> 
   <p>You use it when you have a list of text options for users to pick from, but also want to impose some ordering on them. For instance, when you're creating options for a survey, "Strongly agree", "Agree", "Neutral", "Disagree", and "Strongly disagree" are strings, but they have a specific order to them—from the most to the least agreement.</p>
  </div>
  <div class="readable-text  intended-text" id="p47"> 
   <p>In our case, the time grain options we want the user to see—"Day," "Week," "Month," and "Year"—also have an order, from the smallest unit of time to the largest.</p>
  </div>
  <div class="readable-text  intended-text" id="p48"> 
   <p>For our purposes, we can use <kbd>st.select_slider</kbd> like this within the <kbd>time_series_chart</kbd> function in <kbd>time_series_chart.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p49"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">def time_series_chart(df):
  with st.container(border=True):
    <b>grain_options = ["Day", "Week", "Month", "Year"]</b>
<b>    grain = st.select_slider("Time grain", grain_options)</b>
    chart_tabs = st.tabs(display_metrics)
    for idx, met in enumerate(display_metrics):
      with chart_tabs[idx]:
        chart = get_time_series_chart(df, metrics[met], <b>grain</b>)
        st.plotly_chart(chart, use_container_width=True)</pre>
   </div>
  </div>
  <div class="readable-text " id="p50"> 
   <p><kbd>grain_options</kbd> here holds the ordered list of options, and is fed to the second parameter of <kbd>st.select_slider</kbd>, the first being the label to display. You'll find these parameters very similar to those of <kbd>st.selectbox</kbd> and <kbd>st.radio</kbd>. <kbd>st.select_slider</kbd> returns the option selected by the user, which we store in <kbd>grain</kbd>, and pass as the new parameter we recently added to <kbd>get_time_series_chart</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p51"> 
   <p>Save and run your app with<kbd> streamlit run &lt;path to dashboard.py&gt;</kbd> to get figure 7.2</p>
  </div>
  <div class="browsable-container figure-container" id="p52">  
   <img src="../Images/ch07__image002.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.2 The line chart now has a time grain selector (see chapter_7/in_progress_01 in the GitHub repo for the full code at this point)</h5>
  </div>
  <div class="readable-text " id="p53"> 
   <p>Play around with the grain selector. Using the month grain makes the chart much more palatable when viewing a long date range spanning multiple years.</p>
  </div>
  <div class="readable-text" id="p54"> 
   <h2 class=" readable-text-h2">7.3 Interdependent filters</h2>
  </div>
  <div class="readable-text " id="p55"> 
   <p>"If I've already selected the 'Writing tools' category, why does it still ask me if I want to see staples and calendars?" asks a verbatim comment in the email, reportedly from the CFO, one of the dashboard's more passionate users.</p>
  </div>
  <div class="readable-text  intended-text" id="p56"> 
   <p>You admit it's a valid question. She's referring to the filter bar in figure 7.3, which doesn't take the existing selections into account while displaying options in the filter dropdowns, leading to nonsensical combinations such as "Writing tools" paired with "Paper clips."</p>
  </div>
  <div class="browsable-container figure-container" id="p57">  
   <img src="../Images/ch07__image003.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.3 The filter bar options can have mismatching combinations</h5>
  </div>
  <div class="readable-text " id="p58"> 
   <p>The filter bar isn't "intelligent". Filtering on a product category doesn't update the options available to the user in the segment and product name filters, even if those segments and products don't belong to the selected category.</p>
  </div>
  <div class="readable-text  intended-text" id="p59"> 
   <p>If a user filters the data for "Writing tools", it's a bit annoying to still see all the other product lines (like "Paper clips") in the segment dropdown. The example data we've been using only has ten products overall, so it isn't a dealbreaker per se, but consider the situation where there are hundreds. At that point, using the higher levels in the product hierarchy (like "category") to filter out irrelevant products from the other dropdowns becomes a necessary feature, not a nice-to-have.</p>
  </div>
  <div class="readable-text  intended-text" id="p60"> 
   <p>Let's consider how to fix this.</p>
  </div>
  <div class="readable-text  intended-text" id="p61"> 
   <p>One possibility is to record the interdependencies between the dimensions, and then look up and resolve those dependencies while obtaining the unique values for each field. For example, since<kbd> Product name</kbd> should depend on the selections for <kbd>Category</kbd> and <kbd>Segment</kbd>, we might record that dependency somewhere.</p>
  </div>
  <div class="readable-text  intended-text" id="p62"> 
   <p>This requires us to maintain a new configuration and the logic could get fairly involved.</p>
  </div>
  <div class="readable-text  intended-text" id="p63"> 
   <p>There's an easier alternative: rather than obtaining all the unique filter values first and <em>then </em>filtering the dataframe (figure 7.4), we could get the unique values for the first filter, apply the filter to get a new dataframe, get the unique values for the second filter, apply that one too, and so on.</p>
  </div>
  <div class="browsable-container figure-container" id="p64">  
   <img src="../Images/ch07__image004.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.4 Old filtering approach: Get unique values for all filters first, then filter based on selections</h5>
  </div>
  <div class="readable-text " id="p65"> 
   <p>In the new approach (figure 7.5), since we filter the data frame before getting the unique values for the next filter, we're guaranteed to show only the available values.</p>
  </div>
  <div class="browsable-container figure-container" id="p66">  
   <img src="../Images/ch07__image005.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.5 New filtering approach: Get unique values for each filter, apply filter based on selection, then repeat for other filters</h5>
  </div>
  <div class="readable-text " id="p67"> 
   <p>So when a user selects the category <kbd>"Writing tools"</kbd> the dataframe is filtered to only include those rows, and the unique values for the segment filter are drawn from this new set, which won't include staplers and the like.</p>
  </div>
  <div class="readable-text  intended-text" id="p68"> 
   <p>To implement this, modify <kbd>filter_panel</kbd>.py:</p>
  </div>
  <div class="browsable-container listing-container" id="p69"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
from data_wrangling import get_unique_values, <b>apply_filters</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
filter_dims = ["Age group", "Gender", "Category", "Segment",
               "Product name", "State"]
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
def filter_panel(df):
  filters = {}
  with st.expander("Filters"):
    filter_cols = st.columns(len(filter_dims))
    <b>effective_df = df</b>
    for idx, dim in enumerate(filter_dims):
      with filter_cols[idx]:
        <b>effective_df = apply_filters(effective_df, filters)</b>
        unique_vals = get_unique_values(effective_df, dim)
        filters[dim] = st.multiselect(dim, unique_vals)
  return filters</pre>
   </div>
  </div>
  <div class="readable-text " id="p70"> 
   <p>The changes aren't too complicated. In each iteration through the filter fields, rather than passing <kbd>df</kbd> directly to <kbd>get_unique_values</kbd> to get the set of dropdown options to display, we introduce a variable called <kbd>effective_df</kbd> and pass that.</p>
  </div>
  <div class="readable-text  intended-text" id="p71"> 
   <p>In line with our explanation of the approach, <kbd>effective_df</kbd> is recomputed in each loop iteration by applying the filters we have so far (we import <kbd>apply_filters</kbd> at the top for this purpose).</p>
  </div>
  <div class="readable-text  intended-text" id="p72"> 
   <p>Go ahead and re-run your app! Figure 7.6 shows what happens when you select <kbd>"Writing tools"</kbd> as the only category you're interested in.</p>
  </div>
  <div class="browsable-container figure-container" id="p73">  
   <img src="../Images/ch07__image006.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.6 The filter bar only shows valid option combinations (see chapter_7/in_progress_02 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p74"> 
   <p>As expected, the <kbd>Segment</kbd> filter now only shows writing instruments.</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p75"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p76"> 
    <p>The <em>order</em> of the filters is now meaningful. If the Category filter were to be placed <em>after</em> Segment, choosing a category would have no effect on Segment because the unique values for Segment would already have been computed by the time the selected Category values are evaluated.</p>
   </div>
  </div>
  <div class="readable-text" id="p77"> 
   <h2 class=" readable-text-h2">7.4 Date range comparisons</h2>
  </div>
  <div class="readable-text " id="p78"> 
   <p>Another piece of feedback comes from one of the product line chiefs, who posted a screenshot (figure 7.7) to illustrate her point: "I can see that sales for RoyalQuill were $1.32M for July. But is that good or bad? How did we do last year?"</p>
  </div>
  <div class="browsable-container figure-container" id="p79">  
   <img src="../Images/ch07__image007.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.7 Sales for RoyalQuill were $1.32M but there's no indication of whether that's good, or what the sales were in a previous comparable period</h5>
  </div>
  <div class="readable-text " id="p80"> 
   <p>Often, the hard part about analyzing data is not obtaining or transforming it but <em>contextualizing</em> it. A metric by itself doesn't mean much. To make it useful, you have to be able to <em>compare</em> it to something. If we know sales for a product are $1m in a year, the decisions we would make if we knew that last year's sales were $10m are very different from those we'd make if last year's sales were only $100k.</p>
  </div>
  <div class="readable-text  intended-text" id="p81"> 
   <p>Our dashboard doesn't currently offer an easy way to make this comparison.</p>
  </div>
  <div class="readable-text  intended-text" id="p82"> 
   <p>Ideally, when we see a metric for a certain time period, we should also be able to tell how it's <em>changed</em> as compared to the past. In this section, we'll explore this requirement more deeply and incorporate it into our dashboard.</p>
  </div>
  <div class="readable-text" id="p83"> 
   <h3 class=" readable-text-h3">7.4.1 Adding another date range selector</h3>
  </div>
  <div class="readable-text " id="p84"> 
   <p>What exactly does it mean to compare a metric to its past value? What start date and end date do we use for "the past"? Let's consider some frequently-accessed comparisons that users may be interested in.</p>
  </div>
  <div class="readable-text  intended-text" id="p85"> 
   <p>For instance, if the user is viewing the total sales for August 1 to August 15, 2024, there's a good chance that they might want to see how that compares to the same dates in the previous month, i.e. July 1 to July 15, 2024. This is called a "month-over-month" comparison, often abbreviated to "MoM".</p>
  </div>
  <div class="readable-text  intended-text" id="p86"> 
   <p>Other similar comparisons the user might want to make are QoQ ("quarter-over-quarter") and YoY ("year-over-year"), which are both similar to MoM. QoQ means comparing to analogous dates in the previous quarter. For example, August 1 to August 15 represents the first 15 days of the second month of Q3, so QoQ would compare this to the first 15 days of the second month of <em>Q2</em>, or exactly three months earlier: May 1 to May 15.</p>
  </div>
  <div class="readable-text  intended-text" id="p87"> 
   <p>YoY should be obvious—it's the date range that's exactly a year in the past, so August 1 to August 15, <em>2023 </em>for our example.</p>
  </div>
  <div class="readable-text  intended-text" id="p88"> 
   <p>Another type of comparison an executive might want to make is against the immediately prior X days, where X is the number of days in the currently selected main date range.</p>
  </div>
  <div class="readable-text  intended-text" id="p89"> 
   <p>So, if the main range is August 1 to August 15, the "previous period" would be the 15 days immediately preceding August 1, i.e. July 17 to July 31.</p>
  </div>
  <div class="readable-text  intended-text" id="p90"> 
   <p>Let's now implement these commonly-accessed comparisons. We start by updating our <kbd>date_range_panel</kbd> function in <kbd>date_range_panel.py</kbd> to incorporate a comparison selector and return two more dates to the caller (<kbd>dashboard.py</kbd>, which we'll edit later):</p>
  </div>
  <div class="browsable-container listing-container" id="p91"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
def date_range_panel():
  start = st.date_input("Start date", value=THIRTY_DAYS_AGO)
  end = st.date_input("End date", value=LATEST_DATE)
  <b>comparison = st.selectbox(</b>
<b>    "Compare to", ["MoM", "QoQ", "YoY", "Previous period"])</b>
  <b>compare_start, compare_end = get_compare_range(start, end, comparison)</b>
  <b>st.info(f"Comparing with:  \n{compare_start} - {compare_end}")</b>
  return start, end, <b>compare_start, compare_end</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p92"> 
   <p>Since the comparison options are discrete values, we use an <kbd>st.selectbox</kbd> to offer users a choice between them, and call a yet-to-be-defined function, <kbd>get_compare_range</kbd>, to get the actual start and end dates of the comparison range.</p>
  </div>
  <div class="readable-text  intended-text" id="p93"> 
   <p>We also expose these comparison dates to the user in an <kbd>st.info</kbd> box so the user doesn't have to do any calendar math themselves to get that information.</p>
  </div>
  <div class="readable-text  intended-text" id="p94"> 
   <p>Let's also define the <kbd>get_compare_range</kbd> function we referenced above (in the same file, <kbd>date_range_panel.py</kbd>):</p>
  </div>
  <div class="browsable-container listing-container" id="p95"> 
   <div class="code-area-container"> 
    <pre class="code-area">def get_compare_range(start, end, comparison):
  offsets = {
    "MoM": pd.DateOffset(months=1),
    "QoQ": pd.DateOffset(months=3),
    "YoY": pd.DateOffset(years=1),
    "Previous period": pd.DateOffset((end - start).days + 1)
  }
  offset = offsets[comparison]
  return (start - offset).date(), (end - offset).date()</pre>
   </div>
  </div>
  <div class="readable-text " id="p96"> 
   <p>This function accepts three parameters: the start and end dates of the main date range, and <kbd>comparison</kbd>, a string that holds the type of comparison we want to perform—as discussed above, this could be <kbd>MoM</kbd>, <kbd>QoQ</kbd>, <kbd>YoY</kbd>, or <kbd>Previous period</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p97"> 
   <p>Calculating the comparison date range comes down to subtracting the right <em>offset </em>from both the start and end dates. For example, for an MoM comparison, we need to subtract one month from both dates. For QoQ, we subtract 3 months, and for YoY, we subtract a year.</p>
  </div>
  <div class="readable-text  intended-text" id="p98"> 
   <p>For the <kbd>Previous period</kbd> comparison, we first find the number of days within the main date range using<kbd> (end - start).days + 1</kbd>, and use that as the offset.</p>
  </div>
  <div class="readable-text  intended-text" id="p99"> 
   <p>We store these offsets in a dictionary (called <kbd>offsets</kbd> in the code above) with the comparison name as the key and a Pandas <kbd>DateOffset</kbd> object as the value. We can then obtain the new start and end dates by subtracting the offset from each:</p>
  </div>
  <div class="browsable-container listing-container" id="p100"> 
   <div class="code-area-container"> 
    <pre class="code-area">return (start - offset).date(), (end - offset).date()</pre>
   </div>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p101"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p102"> 
    <p>Why are the <kbd>.date()</kbd>s necessary here? Well, if you've been paying particularly close attention, you might have realized that <kbd>start</kbd> and <kbd>end</kbd> are <kbd>datetime.date</kbd> objects, not Pandas timestamp objects. Pandas makes sure that <kbd>pd.DateOffset</kbd> is compatible with <kbd>datetime.date</kbd> and that the former can be subtracted from the latter, but the result is a Pandas timestamp object. Since we've been trying to keep our date ranges <kbd>datetime.date</kbd> objects elsewhere, we use the <kbd>.date()</kbd> method of the Pandas timestamp class to convert <kbd>start - offset</kbd> and <kbd>end - offset</kbd> to <kbd>datetime.dates</kbd>—thus ensuring consistency.</p>
   </div>
  </div>
  <div class="readable-text " id="p103"> 
   <p>Since the function <kbd>date_range_panel</kbd> now returns four values (<kbd>start</kbd>, <kbd>end</kbd>, <kbd>compare_start</kbd>, and <kbd>compare_end</kbd>) instead of just two, we need to update the code that calls it to reflect this.</p>
  </div>
  <div class="readable-text  intended-text" id="p104"> 
   <p>This code happens to be in <kbd>dashboard.py</kbd>, within the sidebar. Change it from:</p>
  </div>
  <div class="browsable-container listing-container" id="p105"> 
   <div class="code-area-container"> 
    <pre class="code-area">with st.sidebar:
  start, end = date_range_panel()
 
to:
 
with st.sidebar:
  start, end, compare_start, compare_end = date_range_panel()</pre>
   </div>
  </div>
  <div class="readable-text " id="p106"> 
   <p>Your app's sidebar should now look like figure 7.8.</p>
  </div>
  <div class="browsable-container figure-container" id="p107">  
   <img src="../Images/ch07__image008.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.8 Sidebar showing a start/end date selector for the main date range as well as a "Compare to" input (see chapter_7/in_progress_03 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p108"> 
   <p>Though we're not actually doing anything with the comparison date range, you can see the new selectors.</p>
  </div>
  <div class="readable-text" id="p109"> 
   <h3 class=" readable-text-h3">7.4.2 Showing the comparison in the metric bar</h3>
  </div>
  <div class="readable-text " id="p110"> 
   <p>Now that we've collected the date range to compare to the main date range, how do we use it to resolve the feedback we received?</p>
  </div>
  <div class="readable-text  intended-text" id="p111"> 
   <p>Let's consider this with an example. Say we have two date ranges: August 1 to August 31, 2024 (the "main" date range) and July 1 to July 31, 2024 (the comparison date range). If we're comparing the total sales between those ranges, we'll need to calculate them separately for both date ranges and then display the <em>delta</em> (difference) between them.</p>
  </div>
  <div class="readable-text  intended-text" id="p112"> 
   <p>If the August sales are $5m and those in July are $4m, we would display a delta of $1m. Generally speaking, expressing the difference as a percentage of the past number is more useful, so the delta is 20% ($4m / $5m x 100). We would show this number alongside the August sales to provide a complete picture: Sales in August were $5m, up 20% from the previous period.</p>
  </div>
  <div class="readable-text  intended-text" id="p113"> 
   <p>This approach requires us to do two things:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p114">Calculate the metric separately for the comparison date frame, keeping everything else (mainly the filter values) constant</li>
   <li class="readable-text" id="p115">Compute the percentage delta and display it with the main metric.</li>
  </ul>
  <div class="readable-text " id="p116"> 
   <p>For the first part, let's modify <kbd>dashboard.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p117"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
...
 
with st.sidebar:
  start, end, compare_start, compare_end = date_range_panel()
 
...
main_df = get_filtered_data_within_date_range(data, start, end, filters)
if main_df.empty:
  st.warning("No data to display")
else:
  <b>compare_df = get_filtered_data_within_date_range(</b>
<b>                  data, compare_start, compare_end, filters)</b>
  metric_bar(main_df, <b>compare_df</b>)
  ...</pre>
   </div>
  </div>
  <div class="readable-text " id="p118"> 
   <p>Here, we're obtaining a new Pandas dataframe, <kbd>compare_df</kbd>, in much the same way that we get <kbd>main_df</kbd>—by passing the raw prepped data to <kbd>get_filtered_data_within_date_range</kbd> with the appropriate start and end dates and filters.</p>
  </div>
  <div class="readable-text  intended-text" id="p119"> 
   <p>The filters are the same as those used to create <kbd>main_df</kbd>. This is important because if a user has filtered for, say, a particular category and/or gender, the comparison they want to see is with the same category and/or gender, just for a different date range.</p>
  </div>
  <div class="readable-text  intended-text" id="p120"> 
   <p>We also pass <kbd>compare_df</kbd> as a second argument to <kbd>metric_bar</kbd>, which it doesn't support yet, but will when we're done.</p>
  </div>
  <div class="readable-text  intended-text" id="p121"> 
   <p>To compute and display the percentage delta, the changes we need to make are in <kbd>metric_bar.py</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p122"> 
   <p>Let's start by modifying <kbd>metric_bar</kbd> to accept the extra argument we passed in:</p>
  </div>
  <div class="browsable-container listing-container" id="p123"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">def metric_bar(main_df, <b>compare_df</b>):
  with st.container(border=True):
    metric_cols = st.columns(len(display_metrics))
    for idx, metric_name in enumerate(display_metrics):
      metric = metrics[metric_name]
      with metric_cols[idx]:
        value = get_metric(main_df, metric)
        formatted_value = format_metric(value, metric.type)
        <b>formatted_delta = get_formatted_delta(value, compare_df, metric)</b>
        c1, c2, c3 = st.columns([1, 3, 1])
        with c2:
          st.metric(
            metric.title, formatted_value, <b>formatted_delta, "normal"</b>)</pre>
   </div>
  </div>
  <div class="readable-text " id="p124"> 
   <p>Earlier, for each metric we needed to display, we would get the formatted value using <kbd>format_metric</kbd> and pass that, along with a title, to <kbd>st.metric</kbd> for display like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p125"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.metric(metric.title, formatted_value)</pre>
   </div>
  </div>
  <div class="readable-text " id="p126"> 
   <p>However, <kbd>st.metric</kbd> supports showing a delta as well, through its third and fourth argument (internally named <kbd>delta</kbd> and <kbd>delta_color</kbd>).</p>
  </div>
  <div class="readable-text  intended-text" id="p127"> 
   <p>The third argument is the formatted number to show as the change (in this case, the percentage difference), while the fourth argument, <kbd>delta_color</kbd>, indicates the color scheme to display the delta in.</p>
  </div>
  <div class="readable-text  intended-text" id="p128"> 
   <p><kbd>delta_color</kbd> can take the values <kbd>"normal,"</kbd> <kbd>"inverse,"</kbd> or <kbd>"off."</kbd> If it's set to <kbd>"normal,"</kbd> positive deltas are displayed in green, and negative changes will be in red. If it's <kbd>"inverse,"</kbd> the reverse is true: increases are in red, and decreases are green (this is appropriate for metrics where a lower value is better, like cost). If it's <kbd>"off,"</kbd> Streamlit just shows everything in gray.</p>
  </div>
  <div class="readable-text  intended-text" id="p129"> 
   <p>In this case, we're calling <kbd>st.metric</kbd> like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p130"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.metric(metric.title, formatted_value, formatted_delta, "normal")</pre>
   </div>
  </div>
  <div class="readable-text " id="p131"> 
   <p><kbd>"normal"</kbd> is appropriate for all of our metrics since a higher value is better for all of them (you'd want higher sales, a higher gross margin, a higher margin percentage, and a higher average transaction value). For the third argument, we pass in <kbd>formatted_delta</kbd>, which we're obtaining above by calling a function we haven't defined yet:</p>
  </div>
  <div class="browsable-container listing-container" id="p132"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area"><b>formatted_delta = get_formatted_delta(value, compare_df, metric)</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p133"> 
   <p>Let's go ahead and create <kbd>get_formatted_delta</kbd>, and any associated functions now:</p>
  </div>
  <div class="browsable-container listing-container" id="p134"> 
   <div class="code-area-container"> 
    <pre class="code-area">def get_delta(value, compare_df, metric):
  delta = None
  if compare_df is not None:
    compare_value = get_metric(compare_df, metric)
    if compare_value != 0:
      delta = (value - compare_value) / compare_value
  return delta
 
def get_formatted_delta(value, compare_df, metric):
  delta = get_delta(value, compare_df, metric)
  formatted_delta = None
  if delta is not None:
    formatted_delta = format_metric(delta, "percent")
  return formatted_delta</pre>
   </div>
  </div>
  <div class="readable-text " id="p135"> 
   <p>We've defined two functions: <kbd>get_delta</kbd> calculates the actual delta, while <kbd>get_formatted_delta</kbd> calls it and formats the result.</p>
  </div>
  <div class="readable-text  intended-text" id="p136"> 
   <p><kbd>get_delta</kbd> accepts the value of the main metric, <kbd>compare_df</kbd>—the comparison dataframe we computed in <kbd>dashboard.py</kbd>—and <kbd>metric</kbd>, which is the <kbd>Metric</kbd> object that represents the measure we're trying to show the change in.</p>
  </div>
  <div class="readable-text  intended-text" id="p137"> 
   <p>The body of <kbd>get_delta</kbd> isn't complicated. We use the <kbd>get_metric</kbd> function on <kbd>compare_df</kbd> to calculate the metric for the comparison date range, and obtain the percentage delta as follows:</p>
  </div>
  <div class="browsable-container listing-container" id="p138"> 
   <div class="code-area-container"> 
    <pre class="code-area">delta = (value - compare_value) / compare_value</pre>
   </div>
  </div>
  <div class="readable-text " id="p139"> 
   <p>At any point, if we realize that a delta can't be displayed (either because <kbd>compare_df</kbd> contains no data or because trying to calculate it would cause a divide-by-zero error since the comparison value is zero), we return <kbd>None</kbd> instead.</p>
  </div>
  <div class="readable-text  intended-text" id="p140"> 
   <p>In <kbd>get_formatted_delta</kbd>, we take this returned value and get a formatted version of it by calling <kbd>format_metric</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p141"> 
   <div class="code-area-container"> 
    <pre class="code-area">formatted_delta = format_metric(delta, "percent")</pre>
   </div>
  </div>
  <div class="readable-text " id="p142"> 
   <p>Recall from Chapter 6 that <kbd>format_metric</kbd> (defined in the file <kbd>formatting.py</kbd>) converts a numeric value into a user-friendly string depending on its type. In this case, the metric type is a "percent," so format_metric will add a "%" sign at the end.</p>
  </div>
  <div class="readable-text  intended-text" id="p143"> 
   <p>If there's no delta to format (which happens when <kbd>get_delta</kbd> returns <kbd>None</kbd>), <kbd>get_formatted_delta</kbd> returns <kbd>None</kbd> as well.</p>
  </div>
  <div class="readable-text  intended-text" id="p144"> 
   <p>When this is eventually passed to <kbd>st.metric</kbd>, Streamlit handles the <kbd>None</kbd> value correctly by not displaying anything at all.</p>
  </div>
  <div class="readable-text  intended-text" id="p145"> 
   <p>You can now re-run the dashboard to view your updated metric bar (remember to choose a comparison date range that we have data for), as shown in figure 7.9.</p>
  </div>
  <div class="browsable-container figure-container" id="p146">  
   <img src="../Images/ch07__image009.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.9 Metric bar showing how each metric has changed from the comparison date range (see chapter_7/in_progress_04 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p147"> 
   <p>As you can see, the metric bar now shows how each metric has changed as compared to its value in the comparison date range.</p>
  </div>
  <div class="readable-text  intended-text" id="p148"> 
   <p>Boom! We've addressed another key piece of feedback and are well on our way to version 2.0 of our dashboard! Let's see what else the email has to say.</p>
  </div>
  <div class="readable-text" id="p149"> 
   <h2 class=" readable-text-h2">7.5 A drilldown view</h2>
  </div>
  <div class="readable-text " id="p150"> 
   <p>Note n' Nib's CEO prides himself on being a "details guy," so when he sees a number on the dashboard, he wants to investigate <em>why</em>. For instance, if he finds that the average transaction value on ball pens is lower than that on fountain pens, he wants to dig deeper into the data to understand if there's a certain demographic driving the ATV down.</p>
  </div>
  <div class="readable-text  intended-text" id="p151"> 
   <p>Our dashboard doesn't expose data beyond what's in the metrics bar, line and pie charts, but there's clearly a desire for a more flexible and detailed view, perhaps even showing the individual rows in the source data.</p>
  </div>
  <div class="readable-text  intended-text" id="p152"> 
   <p>So far in our dashboard design, we've tried to shield users from complexity where possible. We've relied on visualizations to make data easy to grasp and used a clear, friendly metric bar to display key aggregate numbers. The quality of abstracting away complexity is a laudable one most of the time and for most users. Now and then, however, you'll come across a power user who wants to go deeper and interact with your software in more advanced ways.</p>
  </div>
  <div class="readable-text  intended-text" id="p153"> 
   <p>In our case, Note n' Nib's CEO fits this description—he's comfortable with data and has expressed frustration at not being able to drill down for more detailed insights. Addressing this feedback will likely be the most complex task of this chapter, as we'll need to create a whole new view rather than just improve upon the existing features.</p>
  </div>
  <div class="readable-text" id="p154"> 
   <h3 class=" readable-text-h3">7.5.1 Inserting a modal dialog</h3>
  </div>
  <div class="readable-text " id="p155"> 
   <p>Before considering what a drilldown view might contain, let's ponder where to place this functionality. Since we're classifying it as an "advanced" feature, we probably shouldn't place it in the main window of the dashboard. Casual users should be able to ignore the new, more detailed view, while advanced users should be able to find it with no trouble.</p>
  </div>
  <div class="readable-text  intended-text" id="p156"> 
   <p>Let's use this opportunity to discuss a new UI construct: a modal dialog. A modal dialog is essentially an overlay displayed on top of the main content, temporarily blocking interaction with the underlying interface until it has been dismissed. This overlay would remain focused on a particular task, which makes it ideal for presenting advanced functionality like drilldowns.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p157"> 
   <h4 class=" readable-text-h4">st.dialog</h4>
  </div>
  <div class="readable-text " id="p158"> 
   <p>Streamlit offers modal dialogs out of the box with <kbd>st.dialog</kbd>. Let's see this in action now.</p>
  </div>
  <div class="readable-text  intended-text" id="p159"> 
   <p>For our first iteration on the drilldown view, to keep things simple, when a user wants to drill down into the data, we'll just show them the entire Pandas dataframe. Of course, since users are likely to want to also dive into the comparison date range we recently added, we'll need to show both the main and the comparison dataframes.</p>
  </div>
  <div class="readable-text  intended-text" id="p160"> 
   <p>Listing 7.1 shows a new file, <kbd>drilldown.py</kbd>, set up to achieve this.</p>
  </div>
  <div class="browsable-container listing-container" id="p161"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 7.1 drilldown.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
@st.dialog("Drilldown", width="large")
def drilldown(main_df, compare_df):
  main_tab, compare_tab = st.tabs(["Main", "Compare"])
  with main_tab:
    st.dataframe(main_df, use_container_width=True)
  with compare_tab:
    st.dataframe(compare_df, use_container_width=True)</pre>
   </div>
  </div>
  <div class="readable-text " id="p162"> 
   <p>It may surprise you to learn that <kbd>st.dialog</kbd> is <em>not</em> structured the same way as <kbd>st.columns</kbd>, <kbd>st.tabs</kbd>, or <kbd>st.container</kbd>, i.e., as a widget that holds other widgets within.</p>
  </div>
  <div class="readable-text  intended-text" id="p163"> 
   <p>Instead, it's similar to <kbd>st.cache_data</kbd> from chapter 6 in that it's a <em>decorator</em>. A function decorated with <kbd>st.dialog</kbd> runs and has its content rendered inside a popup dialog.</p>
  </div>
  <div class="browsable-container listing-container" id="p164"> 
   <div class="code-area-container"> 
    <pre class="code-area">@st.dialog("Drilldown", width="large")</pre>
   </div>
  </div>
  <div class="readable-text " id="p165"> 
   <p>The width parameter simply sets the size of the dialog, which may be <kbd>"small"</kbd> (500 pixels wide) or <kbd>"large"</kbd> (750 pixels wide).</p>
  </div>
  <div class="readable-text  intended-text" id="p166"> 
   <p>The function being decorated is called <kbd>drilldown</kbd>, and it accepts <kbd>main_df</kbd> and <kbd>compare_df</kbd> from <kbd>dashboard.py</kbd> as arguments. The function renders two tabs titled "Main" and "Compare", and uses a new widget, <kbd>st.dataframe</kbd>, to display the passed Pandas dataframes in their respective tabs.</p>
  </div>
  <div class="readable-text  intended-text" id="p167"> 
   <p>Using <kbd>st.dataframe</kbd> like this simply shows the dataframe on the screen, just as <kbd>st.write</kbd> did in Chapter 6. We'll encounter it later too.</p>
  </div>
  <div class="readable-text  intended-text" id="p168"> 
   <p>To see the dialog, we need to <em>trigger</em> it, so let's focus on that next.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p169"> 
   <h4 class=" readable-text-h4">Using st.container to display UI elements out of order</h4>
  </div>
  <div class="readable-text " id="p170"> 
   <p>As alluded to earlier, the drilldown view should be unobtrusive to the casual user, but fairly obvious for a power user to access. One way to achieve this would be to add a button labeled "Drilldown" to the sidebar, and have it trigger the dialog when clicked.</p>
  </div>
  <div class="readable-text  intended-text" id="p171"> 
   <p>Let's examine the existing code in <kbd>dashboard.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p172"> 
   <div class="code-area-container"> 
    <pre class="code-area">...
with st.sidebar:
  start, end, compare_start, compare_end = date_range_panel()
 
...
main_df = get_filtered_data_within_date_range(data, start, end, filters)
if main_df.empty:
  st.warning("No data to display")
else:
  compare_df = get_filtered_data_within_date_range(
                  data, compare_start, compare_end, filters)
  ...</pre>
   </div>
  </div>
  <div class="readable-text " id="p173"> 
   <p>The sidebar already has the date range panel in it, with four widgets (two date inputs for the main range, a comparison selectbox, and an info box showing the comparison range), all lined up vertically. Since we want the drilldown trigger to be easily visible, we probably don't want it to be <em>below</em> the date range panel. Cool, so we put it above the panel instead, right?</p>
  </div>
  <div class="readable-text  intended-text" id="p174"> 
   <p>Except, there's a bit of an ordering issue here. To trigger the drilldown view, we need to call the <kbd>drilldown</kbd> function we just decorated with <kbd>st.dialog</kbd>. The parameters to this function are <kbd>main_df</kbd> and <kbd>compare_df</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p175"> 
   <p>If you inspect the <kbd>dashboard.py</kbd> code again, you'll realize that obtaining <kbd>main_df</kbd> and <kbd>compare_df</kbd> requires that we already <em>have</em> the <kbd>start</kbd>, <kbd>end</kbd>, <kbd>compare_start</kbd> and <kbd>compare_end</kbd> values so we can pass them in like this (for <kbd>main_df</kbd>):</p>
  </div>
  <div class="browsable-container listing-container" id="p176"> 
   <div class="code-area-container"> 
    <pre class="code-area">main_df = get_filtered_data_within_date_range(data, start, end, filters)</pre>
   </div>
  </div>
  <div class="readable-text " id="p177"> 
   <p>But where do we get these values? Why, in the sidebar!</p>
  </div>
  <div class="browsable-container listing-container" id="p178"> 
   <div class="code-area-container"> 
    <pre class="code-area">with st.sidebar:
  start, end, compare_start, compare_end = date_range_panel()</pre>
   </div>
  </div>
  <div class="readable-text " id="p179"> 
   <p>Do you see our dilemma? To place the drilldown button above the date range panel, we'd need to write its code <em>before</em> this line, but that code requires values that are only available <em>after </em>this line!</p>
  </div>
  <div class="readable-text  intended-text" id="p180"> 
   <p>This is the perfect place to elaborate on something I mentioned in passing in Chapter 6: the ability to display elements out of order. We need a way to separate the order in which Streamlit renders widgets on the screen from the order in which those widgets are computed.</p>
  </div>
  <div class="readable-text  intended-text" id="p181"> 
   <p>We'll use <kbd>st.container</kbd> for this. In chapter 6, we used it to display a border around the metric bar and visualizations. This time, we'll capitalize on a different property—<kbd>st.container</kbd> can put a <em>placeholder</em> widget on the screen that we can populate with other widgets when we can.</p>
  </div>
  <div class="readable-text  intended-text" id="p182"> 
   <p>For our use case, the placeholder will be above the date range panel—within the sidebar—and we'll only populate it with the actual drilldown button once we have <kbd>main_df</kbd> and <kbd>compare_df</kbd> later in the code.</p>
  </div>
  <div class="readable-text  intended-text" id="p183"> 
   <p>Let's lay this out in <kbd>dashboard.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p184"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
<b>from drilldown import drilldown</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
with st.sidebar:
  <b>dd_button_container = st.container()    </b>#A
  start, end, compare_start, compare_end = date_range_panel()
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
main_df = get_filtered_data_within_date_range(data, start, end, filters)
if main_df.empty:
  st.warning("No data to display")
else:
  compare_df = get_filtered_data_within_date_range(
                  data, compare_start, compare_end, filters)
  <b>if dd_button_container.button("Drilldown", use_container_width=True):</b>
<b>    drilldown(main_df, compare_df)</b>
  ...</pre>
    <div class="code-annotations-overlay-container">
     #A This is the placeholder defined within st.sidebar
     
     <br/>
    </div>
   </div>
  </div>
  <div class="readable-text " id="p185"> 
   <p>As promised, we use <kbd>st.container</kbd> above the date range panel to put a placeholder and refer to it by the name <kbd>dd_button_container</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p186"> 
   <p>Then, once we have <kbd>main_df</kbd> and <kbd>compare_df</kbd>, we create the button that calls the drilldown function when clicked. Notice that we're using the syntax <kbd>dd_button_container.button</kbd> instead of the <kbd>with</kbd>/<kbd>st.button</kbd> structure, just as we could with columns or tabs.</p>
  </div>
  <div class="readable-text  intended-text" id="p187"> 
   <p>It's finally time to see our dialog come to life! Re-run <kbd>dashboard.py</kbd> and click the drilldown button to get figure 7.10.</p>
  </div>
  <div class="browsable-container figure-container" id="p188">  
   <img src="../Images/ch07__image010.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.10 A basic raw dataframe view rendered in a dialog using st.dialog (see chapter_7/in_progress_05 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p189"> 
   <p>You may have noticed that the drilldown button took a second to appear before you clicked it. As you probably guessed, that's because we delayed its rendering until a bunch of other stuff was processed.</p>
  </div>
  <div class="readable-text" id="p190"> 
   <h3 class=" readable-text-h3">7.5.2 Designing the content of the drilldown</h3>
  </div>
  <div class="readable-text " id="p191"> 
   <p>Turn your attention to the dialog in figure 7.10 for a minute. We're currently just displaying <kbd>main_df</kbd> and <kbd>compare_df</kbd> as-is. It's rather ugly, with the horizontal <em>and</em> vertical scrollbars indicating that we only see a tiny portion of the data. More to the point, we can't easily use this view to look for specific data points or view a specific subset of the data. The boss would not be pleased if he had to use this.</p>
  </div>
  <div class="readable-text  intended-text" id="p192"> 
   <p>No, we need to think carefully to get the experience right.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p193"> 
   <h4 class=" readable-text-h4">What do users need from a drilldown view?</h4>
  </div>
  <div class="readable-text " id="p194"> 
   <p>It's clear that the content of the drilldown page needs to change, but how? What do our users need from this view? Well, what better way to understand than to talk to a user?</p>
  </div>
  <div class="readable-text  intended-text" id="p195"> 
   <p>So, you book a slot on the CEO's calendar—it's a sign of his enthusiasm for the dashboard that he readily accepts. In your interview with him, he lays out the original motivation for the feedback he provided about the drilldown view.</p>
  </div>
  <div class="readable-text  intended-text" id="p196"> 
   <p>Note n' Nib has two separate products in its best-selling line of fountain pens: Inkstream and RoyalQuill. InkStream is supposed to be a chic modern take on the fountain pen, while RoyalQuill, reminiscent of the classic elegance of vintage pens, is targeted at older customers.</p>
  </div>
  <div class="readable-text  intended-text" id="p197"> 
   <p>Recently, the company ran an advertising campaign for RoyalQuill, specifically targeting women in the 46-55 and 56+ age groups. The CEO wanted some data on the assumptions and results of this campaign. Specifically, he wanted to know how sales broke down for InkStream and RoyalQuill by age <em>and</em> gender.</p>
  </div>
  <div class="readable-text  intended-text" id="p198"> 
   <p>Our current dashboard shows users a breakdown of a metric by age <em>or</em> gender but not by both, so he can't easily access this information.</p>
  </div>
  <div class="readable-text  intended-text" id="p199"> 
   <p>You may see how this feedback can be generalized to <em>any</em> combination of dimensions in the data, not just age group/gender. Also, it would be tricky to present this kind of detail in a coherent repeatable visualization.</p>
  </div>
  <div class="readable-text  intended-text" id="p200"> 
   <p>What we need, then, is a highly flexible tabular form to show the data, similar to pivot tables that you may be familiar with from spreadsheet programs like Microsoft Excel. This table should:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p201">enable us to view numbers for any combination of dimensions we choose</li>
   <li class="readable-text" id="p202">allow us to focus on just the fields we care about, hiding irrelevant rows and/or columns</li>
   <li class="readable-text" id="p203">show aggregate numbers so we can see a full breakdown</li>
  </ul>
  <div class="readable-text " id="p204"> 
   <p>A mock UI created with these requirements in mind is shown in figure 7.11.</p>
  </div>
  <div class="browsable-container figure-container" id="p205">  
   <img src="../Images/ch07__image011.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.11 A mock UI for the drilldown view</h5>
  </div>
  <div class="readable-text " id="p206"> 
   <p>The mock shows us a fairly flexible table, that's quite similar to a pivot table. The "Drilldown fields" box is a multi-select that lets us choose the dimensions we care about. Below that is a table that only shows the dimensions we've selected. It <em>aggregates</em> the data over those dimensions, showing the metrics for every combination of the selected dimensions. There's also a total row that adds up everything.</p>
  </div>
  <div class="readable-text  intended-text" id="p207"> 
   <p>We've also retained the main/comparison tabs so that users can switch between them to see a past/present view of the metrics. This format is quite flexible, and meets our requirements, so it's time to build it out!</p>
  </div>
  <div class="readable-text" id="p208"> 
   <h3 class=" readable-text-h3">7.5.3 Implementing the drilldown view</h3>
  </div>
  <div class="readable-text " id="p209"> 
   <p>The drilldown view in figure 7.11 is fairly complex, so we'll assemble it piece by piece, starting with the drilldown field selector, and ending with some formatting and styling.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p210"> 
   <h4 class=" readable-text-h4">Aggregating by a few chosen dimensions</h4>
  </div>
  <div class="readable-text " id="p211"> 
   <p>Building the dimension selector (the top widget in figure 7.11) is just a matter of passing the possible dimension options in an <kbd>st.multiselect</kbd>. Add a new function to <kbd>drilldown.py</kbd> that does this and returns the list of the user's selections:</p>
  </div>
  <div class="browsable-container listing-container" id="p212"> 
   <div class="code-area-container"> 
    <pre class="code-area">def drilldown_dimensions():
  return st.multiselect(
    "Drilldown fields",
    ["Age group", "Gender", "Category", "Segment", "Product name", "State"]
  )</pre>
   </div>
  </div>
  <div class="readable-text " id="p213"> 
   <p>As our mock in figure 7.11 shows, we want to display all key metrics simultaneously. Let's put another function (also in <kbd>drilldown.py</kbd>) that takes in a dataframe (or a slice thereof), calculates all the metrics by aggregating it, and returns the results. Remember to import all the modules we need!</p>
  </div>
  <div class="browsable-container listing-container" id="p214"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area"><b>import pandas as pd</b>
import streamlit as st
<b>from metric_config import metrics</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
<b>def get_metric_cols(df):</b>
<b>  metrics_dict = {met: metric.func(df) for met, metric in metrics.items()}</b>
<b>  return pd.Series(metrics_dict)</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...</pre>
   </div>
  </div>
  <div class="readable-text " id="p215"> 
   <p>The expression <kbd>{met: metric.func(df) for met, metric in metrics.items()}</kbd> is a <em>dictionary comprehension</em>, which is shorthand to create a dictionary by iterating through something. Here it's saying "iterate through the metrics dictionary (from <kbd>metric_config.py</kbd>) and return a new dictionary where each key is the name of the metric, and the corresponding value is the result of applying the metric function <kbd>metric.func</kbd> on <kbd>df</kbd>, i.e. the value of that metric".</p>
  </div>
  <div class="readable-text  intended-text" id="p216"> 
   <p>We use a Pandas series here because, as you'll see shortly, it's a versatile data type that integrates seamlessly with various dataframe operations.</p>
  </div>
  <div class="readable-text  intended-text" id="p217"> 
   <p>To prepare the aggregated table given a dataframe and a list of dimensions, we introduce a new function called <kbd>get_aggregate_metrics</kbd> in the same file:</p>
  </div>
  <div class="browsable-container listing-container" id="p218"> 
   <div class="code-area-container"> 
    <pre class="code-area">def get_aggregate_metrics(df, dimensions):
  if dimensions:
    grouped = df.groupby(dimensions)
    return grouped.apply(get_metric_cols).reset_index()
  metric_cols = get_metric_cols(df)
  return pd.DataFrame(metric_cols).T</pre>
   </div>
  </div>
  <div class="readable-text " id="p219"> 
   <p>If <kbd>dimensions</kbd> is not an empty list, i.e. if the user has indeed selected some drilldown dimensions, <kbd>get_aggregate_metrics</kbd> groups <kbd>df</kbd> by those fields, and applies <kbd>get_metric_cols</kbd> to each of the groups (using <kbd>grouped.apply</kbd>, which you should be familiar with from Chapter 6), thus obtaining metric values for each group.</p>
  </div>
  <div class="readable-text  intended-text" id="p220"> 
   <p>If no dimensions are selected, then we call <kbd>get_metric_cols</kbd> directly on <kbd>df</kbd> to get a Pandas series object with the aggregated metrics for the entire dataframe. Finally, we convert this series into a dataframe and return its <em>transpose</em>:</p>
  </div>
  <div class="browsable-container listing-container" id="p221"> 
   <div class="code-area-container"> 
    <pre class="code-area">return pd.DataFrame(metric_cols).T</pre>
   </div>
  </div>
  <div class="readable-text " id="p222"> 
   <p>The transpose (referenced using a Pandas dataframe's <kbd>.T</kbd> property) of a dataframe is another dataframe whose rows and columns are interchanged. In this case, <kbd>metric_cols</kbd> is a <kbd>pd.Series</kbd> object, and calling <kbd>pd.Dataframe</kbd> on it would return a one-column dataframe where each of the metrics is a row.</p>
  </div>
  <div class="readable-text  intended-text" id="p223"> 
   <p>The <kbd>.T</kbd> is required to turn this into a one-<em>row </em>dataframe where each metric is a column, a format that's more handy.</p>
  </div>
  <div class="readable-text  intended-text" id="p224"> 
   <p>Next, we write a function that returns our full drilldown table. For now it's pretty thin since we're only doing some aggregations:</p>
  </div>
  <div class="browsable-container listing-container" id="p225"> 
   <div class="code-area-container"> 
    <pre class="code-area">def get_drilldown_table(df, dimensions):
  aggregated = get_aggregate_metrics(df, dimensions)
  return aggregated</pre>
   </div>
  </div>
  <div class="readable-text " id="p226"> 
   <p>We'll add more logic to <kbd>get_drilldown_table</kbd> later.</p>
  </div>
  <div class="readable-text  intended-text" id="p227"> 
   <p>To wrap up, we also need a function that displays the drilldown table (which is currently a Pandas dataframe):</p>
  </div>
  <div class="browsable-container listing-container" id="p228"> 
   <div class="code-area-container"> 
    <pre class="code-area">def display_drilldown_table(df):
  if df is None:
    st.warning("No data available for selected filters and date range")
  else:
    st.dataframe(df, use_container_width=True, hide_index=True)</pre>
   </div>
  </div>
  <div class="readable-text " id="p229"> 
   <p>This should be simple; we display a warning if there's no data, or use <kbd>st.dataframe</kbd> to display the aggregated table otherwise. Note the use of <kbd>hide_index=True</kbd>. By default, Streamlit displays the index field (which, as you may recall from Chapter 6, is a unique identifier for the row, defaulting to a simple serial number) alongside each row. You can see this in figure 7.10 (they're the numbers to the extreme left in the dataframe). We don't want the index displayed to the user, so we hide it.</p>
  </div>
  <div class="readable-text  intended-text" id="p230"> 
   <p>With these changes made, we can update the <kbd>drilldown</kbd> function too:</p>
  </div>
  <div class="browsable-container listing-container" id="p231"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">@st.dialog("Drilldown", width="large")
def drilldown(main_df, compare_df):
  <b>dimensions = drilldown_dimensions()</b>
<b>  main_data = get_drilldown_table(main_df, dimensions)</b>
<b>  compare_data = get_drilldown_table(compare_df, dimensions)</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
  main_tab, compare_tab = st.tabs(["Main", "Compare"])
  with main_tab:
    <b>display_drilldown_table(main_data)</b>
  with compare_tab:
    <b>display_drilldown_table(compare_data)</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p232"> 
   <p>The order of operations is logical: First we get the drilldown dimensions from the user (<kbd>dimensions = drilldown_dimensions()</kbd>), then we compute the aggregated dataframes (for both <kbd>main_df</kbd> and <kbd>compare_df</kbd>) using <kbd>get_drilldown_table</kbd>, and eventually display them in separate tabs using <kbd>display_drilldown_table</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p233"> 
   <p>If you re-run the dashboard now, you should see a much more palatable version of the drilldown view, as shown in figure 7.12.</p>
  </div>
  <div class="browsable-container figure-container" id="p234">  
   <img src="../Images/ch07__image012.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.12 Drilldown view with a dimension selector and aggregated for selected dimensions (see chapter_7/in_progress_06 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p235"> 
   <p>The user can now pick whichever dimensions they want, and see the metrics for every combination of those dimensions. This effectively lets the user drill into the required level of detail in the data, but perhaps a summary "total" row would be warranted to understand the whole that's being broken down here.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p236"> 
   <h4 class=" readable-text-h4">Adding a "Total" row</h4>
  </div>
  <div class="readable-text " id="p237"> 
   <p>Adding a summary row to the drilldown table is relatively complicated for a couple of reasons:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p238">Pandas dataframes do not natively have a way of designating a row as a summary of all the other rows. When we want totals, we have to wrangle them together using various operations.</li>
   <li class="readable-text" id="p239">The dimension values are meaningless in a total row and should be blank.</li>
  </ul>
  <div class="readable-text " id="p240"> 
   <p>To take an example, let's say we have the following drilldown dataframe (after the filtering and aggregation):</p>
  </div>
  <div class="browsable-container listing-container" id="p241"> 
   <div class="code-area-container"> 
    <pre class="code-area">+--------+----------------+--------------+-------------+--------------+----------+-------+
| Gender |    Segment     | Product name | Total sales | Gross margin | Margin % | ATV   |
+--------+----------------+--------------+-------------+--------------+----------+-------+
|   M    | Fountain pens  | InkStream    |   $100,000  |   $60,000    |   60%    | $10   |
|   M    | Fountain pens  | RoyalQuill   |   $200,000  |  $150,000    |   75%    | $40   |
+--------+----------------+--------------+-------------+--------------+----------+-------+</pre>
   </div>
  </div>
  <div class="readable-text " id="p242"> 
   <p>With the total row added to the top, we would have a dataframe that looks like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p243"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">+--------+----------------+--------------+-------------+--------------+----------+-------+
| Gender |    Segment     | Product name | Total sales | Gross margin | Margin % | ATV   |
+--------+----------------+--------------+-------------+--------------+----------+-------+
| <b>Total</b>  |                |              |   <b>$300,000</b>  |  <b>$210,000</b>    |   <b>70%</b>    | <b>$20</b>   |
|   M    | Fountain pens  | InkStream    |   $100,000  |   $60,000    |   60%    | $10   |
|   M    | Fountain pens  | RoyalQuill   |   $200,000  |  $150,000    |   75%    | $40   |
+--------+----------------+--------------+-------------+--------------+----------+-------+</pre>
   </div>
  </div>
  <div class="readable-text " id="p244"> 
   <p>Let's implement this with a new function, <kbd>add_total_row</kbd>, in <kbd>drilldown.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p245"> 
   <div class="code-area-container"> 
    <pre class="code-area">def add_total_row(df, all_df, dimensions):
  total_metrics = get_metric_cols(all_df)
  if dimensions:
    dim_vals = {dim: '' for dim in dimensions}
    dim_vals[dimensions[0]] = 'Total'
    total_row = pd.DataFrame({**dim_vals, **total_metrics}, index=[0])
    return pd.concat([total_row, df], ignore_index=True)
  total_row = pd.DataFrame({'': 'Total', **total_metrics}, index=[0])
  return total_row</pre>
   </div>
  </div>
  <div class="readable-text " id="p246"> 
   <p><kbd>add_total_rows</kbd> takes three arguments: <kbd>df</kbd>, <kbd>all_df</kbd>, and <kbd>dimensions</kbd> (the same list of dimension names we've been passing around). <kbd>df</kbd> is the drilldown dataframe we have so far (e.g. the first table above), while <kbd>all_df</kbd> is the dataframe with the original granular columns <em>before</em> aggregation.</p>
  </div>
  <div class="readable-text  intended-text" id="p247"> 
   <p>Why do we need both <kbd>df</kbd> <em>and</em> <kbd>all_df</kbd> here? Recall that we have a <kbd>get_metric_cols</kbd> function that can calculate all the metrics we need for a given dataframe—in other words, the numeric values for the "total" row we're trying to build. <kbd>get_metric_cols</kbd> expects a raw non-aggregated dataframe, not the aggregated version. This means we need to pass it <kbd>all_df</kbd>, not <kbd>df</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p248"> 
   <p>That is indeed what the first statement in the function does, storing the results in <kbd>total_metrics</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p249"> 
   <p>The next part builds the total row if the dimensions list is non-empty (<kbd>if dimensions:</kbd>), i.e. if the user has selected some drilldown dimensions.</p>
  </div>
  <div class="readable-text  intended-text" id="p250"> 
   <p>The following two lines are associated with populating the dimension values:</p>
  </div>
  <div class="browsable-container listing-container" id="p251"> 
   <div class="code-area-container"> 
    <pre class="code-area">dim_vals = {dim: '' for dim in dimensions}
dim_vals[dimensions[0]] = 'Total'</pre>
   </div>
  </div>
  <div class="readable-text " id="p252"> 
   <p>The first line is another dictionary comprehension that has a blank value for every dimension key from dimensions. We then set the value for the first dimension to <kbd>"Total"</kbd>. This effectively creates the text display values for our total row as we saw in our example above—<kbd>"Total"</kbd> in the first field and blanks for everything else.</p>
  </div>
  <div class="readable-text  intended-text" id="p253"> 
   <p>We have the dimension values for the total row in <kbd>dim_vals</kbd> (a dictionary) and the metric values in <kbd>total_metrics</kbd> (a <kbd>pd.Series</kbd>). All we need to do is to put them together! That's what the next line does:</p>
  </div>
  <div class="browsable-container listing-container" id="p254"> 
   <div class="code-area-container"> 
    <pre class="code-area">total_row = pd.DataFrame({**dim_vals, **total_metrics}, index=[0])</pre>
   </div>
  </div>
  <div class="readable-text " id="p255"> 
   <p>There's some interesting syntax here, so let's break it down.</p>
  </div>
  <div class="readable-text  intended-text" id="p256"> 
   <p>The character sequence <kbd>**</kbd> here is called a <em>dictionary unpacking operator</em>. It unpacks the items from a dictionary so they can be combined with other items to form a new dictionary, or even passed as function arguments.</p>
  </div>
  <div class="readable-text  intended-text" id="p257"> 
   <p>The former is what's happening here. For instance, if <kbd>dim_vals</kbd> is something like <kbd>{'Gender': 'Total', 'Segment': '', ...}</kbd> and total_metrics is <kbd>{'Total sales': 300000, …}</kbd>, <kbd>{**dim_vals, **total_metrics}</kbd> gives you a <em>combined</em> dictionary <kbd>{'Gender': 'Total', 'Segment': '', ..., 'Total sales': 300000, ...}</kbd>. The<kbd> index=[0]</kbd> sets the index of the only row in this single-row dataframe to 0.</p>
  </div>
  <div class="readable-text  intended-text" id="p258"> 
   <p>You might notice one issue with this though: Didn't we just say that <kbd>total_metrics</kbd> is a <kbd>pd.Series</kbd> and <em>not</em> a dictionary? Well, though that's true, a Pandas series actually has many of the properties of a regular Python dictionary—among them support for the <kbd>**</kbd> operator.</p>
  </div>
  <div class="readable-text  intended-text" id="p259"> 
   <p>The next line concatenates this total row to the rest of the drilldown dataframe and returns it:</p>
  </div>
  <div class="browsable-container listing-container" id="p260"> 
   <div class="code-area-container"> 
    <pre class="code-area">return pd.concat([total_row, df], ignore_index=True)</pre>
   </div>
  </div>
  <div class="readable-text " id="p261"> 
   <p>Now, if the user has <em>not </em>selected any dimensions and <kbd>dimensions</kbd> is empty, getting the dataframe with a total row becomes easier; we just need to add a blank column that says <kbd>'Total'</kbd> to <kbd>total_metrics</kbd>, and there's nothing to concatenate the row to—the dataframe consists of only the total row:</p>
  </div>
  <div class="browsable-container listing-container" id="p262"> 
   <div class="code-area-container"> 
    <pre class="code-area">total_row = pd.DataFrame({'': 'Total', **total_metrics}, index=[0])</pre>
   </div>
  </div>
  <div class="readable-text " id="p263"> 
   <p>We can now add the act of obtaining the total row to the transformations in <kbd>get_drilldown_table</kbd> like so:</p>
  </div>
  <div class="browsable-container listing-container" id="p264"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">def get_drilldown_table(df, dimensions):
  aggregated = get_aggregate_metrics(df, dimensions)
  <b>with_total = add_total_row(aggregated, df, dimensions)</b>
<b>  return with_total</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p265"> 
   <p>Re-run the dashboard to see what your total row looks like (see figure 7.13):</p>
  </div>
  <div class="browsable-container figure-container" id="p266">  
   <img src="../Images/ch07__image013.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.13 Drilldown dataframe view with a total row (see chapter_7/in_progress_07 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p267"> 
   <p>This is <em>almost</em> perfect, but wouldn't it be nice if the total row were highlighted or shaded to set it apart from the other rows?</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p268"> 
   <h4 class=" readable-text-h4">Formatting and styling the drilldown table</h4>
  </div>
  <div class="readable-text " id="p269"> 
   <p>While we have the content of our drilldown table ready to go, the presentation leaves a couple of things to be desired:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p270">As figure 7.17 shows, the numbers in the table are user-unfriendly raw ones, with hardly any formatting. Ideally, we'd want these to be shown in the same way as in the metric bar (e.g. "$1.2m" instead of "1200000").</li>
   <li class="readable-text" id="p271">No shading distinguishes the total row from the rest of the table.</li>
  </ul>
  <div class="readable-text " id="p272"> 
   <p>Let's tackle the former first. Formatting the numbers in the table should be quite straightforward because we've already defined the actual formatting rules in the <kbd>formatting.py</kbd> file from Chapter 6.</p>
  </div>
  <div class="readable-text  intended-text" id="p273"> 
   <p>All we need is a function to apply the formatting to an entire Pandas dataframe rather than the individual numbers displayed in the metric bar.</p>
  </div>
  <div class="readable-text  intended-text" id="p274"> 
   <p>Spin up a new function for this in <kbd>formatting.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p275"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import humanize
 
def format_metric(value, metric_type):
  ...
 
<b>def format_dataframe(df, metrics):</b>
<b>  cols = df.columns</b>
<b>  for col in cols:</b>
<b>    if col in metrics:</b>
<b>      df[col] = df[col].apply(format_metric, metric_type=metrics[col].type)</b>
<b>  return df</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p276"> 
   <p>The <kbd>format_dataframe</kbd> function should be simple to wrap your head around. After accepting two parameters (<kbd>df</kbd>, the dataframe to format, and the <kbd>metrics</kbd> dictionary from <kbd>metrics.py</kbd>), we simply iterate through the columns in <kbd>df</kbd>, and apply <kbd>format_metric</kbd> (a function we wrote in chapter 6) element-wise to each column.</p>
  </div>
  <div class="readable-text  intended-text" id="p277"> 
   <p>Notice how we're passing <kbd>metric_type</kbd> to <kbd>format_metric</kbd> as <em>another </em>parameter to <kbd>.apply()</kbd>!</p>
  </div>
  <div class="readable-text  intended-text" id="p278"> 
   <p>Essentially the following expression:</p>
  </div>
  <div class="browsable-container listing-container" id="p279"> 
   <div class="code-area-container"> 
    <pre class="code-area">df[col] = df[col].apply(format_metric, metric_type=metrics[col].type)</pre>
   </div>
  </div>
  <div class="readable-text " id="p280"> 
   <p>is saying: "issue the function call <kbd>format_metric(element, metric_type=metrics[col].type)</kbd>" for every element in <kbd>df[col]</kbd>, and save the result, which should be our formatted dataframe.</p>
  </div>
  <div class="readable-text  intended-text" id="p281"> 
   <p>Let's turn to the shading problem next: let's say we want to give the total row a gray background so it stands out from the rest of the table.</p>
  </div>
  <div class="readable-text  intended-text" id="p282"> 
   <p>The key to this lies in the <kbd>style</kbd> property of a Pandas dataframe, which enables us to apply <em>conditional formatting </em>(i.e. formatting based on certain rules) to the dataframe.</p>
  </div>
  <div class="readable-text  intended-text" id="p283"> 
   <p>To achieve this, we would use the <kbd>.apply</kbd> method of the <kbd>style</kbd> property, along with a custom function that defines the conditional style to apply.</p>
  </div>
  <div class="readable-text  intended-text" id="p284"> 
   <p>Let's create a new function in <kbd>drilldown.py</kbd> to implement this logic:</p>
  </div>
  <div class="browsable-container listing-container" id="p285"> 
   <div class="code-area-container"> 
    <pre class="code-area">def style_total_row(df):
  def get_style(row):
    first_col = row.index[0]
    return [
      'background-color: #d9d9d9' if row[first_col] == 'Total' else ''
      for _ in row
    ]
  return df.style.apply(get_style, axis=1)</pre>
   </div>
  </div>
  <div class="readable-text " id="p286"> 
   <p>The <kbd>style_total_row</kbd> function accepts the drilldown dataframe <kbd>df</kbd>, and applies the shading we need. To achieve this, it does something interesting: it defines <em>another</em> function called <kbd>get_style</kbd> within its body!</p>
  </div>
  <div class="readable-text  intended-text" id="p287"> 
   <p>In Python, a function defined within another is called a <em>nested function</em> or an <em>inner function</em>. Python considers a nested function to be local to the enclosing function's scope. In other words, any code outside of <kbd>style_total_row</kbd> cannot call <kbd>get_style</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p288"> 
   <p>Getting to the logic of the <kbd>get_style</kbd> function, it operates on an individual row of a Pandas dataframe, and so takes in row as a parameter.</p>
  </div>
  <div class="readable-text  intended-text" id="p289"> 
   <p>It then identifies the name of the first column of the dataframe using <kbd>first_col = row.index[0]</kbd>. The <kbd>index</kbd> property of a dataframe row is a list-like object containing the names of its columns, so <kbd>index[0]</kbd> gives the name of the first column.</p>
  </div>
  <div class="readable-text  intended-text" id="p290"> 
   <p>The next line defines (and returns) the actual conditional style we want to apply:</p>
  </div>
  <div class="browsable-container listing-container" id="p291"> 
   <div class="code-area-container"> 
    <pre class="code-area">return [
  'background-color: lightgray' if row[first_col] == 'Total' else ''
  for _ in row
]</pre>
   </div>
  </div>
  <div class="readable-text " id="p292"> 
   <p>The expression we're returning is a <em>list comprehension</em> which builds a new list by iterating through something (similar to how the dictionary comprehensions we've seen build new dictionaries).</p>
  </div>
  <div class="readable-text  intended-text" id="p293"> 
   <p>In this case, we're iterating through the fields in the dataframe row, using <kbd>for _ in row</kbd>. We don't actually need to refer to the fields themselves, which is why we use <kbd>_</kbd>—a perfectly valid Python identifier, by the way—as the loop index here.</p>
  </div>
  <div class="readable-text  intended-text" id="p294"> 
   <p>For each field, if the passed row is the total row (which we verify by checking if the value of the first column is <kbd>"Total"),</kbd> we add a peculiar string, <kbd>'background-color: lightgray'</kbd>, to the list we're constructing.</p>
  </div>
  <div class="readable-text  intended-text" id="p295"> 
   <p>This notation comes from CSS, the language used to style web pages. I know I promised you don't need to learn CSS to read this book, but this particular piece of it should be obvious enough: we're telling Pandas to give a light gray background to every field in a total row.</p>
  </div>
  <div class="readable-text  intended-text" id="p296"> 
   <p>We've now defined the conditional style we want to apply, but we still need to do the applying. The last line in <kbd>style_total_row</kbd> does this:</p>
  </div>
  <div class="browsable-container listing-container" id="p297"> 
   <div class="code-area-container"> 
    <pre class="code-area">return df.style.apply(get_style, axis=1)</pre>
   </div>
  </div>
  <div class="readable-text " id="p298"> 
   <p><kbd>.apply</kbd> here expects a function that accepts a dataframe row, so it can call it on every row ( as we've seen before).</p>
  </div>
  <div class="readable-text  intended-text" id="p299"> 
   <p>To complete our drilldown view, the final thing we need is to add the formatting and styling to <kbd>get_drilldown_table</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p300"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
<b>from formatting import format_dataframe</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
def get_drilldown_table(df, dimensions):
  aggregated = get_aggregate_metrics(df, dimensions)
  with_total = add_total_row(aggregated, df, dimensions)
  <b>formatted = format_dataframe(with_total, metrics)</b>
<b>  styled = style_total_row(formatted)</b>
<b>  return styled</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p301"> 
   <p>And that's it! Our drilldown view is fully formed now. Check it out in figure 7.14.</p>
  </div>
  <div class="browsable-container figure-container" id="p302">  
   <img src="../Images/ch07__image014.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.14 Completed drilldown view with shaded total row and formatted values (see chapter_7/in_progress_08 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p303"> 
   <p>Whew! That was a lot of work! However, we have more feature requests to address before we're done.</p>
  </div>
  <div class="callout-container sidebar-container"> 
   <div class="readable-text" id="p304"> 
    <h5 class=" callout-container-h5 readable-text-h5">The fragment-like behavior of st.dialog</h5>
   </div>
   <div class="readable-text" id="p305"> 
    <p>If you paid especially close attention in Chapter 4 where we learned about Streamlit's execution model, there's one aspect of how we implemented the drilldown view that may be puzzling you.</p>
   </div>
   <div class="readable-text" id="p306"> 
    <p>To show the dialog, we nested it under a button like this (in <kbd>dashboard.py</kbd>):</p>
   </div>
   <div class="browsable-container listing-container" id="p307"> 
    <div class="code-area-container"> 
     <pre class="code-area">if dd_button_container.button("Drilldown", use_container_width=True):
  drilldown(main_df, compare_df)</pre>
    </div>
   </div>
   <div class="readable-text" id="p308"> 
    <p>with <kbd>drilldown</kbd> being a function decorated with <kbd>st.dialog</kbd>. Within the drilldown, we can perform many interactions, such as selecting a dimension, or setting a filter.</p>
   </div>
   <div class="readable-text" id="p309"> 
    <p>But in previous projects, we've seen that the "clicked" state of <kbd>st.button</kbd> only holds for a single re-run, and that whenever we interact with something nested under a button, the app gets re-run again, and the button click gets cleared. In fact, we had to jump through a bunch of hoops in chapter 4 using <kbd>st.session_state</kbd> to get the behavior we wanted.</p>
   </div>
   <div class="readable-text" id="p310"> 
    <p>But we didn't need to do any of that in this case. Shouldn't interacting with the drilldown have caused a re-run with the button-click getting reset and the drilldown disappearing?</p>
   </div>
   <div class="readable-text" id="p311"> 
    <p>This doesn't happen because of some special behavior that <kbd>st.dialog</kbd> exhibits. When a user interacts with a widget within an <kbd>st.dialog</kbd>-decorated function, only the decorated function gets re-run, <em>not</em> the entire app!</p>
   </div>
   <div class="readable-text" id="p312"> 
    <p>In the above case, when someone selects a drilldown dimension, only the drilldown function gets re-run, and the button remains in the "clicked" state. <kbd>st.dialog</kbd> gets this behavior from a more general decorator called <kbd>st.fragment</kbd>.</p>
   </div>
  </div>
  <div class="readable-text" id="p313"> 
   <h2 class=" readable-text-h2">7.6 Enabling deeplinks</h2>
  </div>
  <div class="readable-text " id="p314"> 
   <p>Next up on the feedback list is a complaint about not being able to share views on the dashboard with other people. Naturally, the CEO frequently emails his reports about data she sees on the dashboard after applying a variety of filters and selections.</p>
  </div>
  <div class="readable-text  intended-text" id="p315"> 
   <p>When receiving one of these, the subordinate spends a good few minutes trying to recreate what his boss saw on the dashboard, sometimes using trial-and-error to get the filters and date ranges right. "This," the CEO writes, "amounts to a collaboration tax."</p>
  </div>
  <div class="readable-text  intended-text" id="p316"> 
   <p>Decision-making through data is not an isolated activity, or shouldn't be, at any enterprise. You generally want at least a few other pairs of eyes to validate the decisions you intend to make. This presents a real problem for users of our dashboard currently.</p>
  </div>
  <div class="readable-text  intended-text" id="p317"> 
   <p>Using the dashboard, they may identify a trend or data point that is key to a decision the company is evaluating. However, if they are to share it with someone else, they have two options: either screenshot the app or give the sharee instructions on how to recreate the view.</p>
  </div>
  <div class="readable-text  intended-text" id="p318"> 
   <p>Neither of these is ideal. A screenshot prevents the other person from interacting with the app further, and the other way is decidedly low-tech (imagine a user telling someone, "You're doing it wrong. You need to apply a date range of last year, filter for the 18-25 age group, and choose a monthly granularity!").</p>
  </div>
  <div class="readable-text  intended-text" id="p319"> 
   <p>Wouldn't it be nice if the user could just copy-paste the URL they're looking at over chat, and the recipient could go to the URL to see exactly what the first user was seeing? After all, this works for many other websites. For instance, when you use a search engine like Google or DuckDuckGo, you can send someone directly to the search results page by sending them your search URL.</p>
  </div>
  <div class="readable-text  intended-text" id="p320"> 
   <p>This functionality is called <em>deeplinking</em>, in the sense of linking someone "deep" into your website.</p>
  </div>
  <div class="readable-text  intended-text" id="p321"> 
   <p>How do deeplinks work? Let's take an example from the search engine DuckDuckGo. If you search for <kbd>"streamlit"</kbd> on duckduckgo.com, the URL of the search results page will be something like:</p>
  </div>
  <div class="browsable-container listing-container" id="p322"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">https://duckduckgo.com/?t=h_&amp;<b>q=streamlit</b>&amp;ia=web</pre>
   </div>
  </div>
  <div class="readable-text " id="p323"> 
   <p>Copy-and-paste this URL in your browser and it'll take you directly to the search results page for the query "streamlit". The part of the URL where it says <kbd>q=streamlit</kbd> is what makes this possible. The URL has embedded information about the inputs entered by the first user, and DuckDuckGo uses this information to direct the second user to the right page.</p>
  </div>
  <div class="readable-text  intended-text" id="p324"> 
   <p>If we apply this logic to our app, we need two things to implement deeplinks:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p325">A way to embed the inputs entered by a user in the app's URL</li>
   <li class="readable-text" id="p326">Given such a URL, a way to repopulate these inputs in the app automatically</li>
  </ul>
  <div class="readable-text" id="p327"> 
   <h3 class=" readable-text-h3">7.6.1 Using st.query_params</h3>
  </div>
  <div class="readable-text " id="p328"> 
   <p>The part of the URL that contains the "extra" information after the actual address is called a <em>query string</em>. It is separated from the rest of the URL by a question mark (<kbd>?</kbd>) character. The query string is made up of several key-value pairs called <em>query parameters</em>, separated in turn by the ampersand (<kbd>&amp;</kbd>) character.</p>
  </div>
  <div class="readable-text  intended-text" id="p329"> 
   <p>For example, in the URL we discussed above, i.e. <kbd>https://duckduckgo.com/?t=h_&amp;q=streamlit&amp;ia=web</kbd>:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p330">The query string is<kbd> t=h_&amp;q=streamlit&amp;ia=web</kbd></li>
   <li class="readable-text" id="p331">The query parameters are:<kbd> t=h_</kbd> (key<kbd> t</kbd> and value <kbd>h_</kbd>), <kbd>q=streamlit</kbd> (key <kbd>q</kbd> and value <kbd>streamlit</kbd>), and <kbd>ia=web</kbd> (key <kbd>ia</kbd> and value <kbd>web</kbd>).</li>
  </ul>
  <div class="readable-text " id="p332"> 
   <p>If our app were to have query parameters, what would they look like? Well, since the query string needs to capture the inputs entered by the user, it might be something like the following:</p>
  </div>
  <div class="browsable-container listing-container" id="p333"> 
   <div class="code-area-container"> 
    <pre class="code-area">start_date=2024-08-01&amp;end_date=2024-08-31&amp;product_name=RoyalQuill</pre>
   </div>
  </div>
  <div class="readable-text " id="p334"> 
   <p>Essentially, the user's selections need to be part of the query string (and, therefore, the URL).</p>
  </div>
  <div class="readable-text  intended-text" id="p335"> 
   <p>Streamlit allows you to manage query parameters through <kbd>st.query_params</kbd>, which is another dictionary-like object similar to <kbd>st.session_state</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p336"> 
   <p>At any point, <kbd>st.query_params</kbd> contains whatever key-value pairs are in your app's URL query string. You can also modify the query string in your browser's address bar by modifying <kbd>st.query_params</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p337"> 
   <p>The syntax for getting and setting parameters in <kbd>st.query_params</kbd> is identical to using a dictionary. For example, the code <kbd>st.query_params["pie_chart_dimension"] = "Gender"</kbd> would set the <kbd>pie_chart_dimension</kbd> parameter, updating the URL to include <kbd>pie_chart_dimension=Gender</kbd> somewhere.</p>
  </div>
  <div class="readable-text  intended-text" id="p338"> 
   <p>You could also read in the value of the parameter like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p339"> 
   <div class="code-area-container"> 
    <pre class="code-area">dimension = st.query_params["pie_chart_dimension"]</pre>
   </div>
  </div>
  <div class="readable-text " id="p340"> 
   <p>Our solution, then, would involve something like figure 7.15.</p>
  </div>
  <div class="browsable-container figure-container" id="p341">  
   <img src="../Images/ch07__image015.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.15 Approach for implementing deeplinking</h5>
  </div>
  <div class="readable-text " id="p342"> 
   <p>When someone first navigates to our app, we should extract the query parameters from the URL if there are any.</p>
  </div>
  <div class="readable-text  intended-text" id="p343"> 
   <p>We then set the values of the widgets based on those parameters. For instance, if we have <kbd>start_date=2024-08-01</kbd> as one of the query parameters, we would set the start date in the date range selector widget to 2024-08-01. If there are no query parameters, or no value specified for a particular widget, we don't set the value of the widget; instead we let the default behavior take over.</p>
  </div>
  <div class="readable-text  intended-text" id="p344"> 
   <p>Then, when someone changes a selection in a widget, we <em>update</em> the query parameters to reflect that change, thus also changing the URL in the address bar. This way, if a user copies the URL, it always has the latest selections they've made in the app!</p>
  </div>
  <div class="readable-text" id="p345"> 
   <h3 class=" readable-text-h3">7.6.2 Setting widget defaults through st.session_state</h3>
  </div>
  <div class="readable-text " id="p346"> 
   <p>There's one part of our scheme that hasn't been covered in any previous chapters. How do we programmatically set the value of an input widget?</p>
  </div>
  <div class="readable-text  intended-text" id="p347"> 
   <p>Recall from chapter 4 that every Streamlit widget (or UI element) has a unique identifier called a widget key. The key is usually created automatically by Streamlit, but if you have two identical widgets, you have to give each one a key manually so Streamlit can tell them apart. One neat thing I didn't mention earlier is that every time you provide a widget a key, its value becomes accessible in <kbd>st.session_state</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p348"> 
   <p>So if you have a dropdown input coded like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p349"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.selectbox("Pick a field", ["Gender", "Product name"], key="select_dim")</pre>
   </div>
  </div>
  <div class="readable-text " id="p350"> 
   <p>You can access its value using <kbd>st.session_state["select_dim"]</kbd></p>
  </div>
  <div class="readable-text  intended-text" id="p351"> 
   <p>Importantly for us, we can also <em>set</em> its value, simulating a user selection, like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p352"> 
   <div class="code-area-container"> 
    <pre class="code-area">st.session_state["select_dim"] = "Product name"</pre>
   </div>
  </div>
  <div class="readable-text " id="p353"> 
   <p>One caveat is that we can only do this <em>before</em> the widget code is run. In other words, we can set the value of the widget key in <kbd>st.session_state</kbd> <em>first</em> and have the widget take on that value when it renders later, but you can't render the widget with a key <em>first</em> and <em>then</em> overwrite its value by setting the value of the key in<kbd> st.session_state</kbd>.</p>
  </div>
  <div class="readable-text" id="p354"> 
   <h3 class=" readable-text-h3">7.6.3 Implementing deeplinks</h3>
  </div>
  <div class="readable-text " id="p355"> 
   <p>We now have all the information needed to build the deeplink functionality. Create a new file called <kbd>query_params.py</kbd> with the content shown in listing 7.2.</p>
  </div>
  <div class="browsable-container listing-container" id="p356"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 7.2 query_params.py</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
 
def get_param(key):
  return st.query_params.get(key, None)
 
def set_widget_defaults():
  for key in st.query_params:
    if key.startswith('w:') and key not in st.session_state:
      st.session_state[key] = get_param(key)
 
def set_params():
  query_params_dict = {}
  for key in st.session_state:
    if key.startswith('w:'):
      value = st.session_state[key]
      query_params_dict[key] = value
  st.query_params.from_dict(query_params_dict)</pre>
   </div>
  </div>
  <div class="readable-text " id="p357"> 
   <p>The <kbd>get_param</kbd> function gets the value of a particular query parameter given its name. It does so by using the <kbd>.get()</kbd> method of <kbd>st.query_params</kbd>, which—identically to that of a regular dictionary—returns a default value of <kbd>None</kbd> if the key does not exist.</p>
  </div>
  <div class="readable-text  intended-text" id="p358"> 
   <p><kbd>set_widget_defaults</kbd> populates the values of various widgets in the app from the query parameters by iterating through them and setting the value of each widget key in <kbd>st.session_state</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p359"> 
   <p>Why do we have the following condition?:</p>
  </div>
  <div class="browsable-container listing-container" id="p360"> 
   <div class="code-area-container"> 
    <pre class="code-area">if key.startswith('w:') and key not in st.session_state:</pre>
   </div>
  </div>
  <div class="readable-text " id="p361"> 
   <p>We don't necessarily want <em>every </em>key stored in <kbd>st.session_state</kbd> to appear in the URL, just those representing widgets. To ensure this, later on we'll prefix the string <kbd>'w:'</kbd> to every widget key we want in the query parameters. This gives us the flexibility of using <kbd>st.session_state</kbd> for other purposes should we need to while still being able to autopopulate widget values with it.</p>
  </div>
  <div class="readable-text  intended-text" id="p362"> 
   <p>We also don't want Streamlit to try to set the widget value from <kbd>st.query_params</kbd> in every re-run of the app because then <em>users</em> wouldn't be able to change the value. Instead, we only want to set each widget value once, when the app is being loaded for the first time from the parameter-embedded URL. That's why we have the sub-condition <kbd>key not in st.session_state</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p363"> 
   <p><kbd>set_widget_defaults</kbd> fulfills the first part of what we need for deep links—the ability to populate widget inputs from the URL. However, we still need to change the query parameters whenever a user makes a selection.</p>
  </div>
  <div class="readable-text  intended-text" id="p364"> 
   <p>That's what the <kbd>set_params</kbd> function does. It loops through <kbd>st.session_state</kbd>, gets the value of every widget key and stores them in a dictionary, <kbd>query_params_dict</kbd>. It then populates all of <kbd>st.query_params</kbd> directly from this dictionary using the <kbd>from_dict</kbd> method. As I illustrated earlier, we could also have set each value in <kbd>st.query_params</kbd>, but I wanted to show you this way too.</p>
  </div>
  <div class="readable-text  intended-text" id="p365"> 
   <p>Of course, for this to work, all of the widgets we want in the query parameters must have keys defined, starting with<kbd> 'w:'</kbd>. Therefore, we'll need to go through all of our code and add widget keys to each widget. Not a lot of fun, I'm afraid, but it has to be done.</p>
  </div>
  <div class="readable-text  intended-text" id="p366"> 
   <p>Here are the changes we'll need to make, if you're following along:</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p367"> 
   <h4 class=" readable-text-h4">Changes to date_range_panel.py</h4>
  </div>
  <div class="readable-text " id="p368"> 
   <p>In <kbd>date_range_panel.py</kbd>, there are three date selection widgets we show the user. We need to add keys to each of them. These would become:</p>
  </div>
  <div class="browsable-container listing-container" id="p369"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">start = st.date_input("Start date", value=THIRTY_DAYS_AGO, <b>key="w:start"</b>)
end = st.date_input("End date", value=LATEST_DATE, <b>key="w:end"</b>)
comparison = st.selectbox(
    "Compare to", ["MoM", "QoQ", "YoY", "Previous period"], <b>key="w:compare"</b>)</pre>
   </div>
  </div>
  <div class="readable-text " id="p370"> 
   <p>The exact names for the keys don't matter as long as they start with <kbd>w:</kbd>. There is an additional wrinkle here though.</p>
  </div>
  <div class="readable-text  intended-text" id="p371"> 
   <p>Notice that we currently assign default values <kbd>THIRTY_DAYS_AGO</kbd> and <kbd>TODAY</kbd> to the start and end date selectors respectively, through the <kbd>value</kbd> parameter in <kbd>st.date_input</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p372"> 
   <p>When we use <kbd>st.session_state</kbd> to set widget values—as we're doing in the <kbd>set_widget_defaults</kbd> function we created earlier—Streamlit will throw an error if we <em>also </em>try to set the value using the <kbd>value</kbd> parameter. We can't use both methods, we have to choose one.</p>
  </div>
  <div class="browsable-container listing-container" id="p373"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area"><b>if 'w:start' not in st.session_state:</b>
<b>  st.session_state['w:start'] = THIRTY_DAYS_AGO</b>
<b>if 'w:end' not in st.session_state:</b>
<b>  st.session_state['w:end'] = LATEST_DATE</b>
start = st.date_input("Start date", key="w:start")
end = st.date_input("End date", key="w:end")</pre>
   </div>
  </div>
  <div class="readable-text " id="p374"> 
   <p>Here, we've removed the <kbd>value</kbd> parameter from both widgets and added some logic at the beginning to set the same values using <kbd>st.session_state</kbd>. These lines must come before the widgets are defined.</p>
  </div>
  <div class="readable-text  intended-text" id="p375"> 
   <p>For reference, the overall <kbd>date_range_panel</kbd> function is now:</p>
  </div>
  <div class="browsable-container listing-container" id="p376"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
def date_range_panel():
  <b>if 'w:start' not in st.session_state:</b>
<b>    st.session_state['w:start'] = THIRTY_DAYS_AGO</b>
<b>  if 'w:end' not in st.session_state:</b>
<b>    st.session_state['w:end'] = LATEST_DATE</b>
  start = st.date_input("Start date", <b>key="w:start"</b>)
  end = st.date_input("End date", <b>key="w:end"</b>)
  comparison = st.selectbox(
    "Compare to", ["MoM", "QoQ", "YoY", "Previous period"], <b>key="w:compare"</b>)
  compare_start, compare_end = get_compare_range(start, end, comparison)
  st.info(f"Comparing with:  \n{compare_start} - {compare_end}")
  return start, end, compare_start, compare_end</pre>
   </div>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p377"> 
   <h4 class=" readable-text-h4">Changes to filter_panel.py</h4>
  </div>
  <div class="readable-text " id="p378"> 
   <p><kbd>filter_panel.py</kbd> has multiselects we need to add a key to:</p>
  </div>
  <div class="browsable-container listing-container" id="p379"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
def filter_panel(df):
  ...
  with st.expander("Filters"):
    ...
    for idx, dim in enumerate(filter_dims):
      with filter_cols[idx]:
        ...
        filters[dim] = st.multiselect(
            dim, unique_vals, <b>key=f'w:filter|{dim}'</b>)
  return filters</pre>
   </div>
  </div>
  <div class="readable-text " id="p380"> 
   <p>In this case, since multiple widgets are populated through a loop, we use the f-string <kbd>f'w:filter|{dim}'</kbd> as the key, using the dimension name <kbd>dim</kbd> to differentiate between the keys.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p381"> 
   <h4 class=" readable-text-h4">Changes to pie_chart.py and time_series_chart.py</h4>
  </div>
  <div class="readable-text " id="p382"> 
   <p>In <kbd>pie_chart.py</kbd>, add a key to the <kbd>st.selectbox</kbd> assigned to <kbd>split_dimension</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p383"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
    split_dimension = st.selectbox(
      "Group by", pie_chart_dims, <b>key="w:pie_split"</b>)</pre>
   </div>
  </div>
  <div class="readable-text " id="p384"> 
   <p>Similarly, in <kbd>time_series_chart.py</kbd>, add keys to <kbd>grain</kbd> and <kbd>split_dimension</kbd> in the <kbd>time_series_chart</kbd> function:</p>
  </div>
  <div class="browsable-container listing-container" id="p385"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
def time_series_chart(df):
  with st.container(border=True):
    ...
    grain = grain_col.select_slider(
          "Time grain", grain_options, <b>key="w:ts_grain"</b>)
    split_dimension = split_col.selectbox(
      "Group by", ["None"] + time_chart_dims, <b>key="w:ts_split"</b>)
    ………</pre>
   </div>
  </div>
  <div class="readable-text " id="p386"> 
   <p>With the widget keys in place, we can now call the relevant functionality we defined earlier in query_params.py from <kbd>dashboard.py</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p387"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">...
<b>from query_params import set_widget_defaults, set_params</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
st.set_page_config(layout='wide')
<b>set_widget_defaults()</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
<b>set_params()</b></pre>
   </div>
  </div>
  <div class="readable-text " id="p388"> 
   <p>Pay attention to exactly where we've placed the calls to <kbd>set_widget_defaults</kbd> and <kbd>set_params</kbd>. As mentioned earlier, we can only use <kbd>st.session_state</kbd> to set widget key values <em>before</em> any of the widgets are created, so the call to <kbd>set_widget_defaults()</kbd> needs to go right at the top (just after <kbd>st.set_page_config(layout='wide')</kbd> which needs to be the first command).</p>
  </div>
  <div class="readable-text  intended-text" id="p389"> 
   <p>On the other hand, the query parameters need to capture changes to <em>any</em> widget that the user has changed, so the call to <kbd>set_params</kbd> has to go at the very <em>end</em> of <kbd>dashboard.py</kbd>, after all the widgets have been created.</p>
  </div>
  <div class="readable-text  intended-text" id="p390"> 
   <p>Let's test out our deeplinks! Save everything and re-run the app. Then try making the following selections in the app:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p391">Set "Start date" to 2024/07/01, and "Compare to" to YoY.</li>
   <li class="readable-text" id="p392">Set the "Time grain" slider in the line chart to Week.</li>
  </ul>
  <div class="readable-text " id="p393"> 
   <p>If you now check the URL in your browser's address bar, it should look something like:</p>
  </div>
  <div class="browsable-container listing-container" id="p394"> 
   <div class="code-area-container"> 
    <pre class="code-area">http://localhost:8501/?w%3Ats_grain=Week&amp;w%3Acompare=YoY&amp;w%3Aend=2024-08-31&amp;w%3Astart=2024-07-01&amp;w%3Apie_split=Age+group</pre>
   </div>
  </div>
  <div class="readable-text " id="p395"> 
   <p>When a web URL contains certain special characters, such as a colon (<kbd>:</kbd>) or a space, it is converted into <em>percent-encoded</em> characters to ensure that browsers and web servers interpret them correctly. Each special character is usually replaced by a <kbd>%</kbd> sign followed by a two-digit hexadecimal code representing the original character in the ASCII standard. One exception is the space character, which, when it appears in the query parameters part of the URL, is encoded as a <kbd>+</kbd> sign.</p>
  </div>
  <div class="readable-text  intended-text" id="p396"> 
   <p>In our case, the following substitutions have occurred:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p397">The colon character has become <kbd>%3A</kbd>, so <kbd>w:ts_grain</kbd> becomes <kbd>w%3Ats_grain</kbd></li>
   <li class="readable-text" id="p398">The space character has become <kbd>+</kbd>, so <kbd>Age group</kbd> becomes <kbd>Age+group</kbd></li>
  </ul>
  <div class="readable-text " id="p399"> 
   <p>Reverse those substitutions and the URL becomes:</p>
  </div>
  <div class="readable-text " id="p400"> 
   <p>This is pretty much what we expected—the selections we made are reflected in the URL (along with the value of the pie chart dimension selectbox, which gets a non-blank value—<kbd>Age group</kbd>—by default, which is automatically captured in the URL).</p>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p401"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p402"> 
    <p>The URL starts with http://localhost: since we're currently developing locally. When we deploy our app, the localhost part will be replaced by whatever the address of the app is. For instance, if we deploy to Streamlit Community Cloud under <a href="https://ceo-dashboard.streamlit.app">https://ceo-dashboard.streamlit.app</a>, our URL with query parameters would look something like https://ceo-dashboard.streamlit.app?query_param1=value1&amp;query_param2=...</p>
   </div>
  </div>
  <div class="readable-text " id="p403"> 
   <p>Next, paste the original URL you copied into another browser tab and navigate to it. Unfortunately, the app throws an error (see figure 7.16).</p>
  </div>
  <div class="browsable-container figure-container" id="p404">  
   <img src="../Images/ch07__image016.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.16 We get an error when we inadvertently pass a string to an st.date_input (see chapter_7/in_progress_09 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p405"> 
   <p>The error claims that we tried to pass the wrong kind of value to a "DateInput", presumably the "Start date" and/or "End date" widgets.</p>
  </div>
  <div class="readable-text  intended-text" id="p406"> 
   <p>The issue here is that in the (parsed) URL above, the value given to the start date widget (with the key <kbd>w:start</kbd>) is the string <kbd>"2024-07-01"</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p407"> 
   <div class="code-area-container"> 
    <pre class="code-area">w:start=2024-07-01</pre>
   </div>
  </div>
  <div class="readable-text " id="p408"> 
   <p>When Streamlit tries to assign this value to the date input widget when it's eventually defined, it results in an error because <kbd>st.date_input</kbd> expects a date object, not a string.</p>
  </div>
  <div class="readable-text  intended-text" id="p409"> 
   <p>There's a similar problem with our filter inputs: these widgets expect lists (as you can select multiple values), but we're passing strings.</p>
  </div>
  <div class="readable-text  intended-text" id="p410"> 
   <p>We need some special handling logic for when the value to be set is not a string but a date or a list.</p>
  </div>
  <div class="readable-text  intended-text" id="p411"> 
   <p>Firstly, when setting the value of such a widget in <kbd>st.query_params</kbd>, let's add a prefix to denote that the value we're placing is a list or a date—say <kbd>L#</kbd> for a list and<kbd> D#</kbd> for a date. Here's the <kbd>set_params</kbd> function in <kbd>query_params.py</kbd> with this modification:</p>
  </div>
  <div class="browsable-container listing-container" id="p412"> 
   <div class="code-area-container code-area-with-html"> 
    <pre class="code-area">import streamlit as st
<b>from datetime import date</b>
<span style="mso-fareast-font-family:&quot;Roboto Mono&quot;"></span>
...
def set_params():
  query_params_dict = {}
  for key in st.session_state:
    if key.startswith('w:'):
      value = st.session_state[key]
      <b>if value:</b>
<b>        if isinstance(value, list):</b>
<b>          value = f'L#{','.join(value)}'</b>
<b>        elif isinstance(value, date):</b>
<b>          value = f'D#{value.isoformat()}'</b>
        query_params_dict[key] = value
  st.query_params.from_dict(query_params_dict)</pre>
   </div>
  </div>
  <div class="readable-text " id="p413"> 
   <p>Here, before adding a value to <kbd>query_params_dict</kbd>, we check its type using <kbd>isinstance</kbd>. If it's a list, we convert it to a string in a specific format (e.g.<kbd> ['M', 'F']</kbd> becomes<kbd> L#M,F</kbd>). If it's a date, we convert it into a different format (e.g. <kbd>2024-08-01</kbd> becomes <kbd>D#2024-08-01</kbd>).</p>
  </div>
  <div class="readable-text  intended-text" id="p414"> 
   <p>We also need the reverse logic to decode these string formats and convert them into the original values. This part goes in the <kbd>get_param</kbd> function, which we'll rewrite entirely:</p>
  </div>
  <div class="browsable-container listing-container" id="p415"> 
   <div class="code-area-container"> 
    <pre class="code-area">def get_param(key):
  if key not in st.query_params:
    return None
  value = st.query_params[key]
  if value.startswith('L#'):
    return value[2:].split(',')
  if value.startswith('D#'):
    return date.fromisoformat(value[2:])
  return value</pre>
   </div>
  </div>
  <div class="readable-text " id="p416"> 
   <p>As you can see, for a particular key, if the value is a string that starts with one of our special prefixes—either <kbd>L#</kbd> or <kbd>D#</kbd>—we do the reverse transformation, converting the string to the original list or date respectively.</p>
  </div>
  <div class="readable-text  intended-text" id="p417"> 
   <p>When we use this returned value in <kbd>set_widget_defaults</kbd>, it will thus be in the expected type, identical to the value that the user originally set, removing the error.</p>
  </div>
  <div class="readable-text  intended-text" id="p418"> 
   <p>You can see for yourself by retrying the earlier steps. You should see figure 7.17 now, demonstrating that you can now copy and paste the current URL of your dashboard to show others exactly what you're seeing.</p>
  </div>
  <div class="browsable-container figure-container" id="p419">  
   <img src="../Images/ch07__image017.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.17 The widgets in the dashboard are populated based on the URL values (see chapter_7/in_progress_10 in the GitHub repo for the full code)</h5>
  </div>
  <div class="readable-text " id="p420"> 
   <p>Explore the deeplinks some more. Note n' Nib's execs can now spend less time fiddling with the dashboard and more time making decisions that benefit the company!</p>
  </div>
  <div class="readable-text" id="p421"> 
   <h2 class=" readable-text-h2">7.7 Sourcing data from a data warehouse</h2>
  </div>
  <div class="readable-text " id="p422"> 
   <p>We've addressed all of the user feedback on the dashboard, but there's one glaring practical problem with it we have yet to talk about: the data we display in the dashboard is sourced from a static CSV file.</p>
  </div>
  <div class="readable-text  intended-text" id="p423"> 
   <p>I chose this approach as I wanted us to focus primarily on what we do with the data once we have it. Reading a static CSV file is probably the easiest way to ingest data in our app. However, there are multiple issues with this:</p>
  </div>
  <ul> 
   <li class="readable-text" id="p424">While a CSV is manageable when dealing with a small amount of data, it quickly becomes inefficient when handling large datasets.</li>
   <li class="readable-text" id="p425">We can't query the data flexibly at the source, and instead have to load it in memory to perform operations like filtering, aggregations, and joins.</li>
  </ul>
  <div class="readable-text " id="p426"> 
   <p>In the real world, we would generally store this data in a <em>data warehouse, </em>which is a specialized system designed to manage large volumes of structured data. In this section, we'll swap out our CSV for a table in a data warehouse—specifically Google BigQuery.</p>
  </div>
  <div class="readable-text" id="p427"> 
   <h3 class=" readable-text-h3">7.7.1 Getting our data into BigQuery</h3>
  </div>
  <div class="readable-text " id="p428"> 
   <p>Google BigQuery is a cloud-based data warehouse service that's part of the Google Cloud Platform (GCP). It allows you to efficiently store and analyze massive datasets using a language called <em>Structured Query Language</em> (SQL), without needing to manage infrastructure or worry about scaling.</p>
  </div>
  <div class="readable-text  intended-text" id="p429"> 
   <p>To begin, you'll need to set up a GCP account, which you can do at cloud.google.com. You'll probably need to enter details of a payment method such as a credit card, but you won't get charged since we're only going to be using free resources for this exercise.</p>
  </div>
  <div class="readable-text  intended-text" id="p430"> 
   <p>When you create a new account, Google will also create a <em>GCP project</em> for you. In GCP parlance, a project is a container for organizing and managing your Google Cloud resources. You need one to use BigQuery; feel free to use the default one created for you or to create a new one. A project has a unique ID; you can choose what this is when you create a project, but the default one is a randomly generated string. For instance, my default project ID was <kbd>dauntless-brace-436702-q0</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p431"> 
   <p>Next, let's go to BigQuery itself. Google Cloud is so vast and offers so many products and services that its UI may be intimidating to a beginner. The most reliable way to find BigQuery is probably to enter the search string "bigquery" in the search box at the top (see figure 7.18)</p>
  </div>
  <div class="browsable-container figure-container" id="p432">  
   <img src="../Images/ch07__image018.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.18 The most reliable way to find something on GCP is to use the search bar.</h5>
  </div>
  <div class="readable-text " id="p433"> 
   <p>Once on the BigQuery page, you should be able to see your BigQuery resources categorized under your GCP projects in an Explorer side panel to the left (see figure 7.19). "Resources" here means things like "queries", "notebooks", "workflows" etc., all of which you may ignore.</p>
  </div>
  <div class="readable-text  intended-text" id="p434"> 
   <p>What we're trying to do is to create a BigQuery table by uploading our CSV file. Before we can do this, we need to create a dataset. A BigQuery dataset is just a way to organize your tables within a project.</p>
  </div>
  <div class="readable-text  intended-text" id="p435"> 
   <p>Make your first dataset by clicking the three dots next to your project ID in the Explorer panel and then "Create dataset" (figure 7.19).</p>
  </div>
  <div class="browsable-container figure-container" id="p436">  
   <img src="../Images/ch07__image019.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.19 The Explorer pane in BigQuery</h5>
  </div>
  <div class="readable-text " id="p437"> 
   <p>This will open a screen where you can configure the dataset. All you need to enter is a name (I chose <kbd>sia_ceo_dashboard</kbd>); you can use the defaults for the remaining options.</p>
  </div>
  <div class="readable-text  intended-text" id="p438"> 
   <p>Once created, your dataset should appear in the Explorer panel. Click the three dots next to it and "Create table" to get to the table creation screen where we can upload our file.</p>
  </div>
  <div class="readable-text  intended-text" id="p439"> 
   <p>Select "Upload" under the "Create table from" options, and "CSV" as the file format. You can then select the <kbd>sales_data.csv</kbd> file from your local disk. You'll need to pick a name for the table (<kbd>sales_data</kbd> works). The remaining options should be straightforward and will likely be auto-populated: your project ID, and the name of the dataset you just created. Figure 7.20 shows what the screen looks like.</p>
  </div>
  <div class="browsable-container figure-container" id="p440">  
   <img src="../Images/ch07__image020.png" alt="image"/> 
   <h5 class=" figure-container-h5">Figure 7.20 The table creation screen in BigQuery</h5>
  </div>
  <div class="readable-text " id="p441"> 
   <p>Check the "Auto detect" box under "Schema" so you don't have to enter it manually. Then click the button at the bottom to actually create your table.</p>
  </div>
  <div class="readable-text  intended-text" id="p442"> 
   <p>At this point, your data is in BigQuery, and the table should appear under your dataset in Explorer. If you like, you can click into it and go to the "Preview" tab to see the data.</p>
  </div>
  <div class="readable-text" id="p443"> 
   <h3 class=" readable-text-h3">7.7.2 Setting up the Python-BigQuery connection</h3>
  </div>
  <div class="readable-text " id="p444"> 
   <p>We can now access our data in the BigQuery interface, but we also need to be able to connect to it from our Python code.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p445"> 
   <h4 class=" readable-text-h4">Enabling the BigQuery and BigQuery Storage APIs</h4>
  </div>
  <div class="readable-text " id="p446"> 
   <p>First, we need to enable a couple of BigQuery-related APIs in our GCP project: the BigQuery and BigQuery Storage APIs. The BigQuery API is what enables us to connect to BigQuery in the first place, while the Storage API makes it faster to ingest data into a Pandas dataframe.</p>
  </div>
  <div class="readable-text  intended-text" id="p447"> 
   <p>In each case, the corresponding result should lead you to a page when you can enable the API.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p448"> 
   <h4 class=" readable-text-h4">Creating a service account</h4>
  </div>
  <div class="readable-text " id="p449"> 
   <p>Since our app will connect to BigQuery programmatically, we need a <em>GCP service account</em> to handle authentication. A service account is a special type of account that belongs to your application instead of to an individual user. It enables your app to authenticate and interact with Google Cloud services, including BigQuery.</p>
  </div>
  <div class="readable-text  intended-text" id="p450"> 
   <p>To create a service account, first find "IAM &amp; Admin" and then "Service accounts" in the Google Cloud navigation menu (or better still, search for "service accounts" and click the first result.</p>
  </div>
  <div class="readable-text  intended-text" id="p451"> 
   <p>In the "Service Accounts" page, click the option to create one. This screen will ask you for a service account name (I used <kbd>sia_service_account</kbd>) and description. Once you've created the account, you'll also need to grant it access to your project on the same screen. Choose the role "Viewer" when you do this.</p>
  </div>
  <div class="readable-text  intended-text" id="p452"> 
   <p>Your service account should now appear in the Service Accounts page.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p453"> 
   <h4 class=" readable-text-h4">Creating a service account key</h4>
  </div>
  <div class="readable-text " id="p454"> 
   <p>We have a service account that can access our BigQuery resources, but we still need to obtain the credentials that will let our Streamlit app act <em>as</em> the service account. For this, we require a service account key.</p>
  </div>
  <div class="readable-text  intended-text" id="p455"> 
   <p>Find the account you just created on the Service Accounts page, click the three dots under "Actions" next to it, and then click "Manage keys."</p>
  </div>
  <div class="readable-text  intended-text" id="p456"> 
   <p>Click "ADD KEY" &gt; "Create new key" and select "JSON" as the key type. When you click "Create", your computer should automatically download a JSON file. Inspect this file in a text editor. It should contain the credentials you need to access BigQuery from your app, as well as additional details such as your project ID.</p>
  </div>
  <div class="readable-text sub-sub-section-heading" id="p457"> 
   <h4 class=" readable-text-h4">Generating secrets.toml</h4>
  </div>
  <div class="readable-text " id="p458"> 
   <p>The credentials we just obtained must be kept secret as they allow anyone who has them to read your BigQuery data. Recall from Chapter 5 that the optimal way to maintain confidential info in Streamlit is to use a <kbd>secrets.toml</kbd> file in conjunction with <kbd>st.secrets</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p459"> 
   <p>Unfortunately, the credential file we have is in JSON, so we need to convert it to TOML. You can do this manually, but let's use Python instead.</p>
  </div>
  <div class="readable-text  intended-text" id="p460"> 
   <p>First create a <kbd>.streamlit</kbd> folder to hold your <kbd>secrets.toml</kbd>.</p>
  </div>
  <div class="readable-text  intended-text" id="p461"> 
   <p>Rename your JSON file to <kbd>sia-service-account.json</kbd>, then open a Python shell from the same folder and type in the following commands:</p>
  </div>
  <div class="browsable-container listing-container" id="p462"> 
   <div class="code-area-container"> 
    <pre class="code-area">&gt;&gt;&gt; import json
&gt;&gt;&gt; import toml
&gt;&gt;&gt; with open('sia-service-account.json') as json_file:
...     config = json.load(json_file)
...
&gt;&gt;&gt; obj_to_write = {'bigquery': config}
&gt;&gt;&gt; with open('.streamlit/secrets.toml', 'a') as toml_file:
...     toml.dump(obj_to_write, toml_file)
...
'[bigquery]\ntype = "service_account"\nproject_id = "dauntless-...'
&lt;Rest excluded for brevity&gt;</pre>
   </div>
  </div>
  <div class="callout-container admonition-block"> 
   <div class="readable-text" id="p463"> 
    <h5 class=" callout-container-h5 readable-text-h5">Note</h5>
   </div>
   <div class="readable-text" id="p464"> 
    <p>You may first need to run "pip install toml" to get this to work.</p>
   </div>
  </div>
  <div class="readable-text " id="p465"> 
   <p>All we're doing here is opening the JSON file we got from GCP, reading it into a Python dictionary, and writing it back to <kbd>secrets.toml</kbd> under the key "bigquery". If you now open <kbd>secrets.toml</kbd>, you should be able to see the credentials in TOML format.</p>
  </div>
  <div class="browsable-container listing-container" id="p466"> 
   <div class="code-area-container"> 
    <pre class="code-area">[bigquery]
type = "service_account"
project_id = "dauntless-brace-436702-q0"
private_key_id = ...
...</pre>
   </div>
  </div>
  <div class="readable-text" id="p467"> 
   <h3 class=" readable-text-h3">7.7.3 Updating the dashboard to load data from BigQuery</h3>
  </div>
  <div class="readable-text " id="p468"> 
   <p>It's time to update our code to source data from BigQuery instead of a static CSV file. We need to install three new Python modules to enable this, so go ahead and enter the following commands into a terminal window:</p>
  </div>
  <div class="browsable-container listing-container" id="p469"> 
   <div class="code-area-container"> 
    <pre class="code-area">pip install google-cloud-bigquery
pip install google-cloud-bigquery-storage
pip install db-dtypes</pre>
   </div>
  </div>
  <div class="readable-text " id="p470"> 
   <p>The first two are needed to access the BigQuery and BigQuery Storage APIs. <kbd>db-dtypes</kbd> is required to enable converting the data returned by BigQuery to a Pandas dataframe.</p>
  </div>
  <div class="readable-text  intended-text" id="p471"> 
   <p>Since we wrote our code in a modular way, the only thing we need to change is the implementation of the <kbd>load_data</kbd> function in <kbd>data_loader.py</kbd>, and the rest of our app should work as before. This is an advantage of the "separation of concerns" principle we discussed in chapter 3.</p>
  </div>
  <div class="readable-text  intended-text" id="p472"> 
   <p>Listing 7.3 shows the new <kbd>data_loader.py</kbd> with <kbd>load_data</kbd> re-implemented to use BigQuery.</p>
  </div>
  <div class="browsable-container listing-container" id="p473"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 7.3 data_loader.py reimplemented to use BigQuery</h5>
   <div class="code-area-container"> 
    <pre class="code-area">import streamlit as st
from google.cloud import bigquery, bigquery_storage
 
DATASET = "sia_ceo_dashboard"
TABLE = "sales_data"
 
def load_data():
  service_account_info = st.secrets["bigquery"]
  client = bigquery.Client.from_service_account_info(service_account_info)
  creds = client._credentials
  storage_client = bigquery_storage.BigQueryReadClient(credentials=creds)
  project_id = service_account_info["project_id"]
  query = f"SELECT * from `{project_id}.{DATASET}.{TABLE}`"
  query_job = client.query(query)
  result = query_job.result()
  return result.to_dataframe(bqstorage_client=storage_client)</pre>
   </div>
  </div>
  <div class="readable-text " id="p474"> 
   <p>We keep a couple of constants at the top (<kbd>DATASET</kbd> and <kbd>TABLE</kbd>) to hold the names of the dataset and table we created in BigQuery.</p>
  </div>
  <div class="readable-text  intended-text" id="p475"> 
   <p>Within <kbd>load_data</kbd>, we first save the credentials from the <kbd>bigquery</kbd> key in <kbd>st.secrets</kbd> to <kbd>service_account_info</kbd>. We then pass in these credentials to create a BigQuery client (essentially an object that contains the methods and abstractions needed to interact with BigQuery):</p>
  </div>
  <div class="browsable-container listing-container" id="p476"> 
   <div class="code-area-container"> 
    <pre class="code-area">client = bigquery.Client.from_service_account_info(service_account_info)</pre>
   </div>
  </div>
  <div class="readable-text " id="p477"> 
   <p>We want to use the same credentials in the BigQuery Storage API client too, so we extract the credentials from the BigQuery client and use them to initialize <kbd>storage_client</kbd>:</p>
  </div>
  <div class="browsable-container listing-container" id="p478"> 
   <div class="code-area-container"> 
    <pre class="code-area">creds = client._credentials
storage_client = bigquery_storage.BigQueryReadClient(credentials=creds)</pre>
   </div>
  </div>
  <div class="readable-text " id="p479"> 
   <p>Our connection is now established.</p>
  </div>
  <div class="readable-text  intended-text" id="p480"> 
   <p>Tables in BigQuery are referred to using a dot-separated combination of the project ID, dataset name, and table name. For instance, the table I created would be referenced as:</p>
  </div>
  <div class="browsable-container listing-container" id="p481"> 
   <div class="code-area-container"> 
    <pre class="code-area">dauntless-brace-436702-q0.sia_ceo_dashboard.sales_data</pre>
   </div>
  </div>
  <div class="readable-text " id="p482"> 
   <p>We obtain the project ID from the credentials (<kbd>project_id = service_account_info["project_id"]</kbd>) and the dataset and table names from the constants we created above.</p>
  </div>
  <div class="readable-text  intended-text" id="p483"> 
   <p>We use the table reference to construct a SQL query like this:</p>
  </div>
  <div class="browsable-container listing-container" id="p484"> 
   <div class="code-area-container"> 
    <pre class="code-area">query = f"SELECT * from `{project_id}.{DATASET}.{TABLE}`"</pre>
   </div>
  </div>
  <div class="readable-text " id="p485"> 
   <p>We'll encounter more SQL in chapter 8, but for the moment, all you need to understand is that "<kbd>SELECT * from &lt;table&gt;</kbd>" means "get me all the columns from <kbd>&lt;table&gt;</kbd>". Essentially, we're telling BigQuery to return all the data in the table.</p>
  </div>
  <div class="readable-text  intended-text" id="p486"> 
   <p>Though we're not doing it here, we could have used a different SQL query to obtain some <em>subset</em> of the data; we couldn't have done this if we were still using a CSV file.</p>
  </div>
  <div class="readable-text  intended-text" id="p487"> 
   <p>The next two lines execute the query itself, wait for it to finish, and save the results to result:</p>
  </div>
  <div class="browsable-container listing-container" id="p488"> 
   <div class="code-area-container"> 
    <pre class="code-area">query_job = client.query(query)
result = query_job.result()</pre>
   </div>
  </div>
  <div class="readable-text " id="p489"> 
   <p>Lastly, we convert the result to a Pandas dataframe, utilizing the BigQuery Storage client for optimized performance, and return the dataframe.</p>
  </div>
  <div class="readable-text  intended-text" id="p490"> 
   <p>If you execute <kbd>streamlit run dashboard.py</kbd> again (you can't just re-run the app in the browser since we're using <kbd>st.cache_data</kbd> and simply re-running would return a previously cached version), the app will now pull data from BigQuery!</p>
  </div>
  <div class="readable-text" id="p491"> 
   <h3 class=" readable-text-h3">7.7.4 Notes on deployment to Streamlit Community Cloud</h3>
  </div>
  <div class="readable-text " id="p492"> 
   <p>In chapter 5, we explored how to deploy our apps to Streamlit Community Cloud. The process to do so remains the same for our metrics dashboard, but I want to call out a couple of things.</p>
  </div>
  <div class="readable-text  intended-text" id="p493"> 
   <p>The first is related to where we store the data. When deploying, if you're using the static CSV approach to source the data, you need to commit the CSV file in git, essentially storing it in your GitHub repo.</p>
  </div>
  <div class="readable-text  intended-text" id="p494"> 
   <p>If you're using BigQuery instead, the CSV is obviously not required, and you don't have to check it into your repository. However, you do need to configure your GCP credentials in Streamlit Community Cloud using the same process we used in Chapter 5.</p>
  </div>
  <div class="readable-text  intended-text" id="p495"> 
   <p>You'll also need to create a <kbd>requirements.txt</kbd> with all the modules we're using and need Community Cloud to install. As discussed in chapter 5, you can use the <kbd>pip freeze</kbd> command to identify the specific versions of the libraries we're using.</p>
  </div>
  <div class="readable-text  intended-text" id="p496"> 
   <p>An example <kbd>requirements.txt</kbd> for the dashboard is provided in listing 7.4.</p>
  </div>
  <div class="browsable-container listing-container" id="p497"> 
   <h5 class=" listing-container-h5 browsable-container-h5">Listing 7.4 requirements.txt</h5>
   <div class="code-area-container"> 
    <pre class="code-area">humanize&gt;=4.10.0
streamlit&gt;=1.38.0
plotly&gt;=5.23.0
google-cloud-bigquery==3.25.0
google-cloud-bigquery-storage==2.26.0
db-dtypes==1.3.0</pre>
   </div>
  </div>
  <div class="readable-text " id="p498"> 
   <p>We're finally all set to release version 2.0 of our dashboard! Without a doubt, there will be more feedback later, and each iteration will refine our dashboard further.</p>
  </div>
  <div class="readable-text  intended-text" id="p499"> 
   <p>For now, however, it's time to bid farewell to Note n' Nib and its data needs. In the next chapter, we're shifting gears from data insights to interactive tools, as we dive into a web app for creating, storing, and sharing haikus.</p>
  </div>
  <div class="readable-text" id="p500"> 
   <h2 class=" readable-text-h2">7.8 Summary</h2>
  </div>
  <ul> 
   <li class="readable-text" id="p501"><em>Launching</em> an app is only the first part of making it successful. You also have to <em>land</em> it, making sure that it serves your users' needs. For this, it is critical to hear from users directly.</li>
   <li class="readable-text" id="p502"><kbd>st.select_slider</kbd> is a cross between <kbd>st.selectbox</kbd> and <kbd>st.slider</kbd>, used when you want to impose a logical order between options.</li>
   <li class="readable-text" id="p503"><kbd>st.metric</kbd> can show the delta associated with a metric, i.e. how a value has changed over time.</li>
   <li class="readable-text" id="p504"><kbd>st.dialog</kbd> is a decorator that lets you create a modal dialog, an overlay that blocks interaction with the rest of the app.</li>
   <li class="readable-text" id="p505">You can use <kbd>st.container</kbd> to create placeholders in your app, only rendering the content you want to show when it's available.</li>
   <li class="readable-text" id="p506">Pandas dataframes have a style property that can be used to set conditional rules that modify how they are displayed on the screen.</li>
   <li class="readable-text" id="p507"><kbd>st.query_params</kbd> is a dictionary-like object that lets you read and update URL query parameters—this can be used to enable deeplinks in an app.</li>
   <li class="readable-text" id="p508">A data warehouse is a specialized system designed to store and retrieve large amounts of data.</li>
   <li class="readable-text" id="p509">Google BigQuery—part of GCP—is an example of a data warehouse. To enable an app to connect to it, you need to create a service account with a key, and record the credentials in <kbd>st.secrets</kbd>.</li>
  </ul>
</body>
</html>