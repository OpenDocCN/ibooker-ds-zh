<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 18. Combining Datasets: concat and append" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0306-concat-and-append">
<h1><span class="label">Chapter 18. </span>Combining Datasets: concat and append</h1>
<p><a data-primary="datasets" data-secondary="combining" data-type="indexterm" id="ix_ch18-asciidoc0"/><a data-primary="Pandas" data-secondary="combining datasets" data-type="indexterm" id="ix_ch18-asciidoc1"/>Some of the most interesting studies of data come from combining
different data sources. These operations can involve anything from very
straightforward concatenation of two different datasets to more
complicated database-style joins and merges that correctly handle any
overlaps between the datasets. <code>Series</code> and <code>DataFrame</code>s are built with
this type of operation in mind, and Pandas includes functions and
methods that make this sort of data wrangling fast and straightforward.</p>
<p>Here we’ll take a look at simple concatenation of <code>Series</code>
and <code>DataFrame</code>s with the <code>pd.concat</code> function; later we’ll
dive into more sophisticated in-memory merges and joins implemented in
Pandas.</p>
<p>We begin with the standard imports:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code>
        <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code></pre>
<p>For convenience, we’ll define this function, which creates a
<code>DataFrame</code> of a particular form that will be useful in the following
examples:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="k">def</code> <code class="nf">make_df</code><code class="p">(</code><code class="n">cols</code><code class="p">,</code> <code class="n">ind</code><code class="p">):</code>
            <code class="sd">"""Quickly make a DataFrame"""</code>
            <code class="n">data</code> <code class="o">=</code> <code class="p">{</code><code class="n">c</code><code class="p">:</code> <code class="p">[</code><code class="nb">str</code><code class="p">(</code><code class="n">c</code><code class="p">)</code> <code class="o">+</code> <code class="nb">str</code><code class="p">(</code><code class="n">i</code><code class="p">)</code> <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">ind</code><code class="p">]</code>
                    <code class="k">for</code> <code class="n">c</code> <code class="ow">in</code> <code class="n">cols</code><code class="p">}</code>
            <code class="k">return</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">ind</code><code class="p">)</code>

        <code class="c1"># example DataFrame</code>
        <code class="n">make_df</code><code class="p">(</code><code class="s1">'ABC'</code><code class="p">,</code> <code class="nb">range</code><code class="p">(</code><code class="mi">3</code><code class="p">))</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code>     <code class="n">A</code>   <code class="n">B</code>   <code class="n">C</code>
        <code class="mi">0</code>  <code class="n">A0</code>  <code class="n">B0</code>  <code class="n">C0</code>
        <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>  <code class="n">C1</code>
        <code class="mi">2</code>  <code class="n">A2</code>  <code class="n">B2</code>  <code class="n">C2</code></pre>
<p>In addition, we’ll create a quick class that allows us to
display multiple <code>DataFrame</code>s side by side. The code makes use of the
special <code>_repr_html_</code> method, which IPython/Jupyter uses to implement
its rich object display:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="k">class</code> <code class="nc">display</code><code class="p">(</code><code class="nb">object</code><code class="p">):</code>
            <code class="sd">"""Display HTML representation of multiple objects"""</code>
            <code class="n">template</code> <code class="o">=</code> <code class="s2">"""&lt;div style="float: left; padding: 10px;"&gt;</code>
<code class="s2">            &lt;p style='font-family:"Courier New", Courier, monospace'&gt;</code><code class="si">{0}{1}</code><code class="s2"/>
<code class="s2">            """</code>
            <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="o">*</code><code class="n">args</code><code class="p">):</code>
                <code class="bp">self</code><code class="o">.</code><code class="n">args</code> <code class="o">=</code> <code class="n">args</code>

            <code class="k">def</code> <code class="nf">_repr_html_</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
                <code class="k">return</code> <code class="s1">'</code><code class="se">\n</code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="bp">self</code><code class="o">.</code><code class="n">template</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="nb">eval</code><code class="p">(</code><code class="n">a</code><code class="p">)</code><code class="o">.</code><code class="n">_repr_html_</code><code class="p">())</code>
                                 <code class="k">for</code> <code class="n">a</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">args</code><code class="p">)</code>

            <code class="k">def</code> <code class="fm">__repr__</code><code class="p">(</code><code class="bp">self</code><code class="p">):</code>
                <code class="k">return</code> <code class="s1">'</code><code class="se">\n\n</code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">a</code> <code class="o">+</code> <code class="s1">'</code><code class="se">\n</code><code class="s1">'</code> <code class="o">+</code> <code class="nb">repr</code><code class="p">(</code><code class="nb">eval</code><code class="p">(</code><code class="n">a</code><code class="p">))</code>
                                   <code class="k">for</code> <code class="n">a</code> <code class="ow">in</code> <code class="bp">self</code><code class="o">.</code><code class="n">args</code><code class="p">)</code></pre>
<p>The use of this will become clearer as we continue our discussion in the
following section.</p>
<section data-pdf-bookmark="Recall: Concatenation of NumPy Arrays" data-type="sect1"><div class="sect1" id="ch_0306-concat-and-append_recall-concatenation-of-numpy-arrays">
<h1>Recall: Concatenation of NumPy Arrays</h1>
<p><a data-primary="arrays" data-secondary="concatenation" data-type="indexterm" id="idm45858781189504"/><a data-primary="concatenation" data-secondary="arrays" data-type="indexterm" id="idm45858781188304"/><a data-primary="np.concatenate() function" data-type="indexterm" id="idm45858781187360"/>Concatenation of <code>Series</code> and <code>DataFrame</code> objects behaves similarly to
concatenation of NumPy arrays, which can be done via the
<code>np.concatenate</code> function, as discussed in
<a data-type="xref" href="ch05.xhtml#section-0202-the-basics-of-numpy-arrays">Chapter 5</a>.
Recall that with it, you can combine the contents of two or more arrays
into a single array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code>
        <code class="n">y</code> <code class="o">=</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">]</code>
        <code class="n">z</code> <code class="o">=</code> <code class="p">[</code><code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">]</code>
        <code class="n">np</code><code class="o">.</code><code class="n">concatenate</code><code class="p">([</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">z</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">])</code></pre>
<p>The first argument is a list or tuple of arrays to concatenate.
Additionally, in the case of multidimensional arrays, it takes an <code>axis</code>
keyword that allows you to specify the axis along which the result will
be concatenated:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="p">[[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code>
             <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">]]</code>
        <code class="n">np</code><code class="o">.</code><code class="n">concatenate</code><code class="p">([</code><code class="n">x</code><code class="p">,</code> <code class="n">x</code><code class="p">],</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">]])</code></pre>
</div></section>
<section data-pdf-bookmark="Simple Concatenation with pd.concat" data-type="sect1"><div class="sect1" id="ch_0306-concat-and-append_simple-concatenation-with-pd.concat">
<h1>Simple Concatenation with pd.concat</h1>
<p><a data-primary="concatenation" data-secondary="with pd.concat()" data-secondary-sortas="pd.concat()" data-type="indexterm" id="ix_ch18-asciidoc2"/><a data-primary="pd.concat() function" data-secondary="concatenation with" data-type="indexterm" id="ix_ch18-asciidoc3"/>The <code>pd.concat</code> function provides a similar syntax to <code>np.concatenate</code>
but contains a number of options that we’ll discuss
momentarily:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Signature in Pandas v1.3.5</code>
<code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">(</code><code class="n">objs</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">0</code><code class="p">,</code> <code class="n">join</code><code class="o">=</code><code class="s1">'outer'</code><code class="p">,</code> <code class="n">ignore_index</code><code class="o">=</code><code class="kc">False</code><code class="p">,</code> <code class="n">keys</code><code class="o">=</code><code class="kc">None</code><code class="p">,</code>
          <code class="n">levels</code><code class="o">=</code><code class="kc">None</code><code class="p">,</code> <code class="n">names</code><code class="o">=</code><code class="kc">None</code><code class="p">,</code> <code class="n">verify_integrity</code><code class="o">=</code><code class="kc">False</code><code class="p">,</code>
          <code class="n">sort</code><code class="o">=</code><code class="kc">False</code><code class="p">,</code> <code class="n">copy</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code></pre>
<p><code>pd.concat</code> can be used for a simple concatenation of <code>Series</code> or
<code>DataFrame</code> objects, just as <code>np.concatenate</code> can be used for simple
concatenations of arrays:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">ser1</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="s1">'A'</code><code class="p">,</code> <code class="s1">'B'</code><code class="p">,</code> <code class="s1">'C'</code><code class="p">],</code> <code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
        <code class="n">ser2</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="s1">'D'</code><code class="p">,</code> <code class="s1">'E'</code><code class="p">,</code> <code class="s1">'F'</code><code class="p">],</code> <code class="n">index</code><code class="o">=</code><code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">])</code>
        <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">ser1</code><code class="p">,</code> <code class="n">ser2</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="mi">1</code>    <code class="n">A</code>
        <code class="mi">2</code>    <code class="n">B</code>
        <code class="mi">3</code>    <code class="n">C</code>
        <code class="mi">4</code>    <code class="n">D</code>
        <code class="mi">5</code>    <code class="n">E</code>
        <code class="mi">6</code>    <code class="n">F</code>
        <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>It also works to concatenate higher-dimensional objects, such as
<code>DataFrame</code>s:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">df1</code> <code class="o">=</code> <code class="n">make_df</code><code class="p">(</code><code class="s1">'AB'</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>
        <code class="n">df2</code> <code class="o">=</code> <code class="n">make_df</code><code class="p">(</code><code class="s1">'AB'</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">])</code>
        <code class="n">display</code><code class="p">(</code><code class="s1">'df1'</code><code class="p">,</code> <code class="s1">'df2'</code><code class="p">,</code> <code class="s1">'pd.concat([df1, df2])'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">df1</code>           <code class="n">df2</code>           <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">df1</code><code class="p">,</code> <code class="n">df2</code><code class="p">])</code>
            <code class="n">A</code>   <code class="n">B</code>         <code class="n">A</code>   <code class="n">B</code>         <code class="n">A</code>   <code class="n">B</code>
        <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>     <code class="mi">3</code>  <code class="n">A3</code>  <code class="n">B3</code>     <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>
        <code class="mi">2</code>  <code class="n">A2</code>  <code class="n">B2</code>     <code class="mi">4</code>  <code class="n">A4</code>  <code class="n">B4</code>     <code class="mi">2</code>  <code class="n">A2</code>  <code class="n">B2</code>
                                    <code class="mi">3</code>  <code class="n">A3</code>  <code class="n">B3</code>
                                    <code class="mi">4</code>  <code class="n">A4</code>  <code class="n">B4</code></pre>
<p>It’s default behavior is to concatenate row-wise within the
<code>DataFrame</code> (i.e., <code>axis=0</code>). Like <code>np.concatenate</code>, <code>pd.concat</code> allows
specification of an axis along which concatenation will take place.
Consider the following example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">df3</code> <code class="o">=</code> <code class="n">make_df</code><code class="p">(</code><code class="s1">'AB'</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">])</code>
        <code class="n">df4</code> <code class="o">=</code> <code class="n">make_df</code><code class="p">(</code><code class="s1">'CD'</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">])</code>
        <code class="n">display</code><code class="p">(</code><code class="s1">'df3'</code><code class="p">,</code> <code class="s1">'df4'</code><code class="p">,</code> <code class="s2">"pd.concat([df3, df4], axis='columns')"</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">df3</code>           <code class="n">df4</code>           <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">df3</code><code class="p">,</code> <code class="n">df4</code><code class="p">],</code> <code class="n">axis</code><code class="o">=</code><code class="s1">'columns'</code><code class="p">)</code>
            <code class="n">A</code>   <code class="n">B</code>         <code class="n">C</code>   <code class="n">D</code>         <code class="n">A</code>   <code class="n">B</code>   <code class="n">C</code>   <code class="n">D</code>
        <code class="mi">0</code>  <code class="n">A0</code>  <code class="n">B0</code>     <code class="mi">0</code>  <code class="n">C0</code>  <code class="n">D0</code>     <code class="mi">0</code>  <code class="n">A0</code>  <code class="n">B0</code>  <code class="n">C0</code>  <code class="n">D0</code>
        <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>     <code class="mi">1</code>  <code class="n">C1</code>  <code class="n">D1</code>     <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>  <code class="n">C1</code>  <code class="n">D1</code></pre>
<p>We could have equivalently specified <code>axis=1</code>; here we’ve
used the more intuitive <code>axis='columns'</code>.</p>
<section data-pdf-bookmark="Duplicate Indices" data-type="sect2"><div class="sect2" id="ch_0306-concat-and-append_duplicate-indices">
<h2>Duplicate Indices</h2>
<p><a data-primary="pd.concat() function" data-secondary="duplicate indices" data-type="indexterm" id="idm45858780464080"/>One important difference between <code>np.concatenate</code> and <code>pd.concat</code> is
that Pandas concatenation <em>preserves indices</em>, even if the result will
have duplicate indices! Consider this short example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">make_df</code><code class="p">(</code><code class="s1">'AB'</code><code class="p">,</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">])</code>
        <code class="n">y</code> <code class="o">=</code> <code class="n">make_df</code><code class="p">(</code><code class="s1">'AB'</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
        <code class="n">y</code><code class="o">.</code><code class="n">index</code> <code class="o">=</code> <code class="n">x</code><code class="o">.</code><code class="n">index</code>  <code class="c1"># make indices match</code>
        <code class="n">display</code><code class="p">(</code><code class="s1">'x'</code><code class="p">,</code> <code class="s1">'y'</code><code class="p">,</code> <code class="s1">'pd.concat([x, y])'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">x</code>             <code class="n">y</code>             <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">])</code>
            <code class="n">A</code>   <code class="n">B</code>         <code class="n">A</code>   <code class="n">B</code>         <code class="n">A</code>   <code class="n">B</code>
        <code class="mi">0</code>  <code class="n">A0</code>  <code class="n">B0</code>     <code class="mi">0</code>  <code class="n">A2</code>  <code class="n">B2</code>     <code class="mi">0</code>  <code class="n">A0</code>  <code class="n">B0</code>
        <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>     <code class="mi">1</code>  <code class="n">A3</code>  <code class="n">B3</code>     <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>
                                    <code class="mi">0</code>  <code class="n">A2</code>  <code class="n">B2</code>
                                    <code class="mi">1</code>  <code class="n">A3</code>  <code class="n">B3</code></pre>
<p>Notice the repeated indices in the result. While this is valid within
<code>DataFrame</code>s, the outcome is often undesirable. <code>pd.concat</code> gives us a
few ways to handle it.</p>
<section data-pdf-bookmark="Treating repeated indices as an error" data-type="sect3"><div class="sect3" id="ch_0306-concat-and-append_treating-repeated-indices-as-an-error">
<h3>Treating repeated indices as an error</h3>
<p><a data-primary="pd.concat() function" data-secondary="catching repeats as error" data-type="indexterm" id="idm45858780406384"/>If you’d like to simply verify that the indices in the
result of <code>pd.concat</code> do not overlap, you can include the
<code>verify_integrity</code> flag. With this set to <code>True</code>, the concatenation will
raise an exception if there are duplicate indices. Here is an example,
where for clarity we’ll catch and print the error message:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="k">try</code><code class="p">:</code>
             <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">],</code> <code class="n">verify_integrity</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
         <code class="k">except</code> <code class="ne">ValueError</code> <code class="k">as</code> <code class="n">e</code><code class="p">:</code>
             <code class="nb">print</code><code class="p">(</code><code class="s2">"ValueError:"</code><code class="p">,</code> <code class="n">e</code><code class="p">)</code>
<code class="ne">ValueError</code><code class="p">:</code> <code class="n">Indexes</code> <code class="n">have</code> <code class="n">overlapping</code> <code class="n">values</code><code class="p">:</code> <code class="n">Int64Index</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'int64'</code><code class="p">)</code></pre>
</div></section>
<section data-pdf-bookmark="Ignoring the index" data-type="sect3"><div class="sect3" id="ch_0306-concat-and-append_ignoring-the-index">
<h3>Ignoring the index</h3>
<p><a data-primary="pd.concat() function" data-secondary="ignoring the index" data-type="indexterm" id="idm45858780279168"/>Sometimes the index itself does not matter, and you would prefer it to
simply be ignored. This option can be specified using the <code>ignore_index</code>
flag. With this set to <code>True</code>, the concatenation will create a new
integer index for the resulting <code>DataFrame</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">display</code><code class="p">(</code><code class="s1">'x'</code><code class="p">,</code> <code class="s1">'y'</code><code class="p">,</code> <code class="s1">'pd.concat([x, y], ignore_index=True)'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">x</code>              <code class="n">y</code>             <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">],</code> <code class="n">ignore_index</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
             <code class="n">A</code>   <code class="n">B</code>          <code class="n">A</code>   <code class="n">B</code>         <code class="n">A</code>   <code class="n">B</code>
         <code class="mi">0</code>  <code class="n">A0</code>  <code class="n">B0</code>      <code class="mi">0</code>  <code class="n">A2</code>  <code class="n">B2</code>     <code class="mi">0</code>  <code class="n">A0</code>  <code class="n">B0</code>
         <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>      <code class="mi">1</code>  <code class="n">A3</code>  <code class="n">B3</code>     <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>
                                      <code class="mi">2</code>  <code class="n">A2</code>  <code class="n">B2</code>
                                      <code class="mi">3</code>  <code class="n">A3</code>  <code class="n">B3</code></pre>
</div></section>
<section data-pdf-bookmark="Adding MultiIndex keys" data-type="sect3"><div class="sect3" id="ch_0306-concat-and-append_adding-multiindex-keys">
<h3>Adding MultiIndex keys</h3>
<p><a data-primary="MultiIndex type" data-secondary="keys option" data-type="indexterm" id="idm45858780146144"/><a data-primary="pd.concat() function" data-secondary="MultiIndex keys" data-type="indexterm" id="idm45858780145168"/>Another option is to use the <code>keys</code> option to specify a label for the
data sources; the result will be a hierarchically indexed series
containing the data:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">display</code><code class="p">(</code><code class="s1">'x'</code><code class="p">,</code> <code class="s1">'y'</code><code class="p">,</code> <code class="s2">"pd.concat([x, y], keys=['x', 'y'])"</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">x</code>              <code class="n">y</code>             <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">],</code> <code class="n">keys</code><code class="o">=</code><code class="p">[</code><code class="s1">'x'</code><code class="p">,</code> <code class="s1">'y'</code><code class="p">])</code>
             <code class="n">A</code>   <code class="n">B</code>          <code class="n">A</code>   <code class="n">B</code>           <code class="n">A</code>   <code class="n">B</code>
         <code class="mi">0</code>  <code class="n">A0</code>  <code class="n">B0</code>      <code class="mi">0</code>  <code class="n">A2</code>  <code class="n">B2</code>     <code class="n">x</code> <code class="mi">0</code>  <code class="n">A0</code>  <code class="n">B0</code>
         <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>      <code class="mi">1</code>  <code class="n">A3</code>  <code class="n">B3</code>       <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>
                                      <code class="n">y</code> <code class="mi">0</code>  <code class="n">A2</code>  <code class="n">B2</code>
                                        <code class="mi">1</code>  <code class="n">A3</code>  <code class="n">B3</code></pre>
<p>We can use the tools discussed in
<a data-type="xref" href="ch17.xhtml#section-0305-hierarchical-indexing">Chapter 17</a> to
transform this multiply indexed <code>Data⁠Frame</code> into the representation
we’re interested in.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Concatenation with Joins" data-type="sect2"><div class="sect2" id="ch_0306-concat-and-append_concatenation-with-joins">
<h2>Concatenation with Joins</h2>
<p><a data-primary="joins" data-seealso="merging" data-type="indexterm" id="idm45858780053328"/><a data-primary="pd.concat() function" data-secondary="concatenation with joins" data-type="indexterm" id="idm45858780052352"/>In the short examples we just looked at, we were mainly concatenating
<code>DataFrame</code>s with shared column names. In practice, data from different
sources might have different sets of column names, and <code>pd.concat</code>
offers several options in this case. Consider the concatenation of the
following two <code>DataFrame</code>s, which have some (but not all!) columns in
common:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">df5</code> <code class="o">=</code> <code class="n">make_df</code><code class="p">(</code><code class="s1">'ABC'</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>
         <code class="n">df6</code> <code class="o">=</code> <code class="n">make_df</code><code class="p">(</code><code class="s1">'BCD'</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">])</code>
         <code class="n">display</code><code class="p">(</code><code class="s1">'df5'</code><code class="p">,</code> <code class="s1">'df6'</code><code class="p">,</code> <code class="s1">'pd.concat([df5, df6])'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">df5</code>                <code class="n">df6</code>                <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">df5</code><code class="p">,</code> <code class="n">df6</code><code class="p">])</code>
             <code class="n">A</code>   <code class="n">B</code>   <code class="n">C</code>          <code class="n">B</code>   <code class="n">C</code>   <code class="n">D</code>         <code class="n">A</code>   <code class="n">B</code>   <code class="n">C</code>    <code class="n">D</code>
         <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>  <code class="n">C1</code>      <code class="mi">3</code>  <code class="n">B3</code>  <code class="n">C3</code>  <code class="n">D3</code>      <code class="mi">1</code>   <code class="n">A1</code>  <code class="n">B1</code>  <code class="n">C1</code>  <code class="n">NaN</code>
         <code class="mi">2</code>  <code class="n">A2</code>  <code class="n">B2</code>  <code class="n">C2</code>      <code class="mi">4</code>  <code class="n">B4</code>  <code class="n">C4</code>  <code class="n">D4</code>      <code class="mi">2</code>   <code class="n">A2</code>  <code class="n">B2</code>  <code class="n">C2</code>  <code class="n">NaN</code>
                                               <code class="mi">3</code>  <code class="n">NaN</code>  <code class="n">B3</code>  <code class="n">C3</code>   <code class="n">D3</code>
                                               <code class="mi">4</code>  <code class="n">NaN</code>  <code class="n">B4</code>  <code class="n">C4</code>   <code class="n">D4</code></pre>
<p>The default behavior is to fill entries for which no data is available
with NA values. To change this, we can adjust the <code>join</code> parameter of
the <code>concat</code> function. By default, the join is a union of the input
columns (<code>join='outer'</code>), but we can change this
to an intersection of the columns using
<code>join='inner'</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">display</code><code class="p">(</code><code class="s1">'df5'</code><code class="p">,</code> <code class="s1">'df6'</code><code class="p">,</code>
                 <code class="s2">"pd.concat([df5, df6], join='inner')"</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">df5</code>                <code class="n">df6</code>
             <code class="n">A</code>   <code class="n">B</code>   <code class="n">C</code>          <code class="n">B</code>   <code class="n">C</code>   <code class="n">D</code>
         <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>  <code class="n">C1</code>      <code class="mi">3</code>  <code class="n">B3</code>  <code class="n">C3</code>  <code class="n">D3</code>
         <code class="mi">2</code>  <code class="n">A2</code>  <code class="n">B2</code>  <code class="n">C2</code>      <code class="mi">4</code>  <code class="n">B4</code>  <code class="n">C4</code>  <code class="n">D4</code>

         <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">df5</code><code class="p">,</code> <code class="n">df6</code><code class="p">],</code> <code class="n">join</code><code class="o">=</code><code class="s1">'inner'</code><code class="p">)</code>
             <code class="n">B</code>   <code class="n">C</code>
         <code class="mi">1</code>  <code class="n">B1</code>  <code class="n">C1</code>
         <code class="mi">2</code>  <code class="n">B2</code>  <code class="n">C2</code>
         <code class="mi">3</code>  <code class="n">B3</code>  <code class="n">C3</code>
         <code class="mi">4</code>  <code class="n">B4</code>  <code class="n">C4</code></pre>
<p>Another useful pattern is to use the <code>reindex</code> method before
concatenation for finer control over which columns are dropped:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">concat</code><code class="p">([</code><code class="n">df5</code><code class="p">,</code> <code class="n">df6</code><code class="o">.</code><code class="n">reindex</code><code class="p">(</code><code class="n">df5</code><code class="o">.</code><code class="n">columns</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code>      <code class="n">A</code>   <code class="n">B</code>   <code class="n">C</code>
         <code class="mi">1</code>   <code class="n">A1</code>  <code class="n">B1</code>  <code class="n">C1</code>
         <code class="mi">2</code>   <code class="n">A2</code>  <code class="n">B2</code>  <code class="n">C2</code>
         <code class="mi">3</code>  <code class="n">NaN</code>  <code class="n">B3</code>  <code class="n">C3</code>
         <code class="mi">4</code>  <code class="n">NaN</code>  <code class="n">B4</code>  <code class="n">C4</code></pre>
</div></section>
<section data-pdf-bookmark="The append Method" data-type="sect2"><div class="sect2" id="ch_0306-concat-and-append_the-append-method">
<h2>The append Method</h2>
<p><a data-primary="append() method, Pandas versus Python" data-type="indexterm" id="idm45858779712928"/><a data-primary="datasets" data-secondary="appending" data-type="indexterm" id="idm45858779712064"/><a data-primary="Pandas" data-secondary="appending datasets" data-type="indexterm" id="idm45858779711088"/>Because direct array concatenation is so common, <code>Series</code> and
<code>DataFrame</code> objects have an <code>append</code> method that can accomplish the same
thing in fewer keystrokes. For example, in place of
<code>pd.concat([df1, df2])</code>, you can use <code>df1.append(df2)</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">display</code><code class="p">(</code><code class="s1">'df1'</code><code class="p">,</code> <code class="s1">'df2'</code><code class="p">,</code> <code class="s1">'df1.append(df2)'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">df1</code>            <code class="n">df2</code>           <code class="n">df1</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">df2</code><code class="p">)</code>
             <code class="n">A</code>   <code class="n">B</code>          <code class="n">A</code>   <code class="n">B</code>         <code class="n">A</code>   <code class="n">B</code>
         <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>      <code class="mi">3</code>  <code class="n">A3</code>  <code class="n">B3</code>     <code class="mi">1</code>  <code class="n">A1</code>  <code class="n">B1</code>
         <code class="mi">2</code>  <code class="n">A2</code>  <code class="n">B2</code>      <code class="mi">4</code>  <code class="n">A4</code>  <code class="n">B4</code>     <code class="mi">2</code>  <code class="n">A2</code>  <code class="n">B2</code>
                                      <code class="mi">3</code>  <code class="n">A3</code>  <code class="n">B3</code>
                                      <code class="mi">4</code>  <code class="n">A4</code>  <code class="n">B4</code></pre>
<p>Keep in mind that unlike the <code>append</code> and <code>extend</code> methods of Python
lists, the <code>append</code> method in Pandas does not modify the original
object; instead it creates a new object with the combined data. It also
is not a very efficient method, because it involves creation of a new
index <em>and</em> data buffer. Thus, if you plan to do multiple <code>append</code>
operations, it is generally better to build a list of <code>DataFrame</code>
objects and pass them all at once to the <code>concat</code> function.</p>
<p>In the next chapter, we’ll look at a more powerful approach
to combining data from multiple sources: the database-style merges/joins
implemented in <code>pd.merge</code>. For more information on <code>concat</code>, <code>append</code>,
and related functionality, see
<a href="https://oreil.ly/cY16c">“Merge, Join,
Concatenate and Compare” in the Pandas documentation</a>.<a data-startref="ix_ch18-asciidoc3" data-type="indexterm" id="idm45858779579904"/><a data-startref="ix_ch18-asciidoc2" data-type="indexterm" id="idm45858779579296"/><a data-startref="ix_ch18-asciidoc1" data-type="indexterm" id="idm45858779578688"/><a data-startref="ix_ch18-asciidoc0" data-type="indexterm" id="idm45858779578080"/></p>
</div></section>
</div></section>
</div></section></div></body></html>