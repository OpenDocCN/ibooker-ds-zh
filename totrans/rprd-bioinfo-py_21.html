<html><head></head><body><section data-pdf-bookmark="Chapter 19. Blastomatic: Parsing Delimited Text Files" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch19">&#13;
<h1><span class="label">Chapter 19. </span>Blastomatic: Parsing Delimited Text Files</h1>&#13;
&#13;
&#13;
<p>Delimited text files are a standard way to encode columnar data.<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="about delimited text files" data-type="indexterm" id="idm45963626777592"/><a data-primary="delimited text files" data-secondary="about" data-type="indexterm" id="idm45963626776600"/><a data-primary="sequence file comparison" data-secondary="about delimited text files" data-type="indexterm" id="idm45963626775656"/><a data-primary="CSV (comma-separated values) files" data-secondary="about" data-type="indexterm" id="idm45963626774680"/>&#13;
You are likely familiar with spreadsheets like Microsoft Excel or Google Sheets, where each worksheet may hold a dataset with columns across the top and records running down.&#13;
You can export this data to a text file where the columns of data are <em>delimited</em>, or separated by a character.&#13;
Quite often the delimiter is a comma, and the file will have an extension of <em>.csv</em>.&#13;
This format is called <em>CSV</em>, for <em>comma-separated values</em>.&#13;
When the delimiter is a tab, the extension may be <em>.tab</em>, <em>.txt</em>, or <em>.tsv</em> for <em>tab-separated values</em>.&#13;
The first line of the file usually will contain the names of the columns.&#13;
Notably, this is not the case with the tabular output from BLAST (Basic Local Alignment Search Tool),<a data-primary="sequence file comparison" data-secondary="about BLAST" data-type="indexterm" id="ch19-blst"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="about BLAST" data-type="indexterm" id="ch19-blst2"/><a data-primary="CSV (comma-separated values) files" data-secondary="about BLAST" data-type="indexterm" id="ch19-blst3"/><a data-primary="delimited text files" data-secondary="about BLAST" data-type="indexterm" id="ch19-blst4"/> one of the most popular tools in bioinformatics used to compare sequences.&#13;
In this chapter, I will show you how to parse this output and merge the BLAST results with metadata from another delimited text file using the <code>csv</code> and <code>pandas</code> modules.</p>&#13;
&#13;
<p>In this exercise, you will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to use <code>csvkit</code> and <code>csvchk</code> to view delimited text files</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use the <code>csv</code> and <code>pandas</code> modules to parse delimited text files</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introduction to BLAST" data-type="sect1"><div class="sect1" id="idm45963626758568">&#13;
<h1>Introduction to BLAST</h1>&#13;
&#13;
<p>The BLAST program is one of the most ubiquitous tools in bioinformatics for determining sequence similarity.&#13;
In <a data-type="xref" href="ch06.html#ch06">Chapter 6</a>, I showed how the Hamming distance between two sequences is one measure of similarity and compared this to the concept of alignment.&#13;
Whereas the Hamming distance compares both sequences starting from the beginning,<a data-primary="Hamming distance determination" data-secondary="about BLAST sequence comparisons" data-type="indexterm" id="idm45963626756152"/><a data-primary="sequence similarity" data-secondary="BLAST versus Hamming distance" data-seealso="BLAST (Basic Local Alignment Search Tool)" data-type="indexterm" id="idm45963626755176"/> an alignment with BLAST starts wherever both sequences begin to overlap and will allow for insertions, deletions, and mismatches to find the longest possible areas of similarity.</p>&#13;
&#13;
<p>I’ll show you the National Center for Biotechnology (NCBI) BLAST web interface, but you can use <code>blastn</code> if you have BLAST installed locally.<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastn for local execution" data-type="indexterm" id="idm45963626752600"/><a data-primary="command line (Unix)" data-secondary="blastn for NCBI BLAST" data-type="indexterm" id="idm45963626751608"/><a data-primary="Unix command line" data-secondary="blastn for NCBI BLAST" data-type="indexterm" id="idm45963626750664"/><a data-primary="sequence file comparison" data-secondary="blastn for local execution" data-type="indexterm" id="idm45963626749720"/>&#13;
I will compare 100 sequences from the <a href="https://oreil.ly/POkOV">Global Ocean Sampling Expedition (GOS)</a> to a sequence database at NCBI.<a data-primary="Global Ocean Sampling Expedition (GOS)" data-secondary="URL" data-type="indexterm" id="idm45963626747816"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="GOS (Global Ocean Sampling Expedition)" data-tertiary="URL" data-type="indexterm" id="idm45963626746856"/><a data-primary="sequence file comparison" data-secondary="GOS (Global Ocean Sampling Expedition)" data-tertiary="URL" data-type="indexterm" id="idm45963626745592"/>&#13;
GOS is one of the earliest metagenomic studies,<a data-primary="metagenomic studies of Global Ocean Sampling Expedition (GOS)" data-type="indexterm" id="idm45963626744152"/><a data-primary="Venter, Craig" data-type="indexterm" id="idm45963626743432"/> dating from the early 2000s when Dr. Craig Venter funded a two-year expedition to collect and analyze ocean samples from around the globe.&#13;
It’s a <em>metagenomic</em> project because the genetic material was taken directly from an environmental sample.&#13;
The purpose of using BLAST is to compare the unknown GOS sequences to known sequences at NCBI to determine their possible taxonomic classification.</p>&#13;
&#13;
<p>I used the FASTX sampler from <a data-type="xref" href="ch18.html#ch18">Chapter 18</a> to randomly select the 100 input sequences in <em>tests/inputs/gos.fa</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ../15_seqmagique/seqmagique.py tests/inputs/gos.fa&#13;
name                   min_len    max_len    avg_len    num_seqs&#13;
tests/inputs/gos.fa        216       1212    1051.48         100</pre>&#13;
&#13;
<p>I used <a href="https://oreil.ly/gXErw">the NCBI BLAST tool</a> to compare these sequences<a data-primary="sequence file comparison" data-secondary="web interface (NCBI)" data-type="indexterm" id="idm45963626737960"/><a data-primary="National Center for Biotechnology Information (NCBI)" data-secondary="BLAST web interface" data-type="indexterm" id="idm45963626737000"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="web interface (NCBI)" data-type="indexterm" id="idm45963626736024"/><a data-primary="nonredundant nucleotide (nr/nt) database" data-type="indexterm" id="idm45963626735048"/><a data-primary="nr/nt (nonredundant nucleotide) database" data-type="indexterm" id="idm45963626734344"/><a data-primary="National Center for Biotechnology Information (NCBI)" data-secondary="nr/nt (nonredundant nucleotide) database" data-type="indexterm" id="idm45963626733640"/> to the <em>nr/nt</em> (nonredundant nucleotide) database using the <code>blastn</code> program to compare nucleotides.&#13;
The results page allows me to select the detailed results for each of the 100 sequences.&#13;
As shown in <a data-type="xref" href="#fig_19.1">Figure 19-1</a>, the first sequence has four <em>hits</em> or matches to known sequences.&#13;
The first and best hit is about 93% identical over 99% of its length to a portion of the genome of <a href="https://oreil.ly/qywN2"><em>Candidatus Pelagibacter</em></a>, a marine bacteria of the SAR11 clade.<a data-primary="National Center for Biotechnology Information (NCBI)" data-secondary="Candidatus Pelagibacter genome" data-type="indexterm" id="idm45963626729160"/><a data-primary="Candidatus Pelagibacter genome" data-type="indexterm" id="idm45963626728168"/>&#13;
Given that the GOS query sequence came from the ocean, this seems a likely match.</p>&#13;
&#13;
<figure><div class="figure" id="fig_19.1">&#13;
<img alt="mpfb 1901" src="assets/mpfb_1901.png"/>&#13;
<h6><span class="label">Figure 19-1. </span>The first GOS sequence has four possible matches from nr/nt</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#fig_19.2">Figure 19-2</a> shows how similar the query sequence is to a region of the <em>Candidatus Pelagibacter</em> genome.&#13;
Notice how the alignment allows for single-nucleotide variations (SNVs) and gaps caused by deletions or insertions between the sequences.<a data-primary="SNVs (single-nucleotide variations)" data-type="indexterm" id="idm45963626723416"/>&#13;
If you want to challenge yourself, try writing a sequence aligner.&#13;
You can see an example in <a data-type="xref" href="#fig_19.2">Figure 19-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_19.2">&#13;
<img alt="mpfb 1902" src="assets/mpfb_1902.png"/>&#13;
<h6><span class="label">Figure 19-2. </span>The alignment of the top BLAST hit</h6>&#13;
</div></figure>&#13;
&#13;
<p>As interesting as it is to explore each individual hit, I want to download a table of all the hits.&#13;
There is a Download All menu with 11 download formats.&#13;
I chose the “Hit table(csv)” format and split this data into <em>hits1.csv</em> and <em>hits2.csv</em> in the <em>tests/inputs</em> directory:<a data-primary="CSV (comma-separated values) files" data-secondary="BLAST table of hits" data-type="indexterm" id="idm45963626717592"/><a data-primary="delimited text files" data-secondary="BLAST table of hits" data-type="indexterm" id="idm45963626716632"/></p>&#13;
&#13;
<pre data-type="programlisting">$ wc -l tests/inputs/hits*.csv&#13;
     500 tests/inputs/hits1.csv&#13;
     255 tests/inputs/hits2.csv&#13;
     755 total</pre>&#13;
&#13;
<p>If you open these files with a text editor, you’ll see they contain comma-separated values.&#13;
You can also open a file with a spreadsheet program like Excel to see the data in columnar format, and you may notice that the columns are not named.&#13;
If you were on a remote machine like a cluster node, you would likely not have access to a graphical program like Excel to inspect the results.&#13;
Further, Excel is limited to about 1 million rows and 16,000 columns.<a data-primary="memory issues" data-secondary="Excel limitations" data-type="indexterm" id="idm45963626713976"/>&#13;
In real-world bioinformatics, it’s pretty easy to exceed both of those values, so I’ll show you command-line tools you can use to look at delimited text files.<a data-startref="ch19-blst" data-type="indexterm" id="idm45963626712728"/><a data-startref="ch19-blst2" data-type="indexterm" id="idm45963626712056"/><a data-startref="ch19-blst3" data-type="indexterm" id="idm45963626711384"/><a data-startref="ch19-blst4" data-type="indexterm" id="idm45963626710712"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using csvkit and csvchk" data-type="sect1"><div class="sect1" id="ch19-using-csvkit-and-csvchk">&#13;
<h1>Using csvkit and csvchk</h1>&#13;
&#13;
<p>First, I’d like to introduce the <code>csvkit</code> module, “a suite of command-line tools for converting to and working with CSV.”<a data-primary="CSV (comma-separated values) files" data-secondary="csvkit module" data-type="indexterm" id="idm45963626707608"/><a data-primary="delimited text files" data-secondary="csvkit module" data-type="indexterm" id="idm45963626706648"/><a data-primary="sequence file comparison" data-secondary="csvkit module for CSV files" data-type="indexterm" id="idm45963626705704"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="csvkit module for CSV files" data-type="indexterm" id="idm45963626704728"/><a data-primary="command line (Unix)" data-secondary="csvkit module for CSV files" data-type="indexterm" id="idm45963626703736"/><a data-primary="Unix command line" data-secondary="csvkit module for CSV files" data-type="indexterm" id="idm45963626702776"/>&#13;
The <em>requirements.txt</em> file for the repo lists this as a dependency, so it’s probably installed.&#13;
If not, you can use this command to install it:<a data-primary="pip package installer" data-secondary="csvkit module" data-type="indexterm" id="idm45963626701096"/></p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m pip install csvkit</pre>&#13;
&#13;
<p>This will install several useful utilities, and I encourage you to read <a href="https://oreil.ly/QDAn2">the documentation</a> to learn about them.&#13;
I want to highlight <code>csvlook</code>, which “renders a CSV file in the console as a Markdown-compatible, fixed-width table.”<a data-primary="CSV (comma-separated values) files" data-secondary="csvkit module" data-tertiary="csvlook" data-type="indexterm" id="idm45963626697624"/><a data-primary="delimited text files" data-secondary="csvkit module" data-tertiary="csvlook" data-type="indexterm" id="idm45963626696392"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="csvkit module for CSV files" data-tertiary="csvlook" data-type="indexterm" id="idm45963626695176"/><a data-primary="sequence file comparison" data-secondary="csvkit module for CSV files" data-tertiary="csvlook" data-type="indexterm" id="idm45963626693912"/><a data-primary="command line (Unix)" data-secondary="csvkit module for CSV files" data-tertiary="csvlook" data-type="indexterm" id="idm45963626692664"/><a data-primary="Unix command line" data-secondary="csvkit module for CSV files" data-tertiary="csvlook" data-type="indexterm" id="idm45963626691432"/>&#13;
Run <strong><code>csvlook --help</code></strong> to view the usage and notice there is an <code>-H|--no-header-row</code> option to view files that have no header row.&#13;
The following command will display the first three rows of the hits table.&#13;
Depending on the size of your screen, this might be unreadable:</p>&#13;
&#13;
<pre data-type="programlisting">$ csvlook -H --max-rows 3 tests/inputs/hits1.csv</pre>&#13;
&#13;
<p>The <a href="https://oreil.ly/T2QSo"><code>csvchk</code> program</a> will transpose a wide record like this to a tall one vertically oriented with the column names on the left rather than across the top.&#13;
This, too, should have been installed with other module dependencies, but you can use <code>pip</code> to install it if needed:<a data-primary="pip package installer" data-secondary="csvchk" data-type="indexterm" id="idm45963626685928"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="csvchk for CSV files" data-type="indexterm" id="idm45963626684984"/><a data-primary="command line (Unix)" data-secondary="csvchk for CSV files" data-type="indexterm" id="idm45963626684008"/><a data-primary="CSV (comma-separated values) files" data-secondary="csvchk" data-type="indexterm" id="idm45963626683064"/><a data-primary="delimited text files" data-secondary="csvchk" data-type="indexterm" id="idm45963626682104"/><a data-primary="sequence file comparison" data-secondary="csvchk for CSV files" data-type="indexterm" id="idm45963626681160"/><a data-primary="Unix command line" data-secondary="csvchk for CSV files" data-type="indexterm" id="idm45963626680200"/></p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m pip install csvchk</pre>&#13;
&#13;
<p>If you read the usage, you’ll see that this tool also has an <code>-N|--noheaders</code> option.&#13;
Use <code>csvchk</code> to inspect the first record in the same hits file:</p>&#13;
&#13;
<pre data-type="programlisting">$ csvchk -N tests/inputs/hits1.csv&#13;
// ****** Record 1 ****** //&#13;
Field1  : CAM_READ_0234442157&#13;
Field2  : CP031125.1&#13;
Field3  : 92.941&#13;
Field4  : 340&#13;
Field5  : 21&#13;
Field6  : 3&#13;
Field7  : 3&#13;
Field8  : 340&#13;
Field9  : 801595&#13;
Field10 : 801257&#13;
Field11 : 6.81e-135&#13;
Field12 : 492</pre>&#13;
&#13;
<p>The output files you can download from NCBI BLAST match the output formats from the command-line <a data-primary="sequence file comparison" data-secondary="output formats" data-type="indexterm" id="idm45963626675592"/><a data-primary="output from program" data-secondary="NCBI BLAST" data-type="indexterm" id="idm45963626674632"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="output formats" data-type="indexterm" id="idm45963626673688"/><a data-primary="command line (Unix)" data-secondary="blastn for NCBI BLAST" data-tertiary="output formats" data-type="indexterm" id="idm45963626672712"/><a data-primary="Unix command line" data-secondary="blastn for NCBI BLAST" data-tertiary="output formats" data-type="indexterm" id="idm45963626671496"/>versions of the BLAST programs, like <code>blastn</code> for comparing nucleotides, <code>blastp</code> for comparing proteins, etc.&#13;
The help documentation for <code>blastn</code> includes an <code>-outfmt</code> option to specify the output format using a number between 0 and 18.&#13;
The preceding output file format is the “Tabular” option 6:</p>&#13;
&#13;
<pre class="pagebreak-before" data-type="programlisting"> *** Formatting options&#13;
 -outfmt &lt;String&gt;&#13;
   alignment view options:&#13;
     0 = Pairwise,&#13;
     1 = Query-anchored showing identities,&#13;
     2 = Query-anchored no identities,&#13;
     3 = Flat query-anchored showing identities,&#13;
     4 = Flat query-anchored no identities,&#13;
     5 = BLAST XML,&#13;
     6 = Tabular,&#13;
     7 = Tabular with comment lines,&#13;
     8 = Seqalign (Text ASN.1),&#13;
     9 = Seqalign (Binary ASN.1),&#13;
    10 = Comma-separated values,&#13;
    11 = BLAST archive (ASN.1),&#13;
    12 = Seqalign (JSON),&#13;
    13 = Multiple-file BLAST JSON,&#13;
    14 = Multiple-file BLAST XML2,&#13;
    15 = Single-file BLAST JSON,&#13;
    16 = Single-file BLAST XML2,&#13;
    17 = Sequence Alignment/Map (SAM),&#13;
    18 = Organism Report</pre>&#13;
&#13;
<p>You may find yourself wondering why the tabular output file does not contain the column headers.<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="output formats" data-tertiary="column names" data-type="indexterm" id="idm45963626665944"/><a data-primary="sequence file comparison" data-secondary="output formats" data-tertiary="column names" data-type="indexterm" id="idm45963626664696"/>&#13;
If you read through all the formatting options, you may notice that output format 7 is “Tabular with comment lines,” and you may ask yourself: Is this the option that will include the column names?&#13;
Dear reader, you will be sorely disappointed to learn it does not.<sup><a data-type="noteref" href="ch19.html#idm45963626663048" id="idm45963626663048-marker">1</a></sup>&#13;
Option 7 is the same as the “Hits table(text)” option on the NCBI BLAST page.&#13;
Download and open that file to see that it contains metadata about the search as unstructured text on lines that begin with the <code>#</code> character.<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="output formats" data-tertiary="# commenting out metadata" data-type="indexterm" id="idm45963626661640"/><a data-primary="sequence file comparison" data-secondary="output formats" data-tertiary="# commenting out metadata" data-type="indexterm" id="idm45963626660376"/><a data-primary="# (comment)" data-primary-sortas="# comment" data-type="indexterm" id="idm45963626659128"/>&#13;
Because so many languages (including Python) use this as a comment character to indicate a line that should be ignored, it’s common to say that the metadata is <em>commented out</em>, and many delimited text parsers will skip these lines.</p>&#13;
&#13;
<p>So what are the column names?&#13;
I must parse through hundreds of lines of the <code>blastn</code> usage to find that “Options 6, 7, 10 and 17 can be additionally configured” to include any of 53 optional fields.&#13;
If the fields are not specified, then the default fields are as follows:<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastn for local execution" data-tertiary="default fields listed" data-type="indexterm" id="idm45963626656248"/><a data-primary="Unix command line" data-secondary="blastn for NCBI BLAST" data-tertiary="default fields listed" data-type="indexterm" id="idm45963626654984"/><a data-primary="command line (Unix)" data-secondary="blastn for NCBI BLAST" data-tertiary="default fields listed" data-type="indexterm" id="idm45963626653768"/><a data-primary="sequence file comparison" data-secondary="blastn for local execution" data-tertiary="default fields listed" data-type="indexterm" id="idm45963626652552"/></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>qaccver</code>: Query sequence accession/ID</p>&#13;
</li>&#13;
<li>&#13;
<p><code>saccver</code>: Subject sequence accession/ID</p>&#13;
</li>&#13;
<li>&#13;
<p><code>pident</code>: Percentage of identical matches</p>&#13;
</li>&#13;
<li>&#13;
<p><code>length</code>: Alignment length</p>&#13;
</li>&#13;
<li>&#13;
<p><code>mismatch</code>: Number of mismatches</p>&#13;
</li>&#13;
<li>&#13;
<p><code>gapopen</code>: Number of gap openings</p>&#13;
</li>&#13;
<li>&#13;
<p><code>qstart</code>:  Start of alignment in query</p>&#13;
</li>&#13;
<li>&#13;
<p><code>qend</code>: End of alignment in query</p>&#13;
</li>&#13;
<li>&#13;
<p><code>sstart</code>: Start of alignment in subject</p>&#13;
</li>&#13;
<li>&#13;
<p><code>send</code>: End of alignment in subject</p>&#13;
</li>&#13;
<li>&#13;
<p><code>evalue</code>: Expect value</p>&#13;
</li>&#13;
<li>&#13;
<p><code>bitscore</code>: Bit score</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If you look again at the usage for <code>csvchk</code>, you’ll find there is an option to name the &#13;
<span class="keep-together"><code>-f|--fieldnames</code></span> for the record.<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="csvchk for CSV files" data-tertiary="column names" data-type="indexterm" id="idm45963626634728"/><a data-primary="command line (Unix)" data-secondary="csvchk for CSV files" data-tertiary="column names" data-type="indexterm" id="idm45963626633480"/><a data-primary="CSV (comma-separated values) files" data-secondary="csvchk" data-tertiary="column names" data-type="indexterm" id="idm45963626632264"/><a data-primary="delimited text files" data-secondary="csvchk" data-tertiary="column names" data-type="indexterm" id="idm45963626631032"/><a data-primary="sequence file comparison" data-secondary="csvchk for CSV files" data-tertiary="column names" data-type="indexterm" id="idm45963626629816"/><a data-primary="Unix command line" data-secondary="csvchk for CSV files" data-tertiary="column names" data-type="indexterm" id="idm45963626628584"/>&#13;
Following is how I could view the first record from a hits file and specify column names:</p>&#13;
&#13;
<pre data-type="programlisting">$ csvchk -f 'qseqid,sseqid,pident,length,mismatch,gapopen,qstart,qend,\&#13;
  sstart,send,evalue,bitscore' tests/inputs/hits1.csv&#13;
// ****** Record 1 ****** //&#13;
qseqid   : CAM_READ_0234442157&#13;
sseqid   : CP031125.1&#13;
pident   : 92.941&#13;
length   : 340&#13;
mismatch : 21&#13;
gapopen  : 3&#13;
qstart   : 3&#13;
qend     : 340&#13;
sstart   : 801595&#13;
send     : 801257&#13;
evalue   : 6.81e-135&#13;
bitscore : 492</pre>&#13;
&#13;
<p>This is a much more useful output.&#13;
If you like this command, you can create an alias called <code>blstchk</code> in <code>bash</code>, like so:<a data-primary="bash shell" data-secondary="alias" data-type="indexterm" id="idm45963626624632"/><a data-primary="alias in bash shell" data-type="indexterm" id="idm45963626623688"/></p>&#13;
&#13;
<pre data-type="programlisting">alias blstchk='csvchk -f "qseqid,sseqid,pident,length,mismatch,gapopen,\&#13;
    qstart,qend,sstart,send,evalue,bitscore"'</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>Most shells allow you to define aliases like this in a file that is read each time you start a new shell. In <code>bash</code>, you could add this line to a file in your <code>$HOME</code> directory, like <em>.bash_profile</em>, <em>.bashrc</em>, or <em>.profile</em>. Other shells have similar properties. Aliases are a handy way to create global shortcuts for common commands. If you wish to create a command shortcut inside a particular project or directory, consider using a target in a <em>Makefile</em>.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Here is how I use the <code>blstchk</code> command:</p>&#13;
&#13;
<pre data-type="programlisting">$ blstchk tests/inputs/hits1.csv&#13;
// ****** Record 1 ****** //&#13;
qseqid   : CAM_READ_0234442157&#13;
sseqid   : CP031125.1&#13;
pident   : 92.941&#13;
length   : 340&#13;
mismatch : 21&#13;
gapopen  : 3&#13;
qstart   : 3&#13;
qend     : 340&#13;
sstart   : 801595&#13;
send     : 801257&#13;
evalue   : 6.81e-135&#13;
bitscore : 492</pre>&#13;
&#13;
<p>The goal of the program in this chapter is to link the BLAST hits to the depth and location of the GOS sequences found in the file <em>tests/inputs/meta.csv</em>.<a data-primary="Global Ocean Sampling Expedition (GOS)" data-secondary="BLAST hits linked to sequences" data-type="indexterm" id="idm45963626614856"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="GOS (Global Ocean Sampling Expedition)" data-tertiary="BLAST hits linked to sequences" data-type="indexterm" id="idm45963626613880"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="about BLAST/GOS goal" data-type="indexterm" id="idm45963626612600"/><a data-primary="sequence file comparison" data-secondary="about BLAST/GOS goal" data-type="indexterm" id="idm45963626611624"/><a data-primary="sequence file comparison" data-secondary="GOS (Global Ocean Sampling Expedition)" data-tertiary="BLAST hits linked to sequences" data-type="indexterm" id="idm45963626610664"/>&#13;
I will use &#13;
<span class="keep-together">the <code>-g|--grep</code></span> option to <code>csvchk</code> to find the preceding query sequence, <em>CAM_READ_0234442157</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ csvchk -g CAM_READ_0234442157 tests/inputs/meta.csv&#13;
// ****** Record 1 ****** //&#13;
seq_id     : CAM_READ_0234442157&#13;
sample_acc : CAM_SMPL_GS112&#13;
date       : 8/8/05&#13;
depth      : 4573&#13;
salinity   : 32.5&#13;
temp       : 26.6&#13;
lat_lon    : -8.50525,80.375583</pre>&#13;
&#13;
<p>The BLAST results can be joined to the metadata where the former’s <code>qseqid</code> is equal to the latter’s <code>seq_id</code>.&#13;
There is a command-line tool called <code>join</code> that will do exactly this.&#13;
The inputs must both be sorted, and I will use the <code>-t</code> option to indicate that the comma is the field delimiter.&#13;
By default, <code>join</code> assumes the first column in each file is the common value, which is true here.&#13;
The output is a comma-separated union of the fields from both files:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd tests/inputs/&#13;
$ join -t , &lt;(sort hits1.csv) &lt;(sort meta.csv) | csvchk -s "," -N - <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO1-1" id="co_blastomatic__parsing_delimited_text_files_CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
// ****** Record 1 ****** //&#13;
Field1  : CAM_READ_0234442157&#13;
Field2  : CP046232.1&#13;
Field3  : 83.810&#13;
Field4  : 105&#13;
Field5  : 12&#13;
Field6  : 5&#13;
Field7  : 239&#13;
Field8  : 340&#13;
Field9  : 212245&#13;
Field10 : 212143&#13;
Field11 : 2.24e-15&#13;
Field12 : 95.3&#13;
Field13 : CAM_SMPL_GS112&#13;
Field14 : 8/8/05&#13;
Field15 : 4573&#13;
Field16 : 32.5&#13;
Field17 : 26.6&#13;
Field18 : -8.50525,80.375583</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO1-1" id="callout_blastomatic__parsing_delimited_text_files_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The two positional inputs to <code>join</code> use shell redirection <code>&lt;</code> to read in the results of sorting the two input files. The output from <code>join</code> is piped to <code>csvchk</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Although it’s good to know how to use <code>join</code>, this output is not particularly useful because it does not have the column headers.&#13;
(Also, the point is to learn how to do this in Python.)&#13;
How might you add headers to this information?&#13;
Would you cobble together some shell commands in a <code>bash</code> script or a <em>Makefile</em> target, or would you write a Python program?&#13;
Let’s keep moving, shall we?&#13;
Next, I’ll show you how the program should work and the output it will create.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963626592632">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>All the code and tests for this exercise can be found in the <em>19_blastomatic</em> directory of the repository.<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastomatic program created" data-tertiary="getting started" data-type="indexterm" id="idm45963626590824"/><a data-primary="sequence file comparison" data-secondary="blastomatic program created" data-tertiary="getting started" data-type="indexterm" id="idm45963626589560"/>&#13;
Change to this directory and copy the second solution to the program <code>blastomatic.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 19_blastomatic/&#13;
$ cp solution2_dict_writer.py blastomatic.py</pre>&#13;
&#13;
<p>The program will accept the BLAST hits and the metadata file and will produce an output file showing the sequence ID, the percent identity match, the depth, and the latitude and longitude of the sample.&#13;
Optionally, the output can be filtered by the percent identity.&#13;
Request help from the program to see the options:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./blastomatic.py -h&#13;
usage: blastomatic.py [-h] -b FILE -a FILE [-o FILE] [-d DELIM] [-p PCTID]&#13;
&#13;
Annotate BLAST output&#13;
&#13;
optional arguments:&#13;
  -h, --help            show this help message and exit&#13;
  -b FILE, --blasthits FILE&#13;
                        BLAST -outfmt 6 (default: None) <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO2-1" id="co_blastomatic__parsing_delimited_text_files_CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
  -a FILE, --annotations FILE&#13;
                        Annotations file (default: None) <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO2-2" id="co_blastomatic__parsing_delimited_text_files_CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
  -o FILE, --outfile FILE&#13;
                        Output file (default: out.csv) <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO2-3" id="co_blastomatic__parsing_delimited_text_files_CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
  -d DELIM, --delimiter DELIM&#13;
                        Output field delimiter (default: ) <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO2-4" id="co_blastomatic__parsing_delimited_text_files_CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
  -p PCTID, --pctid PCTID&#13;
                        Minimum percent identity (default: 0.0) <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO2-5" id="co_blastomatic__parsing_delimited_text_files_CO2-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO2-1" id="callout_blastomatic__parsing_delimited_text_files_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The tabular output file from a BLAST search in <code>-outfmt 6</code>.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO2-2" id="callout_blastomatic__parsing_delimited_text_files_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>An annotations file with metadata about the sequences.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO2-3" id="callout_blastomatic__parsing_delimited_text_files_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The name of the output file, which defaults to <em>out.csv</em>.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO2-4" id="callout_blastomatic__parsing_delimited_text_files_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The output file delimiter, which defaults to a guess based on the output file extension.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO2-5" id="callout_blastomatic__parsing_delimited_text_files_CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The minimum percent identity, which defaults to <code>0</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If I run the program using the first hits file, it will write 500 sequences to the output file <em>out.csv</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./blastomatic.py -b tests/inputs/hits1.csv -a tests/inputs/meta.csv&#13;
Exported 500 to "out.csv".</pre>&#13;
&#13;
<p>I can use <code>csvlook</code> with the <code>--max-rows</code> option to view the first two rows of the table:</p>&#13;
&#13;
<pre data-type="programlisting">$ csvlook --max-rows 2 out.csv&#13;
| qseqid              | pident | depth | lat_lon            |&#13;
| ------------------- | ------ | ----- | ------------------ |&#13;
| CAM_READ_0234442157 | 92.941 | 4,573 | -8.50525,80.375583 |&#13;
| CAM_READ_0234442157 | 85.000 | 4,573 | -8.50525,80.375583 |&#13;
| ...                 |    ... |   ... | ...                |</pre>&#13;
&#13;
<p>Or I can use <code>csvchk</code> with <code>-l|--limit</code> to do the same:</p>&#13;
&#13;
<pre data-type="programlisting">$ csvchk --limit 2 out.csv&#13;
// ****** Record 1 ****** //&#13;
qseqid  : CAM_READ_0234442157&#13;
pident  : 92.941&#13;
depth   : 4573&#13;
lat_lon : -8.50525,80.375583&#13;
// ****** Record 2 ****** //&#13;
qseqid  : CAM_READ_0234442157&#13;
pident  : 85.000&#13;
depth   : 4573&#13;
lat_lon : -8.50525,80.375583</pre>&#13;
&#13;
<p>If I want to only export hits with a percent identity greater than or equal to 90%, I can use the <code>-p|--pctid</code> option to find that only 190 records are found:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./blastomatic.py -b tests/inputs/hits1.csv -a tests/inputs/meta.csv -p 90&#13;
Exported 190 to "out.csv".</pre>&#13;
&#13;
<p>I can peek at the file to see that it appears to have selected the correct data:</p>&#13;
&#13;
<pre data-type="programlisting">$ csvlook --max-rows 4 out.csv&#13;
| qseqid                  | pident | depth | lat_lon              |&#13;
| ----------------------- | ------ | ----- | -------------------- |&#13;
| CAM_READ_0234442157     | 92.941 | 4,573 | -8.50525,80.375583   |&#13;
| JCVI_READ_1091145027519 | 97.368 |     2 | 44.137222,-63.644444 |&#13;
| JCVI_READ_1091145742680 | 98.714 |    64 | 44.690277,-63.637222 |&#13;
| JCVI_READ_1091145742680 | 91.869 |    64 | 44.690277,-63.637222 |&#13;
| ...                     |    ... |   ... | ...                  |</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45963626550040">&#13;
<h5>Using awk and cut with Delimited Text</h5>&#13;
<p>If I only wanted to inspect the second column of data, I could use the <code>cut</code> tool, which has the <code>-f</code> option to select the second field (1-based counting) and the <code>-d</code> option to indicate the comma as the delimiter:<a data-primary="delimited text files" data-secondary="command line awk and cut tools" data-type="indexterm" id="idm45963626547256"/><a data-primary="CSV (comma-separated values) files" data-secondary="command line awk and cut tools" data-type="indexterm" id="idm45963626546296"/><a data-primary="command line (Unix)" data-secondary="delimited files and awk and cut" data-type="indexterm" id="idm45963626545320"/><a data-primary="Unix command line" data-secondary="delimited files and awk and cut" data-type="indexterm" id="idm45963626544360"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="output formats" data-tertiary="awk and cut command line tools" data-type="indexterm" id="idm45963626543400"/><a data-primary="sequence file comparison" data-secondary="output formats" data-tertiary="awk and cut command line tools" data-type="indexterm" id="idm45963626542136"/><a data-primary="awk command line tool" data-type="indexterm" id="idm45963626540888"/><a data-primary="cut command line tool" data-type="indexterm" id="idm45963626540216"/></p>&#13;
&#13;
<pre data-type="programlisting">$ cut -f2 -d, out.csv</pre>&#13;
&#13;
<p>Alternatively, I could use <code>awk</code> with the <code>-F</code> option to indicate the comma as the field separator and the instruction <code>{print $2}</code> (also 1-based) to indicate that it should print the second field:</p>&#13;
&#13;
<pre data-type="programlisting">$ awk -F, '{print $2}' out.csv</pre>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The quotes in the <code>awk</code> command must be delimited by single quotes in <code>bash</code> because double quotes would try to interpolate the variable <code>$2</code>. Ah, the vagaries of shell quoting.</p>&#13;
</div>&#13;
&#13;
<p>If I additionally wanted to verify that all the values in the second column were indeed greater than or equal to <code>90</code>, I could use <code>awk</code> with <code>cut</code>.&#13;
Note I need to add <code>0</code> to the first field to force <code>awk</code> to treat the value as an integer:</p>&#13;
&#13;
<pre data-type="programlisting">$ cut -f2 -d, out.csv | awk '$1 + 0 &gt;= 90' | wc -l&#13;
     190</pre>&#13;
&#13;
<p>Or I could use <code>awk</code> to only print the values of column 2 when they are greater than or equal to <code>90</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ awk -F"," '$2 + 0 &gt;= 90 {print $2}' out.csv | wc -l&#13;
     190</pre>&#13;
&#13;
<p>Or, since Perl was one of my first true loves, here’s a Perl one-liner:</p>&#13;
&#13;
<pre data-type="programlisting">$ perl -F"," -ane '$F[1] &gt;= 90 &amp;&amp; print($F[1], "\n")' out.csv | wc -l&#13;
     190</pre>&#13;
&#13;
<p>It is well worth your time to learn how to use these small, limited tools like <code>join</code>, <code>paste</code>, <code>comm</code>, <code>awk</code>, <code>sed</code>, <code>grep</code>, <code>cut</code>, <code>sort</code>, and even Perl.&#13;
Sufficient proficiency with these tools and Unix pipes can often obviate writing longer Python programs.</p>&#13;
</div></aside>&#13;
&#13;
<p>The <code>blastomatic.py</code> program defaults to writing the output to the comma-separated file <em>out.csv</em>.<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="output formats" data-tertiary="blastomatic program" data-type="indexterm" id="idm45963626520744"/><a data-primary="sequence file comparison" data-secondary="output formats" data-tertiary="blastomatic program" data-type="indexterm" id="idm45963626519496"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastomatic program created" data-tertiary="output formats" data-type="indexterm" id="idm45963626518264"/><a data-primary="sequence file comparison" data-secondary="blastomatic program created" data-tertiary="output formats" data-type="indexterm" id="idm45963626517000"/>&#13;
You can use the <code>-d|--delimiter</code> option to specify a different delimiter and the <code>-o|--outfile</code> option to specify a different file.&#13;
Note that the delimiter will be guessed from the extension of the output filename if it is not specified.&#13;
The extension <em>.csv</em> will be taken to mean commas, and otherwise tabs will be used.</p>&#13;
&#13;
<p>Run <strong><code>make test</code></strong> to see the full test suite.&#13;
When you think you understand how the program should work, start anew:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Annotate BLAST output' blastomatic.py&#13;
Done, see new script "blastomatic.py".</pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining the Arguments" data-type="sect2"><div class="sect2" id="idm45963626511960">&#13;
<h2>Defining the Arguments</h2>&#13;
&#13;
<p>Here is the class I used to define my arguments:<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastomatic program created" data-tertiary="arguments defined" data-type="indexterm" id="idm45963626510632"/><a data-primary="sequence file comparison" data-secondary="blastomatic program created" data-tertiary="arguments defined" data-type="indexterm" id="idm45963626509368"/><a data-primary="arguments" data-secondary="blastomatic program" data-type="indexterm" id="idm45963626508120"/></p>&#13;
&#13;
<pre data-type="programlisting">class Args(NamedTuple):&#13;
    """ Command-line arguments """&#13;
    hits: TextIO <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO3-1" id="co_blastomatic__parsing_delimited_text_files_CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
    annotations: TextIO <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO3-2" id="co_blastomatic__parsing_delimited_text_files_CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
    outfile: TextIO <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO3-3" id="co_blastomatic__parsing_delimited_text_files_CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
    delimiter: str <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO3-4" id="co_blastomatic__parsing_delimited_text_files_CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
    pctid: float <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO3-5" id="co_blastomatic__parsing_delimited_text_files_CO3-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO3-1" id="callout_blastomatic__parsing_delimited_text_files_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The BLAST hits file will be an open filehandle.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO3-2" id="callout_blastomatic__parsing_delimited_text_files_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The metadata file will be an open filehandle.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO3-3" id="callout_blastomatic__parsing_delimited_text_files_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The output file will be an open filehandle.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO3-4" id="callout_blastomatic__parsing_delimited_text_files_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The output file delimiter will be a string.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO3-5" id="callout_blastomatic__parsing_delimited_text_files_CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The percent identity will be a floating-point number.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here is how I parse and validate the arguments:</p>&#13;
&#13;
<pre data-type="programlisting">def get_args():&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Annotate BLAST output',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('-b',&#13;
                        '--blasthits',&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('rt'), <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO4-1" id="co_blastomatic__parsing_delimited_text_files_CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
                        help='BLAST -outfmt 6',&#13;
                        required=True)&#13;
&#13;
    parser.add_argument('-a',&#13;
                        '--annotations',&#13;
                        help='Annotations file',&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('rt'), <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO4-2" id="co_blastomatic__parsing_delimited_text_files_CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
                        required=True)&#13;
&#13;
    parser.add_argument('-o',&#13;
                        '--outfile',&#13;
                        help='Output file',&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('wt'), <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO4-3" id="co_blastomatic__parsing_delimited_text_files_CO4-3"><img alt="3" src="assets/3.png"/></a>&#13;
                        default='out.csv')&#13;
&#13;
    parser.add_argument('-d',&#13;
                        '--delimiter',&#13;
                        help='Output field delimiter', <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO4-4" id="co_blastomatic__parsing_delimited_text_files_CO4-4"><img alt="4" src="assets/4.png"/></a>&#13;
                        metavar='DELIM',&#13;
                        type=str,&#13;
                        default='')&#13;
&#13;
    parser.add_argument('-p',&#13;
                        '--pctid',&#13;
                        help='Minimum percent identity', <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO4-5" id="co_blastomatic__parsing_delimited_text_files_CO4-5"><img alt="5" src="assets/5.png"/></a>&#13;
                        metavar='PCTID',&#13;
                        type=float,&#13;
                        default=0.)&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(hits=args.blasthits, <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO4-6" id="co_blastomatic__parsing_delimited_text_files_CO4-6"><img alt="6" src="assets/6.png"/></a>&#13;
                annotations=args.annotations,&#13;
                outfile=args.outfile,&#13;
                delimiter=args.delimiter or guess_delimiter(args.outfile.name), <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO4-7" id="co_blastomatic__parsing_delimited_text_files_CO4-7"><img alt="7" src="assets/7.png"/></a>&#13;
                pctid=args.pctid)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO4-1" id="callout_blastomatic__parsing_delimited_text_files_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The BLAST file must be a readable text file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO4-2" id="callout_blastomatic__parsing_delimited_text_files_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The metadata file must be a readable text file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO4-3" id="callout_blastomatic__parsing_delimited_text_files_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The output file must be a writable text file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO4-4" id="callout_blastomatic__parsing_delimited_text_files_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The output field delimiter is a string that defaults to the empty string I will guess from the output filename.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO4-5" id="callout_blastomatic__parsing_delimited_text_files_CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The minimum percent identity should be a floating-point number that defaults to <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO4-6" id="callout_blastomatic__parsing_delimited_text_files_CO4-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Create the <code>Args</code> object. Note that the fields of <code>Args</code> do not need to match the parameter names.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO4-7" id="callout_blastomatic__parsing_delimited_text_files_CO4-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>I wrote a function to guess the delimiter from the output filename.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>This program has two required file arguments: the BLAST hits, and the annotations. I don’t want to make these positional arguments because then my user would have to remember the order. It’s better to have these as named options, but then they become optional, which I don’t want either. To overcome this, I use <code>required=True</code> for both the file parameters to ensure the user supplies them.</p>&#13;
</div>&#13;
&#13;
<p>You might like to start with the <code>guess_delimiter()</code> function.&#13;
Here is the test I wrote:</p>&#13;
&#13;
<pre data-type="programlisting">def test_guess_delimiter() -&gt; None:&#13;
    """ Test guess_delimiter """&#13;
&#13;
    assert guess_delimiter('/foo/bar.csv') == ','&#13;
    assert guess_delimiter('/foo/bar.txt') == '\t'&#13;
    assert guess_delimiter('/foo/bar.tsv') == '\t'&#13;
    assert guess_delimiter('/foo/bar.tab') == '\t'&#13;
    assert guess_delimiter('') == '\t'</pre>&#13;
&#13;
<p>Start your <code>main()</code> with some minimal code that will work:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print('hits', args.hits.name)&#13;
    print('meta', args.annotations.name)</pre>&#13;
&#13;
<p>Verify that this works:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./blastomatic.py -a tests/inputs/meta.csv -b tests/inputs/hits1.csv&#13;
hits tests/inputs/hits1.csv&#13;
meta tests/inputs/meta.csv</pre>&#13;
&#13;
<p>At this point, you should be able to pass several tests when you run <strong><code>make test</code></strong>.&#13;
Next, I’ll show you how to parse the delimited text files.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Parsing Delimited Text Files Using the csv Module" data-type="sect2"><div class="sect2" id="idm45963626438152">&#13;
<h2>Parsing Delimited Text Files Using the csv Module</h2>&#13;
&#13;
<p>Python has a <code>csv</code> module that will handle delimited text files easily, but I would first like to show you exactly what it’s doing so you can appreciate how much effort it saves.<a data-primary="CSV (comma-separated values) files" data-secondary="csv module (Python) parsing" data-type="indexterm" id="idm45963626436232"/><a data-primary="delimited text files" data-secondary="csv module (Python) parsing" data-type="indexterm" id="idm45963626435256"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="csv (Python) parsing delimited text" data-type="indexterm" id="idm45963626434296"/><a data-primary="sequence file comparison" data-secondary="csv (Python) parsing delimited text" data-type="indexterm" id="idm45963626433304"/>&#13;
To begin, I will open the metadata file and read the headers from the first line.&#13;
I can call the <code>fh.readline()</code> method on a filehandle to read one line of text.&#13;
This will still have the newline attached, so I call <code>str.rstrip()</code> to remove any whitespace from the right side of the string.&#13;
Finally, I call <code>str.split(',')</code> to break the line on the delimiting comma:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; fh = open('tests/inputs/meta.csv')&#13;
&gt;&gt;&gt; headers = fh.readline().rstrip().split(',')&#13;
&gt;&gt;&gt; headers&#13;
['seq_id', 'sample_acc', 'date', 'depth', 'salinity', 'temp', 'lat_lon']</pre>&#13;
&#13;
<p>So far, so good.&#13;
I’ll try parsing the next line of data:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; line = fh.readline()&#13;
&gt;&gt;&gt; data = line.split(',')&#13;
&gt;&gt;&gt; data&#13;
['JCVI_READ_1092301105055', 'JCVI_SMPL_1103283000037', '2/11/04', '1.6', '',&#13;
 '25.4', '"-0.5938889', '-91.06944"']</pre>&#13;
&#13;
<p>Can you see a problem here?&#13;
I have split the <code>lat_lon</code> field, which contains a comma, into two values, giving me eight values for seven fields:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; len(headers), len(data)&#13;
(7, 8)</pre>&#13;
&#13;
<p>Using <code>str.split()</code> will not work because it fails to consider when the separator is part of the field value.&#13;
That is, when the field separator is enclosed in quotes, it’s not a field separator.&#13;
Notice that the <code>lat_lon</code> value is properly quoted:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; line[50:]&#13;
'11/04,1.6,,25.4,<strong>"-0.5938889,-91.06944"</strong>\n\'</pre>&#13;
&#13;
<p>One way to correctly parse this line uses the <code>pyparsing</code> module:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import pyparsing as pp&#13;
&gt;&gt;&gt; data = pp.commaSeparatedList.parseString(line).asList()&#13;
&gt;&gt;&gt; data&#13;
['JCVI_READ_1092301105055', 'JCVI_SMPL_1103283000037', '2/11/04', '1.6',&#13;
 '', '25.4', '"-0.5938889,-91.06944"']</pre>&#13;
&#13;
<p>That’s close, but the <code>lat_lon</code> field still has the quotes around it.&#13;
I can use a regular expression to remove them:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import re&#13;
&gt;&gt;&gt; data = list(map(lambda s: re.sub(r'^"|"$', '', s), data)) <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO5-1" id="co_blastomatic__parsing_delimited_text_files_CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
&gt;&gt;&gt; data&#13;
['JCVI_READ_1092301105055', 'JCVI_SMPL_1103283000037', '2/11/04', '1.6', '',&#13;
 '25.4', '-0.5938889,-91.06944']</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO5-1" id="callout_blastomatic__parsing_delimited_text_files_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This regular expression replaces a quote anchored to either the beginning or the end of a string with the empty string.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now that I have a list of the <code>headers</code> and a list of the <code>data</code> for a given record, I could create a dictionary by zipping these together.&#13;
I’ve used the <code>zip()</code> function in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.html#ch06">6</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch13.html#ch13">13</a> to join two lists into a list of tuples.&#13;
Because <code>zip()</code> is a lazy function, I must use the <code>list()</code> function in the REPL to force the evaluation:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from pprint import pprint&#13;
&gt;&gt;&gt; pprint(list(zip(headers, data)))&#13;
[('seq_id', 'JCVI_READ_1092301105055'),&#13;
 ('sample_acc', 'JCVI_SMPL_1103283000037'),&#13;
 ('date', '2/11/04'),&#13;
 ('depth', '1.6'),&#13;
 ('salinity', ''),&#13;
 ('temp', '25.4'),&#13;
 ('lat_lon', '-0.5938889,-91.06944')]</pre>&#13;
&#13;
<p>I can change the <code>list()</code> function to <code>dict()</code> to turn this into a dictionary:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; pprint(dict(zip(headers, data)))&#13;
{'date': '2/11/04',&#13;
 'depth': '1.6',&#13;
 'lat_lon': '-0.5938889,-91.06944',&#13;
 'salinity': '',&#13;
 'sample_acc': 'JCVI_SMPL_1103283000037',&#13;
 'seq_id': 'JCVI_READ_1092301105055',&#13;
 'temp': '25.4'}</pre>&#13;
&#13;
<p>I could iterate through each line of the file and create a dictionary of the records by zipping the headers and data.&#13;
That would work just fine, but all this work has already been done for me in the <code>csv</code> module.&#13;
Following is how I can parse the same file into a list of dictionaries using <code>csv.DictReader()</code>.&#13;
By default, it will use the comma as the delimiter:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import csv&#13;
&gt;&gt;&gt; reader = csv.DictReader(open('tests/inputs/meta.csv'))&#13;
&gt;&gt;&gt; for rec in reader:&#13;
...     pprint(rec)&#13;
...     break&#13;
...&#13;
{'date': '2/11/04',&#13;
 'depth': '1.6',&#13;
 'lat_lon': '-0.5938889,-91.06944',&#13;
 'salinity': '',&#13;
 'sample_acc': 'JCVI_SMPL_1103283000037',&#13;
 'seq_id': 'JCVI_READ_1092301105055',&#13;
 'temp': '25.4'}</pre>&#13;
&#13;
<p>That’s much easier.&#13;
Here’s how I might use this to create a dictionary of all the annotations keyed on the sequence ID.&#13;
Be sure to add <code>from pprint import pprint</code> for this:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    annots_reader = csv.DictReader(args.annotations, delimiter=',') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO6-1" id="co_blastomatic__parsing_delimited_text_files_CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
    annots = {row['seq_id']: row for row in annots_reader} <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO6-2" id="co_blastomatic__parsing_delimited_text_files_CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
    pprint(annots)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO6-1" id="callout_blastomatic__parsing_delimited_text_files_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use <code>csv.DictReader()</code> to parse the CSV data in the annotations filehandle.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO6-2" id="callout_blastomatic__parsing_delimited_text_files_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use a dictionary comprehension to create a dictionary keyed on the <code>seq_id</code> field from each record.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Run this with the input files and see if you get a reasonable-looking data structure.&#13;
Here I’ll redirect <code>STDOUT</code> to a file called <em>out</em> and use <code>head</code> to inspect it:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./blastomatic.py -a tests/inputs/meta.csv -b tests/inputs/hits1.csv &gt; out&#13;
$ head out&#13;
{'CAM_READ_0231669837': {'date': '8/4/05',&#13;
                         'depth': '7',&#13;
                         'lat_lon': '-12.092617,96.881733',&#13;
                         'salinity': '32.4',&#13;
                         'sample_acc': 'CAM_SMPL_GS108',&#13;
                         'seq_id': 'CAM_READ_0231669837',&#13;
                         'temp': '25.8'},&#13;
 'CAM_READ_0231670003': {'date': '8/4/05',&#13;
                         'depth': '7',&#13;
                         'lat_lon': '-12.092617,96.881733',</pre>&#13;
&#13;
<p>Before I move on to reading the BLAST hits, I’d like to open the output filehandle.&#13;
The format of the output file should be another delimited text file.&#13;
By default it will be a CSV file, but the user may choose something else, like a tab separator.&#13;
The first line of the file should be the headers, so I’ll immediately write those:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    annots_reader = csv.DictReader(args.annotations, delimiter=',')&#13;
    annots = {row['seq_id']: row for row in annots_reader}&#13;
&#13;
    headers = ['qseqid', 'pident', 'depth', 'lat_lon'] <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO7-1" id="co_blastomatic__parsing_delimited_text_files_CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
    args.outfile.write(args.delimiter.join(headers) + '\n') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO7-2" id="co_blastomatic__parsing_delimited_text_files_CO7-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO7-1" id="callout_blastomatic__parsing_delimited_text_files_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>These are the output file’s column names.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO7-2" id="callout_blastomatic__parsing_delimited_text_files_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><code>args.outfile</code> is a filehandle opened for writing text. Write the headers joined on the <code>args.delimiter</code> string. Be sure to add a newline.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Alternatively, you could use <code>print()</code> with a <code>file</code> argument:</p>&#13;
&#13;
<pre data-type="programlisting">print(args.delimiter.join(headers), file=args.outfile)</pre>&#13;
&#13;
<p>Next, I’ll cycle through the BLAST hits.&#13;
It’s necessary to supply the <code>fieldnames</code> to <code>csv.DictReader()</code> since the first line of the file is missing the column names:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    annots_reader = csv.DictReader(args.annotations, delimiter=',')&#13;
    annots = {row['seq_id']: row for row in annots_reader}&#13;
&#13;
    headers = ['qseqid', 'pident', 'depth', 'lat_lon']&#13;
    args.outfile.write(args.delimiter.join(headers) + '\n')&#13;
&#13;
    hits = csv.DictReader(args.hits, <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO8-1" id="co_blastomatic__parsing_delimited_text_files_CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
                          delimiter=',',&#13;
                          fieldnames=[&#13;
                              'qseqid', 'sseqid', 'pident', 'length',&#13;
                              'mismatch', 'gapopen', 'qstart', 'qend',&#13;
                              'sstart', 'send', 'evalue', 'bitscore'&#13;
                          ])&#13;
&#13;
    for hit in hits: <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO8-2" id="co_blastomatic__parsing_delimited_text_files_CO8-2"><img alt="2" src="assets/2.png"/></a>&#13;
        if float(hit.get('pident', -1)) &lt; args.pctid: <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO8-3" id="co_blastomatic__parsing_delimited_text_files_CO8-3"><img alt="3" src="assets/3.png"/></a>&#13;
            continue&#13;
        print(hit.get('qseqid')) <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO8-4" id="co_blastomatic__parsing_delimited_text_files_CO8-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO8-1" id="callout_blastomatic__parsing_delimited_text_files_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Parse the BLAST CSV file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO8-2" id="callout_blastomatic__parsing_delimited_text_files_CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through each BLAST hit.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO8-3" id="callout_blastomatic__parsing_delimited_text_files_CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Skip those hits where the percent ID is less than the minimum. Use the <code>float()</code> function to convert the text to a floating-point value.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO8-4" id="callout_blastomatic__parsing_delimited_text_files_CO8-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Print the query sequence ID.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Run this version of the program with a minimum percent ID of 90, and verify that you get 190 hits from the first file:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./blastomatic.py -a tests/inputs/meta.csv -b tests/inputs/hits1.csv -p 90 \&#13;
    | wc -l&#13;
     190</pre>&#13;
&#13;
<p>If the BLAST hit’s <code>qseqid</code> value is found as a <code>seq_id</code> in the metadata file, then print to the output file the sequence ID, the percent ID from the BLAST hit, and the depth and latitude/longitude values from the metadata file.&#13;
That should be enough to get you rolling on this program.&#13;
Be sure to run the tests to verify that your program is correct.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Parsing Delimited Text Files Using the pandas Module" data-type="sect2"><div class="sect2" id="idm45963626348248">&#13;
<h2>Parsing Delimited Text Files Using the pandas Module</h2>&#13;
&#13;
<p>The pandas module presents another effective way to read a delimited file.<a data-primary="CSV (comma-separated values) files" data-secondary="pandas module parsing" data-type="indexterm" id="ch19-pan"/><a data-primary="delimited text files" data-secondary="pandas module parsing" data-type="indexterm" id="ch19-pan2"/><a data-primary="sequence file comparison" data-secondary="pandas module parsing delimited text" data-type="indexterm" id="ch19-pan3"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="pandas module parsing delimited text" data-type="indexterm" id="ch19-pan4"/><a data-primary="pandas module parsing delimited text" data-type="indexterm" id="ch19-pan5"/>&#13;
This module, along with NumPy, is one of the foundational Python libraries used in data science.&#13;
I’ll use the <code>pd.read_csv()</code> function, which closely resembles the <code>read_csv()</code> function from the R programming language, if you are familiar with that.&#13;
Note that the function can read text delimited by any delimiter you specify using a <code>sep</code> field separator, but the default is a comma.</p>&#13;
<div data-type="note" epub:type="note">&#13;
<p>Normally the delimiter is a single character, but it’s possible to split text using a string. <a data-primary="errors" data-secondary="ParserWarning from pandas read_csv" data-type="indexterm" id="idm45963626338056"/>If you do this, you may encounter the warning “ParserWarning: Falling back to the <em>python</em> engine because the <em>c</em> engine does not support regex separators (separators &gt; 1 char and different from <em>\s+</em> are interpreted as regex); you can avoid this warning by specifying engine=<em>python</em>.”</p>&#13;
</div>&#13;
&#13;
<p>It’s common to import pandas with the alias <code>pd</code>:<a data-primary="alias in Python" data-secondary="pandas imported as pd" data-type="indexterm" id="idm45963626333864"/><a data-primary="Python" data-secondary="aliasing" data-type="indexterm" id="idm45963626332920"/><a data-primary="pandas module parsing delimited text" data-secondary="importing" data-type="indexterm" id="idm45963626331976"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import pandas as pd&#13;
&gt;&gt;&gt; meta = pd.read_csv('tests/inputs/meta.csv')</pre>&#13;
&#13;
<p>Much of pandas is based on ideas from R.&#13;
A pandas dataframe is a two-dimensional object that holds all the columns and rows of the metadata file in a single object, just like a dataframe in R.<a data-primary="memory issues" data-secondary="pandas dataframe" data-type="indexterm" id="idm45963626329624"/><a data-primary="pandas module parsing delimited text" data-secondary="dataframe holding entire file" data-type="indexterm" id="idm45963626328680"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="pandas module parsing delimited text" data-tertiary="dataframe holding entire file" data-type="indexterm" id="idm45963626327704"/><a data-primary="sequence file comparison" data-secondary="pandas module parsing delimited text" data-tertiary="dataframe holding entire file" data-type="indexterm" id="idm45963626326424"/><a data-primary="errors" data-secondary="memory issues" data-see="memory issues" data-type="indexterm" id="idm45963626325160"/>&#13;
That is, the <code>reader</code> in the previous example is an interface used to sequentially retrieve each of the records, but the pandas dataframe is a full representation of all the data from the file.&#13;
As such, the size of a dataframe will be limited to the amount of memory on your computer.&#13;
Just as I’ve warned about using <code>fh.read()</code> to read an entire file into memory, you must be judicious about which files can be practically read using pandas.&#13;
If you must process millions of rows of delimited text in gigabyte-sized files, I would recommend using <code>cvs.DictReader()</code> to process one record at a time.</p>&#13;
&#13;
<p>If you evaluate the <code>meta</code> object in the REPL, a sample of the table will be shown.&#13;
You can see that pandas used the first row of the file for the column headers.&#13;
As indicated by ellipses, some of the columns have been elided due to the constrained width of the screen:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; meta&#13;
                     seq_id  ...                lat_lon&#13;
0   JCVI_READ_1092301105055  ...   -0.5938889,-91.06944&#13;
1   JCVI_READ_1092351051817  ...   -0.5938889,-91.06944&#13;
2   JCVI_READ_1092301096881  ...   -0.5938889,-91.06944&#13;
3   JCVI_READ_1093017101914  ...   -0.5938889,-91.06944&#13;
4   JCVI_READ_1092342065252  ...     9.164444,-79.83611&#13;
..                      ...  ...                    ...&#13;
95  JCVI_READ_1091145742670  ...   44.690277,-63.637222&#13;
96  JCVI_READ_1091145742680  ...   44.690277,-63.637222&#13;
97  JCVI_READ_1091150268218  ...   44.690277,-63.637222&#13;
98  JCVI_READ_1095964929867  ...  -1.9738889,-95.014725&#13;
99  JCVI_READ_1095994150021  ...  -1.9738889,-95.014725&#13;
&#13;
[100 rows x 7 columns]</pre>&#13;
&#13;
<p>To find the number of rows and columns in a dataframe, inspect the <code>meta.shape</code> attribute.&#13;
Note that this is not followed by parentheses because it is not a method call.&#13;
This dataframe has 100 rows and 7 columns:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; meta.shape&#13;
(100, 7)</pre>&#13;
&#13;
<p>I can inspect the <code>meta.columns</code> attribute for the column names:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; meta.columns&#13;
Index(['seq_id', 'sample_acc', 'date', 'depth', 'salinity', 'temp', 'lat_lon'],&#13;
dtype='object')</pre>&#13;
&#13;
<p>One advantage to dataframes is that you can query all the values from a column using a syntax that looks like accessing a field in a dictionary.&#13;
Here I’ll select the salinity values, and note that pandas has converted the values from text to floating-point values, with missing values represented, with <code>NaN</code> (not a number):</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; meta['salinity']&#13;
0      NaN&#13;
1      NaN&#13;
2      NaN&#13;
3      NaN&#13;
4      0.1&#13;
      ...&#13;
95    30.2&#13;
96    30.2&#13;
97    30.2&#13;
98     NaN&#13;
99     NaN&#13;
Name: salinity, Length: 100, dtype: float64</pre>&#13;
&#13;
<p>I can find the rows with a salinity greater than 50 using syntax almost identical to that in R.&#13;
This returns an array of Boolean values based on the predicate <em>salinity is greater than 50</em>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; meta['salinity'] &gt; 50&#13;
0     False&#13;
1     False&#13;
2     False&#13;
3     False&#13;
4     False&#13;
      ...&#13;
95    False&#13;
96    False&#13;
97    False&#13;
98    False&#13;
99    False&#13;
Name: salinity, Length: 100, dtype: bool</pre>&#13;
&#13;
<p>I can use these Booleans values as a mask to only select the rows where this condition is <code>True</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; meta[meta['salinity'] &gt; 50]&#13;
                     seq_id  ...               lat_lon&#13;
23  JCVI_READ_1092351234516  ...  -1.2283334,-90.42917&#13;
24  JCVI_READ_1092402566200  ...  -1.2283334,-90.42917&#13;
25  JCVI_READ_1092402515846  ...  -1.2283334,-90.42917&#13;
&#13;
[3 rows x 7 columns]</pre>&#13;
&#13;
<p>The result is a new dataframe, so I could then look at the salinity values that were found:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; meta[meta['salinity'] &gt; 50]['salinity']&#13;
23    63.4&#13;
24    63.4&#13;
25    63.4&#13;
Name: salinity, dtype: float64</pre>&#13;
&#13;
<p>If you read the BLAST hits file with pandas, you will need to supply the column names as you did in the previous example:<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="output formats" data-tertiary="column names" data-type="indexterm" id="idm45963626308008"/><a data-primary="sequence file comparison" data-secondary="output formats" data-tertiary="column names" data-type="indexterm" id="idm45963626306760"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; cols = ['qseqid', 'sseqid', 'pident', 'length', 'mismatch', 'gapopen',&#13;
'qstart', 'qend', 'sstart', 'send', 'evalue', 'bitscore']&#13;
&gt;&gt;&gt; hits = pd.read_csv('tests/inputs/hits1.csv', names=cols)&#13;
&gt;&gt;&gt; hits&#13;
                      qseqid      sseqid  ...         evalue  bitscore&#13;
0        CAM_READ_0234442157  CP031125.1  ...  6.810000e-135     492.0&#13;
1        CAM_READ_0234442157  LT840186.1  ...   7.260000e-90     342.0&#13;
2        CAM_READ_0234442157  CP048747.1  ...   6.240000e-16      97.1&#13;
3        CAM_READ_0234442157  CP046232.1  ...   2.240000e-15      95.3&#13;
4    JCVI_READ_1095946186912  CP038852.1  ...   0.000000e+00    1158.0&#13;
..                       ...         ...  ...            ...       ...&#13;
495  JCVI_READ_1095403503430  EU805356.1  ...   0.000000e+00    1834.0&#13;
496  JCVI_READ_1095403503430  EU804987.1  ...   0.000000e+00    1834.0&#13;
497  JCVI_READ_1095403503430  EU804799.1  ...   0.000000e+00    1834.0&#13;
498  JCVI_READ_1095403503430  EU804695.1  ...   0.000000e+00    1834.0&#13;
499  JCVI_READ_1095403503430  EU804645.1  ...   0.000000e+00    1834.0&#13;
&#13;
[500 rows x 12 columns]</pre>&#13;
&#13;
<p>One element of this program is to select only those hits with a percent ID greater than or equal to some minimum.&#13;
pandas will automatically convert the <code>pident</code> column to a floating-point value.&#13;
Here I will select those hits with a percent ID greater than or equal to <code>90</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; wanted = hits[hits['pident'] &gt;= 90]&#13;
&gt;&gt;&gt; wanted&#13;
                      qseqid      sseqid  ...         evalue  bitscore&#13;
0        CAM_READ_0234442157  CP031125.1  ...  6.810000e-135     492.0&#13;
12   JCVI_READ_1091145027519  CP058306.1  ...   6.240000e-06      65.8&#13;
13   JCVI_READ_1091145742680  CP000084.1  ...   0.000000e+00    1925.0&#13;
14   JCVI_READ_1091145742680  CP038852.1  ...   0.000000e+00    1487.0&#13;
111  JCVI_READ_1091145742680  CP022043.2  ...   1.320000e-07      71.3&#13;
..                       ...         ...  ...            ...       ...&#13;
495  JCVI_READ_1095403503430  EU805356.1  ...   0.000000e+00    1834.0&#13;
496  JCVI_READ_1095403503430  EU804987.1  ...   0.000000e+00    1834.0&#13;
497  JCVI_READ_1095403503430  EU804799.1  ...   0.000000e+00    1834.0&#13;
498  JCVI_READ_1095403503430  EU804695.1  ...   0.000000e+00    1834.0&#13;
499  JCVI_READ_1095403503430  EU804645.1  ...   0.000000e+00    1834.0&#13;
&#13;
[190 rows x 12 columns]</pre>&#13;
&#13;
<p>To iterate over the rows in a dataframe, use the <code>wanted.iterrows()</code> method.&#13;
Note that this works like the <code>enumerate()</code> function in that it returns a tuple of the row index and the row value:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for i, hit in wanted.iterrows():&#13;
...     print(hit)&#13;
...     break&#13;
...&#13;
qseqid      CAM_READ_0234442157&#13;
sseqid               CP031125.1&#13;
pident                   92.941&#13;
length                      340&#13;
mismatch                     21&#13;
gapopen                       3&#13;
qstart                        3&#13;
qend                        340&#13;
sstart                   801595&#13;
send                     801257&#13;
evalue                    0.000&#13;
bitscore                492.000&#13;
Name: 0, dtype: object</pre>&#13;
&#13;
<p>To print a single field from a record in the dataframe, you can treat the record like a dictionary using field access through square brackets or by using the familiar <code>dict.get()</code> method.&#13;
As with dictionaries, the first method will create an exception if you misspell a field name, while the latter method will quietly return <code>None</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for i, hit in wanted.iterrows():&#13;
...     print(hit['qseqid'], hit.get('pident'), hit.get('nope'))&#13;
...     break&#13;
...&#13;
CAM_READ_0234442157 92.941 None</pre>&#13;
&#13;
<p>As in the previous example, I recommend you first read the metadata and then iterate through the BLAST hits.&#13;
You can look up the metadata from the <code>meta</code> dataframe by searching over the <code>seq_id</code> field.&#13;
The sequence IDs in the metadata file are unique, so you should only find at most one:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs = meta[meta['seq_id'] == 'CAM_READ_0234442157']&#13;
&gt;&gt;&gt; seqs&#13;
                 seq_id      sample_acc  ...  temp             lat_lon&#13;
91  CAM_READ_0234442157  CAM_SMPL_GS112  ...  26.6  -8.50525,80.375583&#13;
&#13;
[1 rows x 7 columns]</pre>&#13;
&#13;
<p>You can either iterate over the matches or use the <code>iloc</code> accessor to get the first &#13;
<span class="keep-together">(zeroth)</span> record:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs.iloc[0]&#13;
seq_id        CAM_READ_0234442157&#13;
sample_acc         CAM_SMPL_GS112&#13;
date                       8/8/05&#13;
depth                      4573.0&#13;
salinity                     32.5&#13;
temp                         26.6&#13;
lat_lon        -8.50525,80.375583&#13;
Name: 91, dtype: object</pre>&#13;
&#13;
<p>If you fail to find any matches, you will get an empty dataframe:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs = meta[meta['seq_id'] == 'X']&#13;
&gt;&gt;&gt; seqs&#13;
Empty DataFrame&#13;
Columns: [seq_id, sample_acc, date, depth, salinity, temp, lat_lon]&#13;
Index: []</pre>&#13;
&#13;
<p>You can inspect the <code>seqs.empty</code> attribute to see if it’s empty:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs.empty&#13;
True</pre>&#13;
&#13;
<p>or inspect the rows value from <code>seqs.shape</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seqs.shape[0]&#13;
0</pre>&#13;
&#13;
<p>Dataframes can also write their values to a file using the <code>to_csv()</code> method.&#13;
As with <code>read_csv()</code>, you can specify any <code>sep</code> field separator, and the default is the comma.&#13;
Note that by default pandas will include the row index as the first field of the output file.&#13;
I generally use <code>index=False</code> to omit this.&#13;
For example, I’ll save the metadata records with a salinity greater than 50 to the <em>salty.csv</em> file with one line of code:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; meta[meta['salinity'] &gt; 50].to_csv('salty.csv', index=False)</pre>&#13;
&#13;
<p>I can verify that the data was written using <code>csvchk</code> or <code>csvlook</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ csvchk salty.csv&#13;
// ****** Record 1 ****** //&#13;
seq_id     : JCVI_READ_1092351234516&#13;
sample_acc : JCVI_SMPL_1103283000038&#13;
date       : 2/19/04&#13;
depth      : 0.2&#13;
salinity   : 63.4&#13;
temp       : 37.6&#13;
lat_lon    : -1.2283334,-90.42917</pre>&#13;
&#13;
<p>A thorough review of pandas is well beyond the scope of this book, but this should be enough for you to figure out a solution.&#13;
If you would like to learn more, I recommend <a class="orm:hideurl" href="https://oreil.ly/kAtUU"><em>Python for Data Analysis</em></a> by Wes McKinney (O’Reilly, 2017) and <a class="orm:hideurl" href="https://oreil.ly/1V94U"><em>Python Data Science Handbook</em></a> by Jake VanderPlas (O’Reilly, 2016).<a data-primary="Python for Data Analysis (McKinney)" data-type="indexterm" id="idm45963626276712"/><a data-primary="McKinney, Wes" data-type="indexterm" id="idm45963626276024"/><a data-primary="Python Data Science Handbook (VanderPlas)" data-type="indexterm" id="idm45963626275352"/><a data-primary="VanderPlas, Jake" data-type="indexterm" id="idm45963626274648"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="books on data analysis" data-type="indexterm" id="idm45963626273976"/><a data-primary="sequence file comparison" data-secondary="books on data analysis" data-type="indexterm" id="idm45963626273000"/><a data-primary="resources" data-secondary="Python" data-tertiary="data analysis books" data-type="indexterm" id="idm45963626272040"/><a data-primary="Python" data-secondary="data analysis books" data-type="indexterm" id="idm45963626270824"/><a data-primary="data analysis books" data-type="indexterm" id="idm45963626269880"/><a data-startref="ch19-pan" data-type="indexterm" id="idm45963626269208"/><a data-startref="ch19-pan2" data-type="indexterm" id="idm45963626268536"/><a data-startref="ch19-pan3" data-type="indexterm" id="idm45963626267864"/><a data-startref="ch19-pan4" data-type="indexterm" id="idm45963626267192"/><a data-startref="ch19-pan5" data-type="indexterm" id="idm45963626266520"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963626265368">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>I have four solutions, two using the <code>csv</code> module and two using pandas.&#13;
All of the solutions use the same <code>guess_delimiter()</code> function, which I wrote like this:<a data-primary="file extensions" data-secondary="text file delimiter determination" data-type="indexterm" id="idm45963626263096"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastomatic program created" data-tertiary="text file delimiter determination" data-type="indexterm" id="idm45963626262136"/><a data-primary="sequence file comparison" data-secondary="blastomatic program created" data-tertiary="text file delimiter determination" data-type="indexterm" id="idm45963626260856"/></p>&#13;
&#13;
<pre data-type="programlisting">def guess_delimiter(filename: str) -&gt; str:&#13;
    """ Guess the field separator from the file extension """&#13;
&#13;
    ext = os.path.splitext(filename)[1] <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO9-1" id="co_blastomatic__parsing_delimited_text_files_CO9-1"><img alt="1" src="assets/1.png"/></a>&#13;
    return ',' if ext == '.csv' else '\t' <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO9-2" id="co_blastomatic__parsing_delimited_text_files_CO9-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO9-1" id="callout_blastomatic__parsing_delimited_text_files_CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Select the file extension from <code>os.path.splitext()</code>.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO9-2" id="callout_blastomatic__parsing_delimited_text_files_CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Return a comma if the file extension is <em>.csv</em> and the tab character otherwise.</p></dd>&#13;
</dl>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Manually Joining the Tables Using Dictionaries" data-type="sect2"><div class="sect2" id="idm45963626248040">&#13;
<h2>Solution 1: Manually Joining the Tables Using Dictionaries</h2>&#13;
&#13;
<p>This version closely follows all the suggestions from earlier in the chapter:<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastomatic program created" data-tertiary="solution 1 dictionaries joining tables" data-type="indexterm" id="idm45963626246632"/><a data-primary="sequence file comparison" data-secondary="blastomatic program created" data-tertiary="solution 1 dictionaries joining tables" data-type="indexterm" id="idm45963626245352"/></p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    annots_reader = csv.DictReader(args.annotations, delimiter=',') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-1" id="co_blastomatic__parsing_delimited_text_files_CO10-1"><img alt="1" src="assets/1.png"/></a>&#13;
    annots = {row['seq_id']: row for row in annots_reader} <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-2" id="co_blastomatic__parsing_delimited_text_files_CO10-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    headers = ['qseqid', 'pident', 'depth', 'lat_lon'] <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-3" id="co_blastomatic__parsing_delimited_text_files_CO10-3"><img alt="3" src="assets/3.png"/></a>&#13;
    args.outfile.write(args.delimiter.join(headers) + '\n') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-4" id="co_blastomatic__parsing_delimited_text_files_CO10-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    hits = csv.DictReader(args.hits, <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-5" id="co_blastomatic__parsing_delimited_text_files_CO10-5"><img alt="5" src="assets/5.png"/></a>&#13;
                          delimiter=',',&#13;
                          fieldnames=[&#13;
                              'qseqid', 'sseqid', 'pident', 'length',&#13;
                              'mismatch', 'gapopen', 'qstart', 'qend',&#13;
                              'sstart', 'send', 'evalue', 'bitscore'&#13;
                          ])&#13;
&#13;
    num_written = 0 <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-6" id="co_blastomatic__parsing_delimited_text_files_CO10-6"><img alt="6" src="assets/6.png"/></a>&#13;
    for hit in hits: <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-7" id="co_blastomatic__parsing_delimited_text_files_CO10-7"><img alt="7" src="assets/7.png"/></a>&#13;
        if float(hit.get('pident', -1)) &lt; args.pctid: <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-8" id="co_blastomatic__parsing_delimited_text_files_CO10-8"><img alt="8" src="assets/8.png"/></a>&#13;
            continue&#13;
&#13;
        if seq_id := hit.get('qseqid'): <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-9" id="co_blastomatic__parsing_delimited_text_files_CO10-9"><img alt="9" src="assets/9.png"/></a>&#13;
            if seq := annots.get(seq_id): <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-10" id="co_blastomatic__parsing_delimited_text_files_CO10-10"><img alt="10" src="assets/10.png"/></a>&#13;
                num_written += 1 <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-11" id="co_blastomatic__parsing_delimited_text_files_CO10-11"><img alt="11" src="assets/11.png"/></a>&#13;
                args.outfile.write(&#13;
                    args.delimiter.join( <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-12" id="co_blastomatic__parsing_delimited_text_files_CO10-12"><img alt="12" src="assets/12.png"/></a>&#13;
                        map(lambda s: f'"{s}"', [&#13;
                            seq_id,&#13;
                            hit.get('pident'),&#13;
                            seq.get('depth'),&#13;
                            seq.get('lat_lon')&#13;
                        ])) + '\n')&#13;
&#13;
    args.outfile.close() <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-13" id="co_blastomatic__parsing_delimited_text_files_CO10-13"><img alt="13" src="assets/13.png"/></a>&#13;
    print(f'Exported {num_written:,} to "{args.outfile.name}".') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO10-14" id="co_blastomatic__parsing_delimited_text_files_CO10-14"><img alt="14" src="assets/14.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-1" id="callout_blastomatic__parsing_delimited_text_files_CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create a parser for the annotations file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-2" id="callout_blastomatic__parsing_delimited_text_files_CO10-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Read all the annotations into a dictionary keyed on the sequence ID.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-3" id="callout_blastomatic__parsing_delimited_text_files_CO10-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Define the headers of the output file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-4" id="callout_blastomatic__parsing_delimited_text_files_CO10-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Write the headers to the output file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-5" id="callout_blastomatic__parsing_delimited_text_files_CO10-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Create a parser for the BLAST hits.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-6" id="callout_blastomatic__parsing_delimited_text_files_CO10-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Initialize a counter for the number of records written.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-7" id="callout_blastomatic__parsing_delimited_text_files_CO10-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Iterate through the BLAST hits.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-8" id="callout_blastomatic__parsing_delimited_text_files_CO10-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Skip records with a percent ID less than the minimum.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-9" id="callout_blastomatic__parsing_delimited_text_files_CO10-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Attempt to get the BLAST query sequence ID.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-10" id="callout_blastomatic__parsing_delimited_text_files_CO10-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>Attempt to find this sequence ID in the annotations.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-11" id="callout_blastomatic__parsing_delimited_text_files_CO10-11"><img alt="11" src="assets/11.png"/></a></dt>&#13;
<dd><p>If found, increment the counter and write the output values.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-12" id="callout_blastomatic__parsing_delimited_text_files_CO10-12"><img alt="12" src="assets/12.png"/></a></dt>&#13;
<dd><p>Quote all the fields to ensure the delimiter is protected.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-13" id="callout_blastomatic__parsing_delimited_text_files_CO10-13"><img alt="13" src="assets/13.png"/></a></dt>&#13;
<dd><p>Close the output file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO10-14" id="callout_blastomatic__parsing_delimited_text_files_CO10-14"><img alt="14" src="assets/14.png"/></a></dt>&#13;
<dd><p>Print a final status to the user. The comma in the formatting for <code>num_written</code> will add a thousands separator to the number.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Writing the Output File with csv.DictWriter()" data-type="sect2"><div class="sect2" id="idm45963626177352">&#13;
<h2>Solution 2: Writing the Output File with csv.DictWriter()</h2>&#13;
&#13;
<p>This next solution differs from the first only in that I use <code>csv.DictWriter()</code> to write the output file.<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastomatic program created" data-tertiary="solution 2 csv.DictWriter" data-type="indexterm" id="idm45963626175496"/><a data-primary="sequence file comparison" data-secondary="blastomatic program created" data-tertiary="solution 2 csv.DictWriter" data-type="indexterm" id="idm45963626174216"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="csv (Python) parsing delimited text" data-tertiary="csv.DictWriter" data-type="indexterm" id="idm45963626172952"/><a data-primary="sequence file comparison" data-secondary="csv (Python) parsing delimited text" data-tertiary="csv.DictWriter" data-type="indexterm" id="idm45963626171688"/><a data-primary="CSV (comma-separated values) files" data-secondary="csv module (Python) parsing" data-tertiary="csv.DictWriter" data-type="indexterm" id="idm45963626170440"/><a data-primary="delimited text files" data-secondary="csv module (Python) parsing" data-tertiary="csv.DictWriter" data-type="indexterm" id="idm45963626169192"/><a data-primary="output from program" data-secondary="csv.DictWriter" data-type="indexterm" id="idm45963626167960"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="output formats" data-tertiary="csv.DictWriter" data-type="indexterm" id="idm45963626167016"/><a data-primary="sequence file comparison" data-secondary="output formats" data-tertiary="csv.DictWriter" data-type="indexterm" id="idm45963626165768"/>&#13;
I generally prefer to use this method as it will handle, for instance, properly quoting fields that contain the field separator:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    annots_reader = csv.DictReader(args.annotations, delimiter=',')&#13;
    annots = {row['seq_id']: row for row in annots_reader}&#13;
&#13;
    writer = csv.DictWriter( <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO11-1" id="co_blastomatic__parsing_delimited_text_files_CO11-1"><img alt="1" src="assets/1.png"/></a>&#13;
        args.outfile,&#13;
        fieldnames=['qseqid', 'pident', 'depth', 'lat_lon'],&#13;
        delimiter=args.delimiter)&#13;
    writer.writeheader() <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO11-2" id="co_blastomatic__parsing_delimited_text_files_CO11-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    hits = csv.DictReader(args.hits,&#13;
                          delimiter=',',&#13;
                          fieldnames=[&#13;
                              'qseqid', 'sseqid', 'pident', 'length',&#13;
                              'mismatch', 'gapopen', 'qstart', 'qend',&#13;
                              'sstart', 'send', 'evalue', 'bitscore'&#13;
                          ])&#13;
&#13;
    num_written = 0&#13;
    for hit in hits:&#13;
        if float(hit.get('pident', -1)) &lt; args.pctid:&#13;
            continue&#13;
&#13;
        if seq_id := hit.get('qseqid'):&#13;
            if seq := annots.get(seq_id):&#13;
                num_written += 1&#13;
                writer.writerow({ <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO11-3" id="co_blastomatic__parsing_delimited_text_files_CO11-3"><img alt="3" src="assets/3.png"/></a>&#13;
                    'qseqid': seq_id,&#13;
                    'pident': hit.get('pident'),&#13;
                    'depth': seq.get('depth'),&#13;
                    'lat_lon': seq.get('lat_lon'),&#13;
                })&#13;
&#13;
    print(f'Exported {num_written:,} to "{args.outfile.name}".') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO11-4" id="co_blastomatic__parsing_delimited_text_files_CO11-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO11-1" id="callout_blastomatic__parsing_delimited_text_files_CO11-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create a writer object to create the delimited text output file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO11-2" id="callout_blastomatic__parsing_delimited_text_files_CO11-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Write the header row to the output file.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO11-3" id="callout_blastomatic__parsing_delimited_text_files_CO11-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Write a row of data, passing in a dictionary with the same keys as the <code>fieldnames</code> defined for the writer.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO11-4" id="callout_blastomatic__parsing_delimited_text_files_CO11-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>The formatting instruction <code>{:,}</code> will cause the number to be printed with thousands separators.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: Reading and Writing Files Using pandas" data-type="sect2"><div class="sect2" id="idm45963626142344">&#13;
<h2>Solution 3: Reading and Writing Files Using pandas</h2>&#13;
&#13;
<p>The pandas version is a little simpler in some ways and a little more complicated in others.<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastomatic program created" data-tertiary="solution 3 pandas to read and write" data-type="indexterm" id="idm45963626140936"/><a data-primary="sequence file comparison" data-secondary="blastomatic program created" data-tertiary="solution 3 pandas to read and write" data-type="indexterm" id="idm45963626139656"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="pandas module parsing delimited text" data-tertiary="blastomatic input and output" data-type="indexterm" id="idm45963626138392"/><a data-primary="sequence file comparison" data-secondary="pandas module parsing delimited text" data-tertiary="blastomatic input and output" data-type="indexterm" id="idm45963626137112"/><a data-primary="pandas module parsing delimited text" data-secondary="blastomatic program input and output" data-type="indexterm" id="idm45963626135848"/>&#13;
I chose to store all the output records in a Python list and instantiate a new dataframe from that to write the output file:</p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    annots = pd.read_csv(args.annotations, sep=',') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-1" id="co_blastomatic__parsing_delimited_text_files_CO12-1"><img alt="1" src="assets/1.png"/></a>&#13;
    hits = pd.read_csv(args.hits, <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-2" id="co_blastomatic__parsing_delimited_text_files_CO12-2"><img alt="2" src="assets/2.png"/></a>&#13;
                       sep=',',&#13;
                       names=[&#13;
                           'qseqid', 'sseqid', 'pident', 'length', 'mismatch',&#13;
                           'gapopen', 'qstart', 'qend', 'sstart', 'send',&#13;
                           'evalue', 'bitscore'&#13;
                       ])&#13;
&#13;
    data = [] <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-3" id="co_blastomatic__parsing_delimited_text_files_CO12-3"><img alt="3" src="assets/3.png"/></a>&#13;
    for _, hit in hits[hits['pident'] &gt;= args.pctid].iterrows(): <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-4" id="co_blastomatic__parsing_delimited_text_files_CO12-4"><img alt="4" src="assets/4.png"/></a>&#13;
        meta = annots[annots['seq_id'] == hit['qseqid']] <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-5" id="co_blastomatic__parsing_delimited_text_files_CO12-5"><img alt="5" src="assets/5.png"/></a>&#13;
        if not meta.empty: <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-6" id="co_blastomatic__parsing_delimited_text_files_CO12-6"><img alt="6" src="assets/6.png"/></a>&#13;
            for _, seq in meta.iterrows(): <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-7" id="co_blastomatic__parsing_delimited_text_files_CO12-7"><img alt="7" src="assets/7.png"/></a>&#13;
                data.append({ <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-8" id="co_blastomatic__parsing_delimited_text_files_CO12-8"><img alt="8" src="assets/8.png"/></a>&#13;
                    'qseqid': hit['qseqid'],&#13;
                    'pident': hit['pident'],&#13;
                    'depth': seq['depth'],&#13;
                    'lat_lon': seq['lat_lon'],&#13;
                })&#13;
&#13;
    df = pd.DataFrame.from_records(data=data) <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-9" id="co_blastomatic__parsing_delimited_text_files_CO12-9"><img alt="9" src="assets/9.png"/></a>&#13;
    df.to_csv(args.outfile, index=False, sep=args.delimiter) <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-10" id="co_blastomatic__parsing_delimited_text_files_CO12-10"><img alt="10" src="assets/10.png"/></a>&#13;
&#13;
    print(f'Exported {len(data):,} to "{args.outfile.name}".') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO12-11" id="co_blastomatic__parsing_delimited_text_files_CO12-11"><img alt="11" src="assets/11.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-1" id="callout_blastomatic__parsing_delimited_text_files_CO12-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Read the metadata file into a dataframe.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-2" id="callout_blastomatic__parsing_delimited_text_files_CO12-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Read the BLAST hits into a dataframe.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-3" id="callout_blastomatic__parsing_delimited_text_files_CO12-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Initialize a list for the output data.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-4" id="callout_blastomatic__parsing_delimited_text_files_CO12-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Select all the BLAST hits with a percent ID greater than or equal to the minimum percent.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-5" id="callout_blastomatic__parsing_delimited_text_files_CO12-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Select the metadata for the given query sequence ID.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-6" id="callout_blastomatic__parsing_delimited_text_files_CO12-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Verify that the metadata is not empty.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-7" id="callout_blastomatic__parsing_delimited_text_files_CO12-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Iterate over the metadata records (even though there should only be one).</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-8" id="callout_blastomatic__parsing_delimited_text_files_CO12-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Store a new dictionary with the output data.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-9" id="callout_blastomatic__parsing_delimited_text_files_CO12-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Create a new dataframe from the output data.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-10" id="callout_blastomatic__parsing_delimited_text_files_CO12-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>Write the dataframe to the output file, omitting the dataframe index values.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO12-11" id="callout_blastomatic__parsing_delimited_text_files_CO12-11"><img alt="11" src="assets/11.png"/></a></dt>&#13;
<dd><p>Print the status to the console.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 4: Joining Files Using pandas" data-type="sect2"><div class="sect2" id="idm45963626082120">&#13;
<h2>Solution 4: Joining Files Using pandas</h2>&#13;
&#13;
<p>In this last solution, I use pandas to join the metadata and BLAST dataframes, much like the <code>join</code> program I illustrated earlier in the chapter:<a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="blastomatic program created" data-tertiary="solution 4 pandas joining files" data-type="indexterm" id="idm45963626080248"/><a data-primary="sequence file comparison" data-secondary="blastomatic program created" data-tertiary="solution 4 pandas joining files" data-type="indexterm" id="idm45963626078968"/><a data-primary="BLAST (Basic Local Alignment Search Tool)" data-secondary="pandas module parsing delimited text" data-tertiary="joining metadata and BLAST dataframes" data-type="indexterm" id="idm45963626077704"/><a data-primary="sequence file comparison" data-secondary="pandas module parsing delimited text" data-tertiary="joining metadata and BLAST dataframes" data-type="indexterm" id="idm45963626076424"/><a data-primary="pandas module parsing delimited text" data-secondary="joining metadata and dataframes" data-type="indexterm" id="idm45963626075160"/></p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    annots = pd.read_csv(args.annotations, sep=',', index_col='seq_id') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO13-1" id="co_blastomatic__parsing_delimited_text_files_CO13-1"><img alt="1" src="assets/1.png"/></a>&#13;
    hits = pd.read_csv(args.hits,&#13;
                       sep=',',&#13;
                       index_col='qseqid', <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO13-2" id="co_blastomatic__parsing_delimited_text_files_CO13-2"><img alt="2" src="assets/2.png"/></a>&#13;
                       names=[&#13;
                           'qseqid', 'sseqid', 'pident', 'length', 'mismatch',&#13;
                           'gapopen', 'qstart', 'qend', 'sstart', 'send',&#13;
                           'evalue', 'bitscore'&#13;
                       ])&#13;
&#13;
    joined = hits[hits['pident'] &gt;= args.pctid].join(annots, how='inner') <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO13-3" id="co_blastomatic__parsing_delimited_text_files_CO13-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
    joined.to_csv(args.outfile, <a class="co" href="#callout_blastomatic__parsing_delimited_text_files_CO13-4" id="co_blastomatic__parsing_delimited_text_files_CO13-4"><img alt="4" src="assets/4.png"/></a>&#13;
                  index=True,&#13;
                  index_label='qseqid',&#13;
                  columns=['pident', 'depth', 'lat_lon'],&#13;
                  sep=args.delimiter)&#13;
&#13;
    print(f'Exported {joined.shape[0]:,} to "{args.outfile.name}".')</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO13-1" id="callout_blastomatic__parsing_delimited_text_files_CO13-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Read the annotations file and set the index column to <code>seq_id</code>.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO13-2" id="callout_blastomatic__parsing_delimited_text_files_CO13-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Read the BLAST hits and set the index column to <code>qseqid</code>.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO13-3" id="callout_blastomatic__parsing_delimited_text_files_CO13-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Select the BLAST hits with the desired percent ID, and perform an inner join to the annotations using the index columns.</p></dd>&#13;
<dt><a class="co" href="#co_blastomatic__parsing_delimited_text_files_CO13-4" id="callout_blastomatic__parsing_delimited_text_files_CO13-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Write the desired columns of the <code>joined</code> dataframe to the output file using the indicated delimiter. Include the index and name it <code>qseqid</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The join operation is quite complex, so let me take a moment to explain this.&#13;
First, each dataframe must have a unique index, which by default is the row index:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import pandas as pd&#13;
&gt;&gt;&gt; annots = pd.read_csv('tests/inputs/meta.csv')&#13;
&gt;&gt;&gt; annots.index&#13;
RangeIndex(start=0, stop=100, step=1)</pre>&#13;
&#13;
<p>Instead, I want pandas to use the <code>seq_id</code> column as the index, which I indicate with the <code>index_col</code> argument:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; annots = pd.read_csv('tests/inputs/meta.csv', index_col='seq_id')</pre>&#13;
&#13;
<p class="pagebreak-before">I can also indicate the zeroth field:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; annots = pd.read_csv('tests/inputs/meta.csv', index_col=0)</pre>&#13;
&#13;
<p>Now the index is set to the <code>seq_id</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; annots.index[:10]&#13;
Index(['JCVI_READ_1092301105055', 'JCVI_READ_1092351051817',&#13;
       'JCVI_READ_1092301096881', 'JCVI_READ_1093017101914',&#13;
       'JCVI_READ_1092342065252', 'JCVI_READ_1092256406745',&#13;
       'JCVI_READ_1092258001174', 'JCVI_READ_1092959499253',&#13;
       'JCVI_READ_1092959656555', 'JCVI_READ_1092959499263'],&#13;
      dtype='object', name='seq_id')</pre>&#13;
&#13;
<p>Similarly, I want the BLAST hits to be indexed on the query sequence ID:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; cols = ['qseqid', 'sseqid', 'pident', 'length', 'mismatch', 'gapopen',&#13;
 'qstart', 'qend', 'sstart', 'send', 'evalue', 'bitscore']&#13;
&gt;&gt;&gt; hits = pd.read_csv('tests/inputs/hits1.csv', names=cols, index_col='qseqid')&#13;
&gt;&gt;&gt; hits.index[:10]&#13;
Index(['CAM_READ_0234442157', 'CAM_READ_0234442157', 'CAM_READ_0234442157',&#13;
       'CAM_READ_0234442157', 'JCVI_READ_1095946186912',&#13;
       'JCVI_READ_1095946186912', 'JCVI_READ_1095946186912',&#13;
       'JCVI_READ_1095946186912', 'JCVI_READ_1095946186912',&#13;
       'JCVI_READ_1091145027519'],&#13;
      dtype='object', name='qseqid')</pre>&#13;
&#13;
<p>I can select the BLAST hits with <code>pident</code> greater than or equal to the minimum.&#13;
For instance, I find 190 rows with a value of 90:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; wanted = hits[hits['pident'] &gt;= 90]&#13;
&gt;&gt;&gt; wanted.shape&#13;
(190, 11)</pre>&#13;
&#13;
<p>The resulting dataframe is still indexed on the <code>qseqid</code> column, so I can join it to the annotations where the index values (the sequence IDs) are in common.&#13;
By default, pandas will perform a <em>left</em> <em>join</em>, selecting all the rows from the first or <em>left</em> dataframe and substituting null values for rows that have no mate in the right dataframe.&#13;
A <em>right join</em> is the opposite of a left join, selecting all the records from the <em>right</em> dataframe regardless of matches to the left.&#13;
Since I only want the hits that have annotations, I use an <em>inner</em> <em>join</em>.&#13;
<a data-type="xref" href="#fig_19.3">Figure 19-3</a> demonstrates the joins using Venn diagrams.</p>&#13;
&#13;
<figure><div class="figure" id="fig_19.3">&#13;
<img alt="mpfb 1903" src="assets/mpfb_1903.png"/>&#13;
<h6><span class="label">Figure 19-3. </span>A left join selects all the records from the left table, a right joins selects all the records from the right table, and an inner join selects only those records present in both</h6>&#13;
</div></figure>&#13;
&#13;
<p>The join operation creates a new dataframe with the columns of both dataframes, just like the <code>join</code> tool I showed in <a data-type="xref" href="#ch19-using-csvkit-and-csvchk">“Using csvkit and csvchk”</a>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; joined = wanted.join(annots, how='inner')&#13;
&gt;&gt;&gt; joined&#13;
                             sseqid   pident  ...  temp              lat_lon&#13;
CAM_READ_0234442157      CP031125.1   92.941  ...  26.6   -8.50525,80.375583&#13;
JCVI_READ_1091120852400  CP012541.1  100.000  ...  25.0     24.488333,-83.07&#13;
JCVI_READ_1091141680691  MN693562.1   90.852  ...  27.7  10.716389,-80.25445&#13;
JCVI_READ_1091141680691  MN693445.1   90.645  ...  27.7  10.716389,-80.25445&#13;
JCVI_READ_1091141680691  MN693445.1   91.935  ...  27.7  10.716389,-80.25445&#13;
...                             ...      ...  ...   ...                  ...&#13;
JCVI_READ_1095913058159  CP000437.1   94.737  ...   9.4  41.485832,-71.35111&#13;
JCVI_READ_1095913058159  AM286280.1   92.683  ...   9.4  41.485832,-71.35111&#13;
JCVI_READ_1095913058159  DQ682149.1   94.737  ...   9.4  41.485832,-71.35111&#13;
JCVI_READ_1095913058159  AM233362.1   94.737  ...   9.4  41.485832,-71.35111&#13;
JCVI_READ_1095913058159  AY871946.1   94.737  ...   9.4  41.485832,-71.35111&#13;
&#13;
[190 rows x 17 columns]</pre>&#13;
&#13;
<p>Another way to write this is to use the <code>pd.merge()</code> function, which will default to an inner join.&#13;
I must indicate which columns to use for the joins from the left and right dataframes, which in this case are the indexes:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; joined = pd.merge(wanted, annots, left_index=True, right_index=True)</pre>&#13;
&#13;
<p>I can use the <code>joined.to_csv()</code> method to write the dataframe to the output file.&#13;
Note that the common sequence IDs are the index, which has no column name.&#13;
I want the index included in the output file, so I use <code>index=True</code> and <code>index_name='qseqid'</code> so that the file matches the expected output:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; out_fh = open('out.csv', 'wt')&#13;
&gt;&gt;&gt; joined.to_csv(out_fh, index=True, index_label='qseqid',&#13;
columns=['pident', 'depth', 'lat_lon'], sep=',')</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963626025032">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>Add the options to filter by other fields like temperature, salinity, or BLAST e-value.</p>&#13;
&#13;
<p>Default to including all the columns from both files in the output file, and add an option to select a subset of the columns.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963626022792">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Shell aliases can be used to create shortcuts for common commands.</p>&#13;
</li>&#13;
<li>&#13;
<p>Delimited text files do not always have column headers. This is the case with BLAST’s tabular output formats.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>csv</code> and <code>pandas</code> modules can read and write delimited text files.</p>&#13;
</li>&#13;
<li>&#13;
<p>Datasets can be joined on common columns using the <code>join</code> command-line tool or in Python by using common keys from dictionaries or common indexes in pandas dataframes.</p>&#13;
</li>&#13;
<li>&#13;
<p>pandas is a good choice for reading delimited files if you need access to all the data in memory—for example, if you need to perform statistical analysis of the data or want to quickly access all the values for a column. If you need to parse very large delimited files and can process records independently, then use the <code>csv</code> module for better performance.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45963626663048"><sup><a href="ch19.html#idm45963626663048-marker">1</a></sup> You may say to yourself, “My God! What have they done?”</p></div></div></section></body></html>