- en: Chapter 35\. Three-Dimensional Plotting in Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Matplotlib was initially designed with only two-dimensional plotting in mind.
    Around the time of the 1.0 release, some three-dimensional plotting utilities
    were built on top of Matplotlib’s two-dimensional display, and the result is a
    convenient (if somewhat limited) set of tools for three-dimensional data visualization.
    Three-dimensional plots are enabled by importing the `mplot3d` toolkit, included
    with the main Matplotlib installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once this submodule is imported, a three-dimensional axes can be created by
    passing the keyword `projection='3d'` to any of the normal axes creation routines,
    as shown here (see [Figure 35-1](#fig_0412-three-dimensional-plotting_files_in_output_5_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this three-dimensional axes enabled, we can now plot a variety of three-dimensional
    plot types. Three-dimensional plotting is one of the functionalities that benefits
    immensely from viewing figures interactively rather than statically, in the notebook;
    recall that to use interactive figures, you can use `%matplotlib notebook` rather
    than `%matplotlib inline` when running this code.
  prefs: []
  type: TYPE_NORMAL
- en: '![output 5 0](assets/output_5_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-1\. An empty three-dimensional axes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Three-Dimensional Points and Lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic three-dimensional plot is a line or collection of scatter plots
    created from sets of (x, y, z) triples. In analogy with the more common two-dimensional
    plots discussed earlier, these can be created using the `ax.plot3D` and `ax.scatter3D`
    functions. The call signature for these is nearly identical to that of their two-dimensional
    counterparts, so you can refer to Chapters [26](ch26.xhtml#section-0401-simple-line-plots)
    and [27](ch27.xhtml#section-0402-simple-scatter-plots) for more information on
    controlling the output. Here we’ll plot a trigonometric spiral, along with some
    points drawn randomly near the line (see [Figure 35-2](#fig_0412-three-dimensional-plotting_files_in_output_8_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![output 8 0](assets/output_8_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-2\. Points and lines in three dimensions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that scatter points have their transparency adjusted to give a sense
    of depth on the page. While the three-dimensional effect is sometimes difficult
    to see within a static image, an interactive view can lead to some nice intuition
    about the layout of the points.
  prefs: []
  type: TYPE_NORMAL
- en: Three-Dimensional Contour Plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analogous to the contour plots we explored in [Chapter 28](ch28.xhtml#section-0404-density-and-contour-plots),
    `mplot3d` contains tools to create three-dimensional relief plots using the same
    inputs. Like `ax.contour`, `ax.contour3D` requires all the input data to be in
    the form of two-dimensional regular grids, with the *z* data evaluated at each
    point. Here we’ll show a three-dimensional contour diagram of a three-dimensional
    sinusoidal function (see [Figure 35-3](#fig_0412-three-dimensional-plotting_files_in_output_12_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![output 12 0](assets/output_12_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-3\. A three-dimensional contour plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Sometimes the default viewing angle is not optimal, in which case we can use
    the `view_init` method to set the elevation and azimuthal angles. In the following
    example, visualized in [Figure 35-4](#fig_0412-three-dimensional-plotting_files_in_output_14_0),
    we’ll use an elevation of 60 degrees (that is, 60 degrees above the x-y plane)
    and an azimuth of 35 degrees (that is, rotated 35 degrees counter-clockwise about
    the z-axis):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again, note that this type of rotation can be accomplished interactively by
    clicking and dragging when using one of Matplotlib’s interactive backends.
  prefs: []
  type: TYPE_NORMAL
- en: '![output 14 0](assets/output_14_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-4\. Adjusting the view angle for a three-dimensional plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Wireframes and Surface Plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two other types of three-dimensional plots that work on gridded data are wireframes
    and surface plots. These take a grid of values and project it onto the specified
    three-dimensional surface, and can make the resulting three-dimensional forms
    quite easy to visualize. Here’s an example of using a wireframe (see [Figure 35-5](#fig_0412-three-dimensional-plotting_files_in_output_17_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![output 17 0](assets/output_17_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-5\. A wireframe plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A surface plot is like a wireframe plot, but each face of the wireframe is a
    filled polygon. Adding a colormap to the filled polygons can aid perception of
    the topology of the surface being visualized, as you can see in [Figure 35-6](#fig_0412-three-dimensional-plotting_files_in_output_19_0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![output 19 0](assets/output_19_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-6\. A three-dimensional surface plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Though the grid of values for a surface plot needs to be two-dimensional, it
    need not be rectilinear. Here is an example of creating a partial polar grid,
    which when used with the `surface3D` plot can give us a slice into the function
    we’re visualizing (see [Figure 35-7](#fig_0412-three-dimensional-plotting_files_in_output_21_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![output 21 0](assets/output_21_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-7\. A polar surface plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Surface Triangulations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some applications, the evenly sampled grids required by the preceding routines
    are too restrictive. In these situations, triangulation-based plots can come in
    handy. What if rather than an even draw from a Cartesian or a polar grid, we instead
    have a set of random draws?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We could create a scatter plot of the points to get an idea of the surface we’re
    sampling from, as shown in [Figure 35-8](#fig_0412-three-dimensional-plotting_files_in_output_25_0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![output 25 0](assets/output_25_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-8\. A three-dimensional sampled surface
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This point cloud leaves a lot to be desired. The function that will help us
    in this case is `ax.plot_trisurf`, which creates a surface by first finding a
    set of triangles formed between adjacent points (remember that `x`, `y`, and `z`
    here are one-dimensional arrays); [Figure 35-9](#fig_0412-three-dimensional-plotting_files_in_output_27_0)
    shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The result is certainly not as clean as when it is plotted with a grid, but
    the flexibility of such a triangulation allows for some really interesting three-dimensional
    plots. For example, it is actually possible to plot a three-dimensional Möbius
    strip using this, as we’ll see next.
  prefs: []
  type: TYPE_NORMAL
- en: '![output 27 0](assets/output_27_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-9\. A triangulated surface plot
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Example: Visualizing a Möbius Strip'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Möbius strip is similar to a strip of paper glued into a loop with a half-twist,
    resulting in an object with only a single side! Here we will visualize such an
    object using Matplotlib’s three-dimensional tools. The key to creating the Möbius
    strip is to think about its parametrization: it’s a two-dimensional strip, so
    we need two intrinsic dimensions. Let’s call them <math alttext="theta"><mi>θ</mi></math>
    , which ranges from 0 to <math alttext="2 pi"><mrow><mn>2</mn> <mi>π</mi></mrow></math>
    around the loop, and <math alttext="w"><mi>w</mi></math> , which ranges from –1
    to 1 across the width of the strip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now from this parametrization, we must determine the (*x*, *y*, *z*) positions
    of the embedded strip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking about it, we might realize that there are two rotations happening:
    one is the position of the loop about its center (what we’ve called <math alttext="theta"><mi>θ</mi></math>
    ), while the other is the twisting of the strip about its axis (we’ll call this
    <math alttext="phi"><mi>φ</mi></math> ). For a Möbius strip, we must have the
    strip make half a twist during a full loop, or <math alttext="normal upper Delta
    phi equals normal upper Delta theta slash 2"><mrow><mi>Δ</mi> <mi>φ</mi> <mo>=</mo>
    <mi>Δ</mi> <mi>θ</mi> <mo>/</mo> <mn>2</mn></mrow></math> :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we use our recollection of trigonometry to derive the three-dimensional
    embedding. We’ll define <math alttext="r"><mi>r</mi></math> , the distance of
    each point from the center, and use this to find the embedded <math alttext="left-parenthesis
    x comma y comma z right-parenthesis"><mrow><mo>(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo>,</mo> <mi>z</mi> <mo>)</mo></mrow></math> coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to plot the object, we must make sure the triangulation is correct.
    The best way to do this is to define the triangulation *within the underlying
    parametrization*, and then let Matplotlib project this triangulation into the
    three-dimensional space of the Möbius strip. This can be accomplished as follows
    (see [Figure 35-10](#fig_0412-three-dimensional-plotting_files_in_output_36_0)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![output 36 0](assets/output_36_0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 35-10\. Visualizing a Möbius strip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Combining all of these techniques, it is possible to create and display a wide
    variety of three-dimensional objects and patterns in Matplotlib.
  prefs: []
  type: TYPE_NORMAL
