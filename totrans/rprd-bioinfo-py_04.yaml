- en: 'Chapter 3\. Reverse Complement of DNA: String Manipulation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章\. DNA的反向互补：字符串操作
- en: The [Rosalind REVC challenge](https://oreil.ly/ot4z6) explains that the bases
    of DNA form pairs of *A-T* and *G-C*. Additionally, DNA has directionality and
    is usually read from the 5'-end (*five-prime end*) toward the 3'-end (*three-prime
    end*). As shown in [Figure 3-1](#fig_3.1), the complement of the DNA string *AAAACCCGGT*
    is *TTTTGGGCCA*. I then reverse this string (reading from the 3'-end) to get *ACCGGGTTTT*
    as the reverse complement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[Rosalind REVC挑战](https://oreil.ly/ot4z6)解释DNA的碱基形成*A-T*和*G-C*的配对。此外，DNA具有方向性，通常从5''-端（*五端*）向3''-端（*三端*）读取。如图[Figure 3-1](#fig_3.1)所示，DNA字符串*AAAACCCGGT*的互补是*TTTTGGGCCA*。然后我反转这个字符串（从3''-端读取）以获得*ACCGGGTTTT*作为反向互补。'
- en: '![mpfb 0301](assets/mpfb_0301.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0301](assets/mpfb_0301.png)'
- en: Figure 3-1\. The reverse complement of DNA is the complement read from the opposite
    direction
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1\. DNA的反向互补是从相反方向读取的互补序列
- en: 'Although you can find many existing tools to generate the reverse complement
    of DNA—and I’ll drop a spoiler alert that the final solution will use a function
    from the Biopython library—the point of writing our own algorithm is to explore
    Python. In this chapter, you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以找到许多现有工具来生成DNA的反向互补序列——我将透露最终解决方案将使用Biopython库中的一个函数——但编写我们自己的算法的目的是探索Python。在本章中，您将学习：
- en: How to implement a decision tree using a dictionary as a lookup table
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用字典实现决策树作为查找表
- en: How to dynamically generate a list or a string
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何动态生成列表或字符串
- en: How to use the `reversed()` function, which is an example of an iterator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`reversed()`函数，这是迭代器的一个示例
- en: How Python treats strings and lists similarly
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python如何类似地处理字符串和列表
- en: How to use a list comprehension to generate a list
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用列表推导生成列表
- en: How to use `str.maketrans()` and `str.translate()` to transform a string
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`str.maketrans()`和`str.translate()`来转换一个字符串
- en: How to use Biopython’s `Bio.Seq` module
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Biopython的`Bio.Seq`模块
- en: That the real treasure is the friends you make along the way
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正的宝藏是你沿途结交的朋友
- en: Getting Started
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: 'The code and tests for this program are in the *03_revc* directory. To get
    a feel for how the program will work, change into that directory and copy the
    first solution to a program called `revc.py`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序的代码和测试位于*03_revc*目录中。为了了解程序如何工作，请切换到该目录并将第一个解决方案复制到名为`revc.py`的程序中：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the program with `--help` to read the usage:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序时使用`--help`来查看使用方法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The program wants `DNA` and will print the reverse complement, so I’ll give
    it a string:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 程序需要`DNA`并将打印反向互补序列，所以我会给它一个字符串：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As the help indicates, the program will also accept a file as input. The first
    test input has the same string:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如帮助文档所示，程序还将接受文件作为输入。第一个测试输入有相同的字符串：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So the output should be the same:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此输出应该是相同的：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'I want to make the specs for the program just a little harder, so the tests
    will pass both a mix of uppercase and lowercase. The output should respect the
    case of the input:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让程序的规格稍微难一点，这样测试就会通过大小写的混合。输出应该尊重输入的大小写：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run **`pytest`** (or **`make test`**) to see what kinds of tests the program
    should pass. When you’re satisfied you have a feel for what the program should
    do, start anew:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行**`pytest`**（或**`make test`**）来查看程序应该通过哪些类型的测试。当你对程序的预期功能感到满意时，重新开始：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Edit the `get_args()` function until the program will print the preceding usage.
    Then modify your program so that it will echo back input either from the command
    line or from an input file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`get_args()`函数，直到程序将打印前面的用法。然后修改您的程序，以便它将从命令行或输入文件中回显输入：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run the test suite, you should find your program passes the first three
    tests:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行测试套件，你应该会发现你的程序通过了前三个测试：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The program is being passed the input string `AAAACCCGGT`, and the test expects
    it to print `ACCGGGTTTT`. Since the program is echoing the input, this test fails.
    If you think you know how to write a program to satisfy these tests, have at it.
    If not, I’ll show you how to create the reverse complement of DNA, starting with
    a simple approach and working up to more elegant solutions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正在传递输入字符串`AAAACCCGGT`，并且测试期望它打印`ACCGGGTTTT`。由于程序正在回显输入，这个测试失败了。如果您认为自己能写一个满足这些测试的程序，就去做吧。否则，我将向您展示如何创建DNA的反向互补序列，从简单的方法开始，逐步发展到更优雅的解决方案。
- en: Iterating Over a Reversed String
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历反向字符串
- en: 'When creating the reverse complement of DNA, it doesn’t matter if you first
    reverse the sequence and then complement it or vice versa. You will get the same
    answer either way, so I’ll start with how you can reverse a string. In [Chapter 2](ch02.html#ch02),
    I showed how you can use a string slice to get a portion of a string. If you leave
    out the start position, it will start from the beginning:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建DNA的反向互补物时，首先反转序列再补充，或者反之，都没有关系。 无论哪种方式，您都会得到相同的答案，所以我将从如何反转字符串开始。 在[第2章](ch02.html#ch02)中，我展示了如何使用字符串切片获取字符串的一部分。
    如果省略起始位置，它将从开头开始：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you leave out the stop position, it will go to the end:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了停止位置，它将进行到末尾：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you leave out both start and stop, it will return a copy of the entire string:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了起始和停止位置，它将返回整个字符串的副本：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It also takes an optional third argument to indicate the step size. I can use
    no arguments for the start and stop, and a step of `-1` to reverse the string:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它还需要一个可选的第三个参数来指示步长。我可以使用没有参数的情况下开始和停止，步长为`-1`来反转字符串：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Python also has a built-in `reversed()` function, so I’ll try that:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有一个内置的`reversed()`函数，所以我会尝试一下：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Surprise! You were probably expecting to see the string `TGGCCCAAAA`. If you
    read `help(reversed)` in the REPL, however, you’ll see that this function will
    “Return a reverse iterator over the values of the given sequence.”
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 惊喜！ 您可能希望看到字符串`TGGCCCAAAA`。 但是，如果您在REPL中阅读`help(reversed)`，您会发现该函数将“返回给定序列的值的反向迭代器。”
- en: What is an *iterator*? Python’s [Functional Programming HOWTO](https://oreil.ly/dIzn3)
    describes an iterator as “an object representing a stream of data.” I’ve mentioned
    that an *iterable* is some collection of items that Python can visit individually;
    for example, the characters of a string or the elements in a list. An iterator
    is something that will generate values until it is exhausted. Just as I can start
    with the first character of a string (or the first element of a list or the first
    line of a file) and read until the end of the string (or list or file), an iterator
    can be iterated from the first value it produces until it finishes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是*迭代器*？Python的[函数式编程指南](https://oreil.ly/dIzn3)将迭代器描述为“代表数据流的对象。” 我提到过*可迭代*是Python可以单独访问的一些项目的集合；例如，字符串的字符或列表中的元素。
    迭代器是一种在耗尽之前将生成值的东西。 就像我可以从字符串的第一个字符（或列表的第一个元素或文件的第一行）开始阅读直到字符串的结尾（或列表或文件）一样，迭代器可以从它产生的第一个值迭代到它完成的位置。
- en: 'In this case, the `reversed()` function is returning a promise to produce the
    reversed values as soon as it appears that you need them. This is an example of
    a *lazy* function because it waits until forced to do any work. One way to coerce
    the values from `reversed()` is to use a function that will consume the values.
    For instance, if the only goal is to reverse the string, then I could use the
    `str.join()` function. I always feel the syntax is backward on this function,
    but you will often invoke the `str.join()` method on a string literal that is
    the element used to join the sequence:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`reversed()`函数返回一个承诺，即在出现需要时立即产生反转的值。 这是一个*惰性*函数的示例，因为它等待被迫执行任何工作。 强制从`reversed()`中获取值的一种方法是使用将消耗值的函数。
    例如，如果唯一的目标是反转字符串，那么我可以使用`str.join()`函数。 我总觉得这个函数的语法是反向的，但您经常会在用于连接序列的字符串文字上调用`str.join()`方法：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO1-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO1-1)'
- en: Use the empty string to join the reversed characters of the DNA string.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空字符串连接DNA字符串的反转字符。
- en: 'Another method uses the `list()` function to force `reversed()` to produce
    the values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法使用`list()`函数强制`reversed()`生成值：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Wait, what happened? The `dna` variable is a string, but I got back a list—and
    not just because I used the `list()` function. The documentation for `reversed()`
    shows that the function takes a *sequence*, which means any data structure or
    function that returns one thing followed by another. In a list or iterator context,
    Python treats strings as lists of characters:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，发生了什么？ `dna`变量是一个字符串，但我得到了一个列表——不仅仅是因为我使用了`list()`函数。 `reversed()`的文档显示该函数接受一个*序列*，这意味着任何返回一个东西然后另一个东西的数据结构或函数。
    在列表或迭代器上下文中，Python将字符串视为字符列表：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A longer way to build up the reversed DNA sequence is to use a `for` loop to
    iterate over the reversed bases and append them to a string. First I’ll declare
    a `rev` variable, and I’ll append each base in reverse order using the `+=` operator:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更长的构建反向 DNA 序列的方法是使用`for`循环来迭代逆转的碱基，并将它们附加到一个字符串中。首先我将声明一个`rev`变量，然后使用`+=`运算符以逆序附加每个碱基：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-1)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-1)'
- en: Initialize the `rev` variable with the empty string.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 用空字符串初始化`rev`变量。
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-2)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-2)'
- en: Iterate through the reversed bases of DNA.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 逆转 DNA 的碱基。
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-3)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-3)'
- en: Append the current base to the `rev` variable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前碱基附加到`rev`变量。
- en: But since I still need to complement the bases, I’m not quite done.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于我仍然需要补全碱基，所以还没有完全完成。
- en: Creating a Decision Tree
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建决策树
- en: 'There are a total of eight complements: *A* to *T* and *G* to *C*, both upper-
    and lowercase, and then vice versa. I also need to handle the case of a character
    *not* being *A*, *C*, *G*, or *T*. I can use `if`/`elif` statements to create
    a decision tree. I’ll change my variable to `revc` since it’s now the reverse
    complement, and I’ll figure out the correct complement for each base:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一共有八种互补：*A* 到 *T* 和 *G* 到 *C*，包括大小写，然后反过来。我还需要处理字符不是 *A*、*C*、*G* 或 *T* 的情况。我可以使用`if`/`elif`语句创建一个决策树。我将变量更改为`revc`，因为现在它是反向互补，我将找出每个碱基的正确互补。
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-1)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-1)'
- en: Initialize a variable to hold the reverse complement string.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个变量来保存反向互补字符串。
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-2)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-2)'
- en: Iterate through the reversed bases in the DNA string.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 逆转 DNA 字符串中的碱基。
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-3)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-3)'
- en: Test each uppercase and lowercase base.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 测试每个大写和小写碱基。
- en: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-4)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-4)'
- en: Append the complementing base to the variable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将补充的碱基附加到变量中。
- en: '[![5](assets/5.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-5)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-5)'
- en: If the base doesn’t match any of these tests, use the base as is.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果碱基与这些测试中的任何一个不匹配，则使用原始碱基。
- en: 'If you inspect the `revc` variable, it appears to be correct:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检查`revc`变量，它看起来是正确的：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should be able to incorporate these ideas into a program that will pass
    the test suite. To understand what exactly is expected of your program, take a
    look at the *tests/revc_test.py* file. After you pass the `test_uppercase()` function,
    see what is expected by `test_lowercase()`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够将这些想法整合到一个能通过测试套件的程序中。要理解程序的确切预期结果，请查看*tests/revc_test.py*文件。在通过`test_uppercase()`函数后，查看`test_lowercase()`函数的预期结果：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-1)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-1)'
- en: Run the program using lowercase and uppercase DNA strings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小写和大写 DNA 字符串运行程序。
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-2)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-2)'
- en: The exit value should be `0`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 退出值应为`0`。
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-3)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-3)'
- en: The output from the program should be the indicated string.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出应该是指定的字符串。
- en: 'The next tests will pass filenames rather than strings as input:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步测试将使用文件名而不是字符串作为输入：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-1)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The `TEST1` tuple is a file of input and a file of expected output.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-2)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with the filename.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-3)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the exit value is `0`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-4)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Open and read the expected file and compare that to the output.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: It’s equally important to read and understand the testing code as it is to learn
    how to write the solutions. When you write your programs, you may find you can
    copy many of the ideas from these tests and save yourself time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the algorithm in the preceding section will produce the correct answer,
    it is not an elegant solution. Still, it’s a place to start that passes the tests.
    Now that you perhaps have a better idea of the challenge, it’s time to refactor
    the program. Some of the solutions I present are as short as one or two lines
    of code. Here are some ideas you might consider:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Use a dictionary as a lookup table instead of the `if`/`elif` chain.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrite the `for` loop as a list comprehension.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `str.translate()` method to complement the bases.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `Bio.Seq` object and find the method that will do this for you.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no hurry to read ahead. Take your time to try other solutions. I haven’t
    introduced all these ideas yet, so I encourage you to research any unknowns and
    see if you can figure them out on your own.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'I remember one of my teachers in music school sharing this quote with me:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Then said a teacher, Speak to us of Teaching.
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And he said:'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No man can reveal to you aught but that which already lies half asleep in the
    dawning of your knowledge.
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The teacher who walks in the shadow of the temple, among his followers, gives
    not of his wisdom but rather of his faith and his lovingness.
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If he is indeed wise he does not bid you enter the house of his wisdom, but
    rather leads you to the threshold of your own mind.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kahlil Gibran
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Solutions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the solutions share the same `get_args()` function, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-1)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The only argument to the program is a string of DNA.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-2)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Handle the case when reading a file input.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-3)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Return an `Args` object in compliance with the function signature.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using a for Loop and Decision Tree'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is my first solution using the `if`/`else` decision tree:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-1)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-1)'
- en: Initialize a variable to hold the reverse complement.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个变量来保存反向互补序列。
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-2)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-2)'
- en: Iterate through the reversed bases of the DNA argument.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历DNA参数的反向碱基。
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-3)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-3)'
- en: Create an `if`/`elif` decision tree to determine each base’s complement.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`if`/`elif`决策树来确定每个碱基的互补碱基。
- en: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-4)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-4)'
- en: Print the result.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 打印结果。
- en: 'Solution 2: Using a Dictionary Lookup'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2：使用字典查找
- en: 'I mentioned that the `if`/`else` chain is something you should try to replace.
    That is 18 lines of code (LOC) that could be represented more easily using a dictionary
    lookup:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，`if`/`else`链是应该尽量替换的。这是18行代码（LOC），可以更轻松地使用字典查找表示：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If I use a `for` loop to iterate through a string of DNA, I can use the `dict.get()`
    method to safely request each base in a string of DNA to create the complement
    (see [Figure 3-1](#fig_3.1)). Note that I will use the `base` as the optional
    second argument to `dict.get()`. If the base doesn’t exist in the lookup table,
    then I’ll default to using the base as is, just like the `else` case from the
    first solution:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我使用`for`循环遍历DNA字符串，我可以使用`dict.get()`方法安全地请求DNA字符串中的每个碱基来创建互补序列（见[图 3-1](#fig_3.1)）。请注意，我将使用`base`作为`dict.get()`的可选第二个参数。如果碱基不存在于查找表中，则将默认使用碱基本身，就像第一个解决方案中的`else`情况一样：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I can create a `complement` variable to hold the new string I generate:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以创建一个`complement`变量来保存我生成的新字符串：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You saw before that using the `reversed()` function on a string will return
    a list of the characters of the string in reverse order:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到过，在字符串上使用`reversed()`函数会以相反的顺序返回字符串的字符列表：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I can use the `str.join()` function to create a new string from a list:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`str.join()`函数从列表创建一个新字符串：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When I put all these ideas together, the `main()` function becomes significantly
    shorter. It also becomes easier to expand because adding a new branch to the decision
    tree only requires adding a new key/value pair to the dictionary:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将所有这些想法结合在一起时，`main()`函数变得明显更短。这也更容易扩展，因为向决策树添加新分支只需要向字典添加新的键/值对：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-1)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-1)'
- en: This is a dictionary showing how to translate one base to its complement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个字典，展示了如何将一个碱基翻译成其互补碱基。
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-2)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-2)'
- en: Initialize a variable to hold the DNA complement.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个变量来保存DNA互补序列。
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-3)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-3)'
- en: Iterate through each base in the DNA string.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历DNA字符串中的每个碱基。
- en: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-4)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-4)'
- en: Append the translation of the base or the base itself to the complement.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将碱基的翻译或碱基本身附加到互补序列中。
- en: '[![5](assets/5.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-5)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-5)'
- en: Reverse the complement and join the results on an empty string.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 反转互补序列并在空字符串上连接结果。
- en: 'Python strings and lists are somewhat interchangeable. I can change the `complement`
    variable to a list, and nothing else in the program changes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串和列表在某种程度上是可互换的。我可以将`complement`变量更改为列表，程序中的其他内容都不会改变：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO9-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO9-1)'
- en: Initialize the complement to an empty list instead of a string.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将互补序列初始化为空列表而不是字符串。
- en: 'I am highlighting here that the `+=` operator works with both strings and lists
    to append a new value at the end. There is also a `list.append()` method which
    does the same:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里强调 `+=` 运算符可以用于字符串和列表，以在末尾追加一个新值。还有一个 `list.append()` 方法也可以实现相同的效果：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `reversed()` function works just as well on a list as it does a string.
    It’s somewhat remarkable to me that using two different types for the `complement`
    results in so few changes to the code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()` 函数在列表上的效果与在字符串上的效果一样好。对我来说，使用两种不同类型的 `complement` 结果对代码的影响如此之小，这有些引人注目。'
- en: 'Solution 3: Using a List Comprehension'
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 3：使用列表推导式
- en: I suggested that you use a list comprehension without telling you what that
    is. If you’ve never used one before, it’s essentially a way to write a `for` loop
    inside the square brackets (`[]`) used to create a new list (see [Figure 3-2](#fig_3.2)).
    When the goal of a `for` loop is to build up a new string or list, it makes much
    more sense to use a list comprehension.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你使用列表推导式，而没有告诉你它是什么。如果你以前从未使用过，它本质上是在用于创建新列表的方括号（`[]`）内部写一个 `for` 循环的方式（见[图
    3-2](#fig_3.2)）。当 `for` 循环的目标是构建一个新的字符串或列表时，使用列表推导式要明智得多。
- en: '![mpfb 0302](assets/mpfb_0302.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0302](assets/mpfb_0302.png)'
- en: Figure 3-2\. A list comprehension uses a `for` loop to generate a new list
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 列表推导式使用 `for` 循环生成一个新列表
- en: 'This shortens the three lines to initialize a `complement` and loop through
    the string of DNA down to one line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将三行初始化 `complement` 并循环遍历 DNA 字符串的操作缩短为一行：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO10-1)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO10-1)'
- en: Replace the `for` loop with a list comprehension.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用列表推导式替换 `for` 循环。
- en: 'Since the `complement` variable is only used once, I might even shorten this
    further by using the list comprehension directly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `complement` 变量只使用一次，我甚至可以通过直接使用列表推导式来进一步缩短这个过程：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is acceptable because the line is shorter than the maximum of 79 characters
    recommended by PEP8, but it’s not as readable as the longer version. You should
    use whatever version you feel is most immediately understandable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以接受的，因为该行的长度小于 PEP8 建议的 79 个字符的最大值，但它不如较长版本易读。你应该使用你认为最容易理解的版本。
- en: 'Solution 4: Using str.translate()'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 4：使用 str.translate()
- en: 'In [Chapter 2](ch02.html#ch02), I used the `str.replace()` method to substitute
    all the *T*s with *U*s when transcribing DNA to RNA. Could I use that here? Let’s
    try. I’ll start by initializing the DNA string and replacing the *A*s with *T*s.
    Remember that strings are *immutable*, meaning I can’t change a string in place,
    but rather must overwrite the string with a new value:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html#ch02)中，我使用 `str.replace()` 方法将所有的 *T* 替换为 *U*，当将 DNA 转录为 RNA
    时。我能在这里使用吗？让我们试试。我将从初始化 DNA 字符串并将 *A* 替换为 *T* 开始。请记住，字符串是 *不可变* 的，这意味着我不能直接更改一个字符串，而是必须用新值覆盖字符串：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let’s look at the DNA string:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 DNA 字符串：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Can you see where this has started to go wrong? I’ll complement the *T*s to
    *A*s now, and see if you can spot the problem:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到这里开始出错了吗？我现在将 *T* 补足为 *A*，看看你能否发现问题：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As shown in [Figure 3-3](#fig_3.3), all the *A*s that turned into *T*s in the
    first move were just changed back to *A*s. Oh, that way madness lies.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[图 3-3](#fig_3.3)所示，第一步中转变为 *T* 的所有 *A* 刚刚又变回了 *A*。哦，这会让人发疯的。
- en: '![mpfb 0303](assets/mpfb_0303.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0303](assets/mpfb_0303.png)'
- en: Figure 3-3\. Iteratively using `str.replace()` leads to double replacements
    of values and the wrong answer
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 迭代使用 `str.replace()` 导致值的双重替换和错误的答案
- en: 'Fortunately, Python has the `str.translate()` function for exactly this purpose.
    If you read **`help(str.translate)`**, you will find the function requires a table
    “which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or
    `None`.” The `trans` dictionary table will serve, but first, it must be passed
    to the `str.maketrans()` function to transform the complement table into a form
    that uses the *ordinal* values of the keys:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python 有 `str.translate()` 函数，专门用于这个目的。如果你阅读 **`help(str.translate)`**，你会发现该函数需要一个“必须是
    Unicode 序数到 Unicode 序数、字符串或 `None` 的映射”的表格。`trans` 字典表将起到作用，但首先，它必须传递给 `str.maketrans()`
    函数，以将补充表转换为使用键的 *序数* 值的形式：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can see that the string key `A` was turned into the integer value `65`,
    which is the same value returned by the `ord()` function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到字符串键 `A` 被转换为整数值 `65`，这与 `ord()` 函数返回的值相同：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This value represents the ordinal position of the character *A* in the ASCII
    (American Standard Code for Information Interchange, pronounced *as-key*) table.
    That is, *A* is the 65^(th) character in the table. The `chr()` function will
    reverse this process, providing the character represented by an ordinal value:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值表示ASCII（美国标准信息交换码表，发音为as-key）表中字符*A*的序数位置。也就是说，*A*是表中的第65个字符。`chr()`函数将颠倒此过程，提供由序数值表示的字符：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `str.translate()` function requires the complement table to have ordinal
    values for the keys, which is what I get from `str.maketrans()`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.translate()`函数要求互补表具有键的序数值，这正是我从`str.maketrans()`中获取的：'
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, I need to reverse the complement. Here is a solution that incorporates
    all these ideas:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我需要反向互补。这里有一个融合了所有这些想法的解决方案：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-1)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-1)'
- en: Create the translation table needed for the `str.translate()` function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于`str.translate()`函数的翻译表。
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-2)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-2)'
- en: Complement the DNA using the `trans` table. Reverse, and join for a new string.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`trans`表互补DNA。反转并连接成新字符串。
- en: 'But, wait—there’s more! There’s another even shorter way to write this. According
    to the `help(str.translate)` documentation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，等等——还有更多！还有另一种更简短的写法。根据`help(str.translate)`文档：
- en: If there is only one argument, it must be a dictionary mapping Unicode ordinals
    (integers) or characters to Unicode ordinals, strings or `None`. Character keys
    will be then converted to ordinals. *If there are two arguments, they must be
    strings of equal length, and in the resulting dictionary, each character in `x`
    will be mapped to the character at the same position in `y`.*
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果只有一个参数，它必须是将Unicode序数（整数）或字符映射到Unicode序数、字符串或`None`的字典。字符键将被转换为序数。*如果有两个参数，它们必须是长度相等的字符串，且在生成的字典中，`x`中的每个字符将映射到`y`中相同位置的字符。*
- en: 'So I can remove the `trans` dictionary and write the entire solution like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我可以删除`trans`字典，并像这样编写整个解决方案：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-1)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-1)'
- en: Make the translation table using two strings of equal lengths.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用长度相等的两个字符串制作翻译表。
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-2)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-2)'
- en: Create the reverse complement.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建反向互补。
- en: If you wanted to ruin someone’s day—and in all likelihood, that person will
    be future you—you could even condense this into a single line of code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想毁掉某人的一天——很可能那个人会是未来的你——你甚至可以将其压缩成一行代码。
- en: 'Solution 5: Using Bio.Seq'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案5：使用Bio.Seq
- en: I told you at the beginning of this chapter that the final solution would involve
    an existing function.^([1](ch03.html#idm45963636070440)) Many Python programmers
    working in bioinformatics have contributed to a set of modules under the name
    of [Biopython](https://biopython.org). They have written and tested many incredibly
    useful algorithms, and it rarely makes sense to write your own code when you can
    use someone else’s.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头我告诉过你，最终的解决方案将涉及一个现有的函数。^([1](ch03.html#idm45963636070440)) 许多从事生物信息学的Python程序员共同贡献了一套名为[Biopython](https://biopython.org)的模块。他们编写并测试了许多非常有用的算法，当你可以使用他人的代码时，自己编写代码很少有意义。
- en: 'Be sure that you have first installed `biopython` by running the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经先通过运行以下命令安装了`biopython`：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I could import the entire module using `import Bio`, but it makes much more
    sense to only import the code I need. Here I only need the `Seq` class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`import Bio`来导入整个模块，但只导入我需要的代码更加合理。这里我只需要`Seq`类：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now I can use the `Seq.reverse_complement()` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以使用`Seq.reverse_complement()`函数：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This final solution is the version I would recommend, as it is the shortest
    and also uses existing, well-tested, documented modules that are almost ubiquitous
    in bioinformatics with Python:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最终的解决方案是我推荐的版本，因为它是最短的，而且使用了现有的、经过充分测试和文档化的模块，在Python生物信息学中几乎无处不在：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO13-1)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO13-1)'
- en: Use the `Bio.Seq.reverse_complement()` function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Bio.Seq.reverse_complement()` 函数。
- en: 'When you run `mypy` on this solution (you *are* running `mypy` on every one
    of your programs, right?), you may get the following error:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在此解决方案上运行 `mypy` 时（您确实在每一个程序上运行 `mypy`，对吗？），您可能会收到以下错误：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To silence this error, you can tell `mypy` to ignore imported files that are
    missing type annotations. In the [root directory of the GitHub repository for
    this book](https://oreil.ly/RpMgV), you will find a file called *mypy.ini* with
    the following contents:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要消除此错误，您可以告诉 `mypy` 忽略缺少类型注解的导入文件。在本书的 [GitHub 仓库的根目录](https://oreil.ly/RpMgV)
    中，您将找到名为 *mypy.ini* 的文件，其内容如下：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Adding a *mypy.ini* file to any working directory allows you to make changes
    to the defaults that `mypy` uses *when you run it in the same directory*. If you
    would like to make this a global change so that `mypy` will use this no matter
    what directory you are in, then put this same content into *$HOME/.mypy.ini*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 向任何工作目录添加 *mypy.ini* 文件允许您对 `mypy` 在相同目录中运行时使用的默认值进行更改。如果您希望进行全局更改，以便 `mypy`
    无论您在哪个目录中都使用这些内容，则将相同内容放入 *$HOME/.mypy.ini* 中。
- en: Review
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Manually creating the reverse complement of DNA is something of a rite of passage.
    Here’s what I showed:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建DNA的反向互补序列是一种入门仪式。这是我展示的内容：
- en: You can write a decision tree using a series of `if`/`else` statements or by
    using a dictionary as a lookup table.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用一系列 `if`/`else` 语句或使用字典作为查找表来编写决策树。
- en: Strings and lists are very similar. Both can be iterated using a `for` loop,
    and the `+=` operator can be used to append to both.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串和列表非常相似。两者都可以使用 `for` 循环进行迭代，而 `+=` 运算符可用于向两者附加元素。
- en: A list comprehension uses a `for` loop to iterate a sequence and generate a
    new list.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导使用 `for` 循环来迭代一个序列并生成新列表。
- en: The `reversed()` function is a lazy function that will return an iterator of
    the elements of a sequence in reverse order.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reversed()` 函数是一个惰性函数，它将以相反的顺序返回序列的迭代器。'
- en: You can use the `list()` function in the REPL to coerce lazy functions, iterators,
    and generators to generate their values.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 REPL 中使用 `list()` 函数来强制执行惰性函数、迭代器和生成器，以生成它们的值。
- en: The `str.maketrans()` and `str.translate()` functions can perform string substitution
    and generate a new string.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.maketrans()` 和 `str.translate()` 函数可以执行字符串替换并生成新字符串。'
- en: The `ord()` function returns the ordinal value of a character, and conversely,
    the `chr()` function returns the character for a given ordinal value.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ord()` 函数返回字符的序数值，而 `chr()` 函数则根据给定的序数值返回字符。'
- en: Biopython is a collection of modules and functions specific to bioinformatics.
    The preferred way to create the reverse complement of DNA is to use the `Bio.Seq.reverse_complement()`
    function.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Biopython 是专门用于生物信息学的模块和函数集合。创建DNA的反向互补序列的首选方法是使用 `Bio.Seq.reverse_complement()`
    函数。
- en: ^([1](ch03.html#idm45963636070440-marker)) This is kind of like how my high
    school calculus teacher spent a week teaching us how to perform manual derivatives,
    then showed us how it could be done in 20 seconds by pulling down the exponent
    and yada yada yada.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#idm45963636070440-marker)) 这有点像我的高中微积分老师花了一周时间教我们如何进行手动导数，然后展示了如何在20秒内通过拉下指数等方式完成。
