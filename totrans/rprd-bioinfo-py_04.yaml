- en: 'Chapter 3\. Reverse Complement of DNA: String Manipulation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [Rosalind REVC challenge](https://oreil.ly/ot4z6) explains that the bases
    of DNA form pairs of *A-T* and *G-C*. Additionally, DNA has directionality and
    is usually read from the 5'-end (*five-prime end*) toward the 3'-end (*three-prime
    end*). As shown in [Figure 3-1](#fig_3.1), the complement of the DNA string *AAAACCCGGT*
    is *TTTTGGGCCA*. I then reverse this string (reading from the 3'-end) to get *ACCGGGTTTT*
    as the reverse complement.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0301](assets/mpfb_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. The reverse complement of DNA is the complement read from the opposite
    direction
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Although you can find many existing tools to generate the reverse complement
    of DNA—and I’ll drop a spoiler alert that the final solution will use a function
    from the Biopython library—the point of writing our own algorithm is to explore
    Python. In this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to implement a decision tree using a dictionary as a lookup table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to dynamically generate a list or a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `reversed()` function, which is an example of an iterator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Python treats strings and lists similarly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a list comprehension to generate a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `str.maketrans()` and `str.translate()` to transform a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Biopython’s `Bio.Seq` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That the real treasure is the friends you make along the way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code and tests for this program are in the *03_revc* directory. To get
    a feel for how the program will work, change into that directory and copy the
    first solution to a program called `revc.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program with `--help` to read the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The program wants `DNA` and will print the reverse complement, so I’ll give
    it a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As the help indicates, the program will also accept a file as input. The first
    test input has the same string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So the output should be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I want to make the specs for the program just a little harder, so the tests
    will pass both a mix of uppercase and lowercase. The output should respect the
    case of the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run **`pytest`** (or **`make test`**) to see what kinds of tests the program
    should pass. When you’re satisfied you have a feel for what the program should
    do, start anew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `get_args()` function until the program will print the preceding usage.
    Then modify your program so that it will echo back input either from the command
    line or from an input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the test suite, you should find your program passes the first three
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The program is being passed the input string `AAAACCCGGT`, and the test expects
    it to print `ACCGGGTTTT`. Since the program is echoing the input, this test fails.
    If you think you know how to write a program to satisfy these tests, have at it.
    If not, I’ll show you how to create the reverse complement of DNA, starting with
    a simple approach and working up to more elegant solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating Over a Reversed String
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating the reverse complement of DNA, it doesn’t matter if you first
    reverse the sequence and then complement it or vice versa. You will get the same
    answer either way, so I’ll start with how you can reverse a string. In [Chapter 2](ch02.html#ch02),
    I showed how you can use a string slice to get a portion of a string. If you leave
    out the start position, it will start from the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you leave out the stop position, it will go to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you leave out both start and stop, it will return a copy of the entire string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It also takes an optional third argument to indicate the step size. I can use
    no arguments for the start and stop, and a step of `-1` to reverse the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Python also has a built-in `reversed()` function, so I’ll try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Surprise! You were probably expecting to see the string `TGGCCCAAAA`. If you
    read `help(reversed)` in the REPL, however, you’ll see that this function will
    “Return a reverse iterator over the values of the given sequence.”
  prefs: []
  type: TYPE_NORMAL
- en: What is an *iterator*? Python’s [Functional Programming HOWTO](https://oreil.ly/dIzn3)
    describes an iterator as “an object representing a stream of data.” I’ve mentioned
    that an *iterable* is some collection of items that Python can visit individually;
    for example, the characters of a string or the elements in a list. An iterator
    is something that will generate values until it is exhausted. Just as I can start
    with the first character of a string (or the first element of a list or the first
    line of a file) and read until the end of the string (or list or file), an iterator
    can be iterated from the first value it produces until it finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the `reversed()` function is returning a promise to produce the
    reversed values as soon as it appears that you need them. This is an example of
    a *lazy* function because it waits until forced to do any work. One way to coerce
    the values from `reversed()` is to use a function that will consume the values.
    For instance, if the only goal is to reverse the string, then I could use the
    `str.join()` function. I always feel the syntax is backward on this function,
    but you will often invoke the `str.join()` method on a string literal that is
    the element used to join the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the empty string to join the reversed characters of the DNA string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method uses the `list()` function to force `reversed()` to produce
    the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait, what happened? The `dna` variable is a string, but I got back a list—and
    not just because I used the `list()` function. The documentation for `reversed()`
    shows that the function takes a *sequence*, which means any data structure or
    function that returns one thing followed by another. In a list or iterator context,
    Python treats strings as lists of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A longer way to build up the reversed DNA sequence is to use a `for` loop to
    iterate over the reversed bases and append them to a string. First I’ll declare
    a `rev` variable, and I’ll append each base in reverse order using the `+=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the `rev` variable with the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the reversed bases of DNA.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Append the current base to the `rev` variable.
  prefs: []
  type: TYPE_NORMAL
- en: But since I still need to complement the bases, I’m not quite done.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Decision Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a total of eight complements: *A* to *T* and *G* to *C*, both upper-
    and lowercase, and then vice versa. I also need to handle the case of a character
    *not* being *A*, *C*, *G*, or *T*. I can use `if`/`elif` statements to create
    a decision tree. I’ll change my variable to `revc` since it’s now the reverse
    complement, and I’ll figure out the correct complement for each base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a variable to hold the reverse complement string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the reversed bases in the DNA string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Test each uppercase and lowercase base.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Append the complementing base to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: If the base doesn’t match any of these tests, use the base as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you inspect the `revc` variable, it appears to be correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to incorporate these ideas into a program that will pass
    the test suite. To understand what exactly is expected of your program, take a
    look at the *tests/revc_test.py* file. After you pass the `test_uppercase()` function,
    see what is expected by `test_lowercase()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program using lowercase and uppercase DNA strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The exit value should be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The output from the program should be the indicated string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next tests will pass filenames rather than strings as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `TEST1` tuple is a file of input and a file of expected output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with the filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the exit value is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Open and read the expected file and compare that to the output.
  prefs: []
  type: TYPE_NORMAL
- en: It’s equally important to read and understand the testing code as it is to learn
    how to write the solutions. When you write your programs, you may find you can
    copy many of the ideas from these tests and save yourself time.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the algorithm in the preceding section will produce the correct answer,
    it is not an elegant solution. Still, it’s a place to start that passes the tests.
    Now that you perhaps have a better idea of the challenge, it’s time to refactor
    the program. Some of the solutions I present are as short as one or two lines
    of code. Here are some ideas you might consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a dictionary as a lookup table instead of the `if`/`elif` chain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrite the `for` loop as a list comprehension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `str.translate()` method to complement the bases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `Bio.Seq` object and find the method that will do this for you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no hurry to read ahead. Take your time to try other solutions. I haven’t
    introduced all these ideas yet, so I encourage you to research any unknowns and
    see if you can figure them out on your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'I remember one of my teachers in music school sharing this quote with me:'
  prefs: []
  type: TYPE_NORMAL
- en: Then said a teacher, Speak to us of Teaching.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And he said:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No man can reveal to you aught but that which already lies half asleep in the
    dawning of your knowledge.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The teacher who walks in the shadow of the temple, among his followers, gives
    not of his wisdom but rather of his faith and his lovingness.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If he is indeed wise he does not bid you enter the house of his wisdom, but
    rather leads you to the threshold of your own mind.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kahlil Gibran
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the solutions share the same `get_args()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The only argument to the program is a string of DNA.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Handle the case when reading a file input.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Return an `Args` object in compliance with the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 1: Using a for Loop and Decision Tree'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is my first solution using the `if`/`else` decision tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a variable to hold the reverse complement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through the reversed bases of the DNA argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `if`/`elif` decision tree to determine each base’s complement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Print the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 2: Using a Dictionary Lookup'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I mentioned that the `if`/`else` chain is something you should try to replace.
    That is 18 lines of code (LOC) that could be represented more easily using a dictionary
    lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If I use a `for` loop to iterate through a string of DNA, I can use the `dict.get()`
    method to safely request each base in a string of DNA to create the complement
    (see [Figure 3-1](#fig_3.1)). Note that I will use the `base` as the optional
    second argument to `dict.get()`. If the base doesn’t exist in the lookup table,
    then I’ll default to using the base as is, just like the `else` case from the
    first solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I can create a `complement` variable to hold the new string I generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You saw before that using the `reversed()` function on a string will return
    a list of the characters of the string in reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'I can use the `str.join()` function to create a new string from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When I put all these ideas together, the `main()` function becomes significantly
    shorter. It also becomes easier to expand because adding a new branch to the decision
    tree only requires adding a new key/value pair to the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a dictionary showing how to translate one base to its complement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a variable to hold the DNA complement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through each base in the DNA string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Append the translation of the base or the base itself to the complement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse the complement and join the results on an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python strings and lists are somewhat interchangeable. I can change the `complement`
    variable to a list, and nothing else in the program changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the complement to an empty list instead of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am highlighting here that the `+=` operator works with both strings and lists
    to append a new value at the end. There is also a `list.append()` method which
    does the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `reversed()` function works just as well on a list as it does a string.
    It’s somewhat remarkable to me that using two different types for the `complement`
    results in so few changes to the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 3: Using a List Comprehension'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I suggested that you use a list comprehension without telling you what that
    is. If you’ve never used one before, it’s essentially a way to write a `for` loop
    inside the square brackets (`[]`) used to create a new list (see [Figure 3-2](#fig_3.2)).
    When the goal of a `for` loop is to build up a new string or list, it makes much
    more sense to use a list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0302](assets/mpfb_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. A list comprehension uses a `for` loop to generate a new list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This shortens the three lines to initialize a `complement` and loop through
    the string of DNA down to one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the `for` loop with a list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `complement` variable is only used once, I might even shorten this
    further by using the list comprehension directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is acceptable because the line is shorter than the maximum of 79 characters
    recommended by PEP8, but it’s not as readable as the longer version. You should
    use whatever version you feel is most immediately understandable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 4: Using str.translate()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html#ch02), I used the `str.replace()` method to substitute
    all the *T*s with *U*s when transcribing DNA to RNA. Could I use that here? Let’s
    try. I’ll start by initializing the DNA string and replacing the *A*s with *T*s.
    Remember that strings are *immutable*, meaning I can’t change a string in place,
    but rather must overwrite the string with a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s look at the DNA string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you see where this has started to go wrong? I’ll complement the *T*s to
    *A*s now, and see if you can spot the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As shown in [Figure 3-3](#fig_3.3), all the *A*s that turned into *T*s in the
    first move were just changed back to *A*s. Oh, that way madness lies.
  prefs: []
  type: TYPE_NORMAL
- en: '![mpfb 0303](assets/mpfb_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Iteratively using `str.replace()` leads to double replacements
    of values and the wrong answer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Fortunately, Python has the `str.translate()` function for exactly this purpose.
    If you read **`help(str.translate)`**, you will find the function requires a table
    “which must be a mapping of Unicode ordinals to Unicode ordinals, strings, or
    `None`.” The `trans` dictionary table will serve, but first, it must be passed
    to the `str.maketrans()` function to transform the complement table into a form
    that uses the *ordinal* values of the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the string key `A` was turned into the integer value `65`,
    which is the same value returned by the `ord()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This value represents the ordinal position of the character *A* in the ASCII
    (American Standard Code for Information Interchange, pronounced *as-key*) table.
    That is, *A* is the 65^(th) character in the table. The `chr()` function will
    reverse this process, providing the character represented by an ordinal value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `str.translate()` function requires the complement table to have ordinal
    values for the keys, which is what I get from `str.maketrans()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I need to reverse the complement. Here is a solution that incorporates
    all these ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the translation table needed for the `str.translate()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Complement the DNA using the `trans` table. Reverse, and join for a new string.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, wait—there’s more! There’s another even shorter way to write this. According
    to the `help(str.translate)` documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: If there is only one argument, it must be a dictionary mapping Unicode ordinals
    (integers) or characters to Unicode ordinals, strings or `None`. Character keys
    will be then converted to ordinals. *If there are two arguments, they must be
    strings of equal length, and in the resulting dictionary, each character in `x`
    will be mapped to the character at the same position in `y`.*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So I can remove the `trans` dictionary and write the entire solution like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Make the translation table using two strings of equal lengths.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create the reverse complement.
  prefs: []
  type: TYPE_NORMAL
- en: If you wanted to ruin someone’s day—and in all likelihood, that person will
    be future you—you could even condense this into a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution 5: Using Bio.Seq'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I told you at the beginning of this chapter that the final solution would involve
    an existing function.^([1](ch03.html#idm45963636070440)) Many Python programmers
    working in bioinformatics have contributed to a set of modules under the name
    of [Biopython](https://biopython.org). They have written and tested many incredibly
    useful algorithms, and it rarely makes sense to write your own code when you can
    use someone else’s.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be sure that you have first installed `biopython` by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'I could import the entire module using `import Bio`, but it makes much more
    sense to only import the code I need. Here I only need the `Seq` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I can use the `Seq.reverse_complement()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This final solution is the version I would recommend, as it is the shortest
    and also uses existing, well-tested, documented modules that are almost ubiquitous
    in bioinformatics with Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_reverse_complement_of_dna___span_class__keep_together__string_manipulation__span__CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `Bio.Seq.reverse_complement()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run `mypy` on this solution (you *are* running `mypy` on every one
    of your programs, right?), you may get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To silence this error, you can tell `mypy` to ignore imported files that are
    missing type annotations. In the [root directory of the GitHub repository for
    this book](https://oreil.ly/RpMgV), you will find a file called *mypy.ini* with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Adding a *mypy.ini* file to any working directory allows you to make changes
    to the defaults that `mypy` uses *when you run it in the same directory*. If you
    would like to make this a global change so that `mypy` will use this no matter
    what directory you are in, then put this same content into *$HOME/.mypy.ini*.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Manually creating the reverse complement of DNA is something of a rite of passage.
    Here’s what I showed:'
  prefs: []
  type: TYPE_NORMAL
- en: You can write a decision tree using a series of `if`/`else` statements or by
    using a dictionary as a lookup table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings and lists are very similar. Both can be iterated using a `for` loop,
    and the `+=` operator can be used to append to both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list comprehension uses a `for` loop to iterate a sequence and generate a
    new list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reversed()` function is a lazy function that will return an iterator of
    the elements of a sequence in reverse order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `list()` function in the REPL to coerce lazy functions, iterators,
    and generators to generate their values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `str.maketrans()` and `str.translate()` functions can perform string substitution
    and generate a new string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ord()` function returns the ordinal value of a character, and conversely,
    the `chr()` function returns the character for a given ordinal value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Biopython is a collection of modules and functions specific to bioinformatics.
    The preferred way to create the reverse complement of DNA is to use the `Bio.Seq.reverse_complement()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch03.html#idm45963636070440-marker)) This is kind of like how my high
    school calculus teacher spent a week teaching us how to perform manual derivatives,
    then showed us how it could be done in 20 seconds by pulling down the exponent
    and yada yada yada.
  prefs: []
  type: TYPE_NORMAL
