- en: Chapter 12\. Delivering the Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.xhtml#chapter_heavy_scraping) showed how to grab your data
    of interest from the web with a web scraper. We used Scrapy to fetch a dataset
    of Nobel Prize winners and then in Chapters [9](ch09.xhtml#chapter_cleaning) and
    [11](ch11.xhtml#chapter_pandas_exploring) we cleaned and explored the Nobel Prize
    dataset using pandas.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show you how to deliver data statically or dynamically from
    a Python server to JavaScript on the client browser, using our Nobel Prize dataset
    as an example. This data is stored in the JSON format and consists of a list of
    Nobel Prize–winner objects like the one shown in [Example 12-1](#delivery_JSON).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1\. Our Nobel Prize JSON data, scraped and then cleaned
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As with the rest of this book, the emphasis will be on minimizing the amount
    of web development so you can get down to the business of building the web visualization
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A good rule of thumb is to aim to do as much data manipulation as possible with
    Python—it’s much less painful than equivalent operations in JavaScript. Following
    from this, the data delivered should be as close as possible to the form it will
    be consumed in (i.e., for D3 this will usually be a JSON array of objects, such
    as the one we produced in [Chapter 9](ch09.xhtml#chapter_cleaning)).
  prefs: []
  type: TYPE_NORMAL
- en: Serving the Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll need a web server to process HTTP requests from the browser, for the
    initial static HTML and CSS files used to build the web page, and for any subsequent
    AJAX requests for data. During development, this server will typically be running
    on a port of localhost (on most systems this has an IP address of 127.0.0.1).
    Conventionally, an *index.xhtml* HTML file is used to initialize the website or,
    in our case, the [single-page application (SPA)](https://oreil.ly/23h3Y) constituting
    our web visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Serving your SPA with a single-line server can be fine for visualization prototyping
    and sketching out ideas but gives you no control over even basic server functionality,
    such as URL routing or the use of dynamic templates. Thankfully, Python has a
    great little web server that provides all the functionality a web visualizer could
    need without sacrificing our aim to minimize the boilerplate standing between
    our Python-processed data and JavaScripted visualization masterwork. Flask is
    the mini web server in question and a worthy addition to our best-of-breed toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing Your Flask Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to organize your project files is one of those really useful bits of information
    that is often neglected in tutorials and the like, possibly because things can
    get opinionated fast and at the end of the day, it’s a personal preference. Nevertheless,
    good file organization can really pay off, especially when you start collaborating.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 12-1](#file_structure) gives a rough idea of where your files should
    go as you move from the basic dataviz JavaScript prototype using a one-line server
    labeled `basic`, through a more complex project labeled `basic+`, to a typical,
    simple Flask setup labeled `flask_project`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1201](assets/dpj2_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Organizing your server project files
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The key thing with file organization is consistency. It helps enormously to
    have the position of files in your procedural memory.
  prefs: []
  type: TYPE_NORMAL
- en: Serving Data with Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re using Python’s Anaconda packages (see [Chapter 1](ch01.xhtml#chapter_install)),
    then Flask is already available to you. Otherwise, a simple `pip` install should
    make it available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the Flask modules in hand, we can set up a server with a few lines to
    serve the universal programming greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_delivering_the_data_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Flask routes allow you to direct your web traffic. This is the root route (i.e.,
    *http://localhost:8000*).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_delivering_the_data_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the localhost port the server will run on (default 5000). In debug mode,
    Flask will provide useful logging to screen and in the event of an error, a browser-based
    report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, just go to the directory containing *nobel_viz.py* and run the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can now go to your web browser of choice and see the emphatic result shown
    in [Figure 12-2](#delivery_hello_world).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1202](assets/dpj2_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. A simple message served to the browser
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we’ll see in [“Dynamic Data with Flask APIs”](#dynamic_data), pattern matching
    with Flask routing makes it trivial to roll out a simple web API. It’s also easy
    to use templates to generate dynamic web pages as shown in [Figure 12-4](#flask_hello_world).
    Templates can be useful in visualizations for composing essentially static HTML
    pages server-side, but generally you’ll be delivering a simple HTML backbone on
    which to build a visualization with JavaScript. With the visualization being configured
    in JavaScript, the chief job of the server (aside from delivering the static files
    needed to seed the process) is to dynamically negotiate data (usually providing
    it) with the browser’s and JavaScript AJAX requests.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1204](assets/dpj2_1204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4\. (1) An index.xhtml template is used to create a web page using
    a *message* variable, which is then (2) served to the browser
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Flask is perfectly capable of delivering full websites, with powerful HTML templating,
    [blueprints](https://oreil.ly/Y1PxL) for modularizing large sites and supporting
    common usage patterns, and a slew of useful plug-ins and extensions. [The Flask
    user’s guide](https://oreil.ly/aoqYy) is a good starting point for learning more,
    and the API specifics can be found [in this subsection of the guide](https://oreil.ly/kpFpw).
    The single-page apps that characterize most web visualizations don’t need a lot
    of bells and whistles server-side to deliver the necessary static files. Our key
    interest in Flask is its ability to provide simple, efficient data servers, with
    robust RESTful web APIs available in a few lines of Python. But before dipping
    our toes in data APIs, let’s look at how we deliver and use file-based data assets
    such as JSON and CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering Data Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many websites that don’t need the overhead of dynamically configured data choose
    to deliver their data in a *static* form, which essentially means that all the
    HTML files and, crucially, data (usually in JSON or CSV format), exist as files
    on the server’s filesystem, ready to be delivered without, for example, making
    calls to a database.
  prefs: []
  type: TYPE_NORMAL
- en: Static pages are easy to cache, meaning their delivery can be much faster. It
    can also be more secure, as those database calls can be a common attack vector
    for nefarious hackers (e.g., [injection attacks](https://oreil.ly/SY92s)). The
    price paid for this increased speed and security is a loss of flexibility. Being
    limited to a set of preassembled pages means prohibiting user interactions that
    might demand multivariate combinations of data.
  prefs: []
  type: TYPE_NORMAL
- en: For the budding data visualizer, there is an attraction in supplying static
    data. You can easily create a standalone project without needing a web API and
    are able to deliver your work (in progress) as a single folder of HTML, CSS, and
    JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest example of data-driven web visualizations with static files is
    probably that seen in the many cool D3 examples at [*https://bl.ocks.org/mbostock*](https://bl.ocks.org/mbostock).^([1](ch12.xhtml#idm45607760514784))
    They follow a similar structure to the basic page we discussed in [“A Basic Page
    with Placeholders”](ch04.xhtml#webdev101_basic_page).
  prefs: []
  type: TYPE_NORMAL
- en: Although the examples use `<script>` and `<style>` tags to embed JavaScript
    and CSS in the HTML page, I’d recommend keeping your CSS and JavaScript in separate
    files, where you get the advantages of a decent format-aware editor and easier
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 12-2](#delivery_static_source) shows such an *index.xhtml* basic page
    with `<h2>` and `<div>` data placeholders and a `<script>` tag that loads a local
    *script.js* file. As we’re only setting the `font-family` style, we’ll inline
    the CSS in the page. With our *nobel_winners.json* dataset in a *data* subdirectory,
    this gives us the following file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Example 12-2\. A basic HTML page with data placeholders
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The static data file for these examples consists of a single JSON file (*nobel_winners.json*)
    sitting in a *data* subdirectory. Consuming this data requires a JavaScript [AJAX](https://oreil.ly/5w6MQ)
    call to our server. D3 provides convenient libraries for making AJAX calls, with
    D3’s format-specific `json`, `csv`, and `tsv` methods being handier for web visualizers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 12-3](#delivery_d3json) shows how to load data with D3’s `json` method
    using a callback function. Behind the scenes, D3 is using JavaScript’s [Fetch
    API](https://oreil.ly/D5wut) to fetch the data. This returns a JavaScript [Promise](https://oreil.ly/K570a),
    which can be resolved using its `then` method, returning the data unless an error
    has occurred.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-3\. Using D3’s `json` method to load data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_delivering_the_data_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript’s [`JSON.stringify` method](https://oreil.ly/65ZTd) is a handy way
    to prettify a JavaScript object for output. Here we insert some whitespace to
    indent the output by four spaces.
  prefs: []
  type: TYPE_NORMAL
- en: If you run a one-line server (e.g., `python -m http.server`) in your *viz* directory
    and open the localhost page in your web browser, you should see something similar
    to [Figure 12-5](#delivery_browser_json), indicating the data has been successfully
    delivered to JavaScript, ready to be visualized.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1205](assets/dpj2_1205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5\. Delivering JSON to the browser
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The *nobel_winners.json* dataset we’re using isn’t particularly large, but
    if we were to start adding biographical body text or other textual data, it could
    easily grow to a size that strains available browser bandwidth and starts to make
    the user wait uncomfortably. One strategy to limit loading times is to break the
    data down into subsets based on one of the dimensions. An obvious way to do this
    with our data is to store the winners by country. A few lines of pandas does the
    job of creating a suitable *data* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_delivering_the_data_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Groups the winners DataFrame by `country` and iterates over the group name and
    members.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should give us a `winners_by_country` *data* subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now consume our data by country using a little tailor-made function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function call will select all the Australian Nobel Prize winners,
    producing [Figure 12-6](#delivery_oz):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![dpj2 1206](assets/dpj2_1206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-6\. Selecting winners by country
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For the right visualization, the ability to select winners by country could
    reduce the data bandwidth and subsequent lag, but what if we wanted winners by
    year or gender? Each division by dimension (categorical, temporal, etc.) would
    require its own subdirectory, creating a mess of files and all the bookkeeping
    that entails. What if we wanted to make fine-grained requests for data (e.g.,
    all US prize winners since 2000)? At this point, we need a data server that can
    respond dynamically to such requests, usually driven by user interaction. The
    next section will show you how to start crafting such a server with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Data with Flask APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delivering data to web pages with JSON or CSV files is the basis for many of
    the most impressive dataviz examples seen on the web and is perfect for small
    demos and prototypes. But there are constraints to the form, most obviously in
    the size of the datasets that can be realistically delivered. As the datasets
    increase in size and the files start to tip into megabytes, page loading slows
    down and user frustration mounts with every spin of the spinner. For much dataviz,
    particularly dashboards or exploratory charts, it makes sense to deliver the data
    as needed and in response to user requests generated by a user interface of some
    form. For this kind of data delivery a small data server is often perfect for
    the job, and Python’s Flask has everything you need to craft one of these.
  prefs: []
  type: TYPE_NORMAL
- en: If we’re delivering data dynamically, we’re going to need some kind of API to
    enable our JavaScript to request data.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Data API with Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Dataset (see [“Easier SQL with Dataset”](ch03.xhtml#dataset)), we can
    easily adapt our existing server for an SQL database. Here we use Dataset for
    convenience and the specialized JSON encoder (see [Example 3-2](ch03.xhtml#data_json_time))
    to convert Python datatimes to a JSON-friendly ISO string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_delivering_the_data_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Restricts our database queries to keys in this list.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_delivering_the_data_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`request.args` gives us access to the arguments of the request (e.g., `''?country=Australia&category=Chemistry''`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_delivering_the_data_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`dataset`’s `find` method requires our argument dictionary to be unpacked with
    ** (i.e., `find(country=''Australia'', category=''Literature'')`). We convert
    the iterator to a list, ready to serialize.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_delivering_the_data_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the specialized JSON encoder detailed in [Example 3-2](ch03.xhtml#data_json_time).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this little API with [curl](https://curl.se) after starting the
    server (`python server_sql.py`). Let’s get all Japanese Physics prizewinners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You’ve now seen how easy it is to start creating a simple API. There are lots
    of ways one can extend it, but for fast and dirty prototyping, this is a handy
    little form.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you want pagination, authentication, and a host of other things
    a sophisticated RESTful API would provide? In the next chapter, we’ll see how
    easy it is to extend our simple data API into something more powerful and extendible,
    using some brilliant Python libraries like marmalade.
  prefs: []
  type: TYPE_NORMAL
- en: Using Static or Dynamic Delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When to use static or dynamic delivery is highly dependent on context and is
    an inevitable compromise. Bandwidths vary regionally and with devices. For example,
    if you’re developing a visualization that should be accessible from a smartphone
    in a rural context, the data constraints are very different from those of an in-house
    data app running on a local network.
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate guide is user experience. If a little wait at the beginning while
    the data caches leads to a lightning-fast JavaScript dataviz, then purely static
    delivery may well be the answer. If you are allowing the user to cut and slice
    a large, multivariate dataset, then this probably won’t be possible without an
    annoyingly long wait time. As a rough rule of thumb, any dataset less than 200
    KB should be fine with purely static delivery. As you move into the megabytes
    of data and beyond, you’ll probably need a database-driven API from which to fetch
    your data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained the rudiments of static data delivery of files on the
    web server, and dynamic delivery of data, sketching the basis of a simple Flask-based
    RESTful web server. Although Flask makes rolling a basic data API pretty trivial,
    adding such bells and whistles as pagination, selective data queries, and the
    full complement of HTTP verbs requires a little more work. In the first edition
    of this book I turned to some off-the-shelf Python RESTful libraries, but these
    tend to have a short expiry date, probably because it’s so easy to string together
    some single-purpose Python libraries to achieve the same end, with more flexibility.
    It’s also a great way to learn those tools, so building just such a RESTful API
    is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch12.xhtml#idm45607760514784-marker)) Mike Bostock, D3’s creator, is a
    big advocate of examples. Here’s a [great talk](https://oreil.ly/QsMfK) where
    he emphasizes the role examples have played in the success of D3.
  prefs: []
  type: TYPE_NORMAL
