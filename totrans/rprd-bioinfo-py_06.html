<html><head></head><body><section data-pdf-bookmark="Chapter 5. Computing GC Content: Parsing FASTA and Analyzing Sequences" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch05">&#13;
<h1><span class="label">Chapter 5. </span>Computing GC Content: Parsing FASTA <span class="keep-together">and Analyzing Sequences</span></h1>&#13;
&#13;
&#13;
<p>In <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>, you counted all the bases in a string of DNA.<a data-primary="base frequencies" data-see="tetranucleotide frequency" data-type="indexterm" id="idm45963635184216"/>&#13;
In this exercise, you need to count the <em>G</em>s and <em>C</em>s in a sequence and divide by the length of the sequence to <a data-primary="GC content determination" data-secondary="about" data-type="indexterm" id="idm45963635182120"/>determine the GC content as described on <a href="https://oreil.ly/gv8V7">the Rosalind GC page</a>.&#13;
GC content is informative in several ways.&#13;
A higher GC content level indicates a relatively higher melting temperature in molecular biology, and DNA sequences that encode proteins tend to be found in GC-rich regions.&#13;
There are many ways to solve this problem, and they all start with using Biopython to parse a FASTA file, a key file format in bioinformatics.&#13;
I’ll show you how to use the <code>Bio.SeqIO</code> module to iterate over the sequences in the file to identify the sequence with the highest GC content.</p>&#13;
&#13;
<p>You will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to parse FASTA format using <code>Bio.SeqIO</code></p>&#13;
</li>&#13;
<li>&#13;
<p>How to read <code>STDIN</code> (pronounced <em>standard in</em>)</p>&#13;
</li>&#13;
<li>&#13;
<p>Several ways to express the notion of a <code>for</code> loop using list comprehensions, <span class="keep-together"><code>filter()</code></span>, and <code>map()</code></p>&#13;
</li>&#13;
<li>&#13;
<p>How to address runtime challenges such as memory allocation when parsing large files</p>&#13;
</li>&#13;
<li>&#13;
<p>More about the <code>sorted()</code> function</p>&#13;
</li>&#13;
<li>&#13;
<p>How to include formatting instructions in format strings</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use the <code>sum()</code> function to add a list of numbers</p>&#13;
</li>&#13;
<li>&#13;
<p>How to use regular expressions to count the occurrences of a pattern in a string</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963635167192">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>All the code and tests for this program are in the <em>05_gc</em> directory.&#13;
While I’d like to name this program <code>gc.py</code>, it turns out that this conflicts with a very important Python module called <a href="https://oreil.ly/7eNBw"><code>gc.py</code></a> which is used for garbage collection, such as freeing memory.&#13;
Instead, I’ll use <code>cgc.py</code> for <em>calculate GC</em>.</p>&#13;
<div data-type="warning" epub:type="warning">&#13;
<p>If I called my program <code>gc.py</code>, my code would <em>shadow</em> the built-in <code>gc</code> module, making it unavailable.<a data-primary="Python" data-secondary="name causing shadowing of built-in" data-type="indexterm" id="idm45963635160696"/><a data-primary="functions" data-secondary="name causing shadowing of built-in" data-type="indexterm" id="idm45963635159736"/> Likewise, I can create variables and functions with names like <code>len</code> or <code>dict</code> which would shadow those built-in functions. This will cause many bad things to happen, so it’s best to avoid these names. Programs like <code>pylint</code> and <code>flake8</code> can find problems like this.</p>&#13;
</div>&#13;
&#13;
<p>Start by copying the first solution and asking for the usage:<a data-primary="GC content determination" data-secondary="input" data-tertiary="file input" data-type="indexterm" id="ch05-GCin"/><a data-primary="file input" data-secondary="optional positional argument" data-type="indexterm" id="idm45963635154472"/><a data-primary="input for program" data-secondary="STDIN" data-type="indexterm" id="ch05-GCin2"/><a data-primary="GC content determination" data-secondary="input" data-tertiary="STDIN" data-type="indexterm" id="ch05-GCin3"/><a data-primary="STDIN (standard in)" data-secondary="default if file argument empty" data-type="indexterm" id="ch05-GCin4"/></p>&#13;
&#13;
<pre data-type="programlisting">$ cp solution1_list.py cgc.py&#13;
$ ./cgc.py -h&#13;
usage: cgc.py [-h] [FILE] <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
Compute GC content&#13;
&#13;
positional arguments:&#13;
  FILE        Input sequence file (default: &lt;_io.TextIOWrapper <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
              name='&lt;stdin&gt;' mode='r' encoding='utf-8'&gt;)&#13;
&#13;
optional arguments:&#13;
  -h, --help  show this help message and exit</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Note that the positional <code>[FILE]</code> is in square brackets to indicate that it is optional.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This is a rather ugly message that is trying to explain that the default input is <code>STDIN</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>As in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, this program expects a file as input and will reject invalid or unreadable files.&#13;
To illustrate this second point, create an empty file using <code>touch</code> and then use <code>chmod</code> (change mode) to set the permissions to <code>000</code> (all read/write/execute bits off):</p>&#13;
&#13;
<pre data-type="programlisting">$ touch cant-touch-this&#13;
$ chmod 000 cant-touch-this</pre>&#13;
&#13;
<p>Notice that the error message specifically tells me that I lack permission to read the file:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./cgc.py cant-touch-this&#13;
usage: cgc.py [-h] [FILE]&#13;
cgc.py: error: argument FILE: can't open 'cant-touch-this': [Errno 13]&#13;
Permission denied: 'cant-touch-this'</pre>&#13;
&#13;
<p>Now run the program with valid input and observe that the program prints the ID of the record having the highest percentage of GC:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./cgc.py tests/inputs/1.fa&#13;
Rosalind_0808 60.919540</pre>&#13;
&#13;
<p>This program can also read from <code>STDIN</code>.<a data-primary="GC content determination" data-secondary="input" data-tertiary="STDOUT piped to STDIN" data-type="indexterm" id="idm45963635125960"/>&#13;
Simply because I think it’s fun, I’ll show you how, in the <code>bash</code> shell, I can use the pipe operator (<code>|</code>) to route the <code>STDOUT</code> from one program to the <code>STDIN</code> of another program.<a data-primary="STDOUT (standard out)" data-secondary="piped to STDIN" data-type="indexterm" id="idm45963635122696"/><a data-primary="bash shell" data-secondary="STDOUT piped to STDIN" data-type="indexterm" id="idm45963635121752"/><a data-primary="Unix command line" data-secondary="STDOUT" data-type="indexterm" id="idm45963635120808"/><a data-primary="command line (Unix)" data-secondary="STDOUT" data-type="indexterm" id="idm45963635119864"/><a data-primary="| (pipe)" data-primary-sortas="# pipe" data-type="indexterm" id="idm45963635118920"/><a data-primary="pipe (|) STDOUT to STDIN" data-type="indexterm" id="idm45963635117976"/>&#13;
For instance, the <code>cat</code> program will print the contents of a file to <code>STDOUT</code>:<a data-primary="cat printing to STDOUT" data-type="indexterm" id="idm45963635116200"/><a data-primary="STDOUT (standard out)" data-secondary="cat printing to" data-type="indexterm" id="idm45963635115528"/><a data-primary="output from program" data-secondary="STDOUT" data-type="indexterm" id="idm45963635114584"/></p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.fa&#13;
&gt;Rosalind_6404&#13;
CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC&#13;
TCCCACTAATAATTCTGAGG&#13;
&gt;Rosalind_5959&#13;
CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT&#13;
ATATCCATTTGTCAGCAGACACGC&#13;
&gt;Rosalind_0808&#13;
CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC&#13;
TGGGAACCTGCGGGCAGTAGGTGGAAT</pre>&#13;
&#13;
<p>Using the pipe, I can feed this to my program:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.fa | ./cgc.py&#13;
Rosalind_0808 60.919540</pre>&#13;
&#13;
<p>I can also use the <code>&lt;</code> operator to redirect input from a file:<a data-primary="file input" data-secondary="&lt; (redirect input)" data-type="indexterm" id="idm45963635110440"/><a data-primary="&lt; (redirect input)" data-primary-sortas="# redirect input" data-type="indexterm" id="idm45963635109496"/><a data-primary="input for program" data-secondary="&lt; (redirect input)" data-type="indexterm" id="idm45963635108552"/></p>&#13;
&#13;
<pre data-type="programlisting">$ ./cgc.py &lt; tests/inputs/1.fa&#13;
Rosalind_0808 60.919540</pre>&#13;
&#13;
<p>To get started, remove this program and start over:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Compute GC content' cgc.py&#13;
Done, see new script "cgc.py".</pre>&#13;
&#13;
<p>The following shows how to modify the first part of the program to accept a single positional argument that is a valid, readable file:<a data-primary="arguments" data-secondary="valid file as" data-type="indexterm" id="idm45963635105048"/><a data-primary="file input" data-secondary="validating File arguments" data-type="indexterm" id="idm45963635104104"/></p>&#13;
&#13;
<pre data-type="programlisting">import argparse&#13;
import sys&#13;
from typing import NamedTuple, TextIO, List, Tuple&#13;
from Bio import SeqIO&#13;
&#13;
&#13;
class Args(NamedTuple):&#13;
    """ Command-line arguments """&#13;
    file: TextIO <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
&#13;
def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Compute GC content',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('file',&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('rt'), <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
                        nargs='?',&#13;
                        default=sys.stdin,&#13;
                        help='Input sequence file')&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(args.file)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The only attribute of the <code>Args</code> class is a filehandle.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create a positional file argument that, if provided, must be a readable text file.<a data-primary="arguments" data-secondary="positional" data-tertiary="as optional" data-tertiary-sortas="optional" data-type="indexterm" id="idm45963635091240"/><a data-primary="arguments" data-secondary="optional" data-tertiary="positional as" data-type="indexterm" id="idm45963635089752"/></p></dd>&#13;
</dl>&#13;
&#13;
<p>It’s rare to make a positional argument optional, but in this case, I want to either handle a single file input or read from <code>STDIN</code>.&#13;
To do this, I use <code>nargs='?'</code> to indicate that the parameter should accept zero or one argument (see <a data-type="xref" href="ch02.html#table_2.2">Table 2-2</a> in <a data-type="xref" href="ch02.html#openingOutputFiles">“Opening the Output Files”</a>) and set <code>default=sys.stdin</code>.&#13;
In <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, I mentioned that <code>sys.stdout</code> is a filehandle that is always open for writing.&#13;
Similarly, <code>sys.stdin</code> is an open filehandle from which you can always read <code>STDIN</code>.<a data-primary="STDIN (standard in)" data-type="indexterm" id="idm45963635082488"/>&#13;
This is all the code that is required to make your program read either from a file or from <code>STDIN</code>, and I think that’s rather neat and tidy.<a data-startref="ch05-GCin" data-type="indexterm" id="idm45963635081096"/><a data-startref="ch05-GCin2" data-type="indexterm" id="idm45963635080424"/><a data-startref="ch05-GCin3" data-type="indexterm" id="idm45963635079752"/><a data-startref="ch05-GCin4" data-type="indexterm" id="idm45963635079080"/></p>&#13;
&#13;
<p>Modify your <code>main()</code> to print the name of the file:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(args.file.name)</pre>&#13;
&#13;
<p>Verify that it works:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./cgc.py tests/inputs/1.fa&#13;
tests/inputs/1.fa</pre>&#13;
&#13;
<p>Run <strong><code>pytest</code></strong> to see how you’re faring.&#13;
You should pass the first three tests and fail on the fourth:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -xv&#13;
============================ test session starts ============================&#13;
....&#13;
&#13;
tests/cgc_test.py::test_exists PASSED                                 [ 20%]&#13;
tests/cgc_test.py::test_usage PASSED                                  [ 40%]&#13;
tests/cgc_test.py::test_bad_input PASSED                              [ 60%]&#13;
tests/cgc_test.py::test_good_input1 FAILED                            [ 80%]&#13;
&#13;
================================= FAILURES ==================================&#13;
_____________________________ test_good_input1 ______________________________&#13;
&#13;
    def test_good_input1():&#13;
        """ Works on good input """&#13;
&#13;
        rv, out = getstatusoutput(f'{RUN} {SAMPLE1}') <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
        assert rv == 0&#13;
&gt;       assert out == 'Rosalind_0808 60.919540' <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
E       AssertionError: assert './tests/inputs/1.fa' == 'Rosalind_0808 60.919540'&#13;
E         - Rosalind_0808 60.919540 <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
E         + ./tests/inputs/1.fa <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-4" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
tests/cgc_test.py:48: AssertionError&#13;
========================== short test summary info ==========================&#13;
FAILED tests/cgc_test.py::test_good_input1 - AssertionError: assert './tes...&#13;
!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!&#13;
======================== 1 failed, 3 passed in 0.34s ========================</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The test is running the program using the first input file.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The output is expected to be the given string.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This is the expected string.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-4" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>This is the string that was printed.</p></dd>&#13;
</dl>&#13;
&#13;
<p>So far you have created a syntactically correct, well-structured, and documented program that validates a file input, all by doing relatively little work.&#13;
Next, you need to figure out how to find the sequence with the highest GC content.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Get Parsing FASTA Using Biopython" data-type="sect2"><div class="sect2" id="idm45963635051976">&#13;
<h2>Get Parsing FASTA Using Biopython</h2>&#13;
&#13;
<p>The data from the incoming file or <code>STDIN</code> should be sequence data in FASTA format, which is a common way to represent biological sequences.<a data-primary="GC content determination" data-secondary="FASTA format for input" data-type="indexterm" id="idm45963635050120"/><a data-primary="FASTA format" data-secondary="about" data-type="indexterm" id="idm45963635049160"/>&#13;
Let’s look at the first file to understand the format:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.fa&#13;
&gt;Rosalind_6404 <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTTCCC <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
TCCCACTAATAATTCTGAGG&#13;
&gt;Rosalind_5959&#13;
CCATCGGTAGCGCATCCTTAGTCCAATTAAGTCCCTATCCAGGCGCTCCGCCGAAGGTCT&#13;
ATATCCATTTGTCAGCAGACACGC&#13;
&gt;Rosalind_0808&#13;
CCACCCTCGTGGTATGGCTAGGCATTCAGGAACCGGAGAACGCTTCAGACCAGCCCGGAC&#13;
TGGGAACCTGCGGGCAGTAGGTGGAAT</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>A FASTA record starts with a <code>&gt;</code> at the beginning of a line. The sequence ID is any following text up to the first space.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>A sequence can be any length and can span multiple lines or be placed on a single line.</p></dd>&#13;
</dl>&#13;
<div data-type="tip">&#13;
<p>The header of a FASTA file can get very ugly, very quickly. I would encourage you to download real sequences from the National Center for Biotechnology Information (NCBI) or look at the files in the <em>17_synth/tests/inputs</em> directory for more examples.</p>&#13;
</div>&#13;
&#13;
<p>While it would be fun (for certain values of fun) to teach you how to manually parse this file, I’ll go straight to using Biopython’s <code>Bio.SeqIO</code> module:<a data-primary="GC content determination" data-secondary="FASTA format for input" data-tertiary="parsing with Bio.SeqIO" data-type="indexterm" id="idm45963635033416"/><a data-primary="FASTA format" data-secondary="parsing with Bio.SeqIO" data-type="indexterm" id="idm45963635032184"/><a data-primary="Biopython library" data-secondary="Bio.SeqIO" data-tertiary="FASTA parsed" data-type="indexterm" id="idm45963635031240"/><a data-primary="FASTA format" data-secondary="GC content determination" data-type="indexterm" id="idm45963635030024"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from Bio import SeqIO&#13;
&gt;&gt;&gt; recs = SeqIO.parse('tests/inputs/1.fa', 'fasta') <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO5-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO5-1"><img alt="1" src="assets/1.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO5-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The first argument is the name of the input file. As this function can parse many different record formats, the second argument is the format of the data.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I can check the type of <code>recs</code> using <code>type()</code>, as usual:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; type(recs)&#13;
&lt;class 'Bio.SeqIO.FastaIO.FastaIterator'&gt;</pre>&#13;
&#13;
<p>I’ve shown iterators a couple of times now, even creating one in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>.&#13;
In that exercise, I used the <code>next()</code> function to retrieve the next value from the Fibonacci sequence generator.&#13;
I’ll do the same here to retrieve the first record and inspect its type:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rec = next(recs)&#13;
&gt;&gt;&gt; type(rec)&#13;
&lt;class 'Bio.SeqRecord.SeqRecord'&gt;</pre>&#13;
&#13;
<p>To learn more about a sequence record, I highly recommend you read<a data-primary="FASTA format" data-secondary="sequence records" data-type="indexterm" id="idm45963635017544"/><a data-primary="sequence records of FASTA" data-type="indexterm" id="idm45963635016600"/><a data-primary="resources" data-secondary="FASTA sequence records" data-type="indexterm" id="idm45963635015912"/> <a href="https://biopython.org/wiki/SeqRecord">the <code>SeqRecord</code> documentation</a> in addition to the documentation in the REPL, which you can view using <strong><code>help(rec)</code></strong>.&#13;
The data from the FASTA record must be <em>parsed</em>, which means discerning the meaning of the data from its syntax and structure.&#13;
If you look at <code>rec</code> in the REPL, you’ll see something that looks like a dictionary.&#13;
This output is the same as that from <code>repr(seq)</code>, which is used to “return the canonical string representation of the object”:</p>&#13;
&#13;
<pre data-type="programlisting">SeqRecord(&#13;
  seq=Seq('CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGC...AGG'), <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
  id='Rosalind_6404', <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-2"><img alt="2" src="assets/2.png"/></a>&#13;
  name='Rosalind_6404', <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-3"><img alt="3" src="assets/3.png"/></a>&#13;
  description='Rosalind_6404',&#13;
  dbxrefs=[])</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The multiple lines of the sequence are concatenated into a single sequence represented by a <code>Seq</code> object.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>ID</code> of a FASTA record is all the characters in the header starting <em>after</em> the <code>&gt;</code> and continuing up to the first space.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>SeqRecord</code> object is meant to also handle data with more fields, such as <code>name</code>, <code>description</code>, and database cross-references (<code>dbxrefs</code>). Since those fields are not present in FASTA records, the ID is duplicated for <code>name</code> and <code>description</code>, and the <code>dbxrefs</code> value is the empty list.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If you print the sequence, this information will be <em>stringified</em> so it’s a little easier to read.<a data-primary="print() function" data-secondary="FASTA sequence records" data-type="indexterm" id="idm45963634989496"/>&#13;
This output is the same as that for <code>str(rec)</code>, which is meant to provide a useful string representation of an object:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; print(rec)&#13;
ID: Rosalind_6404&#13;
Name: Rosalind_6404&#13;
Description: Rosalind_6404&#13;
Number of features: 0&#13;
Seq('CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGC...AGG')</pre>&#13;
&#13;
<p>The most salient feature for this program is the record’s sequence.&#13;
You might expect this would be a <code>str</code>, but it’s actually another object:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; type(rec.seq)&#13;
&lt;class 'Bio.Seq.Seq'&gt;</pre>&#13;
&#13;
<p>Use <strong><code>help(rec.seq)</code></strong> to see what attributes and methods the <code>Seq</code> object offers.&#13;
I only want the DNA sequence itself, which I can get by coercing the sequence to a string using the <code>str()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; str(rec.seq)&#13;
'CCTGCGGAAGATCGGCACTAGAATAGCCAGAACCGTTTCTCTGAGGCTTCCGGCCTT...AGG'</pre>&#13;
&#13;
<p>Note this is the same class I used in the last solution of <a data-type="xref" href="ch03.html#ch03">Chapter 3</a> to create a reverse complement.&#13;
I can use it here like so:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; rec.seq.reverse_complement()&#13;
Seq('CCTCAGAATTATTAGTGGGAGGGAAGGCCGGAAGCCTCAGAGAAACGGTTCTGG...AGG')</pre>&#13;
&#13;
<p>The <code>Seq</code> object has many other useful methods, and I encourage you to explore the documentation as these can save you a lot of time.<sup><a data-type="noteref" href="ch05.html#idm45963634979240" id="idm45963634979240-marker">1</a></sup>&#13;
At this point, you may feel you have enough information to finish the challenge.&#13;
You need to iterate through all the sequences, determine what percentage of the bases are <em>G</em> or <em>C</em>, and return the ID and GC content of the record with the maximum value.&#13;
I would challenge you to write a solution on your own.&#13;
If you need more help, I’ll show you one approach, and then I’ll cover several variations in the solutions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterating the Sequences Using a for Loop" data-type="sect2"><div class="sect2" id="idm45963634976856">&#13;
<h2>Iterating the Sequences Using a for Loop</h2>&#13;
&#13;
<p>So far I’ve shown that <code>SeqIO.parse()</code> accepts a filename as the first argument, but the <code>args.file</code> argument will be an open filehandle.&#13;
Luckily, the function will also accept this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from Bio import SeqIO&#13;
&gt;&gt;&gt; recs = SeqIO.parse(open('./tests/inputs/1.fa'), 'fasta')</pre>&#13;
&#13;
<p>I can use a <code>for</code> loop to iterate through each record to print the ID and the first 10 bases of each sequence:<a data-primary="Biopython library" data-secondary="Bio.SeqIO" data-tertiary="iterating through records" data-type="indexterm" id="idm45963634972760"/><a data-primary="GC content determination" data-secondary="FASTA format for input" data-tertiary="iterating through records" data-type="indexterm" id="idm45963634971528"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for rec in recs:&#13;
...     print(rec.id, rec.seq[:10])&#13;
...&#13;
Rosalind_6404 CCTGCGGAAG&#13;
Rosalind_5959 CCATCGGTAG&#13;
Rosalind_0808 CCACCCTCGT</pre>&#13;
&#13;
<p>Take a moment to run those lines again and notice that nothing will be printed:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for rec in recs:&#13;
...     print(rec.id, rec.seq[:10])&#13;
...</pre>&#13;
&#13;
<p>Earlier I showed that <code>recs</code> is a <code>Bio.SeqIO.FastaIO.FastaIterator</code>, and, like all iterators, it will produce values until exhausted.&#13;
If you want to loop through the records again, you will need to recreate the <code>recs</code> object using the <code>SeqIO.parse()</code> function.</p>&#13;
&#13;
<p>For the moment, assume the sequence is this:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'CCACCCTCGTGGTATGGCT'</pre>&#13;
&#13;
<p>I need to find how many <em>C</em>s and <em>G</em>s occur in that string.&#13;
I can use another <code>for</code> loop to iterate each base of the sequence and increment a counter whenever the base is a <em>G</em> or a <em>C</em>:</p>&#13;
&#13;
<pre data-type="programlisting">gc = 0 <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
for base in seq: <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
    if base in ('G', 'C'): <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-3"><img alt="3" src="assets/3.png"/></a>&#13;
        gc += 1 <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-4" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize a variable for the counts of the <em>G/C</em> bases.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate each base (character) in the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>See if the base is in the tuple containing <code>G</code> or <code>C</code>.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-4" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Increment the GC counter.</p></dd>&#13;
</dl>&#13;
&#13;
<p>To find the percentage of GC content, divide the GC count by the length of the sequence:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; gc&#13;
12&#13;
&gt;&gt;&gt; len(seq)&#13;
19&#13;
&gt;&gt;&gt; gc / len(seq)&#13;
0.631578947368421</pre>&#13;
&#13;
<p>The output from the program should be the ID of the sequence with the highest <code>GC</code> count, a single space, and the GC content truncated to six significant digits.<a data-primary="GC content determination" data-secondary="output as formatted number" data-type="indexterm" id="idm45963634937800"/><a data-primary="strings (str)" data-secondary="formatting" data-type="indexterm" id="idm45963634936824"/><a data-primary="output from program" data-secondary="formatted number" data-type="indexterm" id="idm45963634935880"/>&#13;
The easiest way to format the number is to learn more about <code>str.format()</code>.&#13;
The <code>help</code> doesn’t have much in the way of documentation, so I recommend you read <a href="https://oreil.ly/OIpEq">PEP 3101</a> on advanced string formatting.<a data-primary="strings (str)" data-secondary="formatting" data-tertiary="online guide to string formatting" data-type="indexterm" id="idm45963634933032"/><a data-primary="resources" data-secondary="string formatting online guide" data-type="indexterm" id="idm45963634931800"/></p>&#13;
&#13;
<p>In <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>, I showed how I can use <code>{}</code> as placeholders for interpolating variables either using <code>str.format()</code> or f-strings.<a data-primary="{} (curly brackets for string formatting)" data-primary-sortas="# curly brackets" data-type="indexterm" id="idm45963634928600"/><a data-primary="curly brackets ({}) for string formatting" data-type="indexterm" id="idm45963634927624"/><a data-primary="format() function for strings" data-type="indexterm" id="idm45963634926920"/><a data-primary="f-strings for formatted output" data-type="indexterm" id="idm45963634926232"/><a data-primary="strings (str)" data-secondary="formatting" data-tertiary="f-string" data-type="indexterm" id="idm45963634925544"/><a data-primary="print() function" data-secondary="formatted output" data-tertiary="f-string" data-type="indexterm" id="idm45963634924328"/>&#13;
I can add formatting instructions after a colon (<code>:</code>) in the curly brackets.&#13;
The syntax looks like that used with the <code>printf()</code> function in C-like languages, so <code>{:0.6f}</code> is a floating-point number to six places:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; '{:0.6f}'.format(gc * 100 / len(seq))&#13;
'63.157895'</pre>&#13;
&#13;
<p>Or, to execute the code directly inside an f-string:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; f'{gc * 100 / len(seq):0.06f}'&#13;
'63.157895'</pre>&#13;
&#13;
<p>To figure out the sequence with the maximum <code>GC</code> count, you have a couple of options, both of which I’ll demonstrate in the solutions:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Make a list of all the IDs and their GC content (a list of tuples would serve well). Sort the list by GC content and take the maximum value.</p>&#13;
</li>&#13;
<li>&#13;
<p>Keep track of the ID and GC content of the maximum value. Overwrite this when a new maximum is found.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>I think that should be enough for you to finish a solution.&#13;
You can do this.&#13;
Fear is the mind killer.&#13;
Keep going until you pass <em>all</em> the tests, including those for linting and type checking.&#13;
Your test output should look something like this:</p>&#13;
&#13;
<pre data-type="programlisting">$ make test&#13;
python3 -m pytest -xv --disable-pytest-warnings --flake8 --pylint&#13;
--pylint-rcfile=../pylintrc --mypy cgc.py tests/cgc_test.py&#13;
=========================== test session starts ===========================&#13;
...&#13;
collected 10 items&#13;
&#13;
cgc.py::FLAKE8 SKIPPED                                              [  9%]&#13;
cgc.py::mypy PASSED                                                 [ 18%]&#13;
tests/cgc_test.py::FLAKE8 SKIPPED                                   [ 27%]&#13;
tests/cgc_test.py::mypy PASSED                                      [ 36%]&#13;
tests/cgc_test.py::test_exists PASSED                               [ 45%]&#13;
tests/cgc_test.py::test_usage PASSED                                [ 54%]&#13;
tests/cgc_test.py::test_bad_input PASSED                            [ 63%]&#13;
tests/cgc_test.py::test_good_input1 PASSED                          [ 72%]&#13;
tests/cgc_test.py::test_good_input2 PASSED                          [ 81%]&#13;
tests/cgc_test.py::test_stdin PASSED                                [ 90%]&#13;
::mypy PASSED                                                       [100%]&#13;
================================== mypy ===================================&#13;
&#13;
Success: no issues found in 2 source files&#13;
====================== 9 passed, 2 skipped in 1.67s =======================</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963634912488">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>As before, all the solutions share the same <code>get_args()</code>, so only the differences will be shown.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Using a List" data-type="sect2"><div class="sect2" id="idm45963634910520">&#13;
<h2>Solution 1: Using a List</h2>&#13;
&#13;
<p>Let’s look at my first solution.<a data-primary="GC content determination" data-secondary="solution 1 using a list" data-type="indexterm" id="ch05-sol1"/>&#13;
I always try to start with the most obvious and simple way, and you’ll find this is often the most verbose.&#13;
Once you understand the logic, I hope you’ll be able to follow more powerful and terse ways to express the same ideas.&#13;
For this first solution, be sure to also import <code>List</code> and <code>Tuple</code> from the <code>typing</code> <span class="keep-together">module:</span></p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    seqs: List[Tuple[float, str]] = [] <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    for rec in SeqIO.parse(args.file, 'fasta'): <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-2"><img alt="2" src="assets/2.png"/></a>&#13;
        gc = 0 <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-3"><img alt="3" src="assets/3.png"/></a>&#13;
        for base in rec.seq.upper(): <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-4" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-4"><img alt="4" src="assets/4.png"/></a>&#13;
            if base in ('C', 'G'): <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-5" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-5"><img alt="5" src="assets/5.png"/></a>&#13;
                gc += 1 <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-6" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-6"><img alt="6" src="assets/6.png"/></a>&#13;
        pct = (gc * 100) / len(rec.seq) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-7" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-7"><img alt="7" src="assets/7.png"/></a>&#13;
        seqs.append((pct, rec.id)) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-8" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-8"><img alt="8" src="assets/8.png"/></a>&#13;
&#13;
    high = max(seqs) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-9" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-9"><img alt="9" src="assets/9.png"/></a>&#13;
    print(f'{high[1]} {high[0]:0.6f}') <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-10" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-10"><img alt="10" src="assets/10.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize an empty list to hold the GC content and sequence IDs as tuples.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through each record in the input file.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Initialize a GC counter.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-4" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Iterate through each sequence, uppercased to guard against possible mixed-case input.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-5" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Check if the base is a <em>C</em> or <em>G</em>.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-6" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Increment the GC counter.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-7" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Calculate the GC content.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-8" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Append a new tuple of the GC content and the sequence ID.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-9" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>Take the maximum value.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-10" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO8-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>Print the sequence ID and GC content of the highest value.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The type annotation <code>List[Tuple[float, str]]</code> on the <code>seqs</code> variable provides not only a way <a data-primary="reproducible programs" data-secondary="documentation provided by tests" data-type="indexterm" id="idm45963634853784"/><a data-primary="type annotation on variable" data-type="indexterm" id="idm45963634852824"/><a data-primary="variables" data-secondary="type annotation on" data-type="indexterm" id="idm45963634852136"/><a data-primary="test-driven development (TDD)" data-secondary="documentation provided by" data-type="indexterm" id="idm45963634851192"/><a data-primary="documentation" data-secondary="tests providing" data-type="indexterm" id="idm45963634850216"/><a data-primary="best practices" data-secondary="documentation provided by tests" data-type="indexterm" id="idm45963634849272"/>to programmatically check the code using tools like <code>mypy</code> but also an added layer of documentation. The reader of this code doesn’t have to jump ahead to see what kind of data will be added to the list because it has been explicitly described using types.</p>&#13;
</div>&#13;
&#13;
<p>In this solution, I decided to make a list of all the IDs and GC percentages mostly so that I could show you how to create a list of tuples.&#13;
Then I wanted to point out a few magical properties of Python’s sorting.&#13;
Let’s start with the <code>sorted()</code> function, which works on strings as you might imagine:<a data-primary="sorted() function" data-type="indexterm" id="idm45963634846168"/><a data-primary="strings (str)" data-secondary="sorted() function" data-type="indexterm" id="idm45963634845496"/><a data-primary="integers (int)" data-secondary="sorted() function" data-type="indexterm" id="idm45963634844552"/><a data-primary="GC content determination" data-secondary="solution 1 using a list" data-tertiary="sorted() function" data-type="indexterm" id="idm45963634843608"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sorted(['McClintock', 'Curie', 'Doudna', 'Charpentier'])&#13;
['Charpentier', 'Curie', 'Doudna', 'McClintock']</pre>&#13;
&#13;
<p>When all the values are numbers, they will be sorted numerically, so I’ve got that going for me, which is nice:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sorted([2, 10, 1])&#13;
[1, 2, 10]</pre>&#13;
&#13;
<p>Note that those same values <em>as strings</em> will sort in lexicographic order:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sorted(['2', '10', '1'])&#13;
['1', '10', '2']</pre>&#13;
<aside class="pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45963634838440">&#13;
<h5>Python Lists Should Be Homogeneous</h5>&#13;
<p>Comparing different types, such as strings and integers, will cause an exception:<a data-primary="errors" data-secondary="sorted() with mixed types" data-type="indexterm" id="idm45963634836792"/><a data-primary="type error" data-secondary="sorted() with mixed types" data-type="indexterm" id="idm45963634835832"/><a data-primary="lists" data-secondary="types should not be mixed" data-type="indexterm" id="idm45963634834872"/><a data-primary="type() function" data-secondary="list member types should not be mixed" data-type="indexterm" id="idm45963634833912"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sorted([2, '10', 1])&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
TypeError: '&lt;' not supported between instances of 'str' and 'int'</pre>&#13;
&#13;
<p>While it’s an acceptable practice in Python to mix types in a list, it’s likely to end in tears.&#13;
This reminds me of a joke by Henny Youngman:<a data-primary="Youngman, Henny" data-type="indexterm" id="idm45963634831512"/>&#13;
A man goes to see his doctor.&#13;
He says, “Doc, it hurts when I do this.”&#13;
The doctor says, “Then don’t do that.”</p>&#13;
&#13;
<p>Essentially my advice is a bit like the doctor’s: yeah, you can mix types in lists in Python, but doing so will lead to runtime exceptions if you try to sort them, so just don’t do that.&#13;
To avoid this, always use a type declaration to describe your data:</p>&#13;
&#13;
<pre data-type="programlisting">seqs: List[Tuple[float, str]] = []</pre>&#13;
&#13;
<p>Try adding this line:</p>&#13;
&#13;
<pre data-type="programlisting">seqs.append('foo')</pre>&#13;
&#13;
<p>Then check the program using <code>mypy</code> to see how clearly the error message shows how this violates the description of the data:</p>&#13;
&#13;
<pre data-type="programlisting">$ mypy solution1_list.py&#13;
solution1_list.py:38: error: Argument 1 to "append" of "list" has&#13;
incompatible type "str"; expected "Tuple[float, str]"&#13;
Found 1 error in 1 file (checked 1 source file)</pre>&#13;
&#13;
<p>Another option is to use the <code>numpy</code> module to create an <em>array</em>, which is like a Python list but where all the values are required (and coerced) to be of a common type.<a data-primary="NumPy module" data-secondary="arrays" data-type="indexterm" id="idm45963634824632"/><a data-primary="type() function" data-secondary="array values same type" data-type="indexterm" id="idm45963634823688"/><a data-primary="arrays" data-type="indexterm" id="idm45963634822744"/><a data-primary="lists" data-secondary="arrays versus" data-type="indexterm" id="idm45963634822072"/>&#13;
Arrays in <code>numpy</code> are both faster (due to memory management) and safer than Python lists.&#13;
Note that mixing strings and numbers will result in a list of strings:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import numpy as np&#13;
&gt;&gt;&gt; nums = np.array([2, '10', 1])&#13;
&gt;&gt;&gt; nums&#13;
array(['2', '10', '1'], dtype='&lt;U21')</pre>&#13;
&#13;
<p>Although this is not correct—I want them to be integers—it is at least safe.&#13;
I can use the <code>int()</code> function in a list comprehension to coerce all the values to integers:<a data-primary="list comprehension" data-secondary="string values to integers" data-type="indexterm" id="idm45963634818568"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [int(n) for n in [2, '10', 1]]&#13;
[2, 10, 1]</pre>&#13;
&#13;
<p>Or the same thing expressed using the higher-order function <code>map()</code>, <a data-primary="map() function transforming" data-type="indexterm" id="idm45963634815912"/><a data-primary="strings (str)" data-secondary="map() for converting types" data-seealso="map() function" data-type="indexterm" id="idm45963634815224"/><a data-primary="type() function" data-secondary="map() for converting types" data-type="indexterm" id="idm45963634813992"/><a data-primary="integers (int)" data-secondary="map() for converting types" data-type="indexterm" id="idm45963634813032"/>which takes a function like <code>int()</code> as the first argument and applies it to all the elements in the sequence to return a new list of elements transformed by that function:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(map(int, [2, '10', 1]))&#13;
[2, 10, 1]</pre>&#13;
&#13;
<p>Which makes for good sorting:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sorted(map(int, [2, '10', 1]))&#13;
[1, 2, 10]</pre>&#13;
</div></aside>&#13;
&#13;
<p>Now consider a list of tuples where the first element is a <code>float</code> and the second element is a <code>str</code>.&#13;
How will <code>sorted()</code> handle this?<a data-primary="GC content determination" data-secondary="solution 1 using a list" data-tertiary="sorted() function" data-type="indexterm" id="idm45963634807336"/><a data-primary="sorted() function" data-type="indexterm" id="idm45963634806104"/><a data-primary="strings (str)" data-secondary="sorted() function" data-type="indexterm" id="idm45963634805432"/><a data-primary="integers (int)" data-secondary="sorted() function" data-type="indexterm" id="idm45963634804488"/>&#13;
By first sorting all the data by the first elements <em>numerically</em> and then the second elements <em>lexicographically</em>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sorted([(0.2, 'foo'), (.01, 'baz'), (.01, 'bar')])&#13;
[(0.01, 'bar'), (0.01, 'baz'), (0.2, 'foo')]</pre>&#13;
&#13;
<p>Structuring <code>seqs</code> as <code>List[Tuple[float, str]]</code> takes advantage of this built-in behavior of <code>sorted()</code>, allowing me to quickly sort the sequences by GC content and select the highest value:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; high = sorted(seqs)[-1]</pre>&#13;
&#13;
<p>This is the same as finding the highest value, which the <code>max()</code> function can do more easily:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; high = max(seqs)</pre>&#13;
&#13;
<p><code>high</code> is a tuple where the first position is the sequence ID and the zeroth position is the GC content that needs to be formatted:<a data-startref="ch05-sol1" data-type="indexterm" id="idm45963634796488"/></p>&#13;
&#13;
<pre data-type="programlisting">print(f'{high[1]} {high[0]:0.6f}')</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Type Annotations and Unit Tests" data-type="sect2"><div class="sect2" id="idm45963634794760">&#13;
<h2>Solution 2: Type Annotations and Unit Tests</h2>&#13;
&#13;
<p>Hidden inside the <code>for</code> loop is a kernel of code to compute GC content that needs to be extracted into a function with a test.<a data-primary="GC content determination" data-secondary="solution 2 type annotations and unit tests" data-type="indexterm" id="ch05-sol2"/><a data-primary="unit testing" data-secondary="GC content determination" data-type="indexterm" id="ch05-sol22"/>&#13;
Following the ideas of test-driven development (TDD), I will first define a <code>find_gc()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">def find_gc(seq: str) -&gt; float: <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Calculate GC content """&#13;
&#13;
    return 0. <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function accepts a <code>str</code> and returns a <code>float</code>.<a data-primary="floating point return value" data-type="indexterm" id="idm45963634780952"/></p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>For now, I return <code>0</code>. Note the trailing <code>.</code> tells Python this is a <code>float</code>. This is shorthand for <code>0.0</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Next, I’ll define a function that will serve as a unit test.&#13;
Since I’m using <code>pytest</code>, this function’s name must start with <code>test_</code>.&#13;
Because I’m testing the <code>find_gc()</code> function, I’ll name the function <code>test_find_gc</code>.&#13;
I will use a series of <code>assert</code> statements to test if the function returns the expected result for a given input.&#13;
Note how this test function serves both as a formal test and as an additional piece of documentation, as the reader can see the inputs and outputs:<a data-primary="test-driven development (TDD)" data-secondary="documentation provided by" data-type="indexterm" id="idm45963634772520"/><a data-primary="best practices" data-secondary="documentation provided by tests" data-type="indexterm" id="idm45963634771544"/><a data-primary="reproducible programs" data-secondary="documentation provided by tests" data-type="indexterm" id="idm45963634770584"/></p>&#13;
&#13;
<pre data-type="programlisting">def test_find_gc():&#13;
    """ Test find_gc """&#13;
&#13;
    assert find_gc('') == 0. <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-1"><img alt="1" src="assets/1.png"/></a>&#13;
    assert find_gc('C') == 100. <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert find_gc('G') == 100. <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-3"><img alt="3" src="assets/3.png"/></a>&#13;
    assert find_gc('CGCCG') == 100. <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-4" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-4"><img alt="4" src="assets/4.png"/></a>&#13;
    assert find_gc('ATTAA') == 0.&#13;
    assert find_gc('ACGT') == 50.</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>If a function accepts a <code>str</code>, I always start by testing with the empty string to make sure it returns something useful.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>A single <code>C</code> should be 100% GC.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Same for a single <code>G</code>.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-4" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO10-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Various other tests mixing bases at various percentages.</p></dd>&#13;
</dl>&#13;
&#13;
<p>It’s rarely possible to exhaustively check every possible input to a function, so I often rely on spot-checking.&#13;
Note that the <a href="https://hypothesis.readthedocs.io/en/latest"><code>hypothesis</code> module</a> can generate random values for testing.<a data-primary="test-driven development (TDD)" data-secondary="hypothesis module random test values" data-type="indexterm" id="idm45963634745960"/><a data-primary="hypothesis module for random test values" data-type="indexterm" id="idm45963634744984"/>&#13;
Presumably, the <code>find_gc()</code> function is simple enough that these tests are sufficient.&#13;
My goal in writing functions is to make them as simple as possible, but no simpler. As Tony Hoare says, “There are two ways to write code: write code so simple there are obviously no bugs in it, or write code so complex that there are no obvious bugs in it.”<a data-primary="Hoare, Tony" data-type="indexterm" id="idm45963634743368"/></p>&#13;
&#13;
<p>The <code>find_gc()</code> and <code>test_find_gc()</code> functions are inside the <code>cgc.py</code> program, not in the <em>tests/cgc_test.py</em> module.&#13;
To execute the unit test, I run <code>pytest</code> on the source code <em>expecting the test to fail</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -v cgc.py&#13;
============================ test session starts ============================&#13;
...&#13;
&#13;
cgc.py::test_find_gc FAILED                                           [100%] <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
================================= FAILURES ==================================&#13;
__________________________________ test_gc __________________________________&#13;
&#13;
    def test_find_gc():&#13;
        """ Test find_gc """&#13;
&#13;
        assert find_gc('') == 0. <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-2"><img alt="2" src="assets/2.png"/></a>&#13;
&gt;       assert find_gc('C') == 100. <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-3"><img alt="3" src="assets/3.png"/></a>&#13;
E       assert 0 == 100.0&#13;
E         +0&#13;
E         -100.0&#13;
&#13;
cgc.py:74: AssertionError&#13;
========================== short test summary info ==========================&#13;
FAILED cgc.py::test_gc - assert 0 == 100.0&#13;
============================= 1 failed in 0.32s =============================</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The unit test fails as expected.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The first test passes because it was expecting <code>0</code>.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO11-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This test fails because it should have returned <code>100</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now I have established a baseline from which I can proceed.&#13;
I know that my code fails to meet some expectation as formally defined using a test.&#13;
To fix this, I move all the relevant code from <code>main()</code> into the function:</p>&#13;
&#13;
<pre data-type="programlisting">def find_gc(seq: str) -&gt; float:&#13;
    """ Calculate GC content """&#13;
&#13;
    if not seq: <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-1"><img alt="1" src="assets/1.png"/></a>&#13;
        return 0 <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    gc = 0 <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-3"><img alt="3" src="assets/3.png"/></a>&#13;
    for base in seq.upper():&#13;
        if base in ('C', 'G'):&#13;
            gc += 1&#13;
&#13;
    return (gc * 100) / len(seq)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This guards against trying to divide by 0 when the sequence is the empty string.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>If there is no sequence, the GC content is 0.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO12-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This is the same code as before.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Then I run <code>pytest</code> again to check that the function works:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -v cgc.py&#13;
============================ test session starts ============================&#13;
...&#13;
&#13;
cgc.py::test_gc PASSED                                                [100%]&#13;
&#13;
============================= 1 passed in 0.30s =============================</pre>&#13;
&#13;
<p class="pagebreak-before">This is TDD:<a data-primary="test-driven development (TDD)" data-secondary="about process of" data-type="indexterm" id="idm45963634702600"/></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Define a function to test.</p>&#13;
</li>&#13;
<li>&#13;
<p>Write the test.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ensure the function fails the test.</p>&#13;
</li>&#13;
<li>&#13;
<p>Make the function work.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ensure the function passes the test (and all your previous tests still pass).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If I later encounter sequences that trigger bugs in my code, I’ll fix the code and add those as more tests.&#13;
I shouldn’t have to worry about weird cases like the <code>find_gc()</code> function receiving a <code>None</code> or a list of integers <em>because I used type annotations</em>.<a data-primary="type annotation on variable" data-type="indexterm" id="idm45963634694664"/><a data-primary="variables" data-secondary="type annotation on" data-type="indexterm" id="idm45963634693976"/>&#13;
Testing is useful.&#13;
Type annotations are useful.&#13;
Combining tests and types leads to code that is easier to verify and comprehend.</p>&#13;
&#13;
<p>I want to make one other addition to this solution: a custom type to document the tuple holding the GC content and sequence ID.<a data-primary="named tuples data structure" data-secondary="output as" data-type="indexterm" id="idm45963634692200"/><a data-primary="GC content determination" data-secondary="output as formatted number" data-type="indexterm" id="idm45963634691240"/><a data-primary="output from program" data-secondary="formatted number" data-type="indexterm" id="idm45963634690264"/>&#13;
I’ll call it <code>MySeq</code> just to avoid any confusion with the <code>Bio.Seq</code> class.&#13;
I add this below the <code>Args</code> definition:</p>&#13;
&#13;
<pre data-type="programlisting">class MySeq(NamedTuple):&#13;
    """ Sequence """&#13;
    gc: float <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-1"><img alt="1" src="assets/1.png"/></a>&#13;
    name: str <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The GC content is a percentage.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO13-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>I would prefer to use the field name <code>id</code>, but that conflicts with the <code>id()</code> <em>identity</em> function which is built into Python.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here is how it can be incorporated into the code:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    seqs: List[MySeq] = [] <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    for rec in SeqIO.parse(args.file, 'fasta'):&#13;
        seqs.append(MySeq(find_gc(rec.seq), rec.id)) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-2"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
    high = sorted(seqs)[-1] <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-3"><img alt="3" src="assets/3.png"/></a>&#13;
    print(f'{high.name} {high.gc:0.6f}') <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-4" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use <code>MySeq</code> as a type annotation.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Create <code>MySeq</code> using the return value from the <code>find_gc()</code> function and the record ID. <br/><br/></p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This still works because <code>MySeq</code> is a tuple.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-4" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO14-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Use the field access rather than the index position of the tuple.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This version of the program is arguably easier to read.&#13;
You can and should create as many custom types as you want to better document and test your code.<a data-startref="ch05-sol2" data-type="indexterm" id="idm45963634651960"/><a data-startref="ch05-sol22" data-type="indexterm" id="idm45963634651288"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: Keeping a Running Max Variable" data-type="sect2"><div class="sect2" id="idm45963634650296">&#13;
<h2>Solution 3: Keeping a Running Max Variable</h2>&#13;
&#13;
<p>The previous solution works well, but it’s a bit verbose and needlessly keeps track of <em>all</em> the sequences when I only care about the maximum value.<a data-primary="GC content determination" data-secondary="solution 3 running max" data-type="indexterm" id="idm45963634648392"/>&#13;
Given how small the test inputs are, this will never be a problem, but bioinformatics is always about scaling up.&#13;
A solution that tries to store all the sequences will eventually choke.&#13;
Consider processing 1 million sequences, or 1 billion, or 100 billion.&#13;
Eventually, I’d run out of memory.</p>&#13;
&#13;
<p>Here’s a solution that would scale to any number of sequences, as it only ever allocates a single tuple to remember the highest value:<a data-primary="GC content determination" data-secondary="solution 3 running max" data-tertiary="scalable" data-type="indexterm" id="idm45963634646424"/><a data-primary="scalability" data-secondary="GC content determination" data-type="indexterm" id="idm45963634645192"/></p>&#13;
&#13;
<pre data-type="programlisting">def main():&#13;
    args = get_args()&#13;
    high = MySeq(0., '') <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
    for rec in SeqIO.parse(args.file, 'fasta'):&#13;
        pct = find_gc(rec.seq) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-2"><img alt="2" src="assets/2.png"/></a>&#13;
        if pct &gt; high.gc: <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-3"><img alt="3" src="assets/3.png"/></a>&#13;
            high = MySeq(pct, rec.id) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-4" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    print(f'{high.name} {high.gc:0.6f}') <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-5" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize a variable to remember the highest value. Type annotation is superfluous as <code>mypy</code> will expect this variable to remain this type forever.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Calculate the GC content.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>See if the percent GC is greater than the highest value.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-4" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>If so, overwrite the highest value using this percent GC and sequence ID.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-5" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO15-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Print the highest value.</p></dd>&#13;
</dl>&#13;
&#13;
<p>For this solution, I also took a slightly different approach to compute the <code>GC</code> content:</p>&#13;
&#13;
<pre data-type="programlisting">def find_gc(seq: str) -&gt; float:&#13;
    """ Calculate GC content """&#13;
&#13;
    return (seq.upper().count('C') + <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-1"><img alt="1" src="assets/1.png"/></a>&#13;
            seq.upper().count('G')) * 100 / len(seq) if seq else 0 <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use the <code>str.count()</code> method to find the <code>C</code>s and <code>G</code>s in the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO16-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Since there are two conditions for the state of the sequence—the empty string or not—I prefer to write a single <code>return</code> using an <code>if</code> expression.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I’ll benchmark the last solution against this one.&#13;
First I need to generate an input file with a significant number of sequences, say 10K.&#13;
In the <em>05_gc</em> directory, you’ll find a <code>genseq.py</code> file similar to the one I used in the <em>02_rna</em> directory.&#13;
This one generates a FASTA file:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./genseq.py -h&#13;
usage: genseq.py [-h] [-l int] [-n int] [-s sigma] [-o FILE]&#13;
&#13;
Generate long sequence&#13;
&#13;
optional arguments:&#13;
  -h, --help            show this help message and exit&#13;
  -l int, --len int     Average sequence length (default: 500)&#13;
  -n int, --num int     Number of sequences (default: 1000)&#13;
  -s sigma, --sigma sigma&#13;
                        Sigma/STD (default: 0.1)&#13;
  -o FILE, --outfile FILE&#13;
                        Output file (default: seqs.fa)</pre>&#13;
&#13;
<p>Here’s how I’ll generate an input file:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./genseq.py -n 10000 -o 10K.fa&#13;
Wrote 10,000 sequences of avg length 500 to "10K.fa".</pre>&#13;
&#13;
<p>I can use that with <code>hyperfine</code> to compare these two implementations:</p>&#13;
&#13;
<pre data-type="programlisting">$ hyperfine -L prg ./solution2_unit_test.py,./solution3_max_var.py '{prg} 10K.fa'&#13;
Benchmark #1: ./solution2_unit_test.py 10K.fa&#13;
  Time (mean ± σ):      1.546 s ±  0.035 s    [User: 2.117 s, System: 0.147 s]&#13;
  Range (min … max):    1.511 s …  1.625 s    10 runs&#13;
&#13;
Benchmark #2: ./solution3_max_var.py 10K.fa&#13;
  Time (mean ± σ):     368.7 ms ±   3.0 ms    [User: 957.7 ms, System: 137.1 ms]&#13;
  Range (min … max):   364.9 ms … 374.7 ms    10 runs&#13;
&#13;
Summary&#13;
  './solution3_max_var.py 10K.fa' ran&#13;
    4.19 ± 0.10 times faster than './solution2_unit_test.py 10K.fa'</pre>&#13;
&#13;
<p>It would appear that the third solution is about four times faster than the second running on 10K sequences.&#13;
You can try generating more and longer sequences for your own benchmarking.&#13;
I would recommend you create a file with at least one million sequences and compare your first solution with this version.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 4: Using a List Comprehension with a Guard" data-type="sect2"><div class="sect2" id="idm45963634596568">&#13;
<h2>Solution 4: Using a List Comprehension with a Guard</h2>&#13;
&#13;
<p><a data-type="xref" href="#fig_5.1">Figure 5-1</a> shows that another way to find all the <em>C</em>s and <em>G</em>s in the sequence is to use a list comprehension and the <code>if</code> comparison from the first solution, which is called a <em>guard</em>.<a data-primary="GC content determination" data-secondary="solution 4 list comprehension with guard" data-type="indexterm" id="idm45963634592664"/><a data-primary="guard" data-type="indexterm" id="idm45963634591672"/><a data-primary="if and elif decision tree" data-secondary="guard" data-type="indexterm" id="idm45963634591000"/><a data-primary="list comprehension" data-secondary="guard" data-type="indexterm" id="idm45963634590040"/><a data-primary="decision trees" data-secondary="guard" data-type="indexterm" id="idm45963634589096"/></p>&#13;
&#13;
<figure><div class="figure" id="fig_5.1">&#13;
<img alt="mpfb 0501" src="assets/mpfb_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>A list comprehension with a guard will select only those elements returning a truthy value for the <code>if</code> expression</h6>&#13;
</div></figure>&#13;
&#13;
<p>The list comprehension only yields those elements passing the guard which checks that the <code>base</code> is in the string <code>'CG'</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; gc = [base for base in 'CCACCCTCGTGGTATGGCT' if base in 'CG']&#13;
&gt;&gt;&gt; gc&#13;
['C', 'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G', 'G', 'C']</pre>&#13;
&#13;
<p>Since the result is a new list, I can use the <code>len()</code> function to find how many <code>C</code>s and <code>G</code>s are present:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; len(gc)&#13;
12</pre>&#13;
&#13;
<p>I can incorporate this idea into the <code>find_gc()</code> function:</p>&#13;
&#13;
<pre data-type="programlisting">def find_gc(seq: str) -&gt; float:&#13;
    """ Calculate GC content """&#13;
&#13;
    if not seq:&#13;
        return 0&#13;
&#13;
    gc = len([base for base in seq.upper() if base in 'CG']) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO17-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO17-1"><img alt="1" src="assets/1.png"/></a>&#13;
    return (gc * 100) / len(seq)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO17-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO17-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Another way to count the <em>C</em>s and <em>G</em>s is to select them using a list comprehension with a guard.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 5: Using the filter() Function" data-type="sect2"><div class="sect2" id="idm45963634572232">&#13;
<h2>Solution 5: Using the filter() Function</h2>&#13;
&#13;
<p>The idea of a list comprehension with a guard can be expressed with the higher-order function <code>filter()</code>.<a data-primary="GC content determination" data-secondary="solution 5 filter()" data-type="indexterm" id="idm45963634570392"/><a data-primary="filter() function" data-secondary="GC content determination" data-type="indexterm" id="idm45963634569432"/>&#13;
Earlier in the chapter I used the <code>map()</code> function to apply the <code>int()</code> function to all the elements of a list to produce a new list of integers.&#13;
The <span class="keep-together"><code>filter()</code></span> function works similarly, accepting a function as the first argument and an iterable as the second.&#13;
It’s different, though, as only those elements returning a truthy value when the function is applied will be returned.&#13;
As this is a lazy function, I will need to coerce with <code>list()</code> in the REPL:<a data-primary="lazy functions" data-secondary="filter()" data-type="indexterm" id="idm45963634565784"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; list(filter(lambda base: base in 'CG', 'CCACCCTCGTGGTATGGCT'))&#13;
['C', 'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G', 'G', 'C']</pre>&#13;
&#13;
<p>So here’s another way to express the same idea from the last solution:</p>&#13;
&#13;
<pre data-type="programlisting">def find_gc(seq: str) -&gt; float:&#13;
    """ Calculate GC content """&#13;
&#13;
    if not seq:&#13;
        return 0&#13;
&#13;
    gc = len(list(filter(lambda base: base in 'CG', seq.upper()))) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO18-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO18-1"><img alt="1" src="assets/1.png"/></a>&#13;
    return (gc * 100) / len(seq)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO18-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO18-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use <code>filter()</code> to select only those bases matching <em>C</em> or <em>G</em>.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 6: Using the map() Function and Summing Booleans" data-type="sect2"><div class="sect2" id="idm45963634555480">&#13;
<h2>Solution 6: Using the map() Function and Summing Booleans</h2>&#13;
&#13;
<p>The <code>map()</code> function is a favorite of mine, so I want to show another way to use it.<a data-primary="map() function transforming" data-secondary="GC bases into boolean" data-type="indexterm" id="idm45963634553624"/><a data-primary="booleans" data-secondary="map() transforming GC bases into" data-type="indexterm" id="idm45963634552664"/><a data-primary="GC content determination" data-secondary="solution 6 map() and summing booleans" data-type="indexterm" id="idm45963634551704"/>&#13;
I could use <code>map()</code> to turn each base into a 1 if it’s a <em>C</em> or <em>G</em>, and a <code>0</code> otherwise:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'CCACCCTCGTGGTATGGCT'&#13;
&gt;&gt;&gt; list(map(lambda base: 1 if base in 'CG' else 0, seq))&#13;
[1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0]</pre>&#13;
&#13;
<p>Counting the <em>C</em>s and <em>G</em>s would then be a matter of summing this list, which I can do using the <code>sum()</code> function:<a data-primary="sum() function" data-type="indexterm" id="idm45963634546040"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sum(map(lambda base: 1 if base in 'CG' else 0, seq))&#13;
12</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45963634544440">&#13;
<h5>Booleans Are Integers</h5>&#13;
<p>Python can use Boolean algebra to combine values like <code>True</code>/<code>False</code> using <code>and</code>/<code>or</code>:<a data-primary="booleans" data-secondary="integers" data-type="indexterm" id="idm45963634541320"/><a data-primary="integers (int)" data-secondary="booleans as" data-type="indexterm" id="idm45963634540376"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; True and False&#13;
False&#13;
&gt;&gt;&gt; True or False&#13;
True</pre>&#13;
&#13;
<p>What do you think happens if you use <code>+</code> instead of <code>and</code>?</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; True + True&#13;
2&#13;
&gt;&gt;&gt; True + False&#13;
1</pre>&#13;
&#13;
<p>It turns out that Python’s Boolean values lead a secret double life as integers, where <code>True</code> is 1 and <code>False</code> is 0.<a data-primary="True (1)" data-type="indexterm" id="idm45963634535160"/><a data-primary="False (0)" data-type="indexterm" id="idm45963634534488"/></p>&#13;
</div></aside>&#13;
&#13;
<p>I can shorten my <code>map()</code> to return the result of the comparison (which is a <code>bool</code> but also an <code>int</code>) and sum that instead:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; sum(map(lambda base: base in 'CG', seq))&#13;
12</pre>&#13;
&#13;
<p>Here is how I could incorporate this idea:</p>&#13;
&#13;
<pre data-type="programlisting">def find_gc(seq: str) -&gt; float:&#13;
    """ Calculate GC content """&#13;
&#13;
    if not seq:&#13;
        return 0&#13;
&#13;
    gc = sum(map(lambda base: base in 'CG', seq.upper())) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO19-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO19-1"><img alt="1" src="assets/1.png"/></a>&#13;
    return (gc * 100) / len(seq)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO19-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO19-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Transform the sequence into Boolean values based on their comparison to the bases <em>C</em> or <em>G</em>, then sum the <code>True</code> values to get a count.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 7: Using Regular Expressions to Find Patterns" data-type="sect2"><div class="sect2" id="idm45963634522536">&#13;
<h2>Solution 7: Using Regular Expressions to Find Patterns</h2>&#13;
&#13;
<p>So far I’ve been showing you multiple ways to manually iterate a sequence of characters in a string to pick out those matching <code>C</code> or <code>G</code>.<a data-primary="GC content determination" data-secondary="solution 7 regular expression" data-type="indexterm" id="idm45963634520200"/><a data-primary="regular expressions (regexes)" data-secondary="GC content determination" data-type="indexterm" id="idm45963634519224"/>&#13;
This is pattern matching, and it’s precisely what regular expressions do.&#13;
The cost to you is learning another domain-specific language (DSL), but this is well worth the effort as regexes are widely used outside of Python.&#13;
Begin by importing the <code>re</code> module:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; import re</pre>&#13;
&#13;
<p>You should read <strong><code>help(re)</code></strong>, as this is a fantastically useful module.<a data-primary="regular expressions (regexes)" data-secondary="help(re) for documentation" data-type="indexterm" id="idm45963634515624"/>&#13;
I want to use the <code>re.findall()</code> function to find all occurrences of a pattern in a string.<a data-primary="regular expressions (regexes)" data-secondary="findall()" data-type="indexterm" id="idm45963634513992"/><a data-primary="re" data-see="regular expressions" data-type="indexterm" id="idm45963634513032"/>&#13;
I can create a <em>character class</em> pattern for the regex engine by using square brackets to enclose any characters I want to include.<a data-primary="regular expressions (regexes)" data-secondary="character class patterns" data-type="indexterm" id="idm45963634511400"/>&#13;
The class <code>[GC]</code> means <em>match either G or C</em>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; re.findall('[GC]', 'CCACCCTCGTGGTATGGCT')&#13;
['C', 'C', 'C', 'C', 'C', 'C', 'G', 'G', 'G', 'G', 'G', 'C']</pre>&#13;
&#13;
<p>As before, I can use the <code>len()</code> function to find how many <code>C</code>s and <code>G</code>s there are.&#13;
The following code shows how I would incorporate this into my function.&#13;
Note that I use the <code>if</code> expression to return <code>0</code> if the sequence is the empty string so I can avoid division when <code>len(seq)</code> is <code>0</code>:</p>&#13;
&#13;
<pre data-type="programlisting">def find_gc(seq: str) -&gt; float:&#13;
    """ Calculate GC content """&#13;
&#13;
    return len(re.findall('[GC]', seq.upper()) * 100) / len(seq) if seq else 0</pre>&#13;
&#13;
<p>Note that it’s important to change how this function is called from <code>main()</code> to explicitly coerce the <code>rec.seq</code> value (which is a <code>Seq</code> object) to a string by using <code>str()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    high = MySeq(0., '')&#13;
&#13;
    for rec in SeqIO.parse(args.file, 'fasta'):&#13;
        pct = find_gc(str(rec.seq)) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO20-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO20-1"><img alt="1" src="assets/1.png"/></a>&#13;
        if pct &gt; high.gc:&#13;
            high = MySeq(pct, rec.id)&#13;
&#13;
    print(f'{high.name} {high.gc:0.6f}')</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO20-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO20-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Coerce the sequence to a string value or the <code>Seq</code> object will be passed.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 8: A More Complex find_gc() Function" data-type="sect2"><div class="sect2" id="idm45963634494408">&#13;
<h2>Solution 8: A More Complex find_gc() Function</h2>&#13;
&#13;
<p>In this final solution, I’ll move almost all of the code from <code>main()</code> into the <code>find_gc()</code> function.<a data-primary="GC content determination" data-secondary="solution 8 SeqRecord input" data-type="indexterm" id="idm45963634492136"/><a data-primary="input for program" data-secondary="SeqRecord object" data-type="indexterm" id="idm45963634491160"/>&#13;
I want the function to accept a <code>SeqRecord</code> object rather than a string of the sequence, and I want it to return the <code>MySeq</code> tuple.</p>&#13;
&#13;
<p>First I’ll change the tests:</p>&#13;
&#13;
<pre data-type="programlisting">def test_find_gc() -&gt; None:&#13;
    """ Test find_gc """&#13;
&#13;
    assert find_gc(SeqRecord(Seq(''), id='123')) == (0.0, '123')&#13;
    assert find_gc(SeqRecord(Seq('C'), id='ABC')) == (100.0, 'ABC')&#13;
    assert find_gc(SeqRecord(Seq('G'), id='XYZ')) == (100.0, 'XYZ')&#13;
    assert find_gc(SeqRecord(Seq('ACTG'), id='ABC')) == (50.0, 'ABC')&#13;
    assert find_gc(SeqRecord(Seq('GGCC'), id='XYZ')) == (100.0, 'XYZ')</pre>&#13;
&#13;
<p>These are essentially the same tests as before, but I’m now passing <code>SeqRecord</code> objects.&#13;
To make this work in the REPL, you will need to import a couple of classes:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from Bio.Seq import Seq&#13;
&gt;&gt;&gt; from Bio.SeqRecord import SeqRecord&#13;
&gt;&gt;&gt; seq = SeqRecord(Seq('ACTG'), id='ABC')</pre>&#13;
&#13;
<p>If you look at the object, it looks similar enough to the data I’ve been reading from input files because I only care about the <code>seq</code> field:</p>&#13;
&#13;
<pre data-type="programlisting">SeqRecord(seq=Seq('ACTG'),&#13;
  id='ABC',&#13;
  name='&lt;unknown name&gt;',&#13;
  description='&lt;unknown description&gt;',&#13;
  dbxrefs=[])</pre>&#13;
&#13;
<p>If you run <strong><code>pytest</code></strong>, your <code>test_find_gc()</code> function should fail because you haven’t yet changed your <code>find_gc()</code> function.&#13;
Here’s how I wrote it:</p>&#13;
&#13;
<pre data-type="programlisting">def find_gc(rec: SeqRecord) -&gt; MySeq: <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Return the GC content, record ID for a sequence """&#13;
&#13;
    pct = 0. <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-2"><img alt="2" src="assets/2.png"/></a>&#13;
    if seq := str(rec.seq): <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-3"><img alt="3" src="assets/3.png"/></a>&#13;
        gc = len(re.findall('[GC]', seq.upper())) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-4" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-4"><img alt="4" src="assets/4.png"/></a>&#13;
        pct = (gc * 100) / len(seq)&#13;
&#13;
    return MySeq(pct, rec.id) <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-5" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function accepts a <code>SeqRecord</code> and returns a <code>MySeq</code>.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Initialize this to a floating-point <code>0.</code>.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This syntax is new as of Python 3.8 and allows variable assignment (first) and testing (second) in one line using the <em>walrus</em> operator (<code>:=</code>).<a data-primary="variables" data-secondary=":= (assignment and testing)" data-secondary-sortas="# assignment and testing" data-type="indexterm" id="idm45963634459992"/><a data-primary=":= (variable assignment and testing)" data-primary-sortas="# variable assignment" data-type="indexterm" id="idm45963634458744"/><a data-primary="equal signs" data-secondary=":= (variable assignment and testing)" data-secondary-sortas="# variable assignment" data-type="indexterm" id="idm45963634457784"/><a data-primary="walrus operator (:=)" data-type="indexterm" id="idm45963634456552"/></p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-4" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>This is the same code as before.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-5" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO21-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Return a <code>MySeq</code> object.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note">&#13;
<p>The walrus operator <code>:=</code> was proposed in <a href="https://www.python.org/dev/peps/pep-0572">PEP 572</a>, which notes that the <code>=</code> operator allows you to name the result of an expression only in a statement form, “making it unavailable in list comprehensions and other expression contexts.” This new operator combines two actions, that of <em>assigning</em> the value of an expression to a variable and then <em>evaluating</em> that variable. In the preceding code, <code>seq</code> is assigned the value of the stringified sequence. If that evaluates to something truthy, such as a nonempty string, then the following block of code will be executed.</p>&#13;
</div>&#13;
&#13;
<p>This radically changes the <code>main()</code> function.&#13;
The <code>for</code> loop can incorporate a <code>map()</code> function to turn each <code>SeqRecord</code> into a <code>MySeq</code>:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    high = MySeq(0., '') <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-1" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-1"><img alt="1" src="assets/1.png"/></a>&#13;
    for seq in map(find_gc, SeqIO.parse(args.file, 'fasta')): <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-2" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-2"><img alt="2" src="assets/2.png"/></a>&#13;
        if seq.gc &gt; high.gc: <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-3" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-3"><img alt="3" src="assets/3.png"/></a>&#13;
            high = seq <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-4" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
    print(f'{high.name} {high.gc:0.6f}') <a class="co" href="#callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-5" id="co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-1" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Initialize the <code>high</code> variable.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-2" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use <code>map()</code> to turn each <code>SeqRecord</code> into a <code>MySeq</code>.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-3" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Compare the current sequence’s GC content against the running high.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-4" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Overwrite the value.</p></dd>&#13;
<dt><a class="co" href="#co_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-5" id="callout_computing_gc_content__parsing_fasta__span_class__keep_together__and_analyzing_sequences__span__CO22-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Print the results.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The point of the expanded <code>find_gc()</code> function was to hide more of the guts of the program so I can write a more expressive program.&#13;
You may disagree, but I think this is the most readable version of the program.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Benchmarking" data-type="sect1"><div class="sect1" id="idm45963634414024">&#13;
<h1>Benchmarking</h1>&#13;
&#13;
<p>So which one is the winner?<a data-primary="GC content determination" data-secondary="solutions benchmarked" data-type="indexterm" id="idm45963634412712"/><a data-primary="benchmarking the solutions" data-secondary="hyperfine tool for multiple runs" data-tertiary="GC content determination" data-type="indexterm" id="idm45963634411752"/><a data-primary="hyperfine tool for benchmarking" data-secondary="GC content determination" data-type="indexterm" id="idm45963634410488"/>&#13;
There is a <code>bench.sh</code> program that will run <code>hyperfine</code> on all the <code>solution*.py</code> with the <em>seqs.fa</em> file.&#13;
Here is the result:</p>&#13;
&#13;
<pre data-type="programlisting">Summary&#13;
  './solution3_max_var.py seqs.fa' ran&#13;
    2.15 ± 0.03 times faster than './solution8_list_comp_map.py seqs.fa'&#13;
    3.88 ± 0.05 times faster than './solution7_re.py seqs.fa'&#13;
    5.38 ± 0.11 times faster than './solution2_unit_test.py seqs.fa'&#13;
    5.45 ± 0.18 times faster than './solution4_list_comp.py seqs.fa'&#13;
    5.46 ± 0.14 times faster than './solution1_list.py seqs.fa'&#13;
    6.22 ± 0.08 times faster than './solution6_map.py seqs.fa'&#13;
    6.29 ± 0.14 times faster than './solution5_filter.py seqs.fa'</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963634406008">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>Try writing a FASTA parser.&#13;
Create a new directory called <em>faparser</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir faparser</pre>&#13;
&#13;
<p>Change into that directory, and run <strong><code>new.py</code></strong> with the <code>-t|--write_test</code> option:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd faparser/&#13;
$ new.py -t faparser.py&#13;
Done, see new script "faparser.py".</pre>&#13;
&#13;
<p>You should now have a structure that includes a <em>tests</em> directory along with a starting test file:</p>&#13;
&#13;
<pre data-type="programlisting">$ tree&#13;
.&#13;
├── Makefile&#13;
├── faparser.py&#13;
└── tests&#13;
    └── faparser_test.py&#13;
&#13;
1 directory, 3 files</pre>&#13;
&#13;
<p>You can run <strong><code>make test</code></strong> or <strong><code>pytest</code></strong> to verify that everything at least runs.&#13;
Copy the <em>tests/inputs</em> directory from <em>05_gc</em> to the new <em>tests</em> directory so you have some test input files.&#13;
Now consider how you want your new program to work.&#13;
I would imagine it would take one (or more) readable text files as inputs, so you could define your arguments accordingly.&#13;
Then what will your program do with the data?&#13;
Do you want it to print, for instance, the IDs and the length of each sequence?&#13;
Now write the tests and code to manually parse the input FASTA files and print the output.&#13;
Challenge yourself.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963634395704">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You can read <code>STDIN</code> from the open filehandle <code>sys.stdin</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>Bio.SeqIO.parse()</code> function will parse FASTA-formatted sequence files into records, which provides access to the record’s ID and sequence.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can use several constructs to visit all the elements of iterables, including <code>for</code> loops, list comprehensions, and the functions <code>filter()</code> and <code>map()</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>A list comprehension with a guard will only produce elements that return a truthy value for the guard. This can also be expressed using the <code>filter()</code> function.</p>&#13;
</li>&#13;
<li>&#13;
<p>Avoid writing algorithms that attempt to store all the data from an input file, as you could exceed the available memory on your machine.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>sorted()</code> function will sort homogeneous lists of strings and numbers lexicographically and numerically, respectively. It can also sort homogeneous lists of tuples using each position of the tuples in order.</p>&#13;
</li>&#13;
<li>&#13;
<p>Formatting templates for strings can include <code>printf()</code>-like instructions to control how output values are presented.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>sum()</code> function will add a list of numbers.</p>&#13;
</li>&#13;
<li>&#13;
<p>Booleans in Python are actually integers.</p>&#13;
</li>&#13;
<li>&#13;
<p>Regular expressions can find patterns of text.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45963634979240"><sup><a href="ch05.html#idm45963634979240-marker">1</a></sup> As the saying goes, “Weeks of coding can save you hours of planning.”</p></div></div></section></body></html>