- en: Chapter 7\. Clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have considered the resolution of entities between two independent
    data sources: a smaller primary dataset that defines a target population to be
    matched and a much larger secondary dataset. We have also assumed that the entities
    in the primary dataset are present only once and there are no duplicates. Therefore,
    we have not sought to compare the entities in the primary dataset with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in [Chapter 5](ch05.html#chapter_5), we resolved UK MPs, as listed
    in Wikipedia, against PSCs of UK companies according to Companies House. We assumed
    that each MP would be present only once in the Wikipedia list but that they could
    have significant control over more than one company, i.e., a single Wikipedia
    entity could match against multiple PSC entities. For instance, the MP named in
    Wikipedia as Geoffrey Clifton-Brown is likely to be the same individual as the
    person with the same name listed as having significant control over the company
    with reference number 09199367\. The same applies to the companies with references
    02303726 and 13420433.
  prefs: []
  type: TYPE_NORMAL
- en: We can represent these entity relationships as a simple network with the similarly
    named individuals represented as *nodes* and the three pairwise comparisons between
    them represented as *edges*, as shown in [Figure 7-1](#fig-7-1).
  prefs: []
  type: TYPE_NORMAL
- en: Note that we didn’t evaluate the pairwise equivalence of the three named individuals
    in the PSC data with each other—we were seeking only to identify links to the
    primary Wikipedia entity. But in the process we have, by association, concluded
    that all three PSC entries are likely to refer to the same single real-world individual.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Simple person match cluster
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In practice we are often faced with multiple data sources to resolve, as well
    as potential duplication within a single source. To produce a resolved view of
    an entity, we need to gather together all the pair-matched records, grouping them
    under a single uniquely identifiable reference.
  prefs: []
  type: TYPE_NORMAL
- en: This process of assembling a collection of examples is called *clustering*.
    The clustering process doesn’t attempt to determine which example (if any) is
    correct but simply to identify the collection as a discrete bounded set whose
    members all have similar characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will examine how to employ basic clustering techniques to
    group entities together based on pairwise comparisons. We will reuse the PSC dataset
    we acquired in [Chapter 5](ch05.html#chapter_5), but first, let’s shrink the problem
    to a small scale so that we can understand the steps we need to take.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Exact Match Clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let’s consider a simple dataset of first names, last names, and year
    of birth, as shown in [Table 7-1](#table-7-1). This table contains an exact duplicate
    (IDs 0 and 1) along with several other similar records.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Simple clustering example dataset
  prefs: []
  type: TYPE_NORMAL
- en: '| **ID** | **First name** | **Last name** | **Year of birth** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Michael | Shearer | 1970 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Michael | Shearer | 1970 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Mike | Shearer | 1970 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Michael | Shearer | 1971 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Michelle | Shearer | 1971 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Mike | Sheare | 1971 |'
  prefs: []
  type: TYPE_TB
- en: Does each ID represent a separate entity or do they refer to the same person?
  prefs: []
  type: TYPE_NORMAL
- en: Based on the limited information we have, we can, for example, group by exact
    equivalence of first name and last name but not year of birth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This gives us four clusters. The entities associated with IDs 0, 1, and 3 are
    grouped together in cluster 0 as they have the exact same name spellings, whereas
    IDs 2, 4, and 5 have a unique spelling variation and are therefore assigned their
    own individual cluster, as we can see in [Figure 7-2](#fig-7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Simple exact match cluster table
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Approximate Match Clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let’s consider what happens to our cluster groupings if we include approximate
    name matching, as introduced in [Chapter 3](ch03.html#chapter_3). We can no longer
    use a simple `groupby` function to calculate our clusters, so we need to work
    through the comparison steps ourselves. This is a helpful exercise to illustrate
    the combined challenge that comes with comparing records within, and across, large
    datasets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step is to generate a table with all the potential combinations of
    record comparisons. We want to compare the record ID 0 with each of the other
    records and then the record ID 1 with the remainder, but without duplicating the
    comparison with ID 0 again (directionality isn’t important in pairwise comparisons).
    In total we have 15 comparisons: 5 for ID 0 against its peers, 4 for ID 1, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From our simple base table we can use the itertools package we introduced in
    [Chapter 3](ch03.html#chapter_3) to generate a DataFrame with composite columns
    A and B, each containing a list of the attributes to be compared drawn from our
    simple table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7-3](#fig-7-3) shows the first few rows of the DataFrame.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. Sample rows of composite match combinations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we need to create the multilevel index columns to hold the individual
    attribute values under the A and B headings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can split out the attributes and recombine the resulting columns, with
    their associated index labels, back to a single DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first few expanded rows are shown in [Figure 7-4](#fig-7-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Sample rows of approximate match combinations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now that we have our attributes prepared for pairwise evaluation, we can use
    the Jaro-Winkler similarity function introduced in [Chapter 3](ch03.html#chapter_3)
    to approximately compare the first names and last names between the A and B values.
    If both match, say with an equivalence score greater than 0.9, then we declare
    an overall match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The resulting matches are listed in [Figure 7-5](#fig-7-5). We can see that
    record ID 0 matches exactly with ID 1 and ID 3 on rows 0 and 2, respectively.
    A match is also declared on row 3 between ID 0 and ID 4 as there is sufficient
    similarity between “Michael” and “Michelle.” Note that rows 6, 7, and 12 also
    record direct matches between the remaining combinations of IDs 1, 3, and 4 independent
    of ID 0.
  prefs: []
  type: TYPE_NORMAL
- en: ID 2 also matches to ID 5 on row 11 with “Shearer” and “Sheare” being sufficiently
    similar.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. Approximate match table
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: From these results we can manually identify two clusters, the first comprising
    IDs 0, 1, 3, and 4 and the second IDs 2 and 5.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are now faced with a problem. We have allowed nonexact matches to
    cluster as a single entity. What attribute values should we now use to describe
    that resolved entity? For the first cluster, comprising IDs 0, 1, 3, and 4, should
    the first name be “Michael” or “Michelle”? IDs 0, 1, and 3 have the first name
    as “Michael” but ID 4 has it listed as “Michelle.” Is the correct year of birth
    1970 or 1971?
  prefs: []
  type: TYPE_NORMAL
- en: For the second cluster, we face the same year of birth dilemma and the question
    of whether we should use “Sheare” or “Shearer”—it’s not clear. This challenge,
    of selecting the most representative values, sometimes known as *canonicalization*,
    is a field of active study but beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Even with this simple example we can see a number of challenges and trade-offs
    we need to consider when clustering entities together. First, the number of pairwise
    comparisons grows very rapidly with number of records to be clustered. For a table
    of n rows there are n × (n–1)/2 combinations. If approximate matches are included,
    the resulting computational burden is significant and may be time-consuming to
    compute. Second, and most challenging, is how to settle on a single set of attributes
    to define a cluster when individual entities within the cluster have differing
    attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have introduced some of the challenges associated with clustering,
    let’s return to the PSC dataset to consider a larger-scale example.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Returning to our example from [Chapter 5](ch05.html#chapter_5), let’s imagine
    we wish to examine the concentration of control over UK companies, identifying
    individuals with influence over several companies. To do this, we need to cluster
    all the matching individual owner entities in the PSC dataset. Further, knowing
    the variable data quality of PSC entries, let’s consider that we want to incorporate
    approximate matches in our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: With approximately 11.5 million entries in our PSC dataset, the total number
    of comparisons we need to make is over 66 trillion. We have our work cut out here!
  prefs: []
  type: TYPE_NORMAL
- en: Data Acquisition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by picking up the raw data we downloaded in [Chapter 5](ch05.html#chapter_5).
    We’ll use a wider range of attributes for matching in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Data Standardization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our raw data, our next step is to standardize and, for simplicity,
    rename the attributes. We also drop any records where the year or month of birth
    is missing because we’ll use these as blocking values to help reduce the number
    of comparisons we need to make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Record Blocking and Attribute Comparison
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As before, we use the Splink framework to perform the comparisons, with exact
    equivalence on year, month, and last name as prediction blocking rules, i.e.,
    we only compare records against each other if there are exact matches between
    the year, month, and last name fields. Clearly, this is a trade-off as we will
    potentially miss some matches with last name inconsistencies or spelling mistakes,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for this single source example we set the `link_type` to `dedupe_only`
    instead of `link_only`. Splink supports `dedupe_only`, `link_only`, and `link_and_dedupe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also specify a convergence tolerance for the EM algorithm and set a maximum
    number of iterations to run (even if convergence has not been reached):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Data Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As before, it’s useful to have a look at the data distribution of our comparison
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in [Figure 7-6](#fig-7-6), we have the expected distribution of
    first, middle, and last names. In [Figure 7-7](#fig-7-7), we can also see that
    the distribution of title and nationality is skewed toward a small number of common
    values. [Figure 7-8](#fig-7-8) shows month of birth is fairly evenly distributed
    across the year, whereas year of birth is somewhat skewed toward the 1980s.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. First name, middle name, and last name distribution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![](assets/hoer_0707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. Title and nationality distribution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![](assets/hoer_0708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. Year and month of birth distribution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Expectation-Maximization Blocking Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the very high number of potential combinations, we need to specify the 
    blocking rules for the EM algorithm as tightly as we can to allow the process
    to complete in a reasonable timeframe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the volume of comparisons that a given blocking rule will generate
    using the `count_num_comparisons_from_blocking` function; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember that every attribute comparison level must pass the blocking rules
    (i.e., not be blocked) in at least one of the estimate parameter steps so that
    *m* and *u* values can be generated for that attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The count of comparisons that would be generated for several combinations of
    attribute blocking rules is given in [Table 7-2](#table-7-2).
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-2\. Blocking rule comparison count
  prefs: []
  type: TYPE_NORMAL
- en: '| Pair | Attribute combination blocking rule | Count of comparisons |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `l.Lastname = r.Lastname and` `l.Month = r.Month and`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l.Title = r.Title and`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l.Nationality = r.Nationality` | 777.4M |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `l.Firstname = r.Firstname and` `l.Year = r.Year and`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l.Middlename = r.Middlename` | 69.7M |'
  prefs: []
  type: TYPE_NORMAL
- en: '| 2 | `l.Lastname = r.Lastname and` `l.Middlename = r.Middlename` | 119.9M
    |'
  prefs: []
  type: TYPE_TB
- en: '| `l.Firstname = r.Firstname and` `l.Month = r.Month and`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l.Year = r.Year and`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l.Title = r.Title and`'
  prefs: []
  type: TYPE_NORMAL
- en: '`l.Nationality = r.Nationality` | 281M |'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the first pair of blocking rules requires evaluation of a large
    number of comparisons, whereas the second pair allows estimation of parameters
    for all the attributes but with a smaller overall comparison count.
  prefs: []
  type: TYPE_NORMAL
- en: First name, middle name, and last name equivalences are the most discriminating
    in reducing the comparison volumes, followed by year of birth and to a lesser
    extent month of birth. Nationality and title are not particularly helpful due
    to limited cardinality of their values, as we saw in [Figure 7-6](#fig-7-6).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can employ these blocking rules as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Computation Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even with these more optimized blocking rules, the execution of the expectation-maximization
    algorithm on a large dataset may take some time, especially if you’re running
    on a modest machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you want to skip the training step you can simply load the
    pretrained model using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Match Classification and Clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the EM step (see [Chapter 4](ch04.html#chapter_4)) is completed, we have
    a trained model to assess the similarity between the record pairs in our single
    dataset. Remember that these pairs are selected using the prediction blocking
    rules (in this case, exact last name, year, and month of birth). The threshold
    for predicting a match is set at 0.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Following pairwise prediction, Splink offers a clustering function to group
    entity pairs together when the match probability to a shared entity exceeds a
    specified threshold. Note that the clustering threshold is applied to the full
    set of pairwise combinations, not the subset that exceeds the 0.9 prediction threshold;
    i.e., records that fell below the equivalence threshold in all their comparisons,
    and thus were not paired at all, will still be present in the output, assigned
    to their own cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The resulting dataset of records, labeled with their parent cluster, can easily
    be converted to a DataFrame, the first few rows of which (sanitized to remove
    names and year and month of birth) are shown in [Figure 7-9](#fig-7-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0709.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-9\. Sample rows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can then group these rows by `cluster_id`, retaining all the different attribute
    values from each source record in a list under the associated column. In our case,
    no variation is expected on last name, month, or year of birth as we generated
    our predictions using exact equivalence of these attributes as our blocking rules.
    This gives us approximately 6.8 million unique clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the attribute variation we see within a cluster, we can select
    a subset of clusters where we have differing first names, titles, and nationalities.
    For ease of manual examination, we limit ourselves to clusters compromising exactly
    six records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the resulting sanitized table, shown in [Figure 7-10](#fig-7-10), we can
    see a selection of these clusters in tabular form.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0710.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-10\. Sample rows showing attribution variation in clusters of size
    six
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Cluster Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our PSCs clustered together, we can perform a count of the
    number of companies each entity controls and then plot the distribution of these
    values in a histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7-11](#fig-7-11) shows the resulting plot, which allows us to begin
    to answer our sample question—how concentrated is the control of UK companies?
    We can see that the majority of individuals control only a single company, with
    a smaller, but still very significant, number having influence over between 2
    and 10 firms. After that, the count falls dramatically until our data suggests
    that we have a handful of individuals with influence over more than 1,000 companies.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0711.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-11\. Histogram distribution of significant company control
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If, like me, you think the significant control of over 1,000 companies sounds
    a little unlikely, then it’s time we examine our clustering results in a little
    more detail to see what may be going on. To get a feel for the issues, let’s look
    at the subset of clusters formed from exactly six records.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Splink provides us with a cluster studio dashboard, which we can interact with
    to explore the clusters we have generated to understand how they have been formed.
    The dashboard is persisted as an HTML page that we can display within the Jupyter
    environment as a Python inline frame (`IFrame`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7-12](#fig-7-12) shows an example of the studio dashboard.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0712.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-12\. Splink cluster studio dashboard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s consider an example cluster, reference: 766724.^([1](ch07.html#id538)) Remember
    that all the nodes in this cluster share the exact matches on the same last name,
    month, and year of birth due to the blocking rules.'
  prefs: []
  type: TYPE_NORMAL
- en: The cluster studio provides a graph view of each cluster with the nodes labeled
    with their assigned unique identifier and linked together with edges associated
    with each of the pairwise comparisons that exceeded the set threshold. This is
    shown in [Figure 7-13](#fig-7-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0713.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-13\. Example cluster
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, we can see that not all of the nodes are connected to each
    other. In fact, between the 6 nodes we have only 9 connected edges out of a possible
    15\. There are clearly two fully interconnected mini-clusters, linked together
    through node 766724. Let’s look at this in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster studio also provides a tabular view of the nodes so that we can
    examine the attributes in more detail, as shown sanitized in [Figure 7-14](#fig-7-14).
    We have sanitized the `Firstname` column—in this case, the first and third rows
    have the same spelling, which is slightly different from the other four rows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0714.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-14\. Example cluster nodes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The top mini-cluster of nodes 8261597, 4524351, and 766724 all have the same
    `Nationality` and are also missing a `Middlename`. The second mini-cluster of
    nodes 766724, 5702850, 4711461, and 9502305 all have exactly matching `Firstname`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The sanitized tabular edge view, shown in [Figure 7-15](#fig-7-15), gives us
    the match weights and associated probabilities for these pairwise comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0715.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-15\. Example cluster edges
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we increase our match threshold to filter out edges with a match weight threshold
    below 3.4, we break the two lowest scoring pairwise links. As seen in [Figure 7-16](#fig-7-16),
    our second mini-cluster remains intact but our first mini-cluster has broken apart,
    with nodes 8261597 and 4524351 now separate due to their different first name
    spelling.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0716.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-16\. Example clusters—high match threshold
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Further increasing the match weight threshold to 8.7 breaks our first mini-cluster
    completely as the lack of `Middlename` becomes a deciding negative factor. This
    is shown in [Figure 7-17](#fig-7-17).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0717.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-17\. Example clusters—higher match threshold
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Increasing the match weight to a very high threshold of 9.4 causes node 766724
    to break apart due to its slightly different first name spelling, as shown in
    [Figure 7-18](#fig-7-18).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/hoer_0718.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-18\. Example clusters—highest match threshold
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see, the size and density of our clusters is highly dependent upon
    the thresholds we set for grouping pairwise comparisons together.
  prefs: []
  type: TYPE_NORMAL
- en: The Companies House website gives us access to information on the address associated
    with these PSC records. Company numbers 8261597, 4711461, and 4524351 were all
    registered by an individual giving the same address, as were 5702850 and 9502305\.
    This gives us more confidence that this cluster does indeed represent one individual.
  prefs: []
  type: TYPE_NORMAL
- en: A wider review suggests that our first pass at assessing the concentration of
    control over UK companies was perhaps too optimistic. Setting our match and clustering
    thresholds at 0.9 has erred toward overlinking, resulting in larger clusters with
    weaker associations. This may go some way to explain the rather dubious assessment
    of several individuals with significant control of more than 1,000 companies.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that working through this sample problem has illustrated that entity
    resolution with messy real-world data is not an exact science. There is no single
    right answer, and judgment is needed to set the matching thresholds to the optimum
    values for the outcomes you are seeking to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how entity resolution within and across multiple
    datasets can produce a large number of pairwise comparisons. We learned how to
    select and evaluate blocking rules to reduce these combinations to a more practical
    volume to allow us to train and then run our matching algorithm in a reasonable
    timeframe.
  prefs: []
  type: TYPE_NORMAL
- en: Using approximate matching and probabilistic entity resolution, we were able
    to generate clusters from pairwise comparisons, allowing for variations in some
    of the attributes. However, we were left with the canonicalization challenge of
    how to decide which attribute values to use to describe our unified entity.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to use graph visualizations to help us understand our clusters.
    We saw how cluster size and composition is strongly influenced by our choice of
    match threshold and that the risks of over- or underlinking need to be balanced
    in the context of a particular dataset and desired outcome.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch07.html#id538-marker)) Note: If you are following along with your own
    notebook and PSC dataset, your cluster references may vary.'
  prefs: []
  type: TYPE_NORMAL
