- en: Chapter 22\. Vectorized String Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One strength of Python is its relative ease in handling and manipulating string
    data. Pandas builds on this and provides a comprehensive set of *vectorized string
    operations* that are an important part of the type of munging required when working
    with (read: cleaning up) real-world data. In this chapter, we’ll walk through
    some of the Pandas string operations, and then take a look at using them to partially
    clean up a very messy dataset of recipes collected from the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Pandas String Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw in previous chapters how tools like NumPy and Pandas generalize arithmetic
    operations so that we can easily and quickly perform the same operation on many
    array elements. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This *vectorization* of operations simplifies the syntax of operating on arrays
    of data: we no longer have to worry about the size or shape of the array, but
    just about what operation we want done. For arrays of strings, NumPy does not
    provide such simple access, and thus you’re stuck using a more verbose loop syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is perhaps sufficient to work with some data, but it will break if there
    are any missing values, so this approach requires putting in extra checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This manual approach is not only verbose and inconvenient, it can be error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pandas includes features to address both this need for vectorized string operations
    as well as the need for correctly handling missing data via the `str` attribute
    of Pandas `Series` and `Index` objects containing strings. So, for example, if
    we create a Pandas `Series` with this data we can directly call the `str.capitalize`
    method, which has missing value handling built in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tables of Pandas String Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a good understanding of string manipulation in Python, most of
    the Pandas string syntax is intuitive enough that it’s probably sufficient to
    just list the available methods. We’ll start with that here, before diving deeper
    into a few of the subtleties. The examples in this section use the following `Series`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Methods Similar to Python String Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nearly all of Python’s built-in string methods are mirrored by a Pandas vectorized
    string method. The following Pandas `str` methods mirror Python string methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `len` | `lower` | `translate` | `islower` | `ljust` |'
  prefs: []
  type: TYPE_TB
- en: '| `upper` | `startswith` | `isupper` | `rjust` | `find` |'
  prefs: []
  type: TYPE_TB
- en: '| `endswith` | `isnumeric` | `center` | `rfind` | `isalnum` |'
  prefs: []
  type: TYPE_TB
- en: '| `isdecimal` | `zfill` | `index` | `isalpha` | `split` |'
  prefs: []
  type: TYPE_TB
- en: '| `strip` | `rindex` | `isdigit` | `rsplit` | `rstrip` |'
  prefs: []
  type: TYPE_TB
- en: '| `capitalize` | `isspace` | `partition` | `lstrip` | `swapcase` |'
  prefs: []
  type: TYPE_TB
- en: 'Notice that these have various return values. Some, like `lower`, return a
    series of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But some others return numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or Boolean values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Still others return lists or other compound values for each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ll see further manipulations of this kind of series-of-lists object as we
    continue our discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Methods Using Regular Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition, there are several methods that accept regular expressions (regexps)
    to examine the content of each string element, and follow some of the API conventions
    of Python’s built-in `re` module (see [Table 22-1](#table-22-1)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 22-1\. Mapping between Pandas methods and functions in Python’s `re` module
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `match` | Calls `re.match` on each element, returning a Boolean. |'
  prefs: []
  type: TYPE_TB
- en: '| `extract` | Calls `re.match` on each element, returning matched groups as
    strings. |'
  prefs: []
  type: TYPE_TB
- en: '| `findall` | Calls `re.findall` on each element |'
  prefs: []
  type: TYPE_TB
- en: '| `replace` | Replaces occurrences of pattern with some other string |'
  prefs: []
  type: TYPE_TB
- en: '| `contains` | Calls `re.search` on each element, returning a boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Counts occurrences of pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `split` | Equivalent to `str.split`, but accepts regexps |'
  prefs: []
  type: TYPE_TB
- en: '| `rsplit` | Equivalent to `str.rsplit`, but accepts regexps |'
  prefs: []
  type: TYPE_TB
- en: 'With these, we can do a wide range of operations. For example, we can extract
    the first name from each element by asking for a contiguous group of characters
    at the beginning of each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can do something more complicated, like finding all names that start
    and end with a consonant, making use of the start-of-string (`^`) and end-of-string
    (`$`) regular expression characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The ability to concisely apply regular expressions across `Series` or `DataFrame`
    entries opens up many possibilities for analysis and cleaning of data.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, [Table 22-2](#table-22-2) lists miscellaneous methods that enable other
    convenient operations.
  prefs: []
  type: TYPE_NORMAL
- en: Table 22-2\. Other Pandas string methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `get` | Indexes each element |'
  prefs: []
  type: TYPE_TB
- en: '| `slice` | Slices each element |'
  prefs: []
  type: TYPE_TB
- en: '| `slice_replace` | Replaces slice in each element with the passed value |'
  prefs: []
  type: TYPE_TB
- en: '| `cat` | Concatenates strings |'
  prefs: []
  type: TYPE_TB
- en: '| `repeat` | Repeats values |'
  prefs: []
  type: TYPE_TB
- en: '| `normalize` | Returns Unicode form of strings |'
  prefs: []
  type: TYPE_TB
- en: '| `pad` | Adds whitespace to left, right, or both sides of strings |'
  prefs: []
  type: TYPE_TB
- en: '| `wrap` | Splits long strings into lines with length less than a given width
    |'
  prefs: []
  type: TYPE_TB
- en: '| `join` | Joins strings in each element of the `Series` with the passed separator
    |'
  prefs: []
  type: TYPE_TB
- en: '| `get_dummies` | Extracts dummy variables as a `DataFrame` |'
  prefs: []
  type: TYPE_TB
- en: Vectorized item access and slicing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `get` and `slice` operations, in particular, enable vectorized element
    access from each array. For example, we can get a slice of the first three characters
    of each array using `str.slice(0, 3)`. This behavior is also available through
    Python’s normal indexing syntax; for example, `df.str.slice(0, 3)` is equivalent
    to `df.str[0:3]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Indexing via `df.str.get(i)` and `df.str[i]` are likewise similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'These indexing methods also let you access elements of arrays returned by `split`.
    For example, to extract the last name of each entry, combine `split` with `str`
    indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Indicator variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another method that requires a bit of extra explanation is the `get_dummies`
    method. This is useful when your data has a column containing some sort of coded
    indicator. For example, we might have a dataset that contains information in the
    form of codes, such as A = “born in America,” B = “born in the United Kingdom,”
    C = “likes cheese,” D = “likes spam”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_dummies` routine lets us split out these indicator variables into
    a `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With these operations as building blocks, you can construct an endless range
    of string processing procedures when cleaning your data.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t dive further into these methods here, but I encourage you to read through
    [“Working with Text Data”](https://oreil.ly/oYgWA) in the Pandas online documentation,
    or to refer to the resources listed in [“Further Resources”](ch24.xhtml#section-0313-further-resources).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Recipe Database'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These vectorized string operations become most useful in the process of cleaning
    up messy, real-world data. Here I’ll walk through an example of that, using an
    open recipe database compiled from various sources on the web. Our goal will be
    to parse the recipe data into ingredient lists, so we can quickly find a recipe
    based on some ingredients we have on hand. The scripts used to compile this can
    be found on [GitHub](https://oreil.ly/3S0Rg), and the link to the most recent
    version of the database is found there as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This database is about 30 MB, and can be downloaded and unzipped with these
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The database is in JSON format, so we will use `pd.read_json` to read it (`lines=True`
    is required for this dataset because each line of the file is a JSON entry):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We see there are nearly 175,000 recipes, and 17 columns. Let’s take a look
    at one row to see what we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot of information there, but much of it is in a very messy form,
    as is typical of data scraped from the web. In particular, the ingredient list
    is in string format; we’re going to have to carefully extract the information
    we’re interested in. Let’s start by taking a closer look at the ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The ingredient lists average 250 characters long, with a minimum of 0 and a
    maximum of nearly 10,000 characters!
  prefs: []
  type: TYPE_NORMAL
- en: 'Just out of curiosity, let’s see which recipe has the longest ingredient list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do other aggregate explorations; for example, we can see how many of
    the recipes are for breakfast foods (using regular expression syntax to match
    both lowercase and capital letters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or how many of the recipes list cinnamon as an ingredient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We could even look to see whether any recipes misspell the ingredient as “cinamon”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is the type of data exploration that is possible with Pandas string tools.
    It is data munging like this that Python really excels at.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Recipe Recommender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go a bit further, and start working on a simple recipe recommendation
    system: given a list of ingredients, we want to find any recipes that use all
    those ingredients. While conceptually straightforward, the task is complicated
    by the heterogeneity of the data: there is no easy operation, for example, to
    extract a clean list of ingredients from each row. So, we will cheat a bit: we’ll
    start with a list of common ingredients, and simply search to see whether they
    are in each recipe’s ingredient list. For simplicity, let’s just stick with herbs
    and spices for the time being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then build a Boolean `DataFrame` consisting of `True` and `False` values,
    indicating whether each ingredient appears in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as an example, let’s say we’d like to find a recipe that uses parsley,
    paprika, and tarragon. We can compute this very quickly using the `query` method
    of `DataFrame`s, discussed further in [Chapter 24](ch24.xhtml#section-0312-performance-eval-and-query):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We find only 10 recipes with this combination. Let’s use the index returned
    by this selection to discover the names of those recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have narrowed down our recipe selection from 175,000 to 10, we are
    in a position to make a more informed decision about what we’d like to cook for
    dinner.
  prefs: []
  type: TYPE_NORMAL
- en: Going Further with Recipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully this example has given you a bit of a flavor (heh) of the types of
    data cleaning operations that are efficiently enabled by Pandas string methods.
    Of course, building a robust recipe recommendation system would require a *lot*
    more work! Extracting full ingredient lists from each recipe would be an important
    piece of the task; unfortunately, the wide variety of formats used makes this
    a relatively time-consuming process. This points to the truism that in data science,
    cleaning and munging of real-world data often comprises the majority of the work—and
    Pandas provides the tools that can help you do this efficiently.
  prefs: []
  type: TYPE_NORMAL
