- en: Chapter 8\. Estimating Financial Risk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Is there a way to approximate how much you can expect to lose when investing
    in financial markets? This is the quantity that the financial statistic *value
    at risk* (VaR) seeks to measure. VaR is a simple measure of investment risk that
    tries to provide a reasonable estimate of the maximum probable loss in value of
    an investment portfolio over a particular time period. A VaR statistic depends
    on three parameters: a portfolio, a time period, and a probability. For example,
    a VaR value of $1 million with a 5% probability and two weeks indicates the belief
    that the portfolio stands only a 5% chance of losing more than $1 million over
    two weeks.'
  prefs: []
  type: TYPE_NORMAL
- en: Since its development soon after the stock market crash of 1987, VaR has seen
    widespread use across financial services organizations. The statistic plays a
    vital role in the management of these institutions by helping to determine the
    risk characteristics of their strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the most sophisticated approaches to estimating this statistic rely
    on computationally intensive simulations of markets under random conditions. The
    technique behind these approaches, called the Monte Carlo simulation, involves
    posing thousands or millions of random market scenarios and observing how they
    tend to affect a portfolio. These scenarios are referred to as *trials*. PySpark
    is an ideal tool for Monte Carlo simulations. PySpark can leverage thousands of
    cores to run random trials and aggregate their results. As a general-purpose data
    transformation engine, it is also adept at performing the pre- and postprocessing
    steps that surround the simulations. It can transform raw financial data into
    the model parameters needed to carry out the simulations, as well as support ad
    hoc analysis of the results. Its simple programming model can drastically reduce
    development time compared to more traditional approaches that use HPC environments.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also discuss how to compute a related statistic called *conditional value
    at risk* (CVaR), sometimes known as *expected shortfall*, which the Basel Committee
    on Banking Supervision proposed as a better risk measure than VaR a few years
    back. A CVaR statistic has the same three parameters as a VaR statistic but considers
    the expected average loss instead of providing a probable loss value. A CVaR of
    $5 million with a 5% *q-value* and two weeks indicates the belief that the average
    loss in the worst 5% of outcomes is $5 million.
  prefs: []
  type: TYPE_NORMAL
- en: In the process of modeling VaR, we’ll introduce a few different concepts, approaches,
    and packages. We’ll start by going over basic financial terminology that will
    be used throughout the chapter and then learn about the methods used to calculate
    VaR, including the Monte Carlo simulation technique. After that, we will download
    and prepare our dataset using PySpark and pandas. We’ll be using stock market
    data from late 2000s and early 2010s, including market indicators such as treasury
    bond prices along with stock values of various companies. Once done with preprocessing,
    we will create a linear regression model to calculate change in value for stocks
    over a time period. We’ll also come up with a way to generate sample market indicator
    values for use in trials when performing a Monte Carlo simulation. Finally, we’ll
    perform the simulation using PySpark and go over our results.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by defining basic financial terms that we will use.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter makes use of a set of terms specific to the finance domain:'
  prefs: []
  type: TYPE_NORMAL
- en: Instrument
  prefs: []
  type: TYPE_NORMAL
- en: A tradable asset, such as a bond, loan, option, or stock investment. At any
    particular time, an instrument is considered to have a *value*, which is the price
    for which it could be sold.
  prefs: []
  type: TYPE_NORMAL
- en: Portfolio
  prefs: []
  type: TYPE_NORMAL
- en: A collection of instruments owned by a financial institution.
  prefs: []
  type: TYPE_NORMAL
- en: Return
  prefs: []
  type: TYPE_NORMAL
- en: The change in an instrument or portfolio’s value over a time period.
  prefs: []
  type: TYPE_NORMAL
- en: Loss
  prefs: []
  type: TYPE_NORMAL
- en: A negative return.
  prefs: []
  type: TYPE_NORMAL
- en: Index
  prefs: []
  type: TYPE_NORMAL
- en: An imaginary portfolio of instruments. For example, the NASDAQ Composite Index
    includes about 3,000 stocks and similar instruments for major US and international
    companies.
  prefs: []
  type: TYPE_NORMAL
- en: Market factor
  prefs: []
  type: TYPE_NORMAL
- en: A value that can be used as an indicator of macro aspects of the financial climate
    at a particular time—for example, the value of an index, the gross domestic product
    of the United States, or the exchange rate between the dollar and the euro. We
    will often refer to market factors as just *factors*.
  prefs: []
  type: TYPE_NORMAL
- en: Methods for Calculating VaR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our definition of VaR has been fairly open ended. Estimating this statistic
    requires proposing a model for how a portfolio functions and choosing the probability
    distribution its returns are likely to take. Institutions employ a variety of
    approaches for calculating VaR, all of which tend to fall under a few general
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Variance-Covariance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Variance-covariance* is by far the simplest and least computationally intensive
    method. Its model assumes that the return of each instrument is normally distributed,
    which allows deriving an estimate analytically.'
  prefs: []
  type: TYPE_NORMAL
- en: Historical Simulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Historical simulation* extrapolates risk from historical data by using its
    distribution directly instead of relying on summary statistics. For example, to
    determine a 95% VaR for a portfolio, we might look at that portfolio’s performance
    for the last 100 days and estimate the statistic as its value on the fifth-worst
    day. A drawback of this method is that historical data can be limited and fails
    to include what-ifs. For example, what if the history we have for the instruments
    in our portfolio lacks market collapses, and we want to model what happens to
    our portfolio in these situations? Techniques exist for making historical simulation
    robust to these issues, such as introducing “shocks” into the data, but we won’t
    cover them here.'
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo Simulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Monte Carlo simulation*, which the rest of this chapter will focus on, tries
    to weaken the assumptions in the previous methods by simulating the portfolio
    under random conditions. When we can’t derive a closed form for a probability
    distribution analytically, we can often estimate its probability density function
    by repeatedly sampling simpler random variables that it depends on and seeing
    how it plays out in aggregate. In its most general form, this method:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines a relationship between market conditions and each instrument’s returns.
    This relationship takes the form of a model fitted to historical data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines distributions for the market conditions that are straightforward to
    sample from. These distributions are fitted to historical data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poses trials consisting of random market conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculates the total portfolio loss for each trial and uses these losses to
    define an empirical distribution over losses. This means that if we run 100 trials
    and want to estimate the 5% VaR, we would choose it as the loss from the trial
    with the fifth-greatest loss. To calculate the 5% CVaR, we would find the average
    loss over the five worst trials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, the Monte Carlo method isn’t perfect either. It relies on models
    for generating trial conditions and for inferring instrument performance, and
    these models must make simplifying assumptions. If these assumptions don’t correspond
    to reality, then neither will the final probability distribution that comes out.
  prefs: []
  type: TYPE_NORMAL
- en: Our Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Monte Carlo risk model typically phrases each instrument’s return in terms
    of a set of market factors. Common market factors might be the value of indexes
    like the S&P 500, the US GDP, or currency exchange rates. We then need a model
    that predicts the return of each instrument based on these market conditions.
    In our simulation, we’ll use a simple linear model. By our previous definition
    of return, a *factor return* is a change in the value of a market factor over
    a particular time. For example, if the value of the S&P 500 moves from 2,000 to
    2,100 over a time interval, its return would be 100\. We’ll derive a set of features
    from simple transformations of the factor returns. That is, the market factor
    vector *m[t]* for a trial *t* is transformed by some function ϕ to produce a feature
    vector of possible different length *f[t]*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f[t] = ϕ(m[t])*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each instrument, we’ll train a model that assigns a weight to each feature.
    To calculate *r[it]*, the return of instrument *i* in trial *t*, we use *c[i]*,
    the intercept term for the instrument; *w[ij]*, the regression weight for feature
    *j* on instrument *i*; and *f[tj]*, the randomly generated value of feature *j*
    in trial *t*:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="r Subscript i t Baseline equals c Subscript i Baseline plus sigma-summation
    Underscript j equals 1 Overscript StartAbsoluteValue w Subscript i Baseline EndAbsoluteValue
    Endscripts w Subscript i j Baseline asterisk f Subscript t j" display="block"><mrow><msub><mi>r</mi>
    <mrow><mi>i</mi><mi>t</mi></mrow></msub> <mo>=</mo> <msub><mi>c</mi> <mi>i</mi></msub>
    <mo>+</mo> <munderover><mo>∑</mo> <mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow>
    <mrow><mrow><mo>|</mo></mrow><msub><mi>w</mi> <mi>i</mi></msub> <mrow><mo>|</mo></mrow></mrow></munderover>
    <msub><mi>w</mi> <mrow><mi>i</mi><mi>j</mi></mrow></msub> <mo>*</mo> <msub><mi>f</mi>
    <mrow><mi>t</mi><mi>j</mi></mrow></msub></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: This means that the return of each instrument is calculated as the sum of the
    returns of the market factor features multiplied by their weights for that instrument.
    We can fit the linear model for each instrument using historical data (also known
    as doing linear regression). If the horizon of the VaR calculation is two weeks,
    the regression treats every (overlapping) two-week interval in history as a labeled
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also worth mentioning that we could have chosen a more complicated model.
    For example, the model need not be linear: it could be a regression tree or explicitly
    incorporate domain-specific knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our model for calculating instrument losses from market factors,
    we need a process for simulating the behavior of market factors. A simple assumption
    is that each market factor return follows a normal distribution. To capture the
    fact that market factors are often correlated—when the NASDAQ is down, the Dow
    is likely to be suffering as well—we can use a multivariate normal distribution
    with a nondiagonal covariance matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="m Subscript t Baseline tilde script upper N left-parenthesis
    mu comma normal upper Sigma right-parenthesis" display="block"><mrow><msub><mi>m</mi>
    <mi>t</mi></msub> <mo>∼</mo> <mi>𝒩</mi> <mrow><mo>(</mo> <mi>μ</mi> <mo>,</mo>
    <mi>Σ</mi> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where μ is a vector of the empirical means of the returns of the factors and
    Σ is the empirical covariance matrix of the returns of the factors.
  prefs: []
  type: TYPE_NORMAL
- en: As before, we could have chosen a more complicated method of simulating the
    market or assumed a different type of distribution for each market factor, perhaps
    using distributions with fatter tails.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the historical stock price dataset and place it in a *data/stocks/*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It can be difficult to find large volumes of nicely formatted historical price
    data. The dataset used in this chapter was downloaded from Yahoo!
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need historical data for risk factors. For our factors, we’ll use the
    values of:'
  prefs: []
  type: TYPE_NORMAL
- en: 'iShares 20 Plus Year Treasury Bond ETF (NASDAQ: TLT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'iShares US Credit Bond ETF (NYSEArca: CRED)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SPDR Gold Trust (NYSEArca: GLD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Download and place the factors data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a look at one of our factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With our dataset downloaded, we will now prepare it.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first few rows of the Yahoo!-formatted data for GOOGL look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s fire up the PySpark shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Read in the instruments dataset as a DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The DataFrame is missing the instrument symbol. Let’s add that using the input
    filenames corresponding to each row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will read in and process the factors dataset in a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We filter out instruments with less than five years of history:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Different types of instruments may trade on different days, or the data may
    have missing values for other reasons, so it is important to make sure that our
    different histories align. First, we need to trim all of our time series to the
    same period in time. To do that, we’ll first convert the `Date` column’s type
    from string to date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s trim the time periods of instruments to align:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will convert the `Date` column’s type and trim the time period in our factors
    DataFrame too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The histories of a few thousand instruments and three factors are small enough
    to read and process locally. This remains the case even for larger simulations
    with hundreds of thousands of instruments and thousands of factors. Even though
    we have used PySpark for preprocessing our data so far, the need arises for a
    distributed system such as PySpark when we’re actually running the simulations,
    which can require massive amounts of computation on each instrument. We can convert
    our PySpark DataFrame into a pandas DataFrame and still continue working with
    it easily by performing in-memory operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will use these pandas DataFrames in the next section as we try to fit a linear
    regression model to predict instrument returns based on factor returns.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the Factor Weights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recall that VaR deals with losses *over a particular time horizon*. We are
    not concerned with the absolute prices of instruments, but with how those prices
    move over a given length of time. In our calculation, we will set that length
    to two weeks. The following function makes use of the pandas `rolling` method
    to transform a time series of prices into an overlapping sequence of price movements
    over two-week intervals. Note that we use 10 instead of 14 to define the window
    because financial data does not include weekends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With these return histories in hand, we can turn to our goal of training predictive
    models for the instrument returns. For each instrument, we want a model that predicts
    its two-week return based on the returns of the factors over the same time period.
    For simplicity, we will use a linear regression model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To model the fact that instrument returns may be nonlinear functions of the
    factor returns, we can include some additional features in our model that we derive
    from nonlinear transformations of the factor returns. As an example, we will add
    one additional feature for each factor return: square. Our model is still a linear
    model in the sense that the response variable is a linear function of the features.
    Some of the features just happen to be determined by nonlinear functions of the
    factor returns. Keep in mind that this particular feature transformation is meant
    to demonstrate some of the options available—it shouldn’t be perceived as a state-of-the-art
    practice in predictive financial modeling.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_estimating_financial_risk_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Convert factors dataframe from long to wide format so that all factors for a
    period are in one row
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_estimating_financial_risk_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Flatten multi-index dataframe and fix column names
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we will be carrying out many regressions—one for each instrument—the
    number of features and data points in each regression is small, meaning that we
    don’t need to make use of PySpark’s distributed linear modeling capabilities.
    Instead, we’ll use the ordinary least squares regression offered by the scikit-learn
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We now have a dataframe where each row is the set of model parameters (coefficients,
    weights, covariants, regressors, or whatever you wish to call them) for an instrument.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in any real-world pipeline it would be useful to understand how
    well these models fit the data. Because the data points are drawn from time series,
    and especially because the time intervals are overlapping, it is very likely that
    the samples are autocorrelated. This means that common measures like *R*² are
    likely to overestimate how well the models fit the data. The [Breusch-Godfrey
    test](https://oreil.ly/9cwg6) is a standard test for assessing these effects.
    One quick way to evaluate a model is to separate a time series into two sets,
    leaving out enough data points in the middle so that the last points in the earlier
    set are not autocorrelated with the first points in the later set. Then train
    the model on one set and look at its error on the other.
  prefs: []
  type: TYPE_NORMAL
- en: With our models that map factor returns to instrument returns in hand, we now
    need a procedure for simulating market conditions by generating random factor
    returns. That’s what we’ll do next.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To come up with a way for generating random factor returns, we need to decide
    on a probability distribution over factor return vectors and sample from it. What
    distribution does the data actually take? It can often be useful to start answering
    this kind of question visually.
  prefs: []
  type: TYPE_NORMAL
- en: A nice way to visualize a probability distribution over continuous data is a
    density plot that plots the distribution’s domain versus its probability density
    function. Because we don’t know the distribution that governs the data, we don’t
    have an equation that can give us its density at an arbitrary point, but we can
    approximate it through a technique called *kernel density estimation* (KDE). In
    a loose way, kernel density estimation is a way of smoothing out a histogram.
    It centers a probability distribution (usually a normal distribution) at each
    data point. So a set of two-week-return samples would result in multiple normal
    distributions, each with a different mean. To estimate the probability density
    at a given point, it evaluates the PDFs of all the normal distributions at that
    point and takes their average. The smoothness of a kernel density plot depends
    on its *bandwidth*, the standard deviation of each of the normal distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use one of pandas DataFrame’s built-in methods to calculate and draw
    a KDE plot. The following snippet creates a density plot for one of our factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 8-1](#figure8-1) shows the distribution (probability density function)
    of two-week returns for the 20+ Year Treasury Bond ETF in our history.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two-week 20+ Year Treasury Bond ETF distribution](assets/aaps_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Two-week 20+ Year Treasury Bond ETF distribution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 8-2](#figure8-2) shows the same for two-week returns of US Credit Bonds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![aaps 0802](assets/aaps_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Two-week US Credit Bond ETF returns distribution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We will fit a normal distribution to the returns of each factor. Looking for
    a more exotic distribution, perhaps with fatter tails, that more closely fits
    the data is often worthwhile. However, for the sake of simplicity, we’ll avoid
    tuning our simulation in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to sample factors’ returns would be to fit a normal distribution
    to each of the factors and sample from these distributions independently. However,
    this ignores the fact that market factors are often correlated. If the Treasury
    Bond ETF is down, the Credit Bond ETF is likely to be down as well. Failing to
    take these correlations into account can give us a much rosier picture of our
    risk profile than its reality. Are the returns of our factors correlated? The
    Pearson’s correlation implementation in pandas can help us find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Because we have nonzero elements off the diagonals, it doesn’t look like it.
  prefs: []
  type: TYPE_NORMAL
- en: The Multivariate Normal Distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The multivariate normal distribution can help here by taking the correlation
    information between the factors into account. Each sample from a multivariate
    normal is a vector. Given values for all of the dimensions but one, the distribution
    of values along that dimension is normal. But, in their joint distribution, the
    variables are not independent.
  prefs: []
  type: TYPE_NORMAL
- en: The multivariate normal is parameterized with a mean along each dimension and
    a matrix describing the covariances between each pair of dimensions. With *N*
    dimensions, the covariance matrix is *N* by *N* because we want to capture the
    covariances between each pair of dimensions. When the covariance matrix is diagonal,
    the multivariate normal reduces to sampling along each dimension independently,
    but placing nonzero values in the off-diagonals helps capture the relationships
    between variables.
  prefs: []
  type: TYPE_NORMAL
- en: The VaR literature often describes a step in which the factor weights are transformed
    (decorrelated) so that sampling can proceed. This is normally accomplished with
    a Cholesky decomposition or eigendecomposition. NumPy package’s `M⁠u⁠l⁠t⁠i⁠v⁠a⁠r⁠i⁠a⁠t⁠e​N⁠o⁠r⁠m⁠a⁠l⁠Distribution`
    takes care of this step for us under the covers using an eigendecomposition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fit a multivariate normal distribution to our data, first we need to find
    its sample means and covariances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can simply create a distribution parameterized with them and sample
    a set of market conditions from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the per-instrument models and a procedure for sampling factor returns,
    we now have the pieces we need to run the actual trials. Let’s start working on
    our simulation and run the trials.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Trials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because running the trials is computationally intensive, we’ll turn to PySpark
    to help us parallelize them. In each trial, we want to sample a set of risk factors,
    use them to predict the return of each instrument, and sum all those returns to
    find the full trial loss. To achieve a representative distribution, we want to
    run thousands or millions of these trials.
  prefs: []
  type: TYPE_NORMAL
- en: We have a few choices for how to parallelize the simulation. We can parallelize
    along trials, instruments, or both. To parallelize along both, we would create
    a dataset of instruments and a dataset of trial parameters and then use the `crossJoin`
    transformation to generate a dataset of all the pairs. This is the most general
    approach, but it has a couple of disadvantages. First, it requires explicitly
    creating a DataFrame of trial parameters, which we can avoid by using some tricks
    with random seeds. Second, it requires a shuffle operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partitioning along instruments would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, the data is partitioned across a DataFrame of instruments,
    and for each instrument a `flatMap` transformation computes and yields the loss
    against every trial. Using the same random seed across all tasks means that we
    will generate the same sequence of trials. `reduceByKey` sums together all the
    losses corresponding to the same trials. A disadvantage of this approach is that
    it still requires shuffling *O*(|instruments| * |trials|) data.
  prefs: []
  type: TYPE_NORMAL
- en: Our model data for our few thousand instruments is small enough to fit in memory
    on every executor, and some back-of-the-envelope calculations reveal that this
    is probably still the case even with a million or so instruments and hundreds
    of factors. A million instruments times 500 factors times the 8 bytes needed for
    the double that stores each factor weight equals roughly 4 GB, small enough to
    fit in each executor on most modern-day cluster machines. This means that a good
    option is to distribute the instrument data in a broadcast variable. The advantage
    of each executor having a full copy of the instrument data is that total loss
    for each trial can be computed on a single machine. No aggregation is necessary.
    We also broadcast some other data required for trial return calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With the partition-by-trials approach (which we will use), we start out with
    a DataFrame of seeds. We want a different seed in each partition so that each
    partition generates different trials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Random number generation is a time-consuming and CPU-intensive process. While
    we don’t employ this trick here, it can often be useful to generate a set of random
    numbers in advance and use it across multiple jobs. The same random numbers should
    *not* be used within a single job, because this would violate the Monte Carlo
    assumption that the random values are independently distributed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each seed, we want to generate a set of trial parameters and observe the
    effects of these parameters on all the instruments. We will write a function that
    calculates the full return of instruments for multiple trials. We start by simply
    applying the linear model that we trained earlier for each instrument. Then we
    average over the returns of all the instruments. This assumes that we’re holding
    an equal value of each instrument in the portfolio. A weighted average would be
    used if we held different amounts of each stock. Lastly, we need to generate a
    bunch of trials in each task. Because choosing random numbers is a big part of
    the process, it is important to use a strong random number generator. Python’s
    in-built `random` library includes a Mersenne Twister implementation that is good
    for this. We use it to sample from a multivariate normal distribution as described
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With our scaffolding complete, we can use it to compute a DataFrame where each
    element is the total return from a single trial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_estimating_financial_risk_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Split array of trial returns into individual DataFrame rows
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall, the whole reason we’ve been messing around with all these numbers
    is to calculate VaR. `trials` now forms an empirical distribution over portfolio
    returns. To calculate 5% VaR, we need to find a return that we expect to underperform
    5% of the time, and a return that we expect to outperform 5% of the time. With
    our empirical distribution, this is as simple as finding the value that 5% of
    trials are worse than and 95% of trials are better than. We can accomplish this
    by pulling the worst 5% of trials into the driver. Our VaR is the return of the
    best trial in this subset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can find the CVaR with a nearly identical approach. Instead of taking the
    best trial return from the worst 5% of trials, we take the average return from
    that set of trials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Visualizing the Distribution of Returns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to calculating VaR at a particular confidence level, it can be
    useful to look at a fuller picture of the distribution of returns. Are they normally
    distributed? Do they spike at the extremities? As we did for the individual factors,
    we can plot an estimate of the probability density function for the joint probability
    distribution using kernel density estimation (see [Figure 8-3](#figure9-3)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![aaps 0803](assets/aaps_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. Two-week returns distribution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Where to Go from Here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The model laid out in this exercise is a very rough first cut of what would
    be used in an actual financial institution. In building an accurate VaR model,
    we glossed over a few very important steps. Curating the set of market factors
    can make or break a model, and it is not uncommon for financial institutions to
    incorporate hundreds of factors in their simulations. Picking these factors requires
    both running numerous experiments on historical data and a heavy dose of creativity.
    Choosing the predictive model that maps market factors to instrument returns is
    also important. Although we used a simple linear model, many calculations use
    nonlinear functions or simulate the path over time with Brownian motion.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, it is worth putting care into the distribution used to simulate the
    factor returns. Kolmogorov-Smirnov tests and chi-squared tests are useful for
    testing an empirical distribution’s normality. Q-Q plots are useful for comparing
    distributions visually. Usually, financial risk is better mirrored by a distribution
    with fatter tails than the normal distribution that we used. Mixtures of normal
    distributions are one good way to achieve these fatter tails. [“Financial Economics,
    Fat-tailed Distributions”](https://oreil.ly/XSxhB), an article by Markus Haas
    and Christian Pigorsch, provides a nice reference on some of the other fat-tailed
    distributions out there.
  prefs: []
  type: TYPE_NORMAL
- en: Banks use PySpark and large-scale data processing frameworks for calculating
    VaR with historical methods as well. [“Evaluation of Value-at-Risk Models Using
    Historical Data”](https://oreil.ly/0JoXu), by Darryll Hendricks, provides a good
    overview and performance comparison of historical VaR methods.
  prefs: []
  type: TYPE_NORMAL
- en: Monte Carlo risk simulations can be used for more than calculating a single
    statistic. The results can be used to proactively reduce the risk of a portfolio
    by shaping investment decisions. For example, if in the trials with the poorest
    returns, a particular set of instruments tends to come up losing money repeatedly,
    we might consider dropping those instruments from the portfolio or adding instruments
    that tend to move in the opposite direction from them.
  prefs: []
  type: TYPE_NORMAL
