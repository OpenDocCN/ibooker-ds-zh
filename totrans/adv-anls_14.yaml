- en: Chapter 11\. Data Structures in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 10](ch10.html#first-steps-python), you learned about simple Python
    object types like strings, integers, and Booleans. Now let’s look at grouping
    multiple values together in what’s called a *collection*. Python by default comes
    with several collection object types. We’ll start this chapter with the *list*.
    We can put values into a list by separating each entry with commas and placing
    the results inside square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This object contains all integers, but itself is *not* an integer data type:
    it is a *list*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In fact, we can include all different sorts of data inside a list…even other
    lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you’re seeing, lists are quite versatile for storing data. But right now,
    we’re really interested in working with something that could function like an
    Excel range or R vector, and then move into tabular data. Does a simple list fit
    the bill? Let’s give it a whirl by trying to multiply `my_list` by two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is probably *not* what you are looking for: Python took you literally
    and, well, doubled your *list*, rather than the *numbers inside* your list. There
    are ways to get what we want here on our own: if you’ve worked with loops before,
    you could set one up here to multiply each element by two. If you’ve not worked
    with loops, that’s fine too: the better option is to import a module that makes
    it easier to perform computations in Python. For that, we’ll use `numpy`, which
    is included with Anaconda.'
  prefs: []
  type: TYPE_NORMAL
- en: NumPy arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As its name suggests, `numpy` is a module for numerical computing in Python
    and has been foundational to Python’s popularity as an analytics tool. To learn
    more about `numpy`, visit the Help section of Jupyter’s menu bar and select “NumPy
    reference.” We’ll focus for right now on the `numpy` *array*. This is a collection
    of data with all items of the same type and that can store data in up to any number,
    or *n* dimensions. We’ll focus on a *one-dimensional* array and convert our first
    one from a list using the `array()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance a `numpy` array looks a *lot* like a list; after all, we even
    created this one *from* a list. But we can see that it really is a different data
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Specifically, it’s an `ndarray`, or *n*-dimensional array. Because it’s a different
    data structure, it may behave differently with operations. For example, what happens
    when we multiply a `numpy` array?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In many ways this behavior should remind you of an Excel range or an R vector.
    And indeed, like R vectors, `numpy` arrays will *coerce* data to be of the same
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’re seeing, `numpy` is a lifesaver for working with data in Python. Plan
    to import it *a lot*…which means typing it a lot. Fortunately, you can lighten
    the load with *aliasing*. We’ll use the `as` keyword to give `numpy` its conventional
    alias, `np`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This gives the module a temporary, more manageable name. Now, each time we want
    to call in code from `numpy` during our Python session, we can refer to its alias.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that aliases are *temporary* to your Python session. If you restart
    your kernel or start a new notebook, the alias won’t work anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and Subsetting NumPy Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a moment to explore how to pull individual items from a `numpy`
    array, which we can do by affixing its index number in square brackets directly
    next to the object name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For example, we just pulled the second element from our array…*or did we?* Let’s
    revisit `my_array`; what is *really* showing in the second position?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It appears that `1` is in the second position, and `5` is actually in the *third*.
    What explains this discrepancy? As it turns out, it’s because Python counts things
    differently than you and I usually do.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a warm-up to this strange concept, imagine being so excited to get your
    hands on a new dataset that you download it several times. That hastiness leaves
    you with a series of files named like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*dataset.csv*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*dataset (1).csv*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*dataset (2).csv*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*dataset (3).csv*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As humans, we tend to start counting things at one. But computers often start
    counting at *zero*. Multiple file downloads is one example: our second file is
    actually named `dataset (1)`, not `dataset (2)`. This is called *zero-based indexing*,
    and it happens *all over* in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: This is all to say that, to Python, indexing something with the number `1` returns
    the value in the *second* position, indexing with `2` returns the third, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It’s also possible to subset a selection of consecutive values, called *slicing*
    in Python. Let’s try finding the second through fourth elements. We already got
    the zero-based kicker out of the way; how hard could this be?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*But wait, there’s more.* In addition to being zero-indexed, slicing is *exclusive*
    of the ending element. That means we need to “add 1” to the second number to get
    our intended range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There’s much more you can do with slicing in Python, such as starting at the
    *end* of an object or selecting all elements from the start to a given position.
    For now, the important thing to remember is that *Python uses zero-based indexing*.
  prefs: []
  type: TYPE_NORMAL
- en: Two-dimensional `numpy` arrays can serve as a tabular Python data structure,
    but all elements must be of the same data type. This is rarely the case when we’re
    analyzing data in a business context, so to meet this requirement we’ll move to
    `pandas`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Pandas DataFrames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Named after the *panel data* of econometrics, `pandas` is especially helpful
    for manipulating and analyzing tabular data. Like `numpy`, it comes installed
    with Anaconda. The typical alias is `pd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pandas` module leverages `numpy` in its code base, and you will see some
    similarities between the two. `pandas` includes, among others, a one-dimensional
    data structure called a *Series*. But its most widely used structure is the two-dimensional
    *DataFrame* (sound familiar?). It’s possible to create a DataFrame from other
    data types, including `numpy` arrays, using the `DataFrame` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'DataFrames generally include named *labels* for each column. There will also
    be an *index* running down the rows, which by default starts at (you guessed it)
    0\. This is a pretty small dataset to explore, so let’s find something else. Unfortunately,
    Python does not include any DataFrames out of the gate, but we can find some with
    the `seaborn` package. `seaborn` also comes installed with Anaconda and is often
    aliased as `sns`. The `get_dataset_names()` function will return a list of DataFrames
    available to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Does *iris* sound familiar? We can load it into our Python session with the
    `load_dataset()` function, and print the first five rows with the `head()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Importing Data in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with R, it’s most common to read in data from external files, and we’ll
    need to deal with directories to do so. The Python Standard Library includes the
    `os` module for working with file paths and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For this next part, have your notebook saved in the main folder of the book
    repository. By default, Python sets the current working directory to wherever
    your active file is located, so we don’t have to worry about changing the directory
    as we did in R. You can still check and change it with the `getcwd()` and `chdir()`
    functions from `os`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python follows the same general rules about relative and absolute file paths
    as R. Let’s see if we can locate *test-file.csv* in the repository using the `isfile()`
    function, which is in the `path` submodule of `os`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now we’d like to locate that file as contained in the *test-folder* subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, try putting a copy of this file in the folder one up from your current
    location. You should be able to locate it with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Like with R, you’ll most commonly read data in from an external source to operate
    on it in Python, and this source can be nearly anything imaginable. `pandas` includes
    functions to read data from, among others, both *.xlsx* and *.csv* files into
    DataFrames. To demonstrate, we’ll read in our reliable *star.xlsx* and *districts.csv*
    datasets from the book repository. The `read_excel()` function is used to read
    Excel workbooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can use `pandas` to read in *.csv* files with the `read_csv()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you’d like to read in other Excel file types or specific ranges and worksheets,
    for example, check the `pandas` documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a DataFrame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s continue to size up the *star* DataFrame. The `info()` method will tell
    us some important things, such as its dimensions and types of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve descriptive statistics with the `describe()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By default, `pandas` only includes descriptive statistics of numeric variables.
    We can override this with `include = 'all'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`NaN` is a special `pandas` value to indicate missing or unavailable data,
    such as the standard deviation of a categorical variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and Subsetting DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s return to the small *roster* DataFrame, accessing various elements by
    their row and column position. To index a DataFrame we can use the `iloc`, or
    *integer location*, method. The square bracket notation will look familiar to
    you, but this time we need to index by both row *and* column (again, both starting
    at zero). Let’s demonstrate on the *roster* DataFrame we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to employ slicing here as well to capture multiple rows and columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To index an entire column by name, we can use the related `loc` method. We’ll
    leave a blank slice in the first index position to capture all rows, then name
    the column of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Writing DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pandas` also includes functions to write DataFrames to both *.csv* files and
    *.xlsx* workbooks with the `write_csv()` and `write_xlsx()` methods, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a short time, you were able to progress all the way from single-element objects,
    to lists, to `numpy` arrays, then finally to `pandas` DataFrames. I hope you were
    able to see the evolution and linkage between these data structures while appreciating
    the added benefits of the packages introduced. The following chapters on Python
    will rely heavily on `pandas`, but you’ve seen here that `pandas` itself relies
    on `numpy` and the basic rules of Python, such as zero-based indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to work with a few different data structures
    and collection types in Python. The following exercises provide additional practice
    and insight on these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Slice the following array so that you are left with the third through fifth
    elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Load the `tips` DataFrame from `seaborn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print some information about this DataFrame, such as the number of observations
    and each column’s type.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the descriptive statistics for this DataFrame.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The [book repository](https://oreil.ly/RKmg0) includes an *ais.xlsx* file in
    the *ais* subfolder of the *datasets* folder. Read it into Python as a DataFrame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the first few rows of this DataFrame.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write just the *sport* column of this DataFrame back to Excel as *sport.xlsx*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
