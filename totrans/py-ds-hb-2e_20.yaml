- en: Chapter 17\. Hierarchical Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point we’ve been focused primarily on one-dimensional and two-dimensional
    data, stored in Pandas `Series` and `DataFrame` objects, respectively. Often it
    is useful to go beyond this and store higher-dimensional data—that is, data indexed
    by more than one or two keys. Early Pandas versions provided `Panel` and `Panel4D`
    objects that could be thought of as 3D or 4D analogs to the 2D `DataFrame`, but
    they were somewhat clunky to use in practice. A far more common pattern for handling
    higher-dimensional data is to make use of *hierarchical indexing* (also known
    as *multi-indexing*) to incorporate multiple index *levels* within a single index.
    In this way, higher-dimensional data can be compactly represented within the familiar
    one-dimensional `Series` and two-dimensional `DataFrame` objects. (If you’re interested
    in true *N*-dimensional arrays with Pandas-style flexible indices, you can look
    into the excellent [Xarray package](https://xarray.pydata.org).)
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the direct creation of `MultiIndex` objects;
    considerations when indexing, slicing, and computing statistics across multiply
    indexed data; and useful routines for converting between simple and hierarchically
    indexed representations of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with the standard imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A Multiply Indexed Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start by considering how we might represent two-dimensional data within
    a one-dimensional `Series`. For concreteness, we will consider a series of data
    where each point has a character and numerical key.
  prefs: []
  type: TYPE_NORMAL
- en: The Bad Way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you would like to track data about states from two different years.
    Using the Pandas tools we’ve already covered, you might be tempted to simply use
    Python tuples as keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With this indexing scheme, you can straightforwardly index or slice the series
    based on this tuple index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But the convenience ends there. For example, if you need to select all values
    from 2010, you’ll need to do some messy (and potentially slow) munging to make
    it happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This produces the desired result, but is not as clean (or as efficient for large
    datasets) as the slicing syntax we’ve grown to love in Pandas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Better Way: The Pandas MultiIndex'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fortunately, Pandas provides a better way. Our tuple-based indexing is essentially
    a rudimentary multi-index, and the Pandas `MultiIndex` type gives us the types
    of operations we wish to have. We can create a multi-index from the tuples as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `MultiIndex` represents multiple *levels* of indexing—in this case, the
    state names and the years—as well as multiple *labels* for each data point which
    encode these levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we reindex our series with this `MultiIndex`, we see the hierarchical representation
    of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the first two columns of the Series representation show the multiple index
    values, while the third column shows the data. Notice that some entries are missing
    in the first column: in this multi-index representation, any blank entry indicates
    the same value as the line above it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to access all data for which the second index is 2020, we can use the Pandas
    slicing notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The result is a singly indexed Series with just the keys we’re interested in.
    This syntax is much more convenient (and the operation is much more efficient!)
    than the home-spun tuple-based multi-indexing solution that we started with. We’ll
    now further discuss this sort of indexing operation on hierarchically indexed
    data.
  prefs: []
  type: TYPE_NORMAL
- en: MultiIndex as Extra Dimension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might notice something else here: we could easily have stored the same
    data using a simple `DataFrame` with index and column labels. In fact, Pandas
    is built with this equivalence in mind. The `unstack` method will quickly convert
    a multiply indexed `Series` into a conventionally indexed `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, the `stack` method provides the opposite operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Seeing this, you might wonder why would we would bother with hierarchical indexing
    at all. The reason is simple: just as we were able to use multi-indexing to manipulate
    two-dimensional data within a one-dimensional `Series`, we can also use it to
    manipulate data of three or more dimensions in a `Series` or `DataFrame`. Each
    extra level in a multi-index represents an extra dimension of data; taking advantage
    of this property gives us much more flexibility in the types of data we can represent.
    Concretely, we might want to add another column of demographic data for each state
    at each year (say, population under 18); with a `MultiIndex` this is as easy as
    adding another column to the `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, all the ufuncs and other functionality discussed in [Chapter 15](ch15.xhtml#section-0303-operations-in-pandas)
    work with hierarchical indices as well. Here we compute the fraction of people
    under 18 by year, given the above data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to easily and quickly manipulate and explore even high-dimensional
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of MultiIndex Creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most straightforward way to construct a multiply indexed `Series` or `DataFrame`
    is to simply pass a list of two or more index arrays to the constructor. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The work of creating the `MultiIndex` is done in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you pass a dictionary with appropriate tuples as keys, Pandas
    will automatically recognize this and use a `MultiIndex` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Nevertheless, it is sometimes useful to explicitly create a `MultiIndex`; we’ll
    look at a couple of methods for doing this next.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit MultiIndex Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more flexibility in how the index is constructed, you can instead use the
    constructor methods available in the `pd.MultiIndex` class. For example, as we
    did before, you can construct a `MultiIndex` from a simple list of arrays giving
    the index values within each level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can construct it from a list of tuples giving the multiple index values
    of each point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even construct it from a Cartesian product of single indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can construct a `MultiIndex` directly using its internal encoding
    by passing `levels` (a list of lists containing available index values for each
    level) and `codes` (a list of lists that reference these labels):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Any of these objects can be passed as the `index` argument when creating a `Series`
    or `DataFrame`, or be passed to the `reindex` method of an existing `Series` or
    `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: MultiIndex Level Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes it is convenient to name the levels of the `MultiIndex`. This can
    be accomplished by passing the `names` argument to any of the previously discussed
    `MultiIndex` constructors, or by setting the `names` attribute of the index after
    the fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With more involved datasets, this can be a useful way to keep track of the meaning
    of various index values.
  prefs: []
  type: TYPE_NORMAL
- en: MultiIndex for Columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a `DataFrame`, the rows and columns are completely symmetric, and just as
    the rows can have multiple levels of indices, the columns can have multiple levels
    as well. Consider the following, which is a mock-up of some (somewhat realistic)
    medical data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fundamentally four-dimensional data, where the dimensions are the subject,
    the measurement type, the year, and the visit number. With this in place we can,
    for example, index the top-level column by the person’s name and get a full `DataFrame`
    containing just that person’s information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and Slicing a MultiIndex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexing and slicing on a `MultiIndex` is designed to be intuitive, and it helps
    if you think about the indices as added dimensions. We’ll first look at indexing
    multiply indexed `Series`, and then multiply indexed `DataFrame` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Multiply Indexed Series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the multiply indexed `Series` of state populations we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access single elements by indexing with multiple terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MultiIndex` also supports *partial indexing*, or indexing just one of
    the levels in the index. The result is another `Series`, with the lower-level
    indices maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Partial slicing is available as well, as long as the `MultiIndex` is sorted
    (see the discussion in [“Sorted and Unsorted Indices”](#ch_0305-hierarchical-indexing_sorted-and-unsorted-indices)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'with sorted indices, partial indexing can be performed on lower levels by passing
    an empty slice in the first index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Other types of indexing and selection (discussed in [Chapter 14](ch14.xhtml#section-0302-data-indexing-and-selection))
    work as well; for example, selection based on Boolean masks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Selection based on fancy indexing also works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Multiply Indexed DataFrames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A multiply indexed `DataFrame` behaves in a similar manner. Consider our toy
    medical `DataFrame` from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that columns are primary in a `DataFrame`, and the syntax used for
    multiply indexed `Series` applies to the columns. For example, we can recover
    Guido’s heart rate data with a simple operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, as with the single-index case, we can use the `loc`, `iloc`, and `ix`
    indexers introduced in [Chapter 14](ch14.xhtml#section-0302-data-indexing-and-selection).
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'These indexers provide an array-like view of the underlying two-dimensional
    data, but each individual index in `loc` or `iloc` can be passed a tuple of multiple
    indices. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Working with slices within these index tuples is not especially convenient;
    trying to create a slice within a tuple will lead to a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You could get around this by building the desired slice explicitly using Python’s
    built-in `slice` function, but a better way in this context is to use an `IndexSlice`
    object, which Pandas provides for precisely this situation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are many ways to interact with data in multiply indexed
    `Series` and `DataFrame`s, and as with many tools in this book the best way to
    become familiar with them is to try them out!
  prefs: []
  type: TYPE_NORMAL
- en: Rearranging Multi-Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the keys to working with multiply indexed data is knowing how to effectively
    transform the data. There are a number of operations that will preserve all the
    information in the dataset, but rearrange it for the purposes of various computations.
    We saw a brief example of this in the `stack` and `unstack` methods, but there
    are many more ways to finely control the rearrangement of data between hierarchical
    indices and columns, and we’ll explore them here.
  prefs: []
  type: TYPE_NORMAL
- en: Sorted and Unsorted Indices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier I briefly mentioned a caveat, but I should emphasize it more here. *Many
    of the `MultiIndex` slicing operations will fail if the index is not sorted.*
    Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by creating some simple multiply indexed data where the indices
    are *not lexographically sorted*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to take a partial slice of this index, it will result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it is not entirely clear from the error message, this is the result
    of the `MultiIndex` not being sorted. For various reasons, partial slices and
    other similar operations require the levels in the `MultiIndex` to be in sorted
    (i.e., lexographical) order. Pandas provides a number of convenience routines
    to perform this type of sorting, such as the `sort_index` and `sortlevel` methods
    of the `DataFrame`. We’ll use the simplest, `sort_index`, here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With the index sorted in this way, partial slicing will work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Stacking and Unstacking Indices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw briefly before, it is possible to convert a dataset from a stacked
    multi-index to a simple two-dimensional representation, optionally specifying
    the level to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite of `unstack` is `stack`, which here can be used to recover the
    original series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Index Setting and Resetting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to rearrange hierarchical data is to turn the index labels into
    columns; this can be accomplished with the `reset_index` method. Calling this
    on the population dictionary will result in a `DataFrame` with `state` and `year`
    columns holding the information that was formerly in the index. For clarity, we
    can optionally specify the name of the data for the column representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A common pattern is to build a `MultiIndex` from the column values. This can
    be done with the `set_index` method of the `DataFrame`, which returns a multiply
    indexed `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In practice, this type of reindexing is one of the more useful patterns when
    exploring real-world datasets.
  prefs: []
  type: TYPE_NORMAL
