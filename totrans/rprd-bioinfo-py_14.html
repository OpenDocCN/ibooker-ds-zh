<html><head></head><body><section data-pdf-bookmark="Chapter 13. Location Restriction Sites: Using, Testing, and Sharing Code" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch13">&#13;
<h1><span class="label">Chapter 13. </span>Location Restriction Sites: <span class="keep-together">Using, Testing, and Sharing Code</span></h1>&#13;
&#13;
&#13;
<p>A <em>palindromic</em> sequence in DNA is one in which the 5’ to 3’ base pair sequence is identical on both strands.<a data-primary="DNA" data-secondary="palindromic sequences" data-type="indexterm" id="idm45963629461912"/><a data-primary="palindromic sequences of DNA" data-type="indexterm" id="idm45963629460968"/><a data-primary="reverse complement of DNA" data-secondary="palindromic sequences of DNA" data-type="indexterm" id="idm45963629460280"/><a data-primary="restriction sites" data-secondary="about" data-type="indexterm" id="idm45963629459304"/><a data-primary="DNA" data-secondary="restriction sites" data-see="restriction sites" data-type="indexterm" id="idm45963629458360"/>&#13;
For example, <a data-type="xref" href="#fig_13.1">Figure 13-1</a> shows that the reverse complement of the DNA sequence <em>GCATGC</em> is the sequence itself.</p>&#13;
&#13;
<figure><div class="figure" id="fig_13.1">&#13;
<img alt="mpfb 1301" src="assets/mpfb_1301.png"/>&#13;
<h6><span class="label">Figure 13-1. </span>A reverse palindrome is equal to its reverse complement</h6>&#13;
</div></figure>&#13;
&#13;
<p>I can verify this in code:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from Bio import Seq&#13;
&gt;&gt;&gt; seq = 'GCATGC'&#13;
&gt;&gt;&gt; Seq.reverse_complement(seq) == seq&#13;
True</pre>&#13;
&#13;
<p>As described in <a href="https://oreil.ly/w3Tdm">the Rosalind REVP challenge</a>, restriction enzymes recognize and cut within specific palindromic sequences of DNA known as restriction sites.&#13;
They typically have a length of between 4 and 12 nucleotides.&#13;
The goal of this exercise is to find the locations in a DNA sequence of every putative restriction enzyme.&#13;
The code to solve this problem could be massively complicated, but a clear understanding of some functional programming techniques helps to <span class="keep-together">create</span> a short, elegant solution.&#13;
I will explore <code>map()</code>, <code>zip()</code>, and <code>enumerate()</code> as well as many small, tested functions.</p>&#13;
&#13;
<p>You will learn:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to find a reverse palindrome</p>&#13;
</li>&#13;
<li>&#13;
<p>How to create modules to share common functions</p>&#13;
</li>&#13;
<li>&#13;
<p>About the <code>PYTHONPATH</code> environment variable</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started" data-type="sect1"><div class="sect1" id="idm45963629444376">&#13;
<h1>Getting Started</h1>&#13;
&#13;
<p>The code and tests for this exercise are in the <em>13_revp</em> directory.<a data-primary="restriction sites" data-secondary="getting started" data-type="indexterm" id="idm45963629442600"/>&#13;
Start by copying a solution to the program <code>revp.py</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd 13_revp&#13;
$ cp solution1_zip_enumerate.py revp.py</pre>&#13;
&#13;
<p>Inspect the usage:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./revp.py -h&#13;
usage: revp.py [-h] FILE&#13;
&#13;
Locating Restriction Sites&#13;
&#13;
positional arguments:&#13;
  FILE        Input FASTA file <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO1-1" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
optional arguments:&#13;
  -h, --help  show this help message and exit</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO1-1" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The only required argument is a single positional file of FASTA-formatted DNA sequences.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Have a look at the first test input file.&#13;
The contents are identical to the example on the Rosalind page:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.fa&#13;
&gt;Rosalind_24&#13;
TCAATGCATGCGGGTCTATATGCAT</pre>&#13;
&#13;
<p>Run the program with this input and verify that you see the position (using 1-based counting) and length of every reverse palindrome in the string having a length between 4 and 12, as illustrated in <a data-type="xref" href="#fig_13.2">Figure 13-2</a>.&#13;
Note that the order of the results is unimportant:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./revp.py tests/inputs/1.fa&#13;
5 4&#13;
7 4&#13;
17 4&#13;
18 4&#13;
21 4&#13;
4 6&#13;
6 6&#13;
20 6</pre>&#13;
&#13;
<figure><div class="figure" id="fig_13.2">&#13;
<img alt="mpfb 1302" src="assets/mpfb_1302.png"/>&#13;
<h6><span class="label">Figure 13-2. </span>The locations of the eight reverse palindromes found in the sequence <em>TCAATGCATGCGGGTCTATATGCAT</em>.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Run the tests to verify that the program passes, then start over:</p>&#13;
&#13;
<pre data-type="programlisting">$ new.py -fp 'Locating Restriction Sites' revp.py&#13;
Done, see new script "revp.py".</pre>&#13;
&#13;
<p>Here is a way to define the program’s parameter:</p>&#13;
&#13;
<pre data-type="programlisting">class Args(NamedTuple):&#13;
    """ Command-line arguments """&#13;
    file: TextIO <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-1" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
&#13;
def get_args() -&gt; Args:&#13;
    """ Get command-line arguments """&#13;
&#13;
    parser = argparse.ArgumentParser(&#13;
        description='Locating Restriction Sites',&#13;
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)&#13;
&#13;
    parser.add_argument('file', <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-2" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
                        help='Input FASTA file',&#13;
                        metavar='FILE',&#13;
                        type=argparse.FileType('rt'))&#13;
&#13;
    args = parser.parse_args()&#13;
&#13;
    return Args(args.file)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-1" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The only parameter is a file.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-2" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Define a parameter that must be a readable text file.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Have the <code>main()</code> function print the input filename for now:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    print(args.file.name)</pre>&#13;
&#13;
<p>Manually verify that the program will produce the correct usage, will reject bogus files, and will print a valid input’s name:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./revp.py tests/inputs/1.fa&#13;
tests/inputs/1.fa</pre>&#13;
&#13;
<p>Run <strong><code>make test</code></strong> and you should find you pass some tests.&#13;
Now you’re ready to write the bones of the program.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Finding All Subsequences Using K-mers" data-type="sect2"><div class="sect2" id="idm45963629409784">&#13;
<h2>Finding All Subsequences Using K-mers</h2>&#13;
&#13;
<p>The first step is to read the sequences from the FASTA input file.<a data-primary="k-mers" data-secondary="finding all subsequences" data-type="indexterm" id="idm45963629408424"/><a data-primary="subsequences" data-secondary="finding all using k-mers" data-type="indexterm" id="idm45963629407464"/><a data-primary="restriction sites" data-secondary="finding all subsequences via k-mers" data-type="indexterm" id="idm45963629406504"/>&#13;
I can use <code>SeqIO.parse()</code> to create a lazy iterator and then use <code>next()</code> to get the first sequence:<a data-primary="Biopython library" data-secondary="Bio.SeqIO" data-tertiary="FASTA parsed" data-type="indexterm" id="idm45963629404440"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from Bio import SeqIO&#13;
&gt;&gt;&gt; recs = SeqIO.parse(open('tests/inputs/1.fa'), 'fasta')&#13;
&gt;&gt;&gt; rec = next(recs)&#13;
&gt;&gt;&gt; seq = str(rec.seq)&#13;
&gt;&gt;&gt; seq&#13;
'TCAATGCATGCGGGTCTATATGCAT'</pre>&#13;
<div data-type="warning" epub:type="warning">&#13;
<p>The preceding code is unsafe to use if the file is empty, such as <em>tests/inputs/empty.fa</em>. If you try to open this file in the same way and call <code>next()</code>, Python will raise a <code>StopIteration</code> exception.<a data-primary="errors" data-secondary="iterating an empty FASTA file" data-type="indexterm" id="idm45963629399912"/><a data-primary="FASTA format" data-secondary="error iterating empty file" data-type="indexterm" id="idm45963629398952"/>&#13;
In your code, I recommend you use a <code>for</code> loop that detects the exhaustion of the iterator and gracefully exits.<a data-primary="iterators" data-secondary="for loop detecting exhaustion of" data-type="indexterm" id="idm45963629397320"/><a data-primary="for loops" data-secondary="iterating input files" data-type="indexterm" id="idm45963629396360"/></p>&#13;
</div>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; empty = SeqIO.parse(open('tests/inputs/empty.fa'), 'fasta')&#13;
&gt;&gt;&gt; next(empty)&#13;
Traceback (most recent call last):&#13;
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;&#13;
  File "/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/&#13;
  site-packages/Bio/SeqIO/Interfaces.py", line 73, in __next__&#13;
    return next(self.records)&#13;
StopIteration</pre>&#13;
&#13;
<p>I need to find all the sequences between 4 and 12 bases long.&#13;
This sounds like another job for k-mers, so I’ll bring in the <code>find_kmers()</code> function from <a data-type="xref" href="ch09.html#ch09">Chapter 9</a>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; def find_kmers(seq, k):&#13;
...     n = len(seq) - k + 1&#13;
...     return [] if n &lt; 1 else [seq[i:i + k] for i in range(n)]&#13;
...</pre>&#13;
&#13;
<p>I can use <code>range()</code> to generate all the numbers between 4 and 12, remembering that the end position is not included so I have to go up to 13.&#13;
As there are many k-mers for each <code>k</code>, I’ll print the value of <code>k</code> and how many k-mers are found:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; for k in range(4, 13):&#13;
...     print(k, len(find_kmers(seq, k)))&#13;
...&#13;
4 22&#13;
5 21&#13;
6 20&#13;
7 19&#13;
8 18&#13;
9 17&#13;
10 16&#13;
11 15&#13;
12 14</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Finding All Reverse Complements" data-type="sect2"><div class="sect2" id="idm45963629388424">&#13;
<h2>Finding All Reverse Complements</h2>&#13;
&#13;
<p>I showed many ways to find the reverse complement in <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>, with the conclusion that <code>Bio.Seq.reverse_complement()</code> is probably the easiest method.<a data-primary="restriction sites" data-secondary="finding all reverse complements" data-type="indexterm" id="idm45963629385752"/><a data-primary="reverse complement of DNA" data-secondary="finding all" data-type="indexterm" id="idm45963629384792"/>&#13;
Start by finding all the 12-mers:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; kmers = find_kmers(seq, 12)&#13;
&gt;&gt;&gt; kmers&#13;
['TCAATGCATGCG', 'CAATGCATGCGG', 'AATGCATGCGGG', 'ATGCATGCGGGT',&#13;
 'TGCATGCGGGTC', 'GCATGCGGGTCT', 'CATGCGGGTCTA', 'ATGCGGGTCTAT',&#13;
 'TGCGGGTCTATA', 'GCGGGTCTATAT', 'CGGGTCTATATG', 'GGGTCTATATGC',&#13;
 'GGTCTATATGCA', 'GTCTATATGCAT']</pre>&#13;
&#13;
<p>To create a list of the reverse complements, you could use a list comprehension:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from Bio import Seq&#13;
&gt;&gt;&gt; revc = [Seq.reverse_complement(kmer) for kmer in kmers]</pre>&#13;
&#13;
<p>Or use <code>map()</code>:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; revc = list(map(Seq.reverse_complement, kmers))</pre>&#13;
&#13;
<p>Either way, you should have 12 reverse complements:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; revc&#13;
['CGCATGCATTGA', 'CCGCATGCATTG', 'CCCGCATGCATT', 'ACCCGCATGCAT',&#13;
 'GACCCGCATGCA', 'AGACCCGCATGC', 'TAGACCCGCATG', 'ATAGACCCGCAT',&#13;
 'TATAGACCCGCA', 'ATATAGACCCGC', 'CATATAGACCCG', 'GCATATAGACCC',&#13;
 'TGCATATAGACC', 'ATGCATATAGAC']</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Putting It All Together" data-type="sect2"><div class="sect2" id="idm45963629377992">&#13;
<h2>Putting It All Together</h2>&#13;
&#13;
<p>You should have just about everything you need to complete this challenge.&#13;
First, pair all the k-mers with their reverse complements, find those that are the same, and print their positions.&#13;
You could iterate through them with a <code>for</code> loop, or you might <span class="keep-together">consider</span> using the <code>zip()</code> function that we first looked at in <a data-type="xref" href="ch06.html#ch06">Chapter 6</a> to create the pairs.&#13;
This is an interesting challenge, and I’m sure you can figure out a working solution before you read my versions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solutions" data-type="sect1"><div class="sect1" id="idm45963629373416">&#13;
<h1>Solutions</h1>&#13;
&#13;
<p>I’ll show three variations to find the restriction sites, which increasingly rely on functions to hide the complexities of the program.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 1: Using the zip() and enumerate() Functions" data-type="sect2"><div class="sect2" id="idm45963629371832">&#13;
<h2>Solution 1: Using the zip() and enumerate() Functions</h2>&#13;
&#13;
<p>In my first solution, I first use <code>zip()</code> to pair the k-mers and reverse complements.&#13;
Assume <code>k=4</code>:<a data-primary="restriction sites" data-secondary="solution 1 zip() and enumerate()" data-type="indexterm" id="idm45963629369560"/><a data-primary="zip() function combining sequences" data-type="indexterm" id="idm45963629368600"/><a data-primary="enumerate() function" data-type="indexterm" id="idm45963629367912"/></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; seq = 'TCAATGCATGCGGGTCTATATGCAT'&#13;
&gt;&gt;&gt; kmers = find_kmers(seq, 4)&#13;
&gt;&gt;&gt; revc = list(map(Seq.reverse_complement, kmers))&#13;
&gt;&gt;&gt; pairs = list(zip(kmers, revc))</pre>&#13;
&#13;
<p>I also need to know the positions of the pairs, which I can get from <code>enumerate()</code>.&#13;
If I inspect the pairs, I see that some of them (4, 6, 16, 17, and 20) are the same:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; pprint(list(enumerate(pairs)))&#13;
[(0, ("TCAA", "TTGA")),&#13;
 (1, ("CAAT", "ATTG")),&#13;
 (2, ("AATG", "CATT")),&#13;
 (3, ("ATGC", "GCAT")),&#13;
 (4, <strong>("TGCA", "TGCA")</strong>),&#13;
 (5, ("GCAT", "ATGC")),&#13;
 (6, <strong>("CATG", "CATG")</strong>),&#13;
 (7, ("ATGC", "GCAT")),&#13;
 (8, ("TGCG", "CGCA")),&#13;
 (9, ("GCGG", "CCGC")),&#13;
 (10, ("CGGG", "CCCG")),&#13;
 (11, ("GGGT", "ACCC")),&#13;
 (12, ("GGTC", "GACC")),&#13;
 (13, ("GTCT", "AGAC")),&#13;
 (14, ("TCTA", "TAGA")),&#13;
 (15, ("CTAT", "ATAG")),&#13;
 (16, <strong>("TATA", "TATA")</strong>),&#13;
 (17, <strong>("ATAT", "ATAT")</strong>),&#13;
 (18, ("TATG", "CATA")),&#13;
 (19, ("ATGC", "GCAT")),&#13;
 (20, <strong>("TGCA", "TGCA")</strong>),&#13;
 (21, ("GCAT", "ATGC"))]</pre>&#13;
&#13;
<p>I can use a list comprehension with a guard to find all the positions where the pairs are the same.&#13;
Note I add 1 to the index values to get 1-based positions:</p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; [pos + 1 for pos, pair in enumerate(pairs) if pair[0] == pair[1]]&#13;
[5, 7, 17, 18, 21]</pre>&#13;
&#13;
<p>In <a data-type="xref" href="ch11.html#ch11">Chapter 11</a>, I introduced the functions <code>fst()</code> and <code>snd()</code> for getting the first or second elements from a 2-tuple.<a data-primary="tuples" data-secondary="fst() to get first element" data-type="indexterm" id="idm45963629358360"/><a data-primary="tuples" data-secondary="snd() to get second element" data-type="indexterm" id="idm45963629357400"/><a data-primary="fst() to get first tuple element" data-type="indexterm" id="idm45963629356440"/><a data-primary="snd() to get second tuple element" data-type="indexterm" id="idm45963629355752"/>&#13;
I’d like to use those here so I don’t have to use indexing with the tuples.&#13;
I also keep using the <code>find_kmers()</code> function from previous chapters.&#13;
It seems like it’s time to put these functions into a separate module so I can import them as needed rather than copying them.</p>&#13;
&#13;
<p>If you inspect the <code>common.py</code> module, you’ll see these functions and their tests.&#13;
I can run <code>pytest</code> to ensure they all pass:</p>&#13;
&#13;
<pre data-type="programlisting">$ pytest -v common.py&#13;
============================= test session starts ==============================&#13;
...&#13;
&#13;
common.py::test_fst PASSED                                               [ 33%]&#13;
common.py::test_snd PASSED                                               [ 66%]&#13;
common.py::test_find_kmers PASSED                                        [100%]&#13;
&#13;
============================== 3 passed in 0.01s ===============================</pre>&#13;
&#13;
<p>Because <code>common.py</code> is in the current directory, I can import any functions I like <span class="keep-together">from it:</span></p>&#13;
&#13;
<pre data-type="programlisting">&gt;&gt;&gt; from common import fst, snd&#13;
&gt;&gt;&gt; [pos + 1 for pos, pair in enumerate(pairs) if fst(pair) == snd(pair)]&#13;
[5, 7, 17, 18, 21]</pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45963629349192">&#13;
<h5>PYTHONPATH</h5>&#13;
<p>You can also place modules of reusable code into a directory that is shared across all your projects.<a data-primary="environment variables" data-secondary="PYTHONPATH" data-type="indexterm" id="idm45963629347816"/><a data-primary="PYTHONPATH environment variable" data-type="indexterm" id="idm45963629346872"/><a data-primary="Python" data-secondary="PYTHONPATH environment variable" data-type="indexterm" id="idm45963629346184"/><a data-primary="PATH environment variable" data-type="indexterm" id="idm45963629345224"/><a data-primary="environment variables" data-secondary="PATH" data-type="indexterm" id="idm45963629344536"/><a data-primary="command line (Unix)" data-secondary="PATH environment variable" data-type="indexterm" id="idm45963629343592"/><a data-primary="Unix command line" data-secondary="PATH environment variable" data-type="indexterm" id="idm45963629342632"/><a data-primary="bash shell" data-secondary="PATH environment variable" data-type="indexterm" id="idm45963629341672"/>&#13;
You can use the <code>PYTHONPATH</code> environment variable to indicate the location of additional directories where Python should look for modules.&#13;
According to <a href="https://oreil.ly/0MpPP">the <code>PYPATH</code> documentation</a>, it will:</p>&#13;
<blockquote>&#13;
<p>Augment the default search path for module files. The format is the same as the shell’s <code>PATH</code>: one or more directory pathnames separated by <code>os.pathsep</code> (e.g., colons on Unix or semicolons on Windows). Nonexistent directories are silently ignored.</p></blockquote>&#13;
&#13;
<p>In <a data-type="xref" href="app02.html#app2_path">Appendix B</a>, I recommend that you install binaries and scripts to a location like <code>$HOME/.local/bin</code> and use something like <code>$HOME/.bashrc</code> to set your <code>PATH</code> to include this directory.&#13;
(I prefer <em>.local</em> so that it is hidden from the normal directory listing.)&#13;
I would likewise suggest you define a location for sharing common Python functions and modules and set your <code>PYTHONPATH</code> to include this location: perhaps something like <code>$HOME/.local/lib</code>.</p>&#13;
</div></aside>&#13;
&#13;
<p>Here is how I incorporated these ideas in the first solution:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    for rec in SeqIO.parse(args.file, 'fasta'): <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-1" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
        for k in range(4, 13): <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-2" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
            kmers = find_kmers(str(rec.seq), k) <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-3" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
            revc = list(map(Seq.reverse_complement, kmers)) <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-4" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
&#13;
            for pos, pair in enumerate(zip(kmers, revc)): <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-5" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-5"><img alt="5" src="assets/5.png"/></a>&#13;
                if fst(pair) == snd(pair): <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-6" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-6"><img alt="6" src="assets/6.png"/></a>&#13;
                    print(pos + 1, k) <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-7" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-7"><img alt="7" src="assets/7.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-1" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Iterate over the records in the FASTA file.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-2" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through all the values of <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-3" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Find the k-mers for this <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-4" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Find the reverse complements of the k-mers.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-5" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Iterate through the positions and pairs of k-mer/reverse complement.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-6" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Check if the first element of the pair is the same as the second element.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-7" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO3-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Print the position plus 1 (to correct for 0-based indexing) and the size of the sequence <code>k</code>.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 2: Using the operator.eq() Function" data-type="sect2"><div class="sect2" id="idm45963629295464">&#13;
<h2>Solution 2: Using the operator.eq() Function</h2>&#13;
&#13;
<p>Though I like the <code>fst()</code> and <code>snd()</code> functions and want to highlight how to share modules and functions, I’m duplicating the <code>operator.eq()</code> function.<a data-primary="restriction sites" data-secondary="solution 2 eq()" data-type="indexterm" id="idm45963629292712"/><a data-primary="eq() function" data-type="indexterm" id="idm45963629291768"/>&#13;
I first introduced this module in <a data-type="xref" href="ch06.html#ch06">Chapter 6</a> to use the <code>operator.ne()</code> (not equal) function, and I’ve also used the <code>operator.le()</code> (less than or equal) and <code>operator.add()</code> functions elsewhere.</p>&#13;
&#13;
<p>I can rewrite part of the preceding solution like so:</p>&#13;
&#13;
<pre data-type="programlisting">for pos, pair in enumerate(zip(kmers, revc)):&#13;
    if operator.eq(*pair): <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO4-1" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
        print(pos + 1, k)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO4-1" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use the functional version of the <code>==</code> operator to compare the elements of the pair. Note the need to splat the pair to expand the tuple into its two values.<a data-primary="equal signs" data-secondary="== (compare for equality)" data-secondary-sortas="# compare for equality" data-tertiary="eq() functional version" data-type="indexterm" id="idm45963629281560"/><a data-primary="== (compare for equality)" data-primary-sortas="# compare for equality" data-secondary="eq() functional version" data-type="indexterm" id="idm45963629280056"/><a data-primary="comparing for equality (==)" data-secondary="eq() functional version" data-type="indexterm" id="idm45963629278824"/></p></dd>&#13;
</dl>&#13;
&#13;
<p>I prefer a list comprehension with a guard to condense this code:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    for rec in SeqIO.parse(args.file, 'fasta'):&#13;
        for k in range(4, 13):&#13;
            kmers = find_kmers(str(rec.seq), k)&#13;
            revc = map(Seq.reverse_complement, kmers)&#13;
            pairs = enumerate(zip(kmers, revc))&#13;
&#13;
            for pos in [pos + 1 for pos, pair in pairs if operator.eq(*pair)]: <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO5-1" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
                print(pos, k)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO5-1" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use a guard for the equality comparison, and correct the position inside a list comprehension.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution 3: Writing a revp() Function" data-type="sect2"><div class="sect2" id="idm45963629270280">&#13;
<h2>Solution 3: Writing a revp() Function</h2>&#13;
&#13;
<p>In this final solution, it behooves me to write a <code>revp()</code> function and create a test.<a data-primary="restriction sites" data-secondary="solution 3 reverse palindromes" data-type="indexterm" id="idm45963629268472"/>&#13;
This will make the program more readable and will also make it easier to move this function into something like the <code>common.py</code> module for sharing in other projects.</p>&#13;
&#13;
<p>As usual, I imagine the signature of my function:</p>&#13;
&#13;
<pre data-type="programlisting">def revp(seq: str, k: int) -&gt; List[int]: <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-1" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Return positions of reverse palindromes """&#13;
&#13;
    return [] <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-2" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-1" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>I want to pass in a sequence and a value for <code>k</code> to get back a list of locations where reverse palindromes of the given size are found.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-2" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>For now, return the empty list.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Here is the test I wrote.&#13;
Note that I decided that the function should correct the indexes to 1-based counting:</p>&#13;
&#13;
<pre data-type="programlisting">def test_revp() -&gt; None:&#13;
    """ Test revp """&#13;
&#13;
    assert revp('CGCATGCATTGA', 4) == [3, 5]&#13;
    assert revp('CGCATGCATTGA', 5) == []&#13;
    assert revp('CGCATGCATTGA', 6) == [2, 4]&#13;
    assert revp('CGCATGCATTGA', 7) == []&#13;
    assert revp('CCCGCATGCATT', 4) == [5, 7]&#13;
    assert revp('CCCGCATGCATT', 5) == []&#13;
    assert revp('CCCGCATGCATT', 6) == [4, 6]</pre>&#13;
&#13;
<p>If I add these to my <code>revp.py</code> program and run <code>pytest revp.py</code>, I’ll see that the test fails as it should.&#13;
Now I can fill in the code:</p>&#13;
&#13;
<pre data-type="programlisting">def revp(seq: str, k: int) -&gt; List[int]:&#13;
    """ Return positions of reverse palindromes """&#13;
&#13;
    kmers = find_kmers(seq, k)&#13;
    revc = map(Seq.reverse_complement, kmers)&#13;
    pairs = enumerate(zip(kmers, revc))&#13;
    return [pos + 1 for pos, pair in pairs if operator.eq(*pair)]</pre>&#13;
&#13;
<p>If I run <code>pytest</code> again, I should get a passing test.&#13;
The <code>main()</code> function is now more readable:</p>&#13;
&#13;
<pre data-type="programlisting">def main() -&gt; None:&#13;
    args = get_args()&#13;
    for rec in SeqIO.parse(args.file, 'fasta'):&#13;
        for k in range(4, 13): <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-1" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-1"><img alt="1" src="assets/1.png"/></a>&#13;
            for pos in revp(str(rec.seq), k): <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-2" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-2"><img alt="2" src="assets/2.png"/></a>&#13;
                print(pos, k) <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-3" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-1" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Iterate through each value of <code>k</code>.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-2" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through each reverse palindrome of size <code>k</code> found in the sequence.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-3" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Print the position and size of the reverse palindrome.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Note that it’s possible to use more than one iterator inside a list comprehension.&#13;
I can collapse the two <code>for</code> loops into a single one, like so:</p>&#13;
&#13;
<pre data-type="programlisting">for k, pos in [(k, pos) for k in range(4, 13) for pos in revp(seq, k)]: <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO8-1" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO8-1"><img alt="1" src="assets/1.png"/></a>&#13;
    print(pos, k)</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO8-1" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>First iterate the <code>k</code> values, then use those to iterate the <code>revp()</code> values, returning both as a tuple.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I would probably not use this construct.&#13;
It reminds me of my old coworker, Joe, who would joke: “If it was hard to write, it should be hard to read!”</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing the Program" data-type="sect1"><div class="sect1" id="idm45963629223672">&#13;
<h1>Testing the Program</h1>&#13;
&#13;
<p>I’d like to take a moment to look at the integration test in <em>tests/revp_test.py</em>.<a data-primary="restriction sites" data-secondary="testing" data-type="indexterm" id="idm45963629221880"/>&#13;
The first two tests are always the same, checking for the existence of the expected program and that the program will produce some usage statement when requested.&#13;
For a program that accepts files as inputs such as this one, I include a test that the program rejects an invalid file.&#13;
I usually challenge other inputs too, like passing strings when integers are expected, to ensure the arguments are rejected.</p>&#13;
&#13;
<p>After I’ve checked that the arguments to the program are all validated, I start passing good input values to see that the program works as expected.&#13;
This requires that I use valid, known input and verify that the program produces the correct, expected output.&#13;
In this case, I encode the inputs and outputs using files in the <em>tests/inputs</em> directory.&#13;
For instance, the expected output for the input file <em>1.fa</em> is found in <em>1.fa.out</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ ls tests/inputs/&#13;
1.fa          2.fa          empty.fa&#13;
1.fa.out      2.fa.out      empty.fa.out</pre>&#13;
&#13;
<p class="pagebreak-before">The following is the first input:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.fa&#13;
&gt;Rosalind_24&#13;
TCAATGCATGCGGGTCTATATGCAT</pre>&#13;
&#13;
<p>and the expected output is:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat tests/inputs/1.fa.out&#13;
5 4&#13;
7 4&#13;
17 4&#13;
18 4&#13;
21 4&#13;
4 6&#13;
6 6&#13;
20 6</pre>&#13;
&#13;
<p>The second input file is significantly larger than the first.&#13;
This is common with the Rosalind problems, and so it would be ugly to try to include the input and output values as literal strings in the test program.&#13;
The expected output for the second file is 70 lines long.&#13;
The last test is for an empty file, and the expected output is the empty string.&#13;
While that may seem obvious, the point is to check that the program does not throw an exception on an empty input file.</p>&#13;
&#13;
<p>In <em>tests/revp_test.py</em>, I wrote a <code>run()</code> helper function that takes the name of the input file, reads the expected output filename, and runs the program with the input to check the output:</p>&#13;
&#13;
<pre data-type="programlisting">def run(file: str) -&gt; None: <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-1" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-1"><img alt="1" src="assets/1.png"/></a>&#13;
    """ Run the test """&#13;
&#13;
    expected_file = file + '.out' <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-2" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-2"><img alt="2" src="assets/2.png"/></a>&#13;
    assert os.path.isfile(expected_file) <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-3" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-3"><img alt="3" src="assets/3.png"/></a>&#13;
&#13;
    rv, out = getstatusoutput(f'{PRG} {file}') <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-4" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-4"><img alt="4" src="assets/4.png"/></a>&#13;
    assert rv == 0 <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-5" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-5"><img alt="5" src="assets/5.png"/></a>&#13;
&#13;
    expected = set(open(expected_file).read().splitlines()) <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-6" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-6"><img alt="6" src="assets/6.png"/></a>&#13;
    assert set(out.splitlines()) == expected <a class="co" href="#callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-7" id="co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-7"><img alt="7" src="assets/7.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-1" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The function takes the name of the input file.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-2" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The output file is the name of the input file plus <em>.out</em>.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-3" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Make sure the output file exists.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-4" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Run the program with the input file and capture the return value and output.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-5" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Make sure the program reported a successful run.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-6" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Read the expected output file, breaking the contents on lines and creating a set of the resulting strings.</p></dd>&#13;
<dt><a class="co" href="#co_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-7" id="callout_location_restriction_sites___span_class__keep_together__using__testing__and_sharing_code__span__CO9-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Break the output of the program on lines and create a set to compare to the expected results. Sets allow me to disregard the order of the lines.</p></dd>&#13;
</dl>&#13;
&#13;
<p>This simplifies the tests.&#13;
Note that the <code>INPUT*</code> and <code>EMPTY</code> variables are declared at the top of the module:</p>&#13;
&#13;
<pre data-type="programlisting">def test_ok1() -&gt; None:&#13;
    run(INPUT1)&#13;
&#13;
def test_ok2() -&gt; None:&#13;
    run(INPUT2)&#13;
&#13;
def test_mepty() -&gt; None:&#13;
    run(EMPTY)</pre>&#13;
&#13;
<p>I would encourage you to spend some time reading the <em>*_test.py</em> files for every program.<a data-primary="test-driven development (TDD)" data-secondary="about" data-type="indexterm" id="idm45963629173640"/>&#13;
I hope that you will integrate testing into your development workflow, and I’m sure you can find ample code to copy from my tests, which will save you time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Further" data-type="sect1"><div class="sect1" id="idm45963629172056">&#13;
<h1>Going Further</h1>&#13;
&#13;
<p>The minimum (4) and maximum (12) values for the length of the sites are hardcoded in the program. Add command-line parameters to pass these as integer options using those default values. Change the code to use the given values, and add tests to ensure the correct sites are found for different ranges of these values.</p>&#13;
&#13;
<p>Write a program that can identify English palindromes such as “A man, a plan, a canal—Panama!” Start by creating a new repository. Find several interesting palindromes to use in your tests. Be sure to provide phrases that are not palindromes and verify that your algorithm rejects those, too. Release your code to the internet, and reap the fame, glory, and profit of writing open source software.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="idm45963629169304">&#13;
<h1>Review</h1>&#13;
&#13;
<p>Key points from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You can reuse functions by placing them into a module and importing them as needed.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>PYTHONPATH</code> environment variable indicates directories which Python should search when looking for modules of code.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>