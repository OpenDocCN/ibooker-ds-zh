- en: 'Chapter 12\. Structured Data: NumPy’s Structured Arrays'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While often our data can be well represented by a homogeneous array of values,
    sometimes this is not the case. This chapter demonstrates the use of NumPy’s *structured
    arrays* and *record arrays*, which provide efficient storage for compound, heterogeneous
    data. While the patterns shown here are useful for simple operations, scenarios
    like this often lend themselves to the use of Pandas `DataFrame`s, which we’ll
    explore in [Part III](part03.xhtml#section-0300-introduction-to-pandas).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Imagine that we have several categories of data on a number of people (say,
    name, age, and weight), and we’d like to store these values for use in a Python
    program. It would be possible to store these in three separate arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But this is a bit clumsy. There’s nothing here that tells us that the three
    arrays are related; NumPy’s structured arrays allow us to do this more naturally
    by using a single structure to store all of this data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that previously we created a simple array using an expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can similarly create a structured array using a compound data type specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here `'U10'` translates to “Unicode string of maximum length 10,” `'i4'` translates
    to “4-byte (i.e., 32-bit) integer,” and `'f8'` translates to “8-byte (i.e., 64-bit)
    float.” We’ll discuss other options for these type codes in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve created an empty container array, we can fill the array with
    our lists of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we had hoped, the data is now conveniently arranged in one structured array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handy thing with structured arrays is that we can now refer to values either
    by index or by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Boolean masking, we can even do some more sophisticated operations, such
    as filtering on age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you’d like to do any operations that are any more complicated than these,
    you should probably consider the Pandas package, covered in [Part IV](part04.xhtml#section-0400-introduction-to-matplotlib).
    As you’ll see, Pandas provides a `DataFrame` object, which is a structure built
    on NumPy arrays that offers a variety of useful data manipulation functionality
    similar to what you’ve seen here, as well as much, much more.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Structured Array Creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structured array data types can be specified in a number of ways. Earlier,
    we saw the dictionary method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For clarity, numerical types can be specified using Python types or NumPy `dtype`s
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A compound type can also be specified as a list of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the names of the types do not matter to you, you can specify the types alone
    in a comma-separated string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The shortened string format codes may not be immediately intuitive, but they
    are built on simple principles. The first (optional) character `<` or `>`, means
    “little endian” or “big endian,” respectively, and specifies the ordering convention
    for significant bits. The next character specifies the type of data: characters,
    bytes, ints, floating points, and so on (see [Table 12-1](#table-12-1)). The last
    character or characters represent the size of the object in bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1\. NumPy data types
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `''b''` | Byte | `np.dtype(''b'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `''i''` | Signed integer | `np.dtype(''i4'') == np.int32` |'
  prefs: []
  type: TYPE_TB
- en: '| `''u''` | Unsigned integer | `np.dtype(''u1'') == np.uint8` |'
  prefs: []
  type: TYPE_TB
- en: '| `''f''` | Floating point | `np.dtype(''f8'') == np.int64` |'
  prefs: []
  type: TYPE_TB
- en: '| `''c''` | Complex floating point | `np.dtype(''c16'') == np.complex128` |'
  prefs: []
  type: TYPE_TB
- en: '| `''S''`, `''a''` | String | `np.dtype(''S5'')` |'
  prefs: []
  type: TYPE_TB
- en: '| `''U''` | Unicode string | `np.dtype(''U'') == np.str_` |'
  prefs: []
  type: TYPE_TB
- en: '| `''V''` | Raw data (void) | `np.dtype(''V'') == np.void` |'
  prefs: []
  type: TYPE_TB
- en: More Advanced Compound Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to define even more advanced compound types. For example, you
    can create a type where each element contains an array or matrix of values. Here,
    we’ll create a data type with a `mat` component consisting of a <math alttext="3
    times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math> floating-point matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now each element in the `X` array consists of an `id` and a <math alttext="3
    times 3"><mrow><mn>3</mn> <mo>×</mo> <mn>3</mn></mrow></math> matrix. Why would
    you use this rather than a simple multidimensional array, or perhaps a Python
    dictionary? One reason is that this NumPy `dtype` directly maps onto a C structure
    definition, so the buffer containing the array content can be accessed directly
    within an appropriately written C program. If you find yourself writing a Python
    interface to a legacy C or Fortran library that manipulates structured data, structured
    arrays can provide a powerful interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Record Arrays: Structured Arrays with a Twist'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NumPy also provides record arrays (instances of the `np.recarray` class), which
    are almost identical to the structured arrays just described, but with one additional
    feature: fields can be accessed as attributes rather than as dictionary keys.
    Recall that we previously accessed the ages in our sample dataset by writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we view our data as a record array instead, we can access this with slightly
    fewer keystrokes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The downside is that for record arrays, there is some extra overhead involved
    in accessing the fields, even when using the same syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Whether the more convenient notation is worth the (slight) overhead will depend
    on your own application.
  prefs: []
  type: TYPE_NORMAL
- en: On to Pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter on structured and record arrays is purposely located at the end
    of this part of the book, because it leads so well into the next package we will
    cover: Pandas. Structured arrays can come in handy in certain situations, like
    when you’re using NumPy arrays to map onto binary data formats in C, Fortran,
    or another language. But for day-to-day use of structured data, the Pandas package
    is a much better choice; we’ll explore it in depth in the chapters that follow.'
  prefs: []
  type: TYPE_NORMAL
