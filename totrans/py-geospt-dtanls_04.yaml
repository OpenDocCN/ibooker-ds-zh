- en: 'Chapter 4\. Geospatial Analytics in the Cloud: Google Earth Engine and Other
    Tools'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you access geospatial data? Although data professionals with enterprise
    accounts may not think about the limitations of personal computing and relying
    on open source data, the rest of us often work within limits. Geospatial analysis
    in the cloud has narrowed the divide, since that means we no longer need to store
    large volumes of data locally. Never before has the general public had open source
    access to geospatial data on such a global scale. This chapter will show you where
    to find data for exploration and learning.
  prefs: []
  type: TYPE_NORMAL
- en: Space programs in the US and around the world have gathered data from satellites
    and sensors for decades, but only recently have we had the capacity to manipulate
    that data in real time for analysis. The USGS hosts [EarthExplorer](https://oreil.ly/OnxdN)
    (Landsat), and the [Copernicus Open Access Hub](https://oreil.ly/gnY7c) provides
    data from European Space Agency (ESA) Sentinel satellites. Landsat high-resolution
    satellite images enable us to evaluate and measure environmental change, understand
    the impact of climate science and agricultural practices, and respond to natural
    disasters across time and space, to name a few examples. The advent of free satellite
    images has enabled decision makers from economically challenged areas across the
    world to bring insights into view and focus on solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Spatial analysis* includes methods and tools applied to location data, in
    which the results vary based on the location or frame analyzing the object. It
    is essentially “location-specific” analysis. This can be as simple as locating
    the nearest subway station or asking how many green spaces or parks are in a community,
    or as complex as revealing patterns in transportation accessibility or health
    outcomes. *Spatial algorithms* are a method of solving a problem by listing and
    executing sequential instructions integrated with geographic properties, used
    for analysis, modeling, and prediction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GIS solve spatial problems that rely on location information like latitude,
    longitude, and projection. Spatial information answers “where” questions: where
    on the Earth’s surface did something occur?'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine, for example, stepping out of your hotel on 41st and Madison Avenue
    in Manhattan. You search in your mapping app for where you might purchase a coat,
    since the weather is dramatically colder than you anticipated. Instantly, the
    locations of apparel stores populate your screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or on the marketing side, say you work for an outdoor provision company, producing
    top-of-the-line outerwear for the discerning customer. You could use geospatial
    information to answer questions like: Where do your potential customers live,
    visit, or travel? Would a potential retail location nearby be a profitable marketing
    decision? How far would potential customers travel? What is the mean income within
    each of the locations you are considering? These *where* components exist in retail
    and commercial environments, the military, climate science, and health care, to
    name a few examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes are another important component of spatially referenced data. *Spatial
    attributes* are bounded in space; these could include a community boundary or
    infrastructure, such as a roadway or metro station, usually represented by a polygon.
    Spatially referenced data can also have nonspatial attributes, such as the income
    of residents in a certain location, and can provide context for the location intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *I* in GIS is increasingly being stored in the cloud. Today your laptop
    can access petabytes of information made available by geospatial analytics processing
    services in the cloud. This chapter will explore one of those services: [Google
    Earth Engine (GEE)](https://oreil.ly/ukyb0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2007, Jim Gray, a computer scientist at Microsoft until he was lost at sea
    later that year, was quite prescient when he said: “For data analysis, one possibility
    is to move the data to you, but the other possibility is to move your query to
    the data. You can either move your questions or the data. Often it turns out to
    be more efficient to move the questions than to move the data.” That’s the basic
    principle behind doing geospatial analytics in the cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll use GEE to perform a variety of tasks associated with
    geographic properties in spatial environments. We’ll also take a quick look at
    another tool that integrates with Python: Leafmap. By the end of the chapter,
    you’ll have enough familiarity with these interfaces to follow along with later
    chapters and eventually launch your own independent project.'
  prefs: []
  type: TYPE_NORMAL
- en: Google Earth Engine Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But first, you’ll need to create your work environments. The Jupyter Notebooks
    for this chapter are available on [GitHub](https://oreil.ly/SbS0R). You can open
    them up and follow along or experiment with the code and explore separately when
    time permits. The instructions for installing the necessary packages and resources
    will be covered as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GEE archive contains more than 60 *petabytes* of satellite imagery and
    remote sensing and geospatial data—all freely available, preprocessed, and easy
    to access. Imagine trying to download all that to your laptop! GEE’s algorithms
    allow the public to create interactive applications or data products in the cloud.
    You just need to apply for a free [Google Earth Engine account](https://oreil.ly/xVOCN)
    (which comes with 250 gigabytes of storage) and authenticate within either the
    terminal or notebook when you are granted access. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: GEE will send you a unique link and verification code. Paste the code into the
    box and hit Enter.
  prefs: []
  type: TYPE_NORMAL
- en: Using the GEE Console and geemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GEE console is a quick resource for locating images and running the code.
    But Python isn’t GEE’s native language: the GEE code editor is designed for writing
    and executing scripts in JavaScript. Its Javascript API has a robust IDE, extensive
    documentation, and interactive visualization functionality, and none of that is
    natively available for Python. To access the full spectrum of interactivity in
    a Python environment, you will need to use [geemap](https://geemap.org), a Python
    package for interacting with GEE created by [Dr. Qiusheng Wu](https://oreil.ly/bGQq1).'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you can use the extensive GEE catalog to locate and visualize data
    with a single click, with limited or no JavaScript expertise. You can find your
    way around the interface and generate maps simply by scrolling through the Scripts
    tab. Each code script allows you to run JavaScript code and generate maps. But
    if you’re seeking autonomy to build your own maps and engage interactively, you’ll
    want to use geemap. The GEE catalog (pictured in [Figure 4-1](#the_gee_console))
    contains useful information you will need when deciding how to interact with data
    in geemap.
  prefs: []
  type: TYPE_NORMAL
- en: '![The GEE console](assets/pgda_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. The GEE catalog
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Look through the Earth Engine Data Catalog, find a dataset [collection](https://oreil.ly/yAow0),
    and scroll down the page. At the bottom, you will notice that the JavaScript code
    is provided. Simply copy and paste it into the console, as shown in [Figure 4-2](#google_earth_engine_ide).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-2](#google_earth_engine_ide) shows what is generated when you paste
    the code into the console and select Run from the list of options in the center
    panel. For example, the data from [Figure 4-1](#the_gee_console) generates USGS
    Landsat 8 Level 2, Collection 2, Tier 1, identified as `ee.ImageCollection("LANDSAT/LC08/C02/T1_L2")`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Google Earth Engine IDE](assets/pgda_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Google Earth Engine IDE
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s learn how to generate GEE images using Python scripts in a Jupyter Notebook.
    geemap even has a tool that will convert JavaScript code to Python right in your
    Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter Notebook is a separate entity from your Python environments. It was
    originally named for its ability to to interact with three different coding languages,
    Julia, Python, and R, but it has expanded well beyond its original capabilities.
    You have to tell the system which version of Python you want. The *kernel* is
    how the Notebook and Python communicate.
  prefs: []
  type: TYPE_NORMAL
- en: Installing geemap will create a console in a Notebook environment similar to
    what you see in the GEE console but with the Python API instead of JavaScript.
    Once you set up a Conda environment, you will be able to interact with GEE within
    a Jupyter Notebook. First, you will need to download the required packages and
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Conda Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Anaconda](https://www.anaconda.com) is a popular platform-agnostic distribution
    manager for Python and other programming languages that installs and manages Conda
    packages. You could think of Anaconda as storage for all of your data science
    tools. Conda manages your packages and tools, allowing you to upload new tools
    as needed and to customize your work environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Conda packages are stored in the Anaconda repository or the cloud, so you don’t
    need additional tools for installation. Conda allows you to make as many environments
    as you need with your preferred version of Python. You also have the option of
    downloading a leaner version of Anaconda called [Miniconda](https://oreil.ly/nh0LE),
    which I prefer, regardless of your operating system. Both are straightforward
    installations. I recommend the Miniconda installation instructions in [this tutorial
    by Ted Petrou](https://oreil.ly/nPTlh).
  prefs: []
  type: TYPE_NORMAL
- en: Opening the Jupyter Notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jupyter Notebooks are open source, interactive, web-based tools. They run in
    your browser and don’t require any additional downloads. You can access the Jupyter
    Notebook for this chapter on [GitHub](https://oreil.ly/SbS0R): the filename is
    *4 Geospatial Analytics in the Cloud*. You can find and configure the installed
    *nbextensions* in the file menu of your Notebook. These are handy plug-ins that
    add more functionality to your Jupyter Notebook environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing geemap and Other Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you’ve installed your Conda environment, you can open your terminal or
    command prompt to install geemap. Execute the following code line by line to activate
    your work environment. Here, I’ve named my geospatial environment `gee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that I specified the version of Python to include in the environment.
    I’ve done this because there are still some dependencies that aren’t ready for
    the latest version of Python. That is one important reason why environments are
    useful: you will receive a warning if there are compatibility conflicts, and you
    can create an environment using the version that will avoid those conflicts.'
  prefs: []
  type: TYPE_NORMAL
- en: This install also includes Cartopy, a Python package for geospatial data processing;
    `jupyter_contrib_nbextensions`, a package for expanded functionality; and `contrib_nbextensions`,
    which will add styles to the Jupyter configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve installed the packages into your environment, whenever you
    open a new session, you will only need to run `import geemap` in a code cell.
    The environment is now visible when you activate, shown here as `(gee)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This environment will contain all of the associated packages as well as their
    dependencies. You can create different environments (abbreviated as `env`) that
    include the dependencies and packages unique to each project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `conda list` command will show you which packages are installed in the
    active environment. This following is a snippet of what loads for me when I execute
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is helpful in case your code throws an error due to a missing dependency.
    Run `conda list`; you should see the versions listed as well. Running `conda env
    list` will display any environments you already have installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'I install a kernel (a part of the operating system running in your environment)
    for each environment that I activate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can add the kernel to your environment—in this case, `*<your environment
    name>*` is `gee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Your local computer has to access files. The `import` statement will add the
    package as a Python *object* (that is, a collection of data and methods) into
    the currently running instance of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Terminal and write `**jupyter notebook**` into the console. A Notebook
    should open in your browser. You will need to import the required libraries into
    the Notebook. You can see them listed in the code shell. Recall that `os` allows
    you to access the operating system where you are running Python, `ee` is the Earth
    Engine library, and `geemap` allows you to interface via Python. You’ll import
    these libraries using the `import` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The central component of a computer operating system is the *kernel*. The kernel
    is specific to each programming language, and the default kernel depends on what
    version of Python you are running in your Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to restart the kernel for the update to take effect. Select Kernel
    from the menu and scroll to the option to rerun. You are now ready to begin working
    in the Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the hash symbol (#) in the last line of the previous code block. In Python
    code, the hash symbol denotes a *comment*, or a line of the code that won’t run.
    When you want to run that line of code, delete the hash symbol. To make sure you
    are using an updated geemap package, *uncomment* that last line (that is, remove
    the # in the last row) before running the code. Once you update geemap, you can
    once again insert the hash, since you won’t need to update the package every time
    you run the code. You may also add commented text to include any clarifying details.
    You will see this practice in many of the code blocks in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating geemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned objects earlier. Python focuses on objects, instead of what you
    may be familiar with as *functions* in other programming languages, so it’s known
    as an *object-oriented* programming language.
  prefs: []
  type: TYPE_NORMAL
- en: You may recall from earlier chapters that a *class* is like a blueprint of a
    building  The building is the object, but many buildings can be built from a set
    of blueprints, right? The object in a specific line of code is an *instance* of
    the class much in the same way that a building is an *instance* of those blueprints.
    Creating the object is called *instantiation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code block is declaring an object instance, which I’m calling `m``ap`,
    and defining the attributes and methods in `geemap.Map()`. You can set your variable
    to anything you would like, but be consistent. I suggest keeping it simple but
    informative and practical. You’ll access the attributes of objects using the object
    name `map`. geemap defaults to a world map (as of this writing). If you prefer
    to center your map in a specific place, you can indicate where using latitude/longitude
    (lat/lon) coordinates and a zoom level. The following will center your map on
    the US:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Layers and Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 4-3](#the_layers_and_tools_menu) shows the Layers and Tools menu on
    the far right of the map. Each layer of a map is actually its own database that
    holds collections of geographic data. These might include roads, buildings, streams,
    or lakes, all represented as collections of points, lines, and/or polygons in
    vector data or imagery represented from raster data. The Layers icon will show
    you the different layers in your map. You can change their opacity, toggle layers
    on and off, and examine other attributes. Enter the following code to render a
    map in your notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![The Layers and Tools menu](assets/pgda_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. The Layers and Tools menu
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Click the different options to see how they customize the map.
  prefs: []
  type: TYPE_NORMAL
- en: The globe icon (on the far left in [Figure 4-4](#searching_location_data_using_gee_asset))
    is the search location/data function. This is where you can find data to load
    onto your map by entering a name and address or a set of lat/lon coordinates or
    by searching and importing data. We will explore more of these options as we build
    a few map layers, and I’ll show you some shortcuts to help you navigate the mapping
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Searching location data using GEE asset ID (Landsat/LC08/C01) in the import
    window](assets/pgda_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. Searching location data using GEE asset ID (Landsat/LC08/C01) in
    the import window
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can access USGS Landsat maps by entering the search parameters in geemap.
    Select “data” and enter a few terms into the search bar. Again, exploring GEE
    may help to identify maps of interest. You can call them to your own project here
    by name. Once you select a Landsat collection and select the asset ID, click the
    import button (seen in blue in [Figure 4-4](#searching_location_data_using_gee_asset)).
  prefs: []
  type: TYPE_NORMAL
- en: To see available arguments and additional customization options, place your
    cursor within the parentheses of `geemap.Map()` and hit Shift + Tab. The text
    below the map in [Figure 4-5](#a_basemap_in_gee_with_docstring) should now be
    visible. Here you can read information about available arguments and additional
    steps for further customization of the map.
  prefs: []
  type: TYPE_NORMAL
- en: '![A basemap in GEE with docstring](assets/pgda_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. A basemap in GEE with docstring
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Basemaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Revisit [Figure 4-3](#the_layers_and_tools_menu) for a moment, and look on
    the far right for a dropdown menu. This menu contains a dictionary of available
    *basemaps*: basic maps that serve as the foundation for your data exploration.
    The Jupyter Notebook lets you scroll through available basemaps without writing
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your data question or the nature of the data, you may want to show
    different geospatial information. For example, if you are interested in showing
    *hydrography* (the physical characteristics and navigability of bodies of water),
    you likely won’t select a basemap that depicts major roadways and highways. Basemaps
    are stored as raster or vector tiles for expediency and performance. The basemap
    dictionary interacts with a *TileLayer*, allowing connections with map services
    such as NASA’s [Global Imagery Browse Services (GIBS)](https://oreil.ly/AOwFm)
    and [OpenStreetMap](https://oreil.ly/1Ti4J).
  prefs: []
  type: TYPE_NORMAL
- en: 'The geemap package brings all the analytic functionality of GEE into *ipyleaflet,*
    an interactive library that brings mapping into your notebook, allowing the dynamic
    updates you see in the maps as you update locations and zoom levels. The default
    map in geemap is the Google Maps global view. You’re going to use OSM as your
    basemap next, so run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Advanced users have the option of creating their own TileLayer, but a variety
    of other default basemaps are freely available in the [ipyleaflet map and basemaps](https://oreil.ly/HJJbT)
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to load a map into your Notebook, let’s get brave and
    start experimenting. The goal is for you to get curious and feel comfortable navigating
    the Jupyter Notebook and selecting different tools.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Landsat 9 Image Collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been working with Landsat data, so let’s look at the Landsat 9 data,
    which was first released in early 2022 and still rolling out as of this writing.
    To see how much of the dataset is available, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs: `106919`.'
  prefs: []
  type: TYPE_NORMAL
- en: The collection includes 106,919 images—and is still increasing!
  prefs: []
  type: TYPE_NORMAL
- en: 'For comparison, the Landsat/LC08/C02/T1_L2 collection contains 1,351,632 images.
    By the time this book is published, the number of Landsat 9 images will be vastly
    larger. You can calculate the median value of all matching bands to reduce the
    size of the image collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Working with Spectral Bands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in [Chapter 1](ch01.xhtml#introduction_to_geospatial_analytics),
    *spectral bands* are like bins of different types of light. Reflected light is
    captured as bands of light energy in a range of different wavelengths or colors.
    Think of the electromagnetic spectrum. Each section of the spectrum is actually
    a band. The information about bands in this section is intended to highlight where
    to locate the data to enter into the code to access the correct information. The
    [bands](https://oreil.ly/NN6Eq) collected by Landsat 8 apply to Landsat 9\. You
    will need this data to apply *scaling factors*, or comparisons of linear distances
    that adjust for distortion of areas and angles based on the map projection (also
    covered in [Chapter 1](ch01.xhtml#introduction_to_geospatial_analytics)). Remember,
    the Earth is shaped as an ellipsoid, not a perfect sphere! We derive scaling factors
    from the Scale and the Offset, as shown in [Figure 4-6](#band_characteristics_of_landsat_eightso).
  prefs: []
  type: TYPE_NORMAL
- en: '![Band characteristics of Landsat 8/9 data](assets/pgda_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. Band characteristics of Landsat 8/9 data
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The USGS provides guidance on which spectral bands are best for different types
    of research. You can learn [more about the science](https://oreil.ly/vTrFF) and
    explore [common Landsat band combinations](https://oreil.ly/HdXC0).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll import *ee.ImageCollection* into your Jupyter Notebook and add it as
    a data layer to your map. You’ll then create a composite image from all of the
    images. This will yield the median value of the spectral bands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we define functions by the keyword `def`. In the following code,
    the function name is `apply_scale_factors`, followed by the parameter `(image)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The asterisk (*) tells the function that you want to select multiple bands
    that meet the defined search requirements. Landsat’s sensors are the Operational
    Land Imager (OLI) and Thermal Infrared Sensor (TIRS). The OLI produces spectral
    bands 1 through 9, and TIRS consists of two thermal bands: SR_B and ST_B.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The colon (:) signals where the function body begins. Inside the function body,
    which is indented, the `return` statement determines the value to be returned.
    After the function definition is complete, calling the function with an argument
    returns a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To understand why you would want to pick and choose certain bands, think of
    them as having a spectral signature. Natural color bands use SR_B4 for red, SR_B3
    for green, and SR_B2 for blue. Green indicates healthy vegetation, brown is less
    healthy, whitish gray typically indicates urban features, and water will appear
    dark blue or black.
  prefs: []
  type: TYPE_NORMAL
- en: 'The near-infrared (NIR) composite uses NIR (SR_B5), red (SR_B4), and green
    (SR_B3). Areas in red have better vegetation health, dark areas are water, and
    urban areas are white. So include these as your visualization parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add them as data layers to your map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In [Figure 4-7](#different_band_combinations_of_landsat), I toggled the infrared
    layer off so you can see the other bands more clearly. There appears to be cloud
    cover as well. Landsat 9 resamples every 16 days, so it will look different when
    you view it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Different band combinations of Landsat 8/9](assets/pgda_0407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. Different band combinations of Landsat 8/9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you hover your cursor over the toolbar icon, you will see the Layers menu
    appear. You can change the opacity of any maps and deselect any layers you don’t
    want to view in the Layers menu. You can also click the gear icon to explore attributes.
    You can also specify the minimum and maximum values to display. Stretching the
    data spreads the pixel values, and you can experiment with different values. Your
    data will show the range of the bands, and you can decide which values you want
    to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To add labels for these layers, create a list of labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then assign a label to each layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Examining two more parameters in [Figure 4-8](#landsat_band_combinations), you
    can also see shortwave infrared. Here, darker green indicates dense vegetation,
    urban areas are shown in blue, healthy vegetation is green, and bare earth is
    magenta.
  prefs: []
  type: TYPE_NORMAL
- en: '![Landsat band combinations](assets/pgda_0408.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8\. Landsat band combinations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s apply your introduction to GEE and geemap to begin exploring.
  prefs: []
  type: TYPE_NORMAL
- en: The National Land Cover Database Basemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [National Land Cover Database (NLCD)](https://oreil.ly/xNJul) tracks land
    cover in the US. It is freely available in the [Earth Engine Data Catalog](https://oreil.ly/1IuYF)
    and is updated every five years. *Land cover* data includes spatial reference
    and land surface characteristics, such as tree canopy cover (which we explored
    in the last chapter), impervious surfaces, and additional patterns of biodiversity
    and climate changes. *Impervious land cover* means nonnatural surfaces, such as
    asphalt, concrete, or other manmade layers, that limit the natural penetration
    of rainwater into soil. This information can help predict which areas may be more
    prone to flooding during heavy rains.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll use NLCD data to perform a Landsat-based examination
    of the imperviousness data layer (for urban classes) and of decision-tree classification
    (for the rest). We won’t be doing a full activity here, just a quick orientation,
    but I encourage you to explore more.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to the [Earth Engine Data Catalog](https://oreil.ly/oWZcr) and scroll
    to NLCD_Releases/2019_REL/NLCD or the National Land Cover Database, as shown in
    [Figure 4-9](#the_earth_engine_data_catalog). Earlier we noted that you can simply
    add this data to the map, but there are a few more options here that I want to
    show you. Copy the JavaScript code and place it on your clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Earth Engine Data Catalog](assets/pgda_0409.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-9\. The Earth Engine Data Catalog
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The NLCD catalog provides a wealth of information, including date ranges for
    collection, the data source, an image snippet, a data description, information
    about the multispectral bands, and image properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In geemap, generate a default map of the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, select the convert JavaScript icon. The box shown in [Figure 4-9](#the_earth_engine_data_catalog)
    will pop up. Paste the JavaScript code from the catalog into the box. Follow the
    instructions in the code comments that populate in the pop-up shown in [Figure 4-10](#using_geemap_to_convert_a_script_from_j):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once you hit Convert, you will see the code update from JavaScript to Python,
    as shown in [Figure 4-10](#using_geemap_to_convert_a_script_from_j).
  prefs: []
  type: TYPE_NORMAL
- en: '![Using geemap to convert a script from JavaScript to Python](assets/pgda_0410.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-10\. Using geemap to convert a script from JavaScript to Python
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the code does not update into a new cell in your Jupyter Notebook, you can
    cut and paste it into a new cell and run the cell. The image will now appear as
    your map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s include the default NLCD legend. Select the landcover layer. To discover
    which legends are available as defaults, run the `builtin_legend` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The NLCD’s legend will be listed as an option. Select it to add it to your map.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Custom Legend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the NLCD offers a built-in legend option, many datasets do not—and even
    when they do, these legends don’t always offer exactly what you need. Thus, it’s
    helpful to be able to create your own map legend. Let’s look at how to do that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The classes in a dataset usually correspond to the categories you’d want in
    a legend. Fortunately, you can convert a class table to a legend.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your data is from the GEE data catalog, you can find a class table there.
    Then use the following code (or find this code cell in your Jupyter Notebook)
    and copy the text from the class table into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can find more info on building and customizing legends manually in the [geemap
    documentation](https://geemap.org).
  prefs: []
  type: TYPE_NORMAL
- en: Now you can explore your map and dig deeper into your areas of interest. What
    questions do you want to ask of this map? Take some time to explore. There are
    many different ways to customize your maps with a broad selection of tools!
  prefs: []
  type: TYPE_NORMAL
- en: The [GEE catalog](https://oreil.ly/3Q25Z) is extensive. As you explore different
    databases and datasets using the skills you’ve learned here, you will be able
    to work with raster and vector data as well as upload your own data sources. A
    list of handy additional functions in geemap is available on the [geemap GitHub
    page](https://geemap.org/usage). However, I’d also like to introduce you to an
    alternative to GEE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leafmap: An Alternative to Google Earth Engine'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualizing geospatial data outside of GEE does not have to be limiting! If
    you don’t have access to a GEE account or aren’t interested in working with GEE,
    consider using Leafmap. Leafmap is a Python package that lets you visualize interactive
    geospatial data in your Jupyter Notebook environment. It is based on the geemap
    package you have already experienced, but as you will see in this section, Leafmap
    provides access to geospatial data outside the GEE platform. Its GUI reduces the
    amount of coding you need to do. It has a variety of open source packages at its
    core.
  prefs: []
  type: TYPE_NORMAL
- en: Leafmap works with many different plotting backends*,* including ipyleaflet*.*
    (A *backend*, in this context, is internal code that runs on a server and receives
    client requests.) Users don’t see backends, but they are always operating nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the Jupyter Notebook Leafmap with the [GitHub link](https://oreil.ly/9ADWy).
    Follow the [Leafmap documentation](https://oreil.ly/f2Ztx) for specific installation
    instructions depending on your version of Python. (If you aren’t sure what version
    you have, enter `**python**` in the terminal, and it will output the number of
    the version you have installed. This is important to remember in case you run
    into issues with your installation of packages.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set up a new environment to work with Leafmap. I originally created
    the Conda environment shown in the following code with Python 3.8, but it is likely
    to work with later versions. I named this environment `geo` because it is running
    in a different version of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, to open the Notebook, type `**jupyter notebook**` and hit Enter.
    Now enter the following code into the Notebook to reveal something similar to
    [Figure 4-11](#installing_basemaps_in_leafmap):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Installing basemaps in Leafmap](assets/pgda_0411.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-11\. Installing basemaps in Leafmap
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Changing the basemap is as easy as placing your cursor inside the basemap parentheses
    and selecting Tab on the keyboard. [Figure 4-12](#changing_basemaps_in_leafmap)
    shows the options that become available. Esri is the selected basemap here, but
    you can scroll up and down until you find a suitable one. Be sure to explore.
    Once you type `**Esri**`, options will populate.
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing basemaps in Leafmap](assets/pgda_0412.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-12\. Changing basemaps in Leafmap
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another useful tool is the ability to preset your zoom levels. When you run
    the cell in your Notebook, you will have the option of sliding between different
    zoom levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-13](#zoom_levels_in_leafmap) shows the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Zoom levels in Leafmap](assets/pgda_0413.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-13\. Zoom levels in Leafmap
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can also provide a reference by inserting a minimap into your larger map,
    as shown in [Figure 4-14](#a_map_within_a_map_the_minimap_function). To do so,
    enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The minimap shown in [Figure 4-14](#a_map_within_a_map_the_minimap_function)
    will appear, helping users stay oriented in a larger context.
  prefs: []
  type: TYPE_NORMAL
- en: '![A map within a map: the minimap function in Leafmap](assets/pgda_0414.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-14\. A map within a map: the minimap function in Leafmap'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored Google Earth Engine and some related tools, libraries,
    and packages that you can use to answer geospatial questions, and it introduced
    you to an alternative tool, Leafmap. This chapter and its associated Notebooks
    will be a handy reference for the projects you’ll do in the next chapter. You
    have rendered visualizations and created maps on the canvas. Next, you will begin
    analyzing these relationships and exploring tools to do some advanced analysis
    of your geospatial data.
  prefs: []
  type: TYPE_NORMAL
