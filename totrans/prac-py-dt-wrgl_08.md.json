["```py\nprint(author)\n```", "```py\n# no variable called \"author\" exists in the same \"universe\"\n# as this line of code; throw an error\nprint(author)\n```", "```py\n# create variable \"author\"\nauthor = \"Susan E. McGregor\"\n\n# variable \"author\" exists in the \"universe\" of this line of code; carry on!\nprint(author)\n```", "```py\n# create a function that prints out a greeting\n# to any name passed to the function\ndef greet_me(a_name):\n    print(\"Variable `a_name` in `greet_me`: \"+a_name)\n    print(\"Hello \"+a_name)\n\n# create a variable named `author`\nauthor = \"Susan E. McGregor\"\n\n# create another variable named `editor`\neditor  = \"Jeff Bleiel\"\n\na_name = \"Python\"\nprint(\"Variable `a_name` in main script: \"+a_name)\n\n# use my custom function, `greet_me` to output \"Hello\" messages to each person\ngreet_me(author)\ngreet_me(editor)\n\nprint(\"Variable `a_name` in main script again: \"+a_name)\n```", "```py\nVariable `a_name` in main script: Python\nVariable `a_name` in `greet_me`: Susan E. McGregor\nHello Susan E. McGregor\nVariable `a_name` in `greet_me`: Jeff Bleiel\nHello Jeff Bleiel\nVariable `a_name` in main script again: Python\n```", "```py\n# create a function that prints out a greeting to any name\ndef greet_me(a_name, greeting=\"Hello\"):\n    print(greeting+\" \"+a_name)\n\n# create a variable named author\nauthor = \"Susan E. McGregor\"\n\n# create another variable named editor\neditor  = \"Jeff Bleiel\"\n\n# use `greet_me()` to output greeting messages to each person\n\n# say \"Hello\" by default\ngreet_me(author)\n# let the programmer specify \"Hi\" as the greeting\ngreet_me(editor, greeting=\"Hi\")\n```", "```py\n# create a function that **returns** a greeting to any name passed in\ndef make_greeting(a_name):\n    return(\"Hello \"+a_name)\n\n# create a variable named author\nauthor = \"Susan E. McGregor\"\n\n# create another variable named editor\neditor  = \"Jeff Bleiel\"\n\n# use my custom function, `greet_me()` to build and store\n# the \"Hello\" messages to each person\nauthor_greeting = make_greeting(author)\neditor_greeting = make_greeting(editor)\n\n# now `print()` the greetings built and returned by each function call\nprint(author_greeting)\nprint(editor_greeting)\n```", "```py\nprint(editor_greeting+\", how are you?\")\n```", "```py\n# function that returns a greeting to any name passed in\ndef make_greeting(a_name):\n    return(\"Hello \"+a_name)\n\n# function that adds a question to any greeting\ndef add_question(a_greeting):\n    return(a_greeting+\", how are you?\")\n\n# create a variable named author\nauthor = \"Susan E. McGregor\"\n\n# create another variable named editor\neditor  = \"Jeff Bleiel\"\n\n# print the greeting message\nprint(make_greeting(author))\n\n# pass the greeting message to the question function and print the result!\nprint(add_question(make_greeting(editor)))\n```", "```py\nthe_date = datetime.strptime(a_row['starttime'], '%Y-%m-%d %H:%M:%S.%f')\n\n```", "```py\nif the_date.weekday() <= 4:\n```", "```py\n# objective: filter all September, 2020 Citi Bike rides, and output a new\n#             file containing only weekday rides\n\n# program outline:\n# 1\\. read in the data file: 202009-citibike-tripdata.csv\n# 2\\. create a new output file, and write the header row to it.\n# 3\\. for each row in the file, make a date from the `starttime`:\n#       a. if it's a weekday, write the row to our output file\n# 4\\. close the output file\n\n# import the \"csv\" library\nimport csv\n\n# import the \"datetime\" library\nfrom datetime import datetime\n\ndef main(): ![1](assets/1.png)\n    # open our data file in \"read\" mode\n    source_file = open(\"202009-citibike-tripdata.csv\",\"r\")\n\n    # open our output file in \"write\" mode\n    output_file = open(\"202009-citibike-weekday-tripdata.csv\",\"w\")\n\n    # pass our source_file to the DictReader \"recipe\"\n    # and store the result in a variable called `citibike_reader`\n    citibike_reader = csv.DictReader(source_file)\n\n    # create a corresponding DictWriter; specify its fieldnames should\n    # be drawn from `citibike_reader`\n    output_writer = csv.DictWriter(output_file,\n                                   fieldnames=citibike_reader.fieldnames)\n\n    # actually write the header row to the output file\n    output_writer.writeheader()\n\n    # loop through our `citibike_reader` rows\n    for a_row in citibike_reader:\n\n        # if the current 'starttime' value is a weekday\n        if is_weekday(a_row['starttime']): ![2](assets/2.png)\n            # write that row of data to our output file\n            output_writer.writerow(a_row)\n\n    # close the output file\n    output_file.close()\n\ndef is_weekday(date_string, date_format='%Y-%m-%d %H:%M:%S.%f'): ![2](assets/2.png)\n\n    # convert the value in the 'date_string' to datetime format\n    the_date = datetime.strptime(date_string, date_format)\n\n    # if `the_date` is a weekday (i.e., its integer value is 0-5)\n    if the_date.weekday() <= 4:\n        return(True)\n    else:\n        return(False)\n\nif __name__ == \"__main__\": ![3](assets/3.png)\n    main()\n```", "```py\n# converting data in an .xls file with Python to csv + metadata file, with\n# functional date values using the \"xrld\" library.\n# first, pip install the xlrd library:\n# https://pypi.org/project/xlrd/2.0.1/\n\n# then, import the `xlrd` library\nimport xlrd\n\n# import the csv library\nimport csv\n\n# needed to test if a given value is *some* type of number\nfrom numbers import Number\n\n# for parsing/formatting our newly interpreted Excel dates\nfrom datetime import datetime\n\ndef main():\n\n    # use `open_workbook()` to load our data in the `source_workbook` variable\n    source_workbook = xlrd.open_workbook(\"fredgraph.xls\")\n\n    global the_datemode ![1](assets/1.png)\n\n    the_datemode = source_workbook.datemode ![1](assets/1.png)\n\n    # open and name a simple metadata text file\n    source_workbook_metadata = open(\"fredgraph_metadata.txt\",\"w\")\n\n    # an `.xls` workbook can have multiple sheets\n    for sheet_name in source_workbook.sheet_names():\n\n        # create a variable that points to the current worksheet\n        current_sheet = source_workbook.sheet_by_name(sheet_name)\n\n        # create \"xls_\"+sheet_name+\".csv\" as current sheet's output file\n        output_file = open(\"xls_\"+sheet_name+\"_dates.csv\",\"w\")\n\n        # use the `writer()` recipe to write `.csv`-formatted rows\n        output_writer = csv.writer(output_file)\n\n        # Boolean variable to detect if we've hit our table-type data yet\n        is_table_data = False\n\n        # now, we need to loop through every row in our sheet\n        for row_num, row in enumerate(current_sheet.get_rows()):\n\n            # pulling out the value in the first column of the current row\n            first_entry = current_sheet.row_values(row_num)[0]\n\n            # if we've hit the header row of our data table\n            if first_entry == 'observation_date':\n\n                # it's time to switch our \"flag\" value to \"True\"\n                is_table_data = True\n\n            # if `is_table_data` is True\n            if is_table_data:\n\n                # pass the requisite data to out `create_table_row()` function\n                new_row = create_table_row(current_sheet, row_num) ![2](assets/2.png)\n\n                # write this new row to the data output file\n                output_writer.writerow(new_row)\n\n            # otherwise, this row must be metadata\n            else:\n\n                # pass the requisite data to our `create_meta_text()` function\n                metadata_line = create_meta_text(current_sheet, row_num)\n\n                # write this new row to the metadata output file\n                source_workbook_metadata.write(metadata_line)\n\n        # just for good measure, let's close our output files\n        output_file.close()\n        source_workbook_metadata.close()\n\ndef create_table_row(the_sheet, the_row_num):\n\n    # extract the table-type data values into separate variables\n    the_date_num = the_sheet.row_values(the_row_num)[0]\n    U6_value = the_sheet.row_values(the_row_num)[1]\n\n    # create a new row object with each of the values\n    new_row = [the_date_num, U6_value]\n\n    # if the `the_date_num` is a number, then the current row is *not*\n    # the header row. We need to transform the date.\n    if isinstance(the_date_num, Number):\n\n        # use the xlrd library's `xldate_as_datetime()` to generate\n        # a Python datetime object\n        the_date_num = xlrd.xldate.xldate_as_datetime(the_date_num, the_datemode)\n\n        # create a new list containing `the_date_num` (formatted to MM/DD/YYYY\n        # using the `strftime()` recipe) and the value in the second column\n        new_row = [the_date_num.strftime('%m/%d/%Y'),U6_value]\n\n    # return the fully formatted row\n    return(new_row)\n\ndef create_meta_text(the_sheet, the_row_num):\n\n    meta_line = \"\"\n\n    # since we'd like our metadata file to be nicely formatted, we\n    # need to loop through the individual cells of each metadata row\n    for item in the_sheet.row(the_row_num):\n\n            # write the value of the cell, followed by a tab character\n            meta_line = meta_line + item.value + '\\t'\n\n    # at the end of each line of metadata, add a newline\n    meta_line = meta_line+'\\n'\n\n    # return the fully formatted line\n    return(meta_line)\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n# converting data in an .xls file with Python to csv + metadata file, with\n# functional date values using the \"xrld\" library.\n# first, pip install the xlrd library:\n# https://pypi.org/project/xlrd/2.0.1/\n\n# then, import the `xlrd` library\nimport xlrd\n\n# import the csv library\nimport csv\n\n# needed to test if a given value is *some* type of number\nfrom numbers import Number\n\n# for parsing/formatting our newly interpreted Excel dates\nfrom datetime import datetime\n\ndef main():\n\n    # use `open_workbook()` to load our data in the `source_workbook` variable\n    source_workbook = xlrd.open_workbook(\"fredgraph.xls\")\n\n    # open and name a simple metadata text file\n    source_workbook_metadata = open(\"fredgraph_metadata.txt\",\"w\")\n\n    # an `.xls` workbook can have multiple sheets\n    for sheet_name in source_workbook.sheet_names():\n\n        # create a variable that points to the current worksheet\n        current_sheet = source_workbook.sheet_by_name(sheet_name)\n\n        # create \"xls_\"+sheet_name+\".csv\" as the current sheet's output file\n        output_file = open(\"xls_\"+sheet_name+\"_dates.csv\",\"w\")\n\n        # use the `writer()` recipe to write `.csv`-formatted rows\n        output_writer = csv.writer(output_file)\n\n        # Boolean variable to detect if we've hit our table-type data yet\n        is_table_data = False\n\n        # now, we need to loop through every row in our sheet\n        for row_num, row in enumerate(current_sheet.get_rows()):\n\n            # pulling out the value in the first column of the current row\n            first_entry = current_sheet.row_values(row_num)[0]\n\n            # if we've hit the header row of our data table\n            if first_entry == 'observation_date':\n\n                # it's time to switch our \"flag\" value to \"True\"\n                is_table_data = True\n\n            # if `is_table_data` is True\n            if is_table_data:\n\n                # extract the table-type data values into separate variables\n                the_date_num = current_sheet.row_values(row_num)[0]\n                U6_value = current_sheet.row_values(row_num)[1]\n\n                # if the value is a number, then the current row is *not*\n                # the header row, so transform the date\n                if isinstance(the_date_num, Number): ![1](assets/1.png)\n                    the_date_num = format_excel_date(the_date_num,\n                                                     source_workbook.datemode)\n\n                # write this new row to the data output file\n                output_writer.writerow([the_date_num, U6_value])\n\n            # otherwise, this row must be metadata\n            else:\n\n                # pass the requisite data to our `create_meta_text()` function\n                metadata_line = create_meta_text(current_sheet, row_num)\n\n                # write this new row to the metadata output file\n                source_workbook_metadata.write(metadata_line)\n\n        # just for good measure, let's close our output files\n        output_file.close()\n        source_workbook_metadata.close()\n\ndef format_excel_date(a_date_num, the_datemode):\n\n    # use the xlrd library's `xldate_as_datetime()` to generate\n    # a Python datetime object\n    a_date_num = xlrd.xldate.xldate_as_datetime(a_date_num, the_datemode)\n\n    # create a new list containing the_date_num (formatted to MM/DD/YYYY\n    # using the `strftime()` recipe) and the value in the second column\n    formatted_date = a_date_num.strftime('%m/%d/%Y')\n\n    return(formatted_date)\n\ndef create_meta_text(the_sheet, the_row_num):\n\n    meta_line = \"\"\n\n    # since we'd like our metadata file to be nicely formatted, we\n    # need to loop through the individual cells of each metadata row\n    for item in the_sheet.row(the_row_num):\n\n            # write the value of the cell, followed by a tab character\n            meta_line = meta_line + item.value + '\\t'\n\n    # at the end of each line of metadata, add a newline\n    meta_line = meta_line+'\\n'\n\n    return(meta_line)\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\n\"\"\" NOAA data formatter ![1](assets/1.png) Reads data from an NOAA fixed-width data file with Python and outputs\na well-formatted CSV file.\n\nThe source file for this example comes from the NOAA and can be accessed here:\nhttps://www1.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt\n\nThe metadata for the file can be found here:\nhttps://www1.ncdc.noaa.gov/pub/data/ghcn/daily/readme.txt\n\nAvailable functions\n-------------------\n* convert_to_columns: Converts a line of text to a list\n\nRequirements\n------------\n* csv module\n\n\"\"\"\n# we'll start by importing the \"csv\" library\nimport csv\n\ndef main():\n    # variable to match our output filename to the input filename\n    filename = \"ghcnd-stations\"\n\n    # we'll just open the file in read format (\"r\") as usual\n    source_file = open(filename+\".txt\", \"r\")\n\n    # the \"readlines()\" method converts a text file to a list of lines\n    stations_list = source_file.readlines()\n\n    # as usual, we'll create an output file to write to\n    output_file = open(filename+\".csv\",\"w\")\n\n    # and we'll use the `csv` library to create a \"writer\" that gives us handy\n    # \"recipe\" functions for creating our new file in csv format\n    output_writer = csv.writer(output_file)\n\n    # we have to \"hard code\" these headers using the contents of `readme.txt`\n    headers = [\"ID\",\"LATITUDE\",\"LONGITUDE\",\"ELEVATION\",\"STATE\",\"NAME\",\n               \"GSN_FLAG\",\"HCNCRN_FLAG\",\"WMO_ID\"]\n\n    # create a list of `tuple`s with each column's start and end index\n    column_ranges = [(1,11),(13,20),(22,30),(32,37),(39,40),(42,71),(73,75),\n                     (77,79),(81,85)] ![2](assets/2.png)\n\n    # write our headers to the output file\n    output_writer.writerow(headers)\n\n    # loop through each line of our file\n    for line in stations_list:\n\n        # send our data to be formatted\n        new_row = convert_to_columns(line, column_ranges)\n\n        # use the `writerow` function to write new_row to our output file\n        output_writer.writerow(new_row)\n\n    # for good measure, close our output file\n    output_file.close()\n\ndef convert_to_columns(data_line, column_info, zero_index=False): ![3](assets/3.png)\n    \"\"\"Converts a line of text to a list based on the index pairs provided\n\n    Parameters\n    ----------\n    data_line : str\n        The line of text to be parsed\n    column_info : list of tuples\n        Each tuple provides the start and end index of a data column\n    zero_index: boolean, optional\n        If False (default), reduces starting index position by one\n\n    Returns\n    -------\n    list\n        a list of data values, stripped of surrounding whitespace\n    \"\"\"\n\n    new_row = []\n\n    # function assumes that provided indices are *NOT* zero-indexed,\n    # so reduce starting index values by 1\n    index_offset = 1\n\n    # if column_info IS zero-indexed, don't offset starting index values\n    if zero_index:\n        index_offset = 0\n\n    # go through list of column indices\n    for index_pair in column_info:\n\n        # pull start value, modifying by `index_offset`\n        start_index = index_pair[0]-index_offset\n\n        # pull end value\n        end_index = index_pair[1]\n\n        # strip whitespace from around the data\n        new_row.append((data_line[start_index:end_index]).strip())\n\n    # return stripped data\n    return new_row\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\npydoc fixed_width_strip_parsing_refactored\n```", "```py\npydoc fixed_width_strip_parsing_refactored.convert_to_columns\n```", "```py\n\"\"\" Web page Saver!\n\nDownloads the contents of a web page and saves it locally\n\nUsage\n-----\npython webpage_saver.py target_url filename\n\nParameters\n----------\ntarget_url : str\n    The full URL of the web page to be downloaded\nfilename : str\n    The desired filename of the local copy\n\nRequirements\n------------\n* argparse module\n* requests module\n\n\"\"\"\n# include the requests library in order to get data from the web\nimport requests\n\n# include argparse library to pull arguments from the command line\nimport argparse\n\n# create a new `ArgumentParser()`\nparser = argparse.ArgumentParser()\n\n# arguments will be assigned based on the order in which they were provided\nparser.add_argument(\"target_url\", help=\"Full URL of web page to be downloaded\") ![1](assets/1.png)\nparser.add_argument(\"filename\", help=\"The desired filename of the local copy\")\nargs = parser.parse_args()\n\n# pull the url of the web page we're downloading from the provided arguments\ntarget_url = args.target_url\n\n# pull the intended output filename from the provided arguments\noutput_filename = args.filename\n\n# create appropriate header information for our web page request\nheaders = {\n    'User-Agent': 'Mozilla/5.0 (X11; CrOS x86_64 13597.66.0) ' + \\\n                  'AppleWebKit/537.36 (KHTML, like Gecko) ' + \\\n                  'Chrome/88.0.4324.109 Safari/537.36',\n    'From': 'YOUR NAME HERE - youremailaddress@emailprovider.som'\n}\n\n# because we're just loading a regular web page, we send a `get` request to the\n# URL, along with our informational headers\nwebpage = requests.get(target_url, headers=headers)\n\n# opening up a local file to save the contents of the web page to\noutput_file = open(output_filename,\"w\")\n\n# the web page's code is in the `text` property of the website's response\n# so write that to our file\noutput_file.write(webpage.text)\n\n# close our output file!\noutput_file.close()\n```", "```py\npython webpage_saver.py \"http://web.mta.info/developers/turnstile.html\" \\\n\"MTA_turnstiles_index.html\"\n```", "```py\npython webpage_saver.py \\\n\"https://www.citibikenyc.com/system-data/operating-reports\" \\\n\"citibike_operating_reports.html\"\n```"]