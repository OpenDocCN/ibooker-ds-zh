<html><head></head><body><section data-pdf-bookmark="Appendix A. Documenting Commands and Creating Workflows with make" data-type="appendix" epub:type="appendix"><div class="appendix" id="app1_makefiles">&#13;
<h1><span class="label">Appendix A. </span>Documenting Commands and Creating Workflows with make</h1>&#13;
&#13;
&#13;
<p>The <code>make</code> program was created in 1976 to help build executable programs from source code files.<a data-primary="Makefiles" data-secondary="about make program" data-type="indexterm" id="idm45963626011544"/>&#13;
Though it was originally developed to assist with programming in the C language, it is not limited to that language or even to the task of compiling code.&#13;
According to the manual, one “can use it to describe any task where some files must be updated automatically from others whenever the others change.”&#13;
The <code>make</code> program has evolved far beyond its role as a build tool to become a workflow system.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Makefiles Are Recipes" data-type="sect1"><div class="sect1" id="idm45963626009464">&#13;
<h1>Makefiles Are Recipes</h1>&#13;
&#13;
<p>When you run the <code>make</code> command, it looks for a file called <em>Makefile</em> (or <em>makefile</em>) in the current working directory.<a data-primary="Makefiles" data-secondary="about Makefiles" data-type="indexterm" id="idm45963626006792"/>&#13;
This file contains recipes that describe discrete actions that combine to create some output.&#13;
Think of how a recipe for a lemon meringue pie has steps that need to be completed in a particular order and combination.&#13;
For instance, I need to separately create the crust, filling, and meringue and then put them together and bake them before I can enjoy a tasty treat.&#13;
I can visualize this with something called a <em>string diagram</em>, as illustrated in <a data-type="xref" href="#fig_a1.1">Figure A-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_a1.1">&#13;
<img alt="mpfb aa01" src="assets/mpfb_aa01.png"/>&#13;
<h6><span class="label">Figure A-1. </span>A string diagram describing how to make a pie, adapted from Brendan Fong and David Spivak, <span class="roman">An Invitation to Applied Category Theory (Seven Sketches in Compositionality)</span>, Cambridge University Press, 2019</h6>&#13;
</div></figure>&#13;
&#13;
<p>It’s not important if you make the pie crust the day before and keep it chilled, and the same might hold true for the filling, but it’s certainly true that the crust needs to go into the dish first, followed by the filling and finally the meringue.&#13;
An actual recipe might refer to generic recipes for crust and meringue elsewhere and list only the steps for the lemon filling and baking instructions.</p>&#13;
&#13;
<p>I can write a <em>Makefile</em> to mock up these ideas.&#13;
I’ll use shell scripts to pretend I’m assembling the various ingredients into some output files like <em>crust.txt</em> and <em>filling.txt</em>.&#13;
In the <em>app01_makefiles/pie</em> directory, I’ve written a <em>combine.sh</em> script that expects a filename and a list of “ingredients” to put into the file:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd app01_makefiles/pie/&#13;
$ ./combine.sh&#13;
usage: combine.sh FILE ingredients</pre>&#13;
&#13;
<p>I can pretend to make the crust like this:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./combine.sh crust.txt flour butter water</pre>&#13;
&#13;
<p>There is now a <em>crust.txt</em> file with the following contents:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat crust.txt&#13;
Will combine flour butter water</pre>&#13;
&#13;
<p>It’s common but not necessary for a recipe in a <em>Makefile</em> to create an output file.&#13;
Note in this example that the <code>clean</code> target removes files:<a data-primary="Makefiles" data-secondary="targets" data-type="indexterm" id="idm45963625992264"/></p>&#13;
&#13;
<pre data-type="programlisting">all: crust.txt filling.txt meringue.txt <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO1-1" id="co_documenting_commands_and_creating_workflows_with_make_CO1-1"><img alt="1" src="assets/1.png"/></a>&#13;
	./combine.sh pie.txt crust.txt filling.txt meringue.txt <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO1-2" id="co_documenting_commands_and_creating_workflows_with_make_CO1-2"><img alt="2" src="assets/2.png"/></a>&#13;
	./cook.sh pie.txt 375 45&#13;
&#13;
filling.txt:                            <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO1-3" id="co_documenting_commands_and_creating_workflows_with_make_CO1-3"><img alt="3" src="assets/3.png"/></a>&#13;
	./combine.sh filling.txt lemon butter sugar&#13;
&#13;
meringue.txt:                           <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO1-4" id="co_documenting_commands_and_creating_workflows_with_make_CO1-4"><img alt="4" src="assets/4.png"/></a>&#13;
	./combine.sh meringue.txt eggwhites sugar&#13;
&#13;
crust.txt:                              <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO1-5" id="co_documenting_commands_and_creating_workflows_with_make_CO1-5"><img alt="5" src="assets/5.png"/></a>&#13;
	./combine.sh crust.txt flour butter water&#13;
&#13;
clean:                                  <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO1-6" id="co_documenting_commands_and_creating_workflows_with_make_CO1-6"><img alt="6" src="assets/6.png"/></a>&#13;
	rm -f crust.txt meringue.txt filling.txt pie.txt</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO1-1" id="callout_documenting_commands_and_creating_workflows_with_make_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This defines a target called <code>all</code>. The first target will be the one that is run when no target is specified. Convention holds that the <code>all</code> target will run <em>all</em> the targets necessary to accomplish some default goal, like building a piece of software. Here I want to create the <em>pie.txt</em> file from the component files and “cook” it. The name <code>all</code> is not as important as the fact that it is defined first. The target name is followed by a colon and then any dependencies that must be satisfied before running this target.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO1-2" id="callout_documenting_commands_and_creating_workflows_with_make_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>all</code> target has two commands to run. Each command is indented with a Tab character.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO1-3" id="callout_documenting_commands_and_creating_workflows_with_make_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This is the <code>filling.txt</code> target. The goal of this target is to create the file called <em>filling.txt</em>. It’s common but not necessary to use the output filename as the target name. This target has just one command, which is to combine the ingredients for the filling.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO1-4" id="callout_documenting_commands_and_creating_workflows_with_make_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>This is the <code>meringue.txt</code> target, and it combines the egg whites and sugar.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO1-5" id="callout_documenting_commands_and_creating_workflows_with_make_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>This is the <code>crust.txt</code> target that combines flour, butter, and water.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO1-6" id="callout_documenting_commands_and_creating_workflows_with_make_CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>It’s common to have a <code>clean</code> target to remove any files that were created in the normal course of building.</p></dd>&#13;
</dl>&#13;
&#13;
<p>As you can see in the preceding example, the target has a name followed by a colon.&#13;
Any dependent actions can be listed after the colon in the order you wish them to be run.&#13;
The actions for a target must be indented with a Tab character, as shown in Figure A-2, and you are allowed to define as many commands as you like.</p>&#13;
&#13;
<figure><div class="figure" id="fig_a1.2">&#13;
<img alt="mpfb aa02" src="assets/mpfb_aa02.png"/>&#13;
<h6><span class="label">Figure A-2. </span>A Makefile target is terminated by a colon and optionally followed by dependencies; all the target’s actions must be indented with a single tab character</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running a Specific Target" data-type="sect1"><div class="sect1" id="idm45963625953272">&#13;
<h1>Running a Specific Target</h1>&#13;
&#13;
<p>Each action in a <em>Makefile</em> is called a <em>target</em>, <em>rule</em>, or <em>recipe</em>.<a data-primary="Makefiles" data-secondary="targets" data-tertiary="running a specific target" data-type="indexterm" id="idm45963625950168"/>&#13;
The order of the targets is not important beyond the first target being the default.&#13;
Targets, like the functions in Python programs, can reference other targets defined earlier or later in the file.</p>&#13;
&#13;
<p>To run a specific target, I run <strong><code>make target</code></strong> to have <code>make</code> run the commands for a given recipe:</p>&#13;
&#13;
<pre data-type="programlisting">$ make filling.txt&#13;
./combine.sh filling.txt lemon butter sugar</pre>&#13;
&#13;
<p>And now there is a file called <em>filling.txt</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat filling.txt&#13;
Will combine lemon butter sugar</pre>&#13;
&#13;
<p>If I try to run this target again, I’ll be told there’s nothing to do because the file already exists:</p>&#13;
&#13;
<pre data-type="programlisting">$ make filling.txt&#13;
make: 'filling.txt' is up to date.</pre>&#13;
&#13;
<p>One of the reasons for the existence of <code>make</code> is precisely not to do extra work to create files unless some underlying source has changed.&#13;
In the course of building software or running a pipeline, it may not be necessary to generate some output unless the inputs have changed, such as the source code being modified.&#13;
To force <code>make</code> to run the <em>filling.txt</em> target, I can either remove that file or run <strong><code>make clean</code></strong> to remove any of the files that have been created:<a data-primary="Makefiles" data-secondary="targets" data-tertiary="clean target" data-type="indexterm" id="idm45963625940632"/></p>&#13;
&#13;
<pre data-type="programlisting">$ make clean&#13;
rm -f crust.txt meringue.txt filling.txt pie.txt</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running with No Target" data-type="sect1"><div class="sect1" id="idm45963625938328">&#13;
<h1>Running with No Target</h1>&#13;
&#13;
<p>If you run the <code>make</code> command with no arguments, it will automatically run the first target.<a data-primary="Makefiles" data-secondary="targets" data-tertiary="running with no target" data-type="indexterm" id="idm45963625936536"/>&#13;
This is the main reason to place the <code>all</code> target (or something like it) first.&#13;
Be careful not to put something destructive like a <code>clean</code> target first, as you might end up accidentally running it and removing valuable data.</p>&#13;
&#13;
<p>Here’s the output when I run <code>make</code> with the preceding <em>Makefile</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ make                                                  <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO2-1" id="co_documenting_commands_and_creating_workflows_with_make_CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
./combine.sh crust.txt flour butter water               <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO2-2" id="co_documenting_commands_and_creating_workflows_with_make_CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
./combine.sh filling.txt lemon butter sugar             <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO2-3" id="co_documenting_commands_and_creating_workflows_with_make_CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
./combine.sh meringue.txt eggwhites sugar               <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO2-4" id="co_documenting_commands_and_creating_workflows_with_make_CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
./combine.sh pie.txt crust.txt filling.txt meringue.txt <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO2-5" id="co_documenting_commands_and_creating_workflows_with_make_CO2-5"><img alt="5" src="assets/5.png"/></a>&#13;
./cook.sh pie.txt 375 45                                <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO2-6" id="co_documenting_commands_and_creating_workflows_with_make_CO2-6"><img alt="6" src="assets/6.png"/></a>&#13;
Will cook "pie.txt" at 375 degrees for 45 minutes.</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO2-1" id="callout_documenting_commands_and_creating_workflows_with_make_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>I run <code>make</code> with no arguments. It looks for the first target in a file called <em>Makefile</em> in the current working directory.<a data-primary="arguments" data-secondary="make with no arguments" data-type="indexterm" id="idm45963625916040"/></p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO2-2" id="callout_documenting_commands_and_creating_workflows_with_make_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <em>crust.txt</em> recipe is run first. Because I didn’t specify a target, <code>make</code> runs the <code>all</code> target which is defined first, and this target lists <em>crust.txt</em> as the first dependency.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO2-3" id="callout_documenting_commands_and_creating_workflows_with_make_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Next, the <em>filling.txt</em> target is run.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO2-4" id="callout_documenting_commands_and_creating_workflows_with_make_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>This is followed by the <em>meringue.txt</em>.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO2-5" id="callout_documenting_commands_and_creating_workflows_with_make_CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Next I assemble <em>pie.txt</em>.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO2-6" id="callout_documenting_commands_and_creating_workflows_with_make_CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>And then I “cook” the pie at 375 degrees for 45 minutes.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If I run <code>make</code> again, I’ll see that the intermediate steps to produce the <em>crust.txt</em>, &#13;
<span class="keep-together"><em>filling.txt</em></span>, and <em>meringue.txt</em> files are skipped because they already exist:</p>&#13;
&#13;
<pre data-type="programlisting">$ make&#13;
./combine.sh pie.txt crust.txt filling.txt meringue.txt&#13;
./cook.sh pie.txt 375 45&#13;
Will cook "pie.txt" at 375 degrees for 45 minutes.</pre>&#13;
&#13;
<p>If I want to force them to be recreated I can run <code>make clean &amp;&amp; make</code>, where the <code>&amp;&amp;</code> is a logical <em>and</em> that will only run the second command if the first command succeeds:<a data-primary="Makefiles" data-secondary="targets" data-tertiary="clean target" data-type="indexterm" id="idm45963625893080"/><a data-primary="Makefiles" data-secondary="logical and (&amp;&amp;)" data-type="indexterm" id="idm45963625891864"/><a data-primary="logical and (&amp;&amp;) in Makefiles" data-type="indexterm" id="idm45963625890920"/><a data-primary="&amp;&amp; (logical and)" data-primary-sortas="# logical and" data-type="indexterm" id="idm45963625890232"/><a data-primary="and, logical (&amp;&amp;)" data-type="indexterm" id="idm45963625889288"/></p>&#13;
&#13;
<pre data-type="programlisting">$ make clean &amp;&amp; make&#13;
rm -f crust.txt meringue.txt filling.txt pie.txt&#13;
./combine.sh crust.txt flour butter water&#13;
./combine.sh filling.txt lemon butter sugar&#13;
./combine.sh meringue.txt eggwhites sugar&#13;
./combine.sh pie.txt crust.txt filling.txt meringue.txt&#13;
./cook.sh pie.txt 375 45&#13;
Will cook "pie.txt" at 375 degrees for 45 minutes.</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Makefiles Create DAGs" data-type="sect1"><div class="sect1" id="idm45963625887256">&#13;
<h1>Makefiles Create DAGs</h1>&#13;
&#13;
<p>Each target can specify other targets as prerequisites or dependencies that must be completed first.<a data-primary="directed acyclic graphs (DAGs)" data-secondary="Makefiles creating" data-type="indexterm" id="idm45963625885880"/><a data-primary="Makefiles" data-secondary="directed acyclic graphs created by" data-type="indexterm" id="idm45963625884920"/><a data-primary="graphs in Python" data-secondary="directed acyclic graphs" data-tertiary="Makefiles creating" data-type="indexterm" id="idm45963625883960"/>&#13;
These actions create a graph structure with a starting point and paths through targets to finally create some output file(s).&#13;
The path described for any target should be a <em>directed</em> (from a start to a stop) <em>acyclic</em> (having no cycles or infinite loops) <em>graph</em>, or DAG, as shown in Figure A-3.</p>&#13;
&#13;
<figure><div class="figure" id="fig_a1.3">&#13;
<img alt="mpfb aa03" src="assets/mpfb_aa03.png"/>&#13;
<h6><span class="label">Figure A-3. </span>The targets may join together to describe a directed acyclic graph of actions to produce some result</h6>&#13;
</div></figure>&#13;
&#13;
<p>Many analysis pipelines are just that—a graph of some input, like a FASTA sequence file, and some transformations (trimming, filtering, comparisons) into some output, like BLAST hits, gene predictions, or functional annotations.&#13;
You would be surprised at just how far <code>make</code> can be abused to document your work and even create fully functional analysis pipelines.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using make to Compile a C Program" data-type="sect1"><div class="sect1" id="idm45963625877352">&#13;
<h1>Using make to Compile a C Program</h1>&#13;
&#13;
<p>I believe it helps to use <code>make</code> for its intended purpose at least once in your life to understand why it exists.<a data-primary="Makefiles" data-secondary="compiling a C program" data-type="indexterm" id="app1-hello"/><a data-primary="C program compiled via Makefile" data-type="indexterm" id="app1-hello2"/><a data-primary="compile defined" data-secondary="C program compiled via Makefile" data-type="indexterm" id="app1-hello3"/>&#13;
I’ll take a moment to write and compile a “Hello, World” example in the C language.<a data-primary="Hello World C program" data-type="indexterm" id="app1-hello4"/>&#13;
In the <em>app01_makefiles/c-hello</em> directory, you will find a simple C program that will print “Hello, World!”&#13;
Here is the <em>hello.c</em> source code:</p>&#13;
&#13;
<pre data-type="programlisting">#include &lt;stdio.h&gt;            <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO3-1" id="co_documenting_commands_and_creating_workflows_with_make_CO3-1"><img alt="1" src="assets/1.png"/></a>&#13;
int main() {                  <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO3-2" id="co_documenting_commands_and_creating_workflows_with_make_CO3-2"><img alt="2" src="assets/2.png"/></a>&#13;
   printf("Hello, World!\n"); <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO3-3" id="co_documenting_commands_and_creating_workflows_with_make_CO3-3"><img alt="3" src="assets/3.png"/></a>&#13;
   return 0;                  <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO3-4" id="co_documenting_commands_and_creating_workflows_with_make_CO3-4"><img alt="4" src="assets/4.png"/></a>&#13;
}                             <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO3-5" id="co_documenting_commands_and_creating_workflows_with_make_CO3-5"><img alt="5" src="assets/5.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO3-1" id="callout_documenting_commands_and_creating_workflows_with_make_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Like in <code>bash</code>, the <code>#</code> character introduces comments in the C language, but this is a special comment<a data-primary="# (comment)" data-primary-sortas="# comment" data-type="indexterm" id="idm45963625855400"/> that allows external modules of code to be used. Here, I want to use the <code>printf</code> (print-format) function, so I need to <code>include</code> the standard I/O (input/output) module, called <code>stdio</code>. I only need to include the “header” file, <code>stdio.h</code>, to get at the function definitions in that module. This is a standard module, and the C compiler will look in various locations for any included files to find it. There may be times when you are unable to compile C (or C++ programs) from source code because some header file cannot be found. For example, the <code>gzip</code> library is often used to de/compress data, but it is not always installed in a library form that other programs may <code>include</code> in this way. Therefore, you will have to download and install the <code>libgz</code> program, being sure to install the headers into the proper <code>include</code> directories. Note that package managers like <code>apt-get</code> and <code>yum</code> often have <code>-dev</code> or <code>-devel</code> packages that you have to install to get these headers; that is, you’ll need to install both <code>libgz</code> and <code>libgz-dev</code> or whatnot.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO3-2" id="callout_documenting_commands_and_creating_workflows_with_make_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This is the start of a function declaration in C. The function name (<code>main</code>) is preceded by its return type (<code>int</code>). The parameters to the function are listed inside the parentheses after its name. In this case there are none, so the parentheses are empty. The opening curly brace (<code>{</code>) shows the start of the code that belongs to the function. Note that C will automatically execute the <code>main()</code> function, and every C program must have a <code>main()</code> function where the program starts.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO3-3" id="callout_documenting_commands_and_creating_workflows_with_make_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>printf()</code> function will print the given string to the command line. This function is defined in the <code>stdio</code> library, which is why I need to <code>#include</code> the header file above.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO3-4" id="callout_documenting_commands_and_creating_workflows_with_make_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p><code>return</code> will exit the function and return the value <code>0</code>. Since this is the return value<a data-primary="exit status after execution" data-secondary="Hello World in C" data-type="indexterm" id="idm45963625834600"/> for the <code>main()</code> function, this will be the exit value for the entire program. The value <code>0</code> indicates that the program ran normally—think “zero errors.” Any non-zero value would indicate a failure.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO3-5" id="callout_documenting_commands_and_creating_workflows_with_make_CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>The closing curly brace (<code>}</code>) is the mate for the one on line 2 and marks the end of the <code>main()</code> function.</p></dd>&#13;
</dl>&#13;
&#13;
<p>To turn that into an executable program you will need to have a C compiler on your machine.&#13;
For instance, I can use <code>gcc</code>, the GNU C compiler:<a data-primary="C program compiled via Makefile" data-secondary="GNU C compiler" data-type="indexterm" id="idm45963625827688"/><a data-primary="compile defined" data-secondary="GNU C compiler" data-type="indexterm" id="idm45963625826728"/><a data-primary="GNU C compiler" data-type="indexterm" id="idm45963625825784"/></p>&#13;
&#13;
<pre data-type="programlisting">$ gcc hello.c</pre>&#13;
&#13;
<p>That will create a file called <em>a.out</em>, which is an executable file.&#13;
On my Macintosh, this is what <code>file</code> will report:</p>&#13;
&#13;
<pre data-type="programlisting">$ file a.out&#13;
a.out: Mach-O 64-bit executable arm64</pre>&#13;
&#13;
<p>And I can execute that:<a data-primary="output from program" data-secondary="Hello World in C" data-type="indexterm" id="idm45963625821784"/></p>&#13;
&#13;
<pre data-type="programlisting">$ ./a.out&#13;
Hello, World!</pre>&#13;
&#13;
<p>I don’t like the name <em>a.out</em>, though, so I can use the <code>-o</code> option to name the output file <em>hello</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ gcc -o hello hello.c</pre>&#13;
&#13;
<p>Run the resulting <em>hello</em> executable.&#13;
You should see the same output.</p>&#13;
&#13;
<p>Rather than typing <code>gcc -o hello hello.c</code> every time I modify <em>hello.c</em>, I can put that in a <em>Makefile</em>:</p>&#13;
&#13;
<pre data-type="programlisting">hello:&#13;
	gcc -o hello hello.c</pre>&#13;
&#13;
<p>And now I can run <strong><code>make hello</code></strong> or just <strong><code>make</code></strong> if this is the first target:</p>&#13;
&#13;
<pre data-type="programlisting">$ make&#13;
gcc -o hello hello.c</pre>&#13;
&#13;
<p>If I run <strong><code>make</code></strong> again, nothing happens because the <em>hello.c</em> file hasn’t changed:</p>&#13;
&#13;
<pre data-type="programlisting">$ make&#13;
make: 'hello' is up to date.</pre>&#13;
&#13;
<p>What happens if I alter the <em>hello.c</em> code to print “Hola” instead of “Hello,” and then try running <code>make</code> again?</p>&#13;
&#13;
<pre data-type="programlisting">$ make&#13;
make: 'hello' is up to date.</pre>&#13;
&#13;
<p>I can force <code>make</code> to run the targets using the <code>-B</code> option:</p>&#13;
&#13;
<pre data-type="programlisting">$ make -B&#13;
gcc -o hello hello.c</pre>&#13;
&#13;
<p>And now the new program has been compiled:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./hello&#13;
Hola, World!</pre>&#13;
&#13;
<p>This is a trivial example, and you may be wondering how this saves time.&#13;
A real-world project in C or any language would likely have multiple <em>.c</em> files with headers (<em>.h</em> files) describing their functions so that they could be used by other <em>.c</em> files.&#13;
The C compiler would need to turn each <em>.c</em> file into a <em>.o</em> (<em>out</em>) file and then link them together into a single executable.&#13;
Imagine you have dozens of <em>.c</em> files, and you change one line of code in one file.&#13;
Do you want to type dozens of commands to recompile and link all your code?&#13;
Of course not.&#13;
You would build a tool to automate those actions for you.<a data-startref="app1-hello" data-type="indexterm" id="idm45963625800024"/><a data-startref="app1-hello2" data-type="indexterm" id="idm45963625799352"/><a data-startref="app1-hello3" data-type="indexterm" id="idm45963625798680"/><a data-startref="app1-hello4" data-type="indexterm" id="idm45963625798008"/></p>&#13;
&#13;
<p>I can add targets to the <em>Makefile</em> that don’t generate new files.<a data-primary="Makefiles" data-secondary="targets" data-tertiary="new files not generated" data-type="indexterm" id="idm45963625796408"/>&#13;
It’s common to have a <code>clean</code> target that will clean up files and directories that I no longer need.<a data-primary="Makefiles" data-secondary="clean Makefile to remove files" data-type="indexterm" id="idm45963625794520"/>&#13;
Here I can create a <code>clean</code> target to remove the <em>hello</em> executable:</p>&#13;
&#13;
<pre data-type="programlisting">clean:&#13;
	rm -f hello</pre>&#13;
&#13;
<p>If I want to be sure that the executable is always removed before running the <code>hello</code> target, I can add it as a dependency:</p>&#13;
&#13;
<pre data-type="programlisting">hello: clean&#13;
	gcc -o hello hello.c</pre>&#13;
&#13;
<p>It’s good to document for <code>make</code> that this is a <em>phony</em> target because the result of the target is not a newly created file.<a data-primary="Makefiles" data-secondary="targets" data-tertiary="phony target" data-type="indexterm" id="idm45963625788664"/>&#13;
I use the <code>.PHONY:</code> target and list all the phonies.&#13;
Here is the complete <em>Makefile</em> now:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat Makefile&#13;
.PHONY: clean&#13;
&#13;
hello: clean&#13;
	gcc -o hello hello.c&#13;
&#13;
clean:&#13;
	rm -f hello</pre>&#13;
&#13;
<p>If you run <strong><code>make</code></strong> in the <em>c-hello</em> directory with the preceding <em>Makefile</em>, you should see this:</p>&#13;
&#13;
<pre data-type="programlisting">$ make&#13;
rm -f hello&#13;
gcc -o hello hello.c</pre>&#13;
&#13;
<p>And there should now be a <em>hello</em> executable in your directory that you can run:</p>&#13;
&#13;
<pre data-type="programlisting">$ ./hello&#13;
Hello, World!</pre>&#13;
&#13;
<p>Notice that the <code>clean</code> target can be listed as a dependency to the <code>hello</code> target even <em>before</em> the target itself is mentioned.&#13;
<code>make</code> will read the entire file and then use the dependencies to resolve the graph.&#13;
If you were to put <code>foo</code> as an additional dependency to <code>hello</code> and then run <strong><code>make</code></strong> again, you would see this:</p>&#13;
&#13;
<pre data-type="programlisting">$ make&#13;
make: *** No rule to make target 'foo', needed by 'hello'.  Stop.</pre>&#13;
&#13;
<p>A <em>Makefile</em> allows me to write independent groups of actions that are ordered by their dependencies.<a data-primary="Makefiles" data-secondary="about Makefiles" data-type="indexterm" id="idm45963625775608"/>&#13;
They are like <em>functions</em> in a higher-level language.&#13;
I have essentially written a program whose output is another program.</p>&#13;
&#13;
<p>I’d encourage you to run <strong><code>cat hello</code></strong> to view the contents of the <em>hello</em> file.&#13;
It’s mostly binary information that will look like gibberish, but you will probably be able to make out some plain English, too.&#13;
You can also use <strong><code>strings hello</code></strong> to extract just the strings of text.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using make for a Shortcut" data-type="sect1"><div class="sect1" id="idm45963625771416">&#13;
<h1>Using make for a Shortcut</h1>&#13;
&#13;
<p>Let’s look at how I can abuse a <em>Makefile</em> to create shortcuts for commands.&#13;
In the <em>app01_makefiles/hello</em> directory, you will find the following <em>Makefile</em>:<a data-primary="Makefiles" data-secondary="shortcuts for commands" data-type="indexterm" id="idm45963625768680"/></p>&#13;
&#13;
<pre data-type="programlisting">$ cat Makefile&#13;
.PHONY: hello            <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO4-1" id="co_documenting_commands_and_creating_workflows_with_make_CO4-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
hello:                   <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO4-2" id="co_documenting_commands_and_creating_workflows_with_make_CO4-2"><img alt="2" src="assets/2.png"/></a>&#13;
	echo "Hello, World!" <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO4-3" id="co_documenting_commands_and_creating_workflows_with_make_CO4-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO4-1" id="callout_documenting_commands_and_creating_workflows_with_make_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Since the <code>hello</code> target doesn’t produce a file, I list it as a phony target.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO4-2" id="callout_documenting_commands_and_creating_workflows_with_make_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This is the <code>hello</code> target. The name of the target should be composed only of letters and numbers, should have no spaces before it, and is followed by a colon (<code>:</code>).</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO4-3" id="callout_documenting_commands_and_creating_workflows_with_make_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The command(s) to run for the <code>hello</code> target are listed on lines that are indented with a tab character.</p></dd>&#13;
</dl>&#13;
&#13;
<p>I can execute this with <strong><code>make</code></strong>:</p>&#13;
&#13;
<pre data-type="programlisting">$ make&#13;
echo "Hello, World!"&#13;
Hello, World!</pre>&#13;
&#13;
<p>I often use a <em>Makefile</em> to remember how to invoke a command with various arguments.&#13;
That is, I might write an analysis pipeline and then document how to run the program on various datasets with all their parameters.&#13;
In this way, I’m documenting my work in a way that I can immediately reproduce by running the target.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Variables" data-type="sect1"><div class="sect1" id="idm45963625747448">&#13;
<h1>Defining Variables</h1>&#13;
&#13;
<p>Here is an example of a <em>Makefile</em> I wrote to document how I used the Centrifuge program for making taxonomic assignments to short reads:<a data-primary="Makefiles" data-secondary="variables" data-type="indexterm" id="idm45963625745608"/><a data-primary="variables" data-secondary="Makefiles" data-type="indexterm" id="idm45963625744664"/></p>&#13;
&#13;
<pre data-type="programlisting">INDEX_DIR = /data/centrifuge-indexes         <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO5-1" id="co_documenting_commands_and_creating_workflows_with_make_CO5-1"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
clean_paired:&#13;
    rm -rf $(HOME)/work/data/centrifuge/paired-out&#13;
&#13;
paired: clean_paired                         <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO5-2" id="co_documenting_commands_and_creating_workflows_with_make_CO5-2"><img alt="2" src="assets/2.png"/></a>&#13;
    ./run_centrifuge.py \                    <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO5-3" id="co_documenting_commands_and_creating_workflows_with_make_CO5-3"><img alt="3" src="assets/3.png"/></a>&#13;
    -q $(HOME)/work/data/centrifuge/paired \ <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO5-4" id="co_documenting_commands_and_creating_workflows_with_make_CO5-4"><img alt="4" src="assets/4.png"/></a>&#13;
    -I $(INDEX_DIR) \                        <a class="co" href="#callout_documenting_commands_and_creating_workflows_with_make_CO5-5" id="co_documenting_commands_and_creating_workflows_with_make_CO5-5"><img alt="5" src="assets/5.png"/></a>&#13;
    -i 'p_compressed+h+v' \&#13;
    -x "9606, 32630" \&#13;
    -o $(HOME)/work/data/centrifuge/paired-out \&#13;
    -T "C/Fe Cycling"</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO5-1" id="callout_documenting_commands_and_creating_workflows_with_make_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Here I define the variable <code>INDEX_DIR</code> and assign a value. Note that there must be spaces on either side of the <code>=</code>. I prefer ALL_CAPS for my variable names, but this is my personal preference.<a data-primary="equal signs" data-secondary="spaces in Makefile assignments" data-type="indexterm" id="idm45963613648184"/></p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO5-2" id="callout_documenting_commands_and_creating_workflows_with_make_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Run the <code>clean_paired</code> target prior to running this target. This ensures that there is no leftover output from a previous run.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO5-3" id="callout_documenting_commands_and_creating_workflows_with_make_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>This action is long, so I used backslashes (<code>\</code>) as on the command line to indicate that the command continues to the next line.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO5-4" id="callout_documenting_commands_and_creating_workflows_with_make_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>To have <code>make</code> <em>deference</em> or use the value of the <code>$HOME</code> environment variable, use the syntax <code>$(HOME)</code>.</p></dd>&#13;
<dt><a class="co" href="#co_documenting_commands_and_creating_workflows_with_make_CO5-5" id="callout_documenting_commands_and_creating_workflows_with_make_CO5-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p><code>$(INDEX_DIR)</code> refers to the variable defined at the top.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing a Workflow" data-type="sect1"><div class="sect1" id="idm45963613633016">&#13;
<h1>Writing a Workflow</h1>&#13;
&#13;
<p>In the <em>app01_makefiles/yeast</em> directory is an example of how to write a workflow as <code>make</code> targets.<a data-primary="Makefiles" data-secondary="workflow within" data-type="indexterm" id="idm45963613630792"/><a data-primary="workflow managers" data-secondary="Makefile containing workflow" data-type="indexterm" id="idm45963613629848"/>&#13;
The goal is to download the yeast genome and characterize various gene types as “Dubious,” “Uncharacterized,” “Verified,” and so on.&#13;
This is accomplished with a collection of command-line tools such as <code>wget</code>, <code>grep</code>, and <code>awk</code>, combined with a custom shell script called <em>download.sh</em>, all pieced together and run in order by <code>make</code>:</p>&#13;
&#13;
<pre data-type="programlisting">.PHONY: all fasta features test clean&#13;
&#13;
FEATURES = http://downloads.yeastgenome.org/curation/$\&#13;
    chromosomal_feature/&#13;
    SGD_features.tab&#13;
&#13;
all: fasta genome chr-count chr-size features gene-count verified-genes \&#13;
     uncharacterized-genes gene-types terminated-genes test&#13;
&#13;
clean:&#13;
	find . \( -name \*gene\* -o -name chr-\* \) -exec rm {} \;&#13;
	rm -rf fasta SGD_features.tab&#13;
&#13;
fasta:&#13;
	./download.sh&#13;
&#13;
genome: fasta&#13;
	(cd fasta &amp;&amp; cat *.fsa &gt; genome.fa)&#13;
&#13;
chr-count: genome&#13;
	grep -e '^&gt;' "fasta/genome.fa" | grep 'chromosome' | wc -l &gt; chr-count&#13;
&#13;
chr-size: genome&#13;
	grep -ve '^&gt;' "fasta/genome.fa" | wc -c &gt; chr-size&#13;
&#13;
features:&#13;
	wget -nc $(FEATURES)&#13;
&#13;
gene-count: features&#13;
	cut -f 2 SGD_features.tab | grep ORF | wc -l &gt; gene-count&#13;
&#13;
verified-genes: features&#13;
	awk -F"\t" '$$3 == "Verified" {print}' SGD_features.tab | \&#13;
		wc -l &gt; verified-genes&#13;
&#13;
uncharacterized-genes: features&#13;
	awk -F"\t" '$$2 == "ORF" &amp;&amp; $$3 == "Uncharacterized" {print $$2}' \&#13;
		SGD_features.tab | wc -l &gt; uncharacterized-genes&#13;
&#13;
gene-types: features&#13;
	awk -F"\t" '{print $$3}' SGD_features.tab | sort | uniq -c &gt; gene-types&#13;
&#13;
terminated-genes:&#13;
	grep -o '/G=[^ ]*' palinsreg.txt | cut -d = -f 2 | \&#13;
		sort -u &gt; terminated-genes&#13;
&#13;
test:&#13;
	pytest -xv ./test.py</pre>&#13;
&#13;
<p>I won’t bother commenting on all the commands.&#13;
Mostly I want to demonstrate how far I can abuse a <em>Makefile</em> to create a workflow.&#13;
Not only have I documented all the steps, but they are <em>runnable</em> with nothing more than the command <strong><code>make</code></strong>.&#13;
Absent using <code>make</code>, I’d have to write a shell script to accomplish this or, more likely, move to a more powerful language like Python.&#13;
The resulting program written in either language would probably be longer, buggier, and more difficult to understand.&#13;
Sometimes, all you need is a <em>Makefile</em> and some shell commands.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Workflow Managers" data-type="sect1"><div class="sect1" id="idm45963613620744">&#13;
<h1>Other Workflow Managers</h1>&#13;
&#13;
<p>As you bump up against the limitations of <code>make</code>, you may choose to move to a workflow manager.<a data-primary="workflow managers" data-type="indexterm" id="idm45963613618936"/>&#13;
There are many to choose from. For example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Snakemake extends the basic concepts of <code>make</code> with Python.<a data-primary="Snakemake" data-type="indexterm" id="idm45963613616568"/></p>&#13;
</li>&#13;
<li>&#13;
<p>The Common Workflow Language (CWL) defines workflows and parameters in a configuration file (in YAML),<a data-primary="Common Workflow Language (CWL)" data-type="indexterm" id="idm45963613614920"/> and you use tools like <code>cwltool</code> or <code>cwl-runner</code> (both implemented in Python) to execute the workflow with another configuration file that describes the arguments.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Workflow Description Language (WDL) takes a similar approach to describe workflows and arguments and can be run with the Cromwell engine.<a data-primary="Workflow Description Language (WDL)" data-type="indexterm" id="idm45963613612040"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Pegasus allows you to use Python code to describe a workflow that then is written to an XML file, which is the input for the engine that will run your code.<a data-primary="Pegasus" data-type="indexterm" id="idm45963613610312"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Nextflow is similar in that you use a full programming language called Groovy (a subset of Java) to write a workflow that can be run by the Nextflow engine.<a data-primary="Nextflow" data-type="indexterm" id="idm45963613608600"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>All of these systems follow the same basic ideas as <code>make</code>, so understanding how <code>make</code> works and how to write the pieces of your workflow and how they interact is the basis for any larger analysis workflow you may create.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Further Reading" data-type="sect1"><div class="sect1" id="idm45963613605800">&#13;
<h1>Further Reading</h1>&#13;
&#13;
<p>Here are some other resources you can use to learn about <code>make</code>:<a data-primary="Makefiles" data-secondary="resources for learning" data-type="indexterm" id="idm45963613604008"/><a data-primary="resources" data-secondary="make information" data-type="indexterm" id="idm45963613603064"/><a data-primary="GNU Make manual" data-type="indexterm" id="idm45963613602120"/><a data-primary="The GNU Make Book (Graham-Cumming)" data-type="indexterm" id="idm45963613601448"/><a data-primary="Graham-Cumming, John" data-type="indexterm" id="idm45963613600760"/><a data-primary="Managing Projects with GNU Make (Mecklenburg)" data-type="indexterm" id="idm45963613600088"/><a data-primary="Mecklenburg, Robert" data-type="indexterm" id="idm45963613599384"/></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <a href="https://oreil.ly/D9daZ">GNU Make Manual</a></p>&#13;
</li>&#13;
<li>&#13;
<p><em>The GNU Make Book</em> by John Graham-Cumming (No Starch Press, 2015)</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/D8Oyk"><em>Managing Projects with GNU Make</em></a> by Robert Mecklenburg (O’Reilly, 2004)</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>