- en: Chapter 4\. Modeling with Summary Statistics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章\. 模型与总结统计
- en: 'We saw in [Chapter 2](ch02.html#ch-data-scope) the importance of data scope
    and in [Chapter 3](ch03.html#ch-theory-datadesign) the importance of data generation
    mechanisms, such as one that can be represented by an urn model. Urn models address
    one aspect of modeling: they describe chance variation and ensure that the data
    are representative of the target. Good scope and representative data lay the groundwork
    for extracting useful information from data, which is the other part of modeling.
    This information is often referred to as the *signal* in the data. We use models
    to approximate the signal, with the simplest of these being the constant model,
    where the signal is approximated by a single number, like the mean or median.
    Other, more complex models summarize relationships between features in the data,
    such as humidity and particulate matter in air quality ([Chapter 12](ch12.html#ch-pa)),
    upward mobility and commute time in communities ([Chapter 15](ch15.html#ch-linear)),
    and height and weight of animals ([Chapter 18](ch18.html#ch-donkey)). These more
    complex models are also approximations built from data. When a model fits the
    data well, it can provide a useful approximation to the world or simply a helpful
    description of the data.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 2 章](ch02.html#ch-data-scope)中看到了数据范围的重要性，在[第 3 章](ch03.html#ch-theory-datadesign)中看到了数据生成机制的重要性，例如可以用一个瓮模型来表示的机制。瓮模型解决了建模的一个方面：它描述了偶然变化，并确保数据代表了目标。良好的范围和代表性数据为从数据中提取有用信息奠定了基础，这在建模的另一部分中经常被称为数据中的*信号*。我们使用模型来近似这个信号，其中最简单的模型之一是常数模型，其中信号由一个单一数字（如均值或中位数）来近似。其他更复杂的模型总结了数据中特征之间的关系，例如空气质量中的湿度和颗粒物质([第
    12 章](ch12.html#ch-pa))，社区中的上升流动性和通勤时间([第 15 章](ch15.html#ch-linear))，以及动物的身高和体重([第
    18 章](ch18.html#ch-donkey))。这些更复杂的模型也是从数据中构建的近似值。当模型很好地适合数据时，它可以提供对世界的有用近似描述或仅仅是数据的有用描述。
- en: In this chapter, we introduce the basics of model fitting through a *loss* formulation.
    We demonstrate how to model patterns in the data by considering the loss that
    arises from using a simple summary to describe the data, the constant model. We
    delve deeper into the connections between the urn model and the fitted model in
    [Chapter 16](ch16.html#ch-risk), where we examine the balance between signal and
    noise when fitting models, and in [Chapter 17](ch17.html#ch-inf-pred-theory),
    where we tackle the topics of inference, prediction, and hypothesis testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过一个*损失*的形式介绍了模型拟合的基础知识。我们演示了如何通过考虑由简单总结描述数据引起的损失来建模数据中的模式，即常数模型。我们在[第
    16 章](ch16.html#ch-risk)深入探讨了瓮模型与拟合模型之间的联系，其中我们检查了拟合模型时信号和噪声之间的平衡，并在[第 17 章](ch17.html#ch-inf-pred-theory)中讨论了推断、预测和假设检验的主题。
- en: The constant model lets us introduce model fitting from the perspective of *loss
    minimization* in a simple context, and it helps us connect summary statistics,
    like the mean and median, to more complex modeling scenarios in later chapters.
    We begin with an example that uses data about the late arrival of a bus to introduce
    the constant model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 常数模型让我们可以从*损失最小化*的角度在简单情境中介绍模型拟合，它帮助我们将总结统计（如均值和中位数）与后续章节中的更复杂建模场景联系起来。我们从一个例子开始，该例子使用关于公交车晚点的数据来介绍常数模型。
- en: The Constant Model
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常数模型
- en: 'A transit rider, Jake, often takes the northbound C bus at the 3rd & Pike bus
    stop in downtown Seattle.^([1](ch04.html#id780)) The bus is supposed to arrive
    every 10 minutes, but Jake notices that he sometimes waits a long time for the
    bus. He wants to know how late the bus usually is. Jake was able to acquire the
    scheduled arrival and actual arrival times for his bus from the Washington State
    Transportation Center. From these data, he can calculate the number of minutes
    that each bus is late to arrive at his stop:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个乘客，Jake，经常在西雅图市中心第三大道和派克街交界处的北行 C 路公交车站乘坐公交车。^([1](ch04.html#id780)) 这辆公交车应该每
    10 分钟到达一次，但是Jake注意到有时候他等车的时间很长。他想知道公交车通常晚到多久。Jake成功获取了从华盛顿州交通中心获得的公交车的预定到达时间和实际到达时间。根据这些数据，他可以计算每辆公交车晚点到达他所在站点的分钟数：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|   | route | direction | scheduled | actual | minutes_late |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|   | 路线 | 方向 | 预定时间 | 实际时间 | 晚到分钟数 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **0** | C | northbound | 2016-03-26 06:30:28 | 2016-03-26 06:26:04 | -4.40
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **0** | C | 北行 | 2016-03-26 06:30:28 | 2016-03-26 06:26:04 | -4.40 |'
- en: '| **1** | C | northbound | 2016-03-26 01:05:25 | 2016-03-26 01:10:15 | 4.83
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **1** | C | 往北 | 2016-03-26 01:05:25 | 2016-03-26 01:10:15 | 4.83 |'
- en: '| **2** | C | northbound | 2016-03-26 21:00:25 | 2016-03-26 21:05:00 | 4.58
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **2** | C | 往北 | 2016-03-26 21:00:25 | 2016-03-26 21:05:00 | 4.58 |'
- en: '| **...** | ... | ... | ... | ... | ... |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... | ... |'
- en: '| **1431** | C | northbound | 2016-04-10 06:15:28 | 2016-04-10 06:11:37 | -3.85
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **1431** | C | 往北 | 2016-04-10 06:15:28 | 2016-04-10 06:11:37 | -3.85 |'
- en: '| **1432** | C | northbound | 2016-04-10 17:00:28 | 2016-04-10 16:56:54 | -3.57
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **1432** | C | 往北 | 2016-04-10 17:00:28 | 2016-04-10 16:56:54 | -3.57 |'
- en: '| **1433** | C | northbound | 2016-04-10 20:15:25 | 2016-04-10 20:18:21 | 2.93
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **1433** | C | 往北 | 2016-04-10 20:15:25 | 2016-04-10 20:18:21 | 2.93 |'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `minutes_late` column in the data table records how late each bus was.
    Notice that some of the times are negative, meaning that the bus arrived early.
    Let’s examine a histogram of the number of minutes each bus is late:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表中的 `minutes_late` 列记录了每辆公交车的迟到时间。请注意，有些时间是负数，这意味着公交车提前到达。让我们来看一下每辆公交车迟到时间的直方图：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](assets/leds_04in01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_04in01.png)'
- en: We can already see some interesting patterns in the data. For example, many
    buses arrive earlier than scheduled, but some are well over 20 minutes late. We
    also see a clear mode (high point) at 0, meaning many buses arrive roughly on
    time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以在数据中看到一些有趣的模式。例如，许多公交车提前到达，但有些车晚到超过20分钟。我们还可以看到明显的众数（高点），在0附近，意味着许多公交车大致按时到达。
- en: To understand how late a bus on this route typically is, we’d like to summarize
    lateness by a constant—this is a statistic, a single number, like the mean, median,
    or mode. Let’s find each of these summary statistics for the `minutes_late` column
    in the data table.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这条路线上公交车通常晚到多久，我们希望通过一个常数来总结迟到情况 —— 这是一个统计量，一个单一的数字，比如均值、中位数或众数。让我们找到数据表中
    `minutes_late` 列的每个这些摘要统计量。
- en: 'From the histogram, we estimate the mode of the data to be 0, and we use Python
    to compute the mean and median:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从直方图中，我们估计数据的众数是0，并使用Python计算均值和中位数：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Naturally, we want to know which of these numbers best represents a summary
    of lateness. Rather than relying on rules of thumb, we take a more formal approach.
    We make a constant model for bus lateness. Let’s call this constant <math><mi>θ</mi></math>
    (in modeling, <math><mi>θ</mi></math> is often referred to as a *parameter*).
    For example, if we consider <math><mi>θ</mi> <mo>=</mo> <mn>5</mn></math> , then
    our model approximates the bus to typically be five minutes late.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们想知道这些数字中哪一个最能代表迟到的摘要情况。我们不想依赖经验法则，而是采取更正式的方法。我们为公交车迟到建立一个常数模型。让我们称这个常数为
    <math><mi>θ</mi></math> （在建模中，<math><mi>θ</mi></math> 通常被称为*参数*）。例如，如果我们考虑 <math><mi>θ</mi>
    <mo>=</mo> <mn>5</mn></math> ，那么我们的模型大致认为公交车通常晚到五分钟。
- en: Now, <math><mi>θ</mi> <mo>=</mo> <mn>5</mn></math> isn’t a particularly good
    guess. From the histogram of minutes late, we saw that there are many more points
    closer to 0 than 5\. But it isn’t clear that <math><mi>θ</mi> <mo>=</mo> <mn>0</mn></math>
    (the mode) is a better choice than <math><mi>θ</mi> <mo>=</mo> <mn>0.74</mn></math>
    (the median), <math><mi>θ</mi> <mo>=</mo> <mn>1.92</mn></math> (the mean), or
    something else entirely. To make choices between different values of <math><mi>θ</mi></math>
    , we would like to assign any value of <math><mi>θ</mi></math> a score that measures
    how well that constant fits the data. That is, we want to assess the loss involved
    in approximating the data by a constant, like <math><mi>θ</mi> <mo>=</mo> <mn>5</mn></math>
    . And ideally, we want to pick the constant that best fits our data, meaning the
    constant that has the smallest loss. In the next section, we describe more formally
    what we mean by loss and show how to use it to fit a model.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，<math><mi>θ</mi> <mo>=</mo> <mn>5</mn></math> 并不是一个特别好的猜测。从迟到时间的直方图中，我们看到有更多的点接近0而不是5。但是目前还不清楚
    <math><mi>θ</mi> <mo>=</mo> <mn>0</mn></math>（众数）是否比 <math><mi>θ</mi> <mo>=</mo>
    <mn>0.74</mn></math>（中位数）、<math><mi>θ</mi> <mo>=</mo> <mn>1.92</mn></math>（均值）或者完全不同的其他值更好。为了在不同的
    <math><mi>θ</mi></math> 值之间做出选择，我们希望给每个 <math><mi>θ</mi></math> 值分配一个评分，以衡量这个常数如何与数据匹配。换句话说，我们希望评估用常数近似数据所涉及的损失，比如
    <math><mi>θ</mi> <mo>=</mo> <mn>5</mn></math> 。而理想情况下，我们希望选择最能匹配我们数据的常数，也就是具有最小损失的常数。在下一节中，我们将更正式地描述损失，并展示如何使用它来拟合模型。
- en: Minimizing Loss
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化损失
- en: We want to model how late the northbound C bus is by a constant, which we call
    <math><mi>θ</mi></math> , and we want to use the data of actual number of minutes
    each bus is late to figure out a good value for <math><mi>θ</mi></math> . To do
    this, we use a *loss function*—a function that measures how far away our constant,
    <math><mi>θ</mi></math> , is from the actual data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要通过一个常数来模拟北向C路线的延迟，这个常数我们称之为<math><mi>θ</mi></math>，并且我们想要利用每辆公交车实际延迟的分钟数的数据来找出一个合适的<math><mi>θ</mi></math>值。为此，我们使用一个*损失函数*，这个函数衡量我们的常数<math><mi>θ</mi></math>与实际数据之间的差距。
- en: A loss function is a mathematical function that takes in <math><mi>θ</mi></math>
    and a data value <math><mi>y</mi></math> . It outputs a single number, the *loss*,
    that measures how far away <math><mi>θ</mi></math> is from <math><mi>y</mi></math>
    . We write the loss function as <math><mrow><mi mathvariant="script">l</mi></mrow>
    <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo> <mi>y</mi> <mo stretchy="false">)</mo></math>
    .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 损失函数是一个数学函数，接受<math><mi>θ</mi></math>和数据值<math><mi>y</mi></math>作为输入。它输出一个单一的数字，*损失*，用来衡量<math><mi>θ</mi></math>和<math><mi>y</mi></math>之间的距离。我们将损失函数写成<math><mrow><mi
    mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo>
    <mi>y</mi> <mo stretchy="false">)</mo></math>。
- en: 'By convention, the loss function outputs lower values for better values of
    <math><mi>θ</mi></math> and larger values for worse <math><mi>θ</mi></math> .
    To fit a constant to our data, we select the particular <math><mi>θ</mi></math>
    that produces the lowest average loss across all choices for <math><mi>θ</mi></math>
    . In other words, we find the <math><mi>θ</mi></math> that *minimizes the average
    loss* for our data, <math><msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <mo>…</mo>
    <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub></math> . More formally, we write
    the average loss as <math><mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub> <mo stretchy="false">)</mo></math>
    , where:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，损失函数对于较好的<math><mi>θ</mi></math>值输出较低的值，对于较差的<math><mi>θ</mi></math>值输出较大的值。为了使常数适应我们的数据，我们选择产生所有<math><mi>θ</mi></math>选择下平均损失最低的特定<math><mi>θ</mi></math>。换句话说，我们找到*最小化数据平均损失*的<math><mi>θ</mi></math>，其中<math><msub><mi>y</mi>
    <mn>1</mn></msub> <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub></math>
    。更正式地，我们将平均损失写为<math><mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo>
    <msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub>
    <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub> <mo stretchy="false">)</mo></math>，其中：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mi>L</mi> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>2</mn></msub> <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub>
    <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo> <mtext>mean</mtext> <mrow><mo>{</mo>
    <mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo> <mi>θ</mi>
    <mo>,</mo> <msub><mi>y</mi> <mn>1</mn></msub> <mo stretchy="false">)</mo> <mo>,</mo>
    <mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo> <mi>θ</mi>
    <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo stretchy="false">)</mo> <mo>,</mo>
    <mo>…</mo> <mo>,</mo> <mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub> <mo stretchy="false">)</mo>
    <mo>}</mo></mrow></mtd></mtr> <mtr><mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo> <mi>θ</mi>
    <mo>,</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mi>L</mi> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>2</mn></msub> <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub>
    <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo> <mtext>mean</mtext> <mrow><mo>{</mo>
    <mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo> <mi>θ</mi>
    <mo>,</mo> <msub><mi>y</mi> <mn>1</mn></msub> <mo stretchy="false">)</mo> <mo>,</mo>
    <mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo> <mi>θ</mi>
    <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo stretchy="false">)</mo> <mo>,</mo>
    <mo>…</mo> <mo>,</mo> <mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub> <mo stretchy="false">)</mo>
    <mo>}</mo></mrow></mtd></mtr> <mtr><mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo> <mi>θ</mi>
    <mo>,</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: 'As a shorthand, we often use the vector <math><mrow><mi mathvariant="bold">y</mi></mrow>
    <mo>=</mo> <mo stretchy="false">[</mo> <msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo>
    <msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>y</mi>
    <mi>n</mi></msub> <mo stretchy="false">]</mo></math> . Then we can write the average
    loss as:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简写，我们经常使用向量<math><mrow><mi mathvariant="bold">y</mi></mrow> <mo>=</mo> <mo
    stretchy="false">[</mo> <msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi>
    <mn>2</mn></msub> <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub>
    <mo stretchy="false">]</mo></math>。然后我们可以将平均损失写为：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo>
    <mrow><mi mathvariant="bold">y</mi></mrow> <mo stretchy="false">)</mo> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo>
    <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mrow><mi mathvariant="script">l</mi></mrow>
    <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo> <mrow><msub><mi>y</mi> <mi>i</mi></msub></mrow>
    <mo stretchy="false">)</mo></mtd></mtr></mtable></math>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo>
    <mrow><mi mathvariant="bold">y</mi></mrow> <mo stretchy="false">)</mo> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo>
    <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mrow><mi mathvariant="script">l</mi></mrow>
    <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo> <mrow><msub><mi>y</mi> <mi>i</mi></msub></mrow>
    <mo stretchy="false">)</mo></mtd></mtr></mtable></math>
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that <math><mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <mi>y</mi> <mo stretchy="false">)</mo></math> tells us the
    model’s loss for a single data point while <math><mi>L</mi> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <mrow><mi mathvariant="bold">y</mi></mrow> <mo stretchy="false">)</mo></math>
    gives the model’s average loss for all the data points. The capital <math><mi>L</mi></math>
    helps us remember that the average loss combines multiple smaller <math><mi mathvariant="script">l</mi></math>
    values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，<math><mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <mi>y</mi> <mo stretchy="false">)</mo></math> 告诉我们模型对单个数据点的损失，而<math><mi>L</mi>
    <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo> <mrow><mi mathvariant="bold">y</mi></mrow>
    <mo stretchy="false">)</mo></math> 给出模型对所有数据点的平均损失。大写的<math><mi>L</mi></math>帮助我们记住平均损失结合了多个较小的<math><mi
    mathvariant="script">l</mi></math>值。
- en: Once we define a loss function, we can find the value of <math><mi>θ</mi></math>
    that produces the smallest average loss. We call this minimizing value <math><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></math> . In other words, of all the
    possible <math><mi>θ</mi></math> values, <math><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow></math>
    is the one that produces the smallest average loss for our data. We call this
    optimization process *model fitting*; it finds the best constant model for our
    data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了一个损失函数，我们可以找到产生最小平均损失的 <math><mi>θ</mi></math> 值。我们称这个最小化的值为 <math><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></math> 。换句话说，对于所有可能的 <math><mi>θ</mi></math>
    值，<math><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow></math>
    是为我们的数据产生最小平均损失的那个值。我们称这个优化过程为*模型拟合*；它找到了适合我们数据的最佳常数模型。
- en: 'Next, we look at two particular loss functions: absolute error and squared
    error. Our goal is to fit the model and find <math><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow></math> for each of these loss functions.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看一下两个特定的损失函数：绝对误差和平方误差。我们的目标是拟合模型并找到每个损失函数的 <math><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></math> 。
- en: Mean Absolute Error
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平均绝对误差
- en: 'We start with the *absolute error* loss function. Here’s the idea behind absolute
    loss. For some value of <math><mi>θ</mi></math> and data value <math><mi>y</mi></math>
    :'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从*绝对误差*损失函数开始。这里是绝对损失背后的理念。对于某个 <math><mi>θ</mi></math> 值和数据值 <math><mi>y</mi></math>
    ：
- en: Find the error, <math><mi>y</mi> <mo>−</mo> <mi>θ</mi></math> .
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到误差，<math><mi>y</mi> <mo>−</mo> <mi>θ</mi></math> 。
- en: Take the absolute value of the error, <math><mo stretchy="false">|</mo> <mi>y</mi>
    <mo>−</mo> <mi>θ</mi> <mo stretchy="false">|</mo></math> .
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取误差的绝对值，<math><mo stretchy="false">|</mo> <mi>y</mi> <mo>−</mo> <mi>θ</mi> <mo
    stretchy="false">|</mo></math> 。
- en: So the loss function is <math><mrow><mi mathvariant="script">l</mi></mrow> <mo
    stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo> <mi>y</mi> <mo stretchy="false">)</mo>
    <mo>=</mo> <mrow><mo stretchy="false">|</mo></mrow> <mi>y</mi> <mo>−</mo> <mi>θ</mi>
    <mo stretchy="false">|</mo></math> .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，损失函数为 <math><mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <mi>y</mi> <mo stretchy="false">)</mo> <mo>=</mo> <mrow><mo
    stretchy="false">|</mo></mrow> <mi>y</mi> <mo>−</mo> <mi>θ</mi> <mo stretchy="false">|</mo></math>
    。
- en: Taking the absolute value of the error is a simple way to convert negative errors
    into positive ones. For instance, the point <math><mi>y</mi> <mo>=</mo> <mn>4</mn></math>
    is equally far away from <math><mi>θ</mi> <mo>=</mo> <mn>2</mn></math> and <math><mi>θ</mi>
    <mo>=</mo> <mn>6</mn></math> , so the errors are equally “bad.”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 取误差的绝对值是将负误差转换为正误差的简单方法。例如，点 <math><mi>y</mi> <mo>=</mo> <mn>4</mn></math> 距离
    <math><mi>θ</mi> <mo>=</mo> <mn>2</mn></math> 和 <math><mi>θ</mi> <mo>=</mo> <mn>6</mn></math>
    同样远，因此误差是同样“糟糕”的。
- en: 'The average of the absolute errors is called the *mean absolute error* (MAE).
    The MAE is the average of each of the individual absolute errors:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 平均绝对误差被称为*平均绝对误差*（MAE）。MAE 是每个单独绝对误差的平均值：
- en: <math display="block"><mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo>
    <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo>
    <mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi>
    <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mrow><mo stretchy="false">|</mo></mrow>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mi>θ</mi> <mo stretchy="false">|</mo></math>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo>
    <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo>
    <mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi>
    <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mrow><mo stretchy="false">|</mo></mrow>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mi>θ</mi> <mo stretchy="false">|</mo></math>
- en: 'Notice that the name MAE tells you how to compute it: take the Mean of the
    Absolute value of the Errors, <math><mo fence="false" stretchy="false">{</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mi>θ</mi> <mo fence="false" stretchy="false">}</mo></math>
    .'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，MAE 的名称告诉你如何计算它：取误差的绝对值的平均值，<math><mo fence="false" stretchy="false">{</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mi>θ</mi> <mo fence="false" stretchy="false">}</mo></math>
    。
- en: 'We can write a simple Python function to compute this loss:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个简单的 Python 函数来计算这个损失：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s see how this loss function behaves when we have just five data points
    <math><mo stretchy="false">[</mo> <mrow><mo>–</mo></mrow> <mn>1</mn> <mo>,</mo>
    <mn>0</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mn>5</mn> <mo>,</mo> <mn>10</mn>
    <mo stretchy="false">]</mo></math> . We can try different values of <math><mi>θ</mi></math>
    and see what the MAE outputs for each value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们只有五个数据点 <math><mo stretchy="false">[</mo> <mrow><mo>–</mo></mrow> <mn>1</mn>
    <mo>,</mo> <mn>0</mn> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mn>5</mn> <mo>,</mo> <mn>10</mn>
    <mo stretchy="false">]</mo></math> 时，这个损失函数的表现。我们可以尝试不同的 <math><mi>θ</mi></math>
    值，并查看每个值对应的 MAE 输出：
- en: '![](assets/leds_04in02.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_04in02.png)'
- en: We suggest verifying some of these loss values by hand to check that you understand
    how the MAE is computed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议通过手工验证一些这些损失值，以确保您理解如何计算 MAE。
- en: 'Of the values of <math><mi>θ</mi></math> that we tried, we found that <math><mi>θ</mi>
    <mo>=</mo> <mn>2</mn></math> has the lowest mean absolute error. For this simple
    example, 2 is the median of the data values. This isn’t a coincidence. Let’s now
    check what the average loss is for the original dataset of bus late times. We
    find the MAE when we set <math><mi>θ</mi></math> to the mode, median, and mean
    of the minutes late, respectively:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试的<math><mi>θ</mi></math>值中，我们发现<math><mi>θ</mi><mo>=</mo><mn>2</mn></math>具有最低的平均绝对误差。对于这个简单的例子，2是数据值的中位数。这不是巧合。现在让我们来检查公交晚点时间原始数据的平均损失是多少，当我们将<math><mi>θ</mi></math>设置为分钟数的众数、中位数和平均数时，分别得到的MAE为：
- en: '![](assets/leds_04in03.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_04in03.png)'
- en: We see again that the median (middle plot) gives a smaller loss than the mode
    and mean (left and right plots). In fact, for absolute loss, the minimizing <math><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></math> is the <math><mtext>median</mtext>
    <mo fence="false" stretchy="false">{</mo> <msub><mi>y</mi> <mn>1</mn></msub> <mo>,</mo>
    <msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>y</mi>
    <mi>n</mi></msub> <mo fence="false" stretchy="false">}</mo></math> .
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次看到中位数（中间图）比众数和平均数（左图和右图）有更小的损失。事实上，对于绝对损失，最小化的<math><mrow><mover><mi>θ</mi><mo
    stretchy="false">^</mo></mover></mrow></math>是<math><mtext>中位数</mtext><mo fence="false"
    stretchy="false">{</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub><mo>,</mo><mo>…</mo><mo>,</mo><msub><mi>y</mi><mi>n</mi></msub><mo
    fence="false" stretchy="false">}</mo></math>。
- en: 'So far, we have found the best value of <math><mi>θ</mi></math> by simply trying
    out a few values and then picking the one with the smallest loss. To get a better
    sense of the MAE as a function of <math><mi>θ</mi></math> , we can try many more
    values of <math><mi>θ</mi></math> and plot a curve that shows how <math><mi>L</mi>
    <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo></math> changes as <math><mi>θ</mi></math> changes.
    We draw the curve for the preceding example with the five data values <math><mo
    stretchy="false">[</mo> <mrow><mo>–</mo></mrow> <mn>1</mn> <mo>,</mo> <mn>0</mn>
    <mo>,</mo> <mn>2</mn> <mo>,</mo> <mn>5</mn> <mo>,</mo> <mn>10</mn> <mo stretchy="false">]</mo></math>
    :'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过简单尝试几个值并选择最小损失的值来找到了<math><mi>θ</mi></math>的最佳值。为了更好地理解<math><mi>θ</mi></math>的MAE作为函数的情况，我们可以尝试更多的<math><mi>θ</mi></math>值，并绘制一条曲线，显示<math><mi>L</mi><mo
    stretchy="false">(</mo><mi>θ</mi><mo>,</mo><mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow><mo
    stretchy="false">)</mo></math>随<math><mi>θ</mi></math>变化的情况。我们为前述的五个数据值<math><mo
    stretchy="false">[</mo><mrow><mo>–</mo></mrow><mn>1</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>10</mn><mo
    stretchy="false">]</mo></math>绘制了这条曲线：
- en: '![](assets/leds_04in04.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_04in04.png)'
- en: 'The preceding plot shows that in fact, <math><mi>θ</mi> <mo>=</mo> <mn>2</mn></math>
    is the best choice for this small dataset of five values. Notice the shape of
    the curve. It is piecewise linear, where the line segments connect at the location
    of the data values (–1, 0, 2, and 5). This is a property of the absolute value
    function. With a lot of data, the flat pieces are less obvious. Our bus data have
    over 1,400 points and the MAE curve appears smoother:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示，实际上<math><mi>θ</mi><mo>=</mo><mn>2</mn></math>是这五个值的最佳选择。请注意曲线的形状。它是分段线性的，线段在数据值（–1,
    0, 2和5）的位置连接。这是绝对值函数的特性。对于大量数据，平坦部分不那么明显。我们的公交数据有超过1400个数据点，MAE曲线看起来更加平滑：
- en: '![](assets/leds_04in05.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_04in05.png)'
- en: We can use this plot to help confirm that the median of the data is the minimizing
    value; in other words, <math><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mo>=</mo> <mn>0.74</mn></math> . This plot is not really a proof, but hopefully
    it’s convincing enough for you.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个图来确认数据的中位数是最小化值；换句话说，<math><mrow><mover><mi>θ</mi><mo stretchy="false">^</mo></mover></mrow><mo>=</mo><mn>0.74</mn></math>。这个图不是真正的证明，但希望它足够令你信服。
- en: Next, let’s look at another loss function that squares error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看另一个平方误差的损失函数。
- en: Mean Squared Error
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 均方误差
- en: 'We have fitted a constant model to our data and found that with mean absolute
    error, the minimizer is the median. Now we’ll keep our model the same but switch
    to a different loss function: squared error. Instead of taking the absolute difference
    between each data value <math><mi>y</mi></math> and the constant <math><mi>θ</mi></math>
    , we’ll square the error. That is, for some value of <math><mi>θ</mi></math> and
    data value <math><mi>y</mi></math> :'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将常数模型拟合到我们的数据中，并发现使用均方误差时，最小化器是中位数。现在我们将保持模型不变，但切换到不同的损失函数：平方误差。我们不再取每个数据值<math><mi>y</mi></math>和常数<math><mi>θ</mi></math>之间的绝对差值，而是将误差平方。也就是说，对于某个<math><mi>θ</mi></math>值和数据值<math><mi>y</mi></math>：
- en: Find the error, <math><mi>y</mi> <mo>−</mo> <mi>θ</mi></math> .
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到误差，<math><mi>y</mi> <mo>−</mo> <mi>θ</mi></math>。
- en: Take the square of the error, <math><mo stretchy="false">(</mo> <mi>y</mi> <mo>−</mo>
    <mi>θ</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></math> .
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算误差的平方，<math><mo stretchy="false">(</mo> <mi>y</mi> <mo>−</mo> <mi>θ</mi> <msup><mo
    stretchy="false">)</mo> <mn>2</mn></msup></math>。
- en: This gives the loss function <math><mrow><mi mathvariant="script">l</mi></mrow>
    <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo> <mi>y</mi> <mo stretchy="false">)</mo>
    <mo>=</mo> <mo stretchy="false">(</mo> <mi>y</mi> <mo>−</mo> <mi>θ</mi> <msup><mo
    stretchy="false">)</mo> <mn>2</mn></msup></math> .
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了损失函数<math><mrow><mi mathvariant="script">l</mi></mrow> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <mi>y</mi> <mo stretchy="false">)</mo> <mo>=</mo> <mo stretchy="false">(</mo>
    <mi>y</mi> <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></math>。
- en: 'As before, we want to use all of our data to find the best <math><mi>θ</mi></math>
    , so we compute the mean squared error, or MSE for short:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，我们希望利用所有数据来找到最佳的<math><mi>θ</mi></math>，因此我们计算均方误差，简称为MSE：
- en: <math display="block"><mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo>
    <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo>
    <mo>=</mo> <mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo> <msub><mi>y</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo> <mo>…</mo>
    <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub> <mo stretchy="false">)</mo> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo>
    <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></math>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo>
    <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo>
    <mo>=</mo> <mi>L</mi> <mo stretchy="false">(</mo> <mi>θ</mi> <mo>,</mo> <msub><mi>y</mi>
    <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo>,</mo> <mo>…</mo>
    <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub> <mo stretchy="false">)</mo> <mo>=</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo>
    <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></math>
- en: 'We can write a simple Python function to compute the MSE:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个简单的Python函数来计算MSE：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s again try the mean, median, and mode as potential minimizers of the MSE:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试均值、中位数和众数作为MSE的潜在最小化器：
- en: '![](assets/leds_04in06.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_04in06.png)'
- en: Now when we fit the constant model using MSE loss, we find that the mean (right
    plot) has a smaller loss than the mode and the median (left and middle plots).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们使用MSE损失来拟合常数模型时，我们发现均值（右图）的损失小于中位数和众数（左图和中图）。
- en: 'Let’s plot the MSE curve for different values of <math><mi>θ</mi></math> given
    our data. The curve shows that the minimizing value <math><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></math> is close to 2:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制给定数据的不同<math><mi>θ</mi></math>值的MSE曲线。曲线显示最小化值<math><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></math>接近2：
- en: '![](assets/leds_04in07.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_04in07.png)'
- en: One feature of this curve that is quite noticeable is how rapidly the MSE grows
    compared to the MAE (note the range on the vertical axis). This growth has to
    do with the nature of squaring errors; it places a much higher loss on data values
    further away from <math><mi>θ</mi></math> . If <math><mi>θ</mi> <mo>=</mo> <mn>10</mn></math>
    and <math><mi>y</mi> <mo>=</mo> <mn>110</mn></math> , the squared loss is <math><mo
    stretchy="false">(</mo> <mn>10</mn> <mo>−</mo> <mn>110</mn> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup> <mo>=</mo> <mn>10</mn> <mo>,</mo> <mn>000</mn></math> whereas
    the absolute loss is <math><mo stretchy="false">|</mo> <mn>10</mn> <mo>−</mo>
    <mn>110</mn> <mrow><mo stretchy="false">|</mo></mrow> <mo>=</mo> <mn>100</mn></math>
    . For this reason, the MSE is more sensitive to unusually large data values than
    the MAE.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这条曲线的一个特点是，与MAE相比，MSE增长得非常迅速（注意纵轴上的范围）。这种增长与平方误差的性质有关；它对远离<math><mi>θ</mi></math>的数据值施加了更高的损失。如果<math><mi>θ</mi>
    <mo>=</mo> <mn>10</mn></math>且<math><mi>y</mi> <mo>=</mo> <mn>110</mn></math>，则平方损失为<math><mo
    stretchy="false">(</mo> <mn>10</mn> <mo>−</mo> <mn>110</mn> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup> <mo>=</mo> <mn>10</mn> <mo>,</mo> <mn>000</mn></math>，而绝对损失为<math><mo
    stretchy="false">|</mo> <mn>10</mn> <mo>−</mo> <mn>110</mn> <mrow><mo stretchy="false">|</mo></mrow>
    <mo>=</mo> <mn>100</mn></math>。因此，MSE对异常大的数据值更为敏感。
- en: 'From the MSE curve, it appears that the minimizing <math><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></math> is the mean of <math><mrow><mi
    mathvariant="bold">y</mi></mrow></math> . Again, this is no mere coincidence;
    the mean of the data always coincides with <math><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow></math>
    for squared error. We show how this comes about from the quadratic nature of the
    MSE. Along the way, we demonstrate a common representation of squared loss as
    a sum of variance and bias terms, which is at the heart of model fitting with
    squared loss. To begin, we add and subtract <math><mrow><mover><mi>y</mi> <mo
    stretchy="false">¯</mo></mover></mrow></math> in the loss function and expand
    the square as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从均方误差曲线来看，最小化的 <math><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow></math>
    看起来是 <math><mrow><mi mathvariant="bold">y</mi></mrow></math> 的均值。同样，这不是巧合；数据的均值总是与平方误差的
    <math><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow></math>
    相符。我们展示了这是如何从均方误差的二次特性推导出来的。在此过程中，我们展示了平方损失作为方差和偏差项之和的常见表示，这是模型拟合中的核心。首先，我们在损失函数中添加和减去
    <math><mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow></math>
    ，并展开平方如下：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mi>L</mi> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <mrow><mi mathvariant="bold">y</mi></mrow> <mo stretchy="false">)</mo></mtd>
    <mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi>
    <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mo stretchy="false">[</mo> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo>+</mo> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo> <mi>θ</mi> <mo stretchy="false">)</mo>
    <msup><mo stretchy="false">]</mo> <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mo>=</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo>
    <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">[</mo>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo> <mi>θ</mi> <mo stretchy="false">)</mo>
    <mo>+</mo> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup> <mo
    stretchy="false">]</mo></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mi>L</mi> <mo stretchy="false">(</mo>
    <mi>θ</mi> <mo>,</mo> <mrow><mi mathvariant="bold">y</mi></mrow> <mo stretchy="false">)</mo></mtd>
    <mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi>
    <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mo stretchy="false">[</mo> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo>+</mo> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo> <mi>θ</mi> <mo stretchy="false">)</mo>
    <msup><mo stretchy="false">]</mo> <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mo>=</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo>
    <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">[</mo>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo> <mi>θ</mi> <mo stretchy="false">)</mo>
    <mo>+</mo> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup> <mo
    stretchy="false">]</mo></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: 'Next, we split the MSE into the sum of these three terms and note that the
    middle term is 0, due to the simple property of the average: <math><mo>∑</mo>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo stretchy="false">)</mo> <mo>=</mo>
    <mn>0</mn></math> :'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将均方误差分解为这三个项的和，并注意中间项为0，这是由于平均数的简单性质：<math><mo>∑</mo> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo>=</mo> <mn>0</mn></math> ：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover></mtd>
    <mtd><mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo>
    <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup> <mo>+</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo>
    <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mn>2</mn> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo>
    <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow> <mo stretchy="false">)</mo>
    <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <mi>θ</mi> <mo stretchy="false">)</mo> <mo>+</mo> <mfrac><mn>1</mn>
    <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow>
    <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo
    stretchy="false">¯</mo></mover></mrow> <mo>−</mo> <mi>θ</mi> <mo stretchy="false">)</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo>
    <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo>+</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo>
    <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr>
    <mtr><mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo>
    <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup>
    <mo>+</mo> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover></mtd>
    <mtd><mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo>
    <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup> <mo>+</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo>
    <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mn>2</mn> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo>
    <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow> <mo stretchy="false">)</mo>
    <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <mi>θ</mi> <mo stretchy="false">)</mo> <mo>+</mo> <mfrac><mn>1</mn>
    <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow>
    <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac>
    <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup>
    <mo>+</mo> <mn>2</mn> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo
    stretchy="false">¯</mo></mover></mrow> <mo>−</mo> <mi>θ</mi> <mo stretchy="false">)</mo>
    <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo> <mrow><mi>i</mi> <mo>=</mo>
    <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo>+</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo>
    <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr>
    <mtr><mtd><mo>=</mo> <mfrac><mn>1</mn> <mi>n</mi></mfrac> <munderover><mo>∑</mo>
    <mrow><mi>i</mi> <mo>=</mo> <mn>1</mn></mrow> <mrow><mi>n</mi></mrow></munderover>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup>
    <mo>+</mo> <mo stretchy="false">(</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <mi>θ</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: Of the remaining two terms, the first does not involve <math><mi>θ</mi></math>
    . You probably recognize it as the variance of the data. The second term is always
    non-negative. It is called the *bias squared*. This second term, the bias squared,
    is 0 when <math><mi>θ</mi></math> is <math><mrow><mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow></mrow></math>
    , so <math><mrow><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow></mrow>
    <mo>=</mo> <mrow><mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow></mrow></math>
    gives the smallest MSE for any dataset.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩余的两个术语中，第一个不涉及 <math><mi>θ</mi></math> 。你可能认识到它是数据的方差。第二个术语始终为非负。它称为*偏差平方*。第二个术语，偏差平方，在
    <math><mrow><mrow><mover><mi>θ</mi></mover></mrow></mrow> <mo>=</mo> <mrow><mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow></mrow></math> 时为 0，因此 <math><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></math> 给出任何数据集的最小均方误差。
- en: We have seen that for absolute loss, the best constant model is the median,
    but for squared error, it’s the mean. The choice of the loss function is an important
    aspect of model fitting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，对于绝对损失，最好的常数模型是中位数，但对于平方误差，是均值。选择损失函数是模型拟合的一个重要方面。
- en: Choosing Loss Functions
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择损失函数
- en: 'Now that we’ve worked with two loss functions, we can return to our original
    question: how do we choose whether to use the median, mean, or mode? Since these
    statistics minimize different loss functions,^([2](ch04.html#id794)) we can equivalently
    ask: what is the most appropriate loss function for our problem? To answer this
    question, we look at the context of our problem.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了两个损失函数，我们可以回到最初的问题：我们如何选择使用中位数、均值或模式？由于这些统计量最小化不同的损失函数，^([2](ch04.html#id794))
    我们可以等价地问：对于我们的问题，什么是最合适的损失函数？为了回答这个问题，我们看一下问题的背景。
- en: Compared to the MAE, the MSE gives especially large losses when the bus is much
    later (or earlier) than expected. A bus rider who wants to understand the typical
    late times would use the MAE and the median (0.74 minutes late), but a rider who
    despises unexpected large late times might summarize the data using the MSE and
    the mean (1.92 minutes late).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与平均绝对误差（MAE）相比，均方误差（MSE）在公交车迟到（或提前）很多时会导致特别大的损失。希望了解典型迟到时间的公交车乘客会使用MAE和中位数（晚0.74分钟），但是讨厌意外大迟到时间的乘客可能会用均方误差和均值（晚1.92分钟）来总结数据。
- en: If we want to refine the model even more, we can use a more specialized loss
    function. For example, suppose that when a bus arrives early, it waits at the
    stop until the scheduled time of departure; then we might want to assign an early
    arrival 0 loss. And if a really late bus is a larger aggravation than a moderately
    late one, we might choose an *asymmetric loss function* that gives a larger penalty
    to super-late arrivals.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想进一步优化模型，我们可以使用更专业的损失函数。例如，假设公交车提前到达时会在站点等待直到预定出发时间；那么我们可能希望将早到视为0损失。如果一个非常迟到的公交车比一个中度迟到的公交车更加令人恼火，我们可能会选择一个*非对称损失函数*，对超级迟到的惩罚更大。
- en: In essence, context matters when choosing a loss function. By thinking carefully
    about how we plan to use the model, we can pick a loss function that helps us
    make good data-driven decisions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，在选择损失函数时上下文很重要。通过仔细考虑我们计划如何使用模型，我们可以选择一个有助于我们做出良好数据驱动决策的损失函数。
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We introduced the constant model: a model that summarizes the data by a single
    value. To fit the constant model, we chose a loss function that measured how well
    a given constant fits a data value, and we computed the average loss over all
    of the data values. We saw that depending on the choice of loss function, we get
    a different minimizing value: we found that the mean minimizes the average squared
    error (MSE), and the median minimizes the average absolute error (MAE). We also
    discussed how we can incorporate context and knowledge of our problem to pick
    a loss function.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了恒定模型：一个通过单一值汇总数据的模型。为了拟合恒定模型，我们选择了一个度量给定常数与数据值匹配程度的损失函数，并计算所有数据值的平均损失。我们发现，根据损失函数的选择，我们得到不同的最小化值：我们发现平均值最小化平均平方误差（MSE），中位数最小化平均绝对误差（MAE）。我们还讨论了如何结合问题的上下文和知识来选择损失函数。
- en: 'The idea of fitting models through loss minimization ties simple summary statistics—like
    the mean, median, and mode—to more complex modeling situations. The steps we took
    to model our data apply to many modeling scenarios:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将模型拟合到损失最小化的概念将简单的汇总统计数据（如平均数、中位数和众数）与更复杂的建模情况联系起来。我们在建模数据时采取的步骤适用于许多建模场景：
- en: Select the form of a model (such as the constant model).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择模型的形式（例如恒定模型）。
- en: Select a loss function (such as absolute error).
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个损失函数（如绝对误差）。
- en: Fit the model by minimizing the loss over all the data (such as average loss).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过最小化所有数据的损失来拟合模型（如平均损失）。
- en: For the rest of this book, our modeling techniques expand upon one or more of
    these steps. We introduce new models, new loss functions, and new techniques for
    minimizing loss. [Chapter 5](ch05.html#ch-bus) revisits the study of a bus arriving
    late at its stop. This time, we present the problem as a case study and visit
    all stages of the data science lifecycle. By going through these stages, we make
    some unusual discoveries; when we augment our analysis by considering data scope
    and using an urn to simulate a rider arriving at the bus stop, we find that modeling
    bus lateness is not the same as modeling the rider’s experience waiting for a
    bus.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们的建模技术扩展到这些步骤的一个或多个。我们引入新模型、新损失函数和新的最小化损失技术。[第五章](ch05.html#ch-bus)
    重新审视了公交车晚点到达站点的研究。这一次，我们将问题呈现为案例研究，并访问数据科学生命周期的所有阶段。通过经历这些阶段，我们做出了一些不同寻常的发现；当我们通过考虑数据范围并使用瓮来模拟乘客到达公交车站时，我们发现建模公交车迟到不同于建模乘客等待公交车的经验。
- en: ^([1](ch04.html#id780-marker)) We (the authors) first learned of the bus arrival
    time data from an analysis by a data scientist named Jake VanderPlas. We’ve named
    the protagonist of this section in his honor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#id780-marker)) 我们（作者）最初从名为杰克·范德普拉斯的数据科学家的分析中了解到公交到达时间数据。我们以他的名义命名本节的主角。
- en: '^([2](ch04.html#id794-marker)) The mode minimizes a loss function called 0-1
    loss. Although we haven’t covered this specific loss, the procedure is identical:
    pick the loss function, then find what minimizes the loss.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#id794-marker)) 众数最小化了一个称为0-1损失的损失函数。尽管我们尚未涵盖这种特定损失，但该过程是相同的：选择损失函数，然后找到最小化损失的内容。
