<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 8. Computation on Arrays: Broadcasting" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0205-computation-on-arrays-broadcasting">
<h1><span class="label">Chapter 8. </span>Computation on Arrays: Broadcasting</h1>
<p><a data-primary="arrays" data-secondary="broadcasting" data-type="indexterm" id="ix_ch08-asciidoc0"/><a data-primary="broadcasting" data-type="indexterm" id="ix_ch08-asciidoc1"/><a data-primary="NumPy" data-secondary="broadcasting" data-type="indexterm" id="ix_ch08-asciidoc2"/>We saw in <a data-type="xref" href="ch06.xhtml#section-0203-computation-on-arrays-ufuncs">Chapter 6</a> how NumPy’s universal
functions can be used to <em>vectorize</em> operations and thereby remove slow
Python loops. <a data-primary="broadcasting" data-secondary="defined" data-type="indexterm" id="idm45858801538368"/>This chapter discusses <em>broadcasting</em>: a set of rules by
which NumPy lets you apply binary operations (e.g., addition,
subtraction, multiplication, etc.) between arrays of different sizes and
shapes.</p>
<section data-pdf-bookmark="Introducing Broadcasting" data-type="sect1"><div class="sect1" id="ch_0205-computation-on-arrays-broadcasting_introducing-broadcasting">
<h1>Introducing Broadcasting</h1>
<p><a data-primary="broadcasting" data-secondary="basics" data-type="indexterm" id="ix_ch08-asciidoc3"/>Recall that for arrays of the same size, binary operations are performed
on an element-by-element basis:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>
        <code class="n">b</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">5</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
        <code class="n">a</code> <code class="o">+</code> <code class="n">b</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">])</code></pre>
<p>Broadcasting allows these types of binary operations to be performed on
arrays of different sizes—for example, we can just as easily add a
scalar (think of it as a zero-dimensional array) to an array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">a</code> <code class="o">+</code> <code class="mi">5</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">])</code></pre>
<p>We can think of this as an operation that stretches or duplicates the
value <code>5</code> into the array <code>[5, 5, 5]</code>, and adds the results.</p>
<p class="pagebreak-before less_space">We can similarly extend this idea to arrays of higher dimension. Observe
the result when we add a one-dimensional array to a two-dimensional
array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">M</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">ones</code><code class="p">((</code><code class="mi">3</code><code class="p">,</code> <code class="mi">3</code><code class="p">))</code>
        <code class="n">M</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">],</code>
               <code class="p">[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">],</code>
               <code class="p">[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">]])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">M</code> <code class="o">+</code> <code class="n">a</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">2.</code><code class="p">,</code> <code class="mf">3.</code><code class="p">],</code>
               <code class="p">[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">2.</code><code class="p">,</code> <code class="mf">3.</code><code class="p">],</code>
               <code class="p">[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">2.</code><code class="p">,</code> <code class="mf">3.</code><code class="p">]])</code></pre>
<p>Here the one-dimensional array <code>a</code> is stretched, or broadcasted, across
the second dimension in order to match the shape of <code>M</code>.</p>
<p>While these examples are relatively easy to understand, more complicated
cases can involve broadcasting of both arrays. Consider the following
example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>
        <code class="n">b</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">3</code><code class="p">)[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">]</code>

        <code class="nb">print</code><code class="p">(</code><code class="n">a</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">b</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="p">[</code><code class="mi">0</code> <code class="mi">1</code> <code class="mi">2</code><code class="p">]</code>
        <code class="p">[[</code><code class="mi">0</code><code class="p">]</code>
         <code class="p">[</code><code class="mi">1</code><code class="p">]</code>
         <code class="p">[</code><code class="mi">2</code><code class="p">]]</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">a</code> <code class="o">+</code> <code class="n">b</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
               <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">]])</code></pre>
<p>Just as before we stretched or broadcasted one value to match the shape
of the other, here we’ve stretched <em>both</em> <code>a</code> and <code>b</code> to
match a common shape, and the result is a two-dimensional array! The
geometry of these examples is visualized in <a data-type="xref" href="#fig_images_in_0205-broadcasting">Figure 8-1</a>.</p>
<p>The light boxes represent the broadcasted values. This way of thinking
about broadcasting may raise questions about its efficiency in terms of
memory use, but worry not: NumPy broadcasting does not actually copy the
broadcasted values in memory. Still, this can be a useful mental model
as we think about broadcasting.<a data-startref="ix_ch08-asciidoc3" data-type="indexterm" id="idm45858801114800"/></p>
<figure><div class="figure" id="fig_images_in_0205-broadcasting">
<img alt="02.05 broadcasting" height="480" src="assets/02.05-broadcasting.png" width="600"/>
<h6><span class="label">Figure 8-1. </span>Visualization of NumPy broadcasting (adapted from a source published in the <a href="http://astroml.org">astroML documentation</a> and used with permission)<sup><a data-type="noteref" href="ch08.xhtml#idm45858801111664" id="idm45858801111664-marker">1</a></sup></h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Rules of Broadcasting" data-type="sect1"><div class="sect1" id="ch_0205-computation-on-arrays-broadcasting_rules-of-broadcasting">
<h1>Rules of Broadcasting</h1>
<p><a data-primary="broadcasting" data-secondary="rules" data-type="indexterm" id="ix_ch08-asciidoc4"/>Broadcasting in NumPy follows a strict set of rules to determine the
interaction between the two arrays:</p>
<dl>
<dt>Rule 1</dt>
<dd>
<p>If the two arrays differ in their number of dimensions, the
shape of the one with fewer dimensions is <em>padded</em> with ones on its
leading (left) side.</p>
</dd>
<dt>Rule 2</dt>
<dd>
<p>If the shape of the two arrays does not match in any
dimension, the array with shape equal to 1 in that dimension is
stretched to match the other shape.</p>
</dd>
<dt>Rule 3</dt>
<dd>
<p>If in any dimension the sizes disagree and neither is equal to
1, an error is raised.</p>
</dd>
</dl>
<p>To make these rules clear, let’s consider a few examples in
detail.</p>
<section data-pdf-bookmark="Broadcasting Example 1" data-type="sect2"><div class="sect2" id="ch_0205-computation-on-arrays-broadcasting_broadcasting-example-1">
<h2>Broadcasting Example 1</h2>
<p><a data-primary="broadcasting" data-secondary="adding two-dimensional array to one-dimensional array" data-type="indexterm" id="idm45858801099360"/>Suppose we want to add a two-dimensional array to a one-dimensional
array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">M</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">ones</code><code class="p">((</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">))</code>
        <code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code></pre>
<p>Let’s consider an operation on these two arrays, which have
the following shapes:</p>
<ul>
<li>
<p><code>M.shape</code> is <code>(2, 3)</code></p>
</li>
<li>
<p><code>a.shape</code> is <code>(3,)</code></p>
</li>
</ul>
<p>We see by rule 1 that the array <code>a</code> has fewer dimensions, so we pad it
on the left with ones:</p>
<ul>
<li>
<p><code>M.shape</code> remains <code>(2, 3)</code></p>
</li>
<li>
<p><code>a.shape</code> becomes <code>(1, 3)</code></p>
</li>
</ul>
<p>By rule 2, we now see that the first dimension disagrees, so we stretch
this dimension to match:</p>
<ul>
<li>
<p><code>M.shape</code> remains <code>(2, 3)</code></p>
</li>
<li>
<p><code>a.shape</code> becomes <code>(2, 3)</code></p>
</li>
</ul>
<p>The shapes now match, and we see that the final shape will be <code>(2, 3)</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">M</code> <code class="o">+</code> <code class="n">a</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">2.</code><code class="p">,</code> <code class="mf">3.</code><code class="p">],</code>
               <code class="p">[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">2.</code><code class="p">,</code> <code class="mf">3.</code><code class="p">]])</code></pre>
</div></section>
<section data-pdf-bookmark="Broadcasting Example 2" data-type="sect2"><div class="sect2" id="ch_0205-computation-on-arrays-broadcasting_broadcasting-example-2">
<h2>Broadcasting Example 2</h2>
<p><a data-primary="broadcasting" data-secondary="two compatible arrays" data-type="indexterm" id="idm45858800981056"/>Now let’s take a look at an example where both arrays need
to be broadcast:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code class="o">.</code><code class="n">reshape</code><code class="p">((</code><code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code>
         <code class="n">b</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code></pre>
<p>Again, we’ll start by determining the shapes of the arrays:</p>
<ul>
<li>
<p><code>a.shape</code> is <code>(3, 1)</code></p>
</li>
<li>
<p><code>b.shape</code> is <code>(3,)</code></p>
</li>
</ul>
<p>Rule 1 says we must pad the shape of <code>b</code> with ones:</p>
<ul>
<li>
<p><code>a.shape</code> remains <code>(3, 1)</code></p>
</li>
<li>
<p><code>b.shape</code> becomes <code>(1, 3)</code></p>
</li>
</ul>
<p>And rule 2 tells us that we must upgrade each of these <code>1</code>s to match the
corresponding size of the other array:</p>
<ul>
<li>
<p><code>a.shape</code> becomes <code>(3, 3)</code></p>
</li>
<li>
<p><code>b.shape</code> becomes <code>(3, 3)</code></p>
</li>
</ul>
<p>Because the results match, these shapes are compatible. We can see this
here:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">a</code> <code class="o">+</code> <code class="n">b</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
                <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">]])</code></pre>
</div></section>
<section data-pdf-bookmark="Broadcasting Example 3" data-type="sect2"><div class="sect2" id="ch_0205-computation-on-arrays-broadcasting_broadcasting-example-3">
<h2>Broadcasting Example 3</h2>
<p><a data-primary="broadcasting" data-secondary="two incompatible arrays" data-type="indexterm" id="idm45858800853952"/>Next, let’s take a look at an example in which the two
arrays are not compatible:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">M</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">ones</code><code class="p">((</code><code class="mi">3</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code>
         <code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code></pre>
<p>This is just a slightly different situation than in the first example:
the matrix <code>M</code> is transposed. How does this affect the calculation? The
shapes of the arrays are as 
<span class="keep-together">follows</span>:</p>
<ul>
<li>
<p><code>M.shape</code> is <code>(3, 2)</code></p>
</li>
<li>
<p><code>a.shape</code> is <code>(3,)</code></p>
</li>
</ul>
<p>Again, rule 1 tells us that we must pad the shape of <code>a</code> with ones:</p>
<ul>
<li>
<p><code>M.shape</code> remains <code>(3, 2)</code></p>
</li>
<li>
<p><code>a.shape</code> becomes <code>(1, 3)</code></p>
</li>
</ul>
<p>By rule 2, the first dimension of <code>a</code> is then stretched to match that of
<code>M</code>:</p>
<ul>
<li>
<p><code>M.shape</code> remains <code>(3, 2)</code></p>
</li>
<li>
<p><code>a.shape</code> becomes <code>(3, 3)</code></p>
</li>
</ul>
<p>Now we hit rule 3—the final shapes do not match, so these two arrays are
incompatible, as we can observe by attempting this operation:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">M</code> <code class="o">+</code> <code class="n">a</code>
<code class="ne">ValueError</code><code class="p">:</code> <code class="n">operands</code> <code class="n">could</code> <code class="ow">not</code> <code class="n">be</code> <code class="n">broadcast</code> <code class="n">together</code> <code class="k">with</code> <code class="n">shapes</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code><code class="mi">2</code><code class="p">)</code> <code class="p">(</code><code class="mi">3</code><code class="p">,)</code></pre>
<p>Note the potential confusion here: you could imagine making <code>a</code> and <code>M</code>
compatible by, say, padding <code>a</code>’s shape with ones on the
right rather than the left. But this is not how the broadcasting rules
work! That sort of flexibility might be useful in some cases, but it
would lead to potential areas of ambiguity. If right-side padding is
what you’d like, you can do this explicitly by reshaping the
array (we’ll use the <code>np.newaxis</code> keyword introduced in
<a data-type="xref" href="ch05.xhtml#section-0202-the-basics-of-numpy-arrays">Chapter 5</a>
for this):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">a</code><code class="p">[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">]</code><code class="o">.</code><code class="n">shape</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">M</code> <code class="o">+</code> <code class="n">a</code><code class="p">[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">1.</code><code class="p">,</code> <code class="mf">1.</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">2.</code><code class="p">,</code> <code class="mf">2.</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">3.</code><code class="p">,</code> <code class="mf">3.</code><code class="p">]])</code></pre>
<p>While we’ve been focusing on the <code>+</code>
operator here, these broadcasting rules apply to <em>any</em> binary ufunc. For
example, here is the <code>logaddexp(a, b)</code> function, which computes
<code>log(exp(a) + exp(b))</code> with more precision than the naive approach:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">logaddexp</code><code class="p">(</code><code class="n">M</code><code class="p">,</code> <code class="n">a</code><code class="p">[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">array</code><code class="p">([[</code><code class="mf">1.31326169</code><code class="p">,</code> <code class="mf">1.31326169</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">1.69314718</code><code class="p">,</code> <code class="mf">1.69314718</code><code class="p">],</code>
                <code class="p">[</code><code class="mf">2.31326169</code><code class="p">,</code> <code class="mf">2.31326169</code><code class="p">]])</code></pre>
<p>For more information on the many available universal functions, refer to
<a data-type="xref" href="ch06.xhtml#section-0203-computation-on-arrays-ufuncs">Chapter 6</a>.<a data-startref="ix_ch08-asciidoc4" data-type="indexterm" id="idm45858800573600"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Broadcasting in Practice" data-type="sect1"><div class="sect1" id="ch_0205-computation-on-arrays-broadcasting_broadcasting-in-practice">
<h1>Broadcasting in Practice</h1>
<p><a data-primary="broadcasting" data-secondary="in practice" data-secondary-sortas="practice" data-type="indexterm" id="idm45858800571472"/>Broadcasting operations form the core of many examples
you’ll see throughout this book. We’ll now take
a look at some instances of where they can be useful.</p>
<section data-pdf-bookmark="Centering an Array" data-type="sect2"><div class="sect2" id="ch_0205-computation-on-arrays-broadcasting_centering-an-array">
<h2>Centering an Array</h2>
<p><a data-primary="arrays" data-secondary="centering" data-type="indexterm" id="idm45858800567536"/><a data-primary="broadcasting" data-secondary="centering an array" data-type="indexterm" id="idm45858800566560"/>In <a data-type="xref" href="ch06.xhtml#section-0203-computation-on-arrays-ufuncs">Chapter 6</a>, we saw that ufuncs allow a NumPy user to
remove the need to explicitly write slow Python loops. Broadcasting
extends this ability. One commonly seen example in data science is
subtracting the row-wise mean from an array of data. Imagine we have an
array of 10 observations, each of which consists of 3 values. Using the
standard convention (see
<a data-type="xref" href="ch38.xhtml#section-0502-introducing-scikit-learn">Chapter 38</a>), we’ll store this in a
<math alttext="10 times 3">
<mrow>
<mn>10</mn>
<mo>×</mo>
<mn>3</mn>
</mrow>
</math> array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">rng</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">default_rng</code><code class="p">(</code><code class="n">seed</code><code class="o">=</code><code class="mi">1701</code><code class="p">)</code>
         <code class="n">X</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">random</code><code class="p">((</code><code class="mi">10</code><code class="p">,</code> <code class="mi">3</code><code class="p">))</code></pre>
<p>We can compute the mean of each column using the <code>mean</code> aggregate across
the first dimension:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">Xmean</code> <code class="o">=</code> <code class="n">X</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
         <code class="n">Xmean</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mf">0.38503638</code><code class="p">,</code> <code class="mf">0.36991443</code><code class="p">,</code> <code class="mf">0.63896043</code><code class="p">])</code></pre>
<p>And now we can center the <code>X</code> array by subtracting the mean (this is a
broadcasting operation):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">X_centered</code> <code class="o">=</code> <code class="n">X</code> <code class="o">-</code> <code class="n">Xmean</code></pre>
<p>To double-check that we’ve done this correctly, we can check
that the centered array has a mean near zero:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">X_centered</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="mf">4.99600361e-17</code><code class="p">,</code> <code class="o">-</code><code class="mf">4.44089210e-17</code><code class="p">,</code>  <code class="mf">0.00000000e+00</code><code class="p">])</code></pre>
<p>To within machine precision, the mean is now zero.</p>
</div></section>
<section data-pdf-bookmark="Plotting a Two-Dimensional Function" data-type="sect2"><div class="sect2" id="ch_0205-computation-on-arrays-broadcasting_plotting-a-two-dimensional-function">
<h2>Plotting a Two-Dimensional Function</h2>
<p><a data-primary="broadcasting" data-secondary="plotting two-dimensional function" data-type="indexterm" id="idm45858800400624"/><a data-primary="plotting" data-secondary="two-dimensional function" data-type="indexterm" id="idm45858800399680"/>One place that broadcasting often comes in handy is in displaying images
based on two-dimensional functions. If we want to define a function
<math alttext="z equals f left-parenthesis x comma y right-parenthesis">
<mrow>
<mi>z</mi>
<mo>=</mo>
<mi>f</mi>
<mo>(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo>)</mo>
</mrow>
</math>, broadcasting can be used to compute the
function across the grid:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="c1"># x and y have 50 steps from 0 to 5</code>
         <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">50</code><code class="p">)</code>
         <code class="n">y</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">50</code><code class="p">)[:,</code> <code class="n">np</code><code class="o">.</code><code class="n">newaxis</code><code class="p">]</code>

         <code class="n">z</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">**</code> <code class="mi">10</code> <code class="o">+</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="mi">10</code> <code class="o">+</code> <code class="n">y</code> <code class="o">*</code> <code class="n">x</code><code class="p">)</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">x</code><code class="p">)</code></pre>
<p>We’ll use Matplotlib to plot this two-dimensional array,
shown in <a data-type="xref" href="#fig_0205-computation-on-arrays-broadcasting_files_in_output_52_0">Figure 8-2</a> (these tools will be discussed in full in
<a data-type="xref" href="ch28.xhtml#section-0404-density-and-contour-plots">Chapter 28</a>):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="o">%</code><code class="k">matplotlib</code> inline
         <code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">imshow</code><code class="p">(</code><code class="n">z</code><code class="p">,</code> <code class="n">origin</code><code class="o">=</code><code class="s1">'lower'</code><code class="p">,</code> <code class="n">extent</code><code class="o">=</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">])</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">colorbar</code><code class="p">();</code></pre>
<figure class="width-60"><div class="figure" id="fig_0205-computation-on-arrays-broadcasting_files_in_output_52_0">
<img alt="output 52 0" height="293" src="assets/output_52_0.png" width="600"/>
<h6><span class="label">Figure 8-2. </span>Visualization of a 2D array</h6>
</div></figure>
<p>The result is a compelling visualization of the two-dimensional
function.<a data-startref="ix_ch08-asciidoc2" data-type="indexterm" id="idm45858800177488"/><a data-startref="ix_ch08-asciidoc1" data-type="indexterm" id="idm45858800176784"/><a data-startref="ix_ch08-asciidoc0" data-type="indexterm" id="idm45858800176112"/></p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45858801111664"><sup><a href="ch08.xhtml#idm45858801111664-marker">1</a></sup> Code to produce this plot can be found in the online <a href="https://oreil.ly/gtOaU">appendix</a>.</p></div></div></section></div></body></html>