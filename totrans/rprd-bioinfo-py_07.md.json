["```py\n$ ./dna.py AAACCCGGGTTT\n3 3 3 3\n$ ./dna.py CGACGATATGTC\n3 3 3 3\n```", "```py\n$ cp solution1_abs_iterate.py hamm.py\n$ ./hamm.py -h\nusage: hamm.py [-h] str str\n\nHamming distance\n\npositional arguments:\n  str         Sequence 1\n  str         Sequence 2\n\noptional arguments:\n  -h, --help  show this help message and exit\n```", "```py\n$ ./hamm.py GAGCCTACTAACGGGAT CATCGTAATGACGGCCT\n7\n```", "```py\n$ new.py -fp 'Hamming distance' hamm.py\nDone, see new script \"hamm.py\".\n```", "```py\nimport argparse\nfrom typing import NamedTuple\n\nclass Args(NamedTuple): ![1](assets/1.png)\n    \"\"\" Command-line arguments \"\"\"\n    seq1: str\n    seq2: str\n\n# --------------------------------------------------\ndef get_args():\n    \"\"\" Get command-line arguments \"\"\"\n\n    parser = argparse.ArgumentParser(\n        description='Hamming distance',\n        formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument('seq1', metavar='str', help='Sequence 1') ![2](assets/2.png)\n\n    parser.add_argument('seq2', metavar='str', help='Sequence 2')\n\n    args = parser.parse_args()\n\n    return Args(args.seq1, args.seq2) ![3](assets/3.png)\n```", "```py\ndef main():\n    args = get_args()\n    print(args.seq1, args.seq2)\n```", "```py\n$ ./hamm.py GAGCCTACTAACGGGAT CATCGTAATGACGGCCT\nGAGCCTACTAACGGGAT CATCGTAATGACGGCCT\n```", "```py\n=================================== FAILURES ===================================\n_________________________________ test_input1 __________________________________\n\n    def test_input1() -> None:\n        \"\"\" Test with input1 \"\"\"\n\n>       run(INPUT1)\n\ntests/hamm_test.py:47:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfile = './tests/inputs/1.txt' ![1](assets/1.png)\n\n    def run(file: str) -> None:\n        \"\"\" Run with input \"\"\"\n\n        assert os.path.isfile(file)\n        seq1, seq2, expected = open(file).read().splitlines() ![2](assets/2.png)\n\n        rv, out = getstatusoutput(f'{RUN} {seq1} {seq2}') ![3](assets/3.png)\n        assert rv == 0\n>       assert out.rstrip() == expected ![4](assets/4.png)\nE       AssertionError: assert 'GAGCCTACTAACGGGAT CATCGTAATGACGGCCT' == '7' ![5](assets/5.png)\nE         - 7\nE         + GAGCCTACTAACGGGAT CATCGTAATGACGGCCT\n\ntests/hamm_test.py:40: AssertionError\n=========================== short test summary info ============================\nFAILED tests/hamm_test.py::test_input1 - AssertionError: assert 'GAGCCTACTAAC...\n!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!\n========================= 1 failed, 3 passed in 0.27s ==========================\n```", "```py\n>>> seq1, seq2 = 'AC', 'ACGT'\n```", "```py\n>>> len(seq1) - len(seq2)\n-2\n```", "```py\n>>> distance = abs(len(seq1) - len(seq2))\n>>> distance\n2\n```", "```py\n>>> min(len(seq1), len(seq2))\n2\n```", "```py\n>>> for i in range(min(len(seq1), len(seq2))):\n...     print(seq1[i], seq2[i])\n...\nA A\nC C\n```", "```py\n$ ./hamm.py ATTG TTG\n3\n```", "```py\ndef main():\n    args = get_args()\n    seq1, seq2 = args.seq1, args.seq2 ![1](assets/1.png)\n\n    l1, l2 = len(seq1), len(seq2) ![2](assets/2.png)\n    distance = abs(l1 - l2) ![3](assets/3.png)\n\n    for i in range(min(l1, l2)): ![4](assets/4.png)\n        if seq1[i] != seq2[i]: ![5](assets/5.png)\n            distance += 1 ![6](assets/6.png)\n\n    print(distance) ![7](assets/7.png)\n```", "```py\ndef hamming(seq1: str, seq2: str) -> int: ![1](assets/1.png)\n    \"\"\" Calculate Hamming distance \"\"\"\n\n    return 0 ![2](assets/2.png)\n```", "```py\ndef test_hamming() -> None:\n    \"\"\" Test hamming \"\"\"\n\n    assert hamming('', '') == 0 ![1](assets/1.png)\n    assert hamming('AC', 'ACGT') == 2 ![2](assets/2.png)\n    assert hamming('GAGCCTACTAACGGGAT', 'CATCGTAATGACGGCCT') == 7 ![3](assets/3.png)\n```", "```py\n$ pytest -v hamm.py\n========================== test session starts ==========================\n...\n\nhamm.py::test_hamming FAILED                                      [100%]\n\n=============================== FAILURES ================================\n_____________________________ test_hamming ______________________________\n\n    def test_hamming() -> None:\n        \"\"\" Test hamming \"\"\"\n\n        assert hamming('', '') == 0\n>       assert hamming('AC', 'ACGT') == 2\nE       assert 0 == 2\nE         +0\nE         -2\n\nhamm.py:69: AssertionError\n======================== short test summary info ========================\nFAILED hamm.py::test_hamming - assert 0 == 2\n=========================== 1 failed in 0.13s ===========================\n```", "```py\ndef hamming(seq1: str, seq2: str) -> int:\n    \"\"\" Calculate Hamming distance \"\"\"\n\n    l1, l2 = len(seq1), len(seq2)\n    distance = abs(l1 - l2)\n\n    for i in range(min(l1, l2)):\n        if seq1[i] != seq2[i]:\n            distance += 1\n\n    return distance\n```", "```py\n$ pytest -v hamm.py\n========================== test session starts ==========================\n...\n\nhamm.py::test_hamming PASSED                                      [100%]\n\n=========================== 1 passed in 0.02s ===========================\n```", "```py\ndef main():\n    args = get_args()\n    print(hamming(args.seq1, args.seq2))  ![1](assets/1.png)\n```", "```py\n>>> list(zip('ABC', '123'))\n[('A', '1'), ('B', '2'), ('C', '3')]\n```", "```py\n>>> list(zip('AC', 'ACGT'))\n[('A', 'A'), ('C', 'C')]\n```", "```py\n>>> for tup in zip('AC', 'ACGT'):\n...     print(tup)\n...\n('A', 'A')\n('C', 'C')\n```", "```py\n>>> for char1, char2 in zip('AC', 'ACGT'):\n...     print(char1, char2)\n...\nA A\nC C\n```", "```py\ndef hamming(seq1: str, seq2: str) -> int:\n    \"\"\" Calculate Hamming distance \"\"\"\n\n    distance = abs(len(seq1) - len(seq2)) ![1](assets/1.png)\n\n    for char1, char2 in zip(seq1, seq2): ![2](assets/2.png)\n        if char1 != char2: ![3](assets/3.png)\n            distance += 1 ![4](assets/4.png)\n\n    return distance\n```", "```py\n>>> from itertools import zip_longest\n>>> list(zip_longest('AC', 'ACGT'))\n[('A', 'A'), ('C', 'C'), (None, 'G'), (None, 'T')]\n```", "```py\ndef hamming(seq1: str, seq2: str) -> int:\n    \"\"\" Calculate Hamming distance \"\"\"\n\n    distance = 0 ![1](assets/1.png)\n    for char1, char2 in zip_longest(seq1, seq2): ![2](assets/2.png)\n        if char1 != char2: ![3](assets/3.png)\n            distance += 1 ![4](assets/4.png)\n\n    return distance\n```", "```py\n>>> seq1, seq2, = 'GAGCCTACTAACGGGAT', 'CATCGTAATGACGGCCT'\n>>> [1 if c1 != c2 else 0 for c1, c2 in zip_longest(seq1, seq2)]\n[1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0]\n```", "```py\n>>> sum([1 if c1 != c2 else 0 for c1, c2 in zip_longest(seq1, seq2)])\n7\n```", "```py\n>>> ones = [1 for c1, c2 in zip_longest(seq1, seq2) if c1 != c2] ![1](assets/1.png)\n>>> ones\n[1, 1, 1, 1, 1, 1, 1]\n>>> sum(ones)\n7\n```", "```py\n>>> bools = [c1 != c2 for c1, c2 in zip_longest(seq1, seq2)]\n>>> bools\n[True, False, True, False, True, False, False, True, False, True, False,\nFalse, False, False, True, True, False]\n>>> sum(bools)\n7\n```", "```py\ndef hamming(seq1: str, seq2: str) -> int:\n    \"\"\" Calculate Hamming distance \"\"\"\n\n    return sum([c1 != c2 for c1, c2 in zip_longest(seq1, seq2)])\n```", "```py\n>>> list(filter(lambda char1, char2: char1 != char2, zip_longest(seq1, seq2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: <lambda>() missing 1 required positional argument: 'char2'\n```", "```py\n>>> seq1, seq2 = 'AC', 'ACGT'\n>>> list(filter(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))\n[(None, 'G'), (None, 'T')]\n```", "```py\n>>> len(filter(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: object of type 'filter' has no len()\n```", "```py\ndef hamming(seq1: str, seq2: str) -> int:\n    \"\"\" Calculate Hamming distance \"\"\"\n\n    distance = filter(lambda t: t[0] != t[1], zip_longest(seq1, seq2)) ![1](assets/1.png)\n    return len(list((distance))) ![2](assets/2.png)\n```", "```py\n>>> seq1, seq2 = 'AC', 'ACGT'\n>>> list(map(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))\n[False, False, True, True]\n```", "```py\n>>> seq1, seq2, = 'GAGCCTACTAACGGGAT', 'CATCGTAATGACGGCCT'\n>>> sum(map(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))\n7\n```", "```py\ndef hamming(seq1: str, seq2: str) -> int:\n    \"\"\" Calculate Hamming distance \"\"\"\n\n    return sum(map(lambda t: t[0] != t[1], zip_longest(seq1, seq2)))\n```", "```py\n>>> not_same = lambda t: t[0] != t[1]\n```", "```py\ndef not_same(t):\n    return t[0] != t[1]\n```", "```py\n>>> not_same(('A', 'A'))\nFalse\n>>> not_same(('A', 'T'))\nTrue\n```", "```py\n>>> not_same = lambda a, b: a != b\n>>> list(map(not_same, zip_longest(seq1, seq2)))\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: <lambda>() missing 1 required positional argument: 'b'\n```", "```py\n>>> from itertools import zip_longest, starmap\n>>> seq1, seq2 = 'AC', 'ACGT'\n>>> list(starmap(not_same, zip_longest(seq1, seq2)))\n[False, False, True, True]\n```", "```py\n>>> import operator\n>>> operator.ne('A', 'A')\nFalse\n>>> operator.ne('A', 'T')\nTrue\n```", "```py\n>>> 1 + 2\n3\n>>> operator.add(1, 2)\n3\n```", "```py\n>>> 'AC' + 'GT'\n'ACGT'\n>>> operator.concat('AC', 'GT')\n'ACGT'\n```", "```py\n>>> seq1, seq2 = 'AC', 'ACGT'\n>>> list(starmap(operator.ne, zip_longest(seq1, seq2)))\n[False, False, True, True]\n```", "```py\n>>> seq1, seq2, = 'GAGCCTACTAACGGGAT', 'CATCGTAATGACGGCCT'\n>>> sum(starmap(operator.ne, zip_longest(seq1, seq2)))\n7\n```", "```py\ndef hamming(seq1: str, seq2: str) -> int:\n    \"\"\" Calculate Hamming distance \"\"\"\n\n    return sum(starmap(operator.ne, zip_longest(seq1, seq2))) ![1](assets/1.png)\n```"]