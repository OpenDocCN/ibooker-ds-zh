<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 16. Handling Missing Data" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0304-missing-values">
<h1><span class="label">Chapter 16. </span>Handling Missing Data</h1>
<p><a data-primary="missing data" data-secondary="handling" data-type="indexterm" id="ix_ch16-asciidoc0"/><a data-primary="Pandas" data-secondary="handling missing data" data-type="indexterm" id="ix_ch16-asciidoc1"/>The difference between data found in many tutorials and data in the real
world is that real-world data is rarely clean and homogeneous. In
particular, many interesting datasets will have some amount of data
missing. To make matters even more complicated, different data sources
may indicate missing data in different ways.</p>
<p>In this chapter, we will discuss some general considerations for missing
data, look at how Pandas chooses to represent it, and explore some
built-in Pandas tools for handling missing data in Python. Here and
throughout the book, I will refer to missing data in general as <em>null</em>,
<code><em>NaN</em></code>, or <em>NA</em> values.</p>
<section data-pdf-bookmark="Trade-offs in Missing Data Conventions" data-type="sect1"><div class="sect1" id="ch_0304-missing-values_trade-offs-in-missing-data-conventions">
<h1>Trade-offs in Missing Data Conventions</h1>
<p><a data-primary="missing data" data-secondary="trade-offs in conventions" data-type="indexterm" id="idm45858786511824"/>A number of approaches have been developed to track the presence of
missing data in a table or <code>DataFrame</code>. Generally, they revolve around
one of two strategies: using a <em>mask</em> that globally indicates missing
values, or choosing a <em>sentinel value</em> that indicates a missing entry.</p>
<p>In the masking approach, the mask might be an entirely separate Boolean
array, or it might involve appropriation of one bit in the data
representation to locally indicate the null status of a value.</p>
<p><a data-primary="sentinel value" data-type="indexterm" id="idm45858786508784"/>In the sentinel approach, the sentinel value could be some data-specific
convention, such as indicating a missing integer value with –9999 or
some rare bit pattern, or it could be a more global convention, such as
indicating a missing floating-point value with <code>NaN</code> (Not a Number), a
special value that is part of the IEEE floating-point 
<span class="keep-together">specification</span>.</p>
<p class="pagebreak-before less_space">Neither of these approaches is without trade-offs. Use of a separate
mask array requires allocation of an additional Boolean array, which
adds overhead in both storage and computation. A sentinel value reduces
the range of valid values that can be represented, and may require extra
(often nonoptimized) logic in CPU and GPU arithmetic, because common
special values like <code>NaN</code> are not available for all data types.</p>
<p>As in most cases where no universally optimal choice exists, different
languages and systems use different conventions. For example, the R
language uses reserved bit patterns within each data type as sentinel
values indicating missing data, while the SciDB system uses an extra
byte attached to every cell to indicate an NA state.</p>
</div></section>
<section data-pdf-bookmark="Missing Data in Pandas" data-type="sect1"><div class="sect1" id="ch_0304-missing-values_missing-data-in-pandas">
<h1>Missing Data in Pandas</h1>
<p>The way in which Pandas handles missing values is constrained by its
reliance on the NumPy package, which does not have a built-in notion of
NA values for non-floating-point data types.</p>
<p>Perhaps Pandas could have followed R’s lead in specifying
bit patterns for each individual data type to indicate nullness, but
this approach turns out to be rather unwieldy. While R has just 4 main
data types, NumPy supports <em>far</em> more than this: for example, while R
has a single integer type, NumPy supports 14 basic integer types once
you account for available bit widths, signedness, and endianness of the
encoding. Reserving a specific bit pattern in all available NumPy types
would lead to an unwieldy amount of overhead in special-casing various
operations for various types, likely even requiring a new fork of the
NumPy package. Further, for the smaller data types (such as 8-bit
integers), sacrificing a bit to use as a mask would significantly reduce
the range of values it can represent.</p>
<p>Because of these constraints and trade-offs, Pandas has two “modes” of
storing and manipulating null values:</p>
<ul>
<li>
<p>The default mode is to use a sentinel-based missing data scheme, with
sentinel values <code>NaN</code> or <code>None</code> depending on the type of the data.</p>
</li>
<li>
<p>Alternatively, you can opt in to using the nullable data types
(dtypes) Pandas provides (discussed later in this chapter), which
results in the creation an accompanying mask array to track missing
entries. These missing entries are then presented to the user as the
special <code>pd.NA</code> value.</p>
</li>
</ul>
<p>In either case, the data operations and manipulations provided by the
Pandas API will handle and propagate those missing entries in a
predictable manner. But to develop some intuition into <em>why</em> these
choices are made, let’s dive quickly into the trade-offs
inherent in <code>None</code>, <code>NaN</code>, and <code>NA</code>. As usual, we’ll start
by importing NumPy and Pandas:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
        <code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code></pre>
<section data-pdf-bookmark="None as a Sentinel Value" data-type="sect2"><div class="sect2" id="ch_0304-missing-values_none-as-a-sentinel-value">
<h2>None as a Sentinel Value</h2>
<p><a data-primary="missing data" data-secondary="None" data-type="indexterm" id="idm45858786470832"/><a data-primary="None object" data-type="indexterm" id="idm45858786469664"/><a data-primary="sentinel value" data-type="indexterm" id="idm45858786468992"/>For some data types, Pandas uses <code>None</code> as a sentinel value. <code>None</code> is a
Python object, which means that any array containing <code>None</code> must have
<code>dtype=object</code>—that is, it must be a sequence of Python objects.</p>
<p>For example, observe what happens if you pass <code>None</code> to a NumPy array:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">vals1</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="kc">None</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
        <code class="n">vals1</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="kc">None</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="nb">object</code><code class="p">)</code></pre>
<p>This <code>dtype=object</code> means that the best common type representation NumPy
could infer for the contents of the array is that they are Python
objects. The downside of using <code>None</code> in this way is that operations on
the data will be done at the Python level, with much more overhead than
the typically fast operations seen for arrays with native types:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="o">%</code><code class="k">timeit</code> np.arange(1E6, dtype=int).sum()
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="mf">2.73</code> <code class="n">ms</code> <code class="err">±</code> <code class="mi">288</code> <code class="n">µs</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">100</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="o">%</code><code class="k">timeit</code> np.arange(1E6, dtype=object).sum()
<code class="n">Out</code><code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="mf">92.1</code> <code class="n">ms</code> <code class="err">±</code> <code class="mf">3.42</code> <code class="n">ms</code> <code class="n">per</code> <code class="n">loop</code> <code class="p">(</code><code class="n">mean</code> <code class="err">±</code> <code class="n">std</code><code class="o">.</code> <code class="n">dev</code><code class="o">.</code> <code class="n">of</code> <code class="mi">7</code> <code class="n">runs</code><code class="p">,</code> <code class="mi">10</code> <code class="n">loops</code> <code class="n">each</code><code class="p">)</code></pre>
<p>Further, because Python does not support arithmetic operations with
<code>None</code>, aggregations like <code>sum</code> or <code>min</code> will generally lead to an
error:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">vals1</code><code class="o">.</code><code class="n">sum</code><code class="p">()</code>
<code class="ne">TypeError</code><code class="p">:</code> <code class="n">unsupported</code> <code class="n">operand</code> <code class="nb">type</code><code class="p">(</code><code class="n">s</code><code class="p">)</code> <code class="k">for</code> <code class="o">+</code><code class="p">:</code> <code class="s1">'int'</code> <code class="ow">and</code> <code class="s1">'NoneType'</code></pre>
<p>For this reason, Pandas does not use <code>None</code> as a sentinel in its
numerical arrays.</p>
</div></section>
<section data-pdf-bookmark="NaN: Missing Numerical Data" data-type="sect2"><div class="sect2" id="ch_0304-missing-values_nan-missing-numerical-data">
<h2>NaN: Missing Numerical Data</h2>
<p><a data-primary="missing data" data-secondary="NaN" data-type="indexterm" id="idm45858786225680"/><a data-primary="NaN (Not a Number) value" data-type="indexterm" id="idm45858786224704"/>The other missing data sentinel, <code>NaN</code> is different; it is a special
floating-point value recognized by all systems that use the standard
IEEE floating-point representation:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">vals2</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">])</code>
        <code class="n">vals2</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="mf">1.</code><code class="p">,</code> <code class="n">nan</code><code class="p">,</code>  <code class="mf">3.</code><code class="p">,</code>  <code class="mf">4.</code><code class="p">])</code></pre>
<p>Notice that NumPy chose a native floating-point type for this array:
this means that unlike the object array from before, this array supports
fast operations pushed into compiled code. Keep in mind that <code>NaN</code> is a
bit like a data virus—it infects any other object it touches.</p>
<p class="pagebreak-before less_space">Regardless
of the operation, the result of arithmetic with <code>NaN</code> will be another
<code>NaN</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="mi">1</code> <code class="o">+</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">nan</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="mi">0</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">nan</code></pre>
<p>This means that aggregates over the values are well defined (i.e., they
don’t result in an error) but not always useful:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">vals2</code><code class="o">.</code><code class="n">sum</code><code class="p">(),</code> <code class="n">vals2</code><code class="o">.</code><code class="n">min</code><code class="p">(),</code> <code class="n">vals2</code><code class="o">.</code><code class="n">max</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="p">(</code><code class="n">nan</code><code class="p">,</code> <code class="n">nan</code><code class="p">,</code> <code class="n">nan</code><code class="p">)</code></pre>
<p>That said, NumPy does provide <code>NaN</code>-aware versions of aggregations that
will ignore these missing values:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">nansum</code><code class="p">(</code><code class="n">vals2</code><code class="p">),</code> <code class="n">np</code><code class="o">.</code><code class="n">nanmin</code><code class="p">(</code><code class="n">vals2</code><code class="p">),</code> <code class="n">np</code><code class="o">.</code><code class="n">nanmax</code><code class="p">(</code><code class="n">vals2</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="p">(</code><code class="mf">8.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">,</code> <code class="mf">4.0</code><code class="p">)</code></pre>
<p>The main downside of <code>NaN</code> is that it is specifically a floating-point
value; there is no equivalent <code>NaN</code> value for integers, strings, or
other types.</p>
</div></section>
<section data-pdf-bookmark="NaN and None in Pandas" data-type="sect2"><div class="sect2" id="ch_0304-missing-values_nan-and-none-in-pandas">
<h2>NaN and None in Pandas</h2>
<p><a data-primary="Pandas" data-secondary="NaN and None in" data-type="indexterm" id="idm45858785953904"/><code>NaN</code> and <code>None</code> both have their place, and Pandas is built to handle
the two of them nearly interchangeably, converting between them where
appropriate:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="kc">None</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">11</code><code class="p">]:</code> <code class="mi">0</code>    <code class="mf">1.0</code>
         <code class="mi">1</code>    <code class="n">NaN</code>
         <code class="mi">2</code>    <code class="mf">2.0</code>
         <code class="mi">3</code>    <code class="n">NaN</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>For types that don’t have an available sentinel value,
Pandas automatically typecasts when NA values are present. For example,
if we set a value in an integer array to <code>np.nan</code>, it will automatically
be upcast to a floating-point type to accommodate the NA:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code> <code class="n">dtype</code><code class="o">=</code><code class="nb">int</code><code class="p">)</code>
         <code class="n">x</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">12</code><code class="p">]:</code> <code class="mi">0</code>    <code class="mi">0</code>
         <code class="mi">1</code>    <code class="mi">1</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="n">x</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="kc">None</code>
         <code class="n">x</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">13</code><code class="p">]:</code> <code class="mi">0</code>    <code class="n">NaN</code>
         <code class="mi">1</code>    <code class="mf">1.0</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">float64</code></pre>
<p>Notice that in addition to casting the integer array to floating point,
Pandas automatically converts the <code>None</code> to a <code>NaN</code> value.</p>
<p>While this type of magic may feel a bit hackish compared to the more
unified approach to NA values in domain-specific languages like R, the
Pandas sentinel/casting approach works quite well in practice and in my
experience only rarely causes issues.</p>
<p><a data-type="xref" href="#table-16-1">Table 16-1</a> lists the upcasting conventions in Pandas when NA
values are introduced.</p>
<table id="table-16-1">
<caption><span class="label">Table 16-1. </span>Pandas handling of NAs by type</caption>
<thead>
<tr>
<th>Typeclass</th>
<th>Conversion when storing NAs</th>
<th>NA sentinel value</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>floating</code></p></td>
<td><p>No change</p></td>
<td><p><code>np.nan</code></p></td>
</tr>
<tr>
<td><p><code>object</code></p></td>
<td><p>No change</p></td>
<td><p><code>None</code> or <code>np.nan</code></p></td>
</tr>
<tr>
<td><p><code>integer</code></p></td>
<td><p>Cast to <code>float64</code></p></td>
<td><p><code>np.nan</code></p></td>
</tr>
<tr>
<td><p><code>boolean</code></p></td>
<td><p>Cast to <code>object</code></p></td>
<td><p><code>None</code> or <code>np.nan</code></p></td>
</tr>
</tbody>
</table>
<p>Keep in mind that in Pandas, string data is always stored with an
<code>object</code> dtype.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Pandas Nullable Dtypes" data-type="sect1"><div class="sect1" id="ch_0304-missing-values_pandas-nullable-dtypes">
<h1>Pandas Nullable Dtypes</h1>
<p><a data-primary="nullable dtypes" data-type="indexterm" id="idm45858785761056"/><a data-primary="Pandas" data-secondary="nullable dtypes" data-type="indexterm" id="idm45858785760352"/>In early versions of Pandas, <code>NaN</code> and <code>None</code> as sentinel values were
the only missing data representations available. The primary difficulty
this introduced was with regard to the implicit type casting: for
example, there was no way to represent a true integer array with missing
data.</p>
<p>To address this difficulty, Pandas later added <em>nullable dtypes</em>, which
are distinguished from regular dtypes by capitalization of their names
(e.g., <code>pd.Int32</code> versus <code>np.int32</code>). For backward compatibility, these
nullable dtypes are only used if specifically 
<span class="keep-together">requested</span>.</p>
<p>For example, here is a <code>Series</code> of integers with missing data, created
from a list containing all three available markers of missing data:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="kc">None</code><code class="p">,</code> <code class="n">pd</code><code class="o">.</code><code class="n">NA</code><code class="p">],</code> <code class="n">dtype</code><code class="o">=</code><code class="s1">'Int32'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">14</code><code class="p">]:</code> <code class="mi">0</code>       <code class="mi">1</code>
         <code class="mi">1</code>    <code class="o">&lt;</code><code class="n">NA</code><code class="o">&gt;</code>
         <code class="mi">2</code>       <code class="mi">2</code>
         <code class="mi">3</code>    <code class="o">&lt;</code><code class="n">NA</code><code class="o">&gt;</code>
         <code class="mi">4</code>    <code class="o">&lt;</code><code class="n">NA</code><code class="o">&gt;</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">Int32</code></pre>
<p>This representation can be used interchangeably with the others in all
the operations explored through the rest of this chapter.</p>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Operating on Null Values" data-type="sect1"><div class="sect1" id="ch_0304-missing-values_operating-on-null-values">
<h1>Operating on Null Values</h1>
<p><a data-primary="missing data" data-secondary="operating on null values in Pandas" data-type="indexterm" id="ix_ch16-asciidoc2"/><a data-primary="null values" data-type="indexterm" id="ix_ch16-asciidoc3"/><a data-primary="Pandas" data-secondary="null values" data-type="indexterm" id="ix_ch16-asciidoc4"/>As we have seen, Pandas treats <code>None</code>, <code>NaN</code>, and <code>NA</code> as essentially
interchangeable for indicating missing or null values. To facilitate
this convention, Pandas provides several methods for detecting,
removing, and replacing null values in Pandas data structures. <a data-primary="isnull() method" data-type="indexterm" id="idm45858785671504"/><a data-primary="notnull() method" data-type="indexterm" id="idm45858785664256"/>They are:</p>
<dl>
<dt><code>isnull</code></dt>
<dd>
<p>Generates a Boolean mask indicating missing values</p>
</dd>
<dt><code>notnull</code></dt>
<dd>
<p>Opposite of <code>isnull</code></p>
</dd>
<dt><code>dropna</code></dt>
<dd>
<p>Returns a filtered version of the data</p>
</dd>
<dt><code>fillna</code></dt>
<dd>
<p>Returns a copy of the data with missing values filled or
imputed</p>
</dd>
</dl>
<p>We will conclude this chapter with a brief exploration and demonstration
of these routines.</p>
<section data-pdf-bookmark="Detecting Null Values" data-type="sect2"><div class="sect2" id="ch_0304-missing-values_detecting-null-values">
<h2>Detecting Null Values</h2>
<p><a data-primary="null values" data-secondary="detecting" data-type="indexterm" id="idm45858785655072"/>Pandas data structures have two useful methods for detecting null data:
<code>isnull</code> and <code>notnull</code>. Either one will return a Boolean mask over the
data. For example:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">15</code><code class="p">]:</code> <code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code> <code class="s1">'hello'</code><code class="p">,</code> <code class="kc">None</code><code class="p">])</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">isnull</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">16</code><code class="p">]:</code> <code class="mi">0</code>    <code class="kc">False</code>
         <code class="mi">1</code>     <code class="kc">True</code>
         <code class="mi">2</code>    <code class="kc">False</code>
         <code class="mi">3</code>     <code class="kc">True</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">bool</code></pre>
<p>As mentioned in <a data-type="xref" href="ch14.xhtml#section-0302-data-indexing-and-selection">Chapter 14</a>, Boolean masks can be used directly as a
<code>Series</code> or 
<span class="keep-together"><code>DataFrame</code></span> index:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="n">data</code><code class="p">[</code><code class="n">data</code><code class="o">.</code><code class="n">notnull</code><code class="p">()]</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">17</code><code class="p">]:</code> <code class="mi">0</code>        <code class="mi">1</code>
         <code class="mi">2</code>    <code class="n">hello</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>The <code>isnull()</code> and <code>notnull()</code> methods produce similar Boolean results
for 
<span class="keep-together"><code>DataFrame</code></span> objects.</p>
</div></section>
<section data-pdf-bookmark="Dropping Null Values" data-type="sect2"><div class="sect2" id="ch_0304-missing-values_dropping-null-values">
<h2>Dropping Null Values</h2>
<p><a data-primary="dropna() method" data-type="indexterm" id="idm45858785521776"/><a data-primary="fillna() method" data-type="indexterm" id="idm45858785520848"/>In <a data-primary="null values" data-secondary="dropping" data-type="indexterm" id="ix_ch16-asciidoc5"/>addition to these masking methods, there are the convenience methods
<code>dropna</code> (which removes NA values) and <code>fillna</code> (which fills in NA
values). For a <code>Series</code>, the result is straightforward:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">dropna</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">18</code><code class="p">]:</code> <code class="mi">0</code>        <code class="mi">1</code>
         <code class="mi">2</code>    <code class="n">hello</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="nb">object</code></pre>
<p>For a <code>DataFrame</code>, there are more options. Consider the following
<code>DataFrame</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">19</code><code class="p">]:</code> <code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code>      <code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code>
                            <code class="p">[</code><code class="mi">2</code><code class="p">,</code>      <code class="mi">3</code><code class="p">,</code>      <code class="mi">5</code><code class="p">],</code>
                            <code class="p">[</code><code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code>      <code class="mi">6</code><code class="p">]])</code>
         <code class="n">df</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">19</code><code class="p">]:</code>      <code class="mi">0</code>    <code class="mi">1</code>  <code class="mi">2</code>
         <code class="mi">0</code>  <code class="mf">1.0</code>  <code class="n">NaN</code>  <code class="mi">2</code>
         <code class="mi">1</code>  <code class="mf">2.0</code>  <code class="mf">3.0</code>  <code class="mi">5</code>
         <code class="mi">2</code>  <code class="n">NaN</code>  <code class="mf">4.0</code>  <code class="mi">6</code></pre>
<p>We cannot drop single values from a <code>DataFrame</code>; we can only drop entire
rows or columns. Depending on the application, you might want one or the
other, so <code>dropna</code> includes a number of options for a <code>DataFrame</code>.</p>
<p>By default, <code>dropna</code> will drop all rows in which <em>any</em> null value is
present:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">20</code><code class="p">]:</code> <code class="n">df</code><code class="o">.</code><code class="n">dropna</code><code class="p">()</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">20</code><code class="p">]:</code>      <code class="mi">0</code>    <code class="mi">1</code>  <code class="mi">2</code>
         <code class="mi">1</code>  <code class="mf">2.0</code>  <code class="mf">3.0</code>  <code class="mi">5</code></pre>
<p>Alternatively, you can drop NA values along a different axis. Using
<code>axis=1</code> or 
<span class="keep-together"><code>axis='columns'</code></span> drops all columns
containing a null value:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">21</code><code class="p">]:</code> <code class="n">df</code><code class="o">.</code><code class="n">dropna</code><code class="p">(</code><code class="n">axis</code><code class="o">=</code><code class="s1">'columns'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">21</code><code class="p">]:</code>    <code class="mi">2</code>
         <code class="mi">0</code>  <code class="mi">2</code>
         <code class="mi">1</code>  <code class="mi">5</code>
         <code class="mi">2</code>  <code class="mi">6</code></pre>
<p>But this drops some good data as well; you might rather be interested in
dropping rows or columns with <em>all</em> NA values, or a majority of NA
values. This can be specified through the <code>how</code> or <code>thresh</code> parameters,
which allow fine control of the number of nulls to allow through.</p>
<p class="pagebreak-before less_space">The default is <code>how='any'</code>, such that any row or
column containing a null value will be dropped. You can also specify
<code>how='all'</code>, which will only drop rows/columns
that contain <em>all</em> null values:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">22</code><code class="p">]:</code> <code class="n">df</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code>
         <code class="n">df</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">22</code><code class="p">]:</code>      <code class="mi">0</code>    <code class="mi">1</code>  <code class="mi">2</code>   <code class="mi">3</code>
         <code class="mi">0</code>  <code class="mf">1.0</code>  <code class="n">NaN</code>  <code class="mi">2</code> <code class="n">NaN</code>
         <code class="mi">1</code>  <code class="mf">2.0</code>  <code class="mf">3.0</code>  <code class="mi">5</code> <code class="n">NaN</code>
         <code class="mi">2</code>  <code class="n">NaN</code>  <code class="mf">4.0</code>  <code class="mi">6</code> <code class="n">NaN</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">23</code><code class="p">]:</code> <code class="n">df</code><code class="o">.</code><code class="n">dropna</code><code class="p">(</code><code class="n">axis</code><code class="o">=</code><code class="s1">'columns'</code><code class="p">,</code> <code class="n">how</code><code class="o">=</code><code class="s1">'all'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">23</code><code class="p">]:</code>      <code class="mi">0</code>    <code class="mi">1</code>  <code class="mi">2</code>
         <code class="mi">0</code>  <code class="mf">1.0</code>  <code class="n">NaN</code>  <code class="mi">2</code>
         <code class="mi">1</code>  <code class="mf">2.0</code>  <code class="mf">3.0</code>  <code class="mi">5</code>
         <code class="mi">2</code>  <code class="n">NaN</code>  <code class="mf">4.0</code>  <code class="mi">6</code></pre>
<p>For finer-grained control, the <code>thresh</code> parameter lets you specify a
minimum number of non-null values for the row/column to be kept:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">24</code><code class="p">]:</code> <code class="n">df</code><code class="o">.</code><code class="n">dropna</code><code class="p">(</code><code class="n">axis</code><code class="o">=</code><code class="s1">'rows'</code><code class="p">,</code> <code class="n">thresh</code><code class="o">=</code><code class="mi">3</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">24</code><code class="p">]:</code>      <code class="mi">0</code>    <code class="mi">1</code>  <code class="mi">2</code>   <code class="mi">3</code>
         <code class="mi">1</code>  <code class="mf">2.0</code>  <code class="mf">3.0</code>  <code class="mi">5</code> <code class="n">NaN</code></pre>
<p>Here, the first and last rows have been dropped because they each
contain only two non-null values.<a data-startref="ix_ch16-asciidoc5" data-type="indexterm" id="idm45858785114192"/></p>
</div></section>
<section data-pdf-bookmark="Filling Null Values" data-type="sect2"><div class="sect2" id="ch_0304-missing-values_filling-null-values">
<h2>Filling Null Values</h2>
<p><a data-primary="null values" data-secondary="filling" data-type="indexterm" id="idm45858785104960"/>Sometimes rather than dropping NA values, you’d like to
replace them with a valid value. This value might be a single number
like zero, or it might be some sort of imputation or interpolation from
the good values. You could do this in-place using the <code>isnull</code> method as
a mask, <a data-primary="fillna() method" data-type="indexterm" id="idm45858785103472"/>but because it is such a common operation Pandas provides the
<code>fillna</code> method, which returns a copy of the array with the null values
replaced.</p>
<p>Consider the following <code>Series</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="n">data</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">Series</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="n">np</code><code class="o">.</code><code class="n">nan</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="kc">None</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="n">index</code><code class="o">=</code><code class="nb">list</code><code class="p">(</code><code class="s1">'abcde'</code><code class="p">),</code>
                           <code class="n">dtype</code><code class="o">=</code><code class="s1">'Int32'</code><code class="p">)</code>
         <code class="n">data</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">25</code><code class="p">]:</code> <code class="n">a</code>       <code class="mi">1</code>
         <code class="n">b</code>    <code class="o">&lt;</code><code class="n">NA</code><code class="o">&gt;</code>
         <code class="n">c</code>       <code class="mi">2</code>
         <code class="n">d</code>    <code class="o">&lt;</code><code class="n">NA</code><code class="o">&gt;</code>
         <code class="n">e</code>       <code class="mi">3</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">Int32</code></pre>
<p class="pagebreak-before less_space">We can fill NA entries with a single value, such as zero:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">data</code><code class="o">.</code><code class="n">fillna</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">26</code><code class="p">]:</code> <code class="n">a</code>    <code class="mi">1</code>
         <code class="n">b</code>    <code class="mi">0</code>
         <code class="n">c</code>    <code class="mi">2</code>
         <code class="n">d</code>    <code class="mi">0</code>
         <code class="n">e</code>    <code class="mi">3</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">Int32</code></pre>
<p>We can specify a forward fill to propagate the previous value forward:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="c1"># forward fill</code>
         <code class="n">data</code><code class="o">.</code><code class="n">fillna</code><code class="p">(</code><code class="n">method</code><code class="o">=</code><code class="s1">'ffill'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">27</code><code class="p">]:</code> <code class="n">a</code>    <code class="mi">1</code>
         <code class="n">b</code>    <code class="mi">1</code>
         <code class="n">c</code>    <code class="mi">2</code>
         <code class="n">d</code>    <code class="mi">2</code>
         <code class="n">e</code>    <code class="mi">3</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">Int32</code></pre>
<p>Or we can specify a backward fill to propagate the next values backward:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="c1"># back fill</code>
         <code class="n">data</code><code class="o">.</code><code class="n">fillna</code><code class="p">(</code><code class="n">method</code><code class="o">=</code><code class="s1">'bfill'</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">28</code><code class="p">]:</code> <code class="n">a</code>    <code class="mi">1</code>
         <code class="n">b</code>    <code class="mi">2</code>
         <code class="n">c</code>    <code class="mi">2</code>
         <code class="n">d</code>    <code class="mi">3</code>
         <code class="n">e</code>    <code class="mi">3</code>
         <code class="n">dtype</code><code class="p">:</code> <code class="n">Int32</code></pre>
<p>In the case of a <code>DataFrame</code>, the options are similar, but we can also
specify an <code>axis</code> along which the fills should take place:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">29</code><code class="p">]:</code> <code class="n">df</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">29</code><code class="p">]:</code>      <code class="mi">0</code>    <code class="mi">1</code>  <code class="mi">2</code>   <code class="mi">3</code>
         <code class="mi">0</code>  <code class="mf">1.0</code>  <code class="n">NaN</code>  <code class="mi">2</code> <code class="n">NaN</code>
         <code class="mi">1</code>  <code class="mf">2.0</code>  <code class="mf">3.0</code>  <code class="mi">5</code> <code class="n">NaN</code>
         <code class="mi">2</code>  <code class="n">NaN</code>  <code class="mf">4.0</code>  <code class="mi">6</code> <code class="n">NaN</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">30</code><code class="p">]:</code> <code class="n">df</code><code class="o">.</code><code class="n">fillna</code><code class="p">(</code><code class="n">method</code><code class="o">=</code><code class="s1">'ffill'</code><code class="p">,</code> <code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">30</code><code class="p">]:</code>      <code class="mi">0</code>    <code class="mi">1</code>    <code class="mi">2</code>    <code class="mi">3</code>
         <code class="mi">0</code>  <code class="mf">1.0</code>  <code class="mf">1.0</code>  <code class="mf">2.0</code>  <code class="mf">2.0</code>
         <code class="mi">1</code>  <code class="mf">2.0</code>  <code class="mf">3.0</code>  <code class="mf">5.0</code>  <code class="mf">5.0</code>
         <code class="mi">2</code>  <code class="n">NaN</code>  <code class="mf">4.0</code>  <code class="mf">6.0</code>  <code class="mf">6.0</code></pre>
<p>Notice that if a previous value is not available during a forward fill,
the NA value remains<a data-startref="ix_ch16-asciidoc4" data-type="indexterm" id="idm45858784746912"/><a data-startref="ix_ch16-asciidoc3" data-type="indexterm" id="idm45858784682960"/><a data-startref="ix_ch16-asciidoc2" data-type="indexterm" id="idm45858784682352"/>.<a data-startref="ix_ch16-asciidoc1" data-type="indexterm" id="idm45858784681584"/><a data-startref="ix_ch16-asciidoc0" data-type="indexterm" id="idm45858784680880"/></p>
</div></section>
</div></section>
</div></section></div></body></html>