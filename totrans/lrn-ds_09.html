<html><head></head><body><section data-pdf-bookmark="Chapter 7. Working with Relations Using SQL" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch-sql">&#13;
<h1><span class="label">Chapter 7. </span>Working with Relations Using SQL</h1>&#13;
&#13;
<p>In <a class="reference internal" data-type="xref" href="ch06.html#ch-pandas">Chapter 6</a>, we used dataframes<a contenteditable="false" data-primary="SQL (structured query language)" data-type="indexterm" id="ix_sql_ch7"/><a contenteditable="false" data-primary="relations" data-type="indexterm" id="ix_relations_ch7"/> to represent tables of data. This chapter introduces <em>relations</em>, another widely used way to represent data tables. We also introduce SQL, the standard programming language for working with relations. Here’s an example of a relation that holds information about popular dog breeds.</p>&#13;
&#13;
<p>Like dataframes, each row in a relation represents a single record—in this case, a single dog breed. Each column represents a feature about the record—for example, the <code>grooming</code> column represents how often each dog breed needs to be groomed.</p>&#13;
&#13;
<p>Both relations and dataframes have labels for each column in the table. However, one key difference is that the rows in a relation don’t have labels, while rows in a dataframe do.</p>&#13;
&#13;
<p>In this chapter, we demonstrate common relation operations using SQL. We start by explaining the structure of SQL queries. Then we show how to use SQL to perform common data manipulation tasks, like slicing, filtering, sorting, grouping, and <span class="keep-together">joining</span>.</p>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This chapter replicates the data analyses in <a class="reference internal" data-type="xref" href="ch06.html#ch-pandas">Chapter 6</a> using relations and SQL instead of dataframes and Python. The datasets, data manipulations, and conclusions are nearly identical across the two chapters for ease of comparison between performing data manipulations in <code>pandas</code> and SQL.</p>&#13;
</div>&#13;
&#13;
&#13;
<section data-pdf-bookmark="Subsetting" data-type="sect1"><div class="sect1" id="sec-sql-subsetting">&#13;
<h1>Subsetting</h1>&#13;
&#13;
<p>To work<a contenteditable="false" data-primary="subsetting, dataframes" data-secondary="SQL and relations" data-type="indexterm" id="ix_subset_df"/><a contenteditable="false" data-primary="SQL (structured query language)" data-secondary="subsetting" data-type="indexterm" id="ix_sql_subset_ch7"/><a contenteditable="false" data-primary="relations" data-secondary="subsetting" data-type="indexterm" id="ix_rel_subset_ch7"/><a contenteditable="false" data-primary="dataframes" data-secondary="subsetting" data-type="indexterm" id="ix_df_subset_ch7"/> with relations, we’ll introduce a domain-specific programming language called <em>SQL</em> (Structured Query Language). We commonly pronounce “SQL” like “sequel” instead of spelling out the acronym. SQL<a contenteditable="false" data-primary="Python" data-secondary="and SQL" data-secondary-sortas="SQL" data-type="indexterm" id="id925"/> is a specialized language for <span class="keep-together">working</span> with relations—as such, SQL has a different syntax than Python for writing programs that operate on relational data.</p>&#13;
&#13;
<p>In this chapter<a contenteditable="false" data-primary="SQL (structured query language)" data-secondary="and pandas" data-secondary-sortas="pandas" data-type="indexterm" id="id926"/>, we’ll use SQL queries within Python programs. This illustrates a common workflow—data scientists often process and subset data in SQL before loading the data into Python for further analysis. SQL databases make it easier to work with large amounts of data compared to <code>pandas</code> programs. However, loading data into <code>pandas</code> makes it easier to visualize the data and build statistical models.</p>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Why do SQL systems<a contenteditable="false" data-primary="pandas library" data-secondary="versus SQL" data-secondary-sortas="SQL" data-type="indexterm" id="id927"/> tend to work better with larger datasets? In short, SQL systems have sophisticated algorithms for managing data stored on disk. For example, when working with a large dataset, SQL systems will transparently load and manipulate small portions of data at a time; doing this in <code>pandas</code> can be quite difficult in comparison. We cover this topic in more detail in <a class="reference internal" data-type="xref" href="ch08.html#ch-files">Chapter 8</a>.</p>&#13;
</div>&#13;
&#13;
<section data-pdf-bookmark="SQL Basics: SELECT and FROM" data-type="sect2"><div class="sect2" id="sql-basics-select-and-from">&#13;
<h2>SQL Basics: SELECT and FROM</h2>&#13;
&#13;
<p>We’ll use the <code>pd.read_sql</code> function<a contenteditable="false" data-primary="sqlalchemy package" data-type="indexterm" id="id928"/><a contenteditable="false" data-primary="read_sql function" data-type="indexterm" id="id929"/>, which runs a SQL query and stores the output in a <code>pandas</code> dataframe. Using this function requires some setup. We start by importing the <code>pandas</code> and <code>sqlalchemy</code> Python packages:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="kn">import</code></span><code> </code><span><code class="nn">pandas</code></span><code> </code><span><code class="k">as</code></span><code> </code><span><code class="nn">pd</code></span><code>&#13;
</code><span><code class="kn">import</code></span><code> </code><span><code class="nn">sqlalchemy</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Our database is stored in a file called <em>babynames.db</em>. This file is a <a class="reference external" href="https://oreil.ly/sGYWE">SQLite</a> database, so we’ll set up a <code>sqlalchemy</code> object that can process this format:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">db</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">sqlalchemy</code></span><span><code class="o">.</code></span><span><code class="n">create_engine</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">sqlite:///babynames.db</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In this book<a contenteditable="false" data-primary="SQLite" data-type="indexterm" id="id930"/><a contenteditable="false" data-primary="PostgreSQL" data-type="indexterm" id="id931"/><a contenteditable="false" data-primary="MySQL" data-type="indexterm" id="id932"/>, we use SQLite, an extremely useful database system for working with data stored locally. Other systems make different trade-offs that are useful for different domains. For instance, PostgreSQL and MySQL are more complex systems that are useful for large web applications where many end users are writing data at the same time. Although each SQL system has slight differences, they provide the same core SQL functionality. Readers may also be aware that Python provides SQLite support in its standard <code>sqlite3</code> library. We choose to use <code>sqlalchemy</code> because it’s easier to reuse the code for other SQL systems beyond SQLite.</p>&#13;
</div>&#13;
&#13;
<p>Now we can use <code>pd.read_sql</code> to run SQL queries on this database. This database has two relations: <code>baby</code> and <code>nyt</code>. Here’s a simple example that reads in the entire <code>baby</code> relation. We write a SQL query as a Python string and pass it into <code>pd.read_sql</code>:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>M</td>&#13;
			<td>19659</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>M</td>&#13;
			<td>18252</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
			<td>M</td>&#13;
			<td>14147</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2020719</strong></td>&#13;
			<td>Verona</td>&#13;
			<td>F</td>&#13;
			<td>5</td>&#13;
			<td>1880</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2020720</strong></td>&#13;
			<td>Vertie</td>&#13;
			<td>F</td>&#13;
			<td>5</td>&#13;
			<td>1880</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2020721</strong></td>&#13;
			<td>Wilma</td>&#13;
			<td>F</td>&#13;
			<td>5</td>&#13;
			<td>1880</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>2020722 rows × 4 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>The text inside the <code>query</code> variable contains SQL code. <code>SELECT</code> and <code>FROM</code> are SQL keywords. We read the preceding query like this:</p>&#13;
&#13;
<div class="highlight-sql notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
<span>SELECT</span><span> </span><span>*</span><span>    </span><span>-- Get all the columns...</span>&#13;
<span>FROM</span><span> </span><span>baby</span><span>;</span><span>  </span><span>-- ...from the baby relation</span>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>The <code>baby</code> relation contains the same data as the <code>baby</code> dataframe in <a class="reference internal" data-type="xref" href="ch06.html#ch-pandas">Chapter 6</a>: the names of all babies registered by the US Social Security Administration.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="What’s a Relation?" data-type="sect2"><div class="sect2" id="whats-a-relation">&#13;
<h2>What’s a Relation?</h2>&#13;
&#13;
<p>Let’s examine the <code>baby</code> relation in more detail. A relation has rows and columns. Every column has a label, as illustrated in <a class="reference internal" data-type="xref" href="#fig-relation-labels">Figure 7-1</a>. Unlike dataframes, however, individual rows in a relation don’t have labels. Also unlike dataframes, rows of a relation aren’t ordered.</p>&#13;
&#13;
<figure><div class="figure" id="fig-relation-labels"><img alt="relation-labels" src="assets/leds_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>The <code>baby</code> relation has labels for columns (boxed)</h6>&#13;
</div></figure>&#13;
&#13;
<p>Relations have a long history. More formal<a contenteditable="false" data-primary="tuples, relations" data-type="indexterm" id="id933"/>  treatments of relations use the term <em>tuple</em> to refer to the rows of a relation, and <em>attribute</em> to refer to the columns. There is also a rigorous way to define data operations using relational algebra, which is derived from mathematical set algebra.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Slicing" data-type="sect2"><div class="sect2" id="slicing_82468291">&#13;
<h2>Slicing</h2>&#13;
&#13;
<p><em>Slicing</em> is an operation<a contenteditable="false" data-primary="slicing" data-secondary="relations" data-type="indexterm" id="ix_slice_rel"/><a contenteditable="false" data-primary="SELECT statement, relations filters" data-type="indexterm" id="id934"/> that creates a new relation by taking a subset of rows or columns out of another relation. Think about slicing a tomato—slices can go both vertically and horizontally. To slice columns of a relation, we give the <code>SELECT</code> statement the columns we want:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Name</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code> </code><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2020719</strong></td>&#13;
			<td>Verona</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2020720</strong></td>&#13;
			<td>Vertie</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2020721</strong></td>&#13;
			<td>Wilma</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>2020722 rows × 1 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Name, Count</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code> </code><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Count</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>19659</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>18252</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
			<td>14147</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2020719</strong></td>&#13;
			<td>Verona</td>&#13;
			<td>5</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2020720</strong></td>&#13;
			<td>Vertie</td>&#13;
			<td>5</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2020721</strong></td>&#13;
			<td>Wilma</td>&#13;
			<td>5</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>2020722 rows × 2 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>To slice<a contenteditable="false" data-primary="LIMIT keyword, relations filters" data-type="indexterm" id="id935"/> out a specific number of rows, use the <code>LIMIT</code> keyword:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Name</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">LIMIT 10;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code> </code><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>7</strong></td>&#13;
			<td>Lucas</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>8</strong></td>&#13;
			<td>Henry</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>9</strong></td>&#13;
			<td>Alexander</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>10 rows × 1 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>In sum, we use the <code>SELECT</code> and <code>LIMIT</code> keywords to slice columns and rows of a <span class="keep-together">relation</span><a contenteditable="false" data-primary="" data-startref="ix_slice_rel" data-type="indexterm" id="id936"/>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Filtering Rows" data-type="sect2"><div class="sect2" id="filtering-rows_70859536">&#13;
<h2>Filtering Rows</h2>&#13;
&#13;
<p>Now we turn<a contenteditable="false" data-primary="WHERE keyword, relations filters" data-type="indexterm" id="ix_where_key"/><a contenteditable="false" data-primary="filtering data" data-secondary="relations" data-type="indexterm" id="ix_filter_rel"/><a contenteditable="false" data-primary="dataframes" data-secondary="slicing" data-type="indexterm" id="id937"/><a contenteditable="false" data-primary="boolean conditions" data-secondary="slicing dataframe rows to filter" data-type="indexterm" id="id938"/><a contenteditable="false" data-primary="slicing" data-secondary="dataframes" data-type="indexterm" id="id939"/> to <em>filtering</em> rows—taking subsets of rows using one or more criteria. In <code>pandas</code>, we slice dataframes using Boolean series objects. In SQL, we instead use the <code>WHERE</code> keyword with a predicate. The following query filters the <code>baby</code> relation to have only the baby names in 2020:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">WHERE Year = 2020;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>M</td>&#13;
			<td>19659</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>M</td>&#13;
			<td>18252</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
			<td>M</td>&#13;
			<td>14147</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>31267</strong></td>&#13;
			<td>Zylynn</td>&#13;
			<td>F</td>&#13;
			<td>5</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>31268</strong></td>&#13;
			<td>Zynique</td>&#13;
			<td>F</td>&#13;
			<td>5</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>31269</strong></td>&#13;
			<td>Zynlee</td>&#13;
			<td>F</td>&#13;
			<td>5</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>31270 rows × 4 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Note<a contenteditable="false" data-primary="double equals (==), for Python equality" data-type="indexterm" id="id940"/><a contenteditable="false" data-primary="== (double equals), for Python equality" data-type="indexterm" id="id941"/><a contenteditable="false" data-primary="equals (=), SQL versus Python" data-type="indexterm" id="id942"/><a contenteditable="false" data-primary="= (equals), SQL versus Python" data-type="indexterm" id="id943"/> that when comparing for equality, SQL uses a single equals sign:</p>&#13;
&#13;
<div class="highlight-sql notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
<span>SELECT</span><span> </span><span>*</span>&#13;
<span>FROM</span><span> </span><span>baby</span>&#13;
<span>WHERE</span><span> </span><span>Year</span><span> </span><span>=</span><span> </span><span>2020</span><span>;</span>&#13;
<span>--         ↑</span>&#13;
<span>--         Single equals sign</span>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>In Python, however, single equals signs are used for variable assignment. The statement <code>Year <span class="pre">=</span> <span class="pre">2020</span></code> will assign the value <code>2020</code> to the variable <code>Year</code>. To compare for equality, Python code uses double equals signs:</p>&#13;
&#13;
<div class="highlight-python notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="c1"># Assignment</code></span><code>&#13;
</code><span><code class="n">my_year</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="mi">2021</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="c1"># Comparison, which evaluates to False</code></span><code>&#13;
</code><span><code class="n">my_year</code></span><code> </code><span><code class="o">==</code></span><code> </code><span><code class="mi">2020</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>To add more predicates<a contenteditable="false" data-primary="AND keyword, relations filters" data-type="indexterm" id="id944"/><a contenteditable="false" data-primary="OR keyword, relations filters" data-type="indexterm" id="id945"/> to the filter, use the <code>AND</code> and <code>OR</code> keywords. For instance, to find the names that have more than 10,000 babies in either 2020 or 2019, we write:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">WHERE Count &gt; 10000</code></span><code class="s1">&#13;
</code><span><code class="s1">  AND (Year = 2020</code></span><code class="s1">&#13;
</code><span><code class="s1">       OR Year = 2019);</code></span><code class="s1">&#13;
</code><span><code class="s1">-- Notice that we use parentheses to enforce evaluation order</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>M</td>&#13;
			<td>19659</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>M</td>&#13;
			<td>18252</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
			<td>M</td>&#13;
			<td>14147</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>41</strong></td>&#13;
			<td>Mia</td>&#13;
			<td>F</td>&#13;
			<td>12452</td>&#13;
			<td>2019</td>&#13;
		</tr>&#13;
		<tr class="pagebreak-before less_space">&#13;
			<td><strong>42</strong></td>&#13;
			<td>Harper</td>&#13;
			<td>F</td>&#13;
			<td>10464</td>&#13;
			<td>2019</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>43</strong></td>&#13;
			<td>Evelyn</td>&#13;
			<td>F</td>&#13;
			<td>10412</td>&#13;
			<td>2019</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>44 rows × 4 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Finally<a contenteditable="false" data-primary="DESC option, relations filters" data-type="indexterm" id="id946"/><a contenteditable="false" data-primary="ORDER By keyword, relations filters" data-type="indexterm" id="id947"/>, to find the 10 most common names in 2020, we can sort the dataframe by <code>Count</code> in descending order using the <code>ORDER <span class="pre">BY</span></code> keyword with the <code>DESC</code> option (short for DESCending):</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">WHERE Year = 2020</code></span><code class="s1">&#13;
</code><span><code class="s1">ORDER BY Count DESC</code></span><code class="s1">&#13;
</code><span><code class="s1">LIMIT 10;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>M</td>&#13;
			<td>19659</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>M</td>&#13;
			<td>18252</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Emma</td>&#13;
			<td>F</td>&#13;
			<td>15581</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>7</strong></td>&#13;
			<td>Sophia</td>&#13;
			<td>F</td>&#13;
			<td>12976</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>8</strong></td>&#13;
			<td>Amelia</td>&#13;
			<td>F</td>&#13;
			<td>12704</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>9</strong></td>&#13;
			<td>William</td>&#13;
			<td>M</td>&#13;
			<td>12541</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>10 rows × 4 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>We see that Liam, Noah, and Emma were the most popular baby names in 2020<a contenteditable="false" data-primary="" data-startref="ix_filter_rel" data-type="indexterm" id="id948"/><a contenteditable="false" data-primary="" data-startref="ix_where_key" data-type="indexterm" id="id949"/>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Example: How Recently Has Luna Become a Popular Name?" data-type="sect2"><div class="sect2" id="example-how-recently-has-luna-become-a-popular-name_99897441">&#13;
<h2>Example: How Recently Has Luna Become a Popular Name?</h2>&#13;
&#13;
<p>As we mentioned<a contenteditable="false" data-primary="filtering data" data-secondary="and slicing" data-secondary-sortas="slicing" data-type="indexterm" id="id950"/><a contenteditable="false" data-primary="slicing" data-secondary="and filtering" data-secondary-sortas="filtering" data-type="indexterm" id="id951"/><a contenteditable="false" data-primary="slicing" data-secondary="relations" data-type="indexterm" id="id952"/> in <a data-type="xref" href="ch06.html#ch-pandas">Chapter 6</a>, a <em>New York Times</em> article mentions that the name Luna was almost nonexistent before 2000 but has since grown to become a very popular name for girls. When exactly did Luna become popular? We can check this in SQL using slicing and filtering:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">WHERE Name = </code><code class="s1">"</code><code class="s1">Luna</code><code class="s1">"</code></span><code class="s1">&#13;
</code><span><code class="s1">  AND Sex = </code><code class="s1">"</code><code class="s1">F</code><code class="s1">"</code><code class="s1">;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">luna</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code><span><code class="n">luna</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Luna</td>&#13;
			<td>F</td>&#13;
			<td>7770</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Luna</td>&#13;
			<td>F</td>&#13;
			<td>7772</td>&#13;
			<td>2019</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Luna</td>&#13;
			<td>F</td>&#13;
			<td>6929</td>&#13;
			<td>2018</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>125</strong></td>&#13;
			<td>Luna</td>&#13;
			<td>F</td>&#13;
			<td>17</td>&#13;
			<td>1883</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>126</strong></td>&#13;
			<td>Luna</td>&#13;
			<td>F</td>&#13;
			<td>18</td>&#13;
			<td>1881</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>127</strong></td>&#13;
			<td>Luna</td>&#13;
			<td>F</td>&#13;
			<td>15</td>&#13;
			<td>1880</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>128 rows × 4 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p><code>pd.read_sql</code> returns a <code>pandas.DataFrame</code> object, which we can use to make a plot. This illustrates a common workflow—process the data using SQL, load it into a <code>pandas</code> dataframe, then visualize the results:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">px</code></span><span><code class="o">.</code></span><span><code class="n">line</code></span><span><code class="p">(</code></span><span><code class="n">luna</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">x</code></span><span><code class="o">=</code></span><span><code class="s1">'</code><code class="s1">Year</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">y</code></span><span><code class="o">=</code></span><span><code class="s1">'</code><code class="s1">Count</code><code class="s1">'</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">width</code></span><span><code class="o">=</code></span><span><code class="mi">350</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">height</code></span><span><code class="o">=</code></span><span><code class="mi">250</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<figure class="informal width-60"><div class="figure"><img src="assets/leds_07in01.png"/>&#13;
&#13;
</div></figure>&#13;
&#13;
<p>In this section, we introduced the common ways that data scientists subset relations—slicing with column labels and filtering using a boolean condition. In the next section, we explain how to aggregate rows together<a contenteditable="false" data-primary="" data-startref="ix_subset_df" data-type="indexterm" id="id953"/><a contenteditable="false" data-primary="" data-startref="ix_sql_subset_ch7" data-type="indexterm" id="id954"/><a contenteditable="false" data-primary="" data-startref="ix_df_subset_ch7" data-type="indexterm" id="id955"/><a contenteditable="false" data-primary="" data-startref="ix_rel_subset_ch7" data-type="indexterm" id="id956"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Aggregating" data-type="sect1"><div class="sect1" id="sec-sql-aggregating">&#13;
<h1>Aggregating</h1>&#13;
&#13;
<p>This section<a contenteditable="false" data-primary="grouping in data tables" data-secondary="SQL" data-type="indexterm" id="ix_group_sql"/><a contenteditable="false" data-primary="SQL (structured query language)" data-secondary="aggregating" data-type="indexterm" id="ix_sql_agg"/><a contenteditable="false" data-primary="relations" data-secondary="aggregating" data-type="indexterm" id="ix_rel_agg_sql"/><a contenteditable="false" data-primary="aggregation" data-secondary="with SQL" data-secondary-sortas="SQL" data-type="indexterm" id="ix_agg_sql"/> introduces grouping and aggregating in SQL. We’ll work with the baby names data, as in the previous section:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="kn">import</code></span><code> </code><span><code class="nn">sqlalchemy</code></span><code>&#13;
</code><span><code class="n">db</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">sqlalchemy</code></span><span><code class="o">.</code></span><span><code class="n">create_engine</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">sqlite:///babynames.db</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">LIMIT 10</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>M</td>&#13;
			<td>19659</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>M</td>&#13;
			<td>18252</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
			<td>M</td>&#13;
			<td>14147</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>7</strong></td>&#13;
			<td>Lucas</td>&#13;
			<td>M</td>&#13;
			<td>11281</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>8</strong></td>&#13;
			<td>Henry</td>&#13;
			<td>M</td>&#13;
			<td>10705</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>9</strong></td>&#13;
			<td>Alexander</td>&#13;
			<td>M</td>&#13;
			<td>10151</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>10 rows × 4 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<section data-pdf-bookmark="Basic Group-Aggregate Using GROUP BY" data-type="sect2"><div class="sect2" id="basic-group-aggregate-using-group-by">&#13;
<h2>Basic Group-Aggregate Using GROUP BY</h2>&#13;
&#13;
<p>Let’s say we want<a contenteditable="false" data-primary="group-aggregate" data-type="indexterm" id="ix_grp_agg2"/><a contenteditable="false" data-primary="SELECT clause, SQL" data-type="indexterm" id="id957"/><a contenteditable="false" data-primary="aggregation" data-secondary="basic group-aggregate" data-type="indexterm" id="ix_agg_basic_grp"/> to find out the total number of babies born as recorded in this data. This is simply the sum<a contenteditable="false" data-primary="SUM function, SQL" data-type="indexterm" id="id958"/> of the <code>Count</code> column. SQL provides functions that we use in the <code>SELECT</code> statement, like <code>SUM</code>:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT SUM(Count)</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>SUM(Count)</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>352554503</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>In <a class="reference internal" data-type="xref" href="ch06.html#ch-pandas">Chapter 6</a>, we used grouping and aggregation to figure out whether US births are trending upward over time. We grouped the dataset by year using <code>.groupby()</code>, then summed the counts within each group using <code>.sum()</code>.</p>&#13;
&#13;
<p>In SQL, we instead group<a contenteditable="false" data-primary="Group By clause, SQL" data-type="indexterm" id="id959"/> using the <code>GROUP <span class="pre">BY</span></code> clause, then call aggregation functions in <code>SELECT</code>:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Year, SUM(Count)</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">GROUP BY Year</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Year</th>&#13;
			<th>SUM(Count)</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>1880</td>&#13;
			<td>194419</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>1881</td>&#13;
			<td>185772</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>1882</td>&#13;
			<td>213385</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>138</strong></td>&#13;
			<td>2018</td>&#13;
			<td>3487193</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>139</strong></td>&#13;
			<td>2019</td>&#13;
			<td>3437438</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>140</strong></td>&#13;
			<td>2020</td>&#13;
			<td>3287724</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>141 rows × 2 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>As with dataframe grouping, notice that the <code>Year</code> column contains the unique <code>Year</code> values—there are no duplicate <code>Year</code> values anymore since we grouped them together. When grouping in <code>pandas</code>, the grouping columns become the index of the resulting dataframe. However, relations don’t have row labels, so the <code>Year</code> values are just a column in the resulting relation.</p>&#13;
&#13;
<p>Here’s the basic recipe for grouping in <code>SQL</code>:</p>&#13;
&#13;
<div class="highlight-sql notranslate">&#13;
<div class="highlight">&#13;
<pre data-type="programlisting">&#13;
<span>SELECT</span>&#13;
<span>  </span><span>col1</span><span>,</span><span>           </span><span>-- column used for grouping</span>&#13;
<span>  </span><span>SUM</span><span>(</span><span>col2</span><span>)</span><span>       </span><span>-- aggregation of another column</span>&#13;
<span>FROM</span><span> </span><span>table_name</span><span>   </span><span>-- relation to use</span>&#13;
<span>GROUP</span><span> </span><span>BY</span><span> </span><span>col1</span><span>     </span><span>-- the column(s) to group by</span>&#13;
</pre>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Note that the order<a contenteditable="false" data-primary="FROM clause, SQL" data-type="indexterm" id="id960"/><a contenteditable="false" data-primary="WHERE clause, SQL" data-type="indexterm" id="id961"/> of clauses in a SQL statement is important. To avoid a syntax error, <code>SELECT</code> needs to appear first, then <code>FROM</code>, then <code>WHERE</code>, then <code>GROUP <span class="pre">BY</span></code>.</p>&#13;
&#13;
<p>When using <code>GROUP <span class="pre">BY</span></code> we need to be careful about the columns given to <code>SELECT</code>. In general, we can only include columns without an aggregation when we use those columns to group. For instance, in the preceding example we grouped by the <code>Year</code> column, so we can include <code>Year</code> in the <code>SELECT</code> clause. All other columns included in <code>SELECT</code> should be aggregated, as we did earlier with <code>SUM(Count)</code>. If we included a “bare” column like <code>Name</code> that wasn’t used for grouping, it’s ambiguous which name within the group should be returned. Although bare columns won’t cause an error for SQLite, they cause other SQL engines to error, so we recommend avoiding them<a contenteditable="false" data-primary="" data-startref="ix_agg_basic_grp" data-type="indexterm" id="id962"/><a contenteditable="false" data-primary="" data-startref="ix_grp_agg2" data-type="indexterm" id="id963"/>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Grouping on Multiple Columns" data-type="sect2"><div class="sect2" id="grouping-on-multiple-columns_9146230">&#13;
<h2>Grouping on Multiple Columns</h2>&#13;
&#13;
<p>We pass multiple<a contenteditable="false" data-primary="grouping in data tables" data-secondary="relations with multiple columns" data-type="indexterm" id="id964"/><a contenteditable="false" data-primary="aggregation" data-secondary="multiple columns, grouping on" data-type="indexterm" id="id965"/> columns into <code>GROUP <span class="pre">BY</span></code> to group by multiple columns at once. This is useful when we need to further subdivide our groups. For example, we can group by both year and sex to see how many male and female babies were born over time:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Year, Sex, SUM(Count)</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">GROUP BY Year, Sex</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Year</th>&#13;
			<th>Sex</th>&#13;
			<th>SUM(Count)</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>1880</td>&#13;
			<td>F</td>&#13;
			<td class="right">83929</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>1880</td>&#13;
			<td>M</td>&#13;
			<td class="right">110490</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>1881</td>&#13;
			<td>F</td>&#13;
			<td class="right">85034</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>279</strong></td>&#13;
			<td>2019</td>&#13;
			<td>M</td>&#13;
			<td class="right">1785527</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>280</strong></td>&#13;
			<td>2020</td>&#13;
			<td>F</td>&#13;
			<td class="right">1581301</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>281</strong></td>&#13;
			<td>2020</td>&#13;
			<td>M</td>&#13;
			<td class="right">1706423</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>282 rows × 3 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Notice that the preceding code is very similar to grouping by a single column, except that it gives multiple columns to <code>GROUP <span class="pre">BY</span></code> to group by both <code>Year</code> and <code>Sex</code>.</p>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Unlike <code>pandas</code>, SQLite<a contenteditable="false" data-primary="unstack() method, dataframe" data-type="indexterm" id="id966"/><a contenteditable="false" data-primary="pivoting" data-type="indexterm" id="id967"/><a contenteditable="false" data-primary="SQLite" data-type="indexterm" id="id968"/><a contenteditable="false" data-primary="GROUP BY function, relations" data-type="indexterm" id="id969"/> doesn’t provide a simple way to pivot a relation. Instead, we can use <code>GROUP <span class="pre">BY</span></code> on two columns in SQL, read the result into a dataframe, and then use the <code>unstack()</code> dataframe method.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Other Aggregation Functions" data-type="sect2"><div class="sect2" id="other-aggregation-functions">&#13;
<h2>Other Aggregation Functions</h2>&#13;
&#13;
<p>SQLite has several<a contenteditable="false" data-primary="MAX function, SQLite" data-type="indexterm" id="id970"/><a contenteditable="false" data-primary="MIN function, SQLite" data-type="indexterm" id="id971"/><a contenteditable="false" data-primary="AVG function, SQLite" data-type="indexterm" id="id972"/><a contenteditable="false" data-primary="COUNT function, SQLite" data-type="indexterm" id="id973"/> other built-in aggregation functions besides <code>SUM</code>, such as <code>COUNT</code>, <code>AVG</code>, <code>MIN</code>, and <code>MAX</code>. For the full list of functions, consult <a class="reference external" href="https://oreil.ly/ALtjb">the SQLite website</a>.</p>&#13;
&#13;
<p>To use another aggregation function, we call it in the <code>SELECT</code> clause. For instance, we can use <code>MAX</code> instead of <code>SUM</code>:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Year, MAX(Count)</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">GROUP BY Year</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe pagebreak-before less_space">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Year</th>&#13;
			<th>MAX(Count)</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>1880</td>&#13;
			<td>9655</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>1881</td>&#13;
			<td>8769</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>1882</td>&#13;
			<td>9557</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>138</strong></td>&#13;
			<td>2018</td>&#13;
			<td>19924</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>139</strong></td>&#13;
			<td>2019</td>&#13;
			<td>20555</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>140</strong></td>&#13;
			<td>2020</td>&#13;
			<td>19659</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>141 rows × 2 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The built-in aggregation<a contenteditable="false" data-primary="PostgreSQL" data-type="indexterm" id="id974"/> functions are one of the first places a data scientist may encounter differences in SQL implementations. For instance, SQLite has a relatively minimal set of aggregation functions while <a class="reference external" href="https://oreil.ly/gqYoK">PostgreSQL has many more</a>. That said, almost all SQL implementations provide <code>SUM</code>, <code>COUNT</code>, <code>MIN</code>, <code>MAX</code>, and <code>AVG</code>.</p>&#13;
</div>&#13;
&#13;
<p>This section covered common ways to aggregate data in SQL using the <code>GROUP <span class="pre">BY</span></code> keyword with one or more columns. In the next section, we’ll explain how to join relations together<a contenteditable="false" data-primary="" data-startref="ix_group_sql" data-type="indexterm" id="id975"/><a contenteditable="false" data-primary="" data-startref="ix_sql_agg" data-type="indexterm" id="id976"/><a contenteditable="false" data-primary="" data-startref="ix_agg_sql" data-type="indexterm" id="id977"/><a contenteditable="false" data-primary="" data-startref="ix_rel_agg_sql" data-type="indexterm" id="id978"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Joining" data-type="sect1"><div class="sect1" id="sec-sql-joining">&#13;
<h1>Joining</h1>&#13;
&#13;
<p>To connect<a contenteditable="false" data-primary="relations" data-secondary="joining" data-type="indexterm" id="ix_rel_join_sql"/><a contenteditable="false" data-primary="SQL (structured query language)" data-secondary="joining" data-type="indexterm" id="ix_sql_join"/><a contenteditable="false" data-primary="joining" data-secondary="SQL and relations" data-type="indexterm" id="ix_join_sql_rel"/> records between two data tables, SQL relations can be joined together similar to dataframes. In this section, we introduce SQL joins to replicate our analysis of the baby names data. Recall that <a class="reference internal" data-type="xref" href="ch06.html#ch-pandas">Chapter 6</a> mentions a <em>New York Times</em> article that talks about how certain name categories, like mythological and baby boomer names, have become more or less popular over time.</p>&#13;
&#13;
<p>We’ve taken the names and categories in the <em>NYT</em> article and put them in a small relation named <code>nyt</code>. First, the code sets up a connection to a database, then runs a SQL query to display the <code>nyt</code> relation:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="kn">import</code></span><code> </code><span><code class="nn">sqlalchemy</code></span><code>&#13;
</code><span><code class="n">db</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">sqlalchemy</code></span><span><code class="o">.</code></span><span><code class="n">create_engine</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">sqlite:///babynames.db</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM nyt;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>nyt_name</th>&#13;
			<th>category</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Lucifer</td>&#13;
			<td>forbidden</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Lilith</td>&#13;
			<td>forbidden</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Danger</td>&#13;
			<td>forbidden</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>20</strong></td>&#13;
			<td>Venus</td>&#13;
			<td>celestial</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>21</strong></td>&#13;
			<td>Celestia</td>&#13;
			<td>celestial</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>22</strong></td>&#13;
			<td>Skye</td>&#13;
			<td>celestial</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>23 rows × 2 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Notice<a contenteditable="false" data-primary="comma-separated value (CSV) file format" data-type="indexterm" id="id979"/><a contenteditable="false" data-primary="CSV (comma-separated value) file format" data-type="indexterm" id="id980"/> that the preceding code runs a query on <code>babynames.db</code>, the same database that contains the larger <code>baby</code> relation from the previous sections. SQL databases can hold more than one relation, making them very useful when we need to work with many data tables at once. CSV files, on the other hand, typically contain one data table each—if we perform a data analysis that uses 20 data tables, we might need to keep track of the names, locations, and versions of 20 CSV files. Instead, it could be simpler to store all the data tables in a SQLite database stored in a single file.</p>&#13;
</div>&#13;
&#13;
<p>To see how popular the categories of names are, we join the <code>nyt</code> relation with the <code>baby</code> relation to get the name counts from <code>baby</code>.</p>&#13;
&#13;
<section data-pdf-bookmark="Inner Joins" data-type="sect2"><div class="sect2" id="inner-joins_81444186">&#13;
<h2>Inner Joins</h2>&#13;
&#13;
<p>As in <a class="reference internal" data-type="xref" href="ch06.html#ch-pandas">Chapter 6</a>, we’ve made smaller<a contenteditable="false" data-primary="left joins" data-type="indexterm" id="ix_left_join"/><a contenteditable="false" data-primary="right joins" data-type="indexterm" id="ix_rt_join"/><a contenteditable="false" data-primary="inner joins" data-type="indexterm" id="ix_inner_join2"/> versions of the <code>baby</code> and <code>nyt</code> tables so that it’s easier to see what happens when we join tables together. The relations are called <code>baby_small</code> and <code>nyt_small</code>:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby_small;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>M</td>&#13;
			<td class="right">18252</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Julius</td>&#13;
			<td>M</td>&#13;
			<td class="right">960</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Karen</td>&#13;
			<td>M</td>&#13;
			<td class="right">6</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>3</strong></td>&#13;
			<td>Karen</td>&#13;
			<td>F</td>&#13;
			<td class="right">325</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>4</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>F</td>&#13;
			<td class="right">305</td>&#13;
			<td>2020</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM nyt_small;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>nyt_name</th>&#13;
			<th>category</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Karen</td>&#13;
			<td>boomer</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Julius</td>&#13;
			<td>mythology</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Freya</td>&#13;
			<td>mythology</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>To join relations<a contenteditable="false" data-primary="INNER JOIN clause, SQL" data-type="indexterm" id="id981"/> in SQL, we use the <code>INNER <span class="pre">JOIN</span></code> clause to say which tables we want to join and the <code>ON</code> clause to specify a predicate for joining the tables. Here’s an example:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby_small INNER JOIN nyt_small</code></span><code class="s1">&#13;
</code><span><code class="s1">  ON baby_small.Name = nyt_small.nyt_name</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
			<th>nyt_name</th>&#13;
			<th>category</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Julius</td>&#13;
			<td>M</td>&#13;
			<td class="right">960</td>&#13;
			<td>2020</td>&#13;
			<td>Julius</td>&#13;
			<td>mythology</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Karen</td>&#13;
			<td>M</td>&#13;
			<td class="right">6</td>&#13;
			<td>2020</td>&#13;
			<td>Karen</td>&#13;
			<td>boomer</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Karen</td>&#13;
			<td>F</td>&#13;
			<td class="right">325</td>&#13;
			<td>2020</td>&#13;
			<td>Karen</td>&#13;
			<td>boomer</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Notice that this result is the same as doing an inner join in <code>pandas</code>: the new table has the columns of both the <code>baby_small</code> and <code>nyt_small</code> tables. The rows with the name Noah are gone, and the remaining rows have their matching <code>category</code> from <code>nyt_small</code>.</p>&#13;
&#13;
<p>To join two tables together, we tell SQL the column(s) from each table that we want to do the join with, using a predicate with the <code>ON</code> keyword. SQL matches rows together when the values in the joining columns fulfill the predicate, as shown in <a class="reference internal" data-type="xref" href="#fig-sql-inner-join">Figure 7-2</a>.</p>&#13;
&#13;
<p>Unlike <code>pandas</code>, SQL gives more flexibility on how rows are joined. The <code>pd.merge()</code> method can only join using simple equality, but the predicate in the <code>ON</code> clause can be arbitrarily complex<a contenteditable="false" data-startref="ix_inner_join2" data-type="indexterm" id="id982"/>. As an example, we take advantage of this extra versatility in <a class="reference internal" data-type="xref" href="ch12.html#sec-pa-collocated">“Finding Collocated Sensors”</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-sql-inner-join"><img alt="sql-inner-join" src="assets/leds_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>Joining two tables together with SQL</h6>&#13;
</div></figure>&#13;
&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Left and Right Joins" data-type="sect2"><div class="sect2" id="left-and-right-joins">&#13;
<h2>Left and Right Joins</h2>&#13;
&#13;
<p>Like <code>pandas</code>, SQL also supports left joins<a contenteditable="false" data-primary="LEFT JOIN clause, SQL" data-type="indexterm" id="id983"/><a contenteditable="false" data-primary="joining" data-secondary="left and right joins" data-type="indexterm" id="ix_join_left_right"/>. Instead of saying <code>INNER <span class="pre">JOIN</span></code>, we use <code>LEFT <span class="pre">JOIN</span></code>:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby_small LEFT JOIN nyt_small</code></span><code class="s1">&#13;
</code><span><code class="s1">  ON baby_small.Name = nyt_small.nyt_name</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
			<th>nyt_name</th>&#13;
			<th>category</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>M</td>&#13;
			<td class="right">18252</td>&#13;
			<td>2020</td>&#13;
			<td>None</td>&#13;
			<td>None</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Julius</td>&#13;
			<td>M</td>&#13;
			<td class="right">960</td>&#13;
			<td>2020</td>&#13;
			<td>Julius</td>&#13;
			<td>mythology</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Karen</td>&#13;
			<td>M</td>&#13;
			<td class="right">6</td>&#13;
			<td>2020</td>&#13;
			<td>Karen</td>&#13;
			<td>boomer</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>3</strong></td>&#13;
			<td>Karen</td>&#13;
			<td>F</td>&#13;
			<td class="right">325</td>&#13;
			<td>2020</td>&#13;
			<td>Karen</td>&#13;
			<td>boomer</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>4</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>F</td>&#13;
			<td class="right">305</td>&#13;
			<td>2020</td>&#13;
			<td>None</td>&#13;
			<td>None</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>As we might expect, the “left” side of the join refers to the table that appears on the left side of the <code>LEFT <span class="pre">JOIN</span></code> keyword. We can see the <code>Noah</code> rows are kept in the resulting relation even when they don’t have a match in the righthand relation.</p>&#13;
&#13;
<p>Note that SQLite doesn’t support right joins directly, but we can perform the same join by swapping the order of relations, then using <code>LEFT <span class="pre">JOIN</span></code>:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM nyt_small LEFT JOIN baby_small</code></span><code class="s1">&#13;
</code><span><code class="s1">  ON baby_small.Name = nyt_small.nyt_name</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>nyt_name</th>&#13;
			<th>category</th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Karen</td>&#13;
			<td>boomer</td>&#13;
			<td>Karen</td>&#13;
			<td>F</td>&#13;
			<td class="right">325.0</td>&#13;
			<td>2020.0</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Karen</td>&#13;
			<td>boomer</td>&#13;
			<td>Karen</td>&#13;
			<td>M</td>&#13;
			<td class="right">6.0</td>&#13;
			<td>2020.0</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Julius</td>&#13;
			<td>mythology</td>&#13;
			<td>Julius</td>&#13;
			<td>M</td>&#13;
			<td class="right">960.0</td>&#13;
			<td>2020.0</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>3</strong></td>&#13;
			<td>Freya</td>&#13;
			<td>mythology</td>&#13;
			<td>None</td>&#13;
			<td>None</td>&#13;
			<td>NaN</td>&#13;
			<td>NaN</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>SQLite<a contenteditable="false" data-primary="SQLite" data-type="indexterm" id="id984"/> doesn’t have a built-in keyword for outer joins. In cases where an outer join is needed, we have to either use a different SQL engine or perform an outer join via <code>pandas</code>. However, in our (the authors’) experience, outer joins are rarely used in practice compared to inner and left joins<a contenteditable="false" data-primary="" data-startref="ix_join_left_right" data-type="indexterm" id="id985"/><a contenteditable="false" data-primary="" data-startref="ix_left_join" data-type="indexterm" id="id986"/><a contenteditable="false" data-primary="" data-startref="ix_rt_join" data-type="indexterm" id="id987"/>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Example: Popularity of NYT Name Categories" data-type="sect2"><div class="sect2" id="example-popularity-of-nyt-name-categories_6304332">&#13;
<h2>Example: Popularity of NYT Name Categories</h2>&#13;
&#13;
<p>Now let’s return to the full <code>baby</code> and <code>nyt</code> relations.</p>&#13;
&#13;
<p>We want to know<a contenteditable="false" data-primary="NYT name categories, popularity of" data-type="indexterm" id="ix_nyt_name"/><a contenteditable="false" data-primary="joining" data-secondary="NYT name categories example" data-type="indexterm" id="ix_join_nyt_name"/> how the popularity of name categories in <code>nyt</code> has changed over time. To answer this question, we should:</p>&#13;
&#13;
<ol class="arabic simple">&#13;
	<li>&#13;
	<p>Inner join <code>baby</code> with <code>nyt</code>, matching rows where the names are equal.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Group the table by <code>category</code> and <code>Year</code>.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Aggregate the counts using a sum:</p>&#13;
	</li>&#13;
</ol>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT</code></span><code class="s1">&#13;
</code><span><code class="s1">  category,</code></span><code class="s1">&#13;
</code><span><code class="s1">  Year,</code></span><code class="s1">&#13;
</code><span><code class="s1">  SUM(Count) AS count           -- [3]</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby INNER JOIN nyt        -- [1]</code></span><code class="s1">&#13;
</code><span><code class="s1">  ON baby.Name = nyt.nyt_name   -- [1]</code></span><code class="s1">&#13;
</code><span><code class="s1">GROUP BY category, Year         -- [2]</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">cate_counts</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code><span><code class="n">cate_counts</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>category</th>&#13;
			<th>Year</th>&#13;
			<th>count</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>boomer</td>&#13;
			<td>1880</td>&#13;
			<td>292</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>boomer</td>&#13;
			<td>1881</td>&#13;
			<td>298</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>boomer</td>&#13;
			<td>1882</td>&#13;
			<td>326</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>647</strong></td>&#13;
			<td>mythology</td>&#13;
			<td>2018</td>&#13;
			<td>2944</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>648</strong></td>&#13;
			<td>mythology</td>&#13;
			<td>2019</td>&#13;
			<td>3320</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>649</strong></td>&#13;
			<td>mythology</td>&#13;
			<td>2020</td>&#13;
			<td>3489</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>650 rows × 3 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>The numbers in square brackets (<code>[1]</code>, <code>[2]</code>, <code>[3]</code>) in the preceding query show how each step in our plan maps to the parts of the SQL query. The code re-creates the dataframe from <a class="reference internal" data-type="xref" href="ch06.html#ch-pandas">Chapter 6</a>, where we created plots to verify the claims of the <em>New York Times</em> article. For brevity, we omit duplicating the plots here.</p>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Notice<a contenteditable="false" data-primary="SELECT clause, SQL" data-type="indexterm" id="id988"/> that in the SQL code in this example, the numbers appear out of order—<code>[3]</code>, <code>[1]</code>, then <code>[2]</code>. As a rule of thumb for first-time SQL learners, we can often think of the <code>SELECT</code> statement as the <em>last</em> piece of the query to execute even though it appears first.</p>&#13;
</div>&#13;
&#13;
<p>In this section, we introduced joins for relations. When joining relations together, we match rows using the <code>INNER <span class="pre">JOIN</span></code> or <code>LEFT <span class="pre">JOIN</span></code> keyword and a boolean predicate. In the next section, we’ll explain how to transform values in a relation<a contenteditable="false" data-primary="" data-startref="ix_join_nyt_name" data-type="indexterm" id="id989"/><a contenteditable="false" data-primary="" data-startref="ix_nyt_name" data-type="indexterm" id="id990"/><a contenteditable="false" data-primary="" data-startref="ix_sql_join" data-type="indexterm" id="id991"/><a contenteditable="false" data-primary="" data-startref="ix_join_sql_rel" data-type="indexterm" id="id992"/><a contenteditable="false" data-primary="" data-startref="ix_rel_join_sql" data-type="indexterm" id="id993"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Transforming and Common Table Expressions" data-type="sect1"><div class="sect1" id="sec-sql-transforming">&#13;
<h1>Transforming and Common Table Expressions</h1>&#13;
&#13;
<p>In this section<a contenteditable="false" data-primary="transformations" data-secondary="of relations" data-secondary-sortas="relations" data-type="indexterm" id="ix_transf_rel"/><a contenteditable="false" data-primary="relations" data-secondary="transforming" data-type="indexterm" id="ix_rel_transf"/><a contenteditable="false" data-primary="functions" data-secondary="SQL transforming" data-type="indexterm" id="ix_func_sql_transf"/>, we show how to call functions to transform columns of data using built-in SQL functions. We also demonstrate how to use common table expressions to build up complex queries from simpler ones. As usual, we start by loading the database:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="c1"># Set up connection to database</code></span><code>&#13;
</code><span><code class="kn">import</code></span><code> </code><span><code class="nn">sqlalchemy</code></span><code>&#13;
</code><span><code class="n">db</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">sqlalchemy</code></span><span><code class="o">.</code></span><span><code class="n">create_engine</code></span><span><code class="p">(</code></span><span><code class="s1">'</code><code class="s1">sqlite:///babynames.db</code><code class="s1">'</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<section data-pdf-bookmark="SQL Functions" data-type="sect2"><div class="sect2" id="sql-functions">&#13;
<h2>SQL Functions</h2>&#13;
&#13;
<p>SQLite provides<a contenteditable="false" data-primary="scalar functions" data-type="indexterm" id="ix_scal_func"/><a contenteditable="false" data-primary="SQL (structured query language)" data-secondary="scalar functions" data-type="indexterm" id="ix_sql_scal_func"/> a variety of <em>scalar functions</em>, or functions that transform single data values. When called on a column of data, SQLite will apply these functions on each value in the column. In contrast, aggregation functions like <code>SUM</code> and <code>COUNT</code> take a column of values as input and compute a single value as output.</p>&#13;
&#13;
<p>SQLite provides<a contenteditable="false" data-primary="LENGTH() function, SQL" data-type="indexterm" id="id994"/> a comprehensive list of the built-in scalar functions in <a class="reference external" href="https://oreil.ly/kznBO">its online documentation</a>. For instance, to find the number of characters in each name, we use the <code>LENGTH</code> function:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Name, LENGTH(Name)</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">LIMIT 10;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>LENGTH(Name)</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>4</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>4</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
			<td>6</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>7</strong></td>&#13;
			<td>Lucas</td>&#13;
			<td>5</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>8</strong></td>&#13;
			<td>Henry</td>&#13;
			<td>5</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>9</strong></td>&#13;
			<td>Alexander</td>&#13;
			<td>9</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>10 rows × 2 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Notice that the <code>LENGTH</code> function is applied to each value within the <code>Name</code> column.</p>&#13;
&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Like aggregation functions, each implementation of SQL provides a different set of scalar functions. SQLite has a relatively minimal set of functions, while <a class="reference external" href="https://oreil.ly/i2KIA">PostgreSQL has many more</a>. That said, almost all SQL implementations provide some equivalent to SQLite’s <code>LENGTH</code>, <code>ROUND</code>, <code>SUBSTR</code>, and <code>LIKE</code> functions.</p>&#13;
</div>&#13;
&#13;
<p>Although scalar functions use the same syntax as an aggregation function, they behave differently. This can result in confusing output if the two are mixed together in a single query:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Name, LENGTH(Name), AVG(Count)</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">LIMIT 10;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>LENGTH(Name)</th>&#13;
			<th>AVG(Count)</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>4</td>&#13;
			<td>174.47</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>Here, the <code>AVG(Name)</code> computes the average of the entire <code>Count</code> column, but the output is confusing—a reader could easily think the average is related to the name Liam. For this reason, we must be careful when scalar and aggregation functions appear together within a <code>SELECT</code> statement.</p>&#13;
&#13;
<p>To extract<a contenteditable="false" data-primary="SUBSTR() function, SQL" data-type="indexterm" id="id995"/><a contenteditable="false" data-primary="substrings" data-type="indexterm" id="id996"/> the first letter of each name, we can use the <code>SUBSTR</code> function (short for <em>substring</em>). As described in the documentation, the <code>SUBSTR</code> function takes three arguments. The first is the input string, the second is the position to begin the substring (1-indexed), and the third is the length of the substring:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Name, SUBSTR(Name, 1, 1)</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">LIMIT 10;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>SUBSTR(Name, 1, 1)</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>L</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>N</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
			<td>O</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>7</strong></td>&#13;
			<td>Lucas</td>&#13;
			<td>L</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>8</strong></td>&#13;
			<td>Henry</td>&#13;
			<td>H</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>9</strong></td>&#13;
			<td>Alexander</td>&#13;
			<td>A</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>10 rows × 2 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>We can<a contenteditable="false" data-primary="AS keyword, SQL" data-type="indexterm" id="id997"/> use the <code>AS</code> keyword to rename the column:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *, SUBSTR(Name, 1, 1) AS Firsts</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">LIMIT 10;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
			<th>Firsts</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>M</td>&#13;
			<td>19659</td>&#13;
			<td>2020</td>&#13;
			<td>L</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>M</td>&#13;
			<td>18252</td>&#13;
			<td>2020</td>&#13;
			<td>N</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
			<td>M</td>&#13;
			<td>14147</td>&#13;
			<td>2020</td>&#13;
			<td>O</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>7</strong></td>&#13;
			<td>Lucas</td>&#13;
			<td>M</td>&#13;
			<td>11281</td>&#13;
			<td>2020</td>&#13;
			<td>L</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>8</strong></td>&#13;
			<td>Henry</td>&#13;
			<td>M</td>&#13;
			<td>10705</td>&#13;
			<td>2020</td>&#13;
			<td>H</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>9</strong></td>&#13;
			<td>Alexander</td>&#13;
			<td>M</td>&#13;
			<td>10151</td>&#13;
			<td>2020</td>&#13;
			<td>A</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>10 rows × 5 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>After calculating the first letter of each name, our analysis aims to understand the popularity of first letters over time. To do this, we want to take the output of this SQL query and use it as a single step within a longer chain of operations.</p>&#13;
&#13;
<p>SQL provides<a contenteditable="false" data-primary="WITH clause, SQL" data-type="indexterm" id="id998"/><a contenteditable="false" data-primary="CREATE TABLE statement, SQL" data-type="indexterm" id="id999"/><a contenteditable="false" data-primary="CREATE VIEW statement, SQL" data-type="indexterm" id="id1000"/> several options to break queries into smaller steps, which is helpful in more complex analyses like this one. The most common options for doing this are to create a new relation using a <code>CREATE <span class="pre">TABLE</span></code> statement, create a new view using <code><span class="keep-together">CREATE</span> <span class="pre">VIEW</span></code>, or create a temporary relation using <code>WITH</code>. Each of these methods has <span class="keep-together">different</span> use-cases. For simplicity, we only describe the <code>WITH</code> statement in this section and suggest that readers look over the SQLite documentation for details<a contenteditable="false" data-primary="" data-startref="ix_scal_func" data-type="indexterm" id="id1001"/><a contenteditable="false" data-primary="" data-startref="ix_func_sql_transf" data-type="indexterm" id="id1002"/><a contenteditable="false" data-primary="" data-startref="ix_sql_scal_func" data-type="indexterm" id="id1003"/>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Multistep Queries Using a WITH Clause" data-type="sect2"><div class="sect2" id="multistep-queries-using-a-with-clause">&#13;
<h2>Multistep Queries Using a WITH Clause</h2>&#13;
&#13;
<p>The <code>WITH</code> clause<a contenteditable="false" data-primary="SQL (structured query language)" data-secondary="multistep queries" data-type="indexterm" id="ix_sql_multistep"/><a contenteditable="false" data-primary="common table expressions, SQL" data-type="indexterm" id="id1004"/> lets us assign a name to any <code>SELECT</code> query. Then we can treat that query as though it exists as a relation in the database just for the duration of the query. SQLite calls these temporary relations <em>common table expressions</em>. For instance, we can take the earlier query that calculates the first letter of each name and call it <code>letters</code>:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">-- Create a temporary relation called letters by calculating</code></span><code class="s1">&#13;
</code><span><code class="s1">-- the first letter for each name in baby</code></span><code class="s1">&#13;
</code><span><code class="s1">WITH letters AS (</code></span><code class="s1">&#13;
</code><span><code class="s1">  SELECT *, SUBSTR(Name, 1, 1) AS Firsts</code></span><code class="s1">&#13;
</code><span><code class="s1">  FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">)</code></span><code class="s1">&#13;
</code><span><code class="s1">-- Then, select the first ten rows from letters</code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT *</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM letters</code></span><code class="s1">&#13;
</code><span><code class="s1">LIMIT 10;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Name</th>&#13;
			<th>Sex</th>&#13;
			<th>Count</th>&#13;
			<th>Year</th>&#13;
			<th>Firsts</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>Liam</td>&#13;
			<td>M</td>&#13;
			<td>19659</td>&#13;
			<td>2020</td>&#13;
			<td>L</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>Noah</td>&#13;
			<td>M</td>&#13;
			<td>18252</td>&#13;
			<td>2020</td>&#13;
			<td>N</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>Oliver</td>&#13;
			<td>M</td>&#13;
			<td>14147</td>&#13;
			<td>2020</td>&#13;
			<td>O</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>7</strong></td>&#13;
			<td>Lucas</td>&#13;
			<td>M</td>&#13;
			<td>11281</td>&#13;
			<td>2020</td>&#13;
			<td>L</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>8</strong></td>&#13;
			<td>Henry</td>&#13;
			<td>M</td>&#13;
			<td>10705</td>&#13;
			<td>2020</td>&#13;
			<td>H</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>9</strong></td>&#13;
			<td>Alexander</td>&#13;
			<td>M</td>&#13;
			<td>10151</td>&#13;
			<td>2020</td>&#13;
			<td>A</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>10 rows × 5 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p><code>WITH</code> statements are very useful since they can be chained together. We can create multiple temporary relations in a <code>WITH</code> statement that each perform a bit of work on the previous result, which lets us gradually build complicated queries a step at a time<a contenteditable="false" data-primary="" data-startref="ix_sql_multistep" data-type="indexterm" id="id1005"/>.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Example: Popularity of “L” Names" data-type="sect2"><div class="sect2" id="example-popularity-of-l-names_3645627">&#13;
<h2>Example: Popularity of “L” Names</h2>&#13;
&#13;
<p>We can use <code>WITH</code> statements to look at the popularity of names that start with the letter L over time. We’ll group the temporary <code>letters</code> relation by the first letter and year, then aggregate the <code>Count</code> column using a sum, then filter to get only names with the letter L:</p>&#13;
&#13;
<div class="cell docutils container">&#13;
<div class="cell_input docutils container">&#13;
<div class="highlight-ipython3 notranslate">&#13;
<div class="highlight">&#13;
<pre data-code-language="python" data-type="programlisting">&#13;
<span><code class="n">query</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="s1">'''</code><code class="s1"> </code></span><code class="s1">&#13;
</code><span><code class="s1">WITH letters AS (</code></span><code class="s1">&#13;
</code><span><code class="s1">  SELECT *, SUBSTR(Name, 1, 1) AS Firsts</code></span><code class="s1">&#13;
</code><span><code class="s1">  FROM baby</code></span><code class="s1">&#13;
</code><span><code class="s1">)</code></span><code class="s1">&#13;
</code><span><code class="s1">SELECT Firsts, Year, SUM(Count) AS Count</code></span><code class="s1">&#13;
</code><span><code class="s1">FROM letters</code></span><code class="s1">&#13;
</code><span><code class="s1">WHERE Firsts = </code><code class="s1">"</code><code class="s1">L</code><code class="s1">"</code></span><code class="s1">&#13;
</code><span><code class="s1">GROUP BY Firsts, Year;</code></span><code class="s1">&#13;
</code><span><code class="s1">'''</code></span><code>&#13;
</code><code>&#13;
</code><span><code class="n">letter_counts</code></span><code> </code><span><code class="o">=</code></span><code> </code><span><code class="n">pd</code></span><span><code class="o">.</code></span><span><code class="n">read_sql</code></span><span><code class="p">(</code></span><span><code class="n">query</code></span><span><code class="p">,</code></span><code> </code><span><code class="n">db</code></span><span><code class="p">)</code></span><code>&#13;
</code><span><code class="n">letter_counts</code></span><code>&#13;
</code></pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<div class="cell_output docutils container">&#13;
<div class="output text_html">&#13;
<div>&#13;
<table class="dataframe">&#13;
	<thead>&#13;
		<tr>&#13;
			<th> </th>&#13;
			<th>Firsts</th>&#13;
			<th>Year</th>&#13;
			<th>Count</th>&#13;
		</tr>&#13;
	</thead>&#13;
	<tbody>&#13;
		<tr>&#13;
			<td><strong>0</strong></td>&#13;
			<td>L</td>&#13;
			<td>1880</td>&#13;
			<td>12799</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>1</strong></td>&#13;
			<td>L</td>&#13;
			<td>1881</td>&#13;
			<td>12770</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>2</strong></td>&#13;
			<td>L</td>&#13;
			<td>1882</td>&#13;
			<td>14923</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>...</strong></td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
			<td>...</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>138</strong></td>&#13;
			<td>L</td>&#13;
			<td>2018</td>&#13;
			<td>246251</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>139</strong></td>&#13;
			<td>L</td>&#13;
			<td>2019</td>&#13;
			<td>249315</td>&#13;
		</tr>&#13;
		<tr>&#13;
			<td><strong>140</strong></td>&#13;
			<td>L</td>&#13;
			<td>2020</td>&#13;
			<td>239760</td>&#13;
		</tr>&#13;
	</tbody>&#13;
</table>&#13;
&#13;
<pre>141 rows × 3 columns</pre>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
</div>&#13;
&#13;
<p>This relation contains the same data as the one from <a class="reference internal" data-type="xref" href="ch06.html#ch-pandas">Chapter 6</a>. In that chapter, we make a plot of the <code>Count</code> column over time, which we omit here for brevity.</p>&#13;
&#13;
<p>In this section, we introduced data transformations. To transform values in a relation, we commonly use SQL functions like <code>LENGTH()</code> or <code>SUBSTR()</code>. We also explained how to build up complex queries using the <code>WITH</code> clause<a contenteditable="false" data-primary="" data-startref="ix_rel_transf" data-type="indexterm" id="id1006"/><a contenteditable="false" data-primary="" data-startref="ix_transf_rel" data-type="indexterm" id="id1007"/><a contenteditable="false" data-primary="" data-startref="ix_relations_ch7" data-type="indexterm" id="id1008"/><a contenteditable="false" data-primary="" data-startref="ix_sql_ch7" data-type="indexterm" id="id1009"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="sec-sql-summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we explained what relations are, why they’re useful, and how to work with them using SQL code. SQL databases are useful for many real-world settings. For example, SQL databases typically have robust data recovery mechanisms—if the computer crashes while in the middle of a SQL operation, the database system can recover as much data as possible without corruption. As mentioned earlier, SQL databases can also handle larger scale; organizations use SQL databases to store and query databases that are far too large to analyze in memory using <code>pandas</code> code. These are just a few reasons why SQL is an important part of the data science toolbox, and we expect that many readers will soon encounter SQL code as part of their work.</p>&#13;
</div></section>&#13;
</div></section></body></html>