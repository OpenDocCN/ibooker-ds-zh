["```py\n## R\nlibrary(tidyverse)\nlibrary(boot) #Required for Bootstrap simulations\nlibrary(rstudioapi) #To load data from local folder\nlibrary(ggpubr) #To generate multi-plots\n\n# Setting the random seed will ensure reproducibility of random numbers\nset.seed(1234)\n# I personally find the default scientific number notation (i.e. with \n# exponents) less readable in results, so I cancel it \noptions(scipen=10)\n\n## Python\nimport pandas as pd\nimport numpy as np\nimport statsmodels.formula.api as smf\nfrom statsmodels.formula.api import ols\nimport matplotlib.pyplot as plt # For graphics\nimport seaborn as sns # For graphics\n```", "```py\n## R\n> x <- 3\n> x\n[1] 3\n```", "```py\n## Python\nIn [1]: x = 3\nIn [2]: x\nOut[2]: 3\n```", "```py\n## R\n> model1 <- lm(icecream_sales ~ temps, data=stand_dat)\n> summary(model1)\n\n...\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) -4519.055    454.566  -9.941   <2e-16 ***\ntemps        1145.320      7.826 146.348   <2e-16 ***\n...\n\n```", "```py\n## Python \nmodel1 = ols(\"icecream_sales ~ temps\", data=stand_data_df)\nprint(model1.fit().summary())\n\n...     \n                 coef    std err          t      P>|t|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept  -4519.0554    454.566     -9.941      0.000   -5410.439   -3627.672\ntemps       1145.3197      7.826    146.348      0.000    1129.973    1160.666\n...\n```", "```py\n## R\nboot_CI_fun <- function(dat, metric_fun, B=20, conf.level=0.9){\n\n  boot_vec <- sapply(1:B, function(x){\n    cat(\"bootstrap iteration \", x, \"\\n\")\n    metric_fun(slice_sample(dat, n = nrow(dat), replace = TRUE))})\n  boot_vec <- sort(boot_vec, decreasing = FALSE)\n  offset = round(B * (1 - conf.level) / 2)\n  CI <- c(boot_vec[offset], boot_vec[B+1-offset])\n  return(CI)\n}\n\n```", "```py\n## Python \ndef boot_CI_fun(dat_df, metric_fun, B = 20, conf_level = 9/10):\n\n  coeff_boot = []\n\n  # Calculate coeff of interest for each simulation\n  for b in range(B):\n      print(\"beginning iteration number \" + str(b) + \"\\n\")\n      boot_df = dat_df.groupby(\"rep_ID\").sample(n=1200, replace=True)\n      coeff = metric_fun(boot_df)\n      coeff_boot.append(coeff)\n\n  # Extract confidence interval\n  coeff_boot.sort()\n  offset = round(B * (1 - conf_level) / 2)\n  CI = [coeff_boot[offset], coeff_boot[-(offset+1)]]\n\n  return CI\n```"]