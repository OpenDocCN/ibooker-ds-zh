- en: Appendix A. Supplemental Topics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 补充主题
- en: Using LaTeX Rendering with SymPy
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SymPy进行LaTeX渲染
- en: As you get more comfortable with mathematical notation, it can be helpful to
    take your SymPy expressions and display them in mathematical notation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对数学符号更加熟悉时，将你的SymPy表达式显示为数学符号可能会很有帮助。
- en: The quickest way to do this is to use the `latex()` function in SymPy on your
    expression and then copy the result to a LaTeX math viewer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最快的方法是在SymPy中使用 `latex()` 函数对你的表达式，然后复制结果到LaTeX数学查看器中。
- en: '[Example A-1](#pqebhBvrfC) is an example that takes a simple expression and
    turns it into a LaTeX string. Of course we can take the results of derivatives,
    integrals, and other SymPy operations and render those as LaTeX too. But let’s
    keep the example straightforward.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 A-1](#pqebhBvrfC) 是一个将简单表达式转换为LaTeX字符串的示例。当然，我们也可以对导数、积分和其他SymPy操作的结果进行渲染成LaTeX。但让我们保持示例简单。'
- en: Example A-1\. Using SymPy to convert an expression into LaTeX
  id: totrans-5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 A-1\. 使用SymPy将表达式转换为LaTeX
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This `\frac{x^{2}}{\sqrt{2 y^{3} - 1}}` string is formatted mathlatex, and
    there are a variety of tools and document formats that can be adapted to support
    it. But to simply render the mathlatex, go to a LaTeX equation editor. Here are
    two different ones I use online:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `\frac{x^{2}}{\sqrt{2 y^{3} - 1}}` 字符串是格式化的mathlatex，有多种工具和文档格式可以适应它。但为了简单地渲染mathlatex，可以去LaTeX方程编辑器。这里有两个我在线使用的不同的：
- en: '[Lagrida LaTeX Equation Editor](https://latexeditor.lagrida.com)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Lagrida LaTeX 方程编辑器](https://latexeditor.lagrida.com)'
- en: '[CodeCogs Equation Editor](https://latex.codecogs.com)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CodeCogs 方程编辑器](https://latex.codecogs.com)'
- en: In [Figure A-1](#daiTFCUMVR) I use Lagrida’s LaTeX editor to render the mathematical
    expression.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 A-1](#daiTFCUMVR) 中，我使用Lagrida的LaTeX编辑器来渲染数学表达式。
- en: '![emds aa01](Images/emds_aa01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![emds aa01](Images/emds_aa01.png)'
- en: Figure A-1\. Using a math editor to view the SymPy LaTeX output
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 A-1\. 使用数学编辑器查看SymPy LaTeX输出
- en: If you want to save the copy/paste step, you can append the LaTeX directly as
    an argument to the CodeCogs LaTeX editor URL as shown in [Example A-2](#ECwErAvaVL),
    and it will show the rendered math equation in your browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要省略复制/粘贴步骤，你可以将LaTeX直接附加为CodeCogs LaTeX编辑器URL的参数，就像[示例 A-2](#ECwErAvaVL)中展示的那样，它将在你的浏览器中显示渲染后的数学方程。
- en: Example A-2\. Open a mathlatex rendering using CodeCogs
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 A-2\. 使用CodeCogs打开一个mathlatex渲染。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you use Jupyter, you can also use [plugins to render mathlatex](https://oreil.ly/mWYf7).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Jupyter，你也可以使用[插件来渲染mathlatex](https://oreil.ly/mWYf7)。
- en: Binomial Distribution from Scratch
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始的二项分布
- en: If you want to implement a binomial distribution from scratch, here are all
    the parts you need in [Example A-3](#HvgtibdvEk).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从头实现一个二项分布，这里是所有你需要的部分在 [示例 A-3](#HvgtibdvEk) 中。
- en: Example A-3\. Building a binomial distribution from scratch
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 A-3\. 从头构建一个二项分布
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `factorial()` and the `binomial_coefficient()`, we can build a binomial
    distribution function from scratch. The factorial function multiplies a consecutive
    range of integers from 1 to `n`. For example, a factorial of 5! would be <math
    alttext="1 asterisk 2 asterisk 3 asterisk 4 asterisk 5 equals 120"><mrow><mn>1</mn>
    <mo>*</mo> <mn>2</mn> <mo>*</mo> <mn>3</mn> <mo>*</mo> <mn>4</mn> <mo>*</mo> <mn>5</mn>
    <mo>=</mo> <mn>120</mn></mrow></math> .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `factorial()` 和 `binomial_coefficient()`，我们可以从头构建一个二项分布函数。阶乘函数将一系列整数从1到`n`相乘。例如，5!
    的阶乘将是 <math alttext="1 asterisk 2 asterisk 3 asterisk 4 asterisk 5 equals 120"><mrow><mn>1</mn>
    <mo>*</mo> <mn>2</mn> <mo>*</mo> <mn>3</mn> <mo>*</mo> <mn>4</mn> <mo>*</mo> <mn>5</mn>
    <mo>=</mo> <mn>120</mn></mrow></math> 。
- en: The binomial coefficient function allows us to select *k* outcomes from *n*
    possibilities with no regard for ordering. If you have *k* = 2 and *n* = 3, that
    would yield sets (1,2) and (1,2,3), respectively. Between those two sets, the
    possible distinct combinations would be (1,3), (1,2), and (2,3). That is three
    combinations so that would be a binomial coefficient of 3\. Of course, using the
    `binomial_coefficient()` function we can avoid all that permutation work by using
    factorials and multiplication instead.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 二项式系数函数允许我们从 *n* 个可能性中选择 *k* 个结果，而不考虑顺序。如果你有 *k* = 2 和 *n* = 3，那将产生集合 (1,2)
    和 (1,2,3)。在这两组之间，可能的不同组合将是 (1,3)，(1,2) 和 (2,3)。因此，这将是一个二项式系数为3。当然，使用 `binomial_coefficient()`
    函数，我们可以避免所有这些排列工作，而是使用阶乘和乘法来实现。
- en: 'When implementing `binomial_distribution()`, notice how we take the binomial
    coefficient and multiply it by the probability of success `p` occurring `k` times
    (hence the exponent). We then multiply it by the opposite case: the probability
    of failure `1.0 – p` occurring `n – k` times. This allows us to account for the
    probability `p` of an event occurring versus not occurring across several trials.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`binomial_distribution()`时，请注意我们如何取二项式系数，并将其乘以成功概率`p`发生`k`次（因此指数）。然后我们乘以相反情况：失败概率`1.0
    - p`在`n - k`次中发生。这使我们能够跨多次试验考虑事件发生与否的概率`p`。
- en: Beta Distribution from Scratch
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始构建贝塔分布
- en: If you are curious how to build a beta distribution from scratch, you will need
    to reuse the `factorial()` function we used for the binomial distribution as well
    as the `approximate_integral()` function we built in [Chapter 2](ch02.xhtml#ch02).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道如何从头开始构建贝塔分布，你将需要重新使用我们用于二项分布的`factorial()`函数，以及我们在[第二章](ch02.xhtml#ch02)中构建的`approximate_integral()`函数。
- en: Just like we did in [Chapter 1](ch01.xhtml#ch01), we pack rectangles under the
    curve for the range we are interested in as shown in [Figure A-2](#ljBKFFcbOi).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第一章](ch01.xhtml#ch01)中所做的那样，我们在感兴趣的范围内根据曲线包装矩形，如图A-2所示。
- en: '![emds aa02](Images/emds_aa02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![emds aa02](Images/emds_aa02.png)'
- en: Figure A-2\. Packing rectangles under the curve to find the area/probability
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图A-2\. 包装矩形以找到面积/概率
- en: This is using just six rectangles; we will get better accuracy if we were to
    use more rectangles. Let’s implement the `beta_distribution()` from scratch and
    integrate 1,000 rectangles between 0.9 and 1.0 as shown in [Example A-4](#QATSjURCDG).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用六个矩形；如果我们使用更多矩形，将会获得更高的准确性。让我们从头实现`beta_distribution()`并在0.9到1.0之间使用1,000个矩形进行积分，如示例A-4所示。
- en: Example A-4\. Beta distribution from scratch
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例A-4\. 从头开始的贝塔分布
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice with the `beta_distribution()` function, we provide a given
    probability `x`, an `alpha` value quantifying successes, and a `beta` value quantifying
    failures. The function will return how likely we are to observe a given likelihood
    `x`. But again, to get a probability of observing probability `x` we need to find
    an area within a range of `x` values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`beta_distribution()`函数时，我们提供一个给定的概率`x`，一个衡量成功的`alpha`值，以及一个衡量失败的`beta`值。该函数将返回观察到给定概率`x`的可能性。但是，要获得观察到概率`x`的概率，我们需要在`x`值范围内找到一个区域。
- en: Thankfully, we have our `approximate_integral()` function defined and ready
    to go from [Chapter 2](ch02.xhtml#ch02). We can calculate the probability that
    the success rate is greater than 90% as well as less than 90%, as shown in the
    last few lines.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经定义并准备好使用来自[第二章](ch02.xhtml#ch02)的`approximate_integral()`函数。我们可以计算成功率大于90%和小于90%的概率，如最后几行所示。
- en: Deriving Bayes’ Theorem
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推导贝叶斯定理
- en: 'If you want to understand why Bayes’ Theorem works rather than take my word
    for it, let’s do a thought experiment. Let’s say I have a population of 100,000
    people. Multiply it with our given probabilities to get the count of people who
    drink coffee and the count of people who have cancer:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想理解为什么贝叶斯定理有效而不是听信我的话，让我们进行一个思想实验。假设我有一个10万人口的人群。将其与我们给定的概率相乘，以得到喝咖啡的人数和患癌症的人数：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>N</mi>
    <mo>=</mo> <mn>100,000</mn></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>P</mi> <mo>(</mo>
    <mtext>Coffee</mtext> <mtext>Drinker</mtext> <mo>)</mo> <mo>=</mo> <mn>.65</mn></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>P</mi>
    <mo>(</mo> <mtext>Cancer</mtext> <mo>)</mo> <mo>=</mo> <mn>.005</mn></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mtext>Coffee</mtext>
    <mtext>Drinkers</mtext> <mo>=</mo> <mn>65,000</mn></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mtext>Cancer</mtext>
    <mtext>Patients</mtext> <mo>=</mo> <mn>500</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>N</mi>
    <mo>=</mo> <mn>100,000</mn></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>P</mi> <mo>(</mo>
    喝咖啡的人 <mo>)</mo> <mo>=</mo> <mn>.65</mn></mrow></mtd></mtr></mtable></math> <math
    display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>P</mi>
    <mo>(</mo> 癌症 <mo>)</mo> <mo>=</mo> <mn>.005</mn></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mtext>喝咖啡的人数</mtext>
    <mo>=</mo> <mn>65,000</mn></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mtext>癌症患者数</mtext> <mo>=</mo>
    <mn>500</mn></mrow></mtd></mtr></mtable></math>
- en: 'We have 65,000 coffee drinkers and 500 cancer patients. Now of those 500 cancer
    patients, how many are coffee drinkers? We were provided with a conditional probability
    <math alttext="upper P left-parenthesis Coffee vertical-bar Cancer right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> <mtext>Coffee|Cancer</mtext> <mo>)</mo></mrow></math> we can multiply
    against those 500 people, which should give us 425 cancer patients who drink coffee:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有65,000名咖啡饮用者和500名癌症患者。现在，这500名癌症患者中，有多少是咖啡饮用者？我们提供了条件概率<math alttext="upper
    P left-parenthesis Coffee vertical-bar Cancer right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> 癌症|咖啡 <mo>)</mo></mrow></math>，我们可以将其乘以这500人，得到应有425名喝咖啡的癌症患者：
- en: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>P</mi>
    <mo>(</mo> <mtext>Coffee</mtext> <mtext>Drinker|Cancer</mtext> <mo>)</mo> <mo>=</mo>
    <mn>.85</mn></mrow></mtd></mtr></mtable></math> <math display="block"><mtable
    displaystyle="true"><mtr><mtd columnalign="right"><mrow><mtext>Coffee</mtext>
    <mtext>Drinkers</mtext> <mtext>with</mtext> <mtext>Cancer</mtext> <mo>=</mo> <mn>500</mn>
    <mo>×</mo> <mn>.85</mn> <mo>=</mo> <mn>425</mn></mrow></mtd></mtr></mtable></math>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mi>P</mi>
    <mo>(</mo> 喝咖啡的人|癌症 <mo>)</mo> <mo>=</mo> <mn>.85</mn></mrow></mtd></mtr></mtable></math>
    <math display="block"><mtable displaystyle="true"><mtr><mtd columnalign="right"><mrow><mtext>喝咖啡的癌症患者数</mtext>
    <mo>=</mo> <mn>500</mn> <mo>×</mo> <mn>.85</mn> <mo>=</mo> <mn>425</mn></mrow></mtd></mtr></mtable></math>
- en: 'Now what is the percentage of coffee drinkers who have cancer? What two numbers
    do we divide? We already have the number of people who drink coffee *and* have
    cancer. Therefore, we proportion that against the total number of coffee drinkers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，喝咖啡的人中得癌症的百分比是多少？我们需要除以哪两个数字？我们已经知道喝咖啡的人数 *和* 得癌症的人数。因此，我们将这个比例与总的喝咖啡的人数进行比较：
- en: <math display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> <mtext>Cancer|Coffee</mtext>
    <mtext>Drinker</mtext> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mtext>Coffee</mtext><mtext>Drinkers</mtext><mtext>with</mtext><mtext>Cancer</mtext></mrow>
    <mrow><mtext>Coffee</mtext><mtext>Drinkers</mtext></mrow></mfrac></mrow></math><math
    display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> <mtext>Cancer|Coffee</mtext>
    <mtext>Drinker</mtext> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mn>425</mn> <mrow><mn>65,000</mn></mrow></mfrac></mrow></math><math
    display="block"><mrow><mi>P</mi> <mo>(</mo> <mtext>Cancer|Coffee</mtext> <mtext>Drinker</mtext>
    <mo>)</mo> <mo>=</mo> <mn>0.006538</mn></mrow></math>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> 癌症|喝咖啡的人 <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mtext>喝咖啡的癌症患者数</mtext></mrow> <mrow><mtext>喝咖啡的人数</mtext></mrow></mfrac></mrow></math><math
    display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> 癌症|喝咖啡的人 <mo>)</mo></mrow> <mo>=</mo>
    <mfrac><mn>425</mn> <mrow><mn>65,000</mn></mrow></mfrac></mrow></math><math display="block"><mrow><mi>P</mi>
    <mo>(</mo> 癌症|喝咖啡的人 <mo>)</mo> <mo>=</mo> <mn>0.006538</mn></mrow></math>
- en: Hold on a minute, did we just flip our conditional probability? Yes we did!
    We started with <math alttext="upper P left-parenthesis Coffee Drinker vertical-bar
    Cancer right-parenthesis"><mrow><mi>P</mi> <mo>(</mo> <mtext>Coffee</mtext> <mtext>Drinker|Cancer</mtext>
    <mo>)</mo></mrow></math> and ended up with <math alttext="upper P left-parenthesis
    Cancer vertical-bar Coffee Drinker right-parenthesis"><mrow><mi>P</mi> <mo>(</mo>
    <mtext>Cancer|Coffee</mtext> <mtext>Drinker</mtext> <mo>)</mo></mrow></math> .
    By taking two subsets of the population (65,000 coffee drinkers and 500 cancer
    patients), and then applying a joint probability using the conditional probability
    we had, we ended up with 425 people in our population who both drink coffee and
    have cancer. We then divide that by the number of coffee drinkers to get the probability
    of cancer given one’s a coffee drinker.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻，我们是不是刚刚颠倒了条件概率？是的！我们从<math alttext="upper P left-parenthesis Coffee Drinker
    vertical-bar Cancer right-parenthesis"><mrow><mi>P</mi> <mo>(</mo> <mtext>Coffee</mtext>
    <mtext>Drinker|Cancer</mtext> <mo>)</mo></mrow></math>开始，最终得到<math alttext="upper
    P left-parenthesis Cancer vertical-bar Coffee Drinker right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> <mtext>Cancer|Coffee</mtext> <mtext>Drinker</mtext> <mo>)</mo></mrow></math>。通过取两个子集（65,000名咖啡饮用者和500名癌症患者），然后应用我们拥有的条件概率来应用联合概率，我们最终在我们的人口中得到了既饮咖啡又患癌症的425人。然后我们将这个数字除以咖啡饮用者的数量，得到患癌症的概率，假如一个人是咖啡饮用者。
- en: 'But where is Bayes’ Theorem in this? Let’s focus on the <math alttext="upper
    P left-parenthesis Cancer vertical-bar Coffee Drinker right-parenthesis"><mrow><mi>P</mi>
    <mo>(</mo> <mtext>Cancer|Coffee</mtext> <mtext>Drinker</mtext> <mo>)</mo></mrow></math>
    expression and expand it with all the expressions we previously calculated:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是贝叶斯定理在哪里呢？让我们专注于<math alttext="upper P left-parenthesis Cancer vertical-bar
    Coffee Drinker right-parenthesis"><mrow><mi>P</mi> <mo>(</mo> <mtext>Cancer|Coffee</mtext>
    <mtext>Drinker</mtext> <mo>)</mo></mrow></math>表达式，并用我们先前计算的所有表达式扩展它：
- en: <math display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> <mtext>Cancer|Coffee</mtext>
    <mtext>Drinker</mtext> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mn>100,000</mn><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Cancer</mtext><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker|Cancer</mtext><mo>)</mo></mrow>
    <mrow><mn>100,000</mn><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker</mtext><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> <mtext>Cancer|Coffee</mtext>
    <mtext>Drinker</mtext> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mn>100,000</mn><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Cancer</mtext><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker|Cancer</mtext><mo>)</mo></mrow>
    <mrow><mn>100,000</mn><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker</mtext><mo>)</mo></mrow></mfrac></mrow></math>
- en: Notice the population <math alttext="upper N"><mi>N</mi></math> of 100,000 exists
    in both the numerator and denominator so it cancels out. Does this look familiar
    now?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意人口<math alttext="upper N"><mi>N</mi></math>为10万，在分子和分母中都存在，所以可以取消。这看起来现在熟悉吗？
- en: <math alttext="upper P left-parenthesis Cancer vertical-bar Coffee Drinker right-parenthesis
    equals StartFraction upper P left-parenthesis Cancer right-parenthesis times upper
    P left-parenthesis Coffee Drinker vertical-bar Cancer right-parenthesis Over upper
    P left-parenthesis Coffee Drinker right-parenthesis EndFraction" display="block"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mtext>Cancer|Coffee</mtext> <mtext>Drinker</mtext> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mtext>Cancer</mtext><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker|Cancer</mtext><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker</mtext><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper P left-parenthesis Cancer vertical-bar Coffee Drinker right-parenthesis
    equals StartFraction upper P left-parenthesis Cancer right-parenthesis times upper
    P left-parenthesis Coffee Drinker vertical-bar Cancer right-parenthesis Over upper
    P left-parenthesis Coffee Drinker right-parenthesis EndFraction" display="block"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mtext>Cancer|Coffee</mtext> <mtext>Drinker</mtext> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mtext>Cancer</mtext><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker|Cancer</mtext><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker</mtext><mo>)</mo></mrow></mfrac></mrow></math>
- en: Sure enough, this should match Bayes’ Theorem!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这应该与贝叶斯定理相符！
- en: <math display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> <mtext>A|B</mtext> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mtext>B|A</mtext><mo>)</mo><mo>*</mo><mi>P</mi><mo>(</mo><mi>B</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>A</mi><mo>)</mo></mrow></mfrac></mrow></math> <math
    display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> <mtext>Cancer|Coffee</mtext>
    <mtext>Drinker</mtext> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mtext>Cancer</mtext><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker|Cancer</mtext><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker</mtext><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> <mtext>A|B</mtext> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mtext>B|A</mtext><mo>)</mo><mo>*</mo><mi>P</mi><mo>(</mo><mi>B</mi><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mi>A</mi><mo>)</mo></mrow></mfrac></mrow></math> <math
    display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> <mtext>Cancer|Coffee</mtext>
    <mtext>Drinker</mtext> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mtext>Cancer</mtext><mo>)</mo><mo>×</mo><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker|Cancer</mtext><mo>)</mo></mrow>
    <mrow><mi>P</mi><mo>(</mo><mtext>Coffee</mtext><mtext>Drinker</mtext><mo>)</mo></mrow></mfrac></mrow></math>
- en: So if you get confused by Bayes’ Theorem or struggle with the intuition behind
    it, try taking subsets of a fixed population based on the provided probabilities.
    You can then trace your way to flip a conditional probability.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对贝叶斯定理感到困惑或者在其背后的直觉上挣扎，尝试基于提供的概率数据获取固定人口的子集。然后你可以追踪你的方式来颠倒一个条件概率。
- en: CDF and Inverse CDF from Scratch
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始的CDF和逆CDF
- en: To calculate areas for the normal distribution, we can of course use the rectangle-packing
    method we learned in [Chapter 1](ch01.xhtml#ch01) and applied to the beta distribution
    earlier in the appendix. It doesn’t require the cumulative density function (CDF)
    but simply packed rectangles under the probability density function (PDF). Using
    this method, we can find the probability a golden retriever weighs between 61
    and 62 pounds as shown in [Example A-5](#CjcMWPpGJu), using 1,000 packed rectangles
    against the normal PDF.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算正态分布的面积，我们当然可以使用我们在[第1章](ch01.xhtml#ch01)中学到的矩形填充法，之前在附录中应用于beta分布。它不需要累积密度函数（CDF），而只需在概率密度函数（PDF）下填充矩形。使用这种方法，我们可以找到金毛寻回犬体重在61至62磅之间的概率，如[示例A-5](#CjcMWPpGJu)所示，使用1,000个填充的矩形对正态PDF进行估算。
- en: Example A-5\. The normal distribution function in Python
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 A-5\. Python中的正态分布函数
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That will give us about 8.25% probability a golden retriever weighs between
    61 and 62 pounds. If we wanted to leverage a CDF that is already integrated for
    us and does not require any rectangle packing, we can declare it from scratch
    as shown in [Example A-6](#KuqFAIPtpi).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供大约8.25%的概率，即金毛犬重量在61至62磅之间。如果我们想利用已经为我们集成且不需要任何矩形包装的CDF，我们可以像在[示例 A-6](#KuqFAIPtpi)中所示从头开始声明它。
- en: Example A-6\. Using the inverse CDF (called `ppf()`) in Python
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 A-6\. 在Python中使用称为`ppf()`的逆CDF
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `math.erf()` is known as the error function and is often used to compute
    cumulative distributions. Finally, to do the inverse CDF from scratch you will
    need to use the inverse of the `erf()` function called `erfinv()`. [Example A-7](#JORdwCMIRL)
    calculates one thousand randomly generated golden retriever weights using an inverse
    CDF coded from scratch.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`math.erf()`被称为误差函数，通常用于计算累积分布。最后，要从头开始做逆CDF，您需要使用名为`erfinv()`的`erf()`函数的逆函数。[示例 A-7](#JORdwCMIRL)
    使用从头编码的逆CDF计算了一千个随机生成的金毛犬重量。'
- en: Example A-7\. Generating random golden retriever weights
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 A-7\. 生成随机金毛犬重量
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Use e to Predict Event Probability Over Time
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 e 预测随时间发生的事件概率
- en: Let’s look at one more use case for <math alttext="e"><mi>e</mi></math> that
    you might find useful. Let’s say you are a manufacturer of propane tanks. Obviously,
    you do not want the tank to leak or else that could create hazards, particularly
    around open flames and sparks. Testing a new tank design, your engineer reports
    that there is a 5% chance in a given year that it will leak.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您可能会发现有用的<math alttext="e"><mi>e</mi></math>的另一个用例。假设您是丙烷罐的制造商。显然，您不希望罐子泄漏，否则可能会在开放火焰和火花周围造成危险。测试新罐设计时，您的工程师报告说，在给定的一年中，有5%的机会它会泄漏。
- en: You know this is already an unacceptably high number, but you want to know how
    this probability compounds over time. You now ask yourself, “What is the probability
    of a leak happening within 2 years? 5 years? 10 years?” The more time that is
    exposed, would not the probability of seeing the tank leak only get higher? Euler’s
    number can come to the rescue again!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道这已经是一个不可接受的高数字，但你想知道这种概率如何随时间复合。现在你问自己，“在2年内发生泄漏的概率是多少？5年？10年？”随着时间的推移，暴露的时间越长，看到罐子泄漏的概率不是越来越高吗？欧拉数再次派上用场！
- en: <math display="block"><mrow><msub><mi>P</mi> <mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>k</mi></mrow></msub>
    <mo>=</mo> <mn>1.0</mn> <mo>-</mo> <msup><mi>e</mi> <mrow><mo>-</mo><mi>λ</mi><mi>T</mi></mrow></msup></mrow></math>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><msub><mi>P</mi> <mrow><mi>l</mi><mi>e</mi><mi>a</mi><mi>k</mi></mrow></msub>
    <mo>=</mo> <mn>1.0</mn> <mo>-</mo> <msup><mi>e</mi> <mrow><mo>-</mo><mi>λ</mi><mi>T</mi></mrow></msup></mrow></math>
- en: This function models the probability of an event over time, or in this case
    the tank leaking after *T* time. <math alttext="e"><mi>e</mi></math> again is
    Euler’s number, lambda <math alttext="lamda"><mi>λ</mi></math> is the failure
    rate across each unit of time (each year), and *T* is the amount of time gone
    by (number of years).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数建模随时间的事件发生概率，或者在本例中是罐子在*T*时间后泄漏的概率。 <math alttext="e"><mi>e</mi></math> 再次是欧拉数，lambda
    <math alttext="lamda"><mi>λ</mi></math> 是每个单位时间（每年）的失效率，*T* 是经过的时间量（年数）。
- en: If we graph this function where *T* is our x-axis, the probability of a leak
    is our y-axis, and λ = .05, [Figure A-3](#HKCiJNGOam) shows what we get.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绘制此函数，其中*T*是我们的x轴，泄漏的概率是我们的y轴，λ = .05，[图 A-3](#HKCiJNGOam)显示了我们得到的结果。
- en: '![emds aa03](Images/emds_aa03.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![emds aa03](Images/emds_aa03.png)'
- en: Figure A-3\. Predicting the probability of a leak over time
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 A-3\. 预测随时间泄漏概率
- en: Here is how we model this function in Python for <math alttext="lamda equals
    .05"><mrow><mi>λ</mi> <mo>=</mo> <mo>.</mo> <mn>05</mn></mrow></math> and <math
    alttext="upper T equals 5"><mrow><mi>T</mi> <mo>=</mo> <mn>5</mn></mrow></math>
    years in [Example A-8](#RJmkBwKJPf).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在Python中为<math alttext="lamda equals .05"><mrow><mi>λ</mi> <mo>=</mo> <mo>.</mo>
    <mn>05</mn></mrow></math>和<math alttext="upper T equals 5"><mrow><mi>T</mi> <mo>=</mo>
    <mn>5</mn></mrow></math>年建模此函数的方式，参见[示例 A-8](#RJmkBwKJPf)。
- en: Example A-8\. Code for predicting the probability of a leak over time
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 A-8\. 用于预测随时间泄漏概率的代码
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The probability of a tank failure after 2 years is about 9.5%, 5 years is about
    22.1%, and 10 years 39.3%. The more time that passes, the more likely the tank
    will leak. We can generalize this formula to predict any event with a probability
    in a given period and see how that probability shifts over different periods of
    time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 2年后罐子失效的概率约为9.5%，5年约为22.1%，10年约为39.3%。随着时间的推移，罐子泄漏的可能性越来越大。我们可以将此公式推广为预测任何在给定期间内具有概率的事件，并查看该概率在不同时间段内的变化。
- en: Hill Climbing and Linear Regression
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爬坡和线性回归
- en: If you find the calculus overwhelming in building machine learning from scratch,
    you can try a more brute-force method. Let’s try a *hill climbing* algorithm,
    where we randomly adjust *m* and *b* by adding random values for a number of iterations.
    These random values will be positive or negative (which will make the addition
    operation effectively subtraction), and we will only keep adjustments that improve
    our sum of squares.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现从头开始构建机器学习中的微积分令人不知所措，您可以尝试一种更加蛮力的方法。让我们尝试一种 *爬山* 算法，其中我们通过添加一些随机值来随机调整
    *m* 和 *b*，进行一定次数的迭代。这些随机值将是正或负的（这将使加法操作有效地成为减法），我们只保留能够改善平方和的调整。
- en: But do we just generate any random number as the adjustment? We will want to
    prefer smaller moves but occasionally we might allow larger moves. This way, we
    have mostly fine adjustments, but occasionally we will make big jumps if they
    are needed. The best tool to do this is a standard normal distribution, with a
    mean of 0 and a standard deviation of 1\. Recall from [Chapter 3](ch03.xhtml#ch03)
    that a standard normal distribution will have a high density of values near 0,
    and the farther the value is away from 0 (in both the negative and positive direction),
    the less likely the value becomes as shown in [Figure A-4](#dvHeFXxfYw).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们随机生成任何数字作为调整吗？我们更倾向于较小的移动，但偶尔也许会允许较大的移动。这样，我们主要是微小的调整，但偶尔如果需要的话会进行大幅跳跃。最好的工具来做到这一点是标准正态分布，均值为
    0，标准差为 1。回想一下第 [3 章](ch03.xhtml#ch03) 中提到的标准正态分布在 0 附近有大量的值，而远离 0 的值（无论是负向还是正向）的概率较低，如
    [图 A-4](#dvHeFXxfYw) 所示。
- en: '![emds aa04](Images/emds_aa04.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![emds aa04](Images/emds_aa04.png)'
- en: Figure A-4\. Most values in a standard normal distribution are small and near
    0, while larger values are less frequent on the tails
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 A-4\. 标准正态分布中大多数值都很小且接近于 0，而较大的值在尾部出现的频率较低
- en: Circling back to the linear regression, we will start `m` and `b` at 0 or some
    other starting values. Then for 150,000 iterations in a `for` loop, we will randomly
    adjust `m` and `b` by adding values sampled from the standard normal distribution.
    If a random adjustment improves/lessens the sum of squares, we keep it. But if
    the sum of squares increases, we undo that random adjustment. In other words,
    we only keep adjustments that improve the sum of squares. Let’s take a look in
    [Example A-9](#MLMseKbSoJ).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回到线性回归，我们将从 0 或其他起始值开始设置 `m` 和 `b`。然后在一个 `for` 循环中进行 150,000 次迭代，我们将随机调整 `m`
    和 `b`，通过添加从标准正态分布中采样的值。如果随机调整改善/减少了平方和，我们将保留它。但如果平方和增加了，我们将撤消该随机调整。换句话说，我们只保留能够改善平方和的调整。让我们在
    [示例 A-9](#MLMseKbSoJ) 中看一看。
- en: Example A-9\. Using hill climbing for linear regression
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 A-9\. 使用爬山算法进行线性回归
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You will see the progress of the algorithm, but ultimately you should get a
    fitted function of approximately `y = 1.9395722046562853x + 4.731834051245578`,
    give or take. Let’s validate this answer. When I used Excel or Desmos to perform
    a linear regression, Desmos gave me `y = 1.93939x + 4.73333`. Not bad! I got pretty
    close!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到算法的进展，但最终您应该得到一个大约为 `y = 1.9395722046562853x + 4.731834051245578` 的拟合函数。让我们验证这个答案。当我使用
    Excel 或 Desmos 进行线性回归时，Desmos 给出了 `y = 1.93939x + 4.73333`。还不错！我几乎接近了！
- en: Why did we need one million iterations? Through experimentation, I found this
    with enough iterations where the solution was not really improving much anymore
    and converged closely to the optimal values for `m` and `b` to minimize the sum
    of squares. You will find many machine learning libraries and algorithms have
    a parameter for the number of iterations to perform, and it does exactly this.
    You need to have enough so it converges on the right answer approximately, but
    not so much that it wastes computation time when it has already found an acceptable
    solution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要一百万次迭代？通过实验，我发现这足够多的迭代次数使得解决方案不再显著改善，并且收敛到了接近于最优的 `m` 和 `b` 值以最小化平方和。您将发现许多机器学习库和算法都有一个迭代次数的参数，它确切地做到这一点。您需要足够多的迭代次数使其大致收敛到正确的答案，但不要太多以至于在已经找到可接受的解决方案时浪费计算时间。
- en: One other question you may have is why I started the `best_loss` at an extremely
    large number. I did this to initialize the best loss with a value I know will
    be overwritten once the search starts, and it will then be compared to the new
    loss of each iteration to see if it results in an improvement. I also could have
    used positive infinity `float('inf')` instead of a very large number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么我将 `best_loss` 设置为一个极大的数字。我这样做是为了用我知道会被覆盖的值初始化最佳损失，并且它将与每次迭代的新损失进行比较，以查看是否有改进。我也可以使用正无穷
    `float('inf')` 而不是一个非常大的数字。
- en: Hill Climbing and Logistic Regression
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爬山算法与逻辑回归
- en: Just like in the previous example with linear regression, we can also apply
    hill climbing to logistic regression. Again, use this technique if you find the
    calculus and partial derivatives to be too much at once.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的线性回归示例一样，我们也可以将爬山算法应用于逻辑回归。如果你觉得微积分和偏导数一次性学习太过于复杂，可以再次使用这一技术。
- en: 'The hill climbing methodology is identical: adjust `m` and `b` with random
    values from a normal distribution. However we do have a different objective function,
    the maximum likelihood estimation, as discussed in [Chapter 6](ch06.xhtml#ch06).
    Therefore, we only take random adjustments that increase the likelihood estimation,
    and after enough iterations we should converge on a fitted logistic regression.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 爬山方法完全相同：用正态分布的随机值调整 `m` 和 `b`。然而，我们确实有一个不同的目标函数，即最大似然估计，在 [第 6 章](ch06.xhtml#ch06)
    中讨论过。因此，我们只采用增加似然估计的随机调整，并在足够的迭代之后应该会收敛到一个拟合的逻辑回归模型。
- en: This is all demonstrated in [Example A-10](#WjhOVwMJCO).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在 [示例 A-10](#WjhOVwMJCO) 中演示。
- en: Example A-10\. Using hill climbing for a simple logistic regression
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 A-10\. 使用爬山算法进行简单的逻辑回归
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Refer to [Chapter 6](ch06.xhtml#ch06) for more details on the maximum likelihood
    estimation, the logistic function, and the reason we use the `log()` function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [第 6 章](ch06.xhtml#ch06) 获取更多关于最大似然估计、逻辑函数以及我们为什么使用 `log()` 函数的详细信息。
- en: A Brief Intro to Linear Programming
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性规划简介
- en: A technique that every data science professional should be familiar with is
    *linear programming*, which solves a system of inequalities by adapting systems
    of equations with “slack variables.” When you have variables that are discrete
    integers or binaries (0 or 1) in a linear programming system, it is known as *integer
    programming*. When linear continuous and integer variables are used, it is known
    as *mixed integer programming*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据科学专业人士都应熟悉的技术是*线性规划*，它通过使用“松弛变量”来适应方程组来解决不等式系统。当你在线性规划系统中有离散整数或二进制变量（0 或
    1）时，它被称为*整数规划*。当使用线性连续和整数变量时，它被称为*混合整数规划*。
- en: While it is much more algorithm-driven than data-driven, linear programming
    and its variants can be used to solve a wide array of classic AI problems. If
    it sounds dubious to brand linear programming systems as AI, it is common practice
    by many vendors and companies as it increases the perceived value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管比数据驱动更多地依赖算法，线性规划及其变体可用于解决广泛的经典人工智能问题。如果将线性规划系统称为人工智能听起来有些靠不住，但许多供应商和公司都将其视为一种常见做法，因为这会增加其感知价值。
- en: In practice, it is best to use the many available solver libraries to do linear
    programming for you, but resources at the end of this section will be provided
    on how to do it from scratch. For these examples we will use [PuLP](https://pypi.org/project/PuLP),
    although [Pyomo](https://www.pyomo.org) is an option as well. We will also use
    graphical intuition, although problems with more than three dimensions cannot
    be visualized easily.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，最好使用众多现有的求解器库来为你执行线性规划，但是在本节末尾将提供如何从头开始执行的资源。在这些示例中，我们将使用 [PuLP](https://pypi.org/project/PuLP)，虽然
    [Pyomo](https://www.pyomo.org) 也是一个选择。我们还将使用图形直觉，尽管超过三个维度的问题不能轻易地进行可视化。
- en: 'Here’s our example. You have two lines of products: the iPac and iPac Ultra.
    The iPac makes $200 profit while the iPac Ultra makes $300 profit.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的例子。你有两条产品线：iPac 和 iPac Ultra。iPac 每件产品盈利 $200，而 iPac Ultra 每件产品盈利 $300。
- en: However, the assembly line can work for only 20 hours, and it takes 1 hour to
    produce the iPac and 3 hours to produce an iPac Ultra.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，装配线只能工作 20 小时，而制造 iPac 需要 1 小时，制造 iPac Ultra 需要 3 小时。
- en: Only 45 kits can be provided in a day, and an iPac requires 6 kits while iPac
    Ultra requires 2 kits.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一天只能提供 45 套装备，而 iPac 需要 6 套，而 iPac Ultra 需要 2 套。
- en: Assuming all supply will be sold, how many of the iPac and iPac Ultra should
    we sell to maximize profit?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有供应都将被销售，我们应该销售多少个 iPac 和 iPac Ultra 以实现利润最大化？
- en: 'Let’s first note that first constraint and break it down:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先注意第一个约束条件并将其拆分：
- en: …the assembly line can work for only 20 hours, and it takes 1 hour to produce
    the iPac and 3 hours to produce an iPac Ultra.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …装配线只能工作 20 小时，生产一个 iPac 需要 1 小时，生产一个 iPac Ultra 需要 3 小时。
- en: We can express that as an inequality where *x* is the number of iPac units and
    *y* is the number of iPac Ultra units. Both must be positive and [Figure A-5](#kCkjAwhqqP)
    shows we can graph accordingly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其表示为一个不等式，其中*x*是 iPac 单元的数量，*y*是 iPac Ultra 单元的数量。两者必须为正，并且[图 A-5](#kCkjAwhqqP)显示我们可以相应地绘制图形。
- en: <math alttext="x plus 3 y less-than-or-equal-to 20 left-parenthesis x greater-than-or-equal-to
    0 comma y greater-than-or-equal-to 0 right-parenthesis" display="block"><mrow><mi>x</mi>
    <mo>+</mo> <mn>3</mn> <mi>y</mi> <mo>≤</mo> <mn>20</mn> <mo>(</mo> <mi>x</mi>
    <mo>≥</mo> <mn>0</mn> <mo>,</mo> <mi>y</mi> <mo>≥</mo> <mn>0</mn> <mo>)</mo></mrow></math>![emds
    aa05](Images/emds_aa05.png)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="x plus 3 y less-than-or-equal-to 20 left-parenthesis x greater-than-or-equal-to
    0 comma y greater-than-or-equal-to 0 right-parenthesis" display="block"><mrow><mi>x</mi>
    <mo>+</mo> <mn>3</mn> <mi>y</mi> <mo>≤</mo> <mn>20</mn> <mo>(</mo> <mi>x</mi>
    <mo>≥</mo> <mn>0</mn> <mo>,</mo> <mi>y</mi> <mo>≥</mo> <mn>0</mn> <mo>)</mo></mrow></math>![emds
    aa05](Images/emds_aa05.png)
- en: Figure A-5\. Graphing the first constraint
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 A-5\. 绘制第一个约束条件
- en: 'Now let us look at the second constraint:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看第二个约束条件：
- en: Only 45 kits can be provided in a day, and an iPac requires 6 kits while iPac
    Ultra requires 2 kits.
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一天只能提供 45 个套件，其中 iPac 需要 6 个套件，而 iPac Ultra 需要 2 个套件。
- en: We can also model and graph in [Figure A-6](#VnhgsinHGv) accordingly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据[图 A-6](#VnhgsinHGv)进行建模和绘图。
- en: <math alttext="6 x plus 2 y less-than-or-equal-to 45 left-parenthesis x greater-than-or-equal-to
    0 comma y greater-than-or-equal-to 0 right-parenthesis" display="block"><mrow><mn>6</mn>
    <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>y</mi> <mo>≤</mo> <mn>45</mn> <mo>(</mo>
    <mi>x</mi> <mo>≥</mo> <mn>0</mn> <mo>,</mo> <mi>y</mi> <mo>≥</mo> <mn>0</mn> <mo>)</mo></mrow></math>![emds
    aa06](Images/emds_aa06.png)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="6 x plus 2 y less-than-or-equal-to 45 left-parenthesis x greater-than-or-equal-to
    0 comma y greater-than-or-equal-to 0 right-parenthesis" display="block"><mrow><mn>6</mn>
    <mi>x</mi> <mo>+</mo> <mn>2</mn> <mi>y</mi> <mo>≤</mo> <mn>45</mn> <mo>(</mo>
    <mi>x</mi> <mo>≥</mo> <mn>0</mn> <mo>,</mo> <mi>y</mi> <mo>≥</mo> <mn>0</mn> <mo>)</mo></mrow></math>![emds
    aa06](Images/emds_aa06.png)
- en: Figure A-6\. Graphing the second constraint
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 A-6\. 绘制第二个约束条件
- en: Notice in [Figure A-6](#VnhgsinHGv) that we now have an overlap between these
    two constraints. Our solution is somewhere in that overlap and we will call it
    the *feasible region*. Finally, we are maximizing our profit *Z*, which is expressed
    next, given the profit amounts for the iPac and iPac Ultra, respectively.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[图 A-6](#VnhgsinHGv)中，现在这两个约束条件之间存在重叠。我们的解决方案位于该重叠区域内，我们称之为*可行区域*。最后，我们正在最大化我们的利润*Z*，下面给出了
    iPac 和 iPac Ultra 的利润金额。
- en: <math alttext="upper Z equals 200 x plus 300 y" display="block"><mrow><mi>Z</mi>
    <mo>=</mo> <mn>200</mn> <mi>x</mi> <mo>+</mo> <mn>300</mn> <mi>y</mi></mrow></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper Z equals 200 x plus 300 y" display="block"><mrow><mi>Z</mi>
    <mo>=</mo> <mn>200</mn> <mi>x</mi> <mo>+</mo> <mn>300</mn> <mi>y</mi></mrow></math>
- en: If we express this function as a line, we can increase *Z* as much as possible
    until the line is just no longer in the feasible region. We then note the x- and
    y-values as visualized in [Figure A-7](#OPAqHuJwSt).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个函数表示为一条线，我们可以尽可能地增加*Z*，直到这条线不再位于可行区域内。然后我们注意在[图 A-7](#OPAqHuJwSt)中可视化的
    x 和 y 值。
- en: Desmos Graph of the Objective Function
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective Function 的 Desmos 图
- en: If you need to see this visualized in a more interactive and animated fashion,
    check out [this graph on Desmos](https://oreil.ly/RQMBT).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要以更交互式和动画的方式看到这个图形，请查看[Desmos 上的这张图](https://oreil.ly/RQMBT)。
- en: '![emds aa07](Images/emds_aa07.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![emds aa07](Images/emds_aa07.png)'
- en: Figure A-7\. Increasing our objective line until it no longer is in the feasible
    region
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 A-7\. 将我们的目标线增加到不再位于可行区域内
- en: When that line “just touches” the feasible region as you increase profit *Z*
    as much as possible, you will land on a vertex, or a corner, of the feasible region.
    That vertex provides the x- and y-values that will maximize profit, as shown in
    [Figure A-8](#bdonOArOSi).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当利润*Z*尽可能地增加时，当那条线“刚好触及”可行区域时，您将落在可行区域的一个顶点或角上。该顶点提供了将最大化利润所需的 x 和 y 值，如[图 A-8](#bdonOArOSi)所示。
- en: While we could use NumPy and a bunch of matrix operations to solve this numerically,
    it will be easier to use PuLP as shown in [Example A-11](#MJjcOPJjvs). Note that
    `LpVariable` defines the variables to solve for. `LpProblem` is the linear programming
    system that adds constraints and objective functions using Python operators. Then
    the variables are solved by calling `solve()` on the `LpProblem`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用NumPy和一堆矩阵运算来进行数值求解，但使用PuLP会更容易，如[示例 A-11](#MJjcOPJjvs)所示。请注意，`LpVariable`定义了要解决的变量。`LpProblem`是线性规划系统，使用Python操作符添加约束和目标函数。然后通过在`LpProblem`上调用`solve()`来求解变量。
- en: '![emds aa08](Images/emds_aa08.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![emds aa08](Images/emds_aa08.png)'
- en: Figure A-8\. Maximized objective for our linear programming system
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: A-8\. 线性规划系统的最大化目标
- en: Example A-11\. Using Python PuLP to solve a linear programming system
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: A-11\. 使用Python PuLP解决线性规划系统
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You might be wondering if it makes sense to build 5.9375 and 4.6875 units. Linear
    programming systems are much more efficient if you can tolerate continuous values
    in your variables, and perhaps you can just round them afterward. But certain
    types of problems absolutely require integers and binary variables to be handled
    discretely.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道是否有意义构建5.9375和4.6875单位。如果您的变量能容忍连续值，线性规划系统会更高效，也许您可以在之后对它们进行四舍五入处理。但某些类型的问题绝对需要处理整数和二进制变量。
- en: To force the `x` and `y` variables to be treated as integers, provide a category
    argument `cat=LpInteger` as shown in [Example A-12](#pqntuvKNRo).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`x`和`y`变量强制为整数，可以使用`cat=LpInteger`参数，如[示例 A-12](#pqntuvKNRo)所示。
- en: Example A-12\. Forcing variables to be solved as integers
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: A-12\. 强制变量作为整数解决
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Graphically, this means we fill our feasible region with discrete points rather
    than a continuous region. Our solution will not land on a vertex necessarily but
    rather the point that is closest to the vertex as shown in [Figure A-9](#TWnQjpTKGu).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从图形上来看，这意味着我们用离散点填充我们的可行区域，而不是连续的区域。我们的解决方案不一定会落在一个顶点上，而是接近顶点的点，如[图 A-9](#TWnQjpTKGu)所示。
- en: There are a couple of special cases in linear programming, as shown in [Figure A-10](#FnSsEsjOEf).
    Sometimes there can be many solutions. At times, there may be no solution at all.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划中有一些特殊情况，如[图 A-10](#FnSsEsjOEf)所示。有时可能有多个解决方案。有时可能根本没有解决方案。
- en: This is just a quick introductory example to linear programming, and unfortunately
    there is not enough room in this book to do the topic justice. It can be used
    for surprising problems, including scheduling constrained resources (like workers,
    server jobs, or rooms), solving Sudokus, and optimizing financial portfolios.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是线性规划的一个快速介绍示例，不幸的是，这本书里没有足够的空间来充分讨论这个话题。它可以用于一些出人意料的问题，包括调度受限资源（如工人、服务器任务或房间）、解决数独和优化金融投资组合。
- en: '![emds aa09](Images/emds_aa09.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![emds aa09](Images/emds_aa09.png)'
- en: Figure A-9\. A discrete linear programming system
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: A-9\. 离散线性规划系统
- en: '![emds aa10](Images/emds_aa10.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![emds aa10](Images/emds_aa10.png)'
- en: Figure A-10\. Special cases of linear programming
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: A-10\. 线性规划的特殊情况
- en: If you want to learn more, there are some good YouTube videos out there including
    [PatrickJMT](https://oreil.ly/lqeeR) and [Josh Emmanuel](https://oreil.ly/jAHWc).
    If you want to deep dive into discrete optimization, Professor Pascal Van Hentenryck
    has done a tremendous service [putting a course together on Coursera](https://oreil.ly/aVGxY).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多，有一些很好的YouTube视频，包括[PatrickJMT](https://oreil.ly/lqeeR)和[Josh Emmanuel](https://oreil.ly/jAHWc)。如果您想深入研究离散优化，Pascal
    Van Hentenryck教授在Coursera上组织了一门极好的课程，[请点击这里](https://oreil.ly/aVGxY)。
- en: MNIST Classifier Using scikit-learn
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scikit-learn进行MNIST分类器
- en: '[Example A-13](#rqjdqTwRJL) shows how to use scikit-learn’s neural network
    for handwritten digit classification.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 A-13](#rqjdqTwRJL)展示了如何使用scikit-learn的神经网络进行手写数字分类。'
- en: Example A-13\. A handwritten digit classifier neural network in scikit-learn
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: A-13\. scikit-learn中的手写数字分类器神经网络示例
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
