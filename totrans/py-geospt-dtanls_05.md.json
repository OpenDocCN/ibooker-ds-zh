["```py\nsurface=asphalt\nhighway=residential\nbuilding=commercial \n```", "```py\nconda create -name OSM\nconda activate OSM\nconda install -c conda-forge osmnx\nconda install -c conda-forge matplotlib\nconda install -c conda-forge descartes \nconda install -c conda-forge shapely \nconda install -c conda-forge jupyter\nconda install -c conda-forge jupyter_contrib_nbextensions\n```", "```py\n(ox) MacBook-Pro-8:~ bonnymcclain$ conda list\n# packages in environment at /Users/bonnymcclain/opt/miniconda3/envs/OSM:\n```", "```py\nimport osmnx as ox\nimport networkx as nx\nimport matplotlib.pyplot as plt #installs with osmnx\n\n# download/model a street network for some city then visualize it\nG = ox.graph_from_place(\"Los Angeles,California,United States\", \nnetwork_type=\"drive\")\nfig, ax = ox.plot_graph(G,figsize=(20,20),bgcolor='#FFFFFF',\n    node_color='black', node_size=0)\n```", "```py\nG = ox.graph_from_place(☞\"Los Angeles,California\")\n```", "```py\nDocstring:\nCreate graph from OSM within the boundaries of some geocodable place(s).\n\nThe query must be geocodable and OSM must have polygon boundaries for the geocode \nresult. If OSM does not have a polygon for this place, you can instead get its \nstreet network using the graph_from_address function, which geocodes the place \nname to a point and gets the network within some distance of that point.\n\nIf OSM does have polygon boundaries for this place but you’re not finding it, \ntry to vary the query string, pass in a structured query dict, or vary the \nwhich_result argument to use a different geocode result. If you know the OSM ID \nof the place, you can retrieve its boundary polygon using the geocode_to_gdf \nfunction, then pass it to the graph_from_polygon function.\n```", "```py\nParameters\n----------\nquery : string or dict or list\n    the query or queries to geocode to get place boundary polygon(s)\nnetwork_type : string {\"all_private\", \"all\", \"bike\", \"drive\", \"drive_service\", \n\"walk\"}\n    what type of street network to get if custom_filter is None\nsimplify : bool\n    if True, simplify graph topology with the `simplify_graph` function\nretain_all : bool\n    if True, return the entire graph even if it is not connected.\n    otherwise, retain only the largest weakly connected component.\ntruncate_by_edge : bool\n    if True, retain nodes outside boundary polygon if at least one of\n    node's neighbors is within the polygon\nwhich_result : int\n    which geocoding result to use. if None, auto-select the first\n    (Multi)Polygon or raise an error if OSM doesn't return one.\nbuffer_dist : float\n    distance to buffer around the place geometry, in meters\nclean_periphery : bool\n    if True, buffer 500m to get a graph larger than requested, then\n    simplify, then truncate it to requested spatial boundaries\ncustom_filter : string\n    a custom ways filter to be used instead of the network_type \n    presets  e.g., '[\"power\"~\"line\"]' or \n    '[\"highway\"~\"motorway|trunk\"]'. Also pass in a network_type that \n    is in settings.bidirectional_network_types if you want graph \n    to be fully bi-directional.\n```", "```py\nox.speed.add_edge_speeds(G, hwy_speeds=None, fallback=None, precision=1)\nox.speed.add_edge_travel_times(G, precision=1)\n```", "```py\nG = ox.add_edge_speeds(G)\nG = ox.add_edge_travel_times(G)\n\nw = 'travel_time'\norig, dest = list(G)[10], list(G)[-10]\nroute1 = nx.shortest_path(G, orig, dest, weight=w)\norig, dest = list(G)[0], list(G)[-1]\nroute2 = nx.shortest_path(G, orig, dest, weight=w)\norig, dest = list(G)[-100], list(G)[100]\nroute3 = nx.shortest_path(G, orig, dest, weight=w)\n\nroutes = [route1, route2, route3]\nrc = ['r', 'y', 'c']\nfig, ax = ox.plot_graph_routes(G, routes, route_colors=rc, route_linewidth=6, \nfigsize=(30, 30),node_size=0,bgcolor='#FFFFFF')\n```", "```py\nplace_name = 'Culver City, California, United States'\nG = ox.graph_from_place(place_name, clean_periphery=False,\nnetwork_type=\"all_private\")\nfig, ax = ox.plot_graph(G,figsize=(7,7),bgcolor='#FFFFFF',\n     node_color=\"b\",node_size=3)\n```", "```py\n %matplotlib inline\n```", "```py\nox.__version__\n```", "```py\nimport osmnx as ox\nimport networkx as nx\nimport matplotlib.pyplot as plt #installs with osmnx\nimport pandas as pd\n%matplotlib inline\nox.__version__\n```", "```py\n# get the network for Manhattan, calculate its basic stats and show the average \ncircuity stats = ox.basic_stats(ox.graph_from_place(\"Manhattan,New York,United States\"))\nstats[\"circuity_avg\"]\n```", "```py\n# get the network for Staten Island, calculate its basic stats and show the \naverage circuity stats = ox.basic_stats(ox.graph_from_place(\"Staten Island,New York,United States\"))\nstats[\"circuity_avg\"]\n```", "```py\nstats = ox.basic_stats(ox.graph_from_place(\"Paris, France\"))\nstats[\"circuity_avg\"]\n```", "```py\n# get street network, and area in square meters\nplace = \"Paris, France\"\ngdf = ox.geocode_to_gdf(place)\narea = ox.project_gdf(gdf).unary_union.area\nG = ox.graph_from_place(place, network_type=\"drive\")\n```", "```py\n# calculate basic stats, merge them, and display\nstats = ox.basic_stats(G, area=area)\npd.Series(stats)\n```", "```py\n# unpack dicts into individual keys:values\nstats = ox.basic_stats(G, area=area)\nfor k, count in stats[\"streets_per_node_counts\"].items():\n    stats[\"{}way_int_count\".format(k)] = count\nfor k, proportion in stats[\"streets_per_node_proportions\"].items():\n    stats[\"{}way_int_prop\".format(k)] = proportion\n# delete the no longer needed dict elements\ndel stats[\"streets_per_node_counts\"]\ndel stats[\"streets_per_node_proportions\"]\n\n# load as a pandas dataframe\npd.DataFrame(pd.Series(stats, name=\"value\")).round(3)\n```", "```py\n# calculate betweenness with a digraph of G (ie, no parallel edges)\nbc = nx.betweenness_centrality(ox.get_digraph(G), weight=\"length\")\nmax_node, max_bc = max(bc.items(), key=lambda x: x[1])\nmax_node, max_bc\n```", "```py\nnc = [\"r\" if node == max_node else \"grey\" for node in G.nodes]\nns = [100 if node == max_node else 15 for node in G.nodes]\nfig, ax = ox.plot_graph(G, node_size=ns, node_color=nc, node_zorder=5)\nplt.show()\n```", "```py\n# add the betweenness centrality values as new node attributes, then plot\nnx.set_node_attributes(G, bc, \"bc\")\nnc = ox.plot.get_node_colors_by_attr(G, \"bc\", cmap=\"plasma\")\nfig, ax = ox.plot_graph(\n    G,\n    node_color=nc,\n    node_size=30,\n    node_zorder=2,\n    edge_linewidth=0.2,\n    edge_color=\"w\",\n)\n```", "```py\nimport osmnx as ox\nimport networkx as nx\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nplt.style.use('default')\nimport pandas as pd\n```", "```py\nplace_name = \"Paris, France\"\ngraph = ox.graph_from_place(place_name, network_type='drive')\nfig, ax = ox.plot_graph(graph)\n```", "```py\nedges = ox.graph_to_gdfs(graph, nodes=False, edges=True)\n```", "```py\nedges.columns\n```", "```py\nIndex(['osmid', 'name', 'highway', 'maxspeed', 'oneway', 'reversed', 'length',\n       'lanes', 'geometry', 'junction', 'width', 'bridge', 'tunnel', 'access',\n       'ref'],\n      dtype='object')\n```", "```py\nedges.crs\n```", "```py\n<Geographic 2D CRS: EPSG:4326>\nName: WGS 84\nAxis Info [ellipsoidal]:\n- Lat[north]: Geodetic latitude (degree)\n- Lon[east]: Geodetic longitude (degree)\nArea of Use:\n- name: World.\n- bounds: (-180.0, -90.0, 180.0, 90.0)\nDatum: World Geodetic System 1984 ensemble\n- Ellipsoid: WGS 84\n- Prime Meridian: Greenwich\n```", "```py\nedges.head()\n```", "```py\nprint(edges['highway'].value_counts())\n```", "```py\nresidential                                  8901\nprimary                                      2984\ntertiary                                     2548\nsecondary                                    2542\nunclassified                                  648\nliving_street                                 458\ntrunk_link                                    194\ntrunk                                         146\nprimary_link                                  118\n[residential, living_street]                   41\nsecondary_link                                 37\n[unclassified, residential]                    30\ntertiary_link                                  20\nmotorway_link                                  16\n…\n```", "```py\nplace = \"Culver City, California\"\ntags = {\"building\": True}\ngdf = ox.geometries_from_place(place, tags={'building':True})\ngdf.shape\n```", "```py\nfig, ax = ox.plot_geometries(gdf, figsize=(10, 10),bgcolor='#FFFFFF')\n```", "```py\ngdf=ox.geometries.geometries_from_address((52.3716,4.9005),dist=15000, \ntags={'natural':'water','highway':''})\ngdf.to_crs(epsg=28992, inplace=True)\ngdf.plot(figsize=(16,16))\ngdf.plot(figsize=(16,16))\n```", "```py\ngdf=ox.geometries.geometries_from_address(('Manhattan, NY'),dist=15000, \n    tags={'natural':'water','building':'commercial','landuse':'commercial',\n    'landuse':'residential','highway':'unclassified','highway':'primary'})\ngdf.to_crs(epsg=2263,inplace=**True**)\ngdf.plot(figsize=(20,29))\n```", "```py\ncf = '[\"highway\"~\"motorway|motorway_link|trunk|trunk_link\"]'\nG = ox.graph_from_place(\"Madrid\", network_type=\"drive\", custom_filter=cf)\nfig, ax = ox.plot_graph(G, node_size=3,node_color='black',edge_linewidth=3,\nbgcolor='#FFFFFF')\n```", "```py\nplace = \"Madrid, Spain\"\ntags = {\"building\": True}\ngdf = ox.geometries_from_place(place, tags)\nfig, ax = ox.plot_footprints(gdf, figsize=(20, 20),alpha=1,color='black',\nbgcolor='#FFFFFF',save=True,filepath='settings.imgs_folder/image.png',show=True,\ndpi=600)\n```", "```py\nimport osmnx as ox\nimport networkx as nx\nimport matplotlib.pyplot as plt\n%matplotlib inline \nplace_name = 'Madrid,Spain'\nG = ox.graph_from_place(place_name,network_type=\"drive\")\nfig, ax = ox.plot_graph(G,figsize=(20,20),bgcolor='#FFFFFF',\n    node_color='black', node_size=0)\n```", "```py\nG = ox.graph_from_place(\n    \"Madrid, Spain\",network_type=\"all\",\n    retain_all=False,\n    truncate_by_edge=True,\n    simplify=True,\n\n)\n\nfig, ax = ox.plot_graph(G, figsize=(20, 20),node_size=0, edge_color=\"#111111\", \nedge_linewidth=0.7,bgcolor='#FFFFFF')\n```"]