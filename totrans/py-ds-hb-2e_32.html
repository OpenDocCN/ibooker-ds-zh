<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 28. Density and Contour Plots" data-type="chapter" epub:type="chapter"><div class="chapter" id="section-0404-density-and-contour-plots">
<h1><span class="label">Chapter 28. </span>Density and Contour Plots</h1>
<p><a data-primary="contour plots" data-type="indexterm" id="ix_ch28-asciidoc0"/><a data-primary="contour plots" data-secondary="density and" data-type="indexterm" id="ix_ch28-asciidoc1"/><a data-primary="Matplotlib" data-secondary="density and contour plots" data-type="indexterm" id="ix_ch28-asciidoc2"/><a data-primary="plotting" data-secondary="density and contour plots" data-type="indexterm" id="ix_ch28-asciidoc3"/>Sometimes it is useful to display three-dimensional data in two
dimensions using contours or color-coded regions. There are three
Matplotlib functions that can be helpful for this task: <code>plt.contour</code>
for contour plots, <code>plt.contourf</code> for filled contour plots, and
<code>plt.imshow</code> for showing images. This chapter looks at several examples
of using these. We’ll start by setting up the notebook for
plotting and importing the functions we will use:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="o">%</code><code class="k">matplotlib</code> inline
        <code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>
        <code class="n">plt</code><code class="o">.</code><code class="n">style</code><code class="o">.</code><code class="n">use</code><code class="p">(</code><code class="s1">'seaborn-white'</code><code class="p">)</code>
        <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code></pre>
<section data-pdf-bookmark="Visualizing a Three-Dimensional Function" data-type="sect1"><div class="sect1" id="ch_0404-density-and-contour-plots_visualizing-a-three-dimensional-function">
<h1>Visualizing a Three-Dimensional Function</h1>
<p><a data-primary="contour plots" data-secondary="three-dimensional function" data-type="indexterm" id="ix_ch28-asciidoc4"/><a data-primary="Matplotlib" data-secondary="three-dimensional function visualization" data-type="indexterm" id="ix_ch28-asciidoc5"/><a data-primary="plotting" data-secondary="three-dimensional function" data-type="indexterm" id="ix_ch28-asciidoc6"/><a data-primary="plt.contour() function" data-type="indexterm" id="ix_ch28-asciidoc7"/>Our first example demonstrates a contour plot using a function
<math alttext="z equals f left-parenthesis x comma y right-parenthesis">
<mrow>
<mi>z</mi>
<mo>=</mo>
<mi>f</mi>
<mo>(</mo>
<mi>x</mi>
<mo>,</mo>
<mi>y</mi>
<mo>)</mo>
</mrow>
</math>, using the following particular choice for
<math alttext="f">
<mi>f</mi>
</math> (we’ve seen this before in
<a data-type="xref" href="ch08.xhtml#section-0205-computation-on-arrays-broadcasting">Chapter 8</a>, when we used it as a motivating example for array
broadcasting):</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="k">def</code> <code class="nf">f</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">):</code>
            <code class="k">return</code> <code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="o">**</code> <code class="mi">10</code> <code class="o">+</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="mi">10</code> <code class="o">+</code> <code class="n">y</code> <code class="o">*</code> <code class="n">x</code><code class="p">)</code> <code class="o">*</code> <code class="n">np</code><code class="o">.</code><code class="n">cos</code><code class="p">(</code><code class="n">x</code><code class="p">)</code></pre>
<p>A contour plot can be created with the <code>plt.contour</code> function. It takes
three arguments: a grid of <em>x</em> values, a grid of <em>y</em> values, and a grid
of <em>z</em> values. The <em>x</em> and <em>y</em> values represent positions on the plot,
and the <em>z</em> values will be represented by the contour levels. Perhaps
the most straightforward way to prepare such data is to use the
<code>np.meshgrid</code> function, which builds two-dimensional grids from
one-dimensional arrays:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">x</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">50</code><code class="p">)</code>
        <code class="n">y</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">40</code><code class="p">)</code>

        <code class="n">X</code><code class="p">,</code> <code class="n">Y</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">meshgrid</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">)</code>
        <code class="n">Z</code> <code class="o">=</code> <code class="n">f</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">)</code></pre>
<p>Now let’s look at this with a standard line-only contour
plot (see <a data-type="xref" href="#fig_0404-density-and-contour-plots_files_in_output_9_0">Figure 28-1</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">contour</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">,</code> <code class="n">Z</code><code class="p">,</code> <code class="n">colors</code><code class="o">=</code><code class="s1">'black'</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0404-density-and-contour-plots_files_in_output_9_0">
<img alt="output 9 0" height="398" src="assets/output_9_0.png" width="600"/>
<h6><span class="label">Figure 28-1. </span>Visualizing three-dimensional data with contours</h6>
</div></figure>
<p>Notice that when a single color is used, negative values are represented
by dashed lines and positive values by solid lines. Alternatively, the
lines can be color-coded by specifying a colormap with the <code>cmap</code>
argument. Here we’ll also specify that we want more lines to
be drawn, at 20 equally spaced intervals within the data range, as shown
in <a data-type="xref" href="#fig_0404-density-and-contour-plots_files_in_output_11_0">Figure 28-2</a>.</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">contour</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">,</code> <code class="n">Z</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="n">cmap</code><code class="o">=</code><code class="s1">'RdGy'</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0404-density-and-contour-plots_files_in_output_11_0">
<img alt="output 11 0" height="200" src="assets/output_11_0.png" width="600"/>
<h6><span class="label">Figure 28-2. </span>Visualizing three-dimensional data with colored contours</h6>
</div></figure>
<p>Here we chose the <code>RdGy</code> (short for <em>Red–Gray</em>) colormap, which is a
good choice for divergent data: (i.e., data with positive and negative
variation around zero). Matplotlib has a wide range of colormaps
available, which you can easily browse in IPython by doing a tab
completion on the <code>plt.cm</code> module:</p>
<pre>plt.cm.&lt;TAB&gt;</pre>
<p>Our plot is looking nicer, but the spaces between the lines may be a bit
distracting. We can change this by switching to a filled contour plot
using the <code>plt.contourf</code> function, which uses largely the same syntax as
<code>plt.contour</code>.</p>
<p>Additionally, we’ll add a <code>plt.colorbar</code> command, which
creates an additional axis with labeled color information for the plot
(see <a data-type="xref" href="#fig_0404-density-and-contour-plots_files_in_output_13_0">Figure 28-3</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">contourf</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">,</code> <code class="n">Z</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="n">cmap</code><code class="o">=</code><code class="s1">'RdGy'</code><code class="p">)</code>
        <code class="n">plt</code><code class="o">.</code><code class="n">colorbar</code><code class="p">();</code></pre>
<figure><div class="figure" id="fig_0404-density-and-contour-plots_files_in_output_13_0">
<img alt="output 13 0" height="392" src="assets/output_13_0.png" width="600"/>
<h6><span class="label">Figure 28-3. </span>Visualizing three-dimensional data with filled contours</h6>
</div></figure>
<p>The colorbar makes it clear that the black regions are “peaks,” while
the red regions are “valleys.”</p>
<p>One potential issue with this plot is that it is a bit splotchy: the
color steps are discrete rather than continuous, which is not always
what is desired. This could be remedied by setting the number of
contours to a very high number, but this results in a rather inefficient
plot: Matplotlib must render a new polygon for each step in the level. <a data-primary="plt.imshow() function" data-type="indexterm" id="ix_ch28-asciidoc8"/>A
better way to generate a smooth representation is to use the
<code>plt.imshow</code> function, which offers the <code>interpolation</code> argument to
generate a smooth two-dimensional representation of the data (see <a data-type="xref" href="#fig_0404-density-and-contour-plots_files_in_output_15_0">Figure 28-4</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">imshow</code><code class="p">(</code><code class="n">Z</code><code class="p">,</code> <code class="n">extent</code><code class="o">=</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code> <code class="n">origin</code><code class="o">=</code><code class="s1">'lower'</code><code class="p">,</code> <code class="n">cmap</code><code class="o">=</code><code class="s1">'RdGy'</code><code class="p">,</code>
                   <code class="n">interpolation</code><code class="o">=</code><code class="s1">'gaussian'</code><code class="p">,</code> <code class="n">aspect</code><code class="o">=</code><code class="s1">'equal'</code><code class="p">)</code>
        <code class="n">plt</code><code class="o">.</code><code class="n">colorbar</code><code class="p">();</code></pre>
<figure><div class="figure" id="fig_0404-density-and-contour-plots_files_in_output_15_0">
<img alt="output 15 0" height="401" src="assets/output_15_0.png" width="600"/>
<h6><span class="label">Figure 28-4. </span>Representing three-dimensional data as an image</h6>
</div></figure>
<p>There are a few potential gotchas with <code>plt.imshow</code>, however:</p>
<ul>
<li>
<p>It doesn’t accept an <em>x</em> and <em>y</em> grid, so you must
manually specify the <em>extent</em> [<em>xmin</em>, <em>xmax</em>, <em>ymin</em>, <em>ymax</em>] of the
image on the plot.</p>
</li>
<li>
<p>By default it follows the standard image array definition where the
origin is in the upper left, not in the lower left as in most contour
plots. This must be changed when showing gridded data.</p>
</li>
<li>
<p>It will automatically adjust the axis aspect ratio to match the input
data; this can be changed with the <code>aspect</code> argument.</p>
</li>
</ul>
<p>Finally, it can sometimes be useful to combine contour plots and image
plots. For example, here we’ll use a partially transparent
background image (with transparency set via the <code>alpha</code> parameter) and
overplot contours with labels on the contours themselves, using the
<code>plt.clabel</code> function (see <a data-type="xref" href="#fig_0404-density-and-contour-plots_files_in_output_18_0">Figure 28-5</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">contours</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">contour</code><code class="p">(</code><code class="n">X</code><code class="p">,</code> <code class="n">Y</code><code class="p">,</code> <code class="n">Z</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="n">colors</code><code class="o">=</code><code class="s1">'black'</code><code class="p">)</code>
        <code class="n">plt</code><code class="o">.</code><code class="n">clabel</code><code class="p">(</code><code class="n">contours</code><code class="p">,</code> <code class="n">inline</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code> <code class="n">fontsize</code><code class="o">=</code><code class="mi">8</code><code class="p">)</code>

        <code class="n">plt</code><code class="o">.</code><code class="n">imshow</code><code class="p">(</code><code class="n">Z</code><code class="p">,</code> <code class="n">extent</code><code class="o">=</code><code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code> <code class="n">origin</code><code class="o">=</code><code class="s1">'lower'</code><code class="p">,</code>
                   <code class="n">cmap</code><code class="o">=</code><code class="s1">'RdGy'</code><code class="p">,</code> <code class="n">alpha</code><code class="o">=</code><code class="mf">0.5</code><code class="p">)</code>
        <code class="n">plt</code><code class="o">.</code><code class="n">colorbar</code><code class="p">();</code></pre>
<figure><div class="figure" id="fig_0404-density-and-contour-plots_files_in_output_18_0">
<img alt="output 18 0" height="383" src="assets/output_18_0.png" width="600"/>
<h6><span class="label">Figure 28-5. </span>Labeled contours on top of an image</h6>
</div></figure>
<p>The combination of these three functions—<code>plt.contour</code>, <code>plt.contourf</code>,
and <code>plt.imshow</code>—gives nearly limitless possibilities for displaying
this sort of three-dimensional data within a two-dimensional plot. For
more information on the options available in these functions, refer to
their docstrings. If you are interested in three-dimensional
visualizations of this type of data<a data-startref="ix_ch28-asciidoc8" data-type="indexterm" id="idm45858759709792"/><a data-startref="ix_ch28-asciidoc7" data-type="indexterm" id="idm45858759709088"/><a data-startref="ix_ch28-asciidoc6" data-type="indexterm" id="idm45858759708416"/><a data-startref="ix_ch28-asciidoc5" data-type="indexterm" id="idm45858759655232"/>, see<a data-startref="ix_ch28-asciidoc4" data-type="indexterm" id="idm45858759654496"/>
<a data-type="xref" href="ch35.xhtml#section-0412-three-dimensional-plotting">Chapter 35</a>.</p>
</div></section>
<section data-pdf-bookmark="Histograms, Binnings, and Density" data-type="sect1"><div class="sect1" id="section-0405-histograms-and-binnings">
<h1>Histograms, Binnings, and Density</h1>
<p><a data-primary="histograms" data-type="indexterm" id="ix_ch28-asciidoc9"/><a data-primary="Matplotlib" data-secondary="histograms, binnings, and density" data-type="indexterm" id="ix_ch28-asciidoc10"/><a data-primary="plotting" data-secondary="histograms, binnings, and density" data-type="indexterm" id="ix_ch28-asciidoc11"/>A <a data-primary="histograms" data-secondary="simple" data-type="indexterm" id="ix_ch28-asciidoc12"/><a data-primary="simple histograms" data-type="indexterm" id="ix_ch28-asciidoc13"/>simple histogram can be a great first step in understanding a dataset.
Earlier, we saw a preview of Matplotlib’s histogram function
(discussed in <a data-type="xref" href="ch09.xhtml#section-0206-boolean-arrays-and-masks">Chapter 9</a>), which creates a basic histogram in one line,
once the normal boilerplate imports are done (see <a data-type="xref" href="#fig_0405-histograms-and-binnings_files_in_output_3_0">Figure 28-6</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="o">%</code><code class="k">matplotlib</code> inline
        <code class="kn">import</code> <code class="nn">numpy</code> <code class="k">as</code> <code class="nn">np</code>
        <code class="kn">import</code> <code class="nn">matplotlib.pyplot</code> <code class="k">as</code> <code class="nn">plt</code>
        <code class="n">plt</code><code class="o">.</code><code class="n">style</code><code class="o">.</code><code class="n">use</code><code class="p">(</code><code class="s1">'seaborn-white'</code><code class="p">)</code>

        <code class="n">rng</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">default_rng</code><code class="p">(</code><code class="mi">1701</code><code class="p">)</code>
        <code class="n">data</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">normal</code><code class="p">(</code><code class="n">size</code><code class="o">=</code><code class="mi">1000</code><code class="p">)</code></pre>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">hist</code><code class="p">(</code><code class="n">data</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0405-histograms-and-binnings_files_in_output_3_0">
<img alt="output 3 0" height="386" src="assets/output_3_0.png" width="600"/>
<h6><span class="label">Figure 28-6. </span>A simple histogram</h6>
</div></figure>
<p>The <code>hist</code> function has many options to tune both the calculation and
the display; here’s an example of a more customized
histogram, shown in <a data-type="xref" href="#fig_0405-histograms-and-binnings_files_in_output_5_0">Figure 28-7</a>.</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">hist</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">bins</code><code class="o">=</code><code class="mi">30</code><code class="p">,</code> <code class="n">density</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code> <code class="n">alpha</code><code class="o">=</code><code class="mf">0.5</code><code class="p">,</code>
                 <code class="n">histtype</code><code class="o">=</code><code class="s1">'stepfilled'</code><code class="p">,</code> <code class="n">color</code><code class="o">=</code><code class="s1">'steelblue'</code><code class="p">,</code>
                 <code class="n">edgecolor</code><code class="o">=</code><code class="s1">'none'</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0405-histograms-and-binnings_files_in_output_5_0">
<img alt="output 5 0" height="392" src="assets/output_5_0.png" width="600"/>
<h6><span class="label">Figure 28-7. </span>A customized histogram</h6>
</div></figure>
<p>The <code>plt.hist</code> docstring has more information on other available
customization options. I find this combination of
<code>histtype='stepfilled'</code> along with some
transparency <code>alpha</code> to be helpful when comparing histograms of several
distributions (see <a data-type="xref" href="#fig_0405-histograms-and-binnings_files_in_output_7_0">Figure 28-8</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">x1</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">normal</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mf">0.8</code><code class="p">,</code> <code class="mi">1000</code><code class="p">)</code>
        <code class="n">x2</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">normal</code><code class="p">(</code><code class="o">-</code><code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1000</code><code class="p">)</code>
        <code class="n">x3</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">normal</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">1000</code><code class="p">)</code>

        <code class="n">kwargs</code> <code class="o">=</code> <code class="nb">dict</code><code class="p">(</code><code class="n">histtype</code><code class="o">=</code><code class="s1">'stepfilled'</code><code class="p">,</code> <code class="n">alpha</code><code class="o">=</code><code class="mf">0.3</code><code class="p">,</code> <code class="n">density</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code> <code class="n">bins</code><code class="o">=</code><code class="mi">40</code><code class="p">)</code>

        <code class="n">plt</code><code class="o">.</code><code class="n">hist</code><code class="p">(</code><code class="n">x1</code><code class="p">,</code> <code class="o">**</code><code class="n">kwargs</code><code class="p">)</code>
        <code class="n">plt</code><code class="o">.</code><code class="n">hist</code><code class="p">(</code><code class="n">x2</code><code class="p">,</code> <code class="o">**</code><code class="n">kwargs</code><code class="p">)</code>
        <code class="n">plt</code><code class="o">.</code><code class="n">hist</code><code class="p">(</code><code class="n">x3</code><code class="p">,</code> <code class="o">**</code><code class="n">kwargs</code><code class="p">);</code></pre>
<figure><div class="figure" id="fig_0405-histograms-and-binnings_files_in_output_7_0">
<img alt="output 7 0" height="391" src="assets/output_7_0.png" width="600"/>
<h6><span class="label">Figure 28-8. </span>Overplotting multiple histograms<sup><a data-type="noteref" href="ch28.xhtml#idm45858759342144" id="idm45858759342144-marker">1</a></sup></h6>
</div></figure>
<p>If you are interested in computing, but not displaying, the histogram
(that is, counting the number of points in a given bin), you can use the
<code>np.histogram</code> function:<a data-startref="ix_ch28-asciidoc13" data-type="indexterm" id="idm45858759339968"/><a data-startref="ix_ch28-asciidoc12" data-type="indexterm" id="idm45858759339232"/></p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">counts</code><code class="p">,</code> <code class="n">bin_edges</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">histogram</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">bins</code><code class="o">=</code><code class="mi">5</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">counts</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="p">[</code> <code class="mi">23</code> <code class="mi">241</code> <code class="mi">491</code> <code class="mi">224</code>  <code class="mi">21</code><code class="p">]</code></pre>
</div></section>
<section data-pdf-bookmark="Two-Dimensional Histograms and Binnings" data-type="sect1"><div class="sect1" id="ch_0405-histograms-and-binnings_two-dimensional-histograms-and-binnings">
<h1>Two-Dimensional Histograms and Binnings</h1>
<p><a data-primary="histograms" data-secondary="two-dimensional" data-type="indexterm" id="ix_ch28-asciidoc14"/>Just as we create histograms in one dimension by dividing the number
line into bins, we can also create histograms in two dimensions by
dividing points among two-dimensional bins. We’ll take a
brief look at several ways to do this. Let’s start by
defining some data—an <code>x</code> and <code>y</code> array drawn from a multivariate
Gaussian distribution:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">mean</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">]</code>
        <code class="n">cov</code> <code class="o">=</code> <code class="p">[[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]]</code>
        <code class="n">x</code><code class="p">,</code> <code class="n">y</code> <code class="o">=</code> <code class="n">rng</code><code class="o">.</code><code class="n">multivariate_normal</code><code class="p">(</code><code class="n">mean</code><code class="p">,</code> <code class="n">cov</code><code class="p">,</code> <code class="mi">10000</code><code class="p">)</code><code class="o">.</code><code class="n">T</code></pre>
<section data-pdf-bookmark="plt.hist2d: Two-Dimensional Histogram" data-type="sect2"><div class="sect2" id="ch_0405-histograms-and-binnings_plt.hist2d-two-dimensional-histogram">
<h2>plt.hist2d: Two-Dimensional Histogram</h2>
<p><a data-primary="histograms" data-secondary="plt.hist2d() function" data-type="indexterm" id="idm45858759208976"/><a data-primary="plt.hist2d() function" data-type="indexterm" id="idm45858759208032"/>One straightforward way to plot a two-dimensional histogram is to use
Matplotlib’s <code>plt.hist2d</code> function (see <a data-type="xref" href="#fig_0405-histograms-and-binnings_files_in_output_13_0">Figure 28-9</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">hist2d</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">bins</code><code class="o">=</code><code class="mi">30</code><code class="p">)</code>
        <code class="n">cb</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">colorbar</code><code class="p">()</code>
        <code class="n">cb</code><code class="o">.</code><code class="n">set_label</code><code class="p">(</code><code class="s1">'counts in bin'</code><code class="p">)</code></pre>
<figure><div class="figure" id="fig_0405-histograms-and-binnings_files_in_output_13_0">
<img alt="output 13 0" height="392" src="assets/output_13_0.png" width="600"/>
<h6><span class="label">Figure 28-9. </span>A two-dimensional histogram with plt.hist2d</h6>
</div></figure>
<p>Just like <code>plt.hist</code>, <code>plt.hist2d</code> has a number of extra options to
fine-tune the plot and the binning, which are nicely outlined in the
function docstring. Further, just as <code>plt.hist</code> has a counterpart in
<code>np.histogram</code>, <code>plt.hist2d</code> has a counterpart in <code>np.histogram2d</code>:</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">counts</code><code class="p">,</code> <code class="n">xedges</code><code class="p">,</code> <code class="n">yedges</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">histogram2d</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">bins</code><code class="o">=</code><code class="mi">30</code><code class="p">)</code>
        <code class="nb">print</code><code class="p">(</code><code class="n">counts</code><code class="o">.</code><code class="n">shape</code><code class="p">)</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="p">(</code><code class="mi">30</code><code class="p">,</code> <code class="mi">30</code><code class="p">)</code></pre>
<p>For the generalization of this histogram binning when there are more
than two dimensions, see the <code>np.histogramdd</code> function.</p>
</div></section>
<section data-pdf-bookmark="plt.hexbin: Hexagonal Binnings" data-type="sect2"><div class="sect2" id="ch_0405-histograms-and-binnings_plt.hexbin-hexagonal-binnings">
<h2>plt.hexbin: Hexagonal Binnings</h2>
<p><a data-primary="binnings" data-type="indexterm" id="idm45858759113856"/><a data-primary="hexagonal binnings" data-type="indexterm" id="idm45858759113152"/><a data-primary="histograms" data-secondary="plt.hexbin() function" data-type="indexterm" id="idm45858759112480"/>The two-dimensional histogram creates a tesselation of squares across
the axes. Another natural shape for such a tesselation is the regular
hexagon. For this purpose, Matplotlib provides the <code>plt.hexbin</code> routine,
which represents a two-dimensional dataset binned within a grid of
hexagons (see <a data-type="xref" href="#fig_0405-histograms-and-binnings_files_in_output_18_0">Figure 28-10</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">plt</code><code class="o">.</code><code class="n">hexbin</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">,</code> <code class="n">gridsize</code><code class="o">=</code><code class="mi">30</code><code class="p">)</code>
        <code class="n">cb</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">colorbar</code><code class="p">(</code><code class="n">label</code><code class="o">=</code><code class="s1">'count in bin'</code><code class="p">)</code></pre>
<figure><div class="figure" id="fig_0405-histograms-and-binnings_files_in_output_18_0">
<img alt="output 18 0" height="383" src="assets/output_18_0.png" width="600"/>
<h6><span class="label">Figure 28-10. </span>A two-dimensional histogram with plt.hexbin</h6>
</div></figure>
<p><code>plt.hexbin</code> has a number of additional options, including the ability
to specify weights for each point and to change the output in each bin
to any NumPy aggregate (mean of weights, standard deviation of weights,
etc.).</p>
</div></section>
<section data-pdf-bookmark="Kernel Density Estimation" data-type="sect2"><div class="sect2" id="ch_0405-histograms-and-binnings_kernel-density-estimation">
<h2>Kernel Density Estimation</h2>
<p><a data-primary="histograms" data-secondary="kernel density estimation and" data-type="indexterm" id="idm45858759033200"/><a data-primary="kernel density estimation (KDE)" data-secondary="Matplotlib" data-type="indexterm" id="idm45858759032032"/>Another common method for estimating and representing densities in
multiple dimensions is <em>kernel density estimation</em> (KDE). This will be
discussed more fully in
<a data-type="xref" href="ch49.xhtml#section-0513-kernel-density-estimation">Chapter 49</a>, but for now I’ll simply mention that KDE can be
thought of as a way to “smear out” the points in space and add up the
result to obtain a smooth function. One extremely quick and simple KDE
implementation exists in the <code>scipy.stats</code> package. Here is a quick
example of using KDE (see <a data-type="xref" href="#fig_0405-histograms-and-binnings_files_in_output_21_0">Figure 28-11</a>).</p>
<pre data-code-language="ipython" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">10</code><code class="p">]:</code> <code class="kn">from</code> <code class="nn">scipy.stats</code> <code class="kn">import</code> <code class="n">gaussian_kde</code>

         <code class="c1"># fit an array of size [Ndim, Nsamples]</code>
         <code class="n">data</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">vstack</code><code class="p">([</code><code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">])</code>
         <code class="n">kde</code> <code class="o">=</code> <code class="n">gaussian_kde</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>

         <code class="c1"># evaluate on a regular grid</code>
         <code class="n">xgrid</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="o">-</code><code class="mf">3.5</code><code class="p">,</code> <code class="mf">3.5</code><code class="p">,</code> <code class="mi">40</code><code class="p">)</code>
         <code class="n">ygrid</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="o">-</code><code class="mi">6</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">40</code><code class="p">)</code>
         <code class="n">Xgrid</code><code class="p">,</code> <code class="n">Ygrid</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">meshgrid</code><code class="p">(</code><code class="n">xgrid</code><code class="p">,</code> <code class="n">ygrid</code><code class="p">)</code>
         <code class="n">Z</code> <code class="o">=</code> <code class="n">kde</code><code class="o">.</code><code class="n">evaluate</code><code class="p">(</code><code class="n">np</code><code class="o">.</code><code class="n">vstack</code><code class="p">([</code><code class="n">Xgrid</code><code class="o">.</code><code class="n">ravel</code><code class="p">(),</code> <code class="n">Ygrid</code><code class="o">.</code><code class="n">ravel</code><code class="p">()]))</code>

         <code class="c1"># Plot the result as an image</code>
         <code class="n">plt</code><code class="o">.</code><code class="n">imshow</code><code class="p">(</code><code class="n">Z</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="n">Xgrid</code><code class="o">.</code><code class="n">shape</code><code class="p">),</code>
                    <code class="n">origin</code><code class="o">=</code><code class="s1">'lower'</code><code class="p">,</code> <code class="n">aspect</code><code class="o">=</code><code class="s1">'auto'</code><code class="p">,</code>
                    <code class="n">extent</code><code class="o">=</code><code class="p">[</code><code class="o">-</code><code class="mf">3.5</code><code class="p">,</code> <code class="mf">3.5</code><code class="p">,</code> <code class="o">-</code><code class="mi">6</code><code class="p">,</code> <code class="mi">6</code><code class="p">])</code>
         <code class="n">cb</code> <code class="o">=</code> <code class="n">plt</code><code class="o">.</code><code class="n">colorbar</code><code class="p">()</code>
         <code class="n">cb</code><code class="o">.</code><code class="n">set_label</code><code class="p">(</code><code class="s2">"density"</code><code class="p">)</code></pre>
<figure><div class="figure" id="fig_0405-histograms-and-binnings_files_in_output_21_0">
<img alt="output 21 0" height="392" src="assets/output_21_0.png" width="600"/>
<h6><span class="label">Figure 28-11. </span>A kernel density representation of a distribution</h6>
</div></figure>
<p>KDE has a smoothing length that effectively slides the knob between
detail and smoothness (one example of the ubiquitous bias–variance
trade-off). The literature on choosing an appropriate smoothing length
is vast; <code>gaussian_kde</code> uses a rule of thumb to attempt to find a nearly
optimal smoothing length for the input data.</p>
<p>Other KDE implementations are available within the SciPy ecosystem, each
with its own strengths and weaknesses; see, for example,
<code>sklearn.neighbors.KernelDensity</code> and
<code>statsmodels.nonparametric.KDEMultivariate</code>.</p>
<p>For visualizations based on
KDE, using Matplotlib tends to be overly verbose. The Seaborn library,
discussed in <a data-type="xref" href="ch36.xhtml#section-0414-visualization-with-seaborn">Chapter 36</a>, provides a much more compact API for creating KDE-based<a data-startref="ix_ch28-asciidoc14" data-type="indexterm" id="idm45858758846480"/>
visualizations<a data-startref="ix_ch28-asciidoc11" data-type="indexterm" id="idm45858758845680"/><a data-startref="ix_ch28-asciidoc10" data-type="indexterm" id="idm45858758844976"/><a data-startref="ix_ch28-asciidoc9" data-type="indexterm" id="idm45858758844304"/><a data-startref="ix_ch28-asciidoc3" data-type="indexterm" id="idm45858758843632"/>.<a data-startref="ix_ch28-asciidoc2" data-type="indexterm" id="idm45858758842832"/><a data-startref="ix_ch28-asciidoc1" data-type="indexterm" id="idm45858758842128"/><a data-startref="ix_ch28-asciidoc0" data-type="indexterm" id="idm45858758841456"/></p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45858759342144"><sup><a href="ch28.xhtml#idm45858759342144-marker">1</a></sup> A full-color version of this figure can be found on <a href="https://oreil.ly/PDSH_GitHub">GitHub</a>.</p></div></div></section></div></body></html>