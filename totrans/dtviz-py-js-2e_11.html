<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 7. Introduction to NumPy" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter_numpy">
<h1><span class="label">Chapter 7. </span>Introduction to NumPy</h1>
<p>This chapter aims to introduce the Numeric Python library (NumPy) to those unacquainted.<a data-primary="NumPy" data-type="indexterm" id="ix_NmPy"/> NumPy is the key building block of pandas, the powerhouse data analysis library that we will be using in the upcoming chapters to clean and explore our recently scraped Nobel Prize dataset (see <a data-type="xref" href="ch06.xhtml#chapter_heavy_scraping">Chapter 6</a>). A basic understanding of NumPy’s core elements and principles is important if you are to get the most out of pandas. Therefore, the emphasis of the chapter is to provide a foundation for the upcoming introduction to pandas.<a data-primary="NumPy" data-secondary="about" data-type="indexterm" id="idm45607782331936"/></p>
<p>NumPy is a Python module that allows access to very fast, multidimensional array manipulation, implemented by low-level libraries written in C and Fortran.<sup><a data-type="noteref" href="ch07.xhtml#idm45607782330608" id="idm45607782330608-marker">1</a></sup> Python’s native performance with large quantities of data is relatively slow, but NumPy allows you to perform parallel operations on large arrays all at once, making it very fast.   Given that NumPy is the chief building block of most of the heavyweight Python data-processing libraries, pandas included, it’s hard to argue with its status as linchpin of the Python data-processing world.</p>
<p>In addition to pandas, NumPy’s <a data-primary="SciPy library (Python)" data-type="indexterm" id="idm45607782329536"/>huge ecosystem includes Science Python (SciPy), which supplements NumPy with hardcore science and engineering modules;  scikit-learn, which adds a host of modern machine-learning algorithms in such domains as classification and feature extraction; and many other specialized libraries that use NumPy’s multidimensional arrays as their primary data objects.<a data-primary="multidimensional arrays (NumPy)" data-secondary="use by other specialized libraries" data-type="indexterm" id="idm45607782328704"/> In this sense, basic NumPy mastery can massively extend your Python range in the data-processing realm.</p>
<p>The key to understanding NumPy is its arrays.<a data-primary="arrays" data-secondary="NumPy" data-type="indexterm" id="ix_arryNumP"/><a data-primary="NumPy" data-secondary="arrays" data-type="indexterm" id="ix_NmPyarry"/> If you understand how these work and how to manipulate them, then a lot of other stuff should follow painlessly.<sup><a data-type="noteref" href="ch07.xhtml#idm45607782324304" id="idm45607782324304-marker">2</a></sup> The next few sections will cover basic array manipulation with a few examples of NumPy in action, setting the scene for the introduction of pandas’s datasets in <a data-type="xref" href="ch08.xhtml#chapter_intro_to_pandas">Chapter 8</a>.</p>
<section data-pdf-bookmark="The NumPy Array" data-type="sect1"><div class="sect1" id="idm45607782322704">
<h1>The NumPy Array</h1>
<p>Everything in NumPy is built around its homogeneous<sup><a data-type="noteref" href="ch07.xhtml#idm45607782320288" id="idm45607782320288-marker">3</a></sup>, multidimensional <code>ndarray</code> object. Operations on these arrays are performed using very fast, compiled libraries, allowing NumPy to massively outperform native Python.<a data-primary="NumPy" data-secondary="arrays" data-tertiary="arithmetic on" data-type="indexterm" id="idm45607782319184"/><a data-primary="arrays" data-secondary="NumPy" data-tertiary="arithmetic on" data-type="indexterm" id="idm45607782317936"/> Among other things you can perform standard arithmetic on these arrays, much as you would a Python <code>int</code> or <code>float</code>.<sup><a data-type="noteref" href="ch07.xhtml#idm45607782315648" id="idm45607782315648-marker">4</a></sup> In the following code, a whole array is added to itself as easily and as quickly as adding two integers:</p>
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code><code> </code><code class="nn">numpy</code><code> </code><code class="k">as</code><code> </code><code class="nn">np</code><code> </code><a class="co" href="#callout_introduction_to_numpy_CO1-1" id="co_introduction_to_numpy_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>
</code><code class="n">a</code><code> </code><code class="o">=</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">3</code><code class="p">]</code><code class="p">)</code><code> </code><a class="co" href="#callout_introduction_to_numpy_CO1-2" id="co_introduction_to_numpy_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
</code><code class="n">a</code><code> </code><code class="o">+</code><code> </code><code class="n">a</code><code>
</code><code class="c1"># output array([2, 4, 6])</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_introduction_to_numpy_CO1-1" id="callout_introduction_to_numpy_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The standard way to use the NumPy library and much preferred to <code>"from numpy import *"</code>.<sup><a data-type="noteref" href="ch07.xhtml#idm45607782280784" id="idm45607782280784-marker">5</a></sup></p></dd>
<dt><a class="co" href="#co_introduction_to_numpy_CO1-2" id="callout_introduction_to_numpy_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Automatically converts a Python list of numbers.<a data-primary="imports" data-secondary="importing NumPy" data-type="indexterm" id="idm45607782277328"/></p></dd>
</dl>
<p>Behind the scenes, NumPy can leverage the massively parallel computation available to modern CPUs allowing, for example, large matrices (2D arrays) to be crunched in acceptable times.</p>
<p>The key properties of the NumPy <code>ndarray</code> are its number of dimensions (<code>ndim</code>), shape (<code>shape</code>), and numeric type (<code>dtype</code>). <a data-primary="arrays" data-secondary="NumPy" data-tertiary="number of dimensions, shape, and numeric type" data-type="indexterm" id="idm45607782244800"/><a data-primary="NumPy" data-secondary="arrays" data-tertiary="number of dimensions, shape, and numeric type" data-type="indexterm" id="idm45607782243552"/><a data-primary="shape (NumPy arrays)" data-type="indexterm" id="idm45607782242368"/><a data-primary="dimensions (NumPy arrays)" data-type="indexterm" id="idm45607782241696"/><a data-primary="numeric type (NumPy arrays)" data-type="indexterm" id="idm45607782241008"/><a data-primary="arrays" data-secondary="NumPy" data-tertiary="reshaping a one-dimensional array" data-type="indexterm" id="idm45607782240320"/><a data-primary="NumPy" data-secondary="arrays" data-tertiary="reshaping a one-dimensional array" data-type="indexterm" id="idm45607782239088"/>The same array of numbers can be reshaped in place, which will sometimes involve changing the array’s number of dimensions. Let’s demonstrate some reshaping with a little eight-member array. We’ll use a <code>print_array_details</code> method to output the key array properties:</p>
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">print_array_details</code><code class="p">(</code><code class="n">a</code><code class="p">):</code>
    <code class="nb">print</code><code class="p">(</code><code class="s1">'Dimensions: </code><code class="si">%d</code><code class="s1">, shape: </code><code class="si">%s</code><code class="s1">, dtype: </code><code class="si">%s</code><code class="s1">'</code>\
        <code class="o">%</code><code class="p">(</code><code class="n">a</code><code class="o">.</code><code class="n">ndim</code><code class="p">,</code> <code class="n">a</code><code class="o">.</code><code class="n">shape</code><code class="p">,</code> <code class="n">a</code><code class="o">.</code><code class="n">dtype</code><code class="p">))</code></pre>
<p>First, we’ll create our one-dimensional array. As the printed details show, by default <a data-primary="numeric type (NumPy arrays)" data-secondary="64-bit integer type" data-type="indexterm" id="idm45607782179696"/>this has a 64-bit integer numeric type (<code>int64</code>):</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">])</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">a</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">2</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">])</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">3</code><code class="p">]:</code> <code class="n">print_array_details</code><code class="p">(</code><code class="n">a</code><code class="p">)</code>
<code class="n">Dimensions</code><code class="p">:</code> <code class="mi">1</code><code class="p">,</code> <code class="n">shape</code><code class="p">:</code> <code class="p">(</code><code class="mi">8</code><code class="p">,),</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>Using the <code>reshape</code> method, we can change the shape and number of dimensions of <code>a</code>. Let’s reshape <code>a</code> into a two-dimensional array <a data-primary="two-dimensional arrays (NumPy)" data-type="indexterm" id="idm45607782088304"/>composed of two four-member arrays:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">4</code><code class="p">]:</code> <code class="n">a</code> <code class="o">=</code> <code class="n">a</code><code class="o">.</code><code class="n">reshape</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">])</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">5</code><code class="p">]:</code> <code class="n">a</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]:</code>
<code class="n">array</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code>
       <code class="p">[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">]])</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">6</code><code class="p">]:</code> <code class="n">print_array_details</code><code class="p">(</code><code class="n">a</code><code class="p">)</code>
<code class="n">Dimensions</code><code class="p">:</code> <code class="mi">2</code><code class="p">,</code> <code class="n">shape</code><code class="p">:</code> <code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">),</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>An eight-member array can also be reshaped <a data-primary="three-dimensional arrays (NumPy)" data-type="indexterm" id="idm45607782053312"/>into a three-dimensional array:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">7</code><code class="p">]:</code> <code class="n">a</code> <code class="o">=</code> <code class="n">a</code><code class="o">.</code><code class="n">reshape</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">])</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">8</code><code class="p">]:</code> <code class="n">a</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">8</code><code class="p">]:</code>
<code class="n">array</code><code class="p">([[[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code>
        <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">]],</code>

       <code class="p">[[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code>
        <code class="p">[</code><code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">]]])</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">9</code><code class="p">]:</code> <code class="n">print_array_details</code><code class="p">(</code><code class="n">a</code><code class="p">)</code>
<code class="n">Dimensions</code><code class="p">:</code> <code class="mi">3</code><code class="p">,</code> <code class="n">shape</code><code class="p">:</code> <code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">),</code> <code class="n">dtype</code><code class="p">:</code> <code class="n">int64</code></pre>
<p>The shape and numeric type can be specified on creation of the array or later. The easiest way to change an array’s <a data-primary="numeric type (NumPy arrays)" data-secondary="changing with astype method" data-type="indexterm" id="idm45607781956784"/><a data-primary="astype method" data-type="indexterm" id="idm45607781872528"/>numeric type is by using the <code>astype</code> method to make a resized copy of the original with the new type:<sup><a data-type="noteref" href="ch07.xhtml#idm45607781871408" id="idm45607781871408-marker">6</a></sup></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="p">:</code><code> </code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="p">[</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">3</code><code class="p">]</code><code class="p">,</code><code> </code><code class="p">[</code><code class="mi">4</code><code class="p">,</code><code> </code><code class="mi">5</code><code class="p">,</code><code> </code><code class="mi">6</code><code class="p">]</code><code class="p">]</code><code class="p">,</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">int32</code><code class="p">)</code><code> </code><a class="co" href="#callout_introduction_to_numpy_CO2-1" id="co_introduction_to_numpy_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="p">:</code><code> </code><code class="n">x</code><code class="o">.</code><code class="n">shape</code><code>
</code><code class="n">Out</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="p">:</code><code> </code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">3</code><code class="p">)</code><code>
</code><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="p">:</code><code> </code><code class="n">x</code><code class="o">.</code><code class="n">shape</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="mi">6</code><code class="p">,</code><code class="p">)</code><code>
</code><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="p">:</code><code> </code><code class="n">x</code><code>
</code><code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="p">:</code><code> </code><code class="n">array</code><code class="p">(</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">3</code><code class="p">,</code><code> </code><code class="mi">4</code><code class="p">,</code><code> </code><code class="mi">5</code><code class="p">,</code><code> </code><code class="mi">6</code><code class="p">]</code><code class="p">,</code><code> </code><code class="n">dtype</code><code class="o">=</code><code class="n">int32</code><code class="p">)</code><code>
</code><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">4</code><code class="p">]</code><code>  </code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="n">x</code><code class="o">.</code><code class="n">astype</code><code class="p">(</code><code class="s1">'</code><code class="s1">int64</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">In</code><code> </code><code class="p">[</code><code class="mi">5</code><code class="p">]</code><code class="p">:</code><code> </code><code class="n">x</code><code class="o">.</code><code class="n">dtype</code><code>
</code><code class="n">Out</code><code class="p">[</code><code class="mi">5</code><code class="p">]</code><code class="p">:</code><code> </code><code class="n">dtype</code><code class="p">(</code><code class="s1">'</code><code class="s1">int64</code><code class="s1">'</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_introduction_to_numpy_CO2-1" id="callout_introduction_to_numpy_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>The array will convert a nested list of numbers into a suitably shaped multidimensional form.</p></dd>
</dl>
<section data-pdf-bookmark="Creating Arrays" data-type="sect2"><div class="sect2" id="idm45607781691440">
<h2>Creating Arrays</h2>
<p>As well as creating arrays with lists of numbers, NumPy provides some utility functions to create arrays with a specific shape.<a data-primary="arrays" data-secondary="NumPy" data-tertiary="creating" data-type="indexterm" id="idm45607781713792"/><a data-primary="NumPy" data-secondary="arrays" data-tertiary="creating" data-type="indexterm" id="idm45607781712544"/> <code>zeros</code> and <code>ones</code> are the most common functions used, creating prefilled arrays. <a data-primary="zeros method (NumPy)" data-type="indexterm" id="idm45607781710336"/><a data-primary="ones method (NumPy)" data-type="indexterm" id="idm45607781709632"/>Here’s a couple of examples. <a data-primary="numeric type (NumPy arrays)" data-secondary="dtype (default type)" data-type="indexterm" id="idm45607781708832"/>Note that the default <code>dtype</code> of these methods is a 64-bit float (<code>float64</code>):</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">32</code><code class="p">]:</code> <code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">zeros</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">])</code>
<code class="n">In</code> <code class="p">[</code><code class="mi">33</code><code class="p">]:</code> <code class="n">a</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">33</code><code class="p">]:</code>
<code class="n">array</code><code class="p">([[</code> <code class="mf">0.</code><code class="p">,</code>  <code class="mf">0.</code><code class="p">,</code>  <code class="mf">0.</code><code class="p">],</code>
       <code class="p">[</code> <code class="mf">0.</code><code class="p">,</code>  <code class="mf">0.</code><code class="p">,</code>  <code class="mf">0.</code><code class="p">]])</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">34</code><code class="p">]:</code> <code class="n">a</code><code class="o">.</code><code class="n">dtype</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">34</code><code class="p">]:</code> <code class="n">dtype</code><code class="p">(</code><code class="s1">'float64'</code><code class="p">)</code>

<code class="n">In</code> <code class="p">[</code><code class="mi">35</code><code class="p">]:</code> <code class="n">np</code><code class="o">.</code><code class="n">ones</code><code class="p">([</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">35</code><code class="p">]:</code>
<code class="n">array</code><code class="p">([[</code> <code class="mf">1.</code><code class="p">,</code>  <code class="mf">1.</code><code class="p">,</code>  <code class="mf">1.</code><code class="p">],</code>
       <code class="p">[</code> <code class="mf">1.</code><code class="p">,</code>  <code class="mf">1.</code><code class="p">,</code>  <code class="mf">1.</code><code class="p">]])</code></pre>
<p>The faster <code>empty</code> method just takes a memory block without the fill overhead, leaving the initialization up to you. <a data-primary="empty method, creating NumPy array" data-type="indexterm" id="idm45607781621008"/>This means you don’t know and can’t guarantee what values the array has, unlike <code>np.zeros</code>, so use with caution:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">empty_array</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">empty</code><code class="p">((</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">))</code> <code class="c1"># create an uninitialized array</code>

<code class="n">empty_array</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">3</code><code class="p">]:</code>
<code class="n">array</code><code class="p">([[</code>  <code class="mf">6.93185732e-310</code><code class="p">,</code>   <code class="mf">2.52008024e-316</code><code class="p">,</code>   <code class="mf">4.71690401e-317</code><code class="p">],</code>
       <code class="p">[</code>  <code class="mf">2.38085057e-316</code><code class="p">,</code>   <code class="mf">6.93185752e-310</code><code class="p">,</code>   <code class="mf">6.93185751e-310</code><code class="p">]])</code></pre>
<p>Another useful utility function is <code>random</code>, found along with some useful siblings in NumPy’s  <code>random</code> module. <a data-primary="random method (NumPy)" data-type="indexterm" id="idm45607781495376"/>This creates a shaped random array:</p>
<pre data-code-language="python" data-type="programlisting"><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">random</code><code class="o">.</code><code class="n">random</code><code class="p">(</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><code class="n">Out</code><code class="p">:</code><code>
</code><code class="n">array</code><code class="p">(</code><code class="p">[</code><code class="p">[</code><code> </code><code class="mf">0.97519667</code><code class="p">,</code><code>  </code><code class="mf">0.94934859</code><code class="p">,</code><code>  </code><code class="mf">0.98379541</code><code class="p">]</code><code class="p">,</code><code> </code><a class="co" href="#callout_introduction_to_numpy_CO3-1" id="co_introduction_to_numpy_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>       </code><code class="p">[</code><code> </code><code class="mf">0.10407003</code><code class="p">,</code><code>  </code><code class="mf">0.35752882</code><code class="p">,</code><code>  </code><code class="mf">0.62971186</code><code class="p">]</code><code class="p">]</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_introduction_to_numpy_CO3-1" id="callout_introduction_to_numpy_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>A 2×3 array of random numbers within the range 0 <code>&lt;=</code> x &lt; 1.</p></dd>
</dl>
<p>The handy <code>linspace</code> creates a specified number of evenly spaced samples over a set interval. <code>arange</code> is similar but uses a step-size argument:<a data-primary="arrange method (NumPy)" data-type="indexterm" id="idm45607781423824"/><a data-primary="linespace method (NumPy)" data-type="indexterm" id="idm45607781423120"/></p>
<pre data-code-language="python" data-type="programlisting"><code class="n">np</code><code class="o">.</code><code class="n">linspace</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">10</code><code class="p">,</code><code> </code><code class="mi">5</code><code class="p">)</code><code> </code><code class="c1"># 5 numbers in range 2-10</code><code>
</code><code class="n">Out</code><code class="p">:</code><code> </code><code class="n">array</code><code class="p">(</code><code class="p">[</code><code class="mf">2.</code><code class="p">,</code><code> </code><code class="mf">4.</code><code class="p">,</code><code class="mf">6.</code><code class="p">,</code><code> </code><code class="mf">8.</code><code class="p">,</code><code> </code><code class="mf">10.</code><code class="p">]</code><code class="p">)</code><code> </code><a class="co" href="#callout_introduction_to_numpy_CO4-1" id="co_introduction_to_numpy_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code>
</code><code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">10</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="p">)</code><code> </code><code class="c1"># from 2 to 10 (exlusive) with step-size 2.</code><code>
</code><code class="n">Out</code><code class="p">:</code><code> </code><code class="n">array</code><code class="p">(</code><code class="p">[</code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">4</code><code class="p">,</code><code> </code><code class="mi">6</code><code class="p">,</code><code> </code><code class="mi">8</code><code class="p">]</code><code class="p">)</code></pre>
<p>Note that unlike <code>arange</code>, <code>linspace</code> is inclusive of the upper value and that the array’s datatype is the default <code>float64</code>.</p>
</div></section>
<section data-pdf-bookmark="Array Indexing and Slicing" data-type="sect2"><div class="sect2" id="idm45607781690848">
<h2>Array Indexing and Slicing</h2>
<p>One-dimensional arrays are indexed and sliced much as <a data-primary="arrays" data-secondary="NumPy" data-tertiary="indexing and slicing" data-type="indexterm" id="idm45607781334848"/><a data-primary="NumPy" data-secondary="arrays" data-tertiary="indexing and slicing" data-type="indexterm" id="idm45607781333600"/><a data-primary="indexing NumPy arrays" data-type="indexterm" id="idm45607781332384"/><a data-primary="slicing arrays" data-type="indexterm" id="idm45607781331712"/>Python lists:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">])</code>
<code class="n">a</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="c1"># Out: 3</code>
<code class="n">a</code><code class="p">[</code><code class="mi">3</code><code class="p">:</code><code class="mi">5</code><code class="p">]</code> <code class="c1"># Out: array([4, 5])</code>
<code class="c1"># every second item from 0-4 set to 0</code>
<code class="n">a</code><code class="p">[:</code><code class="mi">4</code><code class="p">:</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code> <code class="c1"># Out: array([0, 2, 0, 4, 5, 6])</code>
<code class="n">a</code><code class="p">[::</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code> <code class="c1"># Out: array([6, 5, 4, 0, 2, 0]), reversed</code></pre>
<p>Indexing multidimensional arrays is similar to the <em>1-D</em> form. <a data-primary="multidimensional arrays (NumPy)" data-secondary="indexing and slicing" data-type="indexterm" id="idm45607781253632"/>Each dimension has its own indexing/slicing operation and these are specified in a comma-separated tuple.<sup><a data-type="noteref" href="ch07.xhtml#idm45607781252528" id="idm45607781252528-marker">7</a></sup> <a data-type="xref" href="#numpy_indexing">Figure 7-1</a> shows how this works.</p>
<figure><div class="figure" id="numpy_indexing">
<img alt="dpj2 0701" height="555" src="assets/dpj2_0701.png" width="863"/>
<h6><span class="label">Figure 7-1. </span>Multidimensional indexing with NumPy</h6>
</div></figure>
<p>Note that if the number of objects in the selection tuple is less than the number of dimensions, the remaining dimensions are assumed to be fully selected (:). Ellipsis can also be used as a shorthand for full selection of all indices, expanding to the required number of : objects. We will use a three-dimensional array to demonstrate:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">8</code><code class="p">)</code>
<code class="n">a</code><code class="o">.</code><code class="n">shape</code> <code class="o">=</code> <code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>
<code class="n">a</code>
<code class="n">Out</code><code class="p">:</code>
<code class="n">array</code><code class="p">([[[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code>
        <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]],</code>

       <code class="p">[[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code>
        <code class="p">[</code><code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">]]])</code></pre>
<p>NumPy has a handy <code>array_equal</code> method, which compares arrays by shape and elements. <a data-primary="array_equal method (NumPy)" data-type="indexterm" id="idm45607781169632"/>We can use it to show the equivalence of the following array selections, taking the second subarray of axis 0:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">a1</code> <code class="o">=</code> <code class="n">a</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>
<code class="n">a1</code>
<code class="n">Out</code><code class="p">:</code>
<code class="n">array</code><code class="p">([[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code>
       <code class="p">[</code><code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">]])</code></pre>
<p>Testing for equivalence:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">np</code><code class="o">.</code><code class="n">array_equal</code><code class="p">(</code><code class="n">a1</code><code class="p">,</code> <code class="n">a</code><code class="p">[</code><code class="mi">1</code><code class="p">,:])</code>
<code class="n">Out</code><code class="p">:</code> <code class="kc">True</code>

<code class="n">np</code><code class="o">.</code><code class="n">array_equal</code><code class="p">(</code><code class="n">a1</code><code class="p">,</code> <code class="n">a</code><code class="p">[</code><code class="mi">1</code><code class="p">,:,:])</code>
<code class="n">Out</code><code class="p">:</code> <code class="kc">True</code>
<code class="c1"># Taking the first element of the subarrays</code>
<code class="c1"># array([[0, 2], [4, 6]])</code>
<code class="n">np</code><code class="o">.</code><code class="n">array_equal</code><code class="p">(</code><code class="n">a</code><code class="p">[</code><code class="o">...</code><code class="p">,</code><code class="mi">0</code><code class="p">],</code> <code class="n">a</code><code class="p">[:,:,</code><code class="mi">0</code><code class="p">])</code>
<code class="n">Out</code><code class="p">:</code> <code class="kc">True</code></pre>
</div></section>
<section data-pdf-bookmark="A Few Basic Operations" data-type="sect2"><div class="sect2" id="idm45607781335792">
<h2>A Few Basic Operations</h2>
<p>One of the really cool things about NumPy arrays is that you can perform basic (and not so basic) math operations in much the same way that you would with normal numeric variables.<a data-primary="NumPy" data-secondary="arrays" data-tertiary="basic operations with" data-type="indexterm" id="ix_nmPyarryops"/><a data-primary="arrays" data-secondary="NumPy" data-tertiary="basic operations" data-type="indexterm" id="ix_arryNumPops"/> <a data-type="xref" href="#numpy_maths">Figure 7-2</a> shows the use of some overloaded arithmetic operators on a two-dimensional array. <a data-primary="arithmetic operators, use with NumPy arrays" data-type="indexterm" id="idm45607781055696"/>The simple mathematical operations are applied to all members of the array. Note that where the array is divided by a floating-point value (2.0), the result is automatically converted to a float type (<code>float64</code>). Being able to manipulate arrays as easily as <span class="keep-together">single</span> numbers is a huge strength of NumPy and a large part of its expressive power.<a data-primary="math" data-secondary="NumPy array math operations" data-type="indexterm" id="idm45607781008144"/></p>
<figure><div class="figure" id="numpy_maths">
<img alt="dpj2 0702" height="257" src="assets/dpj2_0702.png" width="864"/>
<h6><span class="label">Figure 7-2. </span>A few basic math operations on a two-dimensional NumPy array</h6>
</div></figure>
<p>Boolean operators work in a similar way to the arithmetic ones. <a data-primary="Boolean operators" data-secondary="use with NumPy arrays" data-type="indexterm" id="idm45607781005296"/>As we’ll see in the next chapter, this is a very useful way to create the Boolean masks often used in pandas. Here’s a little example:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">([</code><code class="mi">45</code><code class="p">,</code> <code class="mi">65</code><code class="p">,</code> <code class="mi">76</code><code class="p">,</code> <code class="mi">32</code><code class="p">,</code> <code class="mi">99</code><code class="p">,</code> <code class="mi">22</code><code class="p">])</code>
<code class="n">a</code> <code class="o">&lt;</code> <code class="mi">50</code>
<code class="n">Out</code><code class="p">[</code><code class="mi">69</code><code class="p">]:</code> <code class="n">array</code><code class="p">([</code> <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">,</code> <code class="kc">False</code><code class="p">,</code>  <code class="kc">True</code><code class="p">]</code>
               <code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="nb">bool</code><code class="p">)</code></pre>
<p>Arrays also have a number of useful methods, a selection of which is demonstrated in <a data-type="xref" href="#numpy_array_methods">Example 7-1</a>. <a data-primary="arrays" data-secondary="NumPy" data-tertiary="methods" data-type="indexterm" id="idm45607780961024"/>You can get a comprehensive rundown in <a href="https://oreil.ly/qmnDX">the official NumPy docs</a>.</p>
<div data-type="example" id="numpy_array_methods">
<h5><span class="label">Example 7-1. </span>Some array methods</h5>
<pre data-code-language="python" data-type="programlisting"><code class="n">a</code><code> </code><code class="o">=</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">8</code><code class="p">)</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">4</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="c1"># array([[0, 1, 2, 3],</code><code>
</code><code class="c1">#        [4, 5, 6, 7]])</code><code>
</code><code class="n">a</code><code class="o">.</code><code class="n">min</code><code class="p">(</code><code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code><code>
</code><code class="c1"># array([0, 4])</code><code>
</code><code class="n">a</code><code class="o">.</code><code class="n">sum</code><code class="p">(</code><code class="n">axis</code><code class="o">=</code><code class="mi">0</code><code class="p">)</code><code>
</code><code class="c1"># array([4, 6, 8, 10])</code><code>
</code><code class="n">a</code><code class="o">.</code><code class="n">mean</code><code class="p">(</code><code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code><code> </code><a class="co" href="#callout_introduction_to_numpy_CO4-1" id="co_introduction_to_numpy_CO4-2"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="c1"># array([ 1.5, 5.5 ])</code><code>
</code><code class="n">a</code><code class="o">.</code><code class="n">std</code><code class="p">(</code><code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code><code> </code><a class="co" href="#callout_introduction_to_numpy_CO4-2" id="co_introduction_to_numpy_CO4-3"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
</code><code class="c1"># array([ 1.11803399,  1.11803399])</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_introduction_to_numpy_CO4-1" id="callout_introduction_to_numpy_CO4-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Average along second axis.</p></dd>
<dt><a class="co" href="#co_introduction_to_numpy_CO4-3" id="callout_introduction_to_numpy_CO4-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The standard deviation of [0, 1, 2, 3],…​</p></dd>
</dl></div>
<p>There are also a large number of <a data-primary="functions" data-secondary="array functions in NumPy" data-type="indexterm" id="idm45607780864096"/>built-in array functions. <a data-type="xref" href="#numpy_maths2">Example 7-2</a> demonstrates a selection of these, and you will find a comprehensive list of NumPy’s built-in mathematical routines <a href="https://oreil.ly/vvfzm">at the official NumPy site</a>.<a data-primary="math" data-secondary="NumPy array math functions" data-type="indexterm" id="idm45607780861328"/></p>
<div data-type="example" id="numpy_maths2">
<h5><span class="label">Example 7-2. </span>Some NumPy array math functions</h5>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># Trigonometric functions</code><code>
</code><code class="n">pi</code><code> </code><code class="o">=</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">pi</code><code>
</code><code class="n">a</code><code> </code><code class="o">=</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">array</code><code class="p">(</code><code class="p">[</code><code class="n">pi</code><code class="p">,</code><code> </code><code class="n">pi</code><code class="o">/</code><code class="mi">2</code><code class="p">,</code><code> </code><code class="n">pi</code><code class="o">/</code><code class="mi">4</code><code class="p">,</code><code> </code><code class="n">pi</code><code class="o">/</code><code class="mi">6</code><code class="p">]</code><code class="p">)</code><code>
</code><code>
</code><code class="n">np</code><code class="o">.</code><code class="n">degrees</code><code class="p">(</code><code class="n">a</code><code class="p">)</code><code> </code><code class="c1"># radians to degrees</code><code>
</code><code class="c1"># Out: array([ 180., 90., 45., 30.,])</code><code>
</code><code>
</code><code class="n">sin_a</code><code> </code><code class="o">=</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">a</code><code class="p">)</code><code>
</code><code class="c1"># Out: array([  1.22464680e-16,   1.00000000e+00, </code><a class="co" href="#callout_introduction_to_numpy_CO5-1" id="co_introduction_to_numpy_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
</code><code class="c1">#               7.07106781e-01,   5.00000000e-01])</code><code>
</code><code class="c1"># Rounding</code><code>
</code><code class="n">np</code><code class="o">.</code><code class="n">round</code><code class="p">(</code><code class="n">sin_a</code><code class="p">,</code><code> </code><code class="mi">7</code><code class="p">)</code><code> </code><code class="c1"># round to 7 decimal places</code><code>
</code><code class="c1"># Out: array([ 0.,  1.,  0.7071068,  0.5 ])</code><code>
</code><code>
</code><code class="c1"># Sums, products, differences</code><code>
</code><code class="n">a</code><code> </code><code class="o">=</code><code> </code><code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">8</code><code class="p">)</code><code class="o">.</code><code class="n">reshape</code><code class="p">(</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">4</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="c1"># array([[0, 1, 2, 3],</code><code>
</code><code class="c1">#        [4, 5, 6, 7]])</code><code>
</code><code>
</code><code class="n">np</code><code class="o">.</code><code class="n">cumsum</code><code class="p">(</code><code class="n">a</code><code class="p">,</code><code> </code><code class="n">axis</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code><code> </code><code class="c1"># cumulative sum along second axis</code><code>
</code><code class="c1"># array([[ 0,  1,  3,  6],</code><code>
</code><code class="c1">#        [ 4,  9, 15, 22]])</code><code>
</code><code>
</code><code class="n">np</code><code class="o">.</code><code class="n">cumsum</code><code class="p">(</code><code class="n">a</code><code class="p">)</code><code> </code><code class="c1"># without axis argument, array is flattened</code><code>
</code><code class="c1"># array([ 0,  1,  3,  6, 10, 15, 21, 28])</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_introduction_to_numpy_CO5-1" id="callout_introduction_to_numpy_CO5-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Note the floating-point rounding error for sin(pi).<a data-primary="NumPy" data-secondary="arrays" data-startref="ix_nmPyarryops" data-tertiary="basic operations with" data-type="indexterm" id="idm45607780693232"/><a data-primary="arrays" data-secondary="NumPy" data-startref="ix_arryNumPops" data-tertiary="basic operations" data-type="indexterm" id="idm45607780714608"/><a data-primary="NumPy" data-secondary="arrays" data-startref="ix_NmPyarry" data-type="indexterm" id="idm45607780713120"/><a data-primary="arrays" data-secondary="NumPy" data-startref="ix_arryNumP" data-type="indexterm" id="idm45607780711904"/></p></dd>
</dl></div>
</div></section>
</div></section>
<section data-pdf-bookmark="Creating Array Functions" data-type="sect1"><div class="sect1" id="idm45607782322080">
<h1>Creating Array Functions</h1>
<p>Whether you’re using pandas or one of the many Python data-processing libraries, such as SciPy, scikit-learn, or PyTorch, chances are the core data structure being used is the NumPy array. <a data-primary="functions" data-secondary="array functions in NumPy" data-tertiary="creating" data-type="indexterm" id="idm45607780709136"/><a data-primary="arrays" data-secondary="NumPy" data-tertiary="creating array functions" data-type="indexterm" id="idm45607780707920"/><a data-primary="NumPy" data-secondary="arrays" data-tertiary="creating array functions" data-type="indexterm" id="idm45607780659088"/>The ability to craft little array processing functions is therefore a great addition to your data-processing toolkit and the data visualization toolchain. Often a short internet search will turn up a community solution, but there’s a lot of satisfaction to be gained from crafting your own, besides being a great way to learn. Let’s see how we can harness the NumPy array to calculate a <a href="https://oreil.ly/ajLZJ">moving average</a>. A moving average is a series of averages based on a moving window of the last <em>n</em> values, where <em>n</em> is variable, also known as a <em>moving mean</em> or <em>rolling mean</em>.</p>
<section data-pdf-bookmark="Calculating a Moving Average" data-type="sect2"><div class="sect2" id="idm45607780655440">
<h2>Calculating a Moving Average</h2>
<p><a data-type="xref" href="#numpy_moving_average">Example 7-3</a> shows the few lines needed to calculate a moving average  on a one-dimensional NumPy array.<sup><a data-type="noteref" href="ch07.xhtml#idm45607780652944" id="idm45607780652944-marker">8</a></sup>  As you can see, it’s nice and concise, but there’s a fair amount going on in those few lines. Let’s break it down a bit.<a data-primary="moving_average function (NumPy), creating" data-type="indexterm" id="idm45607780651904"/><a data-primary="averages, calculating moving average for NumPy array" data-type="indexterm" id="idm45607780651232"/></p>
<div data-type="example" id="numpy_moving_average">
<h5><span class="label">Example 7-3. </span>A moving average with NumPy</h5>
<pre data-code-language="python" data-type="programlisting"><code class="k">def</code> <code class="nf">moving_average</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">n</code><code class="o">=</code><code class="mi">3</code><code class="p">):</code>
    <code class="n">ret</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">cumsum</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">dtype</code><code class="o">=</code><code class="nb">float</code><code class="p">)</code>
    <code class="n">ret</code><code class="p">[</code><code class="n">n</code><code class="p">:]</code> <code class="o">=</code> <code class="n">ret</code><code class="p">[</code><code class="n">n</code><code class="p">:]</code> <code class="o">-</code> <code class="n">ret</code><code class="p">[:</code><code class="o">-</code><code class="n">n</code><code class="p">]</code>
    <code class="k">return</code> <code class="n">ret</code><code class="p">[</code><code class="n">n</code> <code class="o">-</code> <code class="mi">1</code><code class="p">:]</code> <code class="o">/</code> <code class="n">n</code></pre></div>
<p>The function receives an array <em>a</em> and number <em>n</em> specifying the size of the moving window.</p>
<p>We first calculate the cumulative sum of the array using NumPy’s built-in method:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">6</code><code class="p">)</code>
<code class="c1"># array([0, 1, 2, 3, 4, 5])</code>
<code class="n">csum</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">cumsum</code><code class="p">(</code><code class="n">a</code><code class="p">)</code>
<code class="n">csum</code>
<code class="c1"># Out: array([0, 1, 3, 6, 10, 15])</code></pre>
<p>Starting at the <em>n</em>th index of the cumulative sum array, we subtract the <em>i</em>–<em>n</em>th value for all <em>i</em>, which means <em>i</em> now has the sum of the last <em>n</em> values of
<em>a</em>, inclusive. Here’s an example with a window of size three:</p>
<pre data-code-language="python" data-type="programlisting"><code class="c1"># a = array([0, 1, 2, 3, 4, 5])</code>
<code class="c1"># csum = array([0, 1, 3, 6, 10, 15])</code>
<code class="n">csum</code><code class="p">[</code><code class="mi">3</code><code class="p">:]</code> <code class="o">=</code> <code class="n">csum</code><code class="p">[</code><code class="mi">3</code><code class="p">:]</code> <code class="o">-</code> <code class="n">csum</code><code class="p">[:</code><code class="o">-</code><code class="mi">3</code><code class="p">]</code>
<code class="c1"># csum = array([0, 1, 3, 6, 9, 12])</code></pre>
<p>Comparing the array <code>a</code> with the final array <code>csum</code>, index 5 is now the sum of the window [3, 4, 5].</p>
<p>Because a moving average only makes sense for index (<em>n</em>–1) onward, it only remains to return these values, divided by the window size <em>n</em> to give the average.</p>
<p>The <code>moving_average</code> function takes a bit of time to get but is a good example of the concision and expressiveness that can be achieved with NumPy arrays and array slicing. You could easily write the function in vanilla Python, but it would likely be a fair bit more involved and, crucially, be much slower for arrays of significant size.</p>
<p>Putting the function to work:</p>
<pre data-code-language="python" data-type="programlisting"><code class="n">a</code> <code class="o">=</code> <code class="n">np</code><code class="o">.</code><code class="n">arange</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
<code class="n">moving_average</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="mi">4</code><code class="p">)</code>
<code class="c1"># Out[98]: array([ 1.5,  2.5,  3.5,  4.5,  5.5,  6.5,  7.5])</code></pre>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45607780487424">
<h1>Summary</h1>
<p>This chapter laid the foundations of NumPy, focusing on its building block, the NumPy array or <code>ndarray</code>. Being proficient with NumPy is a core skill for any Pythonista working with data. It underpins most of Python’s hardcore data-processing stack, so for this reason alone, you should be comfortable with its array <span class="keep-together">manipulations</span>.</p>
<p>Being comfortable with NumPy will make pandas work that much easier and open up the rich NumPy ecosystem of scientific, engineering, machine learning, and statistical algorithmics to your pandas workflow. Although pandas hides its NumPy arrays behind data containers such as its DataFrame and Series, which are adapted to deal with heterogeneous data, these containers behave for the most part like NumPy arrays and will generally do the right thing when asked. Knowing that <code>ndarray</code>s are at its core also helps when you are trying to frame problems for pandas—​ultimately the requested data manipulation has to play nicely with NumPy. Now that we’ve got its building blocks in place, let’s see how pandas extends the homogeneous NumPy array into the realm of heterogeneous data, where much of data visualization work takes place.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45607782330608"><sup><a href="ch07.xhtml#idm45607782330608-marker">1</a></sup> Python’s scripted ease of use comes at the cost of raw speed. By wrapping fast, low-level libraries, initiatives like NumPy aim for simple, cruft-free programming and blinding performance.</p><p data-type="footnote" id="idm45607782324304"><sup><a href="ch07.xhtml#idm45607782324304-marker">2</a></sup> NumPy is used to implement some very advanced math, so don’t expect to understand everything you see online—​just the building blocks.</p><p data-type="footnote" id="idm45607782320288"><sup><a href="ch07.xhtml#idm45607782320288-marker">3</a></sup> This means NumPy deals with arrays of the same datatype (dtype) rather than Python lists, for example, which can have strings, numbers, dates, etc.</p><p data-type="footnote" id="idm45607782315648"><sup><a href="ch07.xhtml#idm45607782315648-marker">4</a></sup> This assumes the arrays meet shape and type constraints.</p><p data-type="footnote" id="idm45607782280784"><sup><a href="ch07.xhtml#idm45607782280784-marker">5</a></sup> Importing all module variables into your namespace using <code>*</code> is almost always a bad idea.</p><p data-type="footnote" id="idm45607781871408"><sup><a href="ch07.xhtml#idm45607781871408-marker">6</a></sup> A more memory-efficient and performant way involves manipulating the array’s view, but it does involve some extra steps. See <a href="https://oreil.ly/FOQWt">this Stack Overflow article</a> for some examples and a discussion of the pros and cons.</p><p data-type="footnote" id="idm45607781252528"><sup><a href="ch07.xhtml#idm45607781252528-marker">7</a></sup> There is a shorthand dot notation (e.g., <code>[..1:3]</code>) to select all indices.</p><p data-type="footnote" id="idm45607780652944"><sup><a href="ch07.xhtml#idm45607780652944-marker">8</a></sup> NumPy has a <code>convolve</code> method, which is the easiest way to calculate a simple moving average but less instructive. Also, pandas has a number of specialized methods for this.</p></div></div></section></div></body></html>