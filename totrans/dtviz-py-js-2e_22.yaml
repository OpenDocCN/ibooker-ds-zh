- en: Chapter 16\. Building a Visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 15](ch15.xhtml#chapter_imagining), we used the results of our pandas
    exploration of the Nobel Prize dataset (see [Chapter 11](ch11.xhtml#chapter_pandas_exploring))
    to imagine a visualization. [Figure 16-1](#d3build_target) shows the visualization
    we imagined, and in this chapter we’ll see how to go about building it, leveraging
    the power of JavaScript and D3.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1601](assets/dpj2_1601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-1\. Our target, a Nobel Prize visualization
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I’ll show how the visual elements we conceived combine to transform our freshly
    cleaned and processed Nobel dataset into an interactive web visualization, deployable
    to billions of devices at the flick of a switch. But before going into the details,
    let’s have a look at the core components of a modern web visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Preliminaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before beginning to build the Nobel visualization, let’s consider the core components
    that will be used and how we will organize our files.
  prefs: []
  type: TYPE_NORMAL
- en: Core Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in [“A Basic Page with Placeholders”](ch04.xhtml#webdev101_basic_page),
    building a modern web visualization requires four key components:'
  prefs: []
  type: TYPE_NORMAL
- en: An HTML skeleton upon which to hang our JavaScripted creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more CSS files to govern the look and feel of the dataviz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JavaScript files themselves, including any third-party libraries you might
    need (D3 being our biggest dependency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And last but not least, the data to be transformed, ideally in the JSON or CSV
    (if wholly static data) format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start looking at our dataviz components, let’s get the file structure
    for our Nobel Prize visualization (Nobel-viz) project in place and establish how
    we’re going to feed data to our visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing Your Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 16-1](#nviz_files) shows the structure of our project directory. By
    convention we have an *index.xhtml* file in the root directory with a *static*
    directory containing all the libraries and assets (images and data) used for our
    visualization.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-1\. Our Nobel-viz project’s file structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The static data files we’ll be using, including a TopoJSON world map (see [Chapter 19](ch19.xhtml#chapter_d3_maps))
    and the country data we grabbed from the web (see [“Getting Country Data for the
    Nobel Dataviz”](ch05.xhtml#country_data)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The Nobel Prize winners’ photos we scraped using Scrapy in [“Scraping Text and
    Images with a Pipeline”](ch06.xhtml#scraping_bio).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The *js* subdirectory contains our Nobel-viz JavaScript module files (*.mjs*),
    separated into core elements and starting with *nbviz_*.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The full Nobel dataset with the mini-biographies that we scraped in [Chapter 6](ch06.xhtml#chapter_heavy_scraping)
    amounts to around three megabytes of data, considerably less when compressed for
    web transport. By the standards of modern web pages, that’s not a huge amount
    of data. In fact, average web page size is somewhere around 2MB to 3MB.^([1](ch16.xhtml#idm45607751186112))
    Nevertheless it’s approaching a point where we might consider breaking it into
    smaller chunks that could be loaded on a need-to-use basis. We could also serve
    the data dynamically from a web server (see [Chapter 13](ch13.xhtml#chapter_delivery_restful))
    with a database like SQLite. As it is, the small inconvenience of an initial wait
    time is compensated by speedy performance thereafter, as all the data is cached
    by the browser. It also makes things a lot simpler having just one initial fetching
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Nobel visualization we’ll serve all the data from a data directory
    (see [Example 16-1](#nviz_files), #2), fetched as the app is initialized.'
  prefs: []
  type: TYPE_NORMAL
- en: The HTML Skeleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although our Nobel visualization has a number of dynamic components, the HTML
    skeleton required is surprisingly simple. This demonstrates a core theme of the
    book—that you need very little conventional web development to set the stage for
    programming data visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *index.xhtml* file, which creates the visualization on loading, is shown
    in [Example 16-2](#d3build_index). The three components are:'
  prefs: []
  type: TYPE_NORMAL
- en: A CSS stylesheet *style.css*, setting fonts, content-block positions, and the
    like, is imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: HTML placeholders for our visual elements with IDs of the form `nobel-[foo]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The JavaScript; first third-party libraries, then our original scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We’ll cover the individual HTML sections in detail in the coming chapters,
    but I wanted you to see what is essentially the entire nonprogrammatic element
    of the Nobel Prize visualization. With this skeleton in place, you can then turn
    to the job of creative programming, something D3 encourages and excels at. As
    you get used to defining your content blocks in HTML, and fixing dimensions and
    positioning with CSS, you’ll find you spend more and more time doing what you
    love best: manipulating data with code.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I find it helpful to treat the identified placeholders, such as the map holder
    `<div id="nobel-map"></div>`, as panels *owned* by their respective elements.
    We set the dimension and relative positioning of these frames in the main CSS
    or JS^([2](ch16.xhtml#idm45607751164464)) file and the elements, such as our dynamic
    map, adapt themselves to the size of their frame. This allows a nonprogramming
    designer to change the look and feel of the visualization through CSS styling.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-2\. The index.xhtml access file to our single-page visualization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The HTML skeleton ([Example 16-2](#d3build_index)) defines the hierarchical
    structure of our Nobel-viz components, but their visual sizing and positioning
    are set in the *style.css* file. In the next section, we’ll see how this is done
    and look at the general styling of our visualization.
  prefs: []
  type: TYPE_NORMAL
- en: CSS Styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll deal with the styling of the individual chart components of our chart
    ([Figure 16-1](#d3build_target)) in their respective chapters. This section will
    cover the remaining nonspecific CSS, most importantly the sizing and positioning
    of our elements’ content blocks (*panels*).
  prefs: []
  type: TYPE_NORMAL
- en: The size of a visualization can be a tricky choice. There are many more device
    formats out there these days, with smartphones, tablets, mobile devices, etc.
    having a variety of different resolutions, such as “retina,”^([3](ch16.xhtml#idm45607750526128))
    and full HD (1,920×1,080). So pixel sizes are much more varied than they used
    to be, and pixel density becomes a more meaningful metric. Most devices perform
    pixel scaling to compensate for this, which is why you can still read the text
    on a smartphone even though it has as many pixels as a large desktop monitor.
    Also, most handheld devices have pinch-and-zoom and pan, allowing the user to
    easily focus on regions of a larger dataviz. For our Nobel dataviz we’ll choose
    a compromise resolution of 1,280×800 pixels, which should look OK on most desktop
    monitors and be usable in landscape mode on a mobile device, including our 50-pixel-high
    top-most user controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set some general styles we want applied to the whole document using
    the `body` selector; a sans-serif font, an off-white background, and some link
    detailing are specified. We also set the width of the visualization and its margins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This color is just off full-white (`#ffffff`) and should help to make the page
    slightly less bright and easier on the eyes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The default underlined hyperlinks look a bit fussy in my opinion, so we remove
    decoration.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main div content blocks to our Nobel-viz, which we position
    absolutely within the `#chart` div (their relative parent). These are the main
    title (`#title`) , some information on the visualization (`#info`), and the main
    container (`#nbviz`). The title and info are placed by eye and the main container
    is placed 90 pixels from the page top to allow them room, and given a width of
    100% to make it expand to the available space. The following CSS achieves this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `chart-holder` is given a height of 750 px, a width of 100% its parent,
    and a `position` property of `relative`, meaning the absolute positioning of its
    child panels will be relative to its top-left corner. The bottom of our charts
    is padded by 20 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We want the SVG contexts for our components to expand to fit their containers.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing for the Nobel-viz’s height constraint of 750 pixels, the width/height
    ratio of two for our equirectangular map,^([4](ch16.xhtml#idm45607750213296))
    and the need to fit over 100 years’ worth of Nobel Prize circular indicators into
    our time chart, playing with the dimensions suggests [Figure 16-2](#d3build_dimensions)
    as a good compromise for the size of our visual elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1602](assets/dpj2_1602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-2\. The Nobel-viz’s dimensions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This CSS positions and sizes the components as shown in [Figure 16-2](#d3build_dimensions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We want absolute, manually adjusted positioning, relative to the `chart-holder`
    parent container.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The timeline runs the full width of the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: You can use padding to let the components “breathe.”
  prefs: []
  type: TYPE_NORMAL
- en: The other CSS styles are specific to the individual components and will be covered
    in their respective chapters. With the preceding CSS, we have an HTML skeleton
    on which to flesh out our visualization with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a visualization of any size, it’s good to start imposing some modularity
    early on. Many of the D3 examples on the web^([5](ch16.xhtml#idm45607749985552))
    are one-page solutions, combining HTML, CSS, JS, and even data on one page. Though
    this is great for teaching by example, as the codebase increases, things will
    degenerate fast, making changes a slog and increasing the chance of namespace
    collisions and the like.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We include the JavaScript files for our visualization using `<script>` tags
    placed at the bottom of the `<body>` tag in our entry *index.xhtml* file, as shown
    in [Example 16-2](#d3build_index):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use local copies of the third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The main entry point for our Nobel app, where it requests its first datasets
    and sets the display ball rolling. This module imports all the others used by
    the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Modular JS with Imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first edition of this book, a common but rather hacky pattern was used
    to establish an `nbviz` namespace within which to place functions, variables,
    constants, etc. used by the various components of the Nobel dataviz. Here’s an
    example, as you may well run into similar patterns in the wild:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables as global will prevent them triggering [JSLint errors](https://www.jslint.com).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Exposes this function to other scripts as part of shared `nbviz` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the `nbviz` object if available, and creates it otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Each JS script was encapsulated with this pattern and all required scripts were
    included with a `<script>` tag in the main *index.xhtml* entry point. With the
    arrival of cross-browser support for JS modules, we have a much cleaner, modern
    way of including our JavaScript with modular imports familiar to any Pythonista
    (see [“JavaScript Modules”](ch02.xhtml#sect_js_modules)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have only to include our main JS module in *index.xhtml*, and that will
    import all the other modules required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: These are imported to initialize their update callbacks. We’ll see how that
    works later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters, the JavaScript/D3 used to produce the visualization’s
    elements will be explained in detail. First, we’ll deal with the flow of data
    through the Nobel-viz, from the (data) server to the client browser and within
    the client, driven by user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Data Flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to deal with data in a project of any complexity. For interactive
    apps, and particularly data visualizations, I find the most robust pattern is
    to have a central data object to cache current data. In addition to the cached
    data, we also have some active reflections or subsets of this dataset, stored
    in the main data object. For example, in our Nobel-viz a user can select a number
    of subsets of the data (e.g., only those winners in the Physics category).
  prefs: []
  type: TYPE_NORMAL
- en: If a different data reflection is triggered by the user, such as by choosing
    the per capita prize metric, a flag^([6](ch16.xhtml#idm45607749683584)) is set
    (in this case, `valuePerCapita` is set to `0` or `1`). We then update all the
    visual components, and those that depend on `valuePerCapita` adapt accordingly.
    The size of the map indicators changes and the bar chart reorganizes.
  prefs: []
  type: TYPE_NORMAL
- en: The key idea is to make sure the visual elements are synchronized to any user-driven
    data changes. A reliable way to do this is to have a single update method (here
    called `onDataChange`) that is called whenever a user does something to change
    the data. This method alerts all the active visual elements to the changed data
    and they respond accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how the app’s code fits together, starting with the shared core
    utilities.
  prefs: []
  type: TYPE_NORMAL
- en: The Core Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first JavaScript file loaded is *nbviz_core.js*. This script contains any
    code we might want to share among the other scripts. For example, we have a `categoryFill`
    method that returns a specific color for each category. This is used by both the
    timeline component and as a border in the biography box. This core code includes
    functions we might want to isolate for testing, or simply to make other modules
    less cluttered.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Often in programming we use string constants as dictionary keys and comparatives,
    and in generated labels. It’s easy to slip into the bad habit of typing these
    strings when required, but a much better way is to define a constant variable
    instead. For example, rather than `'if option === "All Categories"'`, we use `'if
    option === nbviz.ALL_CATS'`. In the former option, mistyping `'All Categories'`
    will not flag an error, an accident waiting to happen. Having a `const` also means
    only one edit is needed to change all occurrences of the string. JavaScript has
    a newish `const` keyword that makes enforcing constancy a bit easier, though it
    only prevents variables from being reassigned. See the [Mozilla documentation](https://oreil.ly/AlEbm)
    for some examples and a breakdown of `const` limitations.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 16-3](#build_core) shows the code shared between the other modules.
    Anything intended to be used by other modules is attached to the shared `nbviz`
    namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-3\. Shared codebase in nbviz_core.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We use one of D3’s built-in color schemes to provide our prize category colors.
    `schemeCategory10` is an array of 10 color hex codes (`['#1f77b4', '#ff7f0e',...]`),
    which we access using the category indices.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This and the following empty methods will be explained in detail in the following
    chapters in a use context.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This function is called when the dataset changes (after initialization of the
    app, this is user-driven) to update the Nobel-viz elements. Update callbacks set
    by the component modules and stored in the `callbacks` array are called in turn,
    triggering any necessary visual changes. See [“Basic Data Flow”](#d3build_sect_components)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_building_a_visualization_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `nbviz` object, with utility functions, constants, and variables, is the
    default export for this module, imported by other modules, thus `import nbviz
    from ​./⁠nbviz_core`.
  prefs: []
  type: TYPE_NORMAL
- en: With the core code at hand, let’s see how our app is initialized by fetching
    static resources using D3’s utility methods.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Nobel Prize Visualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to start the app, we need some data. We use D3’s `json` and `csv`
    helper functions to load the data and convert it to JavaScript objects and arrays.
    The `Promise.all`^([7](ch16.xhtml#idm45607749511824)) method is used to fire off
    these data fetches simultaneously, wait for all four to be resolved, and then
    deliver the data to a specified handler function, in this case `ready`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Fire off simultaneous requests for the four data files. The static files consist
    of a world map (110m resolution) and some country data we’ll be using in the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The array returned to `ready` uses [JavaScript destructuring](https://oreil.ly/RZzXm)
    to assign the sequential data to its respective variables.
  prefs: []
  type: TYPE_NORMAL
- en: If our data requests are successful, the `ready` function receives the requested
    data and we’re ready to start sending data to the visual elements.
  prefs: []
  type: TYPE_NORMAL
- en: Ready to Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the deferred requests for data made by the `Promise.all` method are resolved,
    it calls the specified `ready` function, passing the datasets as arguments in
    the order in which they were added.
  prefs: []
  type: TYPE_NORMAL
- en: The `ready` function is shown in [Example 16-4](#build_ready). If the data has
    downloaded without error, we use the winners’ data to create the active filter
    (courtesy of the Crossfilter library) we will use to allow the user to select
    subsets of the Nobel winners based on category, gender, and country. We then call
    some initializer methods, and finally use the `onDataChange` method to trigger
    a drawing of the visual elements of dataviz, updating bar chart, map, timeline,
    and so on. The schematic in [Figure 16-3](#d3build_work_flow) shows the way in
    which data changes propagate.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-4\. The `ready` function is called when the initial data requests
    have resolved
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This method uses the freshly loaded Nobel Prize dataset to create the filter
    we will use to allow the user to select subsets of the data to visualize. See
    [“Filtering Data with Crossfilter”](#crossfilter) for details.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll see how the `makeFilterAndDimensions` method ([Example 16-4](#build_ready),
    ![1](assets/1.png)) works when we cover the Crossfilter library in [“Filtering
    Data with Crossfilter”](#crossfilter). For now, we’ll assume we have a means of
    getting the data currently selected by the user via some menu selectors (e.g.,
    selecting all female winners).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1603](assets/dpj2_1603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-3\. The app’s main data flow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Data-Driven Updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the menu and map have been initialized in the `ready` function (we’ll
    see how that works in their respective chapters: [Chapter 19](ch19.xhtml#chapter_d3_maps)
    for the map and [Chapter 21](ch21.xhtml#chapter_d3_ui) for the menu), we trigger
    an update of the visual elements with the `onDataChange` method defined in *nbviz_core.js*.
    `onDataChange` (see [Example 16-5](#src_ondatachange)) is a shared function that
    is called whenever the set of displayed data changes in response to user interaction,
    or when the user chooses a different country prize metric (e.g., measuring per
    capita rather than absolute numbers).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-5\. Function called to update the visual elements when selected data
    is changed
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Each component module that needs updating appends its callback to this array.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: On data change the component callbacks are called in turn, triggering any visual
    changes necessary to reflect the new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the modules are first imported, they add their callbacks to the `callbacks`
    array in the core module. Here’s the bar chart, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: When the main core update function calls this callback function, the country
    data is used by the local update function to change the bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: The main dataset, consumed by the timeline, map, and bar chart, is produced
    by the `getCountryData` method, which groups the prize winners by country and
    adds some national information, namely population size and international alphacode.
    [Example 16-6](#build_getCountryData) breaks this method down.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-6\. Creating the main country dataset
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`countryDim` is one of our Crossfilter dimensions (see [“Filtering Data with
    Crossfilter”](#crossfilter)), here providing group key, value counts (e.g., `{key:Argentina,
    value:5}`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: We use the array’s `map` method to create a new array with added components
    from our country dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Fetches country data using our group key (e.g., Australia).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_building_a_visualization_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: If the `valuePerCapita` radio-switch is on then we divide the number of prizes
    by the size of the country’s population, giving a *fairer*, relative prize tally.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_building_a_visualization_CO13-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses `Array`’s `sort` method to make the array descending by value.
  prefs: []
  type: TYPE_NORMAL
- en: The update methods of our Nobel-viz elements all make use of data filtered by
    the Crossfilter library. Let’s see how that’s done now.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Data with Crossfilter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developed by D3’s creators, Mike Bostock and Jason Davies, Crossfilter^([8](ch16.xhtml#idm45607748719440))
    is a highly optimized library for exploring large, multivariate datasets using
    JavaScript. It’s very fast and can easily handle datasets far larger than our
    Nobel Prize dataset. We’ll be using it to filter our dataset of winners by the
    dimensions of category, gender, and country.
  prefs: []
  type: TYPE_NORMAL
- en: The choice of Crossfilter is slightly ambitious, but I wanted to show it in
    action as I’ve found it to be so useful personally. It’s also the basis of [*dc.js*](https://dc-js.github.io/dc.js),
    the very popular D3 charting library, which testifies to its usefulness. Although
    Crossfilter can be a little difficult to grasp, especially when we start intersecting
    dimensional filters, most use cases follow a basic pattern that is quickly absorbed.
    If you ever find yourself trying to cut and slice large datasets, Crossfilter’s
    optimizations will prove a boon.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On initializing the Nobel-viz, the `makeFilterAndDimensions` method defined
    in *nbviz_core.js* is called from the `ready` method in *nbviz_main.js* (see [“Ready
    to Go”](#sect_ready)). `makeFilterAndDimensions` uses the freshly loaded Nobel
    Prize dataset to create a Crossfilter filter and some dimensions (e.g., prize
    category) based on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create our filter using the dataset of Nobel Prize winners fetched
    on initialization. Let’s remind ourselves what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To create our filter, call the `crossfilter` function with the array of winner
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Crossfilter works by allowing you to create dimensional filters on your data.
    You do so by applying a function to the objects. At its simplest, this creates
    a dimension based on a single category—for example, by gender. Here we create
    the gender dimension we’ll use to filter Nobel Prizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This dimension now has an efficient ordering of our dataset by the gender field.
    We can use it like this, to return all objects with gender female:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter` takes a single value or, where appropriate, a range (e.g., [5, 21]—all
    values between 5 and 21). It can also take a Boolean function of the values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Once the filter is applied, `top` returns the specified number of ordered objects.
    Specifying `Infinity`^([9](ch16.xhtml#idm45607748487088)) returns all the filtered
    data objects.
  prefs: []
  type: TYPE_NORMAL
- en: Crossfilter really comes into its own when we start applying multiple dimensional
    filters, allowing us to slice and dice the data into any subsets we require, all
    achieved with impressive speed.^([10](ch16.xhtml#idm45607748484816))
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s clear the gender dimension and add a new one, filtering by prize-winning
    category. To reset a dimension,^([11](ch16.xhtml#idm45607748454160)) apply the
    `filter` method without arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll now create a new prize category dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now filter the gender and category dimensions in sequence, allowing
    us to find, for example, all female Physics prize winners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we can turn the filters on and off selectively. So, for example,
    we can remove the Physics category filter, meaning the gender dimension now contains
    all the female Nobel Prize winners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In our Nobel-viz, these filter operations will be driven by the user making
    selections from the topmost menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as returning the filtered subsets, Crossfilter can perform grouping
    operations on the data. We use this to get the national prize aggregates for the
    bar chart and map indicators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Group takes an optional function as an argument, but the default is generally
    what you want.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_building_a_visualization_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Returns all groups by key and value. Do not modify the returned array.^([12](ch16.xhtml#idm45607748238000))
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_building_a_visualization_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`value` is the total number of Nobel Prize winners for Argentina.'
  prefs: []
  type: TYPE_NORMAL
- en: To create our Crossfilter filter and dimensions, we use the `makeFilterAndDimensions`
    method, defined in *nbviz_core.js*. [Example 16-7](#makeFilterAndDims) shows the
    whole method. Note that the order in which the filters are created isn’t important—their
    intersection will still be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-7\. Making our Crossfilter filter and dimensions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_building_a_visualization_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re using the full JavaScript functions for teaching clarity, but these days
    the shortened form would likely be used: `o => o.country`.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the Nobel Prize Visualization App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the Nobel visualization we need a web server that can access the root
    *index.xhtml* file. For development purposes we can make use of Python’s built-in
    `http` module to kick off the required server. In the root directory containing
    our index file, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now open up a browser window and go to *http:localhost:8080* and you should
    see [Figure 16-4](#d3build_nobelviz).
  prefs: []
  type: TYPE_NORMAL
- en: '![dpj2 1604](assets/dpj2_1604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-4\. The finished Nobel-viz app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we sketched out how to implement the visualization we imagined
    in [Chapter 15](ch15.xhtml#chapter_imagining). The backbone was assembled from
    HTML, CSS, and JavaScript building blocks, and the data feed to the app and data
    flow within it described. In the following chapters, we’ll see how the individual
    components of our Nobel-viz use the data sent to them to create our interactive
    visualization. We’ll start with a big chapter, which will introduce the fundamentals
    of D3 while showing how to build the bar chart component of our app. This should
    set you up for the subsequent D3-focused chapters.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch16.xhtml#idm45607751186112-marker)) See these [SpeedCurve](https://oreil.ly/ngdOJ)
    and [Web Almanac](https://oreil.ly/qIvox) posts for some analysis of average web
    page size.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch16.xhtml#idm45607751164464-marker)) I would advise saving JavaScripted
    styling for special occasions, doing as much as possible with vanilla CSS.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch16.xhtml#idm45607750526128-marker)) Currently around 2,560×1,600 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch16.xhtml#idm45607750213296-marker)) See [“Projections”](ch19.xhtml#sect_projections)
    for a comparison of the different geometric projections. Given the constraint
    of showing all Nobel Prize–winning countries, the equirectangular projection proved
    most effective.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch16.xhtml#idm45607749985552-marker)) See the collection at [D3’s GitHub](https://oreil.ly/khvac).
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch16.xhtml#idm45607749683584-marker)) In our app, I’m keeping things as
    simple as possible; as the number of UI options increases, it’s sensible to store
    flags, ranges, etc. in a dedicated object.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch16.xhtml#idm45607749511824-marker)) You can read more about `Promise.all`
    in the [Mozilla documentation](https://oreil.ly/67Odo).
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch16.xhtml#idm45607748719440-marker)) See this [Square page](https://square.github.io/crossfilter)
    for an impressive example.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch16.xhtml#idm45607748487088-marker)) JavaScript’s [`Infinity`](https://oreil.ly/Ll5xV)
    is a numeric value representing infinity.
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch16.xhtml#idm45607748484816-marker)) Crossfilter was designed to update
    millions of records in real time, in response to user input.
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch16.xhtml#idm45607748454160-marker)) This will clear all the filters
    on this dimension.
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch16.xhtml#idm45607748238000-marker)) See the [Crossfilter GitHub page](https://oreil.ly/saEpG).
  prefs: []
  type: TYPE_NORMAL
