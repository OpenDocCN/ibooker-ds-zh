- en: Chapter 10\. Working with raster data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 使用栅格数据
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Georeferencing with ground control points
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地面控制点进行地理配准
- en: Working with attributes, histograms, and color tables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理属性、直方图和颜色表
- en: Using the GDAL virtual format
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GDAL虚拟格式
- en: Reprojecting rasters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重投影栅格
- en: Using GDAL error handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GDAL错误处理
- en: In the last chapter you learned the basics of raster processing, such as how
    to read and write data and work with individual bands, and how rasters use geotransforms
    to orient themselves to the real world. This was a great first step, but what
    if you have an old aerial photograph or scanned paper map that you’d like to turn
    into a geographic dataset? You might want to do that because it’s fun and interesting,
    or you might want to do a change analysis using this data along with more current
    imagery. To do that, you must overlay the old data on the new. You can do this
    using ground control points, which are essentially a collection of points with
    known locations. This chapter will teach you how to use these points.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了栅格处理的基础知识，例如如何读取和写入数据以及如何处理单个波段，以及栅格如何使用地理变换来定位到现实世界。这是一个很好的第一步，但如果你有一张旧航拍照片或扫描的纸质地图，你想将其转换为地理数据集怎么办？你可能想这么做是因为这很有趣，或者你可能想使用这些数据以及更新的图像进行变化分析。要做到这一点，你必须将旧数据叠加到新数据上。你可以使用地面控制点来完成这项工作，这些控制点本质上是一组具有已知位置的点。本章将教你如何使用这些点。
- en: You’ll also learn how to work with raster attribute tables. Although most of
    the raster examples we’ve looked at so far have been continuous data, such as
    satellite imagery, raster datasets can also contain thematic data. In this case,
    each unique pixel value corresponds to a classification of some kind, such as
    vegetation or soil type. Pixel values are numeric, though, so how do you know
    what each value stands for? For example, the landcover classification map shown
    in [figure 10.1](#ch10fig01) has 125 different classes. I certainly can’t remember
    what each value stands for; 76 doesn’t mean nearly as much to me as “Inter-Mountain
    Basins Semi-Desert Grassland” does. Fortunately, it’s possible to store information
    like this in raster attribute tables.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何处理栅格属性表。虽然我们之前查看的大多数栅格示例都是连续数据，例如卫星图像，但栅格数据集也可以包含主题数据。在这种情况下，每个唯一的像素值对应于某种分类，例如植被或土壤类型。像素值是数字的，但你如何知道每个值代表什么？例如，[图10.1](#ch10fig01)中显示的土地覆盖分类图有125个不同的类别。我当然不可能记住每个值代表什么；76对我来说并不像“山地盆地半荒漠草原”那样有意义。幸运的是，可以将此类信息存储在栅格属性表中。
- en: Figure 10.1\. A landcover classification map, where each unique pixel value
    corresponds to a specific landcover classification
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1\. 一个土地覆盖分类图，其中每个唯一的像素值对应于特定的土地覆盖分类
- en: '![](10fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig01.jpg)'
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Note to Print Book Readers: Color Graphics'
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意：印刷版读者：彩色图形
- en: Many graphics in this book are best viewed in color. The eBook versions display
    the color graphics, so they should be referred to as you read. To get your free
    eBook in PDF, ePub, and Kindle formats, go to [https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)
    to register your print book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多图形最好以彩色查看。电子书版本显示了彩色图形，因此在阅读时应参考。要获取免费PDF、ePub和Kindle格式的电子书，请访问[https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)注册您的印刷版书籍。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Take a look at [figure 10.1](#ch10fig01) again. It uses a constant set of colors
    to display each landcover class. Water is always blue (or almost black if you’re
    viewing this in black and white) and the playa west of the Great Salt Lake are
    always a pale yellowish color (or a very light gray in black and white). Although
    constant colors are certainly not required for data analysis, it’s nice to have
    them when looking at a dataset. You saw earlier how red, green, and blue bands
    can be used to draw an image, but this dataset has only one band that contains
    classification values. Instead of the RGB bands, it has what’s called a *color
    table* that specifies what color each unique pixel value should be drawn in.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看[图10.1](#ch10fig01)。它使用一组固定的颜色来显示每个土地覆盖类别。水总是蓝色（如果你在黑白模式下查看，几乎是黑色）而大盐湖西边的荒地总是淡黄色（在黑白模式下是非常浅的灰色）。虽然固定的颜色对于数据分析来说并非必需，但在查看数据集时拥有它们是很方便的。你之前已经看到如何使用红、绿、蓝波段来绘制图像，但这个数据集只有一个包含分类值的波段。它没有RGB波段，而是有一个所谓的*颜色表*，该表指定了每个唯一的像素值应该绘制成什么颜色。
- en: These are only a few examples of other components of raster datasets. You’ll
    learn how to work with these, and more, in this chapter. You’ll also learn tricks
    for handling errors in GDAL.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是栅格数据集其他组件的几个例子。你将在本章中学习如何处理这些以及其他组件。你还将学习处理GDAL中错误的技巧。
- en: 10.1\. Ground control points
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 地面控制点
- en: You’ve learned how geotransforms work to georeference an image, using the upper-left
    coordinates and pixel size. You don’t always have this information, however. For
    example, if you found an old aerial photo from 1969 and scanned it in, you’d have
    a digital image, but you couldn’t load it into a GIS and see it displayed in the
    correct location. Your scanner creates a digital image, but it doesn’t attach
    any sort of geographic information to it. All is not lost, however, as long as
    you know what area the photo is of and can identify a few locations. These locations
    are called ground control points (GCPs), which are points for which you know the
    real-world coordinates. If you can associate a number of pixels around the image
    with actual coordinates, then the image can be warped to overlay on a map, as
    shown in [figure 10.2](#ch10fig02). This method isn’t used as often as geotransforms,
    but it’s necessary in certain cases. Plus, once an image has been georeferenced
    this way, a geotransform can be computed so that it can be used instead if desired.
    You should be aware that because the image will be stretched, warped, and/or rotated
    so that the GCPs overlay the real coordinates, the pixel size and raster dimensions
    might be changed during the process.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了如何使用左上角坐标和像素大小来使用地理变换（geotransforms）对图像进行地理配准。然而，你并不总是拥有这些信息。例如，如果你发现了一张1969年的旧航空照片并将其扫描，你会得到一个数字图像，但你无法将其加载到GIS中并看到它在正确位置上显示。你的扫描仪创建了一个数字图像，但它没有将其与任何地理信息关联。然而，只要你知道照片是关于哪个区域的，并且可以识别几个位置，一切就不会失去。这些位置被称为地面控制点（GCPs），即你知道其实际世界坐标的点。如果你可以关联图像周围的像素与实际坐标，那么图像可以被扭曲以覆盖在地图上，如图10.2所示。这种方法不像地理变换那样常用，但在某些情况下是必要的。此外，一旦以这种方式对图像进行地理配准，就可以计算地理变换，以便在需要时使用。你应该意识到，由于图像将被拉伸、扭曲和/或旋转，以便地面控制点与真实坐标重叠，像素大小和栅格维度在过程中可能会发生变化。
- en: Figure 10.2\. An example of using four known locations to warp an image to fit
    correctly on a map. Figure A shows an aerial photo with the points overlaid on
    top, figure B shows a topographical map with the same points, and figure C shows
    the photo stretched so that the points match up with the topo map.
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2. 使用四个已知位置扭曲图像以正确地适合地图的示例。图A显示了一个带有重叠点的航空照片，图B显示了一个带有相同点的地形图，图C显示了照片被拉伸以使点与地形图匹配。
- en: '![](10fig02_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig02_alt.jpg)'
- en: It should be apparent that fixed landmarks make good GCPs because they’re the
    easiest thing to pinpoint and get real coordinates for. For example, if you have
    an aerial photograph that includes a freeway, using a car on that freeway won’t
    work because you probably have no way of knowing its location at the exact time
    the photo was taken (if you do, then by all means, use it). An exit ramp, however,
    is a good choice because it doesn’t move, it will be easily visible in the photo,
    and it’s not difficult to get the coordinates for.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很明显，固定地标是很好的地面控制点（GCPs），因为它们是最容易定位并获得真实坐标的东西。例如，如果你有一张包含高速公路的航空照片，使用高速公路上的汽车是不行的，因为你可能不知道照片拍摄时的确切位置（如果你知道，那么当然可以使用它）。然而，出口匝道是一个不错的选择，因为它不会移动，在照片中很容易看到，而且获取坐标也不困难。
- en: Depending on the type of transformation you use to warp the image, you’ll need
    a different number of GCPs. One commonly used algorithm, a *first-order polynomial*,
    fits a linear equation to the image’s x coordinates so the GCP image coordinates
    match, as closely as possible, the real GCP coordinates that you provide. The
    same is done for the y coordinates. This method requires at least three points.
    If your coordinates are exact, then theoretically you don’t need more points,
    but this is probably not the case, and you’ll get better results with a few more
    points evenly distributed around the image. This algorithm works well if your
    image needs to be scaled or rotated, as in [figure 10.3](#ch10fig03)A. If your
    image needs to be bent, as in the shape changes ([figure 10.3](#ch10fig03)B),
    then you’re better off using a higher-order polynomial, such as a quadratic or
    cubic equation, with more GCPs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您用于扭曲图像的变换类型，您需要不同数量的GCPs。一个常用的算法，即*一次多项式*，将线性方程拟合到图像的x坐标，以便GCP图像坐标尽可能接近您提供的真实GCP坐标。同样也适用于y坐标。此方法至少需要三个点。如果您的坐标是精确的，那么理论上您不需要更多的点，但这种情况可能并不常见，并且您可以通过在图像周围均匀分布几个额外的点来获得更好的结果。如果您的图像需要缩放或旋转，如图10.3A所示，则此算法效果良好。如果您的图像需要弯曲，如图10.3B所示（形状变化），那么您最好使用更高阶的多项式，例如二次或三次方程，并使用更多的GCPs。
- en: Figure 10.3\. A scaled and rotated raster (A) and a raster whose shape has changed
    (B)
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3. 缩放和旋转的栅格（A）和形状发生变化的栅格（B）
- en: '![](10fig03_alt.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![10fig03_alt.jpg](10fig03_alt.jpg)'
- en: A polynomial transformation might end up shifting several of your GCPs slightly
    to minimize error across the image, as in [figure 10.4](#ch10fig04)A. If you want
    to eliminate error around the GCPs and are willing to accept greater error in
    other parts of the image, as in [figure 10.4](#ch10fig04)B, you can use a *spline*
    method instead. A spline doesn’t use a single equation, but instead uses different
    equations for different parts of the data, so it can fit the provided points exactly.
    This might cause other parts of the image to be warped in odd ways, however. You
    can use various interpolation methods with the gdalwarp utility that comes with
    GDAL, but you’ll only see how to use a first-order (linear) polynomial with Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式变换可能会将您的几个地面控制点（GCPs）略微移动，以最小化图像中的误差，如图10.4A所示。如果您想消除GCP周围的误差，并且愿意接受图像其他部分的更大误差，如图10.4B所示，您可以使用一种*spline*方法。样条曲线不使用单个方程，而是针对数据的不同部分使用不同的方程，因此可以精确地拟合提供的点。然而，这可能会导致图像的其他部分以奇怪的方式变形。您可以使用GDAL附带的各种插值方法与gdalwarp工具一起使用，但您将只看到如何使用Python中的首次（线性）多项式。
- en: Figure 10.4\. Different error distributions. Triangles are GCPs; circles are
    random points. Solid shapes are the true location; hollow shapes are the location
    the point ends up in the warped raster.
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4. 不同的误差分布。三角形是GCPs；圆圈是随机点。实心形状是真实位置；空心形状是点在扭曲栅格中最终到达的位置。
- en: '![](10fig04_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![10fig04_alt.jpg](10fig04_alt.jpg)'
- en: How do you go about using GCPs? The first things you need are the known coordinates
    for specific pixel offsets. You could get this information the hard way, such
    as opening your raster in image or photo processing software and using it to determine
    pixel offsets. An easier method, however, is to use the QGIS georeferencer plugin.
    This allows you to click on a location in your image and on an already georeferenced
    map, and it will tell you the pixel offsets and corresponding real-world coordinates.
    It will even export the necessary `gdalwarp` command to do the georeferencing
    for you. But you’re here to learn how to do the same job with Python, so let’s
    look at the example back in [figure 10.2](#ch10fig02). This aerial photo of a
    small area shows a few roads and several large water treatment ponds. I’ve determined
    the coordinates for four locations, shown in [table 10.1](#ch10table01) and as
    dots in the figure. I chose points that could be identified on both the image
    in [figure 10.2](#ch10fig02)A and the topo map in [figure 10.2](#ch10fig02)B.
    Getting the point coordinates is the hard part of the process, but it’s something
    you’ll have to do by hand. In this case, the topo map was georeferenced so I could
    figure out the coordinates from the map.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用地面控制点（GCPs）？首先你需要的是特定像素偏移量的已知坐标。你可以通过艰难的方式获取这些信息，例如在图像或照片处理软件中打开你的栅格数据，并使用它来确定像素偏移量。然而，一种更简单的方法是使用QGIS地理配准插件。这允许你在你的图像和已经地理配准的地图上的一个位置点击，它将告诉你像素偏移量和相应的真实世界坐标。它甚至可以导出必要的`gdalwarp`命令来为你进行地理配准。但你是来学习如何用Python做同样工作的，所以让我们看看[图10.2](#ch10fig02)中的示例。这张小区域的航空照片显示了几条道路和几个大型水处理池塘。我已经确定了四个位置的坐标，如[表10.1](#ch10table01)和图中的点所示。我选择了可以在[图10.2](#ch10fig02)A中的图像和[图10.2](#ch10fig02)B中的地形图上识别的点。获取点坐标是这个过程中最困难的部分，但这是你必须手动完成的事情。在这种情况下，地形图已经进行了地理配准，所以我可以从地图上确定坐标。
- en: Table 10.1\. Pixel offsets and coordinates used to georeference the aerial photo
    shown in [figure 10.2](#ch10fig02)
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1\. 用于地理配准[图10.2](#ch10fig02)中显示的航空照片的像素偏移量和坐标
- en: '| Photo column | Photo row | Longitude | Latitude |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 照片列 | 照片行 | 经度 | 纬度 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 1078 | 648 | -111.931075 | 41.745836 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 1078 | 648 | -111.931075 | 41.745836 |'
- en: '| 3531 | 295 | -111.901655 | 41.749269 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 3531 | 295 | -111.901655 | 41.749269 |'
- en: '| 3722 | 1334 | -111.899180 | 41.739882 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 3722 | 1334 | -111.899180 | 41.739882 |'
- en: '| 1102 | 2548 | -111.930510 | 41.728719 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 1102 | 2548 | -111.930510 | 41.728719 |'
- en: The following listing shows how you would attach these ground control points
    to the photo.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何将这些地面控制点附加到照片上。
- en: Listing 10.1\. Adding ground control points to a raster
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1\. 向栅格添加地面控制点
- en: '![](212fig01_alt.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](212fig01_alt.jpg)'
- en: 'When adding GCPs to a raster, make sure you open the dataset for updating,
    as you do here. You also need the spatial reference system of the known coordinates;
    in this case they use the WGS84 datum but are unprojected (lat/lon). The last
    thing you need is a list of GCPs, and you can create each of those with the GCP
    constructor shown here:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在向栅格添加GCPs时，确保你打开数据集以进行更新，就像你在这里做的那样。你还需要已知坐标的空间参考系统；在这种情况下，它们使用WGS84大地基准，但未投影（经纬度）。最后你需要的是GCPs的列表，你可以使用这里显示的GCP构造函数创建每个GCP：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`x`, `y`, and `z` are the real-world coordinates corresponding to the point.
    All are optional and default to 0, although you probably don’t want x and y values
    to be 0.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`、`y`和`z`是与点相对应的真实世界坐标。所有这些都是可选的，默认值为0，尽管你可能不希望x和y的值是0。'
- en: '`pixel` is the column offset for the pixel with known coordinates. This is
    optional and the default is 0.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pixel`是具有已知坐标的像素的列偏移量。这是可选的，默认值为0。'
- en: '`line` is the row offset for the pixel with known coordinates. This is optional
    and the default is 0.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line`是具有已知坐标的像素的行偏移量。这是可选的，默认值为0。'
- en: '`info` and `id` are two optional strings used to identify the GCP, but in my
    experience they don’t carry over to the image. I rarely use GCPs, however, so
    perhaps there are instances where they do. The default is a blank string.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`和`id`是两个可选的字符串，用于识别GCP，但根据我的经验，它们不会传递到图像中。然而，我很少使用GCPs，所以也许有情况它们确实会传递。默认值是一个空字符串。'
- en: In [listing 10.1](#ch10ex01) you use the information in [table 10.1](#ch10table01)
    to create a list of four GCPs, and then you attach those GCPs to the dataset with
    `SetGCPs`. This function requires a list of GCPs and a WKT string containing projection
    information for the real-world coordinates.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表10.1](#ch10ex01)中，你使用[表10.1](#ch10table01)中的信息创建了一个包含四个GCPs（地面控制点）的列表，然后使用`SetGCPs`将这些GCPs附加到数据集上。此函数需要一个GCPs列表和一个包含真实世界坐标投影信息的WKT字符串。
- en: 'Now that you’ve added GCPs, software that understands them can display your
    image in its correct location. If you don’t need to know what GCPs were used to
    georeference the image and would rather use the more common geotransform method
    of georeferencing, you can create a geotransform from the GCPs and set that on
    the dataset instead of attaching the GCPs. To create a geotransform using a first-order
    transformation, pass your list of GCPs to `GCPsToGeoTransform`. Then make sure
    you set both the geotransform and the projection information on your dataset:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经添加了GCPs，理解它们的软件可以显示你的图像在正确的位置。如果你不需要知道用于地理参考图像的GCPs，而更愿意使用更常见的地理变换方法进行地理参考，你可以从GCPs创建一个地理变换，并将其设置在数据集上而不是附加GCPs。要使用一阶变换创建地理变换，将你的GCPs列表传递给`GCPsToGeoTransform`。然后确保你在数据集上设置地理变换和投影信息：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You don’t have to convert your GCPs to a geotransform if you don’t want to,
    however.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想转换你的GCPs到地理变换，你也可以不这么做。
- en: 10.2\. Converting pixel coordinates to another image
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 将像素坐标转换为另一图像
- en: As you learned in the last chapter, functions can help you convert between real-world
    coordinates and pixel offsets. Also, a `Transformer` class can be used for that
    or to go between offsets in two different rasters. One example of why you might
    want to do this is if you’re mosaicking rasters together, because each input image
    goes in a different part of the mosaic. To illustrate this, let’s combine a few
    digital orthophotos of Cape Cod together into one raster.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中学到的，函数可以帮助你在真实世界坐标和像素偏移之间进行转换。此外，可以使用`Transformer`类进行此操作或在不同栅格的偏移之间进行转换。你可能想要这样做的一个例子是当你拼接栅格时，因为每个输入图像都放在拼图中不同的部分。为了说明这一点，让我们将一些关于科德角的高分辨率正射影像组合成一个栅格。
- en: 'To combine the images, it’s necessary to know the extent of the output mosaic.
    The only way to find this is to get the extent of each input raster and calculate
    the overall minimum and maximum coordinates ([figure 10.5](#ch10fig05)). To make
    this a little easier, you’ll create a function that gets the extent of a raster.
    It uses the geotransform to get the upper-left coordinates and then calculates
    the lower right coordinates using the pixel size and raster dimensions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要组合图像，有必要知道输出拼贴的范围。找到这个范围的唯一方法是通过获取每个输入栅格的范围并计算整体的最小和最大坐标([图10.5](#ch10fig05))。为了使这个过程更容易一些，你将创建一个获取栅格范围的函数。它使用地理变换来获取左上角坐标，然后使用像素大小和栅格尺寸来计算右下角坐标：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Figure 10.5\. Dotted lines show the footprints of six rasters to be mosaicked
    together. The solid outer line is the footprint for the output raster.
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5\. 虚线显示将要拼接的六个栅格的足迹。实线外线是输出栅格的足迹。
- en: '![](10fig05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig05.jpg)'
- en: You can see in the following listing how this function is used to help find
    the output extent. Once you know the extent, you can calculate the output dimensions
    and create the raster. Then you can finally start copying data from each file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在下面的列表中看到如何使用此函数来帮助找到输出范围。一旦你知道了范围，你就可以计算输出尺寸并创建栅格。然后你就可以开始从每个文件中复制数据了。
- en: Listing 10.2\. Mosaic multiple images together
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 将多个图像拼接在一起
- en: '![](ch10ex02-0.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex02-0.jpg)'
- en: '![](ch10ex02-1.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10ex02-1.jpg)'
- en: The first thing you do in [listing 10.2](#ch10ex02) is loop through all of the
    input files and use their extents to calculate the final mosaic’s extent, and
    then you calculate the numbers of rows and columns for the output. You do this
    by getting the distance between the min and max values in each direction and dividing
    by the pixel size. You make sure to not accidentally cut the edges off by using
    the `ceil` function to round any partial numbers up to the next integer. Then
    you create a new dataset using these dimensions. You still need to create an appropriate
    geotransform, but that’s easily done by copying one from an input file and changing
    the upper-left coordinates to the ones you calculated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表10.2](#ch10ex02)中，你首先需要遍历所有输入文件，并使用它们的范围来计算最终拼贴图的范围，然后计算输出图的行数和列数。你是通过获取每个方向上的最小值和最大值之间的距离，并将其除以像素大小来做到这一点的。你确保使用`ceil`函数将任何部分数值向上舍入到下一个整数，以避免意外裁剪边缘。然后，你使用这些维度创建一个新的数据集。你仍然需要创建一个合适的地理变换，但这很容易通过从一个输入文件复制一个并更改你计算出的左上角坐标来实现。
- en: 'By this point you have an empty raster of the appropriate size, so it’s time
    to start copying data. This is where the transformer comes in. For each input
    dataset, you create a transformer between that dataset and the output mosaic.
    The third parameter is for transformer options, but you’re not using any of them
    here. Once you have the transformer, you can easily calculate the correct pixel
    offsets for the mosaic that correspond to the upper-left corner of the input raster
    using `TransformPoint`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经有一个适当大小的空栅格，现在是时候开始复制数据了。这就是转换器发挥作用的地方。对于每个输入数据集，你在该数据集和输出拼贴图之间创建一个转换器。第三个参数是转换器选项，但在这里你并没有使用它们。一旦有了转换器，你就可以轻松地使用`TransformPoint`计算与输入栅格左上角相对应的拼贴图的正确像素偏移量：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`bDstToSrc` is a flag specifying if you want to compute offsets from the destination
    raster to the source raster or vice versa. Use `True` to go from the destination
    to the source and `False` to go the other way.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bDstToSrc`是一个标志，指定你是否想从目标栅格到源栅格或相反计算偏移量。使用`True`从目标到源，使用`False`从另一方向。'
- en: '`x`, `y`, and `z` are the coordinates or offsets that you want to transform.
    `z` is optional and defaults to 0.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`、`y`和`z`是你想要转换的坐标或偏移量。`z`是可选的，默认为0。'
- en: You want to compute offsets in the destination raster (the second one provided
    when you created the transformer) based on the source, so you use `False` for
    the first parameter. The `x` and `y` parameters are both 0 because you want the
    offsets corresponding to the first row and first column in the input. The function
    returns a list containing a success flag and a tuple with the requested coordinates,
    but the coordinates are floating-point so you convert them to integers. Finally,
    you read the data from the input raster and write it out to the mosaic using the
    offsets you just calculated. Then you go on to the next input dataset.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要根据源计算目标栅格（当你创建转换器时提供的第二个）中的偏移量，因此对于第一个参数使用`False`。`x`和`y`参数都是0，因为你想得到与输入的第一行和第一列相对应的偏移量。该函数返回一个包含成功标志和包含请求坐标的元组的列表，但坐标是浮点数，所以你需要将它们转换为整数。最后，你从输入栅格中读取数据，并使用你刚刚计算出的偏移量将其写入拼贴图。然后，你继续处理下一个输入数据集。
- en: The resulting mosaic is shown in [figure 10.6](#ch10fig06). You can see how
    the color balancing between the images isn’t perfect. One other thing to be aware
    of is that if the input rasters overlap, then pixel values in the overlap area
    will be overwritten by the last raster that covers the overlap. The order in which
    you combine the rasters might be important to you so that you get the correct
    pixel values. Or you could implement a fancier algorithm to average the pixel
    values or handle them in another way.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 结果拼贴图显示在[图10.6](#ch10fig06)中。你可以看到图像之间的颜色平衡并不完美。还有一点需要注意，如果输入栅格重叠，则重叠区域中的像素值将被覆盖最后覆盖重叠的栅格。栅格组合的顺序可能对你很重要，以确保你得到正确的像素值。或者，你可以实现一个更复杂的算法来平均像素值或以其他方式处理它们。
- en: Figure 10.6\. A simple mosaic of six aerial photos of Cape Cod, Massachusetts
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6\. 马萨诸塞州科德角六张航空照片的简单拼贴
- en: '![](10fig06.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig06.jpg)'
- en: 'You can also transform coordinates between pixel offsets and real-world coordinates
    by not providing one of the datasets. For example, this would get the real-world
    coordinates for the pixel at column 1078 and row 648, assuming that the dataset
    has a valid geotransform:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过不提供其中一个数据集来在像素偏移和真实世界坐标之间转换坐标。例如，这将获取第1078列和第648行的像素的真实世界坐标，假设数据集有一个有效的地理变换：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I prefer to use `ApplyGeoTransform` for this, as you saw in the previous chapter,
    but you should use whichever one makes the most sense to you.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用`ApplyGeoTransform`，正如你在上一章中看到的，但你应该使用对你来说最有意义的任何一个。
- en: 10.3\. Color tables
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 颜色表
- en: In thematic rasters the pixel values represent a classification such as vegetation
    type instead of color information like in a photograph. If you want to control
    how these datasets are displayed, then you need a color table. The map of Utah
    vegetation types shown back in [figure 10.1](#ch10fig01) uses a color table so
    that the image looks the same whether you open it in QGIS, ArcMap, or even the
    Windows Photo Viewer. Color tables only work for integer-type rasters, and I have
    only had luck getting the color mapping to work on pixel values of 255 and below
    (values that fit into a byte).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在主题栅格中，像素值代表分类，如植被类型，而不是照片中的颜色信息。如果你想控制这些数据集的显示方式，那么你需要一个颜色表。之前在[图10.1](#ch10fig01)中展示的犹他州植被类型地图使用了颜色表，这样无论你在QGIS、ArcMap还是Windows图片查看器中打开它，图像看起来都一样。颜色表仅适用于整数类型栅格，而且我只在像素值为255以下（适合一个字节的值）的情况下成功实现了颜色映射。
- en: To see how color tables work, let’s create one for an elevation dataset that
    has been classified into ranges. This file has been created for you and is in
    the book data’s Switzerland folder. It’s called dem_class.tif, and the elevation
    values have been classified into five different ranges, so the pixel values range
    from 0 to 5, with 0 being set to `NoData`. If you look at this file in something
    like Windows Photo Viewer, you’ll only see a black rectangle, because that’s how
    it interprets such small pixel values. If you open it up in QGIS or another GIS
    package, it’s likely that the software will automatically stretch the data for
    you so you’ll see something like [figure 10.7](#ch10fig07).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解颜色表是如何工作的，让我们为已经按范围分类的高程数据集创建一个。这个文件已经为你创建好了，位于书中的数据瑞士文件夹中。它叫做dem_class.tif，高程值已经被分类为五个不同的范围，因此像素值范围从0到5，0被设置为`NoData`。如果你在类似Windows图片查看器这样的软件中查看这个文件，你只会看到一个黑色矩形，因为这就是它解释如此小的像素值的方式。如果你在QGIS或另一个GIS软件包中打开它，软件很可能会自动拉伸数据，这样你就会看到类似[图10.7](#ch10fig07)的内容。
- en: Figure 10.7\. Digital elevation model for Switzerland that has been classified
    into five elevation ranges and then stretched so that the small pixel values appear
    different from one another
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.7\. 瑞士数字高程模型，已按五个高程范围分类，然后拉伸，使小像素值彼此不同
- en: '![](10fig07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7](10fig07.jpg)'
- en: If you add a color map to this image, then it will draw correctly without being
    stretched, and you can specify the colors that are used for each elevation range.
    Let’s try it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给这张图片添加一个颜色图，那么它将正确绘制而不会拉伸，你可以指定用于每个高程范围的颜色。让我们试试。
- en: Listing 10.3\. Add a color map to a raster
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 向栅格添加颜色图
- en: '![](216fig01_alt.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1](216fig01_alt.jpg)'
- en: The first part of this listing doesn’t have anything to do with the color table;
    it’s making a copy of the image so that the original doesn’t get modified. The
    interesting part is when you create an empty color table called `colors` and then
    add colors to it. The first parameter to `SetColorEntry` is the pixel value that
    you want to set the color for, and the second parameter is a tuple or list containing
    the red, green, and blue values for the color. You set colors for pixel values
    between 1 and 5, inclusive. Because this is a byte dataset, there are 255 possible
    pixel values and the color table contains zeros (black) for the values that you
    didn’t change. Finally, you add the color map to the band and tell the band that
    it’s using a color map by setting the color interpretation to paletted, although
    that second step isn’t necessary because GDAL figures it out. Now your image looks
    like [figure 10.8](#ch10fig08), although software that doesn’t understand the
    `NoData` setting will draw a black background.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的前一部分与颜色表无关；它是在创建图像的副本，这样原始图像就不会被修改。有趣的部分是当您创建一个名为`colors`的空颜色表并将其添加颜色。`SetColorEntry`的第一个参数是要设置颜色的像素值，第二个参数是包含颜色红色、绿色和蓝色值的元组或列表。您为像素值1到5设置颜色。因为这是一个字节数据集，所以有255个可能的像素值，颜色表包含您未更改的值的零（黑色）。最后，您将颜色图添加到波段，并设置颜色解释为调色板，尽管这一步不是必要的，因为GDAL会自动识别。现在您的图像看起来像[图10.8](#ch10fig08)，尽管不理解`NoData`设置的软件会绘制黑色背景。
- en: Figure 10.8\. Digital elevation model for Switzerland that has been classified
    into five elevation ranges and then had a color map applied. If you look at the
    color version online, it will look much different from the automatic symbology
    shown in [figure 10.7](#ch10fig07).
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.8\. 瑞士的数字高程模型，已被分类为五个海拔范围，并应用了颜色图。如果您在网上查看颜色版本，它将看起来与[图10.7](#ch10fig07)中显示的自动符号学有很大不同。
- en: '![](10fig08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig08.jpg)'
- en: 'You can also edit existing color tables. Say you want to change the color map
    you created so that the highest elevation range displays as something closer to
    white. Grab the color table from the band and change the entry you’re interested
    in, which is the pixel value 5 in this case:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编辑现有的颜色表。比如说，您想更改您创建的颜色图，使得最高海拔范围显示为更接近白色的颜色。从波段中抓取颜色表，并更改您感兴趣的条目，在这个例子中是像素值5：
- en: '![](217fig01_alt.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](217fig01_alt.jpg)'
- en: Remember to open the dataset for writing. If you don’t, your changes won’t take
    effect and you won’t get an error message, either. You also need to add the color
    map back to the band because the one you’re editing is no longer linked to the
    band.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记得打开数据集以供写入。如果您不这样做，您的更改将不会生效，并且您也不会收到错误消息。您还需要将颜色图重新添加到波段，因为您正在编辑的颜色图不再与波段链接。
- en: 10.3.1\. Transparency
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 透明度
- en: 'Have you ever seen colors referred to as RGBA instead of plain RGB? The *A*
    stands for a fourth value called *alpha*, which is used to specify opacity. The
    higher the alpha value, the more opaque the color. You can add an alpha band to
    your image and then certain software packages, such as QGIS, will use it. Others,
    like ArcMap, ignore the alpha band when using color tables. If you want to go
    this route with color tables, you need to create your dataset with two bands,
    where the first one is your pixel values as before, and the second one holds alpha
    values. You also need to specify that this second band is an alpha band at creation
    time, like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否见过颜色被称作RGBA而不是普通的RGB？*A*代表第四个值，称为*alpha*，它用于指定不透明度。alpha值越高，颜色越不透明。您可以为您的图像添加一个alpha波段，然后某些软件包，如QGIS，将使用它。其他软件，如ArcMap，在使用颜色表时忽略alpha波段。如果您想使用颜色表走这条路，您需要创建包含两个波段的您的数据集，其中第一个波段是您之前的像素值，第二个波段包含alpha值。您还需要在创建时指定第二个波段是alpha波段，如下所示：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then add values between 0 and 255 to your alpha band, where 0 means fully transparent
    and 255 is fully opaque. We’ll talk about NumPy in the next chapter, but this
    is how you’d use NumPy to find all pixels in the first band that are equal to
    5 and set them approximately 25% transparent:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在您的alpha波段中添加0到255之间的值，其中0表示完全透明，255表示完全不透明。我们将在下一章讨论NumPy，但这是您如何使用NumPy找到第一个波段中所有等于5的像素并将它们设置为大约25%透明的方法：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here you use the NumPy `where` function to create a new array based on the values
    of the original data array from band 1\. It’s like an if-else statement, where
    the condition is whether or not the pixel value is equal to 5\. If it is, then
    the corresponding cell in the output array gets a value of 65, which is roughly
    a quarter of 255\. If the original pixel has a value other than 0, then the output
    gets a value of 255, which is no transparency. Write that new array to the second
    band, and make sure you set the color interpretation for that band to alpha.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用 NumPy 的 `where` 函数根据第一个通道的原始数据数组的值创建一个新的数组。它就像一个 if-else 语句，条件是像素值是否等于
    5。如果是，那么输出数组中相应的单元格将得到一个值为 65 的值，这大约是 255 的四分之一。如果原始像素的值不是 0，那么输出将得到一个值为 255 的值，这意味着没有透明度。将这个新数组写入第二个通道，并确保你设置了该通道的颜色解释为
    alpha。
- en: If you wanted to create an image with transparency that more software will understand,
    then you could create a four-band image and forego the color map. In this case,
    you’d put the red value in the first band, green in the second, blue in the third,
    and the alpha value in the fourth band. The disadvantage to this is that your
    dataset would be at least twice as large because it would have twice as many bands.
    It would probably have even another band to hold your original pixel values instead
    of only color information. Otherwise, you’d lose your information about pixel
    classifications, such as landcover types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个透明度更易被多种软件理解的图像，那么你可以创建一个四通道图像并放弃使用颜色映射。在这种情况下，你将红色值放在第一个通道，绿色放在第二个通道，蓝色放在第三个通道，而透明度值放在第四个通道。这种方法的缺点是，你的数据集大小至少会增加一倍，因为它会有两倍的通道数。可能还会有另一个通道来存储原始像素值，而不是只有颜色信息。否则，你将丢失关于像素分类的信息，例如土地覆盖类型。
- en: 10.4\. Histograms
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. 直方图
- en: Sometimes you need a frequency histogram for pixel values. One example of this
    would be calculating the area of each vegetation type in a vegetation classification.
    If you know how many pixels are classified as pinyon-juniper, for instance, then
    you can multiply that number by the area of a pixel (which is pixel width times
    pixel height) to get the total acreage of pinyon-juniper.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要像素值的频率直方图。一个例子是计算植被分类中每种植被类型的面积。例如，如果你知道有多少像素被分类为松树-刺柏，那么你可以将这个数字乘以像素面积（即像素宽度乘以像素高度）来得到松树-刺柏的总英亩数。
- en: 'The easiest way to get a histogram is to use the `GetHistogram` function on
    a band. You can specify exactly what bins you want to use, but the default is
    to use 256 of them. The first one includes values between -0.5 and 0.5, the second
    bin goes from 0.5 to 1.5, and so on. So if you have byte data, this histogram
    will have one bin per possible pixel value (0, 1, 2, and so on). If no histogram
    data already exist for the raster, then this function computes an approximate
    one by default, but you can request an exact one. The function looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 获取直方图的最简单方法是使用通道上的 `GetHistogram` 函数。你可以指定你想要使用的确切箱数，但默认情况下是使用 256 个。第一个箱包括介于
    -0.5 和 0.5 之间的值，第二个箱从 0.5 到 1.5，以此类推。所以如果你有字节数据，这个直方图将每个可能的像素值（0，1，2 等）对应一个箱。如果栅格中没有现有的直方图数据，那么这个函数默认会计算一个近似值，但你也可以请求一个精确值。这个函数看起来是这样的：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`min` is the minimum pixel value to include in the histogram. The default value
    is 0.5.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min` 是包含在直方图中的最小像素值。默认值是 0.5。'
- en: '`max` is the maximum pixel value to include in the histogram. The default value
    is 255.5.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max` 是包含在直方图中的最大像素值。默认值是 255.5。'
- en: '`buckets` is the number of bins you want. The size of the bins is determined
    by taking the difference between `max` and `min` and dividing that by `buckets`.
    The default value is 256.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buckets` 是你想要的箱数。箱的大小是通过将 `max` 和 `min` 之间的差值除以 `buckets` 来确定的。默认值是 256。'
- en: '`include_out_of_range` denotes whether or not to lump pixel values below the
    minimum value into the minimum bin, and the pixel values larger than the maximum
    into the maximum bin. The default value is `False`. Use `True` if you want to
    enable this behavior.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include_out_of_range` 表示是否将低于最小值的像素值合并到最小箱中，以及将高于最大值的像素值合并到最大箱中。默认值是 `False`。如果你想启用此行为，请使用
    `True`。'
- en: '`approx_ok` denotes whether or not it’s okay to use approximate numbers, either
    by looking at overviews or only sampling a subset of the pixels. The function
    will run faster this way. The default value is `True`. Use `False` if you want
    exact counts.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`approx_ok` 表示是否可以使用近似数字，无论是通过查看概览还是仅采样像素子集。这样函数将运行得更快。默认值是 `True`。如果你想得到精确计数，请使用
    `False`。'
- en: '`callback` is a function that’s called periodically while the histogram is
    being computed. This is useful for showing progress while processing large datasets.
    The default value is 0, which means you don’t want to use a callback function.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback` 是一个在计算直方图期间周期性调用的函数。这在处理大型数据集时显示进度非常有用。默认值是 0，这意味着你不想使用回调函数。'
- en: '`callback_data` is data to pass to the callback function if you’re using one.
    The default value is `None`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback_data` 是如果你使用回调函数时传递给回调函数的数据。默认值是 `None`。'
- en: 'This code snippet shows the difference between approximate and exact values,
    using the classified elevation raster that we looked at earlier:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段显示了近似值和精确值之间的差异，使用的是我们之前查看的分类高程栅格：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The histogram consists of a list of counts, in order by bin. In this case the
    first count corresponds to pixel value 0, the second to pixel value 1, and so
    on. Here you only print the first seven entries, because the remaining 249 of
    them are all 0 for this dataset. The results are shown here and in [figure 10.9](#ch10fig09):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图由按区间顺序排列的计数列表组成。在这种情况下，第一个计数对应于像素值 0，第二个对应于像素值 1，依此类推。这里你只打印前七个条目，因为剩下的 249
    个条目在这个数据集中都是 0。结果在这里和 [图 10.9](#ch10fig09) 中显示：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 10.9\. The approximate and exact histograms generated from the classified
    elevation raster
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.9\. 从分类高程栅格生成的近似和精确直方图
- en: '![](10fig09.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig09.jpg)'
- en: Notice that the numbers, including the sum, for the approximate histogram are
    much smaller than those for the exact. Therefore, the approximate numbers are
    not the way to go if you need to tabulate area, but they’d probably work well
    if you want relative frequencies. Also notice that no counts exist for a pixel
    value of 0\. That’s because 0 is set to `NoData`, so it gets ignored.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到，包括总和在内的数字对于近似直方图要小得多。因此，如果你需要编制面积表，近似数字不是最佳选择，但如果你想要相对频率，它们可能工作得很好。也请注意，没有像素值为
    0 的计数。这是因为 0 被设置为 `NoData`，所以它被忽略。
- en: GDAL stores these histograms in an XML file alongside the raster. If you ran
    this code, there should now be a file called dem_class2.tif.aux.xml in your Switzerland
    folder. If you open it and take a look, you’ll see both sets of histogram data.
    As long as you don’t delete that file, those specific histograms won’t need to
    be computed again because GDAL can read the information from the XML file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL 将这些直方图存储在与栅格一起的 XML 文件中。如果你运行了此代码，现在在你的瑞士文件夹中应该有一个名为 dem_class2.tif.aux.xml
    的文件。如果你打开它并查看，你会看到两组直方图数据。只要你不删除该文件，那些特定的直方图就不需要再次计算，因为 GDAL 可以从 XML 文件中读取信息。
- en: 'You can also set a certain binning scheme to be the default for an image. For
    example, say you want to lump pixel values 1 and 2 together, 3 and 4 together,
    and leave 5 alone. You can do that like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将某个特定的区间方案设置为图像的默认值。例如，假设你想要将像素值 1 和 2 合并在一起，3 和 4 合并在一起，而将 5 独立出来。你可以这样做：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, you create a histogram with three bins that include pixel values
    1 through 6\. Why go up to 6 instead of 5, when the actual data values only go
    up to 5? The bins are created of equal size, so if there were three bins between
    1 and 5, then the breaks would be in the wrong places. The breaks for the example
    would be at 2.5 and 4.5, but they would be at 2.2 and 3.8 if you used a range
    of 5 instead of 6\. In that case, the pixels with values 4 and 5 would be lumped
    together and 3 would be alone, which isn’t the desired outcome ([figure 10.10](#ch10fig10)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你创建了一个包含像素值 1 到 6 的三个区间的直方图。为什么是 6 而不是 5，当实际数据值只到 5 时？区间被创建为相等的大小，所以如果在
    1 和 5 之间有三个区间，那么断点就会在错误的位置。示例中的断点将是 2.5 和 4.5，但如果你使用 5 而不是 6 的范围，它们将是 2.2 和 3.8。在这种情况下，值为
    4 和 5 的像素将被合并在一起，而值为 3 的像素将单独存在，这不是期望的结果 ([图 10.10](#ch10fig10))。
- en: Figure 10.10\. The results of creating three bins between 0.5 and 6.5 (A) and
    0.5 and 5.5 (B). In case A, values 1 and 2 share a bin, 3 and 4 share a bin, and
    5 has a bin to itself (there are no pixels with a value of 6). In case B, however,
    value 3 is the one that doesn’t share a bin.
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.10\. 在0.5和6.5（A）以及0.5和5.5（B）之间创建三个箱的结果。在情况A中，值1和2共享一个箱，值3和4共享一个箱，值5有一个单独的箱（没有值为6的像素）。然而，在情况B中，值3是唯一一个不共享箱的值。
- en: '![](10fig10_alt.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig10_alt.jpg)'
- en: 'Once you compute the histogram, you set it as the default. The `SetDefault-Histogram`
    function wants a minimum pixel value, maximum value, and then the list of counts.
    Once you’ve set a default, you can use `GetDefaultHistogram` to get that particular
    one. While `GetHistogram` returns a list of counts, `GetDefaultHistogram` returns
    a tuple containing the minimum pixel value, maximum pixel value, number of bins,
    and a list of counts:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算了直方图，您就可以将其设置为默认值。`SetDefault-Histogram`函数需要一个最小像素值、最大值，然后是计数列表。一旦设置了默认值，您就可以使用`GetDefaultHistogram`来获取特定的那个。当`GetHistogram`返回一个计数列表时，`GetDefaultHistogram`返回一个包含最小像素值、最大像素值、箱数和计数列表的元组：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When you call `GetHistogram,` you provide the min and max values and the number
    of bins to use, so that function doesn’t need to return that information because
    you already know it. These values are returned when you call `GetDefaultHistogram`
    because you might not know what values were used to create the default histogram.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`GetHistogram`时，您提供最小值、最大值和要使用的箱数，因此该函数不需要返回该信息，因为您已经知道了。当您调用`GetDefaultHistogram`时返回这些值，因为您可能不知道用于创建默认直方图的值。
- en: 10.5\. Attribute tables
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5\. 属性表
- en: Integer raster datasets can have attribute tables, although in my experience
    they don’t have nearly as many fields as vector attribute tables. Instead of a
    record in the table corresponding to an individual feature, each record of a raster
    attribute table corresponds to a particular pixel value. For example, all pixels
    with a value of 56 will share the same record in the attribute table, because
    each pixel doesn’t represent an individual feature, but multiple pixels with the
    same value should represent the same thing, whether it’s a certain color, an elevation,
    a land use classification, or something else.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 整数栅格数据集可以具有属性表，尽管根据我的经验，它们拥有的字段数量远不及矢量属性表。在表中，与单个要素对应的记录，每个栅格属性表的记录对应于特定的像素值。例如，所有值为56的像素将在属性表中共享相同的记录，因为每个像素不代表单个要素，而是具有相同值的多个像素应该代表相同的事物，无论是某种颜色、高程、土地利用分类还是其他事物。
- en: An attribute table doesn’t even make sense for many rasters. I can’t think of
    an attribute I would want to attach to various pixel values in an aerial photo,
    for example. In fact, raster attribute tables make the most sense for categorical
    data such as landcover or soil type, when you’d want attributes containing information
    about each category.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多栅格，属性表甚至没有意义。例如，我想不出要附加到航空照片中各种像素值的属性。事实上，当您想要包含有关每个类别的信息时，栅格属性表对于分类数据（如土地覆盖或土壤类型）最有意义。
- en: Let’s create an attribute table for the classified elevation raster we’ve been
    working with. [Table 10.2](#ch10table02) shows the elevation classes used to create
    the dataset, which would be useful information to store.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们在工作中使用的分类高程栅格创建一个属性表。[表10.2](#ch10table02)显示了用于创建数据集的高程类别，这些信息存储起来将非常有用。
- en: Table 10.2\. Pixel values and the corresponding elevation ranges for the classified
    elevation raster
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.2\. 分类高程栅格的像素值及其对应的高程范围
- en: '| Pixel value | Elevation range (meters) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 像素值 | 高程范围（米） |'
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 0 – 800 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 – 800 |'
- en: '| 2 | 800 – 1300 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 800 – 1300 |'
- en: '| 3 | 1300 – 2000 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 1300 – 2000 |'
- en: '| 4 | 2000 – 2600 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2000 – 2600 |'
- en: '| 5 | 2600+ |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 2600+ |'
- en: We’ll use the code in the following listing to add the information from [table
    10.2](#ch10table02) along with the histogram counts to the raster’s attribute
    table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下列表中的代码将[表10.2](#ch10table02)中的信息以及直方图计数添加到栅格的属性表中。
- en: Listing 10.4\. Add an attribute table to a raster
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4\. 向栅格添加属性表
- en: '![](222fig01_alt.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](222fig01_alt.jpg)'
- en: When you create a new raster attribute table, you need to define the columns
    it will have. You provide three pieces of information when you add a column. The
    first is the name of the column. The second is the data type, which can be one
    of `GFT_Integer`, `GFT_Real`, or `GFT_String`. The last thing is the purpose of
    the column using one of the GFU constants from appendix E. (Appendixes C through
    E are available online on the Manning Publications website at [https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python).)
    The desktop software I use either doesn’t support raster attribute tables at all
    (QGIS) or doesn’t see most of them as anything special (ArcGIS), but there’s probably
    software out there that does. Therefore, the only types I’m usually interested
    in are the ones used here. You used `GFU_Name` for the column containing the pixel
    values, `GFU_PixelCount` for the histogram counts, and `GFU_Generic` for the description.
    You also told it that there will be six rows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新的栅格属性表时，你需要定义它将拥有的列。当你添加列时，你提供三条信息。第一条是列名。第二条是数据类型，可以是`GFT_Integer`、`GFT_Real`或`GFT_String`之一。最后一件事情是使用附录E中的GFU常量之一来指定列的用途。（附录C至E可在Manning
    Publications网站上在线获取，网址为[https://www.manning.com/books/geoprocessing-with-python](https://www.manning.com/books/geoprocessing-with-python)。）我使用的桌面软件要么根本不支持栅格属性表（QGIS），要么不把它们看作特别的东西（ArcGIS），但可能存在支持这些功能的软件。因此，我通常只对这里使用的类型感兴趣。你为包含像素值的列使用了`GFU_Name`，为直方图计数使用了`GFU_PixelCount`，为描述使用了`GFU_Generic`。你还告诉它将有六行。
- en: The next step is to add the data. You know the pixel values range from 0 to
    5, so you use the `range` function to get a list containing those numbers and
    then add that list to the first column, which is pixel values. The first parameter
    to `WriteArray` is the data to put in the column, and the second parameter is
    the index of the column that you want to add the data to. Because you already
    specified that there were six rows, you’d have gotten an error about too many
    values if you’d provided a list with more than six items. You don’t have to write
    all rows at once, though. If you’d only provided four values, it would have filled
    the first four rows of the column. An optional third parameter tells it which
    row to begin writing data on, so you could then add the remaining data by passing
    a 4 as the last parameter so that it would start writing on the correct row.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加数据。你知道像素值范围从0到5，所以你使用`range`函数来获取包含这些数字的列表，然后将该列表添加到第一列，即像素值列。`WriteArray`的第一个参数是要放入列中的数据，第二个参数是你想要添加数据的列的索引。因为你已经指定了有六行，如果你提供了一个包含超过六个项目的列表，你会得到一个错误，提示值过多。不过，你不必一次性写入所有行。如果你只提供了四个值，它就会填充该列的前四行。可选的第三个参数告诉它从哪一行开始写入数据，因此你可以通过传递4作为最后一个参数来添加剩余的数据，这样它就会从正确的行开始写入。
- en: You use this same method to add the histogram counts to the second column, except
    this time the list of values comes from the `GetHistogram` function. Remember
    that the 0 values are ignored when computing histograms, but you might want the
    number of zeros in the attribute table. One way to get a histogram that includes
    those values is to set `NoData` to a bogus value and then calculate a histogram
    that hasn’t been calculated before. It needs to be a new histogram because if
    that particular one has already been calculated, then GDAL will pull the information
    out of the XML file you saw earlier, and the zeros still won’t be counted. That’s
    why you set `NoData` to -1 before creating the attribute table, and then use a
    set of parameters that you haven’t yet used to retrieve a histogram. Conveniently,
    you tell it that you want six bins, which is exactly how many rows the table has.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用相同的方法将直方图计数添加到第二列，除了这次值的列表来自`GetHistogram`函数。记住，在计算直方图时，0值会被忽略，但你可能想在属性表中看到零的个数。获取包含这些值的直方图的一种方法是将`NoData`设置为无效值，然后计算一个之前未计算过的直方图。它需要是一个新的直方图，因为如果这个特定的直方图已经被计算过，那么GDAL会从你之前看到的XML文件中提取信息，而零仍然不会被计算。这就是为什么你在创建属性表之前将`NoData`设置为-1，然后使用一组你尚未使用的参数来检索直方图。方便的是，你告诉它你想要六个桶，这正好与表中的行数相同。
- en: Then you set the elevation ranges. You could create a list holding those descriptions,
    but instead you add each one individually by specifying the row, then the column,
    and then the value to put in the table. You don’t bother adding a description
    for the first row with index 0, because there’s not much to say about `NoData`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你设置高程范围。你可以创建一个包含这些描述的列表，但相反，你通过指定行、然后是列，最后是放入表中的值来逐个添加每一个。你不必为索引为0的第一行添加描述，因为没有太多关于`NoData`可以说的。
- en: Once you add all of your data to the table, you add it to the band with `SetDefaultRAT`,
    and then make sure to restore the `NoData` value to your band. [Figure 10.11](#ch10fig11)
    shows a screenshot of this raster attribute table in ArcGIS. Unfortunately, you
    can’t view the results with QGIS.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将所有数据添加到表中，你使用`SetDefaultRAT`将其添加到波段中，然后确保将`NoData`值恢复到你的波段中。[图10.11](#ch10fig11)显示了在ArcGIS中这个栅格属性表的截图。不幸的是，你无法使用QGIS查看结果。
- en: Figure 10.11\. Raster attribute table for the classified elevation raster
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.11. 分类高程光栅的栅格属性表
- en: '![](10fig11.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig11.jpg)'
- en: 10.6\. Virtual raster format
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6. 虚拟光栅格式
- en: The GDAL virtual format (VRT) isn’t another property you can add to a raster,
    like an attribute or color table, but it’s a useful format that allows you to
    define a dataset using an XML file. Virtual raster datasets use other datasets
    to store the data, but the XML describes how to pull the data out of those other
    files. A VRT can be used to subset the data, modify properties such as the projection,
    or even combine multiple datasets into one. In these cases, the original datasets
    aren’t changed, but the modifications are made to the data in memory when it’s
    read by the software.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL虚拟格式（VRT）不是你可以添加到光栅上的另一个属性，比如属性或颜色表，但它是一个有用的格式，允许你使用XML文件定义数据集。虚拟光栅数据集使用其他数据集来存储数据，但XML描述了如何从这些其他文件中提取数据。VRT可以用来分割数据，修改如投影等属性，甚至可以将多个数据集合并成一个。在这些情况下，原始数据集不会被更改，但修改是在软件读取数据时在内存中的数据上进行的。
- en: For example, say you had a raster dataset that covered a large spatial area,
    but you needed to run different analyses on various spatial subsets of the original
    raster. You could clip out the areas you need, or you could define a VRT for each
    of these subsets and not have to create the subsetted rasters on disk. For even
    more information on VRTs than you will see here, check out [http://www.gdal.org/gdal_vrttut.html](http://www.gdal.org/gdal_vrttut.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个覆盖了广大空间区域的光栅数据集，但你需要在原始光栅的不同空间子集上运行不同的分析。你可以裁剪出你需要的区域，或者你可以为这些子集中的每一个定义一个VRT，而不必在磁盘上创建分割后的光栅。对于比这里看到的更多关于VRT的信息，请查看[http://www.gdal.org/gdal_vrttut.html](http://www.gdal.org/gdal_vrttut.html)。
- en: Before we look at manipulating data with a VRT, let’s look at an extremely simple
    example (called simple_example.vrt in the Landsat/Washington data folder). This
    XML defines a VRT dataset with one band, and that band is the blue band from the
    natural color GeoTIFF you created in the last chapter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看使用VRT操作数据之前，让我们看看一个非常简单的例子（在Landsat/Washington数据文件夹中称为simple_example.vrt）。这个XML定义了一个具有一个波段的VRT数据集，而这个波段是你在上一章中创建的自然色GeoTIFF中的蓝色波段。
- en: Listing 10.5\. XML to define a VRT dataset with one band
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5. 定义一个具有一个波段的VRT数据集的XML
- en: '![](224fig01_alt.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](224fig01_alt.jpg)'
- en: This XML contains general dataset information such as the numbers of rows and
    columns, the spatial reference system, and the geotransform. The SRS needs to
    be in WKT, which would have taken up a lot of space, so I opted to truncate it
    for the example (the third line). In real life, you’d need the entire SRS string.
    There’s also a `VRTRasterBand` element for each band in the dataset, which is
    only one in this case. This contains the data type, band number, rows and columns,
    and the information required to load the data. This is a simple case, so it only
    needs a filename and a band number. You want the blue band, which is the third
    one in nat_color.tif. The `relativeToVRT` attribute tells it whether or not the
    file path to the data is relative to the location of the VRT file itself. If you
    want an absolute filename, use a 0 here. In this particular case, the image file
    and the VRT file are in the same directory, but if you were to move the VRT file
    without moving the image file, the VRT would be unable to load any data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此 XML 包含一般数据集信息，例如行数和列数、空间参考系统以及地理变换。SRS 需要使用 WKT，这将占用很多空间，所以我选择在示例中截断它（第三行）。在现实生活中，你需要整个
    SRS 字符串。还有一个 `VRTRasterBand` 元素用于数据集中的每个波段，在本例中只有一个。这包含数据类型、波段号、行数和列数以及加载数据所需的信息。这是一个简单的情况，因此只需要文件名和波段号。你想要蓝色波段，这是
    nat_color.tif 中的第三个波段。`relativeToVRT` 属性告诉它数据文件的路径是否相对于 VRT 文件的位置。如果你想使用绝对文件名，这里使用
    0。在这个特定的情况下，图像文件和 VRT 文件在同一个目录中，但如果你要移动 VRT 文件而不移动图像文件，VRT 将无法加载数据。
- en: 'Creating VRT datasets from Python can be a bit tricky because you need to supply
    part of the XML yourself. The most basic example is providing the source filename
    and band number. You could set up an XML template something like the following
    and then use it when adding bands to the VRT:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 创建 VRT 数据集可能有点棘手，因为你需要自己提供部分 XML。最基本的一个例子是提供源文件名和波段号。你可以设置一个类似于以下的
    XML 模板，然后在添加波段到 VRT 时使用它：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This snippet assumes that you’ll always use the first band from the source
    raster. That’s because you’re going to use it to define a natural color raster
    without copying any data around like you did in the last chapter, and each of
    the input rasters only has one band anyway. Most things work the same way with
    a VRT as they do for other dataset types, so creating the new dataset is the same
    as before. Even though no data will be copied, you still need to make sure that
    you create the dataset with the same dimensions as the originals:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码段假设你将始终使用源栅格的第一个波段。这是因为你将使用它来定义一个自然色栅格，而不像上一章那样复制任何数据，而且每个输入栅格只有一个波段。大多数事情在
    VRT 中与其他数据集类型的工作方式相同，因此创建新数据集的方式与之前相同。即使没有数据被复制，你仍然需要确保创建的数据集与原始数据集具有相同的尺寸：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you can go about adding the links to the three input rasters. For each one,
    you need to create a dictionary with one entry, where the key is `'source_0'`
    and the value is the XML string containing the filename. Then you add that dictionary
    as metadata for the band in the `'vrt_sources'` domain. Repeat this process for
    all three bands.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始添加三个输入栅格的链接。对于每一个，你需要创建一个包含一个条目的字典，其中键是 `'source_0'`，值是包含文件名的 XML 字符串。然后你将这个字典作为
    `'vrt_sources'` 域中波段的元数据添加。为所有三个波段重复此过程。
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you can use QGIS to open the VRT dataset, and you’ll see a three-band image
    such as that shown in [figure 10.12](#ch10fig12). Unlike the GeoTIFF you created
    before, this won’t open up in regular image-processing software, however.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 QGIS 打开 VRT 数据集，你会看到一个三波段图像，如图 10.12 所示。[#ch10fig12]。与之前创建的 GeoTIFF
    不同，这个不会在常规图像处理软件中打开。
- en: Figure 10.12\. Stacked VRT created from three single-band images. It doesn’t
    look like much when printed in black and white, but you can view the color version
    online, which will look like natural color (the way our eyes would see it).
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.12\. 由三个单波段图像创建的堆叠 VRT。当以黑白打印时，看起来并不起眼，但你可以在线查看彩色版本，它看起来就像自然色（就像我们的眼睛看到的那样）。
- en: '![](10fig12.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig12.jpg)'
- en: 10.6.1\. Subsetting
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.1\. 子集
- en: I mentioned earlier that you can use VRTs to subset images without creating
    another subsetted image. The process of creating the empty dataset is similar
    to what you did in the previous chapter when subsetting. You still need to figure
    out the numbers of rows and columns and the new geotransform, and then use that
    information to create the new dataset. That’s what the first part of the following
    listing does, except that it uses a VRT driver. Things change after you create
    the dataset, however, because in this example you need to create the appropriate
    XML for each raster band and insert it into the VRT. The process is explained
    after the code listing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，你可以使用VRT来子集图像而不创建另一个子集图像。创建空数据集的过程与上一章子集时所做的类似。你仍然需要确定行和列的数量以及新的地理变换，然后使用这些信息来创建新的数据集。这就是以下列表的第一部分所做的事情，除了它使用VRT驱动程序。然而，在创建数据集之后，情况会有所变化，因为在这个例子中，你需要为每个栅格波段创建适当的XML并将其插入到VRT中。这个过程将在代码列表之后进行解释。
- en: Listing 10.6\. Subset a raster using a VRT
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. 使用VRT子集栅格
- en: '![](ch10ex06-0.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex06-0.jpg)'
- en: '![](ch10ex06-1.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch10ex06-1.jpg)'
- en: 'As mentioned right before the code listing, you have to create XML to subset
    your raster with a VRT. This XML is slightly more complicated than the XML you
    used a minute ago, because it also includes elements for the source and destination
    extents. The numbers of rows and columns are the same size for both the source
    and destination and are the numbers you calculate. The offsets for the source
    are the offsets you compute to correspond with the upper-left corner of the area
    of interest, and the offsets for the destination are both 0 because you fill the
    entire output image:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码列表之前所述，你必须创建XML来使用VRT子集你的栅格数据。这个XML比刚才使用的XML稍微复杂一些，因为它还包括源和目标范围元素。源和目标行和列的数量相同，并且是计算出的数字。源偏移量是你计算出的与感兴趣区域左上角相对应的偏移量，而目标偏移量都是0，因为你填充了整个输出图像：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This time you use named placeholders in the XML to make it easier to see what
    goes where. To format this string, you need a dictionary with the same keys as
    placeholders. You can create this dictionary once and then change the band number
    (because you’re using a different band from the three-band input image each time)
    when you add a new band to the VRT:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这次你在XML中使用命名占位符来使其更容易看出内容的位置。为了格式化这个字符串，你需要一个与占位符具有相同键的字典。你可以创建这个字典一次，然后在向VRT添加新波段时更改波段号（因为你每次使用的是来自三波段输入图像的不同波段）：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If all went well, the VRT will look like [figure 10.13](#ch10fig13) if you open
    it in QGIS, and it will overlay perfectly on the original image.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，当你用QGIS打开VRT时，它将看起来像[图10.13](#ch10fig13)，并且它将完美地覆盖原始图像。
- en: Figure 10.13\. Subsetted VRT
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.13\. 子集化的VRT
- en: '![](10fig13.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig13.jpg)'
- en: 10.6.2\. Creating troublesome formats
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.2\. 创建麻烦的格式
- en: 'Not all raster formats allow you to create and manipulate multiple-band images.
    For example, if you’d tried to create a natural color JPEG instead of a TIFF in
    the previous chapter, you would have run into problems because the JPEG driver
    doesn’t allow you to create a multiband image and then add data to the bands.
    That’s a real problem if you want JPEG output! Fortunately, VRTs can come to your
    rescue. All you need to do is create a VRT that defines the output you want, and
    then use the JPEG (or whatever format) driver’s `CreateCopy` function. For example,
    to create a JPEG of Vashon Island, open up the VRT you created in the last section
    and then copy it to a JPEG:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有栅格格式都允许你创建和操作多波段图像。例如，如果你在上一章尝试创建一个自然色JPEG而不是TIFF，你会遇到问题，因为JPEG驱动程序不允许你创建多波段图像并向波段添加数据。如果你想要JPEG输出，这确实是个问题！幸运的是，VRT可以救你于水火。你所需要做的就是创建一个定义所需输出的VRT，然后使用JPEG（或任何格式）驱动程序的`CreateCopy`函数。例如，要创建瓦森岛的JPEG，打开上一节中创建的VRT，然后将其复制到JPEG：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you’d rather create an intermediate TIFF instead of a VRT, go right ahead,
    and then copy the TIFF to a JPEG. The advantage to using a VRT is that you’re
    not creating possibly large intermediate files on disk.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意创建一个中间的TIFF文件而不是VRT，那么请直接进行，然后将TIFF文件复制为JPEG。使用VRT的优势在于你不会在磁盘上创建可能很大的中间文件。
- en: 10.6.3\. Reprojecting images
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.6.3\. 重投影图像
- en: Remember talking about reprojecting vector data in [chapter 8](kindle_split_016.html#ch08)?
    Raster data can also be reprojected, but it’s more complicated than with vector
    data. With vectors, you need the new coordinates for each vertex and you’re good
    to go, but with rasters you need to deal with the fact that cells get bent and
    moved around, and a one-to-one mapping from old cell locations to new cell locations
    doesn’t exist (see [figure 10.14](#ch10fig14)). The easiest way to determine the
    pixel value for a new cell is use the value from the input cell that gets mapped
    closest to the output cell. This is called nearest-neighbor and is the fastest
    method, the one you’ll usually want for categorical data. All others, except mode,
    will change your categories, which you definitely don’t want for categorical data.
    Continuous data rasters usually won’t look good if you use nearest-neighbor, however.
    For those, I generally use bilinear interpolation or cubic convolution, which
    use an average of surrounding pixels. Several other methods are available, however,
    that might be more appropriate for your particular data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第 8 章](kindle_split_016.html#ch08)中提到过重新投影矢量数据吗？栅格数据也可以进行重新投影，但比矢量数据更复杂。对于矢量数据，您需要每个顶点的新坐标，然后就可以开始了，但对于栅格数据，您需要处理单元格弯曲和移动的事实，并且不存在从旧单元格位置到新单元格位置的一对一映射（见[图
    10.14](#ch10fig14)）。确定新单元格像素值的最简单方法是使用映射到输出单元格最近的输入单元格的值。这被称为最近邻，是速度最快的方法，通常您会希望用于分类数据。所有其他方法（除模态外）都会更改您的类别，这对于分类数据来说绝对不是您想要的。然而，如果使用最近邻，连续数据栅格通常看起来不会很好。对于这些，我通常使用双线性插值或立方卷积，它们使用周围像素的平均值。然而，还有其他一些方法可能更适合您的特定数据。
- en: Figure 10.14\. Example of how pixels get moved around when the raster is projected.
    The triangles and circles are pixel center points for two different rasters. The
    triangles were created from a reprojected version of the raster that the circles
    came from. Notice that the dimensions are even different.
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.14\. 当栅格投影时像素移动的示例。三角形和圆形是两个不同栅格的像素中心点。三角形是从圆形来源的栅格重新投影版本创建的。请注意，尺寸甚至不同。
- en: '![](10fig14.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig14.jpg)'
- en: 'I think that the easiest way to reproject a raster, other than using the gdalwarp
    utility that comes with GDAL, is to use a VRT. There’s a handy function that creates
    a reprojected VRT dataset for you when you provide the spatial reference information.
    It looks like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为除了使用 GDAL 中的 gdalwarp 工具之外，重新投影栅格最简单的方法是使用 VRT。有一个方便的函数，当您提供空间参考信息时，它会为您创建一个重新投影的
    VRT 数据集。它看起来像这样：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`src_ds` is the dataset you want to reproject.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src_ds` 是您想要重新投影的数据集。'
- en: '`src_wkt` is the WKT representation of the source spatial reference system.
    The default is `None`, in which case it will use the SRS information from the
    source raster. If this raster doesn’t have SRS information, then you need to provide
    it here. You can also provide it here if using `None` makes you nervous.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src_wkt` 是源空间参考系统的 WKT 表示。默认为 `None`，在这种情况下它将使用源栅格的 SRS 信息。如果这个栅格没有 SRS 信息，那么您需要在这里提供它。如果您使用
    `None` 让您感到不安，您也可以在这里提供它。'
- en: '`dst_wkt` is the WKT representation of the desired spatial reference system.
    The default is `None`, in which case no reprojection will occur.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dst_wkt` 是所需空间参考系统的 WKT 表示。默认为 `None`，在这种情况下不会发生重新投影。'
- en: '`eRasampleAlg` is one of the resampling methods from [table 10.3](#ch10table03).
    The default is `GRA_NearestNeighbour`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eRasampleAlg` 是 [表 10.3](#ch10table03) 中的重采样方法之一。默认为 `GRA_NearestNeighbour`。'
- en: Table 10.3\. Resample methods
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 10.3\. 重采样方法
- en: '| Constant | Description |'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| Constant | 描述 |'
- en: '| --- | --- |'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GRA_NearestNeighbour | Closest pixel |'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GRA_NearestNeighbour | 最近的像素 |'
- en: '| GRA_Bilinear | Weighted distance average of 4 pixels |'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GRA_Bilinear | 4 像素的加权距离平均值 |'
- en: '| GRA_Cubic | Average of 16 pixels |'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GRA_Cubic | 16 像素的平均值 |'
- en: '| GRA_CubicSpline | Cubic B-spline of 16 pixels |'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GRA_CubicSpline | 16 像素的立方 B 样条 |'
- en: '| GRA_Lanczos | Lanczos windowed sinc with 36 pixels |'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GRA_Lanczos | Lanczos 窗口 sinc，具有 36 像素 |'
- en: '| GRA_Average | Average |'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GRA_Average | 平均值 |'
- en: '| GRA_Mode | Most common value |'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| GRA_Mode | 最常见的值 |'
- en: '`maxerror` is the maximum amount of error, in pixels, that you want to allow.
    The default is 0, for an exact calculation.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxerror` 是您想要允许的最大误差量，以像素为单位。默认为 0，表示精确计算。'
- en: 'The `AutoCreateWarpedVRT` function doesn’t create a VRT file on disk, but returns
    a dataset object that you can then save to another format using `CreateCopy`.
    The following example takes the natural color Landsat image that uses a UTM spatial
    reference, creates a warped VRT with a destination SRS of unprojected WGS84, and
    copies the VRT to a GeoTIFF:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoCreateWarpedVRT` 函数不会在磁盘上创建 VRT 文件，而是返回一个数据集对象，您可以使用 `CreateCopy` 将其保存为其他格式。以下示例使用具有
    UTM 空间参考的自然色 Landsat 图像，创建一个目标 SRS 为未投影 WGS84 的扭曲 VRT，并将 VRT 复制到 GeoTIFF：'
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The output from this looks like [figure 10.15](#ch10fig15).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出的外观类似于 [图 10.15](#ch10fig15)。
- en: Figure 10.15\. The original Landsat image that uses a UTM spatial reference,
    and the new one that uses unprojected lat/lon coordinates
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.15\. 使用 UTM 空间参考的原始 Landsat 图像，以及使用未投影经纬度坐标的新图像
- en: '![](10fig15.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig15.jpg)'
- en: 10.7\. Callback functions
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.7\. 回调函数
- en: Often you want an indication of how long your process is going to take or how
    far along it is. If I’m batch processing multiple files, and each one takes a
    long time, I’ll sometimes have my code print out a message telling me which file
    it’s currently working on. That’s not a useful technique if I want to see the
    progress of a GDAL function, such as computing statistics or warping an image,
    because that bit of processing is out of my hands once I call the function. Fortunately,
    the GDAL developers thought of this, and many functions take callback functions
    as arguments (in fact, you saw this in the signature for `Get-Histogram`). A callback
    function is one that gets passed to another function and is then called from the
    function it was passed to ([figure 10.16](#ch10fig16)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通常您希望有一个指示您的过程将花费多长时间或它已经进行到什么程度。如果我正在批量处理多个文件，每个文件都需要很长时间，我有时会让我的代码打印出一条消息，告诉我它目前正在处理哪个文件。如果我想查看
    GDAL 函数（如计算统计数据或扭曲图像）的进度，这不是一个有用的技术，因为一旦我调用函数，这部分处理就不再在我手中。幸运的是，GDAL 开发者想到了这一点，许多函数都接受回调函数作为参数（实际上，您在
    `Get-Histogram` 的签名中看到了这一点）。回调函数是传递给另一个函数并从传递给它的函数中调用的函数（[图 10.16](#ch10fig16)）。
- en: Figure 10.16\. Callbacks are functions that get passed as parameters to a second
    function, where they’re later called.
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.16\. 回调函数是作为参数传递给第二个函数的函数，稍后会被调用。
- en: '![](10fig16.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig16.jpg)'
- en: 'In the case of GDAL, the callback functions are designed to show progress,
    so they get called often as the process runs. A predefined function is even available
    for you to use that prints a percentage or a dot at every 2.5% of progress. By
    the time the process has finished, the output from this function looks like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GDAL 的情况下，回调函数被设计用来显示进度，因此它们在过程运行时会频繁调用。甚至有一个预定义的函数可供您使用，它会在每 2.5% 的进度处打印一个百分比或点。到过程完成时，此函数的输出如下所示：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To take advantage of this, just pass `gdal.TermProgress_nocb` to any function
    that takes a callback function as a parameter. This example would cause progress
    information to be printed while calculating statistics:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用这一点，只需将 `gdal.TermProgress_nocb` 传递给任何接受回调函数作为参数的函数。此示例会在计算统计数据时打印进度信息：
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Several of the methods on OGR layers, such as `Intersection` and `Union`, also
    accept a callback parameter. To use it, import GDAL and pass `gdal.TermProgress_nocb`
    as you do with GDAL functions. You could also use callbacks to track the progress
    of your vector-processing functions using the techniques shown here.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: OGR 层上的某些方法，如 `Intersection` 和 `Union`，也接受回调参数。要使用它，导入 GDAL 并将 `gdal.TermProgress_nocb`
    传递，就像传递给 GDAL 函数一样。您还可以使用回调来跟踪您矢量处理函数的进度，使用这里显示的技术。
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You can also use this function to print out the progress of your own functions.
    Instead of passing the `TermProgress_nocb` function to another function, call
    it yourself with the appropriate percentage. For example, if I wanted to use this
    instead of print filenames during my batch processing, I could do something like
    this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用此函数来打印出您自己的函数的进度。不是将 `TermProgress_nocb` 函数传递给另一个函数，而是自己调用它并使用适当的百分比。例如，如果我想在批量处理期间使用此功能代替打印文件名，我可以这样做：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This assumes that the `list_of_files` variable is a list of all of the files
    to process, and that the `process_file` function does something with the file.
    Each time I start processing a new file, I figure out how far I am based on the
    total number of files and pass that to `TermProgress_nocb` so I can get a visual
    indication of my progress. The progress function is also called after finishing
    the loop in order to tidy things up. Otherwise, if the last percentage passed
    wasn’t quite 100, you’d end up with output like this, where the last bit is missing:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设 `list_of_files` 变量是所有要处理的文件的列表，并且 `process_file` 函数对文件做了些处理。每次我开始处理一个新的文件时，我会根据总文件数来确定我的进度，并将这个值传递给
    `TermProgress_nocb`，这样我就可以得到一个可视化的进度指示。进度函数也在循环结束后被调用，以便整理事情。否则，如果最后传递的百分比不是100%，你最终会得到这样的输出，其中最后的部分缺失：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might not care about that, but if other people are running your code, they
    might prefer to know that things finished.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不在乎这一点，但如果其他人正在运行你的代码，他们可能更喜欢知道事情已经完成。
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s possible that with your version of GDAL, the progress function is called
    `TermProgress` instead.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你的 GDAL 版本中，进度函数被命名为 `TermProgress`。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can also write your own callback function if you’d like your progress information
    to look different. The function you define needs to have three different parameters.
    The first is the progress percentage between 0 and 1, the second is a string,
    and the third is whatever you want. If one of the GDAL functions invokes your
    callback, it will pass a string specifying what it’s doing as the second parameter.
    You provide the third parameter when you pass in the callback function. The best
    way to explain how this works is by example, so the following listing is an example
    that allows the user to specify how often to print a progress indicator dot by
    passing in another number between 0 and 1 as the `progressArg` parameter. The
    message string is also printed out once at the beginning.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写自己的回调函数，如果你希望进度信息看起来不同。你定义的函数需要三个不同的参数。第一个是介于0和1之间的进度百分比，第二个是一个字符串，第三个是你想要的任何内容。如果GDAL的某个函数调用了你的回调，它将通过第二个参数传递一个指定它在做什么的字符串。你通过传递回调函数来提供第三个参数。最好的解释方法是通过示例，所以下面的列表是一个示例，允许用户通过传递介于0和1之间的另一个数字作为
    `progressArg` 参数来指定打印进度指示点的时间间隔。消息字符串也会在开始时打印一次。
- en: Listing 10.7\. Use a callback function
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.7\. 使用回调函数
- en: '![](231fig01_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](231fig01_alt.jpg)'
- en: There’s a trick here that you may not have seen before. Normally when you declare
    a variable inside a function, it disappears when the function finishes, right?
    Here you attach the variable to the function as an attribute, so it sticks around
    and can be used the next time the function is called. The Python `hasattr` function
    checks to see if an object has an attribute with a given name, and you check to
    see if the `my_progress` function has an attribute called `last_progress`. If
    there isn’t one, then you assume that this is the first time the function has
    been called and print the message parameter and create the `last_progress` attribute.
    The next time the function is called, that attribute will exist, so the message
    won’t be printed. You’ll also use that attribute to keep track of how many dots
    have been printed so far.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个你可能之前没有见过的技巧。通常，当你在一个函数内部声明一个变量时，当函数结束时，它会消失，对吧？这里你将变量附加到函数作为一个属性，所以它保留下来，可以在下次函数调用时使用。Python
    的 `hasattr` 函数检查一个对象是否有一个具有给定名称的属性，你检查 `my_progress` 函数是否有名为 `last_progress` 的属性。如果没有，那么你假设这是第一次调用该函数，并打印消息参数并创建
    `last_progress` 属性。下次函数被调用时，该属性将存在，所以不会打印消息。你还会使用该属性来跟踪到目前为止已经打印了多少个点。
- en: Next you check to see if the process is done. If so, then you print `done` and
    delete the `last_progress` attribute. If you don’t delete the attribute, then
    you can’t use this function again in the same script because it will always think
    that it’s done and won’t do anything.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你检查进程是否完成。如果是，那么你打印 `done` 并删除 `last_progress` 属性。如果你不删除该属性，那么你无法在同一个脚本中再次使用这个函数，因为它会一直认为它已经完成，而不会做任何事情。
- en: If the process isn’t finished, which is the case most of the time, you use `divmod`
    (which returns a quotient and a remainder as a tuple) to figure out how many dots
    should be printed. Because multiple dots might need to be printed if the process
    runs quickly, you keep printing and incrementing `last_progress` until it equals
    the required number of dots.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程没有完成，这在大多数情况下都是如此，你使用 `divmod`（它返回一个商和一个余数作为元组）来确定应该打印多少个点。因为如果进程运行得很快，可能需要打印多个点，所以你需要继续打印并递增
    `last_progress`，直到它等于所需的点数。
- en: This function uses `sys.stdout.write` instead of `print` because `print` works
    slightly differently in Python 2 and 3, and so you need to call it in different
    ways to get the dot to print without a newline after it. Using `write` solves
    the problem because it doesn’t print a newline unless you request it. You do need
    to call `flush` to make sure that the dot shows up immediately, however. The progress
    function isn’t of much use if the dots aren’t printed until the processing is
    finished.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用 `sys.stdout.write` 而不是 `print`，因为在 Python 2 和 3 中 `print` 的工作方式略有不同，因此你需要以不同的方式调用它，以便在点后面不打印换行符。使用
    `write` 解决了这个问题，因为它除非你请求，否则不会打印换行符。然而，你需要调用 `flush` 来确保点立即显示。如果点直到处理完成才打印，进度函数就没有什么用了。
- en: 'Now that you have your progress function, how do you use it? Exactly the same
    way that you used `TermProgress_nocb`, except that you need to include an additional
    parameter specifying how often you want the indicators printed (the default value
    of 0.02 is only honored if you call the function yourself, not if it’s called
    by something else). Here’s an example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了进度函数，你怎么使用它？正好和 `TermProgress_nocb` 一样使用，只是你需要包含一个额外的参数，指定你希望指示器打印的频率（默认值
    0.02 仅在你自己调用函数时得到尊重，如果是由其他东西调用则不尊重）。以下是一个示例：
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is a simple example, but the same concepts apply if you want to do something
    more complicated. For example, if you had an exceptionally long-running process
    and wanted to be notified by email at certain points in the process, you could
    do that.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但如果你想做更复杂的事情，同样的概念也适用。例如，如果你有一个运行时间异常长的进程，并且希望在进程的某些点上通过电子邮件接收通知，你可以做到这一点。
- en: 10.8\. Exceptions and error handlers
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.8. 异常和错误处理器
- en: 'As with OGR, you can have GDAL throw an exception when it runs into a problem.
    To do this, simply call `UseExceptions`, and you can turn exceptions off by calling
    `Dont-UseExceptions`. Normally, you need to make sure that operations that might
    have failed did work, such as opening a file. If you don’t check and the file
    wasn’t opened, then your script will crash when it tries to use the dataset. This
    might be fine, depending on what you’re doing, but it might not be. Take this
    simple example of batch-computing statistics:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与 OGR 一样，你可以让 GDAL 在遇到问题时抛出异常。为此，只需调用 `UseExceptions`，并且你可以通过调用 `Dont-UseExceptions`
    来关闭异常。通常，你需要确保可能失败的操作确实已经执行，例如打开文件。如果你不检查并且文件没有打开，那么当脚本尝试使用数据集时，它将崩溃。这取决于你正在做什么，可能没问题，但也可能不行。以下是一个简单的批量计算统计数据的示例：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is great, except for the extra “f” at the end of the second filename.
    The script will spit out the following error and crash when it tries to get the
    band, and the last file will never be looked at:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但第二个文件名末尾多了一个“f”。当脚本尝试获取波段时，会抛出以下错误并崩溃，并且最后一个文件永远不会被查看：
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You have a few ways you can solve this problem. You might have your code check
    that the dataset was successfully opened, and if not, print a message so that
    the user knows that the file was skipped. This way nothing will crash and statistics
    will be computed for the last file:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种方法可以解决这个问题。你可能让代码检查数据集是否成功打开，如果没有，打印一条消息，让用户知道文件被跳过了。这样就不会有任何东西崩溃，并且会为最后一个文件计算统计数据：
- en: '[PRE27]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A cleaner way to handle errors would be to use a try/except block. If multiple
    possible points of failure exist, you don’t have to check that each one succeeded.
    Instead, wrap the whole thing in one `try` block and handle all errors in the
    `except` clause:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误的一个更干净的方法是使用 try/except 块。如果存在多个可能失败的点，你不必检查每个点是否成功。相反，将整个内容包裹在一个 `try`
    块中，并在 `except` 子句中处理所有错误：
- en: '[PRE28]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Although the error was encountered in this case, the error message would not
    print automatically. If you need it, you can get access to the error message using
    the `GetLastErrorMsg` function. After the `except` clause is processed, the loop
    continues with the next filename in the list.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这种情况下遇到了错误，但错误信息不会自动打印。如果你需要它，你可以使用`GetLastErrorMsg`函数获取错误信息。在处理完`except`子句后，循环将继续处理列表中的下一个文件名。
- en: 'GDAL also has the concept of error handlers that get called whenever a GDAL
    function runs into an error. The default error handler prints out error messages
    like the one you saw a second ago. If you don’t want these messages printed for
    some reason, you can shut them up with the built-in quiet error handler. To do
    this, enable the handler before running the code that you’d like to be quiet.
    The `PushErrorHandler` function will make a handler the active one until you call
    `PopErrorHandler`, which will restore the original handler:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: GDAL还有一个错误处理器的概念，当GDAL函数遇到错误时会调用它。默认的错误处理器会打印出你刚才看到的错误信息。如果你出于某种原因不希望打印这些信息，你可以使用内置的静默错误处理器来关闭它们。为此，在运行你希望静默的代码之前启用该处理器。`PushErrorHandler`函数将使处理器变为活动状态，直到你调用`PopErrorHandler`，这将恢复原始处理器：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also use `SetErrorHandler` to enable a handler, but then it’s in effect
    until you pass a different handler to `SetErrorHandler`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`SetErrorHandler`来启用处理器，但一旦启用，它就会一直有效，直到你向`SetErrorHandler`传递不同的处理器：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Error handlers aren’t limited to the GDAL functions, though. You can call them
    yourself if you’d like. Say you have a function that takes two datasets, but they
    need to share a spatial reference system for your logic to work. You can call
    whatever error handler happens to be in effect by using the `Error` function,
    which takes three parameters. The first is an error class and the second is an
    error number, both from [table 10.4](#ch10table04). The third argument is the
    error message.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然错误处理器并不限于GDAL函数，但如果你愿意，你也可以自己调用它们。比如说，你有一个函数，它接受两个数据集，但它们需要共享一个空间参考系统才能使你的逻辑工作。你可以通过使用`Error`函数来调用当前有效的任何错误处理器，该函数接受三个参数。第一个是一个错误类，第二个是一个错误数字，两者都来自[表10.4](#ch10table04)。第三个参数是错误信息。
- en: Table 10.4\. Possible error classes and numbers
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.4\. 可能的错误类和数字
- en: '| Error classes | Error numbers (types, if you prefer) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 错误类 | 错误数字（如果你更喜欢类型） |'
- en: '| --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| CE_None | CPLE_None |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| CE_None | CPLE_None |'
- en: '| CE_Debug | CPLE_AppDefined |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| CE_Debug | CPLE_AppDefined |'
- en: '| CE_Warning | CPLE_OutOfMemory |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| CE_Warning | CPLE_OutOfMemory |'
- en: '| CE_Failure | CPLE_FileIO |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| CE_Failure | CPLE_FileIO |'
- en: '| CE_Fatal | CPLE_OpenFailed |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| CE_Fatal | CPLE_OpenFailed |'
- en: '|   | CPLE_IllegalArg |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '|   | CPLE_IllegalArg |'
- en: '|   | CPLE_NotSupported |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|   | CPLE_NotSupported |'
- en: '|   | CPLE_AssertionFailed |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|   | CPLE_AssertionFailed |'
- en: '|   | CPLE_NoWriteAccess |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|   | CPLE_NoWriteAccess |'
- en: '|   | CPLE_UserInterrupt |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|   | CPLE_UserInterrupt |'
- en: '[PRE31]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You might be wondering why you would do this instead of print your error message
    and return from the function. You certainly could do that, but this gives you
    more flexibility in the future. If this function is part of a module you’re reusing
    in different situations, you might want to handle errors in different ways, depending
    on your application. This gives you that ability, because all you have to do is
    change your error handler instead of finding and changing all of your `print`
    statements (which you might have to change back for another application). This
    also makes your function treat errors the same way that GDAL does. If `UseExceptions`
    is in effect, then instead of printing the error message, the call to `Error`
    will raise an exception that can be caught in a try/except block.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，为什么你会选择这样做而不是打印错误信息并从函数中返回。你当然可以这样做，但这样会给你在未来的更多灵活性。如果这个函数是你在不同情况下重复使用的模块的一部分，你可能希望根据你的应用程序以不同的方式处理错误。这为你提供了这种能力，因为你只需要更改你的错误处理程序，而不是找到并更改所有的`print`语句（你可能还需要更改以适应另一个应用程序）。这也使得你的函数以与GDAL相同的方式处理错误。如果`UseExceptions`有效，那么在调用`Error`函数时，将不会打印错误信息，而是抛出一个异常，该异常可以在`try/except`块中被捕获。
- en: 'You can write your own error handlers, too. You might do this so you could
    log error messages to a file or database, or I suppose you could also try to solve
    the error somehow. If you do choose to write your own function, it needs to accept
    the same three arguments that get passed to the `Error` function. Here’s a simple
    example of a handler that logs the error class, reason, and message using the
    Python logging module:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写自己的错误处理器。你可能这么做是为了将错误信息记录到文件或数据库中，或者我想你可能也尝试以某种方式解决错误。如果你选择编写自己的函数，它需要接受传递给`Error`函数的相同三个参数。这里有一个简单示例，展示了如何使用Python日志模块记录错误类、原因和消息：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Get constant names with the ospybook module**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用ospybook模块获取常量名称**'
- en: The ospybook module contains a function that helps you get the human-readable
    forms of the GDAL constants. Pass it the case-sensitive prefix corresponding to
    the type of GDAL constant you want to look up and the numeric value to find. The
    function returns the name of the constant as a string.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ospybook模块包含一个函数，可以帮助你获取GDAL常量的可读形式。传递给它对应于你想要查找的GDAL常量类型的区分大小写的前缀和要查找的数值。该函数返回常量的名称作为字符串。
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You could use a function like this to easily send your error messages to different
    places. If you wanted to see the messages on the screen, all you’d have to do
    is import the logging module and set your error handler:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这样的函数轻松地将错误信息发送到不同的地方。如果你想看到屏幕上的消息，你只需要导入日志模块并设置你的错误处理器：
- en: '[PRE34]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To send the messages to a file instead, you need to add the step of configuring
    the logger, like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要将消息发送到文件，你需要添加配置日志记录器的步骤，如下所示：
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now if you called your `do_something` function on two datasets with different
    spatial references, a line like this would get added to log.txt:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你在具有不同空间参考的两个数据集上调用你的`do_something`函数，就会在log.txt中添加如下一行：
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Normally, when you turn on exceptions by calling `UseExceptions`, the error
    handlers are turned off and an exception is raised when an error is encountered.
    This is why the error messages don’t automatically print when exceptions are enabled.
    If you wanted your error message logged using your new `log_error_handler` function,
    but you also wanted to use exceptions, you could enable the error handler after
    enabling exceptions, and then you should get both behaviors.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你通过调用`UseExceptions`来开启异常时，错误处理器会被关闭，并且当遇到错误时会引发异常。这就是为什么在启用异常时错误信息不会自动打印。如果你想使用你的新`log_error_handler`函数记录错误信息，但同时也想使用异常，你可以在启用异常之后启用错误处理器，然后你应该会得到两种行为。
- en: 10.9\. Summary
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.9\. 摘要
- en: Use known locations, called ground control points, if you don’t have geotransform
    information for a raster dataset. You can create a geotransform from the GCPs.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有栅格数据集的地理变换信息，请使用称为地面控制点（GCP）的已知位置。你可以从GCP创建地理变换。
- en: Add a raster attribute table to your thematic datasets so that you know what
    each pixel value means.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将栅格属性表添加到你的主题数据集中，以便你知道每个像素值代表什么。
- en: Add a color table to a thematic dataset if you want it to draw with the same
    colors all of the time.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想让主题数据集始终以相同的颜色绘制，请为其添加一个颜色表。
- en: You can manipulate data with virtual raster files without ever creating new
    files on disk.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用虚拟栅格文件来操作数据，而无需在磁盘上创建新文件。
- en: The easiest way to reproject a raster is to use a VRT and then copy it to the
    desired format.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新投影栅格最简单的方法是使用VRT，然后将其复制到所需的格式。
- en: It’s a good idea to use callback functions to provide progress information for
    long-running processes.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回调函数提供长时间运行进程的进度信息是个好主意。
