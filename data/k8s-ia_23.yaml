- en: Appendix C. Using other container runtimes
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 C. 使用其他容器运行时
- en: C.1\. Replacing Docker with rkt
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C.1\. 用 rkt 替换 Docker
- en: We’ve mentioned rkt (pronounced rock-it) a few times in this book. Like Docker,
    it runs applications in isolated containers, using the same Linux technologies
    as those used by Docker. Let’s look at how rkt differs from Docker and how to
    try it in Minikube.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中多次提到了 rkt（发音为 rock-it）。与 Docker 一样，它使用与 Docker 相同的 Linux 技术在隔离的容器中运行应用程序。让我们看看
    rkt 与 Docker 的区别以及如何在 Minikube 中尝试它。
- en: The first great thing about rkt is that it directly supports the notion of a
    Pod (running multiple related containers), unlike Docker, which only runs individual
    containers. Rkt is based on open standards and was built with security in mind
    from the start (for example, images are signed, so you can be sure they haven’t
    been tampered with). Unlike Docker, which initially had a client-server based
    architecture that didn’t play well with init systems such as systemd, rkt is a
    CLI tool that runs your container directly, instead of telling a daemon to run
    it. A nice thing about rkt is that it can run existing Docker-formatted container
    images, so you don’t need to repackage your applications to get started with rkt.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: rkt 的第一个优点是它直接支持 Pod 的概念（运行多个相关容器），这与仅运行单个容器的 Docker 不同。rkt 基于开放标准，并且从一开始就考虑了安全性（例如，镜像已签名，因此您可以确信它们没有被篡改）。与最初基于客户端-服务器架构且与
    systemd 等初始化系统不兼容的 Docker 不同，rkt 是一个直接运行容器的 CLI 工具，而不是告诉守护进程运行它。rkt 的一个好处是它可以运行现有的
    Docker 格式容器镜像，因此您无需重新打包应用程序即可开始使用 rkt。
- en: C.1.1\. Configuring Kubernetes to use rkt
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C.1.1\. 配置 Kubernetes 以使用 rkt
- en: As you may remember from [chapter 11](index_split_087.html#filepos1036287),
    the Kubelet is the only Kubernetes component that talks to the Container Runtime.
    To get Kubernetes to use rkt instead of Docker, you need to configure the Kubelet
    to use it by running it with the `--container-runtime=rkt` command-line option.
    But be aware that support for rkt isn’t as mature as support for Docker.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[第 11 章](index_split_087.html#filepos1036287)中可能记得的，Kubelet 是唯一与容器运行时通信的
    Kubernetes 组件。要使 Kubernetes 使用 rkt 而不是 Docker，您需要通过运行带有 `--container-runtime=rkt`
    命令行选项的 Kubelet 来配置它。但请注意，rkt 的支持并不像 Docker 那样成熟。
- en: Please refer to the Kubernetes documentation for more information on how to
    use rkt and what is or isn’t supported. Here, we’ll go over a quick example to
    get you started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考 Kubernetes 文档以获取有关如何使用 rkt 以及哪些功能受支持的更多信息。在此，我们将快速浏览一个示例，以帮助您入门。
- en: C.1.2\. Trying out rkt with Minikube
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C.1.2\. 尝试使用 Minikube 配置 rkt
- en: 'Luckily, to get started with rkt on Kubernetes, all you need is the same Minikube
    executable you’re already using. To use rkt as the container runtime in Minikube,
    all you need to do is start Minikube with the following two options:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，要开始在 Kubernetes 上使用 rkt，您只需要与您已经使用的相同的 Minikube 可执行文件。要在 Minikube 中使用 rkt
    作为容器运行时，您只需使用以下两个选项启动 Minikube 即可：
- en: '`$ minikube start --container-runtime=rkt --network-plugin=cni`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube start --container-runtime=rkt --network-plugin=cni`'
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may need to run `minikube delete` to delete the existing Minikube VM first.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要先运行 `minikube delete` 来删除现有的 Minikube VM。
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `--container-runtime=rkt` option obviously configures the Kubelet to use
    rkt as the Container Runtime, whereas the `--network-plugin=cni` makes it use
    the Container Network Interface as the network plugin. Without this option, pods
    won’t run, so it’s imperative you use it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`--container-runtime=rkt` 选项显然配置了 Kubelet 以使用 rkt 作为容器运行时，而 `--network-plugin=cni`
    则使其使用容器网络接口作为网络插件。没有此选项，Pod 将无法运行，因此您必须使用它。'
- en: Running a Pod
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Pod
- en: 'Once the Minikube VM is up, you can interact with Kubernetes exactly like before.
    You can deploy the kubia app with the `kubectl run` command, for example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Minikube VM 启动，您就可以像以前一样与 Kubernetes 交互。例如，您可以使用 `kubectl run` 命令部署 kubia
    应用程序：
- en: '`$ kubectl run kubia --image=luksa/kubia --port 8080` `deployment "kubia" created`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl run kubia --image=luksa/kubia --port 8080` `deployment "kubia" created`'
- en: When the pod starts up, you can see it’s running through rkt by inspecting its
    containers with `kubectl describe`, as shown in the following listing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Pod 启动时，您可以通过使用 `kubectl describe` 检查其容器来看到它是通过 rkt 运行的，如下所示。
- en: Listing C.1\. Pod running with rkt
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.1\. 使用 rkt 运行的 Pod
- en: '`$ kubectl describe pods` `Name:           kubia-3604679414-l1nn3 ... Status:        
    Running IP:             10.1.0.2 Controllers:    ReplicaSet/kubia-3604679414 Containers:
      kubia:     Container ID:       rkt://87a138ce-...-96e375852997:kubia` `1` `Image:             
    luksa/kubia     Image ID:           rkt://sha512-5bbc5c7df6148d30d74e0...` `1`
    `...`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl describe pods` `Name:           kubia-3604679414-l1nn3 ... Status:        
    Running IP:             10.1.0.2 Controllers:    ReplicaSet/kubia-3604679414 Containers:
      kubia:     Container ID:       rkt://87a138ce-...-96e375852997:kubia` `1` `Image:             
    luksa/kubia     Image ID:           rkt://sha512-5bbc5c7df6148d30d74e0...` `1`
    `...`'
- en: 1 The container and image IDs mention rkt instead of Docker.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 容器和镜像 ID 提到 rkt 而不是 Docker。
- en: You can also try hitting the pod’s HTTP port to see if it’s responding properly
    to HTTP requests. You can do this by creating a `NodePort` Service or by using
    `kubectl port-forward`, for example.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试访问 pod 的 HTTP 端口，看看它是否正确响应 HTTP 请求。你可以通过创建一个 `NodePort` 服务或使用 `kubectl
    port-forward` 等方式来实现。
- en: Inspecting the running containers in the Minikube VM
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Minikube VM 中运行的容器
- en: 'To get more familiar with rkt, you can try logging into the Minikube VM with
    the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要更熟悉 rkt，你可以尝试使用以下命令登录到 Minikube 虚拟机：
- en: '`$ minikube ssh`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube ssh`'
- en: Then, you can use `rkt list` to see the running pods and containers, as shown
    in the following listing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `rkt list` 来查看正在运行的 pods 和容器，如下所示。
- en: Listing C.2\. Listing running containers with rkt list
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 C.2\. 使用 rkt list 列出正在运行的容器
- en: '`$ rkt list` `UUID      APP                 IMAGE NAME                      
    STATE   ... 4900e0a5  k8s-dashboard       gcr.io/google_containers/kun...  running
    ... 564a6234  nginx-ingr-ctrlr    gcr.io/google_containers/ngi...  running ...
    5dcafffd  dflt-http-backend   gcr.io/google_containers/def...  running ... 707a306c 
    kube-addon-manager  gcr.io/google-containers/kub...  running ... 87a138ce` `kubia``              
    registry-1.docker.io/luksa/k...  running ... d97f5c29  kubedns             gcr.io/google_containers/k8s... 
    running ...           dnsmasq             gcr.io/google_containers/k8...          
    sidecar             gcr.io/google_containers/k8...`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ rkt list` `UUID      APP                 IMAGE NAME                      
    STATE   ... 4900e0a5  k8s-dashboard       gcr.io/google_containers/kun...  running
    ... 564a6234  nginx-ingr-ctrlr    gcr.io/google_containers/ngi...  running ...
    5dcafffd  dflt-http-backend   gcr.io/google_containers/def...  running ... 707a306c 
    kube-addon-manager  gcr.io/google-containers/kub...  running ... 87a138ce` `kubia``              
    registry-1.docker.io/luksa/k...  running ... d97f5c29  kubedns             gcr.io/google_containers/k8s... 
    running ...           dnsmasq             gcr.io/google_containers/k8...          
    sidecar             gcr.io/google_containers/k8...`'
- en: You can see the `kubia` container, as well as other system containers running
    (the ones deployed in pods in the `kube-system` namespace). Notice how the bottom
    two containers don’t have anything listed in the `UUID` or `STATE` columns? That’s
    because they belong to the same pod as the `kubedns` container listed above them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `kubia` 容器，以及其他正在运行的系统容器（在 `kube-system` 命名空间中部署的 pod）。注意底部两个容器在 `UUID`
    或 `STATE` 列中没有任何内容？这是因为它们属于与上面列出的 `kubedns` 容器相同的 pod。
- en: Rkt prints containers belonging to the same pod grouped together. Each pod (instead
    of each container) has its own UUID and state. If you tried doing this when you
    were using Docker as the Container Runtime, you’ll appreciate how much easier
    it is to see all the pods and their containers with rkt. You’ll notice no infrastructure
    container exists for each pod (we explained them in [chapter 11](index_split_087.html#filepos1036287)).
    That’s because of rkt’s native support for pods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Rkt 将属于同一 pod 的容器分组在一起打印。每个 pod（而不是每个容器）都有自己的 UUID 和状态。如果你在以前使用 Docker 作为容器运行时尝试过这样做，你会欣赏使用
    rkt 查看所有 pods 和它们的容器有多么容易。你会注意到每个 pod 都没有基础设施容器（我们在第 11 章[章节 11](index_split_087.html#filepos1036287)中解释了它们）。这是因为
    rkt 对 pods 的原生支持。
- en: Listing container images
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列出容器镜像
- en: If you’ve played around with Docker CLI commands, you’ll get familiar quickly
    with rkt’s commands. Run `rkt` without any arguments and you’ll see all the commands
    you can run. For example, to list container images, you run the command in the
    following listing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩过 Docker CLI 命令，你会很快熟悉 rkt 的命令。运行 `rkt` 不带任何参数，你会看到你可以运行的所有命令。例如，要列出容器镜像，你运行以下列表中的命令。
- en: Listing C.3\. Listing images with rkt image list
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 C.3\. 使用 rkt image list 列出镜像
- en: '`$ rkt image list` `ID           NAME                          SIZE    IMPORT
    TIME  LAST USED sha512-a9c3  ...addon-manager:v6.4-beta.1  245MiB  24 min ago  
    24 min ago sha512-a078  .../rkt/stage1-coreos:1.24.0  224MiB  24 min ago   24
    min ago sha512-5bbc  ...ker.io/luksa/kubia:latest  1.3GiB  23 min ago   23 min
    ago sha512-3931  ...es-dashboard-amd64:v1.6.1  257MiB  22 min ago   22 min ago
    sha512-2826  ...ainers/defaultbackend:1.0  15MiB   22 min ago   22 min ago sha512-8b59 
    ...s-controller:0.9.0-beta.4  233MiB  22 min ago   22 min ago sha512-7b59  ...dns-kube-dns-amd64:1.14.2 
    100MiB  21 min ago   21 min ago sha512-39c6  ...nsmasq-nanny-amd64:1.14.2  86MiB  
    21 min ago   21 min ago sha512-89fe  ...-dns-sidecar-amd64:1.14.2  85MiB   21
    min ago   21 min ago`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ rkt image list` `ID           NAME                          SIZE    IMPORT
    TIME  LAST USED sha512-a9c3  ...addon-manager:v6.4-beta.1  245MiB  24 min ago  
    24 min ago sha512-a078  .../rkt/stage1-coreos:1.24.0  224MiB  24 min ago   24
    min ago sha512-5bbc  ...ker.io/luksa/kubia:latest  1.3GiB  23 min ago   23 min
    ago sha512-3931  ...es-dashboard-amd64:v1.6.1  257MiB  22 min ago   22 min ago
    sha512-2826  ...ainers/defaultbackend:1.0  15MiB   22 min ago   22 min ago sha512-8b59 
    ...s-controller:0.9.0-beta.4  233MiB  22 min ago   22 min ago sha512-7b59  ...dns-kube-dns-amd64:1.14.2 
    100MiB  21 min ago   21 min ago sha512-39c6  ...nsmasq-nanny-amd64:1.14.2  86MiB  
    21 min ago   21 min ago sha512-89fe  ...-dns-sidecar-amd64:1.14.2  85MiB   21
    min ago   21 min ago`'
- en: These are all Docker-formatted container images. You can also try building images
    in the OCI image format (OCI stands for Open Container Initiative) with the acbuild
    tool (available at [https://github.com/containers/build](https://github.com/containers/build))
    and running them with rkt. Doing that is outside the scope of this book, so I’ll
    let you try it on your own.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是Docker格式的容器镜像。您也可以尝试使用acbuild工具（可在[https://github.com/containers/build](https://github.com/containers/build)找到）构建OCI镜像格式（OCI代表开放容器倡议）的镜像，并使用rkt运行它们。这样做超出了本书的范围，所以我会让您自己尝试。
- en: The information explained in this appendix so far should be enough to get you
    started using rkt with Kubernetes. Refer to the rkt documentation at [https://coreos.com/rkt](https://coreos.com/rkt)
    and Kubernetes documentation at [https://kubernetes.io/docs](https://kubernetes.io/docs)
    for additional information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本附录中解释的信息应该足以让您开始使用rkt与Kubernetes一起使用。有关rkt的更多信息，请参阅[https://coreos.com/rkt](https://coreos.com/rkt)文档，有关Kubernetes的更多信息，请参阅[https://kubernetes.io/docs](https://kubernetes.io/docs)文档。
- en: C.2\. Using other container runtimes through the CRI
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C.2\. 通过CRI使用其他容器运行时
- en: Kubernetes’ support for other container runtimes doesn’t stop with Docker and
    rkt. Both of those runtimes were initially integrated directly into Kubernetes,
    but in Kubernetes version 1.5, the Container Runtime Interface (CRI) was introduced.
    CRI is a plugin API enabling easy integration of other container runtimes with
    Kubernetes. People are now free to plug other container runtimes into Kubernetes
    without having to dig deep into Kubernetes code. All they need to do is implement
    a few interface methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes对其他容器运行时的支持不仅限于Docker和rkt。这两个运行时最初是直接集成到Kubernetes中的，但在Kubernetes版本1.5中，引入了容器运行时接口（CRI）。CRI是一个插件API，它使得其他容器运行时能够轻松地与Kubernetes集成。现在，人们可以自由地将其他容器运行时插入到Kubernetes中，而无需深入挖掘Kubernetes的代码。他们只需要实现几个接口方法即可。
- en: From Kubernetes version 1.6 onward, CRI is the default interface the Kubelet
    uses. Both Docker and rkt are now used through the CRI (no longer directly).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes版本1.6开始，CRI是Kubelet使用的默认接口。现在，Docker和rkt都是通过CRI使用的（不再是直接使用）。
- en: C.2.1\. Introducing the CRI-O Container Runtime
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C.2.1\. 介绍CRI-O容器运行时
- en: Beside Docker and rkt, a new CRI implementation called CRI-O allows Kubernetes
    to directly launch and manage OCI-compliant containers, without requiring you
    to deploy any additional Container Runtime.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Docker和rkt之外，一个新的CRI实现CRI-O允许Kubernetes直接启动和管理符合OCI规范的容器，而无需您部署任何额外的容器运行时。
- en: You can try CRI-O with Minikube by starting it with `--container-runtime=crio`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`--container-runtime=crio`启动Minikube来尝试CRI-O。
- en: C.2.2\. Running apps in virtual machines instead of containers
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C.2.2\. 在虚拟机中而不是在容器中运行应用
- en: Kubernetes is a container orchestration system, right? Throughout the book,
    we explored many features that show that it’s much more than an orchestration
    system, but the bottom line is that when you run an app with Kubernetes, the app
    always runs inside a container, right? You may find it surprising that’s no longer
    the case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个容器编排系统，对吧？在本书中，我们探讨了众多特性，表明它远不止是一个编排系统，但归根结底，当您使用Kubernetes运行应用时，应用总是运行在容器内部，对吧？您可能会惊讶地发现，这种情况已经不再适用了。
- en: New CRI implementations are being developed that allow Kubernetes to run apps
    in virtual machines instead of in containers. One such implementation, called
    Frakti, allows you to run regular Docker-based container images directly through
    a hypervisor, which means each container runs its own kernel. This allows much
    better isolation between containers compared to when they use the same kernel.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正在开发新的CRI实现，使得Kubernetes能够在虚拟机中而不是在容器中运行应用程序。其中一个名为Frakti的实现允许你通过虚拟机管理程序直接运行基于Docker的常规容器镜像，这意味着每个容器运行自己的内核。这比它们使用相同内核时提供了更好的容器间隔离。
- en: And there’s more. Another CRI implementation is the Mirantis Virtlet, which
    makes it possible to run actual VM images (in the QCOW2 image file format, which
    is one of the formats used by the QEMU virtual machine tool) instead of container
    images. When you use the Virtlet as the CRI plugin, Kubernetes spins up a VM for
    each pod. How awesome is that?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多。另一个CRI实现是Mirantis Virtlet，它使得运行实际的虚拟机镜像（在QCOW2镜像文件格式下，这是QEMU虚拟机工具使用的格式之一）成为可能，而不是容器镜像。当你使用Virtlet作为CRI插件时，Kubernetes为每个pod启动一个虚拟机。这有多么酷？
