- en: Part 3\. C# 6
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 部分\. C# 6
- en: C# 6 is one of my favorite releases. It has lots of features, but they’re mostly
    independent of each other, simple to explain, and easy to apply to existing code.
    In some ways, they’re underwhelming to read about, but they still make a huge
    difference to the readability of your code. If I ever have to write code in an
    older version of C#, it’s the C# 6 features that I find myself missing most.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6 是我最喜欢的版本之一。它有很多特性，但它们大多相互独立，解释简单，并且容易应用到现有代码中。在某些方面，它们在阅读时可能并不令人兴奋，但它们仍然对你的代码可读性产生了巨大的影响。如果我有必要在
    C# 的旧版本中编写代码，我会发现自己最怀念的是 C# 6 的特性。
- en: Whereas each earlier version of C# introduced a whole new way of thinking about
    code (generics, LINQ, dynamic typing, and async/await, respectively), C# 6 is
    more about applying some polish to the code you already have.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个早期的 C# 版本都引入了一种全新的思考代码的方式（分别是泛型、LINQ、动态类型和 async/await），但 C# 6 更多的是对现有代码进行一些润色。
- en: 'I’ve grouped the features into three chapters: features about properties, features
    about strings, and features that aren’t about properties or strings, but this
    is somewhat arbitrary. I recommend reading the chapters in the natural order,
    but there’s no big buildup to a grand scheme as there was with LINQ.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将特性分为三个章节：关于属性的特性、关于字符串的特性，以及既不关于属性也不关于字符串的特性，但这有些随意。我建议按照自然顺序阅读这些章节，但与 LINQ
    相比，这里并没有什么宏伟的计划。
- en: Given the way C# 6 features are easily applicable to existing code, I recommend
    trying them out as you go along. If you maintain a project that has old code you
    haven’t touched in a while, you may find that to be fertile ground for refactoring
    with the benefit of C# 6.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 C# 6 的功能很容易应用到现有代码中，我建议你在使用过程中尝试它们。如果你维护一个项目，其中包含你一段时间没有接触过的旧代码，你可能会发现这是利用
    C# 6 进行重构的理想之地。
- en: Chapter 8\. Super-sleek properties and expression-bodied members
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章\. 超简洁的属性和表达式主体成员
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Implementing read-only properties automatically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动实现只读属性
- en: Initializing automatically implemented properties at their declaration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明时自动初始化实现属性
- en: Removing unnecessary ceremony with expression-bodied members
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表达式主体成员去除不必要的仪式
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Some versions of C# have one big, unifying feature that almost all other features
    contribute to. For example, C# 3 introduced LINQ, and C# 5 introduced asynchrony.
    C# 6 isn’t like that, but it does have a general theme. Almost all the features
    contribute to cleaner, simpler, and more readable code. C# 6 isn’t about doing
    more; it’s about doing the same work with less code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些版本的 C# 有一个统一的大特性，几乎所有其他特性都与之相关。例如，C# 3 引入了 LINQ，C# 5 引入了异步操作。C# 6 并非如此，但它确实有一个总体主题。几乎所有特性都致力于编写更干净、更简单、更易读的代码。C#
    6 不是关于做更多；它是关于用更少的代码做同样的事情。
- en: The features you’ll look at in this chapter are about properties and other simple
    pieces of code. When not much logic is involved, removing even the smallest piece
    of ceremony—braces and return statements, for example—can make a big difference.
    Although the features here may not sound impressive, I’ve been surprised at their
    impact in real code. We’ll start off looking at properties and move on to methods,
    indexers, and operators.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将看到的特性是关于属性和其他简单代码片段的。当逻辑不是很多时，即使去除最小的仪式——例如大括号和返回语句——也能产生很大的影响。尽管这里的特性可能听起来并不令人印象深刻，但我对它们在实际代码中的影响感到惊讶。我们将从属性开始，然后转向方法、索引器和运算符。
- en: 8.1\. A brief history of properties
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 属性的简要历史
- en: C# has had properties from the first version. Although their core functionality
    hasn’t changed over time, they’ve gradually become simpler to express in source
    code and more versatile. Properties allow you to differentiate between how state
    access and manipulation are exposed in the API and how that state is implemented.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C# 从第一版开始就有属性。尽管它们的核心功能随着时间的推移并没有改变，但它们在源代码中的表达方式逐渐变得简单，并且更加灵活。属性允许你区分在 API
    中如何暴露状态访问和操作，以及状态是如何实现的。
- en: For example, suppose you want to represent a point in 2D space. You could represent
    that easily using public fields, as shown in the following listing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想表示二维空间中的一个点。你可以像以下列表所示那样轻松地使用公共字段来表示。
- en: Listing 8.1\. `Point` class with public fields
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. `Point` 类的公共字段
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That doesn’t seem too bad at first glance, but the capabilities of the class
    (“I can access its X and Y values”) are closely tied to the implementation (“I’ll
    use two double fields”). But at this point, the implementation has lost control.
    As long as the class state is exposed directly via fields, you can’t do the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 初看似乎还不错，但类的功能（“我可以访问其 X 和 Y 值”）与实现（“我将使用两个双精度字段”）紧密相关。但在这个阶段，实现已经失去了控制。只要类的状态通过字段直接暴露，你就不能做以下事情：
- en: Perform validation when setting new values (for example, preventing infinite
    or not-a-number values for the X and Y coordinates)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置新值时执行验证（例如，防止 X 和 Y 坐标无限或非数字值）
- en: Perform computation when fetching values (for example, if you wanted to store
    the fields in a different format—unlikely for a point, but perfectly feasible
    in other cases)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取值时执行计算（例如，如果你想要以不同的格式存储字段——对于点来说不太可能，但在其他情况下完全可行）
- en: You might argue that you could always change the field to a property later,
    when you find you need something like this, but that’s a breaking change, which
    you probably want to avoid. (It breaks source compatibility, binary compatibility,
    and reflection compatibility. That’s a big risk to take just to avoid using properties
    from the start.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，当你发现你需要这样的东西时，你可以总是将字段更改为属性，但这是一种破坏性的更改，你可能会想避免。（这会破坏源兼容性、二进制兼容性和反射兼容性。仅仅为了避免一开始就使用属性，就承担这样的风险是很大的。）
- en: In C# 1, the language provided almost no help with properties. A property-based
    version of [listing 8.1](kindle_split_024_split_000.html#ch08ex01) would require
    manual declaration of the backing fields, along with getters and setters for each
    of the properties, as shown in the next listing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 1 中，语言在属性方面几乎没有提供帮助。一个基于属性的 [列表 8.1](kindle_split_024_split_000.html#ch08ex01)
    版本将需要手动声明后置字段，以及每个属性的 getter 和 setter，如下一个列表所示。
- en: Listing 8.2\. `Point` class with properties in C# 1
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. `Point` 类的 C# 属性 1
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You could argue that many properties start off simply reading and writing fields
    with no extra validation, computation, or anything else and stay that way for
    the whole history of the code. Properties like that could’ve been exposed as fields,
    but it’s hard to predict which properties might need extra code later. Even when
    you can do that accurately, it feels like you’re operating at two levels of abstraction
    for no reason. To me, properties act as part of the contract that a type provides:
    its advertised functionality. Fields are simply implementation details; they’re
    the mechanism inside the box, which users don’t need to know about in the vast
    majority of cases. I prefer fields to be private in almost all cases.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会争辩说，许多属性最初只是简单地读取和写入字段，没有额外的验证、计算或其他任何东西，并且在整个代码历史中保持这种状态。这样的属性本可以公开为字段，但很难预测哪些属性以后可能需要额外的代码。即使你可以准确做到这一点，这也感觉像是在没有理由的情况下在两个抽象级别上操作。对我来说，属性充当类型提供的契约的一部分：其宣传的功能。字段仅仅是实现细节；它们是盒子内部的机制，在绝大多数情况下用户不需要了解。我几乎在所有情况下都更喜欢字段是私有的。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Like all good rules of thumb, there are exceptions. In some situations, it makes
    sense to expose fields directly. You’ll see one interesting case in [chapter 11](kindle_split_028_split_000.html#ch11)
    when you look at the tuples provided by C# 7.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有好的经验法则一样，总有例外。在某些情况下，直接公开字段是有意义的。当你查看 C# 7 提供的元组时，你会在 [第 11 章](kindle_split_028_split_000.html#ch11)
    中看到一个有趣的案例。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The only improvement to properties in C# 2 was to allow different access modifiers
    for the getter and setter—for example, a public getter and a private setter. (That’s
    not the only combination available, but it’s by far the most common one.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 中属性的唯一改进是允许 getter 和 setter 使用不同的访问修饰符——例如，公共 getter 和私有 setter。（这并不是唯一可用的组合，但这是最常见的一种。）
- en: C# 3 then added automatically implemented properties, which allow [listing 8.2](kindle_split_024_split_000.html#ch08ex02)
    to be rewritten in a simpler way, as follows.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3 然后添加了自动实现属性，这使得 [列表 8.2](kindle_split_024_split_000.html#ch08ex02) 可以以更简单的方式重写，如下所示。
- en: Listing 8.3\. `Point` class with properties in C# 3
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. `Point` 类的 C# 3 属性
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is almost exactly equivalent to the code in [listing 8.2](kindle_split_024_split_000.html#ch08ex02),
    except there’s no way of accessing the backing fields directly. They’re given
    *unspeakable names*, which aren’t valid C# identifiers but are fine as far as
    the runtime is concerned.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码几乎与列表 8.2 中的代码完全相同，除了无法直接访问支持字段之外。它们被赋予了*难以言喻的名称*，这些名称不是有效的 C# 标识符，但在运行时是可行的。
- en: Importantly, C# 3 allowed only read/write properties to be implemented automatically.
    I’m not going to go into all the benefits (and pitfalls) of immutability here,
    but there are many reasons you might want your `Point` class to be immutable.
    To make your properties truly read-only, you need to go back to writing the code
    manually.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，C# 3 只允许自动实现只读/写属性。我这里不会详细讨论不可变性的所有好处（以及陷阱），但有许多原因你可能想让你的 `Point` 类成为不可变的。为了使你的属性真正只读，你需要手动编写代码。
- en: Listing 8.4\. `Point` class with read-only properties via manual implementation
    in C# 3
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 使用 C# 3 的手动实现只读属性的 `Point` 类
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Declares read-only fields**'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明只读字段**'
- en: '***2* Declares read-only properties returning the field values**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明返回字段值的只读属性**'
- en: '***3* Initializes the fields on construction**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在构造时初始化字段**'
- en: This is irritating, to say the least. Many developers—including me—sometimes
    cheated. If we wanted read-only properties, we’d use automatically implemented
    properties with private setters, as shown in the following listing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这至少是令人烦恼的。许多开发者——包括我——有时会作弊。如果我们想要只读属性，我们会使用具有私有设置器的自动实现属性，如下面的列表所示。
- en: Listing 8.5\. `Point` class with publicly read-only properties via automatic
    implementation with private setters in C# 3
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. 使用 C# 3 的私有设置器自动实现公开只读属性的 `Point` 类
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That works, but it’s unsatisfying. It doesn’t express what you want. It allows
    you to change the values of the properties within the class even though you don’t
    want to; you want a property you can set in the constructor but then never change
    elsewhere, and you want it to be backed by a field in a trivial way. Up to and
    including C# 5, the language forced you to choose between simplicity of implementation
    and clarity of intent, with each choice sacrificing the other. Since C# 6, you
    no longer need to compromise; you can write brief code that expresses your intent
    clearly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这虽然可行，但并不令人满意。它没有表达你的意图。它允许你在类内部更改属性的值，即使你不想这样做；你想要一个可以在构造函数中设置但之后在其他地方永远不会改变的属性，并且你希望它以简单的方式由一个字段支持。直到包括
    C# 5 在内，语言迫使你选择实现简单性和意图清晰之间的权衡，每个选择都牺牲了另一个。自从 C# 6 以来，你不再需要妥协；你可以编写简洁的代码，清楚地表达你的意图。
- en: 8.2\. Upgrades to automatically implemented properties
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 自动实现属性的升级
- en: C# 6 introduced two new features to automatically implemented properties. Both
    are simple to explain and use. In the previous section, I focused on the importance
    of exposing properties instead of public fields and the difficulties of implementing
    immutable types concisely. You can probably guess how our first new feature in
    C# 6 works, but a couple of other restrictions have been lifted, too.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6 引入了两个新特性来自动实现属性。这两个特性都易于解释和使用。在前一节中，我强调了暴露属性而不是公共字段的重要性，以及简洁实现不可变类型所面临的困难。你可能会猜到我们的第一个新特性在
    C# 6 中是如何工作的，但还有一些限制也被放宽了。
- en: 8.2.1\. Read-only automatically implemented properties
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 只读自动实现属性
- en: C# 6 allows genuinely read-only properties backed by read-only fields to be
    expressed in a simple way. All it takes is an empty getter and no setter, as shown
    in the next listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6 允许以简单的方式表达由只读字段支持的真正只读属性。只需一个空的获取器，没有设置器，就像在下一条列表中所示。
- en: Listing 8.6\. `Point` class using read-only automatically implemented properties
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. 使用只读自动实现的属性的 `Point` 类
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Declares read-only automatically implemented properties**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 自动声明只读属性**'
- en: '***2* Initializes the properties on construction**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在构造时初始化属性**'
- en: 'The only parts that have changed from [listing 8.5](kindle_split_024_split_000.html#ch08ex05)
    are the declarations of the `X` and `Y` properties; they no longer have a setter
    at all. Given that there are no setters, you may be wondering how you’re initializing
    the properties in the constructor. It happens exactly as it did in [listing 8.4](kindle_split_024_split_000.html#ch08ex04),
    where you implemented it manually: the field declared by the automatically implemented
    property is read-only, and any assignments to the property are translated by the
    compiler into direct field assignments. Any attempt to set the property in code
    other than the constructor results in a compile-time error.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [列表 8.5](kindle_split_024_split_000.html#ch08ex05) 中改变的部分是 `X` 和 `Y` 属性的声明；它们根本不再有设置器。鉴于没有设置器，你可能想知道如何在构造函数中初始化属性。它正好像在
    [列表 8.4](kindle_split_024_split_000.html#ch08ex04) 中手动实现的那样发生：自动实现的属性声明的字段是只读的，并且对属性的任何赋值都会由编译器转换为直接的字段赋值。在构造函数之外尝试设置属性将导致编译时错误。
- en: As a fan of immutability, this feels like a real step forward to me. It lets
    you express your ideal result in a small amount of code. Laziness is now no obstacle
    to code hygiene, at least in this one small way.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为不可变性的粉丝，这对我来说是一个真正的进步。它让你可以用少量的代码表达你的理想结果。现在，懒惰不再是代码卫生的障碍，至少在这个小方面是这样。
- en: The next limitation removed in C# 6 has to do with initialization. So far, the
    properties I’ve shown have either not been initialized explicitly at all or have
    been initialized in a constructor. But what if you want to initialize a property
    as if it were a field?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6 中移除的下一个限制与初始化有关。到目前为止，我展示的属性要么根本未显式初始化，要么在构造函数中初始化。但如果你想要像字段一样初始化一个属性呢？
- en: 8.2.2\. Initializing automatically implemented properties
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 自动实现属性的初始化
- en: Before C# 6, any initialization of automatically implemented properties had
    to be in constructors; you couldn’t initialize the properties at the point of
    declaration. For example, suppose you had a `Person` class in C# 2, as shown in
    the following listing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 之前，自动实现属性的任何初始化都必须在构造函数中；你无法在声明的地方初始化属性。例如，假设你有一个 C# 2 中的 `Person` 类，如下面的列表所示。
- en: Listing 8.7\. `Person` class with manual property in C# 2
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. C# 2 中具有手动属性的 `Person` 类
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Declares and initializes field**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明并初始化字段**'
- en: '***2* Exposes a property to read/write the field**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 暴露属性以读写字段**'
- en: If you wanted to change this code to use automatically implemented properties,
    you’d have to move the initialization into a constructor, where previously you
    hadn’t explicitly declared any constructors at all. You’d end up with code like
    the following listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将此代码更改为使用自动实现属性，你必须将初始化移动到构造函数中，而之前你根本未显式声明任何构造函数。你最终会得到如下列表所示的代码。
- en: Listing 8.8\. `Person` class with automatically implemented property in C# 3
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8\. C# 3 中具有自动实现属性的 `Person` 类
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Declares the property; no initializer permitted**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明属性；不允许初始化器**'
- en: '***2* Initializes the property in a constructor**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在构造函数中初始化属性**'
- en: That’s about as verbose as it was before! In C# 6, this restriction was removed.
    You can initialize at the point of property declaration, as the following listing
    shows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是之前那么冗长！在 C# 6 中，这个限制被移除了。你可以在属性声明的地方进行初始化，如下面的列表所示。
- en: Listing 8.9\. `Person` class with automatically implemented read/write property
    in C# 6
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. C# 6 中具有自动实现读写属性的 `Person` 类
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Declares and initializes a read/write automatically implemented**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明并初始化读写自动实现**'
- en: Naturally, you can use this feature with read-only automatically implemented
    properties as well. One common pattern is to have a read-only property exposing
    a mutable collection, so a caller can add or remove items from the collection
    but can never change the property to refer to a different collection (or set it
    to be a null reference). As you might expect, this is just a matter of removing
    the setter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，你也可以使用这个特性与只读自动实现属性一起。一个常见的模式是有一个只读属性暴露一个可变集合，这样调用者可以添加或从集合中删除项目，但永远不能更改属性以引用不同的集合（或将其设置为
    null 引用）。正如你所预期的，这只是一个移除设置器的问题。
- en: Listing 8.10\. `Person` class with automatically implemented read-only property
    in C# 6
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. C# 6 中具有自动实现只读属性的 `Person` 类
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Declares and initializes a read-only automatically implemented**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明并初始化只读自动实现**'
- en: I’ve rarely found this particular restriction of earlier versions of C# to be
    a massive problem, because usually I want to initialize properties based on constructor
    parameters anyway, but the change is certainly a welcome addition. The next restriction
    that has been removed ends up being more important in conjunction with read-only
    automatically implemented properties.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我很少发现 C# 早期版本的这个特定限制是一个大问题，因为通常我想要根据构造函数参数初始化属性，但这个变化无疑是一个受欢迎的补充。下一个被移除的限制与只读自动实现属性结合使用时变得更为重要。
- en: 8.2.3\. Automatically implemented properties in structs
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3\. 结构体中的自动实现属性
- en: 'Before C# 6, I always found automatically implemented properties to be a little
    problematic in structs. There were two reasons for this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 之前，我总是觉得自动实现属性在结构体中有点问题。有两个原因：
- en: I always write immutable structs, so the lack of read-only automatically implemented
    properties was always a pain point.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我总是编写不可变结构体，因此缺少只读自动实现属性一直是一个痛点。
- en: I could assign to an automatically implemented property in a constructor only
    after chaining to another constructor because of the rules about definite assignment.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于确定赋值规则，我只能在链接到另一个构造函数之后才能在构造函数中赋值给自动实现属性。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In general, *definite assignment rules* are about the compiler keeping track
    of which variables will have been assigned at a particular point in your code,
    regardless of how you got there. These rules are mostly relevant for local variables,
    to make sure you don’t try to read from a local variable that hasn’t been assigned
    a value yet. Here, we’re looking at a slightly different use of the same rules.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*确定赋值规则*是关于编译器跟踪在代码的特定点哪些变量将被赋值，无论你是如何到达那里的。这些规则主要与局部变量相关，以确保你不会尝试从尚未赋值的局部变量中读取。这里，我们正在查看相同规则的不同用途。
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing demonstrates both of these points in a struct version
    of our previous `Point` class. Just typing it out makes me squirm a little.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了这两个点在我们之前 `Point` 类的结构体版本中的示例。仅仅写下它就让我感到有些不舒服。
- en: Listing 8.11\. `Point` struct in C# 5 using automatically implemented properties
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. C# 5 中使用自动实现属性的 `Point` 结构体
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Properties with public getters and private setters**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 具有公共获取器和私有设置器的属性**'
- en: '***2* Chaining to default constructor**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 链接到默认构造函数**'
- en: '***3* Property initialization**'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 属性初始化**'
- en: This isn’t code I would’ve included in a real codebase. The benefits of automatically
    implemented properties are outweighed by the ugliness. You’re already familiar
    with the read-only aspect of the properties, but why do you need to call the default
    constructor in our constructor initializer?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我会包含在真实代码库中的代码。自动实现属性的好处被其丑陋性所抵消。你已经熟悉属性的只读方面，但为什么你需要在构造函数初始化器中调用默认构造函数？
- en: 'The answer lies in subtleties of the rules around field assignments in structs.
    Two rules are at work here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于结构体字段赋值规则中的细微差别。这里有两个规则在起作用：
- en: You can’t use any properties, methods, indexers, or events in a struct until
    the compiler considers that all the fields have been definitely assigned.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结构体中，直到编译器认为所有字段都已确定赋值之前，你不能使用任何属性、方法、索引器或事件。
- en: Every struct constructor must assign values to all fields before it returns
    control to the caller.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个结构体构造函数在返回控制权给调用者之前必须为所有字段分配值。
- en: In C# 5, without calling the default constructor, you’re violating both rules.
    Setting the `X` and `Y` properties still counts as using the value of the struct,
    so you’re not allowed to do it. Setting the properties doesn’t count as assigning
    the fields, so you can’t return from the constructor anyway. Chaining to the default
    constructor is a workaround because that assigns all fields before your constructor
    body executes. You can then set the properties and return at the end because the
    compiler is happy that all your fields were set anyway.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 5 中，如果不调用默认构造函数，你将违反两条规则。设置 `X` 和 `Y` 属性仍然算作使用了结构体的值，因此不允许这样做。设置属性并不算作分配字段，所以无论如何你都不能从构造函数中返回。链接到默认构造函数是一个解决方案，因为这样会在你的构造函数体执行之前分配所有字段。然后你可以设置属性并在最后返回，因为编译器很高兴地看到所有字段都已设置。
- en: 'In C# 6, the language and the compiler have a closer understanding of the relationship
    between automatically implemented properties and the fields they’re backed by:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 中，语言和编译器对自动实现属性及其所依赖的字段之间的关系有了更深入的理解：
- en: You’re allowed to set an automatically implemented property before all the fields
    are initialized.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在所有字段初始化之前设置自动实现的属性。
- en: Setting an automatically implemented property counts as initializing the field.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置自动实现的属性算作初始化字段。
- en: You’re allowed to read an automatically implemented property before other fields
    are initialized, so long as you’ve set it beforehand.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他字段初始化之前，你可以读取一个自动实现的属性，只要你事先已经设置了它。
- en: Another way of thinking of this is that within the constructor, automatically
    implemented properties are treated as if they’re fields.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考方式是，在构造函数中，自动实现的属性被视为字段。
- en: With those new rules in place and genuine read-only automatically implemented
    properties, the struct version of `Point` in C# 6 shown in the next listing is
    identical to the class version in [listing 8.6](kindle_split_024_split_000.html#ch08ex06),
    other than declaring a struct instead of a sealed class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些新规则生效并且有真正的只读自动实现属性的情况下，C# 6 中 `Point` 结构的版本与下一列表中的类版本相同，除了声明为结构体而不是密封类。
- en: Listing 8.12\. `Point` struct in C# 6 using automatically implemented properties
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. C# 6 中使用自动实现的属性的 `Point` 结构
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result is clean and concise, just the way you want it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是干净简洁的，正是你想要的。
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may be asking whether `Point` should be a struct at all. In this case, I’m
    on the fence. Points do feel like fairly natural value types, but I still usually
    default to creating classes. Outside Noda Time (which is struct heavy), I rarely
    write my own structs. This example certainly isn’t trying to suggest you should
    start using structs more widely, but if you do write your own struct, the language
    is more helpful than it used to be.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问是否应该将 `Point` 实现为结构体。在这种情况下，我处于两可之间。点确实感觉像是相当自然的值类型，但我仍然通常默认创建类。在 Noda
    Time（该库以结构体为主）之外，我很少编写自己的结构体。这个例子当然不是试图建议你应该更广泛地使用结构体，但如果你确实编写了自己的结构体，语言比以前更有帮助。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Everything you’ve seen so far has made automatically implemented properties
    cleaner to work with, which often reduces the amount of boilerplate code. Not
    all properties are automatically implemented, though. The mission of removing
    clutter from your code doesn’t stop there.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所看到的一切都使得自动实现的属性更容易使用，这通常减少了样板代码的数量。但并非所有属性都是自动实现的。从你的代码中移除杂乱的任务并没有停止在这里。
- en: 8.3\. Expression-bodied members
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 表达式成员
- en: Far be it from me to prescribe one specific style of coding in C#. Aside from
    anything else, different problem domains lend themselves to different approaches.
    But I’ve certainly come across types that have a lot of simple methods and properties.
    C# 6 helps you here with *expression-bodied members*. We’ll start off with properties,
    since you were looking at them in the previous section, and then see how the same
    idea can be applied to other function members.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会规定 C# 中的特定编码风格。除了其他任何事情之外，不同的问题领域适合不同的方法。但我确实遇到过具有许多简单方法和属性的类型。C# 6 通过 *表达式成员*
    帮助你在这里。我们将从属性开始，因为你之前已经看过它们，然后我们将看到同样的想法可以应用于其他函数成员。
- en: 8.3.1\. Even simpler read-only computed properties
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 更简单的只读计算属性
- en: 'Some properties are trivial: if the implementation in terms of fields matches
    the logical state of the type, the property can return the field value directly.
    That’s what automatically implemented properties are for. Other properties involve
    computations based on other fields or properties. To demonstrate the problem that
    C# 6 addresses, the following listing adds another property to our `Point` class:
    `DistanceFromOrigin`, which uses the Pythagorean theorem in a simple way to return
    how far the point is from the origin.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有些属性很简单：如果字段的实现与类型的逻辑状态相匹配，属性可以直接返回字段值。这就是自动实现属性的作用。其他属性涉及基于其他字段或属性的运算。为了展示
    C# 6 解决的问题，以下列表为我们的 `Point` 类添加了另一个属性：`DistanceFromOrigin`，它以简单的方式使用勾股定理来返回点与原点的距离。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t worry if the math here isn’t familiar. The details aren’t important, just
    the fact that it’s a read-only property that uses `X` and `Y`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这里的数学不熟悉，细节不重要，重要的是它是一个使用 `X` 和 `Y` 的只读属性。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 8.13\. Adding a `DistanceFromOrigin` property to `Point`
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. 向 `Point` 添加 `DistanceFromOrigin` 属性
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Read-only property to compute a distance**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只读属性用于计算距离**'
- en: 'I’m not going to claim that this is terribly hard to read, but it does contain
    a lot of syntax that I could describe as *ceremony*: it’s there only to make the
    compiler aware of how the meaningful code fits in. [Figure 8.1](kindle_split_024_split_000.html#ch08fig01)
    shows the same property but annotated to highlight the useful parts; the ceremony
    (braces, a return statement, and a semicolon) are in a lighter shade.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会声称这很难阅读，但它确实包含了很多我可以描述为*仪式*的语法：它只存在于让编译器知道有意义代码如何适应的地方。[图8.1](kindle_split_024_split_000.html#ch08fig01)显示了相同的属性，但已注释以突出有用的部分；仪式（花括号、返回语句和分号）以较浅的色调显示。
- en: Figure 8.1\. Annotated property declaration showing important aspects
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. 属性声明注释，显示重要方面
- en: '![](../Images/08fig01_alt.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08fig01_alt.jpg)'
- en: 'C# 6 allows you to express this much more cleanly:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6允许你以更简洁的方式表达：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the `=>` is used to indicate an *expression-bodied member*—in this case,
    a read-only property. No more braces, no more keywords. Both the read-only property
    part and the fact that the expression is used to return the value are implicit.
    Compare this with [figure 8.1](kindle_split_024_split_000.html#ch08fig01), and
    you’ll see that the expression-bodied form has everything that’s useful (with
    a different way of indicating that it’s a read-only property) and nothing extraneous.
    Perfect!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`=>`用于表示*表达式成员体*——在这种情况下，一个只读属性。不再需要花括号，不再需要关键字。只读属性部分以及表达式用于返回值的事实都是隐式的。与[图8.1](kindle_split_024_split_000.html#ch08fig01)进行比较，你会发现表达式成员体形式包含所有有用的部分（以不同的方式表示它是只读属性）以及没有多余的部分。完美！
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**No, this isn’t a lambda expression**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**不，这不是一个lambda表达式**'
- en: 'Yes, you’ve seen this element of syntax before. Lambda expressions were introduced
    in C# 3 as a brief way of declaring delegates and expression trees. For example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你之前已经见过这个语法元素。Lambda表达式在C# 3中引入，作为一种声明委托和表达式树的简短方式。例如：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Expression-bodied members use the `=>` syntax but aren’t lambda expressions.
    The preceding declaration of `DistanceFromOrigin` doesn’t involve any delegates
    or expression trees; it only instructs the compiler to create a read-only property
    that computes the given expression and returns the result.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式成员体使用`=>`语法，但不是lambda表达式。`DistanceFromOrigin`前面的声明不涉及任何委托或表达式树；它只指示编译器创建一个计算给定表达式并返回结果的只读属性。
- en: When talking about the syntax out loud, I usually describe `=>` as a *fat arrow*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当大声谈论语法时，我通常将`=>`描述为*粗箭头*。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You may be wondering whether this is useful in the real world rather than just
    in made-up examples for the book. To show you concrete examples, I’ll use Noda
    Time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这是否在现实世界中是有用的，而不仅仅是书中虚构的例子。为了向您展示具体的例子，我将使用Noda Time。
- en: Pass-through or delegating properties
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 透传或委托属性
- en: 'We’ll briefly consider three types from Noda Time:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要考虑Noda Time中的三种类型：
- en: '`LocalDate`—Just a date in a particular calendar with no time component'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDate`—特定日历中的日期，没有时间组件'
- en: '`LocalTime`—A time of day with no date component'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime`—一天中的时间，没有日期组件'
- en: '`LocalDateTime`—The combination of a date and a time'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDateTime`—日期和时间的组合'
- en: Don’t worry about the details of initialization and so on; just think about
    what you’d want out of the three types. Obviously, a date will have properties
    for the year, month, and day, and a time will have hours, minutes, seconds, and
    so on. What about the type combining the two? It’s handy to be able to get the
    date and time components separately, but often you want the subcomponents of the
    date and time. Each implementation of `LocalDate` and `LocalTime` is carefully
    optimized, and I wouldn’t want to duplicate that logic in `LocalDateTime`, so
    the subcomponent properties are pass-throughs that delegate to properties of the
    date or time components. The implementation shown in the following listing is
    now extremely clean.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心初始化等细节；只需考虑你希望从三种类型中得到什么。显然，日期将具有年、月和日等属性，而时间将具有小时、分钟、秒等属性。那么，结合这两种类型的类型呢？能够分别获取日期和时间组件很方便，但通常你想要日期和时间的子组件。`LocalDate`和`LocalTime`的每个实现都经过了精心优化，我不希望在`LocalDateTime`中重复该逻辑，因此子组件属性是透传的，委托给日期或时间组件的属性。以下列表中所示的实施现在非常简洁。
- en: Listing 8.14\. Delegating properties in Noda Time
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.14\. Noda Time中的委托属性
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Property for the date component**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 日期组件的属性**'
- en: '***2* Properties delegating to date subcomponents**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 委托给日期子组件的属性**'
- en: '***3* Property for the time component**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 时间组件的属性**'
- en: '***4* Properties delegating to time subcomponents**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将属性委托给时间子组件**'
- en: '***5* Initialization, other properties, and members**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 初始化、其他属性和成员**'
- en: A lot of properties are like this; removing the `{ get { return ... } }` part
    from each of them was a real pleasure and leaves the code much clearer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 许多属性都像这样；从每个属性中移除 `{ get { return ... } }` 部分确实是一种乐趣，并且使代码更加清晰。
- en: Performing simple logic on another piece of state
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在另一个状态上执行简单的逻辑
- en: 'Within `LocalTime`, there’s a single piece of state: the nanosecond within
    the day. All the other properties compute a value based on that. For example,
    the code to compute the subsecond value in nanoseconds is a simple remainder operation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LocalTime` 中，只有一个状态：一天中的纳秒数。所有其他属性都是基于这个值来计算值的。例如，计算纳秒级子秒值的代码是一个简单的余数操作：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That code will get even simpler in [chapter 10](kindle_split_026_split_000.html#ch10),
    but for now, you can just enjoy the brevity of the expression-bodied property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 10 章[中](kindle_split_026_split_000.html#ch10)，这段代码将变得更加简单，但到目前为止，你只需享受表达式主体属性的简洁性。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Important caveat**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要注意事项**'
- en: 'Expression-bodied properties have one downside: there’s only a single-character
    difference between a read-only property and a public read/write field. In most
    cases, if you make a mistake, a compile-time error will occur, due to using other
    properties or fields within a field initializer, but for static properties or
    properties returning a constant value, it’s an easy mistake to make. Consider
    the difference between the following declarations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式主体属性有一个缺点：只读属性和公共可读写字段之间只有一个字符的差异。在大多数情况下，如果你犯了一个错误，由于在字段初始化器中使用其他属性或字段，编译时错误将会发生，但对于静态属性或返回常量值的属性，这是一个容易犯的错误。考虑以下声明之间的差异：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This has been a problem for me a couple of times, but after you’re aware of
    it, checking for it is easy enough. Make sure your code reviewers are aware of
    it, too, and you’re unlikely to get caught.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我来说已经成了几次问题，但一旦你意识到它，检查起来就足够简单。确保你的代码审查人员也了解这一点，这样你就不太可能被抓住。
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So far, we’ve concentrated on properties as a natural segue from the other new
    property-related features. As you may have guessed from the section title, however,
    other kinds of members can have expression bodies.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于属性，作为从其他新属性相关功能自然过渡的一部分。然而，正如章节标题所暗示的，其他类型的成员也可以有表达式主体。
- en: 8.3.2\. Expression-bodied methods, indexers, and operators
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 表达式主体方法、索引器和操作符
- en: In addition to expression-bodied properties, you can write expression-bodied
    methods, read-only indexers, and operators, including user-defined conversions.
    The `=>` is used in the same way, with no braces surrounding the expression and
    no explicit return statement.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表达式主体属性外，你还可以编写表达式主体方法、只读索引器和操作符，包括用户定义的转换。`=>` 的使用方式相同，表达式周围没有大括号，也没有显式的返回语句。
- en: For example, a simple `Add` method and its operator equivalent to add a `Vector`
    (with obvious `X` and `Y` properties) to a `Point` might look like the following
    listing in C# 5.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个简单的 `Add` 方法及其等价的操作符，用于将一个具有明显 `X` 和 `Y` 属性的 `Vector` 添加到 `Point` 中，在 C#
    5 中可能看起来像以下代码示例。
- en: Listing 8.15\. Simple methods and operators in C# 5
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. C# 5 中的简单方法和操作符
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Just delegate to the operator.**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只委托给操作符。**'
- en: '***2* Simple constructor call to implement +**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 简单的构造函数调用以实现 +**'
- en: In C# 6, it could look simpler, with both of these being implemented using expression-bodied
    members, as in the next listing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 中，它可能看起来更简单，这两个都可以使用表达式主体成员来实现，如下面的代码示例所示。
- en: Listing 8.16\. Expression-bodied methods and operators in C# 6
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16\. C# 6 中的表达式主体方法和操作符
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the formatting I’ve used in `operator+`; putting everything on one line
    would make it much too long. In general, I put the `=>` at the end of the declaration
    part and indent the body as usual. The way you format your code is entirely up
    to you, but I’ve found this convention works well for all kinds of expression-bodied
    members.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我在 `operator+` 中使用的格式化；将所有内容放在一行会使代码变得非常长。一般来说，我在声明部分的末尾放置 `=>` 并像往常一样缩进主体。你格式化代码的方式完全取决于你，但我发现这个约定对所有类型的表达式成员都很有用。
- en: You can also use expression bodies for `void`-returning methods. In that case,
    there’s no `return` statement to omit; only the braces are removed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用表达式主体为 `void` 返回类型的方法。在这种情况下，没有要省略的 `return` 语句；只需移除大括号。
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: This is consistent with the way lambda expressions work. As a reminder, expression-bodied
    members aren’t lambda expressions, but they have this aspect in common.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 lambda 表达式的工作方式一致。提醒一下，表达式成员不是 lambda 表达式，但它们有这个共同点。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'For example, consider a simple log method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个简单的日志方法：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This could be written with an expression-bodied method like this instead:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用一个表达式成员方法写成这样：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here the benefit is definitely smaller, but for methods where the declaration
    and body fit on one line, it can still be worth doing. In [chapter 9](kindle_split_025_split_000.html#ch09),
    you’ll see a way of making this even cleaner using interpolated string literals.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的好处确实较小，但对于声明和主体可以放在一行的方法来说，这仍然值得做。在 [第 9 章](kindle_split_025_split_000.html#ch09)
    中，你会看到一种使用插值字符串字面量使其更干净的方法。
- en: For a final example with methods, a property, and an indexer, let’s imagine
    you want to create your own `IReadOnlyList<T>` implementation to provide a read-only
    view over any `IList<T>`. Of course, `ReadOnlyCollection<T>` already does this,
    but it also implements the mutable interfaces (`IList<T>`, `ICollection<T>`).
    At times you may want to be precise about what a collection allows via the interfaces
    it implements. With expression-bodied members, the implementation of such a wrapper
    is short indeed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个包含方法、属性和索引器的最终示例，让我们假设你想要创建自己的 `IReadOnlyList<T>` 实现，以提供对任何 `IList<T>` 的只读视图。当然，`ReadOnlyCollection<T>`
    已经做到了这一点，但它也实现了可变接口（`IList<T>`, `ICollection<T>`）。有时你可能想精确地了解集合通过其实现的接口允许什么。使用表达式成员，这样的包装器实现确实很短。
- en: Listing 8.17\. `IReadOnlyList<T>` implementation using expression-bodied members
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.17\. 使用表达式成员的 `IReadOnlyList<T>` 实现
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Indexer delegating to list indexer**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将索引器委托给列表索引器**'
- en: '***2* Property delegating to list property**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 属性委托给列表属性**'
- en: '***3* Method delegating to list method**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 方法委托给列表方法**'
- en: '***4* Method delegating to the other GetEnumerator method**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 方法委托给其他 GetEnumerator 方法**'
- en: The only new feature shown here is the syntax for expression-bodied indexers,
    and I hope it’s sufficiently similar to the syntax for the other kinds of members
    that you didn’t even notice it was new.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的唯一新特性是表达式成员索引器的语法，我希望它与其他类型成员的语法足够相似，以至于你没有注意到它是新的。
- en: Does anything stick out to you, though? Anything surprise you at all? That constructor
    looks a little ugly, doesn’t it?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有什么让你印象深刻的地方吗？有什么让你感到惊讶的吗？那个构造函数看起来有点丑，不是吗？
- en: 8.3.3\. Restrictions on expression-bodied members in C# 6
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. C# 6 中表达式成员的限制
- en: Normally, at this point, having just remarked on how verbose a piece of code
    is, I’d reveal the good news of another feature that C# has implemented to make
    it better. Not this time, I’m afraid—at least not in C# 6.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在这个时候，我刚刚评论了代码的冗长性，我会透露 C# 实现的另一个新特性，以使其变得更好。但这次恐怕不行——至少不是在 C# 6 中。
- en: Even though the constructor has only a single statement, there’s no such thing
    as an expression-bodied constructor in C# 6\. It’s not alone, either. You can’t
    have expression-bodied
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 即使构造函数只有一个语句，但在 C# 6 中没有表达式成员构造函数。它也不是独一无二的。你不能有表达式成员
- en: Static constructors
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态构造函数
- en: Finalizers
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 析构函数
- en: Instance constructors
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例构造函数
- en: Read/write or write-only properties
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写或只写属性
- en: Read/write or write-only indexers
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写或只写索引器
- en: Events
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: None of that keeps me awake at night, but the inconsistency apparently bothered
    the C# team enough that C# 7 allows all of these to be expression-bodied. They
    don’t typically save any printable characters, but formatting conventions allow
    them to save vertical space, and there’s still the readability hint that this
    is just a simple member. They all use the same syntax you’re already used to,
    and [listing 8.18](kindle_split_024_split_000.html#ch08ex18) gives a complete
    example, purely for the sake of showing the syntax. This code isn’t intended to
    be useful other than as an example, and in the case of the event handler, it’s
    dangerously non-thread-safe compared with a simple field-like event.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都没有让我夜不能寐，但显然不一致性让 C# 团队感到足够的困扰，以至于 C# 7 允许所有这些使用表达式成员。它们通常不会节省任何可打印的字符，但格式化约定允许它们节省垂直空间，并且仍然有这种可读性提示，即这只是一个简单的成员。它们都使用你已经习惯的相同语法，[列表
    8.18](kindle_split_024_split_000.html#ch08ex18) 提供了一个完整的示例，纯粹是为了展示语法。这段代码并不打算作为有用的代码，而只是作为一个示例，在事件处理程序的情况下，与简单的字段式事件相比，它是不安全的非线程安全的。
- en: Listing 8.18\. Extra expression-bodied members in C# 7
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.18\. C# 7 中的额外表达式成员
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Static constructor**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 静态构造函数**'
- en: '***2* Finalizer**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 析构函数**'
- en: '***3* Constructor**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 构造函数**'
- en: '***4* Event with custom accessors**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 带有自定义访问器的事件**'
- en: '***5* Read/write indexer**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 读写索引器**'
- en: '***6* Read/write property**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 读写属性**'
- en: 'One nice aspect of this is that the `get` accessor can be expression-bodied
    even if the `set` accessor isn’t, or vice versa. For example, suppose you want
    to make your indexer setter validate that the new value isn’t negative. You could
    still keep an expression-bodied getter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个优点之一是，即使 `set` 访问器不是表达式成员，`get` 访问器也可以是表达式成员，反之亦然。例如，假设你想让你的索引器设置器验证新值不是负数。你仍然可以保留一个表达式成员的获取器：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I expect this to be reasonably common in the future. Setters tend to have validation,
    whereas getters are usually trivial, in my experience.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计在未来这将会相当普遍。根据我的经验，设置器通常包含验证，而获取器通常是微不足道的。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you find yourself writing a lot of logic in a getter, it’s worth considering
    whether it should be a method. Sometimes the boundary can be fuzzy.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己在一个获取器中写了很多逻辑，那么考虑它是否应该是一个方法是有意义的。有时边界可能很模糊。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With all the benefits of expression-bodied members, do they have any other downsides?
    How aggressive should you be in converting everything you possibly can to use
    them?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然表达式成员有许多好处，但它们是否有其他缺点？你应该在将所有可能的内容转换为使用它们时有多激进？
- en: 8.3.4\. Guidelines for using expression-bodied members
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 使用表达式成员的指南
- en: My experience is that expression-bodied members are particularly useful for
    operators, conversions, comparisons, equality checks, and `ToString` methods.
    These usually consist of simple code, but for some types there can be an awful
    lot of these members, and the difference in readability can be significant.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我的经验是，表达式成员特别适用于运算符、转换、比较、相等检查和 `ToString` 方法。这些通常由简单的代码组成，但对于某些类型，可能会有很多这样的成员，可读性的差异可能非常显著。
- en: Unlike some features that are somewhat niche, expression-bodied members can
    be used to significant effect in pretty much every codebase I’ve come across.
    When I converted Noda Time to use C# 6, I removed roughly 50% of the return statements
    in the code. That’s a huge difference, and it’ll only increase as I gradually
    take advantage of the extra opportunities afforded by C# 7.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些相对小众的功能不同，表达式成员可以在我所遇到的几乎每一个代码库中发挥重要作用。当我将 Noda Time 转换为使用 C# 6 时，我移除了代码中大约
    50% 的返回语句。这是一个巨大的差异，而且随着我逐渐利用 C# 7 提供的额外机会，这个比例只会增加。
- en: 'There’s more to expression-bodied members than readability, mind you. I’ve
    found that they provide a psychological effect: it feels like I’m doing functional
    programming to a greater extent than before. That, in turn, makes me feel smarter.
    Yes, that’s as silly as it sounds, but it really does feel satisfying. You may
    be more rational than me, of course.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，表达式成员不仅仅是可读性。我发现它们提供了一种心理效应：感觉我比以前更多地在进行函数式编程。这反过来又让我觉得自己更聪明。是的，听起来很愚蠢，但确实感觉令人满意。当然，你可能会比我更理性。
- en: 'The danger, as always, is overuse. In some cases, you can’t use expression-bodied
    members, because your code includes a `for` statement or something similar. In
    plenty of cases, it’s possible to convert a regular method into an expression-bodied
    member, but you really shouldn’t. I’ve found that there are two categories of
    members like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 总是存在过度使用的危险。在某些情况下，你不能使用表达式成员，因为你的代码中包含了一个 `for` 语句或类似的内容。在许多情况下，将常规方法转换为表达式成员是可能的，但你真的不应该这样做。我发现，这类成员可以分为两类：
- en: Members performing precondition checks
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行前置条件检查的成员
- en: Members using explanatory variables
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解释性变量的成员
- en: As an example of the first category, I have a class called `Preconditions` with
    a generic `CheckNotNull` method that accepts a reference and a parameter name.
    If the reference is null, it throws an `ArgumentNullException` using the parameter
    name; otherwise, it returns the value. This allows a convenient combination of
    check and assign statements in constructors and the like.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一类成员的例子，我有一个名为 `Preconditions` 的类，它有一个通用的 `CheckNotNull` 方法，接受一个引用和一个参数名称。如果引用为空，它将使用参数名称抛出
    `ArgumentNullException`；否则，它返回值。这允许在构造函数等地方方便地将检查和赋值语句组合在一起。
- en: 'This also allows—but certainly doesn’t force—you to use the result as both
    the target of a method call or, indeed, an argument to it. The problem is, understanding
    what’s going on becomes difficult if you’re not careful. Here’s a method from
    the `LocalDateTime` struct I described earlier:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这也允许——但当然不是强制——你将结果用作方法调用的目标或，实际上，作为它的参数。问题是，如果不小心，理解正在发生的事情会变得困难。这里有一个我从之前描述的
    `LocalDateTime` 结构体中提取的方法：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This reads nice and simply: check that the arguments are valid and then do
    the work by delegating to another method. This could be written as an expression-bodied
    member, like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这读起来既简洁又简单：检查参数是否有效，然后通过委托给另一个方法来完成工作。这可以写成表达式体成员，如下所示：
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That would have exactly the same effect, but it’s much harder to read. In my
    experience, one validation check puts a method on the borderline for expression-bodied
    members; with two of them, it’s just too painful.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生完全相同的效果，但阅读起来要困难得多。根据我的经验，一个验证检查将方法放在表达式体成员的边缘；有两个这样的检查，那就太痛苦了。
- en: 'For explanatory variables, the `NanosecondOfSecond` example I provided earlier
    is just one of many properties on `LocalTime`. About half of them use expression
    bodies, but quite a few of them have two statements, like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解释变量，我之前提供的 `NanosecondOfSecond` 示例只是 `LocalTime` 上的许多属性之一。大约一半使用表达式体，但相当多的属性有两个语句，就像这样：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That can easily be written as an expression-bodied property by effectively
    inlining the `minuteOfDay` variable:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地写成表达式体属性，通过有效地内联 `minuteOfDay` 变量：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, the code achieves exactly the same goal, but in the original version,
    the `minuteOfDay` variable adds information about the *meaning* of the subexpression,
    making the code easier to read.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，代码实现了完全相同的目标，但在原始版本中，`minuteOfDay` 变量增加了关于子表达式的*意义*的信息，这使得代码更容易阅读。
- en: On any given day, I *might* come to a different conclusion. But in more complex
    cases, following a sequence of steps and naming the results can make all the difference
    when you come back to the code six months later. It also helps you if you ever
    need to step through the code in a debugger, as you can easily execute one statement
    at a time and check that the results are the ones you expect.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定的一天，我*可能*得出不同的结论。但在更复杂的情况下，遵循一系列步骤并命名结果，当你六个月后回到代码时，可能会有很大的不同。这也帮助你在需要时在调试器中逐步执行代码，因为你可以轻松地一次执行一个语句并检查结果是否是你预期的。
- en: The good news is that you can experiment and change your mind as often as you
    like. Expression-bodied members are purely syntactic sugar, so if your taste changes
    over time, you can always convert more code to use them or revert code that used
    expression bodies a little too eagerly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是你可以随意进行实验和改变主意。表达式体成员纯粹是语法糖，所以如果你的品味随时间改变，你总是可以转换更多代码来使用它们，或者撤销过于急切地使用表达式体的代码。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Automatically implemented properties can now be read-only and backed by a read-only
    field.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动实现的属性现在可以是只读的，并由只读字段支持。
- en: Automatically implemented properties can now have initializers rather than nondefault
    values having to be initialized in a constructor.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动实现的属性现在可以有初始化器，而不是在构造函数中初始化非默认值。
- en: Structs can use automatically implemented properties without having to chain
    constructors together.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体可以使用自动实现的属性，而无需将构造函数链接在一起。
- en: Expression-bodied members allow simple (single-expression) code to be written
    with less ceremony.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式体成员允许用更少的仪式编写简单的（单表达式）代码。
- en: Although restrictions limit the kinds of members that can be written with expression
    bodies in C# 6, those restrictions are lifted in C# 7.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然限制限制了在 C# 6 中使用表达式体编写的成员类型，但这些限制在 C# 7 中被取消了。
- en: Chapter 9\. Stringy features
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章\. 字符串特性
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Using interpolated string literals for more-readable formatting
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插值字符串字面量进行更易读的格式化
- en: Working with `FormattableString` for localization and custom formatting
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `FormattableString` 进行本地化和自定义格式化
- en: Using `nameof` for refactoring-friendly references
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `nameof` 进行重构友好的引用
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Everyone knows how to use strings. If `string` isn’t the first .NET data type
    you learned about, it’s probably the second. The `string` class itself hasn’t
    changed much over the course of .NET’s history, and not many string-oriented features
    have been introduced in C# as a language since C# 1\. C# 6, however, changed that
    with another kind of string literal and a new operator. You’ll look at both of
    these in detail in this chapter, but it’s worth remembering that the strings themselves
    haven’t changed at all. Both features provide new ways of *obtaining* strings,
    but that’s all.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道如何使用字符串。如果`string`不是你首先了解的.NET数据类型，那么它很可能是第二个。在.NET的历史进程中，`string`类本身并没有发生太多变化，自从C#
    1以来，作为一门语言，C#并没有引入很多以字符串为导向的特性。然而，C# 6通过另一种字符串字面量和一个新的运算符改变了这一点。你将在本章中详细了解这两个方面，但值得记住的是，字符串本身并没有发生任何变化。这两个特性提供了获取字符串的新方法，但这只是全部。
- en: Just like the features you saw in [chapter 8](kindle_split_024_split_000.html#ch08),
    string interpolation doesn’t allow you to do anything you couldn’t do before;
    it just allows you to do it more readably and concisely. That’s not to diminish
    the importance of the feature. Anything that allows you to write clearer code
    more quickly—and then read it more quickly later—will make you more productive.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在[第8章](kindle_split_024_split_000.html#ch08)中看到的功能一样，字符串插值并不允许你做之前不能做的事情；它只是允许你以更易读和简洁的方式去做。这并不是要贬低该功能的重要性。任何能够让你更快地编写更清晰代码，并且之后更快地阅读代码的东西，都会让你更有效率。
- en: The `nameof` operator was genuinely new functionality in C# 6, but it’s a reasonably
    minor feature. All it does is allow you to get an identifier that already appears
    in your code but as a string at execution time. It’s not going to change your
    world like LINQ or async/await, but it helps avoid typos and allows refactoring
    tools to do more work for you. Before I show you anything new, let’s revisit what
    you already know.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof`运算符是C# 6中真正的新功能，但它是一个相对较小的特性。它所做的只是允许你在执行时获取一个已经在你的代码中出现的标识符，但作为字符串。它不会像LINQ或async/await那样改变你的世界，但它有助于避免错误，并允许重构工具为你做更多的工作。在我向你展示任何新内容之前，让我们回顾一下你已经知道的内容。'
- en: 9.1\. A recap on string formatting in .NET
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. .NET中的字符串格式化回顾
- en: You almost certainly know everything in this section. You may well have been
    using strings for many years and almost certainly for as long as you’ve been using
    C#. Still, in order to understand how the interpolated string literal feature
    in C# 6 works, it’s best to have all that knowledge uppermost in your mind. Please
    bear with me as we go over the basics of how .NET handles string formatting. I
    promise we’ll get to the new stuff soon.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎肯定知道本节中的所有内容。你可能已经使用字符串很多年了，而且几乎肯定是从使用C#开始就一直在使用。然而，为了理解C# 6中插值字符串字面量功能的工作原理，最好是将所有这些知识都放在心中。请耐心等待，我们将回顾.NET处理字符串格式化的基础知识。我保证我们很快就会到达新内容。
- en: 9.1.1\. Simple string formatting
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1. 简单字符串格式化
- en: 'If you’re like me, you like experimenting with new languages by writing trivial
    console applications that do nothing useful but give the confidence and firm foundation
    to move on to more-impressive feats. As such, I can’t remember how many languages
    I’ve used to implement the functionality shown next—asking the user’s name and
    then saying hello to that user:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样，你喜欢通过编写无用的控制台应用程序来尝试新语言，这些应用程序除了提供信心和坚实的基础外，不会做任何有用的事情。因此，我记不起我使用过多少种语言来实现下一个功能——询问用户的姓名，然后向该用户说你好：
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last line is the most relevant one for this chapter. It uses an overload
    of `Console.WriteLine`, which accepts a *composite format string* including *format
    items* and then arguments to replace those format items. The preceding example
    has one format item, `{0}`, which is replaced by the value of the `name` variable.
    The number in the format item specifies the index of the argument you want to
    fill the hole (where 0 represents the first of the values, 1 represents the second,
    and so on).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最相关的一行是最后一行。它使用了一个`Console.WriteLine`的重载，该重载接受一个包含*复合格式字符串*和*格式项*的参数，然后是替换这些格式项的参数。前面的例子中有一个格式项`{0}`，它被`name`变量的值替换。格式项中的数字指定了你要填充的参数的索引（其中0代表第一个值，1代表第二个，以此类推）。
- en: This pattern is used in various APIs. The most obvious example is the static
    `Format` method in the `string` class, which does nothing *but* format the string
    appropriately. So far, so good. Let’s do something a little more complicated.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在各种API中使用。最明显的例子是`string`类中的静态`Format`方法，它所做的只是适当地格式化字符串。到目前为止，一切顺利。让我们做一些稍微复杂一点的事情。
- en: 9.1.2\. Custom formatting with format strings
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2. 使用格式字符串进行自定义格式化
- en: Just to be clear, my motivation for including this subsection is as much for
    my future self as for you, dear reader. If MSDN displayed the number of times
    I’ve visited any given page, the number for the page on composite format strings
    would be frightening. I keep forgetting exactly what goes where and what terms
    to use, and I figured that if I included that information here, I might start
    remembering it better. I hope you find it helpful in the same way.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，我包括这个子节的原因，不仅是为了未来的自己，也是为了亲爱的读者。如果MSDN显示了我在任何给定页面上访问的次数，那么复合格式字符串页面的数字会令人恐惧。我总是忘记确切的位置和应该使用的术语，我想如果我在这里包含这些信息，我可能会更好地记住它们。我希望你也能以同样的方式找到它有帮助。
- en: 'Each format item in a composite format string specifies the index of the argument
    to be formatted, but it can also specify the following options for formatting
    the value:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 复合格式字符串中的每个格式项指定要格式化的参数的索引，但它也可以指定以下选项来格式化值：
- en: An *alignment*, which specifies a minimum width and whether the value should
    be left- or right-aligned. Right-alignment is indicated by a positive value; left-alignment
    is indicated by a negative value.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*对齐*，它指定最小宽度和值应该是左对齐还是右对齐。右对齐由正值表示；左对齐由负值表示。
- en: A *format string* for the value. This is probably used most often for date and
    time values or numbers. For example, to format a date according to ISO-8601, you
    could use a format string of `yyyy-MM-dd`. To format a number as a currency value,
    you could use a format string of `C`. The meaning of the format string depends
    on the type of value being formatted, so you need to look up the relevant documentation
    to choose the right format string.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于值的*格式字符串*。这通常用于日期和时间值或数字。例如，要按照ISO-8601格式化日期，可以使用格式字符串`yyyy-MM-dd`。要将数字格式化为货币值，可以使用格式字符串`C`。格式字符串的含义取决于正在格式化的值的类型，因此您需要查找相关文档以选择正确的格式字符串。
- en: '[Figure 9.1](kindle_split_025_split_000.html#ch09fig01) shows all the parts
    of a composite format string you could use to display a price.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.1](kindle_split_025_split_000.html#ch09fig01)显示了可以用于显示价格的复合格式字符串的所有部分。'
- en: Figure 9.1\. A composite format string with a format item to display a price
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1. 一个包含用于显示价格的格式项的复合格式字符串
- en: '![](../Images/09fig01.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig01.jpg)'
- en: The alignment and the format string are independently optional; you can specify
    either, both, or neither. A comma in the format item indicates an alignment, and
    a colon indicates a format string. If you need a comma in the format string, that’s
    fine; there’s no concept of a second alignment value.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐和格式字符串是独立可选的；您可以指定任何一个、两个或都不指定。格式项中的逗号表示对齐，而冒号表示格式字符串。如果您需要在格式字符串中包含逗号，那没问题；没有第二个对齐值的观念。
- en: As a concrete example to expand on later, let’s use the code from [figure 9.1](kindle_split_025_split_000.html#ch09fig01)
    in a broader context, showing different lengths of results to demonstrate the
    point of alignment. [Listing 9.1](kindle_split_025_split_000.html#ch09ex01) displays
    a price ($95.25), tip ($19.05), and total ($114.30), lining up the labels on the
    left and the values on the right.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 作为稍后扩展的具体示例，让我们在一个更广泛的环境中使用[图9.1](kindle_split_025_split_000.html#ch09fig01)中的代码，以展示不同长度的结果，以说明对齐的要点。[列表9.1](kindle_split_025_split_000.html#ch09ex01)显示了一个价格（$95.25）、小费（$19.05）和总计（$114.30），将标签对齐在左侧，将值对齐在右侧。
- en: 'The output on a machine using the US English culture settings by default, would
    look like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 默认使用美国英语文化设置的机器上的输出将如下所示：
- en: '[PRE30]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To make the values right-aligned (or left-padded with spaces, to look at it
    the other way around), the code uses an alignment value of 9\. If you had a huge
    bill (a million dollars, for example), the alignment would have no effect; it
    specifies only a minimum width. If you wanted to write code that right-aligned
    every possible set of values, you’d have to work out how wide the biggest one
    would be first. That’s pretty unpleasant code, and I’m afraid nothing in C# 6
    makes it easier.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要使值右对齐（或用空格左填充，从另一个角度来看），代码使用对齐值为 9。如果你有一大笔钱（比如一百万美元），对齐就没有效果；它只指定最小宽度。如果你想编写将每可能的一组值都右对齐的代码，你首先必须计算出最大的宽度是多少。这是一段相当不愉快的代码，而且我担心
    C# 6 中没有任何东西能使其更容易。
- en: Listing 9.1\. Displaying a price, tip, and total with values aligned
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 显示带有对齐值的单价、小费和总计
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* 20% tip**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 20% 小费**'
- en: When I showed the output of [listing 9.1](kindle_split_025_split_000.html#ch09ex01)
    on a machine in the US English culture, the part about the culture was important.
    On a machine using a UK English culture, the code would use £ signs instead. On
    a machine in the French culture, the decimal separator would become a comma, the
    currency sign would become a Euro symbol, and that symbol would be at the end
    of the string instead of the start! Such are the joys of localization, which you’ll
    look at next.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在美国英语文化的机器上展示了 [列表 9.1](kindle_split_025_split_000.html#ch09ex01) 的输出时，关于文化的那部分很重要。在使用英国英语文化的机器上，代码会使用英镑符号。在法语文化的机器上，小数分隔符会变成逗号，货币符号会变成欧元符号，而这个符号会在字符串的末尾而不是开头！这就是本地化的乐趣，你将在下一节中看到。
- en: 9.1.3\. Localization
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. 本地化
- en: In broad terms, *localization* is the task of making sure your code does the
    right thing for all your users, no matter where they are in the world. Anyone
    who claims that localization is simple is either much more experienced at it than
    I am or hasn’t done enough of it to see how painful it can be. Considering the
    world is basically round, it certainly seems to have a lot of nasty corner cases
    to handle. Localization is a pain in all programming languages, but each has a
    slightly different way of addressing the problems.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从广义上讲，*本地化*是指确保你的代码无论用户在世界任何地方都能正确运行的任务。任何声称本地化很简单的人要么比我更有经验，要么还没有足够地做本地化工作以看到它可能有多么痛苦。考虑到世界基本上是圆的，它似乎有很多棘手的边缘情况需要处理。本地化在所有编程语言中都是一种痛苦，但每种语言都有稍微不同的方式来解决这些问题。
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although I use the term *localization* in this section, other people may prefer
    the term *globalization*. Microsoft uses the two terms in a slightly different
    way than other industry bodies, and the difference is somewhat subtle. Experts,
    please forgive the hand-waving here; the big picture is more important than the
    fine details of terminology, just this once.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我在本节中使用术语 *本地化*，但其他人可能更喜欢使用术语 *全球化*。微软在本地化和全球化这两个术语的使用上与其他行业机构略有不同，这种差异是相当微妙的。专家们，请原谅我在这里的手势挥舞；整体图景比术语的细微差别更重要，就这一次。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In .NET, the most important type to know about for localization purposes is
    `CultureInfo`. This is responsible for the cultural preferences of a language
    (such as English), or a language in a particular location (such as French in Canada),
    or a particular variant of a language in a location (such as simplified Chinese
    as used in Taiwan). These cultural preferences include various translations (the
    words used for the days of the week, for example) and indicate how text is sorted
    and how numbers are formatted (whether to use a period or comma as the decimal
    separator) and much more.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，对于本地化目的，最重要的类型是 `CultureInfo`。它负责语言（如英语）的文化偏好，或特定位置的语言（如加拿大的法语），或特定位置的语言的特定变体（如台湾使用的简体中文）。这些文化偏好包括各种翻译（例如，用于星期的单词）以及指示文本的排序方式和数字的格式化方式（是否使用句点或逗号作为小数分隔符）等等。
- en: 'Often, you won’t see `CultureInfo` in a method signature, but instead the `IFormatProvider`
    interface, which `CultureInfo` implements. Most formatting methods have overloads
    with an `IFormatProvider` as the first parameter before the format string itself.
    For example, consider these two signatures from `string.Format`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会在方法签名中看到 `CultureInfo`，而是看到 `IFormatProvider` 接口，这是 `CultureInfo` 实现的。大多数格式化方法都有重载，其中
    `IFormatProvider` 作为格式字符串本身之前的第一参数。例如，考虑以下来自 `string.Format` 的两个签名：
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Usually, if you provide overloads that differ only by a single parameter, that
    parameter is the last one, so you might have expected the `provider` parameter
    to come after `args`. That wouldn’t work, though, because `args` is a parameter
    array (it uses the `params` modifier). If a method has a parameter array, that
    has to be the final parameter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你提供仅通过单个参数不同的重载，那么该参数就是最后一个，所以你可能预计 `provider` 参数应该在 `args` 之后。但这不会起作用，因为
    `args` 是一个参数数组（它使用 `params` 修饰符）。如果一个方法有一个参数数组，那么它必须是最后一个参数。
- en: 'Even though the parameter is of type `IFormatProvider`, the value you pass
    in as an argument is almost always `CultureInfo`. For example, if you want to
    format my date of birth for US English—June 19, 1976—you could use this code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 即使参数类型为 `IFormatProvider`，你作为参数传入的值几乎总是 `CultureInfo`。例如，如果你想为美国英语格式化我的出生日期——1976年6月19日——你可以使用以下代码：
- en: '[PRE33]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, `d` is the standard date/time format specifier for *short date*, which
    in US English corresponds to month/day/year. My date of birth would be formatted
    as 6/19/1976, for example. In British English, the short date format is day/month/year,
    so the same date would be formatted as 19/06/1976\. Notice that not just the ordering
    is different: the month is 0-padded to two digits in the British formatting, too.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`d` 是标准日期/时间格式说明符，用于*短日期*，在美国英语中对应于月/日/年。例如，我的出生日期将被格式化为6/19/1976。在英式英语中，短日期格式是日/月/年，所以相同的日期将被格式化为19/06/1976。请注意，不仅仅是顺序不同：在英式格式中，月份也是0填充到两位数字。
- en: Other cultures can use entirely different formatting. It can be instructive
    to see just how different the results of formatting the same value can be between
    cultures. For example, you could format the same date in every culture .NET knows
    about as shown in the next listing.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文化可以使用完全不同的格式。看到相同值在不同文化中格式化的结果差异可能很有教育意义。例如，你可以像在下一个列表中所示的那样，格式化 .NET 知道的每种文化中的相同日期。
- en: Listing 9.2\. Formatting a single date in every culture
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 在每种文化中格式化单个日期
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output for Thailand shows that I was born in 2519 in the Thai Buddhist
    calendar, and the output for Afghanistan shows that I was born in 1355 in the
    Islamic calendar:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 泰国的输出显示我在泰国佛教历中出生于2519年，而阿富汗的输出显示我在伊斯兰历中出生于1355年：
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This example also shows a negative alignment value to left-align the culture
    name using the `{0,-15}` format item while keeping the date right-aligned with
    the `{1,12:d}` format item.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还显示了一个负对齐值，用于使用 `{0,-15}` 格式项将文化名称左对齐，同时使用 `{1,12:d}` 格式项将日期右对齐。
- en: Formatting with the default culture
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用默认文化进行格式化
- en: If you don’t specify a format provider, or if you pass `null` as the argument
    corresponding to an `IFormatProvider` parameter, `CultureInfo.CurrentCulture`
    will be used as a default. Exactly what that means will depend on your context;
    it can be set on a per thread basis, and some web frameworks will set it before
    processing a request on a particular thread.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有指定格式提供程序，或者如果你传递 `null` 作为对应于 `IFormatProvider` 参数的参数，将使用 `CultureInfo.CurrentCulture`
    作为默认值。这具体意味着什么将取决于你的上下文；它可以在每个线程的基础上设置，并且一些网络框架会在处理特定线程上的请求之前设置它。
- en: 'All I can advise about using the default is to be careful: make sure you know
    that the value in your specific thread will be appropriate. (Checking the exact
    behavior is particularly worthwhile if you start parallelizing operations across
    multiple threads, for example.) If you don’t want to rely on the default culture,
    you’ll need to know the culture of the end user you need to format the text for
    and do so explicitly.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用默认值，我唯一能建议的是要小心：确保你知道你特定线程中的值是合适的。（如果你开始并行化跨多个线程的操作，检查确切的行为特别有价值。）如果你不想依赖于默认文化，你需要知道你需要为格式化文本的最终用户的文化，并明确这样做。
- en: Formatting for machines
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为机器进行格式化
- en: So far, we’ve assumed that you’re trying to format the text for an end user.
    But that’s often not the case. For machine-to-machine communication (such as in
    URL query parameters to be parsed by a web service), you should use the *invariant
    culture*, which is obtained via the static `CultureInfo.InvariantCulture` property.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设你正在尝试为最终用户格式化文本。但情况往往并非如此。对于机器到机器的通信（例如，在由网络服务解析的URL查询参数中），你应该使用*不变文化*，这可以通过静态
    `CultureInfo.InvariantCulture` 属性获得。
- en: 'For example, suppose you were using a web service to fetch the list of best
    sellers from a publisher. The web service might use a URL of [https://manning.com/webservices/bestsellers](https://manning.com/webservices/bestsellers)
    but allow a query parameter called `date` to allow you to find out the best-selling
    books on a particular date.^([[1](kindle_split_025_split_000.html#ch09fn1)]) I’d
    expect that query parameter to use an ISO-8601 format (year first, using dashes
    between the year, month, and day) for the date. For example, if you wanted to
    retrieve the best-selling books as of the start of March 20, 2017, you’d want
    to use a URL of `[https://manning.com/webservices/bestsellers?date=2017-03-20](https://manning.com/webservices/bestsellers?date=2017-03-20)`.
    To construct that URL in code in an application that allows the user to pick a
    specific date, you might write something like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在使用一个 Web 服务从出版社获取畅销书列表。该 Web 服务可能使用 [https://manning.com/webservices/bestsellers](https://manning.com/webservices/bestsellers)
    这样的 URL，但允许一个名为 `date` 的查询参数，以便你可以找到特定日期上的畅销书。[^([1](kindle_split_025_split_000.html#ch09fn1))]
    我预计该查询参数将使用 ISO-8601 格式（年份首先，年份、月份和日期之间使用连字符）来表示日期。例如，如果你想检索 2017 年 3 月 20 日开始的销售量最高的书籍，你将想要使用
    [https://manning.com/webservices/bestsellers?date=2017-03-20](https://manning.com/webservices/bestsellers?date=2017-03-20)
    这样的 URL。在允许用户选择特定日期的应用程序中构建该 URL 的代码可能如下所示：
- en: ¹
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a fictional web service, as far as I’m aware.
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据我所知，这是一个虚构的 Web 服务。
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Most of the time, you shouldn’t be directly formatting data for machine-to-machine
    communication yourself, mind you. I advise you to avoid string conversions wherever
    you can; they’re often a code smell showing that either you’re not using a library
    or framework properly or that you have data design issues (such as storing dates
    in a database as text instead of as a native date/time type). Having said that,
    you may well find yourself building strings manually like this more often than
    you’d like; just pay attention to which culture you should be using.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大多数时候，你不应该直接为机器到机器通信格式化数据。我建议你在可能的情况下避免字符串转换；它们通常是一个代码异味，表明你可能没有正确使用库或框架，或者你有数据设计问题（例如，在数据库中将日期存储为文本而不是作为原生日期/时间类型）。话虽如此，你可能会发现自己比预期的更频繁地手动构建字符串；只需注意你应该使用哪种文化即可。
- en: Okay, that was a long introduction. But with all this formatting information
    buzzing around your brain and somewhat ugly examples niggling at you, you’re in
    the right frame of mind to welcome interpolated string literals in C# 6\. All
    those calls to `string.Format` look unnecessarily long-winded, and it’s annoying
    having to look between the format string and the argument list to see what will
    go where. Surely, we can make our code clearer than that.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是一个很长的介绍。但是，当所有这些格式化信息在你的脑海中嗡嗡作响，以及一些有些丑陋的例子在你心中萦绕时，你正处于欢迎 C# 6 中的插值字符串字面量的正确心态。所有那些调用
    `string.Format` 的代码看起来都过于冗长，而且不得不在格式字符串和参数列表之间来回查找，以确定内容将如何放置，这真的很烦人。当然，我们可以使我们的代码比这更清晰。
- en: 9.2\. Introducing interpolated string literals
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. 插值字符串字面量的介绍
- en: Interpolated string literals in C# 6 allow you to perform all this formatting
    in a much simpler way. The concepts of a format string and arguments still apply,
    but with interpolated string literals, you specify the values and their formatting
    information inline, which leads to code that’s much easier to read. If you look
    through your code and find a lot of calls to `string.Format` using hardcoded format
    strings, you’ll love interpolated string literals.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6 中的插值字符串字面量允许你以更简单的方式执行所有这些格式化操作。格式字符串和参数的概念仍然适用，但使用插值字符串字面量时，你可以在行内指定值及其格式化信息，这使得代码更容易阅读。如果你查看你的代码并发现很多使用硬编码格式字符串调用
    `string.Format` 的情况，你一定会喜欢插值字符串字面量。
- en: String interpolation isn’t a new idea. It’s been in many programming languages
    for a long time, but I’ve never felt it to be as neatly integrated as it is in
    C#. That’s particularly remarkable when you consider that adding a feature into
    a language when it’s already mature is harder than building it into the first
    version.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串插值并不是一个新概念。它已经在许多编程语言中存在很长时间了，但我从未觉得它在 C# 中如此整洁地集成。当你考虑到在语言已经成熟的情况下添加一个功能比将其构建到第一版中更难时，这一点尤其引人注目。
- en: In this section, you’ll look at some simple examples before exploring interpolated
    verbatim string literals. You’ll learn how localization can be applied using `FormattableString`
    and then take a closer look at how the compiler handles interpolated string literals.
    We’ll round off the section with discussion about where this feature is most useful
    as well as its limitations.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将先查看一些简单的示例，然后再探索插值文本字面量。你将学习如何使用`FormattableString`应用本地化，然后更详细地了解编译器如何处理插值字符串字面量。我们将通过讨论这个特性最有用的地方以及其局限性来结束本节。
- en: 9.2.1\. Simple interpolation
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. 简单插值
- en: The simplest way to demonstrate interpolated string literals in C# 6 is to show
    you the equivalent to the earlier example in which we asked for the user’s name.
    The code doesn’t look hugely different; in particular, only the last line has
    changed at all.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 6中演示插值字符串字面量的最简单方法就是展示我们之前要求用户姓名的早期示例的等效代码。代码看起来并没有太大不同；特别是，只有最后一行有所改变。
- en: '| C# 5—old-style style formatting | C# 6—interpolated string literal |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| C# 5—旧式格式化 | C# 6—插值字符串字面量 |'
- en: '| --- | --- |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE38]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The interpolated string literal is shown in bold. It starts with a `$` before
    the opening double quote; that’s what makes it an interpolated string literal
    rather than a regular one, as far as the compiler is concerned. It contains `{name}`
    instead of `{0}` for the format item. The text in the braces is an expression
    that’s evaluated and then formatted within the string. Because you’ve provided
    all the information you need, the second argument to `WriteLine` isn’t required
    anymore.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 插值字符串字面量以粗体显示。它在开双引号之前有一个`$`，这就是它成为插值字符串字面量而不是普通字符串的原因，至少对编译器来说是这样。它使用`{name}`而不是`{0}`作为格式项。花括号中的文本是一个表达式，它在字符串内被评估并格式化。因为你已经提供了所有需要的信息，所以不再需要`WriteLine`的第二个参数。
- en: '|  |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I’ve lied a little here, for the sake of simplicity. This code doesn’t work
    quite the same way as the original code. The original code passed all the arguments
    to the appropriate `Console.WriteLine` overload, which performed the formatting
    for you. Now, all the formatting is performed with a `string.Format` call, and
    then the `Console.WriteLine` call uses the overload, which has just a string parameter.
    The result will be the same, though.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里稍微撒了个谎，为了简化。这段代码并不完全以原始代码的方式工作。原始代码将所有参数传递给适当的`Console.WriteLine`重载，该重载为你执行了格式化。现在，所有格式化操作都通过`string.Format`调用完成，然后`Console.WriteLine`调用使用仅有一个字符串参数的重载。结果将会相同。
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Just as with expression-bodied members, this doesn’t look like a huge improvement.
    For a single format item, the original code doesn’t have a lot to be confused
    by. The first couple of times you see this, it might even take you a little longer
    to read an interpolated string literal than a string formatting call. I was skeptical
    about just how much I’d ever like them, but now I often find myself converting
    pieces of old code to use them almost automatically, and I find the readability
    improvement is often significant.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 就像表达式成员一样，这看起来并没有太大的改进。对于单个格式项，原始代码并没有太多可以混淆的地方。第一次看到这个时，阅读插值字符串字面量可能甚至比阅读字符串格式化调用要花更长的时间。我对于自己到底有多喜欢它们持怀疑态度，但现在我经常发现自己几乎自动地将旧代码的部分转换为使用它们，我发现可读性的提升通常是显著的。
- en: Now that you’ve seen the simplest example, let’s do something a bit more complex.
    You’ll follow the same sequence as before, first looking at controlling the formatting
    of values more carefully and then considering localization.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了最简单的示例，让我们来做一些更复杂的事情。你将遵循之前的顺序，首先仔细查看控制值格式的操作，然后考虑本地化。
- en: 9.2.2\. Format strings in interpolated string literals
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 插值字符串字面量中的格式化字符串
- en: 'Good news! There’s nothing new to learn here. If you want to provide an alignment
    or a format string with an interpolated string literal, you do it the same way
    you would in a normal composite format string: you add a comma before the alignment
    and a colon before the format string. Our earlier composite formatting example
    changes in the obvious way, as shown in the following listing.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！这里没有新的内容需要学习。如果你想要提供一个带有插值字符串字面量的对齐或格式化字符串，你将按照在正常复合格式化字符串中的方式操作：在对齐之前添加一个逗号，在格式化字符串之前添加一个冒号。我们之前复合格式化的示例以明显的方式进行了更改，如下面的列表所示。
- en: Listing 9.3\. Aligned values using interpolated string literals
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 使用插值字符串字面量对齐的值
- en: '[PRE39]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* 20% tip**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 20%的小费**'
- en: '***2* Right-justify prices using nine-digit alignment**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用九位对齐右对齐价格**'
- en: Note that in the last line, the interpolated string doesn’t just contain a simple
    variable for the argument; it performs the addition of the tip to the price. The
    expression can be any expression that computes a value. (You can’t just call a
    method with a `void` return type, for example.) If the value implements the `IFormattable`
    interface, its `ToString(string, IFormatProvider)` method will be called; otherwise,
    `System.Object.ToString()` is used.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在最后一行，插值字符串不仅仅包含一个简单的变量作为参数；它执行了小费与价格的加法。表达式可以是任何计算值的表达式。（例如，你不能只是调用一个返回`void`类型的方法。）如果值实现了`IFormattable`接口，它的`ToString(string,
    IFormatProvider)`方法将被调用；否则，使用`System.Object.ToString()`。
- en: 9.2.3\. Interpolated verbatim string literals
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3\. 插值实际字符串字面量
- en: 'You’ve no doubt seen *verbatim string literals* before; they start with `@`
    before the double quote. Within a verbatim string literal, backslashes and line
    breaks are included in the string. For example, in the verbatim string literal
    `@"c:\Windows"`, the backslash really is a backslash; it isn’t the start of an
    escape sequence. The only kind of escape sequence within a verbatim string literal
    is when you have two double quote characters together, which results in one double
    quote character in the resulting string. Verbatim string literals are typically
    used for the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定之前见过**实际字符串字面量**；它们在双引号前以`@`开头。在实际字符串字面量中，反斜杠和换行符包含在字符串中。例如，在实际字符串字面量`@"c:\Windows"`中，反斜杠确实是一个反斜杠；它不是转义序列的开始。实际字符串字面量中唯一的转义序列是在你有两个双引号字符一起时，这会在结果字符串中产生一个双引号字符。实际字符串字面量通常用于以下情况：
- en: Strings breaking over multiple lines
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨多行的字符串
- en: Regular expressions (which use backslashes for escaping, quite separate from
    the escaping the C# compiler uses in regular string literals)
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式（使用反斜杠进行转义，与C#编译器在常规字符串字面量中使用的转义完全不同）
- en: Hardcoded Windows filenames
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定硬编码的Windows文件名
- en: '|  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: With multiline strings, you should be careful about exactly which characters
    end up in your string. Although the difference between “carriage-return” and “carriage-return
    line-feed separators” is irrelevant in most code, it’s significant in verbatim
    string literals.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在多行字符串中，你应该注意哪些字符最终出现在你的字符串中。尽管在大多数代码中，“回车”和“回车换行分隔符”之间的区别无关紧要，但在实际字符串字面量中却很重要。
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The following shows a quick example of each of these:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了这些功能的快速示例：
- en: '[PRE40]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* SQL is easier to read when split over multiple lines.**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当SQL语句跨多行时更容易阅读。**'
- en: '***2* Backslashes are common in regular expressions.**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 反斜杠在正则表达式中很常见。**'
- en: '***3* Windows filename**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Windows文件名**'
- en: Verbatim string literals can be interpolated as well; you put a `$` in front
    of the `@`, just as you would to interpolate a regular string literal. Our earlier
    multiline output could be written using a single interpolated verbatim string
    literal, as shown in the following listing.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 实际字符串字面量也可以进行插值；你只需在`@`前加上一个`$`，就像插值常规字符串字面量一样。我们之前的多行输出可以使用单个插值实际字符串字面量来编写，如下所示。
- en: Listing 9.4\. Aligned values using a single interpolated verbatim string literal
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. 使用单个插值实际字符串字面量对齐值
- en: '[PRE41]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* 20% tip**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 20%的小费**'
- en: I probably *wouldn’t* do this; it’s just not as clean as using three separate
    statements. I’m using the preceding code only as a simple example of what’s possible.
    Consider it for places where you’re already using verbatim string literals sensibly.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能**不会**这样做；这并不像使用三个单独的语句那样干净。我使用前面的代码仅作为一个简单示例，说明可能实现的功能。考虑在已经合理使用实际字符串字面量的地方使用它。
- en: '|  |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The order of the symbols matters. `$@"Text"` is a valid interpolated verbatim
    string literal, but `@$"Text"` isn’t. I admit I haven’t found a good mnemonic
    device to remember this. Just try whichever way you think is right, and change
    it if the compiler complains!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的顺序很重要。`$@"Text"`是一个有效的插值实际字符串字面量，但`@$"Text"`不是。我承认我还没有找到一个好的记忆技巧来记住这个。只需尝试你认为正确的方式，如果编译器有抱怨就改变它！
- en: '|  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is all very convenient, but I’ve shown only the surface level of what’s
    going on. I’ll assume you bought this book because you want to know about the
    features inside and out.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，但我只展示了表面现象。我假设你买这本书是因为你想了解其内部和外部功能。
- en: 9.2.4\. Compiler handling of interpolated string literals (part 1)
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4\. 编译器对插值字符串字面量的处理（第一部分）
- en: The compiler transformation here is simple. It converts the interpolated string
    literal into a call to `string.Format`, and it extracts the expressions from the
    format items and passes them as arguments after the composite format string. The
    expression is replaced with the appropriate index, so the first format item becomes
    `{0}`, the second becomes `{1}`, and so on.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的编译器转换很简单。它将插值字符串字面量转换为对 `string.Format` 的调用，并从格式项中提取表达式，在复合格式字符串之后将它们作为参数传递。表达式被替换为适当的索引，因此第一个格式项变为
    `{0}`，第二个变为 `{1}`，依此类推。
- en: 'To make this clearer, let’s consider a trivial example, this time separating
    the formatting from the output for clarity:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这一点更清晰，让我们考虑一个简单的例子，这次将格式化与输出分开，以便于理解：
- en: '[PRE42]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is handled by the compiler as if you’d written the following code instead:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会像你写了以下代码一样处理这个问题：
- en: '[PRE43]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The transformation is that simple. If you want to go deeper and verify it for
    yourself, you could use a tool such as ildasm to look at the IL that the compiler
    has generated.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 转换就这么简单。如果你想深入了解并自己验证，可以使用像 ildasm 这样的工具来查看编译器生成的 IL。
- en: One side effect of this transformation is that unlike regular or verbatim string
    literals, interpolated string literals don’t count as constant expressions. Although
    in some cases the compiler could reasonably consider them to be constant (if they
    don’t have any format items or if all the format items are just string constants
    without any alignment or format strings), these would be corner cases that would
    complicate the language for little benefit.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换的一个副作用是，与常规或字面量字符串字面量不同，插值字符串字面量不作为常量表达式。尽管在某些情况下编译器可以合理地认为它们是常量（如果它们没有格式项，或者所有格式项只是没有对齐或格式字符串的字符串常量），但这些将是边缘情况，会为语言增加复杂性而带来很少的好处。
- en: So far, all our interpolated strings have resulted in a call to `string.Format`.
    That doesn’t always happen, though, and for good reasons, as you’ll see in the
    next section.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的插值字符串都导致了对 `string.Format` 的调用。但这并不总是发生，而且有很好的理由，你将在下一节中看到。
- en: 9.3\. Localization using FormattableString
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 使用 FormattableString 进行本地化
- en: In [section 9.1.3](kindle_split_025_split_000.html#ch09lev2sec3), I demonstrated
    how string formatting can take advantage of different format providers—typically
    using `CultureInfo`—to perform localization. All the interpolated string literals
    you’ve seen so far would’ve been evaluated using the default culture for the executing
    thread, so our price examples in 9.1.2 and 9.2.2 could easily have different output
    on your machine than the result I showed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9.1.3 节](kindle_split_025_split_000.html#ch09lev2sec3) 中，我演示了字符串格式化如何利用不同的格式提供者（通常使用
    `CultureInfo`）来执行本地化。你之前看到的所有插值字符串都会使用执行线程的默认文化进行评估，所以 9.1.2 和 9.2.2 中的价格示例在你的机器上的输出可能与我展示的结果不同。
- en: 'To perform formatting in a specific culture, you need three pieces of information:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 要在特定文化中进行格式化，你需要三个信息：
- en: The composite format string, which includes the hardcoded text and the format
    items as placeholders for the real values
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合格式字符串，它包括硬编码的文本和作为真实值占位符的格式项
- en: The values themselves
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些值本身
- en: The culture you want to format the string in
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想要格式化字符串的文化
- en: 'You can slightly rewrite our first example of formatting in a culture to store
    each of these in a separate variable, and then call `string.Format` at the end:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以稍微修改我们的第一个格式化示例，在一个文化中存储这些值，然后在最后调用 `string.Format`：
- en: '[PRE44]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How can you do this with interpolated string literals? An interpolated string
    literal contains the first two pieces of information (the composite format string
    and the values to format), but there’s nowhere to put the culture. That would
    be fine if you could get at the individual pieces of information afterward, but
    every use of interpolated string literals that you’ve seen so far has performed
    the string formatting as well, leaving you with just a single string as the result.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何使用插值字符串字面量来做这件事？插值字符串字面量包含前两个信息（复合格式字符串和要格式化的值），但没有地方可以放置文化。如果你之后可以获取这些单独的信息，那将是好的，但到目前为止你看到的每个插值字符串的使用都执行了字符串格式化，只留下一个字符串作为结果。
- en: 'That’s where `FormattableString` comes in. This is a class in the `System`
    namespace introduced in .NET 4.6 (and .NET Standard 1.3 in the .NET Core world).
    It holds the composite format string and the values so they can be formatted in
    whatever culture you want later. The compiler is aware of `FormattableString`
    and can convert an interpolated string literal into a `FormattableString` instead
    of a string where necessary. That allows you to rewrite our simple date-of-birth
    example as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 `FormattableString` 的作用。这是一个在 .NET 4.6（以及在 .NET Core 世界中的 .NET Standard
    1.3）中引入的 `System` 命名空间中的类。它持有复合格式字符串和值，以便可以在你想要的任何文化中稍后进行格式化。编译器知道 `FormattableString`，可以在必要时将其转换为
    `FormattableString` 而不是字符串。这允许你将我们的简单出生日期示例重写如下：
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Keeps the composite format string and value in a FormattableString**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 将复合格式字符串和值保存在 FormattableString 中**'
- en: '***2* Formats in the specified culture**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 指定文化中的格式**'
- en: Now that you know the basic reason for the existence of `FormattableString`,
    you can look at how the compiler uses it and then examine localization in more
    detail. Although localization is certainly the primary motivation for `FormattableString`,
    it can be used in other situations as well, which you’ll look at in [section 9.3.3](kindle_split_025_split_000.html#ch09lev2sec10).
    The section then concludes with your options if your code is targeting an earlier
    version of .NET.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了 `FormattableString` 存在的基本原因，你可以看看编译器是如何使用它的，然后更详细地检查本地化。尽管本地化无疑是 `FormattableString`
    的主要动机，但它也可以在其他情况下使用，你将在 [第 9.3.3 节](kindle_split_025_split_000.html#ch09lev2sec10)
    中看到。该节随后总结了如果你的代码针对的是 .NET 的早期版本，你的选项。
- en: 9.3.1\. Compiler handling of interpolated string literals (part 2)
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. 编译器处理插值字符串字面量（第二部分）
- en: In a reversal of my earlier approach, this time it makes sense to talk about
    how the compiler considers `FormattableString` before moving on to examining its
    uses in detail. The compile-time type of an interpolated string literal is `string`.
    There’s no conversion from `string` to `FormattableString` or to `IFormattable`
    (which `FormattableString` implements), but there are conversions from interpolated
    string literal expressions to both `FormattableString` and `IFormattable`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在反转我之前的方法后，这次有道理谈谈编译器在详细检查其用法之前是如何考虑 `FormattableString` 的。插值字符串字面量的编译时类型是 `string`。没有从
    `string` 转换到 `FormattableString` 或到 `IFormattable`（`FormattableString` 实现的接口），但是有从插值字符串字面量表达式到
    `FormattableString` 和 `IFormattable` 的转换。
- en: The differences between conversions from an expression to a type and conversions
    from a type to another type are somewhat subtle, but this is nothing new. For
    example, consider the integer literal `5`. Its type is `int`, so if you declare
    `var x = 5`, the type of `x` will be `int`, but you can also use it to initialize
    a variable of type `byte`. For example, `byte y = 5;` is perfectly valid. That’s
    because the language specifies that for constant integer expressions (including
    integer literals) within the range of `byte`, there’s an implicit conversion from
    the expression to `byte`. If you can get your head around that, you can apply
    the exact same idea to verbatim string literals.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 从表达式到类型的转换和从类型到其他类型的转换之间的区别有些微妙，但这并不是什么新鲜事。例如，考虑整数字面量 `5`。它的类型是 `int`，所以如果你声明
    `var x = 5`，`x` 的类型将是 `int`，但你也可以用它来初始化一个 `byte` 类型的变量。例如，`byte y = 5;` 是完全有效的。这是因为语言指定，对于范围在
    `byte` 内的常量整数表达式（包括整数字面量），存在从表达式到 `byte` 的隐式转换。如果你能理解这一点，你就可以将完全相同的思想应用到字面量字符串。
- en: 'When the compiler needs to convert an interpolated string literal into a `FormattableString`,
    it performs most of the same steps as for a conversion to `string`. But instead
    of `string.Format`, it calls the static `Create` method on the `System.Runtime.CompilerServices.FormattableStringFactory`
    class. This is another type introduced at the same time as `FormattableString`.
    To go back to an earlier example, say you have this source code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器需要将插值字符串字面量转换为 `FormattableString` 时，它执行与转换为 `string` 时的大部分相同步骤。但是，它调用的是
    `System.Runtime.CompilerServices.FormattableStringFactory` 类的静态 `Create` 方法，而不是
    `string.Format`。这是与 `FormattableString` 同时引入的另一种类型。回到之前的例子，假设你有以下源代码：
- en: '[PRE46]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That’s handled by the compiler as if you’d written the following code instead
    (with the appropriate namespaces, of course):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这将由编译器处理，就像你写了以下代码一样（当然，带有适当的命名空间）：
- en: '[PRE47]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`FormattableString` is an abstract class with members as shown in the following
    listing.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormattableString` 是一个抽象类，其成员如下所示。'
- en: Listing 9.5\. Members declared by `FormattableString`
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 由 `FormattableString` 声明的成员
- en: '[PRE48]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that you know when and how `FormattableString` instances are built, let’s
    see what you can do with them.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了何时以及如何构建 `FormattableString` 实例，让我们看看你可以用它们做什么。
- en: 9.3.2\. Formatting a FormattableString in a specific culture
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 在特定文化中格式化 FormattableString
- en: 'By far, the most common use for `FormattableString` will be to perform the
    formatting in an explicitly specified culture instead of in the default culture
    for the thread. I expect that most uses will be for a single culture: the invariant
    culture. This is so common that it has its own static method: `Invariant`. Calling
    this is equivalent to passing `CultureInfo.InvariantCulture` into the `ToString(IFormatProvider)`
    method, which behaves exactly as you’d expect. But making `Invariant` a static
    method means it’s simpler to call as a subtle corollary of the language details
    you just looked at in [section 9.3.1](kindle_split_025_split_000.html#ch09lev2sec8).
    The fact that it takes `FormattableString` as a parameter means you can just use
    an interpolated string literal as an argument, and the compiler knows that it
    has to apply the relevant conversion; there’s no need for a cast or a separate
    variable.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`FormattableString` 的最常见用途将是显式地在指定文化中进行格式化，而不是在线程的默认文化中进行格式化。我预计大多数用途将针对单一文化：不变文化。这如此常见，以至于它有自己的静态方法：`Invariant`。调用此方法相当于将
    `CultureInfo.InvariantCulture` 传递给 `ToString(IFormatProvider)` 方法，它的工作方式与你预期的完全一样。但将
    `Invariant` 作为静态方法意味着它比作为你刚刚在 [9.3.1 节](kindle_split_025_split_000.html#ch09lev2sec8)
    中查看的语言细节的微妙推论更容易调用。它接受 `FormattableString` 作为参数的事实意味着你可以直接使用插值字符串字面量作为参数，编译器知道它必须应用相关的转换；不需要进行转换或使用单独的变量。
- en: Let’s consider a concrete example to make it clear. Suppose you have a `DateTime`
    value and you want to format just the date part of it in ISO-8601 format as part
    of a URL query parameter for machine-to-machine communication. You want to use
    the invariant culture to avoid any unexpected results from using the default culture.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个具体的例子来说明这一点。假设你有一个 `DateTime` 值，并且你只想将其日期部分格式化为 ISO-8601 格式，作为机器到机器通信的
    URL 查询参数的一部分。你希望使用不变文化来避免使用默认文化可能产生意外结果。
- en: '|  |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Even when you specify a custom format string for a date and time, and even when
    that custom format uses only digits, the culture still has an impact. The biggest
    one is that the value is represented in the default calendar system for the culture.
    If you format October 21, 2016 (Gregorian) in the culture `ar-SA` (Arabic in Saudi
    Arabia), you’ll get a result with a year of 1438.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你为日期和时间指定了自定义的格式字符串，即使该自定义格式仅使用数字，文化仍然会有影响。其中最大的影响是，该值以文化默认的日历系统表示。如果你在 `ar-SA`（沙特阿拉伯的阿拉伯语）文化中格式化
    2016 年 10 月 21 日（格里高利历），你会得到一个年份为 1438 的结果。
- en: '|  |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can do this formatting in four ways, all of which are shown together in
    the following listing. All four approaches give exactly the same result, but I’ve
    shown all of them to demonstrate how the multiple language features work together
    to give a clean final option.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过四种方式来完成这种格式化，所有这些方式都在下面的列表中一起展示。所有四种方法都给出完全相同的结果，但我展示了所有这些方法来演示多个语言特性如何协同工作以给出一个干净的最终选项。
- en: Listing 9.6\. Formatting a date in the invariant culture
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 在不变文化中格式化日期
- en: '[PRE49]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Old-school formatting with string.Format**'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 传统的 string.Format 格式化**'
- en: '***2* Casting to FormattableString and calling ToString(IFormatProvider)**'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 转换为 FormattableString 并调用 ToString(IFormatProvider)**'
- en: '***3* Regular call to FormattableString.Invariant**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 正常调用 FormattableString.Invariant**'
- en: '***4* Shortened call to FormattableString.Invariant**'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 简化的 FormattableString.Invariant 调用**'
- en: The main interesting difference is between the initializers for `parameter2`
    and `parameter3`. To make sure you have a `FormattableString` for `parameter2`
    rather than just a `string`, you have to cast the interpolated string literal
    to that type. An alternative would’ve been to declare a separate local variable
    of type `FormattableString`, but that would’ve been about as long-winded. Compare
    that with the way `parameter3` is initialized, which uses the `Invariant` method
    that accepts a parameter of type `FormattableString`. That allows the compiler
    to infer that you want to use the implicit conversion from an interpolated string
    literal to `FormattableString`, because that’s the only way that the call will
    be valid.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有趣的不同之处在于`parameter2`和`parameter3`的初始化器。为了确保你有一个`FormattableString`用于`parameter2`而不是仅仅是一个`string`，你必须将插值字符串字面量强制转换为该类型。另一种选择是声明一个单独的局部变量，其类型为`FormattableString`，但这将会很冗长。将其与`parameter3`的初始化方式进行比较，它使用接受`FormattableString`类型参数的`Invariant`方法。这允许编译器推断你想要使用从插值字符串字面量到`FormattableString`的隐式转换，因为这是调用有效的唯一方式。
- en: I’ve cheated for `parameter4`. I’ve used a feature you haven’t seen yet, making
    static methods from a type available with a `using static` directive. You can
    flick forward to the details later ([section 10.1.1](kindle_split_026_split_000.html#ch10lev2sec1))
    or trust me for now that it works. You just need `using static System.FormattableString`
    in your list of `using` directives.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`parameter4`上作弊了。我使用了一个你还没有见过的特性，即使用`using static`指令从类型中创建静态方法。你可以稍后查看详细信息（[第10.1.1节](kindle_split_026_split_000.html#ch10lev2sec1)）或者现在就相信它是有效的。你只需要在你的`using`指令列表中包含`using
    static System.FormattableString`。
- en: Formatting in a noninvariant culture
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 非不变文化的格式化
- en: 'If you want to format a `FormattableString` in any culture other than the invariant
    one, you need to use one of the `ToString` methods. In most cases, you’ll want
    to call the `ToString(IFormatProvider)` overload directly. As a slightly shorter
    example than you saw earlier, here’s code to format the current date and time
    in US English using the “general date/time with short time” standard format string
    (`"g"`):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在除了不变文化之外的任何文化中格式化`FormattableString`，你需要使用其中一个`ToString`方法。在大多数情况下，你将直接调用`ToString(IFormatProvider)`重载。作为一个比之前看到的例子略短的例子，以下是如何使用“一般日期/时间带短时间”标准格式字符串（`"g"`）来格式化当前日期和时间的US
    English代码：
- en: '[PRE50]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Occasionally, you may want to pass the `FormattableString` to another piece
    of code to perform the final formatting step. In that case, it’s worth remembering
    that `FormattableString` implements the `IFormattable` interface, so any method
    accepting an `IFormattable` will accept a `FormattableString`. The `FormattableString`
    implementation of `IFormattable.ToString(string, IFormatProvider)` ignores the
    string parameter because it already has everything it needs: it uses the `IFormatProvider`
    parameter to call the `ToString(IFormatProvider)` method.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想要将`FormattableString`传递给其他代码以执行最终的格式化步骤。在这种情况下，值得记住的是`FormattableString`实现了`IFormattable`接口，因此任何接受`IFormattable`的方法都将接受`FormattableString`。`FormattableString`对`IFormattable.ToString(string,
    IFormatProvider)`的实现忽略了字符串参数，因为它已经拥有所需的一切：它使用`IFormatProvider`参数来调用`ToString(IFormatProvider)`方法。
- en: Now that you know how to use cultures with interpolated string literals, you
    may be wondering why the other members of `FormattableString` exist. In the next
    section, you’ll look at one example.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用带有插值字符串字面量的文化，你可能想知道`FormattableString`的其他成员为什么存在。在下一节中，你将看到一个示例。
- en: 9.3.3\. Other uses for FormattableString
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3\. `FormattableString`的其他用途
- en: I’m not expecting `FormattableString` to be widely used outside the culture
    scenario I showed in [section 9.3.2](kindle_split_025_split_000.html#ch09lev2sec9),
    but it’s worth considering what *can* be done. I’ve chosen this example as one
    that’s immediately recognizable and elegant in its own way, but I wouldn’t go
    so far as to recommend its use. Aside from the code presented here lacking validation
    and some features, it may give the wrong impression to a casual reader (and to
    static code analysis tools). By all means, pursue it as an idea, but use appropriate
    caution.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不期望`FormattableString`在[第9.3.2节](kindle_split_025_split_000.html#ch09lev2sec9)中展示的文化场景之外被广泛使用，但考虑一下*可以*做什么是有价值的。我选择这个例子，因为它立即可识别，并且以它自己的方式优雅。但我不会那么推荐它的使用。除了这里展示的代码缺少验证和一些功能外，它可能给一个随意读者（以及静态代码分析工具）留下错误的印象。无论如何，你可以将其作为一个想法来追求，但请使用适当的谨慎。
- en: Most developers are aware of SQL injection attacks as a security vulnerability,
    and many know the common solution in the format of parameterized SQL. [Listing
    9.7](kindle_split_025_split_000.html#ch09ex07) shows what you don’t want to do.
    If a user enters a value containing an apostrophe, they have huge amounts of power
    over your database. Imagine that you have a database with entries of some kind
    that a user can add a tag to partitioned by user identifier. You’re trying to
    list all the descriptions for a user-specified tag restricted to that user.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员都知道 SQL 注入攻击作为一种安全漏洞，许多人知道参数化 SQL 的常见解决方案。[列表 9.7](kindle_split_025_split_000.html#ch09ex07)
    展示了您不想做的事情。如果用户输入包含撇号的值，他们将拥有对您的数据库的大量控制权。想象一下，您有一个数据库，其中包含用户可以添加标签以按用户标识分区的一些条目。您试图列出针对用户指定的标签的所有描述，并限制在该用户范围内。
- en: Listing 9.7\. Awooga! Awooga! Do not use this code!
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. Awooga! Awooga! 不要使用此代码！
- en: '[PRE51]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Reads arbitrary data from the user**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从用户读取任意数据**'
- en: '***2* Builds SQL dynamically including user input**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 动态构建包含用户输入的 SQL**'
- en: '***3* Executes the untrustworthy SQL**'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 执行不可信的 SQL**'
- en: '***4* Uses the results**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用结果**'
- en: Most SQL injection vulnerabilities I’ve seen in C# use string concatenation
    rather than string formatting, but it’s the same deal. It mixes code (SQL) and
    data (the value the user entered) in an alarming way.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 C# 中看到的绝大多数 SQL 注入漏洞都使用字符串连接而不是字符串格式化，但情况是一样的。它以令人不安的方式混合了代码（SQL）和数据（用户输入的值）。
- en: I’m going to assume that you know how you’d have fixed this problem in the past
    using parameterized SQL and calling `command.Parameters.Add(...)` appropriately.
    Code and data are suitably separated, and life is good again. Unfortunately, that
    safe code doesn’t look as appealing as the code in [listing 9.7](kindle_split_025_split_000.html#ch09ex07).
    What if you could have it both ways? What if you could write SQL that made it
    obvious what you were trying to do but was still safely parameterized? With `FormattableString`,
    you can do exactly that.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我将假设您知道如何使用参数化 SQL 并适当地调用 `command.Parameters.Add(...)` 来修复这个问题。代码和数据得到了适当的分离，生活再次变得美好。不幸的是，这段安全代码看起来并不像
    [列表 9.7](kindle_split_025_split_000.html#ch09ex07) 中的代码那样吸引人。如果可以两者兼得会怎样？如果可以编写既明显表示您要做什么又安全参数化的
    SQL 会怎样？使用 `FormattableString`，您就可以做到这一点。
- en: You’ll work backward, from our desired user code, through the implementation
    that enables it. The following listing shows the soon-to-be-safe equivalent of
    [listing 9.7](kindle_split_025_split_000.html#ch09ex07).
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 您将逆向工作，从我们期望的用户代码开始，通过实现它来启用它。以下列表显示了即将到来的安全等效于 [列表 9.7](kindle_split_025_split_000.html#ch09ex07)。
- en: Listing 9.8\. Safe SQL parameterization using `FormattableString`
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8\. 使用 `FormattableString` 进行安全的 SQL 参数化
- en: '[PRE52]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Reads arbitrary data from the user**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从用户读取任意数据**'
- en: '***2* Builds a SQL command from the interpolated string literal**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从插值字符串字面量构建 SQL 命令**'
- en: '***3* Executes the QL safely**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 安全执行 QL**'
- en: '***4* Uses the results**'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用结果**'
- en: Most of this listing is identical to [listing 9.7](kindle_split_025_split_000.html#ch09ex07).
    The only difference is in how you construct the `SqlCommand`. Instead of using
    an interpolated string literal to format the values into SQL and then passing
    that string into the `SqlCommand` constructor, you’re using a new method called
    `NewSqlCommand`, which is an extension method you’ll write soon. Predictably,
    the second parameter of that method isn’t `string` but `FormattableString`. The
    interpolated string literal no longer has apostrophes around `{tag}`, and you’ve
    specified each parameter’s database type as a format string. That’s certainly
    unusual. What is it doing?
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的大部分与 [列表 9.7](kindle_split_025_split_000.html#ch09ex07) 相同。唯一的区别在于您构建 `SqlCommand`
    的方式。您不是使用插值字符串字面量将值格式化为 SQL 并将其传递给 `SqlCommand` 构造函数，而是使用一个名为 `NewSqlCommand`
    的新方法，这是一个您将很快编写的扩展方法。可预测的是，该方法的第二个参数不是 `string`，而是 `FormattableString`。插值字符串字面量不再围绕
    `{tag}` 有撇号，并且您已指定每个参数的数据库类型作为格式字符串。这确实很不同。它在做什么？
- en: 'First, let’s think about what the compiler is doing for you. It’s splitting
    the interpolated string literal into two parts: a composite format string and
    the arguments for the format items. The composite format string the compiler creates
    will look like this:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下编译器为您做了什么。它将插值字符串字面量分成两部分：一个复合格式字符串和格式项的参数。编译器创建的复合格式字符串看起来会是这样：
- en: '[PRE53]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You want SQL that ends up looking like this instead:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望 SQL 看起来像这样：
- en: '[PRE54]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That’s easy enough to do; you just need to format the composite format string,
    passing in arguments that will evaluate to `"@p0"` and `"@p1"`. If the type of
    those arguments implements `IFormattable`, calling `string.Format` will pass the
    `NVarChar` and `Int` format strings as well, so you can set the types of the `SqlParameter`
    objects appropriately. You can autogenerate the names, and the values come directly
    from the `FormattableString`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易做到；你只需要格式化复合格式字符串，传入将评估为`"@p0"`和`"@p1"`的参数。如果这些参数的类型实现了`IFormattable`，调用`string.Format`将传递`NVarChar`和`Int`格式字符串，因此你可以适当地设置`SqlParameter`对象的类型。你可以自动生成名称，值直接来自`FormattableString`。
- en: It’s highly unusual to make an `IFormattable.ToString` implementation have side
    effects, but you’re using only this format-capturing type for this single call,
    and you can keep it safely hidden from any other code. The following listing is
    a complete implementation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFormattable.ToString`实现产生副作用是非常不寻常的，但你只在这个单一调用中使用这种格式捕获类型，并且你可以安全地将它隐藏在其他代码之外。以下是一个完整的实现。'
- en: Listing 9.9\. Implementing safe SQL formatting
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.9\. 实现安全的SQL格式化
- en: '[PRE55]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The only public part of this is the `SqlFormattableString` static class with
    its `NewSqlCommand` method. Everything else is a hidden implementation detail.
    For each placeholder in the format string, you create a `SqlParameter` and a corresponding
    `FormatCapturingParameter`. The latter is used to format the parameter name in
    the SQL as `@p0`, `@p1,` and so on, and the value provided to the ToString method
    is set into the `SqlParameter`. The type of the parameter is also set if the user
    specifies it in the format string.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的公开部分只有`SqlFormattableString`静态类及其`NewSqlCommand`方法。其他一切都是隐藏的实现细节。对于格式字符串中的每个占位符，你创建一个`SqlParameter`和一个相应的`FormatCapturingParameter`。后者用于将参数名称格式化为SQL中的`@p0`、`@p1`等，并将提供给`ToString`方法的价值设置到`SqlParameter`中。如果用户在格式字符串中指定了参数类型，也会设置参数类型。
- en: At this point, you need to make up your own mind as to whether this is something
    you’d like to see in your production codebase. I’d want to implement extra features
    (such as including the size in the format string; you can’t use the alignment
    part of a format item, because `string.Format` handles that itself), but it can
    certainly be productionized appropriately. But is it just too clever? Are you
    going to have to walk every new developer on the project through this, saying,
    “Yes, I know it looks like we have a massive SQL injection vulnerability, but
    it’s okay, really”?
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，你需要自己决定是否想在你的生产代码库中看到这样的功能。我想要实现额外的功能（例如，在格式字符串中包含大小；你不能使用格式项的对齐部分，因为`string.Format`会自己处理），但这当然可以适当地在生产环境中实现。但是，这会不会太过聪明？你难道要带着每个新加入项目的开发者走过这一过程，说，“是的，我知道这看起来我们有一个巨大的SQL注入漏洞，但真的没关系”？
- en: Regardless of this specific example, you may well be able to find similar situations
    for which you can use the compiler’s extraction of the data and separation from
    the text of an interpolated string literal. Always think carefully about whether
    a solution like this is really providing a benefit or whether it’s just giving
    you a chance to feel smart.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这个具体的例子如何，你很可能都能找到类似的情况，你可以使用编译器从插值字符串字面量的文本中提取数据并分离数据。始终仔细思考这种解决方案是否真的提供了好处，或者它只是给你一个感觉聪明的机会。
- en: All of this is useful if you’re targeting .NET 4.6, but what if you’re stuck
    on an older framework version? Just because you’re using a C# 6 compiler doesn’t
    mean you’re necessarily targeting a modern version of the framework. Fortunately,
    the C# compiler doesn’t tie this to a specific framework version; it just needs
    the right types to be available *somehow*.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对于你目标是.NET 4.6的情况都是有用的，但如果你卡在较老的框架版本上怎么办？仅仅因为你使用的是C# 6编译器，并不意味着你一定在针对框架的现代版本。幸运的是，C#编译器并没有将这一点绑定到特定的框架版本；它只需要以某种方式提供正确的类型。
- en: 9.3.4\. Using FormattableString with older versions of .NET
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4\. 使用FormattableString与较老的.NET版本
- en: Just like the attribute for extension methods and caller information attributes,
    the C# compiler doesn’t have a fixed idea of which assembly should contain the
    `FormattableString` and `FormattableStringFactory` types it relies on. The compiler
    cares about the namespaces and expects an appropriate static `Create` method to
    be present on `FormattableStringFactory`, but that’s about it. If you want to
    take advantage of the benefits of `FormattableString` but you’re stuck targeting
    an earlier version of the framework, you can implement both types yourself.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 就像扩展方法和调用者信息属性一样，C#编译器并没有一个固定的想法，即哪个程序集应该包含它所依赖的`FormattableString`和`FormattableStringFactory`类型。编译器关心的是命名空间，并期望在`FormattableStringFactory`上存在适当的静态`Create`方法，但仅此而已。如果你想利用`FormattableString`的好处，但你被困在早期版本的框架中，你可以自己实现这两个类型。
- en: Before I show you the code, I should point out that this should be viewed as
    a last resort. When you eventually upgrade your environment to target .NET 4.6,
    you should remove these types immediately to avoid compiler warnings. Although
    you can get away with having your own implementation even if you end up executing
    in .NET 4.6, I’d try to avoid getting into that situation; in my experience, having
    the same type in different assemblies can lead to issues that are hard to diagnose.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向你展示代码之前，我应该指出，这应该被视为最后的手段。当你最终将你的环境升级到针对 .NET 4.6 的目标时，你应该立即删除这些类型，以避免编译器警告。尽管你可以在
    .NET 4.6 中执行自己的实现，但我尽量避免这种情况；根据我的经验，不同程序集中的相同类型可能会导致难以诊断的问题。
- en: With all the caveats out of the way, the implementation is simple. [Listing
    9.10](kindle_split_025_split_000.html#ch09ex10) shows both types. I haven’t included
    any validation, I’ve made `FormattableString` a concrete type for brevity, and
    I’ve made both classes internal, but the compiler doesn’t mind those changes.
    The reason for making the types internal is to avoid other assemblies taking a
    dependency on your implementation; whether that’s suitable for your precise situation
    is hard to predict, but please consider it carefully before making the types public.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有注意事项都解决之后，实现是简单的。[列表 9.10](kindle_split_025_split_000.html#ch09ex10) 展示了这两种类型。我没有包含任何验证，为了简洁起见，我将`FormattableString`设为具体类型，并且将两个类都设为内部类，但编译器并不介意这些更改。将类型设为内部类的原因是避免其他程序集对你的实现产生依赖；是否适合你的具体情况很难预测，但在将类型公开之前，请仔细考虑。
- en: Listing 9.10\. Implementing `FormattableString` from scratch
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. 从头开始实现`FormattableString`
- en: '[PRE56]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: I won’t explain the details of the code, because each individual member is quite
    simple. The only part that may need a little explanation is in the `Invariant`
    method calling `formattable?.ToString(CultureInfo.InvariantCulture)`. The `?.`
    part of this expression is the *null conditional* operator, which you’ll look
    at in more detail in [section 10.3](kindle_split_026_split_000.html#ch10lev1sec3).
    Now you know everything you can do with interpolated string literals, but what
    about what you should do with them?
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会解释代码的细节，因为每个成员都非常简单。可能需要稍作解释的部分是在`Invariant`方法调用`formattable?.ToString(CultureInfo.InvariantCulture)`。这个表达式中的`?.`部分是*空条件*运算符，你将在[第
    10.3 节](kindle_split_026_split_000.html#ch10lev1sec3)中更详细地了解它。现在你已经知道了你可以用插值字符串字面量做什么，但关于你应该如何使用它们呢？
- en: 9.4\. Uses, guidelines, and limitations
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 用法、指南和限制
- en: Like expression-bodied members, interpolated string literals are a safe feature
    to experiment with. You can adjust your code to meet your own (or team-wide) thresholds.
    If you change your mind later and want to go back to the old code, doing so is
    trivial. Unless you start using `FormattableString` in your APIs, the use of interpolated
    string literals is a hidden implementation detail. That doesn’t mean it should
    be used absolutely everywhere, of course. In this section, we’ll discuss where
    it makes sense to use interpolated string literals, where it doesn’t, and where
    you might find you can’t even if you want to.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 与表达式成员类似，插值字符串字面量是一个安全的特性，可以用来进行实验。你可以调整你的代码以满足你自己的（或团队范围内的）阈值。如果你后来改变主意，想要回到旧代码，这样做是微不足道的。除非你在你的API中使用`FormattableString`，否则插值字符串字面量的使用是一个隐藏的实现细节。当然，这并不意味着它应该在绝对每个地方都使用。在本节中，我们将讨论在哪里使用插值字符串字面量是合理的，在哪里不合理，以及即使你想要，你可能会发现你甚至无法使用它。
- en: 9.4.1\. Developers and machines, but maybe not end users
  id: totrans-453
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1\. 开发者和机器，但可能不是最终用户
- en: 'First, the good news: almost anywhere you’re already using string formatting
    with hardcoded composite format strings or anywhere you’re using plain string
    concatenation you can use interpolated strings. Most of the time, the code will
    be more readable afterward.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，是好消息：几乎在任何你已经在使用硬编码组合格式字符串进行字符串格式化或任何你使用纯字符串连接的地方，你都可以使用插值字符串。大多数情况下，代码在之后会更容易阅读。
- en: The hardcoded part is important here. Interpolated string literals aren’t dynamic.
    The composite format string is there inside your source code; the compiler just
    mangles it a little to use regular format items. That’s fine when you know the
    text and format of the desired string beforehand, but it’s not flexible.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的硬编码部分很重要。插值字符串字面量不是动态的。组合格式字符串就在你的源代码中；编译器只是稍微修改一下，以便使用常规格式项。当你事先知道所需字符串的文本和格式时，这很好，但它不够灵活。
- en: 'One way of categorizing strings is to think about who or what is going to consume
    them. For the purposes of this section, I’ll consider three consumers:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 一种对字符串进行分类的方法是考虑谁或什么将消费它们。为了本节的目的，我将考虑三个消费者：
- en: Strings designed for other code to parse
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其他代码解析而设计的字符串
- en: Messages for other developers
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向其他开发者的消息
- en: Messages for end users
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向最终用户的消息
- en: Let’s look at each kind of string in turn and think about whether interpolated
    string literals are useful.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每种字符串，并思考插值字符串字面量是否有用。
- en: Machine-readable strings
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可读性强的字符串
- en: Lots of code is built to read other strings. There are machine-readable log
    formats, URL query parameters, and text-based data formats such as XML, JSON,
    or YAML. All of these have a set format, and any values should be formatted using
    the invariant culture. This is a great place to use `FormattableString`, as you’ve
    already seen, if you need to perform the formatting yourself. As a reminder, you
    should typically be taking advantage of an appropriate API for the formatting
    of machine-readable strings anyway.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 大量代码被构建来读取其他字符串。有可读性强的日志格式、URL查询参数和基于文本的数据格式，如XML、JSON或YAML。所有这些都有固定的格式，任何值都应该使用不变的文化格式化。这是一个使用`FormattableString`的好地方，正如你之前看到的，如果你需要自己执行格式化。提醒一下，你通常应该利用适当的API来格式化可读性强的字符串。
- en: Bear in mind that each of these strings might also contain nested strings aimed
    at humans; each line of a log file may be formatted in a specific way to make
    it easy to treat as a single record, but the message part of it may be aimed at
    other developers. You need to keep track of what level of nesting each part of
    your code is working at.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些字符串中也可能包含针对人类的嵌套字符串；日志文件的每一行可能以特定方式格式化，以便将其作为单个记录处理，但消息部分可能针对其他开发者。你需要跟踪代码的每一部分在哪个嵌套级别上工作。
- en: Messages for other developers
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 面向其他开发者的消息
- en: 'If you look at a large codebase, you’re likely to find that many of your string
    literals are aimed at other developers, whether they’re colleagues within the
    same company or developers using an API you’ve released. These are primarily as
    follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看一个大型代码库，你很可能会发现许多字符串字面量是针对其他开发者的，无论是同公司的同事还是使用你发布的API的开发者。这些主要如下：
- en: Tooling strings such as help messages in console applications
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具字符串，例如控制台应用程序中的帮助信息
- en: Diagnostic or progress messages written to logs or the console
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入日志或控制台的诊断或进度消息
- en: Exception messages
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常消息
- en: In my experience, these are typically in English. Although some companies—including
    Microsoft—go to the trouble of localizing their error messages, most don’t. Localization
    has a significant cost both in terms of the data translation and the code to use
    it properly. If you know your audience is at least reasonably comfortable reading
    English, and particularly if they may want to share the messages on English-oriented
    sites such as Stack Overflow, it’s usually not worth the effort of localizing
    these strings.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，这些通常是用英语编写的。尽管一些公司——包括微软——会费心将错误信息本地化，但大多数公司不会这么做。本地化在数据翻译和正确使用代码方面都有显著的成本。如果你知道你的受众至少对阅读英语感到相当舒适，尤其是如果他们可能想在Stack
    Overflow等以英语为主的网站上分享这些信息，那么本地化这些字符串通常不值得付出努力。
- en: 'Whether you go so far as making sure that the values within the text are all
    formatted in a fixed culture is a different matter. It can definitely help to
    improve consistency, but I suspect I’m not the only developer who doesn’t pay
    as much attention to that as I might. I encourage you to use a nonambiguous format
    for dates, however. The ISO format of yyyy-MM-dd is easy to understand and doesn’t
    have the “month first or day first?” problem of dd/MM/yyyy or MM/dd/yyyy. As I
    noted earlier, the culture can affect which numbers are produced because of different
    calendar systems being in use in different parts of the world. Consider carefully
    whether you want to use the invariant culture to force the use of the Gregorian
    calendar. For example, code to throw an exception for an invalid argument might
    look like this:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文本中的值都按照固定文化格式化，这是一回事。这肯定有助于提高一致性，但我怀疑我不是唯一一个没有像我希望的那样重视这一点的人。我鼓励你使用非歧义性的日期格式。yyyy-MM-dd的ISO格式易于理解，并且没有dd/MM/yyyy或MM/dd/yyyy的“月先还是日先？”问题。如我之前所述，文化可能会影响产生哪些数字，因为世界上不同地区使用不同的日历系统。仔细考虑你是否想使用不变的文化来强制使用公历。例如，抛出无效参数异常的代码可能看起来像这样：
- en: '[PRE57]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you know that all the developers reading these strings are going to be in
    the same non-English culture, it’s entirely reasonable to write all those messages
    in that culture instead.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道阅读这些字符串的所有开发者都将处于同一非英语文化中，那么完全有理由用那种文化来编写所有这些消息。
- en: Messages for end users
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最终用户的消息
- en: Finally, almost all applications have at least some text that’s displayed to
    an end user. As with developers, you need to be aware of the expectations of each
    user in order to make the right decision for how to present text to them. In some
    cases, you can be confident that all your end users are happy to use a single
    culture. This is typically the case if you’re building an application to be used
    internally within a business or other organization that’s based in one location.
    Here it’s much more likely that you’ll use whatever that local culture is rather
    than English, but you don’t need to worry about two users wanting to see the same
    information presented in different ways.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，几乎所有应用程序至少都会显示一些文本给最终用户。与开发者一样，你需要了解每个用户的期望，以便为他们做出如何呈现文本的正确决定。在某些情况下，你可以确信所有最终用户都愿意使用单一的文化。这通常是在你为在一个特定地点内部使用的应用程序构建时的情况。在这里，你更有可能使用当地的文化而不是英语，但你不必担心两个用户想要以不同的方式看到相同的信息。
- en: So far, all these situations have been amenable to interpolated string literals.
    I’m particularly fond of using them for exception messages. They let me write
    concise code that still provides useful context to the unfortunate developer poring
    over logs and trying to work out what’s gone wrong this time.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有这些情况都适用于插值字符串字面量。我特别喜欢用它们来编写异常消息。它们让我能够编写简洁的代码，同时仍然为不幸的、正在查看日志并试图找出这次出了什么问题的开发者提供有用的上下文。
- en: But interpolated string literals are rarely helpful when you have end users
    in multiple cultures, and they can hurt your product if you don’t localize. Here,
    the format strings are likely to be in resource files rather than in your code
    anyway, so you’re unlikely to even see the possibility of using interpolated string
    literals. There are occasional exceptions to this, such as when you’re formatting
    just one snippet of information to put within a specific HTML tag or something
    similar. In those exceptional cases, an interpolated string literal should be
    fine, but don’t expect to use them much.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你有多个文化的最终用户时，插值字符串字面量很少有帮助，如果你不进行本地化，它们可能会损害你的产品。在这里，格式字符串可能位于资源文件中而不是你的代码中，所以你甚至不太可能看到使用插值字符串字面量的可能性。偶尔会有例外，比如当你只是格式化一小段信息以放入特定的HTML标签或类似的东西时。在这些异常情况下，插值字符串字面量应该是可以的，但不要期望会经常使用它们。
- en: You’ve seen that you can’t use interpolated string literals for resource files.
    Next, you’ll look at other cases for which the feature simply isn’t designed to
    help you.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到你不能为资源文件使用插值字符串字面量。接下来，你将查看其他一些情况，对于这些情况，该功能根本就没有设计来帮助你。
- en: 9.4.2\. Hard limitations of interpolated string literals
  id: totrans-478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2\. 插值字符串字面量的硬限制
- en: Every feature has its limits, and interpolated string literals are no exception.
    These limitations sometimes have workarounds, which I’ll show you before generally
    advising you not to try them in the first place.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 每个特性都有其局限性，插值字符串字面量也不例外。这些限制有时有解决方案，我会在建议你首先不要尝试它们之前向你展示。
- en: No dynamic formatting
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 没有动态格式化
- en: 'You’ve already seen that you can’t change most of the composite format string
    that makes up the interpolated string literal. Yet one piece feels like it should
    be expressible dynamically but isn’t: individual format strings. Let’s take one
    piece of an example from earlier:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，你不能改变构成插值字符串字面量的复合格式字符串的大部分。然而，有一块感觉应该可以动态表达，但实际上不能：单个格式字符串。让我们从一个早期的例子中取出一部分：
- en: '[PRE58]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, I’ve chosen `9` as the alignment, knowing that the values I’d be formatting
    would fit nicely into nine characters. But what if you know that sometimes all
    the values you need to format will be small and other times they may be huge?
    It’d be nice to make that `9` part dynamic, but there’s no simple way of doing
    it. The closest you can easily come is to use an interpolated string literal as
    the input to `string.Format` or the equivalent `Console.WriteLine` overload, as
    in the following example:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我选择了`9`作为对齐，因为我所格式化的值将很好地适应九个字符。但如果你知道有时你需要格式化的所有值都会很小，而有时它们可能很大呢？如果能让那个`9`部分动态变化，那会很好，但并没有简单的方法来做这件事。你最容易想到的方法是使用插值字符串字面量作为`string.Format`或等效的`Console.WriteLine`重载的输入，如下面的示例所示：
- en: '[PRE59]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The first and last braces are doubled as the escape mechanism in string formats,
    because you want the result of the interpolated string literal to be a string
    such as `"Price: {0,9}"` that’s ready to be formatted using the `price` variable
    to fill in the format item. This isn’t code I’d want to either write or read.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '字符串格式中的第一个和最后一个花括号被用作转义机制，因为你想得到的结果是一个字符串，如`"Price: {0,9}"`，它可以使用`price`变量来填充格式项。这不是我想写或读的代码。'
- en: No expression reevaluation
  id: totrans-486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 没有表达式重新评估
- en: The compiler always converts an interpolated string literal into code that immediately
    evaluates the expressions in the format items and uses them to build either a
    `string` or a `FormattableString`. The evaluation can’t be deferred or repeated.
    Consider the short example in the following listing. It prints the same value
    twice, even though the developer may expect it to use deferred execution.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器总是将插值字符串字面量转换为代码，该代码立即评估格式项中的表达式，并使用它们构建一个`string`或`FormattableString`。评估不能延迟或重复。请考虑以下列表中的简短示例。它两次打印相同的值，尽管开发者可能期望它使用延迟执行。
- en: Listing 9.11\. Even `FormattableString` evaluates expressions eagerly
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11\. 即使 `FormattableString` 也急于评估表达式
- en: '[PRE60]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Prints "Current value: Before"**'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印 "Current value: Before"**'
- en: '***2* Still prints "Current value: Before"**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 仍然打印 "Current value: Before"**'
- en: If you’re desperate, you can work around this. If you change the expression
    to include a lambda expression that captures `value`, you can abuse this to evaluate
    it each time it’s formatted. Although the lambda expression itself is converted
    into a delegate immediately, the resulting delegate would capture the `value`
    variable, not its current value, and you can force the delegate to be evaluated
    each time you format the `FormattableString`. This is a sufficiently bad idea
    that, although I’ve included an example of it in the downloadable samples for
    the book, I’m not going to sully these pages with it. (It’s still a fun abuse,
    admittedly.)
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你绝望了，你可以解决这个问题。如果你将表达式改为包含捕获`value`的lambda表达式，你可以利用这一点在每次格式化时评估它。尽管lambda表达式本身会立即转换为委托，但生成的委托会捕获`value`变量，而不是它的当前值，你可以在每次格式化`FormattableString`时强制委托被评估。这是一个足够糟糕的想法，尽管我在书的可下载示例中包含了一个例子，但我不会将这些页面弄脏。（这确实是一种有趣的滥用。）
- en: No bare colons
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 没有裸露的分号
- en: 'Although you can use pretty much any expression computing a value in interpolated
    string literals, there’s one problem with the conditional `?:` operator: it confuses
    the compiler and indeed the grammar of the C# language. Unless you’re careful,
    the colon ends up being handled as the separator between the expression and the
    format string, which leads to a compile-time error. For example, this is invalid:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你几乎可以使用任何计算值的表达式在插值字符串字面量中，但条件`?:`运算符有一个问题：它会混淆编译器，实际上也会混淆C#语言的语法。除非你小心，否则冒号最终会被处理为表达式和格式字符串之间的分隔符，这会导致编译时错误。例如，这是无效的：
- en: '[PRE61]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It’s simple to fix by using parentheses around the conditional expression:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在条件表达式周围使用括号可以简单地修复它：
- en: '[PRE62]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: I rarely find this to be a problem, partly because I usually try to keep the
    expressions shorter than this anyway. I’d probably extract the yes/no value into
    a separate string variable first. This leads us nicely into a discussion about
    when the choice of whether to use an interpolated string literal really comes
    down to a matter of taste.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我很少发现这成问题，部分原因是我通常尽量保持表达式比这更短。我可能会首先将是/否值提取到一个单独的字符串变量中。这很自然地引出了关于何时选择是否使用插值字符串字面量真正归结为品味问题的一场讨论。
- en: 9.4.3\. When you can but really shouldn’t
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.3. 当你可以但真的不应该
- en: The compiler isn’t going to mind if you abuse interpolated string literals,
    but your coworkers might. There are two primary reasons not to use them even where
    you can.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可能不会介意你滥用插值字符串字面量，但你的同事可能会。即使你可以使用它们，也有两个主要的原因不使用它们。
- en: Defer formatting for strings that may not be used
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 延迟格式化可能不会使用的字符串
- en: 'Sometimes you want to pass a format string and the arguments that would be
    formatted to a method that might use them or might not. For example, if you have
    a precondition validation method, you might want to pass in the condition to check
    along with the format and arguments of an exception message to create if (and
    only if) the condition fails. It’s easy to write code like this:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想要传递一个格式字符串和将要格式化的参数到一个可能使用它们或可能不使用它们的函数中。例如，如果你有一个前置条件验证方法，你可能想传入要检查的条件以及异常消息的格式和参数，以创建（仅在条件失败时）：
- en: '[PRE63]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Alternatively, you could have a logging framework that’ll log only if the level
    has been configured appropriately at execution time. For example, you might want
    to log the size of a request that your server has received:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以有一个日志框架，只有当在执行时配置了适当的级别时才会记录。例如，你可能想记录服务器接收到的请求数量：
- en: '[PRE64]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You might be tempted to use an interpolated string literal for this by changing
    the code to the following:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会被诱惑使用插值字符串字面量来做这件事，通过将代码更改为以下内容：
- en: '[PRE65]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: That would be a bad idea; it forces the string to be formatted even if it’s
    just going to be thrown away, because the formatting will unconditionally be performed
    before the method is called rather than within the method only if it’s needed.
    Although string formatting isn’t hugely expensive in terms of performance, you
    don’t want to be doing it unnecessarily.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 那将是一个糟糕的想法；它迫使字符串被格式化，即使它只是会被丢弃，因为格式化将在方法调用之前无条件地执行，而不是仅在需要时在方法内部执行。尽管字符串格式化在性能方面并不昂贵，但你不想不必要地进行格式化。
- en: You may be wondering whether `FormattableString` would help here. If the validation
    or logging library accepted a `FormattableString` as an input parameter, you could
    defer the formatting and control the culture used for formatting in a single place.
    Although that’s true, it’d still involve creating the object each time, which
    is still an unnecessary cost.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道`FormattableString`在这里是否会有帮助。如果验证或日志库接受`FormattableString`作为输入参数，你就可以延迟格式化，并在一个地方控制用于格式化的文化。尽管这是真的，但仍然需要每次都创建对象，这仍然是不必要的开销。
- en: Format for readability
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 格式化以提高可读性
- en: The second reason for not using interpolated string literals is that they can
    make the code harder to read. Short expressions are absolutely fine and help readability.
    But when the expression becomes longer, working out which parts of the literal
    are code and which are text starts to take more time. I find that parentheses
    are the killer; if you have more than a couple of method or constructor calls
    in the expression, they end up being confusing. This goes double when the text
    also includes parentheses.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用插值字符串字面量的第二个原因是它们可以使代码更难以阅读。简短的表达式绝对可以，并且有助于可读性。但是当表达式变长时，确定字面量中的哪些部分是代码，哪些是文本需要更多时间。我发现括号是杀手；如果你在表达式中有多于几个方法或构造函数调用，它们最终会变得令人困惑。当文本还包括括号时，这一点加倍。
- en: 'Here’s a real example from Noda Time. It’s in a test rather than in production
    code, but I still want the tests to be readable:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个来自Noda Time的真实例子。它在一个测试而不是生产代码中，但我仍然希望测试是可读的：
- en: '[PRE66]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: That’s not too bad, but imagine putting the three arguments within the string.
    I’ve done it, and it’s not pretty; you end up with a literal that’s more than
    100 characters long. You can’t break it up to use vertical formatting to make
    each argument stand alone as I have with the preceding layout, so it ends up being
    noise.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太糟糕，但想象一下将三个参数放在字符串中。我试过，结果并不好看；您最终得到一个超过100个字符的文本。您不能将其拆分以使用垂直格式，使每个参数独立，就像我在前面的布局中所做的那样，所以它最终变成了噪音。
- en: 'To give one final tongue-in-cheek example of just how bad an idea it can be,
    remember the code used to start the chapter:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给出一个最后的幽默例子，说明这可以是一个多么糟糕的想法，请记住用于启动本章的代码：
- en: '[PRE67]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can put all of this inside a single statement using an interpolated string
    literal. You may be skeptical; after all, that code consists of three separate
    statements, and the interpolated string literal can include only expressions.
    That’s true, but statement-bodied lambda expressions are still expressions. You
    need to cast the lambda expression to a specific delegate type, and then you need
    to invoke it to get the result, but it’s all doable. It’s just not pleasant. Here’s
    one option, which does at least use separate lines for each statement by virtue
    of a verbatim interpolated string literal, but that’s about all that can be said
    in its favor:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一个插值字符串字面量将所有这些内容放在一个单独的语句中。您可能持怀疑态度；毕竟，这段代码由三个独立的语句组成，而插值字符串字面量只能包含表达式。这是真的，但是语句体的lambda表达式仍然是表达式。您需要将lambda表达式转换为特定的委托类型，然后您需要调用它以获取结果，但这都是可以做到的。只是不太愉快。这里有一个选项，它至少通过逐字插值的字符串字面量为每个语句使用了单独的行，但这几乎就是它能说的所有优点：
- en: '[PRE68]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'I thoroughly recommend running: run the code to prove that it works, and then
    run away from it as fast as you can. While you’re recovering from that, let’s
    look at the other string-oriented feature of C# 6.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐运行：运行代码以证明它的工作，然后尽可能快地远离它。当您从那件事中恢复过来时，让我们看看 C# 6 的另一个字符串相关特性。
- en: 9.5\. Accessing identifiers with nameof
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5. 访问使用 nameof 的标识符
- en: 'The `nameof` operator is trivial to describe: it takes an expression referring
    to a member or local variable, and the result is a compile-time constant string
    with the simple name for that member or variable. It’s that simple. Anytime you
    hardcode the name of a class, property, or method, you’ll be better off with the
    `nameof` operator. Your code will be more robust both now and in the face of changes.'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof` 运算符很容易描述：它接受一个引用成员或局部变量的表达式，结果是该成员或变量的简单名称的编译时常量字符串。就这么简单。每次您在代码中硬编码类、属性或方法的名称时，您都会发现使用
    `nameof` 运算符会更好。您的代码现在和面对变化时都会更加健壮。'
- en: 9.5.1\. First examples of nameof
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.1. nameof 的第一个示例
- en: In terms of syntax, the `nameof` operator is like the `typeof` operator, except
    that the identifier in the parentheses doesn’t have to be a type. The following
    listing shows a short example with a few kinds of members.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法方面，`nameof` 运算符类似于 `typeof` 运算符，只不过括号中的标识符不必是类型。以下列表显示了一个包含几种成员的简短示例。
- en: Listing 9.12\. Printing out the names of a class, method, field, and parameter
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.12. 打印出类、方法、字段和参数的名称
- en: '[PRE69]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The result is exactly what you’d probably expect:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 结果正是您可能期望的：
- en: '[PRE70]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: So far, so good. But, obviously, you could’ve achieved the same result by using
    string literals. The code would’ve been shorter, too. So why is it better to use
    `nameof`? In one word, robustness. If you make a typo in a string literal, there’s
    nothing to tell you, whereas if you make a typo in a `nameof` operand, you’ll
    get a compile-time error.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但，显然，您可以通过使用字符串字面量达到相同的结果。代码也会更短。那么为什么使用 `nameof` 会更好呢？一句话，健壮性。如果您在字符串字面量中输入了错误，没有任何东西可以告诉您，而如果您在
    `nameof` 操作数中输入了错误，您将得到一个编译时错误。
- en: '|  |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The compiler still won’t be able to spot the problem if you refer to a different
    member with a similar name. If you have two members that differ only in case,
    such as `filename` and `fileName`, you can easily refer to the wrong one without
    the compiler noticing. This is a good reason to avoid such similar names, but
    it’s always been a bad idea to name things so similarly; even if you don’t confuse
    the compiler, you can easily confuse a human reader.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用一个类似名称的不同成员进行引用，编译器仍然无法发现问题。如果您有两个成员，它们仅在大小写上有所不同，例如 `filename` 和 `fileName`，您可以在编译器没有注意到的情况下轻松地引用错误的一个。这是一个避免此类类似名称的好理由，但总是将事物以如此相似的方式命名是一个坏主意；即使您没有混淆编译器，您也容易混淆人类读者。
- en: '|  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Not only will the compiler tell you if you get things wrong, but it knows that
    your `nameof` code is associated with the member or variable you’re naming. If
    you rename it in a refactoring-aware way, your `nameof` operand will change, too.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅编译器会告诉你是否出错，而且它知道你的`nameof`代码与你正在命名的成员或变量相关联。如果你以重构感知的方式进行重命名，你的`nameof`操作数也会改变。
- en: 'For example, consider the following listing. Its purpose is irrelevant, but
    note that `oldName` occurs three times: for the parameter declaration, obtaining
    its name with `nameof`, and obtaining the value as a simple expression.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码示例。其目的无关紧要，但请注意`oldName`出现了三次：用于参数声明、使用`nameof`获取其名称以及作为简单表达式获取其值。
- en: Listing 9.13\. A simple method using its parameter twice in the body
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.13\. 在方法体中使用其参数两次的简单方法
- en: '[PRE71]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In Visual Studio, if you place your cursor within any of the three occurrences
    of `oldName` and press F2 for the Rename operation, all three will be renamed
    together, as shown in [figure 9.2](kindle_split_025_split_000.html#ch09fig02).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，如果你将光标放在`oldName`的任意一处并按F2进行重命名操作，所有三个都会一起重命名，如[图9.2](kindle_split_025_split_000.html#ch09fig02)所示。
- en: Figure 9.2\. Renaming an identifier in Visual Studio
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 在Visual Studio中重命名标识符
- en: '![](../Images/09fig02_alt.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig02_alt.jpg)'
- en: The same approach works for other names (methods, types, and so forth). Basically,
    `nameof` is refactoring friendly in a way that hardcoded string literals aren’t.
    But when should you use it?
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也适用于其他名称（方法、类型等）。基本上，`nameof`在重构方面比硬编码的字符串字面量更友好。但你应该在何时使用它？
- en: 9.5.2\. Common uses of nameof
  id: totrans-541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.2\. `nameof`的常见用法
- en: I’m not going to claim that the examples here are the only sensible uses of
    `nameof`. They’re just the ones I’ve come across most often. They’re mostly places
    where prior to C# 6, you’d have seen either hardcoded names or, possibly, expression
    trees being used as a workaround that’s refactoring friendly but complex.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会声称这里提供的示例是`nameof`的唯一合理用法。它们只是我遇到的最常见的用法。它们大多是在C# 6之前你会看到硬编码的名称或，可能的话，使用作为重构友好但复杂的解决方案的表达式树的地方。
- en: Argument validation
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数验证
- en: 'In [chapter 8](kindle_split_024_split_000.html#ch08), when I showed the uses
    of `Preconditions.CheckNotNull` in Noda Time, that wasn’t the code that’s actually
    in the library. The real code includes the name of the parameter with the null
    value, which makes it a lot more useful. The `InZone` method I showed there looks
    like this:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](kindle_split_024_split_000.html#ch08)中，当我展示了Noda Time中`Preconditions.CheckNotNull`的使用时，那并不是库中实际存在的代码。真正的代码包括带有null值的参数名称，这使得它更有用。我在那里展示的`InZone`方法看起来是这样的：
- en: '[PRE72]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Other precondition methods are used in a similar way. This is by far the most
    common use I find for `nameof`. If you’re not already validating arguments to
    your public methods, I strongly advise you to start doing so; `nameof` makes it
    easier than ever to perform robust validation with informational messages.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 其他前置条件方法以类似的方式使用。这可能是我发现`nameof`最常见的使用方式。如果你还没有开始验证公共方法的参数，我强烈建议你开始这样做；`nameof`使得进行健壮的验证并带有信息性消息变得比以往任何时候都更容易。
- en: Property change notification for computed properties
  id: totrans-547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计算属性的改变通知
- en: As you saw in [section 7.2](kindle_split_022_split_000.html#ch07lev1sec2), `CallerMemberNameAttribute`
    makes it easy to raise events in `INotifyPropertyChanged` implementations when
    the property itself changes. But what if changing the value of one property has
    an effect on another property? For example, suppose you have a `Rectangle` class
    with read/write `Height` and `Width` properties and a read-only `Area` property.
    It’s useful to be able to raise the event for the `Area` property and specify
    the name of the property in a safe way, as shown in the following listing.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第7.2节](kindle_split_022_split_000.html#ch07lev1sec2)中看到的，`CallerMemberNameAttribute`使得在`INotifyPropertyChanged`实现中当属性本身发生变化时引发事件变得容易。但如果一个属性值的改变会影响另一个属性呢？例如，假设你有一个具有读写`Height`和`Width`属性以及只读`Area`属性的`Rectangle`类。能够引发`Area`属性的事件并以安全的方式指定属性名称是有用的，如下面的代码示例所示。
- en: Listing 9.14\. Using `nameof` to raise a property change notification
  id: totrans-549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.14\. 使用`nameof`引发属性更改通知
- en: '[PRE73]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* Avoid raising events when the value isn’t changing.**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 避免在值未改变时引发事件。**'
- en: '***2* Raises the event for the Width property**'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 引发宽度属性的引发事件**'
- en: '***3* Raises the event for the Area property**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 引发面积属性的引发事件**'
- en: '***4* Implemented just like Width**'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 实现方式与Width相同**'
- en: '***5* Computed property**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 计算属性**'
- en: '***6* Change notification as per [section 7.2](kindle_split_022_split_000.html#ch07lev1sec2)**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 根据[第 7.2 节](kindle_split_022_split_000.html#ch07lev1sec2)进行更改通知**'
- en: Most of this listing is exactly as you’d have written it in C# 5, but the line
    in bold would’ve had to be `RaisePropertyChanged("Area")` or `RaisePropertyChanged(()
    => Area)`. The latter approach would’ve been complex, in terms of the `RaisePropertyChanged`
    code, and inefficient, because it builds up an expression tree solely to be inspected
    for the name. The `nameof` solution is much cleaner.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数列表项与你在 C# 5 中编写的完全一样，但粗体行原本应该是 `RaisePropertyChanged("Area")` 或 `RaisePropertyChanged(()
    => Area)`。后者在 `RaisePropertyChanged` 代码方面会更复杂，而且效率低下，因为它仅仅为了检查名称而构建了一个表达式树。`nameof`
    解决方案要干净得多。
- en: Attributes
  id: totrans-558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 属性
- en: Sometimes attributes refer to other members to indicate how the members relate
    to each other. When you want to refer to a type, you can already use `typeof`
    to make that relationship, but that doesn’t work for any other kind of member.
    As a concrete example, NUnit allows tests to be parameterized with values that
    are extracted from a field, property, or method using the `TestCaseSource` attribute.
    The `nameof` operator allows you to refer to that member in a safe way. The following
    listing shows yet another example from Noda Time, testing that all the time zones
    loaded from the Time Zone Database (TZDB, now hosted by IANA) behave appropriately
    at the start and end of time.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 有时属性会引用其他成员来指示成员之间的关系。当你想引用一个类型时，你可以使用 `typeof` 来建立这种关系，但这不适用于任何其他类型的成员。作为一个具体的例子，NUnit
    允许测试使用 `TestCaseSource` 属性从字段、属性或方法中提取的值进行参数化。`nameof` 运算符允许你以安全的方式引用该成员。以下列表展示了
    Noda Time 的另一个示例，测试从时区数据库（TZDB，现在由 IANA 托管）加载的所有时区在时间开始和结束时是否表现适当。
- en: Listing 9.15\. Specifying a test case source with `nameof`
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.15\. 使用 `nameof` 指定测试用例源
- en: '[PRE74]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Field to retrieve all TZDB time zones**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取所有 TZDB 时区的字段**'
- en: '***2* Refers to the field using nameof**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 nameof 引用字段**'
- en: '***3* Test method called with each time zone in turn**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 按顺序调用每个时区的测试方法**'
- en: '***4* Body of test method omitted**'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 测试方法主体省略**'
- en: 'The utility here isn’t restricted to testing. It’s applicable wherever attributes
    indicate a relationship. You could imagine a more sophisticated `RaisePropertyChanged`
    method from the preceding section, where the relationship between properties could
    be specified with attributes instead of within code:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的实用程序不仅限于测试。它适用于属性指示关系的任何地方。你可以想象一个更复杂的 `RaisePropertyChanged` 方法，如前所述，其中属性之间的关系可以用属性而不是代码来指定：
- en: '[PRE75]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The event-raising method could keep a cached data structure indicating that
    whenever it was notified that the `Width` property had changed, it should raise
    a change notification for `Area` as well.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 事件引发方法可以保留一个缓存的数据结构，指示每当它被通知 `Width` 属性已更改时，它还应引发 `Area` 的更改通知。
- en: 'Similarly, in object-relational mapping technologies such as Entity Framework,
    it’s reasonably common to have two properties in a class: one for a foreign key
    and the other to be the entity that key represents. This is shown in the following
    example:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在对象关系映射技术（如 Entity Framework）中，一个类中通常有两个属性：一个用于外键，另一个用于表示该键的实体。以下示例展示了这一点：
- en: '[PRE76]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: There are no doubt many other attributes that can take advantage of this approach.
    Now that you’re aware of it, you may find places in your existing codebase that’ll
    benefit from `nameof`. In particular, you should look for code where you need
    to use reflection with names that you do know at compile time but haven’t previously
    been able to specify in a clean way. There are still a few little subtleties to
    cover for the sake of completeness, however.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 肯定还有许多其他属性可以利用这种方法。现在你已经知道了这一点，你可能会发现现有代码库中有一些地方可以从 `nameof` 中受益。特别是，你应该寻找需要使用反射，但在编译时已知名称但之前无法以干净方式指定的代码。然而，为了完整性，我们仍需涵盖一些小的细微差别。
- en: 9.5.3\. Tricks and traps when using nameof
  id: totrans-572
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.3\. 使用 nameof 时的技巧和陷阱
- en: You may never need to know any of the details in this section. This content
    is primarily here just in case you find yourself surprised by the behavior of
    `nameof`. In general, it’s a pretty simple feature, but a few aspects might surprise
    you.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能永远不需要知道本节中的任何细节。这部分内容主要在这里，以防你发现自己对 `nameof` 的行为感到惊讶。一般来说，这是一个相当简单的功能，但一些方面可能会让你感到惊讶。
- en: Referring to members of other types
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 引用其他类型的成员
- en: 'Often, it’s useful to be able to refer to members in one type from within code
    in another type. Going back to the `TestCaseSource` attribute, for example, in
    addition to a name, you can specify a type where NUnit will look for that name.
    If you have a source of information that’ll be used from multiple tests, it makes
    sense to put it in a common place. To do this with `nameof`, you qualify it with
    the type as well. The result will be the simple name:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，能够从另一个类型的代码中引用一个类型的成员是有用的。以 `TestCaseSource` 属性为例，除了名称外，你还可以指定 NUnit 将在其中查找该名称的类型。如果你有一个将在多个测试中使用的信息来源，将其放在一个公共位置是有意义的。使用
    `nameof` 来实现这一点，你还需要指定类型。结果将是简单的名称：
- en: '[PRE77]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'That is equivalent to the following, except for all the normal benefits of
    `nameof`:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下内容，除了 `nameof` 的所有正常好处：
- en: '[PRE78]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can also use a variable of the relevant type to access a member name, although
    only for instance members. In reverse, you can use the name of the type for both
    static and instance members. The following listing shows all the valid permutations.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用相关类型的变量来访问成员名称，尽管仅限于实例成员。相反，你可以使用类型的名称来访问静态和实例成员。以下列表显示了所有有效的排列。
- en: Listing 9.16\. All the valid ways of accessing names of members in other types
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.16\. 访问其他类型成员名称的所有有效方式
- en: '[PRE79]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: I prefer to always use the type name where possible; if you use a variable instead,
    it *looks* like the value of the variable may matter, but really it’s used only
    at compile time to determine the type. If you’re using an anonymous type, there’s
    no type name you could use, so you have to use the variable.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢在可能的情况下始终使用类型名称；如果你使用一个变量，它 *看起来* 变量的值可能很重要，但实际上它仅在编译时使用，以确定类型。如果你使用匿名类型，就没有可用的类型名称，因此你必须使用变量。
- en: A member still has to be accessible for you to refer to it using `nameof`; if
    `StaticMember` or `InstanceMember` in [listing 9.16](kindle_split_025_split_000.html#ch09ex16)
    had been private, the code trying to access their names would’ve failed to compile.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 成员仍然必须可访问，你才能使用 `nameof` 来引用它；如果 [列表 9.16](kindle_split_025_split_000.html#ch09ex16)
    中的 `StaticMember` 或 `InstanceMember` 是私有的，尝试访问其名称的代码将无法编译。
- en: Generics
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 泛型
- en: You may be wondering what happens if you try to take the name of a generic type
    or method and how it has to be specified. In particular, `typeof` allows both
    bound and unbound type names to be used; `typeof(List<string>)` and `typeof(List<>)`
    are both valid and give different results.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如果你尝试获取一个泛型类型或方法的名称会发生什么，以及它应该如何指定。特别是，`typeof` 允许使用已绑定和未绑定的类型名称；`typeof(List<string>)`
    和 `typeof(List<>)` 都是有效的，并且会给出不同的结果。
- en: 'With `nameof`, the type argument must be specified but isn’t included in the
    result. Additionally, there’s no indication of the number of type parameters in
    the result: `nameof(Action<string>)` and `nameof(Action<string, string>)` both
    have a value of just `"Action"`. This can be irritating, but it removes any question
    of how the resulting name should represent arrays, anonymous types, further generic
    types, and so on.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `nameof`，必须指定类型参数，但该参数不会包含在结果中。此外，结果中也没有类型参数数量的指示：`nameof(Action<string>)`
    和 `nameof(Action<string, string>)` 都有值为 `"Action"`。这可能会令人烦恼，但它消除了关于结果名称应该如何表示数组、匿名类型、进一步泛型类型等问题。
- en: It seems likely to me that the requirement for a type argument to be specified
    may be removed in the future both to be consistent with `typeof` and to avoid
    having to specify a type that makes no difference to the result. But changing
    the result to include the number of type arguments or the type arguments themselves
    would be a breaking change, and I don’t envision that happening. In most cases
    where that matters, using `typeof` to obtain a `Type` would be preferable anyway.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得未来可能取消对类型参数指定的要求，以与 `typeof` 保持一致，并避免需要指定对结果没有影响的类型。但是，将结果更改为包括类型参数的数量或类型参数本身将是一个破坏性更改，我不认为会发生这种情况。在大多数相关情况下，使用
    `typeof` 获取 `Type` 可能会更可取。
- en: 'You can use a type parameter with a `nameof` operator, but unlike `typeof(T)`,
    it’ll always return the name of the type parameter rather than the name of the
    type argument used for that type parameter at execution time. Here’s a minimal
    example of that:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `nameof` 操作符与类型参数一起使用，但与 `typeof(T)` 不同，它总是返回类型参数的名称，而不是在执行时用于该类型参数的类型参数的名称。以下是一个最小示例：
- en: '[PRE80]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1* Always returns "T"**'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 总是返回 "T"**'
- en: 'It doesn’t matter how you call the method: `Method<Guid>()` or `Method<Button>()`
    will both return "`T`".'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何调用方法：`Method<Guid>()`或`Method<Button>()`都将返回"`T`"。
- en: Using aliases
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用别名
- en: Usually, using directives providing type or namespace aliases have no effect
    at execution time. They’re just different ways of referring to the same type or
    namespace. The `nameof` operator is one exception to this rule. The output of
    the following listing is `GuidAlias`, not `Guid`.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，提供类型或命名空间别名的使用指令在执行时没有效果。它们只是引用相同类型或命名空间的不同方式。`nameof`运算符是这一规则的例外。以下列表的输出是`GuidAlias`，而不是`Guid`。
- en: Listing 9.17\. Using an alias in the `nameof` operator
  id: totrans-594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.17\. 在`nameof`运算符中使用别名
- en: '[PRE81]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Predefined aliases, arrays and nullable value types
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 预定义别名、数组和可空值类型
- en: 'The `nameof` operator can’t be used with any of the predefined aliases (`int`,
    `char`, `long`, and so on) or the `?` suffix to indicate a nullable value type
    or array types. Therefore, all the following are invalid:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameof`运算符不能与任何预定义别名（如`int`、`char`、`long`等）或`?`后缀（表示可空值类型或数组类型）一起使用。因此，以下都是无效的：'
- en: '[PRE82]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* Predefined alias for System.Single**'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* System.Single的预定义别名**'
- en: '***2* Shorthand for Nullable<Guid>**'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Nullable<Guid>的缩写**'
- en: '***3* Array**'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 数组**'
- en: 'These are a little annoying, but you have to use the CLR type name for the
    predefined aliases and the `Nullable<T>` syntax for nullable value types:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有点令人烦恼，但您必须使用CLR类型名称作为预定义别名，并使用`Nullable<T>`语法表示可空值类型：
- en: '[PRE83]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As noted in the previous section on generics, the name of `Nullable<T>` will
    always be `Nullable` anyway.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述的泛型中提到的，`Nullable<T>`的名称始终是`Nullable`。
- en: The name, the simple name, and only the name
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 名称、简单名称，以及仅名称
- en: The `nameof` operator is in some ways a cousin of the mythical `infoof` operator,
    which has never been seen outside the room used for C# language design meetings.
    (See [http://mng.bz/6GVe](http://mng.bz/6GVe) for more information on `infoof`.)
    If the team ever manages to catch and tame `infoof`, it could return references
    to `MethodInfo`, `EventInfo`, `PropertyInfo` objects, and their friends. Alas,
    `infoof` has proved elusive so far, but many of the tricks it uses to evade capture
    aren’t available to the simpler `nameof` operator. Trying to take the name of
    an overloaded method? That’s fine; they all have the same name anyway. Can’t easily
    resolve whether you’re referring to a property or a type? Again, if they both
    have the same name, it doesn’t matter which you use. Although `infoof` would certainly
    provide benefits above and beyond `nameof` if it could ever be sensibly designed,
    the `nameof` operator is considerably simpler and still addresses many of the
    same use cases.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，`nameof`运算符是神话中的`infoof`运算符的远亲，后者从未在C#语言设计会议使用的房间里出现过。（有关`infoof`的更多信息，请参阅[http://mng.bz/6GVe](http://mng.bz/6GVe)。）如果团队能够捕捉并驯服`infoof`，它将返回`MethodInfo`、`EventInfo`、`PropertyInfo`对象及其朋友的引用。唉，到目前为止，`infoof`仍然难以捉摸，但它用来逃避捕捉的许多技巧并不适用于更简单的`nameof`运算符。试图获取重载方法的名称？那没问题；它们无论如何都有相同的名称。难以轻易确定你是指属性还是类型？再次，如果它们都有相同的名称，使用哪个都无关紧要。虽然如果能够合理设计，`infoof`无疑会提供比`nameof`更多的好处，但`nameof`运算符仍然相当简单，并且仍然解决了许多相同的使用场景。
- en: 'One point to note about what’s returned—the *simple name* or “bit at the end”
    in less specification-like terminology: it doesn’t matter if you use `nameof(Guid)`
    or use `nameof(System.Guid)` from within a class importing the `System` namespace.
    The result will still be only `"Guid"`.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 关于返回的内容有一点需要注意——*简单名称*或更非规范术语中的“末尾的位”：如果你使用`nameof(Guid)`或从导入`System`命名空间类的内部使用`nameof(System.Guid)`，结果仍然只是`"Guid"`。
- en: Namespaces
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'I haven’t given details about all the members that `nameof` can be used with,
    because it’s the set you’d expect: basically, all members except finalizers and
    constructors. But because we normally think about members in terms of types and
    members within types, you may be surprised that you can take the name of a namespace.
    Yes, namespaces are also members—of other namespaces.'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有详细说明`nameof`可以与之一起使用的所有成员，因为这是你预期的集合：基本上，所有成员除了终结器和构造函数。但由于我们通常从类型及其成员的角度考虑成员，你可能会惊讶地发现你可以获取命名空间的名称。是的，命名空间也是成员——其他命名空间的成员。
- en: But given the preceding rule about only the simple name being returned, that
    isn’t terribly useful. If you use `nameof(System.Collections.Generic)`, I suspect
    you want the result to be `System.Collections.Generic,` but in reality, it’s just
    `Generic`. I’ve never come across a type where this is useful behavior, but then
    it’s rarely important to know a namespace as a compile-time constant anyway.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，鉴于前面关于只返回简单名称的规则，这并不是非常有用。如果你使用 `nameof(System.Collections.Generic)`，我怀疑你希望结果是
    `System.Collections.Generic,` 但实际上，它只是 `Generic`。我从未遇到过这种有用的行为，但话又说回来，通常知道一个命名空间作为编译时常量并不重要。
- en: Summary
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Interpolated string literals allow you to write simpler string-formatting code.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值字符串字面量允许你编写更简单的字符串格式化代码。
- en: You can still use format strings in interpolated string literals to provide
    more formatting details, but the format string has to be known at compile time.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你仍然可以在插值字符串字面量中使用格式字符串来提供更多的格式化细节，但格式字符串必须在编译时已知。
- en: Interpolated verbatim string literals provide a mixture of the features of interpolated
    string literals and verbatim string literals.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值文本字面量提供了插值字符串字面量和文本字符串字面量的特征混合。
- en: The `FormattableString` type provides access to all the information required
    to format a string before the formatting takes place.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormattableString` 类型提供了在格式化之前格式化字符串所需的所有信息。'
- en: '`FormattableString` is usable out of the box in .NET 4.6 and .NET Standard
    1.3, but the compiler will use it if you provide your own implementation in earlier
    versions.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormattableString` 在 .NET 4.6 和 .NET Standard 1.3 中可以直接使用，但如果你在早期版本中提供了自己的实现，编译器将使用它。'
- en: The `nameof` operator provides refactoring-friendly and typo-safe access to
    names within your C# code.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nameof` 运算符提供了对 C# 代码中名称的重构友好和拼写安全的访问。'
- en: Chapter 10\. A smörgåsbord of features for concise code
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章。简洁代码的功能拼盘
- en: '|  |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Avoiding code clutter when referring to static members
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引用静态成员时避免代码杂乱
- en: Being more selective in importing extension methods
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导入扩展方法时更加选择性地使用
- en: Using extension methods in collection initializers
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集合初始化器中使用扩展方法
- en: Using indexers in object initializers
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象初始化器中使用索引器
- en: Writing far fewer explicit null checks
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式空检查要少得多
- en: Catching only exceptions you’re really interested in
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只捕获你真正感兴趣的异常
- en: '|  |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This chapter is a grab bag of features. No particular theme runs through it
    besides expressing your code’s intention in ever leaner ways. The features in
    this chapter are the ones left over when all the obvious ways of grouping features
    have been used. That doesn’t in any way undermine their usefulness, however.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一个杂烩，除了以更简洁的方式表达代码意图之外，没有特定的主题贯穿其中。本章中的功能是在使用所有明显的功能分组方式之后留下的。然而，这并不以任何方式削弱了它们的有用性。
- en: 10.1\. Using static directives
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 使用静态指令
- en: The first feature we’ll look at provides a simpler way of referring to static
    members of a type, including extension methods.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个功能提供了一种更简单的方式来引用类型的静态成员，包括扩展方法。
- en: 10.1.1\. Importing static members
  id: totrans-631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1. 导入静态成员
- en: The canonical example for this feature is `System.Math`, which is a static class
    and so has only static members. You’re going to write a method that converts from
    polar coordinates (an angle and a distance) to Cartesian coordinates (the familiar
    (x, y) model) using the more human-friendly degrees instead of radians to express
    the angle. [Figure 10.1](kindle_split_026_split_000.html#ch10fig01) gives a concrete
    example of how a single point is represented in both coordinate systems. Don’t
    worry if you’re not totally comfortable with the math part of this; it’s just
    an example that uses a lot of static members in a short piece of code.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的典型示例是 `System.Math`，它是一个静态类，因此只有静态成员。你将编写一个方法，将极坐标（一个角度和一个距离）转换为笛卡尔坐标（熟悉的
    (x, y) 模型），使用更人性化的度数而不是弧度来表示角度。[图10.1](kindle_split_026_split_000.html#ch10fig01)
    给出了在两种坐标系中如何表示一个点的具体示例。如果你对数学部分不是完全舒服，不要担心；它只是一个使用大量静态成员的简短代码示例。
- en: Figure 10.1\. An example of polar and Cartesian coordinates
  id: totrans-633
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1. 极坐标和笛卡尔坐标的示例
- en: '![](../Images/10fig01.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10fig01.jpg)'
- en: 'Assume that you already have a `Point` type representing Cartesian coordinates
    in a simple way. The conversion itself is fairly simple trigonometry:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经有一个 `Point` 类型，它以简单的方式表示笛卡尔坐标。转换本身相当简单，是三角学：
- en: Convert the angle from degrees into radians by multiplying it by π/180\. The
    constant π is available via `Math.PI`.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将角度乘以 π/180 转换为弧度。常数 π 通过 `Math.PI` 提供。
- en: Use the `Math.Cos` and `Math.Sin` methods to work out the `x` and `y` components
    of a point with magnitude 1, and multiply up.
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Math.Cos` 和 `Math.Sin` 方法来计算具有大小 1 的点的 `x` 和 `y` 分量，并相乘。
- en: The following listing shows the complete method with the uses of `System.Math`
    in bold. I’ve omitted the class declaration for convenience. It could be in a
    `CoordinateConverter` class, or it could be a factory method in the `Point` type
    itself.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了包含 `System.Math` 使用情况的完整方法，粗体文本突出显示了这些使用情况。为了方便，省略了类声明。它可以在 `CoordinateConverter`
    类中，或者它可以是 `Point` 类型本身的工厂方法。
- en: Listing 10.1\. Polar-to-Cartesian conversion in C# 5
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. C# 5 中的极坐标到笛卡尔坐标转换
- en: '[PRE84]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1* Converts degrees into radians**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将角度转换为弧度**'
- en: '***2* Trigonometry to complete conversion**'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用三角函数完成转换**'
- en: Although this code isn’t terribly hard to read, you can imagine that as you
    write more math-related code, the repetition of `Math.` clutters the code considerably.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码并不难读，但你可以想象，随着你编写更多与数学相关的代码，`Math.` 的重复使用会大大增加代码的混乱。
- en: C# 6 introduced the *using static directive* to make this sort of code simpler.
    The following listing is equivalent to [listing 10.1](kindle_split_026_split_000.html#ch10ex01)
    but imports all the static members of `System .Math`.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6 引入了 *using static 指令* 以简化此类代码。以下列表与 [列表 10.1](kindle_split_026_split_000.html#ch10ex01)
    等效，但导入了 `System.Math` 的所有静态成员。
- en: Listing 10.2\. Polar-to-Cartesian conversion in C# 6
  id: totrans-645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. C# 6 中的极坐标到笛卡尔坐标转换
- en: '[PRE85]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Converts degrees into radians**'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将角度转换为弧度**'
- en: '***2* Trigonometry to complete conversion**'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用三角函数完成转换**'
- en: 'As you can see, the syntax for a `using static` directive is simple:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`using static` 指令的语法很简单：
- en: '[PRE86]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'With that in place, all the following members are available directly by using
    their simple names rather than having to qualify them with the type:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，所有以下成员都可以通过使用它们的简单名称直接使用，而无需用类型限定：
- en: Static fields and properties
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态字段和属性
- en: Static methods
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法
- en: Enum values
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举值
- en: Nested types
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类型
- en: The ability to use enum values directly is particularly useful in `switch` statements
    and anywhere you combine enum values. The following side-by-side example shows
    how to retrieve all the fields of a type with reflection. The text in bold highlights
    the code that can be removed with an appropriate `using static` directive.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用枚举值的能力在 `switch` 语句和任何结合枚举值的地方特别有用。以下并排示例展示了如何使用反射检索类型的所有字段。粗体文本突出显示了可以使用适当的
    `using static` 指令删除的代码。
- en: '| C# 5 code | With using static in C# 6 |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| C# 5 代码 | 使用 C# 6 中的 static |'
- en: '| --- | --- |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| using System.Reflection; ...'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '| 使用 System.Reflection; ...'
- en: var fields = type.GetFields(
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: var fields = type.GetFields(
- en: '**BindingFlags.**Instance &#124;'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '**BindingFlags.**Instance &#124;'
- en: '**BindingFlags.**Static &#124;'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**BindingFlags.**Static &#124;'
- en: '**BindingFlags.**Public &#124;'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '**BindingFlags.**Public &#124;'
- en: '**BindingFlags.**NonPublic) | using static System.Reflection.BindingFlags;
    ...'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**BindingFlags.**NonPublic) | 使用静态 System.Reflection.BindingFlags; ...'
- en: var fields = type.GetFields(
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: var fields = type.GetFields(
- en: Instance &#124; Static &#124; Public &#124; NonPublic); |
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: Instance &#124; Static &#124; Public &#124; NonPublic); |
- en: 'Similarly, a `switch` statement responding to specific HTTP status codes can
    be made simpler by avoiding the repetition of the enum type name in every case
    label:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以通过避免在每个情况标签中重复枚举类型名称来简化响应特定 HTTP 状态码的 `switch` 语句：
- en: '| C# 5 code | With using static in C# 6 |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| C# 5 代码 | 使用 C# 6 中的 static |'
- en: '| --- | --- |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| using System.Net;'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '| 使用 System.Net;'
- en: '...'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: switch (response.StatusCode)
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: switch (response.StatusCode)
- en: '{'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'case **HttpStatusCode.**OK:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 'case **HttpStatusCode.**OK:'
- en: '...'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'case **HttpStatusCode.**TemporaryRedirect:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 'case **HttpStatusCode.**TemporaryRedirect:'
- en: 'case **HttpStatusCode.**Redirect:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 'case **HttpStatusCode.**Redirect:'
- en: 'case **HttpStatusCode.**RedirectMethod:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 'case **HttpStatusCode.**RedirectMethod:'
- en: '...'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'case **HttpStatusCode.**NotFound:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 'case **HttpStatusCode.**NotFound:'
- en: '...'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'default:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: '... | } using static'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '... | } 使用静态'
- en: System.Net.HttpStatusCode;
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: System.Net.HttpStatusCode;
- en: '...'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: switch (response.StatusCode)
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: switch (response.StatusCode)
- en: '{'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 'case OK:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 'case OK:'
- en: '...'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'case TemporaryRedirect:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 'case TemporaryRedirect:'
- en: 'case Redirect:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 'case Redirect:'
- en: 'case RedirectMethod:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 'case RedirectMethod:'
- en: '...'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'case NotFound:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 'case NotFound:'
- en: '...'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'default:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 'default:'
- en: '...'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '} |'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '} |'
- en: 'Nested types are relatively rare in handwritten code, but they’re more common
    in generated code. If you use them even occasionally, the ability to import them
    directly in C# 6 can significantly declutter your code. As an example, my implementation
    of the Google Protocol Buffers serialization framework to C# generates nested
    types to represent nested messages declared in the original `.proto` file. One
    quirk is that the nested C# types are doubly nested to avoid naming collisions.
    Say you have an original `.proto` file with a message like this:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类型在手工编写的代码中相对较少，但在生成的代码中更为常见。即使偶尔使用它们，C# 6 直接导入它们的能力也可以显著清理你的代码。例如，我将 Google
    Protocol Buffers 序列化框架实现为 C# 的代码生成了嵌套类型来表示原始 `.proto` 文件中声明的嵌套消息。一个特点是嵌套的 C# 类型是双重嵌套的，以避免命名冲突。假设你有一个包含如下消息的原始
    `.proto` 文件：
- en: '[PRE87]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The code that’s generated has the following structure with a lot more other
    members, of course:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码具有以下结构，当然还有更多其他成员：
- en: '[PRE88]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'To refer to `Inner` from your code in C# 5, you had to use `Outer.Types.Inner`,
    which is painful. The double nesting became considerably less inconvenient with
    C# 6, where it becomes relegated to a single `using static` directive:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 C# 5 中从你的代码中引用 `Inner`，你必须使用 `Outer.Types.Inner`，这很痛苦。在 C# 6 中，双重嵌套变得相当不那么不便，因为它变成了单个
    `using static` 指令：
- en: '[PRE89]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In all these cases, the members that are available via the static imports are
    considered during member lookup only after other members have been considered.
    For example, if you have a static import of `System.Math` but you also have a
    `Sin` method declared in your class, a call to `Sin()` will find your `Sin` method
    rather than the one in `Math`.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，通过静态导入可用的成员仅在考虑了其他成员之后才在成员查找期间考虑。例如，如果你有一个 `System.Math` 的静态导入，但你的类中也声明了一个
    `Sin` 方法，那么对 `Sin()` 的调用将找到你的 `Sin` 方法而不是 `Math` 中的那个。
- en: '|  |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The imported type doesn’t have to be static**'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**导入的类型不必是静态的**'
- en: 'The `static` part of `using static` doesn’t mean that the type you import must
    be static. The examples shown so far have been, but you can import regular types,
    too. That lets you access the static members of those types without qualification:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '`using static` 的 `static` 部分并不意味着你导入的类型必须是静态的。到目前为止显示的示例都是这样的，但你也可以导入常规类型。这让你可以无条件地访问这些类型的静态成员：'
- en: '[PRE90]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* Access String.Join by its simple name**'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过简单名称访问 String.Join**'
- en: I haven’t found this to be as useful as the earlier examples, but it’s available
    if you want it. Any nested types are made available by their simple names, too.
    There’s one exception to the set of static members that’s imported with a `using
    static` directive that isn’t quite so straightforward, and that’s extension methods.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这并不像早期示例那样有用，但它可供使用。任何嵌套类型都可以通过它们的简单名称提供。有一个例外是 `using static` 指令导入的静态成员集，它并不那么直接，那就是扩展方法。
- en: '|  |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.1.2\. Extension methods and using static
  id: totrans-713
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 扩展方法和 using static
- en: One aspect of C# 3 that I was never keen on was the way extension methods were
    discovered. Importing a namespace and importing extension methods were both performed
    with a single `using` directive; there was no way of doing one without the other
    and no way of importing extension methods from a single type. C# 6 improves the
    situation, although some of the aspects I dislike couldn’t be fixed without breaking
    backward compatibility.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未特别热衷于 C# 3 中扩展方法发现的方式。导入命名空间和导入扩展方法都是通过单个 `using` 指令完成的；没有一种方法可以在不导入另一个的情况下完成，也没有一种方法可以从单个类型导入扩展方法。C#
    6 改善了这种情况，尽管一些我不喜欢的方面无法在不破坏向后兼容性的情况下修复。
- en: 'The two important ways in which extension methods and `using static` directives
    interact in C# 6 are easy to state but have subtle implications:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6 中扩展方法和 `using static` 指令交互的两种重要方式容易陈述，但具有微妙的影响：
- en: Extension methods from a single type can be imported with a `using static` directive
    for that type without importing any extension methods from the rest of the namespace.
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自单个类型的扩展方法可以使用该类型的 `using static` 指令导入，而无需从命名空间的其他部分导入任何扩展方法。
- en: Extension methods imported from a type aren’t available as if you were calling
    a regular static method like `Math.Sin`. Instead, you have to call them as if
    they were instance methods on the extended type.
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类型导入的扩展方法并不像调用常规静态方法（如 `Math.Sin`）那样可用。相反，你必须像调用扩展类型的实例方法一样调用它们。
- en: 'I’ll demonstrate the first point by using the most commonly used set of extension
    methods in all of .NET: the ones for LINQ. The `System.Linq.Queryable` class contains
    extension methods for `IQueryable<T>` accepting expression trees, and the `System.Linq.Enumerable`
    class contains extension methods for `IEnumerable<T>` accepting delegates. Because
    `IQueryable<T>` inherits from `IEnumerable<T>` with a regular `using` directive
    for `System.Linq`, you can use the extension methods accepting delegates on `IQueryable<T>`,
    although you usually don’t want to. The following listing shows how a `using static`
    directive for just `System.Linq.Queryable` means the extension methods in `System.Linq.Enumerable`
    aren’t picked up.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过使用在所有 .NET 中最常用的扩展方法集来演示第一个点：LINQ 的扩展方法。`System.Linq.Queryable` 类包含接受表达式树的
    `IQueryable<T>` 扩展方法，而 `System.Linq.Enumerable` 类包含接受委托的 `IEnumerable<T>` 扩展方法。由于
    `IQueryable<T>` 通过常规 `using` 指令继承自 `IEnumerable<T>`，因此你可以使用接受委托的 `IQueryable<T>`
    扩展方法，尽管你通常不想这样做。下面的列表显示了仅对 `System.Linq.Queryable` 使用 `using static` 指令意味着 `System.Linq.Enumerable`
    中的扩展方法不会被选中。
- en: Listing 10.3\. Selective importing of extension methods
  id: totrans-719
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3\. 选择性导入扩展方法
- en: '[PRE91]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* Creates an IQueryable<string>**'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建了一个 IQueryable<string>**'
- en: '***2* Creates a delegate and expression tree**'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建了一个委托和表达式树**'
- en: '***3* Valid: uses Queryable.Where**'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 有效：使用 Queryable.Where**'
- en: '***4* Invalid: no in-scope Where method accepts a delegate**'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 无效：Where 方法不接受委托**'
- en: One point that’s worth noting is that if you accidentally imported `System.Linq`
    with a regular `using` directive, such as to allow `query` to be explicitly typed,
    that would silently make the last line valid.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果你不小心使用常规的 `using` 指令导入了 `System.Linq`，例如为了允许 `query` 明确指定类型，那么这会静默地使最后一行有效。
- en: The impact of this change should be considered carefully by library authors.
    If you wish to include some extension methods but allow users to explicitly opt
    into them, I encourage the use of a separate namespace for that purpose. The good
    news is that you can now be confident that any users—at least those with C# 6—can
    be selective in which extension methods to import without you having to create
    many namespaces. For example, in Noda Time 2.0, I introduced a `NodaTime.Extensions`
    namespace with extension methods targeting many types. I expect that some users
    will want to import only a subset of those extension methods, so I split the method
    declarations into several classes, with each class containing methods extending
    a single type. In other cases, you may wish to split your extension methods along
    different lines. The important point is that you should consider your options
    carefully.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 库作者应仔细考虑这一变化的影响。如果你希望包含一些扩展方法但允许用户明确选择它们，我鼓励使用单独的命名空间。好消息是，你现在可以确信任何用户——至少是那些使用
    C# 6 的用户——可以选择性导入哪些扩展方法，而无需你创建许多命名空间。例如，在 Noda Time 2.0 中，我引入了一个 `NodaTime.Extensions`
    命名空间，其中包含针对许多类型的扩展方法。我预计一些用户可能只想导入这些扩展方法的一个子集，因此我将方法声明拆分成了几个类，每个类包含扩展单个类型的方法。在其他情况下，你可能希望根据不同的标准拆分你的扩展方法。重要的是，你应该仔细考虑你的选择。
- en: 'The fact that extension methods can’t be called as if they were regular static
    methods is also easily demonstrated using LINQ. [Listing 10.4](kindle_split_026_split_000.html#ch10ex04)
    shows this by calling the `Enumerable.Count` method on a sequence of strings:
    once in a valid way as an extension method, as if it were an instance method declared
    in `IEnumerable<T>`, and once attempting to use it as a regular static method.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法不能像常规静态方法那样被调用的事实，也可以通过 LINQ 轻易地演示。[列表 10.4](kindle_split_026_split_000.html#ch10ex04)
    通过在字符串序列上调用 `Enumerable.Count` 方法来展示这一点：一次以有效的方式作为扩展方法，就像在 `IEnumerable<T>` 中声明的实例方法一样，另一次尝试将其作为常规静态方法使用。
- en: Listing 10.4\. Attempting to call `Enumerable.Count` in two ways
  id: totrans-728
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 以两种方式尝试调用 `Enumerable.Count`
- en: '[PRE92]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1* Valid: calling Count as if it were an instance method**'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 有效：将 Count 作为实例方法调用**'
- en: '***2* Invalid: extension methods aren’t imported as regular static methods**'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 无效：扩展方法没有作为常规静态方法导入**'
- en: 'Effectively, the language is encouraging you to think of extension methods
    as different from other static methods in a way that it didn’t before. Again,
    this has an impact on library developers: converting a method that already existed
    in a static class into an extension method (by adding the `this` modifier to the
    first parameter) used to be a nonbreaking change. As of C# 6, that becomes a breaking
    change: callers who were importing the method with a `using static` directive
    would find that their code no longer compiled after the method became an extension
    method.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，语言正在鼓励你将扩展方法视为与其他静态方法不同的方式，这在之前是没有的。再次强调，这对库开发者有影响：将已经存在于静态类中的方法转换为扩展方法（通过在第一个参数上添加`this`修饰符）曾经是一个非破坏性更改。从C#
    6开始，这变成了一个破坏性更改：使用`using static`指令导入方法的调用者会发现，在方法成为扩展方法后，他们的代码不再编译。
- en: '|  |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Extension methods discovered via static imports aren’t preferred over extension
    methods discovered through namespace imports. If you make a method call that isn’t
    handled by regular method invocation, but multiple extension methods are applicable
    via imported namespaces or classes, overload resolution is applied as normal.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 通过静态导入发现的扩展方法并不比通过命名空间导入发现的扩展方法更受欢迎。如果你调用一个不是由常规方法调用处理的方法，但通过导入的命名空间或类有多个扩展方法适用，则应用重载解析。
- en: '|  |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Just like extension methods, object and collection initializers were largely
    added to the language as part of the bigger feature of LINQ. And just like extension
    methods, they’ve been tweaked in C# 6 to make them slightly more powerful.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 就像扩展方法一样，对象和集合初始化器主要是作为LINQ更大功能的一部分被添加到语言中的。就像扩展方法一样，它们在C# 6中经过了调整，使其变得更加强大。
- en: 10.2\. Object and collection initializer enhancements
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 对象和集合初始化器增强
- en: 'As a reminder, object and collection initializers were introduced in C# 3\.
    Object initializers are used to set properties (or, more rarely, fields) in newly
    created objects; collection initializers are used to add elements to newly created
    collections via the `Add` methods that the collection type supports. The following
    simple example shows initializing a Windows Forms `Button` with text and a background
    color as well as initializing a `List<int>` with three values:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，对象和集合初始化器是在C# 3中引入的。对象初始化器用于设置新创建对象中的属性（或更少的情况下，字段）；集合初始化器用于通过集合类型支持的`Add`方法向新创建的集合中添加元素。以下简单示例展示了如何使用文本和背景颜色初始化Windows
    Forms `Button`，以及如何使用三个值初始化`List<int>`：
- en: '[PRE93]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'C# 6 enhances both of these features and makes them slightly more flexible.
    These enhancements aren’t as globally useful as some of the other features in
    C# 6, but they’re still welcome additions. In both cases, the initializers have
    been expanded to include members that previously couldn’t be used there: object
    initializers can now use indexers, and collection initializers can now use extension
    methods.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6增强了这两个功能，并使它们稍微灵活一些。这些增强并不像C# 6中的其他一些功能那样具有全局性，但它们仍然是受欢迎的补充。在两种情况下，初始化器都被扩展，包括之前不能在那里使用的成员：对象初始化器现在可以使用索引器，集合初始化器现在可以使用扩展方法。
- en: 10.2.1\. Indexers in object initializers
  id: totrans-742
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1. 对象初始化器中的索引器
- en: Until C# 6, object initializers could invoke only property setters or set fields
    directly. C# 6 allows indexer setters to be invoked as well using the `[index]
    = value` syntax used to invoke them in regular code.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 6之前，对象初始化器只能调用属性设置器或直接设置字段。C# 6允许使用与常规代码中调用它们的相同语法`[index] = value`来调用索引设置器。
- en: 'To demonstrate this in a simple way, I’ll use `StringBuilder`. This would be
    a fairly unusual usage, but we’ll talk about best practices shortly. The example
    initializes a `StringBuilder` from an existing string (`"This text needs truncating"`),
    truncates the builder to a set length, and modifies the last character to a Unicode
    ellipsis (...). When printed to the console, the result is `"This text..."`. Before
    C# 6, you couldn’t have modified the last character within the initializer, so
    you would’ve ended up with something like this:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以简单的方式演示这一点，我将使用`StringBuilder`。这将会是一个相当不寻常的使用方式，但我们很快会讨论最佳实践。该示例从现有字符串（`"This
    text needs truncating"`）初始化`StringBuilder`，将构建器截断到设置的长度，并将最后一个字符修改为Unicode省略号（...）。当打印到控制台时，结果是`"This
    text..."`。在C# 6之前，你无法在初始化器中修改最后一个字符，所以你最终会得到类似这样的结果：
- en: '[PRE94]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1* Sets the Length property to truncate the builder**'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将Length属性设置为截断构建器**'
- en: '***2* Modifies the final character to “...”**'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将最后一个字符修改为“...”**'
- en: '***3* Makes sure the console will support Unicode**'
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 确保控制台支持 Unicode**'
- en: '***4* Prints out the builder content**'
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印出构建器的内容**'
- en: Given how little the initializer is giving you (a single property), I’d at least
    consider setting the length in a separate statement instead. C# 6 allows you to
    perform all the initialization you need in a single expression, because you can
    use the indexer within the object initializer. The following listing demonstrates
    this in a slightly contrived way.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到初始化器提供的很少（一个属性），我至少会考虑在单独的语句中设置长度。C# 6 允许你在单个表达式中执行所有需要的初始化，因为你可以使用对象初始化器中的索引器。以下列表以略微人为的方式展示了这一点。
- en: Listing 10.5\. Using an indexer in a `StringBuilder` object initializer
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. 在 `StringBuilder` 对象初始化器中使用索引器
- en: '[PRE95]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* Sets the Length property to truncate the builder**'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 Length 属性设置为截断构建器**'
- en: '***2* Modifies the final character to “...”**'
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将最后一个字符修改为“...”**'
- en: '***3* Makes sure the console will support Unicode**'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 确保控制台支持 Unicode**'
- en: '***4* Prints out the builder content**'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印出构建器的内容**'
- en: I deliberately chose to use `StringBuilder` here not because it’s the most obvious
    type containing an indexer but to make it clear that this is an *object* initializer
    rather than a *collection* initializer.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意选择在这里使用 `StringBuilder` 不是因为它是最明显包含索引器的类型，而是为了清楚地表明这是一个 *对象* 初始化器而不是 *集合*
    初始化器。
- en: 'You might have expected me to use a `Dictionary<,>` of some kind instead, but
    there’s a hidden danger here. If your code is correct, it’ll work as you’d expect,
    but I recommend sticking to using a collection initializer in most cases. To see
    why, let’s look at an example initializing two dictionaries: one using indexers
    in an object initializer and one using a collection initializer.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能预期我会使用某种 `Dictionary<,>` 来实现，但这里有一个隐藏的风险。如果你的代码是正确的，它将按预期工作，但我建议在大多数情况下坚持使用集合初始化器。为了了解原因，让我们看看初始化两个字典的例子：一个使用对象初始化器中的索引器，另一个使用集合初始化器。
- en: Listing 10.6\. Two ways of initializing a dictionary
  id: totrans-759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 初始化字典的两种方式
- en: '[PRE96]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* Regular collection initializer from C# 3**'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* C# 3 中的常规集合初始化器**'
- en: '***2* Object initializer with indexer in C# 6**'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* C# 6 中带有索引器的对象初始化器**'
- en: Superficially, these might look equivalent. When you have no duplicate keys,
    they’re equivalent, and I even prefer the appearance of the object initializer.
    But the dictionary indexer setter overwrites any existing entry with the same
    key, whereas the `Add` method throws an exception if the key already exists.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这些可能看起来是等效的。当你没有重复的键时，它们是等效的，我甚至更喜欢对象初始化器的样子。但是，字典索引器设置器会覆盖任何具有相同键的现有条目，而
    `Add` 方法如果键已存在则会抛出异常。
- en: '[Listing 10.6](kindle_split_026_split_000.html#ch10ex06) deliberately includes
    the `"B"` key twice. This is an easy mistake to make, usually as the result of
    copying and pasting a line and then forgetting to modify the key part. The error
    won’t be caught at compile time in either case, but at least with the collection
    initializer, it doesn’t do the wrong thing silently. If you have any unit tests
    that execute this piece of code—even if they don’t explicitly check the contents
    of the dictionary—you’re likely to find the bug quickly.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.6](kindle_split_026_split_000.html#ch10ex06) 故意包含了两次的 `"B"` 键。这是一个容易犯的错误，通常是由于复制粘贴一行然后忘记修改键部分而造成的。在两种情况下，错误都不会在编译时被捕获，但至少在集合初始化器中，它不会默默地做错事。如果你有任何执行此段代码的单元测试——即使它们没有明确检查字典的内容——你很可能会快速发现这个错误。'
- en: '|  |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Roslyn to the rescue?**'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '**Roslyn 来拯救？**'
- en: Being able to spot this bug at compile time would be better, of course. It should
    be possible to write an analyzer to spot this problem for both collection and
    object initializers. For object initializers using an indexer, it’s hard to imagine
    many cases where you’d legitimately want to specify the same constant indexer
    key multiple times, so popping up a warning seems entirely reasonable.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，能够在编译时发现这个错误会更好。应该能够编写一个分析器来检测集合和对象初始化器中的这个问题。对于使用索引器的对象初始化器，很难想象有多少合法的情况需要多次指定相同的常量索引器键，因此弹出警告似乎是完全合理的。
- en: I don’t know of any such analyzer yet, but I hope it’ll exist at some point.
    With that danger cleared, there’d be no reason not to use indexers with dictionaries.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道有这样的分析器，但我希望它最终会出现。清除了这个风险后，就没有理由不使用索引器与字典一起使用了。
- en: '|  |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'So when should you use an indexer in an object initializer rather than a collection
    initializer? You should do so in a few reasonably obvious cases, such as the following:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在什么情况下你应该在对象初始化器中使用索引器而不是集合初始化器呢？你应该在以下几种合理明显的情况下这样做：
- en: If you can’t use a collection initializer because the type doesn’t implement
    `IEnumerable` or doesn’t have suitable `Add` methods. (You can potentially introduce
    your own `Add` methods as extension methods, however, as you’ll see in the next
    section.) For example, `ConcurrentDictionary<,>` doesn’t have `Add` methods but
    does have an indexer. It has `TryAdd` and `AddOrUpdate` methods, but those aren’t
    used by the collection initializer. You don’t need to worry about concurrent updates
    to the dictionary while you’re in an object initializer, because only the initializing
    thread has any knowledge of the new dictionary.
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不能使用集合初始化器，因为类型没有实现 `IEnumerable` 或没有合适的 `Add` 方法。（然而，你可以作为扩展方法引入自己的 `Add`
    方法，正如你将在下一节中看到的。）例如，`ConcurrentDictionary<,>` 没有提供 `Add` 方法，但它有一个索引器。它有 `TryAdd`
    和 `AddOrUpdate` 方法，但这些方法不被集合初始化器使用。当你处于对象初始化器中时，你不需要担心字典的并发更新，因为只有初始化线程知道新的字典。
- en: If the indexer and the `Add` method would handle duplicate keys in the same
    way. Just because dictionaries follow the “throw on add, overwrite in the indexer”
    pattern doesn’t mean that all types do.
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果索引器和 `Add` 方法以相同的方式处理重复键。尽管字典遵循“在添加时抛出异常，在索引器中覆盖”的模式，但这并不意味着所有类型都这样做。
- en: If you’re genuinely trying to replace elements rather than adding them. For
    example, you might be creating one dictionary based on another and then replacing
    the value corresponding to a particular key.
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你真正试图替换元素而不是添加它们。例如，你可能基于另一个字典创建一个字典，然后替换特定键对应的值。
- en: Less clear-cut cases exist as well in which you need to balance readability
    against the possibility of the kind of error described previously. [Listing 10.7](kindle_split_026_split_000.html#ch10ex07)
    shows an example of a schemaless entity type with two regular properties, but
    that otherwise allows arbitrary key/value pairs for its data. You’ll then look
    at the options for how you might initialize an instance.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在一些不太明显的情况，你需要在这类错误的可能性与可读性之间进行权衡。[列表 10.7](kindle_split_026_split_000.html#ch10ex07)
    展示了一个具有两个常规属性的无模式实体类型的示例，但除此之外，它允许其数据具有任意键/值对。然后，你将查看初始化实例的选项。
- en: Listing 10.7\. A schemaless entity type with key properties
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.7\. 具有键属性的无模式实体类型
- en: '[PRE97]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Let’s consider two ways of initializing an entity for which you want to specify
    a parent key, the new entity’s key, and two properties (a name and location, just
    as simple strings). You can use a collection initializer but then set the other
    properties afterward or do the whole thing with an object initializer but risk
    typos in the keys. The following listing demonstrates both options.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑两种初始化实体的方法，对于这个实体，你需要指定一个父键、新实体的键以及两个属性（例如，一个名称和一个位置，就像简单的字符串）。你可以使用集合初始化器，然后之后设置其他属性，或者使用对象初始化器来完成整个操作，但可能会在键中出错。下面的列表展示了这两种选项。
- en: Listing 10.8\. Two ways of initializing a `SchemalessEntity`
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. 初始化 `SchemalessEntity` 的两种方式
- en: '[PRE98]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1* Specifies data properties with a collection initializer**'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用集合初始化器指定数据属性**'
- en: '***2* Specifies key properties separately**'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 分别指定键属性**'
- en: '***3* Specifies key properties in an object initializer**'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在对象初始化器中指定键属性**'
- en: '***4* Specifies data properties using indexers**'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用索引器指定数据属性**'
- en: Which of these approaches is better? The second looks a lot cleaner to me. I’d
    typically extract the name and location keys into string constants anyway, at
    which point the risk of accidentally using duplicate keys is at least reduced.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？对我来说，第二种看起来干净得多。我通常会提取名称和位置键到字符串常量中，这样至少可以减少意外使用重复键的风险。
- en: If you’re in control of a type like this, you can add extra members to allow
    you to use a collection initializer. You could add a `Properties` property that
    either exposes the dictionary directly or exposes a view over it. At that point,
    you could use a collection initializer to initialize `Properties` within an object
    initializer that also sets `Key` and `ParentKey`. Alternatively, you could provide
    a constructor that accepts the key and parent key, at which point you can make
    an explicit constructor call with those values and then specify the name and location
    properties with a collection initializer.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你控制着这样的类型，你可以添加额外的成员以允许你使用集合初始化器。你可以添加一个`Properties`属性，该属性可以直接暴露字典或暴露其视图。到那时，你可以在设置`Key`和`ParentKey`的对象初始化器中使用集合初始化器来初始化`Properties`。或者，你也可以提供一个接受键和父键的构造函数，在这种情况下，你可以使用这些值显式调用构造函数，然后使用集合初始化器指定名称和位置属性。
- en: 'This may feel like a huge amount of detail for a choice between using indexers
    in an object initializer or using a collection initializer as in previous versions.
    The point is that the choice is yours to make: no book will be able to give you
    simple rules to follow that give you a best answer in every case. Be aware of
    the pros and cons, and apply your own judgment.'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉像是选择在对象初始化器中使用索引器或使用与之前版本类似的集合初始化器时需要的大量细节。重点是选择权在你手中：没有一本书能给出简单的规则来指导你，让你在每种情况下都能得到最佳答案。要意识到利弊，并运用自己的判断。
- en: 10.2.2\. Using extension methods in collection initializers
  id: totrans-787
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2. 在集合初始化器中使用扩展方法
- en: 'A second change in C# 6 related to object and collection initializers concerns
    which methods are available in collection initializers. As a reminder, two conditions
    must be met in order to use a collection initializer with a type:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6中与对象和集合初始化器相关的第二个变化是关于在集合初始化器中可用的方法。提醒一下，为了使用与类型相关的集合初始化器，必须满足两个条件：
- en: The type must implement `IEnumerable`. I’ve found this to be an annoying restriction;
    sometimes I implement `IEnumerable` solely so I can use the type in collection
    initializers. But it is what it is. This restriction hasn’t changed in C# 6.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型必须实现`IEnumerable`。我发现这是一个令人烦恼的限制；有时我仅仅实现`IEnumerable`以便可以在集合初始化器中使用该类型。但就是这样。这个限制在C#
    6中没有改变。
- en: There must be a suitable `Add` method for every element in the collection initializer.
    Any elements that aren’t in curly braces are assumed to correspond to single-argument
    calls to `Add` methods. When multiple arguments are required, they must be in
    curly braces.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合初始化器中的每个元素都必须有一个合适的`Add`方法。任何不在花括号中的元素都假定是对`Add`方法的单参数调用。当需要多个参数时，它们必须放在花括号中。
- en: 'Occasionally, this can be a little restrictive. Sometimes you want to easily
    create a collection in a way that the `Add` methods supplied by the collection
    itself don’t support. The preceding conditions are still true in C# 6, but the
    definition of “suitable” in the second condition now includes extension methods.
    In some ways, this has simplified the transformation. Here’s a declaration using
    a collection initializer:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这可能会有些限制。有时你想要以`Add`方法提供者本身不支持的方式轻松地创建一个集合。在C# 6中，前面的条件仍然成立，但现在第二个条件中“合适”的定义包括了扩展方法。在某种程度上，这简化了转换。以下是一个使用集合初始化器的声明：
- en: '[PRE99]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'That declaration is essentially equivalent to this:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 该声明本质上等同于以下内容：
- en: '[PRE100]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The normal overload resolution is applied to work out what each of those method
    calls means. If that fails, the collection initializer won’t compile. With just
    the regular `List<T>`, the preceding code won’t compile, but if you add a single
    extension method it will:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的过载解析被用来确定每个方法调用意味着什么。如果这失败了，集合初始化器将无法编译。仅使用常规的`List<T>`，前面的代码将无法编译，但如果你添加一个单独的扩展方法，它就可以：
- en: '[PRE101]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'With this in place, the first and last calls to `Add` in our earlier code end
    up calling the extension method. The list ends up with five elements (`"10", "hello",
    "20", "20", "20"`), because the last `Add` call adds three elements. This is an
    unusual extension method, but it helps demonstrate three points:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们之前代码中`Add`的第一个和最后一个调用最终调用了扩展方法。列表最终包含五个元素（`"10", "hello", "20", "20",
    "20"`），因为最后一个`Add`调用添加了三个元素。这是一个不寻常的扩展方法，但它有助于说明三个要点：
- en: Extension methods can be used in collection initializers, which is the whole
    point of this section of the book.
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法可以在集合初始化器中使用，这正是本书这一节的主要内容。
- en: This isn’t a generic extension method; it works for only `List<string>`. This
    is a kind of specialization that couldn’t be performed in `List<T>` itself. (Generic
    extension methods are fine, too, so long as the type arguments can be inferred.)
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不是一个泛型扩展方法；它只适用于 `List<string>`。这是一种在 `List<T>` 本身中无法执行的特殊化。 (泛型扩展方法也很好，只要类型参数可以推断出来。)
- en: Optional parameters can be used in the extension methods; our first call to
    `Add` will effectively be compiled to `Add(10, 1)` because of the default value
    of the second parameter.
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法中可以使用可选参数；我们第一次调用 `Add` 将实际上被编译为 `Add(10, 1)`，因为第二个参数的默认值。
- en: Now that you know what you can do, let’s take a closer look at where it makes
    sense to use this feature.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了你可以做什么，让我们更仔细地看看在哪里使用这个特性是有意义的。
- en: Creating other general-purpose Add signatures
  id: totrans-802
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建其他通用 Add 签名
- en: One technique I’ve found useful in my work with Protocol Buffers is to create
    `Add` methods accepting collections. This process is like using `AddRange` but
    it can be used in collection initializers. This is particularly useful within
    object initializers in which the property you’re initializing is read-only but
    you want to add the results of a LINQ query.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的 Protocol Buffers 工作中发现的一个有用技术是创建接受集合的 `Add` 方法。这个过程类似于使用 `AddRange`，但它可以在集合初始化器中使用。这在对象初始化器中尤其有用，其中你正在初始化的属性是只读的，但你希望添加
    LINQ 查询的结果。
- en: 'For example, consider a `Person` class with a read-only `Contacts` property
    that you want to populate with all the contacts from another list who live in
    Reading. In Protocol Buffers, the `Contacts` property would be of type `RepeatedField<Person>`,
    and `RepeatedField<T>` has the appropriate `Add` method, allowing you to use a
    collection initializer:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个 `Person` 类，它有一个只读的 `Contacts` 属性，你希望用居住在 Reading 的所有联系人填充它。在 Protocol
    Buffers 中，`Contacts` 属性的类型将是 `RepeatedField<Person>`，而 `RepeatedField<T>` 有适当的
    `Add` 方法，允许你使用集合初始化器：
- en: '[PRE102]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'It can take a little getting used to, but then it’s extremely useful and certainly
    beats having to call `jon.Contacts.AddRange(...)` separately. But what if you
    weren’t using Protocol Buffers, and `Contacts` was exposed only as `List<Person>`
    instead? With C# 6, that’s not a problem: you can create an extension method for
    `List<T>` that adds an overload of `Add` accepting an `IEnumerable<T>` and calling
    `AddRange` with it, as shown in the following listing.'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一点时间来适应，但一旦适应了，它就极其有用，并且绝对比单独调用 `jon.Contacts.AddRange(...)` 更好。但如果你没有使用
    Protocol Buffers，并且 `Contacts` 只作为 `List<Person>` 公开呢？在 C# 6 中，这不成问题：你可以为 `List<T>`
    创建一个扩展方法，它添加了一个接受 `IEnumerable<T>` 的 `Add` 重载，并用它来调用 `AddRange`，如下所示。
- en: Listing 10.9\. Exposing explicit interface implementations via extension methods
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. 通过扩展方法公开显式接口实现
- en: '[PRE103]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: With that extension method in place, the earlier code works fine even with `List<T>`.
    If you wanted to be broader still, you could write an extension method targeting
    `IList<T>` instead, although if you went down that route, you’d need to write
    the loop within the method body because `IList<T>` doesn’t have an `AddRange`
    method.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在有了这个扩展方法之后，之前的代码即使在 `List<T>` 中也能正常工作。如果你想更广泛一些，你可以编写一个针对 `IList<T>` 的扩展方法，尽管如果你选择这条路，你需要在方法体中编写循环，因为
    `IList<T>` 没有提供 `AddRange` 方法。
- en: Creating specialized Add signatures
  id: totrans-810
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建专门的 Add 签名
- en: Suppose you have a `Person` class, as shown earlier, with a `Name` property,
    and within one area of code you do a lot of work with `Dictionary<string, Person>`
    objects, always indexing the `Person` objects by name. Adding entries to the dictionary
    with a simple call to `dictionary.Add(person)` can be convenient, but `Dictionary<string,
    Person>` doesn’t, as a type, know that you’re indexing by name. What are your
    choices?
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个 `Person` 类，如前所述，它有一个 `Name` 属性，并且在某个代码区域中你经常使用 `Dictionary<string, Person>`
    对象，总是按名称索引 `Person` 对象。通过简单的调用 `dictionary.Add(person)` 向字典中添加条目可能是方便的，但 `Dictionary<string,
    Person>` 作为一种类型，并不知道你是在按名称索引。你的选择是什么？
- en: You could create a class derived from `Dictionary<string, Person>` and add an
    `Add(Person)` method to it. That doesn’t appeal to me, because you’re not specializing
    the behavior of the dictionary in any meaningful way; you’re just making it more
    convenient to use.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个从 `Dictionary<string, Person>` 派生的类，并向其中添加一个 `Add(Person)` 方法。但这对我来说没有吸引力，因为你并没有以任何有意义的方面来专门化字典的行为；你只是让它更方便使用。
- en: You could create a more general class implementing `IDictionary<TKey, TValue>`
    that accepts a delegate explaining the mapping from `TValue` to `TKey` and implement
    that via composition. That could be useful but may be overkill for this one task.
    Finally, you could create an extension method for this one specific case, as shown
    in the following listing.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个更通用的类，实现 `IDictionary<TKey, TValue>`，它接受一个委托来解释从 `TValue` 到 `TKey` 的映射，并通过组合来实现。这可能很有用，但可能对于这个任务来说有点过度。最后，你可以为这个特定情况创建一个扩展方法，如下面的列表所示。
- en: Listing 10.10\. Adding a type-argument-specific `Add` method for dictionaries
  id: totrans-814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 为字典添加特定类型参数的 `Add` 方法
- en: '[PRE104]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'That already would’ve been a good option before C# 6, but the combination of
    using the `using static` feature to limit the way extension methods are imported
    along with the use of extension methods in collection initializers makes it more
    compelling. You can then initialize a dictionary without any repetition of the
    name:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 之前，这已经是一个不错的选择，但使用 `using static` 功能来限制扩展方法导入的方式以及使用扩展方法在集合初始化器中的使用使得它更具吸引力。然后你可以初始化一个字典，而不需要重复名称：
- en: '[PRE105]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: An important point here is how you’ve specialized the API for one particular
    combination of type arguments to `Dictionary<,>` but without changing the type
    of object you’re creating. No other code needs to be aware of the specialization
    here, because it’s only superficial; it exists only for our convenience rather
    than being part of an object’s inherent behavior.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要观点是，你如何专门化了一个特定类型参数组合的 API，但没有改变你创建的对象的类型。其他代码不需要知道这里的专门化，因为它只是表面的；它只存在于我们的方便，而不是对象固有行为的一部分。
- en: '|  |'
  id: totrans-819
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This approach has downsides as well, one of which is that nothing prevents an
    entry from being added by using something other than a person’s name. As ever,
    I encourage you to think through the pros and cons for yourself; don’t blindly
    trust my advice or anyone else’s.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也有缺点，其中之一是没有任何东西可以阻止使用除人名之外的东西添加条目。一如既往，我鼓励你自己思考利弊；不要盲目相信我的建议或任何人的建议。
- en: '|  |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Reexposing existing methods “hidden” by explicit interface implementation
  id: totrans-823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重新公开由显式接口实现“隐藏”的现有方法
- en: In [section 10.2.1](kindle_split_026_split_000.html#ch10lev2sec3), I used `ConcurrentDictionary<,>`
    as an example of where you might want to use an indexer instead of a collection
    initializer. Without any extra help, you can’t use a collection initializer because
    no `Add` method is exposed. But `ConcurrentDictionary<,>` does have an `Add` method;
    it’s just that it uses explicit interface implementation to implement `IDictionary<,>.Add`.
    Usually, if you want to access a member that uses explicit interface implementation,
    you have to cast to the interface—but you can’t do that in a collection initializer.
    Instead, you can expose an extension method, as shown in the following listing.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10.2.1 节](kindle_split_026_split_000.html#ch10lev2sec3) 中，我使用了 `ConcurrentDictionary<,>`
    作为你可能想使用索引器而不是集合初始化器的例子。没有额外的帮助，你不能使用集合初始化器，因为没有暴露 `Add` 方法。但 `ConcurrentDictionary<,>`
    确实有一个 `Add` 方法；只是它使用显式接口实现来实现 `IDictionary<,>.Add`。通常，如果你想访问使用显式接口实现的成员，你必须将其转换为接口——但在集合初始化器中你不能这样做。相反，你可以公开一个扩展方法，如下面的列表所示。
- en: Listing 10.11\. Exposing explicit interface implementations via extension methods
  id: totrans-825
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11\. 通过扩展方法公开显式接口实现
- en: '[PRE106]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'At first glance, this looks completely pointless. It’s an extension method
    to call a method with exactly the same signature. But this effectively works around
    explicit interface implementation, making the `Add` method always available, including
    in collection initializers. You can now use a collection initializer for `ConcurrentDictionary<,>`:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎完全没有意义。这是一个扩展方法，用于调用具有完全相同签名的函数。但这种方法实际上绕过了显式接口实现，使得 `Add` 方法始终可用，包括在集合初始化器中。现在你可以为
    `ConcurrentDictionary<,>` 使用集合初始化器：
- en: '[PRE107]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'This should be used cautiously, of course. When a method is obscured by explicit
    interface implementation, that’s often meant to discourage you from calling it
    without a certain amount of care. This is where the ability to selectively import
    extension methods with `using static` is useful: you could have a namespace of
    static classes with extension methods that are meant to be used only selectively
    and import just the relevant class in each case. Unfortunately, it still exposes
    the `Add` method to the rest of the code in the same class, but again you need
    to weigh whether that’s worse than the alternatives.'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这应该谨慎使用。当一个方法被显式接口实现所掩盖时，这通常意味着它需要你小心地调用，而不需要一定的谨慎。这就是使用 `using static` 选择性导入扩展方法的能力所在：你可以有一个只打算选择性使用的静态类命名空间，并且只为每个情况导入相关的类。不幸的是，它仍然将
    `Add` 方法暴露给同一类中的其余代码，但再次强调，你需要权衡这是否比其他选择更糟糕。
- en: The extension method in [listing 10.11](kindle_split_026_split_000.html#ch10ex11)
    is broad, extending all dictionaries. You could decide to target only `ConcurrentDictionary<,>`
    instead to avoid inadvertently using an explicitly implemented `Add` method from
    another dictionary type.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.11](kindle_split_026_split_000.html#ch10ex11) 中的扩展方法很广泛，扩展了所有字典。你可以决定只针对
    `ConcurrentDictionary<,>` 进行目标定位，以避免无意中使用来自其他字典类型的显式实现的 `Add` 方法。'
- en: 10.2.3\. Test code vs. production code
  id: totrans-831
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3\. 测试代码与生产代码
- en: You’ve probably noticed a lot of caveats in this section. Few clear-cut cases
    exist that enable you to “definitely use it here” with respect to these features.
    But most of the downsides I’ve noted are in terms of areas where the feature is
    convenient in one piece of code but you don’t want it infecting other places.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了本节中有许多注意事项。很少有明确的案例可以让你“肯定在这里使用”这些功能。但大多数我提到的缺点都是在这样一个领域，即该功能在某个代码片段中很方便，但你不想让它影响到其他地方。
- en: 'My experience is that object and collection initializers are usually used in
    two places:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 我的经验是，对象和集合初始化器通常用于两个地方：
- en: Static initializers for collections that’ll never be modified after type initialization
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型初始化后永远不会被修改的集合的静态初始化器
- en: Test code
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码
- en: The concerns around exposure and correctness still apply for static initializers
    but much less so for test code. If you decide that in your test assemblies it’s
    handy to have `Add` extension methods to make collection initializers simpler,
    that’s fine. It won’t impact your production code at all. Likewise, if you use
    indexers in your collection initializers for tests and accidentally set the same
    key twice, chances are high that your tests will fail. Again, the downside is
    minimized.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 关于暴露和正确性的担忧仍然适用于静态初始化器，但对于测试代码来说则少得多。如果你决定在你的测试程序集中使用`Add`扩展方法来简化集合初始化，那是可以的。这根本不会影响你的生产代码。同样，如果你在测试中的集合初始化器中使用了索引器，并且不小心设置了相同的键两次，那么你的测试很可能失败。再次强调，缺点被最小化了。
- en: This isn’t a distinction that affects only this pair of features. Test code
    should still be of high quality, but how you measure that quality and the impact
    of making any particular trade-off is different for test code as compared to production
    code, particularly for public APIs.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是只影响这对功能的区别。测试代码仍然应该是高质量的，但与生产代码相比，衡量这种质量以及做出任何特定权衡的影响对于测试代码来说是不同的，尤其是对于公共API。
- en: 'The addition of extension methods as part of LINQ encouraged a more fluent
    approach to composing multiple operations. Instead of using multiple statements,
    in many cases it’s now idiomatic to chain multiple method calls together in a
    single statement. That’s what LINQ queries end up doing all the time, but it became
    a more idiomatic pattern with APIs such as LINQ to XML. This can lead to the same
    problem we’ve had for a long time when chaining property accesses together: everything
    breaks as soon as you encounter a null value. C# 6 allows you terminate one of
    these chains safely at that point instead of the code blowing up with an exception.'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 中作为一部分添加的扩展方法鼓励了一种更流畅的方法来组合多个操作。在许多情况下，现在更习惯于在一个语句中链接多个方法调用，而不是使用多个语句。这正是
    LINQ 查询一直所做的，但随着 LINQ to XML 等API的出现，这成为一种更习惯的模式。这可能导致我们长期以来在链接属性访问时遇到的问题：一旦遇到空值，一切都会崩溃。C#
    6 允许你在这个点上安全地终止这些链之一，而不是让代码因为异常而崩溃。
- en: 10.3\. The null conditional operator
  id: totrans-839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 空值条件运算符
- en: I’m not going to go into the merits of nullity, but it’s something we often
    have to live with, along with complex object models with properties several levels
    deep. The C# language team has been thinking for a long time about making nullity
    easier to work with. Some of that work is still in progress, but C# 6 has taken
    one step along the way. Again, it can make your code much shorter and simpler,
    expressing how you want to handle nullity without having to repeat expressions
    everywhere.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨空值的优点，但这是我们经常不得不忍受的事情，包括具有多层属性的复杂对象模型。C#语言团队长期以来一直在思考如何使空值更容易处理。其中一些工作仍在进行中，但C#
    6已经迈出了第一步。再次强调，它可以让你编写的代码更短、更简单，表达你如何处理空值，而无需在各个地方重复表达式。
- en: 10.3.1\. Simple and safe property dereferencing
  id: totrans-841
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1. 简单且安全的属性解引用
- en: 'As a working example, let’s suppose you have a `Customer` type with a `Profile`
    property that has a `DefaultShippingAddress` property, which has a `Town` property.
    Now let’s suppose you want to find all customers within a collection whose default
    shipping address has Reading as a town name. Without worrying about nullity, you
    could use this:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个工作示例，让我们假设你有一个具有`Profile`属性的`Customer`类型，该`Profile`属性又有一个`DefaultShippingAddress`属性，它有一个`Town`属性。现在假设你想要找到所有默认发货地址的城镇名为Reading的顾客。无需担心空值，你可以使用以下方法：
- en: '[PRE108]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'That works fine if you know that every customer has a profile, every profile
    has a default shipping address, and every address has a town. But what if any
    of those is null? You’ll end up with a `NullReferenceException` when you probably
    just want to exclude that customer from the results. Previously, you’d have to
    rewrite this as something horrible, checking each property for nullity one at
    a time by using the short-circuiting `&&` operator:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道每个顾客都有一个配置文件，每个配置文件都有一个默认的发货地址，每个地址都有一个城镇，那么这会工作得很好。但如果其中任何一个为空呢？当你可能只想排除该顾客时，你将遇到`NullReferenceException`。以前，你必须将这段代码重写为一些糟糕的东西，通过使用短路`&&`操作符逐个检查每个属性的空值：
- en: '[PRE109]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Yeesh. So much repetition. It gets even worse if you need to make a method
    call at the end rather than using `==` (which already handles null correctly,
    at least for references; see [section 10.3.3](kindle_split_026_split_000.html#ch10lev2sec8)
    for possible surprises). So how does C# 6 improve this? It introduces the *null
    conditional ?.* operator, which is a short-circuiting operator that stops if the
    expression evaluates to null. A null-safe version of the query is as follows:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。重复太多了。如果你需要在最后进行方法调用而不是使用`==`（它已经正确处理了空值，至少对于引用来说是这样；参见[第10.3.3节](kindle_split_026_split_000.html#ch10lev2sec8)以了解可能的惊喜），情况会更糟。那么C#
    6是如何改进这一点的呢？它引入了*空条件 ?.* 操作符，这是一个短路操作符，如果表达式评估为空值，则会停止。查询的空安全版本如下：
- en: '[PRE110]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This is exactly the same as our first version but with two uses of the null-conditional
    operator. If either `c.Profile` or `c.Profile.DefaultShippingAddress` is null,
    the whole expression on the left side of `==` evaluates to null. You may be asking
    yourself why you have only two uses, when four things are potentially null:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们的第一个版本完全相同，但使用了两次空条件操作符。如果`c.Profile`或`c.Profile.DefaultShippingAddress`中的任何一个为空，那么`==`左侧的表达式将评估为空。你可能想知道为什么只有两个使用，而四个东西都可能为空：
- en: '`c`'
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`'
- en: '`c.Profile`'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c.Profile`'
- en: '`c.Profile.DefaultShippingAddress`'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c.Profile.DefaultShippingAddress`'
- en: '`c.Profile.DefaultShippingAddress.Town`'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c.Profile.DefaultShippingAddress.Town`'
- en: I’ve assumed that all the elements of `allCustomers` are non-null references.
    If you needed to handle the possibility of null elements there, you could use
    `c?.Profile` at the start instead. That covers the first bullet; the `==` operator
    already handles null operands, so you don’t need to worry about the last bullet.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经假设`allCustomers`中的所有元素都是非空引用。如果你需要处理空元素的可能性，你可以在开始时使用`c?.Profile`。这涵盖了第一个要点；`==`操作符已经处理了空操作数，所以你不需要担心最后一个要点。
- en: 10.3.2\. The null conditional operator in more detail
  id: totrans-854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2. 空条件操作符的详细说明
- en: This brief example shows only properties, but the null conditional operator
    can also be used to access methods, fields, and indexers. The basic rule is that
    when a null conditional operator is encountered, the compiler injects a nullity
    check on the value to the left of the `?`. If the value is null, evaluation stops
    and the result of the overall expression is null. Otherwise, evaluation continues
    with the property, method, field, or index access to the right of the `?` without
    reevaluating the first part of the expression. If the type of the overall expression
    would be a non-nullable value type without the null conditional operator, it becomes
    the nullable equivalent if a null conditional operator is involved anywhere in
    the sequence.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的例子只展示了属性，但空条件操作符也可以用来访问方法、字段和索引器。基本规则是，当遇到空条件操作符时，编译器会在`?`左侧的值上注入一个空值检查。如果该值为空，则评估停止，整个表达式的结果是空。否则，评估会继续进行，使用`?`右侧的属性、方法、字段或索引访问，而不会重新评估表达式的第一部分。如果整个表达式的类型在没有空条件操作符的情况下将是一个不可为空的值类型，那么如果序列中任何地方涉及空条件操作符，它就变成了可空等效类型。
- en: 'The overall expression here—the part where evaluation stops abruptly if a null
    value is encountered—is basically the sequence of property, field, indexer, and
    method access involved. Other operators, such as comparisons, break the sequence
    because of precedence rules. To demonstrate this, let’s have a closer look at
    the condition for the `Where` method in [section 10.3.1](kindle_split_026_split_000.html#ch10lev2sec6).
    Our lambda expression was as follows:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 这里整体的表达式——遇到空值时评估突然停止的部分——基本上是涉及属性、字段、索引器和方法访问的序列。其他操作符，如比较操作符，由于优先级规则而中断序列。为了演示这一点，让我们更仔细地看看[第10.3.1节](kindle_split_026_split_000.html#ch10lev2sec6)中`Where`方法的条件。我们的lambda表达式如下：
- en: '[PRE111]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The compiler treats this roughly as if you’d written this:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器大致将其处理为如果你这样写：
- en: '[PRE112]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Notice how each property access (which I’ve highlighted in bold) occurs only
    once. In our pre-C# 6 version checking for null, you’d potentially evaluate `c.Profile`
    three times and `c.Profile.DefaultShippingAddress` twice. If those evaluations
    depended on data being mutated by other threads, you could be in trouble: you
    could pass the first two nullity tests and still fail with a `NullReferenceException`.
    The C# code is safer and more efficient because you’re evaluating everything only
    once.'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个属性访问（我在粗体中突出显示）只发生一次。在我们C# 6之前的版本中检查空值时，你可能会评估`c.Profile`三次，以及`c.Profile.DefaultShippingAddress`两次。如果这些评估依赖于其他线程修改的数据，你可能会遇到麻烦：你可能会通过前两个空值测试，但仍然因为`NullReferenceException`而失败。C#代码更安全、更高效，因为你只评估一次。
- en: 10.3.3\. Handling Boolean comparisons
  id: totrans-861
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3. 处理布尔比较
- en: 'Currently, you’re still performing the comparison at the end with the `==`
    operator; that isn’t short-circuited away if anything is null. Suppose you want
    to use the `Equals` method instead and write this:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你仍然在末尾使用`==`操作符进行比较；如果任何内容为空，则不会短路。假设你想使用`Equals`方法并编写如下：
- en: '[PRE113]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Unfortunately, this doesn’t compile. You’ve added a third null conditional operator,
    so you don’t call `Equals` if you have a shipping address with a `Town` property
    of null. But now the overall result is `Nullable<bool>` instead of `bool`, which
    means our lambda expression isn’t suitable for the `Where` method yet.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这无法编译。你添加了第三个空条件操作符，所以如果你有一个具有空`Town`属性的运输地址，你不会调用`Equals`。但现在整体结果是`Nullable<bool>`而不是`bool`，这意味着我们的lambda表达式还不适合`Where`方法。
- en: 'This is a pretty common occurrence with the null conditional operator. Anytime
    you use the null conditional operator in any kind of condition, you need to consider
    three possibilities:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 这在空条件操作符中是一个相当常见的情况。任何你在任何条件中使用空条件操作符的时候，都需要考虑三种可能性：
- en: Every part of the expression is evaluated, and the result is true.
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式的每一部分都会被评估，结果是真的。
- en: Every part of the expression is evaluated, and the result is false.
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式的每一部分都会被评估，结果是假的。
- en: The expression short-circuited because of a null value, and the result is null.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于空值，表达式短路了，结果是空。
- en: 'Usually, you want to collapse those three possibilities down to two by making
    the third option map to a true or false result. There are two common ways of doing
    this: comparing against a `bool` constant or using the null coalescing `??` operator.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望将这三个可能性合并为两个，使第三个选项映射为真或假的结果。有两种常见的方法来做这件事：比较一个`bool`常量或使用空合并`??`操作符。
- en: '|  |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Language design choices for nullable Boolean comparisons**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '**可空布尔比较的语言设计选择**'
- en: The behavior of `bool?` in comparisons with non-nullable values caused concern
    for the language designers in the C# 2 time frame. The fact that `x == true` and
    `x != false` are both valid but with different meanings if `x` is a `bool?` variable
    can be pretty surprising. (If `x` is null, `x == true` evaluates to `false`, and
    `x != false` evaluates to `true`.)
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 2版本中，`bool?`与不可为null的值进行比较时的行为让语言设计者感到担忧。当`x`是一个`bool?`变量时，`x == true`和`x
    != false`都是有效的，但具有不同的含义，这可能会让人感到惊讶。（如果`x`为null，`x == true`评估为`false`，而`x != false`评估为`true`。）
- en: Was it the right design choice? Maybe. Often all the choices available are unpleasant
    in one respect or other. It won’t change now, though, so it’s best to be aware
    of it and write code as clearly as possible for readers who may be less aware.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否是正确的设计选择？也许吧。通常，所有可用的选择在某个方面都是不愉快的。不过，现在改变已经不可能了，所以最好对此有所了解，并为可能不太了解的读者尽可能清晰地编写代码。
- en: '|  |'
  id: totrans-874
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To simplify our example, let’s suppose you already have a variable called `name`
    containing the relevant string value, but it can be null. You want to write an
    `if` statement and execute the body of the statement if the town is X based on
    the `Equals` method. This is the simplest way of demonstrating a condition: in
    real life, you could be conditionally accessing a Boolean property, for example.
    [Table 10.1](kindle_split_026_split_000.html#ch10table01) shows the options you
    can use depending on whether you also want to enter the body of the statement
    if `name` is null.'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化示例，让我们假设你已经有了一个名为`name`的变量，它包含相关的字符串值，但它可以是null。你想要编写一个`if`语句，并根据`Equals`方法，如果城镇是X，则执行语句的主体。这是演示条件的最简单方式：在现实生活中，你可能会条件性地访问一个布尔属性，例如。[表10.1](kindle_split_026_split_000.html#ch10table01)显示了你可以使用的选项，具体取决于你是否还希望在`name`为null时进入语句的主体。
- en: Table 10.1\. Options for performing Boolean comparisons using the null conditional
    operator
  id: totrans-876
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1\. 使用空条件运算符执行布尔比较的选项
- en: '| You don’t want to enter the body if name is null | You do want to enter the
    body if name is null |'
  id: totrans-877
  prefs: []
  type: TYPE_TB
  zh: '| 如果名称为空，则不希望进入主体 | 如果名称为空，则希望进入主体 |'
- en: '| --- | --- |'
  id: totrans-878
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| if (name?.Equals("X") ?? false) | if (name?.Equals("X") == true) |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
  zh: '| if (name?.Equals("X") ?? false) | if (name?.Equals("X") == true) |'
- en: '| if (name?.Equals("X") ?? true) | if (name?.Equals("X") != false) |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
  zh: '| if (name?.Equals("X") ?? true) | if (name?.Equals("X") != false) |'
- en: I prefer the null coalescing operator approach; I read it as “try to perform
    the comparison, but default to the value after the `??` if you have to stop early.”
    After you understand that the type of the expression (`name?.Equals("X")` in this
    case) is `Nullable<bool>`, nothing else is new here. It just so happens that you’re
    much more likely to come up against this case than you were before the null conditional
    operator became available.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢空合并运算符的方法；我把它读作“尝试执行比较，但如果需要提前停止，则默认使用`??`后面的值。”在你理解了表达式的类型（在这种情况下是`name?.Equals("X")`）是`Nullable<bool>`之后，这里就没有什么新的内容了。只是碰巧，你现在遇到这种情况的可能性比空条件运算符可用之前要大得多。
- en: 10.3.4\. Indexers and the null conditional operator
  id: totrans-882
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.4\. 索引器和空条件运算符
- en: 'As I mentioned earlier, the null conditional operator works for indexers as
    well as for fields, properties, and methods. The syntax is again just adding a
    question mark, but this time before the opening square bracket. This works for
    array access as well as user-defined indexers, and again the result type becomes
    nullable if it would otherwise be a non-nullable value type. Here’s a simple example:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，空条件运算符不仅适用于索引器，还适用于字段、属性和方法。语法再次是添加一个问号，但这次是在开方括号之前。这对于数组访问以及用户定义的索引器都适用，并且如果结果类型原本是一个不可为null的值类型，则结果类型变为可空的。以下是一个简单的示例：
- en: '[PRE114]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: There’s not a lot more to say about how the null-conditional operator works
    with indexers; it’s as simple as that. I haven’t found this to be nearly as useful
    as working with properties and methods, but it’s still good to know that it’s
    there, as much for consistency as anything else.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 关于空条件运算符与索引器的工作方式，没有太多可说的；就是这样简单。我没有发现这像与属性和方法一起使用那样有用，但了解它的存在仍然很好，这不仅是为了保持一致性。
- en: 10.3.5\. Working effectively with the null conditional operator
  id: totrans-886
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.5\. 高效使用空条件运算符
- en: You’ve already seen that the null conditional operator is useful when working
    with object models with properties that may or may not be null, but other compelling
    use cases exist. We’ll look at two of them here, but this isn’t an exhaustive
    list, and you may come up with additional novel uses yourself.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，当与可能为 null 或不为 null 的属性的对象模型一起工作时，空条件运算符非常有用，但还存在其他令人信服的使用案例。在这里，我们将探讨其中的两个，但这并不是一个详尽的列表，你自己也可能想出额外的创新用法。
- en: Safe and convenient event raising
  id: totrans-888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安全且方便的事件引发
- en: 'The pattern for raising an event safely even in the face of multiple threads
    has been well known for many years. For example, to raise a field-like `Click`
    event of type `EventHandler`, you’d write code like this:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在多线程的情况下安全引发事件的模式已经为人所熟知多年。例如，为了引发类似于字段的 `Click` 事件，类型为 `EventHandler`，你会编写如下代码：
- en: '[PRE115]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Two aspects are important here:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的方面：
- en: You’re not just calling `Click(this, EventArgs.Empty),` because `Click` might
    be null. (That would be the case if no handler was subscribed to the event.)
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不只是调用 `Click(this, EventArgs.Empty),`，因为 `Click` 可能是 null。（如果没有处理器订阅该事件，就会是这样。）
- en: You’re copying the value of the `Click` field to a local variable first so that
    even if it changes in another thread after you’ve checked for nullity, you still
    have a non-null reference. You may invoke a “slightly old” (just unsubscribed)
    event handler, but that’s a reasonable race condition.
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你首先将 `Click` 字段的值复制到一个局部变量中，这样即使在你检查 null 性之后它在另一个线程中改变了，你仍然有一个非 null 引用。你可能调用一个“稍微旧一点”（刚刚取消订阅）的事件处理器，但这是一种合理的竞争条件。
- en: 'So far, so good—but so long-winded. The null conditional operator comes to
    the rescue, however. It can’t be used for the shorthand style of delegate invocation
    of `handler(...)`, but you can use it to conditionally call the `Invoke` method
    and all in a single line:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利——但有点冗长。然而，空条件运算符来了，它不能用于 `handler(...)` 的简写风格委托调用，但你可以用它来有条件地调用 `Invoke`
    方法，并且一行搞定：
- en: '[PRE116]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: If this is the only line in your method (`OnClick` or similar), this has the
    compound benefit that now it’s a single-expression body, so it can be written
    as an expression-bodied method. It’s just as safe as the earlier pattern but a
    good deal more concise.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你方法（`OnClick` 或类似）中的唯一一行，那么它现在具有复合的好处，即它现在是一个单表达式主体，因此可以写成表达式主体方法。它和早期模式一样安全，但更加简洁。
- en: Making the most of null-returning APIs
  id: totrans-897
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 充分利用返回 null 的 API
- en: In [chapter 9](kindle_split_025_split_000.html#ch09), I talked about logging
    and how interpolated string literals don’t help in terms of performance. But they
    can be cleanly combined with the null conditional operator if you have a logging
    API designed with that pattern in mind. For example, suppose you have a logger
    API along the lines of that shown in the next listing.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 9 章](kindle_split_025_split_000.html#ch09) 中，我谈到了日志记录以及插值字符串字面量在性能方面并没有帮助。但是，如果你有一个考虑到这种模式的日志
    API，你可以干净地将其与空条件运算符结合使用。例如，假设你有一个类似于以下列表中所示的日志 API。
- en: Listing 10.12\. Sketch of a null-conditional-friendly logging API
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12\. 兼容空条件日志 API 的草图
- en: '[PRE117]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '***1* Interface returned by GetLog methods and so on**'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* GetLog 方法等返回的接口**'
- en: '***2* Properties returning null when the log is disabled**'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当日志禁用时返回 null 的属性**'
- en: '***3* Interface representing an enabled log sink**'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 表示启用日志接收器的接口**'
- en: 'This is only a sketch; a full logging API would have much more to it. But by
    separating the step of getting an active logger at a particular log level from
    the step of performing the logging, you can write efficient and informative logging:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个草图；一个完整的日志 API 将会有更多内容。但通过将获取特定日志级别的活动日志器的步骤与执行日志记录的步骤分开，你可以编写高效且信息丰富的日志：
- en: '[PRE118]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: If debug logging is disabled, you never get as far as formatting the interpolated
    string literal, and you can determine that without creating a single object. If
    debug logging is enabled, the interpolated string literal will be evaluated and
    passed on to the `Log` method as usual. Without getting too misty eyed, this is
    the sort of thing that makes me love the way C# has evolved.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 如果禁用了调试日志记录，你甚至不会到达格式化插值字符串字面量的步骤，你可以在不创建任何对象的情况下确定这一点。如果启用了调试日志记录，插值字符串字面量将像往常一样被评估并传递给
    `Log` 方法。不过，不要过于感伤，这类事情正是让我热爱 C# 不断进化的原因。
- en: Of course, you need the logging API to handle this in an appropriate way first.
    If whichever logging API you’re using doesn’t have anything like this, extension
    methods might help you out.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要首先使用日志API以适当的方式处理这个问题。如果你使用的日志API没有类似的功能，扩展方法可能有助于你。
- en: 'A lot of the reflection APIs return null at appropriate times, and LINQ’s `FirstOrDefault`
    (and similar) methods can work well with the null-conditional operator. Likewise,
    LINQ to XML has many methods that return null if they can’t find what you’re asking
    for. For example, suppose you have an XML element with an optional `<author>`
    element that may or may not have a `name` attribute. You can easily retrieve the
    author name with either of these two statements:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 许多反射API在适当的时候返回null，LINQ的`FirstOrDefault`（以及类似）方法可以很好地与空条件运算符一起工作。同样，LINQ to
    XML也有许多方法，如果找不到你请求的内容，它们会返回null。例如，假设你有一个包含可选的`<author>`元素的XML元素，该元素可能或可能没有`name`属性。你可以使用以下两种语句中的任意一种轻松检索作者名称：
- en: '[PRE119]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The first of these uses the null conditional operator twice: once to access
    the attribute of the element and once to access the value of the attribute. The
    second approach uses the way that LINQ to XML already embraces nullity in its
    explicit conversion operators.'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个使用空条件运算符两次：一次用于访问元素的属性，一次用于访问属性的值。第二种方法使用了LINQ to XML已经在其显式转换运算符中采用的接受空值的方式。
- en: 10.3.6\. Limitations of the null conditional operator
  id: totrans-911
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.6. 空条件运算符的限制
- en: 'Beyond occasionally having to deal with nullable value types when previously
    you were using only non-nullable values, there are few unpleasant surprises with
    the null conditional operator. The only thing that might surprise you is that
    the result of the expression is always classified as a value rather than a variable.
    The upshot of this is that you can’t use the null-conditional operator as the
    left side of an assignment. For example, the following are all invalid:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 除了偶尔需要处理之前仅使用非空值时的可空值类型之外，空条件运算符几乎没有不愉快的情况。唯一可能让你感到惊讶的是，表达式的结果始终被分类为值而不是变量。结果是，你不能将空条件运算符用作赋值语句的左侧。例如，以下都是无效的：
- en: '[PRE120]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: In those cases, you need to use the old-fashioned `if` statement. My experience
    is that this limitation is rarely an issue.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些情况下，你需要使用老式的`if`语句。我的经验是，这种限制很少成为问题。
- en: The null conditional operator is great for avoiding `NullReferenceException`,
    but sometimes exceptions happen for more reasonable causes, and you need to be
    able to handle them. Exception filters represent the first change to the structure
    of a `catch` block since C# was first introduced.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 空条件运算符非常适合避免`NullReferenceException`，但有时异常发生的原因更加合理，你需要能够处理它们。异常过滤器代表了自C#首次引入以来`catch`块结构的第一次变化。
- en: 10.4\. Exception filters
  id: totrans-916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 异常过滤器
- en: 'Our final feature in this chapter is a little embarrassing: it’s C# playing
    catch-up with VB. Yes, VB has had exception filters forever, but they were introduced
    only in C# 6\. This is another feature you may rarely use, but it’s an interesting
    peek into the guts of the CLR. The basic premise is that you can now write `catch`
    blocks that only *sometimes* catch an exception based whether a filter expression
    returns `true` or `false`. If it returns `true`, the exception is caught. If it
    returns `false`, the `catch` block is ignored.'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个特性有点尴尬：这是C#在追赶VB。是的，VB一直都有异常过滤器，但它们是在C# 6中引入的。这是另一个你可能很少使用的特性，但它是对CLR内部结构的有趣一瞥。基本前提是，你现在可以编写`catch`块，这些块仅在过滤器表达式返回`true`或`false`时才会偶尔捕获异常。如果返回`true`，则捕获异常。如果返回`false`，则忽略`catch`块。
- en: 'As an example, imagine you’re performing a web operation and know that the
    server you’re connecting to is sometimes offline. If you fail to connect to it,
    you have another option, but any other kind of failure should result in an exception
    bubbling up in the normal way. Prior to C# 6, you’d have to catch the exception
    and rethrow it if didn’t have the right status:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在执行网络操作，并且知道你连接的服务器有时会离线。如果你无法连接到它，你还有另一个选择，但任何其他类型的失败都应导致异常以正常方式冒泡。在C#
    6之前，你必须捕获异常，并在没有正确状态时重新抛出它：
- en: '[PRE121]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '***1* Attempts the web operation**'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 尝试执行网络操作**'
- en: '***2* Rethrows if it’s not a connection failure**'
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果不是连接失败则重新抛出**'
- en: '***3* Handles the connection failure**'
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 处理连接失败**'
- en: 'With an exception filter, if you don’t want to handle an exception, you don’t
    catch it; you filter it away from your `catch` block to start with:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想要处理异常，你不需要捕获它；你可以通过过滤从你的`catch`块中将其移除，从以下开始：
- en: '[PRE122]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '***1* Attempts the web operation**'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 尝试执行网络操作**'
- en: '***2* Catches only connection failures**'
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 只捕获连接失败**'
- en: '***3* Handles the connection failure**'
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 处理连接失败**'
- en: 'Beyond specific cases like this, I can see exception filters being useful in
    two generic use cases: retry and logging. In a retry loop, you typically want
    to catch the exception only if you’re going to retry the operation (if it meets
    certain criteria and you haven’t run out of attempts); in a logging scenario,
    you may never want to catch the exception but log it while it’s in-flight, so
    to speak. Before going into more details of the concrete use cases, let’s see
    what the feature looks like in code and how it behaves.'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种特定情况之外，我可以看到异常过滤器在两个通用用例中很有用：重试和记录。在重试循环中，你通常只想在将要重试操作时捕获异常（如果它满足某些条件且你没有用尽尝试次数）；在记录场景中，你可能永远不想捕获异常，但可以在它“飞行”时记录它，换句话说。在更详细地讨论具体用例之前，让我们看看这个特性在代码中的样子以及它的行为。
- en: 10.4.1\. Syntax and semantics of exception filters
  id: totrans-929
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1\. 异常过滤器的语法和语义
- en: 'Our first full example, shown in the following listing, is simple: it loops
    over a set of messages and throws an exception for each of them. You have an exception
    filter that will catch exceptions only when the message contains the word *catch*.
    The exception filter is highlighted in bold.'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个完整示例，如以下列表所示，很简单：它遍历一组消息并为每个消息抛出异常。你有一个异常过滤器，它只会在消息包含单词*catch*时捕获异常。异常过滤器以粗体突出显示。
- en: Listing 10.13\. Throwing three exceptions and catching two of them
  id: totrans-931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.13：抛出三个异常并捕获其中两个
- en: '[PRE123]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '***1* Loops outside the try/catch statement once per message**'
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每条消息在try/catch语句外循环一次**'
- en: '***2* Throws an exception with a different message each time**'
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每次抛出带有不同消息的异常**'
- en: '***3* Catches the exception only if it contains "catch"**'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 只有当异常包含"catch"时才捕获异常**'
- en: '***4* Writes out the message of the caught exception**'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 输出捕获异常的消息**'
- en: 'The output is two lines for the caught exceptions:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 对于捕获的异常，输出是两行：
- en: '[PRE124]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Output for the uncaught exception is a message of `This won’t be caught`. (Exactly
    what that looks like depends on how you run the code, but it’s a normal unhandled
    exception.)
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 未捕获异常的输出是一个消息“这不会被捕获”。（具体看起来如何取决于你如何运行代码，但这是一个正常的未处理异常。）
- en: 'Syntactically, that’s all there is to exception filters: the contextual keyword
    `when` followed by an expression in parentheses that can use the exception variable
    declared in the `catch` clause and must evaluate to a Boolean value. The semantics
    may not be quite what you expect, though.'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，这就是异常过滤器：上下文关键字`when`后面跟着一个括号内的表达式，该表达式可以使用`catch`子句中声明的异常变量，并且必须评估为布尔值。不过，其语义可能并不完全符合你的预期。
- en: The two-pass exception model
  id: totrans-941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 双遍历异常模型
- en: 'You’re probably used to the idea of the CLR unwinding the stack as an exception
    “bubbles up” until it’s caught. What’s more surprising is exactly how this happens.
    The process is more complicated than you may expect using a *two-pass model.*^([[1](kindle_split_026_split_000.html#ch10fn1)])
    This model uses the following steps:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经习惯了CLR在异常“冒泡”直到被捕获时回溯调用栈的想法。更令人惊讶的是，这到底是如何发生的。这个过程比你可能预期的更复杂，它使用了一个*两遍模型*。^([[1](kindle_split_026_split_000.html#ch10fn1)])
    此模型使用以下步骤：
- en: ¹
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I don’t know the origins of this model for exception processing. I suspect it
    maps onto the Windows Structured Exception Handling (often abbreviated to SEH)
    mechanism in a straightforward way, but this is deeper into the CLR than I like
    to venture.
  id: totrans-945
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我不清楚这个异常处理模型的起源。我怀疑它以一种直接的方式映射到Windows结构化异常处理（通常缩写为SEH）机制，但这已经深入到CLR（公共语言运行时）的内部，超出了我愿意探索的范围。
- en: The exception is thrown, and the *first pass* starts.
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常被抛出，并开始第一遍处理。
- en: The CLR walks down the stack, trying to find which `catch` block will handle
    the exception. (We’ll call this the *handling catch block* as shorthand, but that’s
    not official terminology.)
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR沿着调用栈向下遍历，试图找到哪个`catch`块将处理异常。（我们将称之为“处理catch块”作为简称，但这不是官方术语。）
- en: Only `catch` blocks with compatible exception types are considered.
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有与兼容异常类型匹配的`catch`块才会被考虑。
- en: If a `catch` block has an exception filter, the filter is executed; if the filter
    returns `false`, this `catch` block *won’t* handle the exception.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个 `catch` 块有一个异常过滤器，则执行该过滤器；如果过滤器返回 `false`，则此 `catch` 块将不会处理异常。
- en: A `catch` block without an exception filter is equivalent to one with an exception
    filter that returns `true`.
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有异常过滤器的 `catch` 块等同于有一个返回 `true` 的异常过滤器的 `catch` 块。
- en: 'Now that the handling `catch` block has been determined, the *second pass*
    starts:'
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在已经确定了处理 `catch` 块，开始进行 *第二次遍历*：
- en: The CLR unwinds the stack from the point at which the exception was thrown as
    far as the `catch` block that has been determined.
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR 从抛出异常的点开始回溯堆栈，直到确定的 `catch` 块。
- en: Any `finally` blocks encountered while unwinding the stack are executed. (This
    doesn’t include any `finally` block associated with the handling `catch` block.)
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在回溯堆栈时遇到的任何 `finally` 块都将被执行。（这不包括与处理 `catch` 块关联的任何 `finally` 块。）
- en: The handling `catch` block is executed.
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行处理 `catch` 块。
- en: The `finally` statement associated with the handling `catch` block is executed,
    if there is one.
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有，与处理 `catch` 块关联的 `finally` 语句将被执行。
- en: '[Listing 10.14](kindle_split_026_split_000.html#ch10ex14) shows a concrete
    example of all of this with three important methods: `Bottom`, `Middle`, and `Top`.
    `Bottom` calls `Middle` and `Middle` calls `Top,` so the stack ends up being self-describing.
    The `Main` method calls `Bottom` to start the ball rolling. Please don’t be daunted
    by the length of this code; it’s not doing anything massively complicated. Again,
    the exception filters are highlighted in bold. The `LogAndReturn` method is just
    a convenient way to trace the execution. It’s used by exception filters to log
    a particular method and then return the specified value to say whether the exception
    should be caught.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.14](kindle_split_026_split_000.html#ch10ex14) 展示了所有这些内容的具体示例，包括三个重要方法：`Bottom`、`Middle`
    和 `Top`。`Bottom` 调用 `Middle`，而 `Middle` 调用 `Top`，因此堆栈最终会自我描述。`Main` 方法调用 `Bottom`
    来启动整个过程。请别被这段代码的长度吓倒；它并没有做任何特别复杂的事情。再次强调，异常过滤器以粗体突出显示。`LogAndReturn` 方法只是追踪执行的一个方便方式。它被异常过滤器用来记录特定方法，然后返回指定的值以表明是否应该捕获异常。'
- en: Listing 10.14\. A three-level demonstration of exception filtering
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. 异常过滤器的三级演示
- en: '[PRE125]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '***1* Convenience method called by exception filters**'
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由异常过滤器调用的便利方法**'
- en: '***2* Finally block (no catch) executed on the second pass**'
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第二次遍历中执行的 *finally* 块（没有 catch）**'
- en: '***3* Exception filter that never catches**'
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 永远不会捕获异常的异常过滤器**'
- en: '***4* This never prints, because the filter returns false.**'
  id: totrans-962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这永远不会打印，因为过滤器返回了 `false`。**'
- en: '***5* Finally block executed on the second pass**'
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 第二次遍历中执行的 *finally* 块**'
- en: '***6* Exception filter that’s never called—wrong exception type**'
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 永远不会被调用的异常过滤器——错误的异常类型**'
- en: '***7* Exception filter that always catches**'
  id: totrans-965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 总是捕获异常的异常过滤器**'
- en: '***8* This is printed, because you catch the exception here.**'
  id: totrans-966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 这将被打印出来，因为在这里捕获了异常。**'
- en: 'Phew! With the description earlier and the annotations in the listing, you
    have enough information to work out what the output will be. We’ll walk through
    it to make sure it’s really clear. First, let’s look at what’s printed:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吸！有了前面的描述和列表中的注释，你已经有足够的信息来推断输出结果。我们将逐步分析以确保其清晰易懂。首先，让我们看看打印出来的内容：
- en: '[PRE126]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[Figure 10.2](kindle_split_026_split_000.html#ch10fig02) shows this process.
    In each step, the left side shows the stack (ignoring `Main`), the middle part
    describes what’s happening, and the right side shows any output from that step.'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.2](kindle_split_026_split_000.html#ch10fig02) 展示了此过程。在每一步中，左侧显示堆栈（忽略
    `Main`），中间部分描述正在发生的事情，右侧显示该步骤的任何输出。'
- en: Figure 10.2\. Execution flow of [listing 10.14](kindle_split_026_split_000.html#ch10ex14)
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2\. [列表 10.14](kindle_split_026_split_000.html#ch10ex14) 的执行流程
- en: '![](../Images/10fig02_alt.jpg)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig02_alt.jpg)'
- en: '|  |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Security impact of the two-pass model**'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '**两遍模型的安全影响**'
- en: The execution timing of `finally` blocks affects `using` and `lock` statements,
    too. This has an important implication of what you can use `try/finally` or `using`
    for if you’re writing code that may be executed in an environment that may contain
    hostile code. If your method may be called by code you don’t trust, and you allow
    exceptions to escape from that method, then the caller can use an exception filter
    to execute code before your `finally` block executes.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 块的执行时机也会影响 `using` 和 `lock` 语句。如果你正在编写可能在包含恶意代码的环境中执行代码的代码，这对你可以使用
    `try/finally` 或 `using` 的含义有重要的启示。如果你的方法可能被你不信任的代码调用，并且你允许异常从该方法中逃逸，那么调用者可以使用异常过滤器在执行你的
    `finally` 块之前执行代码。'
- en: All of this means you shouldn’t use `finally` for anything security sensitive.
    For example, if your `try` block enters a more privileged state and you’re relying
    on a `finally` block to return to a less privileged state, other code could execute
    while you’re still in that privileged state. A lot of code doesn’t need to worry
    about this sort of thing—it’s always running under friendly conditions—but you
    should definitely be aware of it. If you’re concerned, you could use an empty
    `catch` block with a filter that removes the privilege and returns `false` (so
    the exception isn’t caught), but that’s not something I’d want to do regularly.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着你不应该将 `finally` 用于任何安全敏感的操作。例如，如果你的 `try` 块进入了一个更高级别的状态，而你依赖于 `finally`
    块来返回到一个较低级别的状态，那么在你仍然处于高级别状态时，其他代码可能会执行。很多代码不需要担心这类问题——它们总是在友好的条件下运行——但你确实应该对此有所了解。如果你对此感到担忧，你可以使用一个空的
    `catch` 块，并带有过滤器的功能来移除权限并返回 `false`（这样异常就不会被捕获），但这不是我想经常做的事情。
- en: '|  |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Catching the same exception type multiple times
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多次捕获相同的异常类型
- en: In the past, it was always an error to specify the same exception type in multiple
    `catch` blocks for the same `try` block. It didn’t make any sense, because the
    second block would never be reached. With exception filters, it makes a lot more
    sense.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，在同一个 `try` 块中指定相同的异常类型在多个 `catch` 块中总是错误的。这没有意义，因为第二个块永远不会被执行。有了异常过滤器，这就有更多的意义。
- en: 'To demonstrate this, let’s expand our initial `WebException` example. Suppose
    you’re fetching web content based on a URL provided by a user. You might want
    to handle a connection failure in one way, a name resolution failure in a different
    way, and let any other kind of exception bubble up to a higher-level `catch` block.
    With exception filters, you can do that simply:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们扩展我们最初的 `WebException` 示例。假设你正在根据用户提供的 URL 获取网络内容。你可能希望以一种方式处理连接失败，以另一种方式处理名称解析失败，并让任何其他类型的异常冒泡到更高级别的
    `catch` 块。使用异常过滤器，你可以简单地做到这一点：
- en: '[PRE127]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '***1* Attempts the web operation**'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 尝试执行网络操作**'
- en: '***2* Handles a connection failure**'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 处理连接失败**'
- en: '***3* Handles a name-resolution failure**'
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 处理名称解析失败**'
- en: If you wanted to handle all other `WebException`s at the same level, it’d be
    valid to have a general `catch (WebException e) { ... }` block with no exception
    filter after the two status-specific ones.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以相同级别处理所有其他的 `WebException`，在两个特定状态之后的 `catch (WebException e) { ... }`
    块中不使用异常过滤器是有效的。
- en: Now that you know how exception filters work, let’s return to the two generic
    examples I gave earlier. These aren’t the only uses, but they should help you
    recognize other, similar situations. Let’s start with retrying.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经了解了异常过滤器的工作原理，让我们回到我之前给出的两个通用示例。这些不是唯一的用途，但它们应该能帮助你识别其他类似的情况。让我们从重试开始。
- en: 10.4.2\. Retrying operations
  id: totrans-986
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2\. 重试操作
- en: As cloud computing becomes more prevalent, we’re generally becoming more aware
    of operations that can fail and the need to think about what effect we want that
    failure to have on our code. For remote operations—web service calls and database
    operations, for example—there are sometimes transient failures that are perfectly
    safe to retry.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算变得越来越普遍，我们通常越来越意识到可能会失败的操作以及我们需要考虑这些失败对我们代码产生的影响。对于远程操作——例如网络服务调用和数据库操作——有时会有短暂的失败，这些失败是完全可以重试的。
- en: '|  |'
  id: totrans-988
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Keep track of your retry policies**'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**跟踪你的重试策略**'
- en: Although being able to retry like this is useful, it’s worth being aware of
    every layer of your code that might be attempting to retry a failed operation.
    If you have multiple layers of abstraction each trying to be nice and transparently
    retrying a failure that might be transient, you can end up delaying logging a
    real failure for a long time. In short, it’s a pattern that doesn’t compose well
    with itself.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够像这样重试很有用，但值得注意你代码的每一层都可能在尝试重试失败的操作。如果你有多个抽象层，每个层都在尝试优雅且透明地重试可能是一时性的失败，你可能会延迟很长时间记录真正的失败。简而言之，这是一个与自身不太兼容的模式。
- en: If you control the whole stack for an application, you should think about where
    you want the retry to occur. If you’re responsible for only one aspect of it,
    you should consider making the retry configurable so that a developer who does
    control the whole stack can determine whether your layer is where they want retries
    to occur.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你控制着整个应用程序的堆栈，你应该考虑你希望在哪个地方进行重试。如果你只负责其中的一方面，你应该考虑使重试可配置，以便控制整个堆栈的开发者可以确定是否在你的层中进行重试。
- en: '|  |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Production retry handling is somewhat complicated. You may need complicated
    heuristics to determine when and how long to retry for and an element of randomness
    on the delays between attempts to avoid retrying clients getting in sync with
    each other. [Listing 10.15](kindle_split_026_split_000.html#ch10ex15) provides
    a hugely simplified version^([[2](kindle_split_026_split_000.html#ch10fn2)]) to
    avoid distracting you from the exception filter aspects.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境中的重试处理有些复杂。你可能需要复杂的启发式方法来确定何时以及多长时间重试，以及尝试之间的延迟中包含一些随机性，以避免重试客户端彼此同步。[列表
    10.15](kindle_split_026_split_000.html#ch10ex15) 提供了一个高度简化的版本^([[2](kindle_split_026_split_000.html#ch10fn2)])，以避免分散你对异常过滤器方面的注意力。
- en: ²
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At a bare minimum, I’d expect any real-world retry mechanism to accept a filter
    to check which failures are retriable and a delay between calls.
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 至少，我期望任何现实世界的重试机制都能接受一个过滤器来检查哪些失败是可以重试的，以及调用之间的延迟。
- en: 'All your code needs to know is the following:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码只需要知道以下内容：
- en: What operation you’re trying to execute
  id: totrans-998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你试图执行的操作
- en: How many times you’re willing to try it
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你愿意尝试多少次
- en: At that point, using an exception filter to catch exceptions only when you’re
    going to retry the operation, the code is straightforward.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时刻，使用异常过滤器仅在你要重试操作时捕获异常，代码就很简单了。
- en: Listing 10.15\. A simple retry loop
  id: totrans-1001
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.15\. 一个简单的重试循环
- en: '[PRE128]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Although `while(true)` loops are rarely a good idea, this one makes sense. You
    could write a loop with a condition based on `retryCount`, but the exception filter
    effectively already provides that, so it’d be misleading. Also, the end of the
    loop would then be reachable from the compiler’s standpoint, so it wouldn’t compile
    without a `return` or `throw` statement at the end of the method.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无限循环 (`while(true)`) 往往不是一个好主意，但这个例子是有意义的。你可以编写一个基于 `retryCount` 条件的循环，但异常过滤器实际上已经提供了这个功能，所以这样做会误导。此外，从编译器的角度来看，循环的结束将是可到达的，所以如果没有在方法末尾添加
    `return` 或 `throw` 语句，它将无法编译。
- en: 'When this is in place, calling it to achieve a retry is simple:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个机制到位后，调用它进行重试很简单：
- en: '[PRE129]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Usually, this will return a result immediately. Sometimes, if you execute it
    at about 10 seconds into a minute, it’ll fail a couple of times and then succeed.
    Sometimes, if you execute it right at the start of a minute, it’ll fail a couple
    of times, catching the exception and logging it, and then fail a third time, at
    which point the exception won’t be caught.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这会立即返回结果。有时，如果你在一分钟大约 10 秒时执行它，它可能会失败几次然后成功。有时，如果你在一分钟的开始时执行它，它可能会失败几次，捕获异常并记录，然后第三次失败，此时异常不会被捕获。
- en: 10.4.3\. Logging as a side effect
  id: totrans-1007
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.3\. 作为副作用进行日志记录
- en: Our second example is a way of logging exceptions in-flight. I realize I’ve
    used logging to demonstrate many of the C# 6 features, but this is a coincidence.
    I don’t believe the C# team decided that they’d target logging specifically for
    this release; it just works well as a familiar scenario.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个例子是记录飞行中的异常的方法。我意识到我已经使用了日志来展示许多 C# 6 的特性，但这只是一个巧合。我不相信 C# 团队决定他们要专门针对这次发布进行日志记录；它只是作为一个熟悉的场景而很好地工作。
- en: The subject of exactly how and where it makes sense to log exceptions is a matter
    of much debate, and I don’t intend to enter that debate here. Instead, I’ll assert
    that at least sometimes, it’s useful to log an exception within one method call
    even if it’s going to be caught (and possibly logged a second time) somewhere
    further down the stack.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在哪里以及何时记录异常的准确方法是一个备受争议的话题，我并不打算参与这场辩论。相反，我将断言，至少在某些情况下，在方法调用中记录异常是有用的，即使它将被捕获（并且可能被第二次记录）在堆栈的更深处。
- en: You can use exception filters to log the exception in a way that doesn’t disturb
    the execution flow in any other way. All you need is an exception filter that
    calls a method to log the exception and then returns `false` to indicate that
    you don’t really want to catch the exception. The following listing demonstrates
    this in a `Main` method that will still lead to the process completing with an
    error code, but only after it has logged the exception with a timestamp.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用异常过滤器以不会以任何其他方式干扰执行流程的方式记录异常。你所需要的只是一个调用方法来记录异常并返回`false`以表示你实际上并不想捕获异常的异常过滤器。以下列表展示了在`Main`方法中如何实现这一点，该方法最终将以错误代码完成进程，但只有在记录了异常和带有时戳之后。
- en: Listing 10.16\. Logging in a filter
  id: totrans-1011
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.16. 过滤器中的日志记录
- en: '[PRE130]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This listing is in many ways just a variation of [listing 10.14](kindle_split_026_split_000.html#ch10ex14),
    in which we used logging to investigate the semantics of the two-pass exception
    system. In this case, you’re never catching the exception in the filter; the whole
    `try`/`catch` and filter exist only for the side effect of logging.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表在许多方面只是[列表10.14](kindle_split_026_split_000.html#ch10ex14)的一个变体，在列表10.14中，我们使用了日志来调查两遍异常系统的语义。在这种情况下，你永远不会在过滤器中捕获异常；整个`try`/`catch`和过滤器只存在于记录的副作用。
- en: 10.4.4\. Individual, case-specific exception filters
  id: totrans-1014
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.4. 个别、特定情况的异常过滤器
- en: 'In addition to those generic examples, specific business logic sometimes requires
    some exceptions to be caught and others to propagate further. If you doubt that
    this is ever useful, consider whether you always catch `Exception` or whether
    you tend to catch specific exception types like `IOException` or `SqlException`.
    Consider the following block:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些通用示例之外，特定的业务逻辑有时需要捕获某些异常，而让其他异常进一步传播。如果你怀疑这永远不会有用，考虑你是否总是捕获`Exception`，或者你是否倾向于捕获特定的异常类型，如`IOException`或`SqlException`。考虑以下代码块：
- en: '[PRE131]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'You can think of that block as being broadly equivalent to this:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个块视为大致等同于这个：
- en: '[PRE132]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Exception filters in C# 6 are a generalization of that. Often, the relevant
    information isn’t in the type but is exposed in some other way. Take `SqlException`,
    for example; it has a `Number` property corresponding to an underlying cause.
    It’d be far from unreasonable to handle some SQL failures in one way and others
    in a different way. Getting the underlying HTTP status from a `WebException` is
    slightly tricky because of the API, but again, you may well want to handle a 404
    (Not Found) response differently than a 500 (Internal Error).
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: C# 6中的异常过滤器是对此的泛化。通常，相关信息不在类型中，而是以某种其他方式公开。以`SqlException`为例；它有一个`Number`属性，对应于一个底层原因。以某种方式处理某些SQL失败，而以不同的方式处理其他SQL失败是完全合理的。从`WebException`获取底层HTTP状态稍微有些棘手，因为API的原因，但同样，你可能会想以不同的方式处理404（未找到）响应和500（内部错误）响应。
- en: 'One word of caution: I strongly urge you *not* to filter based on the exception
    message (other than for experimental purposes, as I did in [listing 10.13](kindle_split_026_split_000.html#ch10ex13)).
    Exception messages aren’t generally seen as having to stay stable between releases,
    and they may well be localized, depending on the source. Code that behaves differently
    based on a particular exception message is fragile.'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 一点注意事项：我强烈建议你*不要*根据异常消息进行过滤（除了实验目的之外，就像我在[列表10.13](kindle_split_026_split_000.html#ch10ex13)中所做的那样）。异常消息通常不被视为需要在发布之间保持稳定，并且它们可能根据来源而本地化。基于特定异常消息表现不同的代码是脆弱的。
- en: 10.4.5\. Why not just throw?
  id: totrans-1021
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.5. 为什么不直接抛出？
- en: You may be wondering what all the fuss is about. We’ve always been able to rethrow
    exceptions, after all. Code using an exception filter like this
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道所有这些喧嚣究竟是为了什么。毕竟，我们一直以来都能够重新抛出异常。使用类似这样的异常过滤器
- en: '[PRE133]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'isn’t very different from this:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 与此并不非常不同：
- en: '[PRE134]'
  id: totrans-1025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Does this really meet the high bar for a new language feature? It’s arguable.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否真正达到了新语言特性的高标准？这是有争议的。
- en: 'There *are* differences between the two pieces of code: you’ve already seen
    that the timing of when `condition` is evaluated changes relative to any `finally`
    blocks higher up the call stack. Additionally, although a simple `throw` statement
    does preserve the original stack trace for the most part, subtle differences can
    exist, particularly in the stack frame where the exception is caught and rethrown.
    That could certainly make the difference between diagnosing an error being simple
    and it being painful.'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 两个代码片段之间确实存在差异：你已经看到 `condition` 的评估时机相对于调用堆栈中更高的 `finally` 块发生了变化。此外，尽管简单的
    `throw` 语句在大多数情况下确实保留了原始堆栈跟踪，但可能存在细微的差异，尤其是在捕获和重新抛出异常的堆栈帧中。这确实可能使诊断错误变得简单或痛苦。
- en: I doubt that exception filters will massively transform many developers’ lives.
    They’re not something I miss when I have to work on a C# 5 codebase, unlike expression-bodied
    members and interpolated string literals, for example, but they’re still nice
    to have.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑异常过滤器会极大地改变许多开发者的生活。当我在 C# 5 代码库上工作时，我不会错过它们，例如与表达式成员体和插值字符串字面量相比，但它们仍然很受欢迎。
- en: Of the features described in this chapter, `using static` and the null conditional
    operator are certainly the ones I use most. They’re applicable in a broad range
    of cases and can sometimes make the code radically more readable. (In particular,
    if you have code that deals with a lot of constants defined elsewhere, `using
    static` can make all the difference in terms of readability.)
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章描述的功能中，`using static` 和空值条件运算符无疑是我在大多数情况下使用的。它们适用于广泛的场景，有时可以使代码的阅读性大大提高。（特别是，如果你有处理大量在其他地方定义的常量的代码，`using
    static` 可以在可读性方面产生重大差异。）
- en: 'One aspect that’s common to the null conditional operator and the object/collection
    initializer improvements is the ability to express a complex operation in a single
    expression. This reinforces the benefits that object/collection initializers introduced
    back in C# 3: it allows expressions to be used for field initialization or method
    arguments that might otherwise have had to be computed separately and less conveniently.'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 空值条件运算符和对象/集合初始化器改进的共同之处在于能够在一个表达式中表达一个复杂操作。这加强了对象/集合初始化器在 C# 3 中引入的好处：它允许表达式用于字段初始化或可能需要单独和不太方便计算的方法参数。
- en: Summary
  id: totrans-1031
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: '`using static` directives allow your code to refer to static type members (usually
    constants or methods) without specifying the type name again.'
  id: totrans-1032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using static` 指令允许你的代码在不需要再次指定类型名称的情况下引用静态类型成员（通常是常量或方法）。'
- en: '`using static` also imports all extension methods from the specified type,
    so you don’t need to import all the extension methods from a namespace.'
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using static` 也会导入指定类型中所有的扩展方法，因此你不需要从命名空间中导入所有的扩展方法。'
- en: Changes to extension method importing mean that converting a regular static
    method into an extension method is no longer a backward-compatible change in all
    cases.
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法导入的更改意味着将常规静态方法转换为扩展方法不再是所有情况下向后兼容的更改。
- en: Collection initializers can now use `Add` extension methods as well as those
    defined on the collection type being initialized.
  id: totrans-1035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合初始化器现在可以使用 `Add` 扩展方法以及初始化的集合类型上定义的方法。
- en: Object initializers can now use indexers, but there are trade-offs between using
    indexers and collection initializers.
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象初始化器现在可以使用索引器，但使用索引器和集合初始化器之间存在权衡。
- en: The null conditional `?.` operator makes it much easier to work with chained
    operations in which one element of the chain can return null.
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空值条件 `?.` 运算符使得处理链式操作变得容易得多，其中链的一个元素可以返回 null。
- en: Exception filters allow more control over exactly which exceptions are caught
    based on the exception’s data rather than just its type.
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常过滤器允许根据异常的数据而不是类型来控制确切捕获哪些异常。
