- en: Appendix B. Monads
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录B. 单子
- en: After reading this book, you might be surprised (and possibly frustrated) by
    the fact that I didn’t talk about monads. Monads are a hot topic, and you can
    find many so-called “Monad tutorials” on the web. The topic of monads seems to
    be very intimidating, and many programmers read these tutorials one after the
    other in the hope that they’ll eventually understand what monads are. Of course,
    many other programmers do understand monads, but very few are able to explain
    monads in simple terms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书之后，你可能会对我没有谈论单子的事实感到惊讶（并且可能感到沮丧）。单子是一个热门话题，你可以在网上找到许多所谓的“单子教程”。单子的主题似乎非常令人生畏，许多程序员一个接一个地阅读这些教程，希望他们最终能理解单子是什么。当然，许多其他程序员确实理解单子，但很少有人能够用简单的话解释单子。
- en: 'The reason why there are so many monad tutorials is probably because there’s
    no definitive tutorial, so people keep trying to roll their own. This appendix
    is not another monad tutorial. I wouldn’t want to write one for two reasons:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多单子教程的原因可能是因为没有确切的教程，所以人们一直在尝试自己编写。这个附录不是另一个单子教程。我不愿意写一个，有两个原因：
- en: If you have read this book, you don’t need a monad tutorial. Although I never
    used the term *monad*, you already know what a monad is. You know the concept
    and have made heavy use of it throughout this book. You just have to name it.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你已经阅读了这本书，你不需要单子教程。尽管我从未使用过*单子*这个术语，但你已经知道什么是单子。你知道这个概念，并在整本书中大量使用了它。你只需要给它命名。
- en: 'There’s an old saying about monads having a kind of magic: as soon as you understand
    them, you lose the ability to explain them to others.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于单子（monads）有一种古老的谚语：一旦你理解了它们，你就失去了向他人解释它们的能力。
- en: 'But let’s see what others say about monads. Searching on the internet, you
    can find many definitions:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们看看别人对单子的看法。在网上搜索，你可以找到许多定义：
- en: “A monad is just a monoid in the category of endofunctors.”
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “单子是端点函子范畴中的单群。”
- en: “A monad is a computational context for some value.”
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “单子是某个值的计算上下文。”
- en: “A monad is a class with a `unit` method and a `flatmap` method.”
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “单子是一个具有`unit`方法和`flatmap`方法的类。”
- en: 'You may also find some more exotic definitions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能找到一些更奇特的定义：
- en: “Monads are burritos.”
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “单子是卷饼。”
- en: “Monads are elephants.”
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “单子是象。”
- en: In the first list, the definitions are valid... in some contexts. The first
    one is probably the most rigorous definition in the context of category theory,
    a branch of mathematics about which most programmers don’t care. (They should,
    but that’s another story.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个列表中，定义在某些上下文中是有效的...。第一个定义可能是范畴论上下文中最严谨的定义，范畴论是大多数程序员不太关心的数学的一个分支。（他们应该关心，但这又是另一个故事。）
- en: The third definition is probably the most easily understood by Java programmers.
    The names of the methods are unimportant. What matters are the rules these methods
    must respect.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个定义可能是Java程序员最容易理解的。方法的名字并不重要。重要的是这些方法必须遵守的规则。
- en: The second definition is probably the most useful for understanding monads.
    Monads are computational contexts, and functional programming is programming with
    functions. Safe functional programming is programming with total functions. Functions
    that aren’t total are said to be partial, which means that they don’t always have
    a value (see [chapter 2](kindle_split_009.xhtml#ch02)). And when they have no
    value, they aren’t happy and start doing awful things. And they stop being pure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个定义可能是理解单子最有用的。单子是计算上下文，函数式编程是用函数编程。安全的函数式编程是用全函数编程。不是全函数的函数被称为部分函数，这意味着它们并不总是有一个值（见[第2章](kindle_split_009.xhtml#ch02)）。当它们没有值时，它们就不高兴，开始做可怕的事情。它们就不再是纯函数了。
- en: 'Consider the following function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Is this a pure function? No one can say. It depends on the programming language
    used. In some languages, it could throw an arithmetic overflow exception, so it
    wouldn’t be a total function because it wouldn’t be defined for all pairs `(x,
    y)`. It wouldn’t be a pure function because throwing an exception is a side effect.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个纯函数吗？没有人能说。这取决于所使用的编程语言。在某些语言中，它可能会抛出一个算术溢出异常，因此它不会是一个全函数，因为它不会为所有`(x, y)`对定义。它不会是一个纯函数，因为抛出异常是一个副作用。
- en: In Java, using integers, however, this function is pure. This means that whatever
    pair of integers you give to the function, it will always return a value, and
    always the same value for the same pair. So you can trust the function. This doesn’t
    mean the result will always be correct. In the case of overflow, the result might
    not be what you intended, but that’s another problem. There will always be a result
    (meaning that the program won’t hang in the wild) and this result will always
    be the same.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Java中使用整数，这个函数是纯函数。这意味着无论你给函数提供哪一对整数，它都会返回一个值，并且对于相同的对总是返回相同的值。所以你可以信任这个函数。这并不意味着结果总是正确的。在溢出的情况下，结果可能不是你想要的，但这又是另一个问题。总会有一个结果（这意味着程序不会在野外挂起）并且这个结果总是相同的。
- en: What about this function?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数怎么样？
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the context of Java and integers, which means a function taking a pair of
    integers as its argument and returning an integer, this isn’t a total function.
    It might have no result for some pairs of integers. If the second argument is
    0, there’s no result and the function throws an exception. This is because `g`
    isn’t a total function if considered as a function from (integer, integer) to
    integer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和整数的背景下，这意味着一个函数接受一对整数作为其参数并返回一个整数，这不是一个全函数。对于某些整数对，它可能没有结果。如果第二个参数是0，就没有结果，函数会抛出异常。这是因为如果将`g`视为从（整数，整数）到整数的函数，它不是一个全函数。
- en: 'There are two ways to make `g` a total function: change the domain, making
    it a function of (integer, non-null integer), or change the codomain, making it
    a function of (integer, integer) to (integer | exception).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`g`成为一个全函数，有两种方法：改变定义域，使其成为（整数，非空整数）的函数，或者改变值域，使其成为（整数，整数）到（整数 | 异常）的函数。
- en: 'To implement the first option, you’d have to create a new type: `NonNullInteger`.
    This is perfectly possible.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现第一种方法，你必须创建一个新的类型：`NonNullInteger`。这是完全可能的。
- en: 'To implement the second option, you’d again have to create a new type: `IntegerOrException`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现第二种方法，你还得创建一个新的类型：`IntegerOrException`。
- en: Functional programmers prefer the second approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序员更喜欢第二种方法。
- en: But if you change function `g` to return `IntegerOrException`, you can no longer
    compose it with `f`. More precisely, `f . g (x)`, or `f(g(x))` if you prefer this
    notation, will no longer compile because the types no longer match.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你将函数`g`改为返回`IntegerOrException`，你就不能再将其与`f`组合。更准确地说，`f . g (x)`，或者如果你喜欢这种表示法，`f(g(x))`将无法编译，因为类型不再匹配。
- en: The solution is to create a computational context in which the functions can
    be safely executed. If you like metaphors, you can think about the context as
    a safe box.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在一个计算环境中创建函数，以便可以安全地执行。如果你喜欢隐喻，你可以将这个环境想象成一个安全盒。
- en: So, what you need is
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你需要做的是
- en: A safe box
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个安全盒
- en: A way to put the parameter value inside the box
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方法是将参数值放入盒子里
- en: A way to put the modified function inside the box so that it can be applied
    to the parameter value
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方法是将修改后的函数放入盒子里，以便它可以应用于参数值
- en: And that’s it. The result will be a box containing the result of the function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。结果将是一个包含函数结果的盒子。
- en: 'To take a simple example in Java, you’ll have to slightly modify the requirements,
    because Java doesn’t offer such a safe box. It offers three types of safe boxes,
    but not one suitable for this use case, so you have to modify the requirement
    by saying that in case of error, the result won’t throw an exception but will
    simply return nothing. (Note that Java has a type for this: `Void`. But instantiating
    this type is a bit tricky.)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以Java为例，简单来说，你需要稍微修改一下要求，因为Java没有提供这样的安全盒。它提供了三种安全盒类型，但没有一种适合这种情况，所以你必须通过说在出错的情况下，结果不会抛出异常，而是简单地返回空值来修改要求。（注意，Java有这种类型：`Void`。但实例化这种类型有点棘手。）
- en: The type of safe box you can use for returning a result or nothing is the `Option`
    you developed in [chapter 6](kindle_split_013.xhtml#ch06), or (better) the `Result`
    type from [chapter 7](kindle_split_014.xhtml#ch07). In standard Java 8, it could
    be the `Optional` type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用返回结果或无结果的`Option`来作为安全盒的类型，这是你在[第6章](kindle_split_013.xhtml#ch06)中开发的，或者（更好）是[第7章](kindle_split_014.xhtml#ch07)中的`Result`类型。在标准的Java
    8中，可以是`Optional`类型。
- en: In functional languages, the method that will put a value into the box is generally
    named `unit` or `return`, but you named it `of` for `Option` and `Result`, as
    Java 8 designers did for `Optional`. That doesn’t change anything.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式语言中，将值放入盒子的方法通常命名为`unit`或`return`，但你将其命名为`of`用于`Option`和`Result`，就像Java
    8设计者对`Optional`所做的那样。这并没有改变什么。
- en: 'The method that allows you to apply the modified function to the value inside
    the box is called `flatMap`. Let’s take the example of a simpler function taking
    a `String` and returning the first character. A “normal” method could look like
    this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你将修改后的函数应用于盒子内值的那个方法被称为`flatMap`。让我们以一个更简单的函数为例，它接受一个`String`并返回第一个字符。一个“正常”的方法可能看起来像这样：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To make this function return either the first character or nothing, you must
    change it into this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个函数返回第一个字符或无，你必须将其改为以下内容：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To use these tools, you need to put a `String` in context:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些工具，你需要将一个`String`放入上下文中：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `unit` (`of`) and `flatMap` methods are all that’s needed to make `Optional`
    a monad.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`unit`（单位）和`flatMap`方法就足够将`Optional`转换为单子。'
- en: 'There are, however, other use cases that are frequent enough to have been added
    in most monad implementations. For example, you might have to use a function returning
    a raw value, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些用例足够频繁，以至于在大多数单子实现中都被添加了。例如，你可能需要使用返回原始值的函数，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You could do it with
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下方式做到这一点
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But this isn’t very efficient, because the function will wrap the result in
    an `Optional`, just for the `flatMap` method to unwrap it. So there’s a map method
    for this use case:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不非常高效，因为函数将结果包装在一个`Optional`中，只是为了`flatMap`方法解包它。因此，有一个针对这种情况的映射方法：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that if you were to use `map` with a function returning an `Optional`,
    such as the following, you’d obtain an `Optional<Optional<Character>>`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你使用返回`Optional`的函数与`map`一起使用，例如以下示例，你会得到`Optional<Optional<Character>>`：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This can be changed into an `Optional<Character>` using a method called `flatten`
    (or `join`), but this method is missing in `Optional`. As you can see, there’s
    a strong relation between `unit` (`of`), `flatMap`, `map`, and `flatten`. The
    `flatten` method can be implemented as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个名为`flatten`（或`join`）的方法转换为`Optional<Character>`，但这个方法在`Optional`中缺失。正如你所见，`unit`（`of`）、`flatMap`、`map`和`flatten`之间存在强烈的关联。`flatten`方法可以如下实现：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lots of other use cases can be abstracted inside monads, but they’re not necessary
    to make a type a monad. One of the most often used is `fold`. This method is generally
    seen as specific to vector types, such as `List` or `Stream`, but it’s not. For
    `Option`, for example, `fold` can be implemented in `None<T>` as
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他用例可以在单子内部抽象，但它们对于将类型转换为单子并不是必要的。最常用的之一是`fold`。这种方法通常被视为特定于向量类型，如`List`或`Stream`，但实际上并非如此。例如，对于`Option`，`fold`可以在`None<T>`中实现如下：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: and in `Some<T>` as
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Some<T>`中也是如此
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (Technically, this is a left fold, but the difference is irrelevant for this
    example.)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: （技术上，这是一个左折叠，但这个例子中的差异无关紧要。）
- en: 'You can’t add this method to the Java 8 class `Optional`, which is `final`.
    But you can write an external implementation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将此方法添加到Java 8类`Optional`中，因为它是`final`的。但你可以编写一个外部实现：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, you use `Optional.get()`, which is awfully bad. (It’s forbidden to access
    the value from outside of the context, which means this method shouldn’t be public.)
    There’s no smart solution to this problem. You know that the `get` method will
    never be called if the value isn’t present, so you could write this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你使用了`Optional.get()`，这非常糟糕。（从上下文外部访问值是被禁止的，这意味着这个方法不应该公开。）没有聪明的解决方案来解决这个问题。你知道如果值不存在，`get`方法永远不会被调用，所以你可以写出以下内容：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But this is ugly. The less ugly implementation would probably look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但这很丑。不那么丑的实现可能看起来像这样：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Anyway, folding an `Optional` is useless, except to understand that the `orElse`
    method is in fact a `fold` and could be defined as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，折叠`Optional`是没有用的，除非是为了理解`orElse`方法实际上是一个`fold`，可以定义为以下内容：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Yes, again this is totally useless, but it’s helpful to understand it when studying
    other monads such as `Stream` or `List` (but not the `java.util.List`, of course).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这同样毫无用处，但它在研究其他单子，如`Stream`或`List`（当然不是`java.util.List`）时很有帮助。
- en: Lots of other methods could have been added to `Optional` and are missing, and
    you can’t add them because `Optional` is final. This is a good reason to develop
    a totally new `Option` monad. But at the same time, `Optional` is almost useless
    because it can’t carry the reason for the absence of data. This is why another
    monad is needed. In this book, we called it `Result`, and it roughly corresponds
    to the Scala `Try` class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他方法本可以添加到`Optional`中，但它们缺失了，而且你不能添加它们，因为`Optional`是最终的。这是开发一个全新的`Option`单子的好理由。但与此同时，`Optional`几乎毫无用处，因为它不能携带数据缺失的原因。这就是为什么还需要另一个单子的原因。在这本书中，我们称之为`Result`，它大致对应于Scala的`Try`类。
