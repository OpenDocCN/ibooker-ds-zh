- en: 1 Why microservices?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 为什么是微服务？
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: The learning approach of this book
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书的学习方法
- en: The what and why of microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的什么和为什么
- en: The benefits and drawbacks of using microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用微服务的利弊
- en: What’s wrong with the monolith?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构有什么问题？
- en: The basics of microservices design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计的基础知识
- en: A quick overview of the application we build
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们构建的应用程序的快速概述
- en: As software continues to become larger and more complicated, we need better
    ways of managing and mitigating its complexity. As it grows alongside our business,
    we need better ways of dividing it up so that multiple teams can participate in
    the construction effort.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件的日益庞大和复杂，我们需要更好的方法来管理和减轻其复杂性。随着它随着我们的业务增长，我们需要更好的方法来分割它，以便多个团队能够参与到构建工作中。
- en: As our demanding customer base grows, we must also be able to expand our software.
    At the same time, our applications should be fault-tolerant and able to scale
    quickly to meet peak demand. How do we then meet the demands of modern business
    while evolving and developing our application?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们苛刻的客户群的增长，我们也必须能够扩展我们的软件。同时，我们的应用程序应该具有容错能力，能够快速扩展以满足峰值需求。那么我们如何在演进和开发我们的应用程序的同时满足现代业务的需求？
- en: Microservices are an architectural pattern that plays a pivotal role in contemporary
    software development. A *distributed application* composed of microservices solves
    these problems and more, but typically it is more difficult, more complex, and
    more time-consuming to architect than a traditional *monolithic* application.
    If these terms are new-microservices, distributed application, and monolithic
    application-they will be explained soon.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一种在当代软件开发中扮演关键角色的架构模式。由微服务组成的*分布式应用程序*解决了这些问题以及更多，但通常比传统的*单体*应用程序更难设计、更复杂、更耗时。如果这些术语是新的——微服务、分布式应用程序和单体应用程序——它们将很快得到解释。
- en: Conventional wisdom says that microservices are too difficult. We are told to
    start “monolith-first” and later restructure to microservices when necessary to
    scale. But I argue that this attitude doesn’t make the job of building an application
    any easier! Your application is always going to tend toward complexity and, eventually,
    you will need to scale it. When you do decide you need to change, you now have
    the extremely difficult job of safely converting your monolith to microservices
    when staff and customers already depend on it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 传统智慧认为微服务太难。我们被告知从“单体优先”开始，并在需要扩展时将其重构为微服务。但我认为这种态度并不能使构建应用程序的工作变得更容易！你的应用程序总是倾向于复杂性，最终你将需要对其进行扩展。当你决定需要改变时，你现在面临着一个极其困难的任务，那就是在员工和客户已经依赖它的情况下，安全地将你的单体架构转换为微服务。
- en: Now is also the perfect time to be building microservices. The confluence of
    various factors-accessible and cheap cloud infrastructure, ever improving tools,
    and increasing opportunities for automation-is driving an industry-wide movement
    toward smaller and smaller services, aka *microservices*. Applications become
    more complex over time, but microservices offer us better ways to manage such
    complexity. There is no better time than now to go “microservices-first.”
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在也是构建微服务的完美时机。各种因素的汇聚——可访问且廉价的云基础设施、不断改进的工具以及自动化机会的增加——正在推动整个行业向更小、更小的服务发展，即*微服务*。随着时间的推移，应用程序变得更加复杂，但微服务为我们提供了更好的方法来管理这种复杂性。没有比现在更好的时间去“以微服务为先”。
- en: In this book, I will show you that a microservices-first approach is no longer
    as daunting as it once was. I believe the balance is firmly tipping toward microservices.
    The remaining problem is that *learning* microservices is difficult. The learning
    curve is steep and holds back many developers in their quest to build microservices.
    Together, we will break the learning curve. We will say “Boo” to the monolith,
    and we’ll build from the ground up a simple but complete video-streaming application
    using microservices.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将向你展示，以微服务为先的方法不再像以前那样令人畏惧。我相信平衡已经坚定地倾向于微服务。剩下的问题是学习微服务是困难的。学习曲线陡峭，阻碍了许多开发者构建微服务的努力。我们将一起打破学习曲线。我们将对单体架构说“呸”，并从头开始构建一个简单但完整的视频流应用，使用微服务。
- en: 1.1 This book is practical
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 本书是实用的
- en: Why are you reading this book? You are reading this because you want or need
    to build a microservices application, which is an important skill set for modern
    developers, but it’s a difficult skill set to obtain, and you need some guidance.
    You may have read other books on microservices and been left wondering *where
    do I begin?* I understand your torment.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么在读这本书？你之所以在读这本书，是因为你想要或者需要构建一个微服务应用，这对于现代开发者来说是一个重要的技能集，但获得这个技能集却很困难，你需要一些指导。你可能已经读过其他关于微服务的书籍，并且还在
    wonder *我从哪里开始？* 我理解你的困扰。
- en: Microservices are tough to learn. Not only do you have to learn deep and complicated
    tools, you must also learn to build a distributed application. This requires new
    design patterns, protocols, and methods of communication. That’s a lot to learn
    in anyone’s book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的学习难度很大。你不仅要学习深入且复杂的工具，还必须学会构建分布式应用。这需要新的设计模式、协议和通信方法。在任何人看来，这都是一大堆要学习的内容。
- en: In this book, we cut through the seemingly impenetrable learning curve of building
    microservices applications. The learning curve you must endure can seem insurmountable
    when tackled by yourself, but, rather than that, we’ll undergo this development
    adventure together. We’ll start as simple as possible and, piece-by-piece, we’ll
    build up to deploying our application to production.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们突破了构建微服务应用看似无法逾越的学习曲线。当你独自面对时，你必须忍受的学习曲线可能看起来难以克服，但，而不是这样，我们将共同经历这个开发冒险。我们将尽可能简单开始，逐步构建，最终将应用部署到生产环境中。
- en: This book is about busting through the learning curve and bootstrapping a working
    application that will last indefinitely, an application that we can continuously
    update and build on to satisfy the ongoing and changing needs of our customers
    and users. Figure 1.1 illustrates this idea of cutting through the learning curve.
    While our example application is small and simple, from the start, we will build-in
    pathways to scalability that will later allow it to be expanded out to a truly
    massive distributed application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于突破学习曲线，启动一个可以无限期使用的、可不断更新和构建的应用，以满足我们客户和用户持续变化的需求。图1.1展示了突破学习曲线的概念。虽然我们的示例应用很小且简单，但从一开始，我们将构建可扩展性路径，以便将来将其扩展为一个真正的巨大分布式应用。
- en: '![](../Images/CH01_F01_Davis4.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH01_F01_Davis4.png)'
- en: Figure 1.1 Cutting through the learning curve. In this book, we’ll learn only
    the bare minimum, just enough to bootstrap our application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 突破学习曲线。在这本书中，我们将只学习最基本的知识，仅够启动我们的应用。
- en: How is this book different from all the other books on microservices? Other
    books are notably theoretical. That’s a good approach for an experienced developer
    or architect looking to broaden their knowledge, but acquiring practical skills
    that way is challenging and doesn’t help you navigate the minefield of bootstrapping
    a new application. The technical choices you make at project inception can haunt
    you for a long time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书与其他所有关于微服务的书籍有什么不同？其他书籍明显是理论的。这对于一个经验丰富的开发者或架构师来说是一个很好的方法，他们想要扩展他们的知识，但通过这种方式获得实际技能是具有挑战性的，并且不能帮助你导航启动新应用的雷区。你在项目启动时做出的技术选择可能会长期困扰你。
- en: This book *is* different; this book *is not* theoretical. We will take a practical
    approach to learning. There is a small amount of theory interspersed throughout,
    and we will actually build a substantial microservices application. We will start
    from nothing and work through bringing our application into existence and getting
    it into production. We’ll build and test the application on our development workstation
    (or personal computer), and ultimately, we’ll deploy it to the cloud.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书 *确实是* 不同的；这本书 *不是* 理论的。我们将采取实际的学习方法。书中穿插了一些理论，但我们实际上会构建一个实质性的微服务应用。我们将从零开始，逐步将应用带入存在并投入生产。我们将在我们的开发工作站（或个人电脑）上构建和测试应用，最终，我们将将其部署到云端。
- en: Together we’ll get our microservices application off the ground without having
    to learn the deepest details of any of the tools or technologies. An example of
    this book’s learning model is illustrated in figure 1.2.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一起启动我们的微服务应用，而不必学习任何工具或技术的最深层细节。本书的学习模型示例如图1.2所示。
- en: '![](../Images/CH01_F02_Davis4.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH01_F02_Davis4.png)'
- en: Figure 1.2 The learning model for this book. We will skim the surface of these
    deep and complicated technologies to only use what is necessary to bootstrap our
    application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2本书的学习模型。我们将对这些深奥而复杂的技术进行简要了解，只为启动我们的应用程序提供必要的部分。
- en: This book is about building a microservices application, starting with nothing.
    Some people have already asked why I didn’t write this book to show how to convert
    a monolith to a microservices application? This is something that many people
    would like to learn.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是关于从零开始构建微服务应用程序的。有些人已经问我为什么我没有写这本书来展示如何将单体转换为微服务应用程序？这是许多人想要学习的内容。
- en: I wrote the book in this way because it’s much easier to learn how to write
    an application from scratch than it is to learn how to refactor an existing application.
    I also believe these skills are useful because, in time, more and more applications
    will be written microservices-first.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我以这种方式写这本书，因为从头开始学习如何编写应用程序比学习如何重构现有应用程序要容易得多。我也相信这些技能是有用的，因为随着时间的推移，越来越多的应用程序将以微服务优先的方式编写。
- en: In any case, refactoring an existing application is much more complicated than
    building a fresh application. It’s a process with many complex variables and depends
    heavily on the particulars of the legacy codebase. I make the presumption that
    it will be easier for you to figure out your own monolith conversion strategy
    once you know (indeed, once you have experienced) how to create a greenfield (new)
    microservices application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，重构现有应用程序都比构建全新的应用程序复杂得多。这是一个包含许多复杂变量的过程，并且高度依赖于遗留代码库的特定情况。我假设，一旦你了解了（实际上，一旦你亲身体验了）如何创建绿色田野（新）微服务应用程序，你将更容易找到自己的单体转换策略。
- en: I can assure you that when you can build an application microservices-first,
    you will be much better equipped to clearly see a route from your existing monolith
    to microservices. That journey from monolith to microservices will no doubt still
    be demanding, so stay tuned. In chapter 11, we will discuss more on this topic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以向你保证，当你能够以微服务优先的方式构建应用程序时，你将更有能力清楚地看到从现有单体到微服务的路线。从单体到微服务的这一旅程无疑仍然会很有挑战性，所以请保持关注。在第11章中，我们将更深入地讨论这个话题。
- en: Throughout this book, you will learn concrete and practical techniques for getting
    a microservices application off the ground. Of course, there are many diverse
    ways to go about this and many different tools you can use. I am teaching you
    one single recipe and one set of tools (albeit a popular toolset). You will, no
    doubt, find many ways to improve on this recipe and enhance it for your own situation.
    Other experienced developers will, of course, already have their own recipes for
    doing this. What I’m trying to say is that this is my way, and it is just one
    of many ways that will work; however, I can attest that I have tried every technique
    in this book in production and found these to work well. So without further ado,
    let us commence our journey of learning and discovery.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你将学习到具体实用的技术，以便将微服务应用程序启动起来。当然，有许许多多的方法和许多不同的工具可以用来实现这一点。我在教你一个单一的配方和一套工具（尽管是一个流行的工具集）。毫无疑问，你会发现许多改进这个配方和适应你自身情况的方法。当然，其他经验丰富的开发者已经拥有他们自己的配方来做这件事。我试图说的是，这是我的方法，这只是许多可行方法中的一种；然而，我可以证明我已经在生产中尝试了这本书中的每一个技术，并发现它们效果良好。所以，无需多言，让我们开始我们的学习和探索之旅。
- en: 1.2 What will I learn?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 我将学到什么？
- en: Throughout the book, we will progress from easy to more difficult. We’ll start
    with the simplest task-creating a single microservice. Over 11 chapters, we’ll
    build up to a more complex application and infrastructure, but we’ll do it in
    incremental steps so that you never get lost. After reading this book and practicing
    the skills taught, you can expect to be able to
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将从简单到复杂逐步进行。我们将从最简单的任务——创建单个微服务开始。在11章中，我们将逐步构建一个更复杂的应用程序和基础设施，但我们将以增量步骤进行，这样你就不会迷失方向。阅读这本书并实践所教授的技能后，你可以期待能够
- en: Create individual microservices
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单个微服务
- en: Package and publish microservices using Docker
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker打包和发布微服务
- en: Develop a microservices application on your development workstation using Docker
    Compose
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的开发工作站上使用Docker Compose开发微服务应用程序
- en: Test your code, microservices, and application using Jest and Cypress
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jest和Cypress测试你的代码、微服务和应用程序
- en: Integrate third-party servers into your application (like MongoDB and RabbitMQ,
    as examples)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第三方服务器集成到你的应用程序中（例如MongoDB和RabbitMQ等）
- en: Communicate between microservices using HTTP and RabbitMQ messages
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP和RabbitMQ消息在微服务之间进行通信
- en: Store the data and files your microservices need to operate
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储您的微服务运行所需的数据和文件
- en: Create production infrastructure with Kubernetes using Terraform
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform和Kubernetes创建生产基础设施
- en: Deploy your microservices to production using Terraform
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Terraform将微服务部署到生产环境中
- en: Create a continuous delivery pipeline to automatically deploy your application
    as you update the code
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个持续交付管道，以便在更新代码时自动部署您的应用程序
- en: 1.3 What do I need to know?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 我需要了解什么？
- en: You might be wondering, what you need to know going into this book. I have made
    an effort to write this book with as few assumptions as possible about what you
    already know. We are going on a journey that takes you from absolute basics all
    the way through to some rather complicated concepts. I think there’s something
    here for everyone, no matter how much experience you might have already as a developer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道，进入本书之前您需要了解什么。我努力编写这本书，尽可能少地假设您已经知道的内容。我们将从绝对的基础开始，一直深入到一些相当复杂的概念。我认为这里对每个人来说都有所帮助，无论您作为开发者的经验如何。
- en: It’s best coming into this book if you have some entry-level understanding of
    computer programming. I don’t think you’ll need much, so long as you can read
    code and get the gist of what it’s doing. But don’t worry; I’ll explain as much
    as possible about anything important that is happening in the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对计算机编程有一些入门级理解，那么进入本书会更好。我认为您不需要太多，只要您能阅读代码并理解其功能即可。但请放心；我会尽可能多地解释代码中发生的重要事情。
- en: If you have a background in programming, you’ll have no problem following along
    with the examples in this book. If you are learning programming while reading
    this book, you could find it to be quite a bit more challenging, but not impossible,
    and you might have to put in some extra work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有编程背景，您将没有问题跟随本书中的示例。如果您在阅读本书的同时学习编程，您可能会发现这相当具有挑战性，但并非不可能，您可能需要做一些额外的工作。
- en: This book uses Node.js for examples of microservices, but starting out, you
    don’t need to know JavaScript or Node.js. You’ll pick up enough along the way
    to follow along. This book also uses Microsoft Azure for examples of production
    deployment. Again, starting out, you don’t need to know anything about Azure either.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用Node.js作为微服务的示例，但一开始，您不需要了解JavaScript或Node.js。您将在学习过程中获得足够的知识来跟随。本书还使用Microsoft
    Azure作为生产部署的示例。同样，一开始，您也不需要了解Azure。
- en: Rest assured that this book isn’t about Node.js or Azure; it’s about building
    microservices applications using modern tooling like Docker, Kubernetes, and Terraform.
    Most of the skills you will take away from this book are transferable to other
    languages and other cloud providers. Because I had to pick a programming language
    and cloud vendor that I could use to demonstrate the techniques in this book,
    I chose Node.js and Azure. That’s mostly what I use in production these days.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请放心，这本书不是关于Node.js或Azure的；它是关于使用Docker、Kubernetes和Terraform等现代工具构建微服务应用程序的。您从本书中学到的大多数技能都可以转移到其他语言和其他云服务提供商。因为我必须选择一个编程语言和云服务提供商来演示本书中的技术，所以我选择了Node.js和Azure。这就是我目前在生产中主要使用的内容。
- en: If Node.js and Azure aren’t your thing, with some extra research and experimentation
    on your part, you’ll be able to figure out how to replace Node.js and JavaScript
    with your favorite programming language and replace Azure with your preferred
    cloud vendor. In fact, the main reason I use Docker, Kubernetes, and Terraform
    in the first place is precisely because these tools offer freedom-freedom of choice
    for programming language and freedom from cloud vendor lock-in.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Node.js和Azure不是您所擅长，通过您的一些额外研究和实验，您将能够找出如何用您喜欢的编程语言替换Node.js和JavaScript，并用您首选的云服务提供商替换Azure。实际上，我最初选择使用Docker、Kubernetes和Terraform的主要原因正是这些工具提供了自由——选择编程语言的自由和摆脱云服务提供商锁定自由的自由。
- en: 1.4 Managing complexity
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 管理复杂性
- en: A microservice application, like any application, will become more complex over
    time. But it doesn’t need to start that way! This book takes the approach that
    we can begin from a simple starting point and that each iteration of development
    can also be just as simple. In addition, each microservice is small and simple.
    As you read this book, you’ll find that it isn’t as difficult as you might think
    to build applications with microservices (despite what some people say).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何应用一样，微服务应用随着时间的推移会变得更加复杂。但它们不需要从这种状态开始！这本书采取的方法是我们可以从一个简单的起点开始，并且每个开发迭代也可以同样简单。此外，每个微服务都是小巧简单的。当你阅读这本书时，你会发现使用微服务构建应用程序并不像你想象的那么困难（尽管有些人这么说）。
- en: Microservices give us a way to manage complexity at a granular level, and it’s
    the level we work at almost every day-the level of a single microservice. At that
    level, microservices are not complex. In fact, to earn the name *microservice*,
    they have to be small and simple. A single microservice is intended to be manageable
    by a single developer or a small team!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务为我们提供了一种在细粒度上管理复杂性的方法，这是我们几乎每天都在工作的层面——单个微服务的层面。在那个层面，微服务并不复杂。事实上，为了获得**微服务**这个名称，它们必须小巧简单。单个微服务旨在由单个开发者或小型团队管理！
- en: It is true, though, that through continued development and evolution, a complex
    system will emerge. There’s no denying that a microservices application will become
    complex. But that doesn’t happen immediately; it takes time. Along the way, we’ll
    use microservices to manage the growing complexity of your application so that
    it doesn’t become a burden.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，但通过持续的开发和演变，一个复杂的系统将会出现。不可否认，微服务应用将会变得复杂。但这并不是立即发生的；它需要时间。在这个过程中，我们将使用微服务来管理你应用的增长复杂性，以便它不会成为负担。
- en: A microservices application is a form of *complex adaptive system*, where complexity
    emerges naturally from the interactions of its constituent parts. Even though
    the system as a whole can become far too complex for any mere mortal to understand,
    each of its components remains small, manageable, and easy to understand. Don’t
    worry though; the example application we build in this book isn’t that complicated.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应用是一种**复杂自适应系统**的形式，其复杂性自然地从其组成部分的交互中产生。尽管整个系统可能过于复杂，以至于任何凡人都无法理解，但每个组成部分仍然保持小巧、可管理和易于理解。不过，不用担心；这本书中我们构建的示例应用并不复杂。
- en: Development with this microservices attitude (with help from our tools and automation)
    allows us to build extremely large and scalable applications without being overwhelmed
    by the complexity. And, after reading this book, you’ll be able to zoom in and
    look at any part of the most complex microservices application and find its components
    to be straightforward and understandable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种微服务态度（在工具和自动化的帮助下）进行开发，使我们能够构建极其庞大且可扩展的应用程序，而不会被复杂性所压倒。而且，在阅读这本书之后，你将能够聚焦于最复杂的微服务应用的任何部分，并发现其组件简单易懂。
- en: 1.5 What is a microservice?
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 什么是微服务？
- en: Before we can understand a microservices application, we must first understand
    what it means to be a microservice.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够理解微服务应用之前，我们首先必须理解什么是微服务。
- en: Definition A *microservice* is a tiny and independent software process that
    runs on its own deployment schedule and can be updated independently.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 定义A **微服务** 是一个微小且独立的软件进程，它在自己的部署计划上运行，并且可以独立更新。
- en: Let’s break that definition down. A microservice is a small, independent software
    process that has its own separate deployment frequency. That is to say that it
    must be possible to update each microservice independently from other microservices.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个定义。微服务是一个小型、独立的软件进程，它有自己的独立部署频率。也就是说，必须能够独立于其他微服务更新每个微服务。
- en: A microservice can be owned and operated either by a single developer or a team
    of developers. A developer or team might also manage multiple other microservices.
    Each developer/team has the responsibility for the microservice(s) they own. In
    the modern world of programming, this often includes development, testing, deployment,
    and operations. We might find, however, that when we work for a small company
    or a startup (as I do), or when we are learning (as we are in this book), we must
    manage multiple microservices or, indeed, even an entire microservices application
    on our own.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务可以由单个开发者或一组开发者拥有和运营。开发者或团队也可能管理多个其他微服务。每个开发者/团队对其拥有的微服务负责。在现代编程世界中，这通常包括开发、测试、部署和运维。然而，我们可能会发现，当我们为一家小公司或初创公司（像我一样）工作，或者当我们在学习（正如我们在本书中所做的那样）时，我们必须自己管理多个微服务，甚至可能是一个完整的微服务应用程序。
- en: An individual microservice might be exposed to the outside world so our customers
    can interact with it or it might be purely an internal service and not externally
    accessible. It typically has access to a database, file storage, or some other
    method of state persistence. Figure 1.3 illustrates these internal and external
    relationships.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的微服务可能对外界开放，以便我们的客户可以与之交互，或者它可能纯粹是一个内部服务，不可外部访问。它通常可以访问数据库、文件存储或其他一些状态持久化方法。图1.3展示了这些内部和外部关系。
- en: '![](../Images/CH01_F03_Davis4.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F03_Davis4.png)'
- en: Figure 1.3 A single microservice can have connections to the outside world or
    other services, and it also can have a database and/or attached file storage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 一个单独的微服务可以连接到外部世界或其他服务，它也可以拥有数据库和/或附加的文件存储。
- en: By itself, a single microservice doesn’t do much. A well-designed system, however,
    can be decomposed into such simple services. The services must collaborate with
    each other to provide the features and functionality of the greater application.
    This brings us to the topic of the microservices application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，一个微服务本身并不做什么。然而，一个设计良好的系统可以被分解成这样的简单服务。服务必须相互协作，以提供更大应用程序的功能和特性。这把我们带到了微服务应用程序的主题。
- en: 1.6 What is a microservices application?
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 什么是微服务应用程序？
- en: A microservices application is traditionally known as a *distributed application*,
    a system composed of tiny components that live in separate processes and communicate
    via the network. Each service or component resides on a logically distinct (virtual)
    computer and sometimes even on a physically separate computer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，微服务应用程序被称为*分布式应用程序*，它是由存在于单独进程中的微小组件组成的系统，并通过网络进行通信。每个服务或组件都位于一个逻辑上独立的（虚拟）计算机上，有时甚至位于一个物理上独立的计算机上。
- en: Definition A *microservices application* is a distributed program composed of
    many tiny services that collaborate to achieve the features and functionality
    of the overall project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个*微服务应用程序*是由许多小型服务组成的分布式程序，这些服务协作以实现整个项目的特性和功能。
- en: Typically, a microservices application has one or more services that are externally
    exposed to allow users to interact with the system. Figure 1.4 shows two such
    services acting as gateways for web-based and mobile phone users. You can also
    see in figure 1.4 that many services are working together within the *cluster*.
    It is called a cluster because it is a group of computers that are represented
    to us (the developers) as a single cohesive slab of computing power to be directed
    as we will. Somewhere close by we also have a database server. In figure 1.4,
    it is shown to be outside the cluster, but it could just as easily be hosted inside
    the cluster. We’ll talk more about this in chapter 4.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个微服务应用程序有一个或多个外部暴露的服务，以便用户可以与系统交互。图1.4显示了两个这样的服务作为基于Web和手机用户的网关。您还可以在图1.4中看到，许多服务在*集群*内部协同工作。它被称为集群，因为它是一组计算机，对我们（开发者）来说，它是一个单一的、统一的计算能力块，我们可以按照我们的意愿对其进行指导。附近我们还有一个数据库服务器。在图1.4中，它显示在集群之外，但它也可以轻松地托管在集群内部。我们将在第4章中更多地讨论这一点。
- en: '![](../Images/CH01_F04_Davis4.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F04_Davis4.png)'
- en: Figure 1.4 A microservices application is composed of multiple, small independent
    services running in a cluster.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 一个微服务应用程序由多个小型独立服务组成，这些服务在一个集群中运行。
- en: The cluster is hosted on a cluster orchestration platform, and we use Kubernetes
    for this purpose. *Orchestration* is the automated management of our services.
    This is what Kubernetes does for us-it helps us to deploy and manage our services.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 集群托管在集群编排平台上，我们使用Kubernetes来完成这项任务。*编排*是我们服务的自动化管理。这正是Kubernetes为我们所做的一一它帮助我们部署和管理我们的服务。
- en: The cluster itself, our database and other virtual infrastructure, are all hosted
    on our chosen cloud vendor. We will learn how to deploy this infrastructure on
    Microsoft Azure, but with some work on your own, you can change the examples in
    this book to deploy to Amazon Web Services (AWS) or Google Cloud Platform (GCP).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 集群本身、我们的数据库以及其他虚拟基础设施都托管在我们选择的云服务提供商上。我们将学习如何在Microsoft Azure上部署此基础设施，但通过你自己的努力，你可以更改本书中的示例以部署到Amazon
    Web Services (AWS)或Google Cloud Platform (GCP)。
- en: A microservices application can take many forms, is very flexible, and can be
    arranged to suit many situations. Any particular application might have a familiar
    overall structure, but the services it contains will do different jobs, depending
    on the needs of our customers and the domain of our business.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应用程序可以采取多种形式，非常灵活，可以安排以适应许多情况。任何特定的应用程序可能都有一个熟悉的整体结构，但其所包含的服务将执行不同的任务，这取决于我们客户的需要和我们的业务领域。
- en: 1.7 What’s wrong with the monolith?
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 单体的弊端是什么？
- en: What is a monolith and what is so wrong with it that we’d like to use microservices
    instead? Although distributed computing has been around for decades, applications
    were often built in the monolithic form. This is the way that the majority of
    software was developed before the cloud revolution and microservices. Figure 1.5
    shows what the services in a simple video-streaming application might look like
    and compares the differences between a monolithic version of the application and
    a microservices version.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 单体是什么，它有什么问题，以至于我们宁愿使用微服务？尽管分布式计算已经存在了几十年，但应用程序通常以单体形式构建。这是在云革命和微服务之前，大多数软件开发的方式。图1.5显示了简单视频流应用程序中的服务可能的样子，并比较了应用程序的单体版本和微服务版本之间的差异。
- en: Definition A *monolith* is an entire application that runs in a single process.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 定义：*单体*是一个运行在单个进程中的完整应用程序。
- en: '![](../Images/CH01_F05_Davis4.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5](../Images/CH01_F05_Davis4.png)'
- en: Figure 1.5 Monolith vs. microservices. You can see that building with microservices
    offers many advantages over the traditional monolithic application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 单体与微服务对比。你可以看到，使用微服务构建提供了许多相对于传统单体应用程序的优势。
- en: It is much easier to build a monolith than a microservices application. You
    need fewer technical and architectural skills. It’s a great starting point when
    building a new application, say for an early-stage product, and you want to test
    the validity of the business model before you commit to the higher technical investment
    required by a microservices application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务应用程序相比，构建单体架构要容易得多。你需要的技术和架构技能更少。当构建一个新应用程序时，例如早期产品，你希望在投入微服务应用程序所需的高技术投资之前测试商业模式的有效性，这是一个很好的起点。
- en: A monolith is a great option for creating a throw-away prototype. It also might
    be all that you need for an application that has a small scope or an application
    that stabilizes quickly and does not need to evolve or grow over its lifetime.
    If your application will always be this small, it makes sense for it to be a monolith.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 原型设计时，单体架构是一个非常好的选择。它也可能是一个范围较小或快速稳定且不需要在其生命周期内演变或增长的应用程序的最佳选择。如果你的应用程序始终如此小巧，那么将其设计为单体架构是有意义的。
- en: Deciding whether to go monolith-first or microservices-first is a balancing
    act that has traditionally been won by the monolith. However, in this book, I’ll
    show you, given the improvements in modern tooling and with cheap and convenient
    cloud infrastructure, that it’s important that you at least consider building
    microservices-first.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 决定是先单体后微服务，还是先微服务后单体，这是一个平衡行为，传统上是由单体获胜的。然而，在这本书中，我将向你展示，鉴于现代工具的改进以及廉价便捷的云基础设施，至少考虑先构建微服务架构是很重要的。
- en: Most products generally need to grow and be evolved, and as your monolith grows
    bigger and has more useful features, it becomes more difficult to justify throwing
    away the throw-away prototype. So down the road, you could find yourself stuck
    with the monolith at a time when what you really need is the flexibility, security,
    and scalability of a microservices application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数产品通常需要成长和进化，随着你的单体架构变得更大，具有更多有用功能，就更加难以证明丢弃临时原型是合理的。所以，在未来的某个时候，你可能会发现自己被困在单体架构中，而此时你真正需要的是微服务应用的灵活性、安全性和可扩展性。
- en: Monoliths come with a host of potential problems. These start out small, and
    we always have the best of intentions of keeping the code clean and well organized.
    A good team of developers can keep a monolith elegant and well organized for many
    years. But as time passes, the vision can be lost or sometimes there wasn’t a
    strong vision in the first place. All the code runs in the same process, so there
    are no barriers and nothing to stop us writing a huge mess of spaghetti code that
    will be near impossible to pick apart later.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构带来了一系列潜在问题。这些问题最初很小，我们总是怀有最好的意图，保持代码干净和井井有条。一支优秀的开发团队能够让单体架构保持优雅和井井有条多年。但随着时间的推移，愿景可能会丢失，有时一开始就没有强烈的愿景。所有代码都在同一个进程中运行，因此没有障碍，也没有什么可以阻止我们编写一团糟的意大利面代码，这种代码在以后几乎不可能拆分。
- en: Staff turnover also has a big effect. As developers leave the team they take
    crucial knowledge with them, and they are replaced by new developers who will
    have to develop their own mental model of the application, which could easily
    be at odds with the original vision. Time passes, code changes hands many times,
    and these negative forces conspire to devolve the codebase into what is called
    a big ball of mud. This name denotes the messy state of the application when there
    is no longer a discernible architecture.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 人员流动也产生了重大影响。随着开发人员离开团队，他们带走了关键知识，而新来的开发人员则需要建立自己对应用的思维模型，这可能与原始愿景相冲突。时间流逝，代码多次易手，这些负面因素共同导致代码库退化成所谓的“一团糟”。这个名字描述了当应用不再有可识别架构时的混乱状态。
- en: Updating the code for a monolith is a risky affair. It’s all or nothing. When
    you push a code change that breaks the monolith, the entire application ceases
    operation, your customers are left high and dry, and your company bleeds money.
    We might only want to change a single line of code, but still, we must deploy
    the entire monolith and risk breaking it. This risk stokes deployment fear. Fear
    slows the pace of development.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 更新单体架构的代码是一件风险很高的事情。要么全有，要么全无。当你推送一个破坏单体的代码更改时，整个应用将停止运行，你的客户将陷入困境，你的公司会损失金钱。我们可能只想更改一行代码，但仍然必须部署整个单体，并承担破坏它的风险。这种风险加剧了部署恐惧。恐惧减缓了开发速度。
- en: In addition, as the structure of the monolith degenerates, our risk of breaking
    it in unanticipated ways increases. Testing becomes harder and breeds yet more
    deployment fear. Have I convinced you that you should try microservices? Wait,
    there’s more!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着单体架构的结构退化，我们以不可预见的方式破坏它的风险增加。测试变得更加困难，并滋生更多的部署恐惧。我已经说服你尝试微服务了吗？等等，还有更多！
- en: Due to the sheer size of an established monolith, testing is problematic, and
    because of its extremely low level of granularity, it is difficult to scale. Eventually,
    the monolith expands to consume the physical limits of the machine it runs on.
    As the aging monolith consumes more and more physical resources, it becomes more
    expensive to run. I have witnessed this! To be fair, this kind of eventuality
    might be a long way off for any monolith, but even after just a few years of growth,
    the monolith leads to a place that you would prefer not to be.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现有单体架构的规模庞大，测试变得困难，由于其极低的粒度级别，扩展也变得困难。最终，单体架构会扩展到消耗其运行的机器的物理极限。随着老化的单体架构消耗越来越多的物理资源，运行成本越来越高。我亲眼见过这种情况！公平地说，这种可能性对于任何单体架构来说可能还遥不可及，但即使只是几年增长，单体架构也会把你带到你不想去的地方。
- en: 'Despite the eventual difficulties with the monolith, it remains the simplest
    way to bootstrap a new application. Shouldn’t we always start with a monolith
    and later restructure when we need to scale? My answer: *it depends*.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单体架构最终会遇到困难，但它仍然是启动新应用最简单的方式。难道我们不应该总是从单体架构开始，并在需要扩展时进行重构吗？我的回答是：*视情况而定*。
- en: Many applications will always be small. There are plenty of small monoliths
    in the wild that do their job well and don’t need to be scaled or evolved. Because
    these are not expanding, they do not suffer the problems of growth. If you believe
    your application will remain small and simple and doesn’t need to evolve, you
    should definitely build it as a monolith.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序始终会保持小型。野外有大量的小型单体应用，它们能很好地完成工作，不需要扩展或进化。因为这些应用没有扩张，所以它们不会遭受增长带来的问题。如果你认为你的应用程序将保持小型和简单，并且不需要进化，那么你绝对应该将其构建为一个单体。
- en: There are many applications, however, that we can easily predict will benefit
    from a microservices-first approach. These are the kinds of applications we know
    will continually be evolved over many years. Other applications that can benefit
    are those that need to be flexible, scalable, or have security constraints from
    the start. Building these types of applications is much easier if you start with
    microservices because converting an existing monolith is difficult and risky.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多应用程序我们可以很容易地预测将受益于微服务优先的方法。这些是我们知道将在多年内持续进化的应用程序类型。其他可以从中受益的应用程序是那些需要灵活、可扩展或从一开始就有安全约束的应用程序。如果你从微服务开始构建这些类型的应用程序，那么构建起来会容易得多，因为将现有单体转换为微服务既困难又风险高。
- en: By all means, if you need to validate your business idea first, do so by initially
    building a monolith. However, even in this case, I would argue that with the right
    tooling, prototyping with microservices isn’t much more difficult than prototyping
    with a monolith. After all, what is a monolith if not a single large service?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你需要首先验证你的商业想法，那么你可以通过最初构建一个单体来这样做。然而，即使在这种情况下，我仍然认为，有了合适的工具，使用微服务进行原型设计并不比使用单体原型设计困难多少。毕竟，单体如果不是一个单一的大型服务又是什么呢？
- en: You might even consider using the techniques in this book to bootstrap your
    monolith as a single service within a Kubernetes cluster. Now you have the best
    of both worlds! When the time comes to decompose to microservices, you are already
    in the best possible position to do so and, at your leisure, you can start chipping
    microservices off the monolith. And with the ease of automated deployment that
    modern tooling offers, it is easy to tear down and recreate your application or
    create replica environments for development and testing. If you want or need to
    create a monolith first, you can still benefit from the techniques and technologies
    presented in this book.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以考虑使用本书中的技术来启动你的单体，将其作为一个单一服务在Kubernetes集群中。现在你拥有了两者之最佳！当需要分解为微服务的时候，你已经处于最佳位置去做这件事，并且在你方便的时候，你可以开始从单体中剥离微服务。并且，有了现代工具提供的自动化部署的便利性，拆解和重建你的应用程序或创建用于开发和测试的副本环境变得容易。如果你想要或需要首先创建一个单体，你仍然可以从本书中介绍的技术和工具中受益。
- en: If you do start with a monolith, for your own sanity and as early as possible,
    either throw it away and replace it or incrementally restructure it into microservices.
    We’ll talk more about breaking up existing monoliths in chapter 11.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实从单体开始，为了你自己的精神健康，并且尽可能早地，要么丢弃它并替换它，要么逐步将其重构为微服务。我们将在第11章中更多地讨论拆分现有单体的问题。
- en: 1.8 Why are microservices popular now?
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 为什么微服务现在这么受欢迎？
- en: Why does it seem that right now microservices are exploding in popularity? Is
    this just a passing fad?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么现在微服务似乎正变得越来越受欢迎？这是否只是一个短暂的潮流？
- en: 'No, it is not a passing fad. Distributed computing has been around for a long
    time and has always had many advantages over monolithic applications. Traditionally
    though, it has been more complex and more costly to build applications in this
    way. Developers only reached for these more powerful application architectures
    for the most demanding problems: those where the value of the solution would outweigh
    the cost of the implementation.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这并不是一个短暂的潮流。分布式计算已经存在很长时间，并且始终在单体应用之上拥有许多优势。然而，传统上，以这种方式构建应用程序更加复杂和昂贵。开发者只有在面对最苛刻的问题时才会寻求这些更强大的应用架构：那些解决方案的价值会超过实现成本的案例。
- en: In recent times, however, with the advent of cloud technology, virtualization,
    and the creation of automated tools for managing our virtual infrastructure, it
    has become much less expensive to build such distributed systems. As it became
    cheaper to replace monolithic applications with distributed applications, we naturally
    considered the ways this could improve the structure of our applications. In doing
    so, the components of our distributed systems have shrunk to the tiniest possible
    size so that now we call them *microservices*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，近年来，随着云计算、虚拟化和自动化工具的创建，用于管理我们的虚拟基础设施，构建这样的分布式系统变得更加便宜。随着用分布式应用程序替换单体应用程序变得更加便宜，我们自然会考虑这种方法如何改善我们应用程序的结构。在这样做的时候，我们分布式系统的组件已经缩小到可能的最小尺寸，因此现在我们称之为
    *微服务*。
- en: That’s why microservices are popular now. Not only are they generally a worthwhile
    way to build complex modern applications, but they are also increasingly *cost-effective*.
    Distributed computing has become more accessible than ever before, so naturally
    more developers are using it. Right now, it appears to be nearing critical mass,
    and so it’s reaching the mainstream.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，微服务现在很受欢迎。它们不仅通常是一种构建复杂现代应用的值得尝试的方法，而且它们也越来越具有成本效益。分布式计算比以往任何时候都更容易获得，因此自然有更多的开发者开始使用它。目前，它似乎正在接近临界质量，因此正在进入主流。
- en: But why are microservices so good? How do they improve the structure of our
    application? This question leads to the benefits of microservices.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么微服务如此优秀？它们是如何改善我们应用程序的结构？这个问题引出了微服务的优势。
- en: 1.9 Benefits of microservices
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9 微服务的优势
- en: 'Building distributed applications brings many advantages. Each service can
    potentially have its own dedicated CPU, memory, and other resources. Typically
    though, we share physical infrastructure between many services and that’s what
    makes microservices cost-effective. But we are also able to separate these out
    when necessary so that the services with the heaviest workloads can be allocated
    dedicated resources. We can say that each small service is independently scalable,
    and this gives us a fine-grained ability to tune the performance of our application.
    In this section, we look at these benefits:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构建分布式应用程序带来了许多优势。每个服务都可能拥有自己的专用CPU、内存和其他资源。通常情况下，我们在许多服务之间共享物理基础设施，这就是微服务具有成本效益的原因。但我们在必要时也可以将这些服务分离出来，以便为工作负载最重的服务分配专用资源。我们可以这样说，每个小型服务都是独立可扩展的，这使我们能够精细调整应用程序的性能。在本节中，我们将探讨这些优势：
- en: '*Allows for fine-grained control*-Microservices allow us to build an application
    with fine-grained control over scalability'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*允许精细控制*- 微服务使我们能够对可扩展性进行精细控制'
- en: '*Minimizes deployment risk*-Microservices help us minimize deployment risk
    while maximizing the pace of development'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最小化部署风险*- 微服务帮助我们最小化部署风险，同时最大化开发速度'
- en: '*Lets you choose your own tech stack*-Microservices allow us to choose the
    right stack for the task at hand so that we aren’t constrained to a single tech
    stack'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*允许选择自己的技术栈*- 微服务使我们能够为手头的任务选择合适的技术栈，这样我们就不会局限于单一的技术栈'
- en: Having a distributed application offers us the potential for better reliability
    and reduced deployment risk. When we update a particular service we can do so
    without the risk of breaking the entire application. Of course, we might still
    risk breaking a part of the application, but that is better and easier to recover
    from than bringing down the entire application. When problems occur, it’s easier
    to rollback just a small part of the system rather than the whole. Reduced deployment
    risk has the knock-on effect of promoting frequent deployments, and this is essential
    to agility and sustaining a fast pace of development.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有分布式应用程序为我们提供了更好的可靠性和降低部署风险的可能性。当我们更新特定服务时，我们可以这样做，而不会冒着破坏整个应用程序的风险。当然，我们仍然可能冒着破坏应用程序一部分的风险，但这比关闭整个应用程序更容易恢复。当出现问题时，只需回滚系统的一小部分，而不是整个系统，这要容易得多。降低部署风险对促进频繁部署有连锁反应，这对于敏捷性和保持快速的开发速度至关重要。
- en: These benefits are nothing new. After all, we have built distributed applications
    for a long time, but such systems have become cheaper to build and the tools have
    improved. It is easier than ever before to build applications this way and to
    reap the rewards. As costs decreased and deployment convenience increased, our
    services tended towards the micro-level, and this brought its own complement of
    benefits.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些好处并不是什么新鲜事。毕竟，我们已经构建了分布式应用程序很长时间了，但这样的系统现在建造成本更低，工具也更好了。以这种方式构建应用程序并从中获益比以往任何时候都更容易。随着成本的降低和部署便利性的增加，我们的服务倾向于向微级别发展，这也带来了它自己的配套好处。
- en: Smaller services are quicker to boot than larger services. This helps make our
    system easier to scale because we can quickly replicate any service that becomes
    overloaded. Smaller services are also easier to test and troubleshoot. Even though
    testing an overall system can still be difficult, we can more easily prove that
    each individual part of it is working as expected.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 较小的服务启动比大型服务快。这有助于使我们的系统更容易扩展，因为我们可以快速复制任何过载的服务。较小的服务也更容易进行测试和故障排除。尽管测试整个系统仍然可能很困难，但我们更容易证明它的每个部分都在按预期工作。
- en: Building applications with many small and independently upgradeable parts means
    we can have an application that is more amenable to being extended, evolved, and
    rearranged over its lifetime. The fact that we have enforced process boundaries
    between our components means that we will never be tempted to write spaghetti
    code. And, indeed, if we do write terrible code (we all have bad days, right?),
    the impact of bad code is controlled and isolated because every microservice (to
    earn the name) should be small enough that it can be thrown away and rewritten
    within a matter of weeks, if not days. In this sense, we are *designing our code
    for disposability*. We are designing it to be replaced over time. The ongoing
    and iterative replacement of our application is not only made possible, but it
    is actively encouraged, and this is what we need for our application architecture
    to survive the continuously evolving needs of the modern business.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用许多小型且可独立升级的部分构建应用程序意味着我们可以拥有一个在其生命周期内更容易扩展、演变和重新排列的应用程序。我们强制在组件之间建立流程边界的事实意味着我们永远不会被诱惑去编写意大利面代码。实际上，如果我们确实编写了糟糕的代码（我们都有糟糕的日子，对吧？），糟糕代码的影响将被控制和隔离，因为每个微服务（为了获得这个名字）应该足够小，以至于可以在几周甚至几天内被丢弃并重新编写。从这个意义上说，我们正在*设计我们的代码以供丢弃*。我们正在设计它以便随着时间的推移进行替换。我们应用程序的持续和迭代替换不仅成为可能，而且被积极鼓励，这正是我们应用程序架构能够适应现代商业不断变化需求的关键。
- en: Another benefit that really excites developers using microservices is that we
    are no longer constrained to a single technology stack for our application. Each
    service in our application can potentially contain any tech stack. For larger
    companies, this means that different teams can choose their own tech stack; they
    can choose it based on their experience or based on the stack that is best for
    the job at hand. Various tech stacks can co-exist within our cluster and work
    together using shared protocols and communication mechanisms.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用微服务的开发者来说，另一个真正令人兴奋的好处是我们不再受限于为我们的应用程序使用单一技术栈。我们应用程序中的每个服务都可能包含任何技术栈。对于大型公司来说，这意味着不同的团队可以选择自己的技术栈；他们可以根据自己的经验或根据最适合当前工作的技术栈来选择。各种技术栈可以存在于我们的集群中，并使用共享协议和通信机制协同工作。
- en: Being able to change between tech stacks is important for the long-term health
    of the application. As the tech landscape evolves, as it always does, older tech
    stacks fall out of favor and must eventually be replaced by new ones. Microservices
    create a structure that can be progressively converted to newer tech stacks. As
    developers, we no longer need languish on out-of-date technologies.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在技术栈之间进行切换对于应用程序的长期健康至关重要。随着技术领域的不断演变，就像它总是做的那样，旧的技术栈会失去优势，最终必须被新的技术栈所取代。微服务创建了一种可以逐步转换为更新技术栈的结构。作为开发者，我们不再需要滞留在过时的技术上了。
- en: Technology (tech) stack
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 技术栈（tech stack）
- en: Your technology stack is the combination of tools, software, and frameworks
    on which you build each microservice. You can think of it as the fundamental underlying
    elements needed by your application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你的技术栈是你构建每个微服务所使用的工具、软件和框架的组合。你可以将其视为你的应用程序所需的基本基础元素。
- en: Some stacks have names. For example, MEAN (Mongo, Express, Angular, Node.js)
    or LAMP (Linux, Apache, MySQL, PHP). But your stack is just the combination of
    tools you use, and it doesn’t need a name to be valid.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些栈有名字。例如，MEAN（Mongo, Express, Angular, Node.js）或LAMP（Linux, Apache, MySQL,
    PHP）。但你的栈只是你使用的工具的组合，它不需要名字就是有效的。
- en: When building a monolith, we have to choose a single tech stack, and we have
    to stay with that stack for as long as the monolith remains in operation. The
    microservices architecture is appealing because it gives us the potential to use
    multiple tech stacks within one application. This allows us to change our tech
    stack over time as we evolve our application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建单体应用时，我们必须选择一个技术栈，并且必须在这个栈上保持不变，直到单体应用停止运行。微服务架构之所以吸引人，是因为它给了我们在一个应用程序中使用多个技术栈的潜力。这允许我们在应用演变的过程中随着时间的推移改变我们的技术栈。
- en: 1.10 Drawbacks of microservices
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10 微服务的缺点
- en: 'This chapter would not be complete without addressing the two main problems
    that people have with microservices:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章如果不讨论人们与微服务相关的两个主要问题，就不会完整：
- en: Microservices are more difficult
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务更难
- en: People often fear complexity
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们常常害怕复杂性
- en: The first problem is the steep learning curve. Learning how to build microservices
    requires you to learn not just a complicated arrangement of technologies, but
    also the principles and techniques for building distributed applications. Although
    learning how to build microservices is difficult, this book will help you shortcut
    the learning curve.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是陡峭的学习曲线。学习如何构建微服务需要你学习不仅仅是复杂的技术组合，还要学习构建分布式应用的原则和技术。虽然学习如何构建微服务是困难的，但这本书将帮助你缩短学习曲线。
- en: Note I can understand if you feel daunted by what’s in front of you. But recently,
    huge progress has been made in the development of tooling for building distributed
    applications. Our tools are now more sophisticated, easier to use, and most importantly,
    more *automatable* than ever before.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我能够理解如果你对面前的东西感到畏惧。但最近，在构建分布式应用的工具开发方面取得了巨大的进步。我们的工具现在更加复杂，更容易使用，最重要的是，比以往任何时候都更加*自动化*。
- en: These days, a single experienced developer is now capable of bootstrapping a
    microservices application on their own without the support of a team. I know this
    because I have done this multiple times for startups. Still, it surprises me how
    much can be achieved on one’s own. We’ll talk more about how startups, small teams,
    and solo developers can work with microservices quickly and effectively in chapter
    11.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个经验丰富的开发者现在能够独立启动微服务应用程序，而不需要团队的支持。我知道这一点，因为我已经为多家初创公司做过多次。尽管如此，我还是很惊讶一个人能取得多大的成就。我们将在第11章中更多地讨论初创公司、小型团队和独立开发者如何快速有效地与微服务合作。
- en: To be fair, the tools are *still* complicated. Ordinarily, it would take months
    or longer to conquer the learning curve on your own-mastering any of these tools
    takes significant time! But this book takes a different approach. Together we
    will only learn the bare minimum necessary to bootstrap our application and get
    it running in production. Together we will produce a simple but working microservices
    application. Along the way, we’ll also learn the basics of structuring distributed
    applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，工具仍然很复杂。通常，你需要数月甚至更长时间才能独自克服学习曲线——掌握这些工具需要大量的时间！但本书采取了不同的方法。我们将一起学习启动我们的应用程序并使其在生产中运行所需的最基本知识。我们将一起创建一个简单但实用的微服务应用程序。在这个过程中，我们还将学习构建分布式应用的基础知识。
- en: As I mentioned, there are actually two problems facing microservices developers.
    The second is that building a microservices application, indeed any distributed
    application, is going to be more complicated than building the equivalent monolith.
    It is hard to argue with this. The first thing I would say is that yes, building
    a monolith is simpler in the beginning and in many cases it is the right decision.
    If your application is one of those that must later be converted or restructured
    to microservices however, then you should consider the eventual cost of unraveling
    your big ball of mud.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，微服务开发者实际上面临两个问题。第二个问题是构建微服务应用程序，实际上任何分布式应用程序，都将比构建等效的单体应用更复杂。这一点很难反驳。我首先想说，是的，构建单体应用在开始时更简单，在许多情况下这是正确的决定。如果你的应用程序是那些必须后来转换为微服务或重构的应用程序之一，那么你应该考虑解开你的大泥球最终的成本。
- en: Don’t be frightened by complexity; it happens whether you like it or not. Fortunately,
    microservices offer us tangible ways of managing complexity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被复杂性吓倒；无论你是否喜欢，它都会发生。幸运的是，微服务为我们提供了管理复杂性的具体方法。
- en: 'If you think this through, you might concede that building microservices, at
    least in certain situations, is actually less complicated than building a monolith.
    If this discussion hasn’t convinced you, consider this: *any* significant application
    is going to become complex. If not at the start, it *will* grow more complex over
    time. You can’t hide from complexity in modern software development, it *always*
    catches up with you, eventually. Instead, let’s take control of this situation
    and meet the complexity head-on. What we want are better tools to help manage
    complexity. Microservices as an architectural pattern is one such tool.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细思考，你可能会承认，至少在某些情况下，构建微服务实际上比构建单体应用程序更简单。如果这次讨论还没有说服你，考虑这一点：*任何*重要的应用程序最终都会变得复杂。如果不是一开始，它*将会*随着时间的推移变得更加复杂。你无法在现代软件开发中隐藏复杂性，它*总是*最终会追上你。相反，让我们控制这种局面，直面复杂性。我们想要的更好的工具来帮助我们管理复杂性。微服务作为一种架构模式就是这样一种工具。
- en: Think of microservices as a way to bring the pain forward, to a place where
    it’s more economical to deal with. What do we get in return for this pain? Microservices
    offer us tangible ways to manage complexity in our application. They provide hard
    boundaries that prevent us from writing spaghetti code. Microservices allow us
    to more easily rewire our application, scale it, and upgrade it over time. Microservices
    also force us to apply better design. We can’t prevent complexity, but we can
    manage it, and modern tooling for distributed applications is already here to
    help us.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将微服务视为将痛苦提前，到一个处理起来更经济的地方的方法。为此痛苦，我们得到了什么回报？微服务为我们提供了管理应用程序复杂性的具体方法。它们提供了硬边界，防止我们编写意大利面代码。微服务使我们能够更容易地重新布线我们的应用程序，随着时间的推移进行扩展和升级。微服务还迫使我们应用更好的设计。我们无法阻止复杂性，但我们可以管理它，而现代分布式应用程序的工具已经在这里帮助我们了。
- en: 1.11 Modern tooling for microservices
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.11 微服务的现代工具
- en: This book is all about the tooling. Together, we will learn the basics of a
    number of dif-ferent tools. To start with, we must be able to create a microservice.
    We’ll use JavaScript and Node.js to do this, and the next chapter will teach you
    the basics of that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书全部关于工具。我们将一起学习许多不同工具的基础知识。首先，我们必须能够创建一个微服务。我们将使用 JavaScript 和 Node.js 来完成这项工作，下一章将教你这方面的基础知识。
- en: 'We are using Node.js because that’s my weapon of choice. However, as far as
    microservices are concerned, the technology stack within the service is not particularly
    important. We could just as easily build our microservices with Python, Ruby,
    Java, Go, or virtually any other language. We’ll encounter numerous tools along
    our journey, but these are the most important ones:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Node.js，因为那是我的选择。然而，就微服务而言，服务内部的技术堆栈并不特别重要。我们同样可以用 Python、Ruby、Java、Go
    或几乎任何其他语言来构建我们的微服务。在我们旅途中，我们将遇到许多工具，但这些都是最重要的：
- en: '*Docker* —To package and deploy our services'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker* —打包和部署我们的服务'
- en: '*Docker Compose* —To test our microservices application on our development
    workstation'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker Compose* —在开发工作站上测试我们的微服务应用程序'
- en: '*Kubernetes* —To host our application in the cloud'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes* —在云端托管我们的应用程序'
- en: '*Terraform* —To build our cloud infrastructure, our Kubernetes cluster, and
    deploy our application'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Terraform* —构建我们的云基础设施，我们的 Kubernetes 集群，并部署我们的应用程序'
- en: The technological landscape is always changing and so are the tools. So why
    should we learn any particular toolset when the tools are constantly outdated
    and replaced? Well, it’s because we will always need good tools to work effectively.
    And with better tools, we can do a better job, or maybe we just get to do the
    same job but more effectively. Either way, this helps us to be more productive.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 技术景观总是在变化，工具也是如此。那么，为什么我们应该学习任何特定的工具集，当工具不断过时并被取代时？嗯，这是因为我们始终需要好的工具来有效地工作。有了更好的工具，我们可以做得更好，或者也许我们只是更有效地完成同样的工作。无论如何，这有助于我们提高生产力。
- en: I selected the tools for this book because these make the job of building microservices
    applications significantly easier and quicker. All technologies change in time,
    but I don’t think these particular tools are going anywhere soon. They are popular,
    are currently the best we have, and all fill useful positions in one’s toolkit.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择这本书的工具，因为这些工具可以显著简化构建微服务应用程序的工作，并使其更快。所有技术都会随时间而变化，但我认为这些特定的工具不会很快消失。它们很受欢迎，目前是我们拥有的最好的工具，并且都在一个人的工具箱中占据有用的位置。
- en: Of course, these tools will eventually be replaced, but hopefully, in the meantime,
    we’ll have extracted significant value from these and built many good applications.
    And when the tools do change, they will certainly be replaced by better tools
    that lift the bar of abstraction even higher, making our jobs easier and less
    frustrating.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些工具最终会被取代，但希望在这段时间里，我们能够从这些工具中提取出显著的价值，并构建许多优秀的应用程序。当工具发生变化时，它们肯定会由更好的工具所取代，这些工具将进一步提高抽象层次，使我们的工作更加容易，减少挫败感。
- en: Docker is the one tool out of all the tools that is more or less ubiquitous.
    It seems to have almost come from nowhere and has taken over our industry. Kubernetes
    on the other hand is not quite as ubiquitous as Docker, although it does have
    a strong future because it allows us to transcend the boundaries of cloud vendors.
    This is good news if you ever felt trapped with your particular cloud provider.
    We can run our Kubernetes-based application on pretty much any cloud platform,
    and we have freedom of movement when needed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是所有工具中几乎无处不在的一个。它似乎是从无到有，并接管了我们的行业。另一方面，Kubernetes并不像Docker那样无处不在，尽管它确实有一个强大的未来，因为它允许我们超越云供应商的界限。如果你曾经感到被特定的云提供商所困，这是一个好消息。我们几乎可以在任何云平台上运行基于Kubernetes的应用程序，并在需要时拥有行动的自由。
- en: Terraform is a relative newcomer, but I think it’s a game-changer. It’s a declarative
    configuration language that allows us to script the creation of cloud resources
    and the deployment of our services. The important thing about Terraform is that
    it’s one language that can work with potentially any cloud vendor. No matter which
    cloud vendor you choose, now or in the future, chances are that Terraform will
    support it, and you won’t have to learn something new.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform是一个相对较新的工具，但我认为它是一个变革者。它是一种声明性配置语言，允许我们编写脚本以创建云资源并部署我们的服务。Terraform的重要之处在于，它是一种可以与任何潜在云供应商一起工作的单一语言。无论你现在或将来选择哪个云供应商，Terraform很可能都会支持它，你不需要学习新的东西。
- en: 'Think about this for a moment: *Terraform means we can easily code the creation
    of cloud infrastructure*. This is something! In the past, we would laboriously
    and physically piece together infrastructure, but now we are able to create it
    with code. This concept is called *infrastructure as code* and it is a key enabler
    for *continuous delivery*, something important to modern software development
    that we’ll look at in chapter 7.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看：*Terraform意味着我们可以轻松地用代码创建云基础设施*。这真是个大事情！在过去，我们不得不辛苦地物理拼接基础设施，但现在我们能够用代码来创建它。这个概念被称为*基础设施即代码*，它是*持续交付*的关键推动力，这在第7章中我们将探讨的现代软件开发中的重要内容。
- en: 1.12 Designing a microservices application
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.12 设计微服务应用程序
- en: This isn’t a book about theory, but I do have to touch on some of the software
    design aspects before we get into the practical stuff. I promise this is just
    some foundational principles, and there are plenty of other books to help you
    get a better grounding in this space.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于理论的书籍，但在我们进入实际内容之前，我必须简要提及一些软件设计方面。我保证这只是一些基础原则，而且有很多其他书籍可以帮助你在这一领域打下更好的基础。
- en: 'At the outset, I’d like to say that designing a microservices application isn’t
    particularly different from designing any software. You can read any good book
    on software design and apply those same principles and techniques to microservices.
    There aren’t many hard and fast rules that I follow, but I feel these few are
    especially important:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，我想说，设计微服务应用程序与设计任何软件并没有太大的不同。你可以阅读任何关于软件设计的优秀书籍，并将相同的原理和技术应用于微服务。我没有太多严格遵循的规则，但我认为这些规则特别重要：
- en: Don’t over design or try and future proof your architecture. Start with a simple
    design for your application.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要过度设计或试图使你的架构具有前瞻性。从你应用程序的简单设计开始。
- en: Apply continuous refactoring during development to keep it as simple as it can
    be.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发过程中应用持续重构，以保持其尽可能简单。
- en: Let a good design emerge naturally.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让一个好的设计自然出现。
- en: I feel that the last rule is especially encouraged by microservices. You can’t
    conclusively preplan a big microservices application. The architecture has to
    emerge during development and over the lifetime of the application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得最后一个规则特别受到微服务的鼓励。你无法预先规划一个大的微服务应用程序。架构必须在开发过程中以及应用程序的生命周期中逐渐显现。
- en: 'I’m not saying that you shouldn’t do any planning. You definitely should be
    planning at every stage of development. What I am saying is that you should be
    planning for your plan to change! You should be able to respond quickly to changing
    circumstances, and that’s another thing that’s well supported by microservices.
    Rules aside, let’s briefly discuss three principles that seem particularly relevant
    to microservices:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说你不应该做任何规划。你肯定应该在开发的每个阶段进行规划。我想说的是，你应该为你的计划可能发生变化做好准备！你应该能够快速应对变化的情况，这也是微服务所支持的另一个优点。抛开规则不谈，让我们简要讨论三个似乎特别适用于微服务的原则：
- en: Single responsibility principle
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Loose coupling
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合
- en: High cohesion
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高内聚
- en: Generally, we’d like to have each microservice be as small and simple as possible.
    One individual service should cover only a single conceptual area of the business.
    That is to say that each service should have a single, well-defined area of responsibility.
    This is normally known as the *single responsibility principle*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望每个微服务尽可能小和简单。一个单独的服务应该只覆盖业务的一个概念领域。也就是说，每个服务应该有一个单一、明确的职责区域。这通常被称为**单一职责原则**。
- en: Microservices should be *loosely coupled* and have *high cohesion*. Loosely
    coupled means that the connections between services are minimal and that they
    don’t share information unless necessary. When we reduce the connections and dependencies
    between microservices, we make it easier to upgrade individual services without
    having problems propagate through the application. Loose coupling helps us pull
    apart and rewire our application into new configurations. This makes our application
    more flexible and responsive to the changing needs of the business.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该是**松散耦合**并且具有**高内聚**。松散耦合意味着服务之间的连接最小化，并且除非必要，它们不共享信息。当我们减少微服务之间的连接和依赖关系时，我们使得升级单个服务而不会导致问题在应用程序中传播变得更容易。松散耦合帮助我们拆分并重新布线我们的应用程序，使其进入新的配置。这使得我们的应用程序更加灵活，能够对业务变化的需求做出快速响应。
- en: The code contained within a microservice should be highly cohesive. This means
    that all the code in a microservice *belongs together* and contributes to solve
    the problem that is the service’s area of responsibility. If a microservice solves
    more than one problem or has a larger area of responsibility, then this is an
    indication that it is not highly cohesive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务内部包含的代码应该是高度内聚的。这意味着微服务中的所有代码都*属于一起*，并有助于解决服务职责区域内的难题。如果一个微服务解决了一个以上的问题或有一个更大的职责区域，那么这表明它不是高度内聚的。
- en: A design paradigm that works well for microservices is called *domain driven
    design* (DDD). Using DDD is a great way to understand the domain of a business
    and to model the business as software. The technique comes from the book, *Domain
    Driven Design*, by Eric Evans (2003). I have used it multiple times myself and
    find that it maps well to designing distributed applications. Specifically, the
    concept of the *bounded context* fits well to the boundary of a microservice as
    illustrated in figure 1.6.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常适合微服务的架构范式被称为**领域驱动设计**（DDD）。使用DDD是理解业务领域并作为软件来建模业务的一个很好的方法。这种技术源自埃里克·埃文斯（Eric
    Evans）所著的《领域驱动设计》（Domain Driven Design）一书（2003年）。我自己多次使用过它，并发现它非常适合设计分布式应用程序。具体来说，*边界上下文*的概念非常适合微服务的边界，如图1.6所示。
- en: '![](../Images/CH01_F06_Davis4.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F06_Davis4.png)'
- en: Figure 1.6 Bounded contexts from domain driven design (DDD) equate to the boundaries
    of microservices.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 领域驱动设计（DDD）中的边界上下文等同于微服务的边界。
- en: This figure shows how the boundaries of concepts in our video-streaming domain
    might fit into microservices. Concepts such as *User*, *Like*, and *Video* live
    within our microservices, and some concepts (like Video) create the relationships
    between microservices. For example, in figure 1.6, the idea of a video is almost
    the same (but there can be differences) between the recommendations and the video-storage
    microservices.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了我们的视频流领域中的概念边界可能如何适应微服务。例如，*用户*、*点赞*和*视频*等概念存在于我们的微服务中，而某些概念（如视频）创建了微服务之间的关系。例如，在图1.6中，视频的概念在推荐和视频存储微服务之间几乎是相同的（但可能会有所不同）。
- en: There is a coding principle that seems like it might be under attack by microservices.
    Many developers live by the motto *don’t repeat yourself* (DRY). But in the world
    of microservices, we are developing a higher tolerance for duplicated code than
    what was previously considered acceptable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个编码原则似乎正受到微服务的攻击。许多开发者遵循“不要重复自己”（DRY）的座右铭。但在微服务的世界中，我们正在发展出比以前认为可接受的高容忍度来容忍重复的代码。
- en: The hard process boundaries in a microservices application certainly make it
    more difficult to share code, and the practice of DDD seems to encourage duplicating
    concepts, if not replicating code. Also, when microservices are owned by separate
    teams, we then encounter all the usual barriers to sharing code that already exists
    between teams.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应用中的硬边界过程无疑使得代码共享变得更加困难，而领域驱动设计（DDD）的实践似乎鼓励复制概念，如果不是复制代码。此外，当微服务由不同的团队拥有时，我们就会遇到团队之间已经存在的所有共享代码的障碍。
- en: Be assured, there are good ways to share code between microservices, and we
    aren’t simply going to throw out DRY. We’d still like to share code between microservices
    when it makes sense to do so.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请放心，有很好的方法在微服务之间共享代码，我们不会简单地抛弃DRY原则。当这样做有意义时，我们仍然希望在微服务之间共享代码。
- en: 1.13 An example application
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.13 一个示例应用
- en: By the end of this book, we’ll have built a simple but complete microservices
    application. In this section, we’ll develop an idea of what the final product
    looks like.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到这本书的结尾，我们将构建一个简单但完整的微服务应用。在本节中，我们将形成一个关于最终产品外观的概念。
- en: The example product we will build is a video-streaming application. Every good
    product deserves a name, so after much brainstorming and throwing around various
    ideas, I’ve landed on the name *FlixTube*, the future king of the video-streaming
    world. Gotta start somewhere right?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的示例产品是一个视频流应用。每个优秀的产品都值得一个名字，所以在经过多次头脑风暴和提出各种想法之后，我最终选择了“FlixTube”，这是视频流世界的未来之王。不是吗，总得从某个地方开始？
- en: Why choose video streaming as the example? Simply because it’s a fun example
    and is surprisingly easy to create (at least in a simple form). It’s also a well-known
    use case for microservices, being the approach successfully taken to the extreme
    by Netflix. (Reports vary, but we know they run 100s if not 1,000s of microservices.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择视频流作为示例？简单来说，这是一个有趣的例子，而且出人意料地容易创建（至少在简单形式上）。它也是微服务的一个知名用例，Netflix成功地将其推向了极致。（报道各有不同，但我们知道他们运行了成百上千个微服务。）
- en: We’ll use the FlixTube example application to demonstrate the process of constructing
    a microservices application. It will only have a small number of microservices,
    but we will build-in the pathways we need for future scalability, including adding
    more virtual machines to the cluster, replicating services for scale and redundancy,
    and extracting services to separate code repositories so these can have separate
    deployment schedules and be managed by separate teams.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用FlixTube示例应用来展示构建微服务应用的过程。它将只有少数几个微服务，但我们将内置未来可扩展性所需的路径，包括向集群添加更多虚拟机、复制服务以实现规模和冗余，以及将服务提取到单独的代码仓库，以便它们可以拥有单独的部署计划并由不同的团队管理。
- en: Our application will have a browser-based front end so our users can view a
    list of videos. From there they can select a video and it will begin playing.
    During development, we’ll boot our application using Docker Compose, which we’ll
    cover in chapters 4 and 5\. We’ll build and publish Docker images for our microservices
    in chapter 3\. In chapters 6 and 7, we’ll deploy our application to production.
    In chapter 8, we’ll swing back to development for some automated testing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将有一个基于浏览器的前端，让我们的用户可以查看视频列表。从那里，他们可以选择一个视频，它就会开始播放。在开发过程中，我们将使用Docker
    Compose启动我们的应用程序，我们将在第4章和第5章中介绍。我们将在第3章中构建和发布我们的微服务Docker镜像。在第6章和第7章中，我们将部署我们的应用程序到生产环境。在第8章中，我们将回到开发阶段进行一些自动化测试。
- en: Our application will contain services for video streaming, storage, and upload,
    plus a gateway for the customer-facing front end. We’ll work up to deploying the
    full application in chapter 9, which figure 1.7 illustrates. In chapters 10 and
    11, we’ll look at all the ways this architecture can help us scale in the future
    as our application grows. Are you ready to start building with microservices?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将包含视频流、存储和上传的服务，以及面向客户的网关。我们将在第9章中部署完整的应用程序，如图1.7所示。在第10章和第11章中，我们将探讨这种架构如何帮助我们随着应用程序的增长而扩展。你准备好开始使用微服务构建了吗？
- en: '![](../Images/CH01_F07_Davis4.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH01_F07_Davis4.png)'
- en: Figure 1.7 Our example application running in production on Kubernetes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 我们示例应用程序在生产环境中运行在Kubernetes上。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We take a practical rather than a theoretical approach to learning how to build
    a microservices application.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们采取的是一种实用而非理论的方法来学习如何构建微服务应用程序。
- en: Microservices are small and independent processes that each do one thing well.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是小型且独立的进程，每个进程都擅长做一件事。
- en: A microservices application is composed of numerous small processes working
    together to create the application’s features.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务应用程序由许多小型进程组成，它们共同工作以创建应用程序的功能。
- en: A monolith is an application composed of a single massive service.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体是一个由单个大型服务组成的应用程序。
- en: Although building a microservices application is more complicated than building
    a monolith, it’s not as difficult as you might think.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然构建微服务应用程序比构建单体更复杂，但并不像你想象的那么困难。
- en: Applications built from microservices are more flexible, scalable, reliable,
    and fault-tolerant than monolithic applications.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由微服务构建的应用程序比单体应用程序更灵活、可扩展、可靠和容错。
- en: The union of the modern tools like Docker, Kubernetes, and Terraform make building
    a microservices application much easier than previously possible.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker、Kubernetes和Terraform等现代工具的结合使得构建微服务应用程序比以前更容易。
- en: Domain driven design (DDD) is an effective way to design a microservices application.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计（DDD）是设计微服务应用程序的有效方法。
- en: Bounded contexts from DDD map well to the boundaries of microservices.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DDD中的边界上下文很好地映射到微服务的边界。
- en: We previewed the example application that we’ll build in this book.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们预览了本书中将构建的示例应用程序。
