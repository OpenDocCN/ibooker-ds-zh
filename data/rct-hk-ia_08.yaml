- en: 7 Managing performance with useMemo
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 使用 useMemo 管理性能
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using the `useMemo` hook to avoid rerunning expensive computations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useMemo` 钩子避免重新运行昂贵的计算
- en: Controlling `useMemo` with a dependency array
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖数组控制 `useMemo`
- en: Considering the user experience as your app re-renders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑用户体验作为你的应用重新渲染
- en: Handling race conditions when fetching data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取数据时处理竞态条件
- en: Using JavaScript’s optional chaining syntax with square brackets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 的可选链语法与方括号
- en: React is great at making it easy to display data in efficient, appealing, and
    responsive ways. But simply throwing raw data onto the screen is rare. Whether
    our apps are statistical, financial, scientific, entertaining, or whimsical, we
    almost always manipulate our data before bringing it to the surface.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: React 在以高效、吸引人和响应式的方式显示数据方面做得很好。但将原始数据直接扔到屏幕上是很罕见的。无论我们的应用是统计的、金融的、科学的、娱乐的还是异想天开的，我们几乎总是在将其呈现出来之前操纵我们的数据。
- en: Sometimes that manipulation can be complicated or time-consuming. If the time
    and resources spent are necessary to bring the data to life, the outcome may make
    up for the cost. But if the user experience is degraded by our computations, we
    need to consider ways of streamlining our code. Maybe a quest for more-efficient
    algorithms will pay dividends, or maybe our algorithms are already efficient and
    there is no way to make them faster. Either way, we shouldn’t perform the computations
    at all if we know their output will be unchanged. In such a case, React provides
    the `useMemo` hook to help us avoid unnecessary and wasteful work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这种操作可能很复杂或耗时。如果花费的时间和资源是使数据生动起来的必要条件，那么结果可能会弥补成本。但如果我们的计算降低了用户体验，我们需要考虑简化代码的方法。也许寻找更高效的算法会带来回报，或者也许我们的算法已经足够高效，没有方法使它们更快。无论如何，如果我们知道它们的输出将不会改变，我们就根本不应该执行这些计算。在这种情况下，React
    提供了 `useMemo` 钩子来帮助我们避免不必要的和浪费的工作。
- en: We start this chapter by being willfully wasteful, running the risk of crashing
    the browser with some gratuitously resource-intensive anagram generation. We call
    on `useMemo` to protect the user from some seriously sluggish UI updates. We then
    bring the bookings to life in our example app, this time calling `useMemo` to
    avoid regenerating grids of booking slots for no reason. When fetching the bookings
    for the selected week and bookable, we examine a method for coping with multiple
    requests and responses from within a `useEffect` call.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本章开始就故意浪费资源，冒着用一些资源密集型的字母组合生成操作使浏览器崩溃的风险。我们调用 `useMemo` 来保护用户免受一些严重缓慢的 UI
    更新的影响。然后我们在示例应用程序中将预订内容生动起来，这次调用 `useMemo` 来避免无理由地重新生成预订格子的网格。在获取所选周和可预订的预订时，我们检查在
    `useEffect` 调用内部处理多个请求和响应的方法。
- en: The title of section 7.1 is a little messed up; let’s find out what it’s trying
    to teach us about React Hooks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 7.1 节标题有点混乱；让我们找出它试图教我们关于 React 钩子的什么。
- en: 7.1 Breaking the cook’s heart by calling, “O, shortcake!”
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 通过喊“哦，短饼！”来打破厨师的心
- en: Say you’re trying to develop an anagram app that will find amusing anagrams
    of words, names, and phrases. It’s early in the development process and, so far,
    you have an app that finds all of the combinations of letters in some source text.
    In figure 7.1, your fledgling app is displaying the 12 distinct anagrams of the
    source text `ball`. The app is live on CodeSandbox ([https://codesandbox.io/s/anagrams-djwuy](https://codesandbox.io/s/anagrams-djwuy)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在尝试开发一个寻找单词、名字和短语有趣字母组合的应用程序。开发过程还处于早期阶段，到目前为止，你有一个可以找到某些源文本中所有字母组合的应用程序。在图
    7.1 中，你的初出茅庐的应用程序正在显示源文本 `ball` 的 12 个不同的字母组合。该应用程序已在 CodeSandbox 上实时运行 ([https://codesandbox.io/s/anagrams-djwuy](https://codesandbox.io/s/anagrams-djwuy))。
- en: '![](../Images/7-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-1.png)'
- en: Figure 7.1 The Anagrams app counts and displays anagrams of text entered by
    the user. The user can count all anagrams or only distinct anagrams, and can toggle
    the display of the anagrams.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 Anagrams 应用程序计算并显示用户输入文本的字母组合。用户可以计算所有字母组合或仅计算不同的字母组合，并且可以切换字母组合的显示。
- en: You can toggle between All anagrams and Distinct anagrams. For example, because
    “ball” has a repeated letter “l,” you could swap their positions and still have
    the word “ball.” The two identical words are counted separately in the All category
    but not in the Distinct category. You can also hide the generated anagrams, letting
    the app find new anagrams behind the scenes as you enter the source text, without
    having to render the new anagrams as you type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在全部排列和不同排列之间切换。例如，因为“ball”有一个重复的字母“l”，你可以交换它们的位置，仍然得到单词“ball”。在全部排列类别中，这两个相同的单词被单独计算，但在不同排列类别中则不是。你还可以隐藏生成的排列，让你在输入源文本时，应用在幕后找到新的排列，而无需在输入时渲染新的排列。
- en: Be careful! The number of anagrams shoots up as the number of letters in the
    source text increases. There are *n*! (n factorial) combinations of *n* letters.
    For four letters, that’s 4 × 3 × 2 × 1 = 24 combinations. For ten letters, there
    are 10!, or 3,628,800, combinations, as shown in figure 7.2\. The app is limited
    to ten characters—remove the cap at your own risk!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意！随着源文本中字母数量的增加，排列的数量会急剧增加。有 *n*!（n 的阶乘）种 *n* 个字母的组合。对于四个字母，那是 4 × 3 × 2 ×
    1 = 24 种组合。对于十个字母，有 10!，即 3,628,800 种组合，如图 7.2 所示。应用限制为十个字符——移除限制请自行承担风险！
- en: '![](../Images/7-2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-2.png)'
- en: Figure 7.2 Be careful! The number of anagrams increases quickly as the source
    text gets longer. There are over 3.5 million anagrams of a 10-letter word.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 注意！随着源文本长度的增加，排列的数量会迅速增加。一个 10 个字母的单词有超过 350 万个排列。
- en: 7.1.1 Generating anagrams with an expensive algorithm
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 使用昂贵的算法生成排列
- en: A coworker provides you with the code for finding the anagrams. The algorithm
    is shown in the following listing. It could certainly be improved. But whatever
    the algorithm, you want to be performing such expensive calculations only if absolutely
    necessary.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 同事为你提供了查找排列的代码。算法如下所示。它当然可以改进。但无论算法如何，你只想在绝对必要时才执行这种昂贵的计算。
- en: '*Live*: [https://djwuy.csb.app/](https://djwuy.csb.app/), *Code*: [https://codesandbox.io/s/anagrams-djwuy](https://codesandbox.io/s/anagrams-djwuy)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*Live*: [https://djwuy.csb.app/](https://djwuy.csb.app/)，*Code*: [https://codesandbox.io/s/anagrams-djwuy](https://codesandbox.io/s/anagrams-djwuy)'
- en: Listing 7.1 Finding anagrams
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 查找排列
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Create a function to find all combinations of letters in some source text.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个函数来查找某些源文本中字母的所有组合。
- en: ❷ Call the function recursively on source text with one letter removed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在移除一个字母后，递归地调用源文本上的函数。
- en: ❸ Create a function to remove duplicates from an array.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个从数组中删除重复项的函数。
- en: 'The algorithm takes each letter in a word and appends all the anagrams of the
    remaining letters. So, for “ball” it would find the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法取单词中的每个字母，并附加剩余字母的所有排列。所以，对于“ball”来说，它会找到以下内容：
- en: “b” + anagrams of “all”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “b” + “all” 的排列
- en: “a” + anagrams of “bll”
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “a” + “bll” 的排列
- en: “l” + anagrams of “bal”
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: “l” + “bal” 的排列
- en: “l” + anagrams of “bal”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: “l” + “bal” 的排列
- en: The main app calls `getAnagrams` and `getDistinct` to get the info it needs
    to display. The following listing is an earlier implementation. Can you spot any
    problems?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用调用 `getAnagrams` 和 `getDistinct` 来获取显示所需的信息。以下列表是一个早期的实现。你能发现任何问题吗？
- en: Listing 7.2 The anagrams app before the fix
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 修复前的排列应用
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Import the anagram finder functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入排列查找函数。
- en: ❷ Manage the source text state.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 管理源文本状态。
- en: ❸ Include flags for toggling distinct anagrams and anagram display.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 包含用于切换不同排列和排列显示的标志。
- en: ❹ Use the anagram functions to generate the data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用排列函数生成数据。
- en: ❺ Cap the number of letters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 限制字母的数量。
- en: ❻ Display the number of anagrams.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 显示排列的数量。
- en: ❼ Display the list of anagrams.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 显示排列列表。
- en: 'The key problem is that the code calls the expensive anagram functions on *every*
    render. But the anagrams change only if the source text changes. You really shouldn’t
    generate the anagrams again if the user clicks either of the check boxes, toggling
    between All and Distinct anagrams, or showing and hiding the list. Here are the
    current calls to the anagram functions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题是代码在每次渲染时都会调用昂贵的排列函数。但是，只有当源文本改变时，排列才会改变。当用户点击任一复选框，在全部排列和不同排列之间切换，或者显示和隐藏列表时，你真的不应该再次生成排列。以下是当前对排列函数的调用：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The expensive functions run on every render.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 昂贵的函数在每次渲染时运行。
- en: We need a way of asking React to run the expensive functions only if their output
    is likely to be different. For `getAnagrams`, that’s if the `sourceText` value
    changes. For `getDistinct`, that’s if the `anagrams` array changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来请求React仅在输出可能不同时运行昂贵的函数。对于`getAnagrams`，这是当`sourceText`值改变时。对于`getDistinct`，这是当`anagrams`数组改变时。
- en: 7.1.2 Avoiding redundant function calls
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 避免冗余函数调用
- en: The following listing shows the code for the live example. It wraps the expensive
    functions in calls to the `useMemo` hook, providing an array of dependencies for
    each call.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了实时示例的代码。它将昂贵的函数包装在`useMemo`钩子的调用中，为每个调用提供依赖项数组。
- en: '*Live*: [https://djwuy.csb.app/](https://djwuy.csb.app/), *Code*: [https://codesandbox.io/s/anagrams-djwuy](https://codesandbox.io/s/anagrams-djwuy)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*Live*: [https://djwuy.csb.app/](https://djwuy.csb.app/), *Code*: [https://codesandbox.io/s/anagrams-djwuy](https://codesandbox.io/s/anagrams-djwuy)'
- en: Listing 7.3 The anagrams app with `useMemo`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 使用`useMemo`的字母组合应用
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Import the useMemo hook.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入`useMemo`钩子。
- en: ❷ Call useMemo.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用`useMemo`。
- en: ❸ Pass the expensive function to useMemo.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将昂贵的函数传递给`useMemo`。
- en: ❹ Specify a list of dependencies.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 指定依赖项列表。
- en: ❺ Assign the value getDistinct returns to a variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将`getDistinct`返回的值赋给一个变量。
- en: ❻ Wrap the call to getDistinct in another function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在另一个函数中包装对`getDistinct`的调用。
- en: ❼ Rerun the getDistinct function only when the anagrams array changes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 仅当字母组合数组改变时重新运行`getDistinct`函数。
- en: In this version, React should call `getAnagrams` only when `sourceText` changes,
    and should call `getDistinct` only when `anagrams` changes. Users can toggle at
    will without causing a cascade of costly calls as the app tries to keep up while
    rebuilding the same million anagrams again and again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，React应该在`sourceText`改变时调用`getAnagrams`，在`anagrams`改变时调用`getDistinct`。用户可以随意切换，而不会导致应用在重建相同的百万个字母组合时产生一系列昂贵的调用。
- en: You could see the last example, decide there’s no more to learn, and bury your
    head in the sand—*some emu*. Or be too timid to ask for more details—*Mouse*?
    *Me*? But, be brave, lean on React, and calm those costly calls—*useMemo*!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到最后一个例子，决定没有更多东西可以学习了，然后埋头于沙子中——*一些鸸鹋*。或者过于胆怯而不敢询问更多细节——*老鼠*？*我*？但是，要勇敢，依靠React，平息那些昂贵的调用——*useMemo*！
- en: 7.2 Memoizing expensive function calls with useMemo
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 使用`useMemo`缓存昂贵的函数调用
- en: If we have a function, `expensiveFn`, that takes time and resources to calculate
    its return value, then we want to call the function only when absolutely necessary.
    By calling the function inside the `useMemo` hook, we ask React to store a value
    computed by the function for a given set of arguments. If we call the function
    inside `useMemo` again, using the same arguments as the previous call, it should
    return the stored value. If we pass different arguments, it will use the function
    to compute a new value and update its store before returning the new value. The
    process of storing a result for a given set of arguments is called *memoizing*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个函数`expensiveFn`，它需要时间和资源来计算其返回值，那么我们只想在绝对必要时调用该函数。通过在`useMemo`钩子内部调用该函数，我们请求React为给定的一组参数存储由该函数计算出的值。如果我们再次在`useMemo`内部调用该函数，使用与上次调用相同的参数，它应该返回存储的值。如果我们传递不同的参数，它将使用该函数计算新值，并在返回新值之前更新其存储。为给定参数集存储结果的过程称为*记忆化*。
- en: When calling `useMemo`, pass it a *create functio*n and a list of dependencies,
    as shown in figure 7.3.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`useMemo`时，传递给它一个*创建函数*和依赖项列表，如图7.3所示。
- en: '![](../Images/7-3.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-3.png)'
- en: Figure 7.3 Call the `useMemo` hook with a function and a list of dependencies.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 使用函数和依赖项列表调用`useMemo`钩子。
- en: The list of dependencies is an array of values and should include all the values
    the function uses in its computation. On each call, `useMemo` compares the dependency
    list to the previous list. If each list holds the same values in the same order,
    `useMemo` may return the stored value. If any value in the list has changed, `useMemo`
    will call the function and store and return the function’s return value. To reiterate,
    `useMemo` *may* return the stored value. React reserves the right to clear its
    store if it needs to free up memory. So, it might call the expensive function
    even if the dependencies are unchanged.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项列表是一个值数组，应包括函数在其计算中使用的所有值。在每次调用中，`useMemo`会将依赖项列表与之前的列表进行比较。如果每个列表都包含相同顺序的相同值，`useMemo`可能会返回存储的值。如果列表中的任何值已更改，`useMemo`将调用函数，存储并返回函数的返回值。再次强调，`useMemo`*可能*返回存储的值。React保留清除其存储以释放内存的权利。因此，即使依赖项未更改，它也可能调用昂贵的函数。
- en: If you omit the dependency list, `useMemo` always runs your function, which
    kind of defeats the purpose! If you pass an empty array, the values in the list
    never change, so `useMemo` could always return the stored value. It may, however,
    decide to clear its store and run your function again anyway. It’s almost certainly
    best to avoid that kind of maybe-or-maybe-not behavior.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您省略了依赖列表，`useMemo`总是会运行您的函数，这有点违背了初衷！如果您传递一个空数组，列表中的值永远不会改变，因此`useMemo`可以始终返回存储的值。然而，它可能仍然决定清除其存储并再次运行您的函数。几乎可以肯定，最好避免这种可能或可能不的行为。
- en: That’s how `useMemo` works. We see it in action again in the bookings example
    app in section 7.4, memoizing a function for generating a grid of booking slots.
    First, we use our state-sharing and React Hooks skills to put the Bookings page
    components into place and pass them the bits and pieces they need to work nicely
    together.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`useMemo`的工作方式。我们再次在7.4节的预订示例应用中看到它的作用，用于生成预订槽位的网格。首先，我们使用我们的状态共享和React Hooks技能将Bookings页面组件放在一起，并传递它们需要一起良好工作的各个部分。
- en: 7.3 Organizing the components on the Bookings page
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 组织Bookings页面上的组件
- en: So far, the Bookables and Users pages have had all the attention in the bookings
    app; it’s about time the Bookings page got some love! We need to put the shared-state
    concepts from chapter 6 into action and decide which components will manage which
    state as we let users view bookings for different bookables and different weeks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Bookables和Users页面在预订应用中受到了所有关注；是时候让Bookings页面得到一些关注了！我们需要将第6章中的共享状态概念付诸实践，并决定哪些组件将管理哪些状态，当我们让用户查看不同可预订项目和不同周次的预订时。
- en: Figure 7.4 shows the layout of the Bookings page, with the list of bookables
    on the left and the bookings info taking up the rest of the page. We have a `BookingsPage`
    component for the page itself, a `BookablesList` component for the list on the
    left, and a `Bookings` component for the rest of the page. The bookings info includes
    a week picker, an area to display a bookings grid, and an area to display the
    details of a selected booking.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4显示了Bookings页面的布局，左侧是可预订项目的列表，页面的其余部分是预订信息。我们有一个`BookingsPage`组件用于页面本身，一个`BookablesList`组件用于左侧的列表，以及一个`Bookings`组件用于页面的其余部分。预订信息包括周选择器、显示预订网格的区域以及显示所选预订详情的区域。
- en: Figure 7.4 has placeholders for the bookings grid and the booking details. We’ll
    bring the bookings grid to life and incorporate the `useMemo` hook in section
    7.4\. We’ll populate the booking details and introduce the `useContext` hook in
    chapter 8\. In this section, we put the pieces into place on the page.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4为预订网格和预订详情提供了占位符。我们将在第7.4节中使预订网格变得生动，并引入`useMemo`钩子。我们将在第8章中填充预订详情并介绍`useContext`钩子。在本节中，我们将页面上的各个部分放在一起。
- en: '![](../Images/7-4.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片7-4](../Images/7-4.png)'
- en: 'Figure 7.4 The Bookings page includes two components: one for the list of bookables,
    and one containing the week picker, bookings grid, and booking details.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 Bookings页面包括两个组件：一个用于可预订项目的列表，另一个包含周选择器、预订网格和预订详情。
- en: This book uses the bookings app to teach you about React Hooks. To save you
    time and effort, I'm focusing more on teaching hooks than I am on teaching you
    how to code the bookings app, which could get very repetitive and wouldn't benefit
    learning React. So, sometimes, the book sets challenges and points you to the
    example’s GitHub repo to get the latest code for certain components. With the
    Bookings page, the example app is edging into complexity, so a few more cases
    of changes in the repo are not fully listed in the book; I’ll make it clear when
    you need to check the repo.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用预订应用来教您关于React Hooks的知识。为了节省您的时间和精力，我更专注于教授钩子，而不是教授您如何编写预订应用，这可能会变得非常重复，并且不会对学习React有所帮助。因此，有时本书会设置挑战，并将您指向示例的GitHub仓库以获取某些组件的最新代码。随着Bookings页面的示例应用变得越来越复杂，仓库中的更改案例在书中并未全部列出；当您需要检查仓库时，我会明确指出。
- en: Table 7.1 lists the components in play for the Bookings page, along with their
    main function and the shared state they manage. In chapter 8, we’ll use the `useContext`
    hook to access the current user from the `BookingDetails` component; although
    we don’t work with the `App` component in this chapter, it’s included in the table
    so you can see the full hierarchy of components.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1列出了Bookings页面中涉及到的组件，以及它们的主要功能和它们管理的共享状态。在第8章中，我们将使用`useContext`钩子从`BookingDetails`组件访问当前用户；尽管我们在这章中没有与`App`组件打交道，但它包含在表中，以便您可以看到组件的完整层次结构。
- en: Table 7.1 Components for the Bookings page
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 预订页面组件
- en: '| Component | Role | Managed state | Hook |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 角色 | 管理的状态 | 钩子 |'
- en: '| `App` | Render header with links to pages. Render user picker. Use routes
    to render correct page. | Current user | `useState` + Context API—see chapter
    8 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `App` | 渲染带有页面链接的标题。渲染用户选择器。使用路由渲染正确的页面。 | 当前用户 | `useState` + 上下文 API—见第
    8 章 |'
- en: '| `BookingsPage` | Render `BookablesList` and `Bookings` components. | Selected
    bookable | `useState` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `BookingsPage` | 渲染 `BookablesList` 和 `Bookings` 组件。 | 已选可预订项 | `useState`
    |'
- en: '| `BookablesList` | Render list of bookables and let users select a bookable.
    |  |  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `BookablesList` | 渲染可预订项列表并允许用户选择可预订项。 |  |  |'
- en: '| `Bookings` | Render `WeekPicker`, `BookingsGrid`, and `BookingDetails` components.
    | Selected week and selected booking | `useReducer` and `useState` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `Bookings` | 渲染 `WeekPicker`、`BookingsGrid` 和 `BookingDetails` 组件。 | 已选周和已选预订
    | `useReducer` 和 `useState` |'
- en: '| `WeekPicker` | Let users switch between weeks to view. |  |  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `WeekPicker` | 允许用户切换周次以查看。 |  |  |'
- en: '| `BookingsGrid` | Display a grid of booking slots for the selected bookable
    and week. Populate the grid with any existing bookings. Highlight the selected
    booking. |  |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `BookingsGrid` | 显示所选可预订项和周的预订时段网格。用任何现有的预订填充网格。突出显示所选预订。 |  |  |'
- en: '| `BookingDetails` | Display details of the selected booking. |  |  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `BookingDetails` | 显示所选预订的详细信息。 |  |  |'
- en: 'We’ll work from the `BookingsPage` down; the listings should give you a good
    sense of the structure of the page and of the flow of state through the hierarchy
    of components. The discussion is split into two subsections, using the shared
    state as the focus:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `BookingsPage` 开始工作；列表应该能给你一个很好的页面结构和状态在组件层次结构中流动的感觉。讨论分为两个小节，以共享状态为重点：
- en: Managing the selected bookable with `useState`
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useState` 管理所选可预订项
- en: Managing the selected week and booking with `useReducer` and `useState`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useReducer` 和 `useState` 管理所选周和预订
- en: All the pieces shown in table 7.1 will need to be in position before the app
    returns to a working state, but the listings aren’t long, so we’ll get there soon.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 中显示的所有组件都需要在应用返回到工作状态之前就位，但列表并不长，所以我们很快就能到达那里。
- en: 7.3.1 Managing the selected bookable with useState
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 使用 `useState` 管理所选可预订项
- en: Our first piece of shared state is the selected bookable. It’s used by the `BookablesList`
    and `Bookings` components. (Remember, the `Bookings` component is the container
    for the `WeekPicker`, `BookingsGrid`, and `BookingDetails` components.) Their
    nearest shared parent is the Bookings page itself.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一块共享状态是已选可预订项。它被 `BookablesList` 和 `Bookings` 组件使用。（记住，`Bookings` 组件是 `WeekPicker`、`BookingsGrid`
    和 `BookingDetails` 组件的容器。）它们最近的共享父级是预订页面本身。
- en: Listing 7.4 shows the `BookingsPage` component calling `useState` to manage
    the selected bookable. `BookingsPage` also passes the updater function, `setBookable`,
    to `BookablesList` so that users can choose a bookable from the list. It no longer
    directly imports `WeekPicker`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 展示了 `BookingsPage` 组件调用 `useState` 来管理所选可预订项。`BookingsPage` 还将更新函数 `setBookable`
    传递给 `BookablesList`，以便用户可以从列表中选择可预订项。它不再直接导入 `WeekPicker`。
- en: 'Branch: 0701-bookings-page, File: src/components/Bookings/BookingsPage.js'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0701-bookings-page，文件：src/components/Bookings/BookingsPage.js
- en: Listing 7.4 The `BookingsPage` component
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 `BookingsPage` 组件
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Manage the selected bookable with the useState hook.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `useState` 钩子管理所选可预订项。
- en: ❷ Pass the bookable down so it can be highlighted in the list.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将可预订项传递下去，以便在列表中突出显示。
- en: ❸ Pass the updater function so users can select a bookable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 传递更新函数，以便用户可以选择可预订项。
- en: ❹ Let the Bookings component display the bookings for the selected bookable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 让预订组件显示所选可预订项的预订。
- en: The page passes the selected bookable to the `Bookings` component (created next)
    so that it can show the bookable’s bookings. To show the correct bookings (and
    to let users make new bookings), the `Bookings` component also needs to know the
    selected week. Let’s see how it manages that state itself.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 页面将所选可预订项传递给（稍后创建的）`Bookings` 组件，以便它可以显示可预订项的预订。为了显示正确的预订（并让用户创建新的预订），`Bookings`
    组件还需要知道所选周。让我们看看它是如何管理这个状态的。
- en: 7.3.2 Managing the selected week and booking with useReducer and useState
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 使用 `useReducer` 和 `useState` 管理所选周和预订
- en: Users can switch weeks by using the week picker. They can navigate forward a
    week or back a week and jump straight to the week containing today’s date. They
    can also enter a date into a text box and go to the week for that date. To share
    the selected date with the bookings grid, we lift the week picker’s reducer up
    into the `Bookings` component, as shown in the following listing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过使用周选择器来切换周。他们可以向前或向后导航一周，也可以直接跳转到包含今天日期的那一周。他们还可以在文本框中输入一个日期并转到该日期的周。为了与预订网格共享选定的日期，我们将周选择器的
    reducer 提升到 `Bookings` 组件中，如下所示。
- en: 'Branch: 0701-bookings-page, File: src/components/Bookings/Bookings.js'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0701-bookings-page，文件：src/components/Bookings/Bookings.js
- en: Listing 7.5 The `Bookings` component
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 `Bookings` 组件
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Import the existing reducer for the week picker.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入现有的周选择器 reducer。
- en: ❷ Destructure the current bookable from props.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从属性中解构当前可预订项。
- en: ❸ Manage the shared state for the selected week.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 管理选定周的共享状态。
- en: ❹ Manage the shared state for the selected booking.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 管理选定的预订的共享状态。
- en: The `Bookings` component imports the reducer and passes it in when calling the
    `useReducer` hook. It also calls the `useState` hook to manage the shared selected
    booking state for both the `BookingsGrid` and `BookingDetails` components.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bookings` 组件导入 reducer 并在调用 `useReducer` 钩子时传递它。它还调用 `useState` 钩子来管理 `BookingsGrid`
    和 `BookingDetails` 组件的共享选定预订状态。'
- en: Challenge 7.1
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 7.1
- en: Update the `WeekPicker` component so that it receives `dispatch` as a prop,
    no longer calling `useReducer` itself. It doesn’t need to display the selected
    date, so remove that from the end of its returned UI, and remove any redundant
    imports. Check the repo for the latest version (src/components/Bookings/WeekPicker.js).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `WeekPicker` 组件，使其接收 `dispatch` 作为属性，不再自己调用 `useReducer`。它不需要显示选定的日期，因此从返回的
    UI 末尾移除该功能，并移除任何多余的导入。检查仓库以获取最新版本（src/components/Bookings/WeekPicker.js）。
- en: In section 7.4, we build up the bookings grid to show actual bookings. For the
    current repo branch, let’s just add a couple of placeholder components to check
    that the page structure is working nicely. The following listing shows our temporary
    bookings grid.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 7.4 节中，我们构建预订网格以显示实际预订。对于当前仓库分支，我们只需添加几个占位符组件来检查页面结构是否工作良好。以下列表显示了我们的临时预订网格。
- en: 'Branch: 0701-bookings-page, File: src/components/Bookings/BookingsGrid.js'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0701-bookings-page，文件：src/components/Bookings/BookingsGrid.js
- en: Listing 7.6 The `BookingsGrid` placeholder
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 `BookingsGrid` 占位符
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The following listing shows our temporary details component.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了我们的临时详情组件。
- en: 'Branch: 0701-bookings-page, File: src/components/Bookings/BookingDetails.js'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0701-bookings-page，文件：src/components/Bookings/BookingDetails.js
- en: Listing 7.7 The `BookingDetails` placeholder
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 `BookingDetails` 占位符
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Everything should now be in place, and the app should be back in working order.
    The Bookings page should look like figure 7.4 (if you have the latest CSS, or
    roll your own for the placeholders).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该一切就绪，应用应该恢复正常工作。预订页面应该看起来像图 7.4（如果您有最新的 CSS，或者为占位符自己创建一个）。
- en: Challenge 7.2
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 7.2
- en: 'Make a small change to `BookablesList`, removing the code for moving focus
    to the Next button. This will just slim down the component for future changes.
    The updates are on the current branch: /src/components/Bookables/BookablesList.js.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `BookablesList` 进行小幅修改，移除移动焦点到“下一步”按钮的代码。这将仅简化组件以供未来的更改。更新位于当前分支：/src/components/Bookables/BookablesList.js。
- en: With all the components in place and a sense of where the page manages each
    piece of shared state, it’s time to introduce a new React Hook to the bookings
    app. The `useMemo` hook will help us run expensive calculations only when necessary.
    Let’s see why we need it and how it helps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有组件就绪并且对页面如何管理每一块共享状态有了一定的了解之后，是时候向预订应用引入一个新的 React 钩子了。`useMemo` 钩子将帮助我们仅在必要时运行昂贵的计算。让我们看看为什么我们需要它以及它是如何帮助的。
- en: 7.4 Efficiently building the bookings grid with useMemo
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 使用 `useMemo` 高效构建预订网格
- en: With the Bookings page structure and hierarchy in place, we’re ready to build
    up our most complicated component yet, the `BookingsGrid`. In this section, we
    develop the grid so that it can display booking slots for a bookable in a given
    week and place any existing bookings in the grid. Figure 7.5 shows the grid with
    three rows for sessions and five columns for dates. Four existing bookings are
    in the grid, and the user has selected one of the bookings.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bookings 页面结构和层次结构就绪后，我们准备构建迄今为止最复杂的组件，即 `BookingsGrid`。在本节中，我们开发网格，使其能够显示给定周和地点的预订时段，并将任何现有预订放入网格中。图
    7.5 显示了具有三个行（会话）和五个列（日期）的网格。网格中有四个现有预订，用户已选择其中一个预订。
- en: '![](../Images/7-5.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-5](../Images/7-5.png)'
- en: Figure 7.5 The bookings grid showing bookings for the selected bookable and
    week. A booking in the grid has been selected.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 显示了所选可预订项目和周的预订网格。网格中的一个预订已被选中。
- en: 'We develop the component in five stages:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在五个阶段中开发组件：
- en: Generating a grid of sessions and dates—we want to transform our data to make
    looking up empty booking slots easier.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成会话和日期的网格——我们希望将数据转换，以便更容易查找空预订时段。
- en: Generating a lookup for bookings—we want to transform our data to make looking
    up existing bookings easier.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成预订查找——我们希望将数据转换，以便更容易查找现有预订。
- en: Providing a `getBookings` data-loading function—it will handle building the
    query strings for our request to the JSON server.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个 `getBookings` 数据加载函数——它将处理构建我们向 JSON 服务器请求的查询字符串。
- en: Creating the `BookingsGrid` component—this is the meat of the section and is
    where we enlist the help of `useMemo`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `BookingsGrid` 组件——这是本节的核心内容，也是我们请求 `useMemo` 帮助的地方。
- en: Coping with racing responses when fetching data in `useEffect`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理在 `useEffect` 中获取数据时的竞态响应。
- en: In stage 5, we see how to manage multiple requests and responses for data within
    calls to the `useEffect` hook, with later requests superseding earlier ones, and
    how to manage errors. There’s a lot to sink our teeth into, so let’s get started
    by transforming lists of days and sessions into two-dimensional booking grids.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 阶段，我们将了解如何在 `useEffect` 钩子调用中管理多个请求和响应，以及如何管理错误。有很多内容需要消化，所以让我们从将天数和会话列表转换为二维预订网格开始。
- en: 7.4.1 Generating a grid of sessions and dates
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 生成会话和日期的网格
- en: The bookings grid displays empty booking slots and existing bookings in a table,
    with sessions as rows and dates as columns. An example grid of booking slots for
    the Meeting Room bookable is shown in figure 7.6.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 预订网格以表格形式显示空预订时段和现有预订，其中会话为行，日期为列。图 7.6 展示了 Meeting Room 可预订项目的预订时段示例网格。
- en: '![](../Images/7-6.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-6](../Images/7-6.png)'
- en: Figure 7.6 The bookings grid for the Meeting Room bookable. It has rows for
    each session and columns for each date.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 显示了 Meeting Room 可预订项目的预订网格。它为每个会话有行，为每个日期有列。
- en: Users book different bookables for different sessions and days of the week.
    When the user chooses a new bookable, the `BookingsGrid` component needs to generate
    a new grid, for the latest sessions and dates. Figure 7.7 shows the grid generated
    when the user switches to the Lounge bookable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 用户为不同会话和周的不同日子预订不同的可预订项目。当用户选择新的可预订项目时，`BookingsGrid` 组件需要生成一个新的网格，用于最新的会话和日期。图
    7.7 显示了用户切换到 Lounge 可预订项目时生成的网格。
- en: '![](../Images/7-7.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-7](../Images/7-7.png)'
- en: Figure 7.7 The bookings grid for the Lounge bookable. The Lounge is available
    for five sessions on every day of the week.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 显示了 Lounge 可预订项目的预订网格。Lounge 在每周的每一天都提供五个时段。
- en: 'Each cell in the grid corresponds to a booking slot. We want the grid data
    to be structured so that it’s easy to access the data for a specific booking slot.
    For example, to access the data for the Breakfast session on August 3, 2020, we
    use this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 网格中的每个单元格都对应一个预订时段。我们希望网格数据结构化，以便轻松访问特定预订时段的数据。例如，要访问 2020 年 8 月 3 日早餐会话的数据，我们使用以下方法：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For an empty booking slot, the booking data looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空预订时段，预订数据看起来像这样：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the data from the database, each bookable specifies the sessions and days
    for which it can be booked. Here’s the data for the Meeting Room:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库的数据中，每个可预订项目指定了可以预订的会话和日子。以下是 Meeting Room 的数据：
- en: '[PRE10]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `days` represent days in the week, where Sunday = 0, Monday = 1, . . . ,
    Saturday = 6\. So, the Meeting Room can be booked for sessions 1, 2, and 3, Monday
    through Friday, as we saw in figure 7.6\. To get the specific dates for the bookings,
    rather than just the day numbers, we also need the start date for the week we
    want to display. And to get the specific session names, we need to import the
    array of session names from the config file, static.json.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`days` 代表一周中的天数，其中周日 = 0，周一 = 1，...，周六 = 6。因此，会议室可以在周一至周五预订会话 1、2 和 3，正如我们在图
    7.6 中所看到的。要获取预订的具体日期，而不仅仅是天数，我们还需要显示周的开始日期。要获取具体的会话名称，我们需要从配置文件 static.json 中导入会话名称数组。'
- en: The grid generator function, `getGrid`, is in the following listing. The calling
    code passes `getGrid` the current bookable and the start date for the selected
    week.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 网格生成函数 `getGrid` 在以下列表中。调用代码将 `getGrid` 的当前可预订和所选周的起始日期传递给它。
- en: 'Branch: 0702-bookings-memo, File: /src/components/Bookings/grid-builder.js'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0702-bookings-memo，文件：/src/components/Bookings/grid-builder.js
- en: Listing 7.8 The grid generator
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 网格生成器
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Assign the session names to the sessionNames variable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将会话名称分配给 `sessionNames` 变量。
- en: ❷ Accept the current bookable and week start date as arguments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将当前可预订的书籍和周开始日期作为参数接受。
- en: ❸ Use the day numbers and start date to create an array of dates for the week.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用天数和起始日期创建一周的日期数组。
- en: ❹ Use the session names and numbers to create an array of session names.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用会话名称和数字创建一个会话名称数组。
- en: ❺ Assign an object to grid for each session.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为每个会话分配一个对象到网格中。
- en: ❻ Assign a booking object for each date to each session.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 为每个会话分配一个预订对象到每个日期。
- en: ❼ In addition to the grid, return the dates and sessions arrays for convenience.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 除了网格之外，为了方便，返回日期和会话数组。
- en: 'The `getGrid` function starts by mapping the day and session indexes to dates
    and session names. It uses a truncated ISO 8601 format for dates:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`getGrid` 函数首先将日期和会话索引映射到日期和会话名称。它使用截断的 ISO 8601 格式表示日期：'
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `shortISO` function has been added to the utils/date-wrangler.js file that
    also contains the `addDays` function. `shortISO` returns the date part of the
    ISO-string for a given date:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`shortISO` 函数已被添加到包含 `addDays` 函数的 `utils/date-wrangler.js` 文件中。`shortISO`
    返回给定日期的 ISO-字符串的日期部分：'
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For example, for a JavaScript date object representing August 3, 2020, `shortISO`
    returns the string `"2020-08-03"`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于表示 2020 年 8 月 3 日的 JavaScript 日期对象，`shortISO` 返回字符串 `"2020-08-03"`。
- en: 'The code in the listing also imports the session names from static.json and
    assigns them to the `sessionNames` variable. The session data looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的代码还从 static.json 导入会话名称并将它们分配给 `sessionNames` 变量。会话数据如下所示：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each session index from the bookable is mapped to its session name:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将可预订的每个会话索引映射到其会话名称：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, if the selected bookable is the Meeting Room, then `bookable.sessions` is
    the array `[1,` `2,` `3]` and `sessions` becomes `["Morning",` `"Lunch",` `"Afternoon"]`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果所选的可预订的是会议室，那么 `bookable.sessions` 是数组 `[1, 2, 3]`，而 `sessions` 变为 `["Morning",
    "Lunch", "Afternoon"]`。
- en: Having acquired the dates and session names, `getGrid` then uses nested `forEach`
    loops to build up the grid of booking sessions. You could use the `reduce` array
    method here, but I find the `forEach` syntax easier to follow in this case. (Don’t
    worry, `reduce` fans; the next listing employs its services.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取了日期和会话名称之后，`getGrid` 然后使用嵌套的 `forEach` 循环来构建预订会话的网格。您也可以在这里使用 `reduce` 数组方法，但我发现在这种情况下
    `forEach` 语法更容易理解。（不要担心，`reduce` 粉丝；下一个列表将使用其服务。）
- en: 7.4.2 Generating a lookup for bookings
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 生成预订查找
- en: We also want an easy way to look up existing bookings. Figure 7.8 shows a bookings
    grid with existing bookings in four cells.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望有一个简单的方法来查找现有预订。图 7.8 展示了一个包含四个单元格中现有预订的预订网格。
- en: '![](../Images/7-8.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-8.png)'
- en: Figure 7.8 The bookings grid with existing bookings in four cells
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 包含四个单元格中现有预订的预订网格
- en: 'We want to use the session name and date to access the data for an existing
    booking, like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用会话名称和日期来访问现有预订的数据，如下所示：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The lookup expression should return the data for the Movie Pitch! booking,
    with this structure:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 查找表达式应返回 Movie Pitch! 预订的数据，具有以下结构：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: But the server returns the bookings data as an array. We need to transform the
    array of bookings into the handy lookup object. Listing 7.9 adds a new function,
    `transformBookings`, to the grid-builder.js file from listing 7.8.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但服务器以数组的形式返回预订数据。我们需要将预订数组转换为方便的查找对象。列表 7.9 向列表 7.8 中的 grid-builder.js 文件添加了一个新函数
    `transformBookings`。
- en: 'Branch: 0702-bookings-memo, File: /src/components/Bookings/grid-builder.js'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0702-bookings-memo，文件：/src/components/Bookings/grid-builder.js
- en: Listing 7.9 The `transformBookings` function
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 `transformBookings` 函数
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Use reduce to step through each booking and build up the bookings lookup.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 reduce 遍历每个预订并构建预订查找。
- en: ❷ Destructure the session and date for the current booking.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 解构当前预订的会话和日期。
- en: ❸ Add a property to the lookup for each new session.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为每个新会话添加一个属性。
- en: ❹ Assign the booking to its session and date.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将预订分配给其会话和日期。
- en: ❺ Start the bookings lookup as an empty object.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将预订查找作为空对象开始。
- en: The `transformBookings` function uses the `reduce` method to step through each
    booking in the array and build up the `bookings` lookup object, assigning the
    current booking to its allotted lookup slot. The lookup object that `transformBookings`
    creates has entries for only the existing bookings, not necessarily for every
    cell in the bookings grid.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`transformBookings` 函数使用 `reduce` 方法遍历数组中的每个预订并构建 `bookings` 查找对象，将当前预订分配给其分配的查找槽位。`transformBookings`
    创建的查找对象只包含现有预订的条目，不一定包含预订网格中的每个单元格。'
- en: We now have functions to generate the grid and transform an array of bookings
    into a lookup object. But where are the bookings?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了生成网格和将预订数组转换为查找对象的函数。但预订在哪里？
- en: 7.4.3 Providing a getBookings data-loading function
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 提供一个 getBookings 数据加载函数
- en: The `BookingsGrid` component needs some bookings to display for the selected
    bookable and week. We could use our existing `getData` function from within an
    effect in the `BookingsGrid` component, building up the necessary URL there. Instead,
    let’s keep our data-access functions in the api.js file. The following listing
    shows the part of the updated file with our new `getBookings` function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingsGrid` 组件需要一些预订来显示所选的可预订项和周。我们可以在 `BookingsGrid` 组件中的效果内部使用现有的 `getData`
    函数，并在那里构建必要的 URL。相反，让我们将数据访问函数保留在 api.js 文件中。以下列表显示了更新文件中我们的新 `getBookings` 函数的部分。'
- en: 'Branch: 0702-bookings-memo, File: /src/utils/api.js'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0702-bookings-memo，文件：/src/utils/api.js
- en: Listing 7.10 The `getBookings` API function
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 `getBookings` API 函数
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Import a function to format dates.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入一个格式化日期的函数。
- en: ❷ Export the new getBookings function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导出新的 getBookings 函数。
- en: ❸ Format the dates for the query string.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 格式化查询字符串的日期。
- en: ❹ Build up the query string.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 构建查询字符串。
- en: ❺ Fetch the bookings, returning a promise.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取预订，返回一个承诺。
- en: 'The `getBookings` function accepts three arguments: `bookableId`, `startDate`,
    and `endDate`. It uses the arguments to build up the query string for the required
    bookings. For example, to fetch the bookings for the Meeting Room between Sunday,
    June 21, 2020, and Saturday, June 27, 2020, the query string is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBookings` 函数接受三个参数：`bookableId`、`startDate` 和 `endDate`。它使用这些参数来构建所需预订的查询字符串。例如，要获取
    2020 年 6 月 21 日星期日到 2020 年 6 月 27 日星期六会议室的预订，查询字符串如下：'
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `json-server` we have running will parse the query string and return the
    requested bookings as an array, ready for transformation into a lookup object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的 `json-server` 将解析查询字符串并返回请求的预订数组，以便转换为查找对象。
- en: With the helper functions in place, it’s time to put them to good use as we
    construct the `BookingsGrid` component.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好辅助函数后，是时候将它们用于构建 `BookingsGrid` 组件了。
- en: 7.4.4 Creating the BookingsGrid component and calling useMemo
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.4 创建 BookingsGrid 组件并调用 useMemo
- en: 'For a given bookable and week, the `BookingsGrid` component fetches the bookings
    and displays them, highlighting any selected booking. It uses three React Hooks:
    `useState`, `useEffect`, and `useMemo`. We break the code for the component across
    a number of listings, in this subsection and the next, starting with the imports
    and component skeleton in the following listing.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的可预订项和周，`BookingsGrid` 组件获取预订并显示它们，突出显示任何选定的预订。它使用三个 React Hooks：`useState`、`useEffect`
    和 `useMemo`。我们将组件的代码拆分到多个列表中，在本小节和下一节中，从以下列表中的导入和组件骨架开始。
- en: 'Branch: 0702-bookings-memo, File: /src/components/Bookings/BookingsGrid.js'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0702-bookings-memo，文件：/src/components/Bookings/BookingsGrid.js
- en: 'Listing 7.11 The `BookingsGrid` component: Skeleton'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 `BookingsGrid` 组件：骨架
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Import useMemo to memoize the grid.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 `useMemo` 以缓存网格。
- en: ❷ Import the new grid functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入新的网格函数。
- en: ❸ Import a new data-loading function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 导入新的数据加载函数。
- en: The code imports the helper functions created previously and the three hooks.
    As you’ll see over the next few listings, we use the `useState` hook to manage
    the state for the bookings and any errors, the `useEffect` hook to fetch the bookings
    data from the server, and the `useMemo` hook to reduce the number of times we
    generate the grid data.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 代码导入了之前创建的辅助函数和三个钩子。正如你将在接下来的几个列表中看到的，我们使用 `useState` 钩子来管理预订和任何错误的状态，使用 `useEffect`
    钩子从服务器获取预订数据，使用 `useMemo` 钩子减少生成网格数据次数。
- en: Variables
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: The `Bookings` component passes the `BookingsGrid` component the selected bookable,
    the selected week, and the currently selected booking along with its updater function,
    as highlighted in the following listing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bookings` 组件将所选的可预订项、所选周和当前所选的预订及其更新函数传递给 `BookingsGrid` 组件，如下面的列表所示。'
- en: 'Branch: 0702-bookings-memo, File: /src/components/Bookings/BookingsGrid.js'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0702-bookings-memo，文件：/src/components/Bookings/BookingsGrid.js
- en: 'Listing 7.12 The `BookingsGrid` component: 1\. Variables'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 `BookingsGrid` 组件：1. 变量
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Destructure the props.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 解构 props。
- en: ❷ Handle the bookings data locally.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 本地处理预订数据。
- en: ❸ Handle loading errors locally.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 本地处理加载错误。
- en: ❹ Wrap the grid generator function with useMemo.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 `useMemo` 将网格生成函数包装起来。
- en: ❺ Call the grid generator only if there’s a bookable.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 只有在有可预订的情况下才调用网格生成器。
- en: ❻ Regenerate the grid when the bookable or week changes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当可预订项或周发生变化时，重新生成网格。
- en: '`BookingsGrid` handles the bookings and error state itself with two calls to
    the `useState` hook. It then uses the `getGrid` function from section 7.4.2 to
    generate the grid, assigning the returned grid, sessions, and dates data to local
    variables. We’ve decided to see `getGrid` as an expensive function, wrapping it
    with `useMemo`. Why might it warrant such treatment?'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingsGrid` 使用两个 `useState` 钩子本身处理预订和错误状态。然后它使用 7.4.2 节中的 `getGrid` 函数生成网格，将返回的网格、会话和日期数据分配给局部变量。我们决定将
    `getGrid` 视为一个昂贵的函数，并用 `useMemo` 包装它。为什么它可能值得这样的处理？'
- en: When the user chooses a bookable on the Bookings page, the `Bookings` component
    displays a grid of booking slots for the bookable’s available sessions and dates.
    It generates the data for the grid based on the bookable’s properties and the
    selected week. As we’ll see in the next listing, the `BookingsGrid` component
    uses the fetch-on-render, data-loading strategy, sending a request for data after
    the initial render. The grid, shown in figure 7.9, displays a loading indicator
    in the top-left cell and reduces the opacity of the body cells until the data
    arrives.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在预订页面上选择可预订项时，`Bookings` 组件显示可预订项可用会话和日期的预订时段网格。它根据可预订项的属性和所选周生成网格数据。正如我们将在下一个列表中看到的，`BookingsGrid`
    组件使用在渲染时请求数据的数据加载策略，在初始渲染后发送数据请求。网格（如图 7.9 所示）在左上角单元格显示加载指示器，并在数据到达之前降低主体单元格的不透明度。
- en: '![](../Images/7-9.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-9.png)'
- en: Figure 7.9 The `BookingsGrid` component displays a loading spinner in its top-left
    cell and reduces the opacity of the grid cells while a fetch is in progress.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 `BookingsGrid` 组件在其左上角单元格显示加载指示器，并在数据请求进行时降低网格单元格的不透明度。
- en: When the data arrives, the grid re-renders, hiding the loading indicator and
    showing the bookings for the selected week. Figure 7.10 shows four bookings in
    the grid.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据到达时，网格会重新渲染，隐藏加载指示器并显示所选周的预订。图 7.10 显示了网格中的四个预订。
- en: '![](../Images/7-10.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-10.png)'
- en: Figure 7.10 The bookings grid showing four bookings
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 显示四个预订的预订网格
- en: With the bookings in place, the user is now free to select an existing booking
    or an empty booking slot. In figure 7.11, the user has selected the Movie Pitch!
    booking and, yet again, the component has re-rendered, highlighting the cell.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在预订就绪后，用户现在可以自由选择现有的预订或空预订时段。在图 7.11 中，用户选择了“电影提案”预订，并且组件再次重新渲染，突出显示单元格。
- en: '![](../Images/7-11.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-11.png)'
- en: Figure 7.11 The bookings grid showing a selected booking
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 显示已选择的预订的预订网格
- en: The component renders for each change in status, as listed in table 7.2, although
    the underlying grid data for the booking slots hasn’t changed.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 组件在状态变化时渲染，如表 7.2 所示，尽管预订时段的底层网格数据并未改变。
- en: Table 7.2 Bookings grid rendering behavior for different events
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 不同事件的预订网格渲染行为
- en: '| Event | Render with |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 渲染方式 |'
- en: '| Initial render | Blank grid |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 初始渲染 | 空网格 |'
- en: '| Data fetching | Loading indicator |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 数据获取 | 加载指示器 |'
- en: '| Data loaded | Bookings in cells |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 数据加载 | 单元格中的预订 |'
- en: '| Booking selected | Highlighted selection |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 已选预订 | 高亮选择 |'
- en: 'For the events listed, we don’t want to regenerate the underlying grid data
    on each re-render, so we use the `useMemo` hook, specifying the bookable and start
    date for the week as dependencies:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列出的活动，我们不想在每次重新渲染时重新生成底层的网格数据，因此我们使用 `useMemo` 钩子，指定可预订和周的开始日期作为依赖项：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By wrapping `getGrid` in `useMemo`, we ask React to store the generated grid
    lookup and to call `getGrid` again only if the bookable or start date changes.
    For the three re-rendering scenarios in table 7.2 (not for the initial render),
    React should return the stored grid, avoiding unnecessary computation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `getGrid` 包裹在 `useMemo` 中，我们要求 React 存储生成的网格查找，并且只有在可预订或开始日期更改时才再次调用 `getGrid`。对于表
    7.2 中的三个重新渲染场景（不是初始渲染），React 应该返回存储的网格，避免不必要的计算。
- en: In reality, for the size of grids we’re generating, we don’t really need `useMemo`.
    Modern browsers, JavaScript, and React will hardly notice the work required. There’s
    also some overhead in requiring React to store functions, return values, and dependency
    values, so we don’t want to memoize everything. As we saw with the anagrams example
    earlier in the chapter, however, sometimes expensive functions can adversely affect
    performance, so it’s good to have the `useMemo` hook in your toolbelt.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，对于我们生成的网格大小，我们实际上并不需要 `useMemo`。现代浏览器、JavaScript 和 React 几乎不会注意到所需的工作。此外，要求
    React 存储函数、返回值和依赖值也有一些开销，因此我们不想对所有内容进行记忆化。然而，正如我们在本章前面看到的字母表排列示例中看到的那样，有时昂贵的函数可能会对性能产生不利影响，所以拥有
    `useMemo` 钩子是个好主意。
- en: Although the main focus of this chapter is the `useMemo` hook, a useful technique
    for data-fetching within a call to `useEffect` is worth flagging with a subsection
    heading. Let’s see how to avoid getting multiple requests and responses knotted.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章的主要重点是 `useMemo` 钩子，但在 `useEffect` 调用中进行数据获取的有用技术值得用小节标题标记。让我们看看如何避免得到多个请求和响应的纠缠。
- en: 7.4.5 Coping with racing responses when fetching data in useEffect
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.5 在 useEffect 中获取数据时处理竞态响应
- en: When interacting with the bookings app, the user might get a little click-happy
    and switch quickly between bookables and weeks, initiating a flurry of data requests.
    We want to display the data for only their last selection. Unfortunately, we’re
    not in control of when the data returns from the server, and an older request
    might resolve after a more recent one, leaving the display out of sync with the
    user’s selection.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当与预订应用交互时，用户可能会变得有点点击狂热，快速在可预订和周之间切换，引发一系列数据请求。我们只想显示他们的最后选择的数据。不幸的是，我们无法控制数据从服务器返回的时间，一个较旧请求可能在较新的请求之后解决，导致显示与用户的选择不同步。
- en: We could try to implement a way to cancel in-flight requests. If the data response
    isn’t too large, however, it’s easier to simply let the requests run their course
    and ignore the unwanted data when it arrives. In this subsection, we finish off
    the `BookingsGrid` component, fetching the bookings data, and building the UI
    for display.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试实现一种取消进行中的请求的方法。然而，如果数据响应不是太大，简单地让请求按其流程运行并忽略到达的不想要的日期会更简单。在本小节中，我们完成
    `BookingsGrid` 组件，获取预订数据，并构建用于显示的 UI。
- en: Effects
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 影响
- en: The `BookingsGrid` component loads the bookings for the selected bookable and
    week. Listing 7.13 shows calls to our helper functions, `getBookings` and `transformBookings`,
    wrapped inside a call to `useEffect`. The effect runs whenever the week or bookable
    changes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingsGrid` 组件加载所选可预订和周次的预订。列表 7.13 显示了在 `useEffect` 调用中包裹我们的辅助函数 `getBookings`
    和 `transformBookings` 的调用。效果在周或可预订更改时运行。'
- en: 'Branch: 0702-bookings-memo, File: /src/components/Bookings/BookingsGrid.js'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0702-bookings-memo，文件：/src/components/Bookings/BookingsGrid.js
- en: 'Listing 7.13 The `BookingsGrid` component: 2\. Effects'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13 `BookingsGrid` 组件：2. 影响
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Use a variable to track whether the bookings data is current.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用变量跟踪预订数据是否最新。
- en: ❷ Call our getBookings data-fetching function.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用我们的 `getBookings` 数据获取函数。
- en: ❸ Check if the bookings data is current.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查预订数据是否最新。
- en: ❹ Create a bookings lookup and assign it to state.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个预订查找并将其分配给状态。
- en: ❺ Return a cleanup function to invalidate the data.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回一个清理函数以使数据无效。
- en: ❻ Run the effect when the bookable or week changes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当可预订或周发生变化时运行效果。
- en: 'The code uses a `doUpdate` variable to match each request with its data. The
    variable is initially set to `true`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用 `doUpdate` 变量来匹配每个请求及其数据。该变量最初设置为 `true`：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For a particular request, the callback function in the `then` clause will update
    the state only if `doUpdate` is still `true`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的请求，`then` 子句中的回调函数只有在 `doUpdate` 仍然是 `true` 时才会更新状态：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When the user selects a new bookable or switches to a new week, React reruns
    the component, and the effect runs again to load the newly selected data. The
    in-flight data from the previous request is no longer needed. Before rerunning
    an effect, React calls any associated cleanup function for the previous invocation
    of the effect. Our effect uses the cleanup function to invalidate the in-flight
    data:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择新的可预订项或切换到新的一周时，React 会重新运行组件，并再次运行效果以加载新选择的数据。之前请求的飞行数据不再需要。在重新运行效果之前，React
    会调用之前效果调用的任何相关清理函数。我们的效果使用清理函数来使飞行数据无效：
- en: '[PRE27]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the previously requested bookings arrive, the `then` clause from the associated
    call to `getBookings` will see the data is stale and won’t update the state.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当之前请求的预订到达时，`getBookings` 相关调用的 `then` 子句会看到数据已过时，不会更新状态。
- en: If the bookings are current, the `then` clause transforms the linear array of
    bookings into a lookup structure by passing the response to the `transformBookings`
    function. The lookup object is assigned to local state with `setBookings`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预订是当前的，`then` 子句通过传递响应到 `transformBookings` 函数将预订的线性数组转换为查找结构。查找对象通过 `setBookings`
    分配到本地状态。
- en: UI helper function
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: UI 辅助函数
- en: The contents and behavior of a cell in the bookings grid depend on whether there
    are any bookings to display and whether the user has selected the cell. Figure
    7.12 shows a couple of empty cells and a cell for an existing booking, Movie Pitch!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 预订网格中单元格的内容和行为取决于是否有要显示的预订以及用户是否选择了单元格。图 7.12 显示了一些空单元格和一个现有预订单元格，Movie Pitch!。
- en: '![](../Images/7-12.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-12.png)'
- en: Figure 7.12 Cells in the grid represent existing bookings where they exist,
    or just the underlying grid data for session and date.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 网格中的单元格表示存在的预订，如果存在，或者只是会话和日期的底层网格数据。
- en: When a user selects a cell, that cell should be highlighted, whether the cell
    shows an existing booking or an empty booking slot. Figure 7.13 shows the grid
    after the user has selected the Movie Pitch! booking. CSS styles and the cell’s
    `class` attribute are used to change the cell’s appearance.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择一个单元格时，无论单元格显示的是现有预订还是空预订槽，该单元格都应该被突出显示。图 7.13 显示了用户选择 Movie Pitch! 预订后的网格。CSS
    样式和单元格的 `class` 属性用于改变单元格的外观。
- en: '![](../Images/7-13.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-13.png)'
- en: Figure 7.13 The selected cell is displayed using different CSS styles.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 使用不同的 CSS 样式显示所选单元格。
- en: Listing 7.14 has the code for a `cell` helper function that returns the UI for
    a single cell in the bookings grid. It uses the two lookup objects, `bookings`
    and `grid`, to get the data for the cell, set the cell’s class, and attach an
    event handler if there are bookings. The `cell` function is in the scope of `BookingsGrid`
    and can access the `booking`, `bookings`, `grid`, and `setBookings` variables.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14 包含一个 `cell` 辅助函数的代码，该函数返回预订网格中单个单元格的 UI。它使用两个查找对象 `bookings` 和 `grid`
    来获取单元格的数据，设置单元格的类，并在有预订的情况下附加事件处理程序。`cell` 函数在 `BookingsGrid` 的作用域内，可以访问 `booking`、`bookings`、`grid`
    和 `setBookings` 变量。
- en: 'Branch: 0702-bookings-memo, File: /src/components/Bookings/BookingsGrid.js'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0702-bookings-memo，文件：/src/components/Bookings/BookingsGrid.js
- en: 'Listing 7.14 The `BookingsGrid` component: 3\. UI helper'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14 `BookingsGrid` 组件：3. UI 辅助工具
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ First check the bookings lookup, then the grid lookup.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 首先检查预订查找，然后是网格查找。
- en: ❷ Use optional chaining because there might not be a booking.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用可选链，因为可能没有预订。
- en: ❸ Set a handler only if bookings have been loaded.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅当预订已加载时设置处理程序。
- en: '![](../Images/7-14.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-14.png)'
- en: Figure 7.14 The display of a cell depends on whether the grid is active and
    whether a cell has been selected. While bookings are loading, the UI shows the
    loading indicator, and the grid is not active.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 单元格的显示取决于网格是否处于活动状态以及单元格是否已被选中。在加载预订时，UI 显示加载指示器，网格不处于活动状态。
- en: 'The data for a cell comes either from the existing bookings in the `bookings`
    lookup or from the empty booking slot data in the `grid` lookup. The code uses
    optional chaining syntax with square-bracket notation to assign the correct value
    to the `cellData` variable:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格的数据要么来自 `bookings` 查找中的现有预订，要么来自 `grid` 查找中的空预订时段数据。代码使用方括号表示法的可选链语法将正确的值分配给
    `cellData` 变量：
- en: '[PRE29]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `bookings` lookup has data for only the existing bookings, but the `grid`
    lookup has data for every session and date. We need the optional chaining for
    `bookings` but not for `grid`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`bookings` 查找只包含现有预订的数据，但 `grid` 查找包含每个会话和日期的数据。我们需要为 `bookings` 使用可选链，但不为
    `grid` 使用。'
- en: We set the click handler on the cell only if there are bookings. While bookings
    are loading, when a user switches bookables or weeks, the handler is set to `null`
    and the user can’t interact with the grid.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在存在预订时，我们才在单元格上设置点击处理程序。当预订正在加载时，当用户切换可预订项或周次时，处理程序设置为 `null`，用户无法与网格交互。
- en: UI
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: UI
- en: 'The final piece of the `BookingsGrid` puzzle returns the UI. As ever, the UI
    is driven by the state. We check whether the grid of booking slots has been generated,
    whether the bookings have been loaded, and whether there is an error. We then
    return either alternative UI (loading text) or additional UI (an error message),
    or we set class names to show, hide, or highlight elements. Figure 7.14 shows
    the bookings grid for three states:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookingsGrid` 拼图的最后一部分返回 UI。一如既往，UI 由状态驱动。我们检查预订时段的网格是否已生成，预订是否已加载，以及是否存在错误。然后我们返回替代
    UI（加载文本）或附加 UI（错误消息），或者设置类名以显示、隐藏或突出显示元素。图 7.14 展示了三种状态下的预订网格：'
- en: There are no bookings. The grid shows a loading indicator. The grid is inactive,
    and the user can’t interact with the grid.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有预订。网格显示加载指示器。网格处于非活动状态，用户无法与网格交互。
- en: The bookings have loaded. The grid hides the loading indicator. The grid is
    active, and the user can interact with the grid.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预订已加载。网格隐藏了加载指示器。网格处于活动状态，用户可以与网格交互。
- en: The bookings have loaded. The grid hides the loading indicator. The grid is
    active, and the user has selected a cell.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预订已加载。网格隐藏了加载指示器。网格处于活动状态，用户已选择一个单元格。
- en: '![](../Images/7-15.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-15.png)'
- en: Figure 7.15 The `BookingsGrid` component displays any errors above the grid.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 `BookingsGrid` 组件在网格上方显示任何错误。
- en: In figure 7.15, you can see an error displayed right above the date headings
    for the grid.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 7.15 中，你可以看到错误信息直接显示在网格日期标题上方。
- en: The following listing shows the error section, uses class names to control whether
    the grid is active, and calls our UI helper function, `cell`, to get the UI for
    each table cell.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了错误部分，使用类名来控制网格是否处于活动状态，并调用我们的 UI 辅助函数 `cell` 来获取每个表格单元格的 UI。
- en: 'Branch: 0702-bookings-memo, File: /src/components/Bookings/BookingsGrid.js'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0702-bookings-memo，文件：/src/components/Bookings/BookingsGrid.js
- en: 'Listing 7.15 The `BookingsGrid` component: 4\. UI'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.15 `BookingsGrid` 组件：4. UI
- en: '[PRE30]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Show an error section at the top of the grid if there’s an error.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果有错误，在网格顶部显示错误部分。
- en: ❷ Include an “active” class when the bookings data has loaded.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当预订数据已加载时，包含一个“活动”类。
- en: ❸ Include a loading indicator in the top-left cell.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在左上角单元格中包含一个加载指示器。
- en: ❹ Use the UI helper function to generate each table cell.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 UI 辅助函数生成每个表格单元格。
- en: If `bookings` is not `null`, a class of `active` is assigned to the table. The
    CSS for the app hides the loading indicator and sets the cell opacity to 1 when
    the grid is active.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `bookings` 不是 `null`，则将 `active` 类分配给表格。应用的 CSS 隐藏加载指示器，并在网格处于活动状态时将单元格不透明度设置为
    1。
- en: In the code, we inspect the state ourselves and decide what UI to return from
    within the component. It’s also possible to use React *error boundaries* to specify
    error UI and React’s `Suspense` component to specify fallback UI while data is
    loading, separately from individual components. We use error boundaries to catch
    errors and `Suspense` components to catch promises (loading data) in part 2.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们自行检查状态并决定从组件内部返回什么 UI。也可以使用 React 的 *错误边界* 来指定错误 UI，以及使用 React 的 `Suspense`
    组件来指定数据加载时的回退 UI，这些操作与单个组件分开进行。在第二部分中，我们使用错误边界来捕获错误，并使用 `Suspense` 组件来捕获承诺（加载数据）。
- en: Before that, we need to create our `BookingDetails` component to show the details
    of whichever booking slot or existing booking a user clicks. The new component
    needs access to the current user of the app, stored all the way up in the root
    component, `App`. Rather than drilling the user value down through multiple layers
    of component props, we’ll enlist the help of React’s Context API and the `useContext`
    hook.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们需要创建我们的 `BookingDetails` 组件来显示用户点击的任何预订时段或现有预订的详细信息。新组件需要访问应用中的当前用户，存储在根组件
    `App` 中。而不是通过多层组件属性向下传递用户值，我们将利用 React 的 Context API 和 `useContext` 钩子来寻求帮助。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Try to avoid unnecessarily rerunning expensive computations by wrapping them
    in the `useMemo` hook.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量避免通过将它们包装在 `useMemo` 钩子中来不必要地重新运行昂贵的计算。
- en: 'Pass `useMemo` the expensive function you want to memoize:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要缓存的昂贵函数传递给 `useMemo`：
- en: '[PRE31]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Pass the `useMemo` hook a list of dependencies for the expensive function:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `useMemo` 钩子传递给昂贵函数的依赖项列表：
- en: '[PRE32]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the values in the dependency array don’t change from one call to the next,
    `useMemo` can return its stored result for the expensive function.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果依赖数组中的值在连续调用之间没有变化，`useMemo` 可以返回其存储的昂贵函数的结果。
- en: Don’t rely on `useMemo` to always use a memoized value. React may discard stored
    results if it needs to free up memory.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要依赖 `useMemo` 总是使用缓存值。如果 React 需要释放内存，它可能会丢弃存储的结果。
- en: 'Use JavaScript’s optional chaining syntax with square brackets to access properties
    of variables that may be `undefined`. Include a period, even when working with
    square brackets:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 的可选链式语法（方括号）来访问可能为 `undefined` 的变量的属性。即使在处理方括号时，也要包含一个点：
- en: '[PRE33]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When fetching data within a call to `useEffect`, combine a local variable and
    the cleanup function to match a data request with its response:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `useEffect` 调用中获取数据时，将局部变量和清理函数结合起来，以匹配数据请求及其响应：
- en: '[PRE34]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the component re-renders with a new `url`, the cleanup function for the previous
    render will set the previous render’s `doUpdate` variable to `false`, preventing
    the previous `then` method callback from performing updates with stale data.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果组件使用新的 `url` 重新渲染，前一次渲染的清理函数会将前一次渲染的 `doUpdate` 变量设置为 `false`，防止前一次的 `then`
    方法回调使用过时的数据进行更新。
