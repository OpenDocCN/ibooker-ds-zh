- en: 4 Writing composable, pure code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 编写可组合、纯函数代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Refactoring imperative coding to a declarative, functional style
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令式编码重构为声明式、函数式风格
- en: Mastering JavaScript’s higher-order functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握JavaScript的高阶函数
- en: Introducing pure functions and immutability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍纯函数和不可变性
- en: Combining pure logic with curry and composition
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将纯逻辑与柯里化和组合结合
- en: Improving readability and structure of code with a point-free style
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无点风格提高代码的可读性和结构
- en: Creating native function chains with the pipeline operator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道操作符创建原生函数链
- en: '*If you want to see which features will be in mainstream programming languages
    tomorrow, then take a look at functional programming languages today*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想知道明天主流编程语言中会有哪些特性，那么现在就看看函数式编程语言吧*'
- en: —Simon Peyton Jones
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ——西蒙·佩顿·琼斯
- en: 'If objects are the fabric of JavaScript, functions represent the needles used
    to thread the pieces together. We can use functions in JavaScript to describe
    collections of objects (classes, constructor functions, and so on) and also to
    implement the business logic, the machinery that advances the state of our application.
    The reason why functions are so ubiquitous, versatile, and powerful in JavaScript
    is that they are objects too:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象是JavaScript的织物，那么函数就是用来缝合这些片段的针。我们可以在JavaScript中使用函数来描述对象集合（类、构造函数等），也可以用来实现业务逻辑，推动我们应用程序状态的机器。函数在JavaScript中如此普遍、灵活和强大，是因为它们也是对象：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JavaScript has higher-order or first-class functions, which means you can pass
    them around as arguments to another function or as a return value. With higher-order
    functions, you can dramatically simplify complex patterns of software to a handful
    of functions, making JavaScript a lot more succinct than other mainstream languages
    such as Java and C#.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript具有高阶或一等函数，这意味着你可以将它们作为参数传递给另一个函数，或者作为返回值。通过高阶函数，你可以将复杂的软件模式简化为一小部分函数，使JavaScript比其他主流语言（如Java和C#）更加简洁。
- en: In chapter 3, we looked at how objects compose their structure to some extent
    using OLOO and more fully using mixins. Higher-order functions compose too—not
    structurally, but behaviorally, by being chained together and passed around as
    callbacks to represent sequences of computational logic. Higher-order functions
    are JavaScript’s most powerful features by far, and the best way to learn about
    them is through the functional programming (FP) paradigm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们探讨了对象如何通过OLOO（对象链接对象）在一定程度上组合其结构，通过混入（mixins）则更加充分。高阶函数也可以组合——不是结构上，而是通过连接在一起，作为回调传递来表示计算逻辑的序列。高阶函数是JavaScript最强大的特性，了解它们的最佳方式是通过函数式编程（FP）范式。
- en: FP is a force to be reckoned with. These days, it’s almost impossible to read
    about the wonders of JavaScript without seeing a shout-out to FP. I think JavaScript
    has continued to flourish thanks to its FP support, which is one of the things
    that drew me toward JavaScript many years ago. Although, theoretically, FP is
    an old school of thought, it’s become pervasive recently in JavaScript coding
    and application design. Good examples are libraries such as Underscore and Lodash
    for processing data, React and Hooks for building modern UIs, and Redux and RxJS
    for managing state. In fact, if you look at 2019’s State of JavaScript results
    for most-used utility libraries ([https://2019.stateofjs .com/other-tools/#utilities](https://2019.stateofjs.com/other-tools/#utilities)),
    you will find Lodash, Underscore, RxJS, and Ramda ranking at the top. All these
    libraries enhance the functional capabilities of JavaScript.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程（FP）是一股不可忽视的力量。如今，几乎不可能不提到FP的奇妙之处来谈论JavaScript。我认为JavaScript之所以能够持续繁荣，得益于其对FP的支持，这也是多年前吸引我转向JavaScript的原因之一。虽然从理论上讲，FP是一种老式思想，但它最近在JavaScript编码和应用设计中变得无处不在。好的例子包括Underscore和Lodash这样的库用于数据处理，React和Hooks用于构建现代UI，以及Redux和RxJS用于状态管理。实际上，如果你查看2019年JavaScript状态调查结果中最常用的实用库（[https://2019.stateofjs.com/other-tools/#utilities](https://2019.stateofjs.com/other-tools/#utilities)），你会发现Lodash、Underscore、RxJS和Ramda排名靠前。所有这些库都增强了JavaScript的函数式能力。
- en: Fundamentally speaking, FP promotes a different approach to problem solving
    from the more common structured or imperative way to which we’re all accustomed.
    Wrapping your head around FP requires a mastery of JavaScript’s main unit of computation,
    which has always been functions. Any type of object definition tries to associate
    the data (instance fields) with the logic (methods) that process that data. Objects
    compose at a coarse-grained level, as you learned about in chapter 3\. Functions,
    on the other hand, separate data (arguments) and logic (function body) more distinctly
    and compose at a more fine-grained, lower level. FP programs are made up of a
    set of functions that receive input and produce a result with this data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，函数式编程（FP）提倡一种与更常见的结构化或命令式方式不同的解决问题的方法，这是我们所有人都习惯的方式。理解函数式编程需要掌握JavaScript的主要计算单元，这始终是函数。任何类型的对象定义都试图将数据（实例字段）与处理这些数据的逻辑（方法）关联起来。对象在粗粒度级别上进行组合，正如你在第3章中学到的。另一方面，函数更明显地分离数据（参数）和逻辑（函数体），并在更细粒度、更低的级别上进行组合。函数式程序由一组接收输入并使用这些数据产生结果的函数组成。
- en: In this chapter, we’ll take two important parts of our blockchain application
    and improve them by using FP. The goal is not a complete redesign of the application.
    Rather, we’ll keep things simple and take a more lenient approach that combines
    the benefits of OO and FP paradigms together—aka a hybrid model. You’ll learn
    that although imperative and FP disagree on fundamental principles, you can benefit
    from their strengths when tackling different parts of your application. To help
    you transition to an FP way of coding, we’ll visualize how an imperative program
    is converted to a functional one (section 4.2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将选取我们区块链应用的两个重要部分，通过使用函数式编程（FP）来改进它们。目标不是对应用进行完全的重设计。相反，我们将保持简单，采取更宽容的方法，将面向对象（OO）和函数式编程（FP）范式的好处结合起来——即混合模型。你将了解到，尽管命令式和函数式编程在基本原则上存在分歧，但在处理应用的不同部分时，你可以从它们的优势中受益。为了帮助你过渡到函数式编程的编码方式，我们将可视化一个命令式程序是如何转换为函数式程序的（第4.2节）。
- en: Unless you’re an expert, I recommend that you start by slowly adopting the basics
    of FP covered in this chapter and then finding ways to embed FP in your application.
    Later, how far you want to take this paradigm in your own code is up to you. Core
    business logic is usually a good candidate for this way of thinking. We’ll go
    through the exercise of refactoring some imperative code into functional so that
    you can get a sense of how these two kinds compare.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你是专家，否则我建议你从本章中介绍的函数式编程的基本知识开始慢慢学习，然后找到将函数式编程嵌入到你的应用中的方法。以后，你想要在你的代码中走多远，这取决于你。核心业务逻辑通常是这种思维方式的好候选者。我们将通过将一些命令式代码重构为函数式代码的练习，让你感受到这两种方法的比较。
- en: It’s been a noticeable trend for a few years now that platform teams, including
    JavaScript, are adding more features to their programming languages to support
    a functional style. ECMAScript 2019 (aka ES10), for example, added `Array.prototype`
    `.{flat``,`and `flatMap``}`, which are integral to using data structures in a
    functional way. As of this writing, the road map for TC39 features a set of functional-inspired
    proposals moving up the ranks that will affect how you write JavaScript code in
    the years to come. So learning about this paradigm now will prepare you for what’s
    ahead. In this book, we’ll be looking at the
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，平台团队，包括JavaScript，都在向他们的编程语言添加更多功能以支持函数式风格，这已经成为一个明显的趋势。例如，ECMAScript 2019（又称ES10）添加了`Array.prototype.flat`和`flatMap`，这对于以函数式方式使用数据结构至关重要。截至本文撰写时，TC39的功能路线图上有一系列受函数式编程启发的提案正在上升，这将影响你未来几年编写JavaScript代码的方式。因此，现在了解这种范式将为你未来的学习做好准备。在这本书中，我们将探讨
- en: Pipeline operator ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道操作符 ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator))
- en: Bind operator ([https://github.com/tc39/proposal-bind-operator](https://github.com/tc39/proposal-bind-operator))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定操作符 ([https://github.com/tc39/proposal-bind-operator](https://github.com/tc39/proposal-bind-operator))
- en: We still have a way to go before we understand why these features are so important.
    Understanding these features begins with understanding functional programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解为什么这些功能如此重要之前，我们还有很长的路要走。理解这些功能始于理解函数式编程。
- en: 4.1 What is functional programming?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 什么是函数式编程？
- en: 'In this section, I’ll provide a suitable definition of FP. First, I’ll show
    you a short example and go over some of the basic qualities of functional code.
    Many people relate FP to the array APIs `map`, `reduce`, and `filter`. You’ve
    probably seen these APIs in action many times. Let’s start with a quick example
    to jog your memory: determine whether all block objects in an array are valid.
    For this example, you can assume that you can skip validating the genesis block
    and that all blocks have an `isValid` method. Implementing this logic by using
    the array APIs would look like the next listing.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将提供一个合适的FP定义。首先，我会给你一个简短的例子，并概述一些函数式代码的基本特性。许多人将FP与数组API `map`、`reduce`
    和 `filter` 相关联。你可能多次见过这些API的实际应用。让我们从一个快速示例开始，以唤醒你的记忆：确定数组中所有区块对象是否有效。对于这个例子，你可以假设可以跳过验证创世区块，并且所有区块都有一个
    `isValid` 方法。通过使用数组API实现这个逻辑将类似于下面的列表。
- en: Listing 4.1 Combining `map`, `filter`, and `reduce`
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 结合 `map`、`filter` 和 `reduce`
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Skips the genesis block (which is always assumed to be valid)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跳过创世区块（始终假设是有效的）
- en: ❷ Converts the array of blocks to an array of Boolean values by calling isValid
    on each block
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过对每个区块调用 `isValid`，将区块数组转换为布尔值数组
- en: ❸ Performs a logical AND of all the Boolean values together, parting from true,
    to obtain the final result
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对所有布尔值进行逻辑与操作，从true开始，以获得最终结果
- en: As you know, these array APIs were designed to be higher-order functions, which
    means that they either accept a callback function or return one and delegate most
    of the logic to the callback function you provide. You’ve probably written similar
    code before but never thought about it from an FP point of view. An FP-aware programmer
    always prefers writing code that is heavily driven by higher-order functions this
    way.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，这些数组API被设计成高阶函数，这意味着它们要么接受一个回调函数，要么返回一个，并将大部分逻辑委托给提供的回调函数。你可能之前写过类似的代码，但从未从函数式编程的角度考虑过。一个具有FP意识的程序员总是更喜欢以这种方式编写由高阶函数驱动的代码。
- en: 'Aside from the tendency to use functions for almost anything, another important
    quality of FP programs is immutability. In listing 4.1, even though `arr` is being
    mapped over and filtered, the original `arr` reference is kept intact:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了几乎用函数做任何事情的趋势之外，FP程序的重要特性还包括不可变性。在列表4.1中，尽管 `arr` 正在被映射和过滤，但原始的 `arr` 引用保持完整：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Code that is immutable avoids bugs that arise from inadvertently changing your
    application’s state, especially when you deal with asynchronous functions that
    can run at arbitrary points in time. Did you know that methods such as `reverse`
    and `sort` mutate the array in place? What would happen if you passed that original
    array object to some other part of your program? Now the result is unpredictable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变代码避免了由于意外更改应用程序状态而产生的错误，尤其是在处理可以在任意时间点运行的异步函数时。你知道 `reverse` 和 `sort` 方法会就地修改数组吗？如果你将原始数组对象传递给程序的其他部分会发生什么？现在结果是不可预测的。
- en: 'An immutable function that always returns a predictable result, given a set
    of arguments, is known as pure, and with that definition, we arrive at the definition
    of FP:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个总是返回可预测结果的不可变函数，给定一组参数，被称为纯函数，根据这个定义，我们来到了FP的定义：
- en: '*Functional programming is the art of composing higher-order functions to advance
    the state of a program in a pure manner.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数式编程是艺术性地组合高阶函数，以纯粹的方式推进程序状态。*'
- en: 'So far, I’ve talked a little about composition and pure code. FP takes these
    ideas to the practical extreme. Now I’ll unpack the key parts of the definition
    of FP:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经简要地谈到了组合和纯代码。函数式编程将这些理念推向了实用的极致。现在，我将展开FP定义的关键部分：
- en: As you know by now, a higher-order function is one that can receive a function
    as a parameter or produce another function as a return value. With FP, you use
    functions for pretty much anything you do, and your program becomes one big assembly
    of functions glued together by composition.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如你所知，高阶函数是可以接收函数作为参数或产生另一个函数作为返回值的函数。在FP中，你几乎可以用函数做任何事情，你的程序就变成了一个由组合连接起来的函数大集合。
- en: Pure functions compute their results based entirely on the set of input arguments
    received. They don’t cause side effects—that is, they don’t rely on accessing
    any outside or globally shared state, which makes programs more predictable and
    simple to reason about because you don’t have to keep track of unintended state
    changes.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数完全基于接收到的输入参数集来计算其结果。它们不会产生副作用——也就是说，它们不依赖于访问任何外部或全局共享的状态，这使得程序更可预测且易于推理，因为你不必跟踪意外的状态变化。
- en: FP developers use functions to represent any type of data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: FP 开发者使用函数来表示任何类型的数据。
- en: 4.1.1 Functions as data
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 函数作为数据
- en: 'You can use functions to represent data in the form of expressions. Expressions
    can be evaluated to produce a value right away or passed to other parts of your
    code as callbacks to be evaluated when needed. Here are a few examples:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用函数以表达式的形式表示数据。表达式可以立即评估以产生一个值，或者作为回调传递到代码的其他部分，以便在需要时评估。以下是一些示例：
- en: 'Declare a constant value:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个常量值：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As with regular constants, you can assign an expression to a variable or pass
    it as a function argument.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如常规常量一样，你可以将表达式赋给变量或将其作为函数参数传递。
- en: 'Echo the same value, also known as the identity function:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射相同的值，也称为恒等函数：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create new objects or implement arbitrary business logic:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新对象或实现任意业务逻辑：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function is known as a factory function, which always produces a new object.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数被称为工厂函数，它总是产生一个新的对象。
- en: 'Encapsulated, private data (closure):'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装、私有数据（闭包）：
- en: '[PRE6]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`a` is stored as part of the outer function’s closure and referenced later
    in the internal function when the entire expression is evaluated:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`a` 作为外部函数的闭包的一部分存储，并在整个表达式评估时在内部函数中引用：'
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: NOTE The arrow function notation used here is syntactically convenient to embed
    in fluent method chains, such as when you code with `map`, `filter`, `reduce`,
    and others or when you need an one-line expression. Although this chapter uses
    this notation often because of its terse design, regular function syntax is equally
    appropriate for all these examples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这里使用的箭头函数符号在语法上方便嵌入流畅的方法链中，例如当你使用 `map`、`filter`、`reduce` 等进行编码或需要一行表达式时。尽管这一章经常使用这种符号，因为它设计简洁，但常规函数语法同样适用于所有这些例子。
- en: All these expressions (except the first one) receive input and return output.
    The return value of a pure function is always a factor of the input it receives
    (unless it’s always a constant); otherwise, the implication is that you’ve somehow
    opened the door to side effects and impure code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些表达式（除了第一个）接收输入并返回输出。纯函数的返回值始终是输入的一个因子（除非它始终是一个常数）；否则，这意味着你以某种方式打开了通往副作用和不纯代码的大门。
- en: Listing 4.2 shows a simple, naïve example that illustrates combining some of
    these expressions, which contain computation or data, as higher-order functions.
    The code attempts to perform some mathematical operation only if conditions allow;
    otherwise, it returns a default value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 展示了一个简单、直观的示例，说明了如何将这些包含计算或数据的表达式组合为高阶函数。代码仅在条件允许的情况下尝试执行一些数学运算；否则，它返回一个默认值。
- en: Listing 4.2 Combining higher-order functions
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 组合高阶函数
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Checks whether a value is not null
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查一个值是否不为空
- en: ❷ Executes a safe operation; otherwise, calls a recovery function
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行安全操作；否则，调用恢复函数
- en: ❸ Runs operation only if the validator function returns true; otherwise, returns
    NaN
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅当验证函数返回 true 时运行操作；否则，返回 NaN
- en: ❹ Uses the identity function as recovery, aliased under the name orElse
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用恒等函数作为恢复，别名为 orElse
- en: ❺ Computes the square of a number if the input is not null; otherwise, recovers
    with the value 42
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果输入不为空，则计算数字的平方；否则，使用值 42 进行恢复
- en: If you look at the structure of `safeSquare`, notice that it’s made up of functions
    that clearly communicate the intent of the program. Some of these functions carry
    only data (`orElse`); other functions carry out a computation (`square`); some
    functions do both (`onlyIf`). This listing gives you a good first look at code
    done the functional way.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `safeSquare` 的结构，你会发现它由一些函数组成，这些函数清楚地传达了程序的意图。其中一些函数只携带数据（`orElse`）；其他函数执行计算（`square`）；一些函数两者兼具（`onlyIf`）。这个列表为你提供了一个很好的首次了解以函数方式编写的代码。
- en: 4.1.2 The functional way
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 函数式方法
- en: As the saying goes, less is more. The functional paradigm imposes restrictions
    that are meant not to diminish what you can do, but to empower you. In this section,
    you’ll look at a set of guidelines that help you code the functional way. In section
    4.3.2, you’ll learn how to work with these guidelines to tackle any type of problem.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如俗话所说，少即是多。函数式范式施加的限制旨在不是减少你可以做的事情，而是赋予你力量。在本节中，你将了解一组有助于你以函数式方式编码的指南。在第4.3.2节中，你将学习如何使用这些指南来解决任何类型的问题。
- en: An FP programmer always codes with a certain set of rules in mind. These rules
    can take some getting used to but become second nature with practice. Learning
    them will be well worth your time, however, because you’ll end up with code that
    is more predictable and simpler to maintain.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: FP程序员总是带着一套规则在心中编码。这些规则可能需要一些时间来适应，但随着实践会变得自然而然。然而，学习它们将非常值得你的时间，因为最终你会得到更可预测且更容易维护的代码。
- en: 'The functional way in JavaScript involves these four simple rules:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数式方法涉及这四条简单的规则：
- en: Functions must always return a value and (with a few exceptions) declare at
    least one parameter.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数必须始终返回一个值，并且（除了一些例外情况）至少声明一个参数。
- en: The observable state of an application before and after a function runs does
    not change; it’s immutable and side-effect-free. A new state is created each time.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数运行前后应用程序的可观察状态不会改变；它是不可变的且无副作用的。每次都会创建一个新的状态。
- en: Everything a function needs to carry its work must be passed in via arguments
    or inherited from its surrounding outer function (closure), provided that the
    outer function abides by the same rules.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数执行其工作所需的一切都必须通过参数传递或从其周围的父函数（闭包）继承，前提是父函数遵守相同的规则。
- en: A function called with the same input must always produce the same output. This
    rule leads to a principle known as referential transparency, which states that
    an expression and its corresponding value are interchangeable without altering
    the code’s behavior.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用相同输入的函数必须始终产生相同的输出。这个规则导致了一个被称为引用透明性的原则，该原则指出，一个表达式及其对应的值可以互换而不改变代码的行为。
- en: With these simple rules, we can remove side effects and mutations from your
    code, which are one of the leading causes of bugs. When a function obeys all these
    rules, it is said to be pure. Sound simple enough? To rephrase, FP is the art
    of combining functions that play by these rules to advance the state of a program
    to its final outcome.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些简单的规则，我们可以从你的代码中移除副作用和突变，这些都是导致错误的主要原因之一。当一个函数遵守所有这些规则时，它被称为纯函数。听起来足够简单吗？换句话说，FP是将遵循这些规则的函数组合起来以推进程序状态到最终结果的艺术。
- en: According to these rules, how is something like printing to the console pure?
    It’s not. Functions that reach out of their scope, to perform I/O in this case,
    are effectful —that is, they cause a side effect. Side effects can also include
    functions that read/write to variables outside their own scope, accesses the filesystem,
    writes to a network socket, relies on random methods such as `Math.random`, and
    so on. Anything that makes the outcome of a function unpredictable is considered
    bad practice in the FP world.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则，如何将打印到控制台这样的操作视为纯函数呢？它不是。超出其作用域的函数，在这种情况下执行I/O，是有效果的——也就是说，它们会产生副作用。副作用还可以包括在其作用域之外读取/写入变量的函数、访问文件系统、写入网络套接字、依赖于随机方法如`Math.random`等。任何使函数结果不可预测的事物都被视为FP世界中的不良实践。
- en: But how can anything useful come out of functional coding when we can’t touch
    all the things that mutate the state of our program? Indeed, working with immutable
    code requires a different mindset and, in some cases, a different approach to
    a problem, which is the hardest part. With FP, objects shouldn’t be manipulated
    and changed directly. A change to an object means that a new one is always created,
    similar to version control, in that every change, even in the same line, results
    in a new commit ID. With respect to reading files, printing to the console, or
    any other practical real-world task, we need to learn to deal with these cases
    in a practical way.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们无法触及改变程序状态的那些事物时，如何从函数式编码中获得有用的东西呢？确实，处理不可变代码需要不同的思维方式，在某些情况下，需要以不同的方式处理问题，这是最难的部分。在FP中，对象不应该被直接操作和更改。对对象的更改意味着总是创建一个新的对象，类似于版本控制，其中每个更改，即使在同一行，也会产生一个新的提交ID。至于读取文件、打印到控制台或其他任何实际的实际任务，我们需要学会以实际的方式处理这些情况。
- en: So far, we’ve been talking about FP at a high level. To make this discussion
    more concrete, section 4.2 compares functional and imperative code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在高层次上讨论FP。为了使这次讨论更加具体，第4.2节比较了函数式和命令式代码。
- en: 4.2 Functional versus imperative at a glance
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 函数式与命令式一览
- en: So that you can begin to wrap your head around this paradigm shift, it’s best
    to tackle a couple of problems. We’ll quickly go over the techniques needed to
    implement this shift throughout the chapter so that you get an end-to-end view
    of using FP in JavaScript.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你开始理解这个范式转变，最好的办法是解决几个问题。我们将在本章中快速概述实现这一转变所需的技术，以便你能够全面了解在JavaScript中使用FP（函数式编程）的过程。
- en: The first problem we’re tackling in this chapter is a functional way to implement
    the logic behind calculating hashes. Here, we will swap the insecure algorithm
    for a secure implementation of the `HasHash` mixin logic. This implementation
    will be a good warmup for our second example, which involves calculating the balance
    of a user’s digital wallet by using only pure functions. In the latter exercise,
    we will see a complete refactoring of imperative code into functional. The balance
    calculation involves processing all the blocks from the public ledger and tallying
    all the transactions that refer to a specific user. If the user appears as the
    recipient, we add funds; otherwise, we subtract funds.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们要解决的第一个问题是如何以函数式的方式实现计算哈希的逻辑。在这里，我们将用安全的`HasHash`混合逻辑实现来替换不安全的算法。这个实现将为我们第二个示例提供一个良好的热身，该示例涉及通过仅使用纯函数来计算用户的数字钱包余额。在后一个练习中，我们将看到命令式代码到函数式的完全重构。余额计算涉及处理公共账本中的所有区块，并统计所有涉及特定用户的交易。如果用户作为收款人出现，我们增加资金；否则，我们减少资金。
- en: 'To give you a frame for comparison, the imperative version of our second problem
    looks something like the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个比较框架，我们第二个问题的命令式版本看起来可能如下所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You’ll learn how to transition this version into a more functional style, like
    so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何将这个版本过渡到更函数式的风格，如下所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You’re probably wondering whether these two programs are the same: the first
    version has loops and conditionals, and the second one doesn’t. Shockingly, the
    programs are the same. You probably recognize some of the constructs in this code
    block, such as `map` and `filter`, but how this code works may not be clear, especially
    because the control and data flow is in the opposite direction of its imperative
    counterpart. The rounding instruction appears at the top rather than at the end,
    for example.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这两个程序是否相同：第一个版本有循环和条件语句，而第二个版本没有。令人震惊的是，这两个程序是相同的。你可能认识这个代码块中的一些结构，比如`map`和`filter`，但这个代码是如何工作的可能并不清楚，尤其是因为控制和数据流与命令式对应物相反。例如，舍入指令出现在顶部而不是底部。
- en: Looking at the FP style again, you may also wonder where the tallying of the
    total is taking place. Compare figures 4.1 and 4.2 to see the different control
    and data flows of the imperative and functional approaches.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 再次审视FP风格，你可能也会想知道总计数在哪里进行。比较图4.1和图4.2，以查看命令式和函数式方法的不同控制和数据流。
- en: '![](../Images/4-1.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-1.png)'
- en: Listing 4.1 Imperative flow of control for the logic in calculating a user’s
    total balance in a blockchain
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 计算区块链中用户总余额的逻辑的命令式控制流程
- en: The imperative approach (figure 4.1) describes not only the changes in state,
    but also how this change is produced as data flowing through all the control structures
    (loops, conditionals, variable assignment, and so on). The functional approach
    (figure 4.2), on the other hand, models a unidirectional flow of state transformations
    that hides the intricate control details; it shows you the steps needed to obtain
    the final result without all the unnecessary cruft. Also, each step is immutable,
    as mentioned earlier, which allows you to laser-focus on any of them without having
    to worry about the rest (figure 4.2).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式方法（图4.1）不仅描述了状态的变化，还描述了这种变化是如何通过所有控制结构（循环、条件、变量赋值等）中的数据流产生的。另一方面，函数式方法（图4.2）模型了一个单向状态转换流，隐藏了复杂的控制细节；它展示了获取最终结果所需的步骤，而不需要所有不必要的冗余。此外，正如之前提到的，每个步骤都是不可变的，这允许你集中精力在任何一步上，而不必担心其他部分（图4.2）。
- en: '![](../Images/4-2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-2.png)'
- en: Listing 4.2 Functional flow of control for the logic in calculating a user’s
    total balance in a blockchain
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 计算区块链中用户总余额的逻辑的函数式控制流程
- en: Figure 4.2 is modeling a declarative flow. Think of this figure as being like
    summarizing the highlights of the imperative version in the form of a recipe.
    Declarative code is written to match how it will be read. Write code for your
    users and colleagues, not for the machine, that’s what compilers are for.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 模拟了声明式流程。将这个图想象成以食谱的形式总结命令式版本的要点。声明式代码是按照其将被读取的方式来编写的。为你的用户和同事编写代码，而不是为机器编写，这就是编译器的用途。
- en: A good example of a declarative language is SQL. In SQL, the beauty of declarative
    programming is that it focuses on what you’re trying to accomplish rather than
    how, so mundane details such as code splitting, looping, and state management
    are tucked inside their respective steps. The hardest part about embracing FP
    is letting go of your old ways and your imperative bias. After you cross this
    line, you start to see how the structure, readability, and maintainability of
    your code improve, especially in JavaScript, which gives you the freedom to mutate
    data in many ways. We’re fortunate that JavaScript allows us to write code this
    way, and we should take advantage of it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式语言的一个好例子是 SQL。在 SQL 中，声明式编程的美丽之处在于它关注你试图完成的事情，而不是如何完成，因此诸如代码拆分、循环和状态管理等平凡细节都被隐藏在各自的步骤中。拥抱函数式编程最困难的部分是放弃你的旧方法和命令式偏见。一旦你越过这条线，你就会开始看到你的代码的结构、可读性和可维护性如何提高，尤其是在
    JavaScript 中，它给你以多种方式修改数据的自由。我们很幸运，JavaScript 允许我们以这种方式编写代码，我们应该充分利用这一点。
- en: To embrace the FP mindset, you must understand function composition, discussed
    in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要拥抱函数式编程心态，你必须理解下一节中讨论的函数组合。
- en: '4.3 Composition: The functional way'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 组合：函数式方法
- en: Generally speaking, composition occurs when data combines to make like-data
    or data of the same type; it preserves type. Objects fuse into new objects (like
    the mixins from chapter 3), and functions combine to create new functions (like
    the functions in this chapter). When mixins create new objects, this process is
    known as coarse-grained, structural composition. This section teaches you how
    to assemble code at the function level, known as fine-grained or low-level composition.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，组合发生在数据结合形成类似数据或同一类型的数据时；它保留了类型。对象融合成新的对象（就像第 3 章中的混入），函数组合成新的函数（就像本章中的函数）。当混入创建新对象时，这个过程被称为粗粒度、结构化组合。本节将教你如何在函数级别组装代码，称为细粒度或低级别组合。
- en: Function composition is the backbone of functional programming, and it’s the
    guiding principle by which you arrange and assemble your entire code. Although
    JavaScript doesn’t enforce any restrictions, composition is most effective when
    your functions play by the rules of purity mentioned in section 4.1.2.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是函数式编程的骨架，它是你安排和组装整个代码的指导原则。尽管 JavaScript 不强制执行任何限制，但组合在函数遵循第 4.1.2 节中提到的纯度规则时最为有效。
- en: In this section, we’ll implement the business logic of the `HasHash` mixin.
    First, you’ll learn how to convert the imperative `calculateHash` method we started
    in chapter 2 to use a more functional style. We’ll use this method to fill in
    the skeleton implementation we started in chapter 3\. Second, you’ll learn how
    composition can help you work around code that has side effects. This capability
    is important because most of the time, you will need to mix pure code with effectful
    code in your daily activities.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现 `HasHash` 混入的业务逻辑。首先，你将学习如何将我们在第 2 章开始使用的命令式 `calculateHash` 方法转换为更函数式的方式。我们将使用这个方法来填充我们在第
    3 章开始构建的框架实现。其次，你将学习组合如何帮助你绕过具有副作用代码。这种能力很重要，因为在日常活动中，你通常需要将纯代码与有副作用的代码混合。
- en: The best way to understand how functions compose is to start small, with only
    two functions, because then that same logic can be extended to an arbitrary number
    of them. So given the functions `f` and `g`, you can order them in a such a way
    that the output of the first becomes the input of the second, like binary plumbing,
    as shown in figure 4.3.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 理解函数组合的最佳方式是从简单开始，只使用两个函数，因为这样同样的逻辑可以扩展到任意数量的函数。所以，给定函数 `f` 和 `g`，你可以以某种方式对它们进行排序，使得第一个函数的输出成为第二个函数的输入，就像二进制管道一样，如图
    4.3 所示。
- en: '![](../Images/4-3.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3](../Images/4-3.png)'
- en: Listing 4.3 High-level diagram of composition. The directions of the arrows
    are important. Composition works right to left. So in `f` composed with `g`, `g`
    receives the initial input arguments. Then `g`’s output is input to `f`. Finally,
    `f`’s result becomes the output of the entire operation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 组合的高级图。箭头的方向很重要。组合是从右到左工作的。所以，在 `f` 与 `g` 组合时，`g` 接收初始输入参数。然后 `g` 的输出作为
    `f` 的输入。最后，`f` 的结果成为整个操作的结果。
- en: In code, composition can be represented concisely by `f(g(args))`. Because JavaScript
    executes eagerly, it will try to evaluate any variable with a set of parentheses
    in front of it immediately. If you want to express the composition of two functions
    and assign it to a variable name, you can wrap a function around that expression.
    Let’s call this expression `compose` (see the next listing).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，组合可以通过 `f(g(args))` 简洁地表示。由于 JavaScript 会立即求值，它会尝试立即评估任何带有括号的前置变量的任何变量。如果你想表达两个函数的组合并将其赋给一个变量名，你可以将一个函数包裹在这个表达式周围。让我们称这个表达式为
    `compose`（见下一条列表）。
- en: Listing 4.3 Composition of two functions
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 两个函数的组合
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Using JavaScript’s spread operator to support an arbitrary number of arguments
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 JavaScript 的扩展运算符来支持任意数量的参数
- en: Listing 4.3 assumes, however, that `f` and `g` are functions that exist outside
    the context of `compose`. We know that this situation is a side effect. Instead,
    make `f` and `g` input arguments, and use the closure around the inner function
    so that this code works with any two functions that you provide. Closures are
    important features that work amazingly well with higher-order functions; I’ll
    review them in section 4.4.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，列表 4.3 假设 `f` 和 `g` 是存在于 `compose` 上下文之外的函数。我们知道这种情况是一个副作用。相反，将 `f` 和 `g`
    作为输入参数，并使用内函数的闭包，这样这段代码就可以与任何你提供的两个函数一起工作。闭包是与高阶函数一起工作得非常好的重要特性；我将在第 4.4 节中回顾它们。
- en: 'Let’s wrap this expression yet again with another function around `compose`
    and call it `compose2`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次用另一个函数包裹这个表达式，并在 `compose` 旁边调用它 `compose2`：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code is a lot more flexible. Because `compose2` accepts functions as arguments
    and returns a function, it’s of higher-order, of course. Also, notice that `compose2`
    evaluates the functions right to left (`f` after `g`) to align with the mathematical
    definition of function composition. Here’s a more-concrete example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更加灵活。因为 `compose2` 接受函数作为参数并返回一个函数，所以它是一个高阶函数。此外，请注意 `compose2` 从右到左（`f`
    在 `g` 之后）评估函数，以符合函数组合的数学定义。这里有一个更具体的例子：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You could combine these functions directly:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接组合这些函数：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you use `compose2`, the same expression becomes
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `compose2` 时，相同的表达式变为
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s a little pro tip. Because you can assign functions directly to a variable,
    any time you have the input argument repeated to the left and the right of an
    expression, you can cancel it and make your code more compact:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个小技巧。因为你可以直接将函数赋给变量，所以每次你在表达式的左右两边重复输入参数时，你可以取消它，使你的代码更加紧凑：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Figure 4.4 shows the flow from figure 4.3.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 展示了从图 4.3 的流程。
- en: '![](../Images/4-4.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-4.png)'
- en: Listing 4.4 Sequentially executed count after split
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 分割后的顺序执行计数
- en: '`compose2` is superior to a direct call because it’s able to separate the declaration
    of functions involved in the sequence from its evaluation. The concept is similar
    to OLOO, which allows you to instantiate a ready-to-use set of objects and initialize
    those objects when you need to. By capturing the functions passed in as variables
    (`f` and `g`), we can defer any execution until the caller supplies the input
    parameter. This process is called lazy evaluation. In other words, the expression'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose2` 比直接调用更优越，因为它能够将序列中涉及的函数的声明与其评估分离。这个概念类似于 OLOO，它允许你实例化一个可用的对象集并在需要时初始化这些对象。通过捕获传入的函数（`f`
    和 `g`）作为变量，我们可以将任何执行延迟到调用者提供输入参数时。这个过程被称为惰性求值。换句话说，表达式'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: is itself a function made from two other functions (like an object made from
    two mixins). Yet this function will not run until the caller evaluates it; it
    sits there dormant. `compose2` allows you to create a complex, ready-to-use expression
    from a couple of simple ones and assign it a name (`countWords`) to use in other
    parts of the code, if needed. Let’s embellish this example a bit more in the next
    section; we’ll tackle something a bit more realistic that works in a side effect
    in the mix.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本身是由两个其他函数（就像由两个混合器组成的对象）组成的函数。然而，这个函数不会在调用者评估它之前运行；它在那里处于休眠状态。`compose2` 允许你从几个简单的函数中创建一个复杂、可用的表达式，并在需要时给它一个名字（`countWords`）以在其他代码部分中使用。让我们在下一节中更详细地说明这个例子；我们将处理一个稍微更现实的问题，它涉及到副作用。
- en: 4.3.1 Working with side effects
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 与副作用一起工作
- en: Exception handling, logging to a file, and making HTTP requests are some of
    the tasks we work on every day. All these tasks involve side effects in one way
    or another, and there’s no avoiding them. The way to deal with side effects in
    a functional-style application is to isolate and push them away from our main
    application logic. This way, we can keep the important business logic of our application
    pure and immutable, and then use composition to bring all the pieces back together.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理、记录到文件以及发起 HTTP 请求是我们每天都要处理的任务之一。所有这些任务都以某种方式涉及副作用，而且无法避免。在函数式风格的应用程序中处理副作用的方法是将它们隔离并从我们的主要应用程序逻辑中推离。这样，我们可以保持应用程序的重要业务逻辑纯净且不可变，然后使用组合将所有部分重新组合在一起。
- en: 'To see how you can split pure from non-pure code, let’s tackle another task:
    counting the words in a text file. Assume that the file contains the words “the
    quick brown fox jumps over the lazy dog.” For simplicity, let’s use the synchronous
    version of the filesystem API built into Node.js, as shown in the next listing.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何将纯代码与非纯代码分开，让我们处理另一个任务：计算文本文件中的单词数。假设文件包含单词“the quick brown fox jumps over
    the lazy dog。”为了简单起见，让我们使用 Node.js 内置的同步版本文件系统 API，如下一列表所示。
- en: Listing 4.4 Imperative function that counts the words in a text file
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 计算文本文件中单词数的命令式函数
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 4.4 is trivial but packs in a few steps. As in `calculateHash`, you
    can identify four clear tasks: reading the raw file, decoding the raw binary as
    a string, splitting the string into words, and counting the words. Arranging these
    tasks with `compose` should look like figure 4.5.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 简单但包含了几个步骤。正如在 `calculateHash` 中，你可以识别出四个清晰的任务：读取原始文件，将原始二进制解码为字符串，将字符串拆分为单词，以及计数单词。使用
    `compose` 安排这些任务应该看起来像图 4.5。
- en: '![](../Images/4-5.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5](../Images/4-5.png)'
- en: Listing 4.5 The logic of `countWordsInFile` derives from the logic of composing
    other single-responsibility functions such as `read`, `decode`, `split`, and `count`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 `countWordsInFile` 的逻辑源自其他单一职责函数（如 `read`、`decode`、`split` 和 `count`）的组合逻辑。
- en: First, represent each task as its own expression. You saw `count` and `split`
    earlier; the next listing shows the other two tasks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将每个任务表示为其自己的表达式。你之前看到了 `count` 和 `split`；下一列表显示了其他两个任务。
- en: Listing 4.5 Helper functions to support `countWordsInFile`
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 支持使用 `countWordsInFile` 的辅助函数
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Creating an alias to shorten the filesystem API call
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建别名以缩短文件系统 API 调用
- en: In listing 4.5, we gave each variable a specific name to make the program easy
    to follow. In imperative code, variable names are used to describe the output,
    if any, of executing a statement or series of statements, but these variable names
    don’t describe the process of computing them. You have to parse through the code
    to see that process. When you push for a more declarative style, the function
    names indicate what to do at each step. Let’s work our way there. A direct call
    would look like
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 4.5 中，我们给每个变量指定了一个特定的名字，使程序易于理解。在命令式代码中，变量名用于描述执行一个或一系列语句的输出（如果有），但这些变量名并不描述计算它们的过程。你必须解析代码以了解这个过程。当你推动更声明式风格时，函数名表明了每个步骤要做什么。让我们一步步实现这一点。直接调用可能看起来像这样：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can see that all variable assignment was removed. But we can agree that
    this style of code can become unwieldy as complexity grows. Let’s use `compose2`
    to fix this problem:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到所有变量赋值都被移除了。但我们可以同意，随着复杂性的增加，这种代码风格可能会变得难以控制。让我们使用 `compose2` 来解决这个问题：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each `compose2` segment can be represented by its own micro module, as shown
    in figure 4.6.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `compose2` 段可以表示为其自己的微模块，如图 4.6 所示。
- en: '![](../Images/4-6.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6](../Images/4-6.png)'
- en: Listing 4.6 Diagram `countWordsInFile` improved with `compose2`
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 使用 `compose2` 改进的 `countWordsInFile` 图
- en: 'But wait a minute—we already have a named abstraction that handles `compose2(count``,`
    `split``)`. That abstraction is called `countWords`. Let’s plug it in:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等——我们已经有了一个名为的抽象，可以处理 `compose2(count`,`split`)`。这个抽象叫做 `countWords`。让我们将其插入：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The reason why you can swap portions of the code in and out like Lego bricks
    is referential transparency. In other words, the expression is pure and doesn’t
    rely on any global, shared state. The outcome of either expression would be the
    same and, therefore, does not alter the result of the program. Plugging in this
    abstraction is better, but we can do even better.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你之所以可以像乐高积木一样交换代码片段，是因为引用透明性。换句话说，表达式是纯的，不依赖于任何全局或共享状态。两个表达式的结果将是相同的，因此不会改变程序的结果。插入这个抽象是更好的，但我们还可以做得更好。
- en: For more complex logic, you’re probably thinking that grouping functions in
    pairs is a lot of typing. To simplify the code, it would be ideal to have a version
    of `compose2` that can work on any number of functions or an array of functions.
    Let’s repurpose `compose` and use `Array#reduce` with `compose2` to extend combining
    two functions to any number of functions. This technique is analogous to putting
    together clusters of Lego bricks at a time instead of assembling individual bricks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的逻辑，你可能认为将函数成对分组需要输入很多。为了简化代码，最好有一个可以处理任意数量函数或函数数组的 `compose2` 版本。让我们重新利用
    `compose` 并使用 `Array#reduce` 与 `compose2` 结合，将两个函数的组合扩展到任意数量的函数。这种技术与一次组装一簇乐高积木而不是单个积木相似。
- en: 'In `Array#reduce`, the reducer is the callback function that accumulates or
    folds your data into a single value. If you’re not familiar with how `reduce`
    works, here’s a simple example. Consider a function, `sum`, as a reducer for adding
    a list of numbers:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Array#reduce` 中，reducer 是一个回调函数，它将你的数据累积或折叠成一个单一值。如果你不熟悉 `reduce` 的工作原理，这里有一个简单的例子。考虑一个函数
    `sum`，它作为添加数字列表的reducer：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The reducer takes the current accumulated result in `a` and adds it to the next
    element, `b`, starting with the first element in the array.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer 会将当前累积的结果 `a` 与下一个元素 `b` 相加，从数组的第一个元素开始。
- en: 'By the same token, `compose2` is the reducer for `compose`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`compose2` 是 `compose` 的reducer：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, the reducer takes two functions at a time and composes them (adds
    them), creating another function. That function is remembered for the next iteration
    and then composed with the next one and so on, resulting in a function that is
    the composition of all functions provided by the user. Function composition works
    right to left, with the rightmost function receiving the input parameter at the
    call site and kicking off the entire process. In that order, `reduce` folds all
    the functions in the array with the first function in the declaration as the last
    one to be executed, which matches nicely with the definition of function composition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，reducer 一次取两个函数并将它们组合（相加），创建另一个函数。这个函数会被记住，然后在下一次迭代中与下一个函数组合，依此类推，最终得到一个由用户提供的所有函数组成的组合函数。函数组合是从右到左工作的，最右边的函数接收调用点的输入参数并启动整个过程。按照这个顺序，`reduce`
    将数组中的所有函数折叠到声明中的第一个函数，这与函数组合的定义非常吻合。
- en: Now let’s use this technique in the next listing to peel those nested calls
    shown in the preceding code snippets into a much more streamlined, unidirectional
    flow.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一个列表中使用这项技术，将前面代码片段中显示的嵌套调用剥离开，形成一个更加精简、单向的流程。
- en: Listing 4.6 `countWordsInFile` implemented with `compose`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 使用 `compose` 实现的 `countWordsInFile`
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code looks like pseudocode at first, doesn’t it? If you compare listings
    4.4 and 4.6, you can see that the latter is a basic outline of the former; it’s
    declarative! This style of coding is also known as point-free, which we’ll discuss
    in section 4.6.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码一开始看起来像伪代码，不是吗？如果你比较列表 4.4 和 4.6，你会发现后者是前者的一种基本框架；它是声明式的！这种编码风格也被称为无点式，我们将在第
    4.6 节中讨论。
- en: The level of modularity used (fine-grained function level or coarse-grained
    modules with multiple functions) is up to you; you can compose to your heart’s
    content (figure 4.7).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的模块化程度（细粒度函数级别或粗粒度模块，包含多个函数）取决于你；你可以随心所欲地进行组合（见图 4.7）。
- en: '![](../Images/4-7.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4-7](../Images/4-7.png)'
- en: Listing 4.7 The structure of composable software. A program is implemented by
    composing other subprograms, which can be as small as a function or as big as
    another program. Each module (consider Module N) uses composition, finally arriving
    at assembling individual functions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 可组合软件的结构。一个程序通过组合其他子程序来实现，这些子程序可以是函数那么小，也可以是另一个程序那么大。每个模块（考虑模块 N）都使用组合，最终到达组装单个函数的阶段。
- en: Whether you’re composing simple functions or entire modules of code with a function
    interface, the simplicity of assembling composable code doesn’t change. (We’ll
    talk about importing and using modules in chapter 6.)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是组合简单的函数还是具有函数接口的整个代码模块，组装可组合代码的简单性都不会改变。（我们将在第 6 章中讨论导入和使用模块。）
- en: Now that you understand the composition pattern, let’s use it to decompose and
    simplify the hashing logic of our blockchain application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了组合模式，让我们用它来分解并简化我们的区块链应用的哈希逻辑。
- en: 4.3.2 Decomposing complex code
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 复杂代码的分解
- en: 'In chapters 2 and 3, we began creating a hashing method for our transaction
    classes called `calculateHash`. This hashing algorithm, or the digest string that
    it generated, was insecure and prone to collisions. In the cryptocurrency world,
    this situation is a no-go, so let’s improve it. You’ll see how a more functional
    design will enable you to easily swap the insecure algorithm for a more secure
    one that uses Node.js’s crypto module. Here’s the last version of that code again
    for reference:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章和第 3 章中，我们开始为我们的交易类创建一个名为 `calculateHash` 的哈希方法。这个哈希算法，或者它生成的摘要字符串，是不安全的并且容易发生冲突。在加密货币世界中，这种情况是不可接受的，所以让我们改进它。你会看到更函数式的设计如何使你能够轻松地用更安全的算法（使用
    Node.js 的 crypto 模块）替换不安全的算法。以下是该代码的最后一个版本，供参考：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using the four rules outlined earlier in section 4.1.2, is this function/method
    pure? Before answering this question, let’s practice a little reverse engineering.
    First, let’s decompose the function into its main parts; then we’ll analyze each
    piece individually. When we split the function apart, we’ll compose it back together
    by using a more functional approach. With lots of practice, you’ll get better
    at this process, which will become second nature.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第 4.1.2 节中概述的四个规则，这个函数/方法是否是纯的？在回答这个问题之前，让我们先进行一点逆向工程。首先，让我们将函数分解为其主要部分；然后我们将逐个分析每个部分。当我们将函数拆分时，我们将通过使用更函数式的方法将其重新组合。经过大量的练习，你会在这个过程中变得更熟练，这将成为你的第二天性。
- en: '`calculateHash` performs two main tasks, split into two methods:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateHash` 执行两个主要任务，分为两个方法：'
- en: 'Assembling the data from the set of keys:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从键集合中组装数据：
- en: '[PRE27]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Computing the digest or cipher from this data:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这些数据中计算摘要或密文：
- en: '[PRE28]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This thought process itself is beneficial because smaller functions are much
    simpler to reason about than larger ones, and you can carry this thought process
    as deep as you deem reasonable. Now to answer the question at hand: Are these
    two methods pure? Believe it or not, `computeCipher` is pure from a practical
    standpoint, whereas `assemble` is not. The reason is that `assemble` makes assumptions
    about its context when it attempts to read properties from `this`—a potential
    downside of mixins that we highlighted in chapter 3\. With a standalone function
    declaration, `this` is bound to the function, not the surrounding object. To fix
    this problem, we can use JavaScript’s dynamic binding:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种思维过程本身是有益的，因为较小的函数比较大的函数更容易推理，你可以将这种思维过程深入到你认为合理的程度。现在来回答手头的问题：这两个方法是否是纯的？信不信由你，`computeCipher`
    从实用角度来看是纯的，而 `assemble` 则不是。原因是 `assemble` 在尝试从 `this` 中读取属性时对其上下文做出了假设——这是我们在第
    3 章中强调的混入的潜在缺点。使用独立的函数声明时，`this` 与函数绑定，而不是与周围的对象绑定。为了解决这个问题，我们可以使用 JavaScript
    的动态绑定：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The call to `bind` will correct the `this` reference and point it to the surrounding
    object whose properties we want to read. This code is looking better, but relying
    on this type of binding can make it hard to follow. Also remember that making
    assumptions about the environment is a side effect, which we still have in `calculateHash`.
    To put it another way, a function that infers state is harder to work with because
    its own behavior is dependent on external factors. For that reason, you’ll never
    see references to external variables, including `this,` used in a pure FP code
    base. On the other hand, functions that are explicit about the data they need
    are self-documenting and, thus, simpler to use and maintain.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`的调用将修正`this`引用，使其指向我们想要读取属性的外围对象。这段代码看起来更好，但依赖于这种类型的绑定可能会使其难以理解。此外，请记住，对环境的假设是一个副作用，我们在`calculateHash`中仍然有这个副作用。换句话说，推断状态的函数更难处理，因为其自身的行为依赖于外部因素。因此，您永远不会在纯FP代码库中看到对外部变量的引用，包括`this`。另一方面，明确其所需数据的函数是自文档化的，因此更易于使用和维护。'
- en: 'Let’s change `assemble` to a function that is explicit about its contract and
    accepts the set of keys for the properties used in the hashing process, as well
    as the object to hash:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`assemble`改为一个明确其合同的功能，它接受用于散列过程的键集合以及要散列的对象：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By not making any assumptions, this generic, standalone function is completely
    divorced from its surrounding class or object context. The fine line in the sand
    where OO departs to FP in a hybrid model is where we disassociate or extract the
    code under a class’s methods and move it into one or more pure functions. This
    separation or segregation from the mutable, stateful components to immutable ones
    will help you avoid making assumptions about your data and use FP where it makes
    sense.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不做出任何假设，这个通用的独立函数完全脱离了其周围的类或对象上下文。在混合模型中，面向对象（OO）与函数式编程（FP）之间的微妙界限是我们将类的方法下的代码解耦或提取出来，并将其移动到一个或多个纯函数中。这种从可变、有状态组件到不可变组件的分离或隔离将帮助您避免对数据做出假设，并在合适的地方使用FP。
- en: Let’s come back to `computeCipher`, the heart of the hashing process. Earlier,
    I mentioned that in by-the-book functional programming, mutations are prohibited.
    In practice, though, we accept making code easier to implement as long as state
    changes don’t ripple out or leak from the function’s scope. In this case, all
    the mutations are kept locally, so the code is acceptable as is.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`computeCipher`，这是散列过程的核心。之前我提到，在按部就班的函数式编程中，是不允许有变化的。然而，在实践中，只要状态变化不会从函数的作用域中扩散或泄露，我们会接受使代码更容易实现的方案。在这种情况下，所有的变化都保持在本地，因此代码是可以接受的。
- en: Nevertheless, `computeCipher` doesn’t capture the true functional spirit; it
    still feels a bit procedural. By inspecting `computeCipher` as its own microenvironment,
    you can see that its logic still depends on setting and changing variables like
    the loop counter `i` and the accumulated `hash`. You have room for improvement.
    Working with lists and arrays is simple with APIs such as `map` and `reduce`,
    but when you need to keep track of and reuse state in an iterative manner, recursion
    is the best way to achieve your goal. The next listing shows how you can refactor
    the `while` loop as a recursive function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`computeCipher`并没有真正体现函数式精神；它仍然有点像过程式编程。通过将`computeCipher`视为其自身的微观环境，您可以看到其逻辑仍然依赖于设置和改变变量，如循环计数器`i`和累积的`hash`。您有改进的空间。使用`map`和`reduce`等API处理列表和数组很简单，但当你需要以迭代方式跟踪和重用状态时，递归是实现目标的最佳方式。接下来的列表显示了如何将`while`循环重构为递归函数。
- en: Listing 4.7 Refactoring `computeCipher` as a recursive function
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 将`computeCipher`重构为递归函数
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Calls itself recursively with the updated hash at each iteration as an input
    argument to avoid assigning and changing data in place
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每次迭代中递归调用自身，并将更新的hash作为输入参数，以避免在原地分配和更改数据
- en: 'This function brings us back to our four main FP rules, without any trade-offs,
    and here’s what we gained:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使我们回到了四个主要的FP规则，没有任何权衡，以下是我们的收获：
- en: We used JavaScript’s default argument syntax to capture the initial state properly.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了JavaScript的默认参数语法来正确地捕获初始状态。
- en: We eliminated all variable reassignment.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们消除了所有变量的重新赋值。
- en: We created expressions in which every branch produces a return value.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了每个分支都产生返回值的表达式。
- en: 'Now that we have these two smaller, simpler functions, we can compose them
    to compute the cipher of a transaction object:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这两个更小、更简单的函数，我们可以将它们组合起来计算交易对象的密文：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But wait a second—we have a problem. `compose2` expects a function but instead
    got a string when `assemble` ran, so this code fails to run. Let’s use lazy evaluation
    to make a small adjustment to `assemble`, turning it into a higher-order function
    that accepts the keys and returns a function that is ready to receive the object
    of the call, taking advantage of closures:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等——我们有一个问题。`compose2`期望一个函数，但`assemble`运行时却得到了一个字符串，所以这段代码无法运行。让我们使用延迟求值对`assemble`进行一些小的调整，将其转换为一个接受键并返回一个准备接收调用对象的函数的高阶函数，利用闭包：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This small adjustment is enough to get to our more functional approach:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小小的调整就足以让我们达到更函数式的方法：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In essence, what we did to `assemble` was convert a 2-arity (two-argument) function
    to two single-arity (single-argument) functions—the premise behind a technique
    called curried function evaluation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，我们对`assemble`所做的操作是将一个2-arity（两个参数）函数转换为两个单-arity（单个参数）函数——这是称为curried函数评估的技术背后的前提。
- en: 4.4 Currying and closures
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 Currying和闭包
- en: Currying is a technique that will help you compose functions when they require
    multiple arguments. It relies on JavaScript’s amazing support for closures. In
    this section, we’ll begin with a quick review of closures and then move on to
    curried function application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Currying是一种技术，当函数需要多个参数时，它可以帮助你组合函数。它依赖于JavaScript对闭包的惊人支持。在本节中，我们将从对闭包的快速回顾开始，然后转向curried函数应用。
- en: You are probably familiar with closures, which are central to how JavaScript
    works. In fact, they’re among the most compelling JavaScript features. To keep
    the discussion focused, I won’t cover closures in depth but will provide some
    detail in case you’re not familiar with them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉闭包，这是JavaScript工作方式的核心。实际上，它们是JavaScript最吸引人的特性之一。为了使讨论集中，我不会深入探讨闭包，但会提供一些细节，以防你对它们不熟悉。
- en: A closure is another form of scope or context created around functions that
    allows a function to reference surrounding variables. When a function is called,
    JavaScript retains references to variables of a function’s local and global lexical
    environment—that is, all variables syntactically declared around this function.
    In the specification, the internal reference [[Scope]] links a function to its
    closure. In other books and online resources, you may see the term backpack used
    to describe this linkage. The reason I say around and not before is because hoisted
    variables and functions are also part of a function’s closure. The following listing
    provides an example.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是围绕函数创建的另一种作用域或上下文形式，允许函数引用周围的变量。当函数被调用时，JavaScript保留对函数局部和全局词法环境变量的引用——即围绕此函数的所有语法上声明的变量。在规范中，内部引用[[Scope]]将一个函数与其闭包链接起来。在其他书籍和在线资源中，你可能看到使用术语“背包”来描述这种链接。我说“围绕”而不是“之前”，是因为提升的变量和函数也是函数闭包的一部分。以下列表提供了一个示例。
- en: Listing 4.8 Basics of scope with closures
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 使用闭包的作用域基础
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Prints inner outer global
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印内部外部全局
- en: ❷ Prints outer global
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印外部全局
- en: You can visualize this example in figure 4.8.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图4.8中可视化这个例子。
- en: '![](../Images/4-8.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-8.png)'
- en: Listing 4.8 The closure mechanism in JavaScript allows any function to reference
    its lexical environment. The innermost function has access to all the state from
    its outer scopes (outer + global), and the outer scope can access everything from
    its surrounding global scope.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 JavaScript中的闭包机制允许任何函数引用其词法环境。最内层的函数可以访问其外部作用域（外部+全局）中的所有状态，而外部作用域可以访问其周围全局作用域中的所有内容。
- en: JavaScript gives you complete freedom to access a sizeable subset of application
    state from which a function is declared, implying the global scope as well as
    any outer variables that lexically appear around a function. In essence, closures
    make all this state implicit function arguments. Although access to these variables
    is certainly convenient at times, it can also lead to code that is hard to maintain.
    Theoretically, FP considers accessing any state surrounding a function to be a
    side effect; after all, we’re reaching outside. In practice, however, using closures
    is permissible so long as they are bounded and narrow in scope and, more important,
    don’t incur any observable changes beyond the surrounded function. Using closures
    is the way to code with JavaScript, and we should take advantage of them. Closures
    enable some powerful patterns in JavaScript, currying being one of them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许你完全自由地访问从函数声明的应用状态的一部分，这意味着全局作用域以及任何在函数周围按词法出现的任何外部变量。本质上，闭包使所有这些状态都成为隐式函数参数。虽然有时访问这些变量确实很方便，但它也可能导致难以维护的代码。从理论上讲，函数式编程（FP）认为访问函数周围任何状态都是副作用；毕竟，我们是在外部访问。然而，在实践中，只要闭包是有限制的、作用域狭窄的，并且更重要的是，不会在包围的函数之外引起任何可观察的变化，使用闭包是允许的。使用闭包是编写JavaScript代码的方式，我们应该充分利用它们。闭包使JavaScript中的一些强大模式成为可能，柯里化就是其中之一。
- en: 4.4.1 Curried function application
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 柯里化函数应用
- en: A function that has its argument list expanded as stepwise, single, nested functions
    of single arguments is said to be curried. The next listing shows a simple example
    of manual currying.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将参数列表展开为逐步、单一、嵌套的单参数函数的函数被称为柯里化。下面的列表展示了手动柯里化的一个简单示例。
- en: Listing 4.9 Evaluating `add` as separate single-argument functions
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 将 `add` 作为单独的单参数函数进行评估
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Addition does not take place until the last variable is bound.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加法操作只有在最后一个变量被绑定时才会发生。
- en: ❷ Bind the expression, and the function executes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 绑定表达式，函数执行。
- en: 'Instead of `add` receiving `x` and `y` arguments in one shot, the code accepts
    them as singular functions that get called sequentially. More formally, currying
    is the process of converting a function of multiple arguments (or arity N) to
    be evaluated it as N unary (arity 1) functions. Until the entire list of arguments
    has been provided and all functions evaluated, a curried function always returns
    the next function. If you take a small step back, you can see that currying is
    another form of composition: you’re taking a complex function and evaluating it
    as multiple simple ones. Because `add` takes two arguments, `x` and `y`, it’s
    evaluated as two single-argument functions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `add` 一次性接收 `x` 和 `y` 参数不同，代码接受它们作为单独的函数，这些函数按顺序被调用。更正式地说，柯里化是将多参数函数（或N元函数）转换为评估为N个一元（元数1）函数的过程。直到提供了整个参数列表并且所有函数都已评估，柯里化函数始终返回下一个函数。如果你退一步想，你可以看到柯里化是组合的另一种形式：你正在将一个复杂函数评估为多个简单函数。因为
    `add` 接受两个参数 `x` 和 `y`，所以它被评估为两个单参数函数：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Going back to our word-counting example, let’s use this manual currying technique
    to buy more flexibility in decoding the binary buffer as a result of the file
    IO. As `decode` stands right now, the `toString` method on buffers assumes a UTF-8
    encoding:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的单词计数示例，让我们使用这种手动柯里化技术来在解码文件I/O的结果二进制缓冲区时获得更多的灵活性。正如 `decode` 现在所做的那样，缓冲区的
    `toString` 方法假设UTF-8编码：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Most of the time, this method is what you’ll want to use. But it’d be nice
    to have flexibility in case we ever need ASCII encoding as well. Instead of refactoring
    `decode` to accept another argument, let’s embed another function in between to
    capture the encoding parameter (with its own default argument):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，这个方法是你想要的。但如果我们需要ASCII编码，灵活性会更好。与其重构 `decode` 以接受另一个参数，不如在中间嵌入另一个函数来捕获编码参数（带有自己的默认参数）：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can call `decode` once to partially curry/set the encoding parameter
    and plug the resulting (remaining) function into the compose expression as such:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以调用一次 `decode` 来部分柯里化/设置编码参数，并将结果（剩余）函数作为如下组合表达式插入：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The declarative quality of this code is enhanced even further because you can
    see not only the steps that make up your solution, but also the attributes or
    the configuration of these functions in each step.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的声明式质量得到了进一步的提升，因为你不仅可以看到构成解决方案的步骤，还可以看到每个步骤中这些函数的属性或配置。
- en: 'Let’s continue working our way toward calculating secure object hashes in a
    functional way. Consider a helper function called `prop`, again manually curried:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以函数式的方式计算安全对象哈希的工作。考虑一个名为`prop`的辅助函数，再次手动curry：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: With the helper `isFunction`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用辅助函数`isFunction`
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`prop` can access a property from any object by name. You can partially bind
    the `name` parameter to create a function with the `name` in its closure and then
    accept the object from which to extract the named property. Consider this simple
    example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`prop`可以通过名称从任何对象中访问属性。你可以部分绑定`name`参数，创建一个具有`name`在其闭包中的函数，然后接受从中提取命名属性的对象。考虑这个简单的例子：'
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also create a function that extracts multiple properties into an array
    by mapping `prop` over an array of keys:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个函数，通过映射`prop`到一个键的数组上，将多个属性提取到一个数组中：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Calling `prop` on a single object is not as exciting as calling it on a collection
    of objects. Given an array of three transaction objects with funds, 10.0, 12.5,
    and 20.0, respectively, you can map `prop` over it:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个对象上调用`prop`并不像在对象集合上调用它那样令人兴奋。给定一个包含三个交易对象（分别有资金10.0、12.5和20.0）的数组，你可以将`prop`映射到它上面：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this code, the higher-order function `prop('funds``')` did not produce a
    result until `map` used it, which is convenient. But when functions get more complex,
    the awkward notation used to write functions with expanded arrow syntax becomes
    hard to read, not to mention that multifunction evaluation—`add(x)(y)`--is cumbersome.
    You can automate the process of manually expanding into multiple functions with
    the `curry` function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，高阶函数`prop('funds')`直到`map`使用它才产生结果，这是很方便的。但当函数变得更加复杂时，使用扩展箭头语法编写的函数的尴尬记法变得难以阅读，更不用说多函数评估——`add(x)(y)`——是繁琐的。你可以使用`curry`函数自动化将手动展开成多个函数的过程。
- en: '`curry` automates the manual currying process that we’ve been doing so far,
    converting a function of multiple arguments to several nested functions of a single
    argument. Thus, a function like `add`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`curry`自动化了我们迄今为止所进行的手动curry过程，将多个参数的函数转换为多个单参数嵌套函数。因此，像`add`这样的函数'
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: can be written as
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 可以写成
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The wonderful quality of `curry` is that it dynamically changes the way the
    function evaluates and smooths over the syntax needed to partially pass arguments.
    You can call `add` piece-wise as `add(3)(7)` or, preferably, at the same time
    as `add(3,7)`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`curry`的奇妙之处在于它动态地改变了函数的评估方式，并平滑了部分传递参数所需的语法。你可以分步骤地调用`add`，如`add(3)(7)`，或者更理想的是同时调用`add(3,7)`。'
- en: NOTE In theory, currying is a much stricter form of partial application that
    requires that returned functions take a single parameter at a time. In partial
    application, a returned function can take one or several arguments.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在理论上，currying是一种更严格的偏应用形式，它要求返回的函数每次只接受一个参数。在偏应用中，返回的函数可以接受一个或多个参数。
- en: As with `compose`, you can import `curry` from any FP library (Ramda, underscore.js,
    and so on), but studying the implementation is interesting; it uses a lot of modern
    JavaScript idioms (such as rest and spread operators) to manipulate function objects.
    It also uses a bit of reflection to dynamically figure out the function’s length
    (a topic that I’ll circle back to in chapter 7).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与`compose`一样，你可以从任何FP库（如Ramda、underscore.js等）导入`curry`，但研究其实现很有趣；它使用了大量的现代JavaScript惯用语法（如rest和spread操作符）来操作函数对象。它还使用了一点点反射来动态确定函数的长度（这个话题我将在第7章中再次提及）。
- en: 'In keeping with the pure FP spirit of avoiding loops and reassignment of variables,
    you can implement `curry` as a recursive, arrow function quite elegantly. You
    may also find versions that take a more imperative, iterative approach:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持纯FP精神，避免循环和变量的重新赋值，你可以非常优雅地将`curry`实现为一个递归的箭头函数。你也可能找到采用更命令式、迭代方法的版本：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The following listing shows how to use `curry` to enhance `prop` and `props`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何使用`curry`来增强`prop`和`props`。
- en: Listing 4.10 Curried versions of `prop` and `props`
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10 `prop`和`props`的curry版本
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Internally, curry adds runtime support to rewrite the (name, a) pair into
    partially evaluated arguments name => a => ...
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 内部，curry添加了运行时支持，将(name, a)对重写为部分评估的参数name => a => ...
- en: ❷ We no longer use the varargs ...name argument, as this is allowed only as
    the last (or only) argument.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们不再使用varargs ...name参数，因为这只能作为最后一个（或唯一的）参数。
- en: Not everything can be curried, unfortunately
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有内容都可以curry化
- en: As wonderful and powerful as `curry` is, in JavaScript there are a few edge
    cases where `curry` can change the expected behavior of a function when it relies
    on features such as variadic parameters or parameters with default values.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`curry`非常神奇且强大，但在JavaScript中，当它依赖于诸如可变参数或具有默认值的参数等特性时，`curry`可能会改变函数预期的行为，存在一些边缘情况。
- en: In listing 4.11, to make `props` work with `curry`, we needed to change ...`names`
    to a normal, nonvariadic parameter, `names`, that is allowed to appear as a first
    argument. Variadic parameters always need to appear at the end of the function
    signature.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.11中，为了让`props`与`curry`一起工作，我们需要将...`names`改为一个普通的、非可变参数`names`，它允许作为第一个参数出现。可变参数始终需要出现在函数签名末尾。
- en: 'Another, more subtle issue to watch out for is default parameters. Looking
    at the implementation of `curry` in this section, you can see that it relies on
    `Function.length`. This property is a bit tricky in JavaScript because it does
    not count functions with default values, as this snippet of code illustrates:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的更微妙的问题是默认参数。查看本节中`curry`的实现，你可以看到它依赖于`Function.length`。在JavaScript中，这个属性有点棘手，因为它不会计算具有默认值的函数，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To reiterate, `curry` mandates that you satisfy all the arguments of a function
    before it evaluates. Until that happens, `curry` keeps returning the partially
    applied functions with the remaining arguments waiting to be passed in. This situation
    also prevents running functions with unsatisfied or `undefined` arguments. As
    I said earlier, `add(3)` returns a function to the caller, but `add(3,7)` evaluates
    to `10` immediately. There’s no way to call a function with an unsatisfied set
    of arguments, which is great!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`curry`要求你在评估之前满足函数的所有参数。直到那时，`curry`会继续返回带有剩余待传递参数的部分应用函数。这种情况也防止了运行具有未满足或`undefined`参数的函数。正如我之前所说的，`add(3)`返回一个函数给调用者，但`add(3,7)`会立即评估为`10`。无法调用具有未满足参数集的函数，这真是太好了！
- en: 'With curried functions, the order of arguments is important. Normally, we don’t
    pay a lot of attention to order in object-oriented code. But in FP, argument order
    is crucial because it relies so much on partial application. In all the curried
    functions shown in this chapter, notice that the arguments are arranged to benefit
    from partial evaluation. For that reason, it’s best to place the most static,
    fixed arguments first and allow the last ones to be the more dynamic call-specific
    arguments, as in the definition for `prop`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在curried函数中，参数的顺序很重要。通常，我们在面向对象的代码中不会过多关注顺序。但在FP中，参数顺序至关重要，因为它在很大程度上依赖于部分应用。在本章中展示的所有curried函数中，请注意参数的排列是为了从部分评估中受益。因此，最好将最静态、固定的参数放在前面，并允许最后的参数是更动态的调用特定参数，就像`prop`的定义一样：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The last parameter, `obj`, is left unbounded (free) so that you can freely
    extract a particular field from any object as you’re `map`ping over an array,
    for example. Given the transactions `tx1` and `tx2`, one for $10 and the other
    for $12.50, respectively, you can create a new function, `fundsOf`, with a partially
    bound `funds` property key. Now you can apply this function to any object with
    that key or even `map` this function an array of similar objects:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数`obj`被留作未限制（自由）的，这样你就可以在映射数组时自由地从任何对象中提取特定字段，例如。给定交易`tx1`和`tx2`，分别代表10美元和12.50美元，你可以创建一个新的函数`fundsOf`，它具有部分绑定的`funds`属性键。现在你可以将此函数应用于具有该键的任何对象，甚至可以将此函数映射到类似对象的数组中：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now that you’ve learned about currying and composition, you can use them together
    to create a functional version of the `calculateHash` logic inside `HasHash`.
    Alone, `curry` and `compose` offer lots of value, but together, they are even
    more powerful.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了currying和组合，你可以将它们结合起来，在`HasHash`中的`calculateHash`逻辑创建一个函数式版本。单独来看，`curry`和`compose`提供了很多价值，但结合起来，它们更加强大。
- en: 4.4.2 The curry and composition dynamic duo
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 curry和组合动态搭档
- en: 'One of the goals of this chapter is to generate a more secure hashing digest
    for `calculateHash` in our `HasHash` mixin. So far, we’re at this point in using
    the recursive definition of `computeCipher`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个目标是为我们的`HasHash`混入中的`calculateHash`生成一个更安全的哈希摘要。到目前为止，我们使用`computeCipher`的递归定义处于这个阶段：
- en: '[PRE53]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`HasHash` is aware of its surrounding context (namely, the transaction object
    referenced by `this`), but the functions are kept pure and side-effect-free. By
    building these small islands of pure logic, we can put all this code aside and
    lessen the mental burden of having to keep track of everything that’s happening.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasHash` 了解其周围的环境（即由 `this` 引用的交易对象），但函数保持纯净且无副作用。通过构建这些小的纯逻辑岛屿，我们可以将这些代码放一边，减轻跟踪所有发生的事情的心理负担。'
- en: 'But we’re not done yet. Now that each function is separate, let’s improve the
    code a bit more to make `HasHash` more secure and applicable to the other blockchain
    domain objects. We will make two additional changes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有完成。现在每个函数都是独立的，让我们进一步改进代码，使 `HasHash` 更安全且适用于其他区块链域对象。我们将进行两项额外的更改：
- en: 'Integrate `HasHash` with any object. This change involves refactoring `assemble`
    to take an array of the parts of an object used in hashing, giving us extra flexibility
    when assigning `HasHash` to other classes. Part of this change also involves mapping
    a call to `JSON.stringify` to ensure that any object provided (primitive or otherwise)
    gets converted to its string representation. `JSON.stringify` is a good way of
    ensuring that we get a string out of any type of data, and it works well, provided
    that the objects are not incredibly long:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `HasHash` 与任何对象集成。这次更改涉及重构 `assemble` 以接受用于哈希的对象部分数组，这使我们能够在将 `HasHash` 分配给其他类时具有额外的灵活性。这次更改的部分也涉及将调用映射到
    `JSON.stringify`，以确保任何提供的对象（原始或非原始）都转换为它的字符串表示。`JSON.stringify` 是确保我们从任何类型的数据中获取字符串的好方法，并且它工作得很好，前提是对象不是特别长：
- en: '[PRE54]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This line creates the string with the necessary object data to seed to the
    hashing code. Here’s an example:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这行代码创建了一个包含必要对象数据的字符串，用于向哈希代码播种。以下是一个示例：
- en: '[PRE55]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Implement a more secure hash. Let’s use Node.js’s crypto module. This module
    gives you the option to generate hashes using widely adopted algorithms, such
    as SHA-2, as well as different output encodings, such as hexadecimal:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个更安全的哈希。让我们使用 Node.js 的 crypto 模块。此模块为您提供使用广泛采用的算法生成哈希的选项，例如 SHA-2，以及不同的输出编码，例如十六进制：
- en: '[PRE56]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The next listing shows an example that creates the SHA-256 representation of
    a simple object.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了创建简单对象 SHA-256 表示的示例。
- en: Listing 4.11 Computing a SHA-256 value from the contents of an object
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 从对象的 内容计算 SHA-256 值
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ SHA-2 is a set of secure cryptographic hash functions. The longer the bit
    string, the more secure it is. In this case, I’m using SHA0256, which is widely
    adopted in the industry
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ SHA-2 是一组安全的加密哈希函数。字符串越长，安全性越高。在这种情况下，我使用的是 SHA0256，它在业界得到了广泛的应用
- en: ❷ Returns a hexadecimal-encoded string instead of a binary buffer, making the
    output more legible
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个十六进制编码的字符串，而不是二进制缓冲区，这使得输出更易于阅读
- en: 'Hash computation must be reliable and predictable; given the same input, it
    must produce the same output. If you recall from our starting guidelines, predictability
    conveniently points to the principle of referential transparency. All that’s left
    to do now is `compose` these two:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希计算必须是可靠和可预测的；给定相同的输入，它必须产生相同的输出。如果您还记得我们的起始指南，可预测性方便地指向引用透明性的原则。现在我们只剩下 `compose`
    这两个：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'But there’s an issue here. Can you spot why this code won’t work? `computeCipher`
    is not a function of a single argument. Invoking this function as is will pass
    the output of `assemble` into the `options` part and `undefined` for `data`, which
    will break the entire flow. We can use currying to address this mismatch by partially
    configuring `computeCipher` to produce a function that gets inserted into `compose`.
    First, add `curry` to the function definition:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个问题。你能看出为什么这段代码不会工作吗？`computeCipher` 不是一个单参数的函数。以这种方式调用此函数会将 `assemble`
    的输出传递到 `options` 部分，并将 `undefined` 传递给 `data`，这将破坏整个流程。我们可以通过部分配置 `computeCipher`
    以产生一个函数，该函数被插入到 `compose` 中来解决这种不匹配。首先，将 `curry` 添加到函数定义中：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then call `computeCipher` piecewise, as you did with `add` and `prop`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后分步调用 `computeCipher`，就像您对 `add` 和 `prop` 所做的那样：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The next listing puts everything together.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表将所有内容组合在一起。
- en: Listing 4.12 Final implementation of `HasHash`
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 `HasHash` 的最终实现
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ Passing this works well when it’s your own code, but when you’re using third-party
    libraries, it’s best to send a copy of only the data needed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当它是您自己的代码时，传递此方法效果很好，但当你使用第三方库时，最好只发送所需数据的副本。
- en: '![](../Images/4-9.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-9.png)'
- en: Listing 4.9 Composing with `curry` in the implementation of `calculateHash`.
    The label above each box shows the complete function signature. `computeCipher`
    and `props` are curried and have been partially applied. The far-right parameter
    (or the only parameter) of all functions is used to receive the input of one function
    in the chain.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 在`calculateHash`的实现中使用`curry`进行组合。每个框上方的标签显示了完整的函数签名。`computeCipher`和`props`已被curry化并部分应用。所有函数的最右侧参数（或唯一参数）用于接收链中一个函数的输入。
- en: 'Figure 4.9 shows the flow of data using a simple transaction object literal:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9展示了使用简单的交易对象字面量来表示数据流：
- en: '[PRE62]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We used `curry` and `compose` to drive the execution of `calculateHash`, which
    are known as function combinators—functions that build up (combine) other functions.
    Combinators have no special logic of their own; they work on either the structure
    of the functions themselves or on coordinating their execution. `curry` manipulates
    the arguments so that they can be evaluated one at a time. Similarly, `compose`
    is in charge of threading through a function’s output with the next function’s
    input. All this control flow is abstracted from you in this snippet of code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`curry`和`compose`来驱动`calculateHash`的执行，这些被称为函数组合子——组合其他函数的函数。组合子没有自己的特殊逻辑；它们要么作用于函数的结构本身，要么协调它们的执行。`curry`操作参数，以便它们可以逐个评估。同样，`compose`负责将一个函数的输出传递给下一个函数的输入。所有这些控制流都在这段代码中被抽象化：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The object referenced by `this` enters the composition chain, and on the other
    side, you get its hash value. Passing the original context (`this`) here is safe
    because all these functions are side-effect-free. But what happens when someone
    else changes them or when you’re integrating with other functions you don’t know
    about? In JavaScript, object values are stored by reference. When you pass an
    object to a function, that reference is passed by value, not the object itself
    (as with primitives). You can guard against any undesirable mutations and make
    your code more predictable by sending a copy. This situation is also a good opportunity
    for the input object being hashed to use only the data you need. To do so, let’s
    use the `Object.fromEntries` API. This API allows you to turn any iterable object
    of key/value pairs (`Array`, `Map`, and so on) into an object. `HasHash` already
    has the list of keys for the data to hash, so it’s easy to construct an object
    with only that data:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由`this`引用的对象进入组合链，而在另一边，你得到它的哈希值。在这里传递原始上下文（`this`）是安全的，因为所有这些函数都是无副作用的。但当你或其他人更改它们，或者当你与其他你不知道的函数集成时会发生什么？在JavaScript中，对象值是通过引用存储的。当你将对象传递给函数时，传递的是引用的值，而不是对象本身（与原始数据类型不同）。你可以通过发送一个副本来防止任何不希望的突变，并使你的代码更具可预测性。这种情况也是输入对象仅使用所需数据的好机会。为此，让我们使用`Object.fromEntries`
    API。这个API允许你将任何键/值对的可迭代对象（`Array`、`Map`等）转换为对象。`HasHash`已经有了要哈希的数据的键列表，因此很容易构建一个只包含该数据的对象：
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With this snippet, we’ve completed our `HasHash` mixin. As you can see, it’s
    not an entirely pure object, because it depends on the global `this` to exist,
    which points to the prototype of the object to which `HasHash` is assigned. But
    we can call it a hybrid because it relies on pure functions to carry out its work.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个片段，我们已经完成了`HasHash`混合。正如你所见，它不是一个完全纯净的对象，因为它依赖于全局的`this`存在，它指向`HasHash`被分配的对象的原型。但我们可以称它为混合型，因为它依赖于纯函数来完成其工作。
- en: 'We still have to tackle the other coding example: calculating a user’s total
    balance from blockchain transactions. In the code snippets you’ve seen so far,
    we’ve always used a regular float to represent the `funds` amount. I did this
    to keep things simple. In the real world, `funds` always has two components: a
    numerical value and a currency denomination (such as $10.0 or ฿10.0). To represent
    currency, let’s create an object called `Money`, designed to be immutable.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要处理其他编码示例：从区块链交易中计算用户的总余额。在迄今为止看到的代码片段中，我们始终使用常规浮点数来表示`funds`金额。我这样做是为了保持简单。在现实世界中，`funds`总是有两个组成部分：数值和货币单位（如$10.0或฿10.0）。为了表示货币，让我们创建一个名为`Money`的对象，设计为不可变。
- en: 4.5 Working with immutable objects
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 使用不可变对象
- en: The notion of purity extends beyond functions to objects. So far, the main entities
    of our blockchain application (`Block`, `Transaction`, and so on) are mutable,
    which means that you can easily change the properties of the object after instantiation.
    We made this design decision to allow these objects to recalculate their hashes
    on update, and also to allow the object to be dynamically extended via mixins
    or traditional class-based inheritance if need be. We could also have decided
    to make the objects immutable, and there are many good use cases for this design,
    one of which we’ll explore in this section.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 纯洁性的概念不仅限于函数，也扩展到了对象。到目前为止，我们区块链应用的主要实体（如`Block`、`Transaction`等）是可变的，这意味着你可以在实例化后轻松更改对象的属性。我们做出这个设计决策是为了允许这些对象在更新时重新计算它们的哈希值，并且如果需要，允许对象通过混入或传统的基于类的继承动态扩展。我们也可以选择使对象不可变，这种设计有许多很好的用例，其中之一我们将在本节中探讨。
- en: 'Consider an object called `Money` that represents the amount of currency being
    transacted. `Money` is an object with perpetual value: ten cents will always equate
    to ten cents. Its identity is given by the amount and the currency name. If you
    change ten cents to five cents, conceptually, that’s a new `Money` entity. Think
    about what it means to change a date value. Isn’t this value a different moment
    in time? Changing a point in a Cartesian plane is another point. Other examples
    widely used in industry that lend themselves to this type of design include `DateTime`,
    `Point`, `Line`, `Money`, and `Decimal`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个名为`Money`的对象，它代表正在交易的货币金额。`Money`是一个具有永久价值的对象：一角硬币始终等于一角硬币。其身份由金额和货币名称给出。如果你将一角硬币改为五分硬币，从概念上讲，那将是一个新的`Money`实体。想想看改变日期值意味着什么。这不是一个不同时间点的值吗？在笛卡尔平面上改变一个点，那又是另一个点。在工业界广泛使用的其他一些适合这种设计类型的例子包括`DateTime`、`Point`、`Line`、`Money`和`Decimal`：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Immutable objects are a well-known pattern in industry. In chapter 2, we discussed
    how `Object.create` allows you to define immutable fields by using data descriptors
    upon creation. Generally speaking, an immutable object is one for which you can’t
    set any fields. Its data descriptors have `writable:` `false` for all fields.
    A popular pattern based on this is called the Value Object pattern. A value object
    is immutable upon creation and has some fields to describe identity and comparison.
    Similar to the guidelines imposed by pure functions, here are some guidelines
    to keep in mind when deciding whether to use this pattern:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象在工业界是一个已知的模式。在第2章中，我们讨论了如何使用数据描述符在创建时定义不可变字段，`Object.create`允许你这样做。一般来说，不可变对象是指你不能设置任何字段的那些对象。其数据描述符对于所有字段都有`writable:`
    `false`。基于此的一个流行模式被称为值对象模式。值对象在创建时是不可变的，并且有一些字段用于描述身份和比较。与纯函数强加的规则类似，以下是一些在决定是否使用此模式时需要记住的指南：
- en: Has no global identity — There’s no way to fetch an instance of a value object
    by some sort of ID. Conversely, transactions are globally identified by their
    hash values (`transactionId`). Similarly, a `Block` is identified by index value
    or position in the ledger.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有全局身份 —— 无法通过某种ID获取值对象的实例。相反，事务通过其哈希值（`transactionId`）进行全局标识。同样，一个`Block`通过索引值或账本中的位置来标识。
- en: Closed to modification — When the object is instantiated, you may not alter
    any of its properties. Doing so results in the creation of a new object or an
    error.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可修改 —— 当对象被实例化后，你无法更改其任何属性。这样做会导致创建一个新的对象或产生错误。
- en: Closed to extension — You may not dynamically add properties to (mixins) or
    remove properties from this object, and you may not derive new objects from it
    (inheritance).
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可扩展 —— 你不能动态地向（混入）此对象添加属性，也不能从它中移除属性，并且不能从中派生新的对象（继承）。
- en: Defines its own equality — With no unique ID, it’s beneficial to implement an
    `equals` method that knows how to compare two value objects based on their properties.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自己的等价性 —— 由于没有唯一的ID，实现一个能够根据其属性比较两个值对象的`equals`方法是有益的。
- en: Override `toString` and `valueOf`—Value objects need seamless representation
    as either a string or primitive. Overriding methods such as `toString` and `valueOf`
    affects how an object behaves next to a mathematical symbol or when concatenated
    with a string.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖`toString`和`valueOf`——值对象需要无缝地以字符串或原始值的形式表示。覆盖如`toString`和`valueOf`这样的方法会影响对象在数学符号旁边的行为或与字符串连接时的行为。
- en: 'For our blockchain, we’re going to represent the `funds` field of `Transaction`
    as a `Money` object. Before we look at the internal details, let’s see how it’s
    used:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的区块链，我们将 `Transaction` 的 `funds` 字段表示为 `Money` 对象。在我们查看内部细节之前，让我们看看它是如何被使用的：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Let’s implement `Money` by using a simple function instead of a class. Unlike
    class constructors, normal functions can be curried. So we can do things like
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用一个简单的函数而不是类来实现 `Money`。与类构造函数不同，普通函数可以进行柯里化。因此，我们可以做如下事情：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Also, `Money` supports a few key operations such as adding, subtracting, rounding,
    and (most importantly) implementing some sense of equality. Why is equality important?
    Without some field describing its identity, value objects are comparable only
    by their attributes:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Money` 支持一些关键操作，如加法、减法、四舍五入，以及（最重要的是）实现某种相等性。为什么相等性很重要？如果没有描述其身份的字段，值对象只能通过其属性进行比较：
- en: '[PRE68]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the case of `Money`, we’re not interested in using inheritance or any of
    the instantiation patterns of previous chapters, which are intended to build complex
    objects; using a simple function to return an object literal is more than enough.
    This pattern also goes by the name Function Factory.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Money` 的情况下，我们不感兴趣使用继承或任何前几章中提到的实例化模式，这些模式旨在构建复杂对象；使用一个简单的函数返回一个对象字面量就足够了。这种模式也被称为函数工厂。
- en: To implement the “closed for modification and extension” guarantees, we can
    use the `Object.freeze` and `Object.seal` JavaScript built-in methods, respectively.
    Both methods are easy to compose. The next listing shows the implementation details
    of `Money`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现“封闭修改和扩展”的保证，我们可以分别使用 JavaScript 内置的 `Object.freeze` 和 `Object.seal` 方法。这两种方法都很容易组合。下一个列表显示了
    `Money` 的实现细节。
- en: Listing 4.13 Details of the `Money` value object
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 `Money` 值对象的详细信息
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ❶ The new object is first frozen and then sealed.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新对象首先被冻结，然后被密封。
- en: ❷ Uses Object.assign with Object.create(null) to create a value object without
    any prototype references, making it closer to a true value in the system
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 Object.assign 和 Object.create(null) 创建一个没有任何原型引用的值对象，使其更接近系统中的真实值
- en: ❸ Overrides Object#valueOf and Object#toString to help JavaScript’s type coercion
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 重写 Object#valueOf 和 Object#toString 以帮助 JavaScript 的类型强制转换
- en: ❹ Implemented outside the object literal definition to make static methods
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在对象字面量定义外部实现以创建静态方法
- en: 'The code in listing 4.13 packs in a lot of functionality because we’re trying
    to arrive at an object that behaves and feels like a primitive. Aside from making
    the object immutable and closed for extension, we’re instantiating it from a “null
    object” prototype `Object.create(null``)` in a single step, using `Object.assign`
    (chapter 3). `Money` won’t automatically inherit any of `Object.prototype`’s member
    fields (such as `toString` and `valueOf`), in particular one that doesn’t apply
    in this case: `Object#isPrototypeOf`. The downside is that you’re responsible
    for implementing these properties correctly.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 中的代码包含了大量的功能，因为我们试图得到一个表现得像原始类型一样的对象。除了使对象不可变和封闭扩展之外，我们通过使用 `Object.assign`（第
    3 章）在单步中从“null 对象”原型 `Object.create(null)` 实例化它。`Money` 不会自动继承 `Object.prototype`
    的任何成员字段（如 `toString` 和 `valueOf`），特别是这个情况下不适用：`Object#isPrototypeOf`。缺点是，你必须负责正确实现这些属性。
- en: 'Hence, we’ll implement `toString` and `valueOf` to work as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将实现 `toString` 和 `valueOf` 以如下方式工作：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`valueOf` is a bit more interesting. Unlike with `toString`, you don’t invoke
    `valueOf` directly. JavaScript automatically calls it when the object is expected
    to behave as a primitive, especially in a numeric context. When the object is
    next to a math symbol, we can downgrade (coerce) `Money` to `Number`. Then you
    can wrap that result back into `Money` with proper a currency denomination, if
    needed:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`valueOf` 方法有点更有趣。与 `toString` 不同，你不需要直接调用 `valueOf`。当对象被期望以原始类型行为，尤其是在数值上下文中时，JavaScript
    会自动调用它。当对象与数学符号相邻时，我们可以将 `Money` 降级（强制）为 `Number`。然后，如果需要，你可以用适当的货币单位将那个结果包装回
    `Money`：'
- en: '[PRE71]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now let’s see the effects of applying `Object.seal` and `Object.freeze` to
    these objects. We used `compose` to apply each method sequentially. `Object.freeze`
    prevents you from changing any of its attributes (remember that we’re assuming
    strict mode), as shown here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看将 `Object.seal` 和 `Object.freeze` 应用到这些对象上的效果。我们使用了 `compose` 来按顺序应用每个方法。`Object.freeze`
    阻止你更改其任何属性（记住我们假设严格模式），如下所示：
- en: '[PRE72]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And `Object.seal` prevents clients from extending it:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Object.seal` 阻止客户端扩展它：
- en: '[PRE73]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Finally, notice that all the methods in `Money` (`plus`, `minus`, and so on)
    use copy-on-write semantics, returning new objects instead of changing the existing
    one and embracing the principles of purity we’ve discussed so far.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，`Money`（`plus`、`minus`等）中的所有方法都使用写时复制语义，返回新对象而不是改变现有对象，并接受我们之前讨论的纯度原则。
- en: Pure object manipulation
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 纯对象操作
- en: In functional programming, there’s an approach to manipulate data inside objects
    known as lenses so that you don’t have to roll your own version of copy-on-write.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，有一种在对象内部操作数据的方法称为镜头，这样你就不必自己实现写时复制版本。
- en: A lens allows you to target a specific property or path inside an object so
    that you can perform changes to it in a composable, immutable manner. Behind the
    scenes, it uses copy-on-write, but everything is done for you automatically. You
    can learn more about this technique on your own by exploring the Ramda lens APIs
    ([https://ramdajs .com/docs/#lens](https://ramdajs.com/docs/#lens)).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 镜头允许你针对对象中的特定属性或路径进行定位，这样你就可以以可组合和不可变的方式对其进行更改。幕后，它使用写时复制，但所有操作都是自动完成的。你可以通过探索Ramda镜头API（[https://ramdajs.com/docs/#lens](https://ramdajs.com/docs/#lens)）来了解更多关于这项技术的信息。
- en: At this point, you’ve learned how to structure functional code by using composition
    and currying. Primitive data can be manipulated and mutated at will (because it’s
    immutable by design), whereas custom data objects need a bit more attention. In
    the latter case, using value objects when appropriate or passing copies of data
    to code can help divert lots of nasty bugs.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何通过组合和柯里化来构建函数式代码。原始数据可以随意操作和修改（因为它设计上是不可变的），而自定义数据对象则需要更多的关注。在后一种情况下，在适当的时候使用值对象或向代码传递数据副本可以帮助避免许多讨厌的bug。
- en: With all the fundamentals behind us, let’s improve the design of our code with
    a paradigm known as point-free coding—the last piece needed to implement the logic
    of calculating the balance of a user’s digital wallet.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握所有基础知识之后，让我们通过一种称为无点编码的范式来改进我们的代码设计——这是实现计算用户数字钱包余额逻辑所需最后一块拼图。
- en: 4.6 Point-free coding
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 无点编码
- en: Point-free coding is a byproduct of adopting declarative programming. You can
    use point-free coding without FP. But because point-free is all about improving
    the readability of code at a glance and making it simpler to parse, having the
    guarantees imposed by FP furthers this cause.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 无点编码是采用声明式编程的副产品。你可以使用无点编码而不必使用FP。但是，因为无点编码的全部都是为了提高代码的可读性并使其更容易解析，所以FP强加的保证进一步推动了这一目标。
- en: Learning the point-free style is beneficial because it allows developers to
    understand your code at first sight without necessarily having to dive into the
    internals. Point-free refers to a style in which function definitions do not explicitly
    identify the arguments (or the points) they receive; they are implicitly (tacitly)
    passed through the flow of a program, usually with the help of `curry` and `compose`.
    Removing this clutter usually reveals a leaner code structure that humans can
    parse visually with ease. By being able to see the forest for the trees, you can
    spot higher-level bugs that could arise from using bad logic or making bad assumptions
    about requirements.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 学习无点风格是有益的，因为它允许开发者无需深入了解内部结构就能一眼看懂你的代码。无点编码指的是一种函数定义不明确标识它们接收的参数（或点）的风格；它们隐式（默示）地通过程序的流程传递，通常在`curry`和`compose`的帮助下。移除这种杂乱通常可以揭示一个更简洁的代码结构，人们可以轻松地通过视觉解析。通过能够看到森林而不是树木，你可以发现可能由不良逻辑或对需求做出不良假设而引发的高级bug。
- en: Because JavaScript has curried, first-class functions, we can assign a function
    to a variable, use this named variable as an argument to `compose`, and effectively
    create an executable outline of our code. In this section, you’ll learn about
    the benefits of using a point-free style with JavaScript, such as
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript有柯里化和一等函数，我们可以将一个函数赋给一个变量，将这个命名的变量用作`compose`的参数，从而有效地创建我们代码的可执行轮廓。在本节中，你将了解使用无点风格在JavaScript中的好处，例如
- en: Improving the legibility of your code by reducing syntactical noise
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过减少语法噪声来提高代码的可读性
- en: Making composition clearer and terser
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使组合更清晰和简洁
- en: Avoiding introducing unnecessary parameter names
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免引入不必要的参数名称
- en: Building a vocabulary describing the actions and tasks that make up your application
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建描述构成你的应用程序的动作和任务的词汇表
- en: 'Before we begin learning about this style, it helps to see it in comparison
    with non-point-free coding. Let’s do a quick review:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习这种风格之前，将其与非无点代码进行比较是有帮助的。让我们快速回顾一下：
- en: '[PRE74]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: To get a high-level idea of what this function does, you’re forced to read every
    statement and trace the flow. Each statement in the function describes in detail
    how every function is called and the parameters (or points) each function receives
    at the call site.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这个函数的高级功能，你必须阅读每个语句并追踪流程。函数中的每个语句都详细描述了每个函数是如何被调用以及每个函数在调用点接收的参数（或点）。
- en: 'On the other hand, using `compose` removes the unnecessary overhead and focuses
    on the high-level steps required to create a higher-level representation of the
    same logic. When we applied FP to `countWordsInFile` earlier, we arrived at this
    code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用`compose`消除了不必要的开销，并专注于创建更高层次逻辑表示所需的高级步骤。当我们之前将FP应用于`countWordsInFile`时，我们得到了以下代码：
- en: '[PRE75]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This program is point-free. Notice that nothing in this program tells you how
    to invoke `countWordsInFile`. The only thing you see is the structure of this
    function or what steps are involved. Because the signature of the function (and
    all the embedded functions) is missing, you may feel that this style obscures
    the code a bit for someone who is not familiar with these functions. That point
    is a valid one, and I’ve seen how it can make using a debugger a bit more challenging.
    But for someone who is familiar with this style and knows their way around a debugger,
    point-free coding makes composition much cleaner and allows you to visualize the
    high-level steps as though they were plug-and-play components.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是无点代码的。注意，这个程序中没有告诉你如何调用`countWordsInFile`。你看到的所有东西只是这个函数的结构或涉及哪些步骤。因为函数的签名（以及所有嵌套函数）缺失，你可能觉得这种风格对不熟悉这些函数的人来说代码有点难以理解。这一点是有效的，我见过它如何使使用调试器变得有点更具挑战性。但对于熟悉这种风格并且熟悉调试器的人来说，无点代码使组合更加清晰，并允许你将高级步骤视为即插即用的组件。
- en: A common analogy for point-free code is Lego bricks. When you’re looking at
    a Lego structure from a distance, you can’t see the pins that hold everything
    together, yet you appreciate the overall structure. If you look at the imperative
    version of `countWordsInFile` once more, the “pins” in this case refer to the
    intermediate variable names that connect one statement to the next.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 无点代码的一个常见类比是乐高积木。当你从远处观察一个乐高结构时，你看不到将所有东西连接在一起的销钉，但你仍然能欣赏到整体结构。如果你再次查看`countWordsInFile`的命令式版本，这里的“销钉”指的是连接一个语句到下一个语句的中间变量名。
- en: 'Suppose that you’re working on another task, such as counting an array of serialized
    block data from a JSON file. At a high level, you should be able to see that the
    structure of this code is similar to the preceding snippet of code. The only difference
    is that instead of dealing with space-separated words, you will deal with parsing
    an array of elements. Pure functions are easy to swap in and out because they
    don’t depend on any external data other than their own arguments. `countBlocksInFile`
    is implemented simply by swapping `split` with `JSON.parse`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理另一个任务，比如从JSON文件中计数序列化的块数据数组。从高层次来看，你应该能够看到这段代码的结构与前面的代码片段相似。唯一的区别是，你将处理解析元素数组，而不是处理空格分隔的单词。纯函数很容易替换，因为它们除了自己的参数之外不依赖于任何外部数据。`countBlocksInFile`的实现简单地将`split`替换为`JSON.parse`：
- en: '[PRE76]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Again, this swap is evident because point-free coding cleans up the process
    of passing functions and arguments around, allowing you to focus on the task at
    hand, such as changing a red Lego brick for a green one. It should be obvious
    at this point that `countBlocksInFile` is another Lego bundle (a module) that
    can be composed (pinned) further. You can build entire complex applications from
    this fundamental idea (figure 4.10).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这种交换是显而易见的，因为无点代码清理了传递函数和参数的过程，让你能够专注于手头的任务，比如将一个红色乐高积木换成绿色乐高积木。此时应该很明显，`countBlocksInFile`是另一个可以进一步组合（固定）的乐高捆绑（模块）。你可以从这个基本思想（图4.10）构建整个复杂的应用程序。
- en: '![](../Images/4-10.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-10.png)'
- en: Listing 4.10 Functions composed to build entire applications
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.10：构建整个应用程序的函数组合
- en: All these Lego bricks become the taxonomy, or vocabulary, if you will, of the
    Lego set that is your application.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些乐高积木都成为了你的应用程序乐高套件中的分类法，或者说词汇表。
- en: Now that you understand how to structure your code by using composition and
    currying, let’s tackle a more complex imperative-to-functional transformation
    that involves computing a user’s digital-wallet balance.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何通过使用组合和柯里化来结构化你的代码，让我们来处理一个更复杂的需求式到函数式的转换，这涉及到计算用户的数字钱包余额。
- en: 4.7 Imperative to functional transformation
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 需求式到函数式的转换
- en: 'In chapter 3, I looked at the skeleton of the `Wallet` class (listing 3.9)
    but deliberately omitted the `balance` method. Here is that snippet of code again:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章，我看了`Wallet`类的骨架（列表3.9），但故意省略了`balance`方法。下面是这段代码的再次展示：
- en: '[PRE77]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now we’re prepared to fill in the complex logic details. To compute the balance
    of a user, given a blockchain (`ledger`) object argument, we need to tally all
    the transactions from all the blocks that have been mined for that user since
    the beginning of the ledger. We can omit the genesis block because we know that
    it doesn’t carry any data we’re interested in.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好填充复杂的逻辑细节。为了计算用户的余额，给定一个区块链（账本）对象参数，我们需要累计自账本开始以来为该用户挖掘的所有区块中的所有交易。我们可以省略创世区块，因为我们知道它不包含我们感兴趣的数据。
- en: Let’s look at this problem again with an imperative mindset and compare it with
    a functional one. This time, we’ll be using all the bells and whistles that we’ve
    learned thus far. The algorithm can look like the following listing.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次以命令式思维来审视这个问题，并将其与函数式思维进行比较。这次，我们将使用我们迄今为止所学到的所有技巧。算法可以看起来像以下列表。
- en: Listing 4.14 Imperative algorithm for computing total balance
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.14 计算总余额的命令式算法
- en: '[PRE78]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ❶ ledger is a Blockchain object, and iterating over it delivers each block.
    You’ll learn how to make any object iterable in chapter 7\. For now, you can safely
    assume that it’s an array of blocks.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 账本（ledger）是一个区块链对象，遍历它将返回每个区块。你将在第7章学习如何使任何对象可迭代。现在，你可以安全地假设它是一个区块的数组。
- en: ❷ If the user is the sender of the transaction, we discount the amount in the
    transaction; otherwise, we add it to the running balance.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果用户是交易的发送者，我们将折扣交易中的金额；否则，我们将它添加到累计余额中。
- en: Comparing this algorithm with the FP guidelines, you can see that it involves
    looping over the blockchain data structure, which means that you need to keep
    a running count of the balance as you iterate through all blocks and then through
    each transaction of that block. Within each iteration, there’s a lot of branching
    to accommodate different conditions—an imperative “pyramid of doom,” you might
    say. Let’s revisit that flow in figure 4.11.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 将此算法与FP指南进行比较，你可以看到它涉及到遍历区块链数据结构，这意味着你需要在你遍历所有区块以及每个区块的交易时，保持余额的累计计数。在每次迭代中，有很多分支来适应不同的条件——你可以称之为命令式的“灾难金字塔”。让我们回顾一下图4.11中的流程。
- en: '![](../Images/4-11.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![图4-11](../Images/4-11.png)'
- en: Listing 4.11 Imperative flow of control for the logic in calculating a user’s
    total balance in a blockchain
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.11 计算区块链中用户总余额的逻辑的命令式流程控制
- en: All the diamond-shaped boxes represent branching logic, nested within circulating
    arrows that represent loops. Arguably, this figure is not trivial to parse; it
    represents a simple piece of code.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 所有菱形框代表分支逻辑，嵌套在代表循环的循环箭头中。可以说，这个图并不容易解析；它代表了一小段代码。
- en: In addition, listing 4.14 has side effects in the way it references `this` to
    access a wallet’s properties and reassigns `balance` at each iteration. Refactoring
    this code by using a hybrid (FP + OO) approach involves
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，列表4.14在引用`this`以访问钱包属性和每次迭代重新分配`balance`的方式中存在副作用。通过使用混合（FP + OO）方法重构此代码涉及
- en: Making the data explicit function arguments instead of implicitly
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据显式作为函数参数，而不是隐式地
- en: Transforming loops and nested conditionals to a fluent data transformation with
    `map` and `filter`
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将循环和嵌套条件转换为使用`map`和`filter`的流畅数据转换
- en: Removing variable reassignments with an immutable `reduce` operation
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变的`reduce`操作去除变量重新分配
- en: 'The best course of action is to extract the logic into its own function, free
    from side effects, and have `balance` internally delegate to it with all the initial
    data. We can call this new method `computeBalance`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳做法是将逻辑提取到它自己的函数中，使其无副作用，并且让`balance`内部委托给它，并带上所有初始数据。我们可以称这个新方法为`computeBalance`：
- en: '[PRE79]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'It’s reasonable to start with the handy array essentials we’re familiar with:
    `map`, `filter`, and `reduce`. The following code represents the same algorithm,
    functionally inspired. Figure 4.12 shows what the new flow will look like.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有理由从我们熟悉的方便的数组基本操作开始：`map`、`filter`和`reduce`。以下代码代表了相同的算法，功能上受到启发。图4.12显示了新的流程将看起来是什么样子。
- en: There’s a small caveat in the functional approach shown in listing 4.15, which
    can be a bit confusing. Because the flow of data involves processing the array
    of blocks and, within each one, an array of transactions, we’re forced to deal
    with an array of arrays. To make things simple, when you encounter this issue,
    the best thing to do is flatten these structures. You’ll learn in chapter 5 that
    this occurrence is common in functional code. For now, we’ll use `Array#flat`
    to flatten the nested structure.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.15中展示的函数式方法中有一个小的注意事项，可能会有些令人困惑。因为数据处理流程涉及到处理区块的数组，以及每个区块内的交易数组，我们被迫处理一个数组数组。为了简化问题，当你遇到这个问题时，最好的办法是将这些结构展平。你将在第5章中了解到这种情况在函数式代码中很常见。现在，我们将使用`Array#flat`来展平嵌套结构。
- en: Listing 4.15 Calculating balance in `Wallet` with FP
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15 使用FP在`Wallet`中计算余额
- en: '[PRE80]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: ❶ Array.from turns any iterable into an array
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `Array.from`将任何可迭代对象转换为数组
- en: ❷ Uses the utility functions not and prop to call isGenesis (check code repository
    for implementation)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用`not`和`prop`实用函数调用`isGenesis`（检查代码仓库以获取实现）
- en: ❸ Reads the collection of transactions (data) from the chain
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从链中读取交易（数据）集合
- en: ❹ The resulting array of arrays from the previous step is flattened into a single
    array.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 上一步骤生成的数组数组被展平成一个单一数组。
- en: ❺ Calculates this user’s balance from each transaction
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从每个交易中计算此用户的余额
- en: ❻ Uses Money.sum function as a reducer, starting from Money.zero, and tallies
    the total
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用`Money.sum`函数作为reducer，从`Money.zero`开始，并总计总数
- en: ❽ Invokes the Money.round method on the result
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 在结果上调用`Money.round`方法
- en: For the most part, you can see that this algorithm is a reincarnation of the
    imperative logic but takes advantage of the higher-order functions from the array
    that connects each piece of the transformation, radically changing the flow of
    data. Also, the fact that we’re performing addition through code such as `reduce(Money.sum,`
    `Money .zero())` speaks to the mathematical nature that functional programs tend
    to exhibit.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，你可以看到这个算法是命令式逻辑的再世，但利用了数组中的高阶函数来连接每个转换的部分，彻底改变了数据的流程。此外，我们通过像`reduce(Money.sum,
    Money.zero())`这样的代码执行加法，这也说明了函数式程序往往表现出的数学性质。
- en: '![](../Images/4-12.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-12.png)'
- en: Listing 4.12 Functional flow of control for the logic in calculating a user’s
    total balance in a blockchain
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 计算区块链中用户总余额的逻辑的函数式流程控制
- en: 'For completeness, here’s the `balanceOf` function used in the functional version,
    now done as a lambda expression, which maps a user ID in a transaction to a positive
    or negative monetary value depending on whether said user is the sender or the
    recipient:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，这里提供了在函数式版本中使用的`balanceOf`函数，现在作为一个lambda表达式实现，它将交易中的用户ID映射到正或负货币值，这取决于该用户是发送者还是接收者：
- en: '[PRE81]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you look back at listing 4.15 again, perhaps the most complex step you see
    is the call to `flat` on the array of arrays structure that is built during the
    flow of the data. Here’s `flat` with a simple example so that you can see how
    it peels off the nested array:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看列表4.15，你可能会看到最复杂的步骤是对在数据处理流程中构建的数组数组结构上的`flat`调用。这里有一个简单的例子，以便你可以看到它是如何剥离嵌套数组的：
- en: '[PRE82]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Because the algorithm performs a `map` operation beforehand, there’s a shortcut:
    using `Array#flatMap` method directly. We’ll revisit `map` and `flatMap` in more
    detail in chapter 5, but for now, we’ll go over them in order to understand how
    `computeBalance` works. As you can see, `flat` is intuitive, but what the heck
    is `flatMap`? The combination of `map` followed by `flat` occurs frequently in
    functional programs, so often that it makes sense to alias the composition of
    these two methods as a single method. The agreed-upon name in the functional communities
    is `flatMap`. The preceding code simplifies to the next listing.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因为算法在之前执行了一个`map`操作，所以有一个捷径：直接使用`Array#flatMap`方法。我们将在第5章中更详细地回顾`map`和`flatMap`，但就现在而言，我们将按顺序介绍它们，以便了解`computeBalance`是如何工作的。正如你所见，`flat`是直观的，但`flatMap`究竟是什么呢？在函数式程序中，`map`后面跟着`flat`的组合经常出现，以至于将这两个方法的组合作为单个方法是有意义的。函数式社区中达成一致的名字是`flatMap`。前面的代码简化到下一个列表。
- en: Listing 4.16 `computeBalance` using `map`, `filter`, and `reduce`
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 使用 `map`、`filter` 和 `reduce` 的 `computeBalance`
- en: '[PRE83]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ❶ Substituting flatMap for map and then flat
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用 `flatMap` 替换 `map` 然后用 `flat`
- en: With these APIs, you can solve virtually any array processing task you need
    and probably even remove loops from your code. This capability is the future of
    working with collections in JavaScript.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些API，你可以解决几乎任何你需要处理的数组处理任务，甚至可能从你的代码中移除循环。这种能力是JavaScript中处理集合的未来。
- en: This listing is a good stopping point, but for the joy of it, let’s go one step
    further. In functional programs, it’s not common to use dot notation to invoke
    sequences of functions (`map(...).filter(...).reduce(...)`), as this notation
    assumes the inner workings of an object chaining these operations together. Instead,
    use their extracted, curried function forms with the help of `compose` to thread
    through the entire flow of data, passing said object to each call (no assumptions),
    making it point-free!
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表是一个很好的停止点，但为了乐趣，让我们再进一步。在函数式程序中，通常不使用点符号来调用函数序列（`map(...).filter(...).reduce(...)`），因为这种符号假设有一个对象将这些操作串联起来。相反，使用
    `compose` 的帮助，使用提取的、柯里化的函数形式来贯穿整个数据流，将对象传递给每个调用（无假设），使其无参数化！
- en: Let’s go over this technique slowly. When extracting a method into its own function,
    place the instance object as the last argument, and curry the function. The following
    listing shows how to extract `Array#map(f``)`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们慢慢来介绍这个技术。当将方法提取为其自己的函数时，将实例对象作为最后一个参数放置，并柯里化该函数。以下列表显示了如何提取 `Array#map(f``)`。
- en: Listing 4.17 Extracting `map` in curried form
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.17 以柯里化形式提取 `map`
- en: '[PRE84]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ❶ Array arr is the last parameter.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数组 `arr` 是最后一个参数。
- en: 'To embed `map` in a chain, partially apply the first argument, the mapper function:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要在链中嵌入 `map`，部分应用第一个参数，即映射函数：
- en: '[PRE85]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The dynamic array (`arr`) argument isn’t provided directly because `compose`
    will do it for you in a point-free way. Most third-party FP libraries carry these
    helper functions (`map`, `filter`, `reduce`, and many more) in curried form. The
    more functional version of this code, shown in the next listing, takes advantage
    of fine-grained, point-free design. The point-free design requires a fixed `address`
    parameter, whereas `ledger` is provided at the call site.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数组（`arr`）参数不是直接提供的，因为 `compose` 会以无参数化的方式为你完成。大多数第三方 FP 库都携带这些辅助函数（`map`、`filter`、`reduce`
    以及更多）的柯里化形式。下一列表中显示的代码的更函数式版本利用了细粒度、无参数化的设计。无参数化设计需要一个固定的 `address` 参数，而 `ledger`
    在调用位置提供。
- en: Listing 4.18 Point-free version of `computeBalance`
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.18 `computeBalance` 的无参数版本
- en: '[PRE86]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ❶ With compose, the logic reads right to left.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `compose`，逻辑从右到左读取。
- en: ❷ Uses the curried extracted forms of the equivalent Array#filter method
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用等价的 `Array#filter` 方法的柯里化提取形式
- en: ❸ Uses nested composition to make the code more modular
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用嵌套组合来使代码更加模块化
- en: Third-party FP libraries
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方 FP 库
- en: Functional languages such as Haskell and F# have built-in native operators to
    implement many of these techniques. In this chapter, you were introduced to the
    operators `compose` and `curry`. Normally, you would not write these operators
    by hand. Instead you’d import a third-party library such as Ramda ([https://ramdajs.com](https://ramdajs.com/)),
    Crocks ([https:// crocks.dev](https://crocks.dev/)), Lodash ([https://lodash.com](https://lodash.com/)),
    or UnderscoreJS ([https://underscorejs.org](https://underscorejs.org/)) to import
    a lot of these utility functions. You can find the ones used in this book in the
    code repo ([http://mng.bz/pVy2](http://mng.bz/pVy2)).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言，如 Haskell 和 F#，具有内置的本地操作符来实现许多这些技术。在本章中，你被介绍了 `compose` 和 `curry` 操作符。通常，你不会手动编写这些操作符。相反，你会导入第三方库，如
    Ramda ([https://ramdajs.com](https://ramdajs.com/))、Crocks ([https:// crocks.dev](https://crocks.dev/))、Lodash
    ([https://lodash.com](https://lodash.com/)) 或 UnderscoreJS ([https://underscorejs.org](https://underscorejs.org/))
    来导入许多这些实用函数。你可以在代码库中找到本书中使用的函数（[http://mng.bz/pVy2](http://mng.bz/pVy2)）。
- en: FP takes a little getting used to, but thinking this way puts you on the path
    to writing highly modular, maintainable, cleaner, and more reliable code. In fact,
    it saves you from potential bugs because JavaScript gives you total freedom to
    mutate almost anything, making your development experience a lot more enjoyable.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: FP 需要一点时间来适应，但这样思考会让你走上编写高度模块化、易于维护、更简洁和更可靠的代码的道路。实际上，它可以帮助你避免潜在的bug，因为JavaScript给你提供了几乎可以突变任何事物的完全自由，使你的开发体验变得更加愉快。
- en: Fanning out to pure functions like this one is a compelling idea that will become
    more and more prominent as JavaScript continues to embrace more functional features
    and make creating function chains a native part of the language.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据扇出到像这样的纯函数是一个令人信服的想法，随着 JavaScript 继续拥抱更多的函数式特性，并使创建函数链成为语言的本能部分，这个想法将变得越来越突出。
- en: 4.8 Native function chains
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 本地函数链
- en: 'Now that you understand the basic functional programming concepts, you’re one
    step ahead in learning a new feature that could make landfall in the near future.
    In this chapter, you learned (among other things) how to create functional chains
    by using `compose`. One of the most noticeable qualities of this operator is that
    the flow of data happens in reverse, which can be quite jarring for some people.
    Luckily, there’s a solution: the `pipe` operator. A close cousin of `compose`,
    `pipe` takes the functions in the natural left-to-right order. The buildout of
    `pipe` is exactly the same as that of `compose`. The only change would be to use
    `reduceRight` instead of `reduce`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了基本的函数式编程概念，你在学习即将到来的新特性方面又迈出一步。在本章中，你学习了（以及其他内容）如何使用 `compose` 创建函数链。这个操作符最显著的特点是数据流的方向是相反的，这可能会让一些人感到震惊。幸运的是，有一个解决方案：`pipe`
    操作符。`pipe` 是 `compose` 的近亲，它按照自然从左到右的顺序处理函数。`pipe` 的构建与 `compose` 完全相同。唯一的区别是使用
    `reduceRight` 而不是 `reduce`：
- en: '[PRE87]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This operator is inspired by the way in which UNIX-based programs pipe data
    forward into one another. With `pipe`, you could rearrange the logic to calculate
    a balance like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符的灵感来源于基于 UNIX 的程序如何将数据管道传输到另一个程序。使用 `pipe`，你可以重新排列逻辑来计算余额，如下所示：
- en: '[PRE88]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You’ll also find `pipe` in most FP libraries for JavaScript, such as Ramda
    and Crocks. If you prefer this way of thinking, JavaScript has a nice surprise
    in store for you. Introducing the pipeline operator: `|>` ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator)).
    Inspired by functional languages such as Elixir and F#, this native operator allows
    you to call sequences of functions with the data flowing unidirectionally to the
    right without needing any special third-party libraries.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你也会在大多数 JavaScript FP 库中找到 `pipe`，例如 Ramda 和 Crocks。如果你喜欢这种方式思考，JavaScript 为你准备了一个惊喜。介绍管道操作符：`|>`
    ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator))。这个操作符灵感来源于像
    Elixir 和 F# 这样的函数式语言。这个本地操作符允许你以单向数据流到右的方式调用一系列函数，而无需任何特殊的第三方库。
- en: 'It’s important to start learning about this new feature now because when it
    becomes official, it will radically change the way we write code. Here’s an example:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始学习这个新特性非常重要，因为当它成为官方特性时，它将彻底改变我们编写代码的方式。以下是一个例子：
- en: '[PRE89]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You can even mix it with lambda expressions:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将它与 lambda 表达式混合：
- en: '[PRE90]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now imagine that you had some of the common array methods extracted in curried,
    function form, as provided in these functional utility libraries. You’ll be able
    to write code like this:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，如果你有一些常见的数组方法被提取成柯里化函数形式，就像这些函数式实用库所提供的那样。你将能够编写如下代码：
- en: '[PRE91]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This example is a terser, more idiomatic way of designing code, and it pairs
    extremely well with `curry` for a declarative, native point-free design. For details
    on experimenting with this operator now, see appendix A.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一种更简洁、更符合习惯的代码设计方式，它与 `curry` 非常搭配，用于声明性、无点设计。关于现在如何实验这个操作符的详细信息，请参阅附录
    A。
- en: More about functional programming in JavaScript
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JavaScript 中的函数式编程的更多信息
- en: JavaScript’s support for the functional programming paradigm is a huge subject
    to cover. In this book, I’ll cover only enough FP to open your eyes to how it’s
    steering JavaScript’s future, as well as helping you become proficient and do
    more with less. If you’d like more information about functional programming and
    broader topics, you can read about them in detail in my 2016 book *Functional
    Programming in JavaScript* ([http://mng.bz/0mMN](http://mng.bz/0mMN)).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对函数式编程范式的支持是一个巨大的主题。在这本书中，我将只涵盖足够的函数式编程知识，以让你了解它如何引领 JavaScript 的未来，同时帮助你变得更加熟练，用更少的代码做更多的事情。如果你想要更多关于函数式编程和更广泛主题的信息，你可以在我的
    2016 年出版的《JavaScript 函数式编程》一书中详细了解它们（[http://mng.bz/0mMN](http://mng.bz/0mMN)）。
- en: From now on, if anyone asks whether JavaScript is object-oriented or functional,
    say “Yes!” The previous chapters highlighted the object-oriented nature of JavaScript.
    This chapter focused on functional programming and the art of composing pure,
    higher-order functions. Pure functions guarantee consistent and predictable results
    based on their input. Their purpose is clearly depicted by their signatures or,
    as Eric Evans puts it in Domain-Driven Design (Addison-Wesley Professional, 2013),
    “A pure function is an intention-revealing interface.”
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，如果有人问 JavaScript 是面向对象还是函数式，就说“是！”前几章强调了 JavaScript 的面向对象特性。这一章专注于函数式编程以及组合纯、高阶函数的艺术。纯函数基于其输入保证一致和可预测的结果。它们的目的通过它们的签名清楚地描述，正如埃里克·埃文斯在《领域驱动设计》（Addison-Wesley
    Professional, 2013）中所说，“一个纯函数是一个意图揭示的接口。”
- en: Although the functional paradigm has many benefits, it doesn’t have to be an
    all-or-nothing process. I deliberately used a hybrid style for the blockchain
    application with OO and FP concepts intertwined. You can not only take advantage
    of prototypal object models, but also create highly testable and portable modules
    of functions that encapsulate your critical business logic. Functional programming
    helps you write more robust and bug-free code, especially in a language such as
    JavaScript, where almost everything is mutable. We’ll circle back to coding with
    immutability in chapter 5.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数式范式有许多好处，但它不必是一个全有或全无的过程。我故意在区块链应用程序中使用了混合风格，面向对象和函数式概念交织在一起。你不仅可以利用原型对象模型，还可以创建封装你的关键业务逻辑的、高度可测试和可移植的函数模块。函数式编程帮助你编写更健壮且无错误的代码，尤其是在像
    JavaScript 这样的语言中，几乎一切都是可变的。我们将在第 5 章中回到使用不可变性的编码。
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: JavaScript’s higher-order functions are the means by which we can achieve functional
    code.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的高阶函数是我们实现函数式代码的手段。
- en: Code written in a functional style is declarative, composable, lazy, and simple
    to reason about.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数式风格编写的代码是声明性的、可组合的、惰性的，并且易于推理。
- en: The composition of pure functions is the bread and butter of any functional
    codebase.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数的组合是任何函数式代码库的基石。
- en: Shifting to a functional mindset requires a different approach to problem-solving
    based on decomposing code into fine-grained behavior.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向函数式思维模式需要一种不同的解决问题的方法，即通过将代码分解成细粒度行为。
- en: Lazy programming allows you to defer computation, and with `curry`, you can
    create composable software by using functions of any arity (number of arguments).
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 惰性编程允许你延迟计算，而使用`curry`，你可以通过使用任何阶数（参数数量）的函数来创建可组合的软件。
- en: Learning about FP principles will give you the competitive edge you need to
    begin using the new JavaScript features that will be available in the years to
    come.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 FP 原则将为你提供所需的竞争优势，以便开始使用未来几年将可用的新的 JavaScript 功能。
- en: Using the pipeline operator (`|>`) makes it incredibly easy and idiomatic to
    implement point-free function chains.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道操作符（`|>`）使得实现无点函数链变得极其简单且符合惯例。
