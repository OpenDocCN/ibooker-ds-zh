- en: Unit 5\. Iterables
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元5\. 可迭代对象
- en: In JavaScript, `String`s and `Array`s have always had a couple of things in
    common. They both contain an indefinite amount of *stuff*—characters in the case
    of strings and any datatype in the case of arrays. They both also have a `length`
    property indicating how many items they have. But there was never a common protocol
    that described how these things worked. Starting in ES2015, there are two new
    protocols that describe these JavaScript behaviors, known as the *iterable* and
    *iterator* protocols.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`String`和`Array`始终有一些共同之处。它们都包含一定数量的内容——字符串中的字符和数组中的任何数据类型。它们也都有一个`length`属性，表示它们包含的项目数量。但从未有一个共同的协议来描述这些内容是如何工作的。从ES2015开始，有两个新协议描述了这些JavaScript行为，被称为*迭代*和*迭代器*协议。
- en: '`String`s and `Array`s are now known as *iterables*. This means they adhere
    to the new iterable protocol and can be predictably interacted with in common
    ways, including being used with the new `for..of` statement and the new *spread*
    operator. There are also two new iterables: `Map`s and `Set`s. Additionally, you
    can define your own iterables or even customize the behavior of the built-in ones.
    And because they all follow the iterable protocol, they will always behave in
    predictable ways.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`和`Array`现在被称为*可迭代对象*。这意味着它们遵循新的迭代协议，并且可以用常见的方式进行预测性交互，包括使用新的`for..of`语句和新的*扩展*运算符。还有两个新的可迭代对象：`Map`和`Set`。此外，你可以定义自己的可迭代对象，甚至可以自定义内置对象的行为。由于它们都遵循迭代协议，它们的行为总是可预测的。'
- en: 'We‘ll start the unit by looking at the iterable protocol itself: how it works,
    how to create your own iterables, and how to use iterables with the `for..of`
    statement and spread operator. You’ll then learn about the new built-in iterable
    types, `Set`s and `Map`s. Finally, you’ll wrap up the unit by building a Blackjack
    game that make uses of `Map`s and `Set`s, as well as using `for..of` and spread.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个单元开始，看看迭代协议本身：它是如何工作的，如何创建自己的可迭代对象，以及如何使用`for..of`语句和扩展运算符来使用可迭代对象。然后，你将了解新的内置可迭代类型`Set`和`Map`。最后，你将通过构建一个使用`Map`和`Set`以及使用`for..of`和扩展运算符的21点游戏来结束这个单元。
- en: Lesson 23\. Iterables
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第23课\. 可迭代对象
- en: After reading [lesson 23](kindle_split_036_split_000.xhtml#ch23), you will
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第23课](kindle_split_036_split_000.xhtml#ch23)之后，你将
- en: Know what an iterable is and how to use it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可迭代对象是什么以及如何使用它
- en: Know how to use the spread operator on iterables to ungroup an object’s items
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在可迭代对象上使用扩展运算符来取消对象的分组
- en: Know how to use iterables in a `for..in` statement to loop over an object’s
    values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在`for..in`语句中使用可迭代对象来遍历对象的值
- en: Know how to create your own iterables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何创建自己的可迭代对象
- en: Know how to customize the behavior of built-in iterables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何自定义内置可迭代对象的行为
- en: 'JavaScript in ES2015 has introduced a couple of new protocols: the iterable
    protocol and the iterator protocol. Together these protocols describe the behavior
    and mechanics of objects that can be *iterated*—that is to say, objects that produce
    a series of values and can have their values looped over. When you think of objects
    that can be iterated, `Array` probably springs to mind, but you can also iterate
    `String`s, the `arguments` object, `NodeList`s, and as we’ll see in the upcoming
    lessons, `Set`s and `Map`s. On top of having all these built-in iterables, you
    can, as you’ll discover in this lesson, build your own!'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在ES2015中引入了几个新协议：迭代协议和迭代器协议。这两个协议共同描述了可迭代对象的行为和机制——也就是说，可以产生一系列值并且可以遍历其值的对象。当你想到可迭代对象时，`Array`可能首先浮现在你的脑海中，但你也可以迭代`String`、`arguments`对象、`NodeList`，以及我们将在接下来的课程中看到的`Set`和`Map`。除了所有这些内置的可迭代对象之外，你还可以，正如你将在本课中发现的，创建自己的可迭代对象！
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: The following code logs all of the indices of an array. But what if you wanted
    to log all of the values?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码记录了数组的所有索引。但如果你想要记录所有值呢？
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 23.1\. Iterables—what are they?
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1\. 可迭代对象——它们是什么？
- en: An iterable is any object that follows the iterable protocol that’s new in JavaScript,
    introduced in ES2015.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象是任何遵循JavaScript中引入的迭代协议的对象，该协议在ES2015中引入。
- en: Common built-in iterables are `String`s and `Array`s but so are `Set`s and `Map`s.
    Because all of the objects follow a common protocol, it means they all behave
    in similar ways. You can also use this protocol to create your own iterables or
    customize the behavior of default ones!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的内置可迭代对象有`String`和`Array`，但`Set`和`Map`也是。因为所有对象都遵循一个共同的协议，这意味着它们的行为方式相似。你还可以使用此协议来创建自己的可迭代对象或自定义默认对象的行为！
- en: As I mentioned, not all iterables are new. JavaScript has always had strings
    and arrays. But the protocol that sets a contract for how strings, arrays, and
    other iterators behave is new. Strings and arrays have been updated to use this
    new protocol, and other objects like `Set`s and `Map`s are new objects that also
    make use of the protocol.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，并非所有可迭代对象都是新的。JavaScript 一直有字符串和数组。但为字符串、数组和其他迭代器行为设定契约的协议是新的。字符串和数组已经更新以使用这个新协议，而像
    `Set` 和 `Map` 这样的其他对象是新的对象，它们也利用了这个协议。
- en: Along with the new iterable protocol, we get some new ways to interact with
    objects that make use of it, specifically the `for..of` statement and the spread
    operator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的可迭代协议之外，我们还得到了一些新的与使用它的对象交互的方法，特别是 `for..of` 语句和展开操作符。
- en: 23.2\. The for..of statement
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.2\. `for..of` 语句
- en: How many times have you written code that looks like this?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你写过多少次这样的代码？
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the `for..of` you can now achieve the same thing with this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for..of`，你现在可以用这个来实现相同的功能：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: JavaScript has long had the `for..in` statement that allows you to enumerate
    an object’s keys (property names), but now with the `for..of` statement you can
    iterate an iterable’s values, as shown in the next listing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 很早就有了允许你枚举对象键（属性名）的 `for..in` 语句，但现在有了 `for..of` 语句，你可以迭代可迭代对象的值，如下一列表所示。
- en: Listing 23.1\. Comparing `for..in` and `for..of`
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 23.1\. 比较 `for..in` 和 `for..of`
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* series, publisher**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 系列，出版社**'
- en: '***2* Get Programming, Manning**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 编程入门，Manning**'
- en: This is similar to `Array.prototype.forEach`, but it has a few benefits. It
    can be used with any iterable, not just arrays. It is an imperative operation
    and thus can be optimized to perform better than the higher-order `forEach` method.
    Additionally, it can be broken out of early using `break`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `Array.prototype.forEach` 类似，但它有几个优点。它可以与任何可迭代对象一起使用，而不仅仅是数组。它是一个命令式操作，因此可以优化以比高阶
    `forEach` 方法表现得更好。此外，它可以使用 `break` 来提前退出。
- en: 'One final benefit of using `for..of` is that you can’t `yield` from a non-generator
    function, even if that function is inside a generator:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for..of` 的一个最终好处是，你无法从一个非生成器函数中 `yield`，即使该函数位于生成器内部：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* SyntaxError: unexpected identifier**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 语法错误：意外的标识符**'
- en: 'You get this error because the `yield` is actually inside of the arrow function
    that’s the callback for `forEach`. The `yield` doesn’t bubble up to the nearest
    generator function in the stack. If it’s used inside a non-generator function,
    it’s a syntax error. However, you can get around this by using `for..of` like
    so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到这个错误是因为 `yield` 实际上位于 `forEach` 的回调箭头函数内部。`yield` 不会冒泡到堆栈中最接近的生成器函数。如果它在一个非生成器函数内部使用，则是一个语法错误。然而，你可以通过如下使用
    `for..of` 来解决这个问题：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `for..of` statement isn’t a game changer, but it is yet another tool in
    your JavaScript Next tool belt. So far we’ve been looking at ways to process existing
    iterables; in the next section you’ll create your own iterables.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`for..of` 语句并不是一个颠覆性的改变，但它又是你 JavaScript 新工具箱中的另一个工具。到目前为止，我们一直在探讨处理现有可迭代对象的方法；在下一节中，你将创建自己的可迭代对象。'
- en: '|  |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 23.1**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 23.1**'
- en: '**[Q1:](kindle_split_036_split_002.xhtml#ch23qa2q0a1)**'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_036_split_002.xhtml#ch23qa2q0a1)**'
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many times will the following `for..of` loop run?
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下 `for..of` 循环将运行多少次？
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 23.1 answer**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 23.1 答案**'
- en: '**[A1:](kindle_split_036_split_002.xhtml#ch23qa1q1)**'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_036_split_002.xhtml#ch23qa1q1)**'
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '3'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '3'
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 23.3\. Spread
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.3\. 展开操作
- en: 'One thing all iterables in JavaScript share is their ability to be used with
    the *spread operator*. The spread operator allows you to treat the passing of
    a single iterable as if you passed all of its items individually. Let’s look at
    what that means. Imagine you’re running an online marketplace. For any item, there
    are a series of vendors who offer that item, all at different prices. You want
    to show the user the lowest price available. You can easily get an array of all
    the prices, but once you have an array of prices, how do you find the lowest price?
    You want to give this array of prices to `Math.min` but that requires you pass
    in all the prices individually, not as an array. Before the spread operator, you
    would likely use something like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中所有可迭代的对象都有一个共同点，那就是它们可以使用*展开操作符*。展开操作符允许你将单个可迭代的传递视为传递了所有其项目。让我们看看这意味着什么。想象你正在运行一个在线市场。对于任何商品，都有一系列的卖家提供该商品，价格各不相同。你想要向用户展示最低的价格。你可以轻松地获取所有价格组成的数组，但一旦你有了价格数组，你如何找到最低的价格？你想要将这个价格数组传递给`Math.min`，但这需要你单独传递所有价格，而不是作为一个数组。在展开操作符之前，你可能会使用类似以下的方法：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'However this can be greatly simplified with the use of the spread operator:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用展开操作符可以极大地简化这个过程：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instead of passing the prices array to `Math.min` as a single parameter, it’s
    passing all of the values of the array as separate parameters. This doesn’t just
    work on arrays, but on any iterable, even strings. In the case of a string, though,
    it would pass each individual character as a separate parameter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将价格数组作为一个单独的参数传递给`Math.min`，它将数组的所有值作为单独的参数传递。这不仅适用于数组，也适用于任何可迭代的对象，甚至是字符串。然而，在字符串的情况下，它将每个单独的字符作为单独的参数传递。
- en: You might have noticed that spread uses the exact same syntax as rest. This
    is by design, as spread is the exact opposite of rest. When writing a function
    you expect to be given a series of values as parameters, you can group all of
    the values you’re given into a single array using rest, as shown in the next listing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，展开使用了与剩余参数完全相同的语法。这是有意为之，因为展开是剩余参数的完全对立面。当你编写一个期望接收一系列值作为参数的函数时，你可以使用剩余参数将所有提供的值组合成一个数组，如下一个列表所示。
- en: Listing 23.2\. Grouping parameters into an array using rest
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.2\. 使用剩余参数将参数组合成一个数组
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* [“a”, “c”]**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [“a”, “c”]**'
- en: The function `findDuplicates` takes any number of parameters and returns the
    ones that are duplicates. Internally it groups all those values into an array
    using spread.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`findDuplicates`函数接受任意数量的参数，并返回重复的参数。内部使用展开将这些值分组到一个数组中。'
- en: 'On the flip side, if you already have an array, you can’t just pass it to the
    `findDuplicates` function because it will only have one array and will be looking
    for duplicates of the array. However you can *ungroup* the array and send its
    contents as individual arguments, as shown in the next listing:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，如果你已经有一个数组，你不能直接将其传递给`findDuplicates`函数，因为它只有一个数组，并且正在寻找数组的重复项。然而，你可以*取消分组*数组，并将它的内容作为单独的参数发送，如下一个列表所示：
- en: Listing 23.3\. Ungrouping parameters using spread
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.3\. 使用展开取消分组参数
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* [“a”, “c”]**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [“a”, “c”]**'
- en: Again, this doesn’t need to be an array to use spread; it can be any iterable
    such as a string (or `Map` or `Set`, which you will learn about later in this
    unit), as shown in the following listing and [figure 23.1](kindle_split_036_split_003.xhtml#ch23fig01).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这不需要是一个数组来使用展开；它可以是一个任何可迭代的对象，例如一个字符串（或`Map`或`Set`，你将在本单元的后面学习到），如下面的列表和[图23.1](kindle_split_036_split_003.xhtml#ch23fig01)所示。
- en: Listing 23.4\. Ungrouping parameters using spread
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.4\. 使用展开取消分组参数
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* [“a”, “c”]**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [“a”, “c”]**'
- en: Figure 23.1\. The rest-spread relationship
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图23.1\. rest-spread关系
- en: '![](Images/23fig01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/23fig01.jpg)'
- en: 'Spread isn’t limited to function arguments, either. It can also be used to
    spread an iterable across an array literal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 展开不仅限于函数参数，它还可以用来将可迭代的对象展开到数组字面量中：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* [“I”, “s”, “a”, “a”, “c”, “k”, “s”]**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [“I”, “s”, “a”, “a”, “c”, “k”, “s”]**'
- en: 'It doesn’t have to be the only item, either, and unlike rest, it doesn’t even
    need to be the last item:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它也不必是唯一的项，而且与剩余参数不同，它甚至不需要是最后一个项：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* [ “1”, “2”, “3”, “ABC” ]**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [ “1”, “2”, “3”, “ABC” ]**'
- en: 'You can even combine multiple spread operators together:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将多个展开操作符组合在一起：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* 26**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 26**'
- en: Notice how we’re spreading an array and spreading a string. It doesn’t matter
    what type they are, just that they’re both iterables. The result is a new array
    with all 26 letters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何展开一个数组和展开一个字符串的。它们可以是任何类型，只要它们都是可迭代的。结果是包含所有26个字母的新数组。
- en: 23.3.1\. Using spread as an immutable push
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.3.1\. 使用展开操作作为不可变推送
- en: 'This technique can be used as an immutable form of `Array.prototype.push`.
    Sometimes you may want to add something to an array, but instead of modifying
    the original array, get a copy with the value added. This is a common technique
    in libraries such as Redux.js, where you must take the existing state and some
    data and derive the next state without modifying the existing state. If the existing
    state is an array, and you want to add an item to the array, using `push` would
    modify the existing state (the current array), which could cause bugs. But you
    can use spread to copy an existing array into a new array with the new item:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以用作`Array.prototype.push`的不可变形式。有时你可能想向数组中添加一些内容，但不是修改原始数组，而是获取一个包含新值的副本。这在像Redux.js这样的库中是一个常见的技巧，在那里你必须获取现有状态和一些数据，并推导出下一个状态，而不修改现有状态。如果现有状态是一个数组，并且你想向数组中添加一个项目，使用`push`会修改现有状态（当前数组），这可能会导致错误。但你可以使用展开操作将现有数组复制到一个包含新项目的新数组中：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This would create a new array and leave the previous array untouched. In order
    to achieve this using `push`, you would have to first create a copy of the array,
    then push to the copy, then return the copy:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新数组，而不会触及原始数组。为了使用`push`实现这一点，你必须首先创建数组的副本，然后向副本中推送，然后返回副本：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice how much more concise the version using spread is. You can make an operation
    like this even more expressive with use of an arrow function like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用展开操作的这个版本是多么简洁。你可以使用箭头函数等来使这种操作更加表达性：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here it looks as if you were merely describing what the function does. In fact,
    this description is actually the implementation as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来你只是在描述函数的功能。实际上，这个描述本身就是实现。
- en: 'You can also use this technique to make a shallow copy of an array. This is
    really useful if you need to perform some destructive actions on an array but
    don’t want to alter the original array:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用这种技术来创建数组的浅拷贝。如果你需要对数组执行一些破坏性操作，但又不想修改原始数组，这非常有用：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the capstone of [unit 1](kindle_split_012.xhtml#part01) you wrote some helper
    functions, `createTag` and `interlace`, to make creating tagged template functions
    much easier. You used them both to create a tagged template function called `htmlSafe`.
    The original code is repeated in the next listing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[单元1](kindle_split_012.xhtml#part01)的总结中，你编写了一些辅助函数，`createTag`和`interlace`，以使创建标记模板函数变得更加容易。你使用它们两个创建了一个名为`htmlSafe`的标记模板函数。原始代码在下一列表中重复。
- en: Listing 23.5\. Original functions from unit 1 capstone
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.5\. 单元1总结中的原始函数
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* This whole function is just to abstract away how you’re grouping all
    but the first parameter.**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 整个函数只是为了抽象出如何分组除了第一个参数之外的所有参数。**'
- en: '***2* Get a copy of the vals array.**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取`vals`数组的副本。**'
- en: '***3* Put the string template together.**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 组合字符串模板。**'
- en: '***4* HTML escape all the interpolated values.**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 对所有插值值进行HTML转义。**'
- en: '***5* Example usage**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 示例用法**'
- en: We now have some tools that could make this much easier. You reimplement the
    same functionality using spread and rest, as shown in the following listing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一些工具可以使这变得更加容易。你使用展开操作和剩余参数重新实现了相同的功能，如下列表所示。
- en: Listing 23.6\. Updated functions from unit 1 capstone
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表23.6\. 单元1总结中更新的函数
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Copying the array using spread instead of slice**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用展开操作而非切片复制数组**'
- en: '***2* Using rest to gather values**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用剩余参数收集值**'
- en: You were now able to condense this down quite a bit. In the `interlace` function,
    You used spread to make a copy of `vals` instead of `slice`. Also by using rest
    to gather the parameters, you didn’t even need the `createTag` function anymore.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你能够将这段代码大大简化。在`interlace`函数中，你使用展开操作来复制`vals`而不是使用`slice`。通过使用剩余参数来收集参数，你甚至不再需要`createTag`函数。
- en: 'While you’re at it, use default function parameters to remove the need to map
    all your values before passing them to your reducer:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，使用默认函数参数来消除在将值映射到你的reducer之前的需求：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here you made `interlace` take a third parameter, called `processer`, that defaults
    to `String`, and used that for each value in the reducer. By doing that, calling
    the `interlace` function with only two parameters works just the same as before,
    but calling it with a third parameter (in this case `htmlEscape`) will instead
    run that function on each value in the reducer. This eliminates the need to iterate
    the entire list of values before reducing them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你让 `interlace` 函数接受一个第三个参数，称为 `processer`，默认值为 `String`，并使用它来处理每个 `reducer`
    中的值。通过这样做，只用两个参数调用 `interlace` 函数的效果与之前相同，但使用第三个参数（在这种情况下为 `htmlEscape`）将代替在 `reducer`
    中的每个值上运行该函数。这样就消除了在减少之前迭代整个值列表的需要。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 23.2**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 23.2**'
- en: '**[Q1:](kindle_split_036_split_003.xhtml#ch23qa4q0a1)**'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_036_split_003.xhtml#ch23qa4q0a1)**'
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will the following lengths be in the logs?
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 日志中以下长度将会是多少？
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 23.2 answer**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 23.2 答案**'
- en: '**[A1:](kindle_split_036_split_003.xhtml#ch23qa3q1)**'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_036_split_003.xhtml#ch23qa3q1)**'
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '3'
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3'
- en: '1'
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '1'
- en: '3'
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '3'
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 23.4\. Iterators—looking under the hood of iterables
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.4\. 迭代器——查看可迭代对象的内部
- en: Any object with an `@@iterator`^([[1](kindle_split_036_split_004.xhtml#ch23fn01)])
    property that follows the iterator protocol is an iterable. That is to say, an
    object becomes iterable when it has the property `@@iterator` pointing to another
    object that’s an iterator.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有 `@@iterator` 属性且遵循迭代器协议的对象都是可迭代的。也就是说，一个对象成为可迭代的，当它有一个 `@@iterator` 属性指向另一个对象，而这个对象是一个迭代器。
- en: ¹
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The terminology `@@name` is a shorthand way to describe a property symbol of
    `name`. If an object is said to have the property `@@foo`, that is a shorthand
    way of saying it has the property `Symbol.foo`.
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 术语 `@@name` 是描述 `name` 属性符号的简写方式。如果一个对象被说成有 `@@foo` 属性，那么这是一个简写方式，表示它有 `Symbol.foo`
    属性。
- en: The purpose of an iterator is to produce a series of values. An iterator needs
    to be able to give each value in order, one at a time. It also needs to know when
    it has finished, so it can stop trying to produce values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的目的是生成一系列值。迭代器需要能够按顺序逐个提供每个值。它还需要知道何时完成，以便停止尝试生成值。
- en: An iterator is an object that implements a `next` function. The `next` function
    must return an object with the two properties, `value` and `done`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一个实现了 `next` 函数的对象。`next` 函数必须返回一个具有两个属性的对象，`value` 和 `done`。
- en: The `done` property indicates whether or not the iterator has completed iterating
    its properties. The spread operator and `for..of` will both continue to call `next`
    on an iterator until it specifies it has no more values by setting `done` to `true`.
    You never have to set `done` to `true`; but it’s perfectly valid to make an infinite
    value iterator. But it’s ill-advised to use spread or `for..of` on an infinite
    iterator, as it will never complete.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`done` 属性表示迭代器是否已经完成了其属性的迭代。展开操作符和 `for..of` 都会继续在迭代器上调用 `next`，直到它通过将 `done`
    设置为 `true` 来指定没有更多值。你永远不需要将 `done` 设置为 `true`；但创建一个无限值迭代器是完全合法的。但是，不建议在无限迭代器上使用展开操作符或
    `for..of`，因为它永远不会完成。'
- en: The `value` property returned from `next` indicates the next value that the
    iterator is producing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `next` 返回的 `value` 属性表示迭代器正在生成的下一个值。
- en: 'Think about the example where you use spread to get an array of characters
    from a string:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你使用展开操作符从一个字符串中获取字符数组示例：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* [ “I”, “s”, “a”, “a”, “c”, “k”, “s”]**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [ “I”, “s”, “a”, “a”, “c”, “k”, “s”]**'
- en: It’s the string’s `@@iterator` that produces those values, not the string itself.
    It’s because the string has this `@@iterator` property that the string is an iterable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 是字符串的 `@@iterator` 产生了这些值，而不是字符串本身。正是因为字符串有这个 `@@iterator` 属性，字符串才成为可迭代的。
- en: That is to say, to make an object iterable, it must have an `@@iterator` method
    that returns a new iterator object.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，为了使一个对象可迭代，它必须有一个返回新迭代器对象的 `@@iterator` 方法。
- en: 'Next you’ll create a function that you can use as an object’s `@@iterator`.
    That means the function needs to return a new object with a `next` method, and
    the `next` method needs to return another object with `done` and `value` properties.
    Start with a simple iterator that just produces the first three prime numbers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个可以作为对象 `@@iterator` 的函数。这意味着该函数需要返回一个新的对象，该对象有一个 `next` 方法，并且 `next`
    方法需要返回另一个具有 `done` 和 `value` 属性的对象。从一个简单的迭代器开始，它只生成前三个素数：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now create an iterable that uses this as its iterator:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个使用此作为其迭代器的可迭代对象：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* [2, 3, 5]**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [2, 3, 5]**'
- en: 'This works but it was a pretty cumbersome way to create an iterator. There’s
    a much easier way. You may have even already picked up on it. In the functions
    unit, we already covered a type of function that returns objects with `next` and
    `done` properties: the generator function. The fact is that a generator is both
    an iterator and an iterable. That means you can iterate a generator directly or
    use it as an `@@iterator` property to make another object an iterable.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，但这是一个相当繁琐的创建迭代器的方式。有一个更简单的方法。你可能甚至已经注意到了。在函数单元中，我们已经介绍了一种返回具有`next`和`done`属性的对象的函数类型：生成器函数。事实上，生成器既是迭代器也是可迭代的。这意味着你可以直接迭代生成器，或者将其用作`@@iterator`属性，使另一个对象成为可迭代的。
- en: 'Recreate the same iterator using a generator function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成器函数重新创建相同的迭代器：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* [2, 3, 5]**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [2, 3, 5]**'
- en: 'Wow, that was much easier! But because the generator is also an iterable itself,
    you can use it directly without having to set it as a `Symbol.iterator` first:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这容易多了！但是因为生成器本身也是一个可迭代的，所以你可以直接使用它，而无需首先将其设置为`Symbol.iterator`：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* [2, 3, 5]**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [2, 3, 5]**'
- en: Here you just created a simple iterator using a generator to understand how
    it works. However, the possibilities are endless for how you can use generators
    to create custom iterators.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你只是使用生成器创建了一个简单的迭代器来理解它是如何工作的。然而，你可以使用生成器创建自定义迭代器的可能性是无限的。
- en: 'Let’s go back to the string. When iterated it produces each character in a
    series. But why each character? Why not each word? This isn’t actually a decision
    that the string makes; it’s decided by the default iterator that the string uses.
    Override a string’s iterator with your own that produces words instead of characters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到字符串。当你迭代它时，它会按顺序产生每个字符。但为什么是每个字符？为什么不是每个单词？这实际上不是字符串做出的决定；这是由字符串使用的默认迭代器决定的。用你自己的产生单词而不是字符的迭代器覆盖字符串的迭代器：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* [“Iterables”, “are”, “quite”, “something”]**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [“可迭代对象”，是，“相当”的东西]**'
- en: Here you created a string. You wrapped it in an `Object` invocation to create
    an object string; otherwise when you update a property it won’t stick around.
    You then set the string’s `@@iterator` to your own that naively produces words
    instead of characters. Now when you spread the string, you get an array of words!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你创建了一个字符串。你用`Object`调用将其包装起来以创建一个对象字符串；否则，当你更新一个属性时，它不会保留。然后你将字符串的`@@iterator`设置为你的自己的，它天真地产生单词而不是字符。现在当你展开字符串时，你会得到一个单词数组！
- en: 'Be careful when overriding an object’s `@@iterator`. If you try to iterate
    the object within its own iterator, you’ll create an endless loop! Let’s look
    at an example. Say you want to create an array that, when iterated, produces its
    values in reverse order. You might try something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写对象的`@@iterator`时要小心。如果你尝试在其自己的迭代器中迭代对象，你会创建一个无限循环！让我们看看一个例子。比如说，你想创建一个数组，当你迭代它时，它会以相反的顺序产生其值。你可能尝试这样做：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Oops, you’re trying to iterate yourself within your iterator!**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 哎呀，你正在尝试在你的迭代器中迭代你自己！**'
- en: '***2* Uncaught RangeError: maximum call stack size exceeded**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 未捕获的RangeError：超出最大调用栈大小**'
- en: You see, what’s happening here is that within the iterator, you use `[ ...this
    ]`, which in turn tries to iterate `this` to get the values. This in turn must
    use the iterator, but you’re already in the iterator, so it’s a recursive call!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，这里发生的事情是在迭代器内部，你使用了`[ ...this ]`，这反过来又尝试迭代`this`以获取值。这反过来又必须使用迭代器，但你已经在迭代器内部了，所以这是一个递归调用！
- en: 'Oftentimes you’ll find yourself wanting to iterate an object’s keys and values.
    It’s pretty simple to iterate one or the other using either `for..in` or `for..of`.
    But to iterate both, most people resort to code that looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 经常你会发现你想迭代一个对象的键和值。使用`for..in`或`for..of`迭代一个或另一个很简单。但要同时迭代两者，大多数人会求助于看起来像这样的代码：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here you’re iterating the object’s keys and then using each key to get the
    appropriate value. This isn’t very elegant. You can use a generator to create
    an iterator that iterates both:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你正在迭代对象的键，然后使用每个键来获取相应的值。这并不很优雅。你可以使用生成器创建一个迭代器，它同时迭代这两个：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This generator takes an object and `yield`s an array of the property name and
    property value for each property. You can use it like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器接受一个对象，并为每个属性`yield`s一个包含属性名和属性值的数组。你可以这样使用它：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here you’re using `for..of` to iterate the key/value pairs. You then use array
    destructuring to grab those values directly. Pretty neat!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你使用`for..of`来迭代键/值对。然后你使用数组解构来直接获取这些值。相当不错！
- en: 'Let’s say you’re building a social app that allows friends to like status updates.
    You want to list which friends have liked something. You already have a function
    called `sentenceJoin` that takes a list of names and joins them for use in a sentence:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个社交应用，允许朋友点赞状态更新。你想要列出哪些朋友点赞了某些内容。你已经有一个名为`sentenceJoin`的函数，它接受一个名字列表并将它们连接起来用于句子：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* JD and Christina**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* JD和Christina**'
- en: '***2* JD, Christina, Talan, and Jonathan**'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* JD，Christina，Talan和Jonathan**'
- en: 'The problem is that if the list of names is very long, you only want to list
    the first two names, then the number of remaining friends. You can create an iterator
    for that like so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果名字列表非常长，你只想列出前两个名字，然后是剩余的朋友数量。你可以创建一个迭代器来做到这一点，如下所示：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now you can format your friends list like so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以这样格式化你的朋友列表：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* JD, Christina, and two others liked this.**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* JD，Christina和两位其他人喜欢这个。**'
- en: The iterable and iterator protocal set a foundation for supporting all kinds
    of iterable objects. In this lesson we primarily looked at strings, arrays, and
    custom iterables. In the rest of this unit we’ll look at completely new iterables.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代和迭代器协议为支持所有类型的可迭代对象奠定了基础。在本课中，我们主要探讨了字符串、数组和自定义可迭代对象。在本单元的其余部分，我们将探讨全新的可迭代对象。
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 23.3**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 23.3**'
- en: '**[Q1:](kindle_split_036_split_004.xhtml#ch23qa6q0a1)**'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_036_split_004.xhtml#ch23qa6q0a1)**'
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do you make an object an iterable?
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使一个对象成为可迭代的？
- en: Is a generator object an iterable or an iterator?
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器对象是可迭代的还是迭代器？
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 23.3 answer**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 23.3 答案**'
- en: '**[A1:](kindle_split_036_split_004.xhtml#ch23qa5q1)**'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_036_split_004.xhtml#ch23qa5q1)**'
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By setting its `@@iterator` (`Symbold.iterator`) property.
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过设置其`@@iterator`（`Symbol.iterator`）属性。
- en: It’s both.
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它既是。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this lesson, you learned the basics of how to use and create your own iterables
    and iterators.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何使用和创建自己的可迭代对象和迭代器的基础知识。
- en: An iterable is an object with an `@@iterator` property.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代是一个具有`@@iterator`属性的对象。
- en: The `@@iterator` property must be a function that returns new iterator objects.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@@iterator`属性必须是一个返回新迭代器对象的函数。'
- en: An iterator object must have a `next` method.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器对象必须有一个`next`方法。
- en: The `next` method on an iterator object must return an object with `value` and/or
    `done` properties.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器对象的`next`方法必须返回一个包含`value`和/或`done`属性的对象。
- en: The `value` property is the next value of the iterable.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`属性是可迭代对象的下一个值。'
- en: The `done` property indicates whether or not all the values have been iterated.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done`属性指示是否已迭代所有值。'
- en: 'Let’s see if you got this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否明白了：
- en: '**[Q23.1](kindle_split_050_split_016.xhtml#app01qa16q0a1)**'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q23.1](kindle_split_050_split_016.xhtml#app01qa16q0a1)**'
- en: ''
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As we discussed, using spread on an infinite iterable would break, because
    it would continue to ask for values and never stop. Write a function called `take`
    that accepts two parameters: `n` the number of items to take, and `iterable` the
    iterable object to take the items from. Create an infinite iterable and take the
    first 10 values from it. Bonus points if `take` stops early if the iterable runs
    out of values before `n` has been reached.'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如我们讨论的，在无限可迭代对象上使用展开操作会导致中断，因为它会继续请求值而永远不会停止。编写一个名为`take`的函数，它接受两个参数：`n`表示要获取的项目数量，`iterable`表示从中获取项目的可迭代对象。创建一个无限可迭代对象，并从中获取前10个值。如果`take`在`n`达到之前可迭代对象就耗尽了值，则加分。
- en: Lesson 24\. Sets
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第24课\. 集合
- en: After reading [lesson 24](kindle_split_037_split_000.xhtml#ch24), you will
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完[第24课](kindle_split_037_split_000.xhtml#ch24)后，你将
- en: Know how to use and create sets
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用和创建集合
- en: Know how to perform array operations on sets
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在集合上执行数组操作
- en: Understand when to use arrays and when to use sets
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解何时使用数组，何时使用集合
- en: Understand what WeakSets are and when to use them
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解WeakSets是什么以及何时使用它们
- en: '`Set`s are a new type of object in JavaScript. A set is a unique collection
    of data. It can store any data type but won’t store duplicate references to the
    same value. Sets are iterables, so you can use spread and `for..of` with them.
    Sets are most closely related to arrays; however, when you use an array your focus
    is generally on the individual items in the array. When dealing with a set, you’re
    usually dealing with the set as a whole.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`是JavaScript中的一种新类型对象。集合是一组唯一的数据。它可以存储任何数据类型，但不会存储对同一值的重复引用。集合是可迭代的，因此你可以使用展开操作符和`for..of`与它们一起使用。集合与数组最为接近；然而，当你使用数组时，你的焦点通常是数组中的单个项目。当处理集合时，你通常是将集合作为一个整体来处理。'
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Imagine you’re building a video game where the player starts with a set of skills
    and as the player encounters new skills, they’re added to the player’s skill set.
    How would you make sure that the player never ends up with duplicate skills?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在制作一个视频游戏，玩家开始时有一组技能，随着玩家遇到新的技能，这些技能会被添加到玩家的技能集中。你将如何确保玩家不会最终拥有重复的技能？
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 24.1\. Creating sets
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.1\. 创建集合
- en: 'There’s no literal version of a `Set`, such as `[ ... ]` for arrays or `{ ...
    }` for objects, so sets must be created using the `new` keyword like so:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 没有集合的文本表示形式，例如数组或对象的 `[ ... ]` 或 `{ ... }`，因此必须使用 `new` 关键字如下创建集合：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Additionally, if you want to create a set with some initial values, you can
    use an iterable as the first (and only) parameter:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想创建一个具有一些初始值的集合，你可以使用可迭代作为第一个（也是唯一一个）参数：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now this set will have three strings as initial values. Whenever you use an
    iterable as the parameter, the iterable’s individual values get added as items
    in the set, not the iterable itself:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个集合将具有三个字符串作为初始值。每次你使用可迭代参数时，可迭代参数的各个值都会作为集合中的项添加，而不是可迭代本身：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Set {“A”, “E”, “I”, “O”, “U”}**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 集合 {“A”， “E”， “I”， “O”， “U”}**'
- en: 'The string “AEIOU” is an iterable for the letters A-E-I-O-U, so the set ends
    up containing those five individual characters as separate values, not the entire
    string as a single value. If you want to initialize a `Set` with a single string
    value, you can do so by putting it in an `Array`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 “AEIOU” 是 A-E-I-O-U 字母的可迭代，因此集合最终包含这五个单独的字符作为不同的值，而不是整个字符串作为一个单一值。如果你想用一个单个字符串值初始化一个
    `Set`，你可以通过将其放入 `Array` 中来实现：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Set {“AEIOU”}**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 集合 {“AEIOU”}**'
- en: 'You can even use another set as the iterable argument to create a new set.
    This is actually a convenient way of cloning or making a copy of an existing set:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以使用另一个集合作为可迭代参数来创建一个新的集合。这实际上是一种方便的克隆或复制现有集合的方法：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the iterable passed as an argument to the set constructor has any duplicate
    values, they’ll be ignored and only the first occurrence of each value will be
    used:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给集合构造函数的可迭代参数有任何重复值，它们将被忽略，并且只使用每个值的第一个出现：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Set {“red”, “black”, “green”}**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 集合 {“red”， “black”， “green”}**'
- en: 'If you create a set with a non-iterable argument, an error will be thrown:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用一个非可迭代参数创建一个集合，将会抛出一个错误：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Uncaught TypeError: undefined is not a function**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 未捕获的类型错误：undefined 不是一个函数**'
- en: You get this error because the number `36` has no `Symbol.iterator` function.
    The error is confusing, but when a `Set` is initialized with a value, the first
    thing it does is try to iterate the value using its `Symbol.iterator`. If the
    value given doesn’t have an `@@iterator` (as a number doesn’t), you get the vague
    *undefined is not a function* error.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到这个错误是因为数字 `36` 没有具有 `Symbol.iterator` 函数。错误很令人困惑，但当一个 `Set` 用一个值初始化时，它首先尝试使用其
    `Symbol.iterator` 迭代该值。如果给定的值没有 `@@iterator`（例如，数字没有），你会得到一个模糊的 *undefined 不是一个函数*
    错误。
- en: 'If you want to initialize a `Set` with a single number in it, just wrap the
    number in an `Array` like so:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用一个数字初始化一个包含单个数字的 `Set`，只需像这样用 `Array` 包裹数字：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Set {36}**'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 集合 {36}**'
- en: Now that you know how to create a set, in the next section we’ll turn our focus
    to using them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建集合，在下一节中，我们将转向如何使用它们。
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 24.1**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 24.1**'
- en: '**[Q1:](kindle_split_037_split_001.xhtml#ch24qa2q0a1)**'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_037_split_001.xhtml#ch24qa2q0a1)**'
- en: ''
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What will be the difference between the following two sets?
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下两个集合之间的区别是什么？
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 24.1 answer**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 24.1 答案**'
- en: '**[A1:](kindle_split_037_split_001.xhtml#ch24qa1q1)**'
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_037_split_001.xhtml#ch24qa1q1)**'
- en: ''
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Set {“H”, “e”, “l”, “o”}
  id: totrans-253
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合 {“H”， “e”， “l”， “o”}
- en: Set {“Hello”}
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集合 {“Hello”}
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 24.2\. Using sets
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.2\. 使用集合
- en: Most of the time, an array is good enough. But if you find yourself needing
    a unique list of things, you may want to use a set. You should also make your
    decision based on what you want to do with the list of items. If the operations
    you want to perform on the list are more array-centric, such as interacting with
    elements at specific indices or using a method like `splice`, you probably want
    to use an array. But if you find the API of `Set` more in alignment with the operations
    you want to perform, such as adding, checking for presence, and removing based
    on value (as opposed to index), then `Set` is probably your choice. If you find
    you need a mix of both, it’s probably easier to use a set and convert it to an
    array whenever you need to perform an array operation on it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，数组就足够了。但如果你发现自己需要一组独特的事物，你可能想使用一个集合。你也应该根据你想要对项目列表执行的操作来做出决定。如果你想要在列表上执行的操作更偏向于数组，例如与特定索引的元素交互或使用像
    `splice` 这样的方法，那么你可能想使用数组。但如果你发现 `Set` 的 API 与你想要执行的操作更一致，例如添加、检查是否存在以及基于值（而不是索引）删除，那么
    `Set` 可能是你的选择。如果你发现自己需要两者的混合，那么在需要对该集合执行数组操作时将其转换为数组可能更容易。
- en: 'Let’s imagine you’re building a video game that allows a character to move
    across an area. You render the area using a series of tiles. Every time the character
    moves, you’re given a new set of tiles to render to draw the current state of
    the game. But to speed up the render time of your game, at each frame you only
    want to render those tiles which are not already painted on the screen. If you
    have the currently rendered tiles stored in a set, you can check if they’re already
    rendered using `Set.prototype.has` like so:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象你正在制作一个允许角色在区域内移动的视频游戏。你使用一系列瓦片来渲染区域。每次角色移动时，你会得到一组新的瓦片来渲染，以绘制游戏的当前状态。但为了加快游戏的渲染时间，在每一帧中，你只想渲染那些尚未绘制到屏幕上的瓦片。如果你有一个当前渲染的瓦片集合存储，你可以使用
    `Set.prototype.has` 来检查它们是否已经渲染，如下所示：
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here you have a set named `frame` and you’re using `.has()` to determine if
    the tile has already been drawn to the screen. Of course, once you paint the tile
    to the screen, you will want to add it to the set to remember that this tile is
    painted for the next frame. You can do so using `Set.prototype.has` like so:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有一个名为 `frame` 的集合，你正在使用 `.has()` 来确定瓦片是否已经被绘制到屏幕上。当然，一旦你将瓦片绘制到屏幕上，你将希望将其添加到集合中，以便记住这个瓦片在下一帧已经被绘制。你可以使用
    `Set.prototype.has` 如下操作：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now you would also want to remove any frames that are no longer being drawn
    on the current frame. So you would need to delete all the tiles from your set
    that are no longer being drawn, as well as add all the new tiles that need to
    be drawn. Write a function that does this for you, as shown in the next listing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你也会想要删除那些在当前帧上不再绘制的帧。因此，你需要从你的集合中删除所有不再绘制的瓦片，以及添加所有需要绘制的新的瓦片。编写一个函数来为你完成这项工作，如下一个列表所示。
- en: Listing 24.1\. Drawing the next frame
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 24.1\. 绘制下一帧
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Use for..of to iterate all the tiles that make up the current frame.**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 for..of 来迭代组成当前帧的所有瓦片。**'
- en: '***2* Check if the next frame has a given tile.**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查下一帧是否有指定的瓦片。**'
- en: '***3* Remove the tile if the next frame does contain it.**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果下一帧包含该瓦片，则移除它。**'
- en: '***4* Use for..of to iterate all of the next frame’s tiles.**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 for..of 来迭代下一帧的所有瓦片。**'
- en: '***5* Check if the current frame doesn’t yet have the tile.**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 检查当前帧是否尚未包含该瓦片。**'
- en: '***6* Add the tile if the current frame doesn’t already contain it.**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果当前帧尚未包含该瓦片，则添加它。**'
- en: OK, let’s imagine that as your player travels around, they can collect new quests.
    If the player already has a quest in their quest book, you don’t want to add a
    duplicate. If you were using an array, you would have to come up with a strategy
    to ensure that no duplicate quests get added, but if you were using a set, you
    would get that functionality for free.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们想象一下，当你的玩家在游戏中四处旅行时，他们可以收集新的任务。如果玩家已经在他们的任务书中有一个任务，你不希望添加重复的任务。如果你使用数组，你必须想出一个策略来确保不会添加重复的任务，但如果你使用集合，你会免费获得这个功能。
- en: 'If you want to give an indicator letting the player know how many quests they
    have, you could use `Set.prototype.size`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要提供一个指示器，让玩家知道他们有多少个任务，你可以使用 `Set.prototype.size`：
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The property `Set.prototype.size` is equivalent to the `length` property of
    a string or an array. Additionally the method `add` that you’ve been using is
    very similar to the `push` method of an array, which adds an item to the end of
    the array’s list of items. But the `delete` function has no array counterpart.
    You can easily remove an item from an array using `pop` or `shift`. (`pop` removes
    and returns the last item from the array; `shift` removes and returns the first
    item, which also causes all the other items indices to shift down by one.) But
    these functions delete values based on their position, last and first, respectively.
    The `delete` method of a set specifies to delete a specific value from the set,
    no matter its position. This concept wouldn’t carry over to arrays easily because
    an array could have the specific value in more than one location. You could convert
    an array to set and then use `delete` to remove the item, but it would have the
    side effect of also uniquing the array, which may not be desired. On the flip
    side, sets have no equivalent methods for `pop` or `shift`. But sets do maintain
    insertion order, so you could easily convert a set to an array to get the first
    or last item:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 `Set.prototype.size` 等同于字符串或数组中的 `length` 属性。此外，你一直在使用的 `add` 方法与数组的 `push`
    方法非常相似，它将项目添加到数组的末尾项目列表中。但是，`delete` 函数没有数组对应的函数。你可以很容易地使用 `pop` 或 `shift` 从数组中删除一个项目。（`pop`
    会删除并返回数组中的最后一个项目；`shift` 会删除并返回第一个项目，这也会导致其他所有项目的索引下移一个位置。）但是，这些函数是基于位置删除值的，分别是最后一个和第一个。集合的
    `delete` 方法指定从集合中删除一个特定的值，无论其位置如何。这个概念不容易应用到数组上，因为数组可能包含多个位置上的特定值。你可以将数组转换为集合，然后使用
    `delete` 删除项目，但这会产生副作用，即也会使数组去重，这可能不是你想要的。另一方面，集合没有 `pop` 或 `shift` 的等效方法。但是，集合确实维护插入顺序，因此你可以很容易地将集合转换为数组以获取第一个或最后一个项目：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When you use spread with a `Set` like `[ ...set ]`, we’re creating a new `Array`
    with all the individual values from the set used as items in the array. This function
    would return the last item in a set, but it wouldn’t remove it because using spread
    on an iterable does not alter the iterable. The newly created array would have
    its last item removed, but not the set. To also remove the last item from the
    set, you would have to make sure you `delete` it from the set as well:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用扩展操作符与 `Set` 一起使用，如 `[ ...set ]`，我们正在创建一个新的 `Array`，其中包含集合中所有单独的值作为数组的项目。这个函数会返回集合中的最后一个项目，但不会删除它，因为使用扩展操作符对可迭代对象不会改变可迭代对象。新创建的数组会删除其最后一个项目，但集合不会。要同时从集合中删除最后一个项目，你必须确保你也从集合中
    `delete` 它：
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Making a `shift` function would be as simple as internally using `shift` instead
    of `pop`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `shift` 函数就像在内部使用 `shift` 而不是 `pop` 一样简单：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Sets maintain their insertion order, and there’s no way to rearrange them,
    short of emptying them completely and adding back the items in a new order. Imagine
    you’re creating a game and storing a set of players. After each round, you want
    to put the first player in the last position to keep cycling which player goes
    first for each round. With an array, you could combine `shift` and `push` like
    so:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 集合维护其插入顺序，没有方法可以重新排列它们，除非完全清空并按新顺序添加项目。想象一下你正在创建一个游戏并存储一组玩家。在每一轮结束后，你想要将第一个玩家放到最后一个位置，以保持每一轮轮流确定哪个玩家先手。使用数组，你可以像这样组合
    `shift` 和 `push`：
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you wanted to create a new set with the new order, you could convert it
    to an array, set the order, and return a new set like so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个新的集合并具有新的顺序，你可以将其转换为数组，设置顺序，然后返回一个新的集合，如下所示：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If you needed to actually change the order of the existing set, you could do
    so by emptying out the entire set using `Set.prototype.clear`. But there’s no
    method to add multiple items to a set at once. In order to add the items back
    to the set after the order has been changed, your would need to add them back
    individually using `Set.prototype.add` like so:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要实际改变现有集合的顺序，你可以通过使用 `Set.prototype.clear` 清空整个集合来实现。但是，没有方法可以一次向集合中添加多个项目。在改变顺序后，为了将项目重新添加到集合中，你需要使用
    `Set.prototype.add` 逐个添加，如下所示：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* First get all the items from the set into an array.**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 首先将集合中的所有项目放入一个数组中。**'
- en: '***2* Remove all items from the set.**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从集合中删除所有项目。**'
- en: '***3* Reorder the array.**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 重新排序数组。**'
- en: '***4* Add the items back to the set in the new order.**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 以新的顺序将项目添加回集合。**'
- en: Now that you know how to use a set, in the next section we’ll take a look at
    when you might want to use a set versus an array, and vice versa.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用集合，在下一节中，我们将探讨你何时可能想要使用集合而不是数组，反之亦然。
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 24.2**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 24.2**'
- en: '**[Q1:](kindle_split_037_split_002.xhtml#ch24qa4q0a1)**'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_037_split_002.xhtml#ch24qa4q0a1)**'
- en: ''
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the fundamental difference between the array methods `Array.prototype.shift`,
    `Array.prototype.pop`, and the set method `Set.prototype.delete`?
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组方法 `Array.prototype.shift`、`Array.prototype.pop` 和集合方法 `Set.prototype.delete`
    之间的基本区别是什么？
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 24.2 answer**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 24.2 答案**'
- en: '**[A1:](kindle_split_037_split_002.xhtml#ch24qa3q1)**'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_037_split_002.xhtml#ch24qa3q1)**'
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The array methods `Array.prototype.shift` and `Array.prototype.pop` remove items
    based on their position (index) in the array, first and last, respectively. The
    set method `Set.prototype.delete` removes an item based on the value of the item
    itself.
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数组方法 `Array.prototype.shift` 和 `Array.prototype.pop` 分别基于数组中元素的（位置）索引（第一个和最后一个）来移除元素。集合方法
    `Set.prototype.delete` 基于元素的值本身来移除元素。
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 24.3\. What about the WeakSet?
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 24.3. 关于 `WeakSet` 呢？
- en: A `WeakSet` is a specialized type of `Set`. Its sole purpose is to contain objects
    *weakly* in the sense that it doesn’t prevent them from being garbage-collected.
    Normally if you add an object to an array and remove all other references to it,
    it will still not be eligible for garbage collection because the array still has
    a reference to the object. This is the same for sets as well. Sometimes you may
    want to store an object without preventing it from being garbage-collected, though.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakSet` 是 `Set` 的一种特殊类型。它的唯一目的是以 *弱引用* 的方式包含对象，这意味着它不会阻止它们被垃圾回收。通常情况下，如果你将一个对象添加到一个数组中，并移除对该对象的全部其他引用，它仍然不符合垃圾回收的条件，因为数组仍然持有对该对象的引用。对于集合来说也是如此。有时你可能想要存储一个对象，同时又不阻止它被垃圾回收。'
- en: 'Say you’re building an MMO (massively multiplayer online) game and want to
    use a set to determine which players are currently spawning to keep them from
    being killed while spawning. You could add them to a `spawning` set like so:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个大型多人在线（MMO）游戏，并想使用一个集合来确定哪些玩家目前正在生成，以防止他们在生成过程中被杀死。你可以像这样将它们添加到 `spawning`
    集合中：
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then anything else that tries to attack the player can first check if the player
    is currently spawning before adding damage to it:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，任何试图攻击玩家的东西都可以首先检查玩家是否目前正在生成，然后再向它添加伤害：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If spawning is a normal set, then if the player leaves the game or possibly
    looses their internet connection while spawning, you’ll need to make sure that
    you remove the player from the spawning set. That might not seem too difficult,
    but what happens if you have several sets that are keeping track of players for
    various reasons? Having to make sure you remove all references to the player when
    they exit the game can become a hassle. But if we used `WeakSet`s that wouldn’t
    be necessary, as the `WeakSet` doesn’t prevent an item from being garbage-collected.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成是一个普通的集合，那么如果玩家离开游戏或者在生成过程中可能丢失互联网连接，你需要确保从生成集合中移除玩家。这看起来可能并不困难，但如果你有多个集合，它们出于各种原因跟踪玩家，确保在玩家退出游戏时移除所有对玩家的引用可能会变得麻烦。但是，如果我们使用了
    `WeakSet`，那就没有必要了，因为 `WeakSet` 不会阻止一个元素被垃圾回收。
- en: In order to achieve this, a `WeakSet` has no reference to any of the items it
    contains. You have to already have a reference to the item in order to check if
    a `WeakSet` contains it. This is OK for our use case, as in your game you already
    have a player and want to check if that player is in the `spawning WeakSet`, so
    it works.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，`WeakSet` 对其包含的任何元素都没有引用。你必须已经有一个对该元素的引用，才能检查 `WeakSet` 是否包含该元素。这对于我们的用例来说是可行的，因为在你的游戏中，你已经有一个玩家，并想要检查该玩家是否在
    `spawning WeakSet` 中，所以它工作得很好。
- en: 'Because a `WeakSet` has no reference to its items, `WeakSet`s cannot be iterated.
    Thus, a `WeakSet` isn’t actually an iterable like the `Set` is. You can’t use
    `for..of` or spread on it. A `WeakSet` also can only contain object values: primitive
    values aren’t allowed, and trying to add one will throw an error.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `WeakSet` 对其项目没有引用，因此 `WeakSet` 不能被迭代。因此，`WeakSet` 并不是一个可迭代的集合，像 `Set` 一样。你不能在它上面使用
    `for..of` 或展开操作。`WeakSet` 也只能包含对象值：不允许原始值，尝试添加一个原始值将会抛出错误。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, you learned how to create and use sets and why you would use
    one over an array.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何创建和使用集合，以及为什么你会选择使用集合而不是数组。
- en: A set has a new literal and must be created using `new`.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个集合有一个新的字面量，并且必须使用 `new` 来创建。
- en: You can create a set using an iterable as an argument.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用可迭代对象作为参数来创建一个集合。
- en: You can clone a set by creating a new set with an existing set as an argument.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过创建一个新的集合并将现有的集合作为参数来克隆一个集合。
- en: Sets are iterables and thus can be used with spread and `for..of`.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合是可迭代的，因此可以使用展开和 `for..of`。
- en: You add a value to a set using `Set.prototype.add`.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `Set.prototype.add` 向集合中添加一个值。
- en: You can tell if a set has a value using `Set.prototype.has`.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `Set.prototype.has` 来判断一个集合是否包含某个值。
- en: You can remove a value from a set using `Set.prototype.delete`.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `Set.prototype.delete` 从集合中移除一个值。
- en: You can empty a set by using `Set.prototype.clear`.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `Set.prototype.clear` 来清空一个集合。
- en: You can determine how many items a set contains with `Set.prototype.size`.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `Set.prototype.size` 来确定一个集合包含多少项。
- en: A `WeakSet` is not an iterable.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakSet` 不是一个可迭代的。'
- en: A `WeakSet` can only contain objects.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakSet` 只能包含对象。'
- en: A `WeakSet` doesn’t prevent its contents from being garbage-collected.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakSet` 不能阻止其内容被垃圾回收。'
- en: A `WeakSet` has no way to inspect its contents.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakSet` 没有方法来检查其内容。'
- en: 'Let’s see if you got this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q24.1](kindle_split_050_split_017.xhtml#app01qa17q0a1)**'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q24.1](kindle_split_050_split_017.xhtml#app01qa17q0a1)**'
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Create the following helper functions to make dealing with sets even more useful:'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建以下辅助函数，使处理集合更加有用：
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`union`—A function that takes two sets and returns a new set with all the values
    from both sets'
  id: totrans-332
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`union`—一个函数，它接受两个集合，并返回一个新集合，其中包含两个集合的所有值'
- en: '`intersection`—A function that takes two sets and returns a new set with only
    the values that are in both sets'
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intersection`—一个函数，它接受两个集合，并返回一个新集合，其中只包含两个集合都有的值'
- en: '`subtract`—A function that takes two sets and returns a new set with all of
    the values from the first set, excluding any values that are in the second set'
  id: totrans-334
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtract`—一个函数，它接受两个集合，并返回一个新集合，其中包含第一个集合的所有值，但不包括第二个集合中的任何值'
- en: '`difference`—A function that takes two sets and returns a new set of only the
    values they aren’t in both sets (the opposite of intersection)'
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`difference`—一个函数，它接受两个集合，并返回一个新集合，其中只包含它们都不在的值（交集的相反）'
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go further. For more fun you can update these functions to work on any number
    of sets, not just two.
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更进一步。为了更有趣，你可以更新这些函数，使其能够处理任意数量的集合，而不仅仅是两个。
- en: Lesson 25\. Maps
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第25课\. Maps
- en: After reading [lesson 25](kindle_split_038_split_000.xhtml#ch25), you will
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完第25课（[lesson 25](kindle_split_038_split_000.xhtml#ch25)）后，你将
- en: Know to create a `Map`
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何创建 `Map`
- en: How to convert a plain object into a `Map`
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将普通对象转换为 `Map`
- en: How to add and access values on a `Map`
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 `Map` 上添加和访问值
- en: How to iterate the keys and values from a `Map`
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何迭代 `Map` 的键和值
- en: How `Map`s are destructured
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map` 的解构方式'
- en: Understand when it makes sense to use a `Map` over an `Object`
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解何时使用 `Map` 而不是 `Object` 更有意义
- en: Understand why it makes sense to use a `WeakMap` over a `Map`
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么使用 `WeakMap` 而不是 `Map` 更有意义
- en: Like `Set`s, `Map`s are a new type of object in JavaScript. Not to be confused
    with `Array.prototype.map`, which is a higher-order array method, `Map`s are another
    type of iterable that’s new to JavaScript in ES2015\. A `Map` is a lot like a
    generic object in JavaScript with *keys* and *values*. But a `Map` can be iterated,
    whereas an object can’t. Plain objects are also limited to only being able to
    have string values as keys;^([[1](kindle_split_038_split_000.xhtml#ch25fn01)])
    `Map`s, on the other hand, can have any datatype as a key, even another `Map`!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Set` 类似，`Map` 是 JavaScript 中的一种新类型对象。不要与 `Array.prototype.map` 混淆，后者是一个高阶数组方法，`Map`
    是 JavaScript 在 ES2015 中引入的另一种可迭代类型。`Map` 在 JavaScript 中类似于具有 *键* 和 *值* 的通用对象。但
    `Map` 可以被迭代，而对象不能。普通对象也仅限于只能将字符串值作为键；^([[1](kindle_split_038_split_000.xhtml#ch25fn01)])
    相反，`Map` 可以使用任何数据类型作为键，甚至可以是另一个 `Map`！
- en: ¹
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Technically, strings and symbols.
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 技术上，字符串和符号。
- en: '|  |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: When you need a container of data with no need for qualified identifiers for
    each datum, you may reach for an array. When you need to store data and be able
    to retrieve specific data based on a string identifier, you may reach for an object.
    But what if you need to retrieve data based on a more complex identifier such
    as a DOM node or something else that can’t be used as the key of an object? What
    do you reach for then?
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要一个不需要为每个数据项指定合格标识符的数据容器时，你可能需要使用数组。当你需要存储数据并能够根据字符串标识符检索特定数据时，你可能需要使用对象。但如果你需要根据更复杂的标识符（如DOM节点或其他不能用作对象键的东西）来检索数据，你该怎么办？
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 25.1\. Creating maps
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.1\. 创建映射
- en: 'As with `Set`s, there’s no literal version of a `Map` and they must be created
    using the `new` keyword like so:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Set`一样，没有`Map`的文本表示形式，它们必须使用`new`关键字创建，如下所示：
- en: '[PRE57]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Remember from the last lesson that you can instantiate a `Set` with a single
    array argument, to define the initial values for the set? You may be thinking
    that because a `Map` is a series of keys and values, you can instantiate a `Map`
    with initial values by passing in a single object parameter. This isn’t the case,
    though. But if you think about it, this makes sense. An array can contain any
    datatype that a set can, but an object’s keys are limited to strings, whereas
    a `Map`’s keys can be any datatype. So using an object as the initial parameter
    would limit what kind of keys you could use. Instead, to instantiate a `Map` with
    initial values, you use one large array containing smaller arrays of key/value
    pairs like so:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 记得上一课中你可以用一个数组参数实例化一个`Set`，以定义集合的初始值吗？你可能认为，因为`Map`是一系列键和值，你可以通过传递一个单个对象参数来使用初始值实例化一个`Map`。但这并不是事实。但是如果你这么想，这很有道理。数组可以包含任何集合可以包含的数据类型，但对象的键限于字符串，而`Map`的键可以是任何数据类型。所以，为了使用初始值实例化一个`Map`，你使用一个包含键/值对小数组的大的数组，如下所示：
- en: '[PRE58]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice how you used different types of objects as keys for your map: first
    a string, then a number, then a `RegExp` object. All these are valid keys for
    a map and they won’t get converted into strings like they would for an object.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你如何使用不同类型的对象作为映射的键：首先是一个字符串，然后是一个数字，接着是一个`RegExp`对象。所有这些都是映射的有效键，并且它们不会像对象那样被转换为字符串。
- en: 'If you do find yourself wanting to convert an `Object` into a `Map`, you can
    do it like so:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己想要将一个`Object`转换为`Map`，你可以这样做：
- en: '[PRE59]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here you used `Object.keys` to get an array of all the properties of `myObj`.
    You then used `Array.prototype.map` to covert the array of keys into an array
    of key/value pairs. The key/value pairs are then used as the argument to the `Map`
    constructor.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用了`Object.keys`来获取`myObj`的所有属性的数组。然后你使用了`Array.prototype.map`将键的数组转换为键/值对的数组。然后，键/值对被用作`Map`构造函数的参数。
- en: Don’t get confused or caught up in the fact that you’re using `Array.prototype.map`
    in conjunction with `Map`. The `map` method of an array is an action that maps
    values from one array to transformed values in a new array. The `Map` object,
    on the other hand, maps keys to values. It isn’t an action or transformation,
    but a data store that allows you to access values based on keys. You give a `Map`
    a key and get back a value; in a sense it maps the key to the value.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为你在使用`Array.prototype.map`与`Map`结合而感到困惑或陷入其中。数组上的`map`方法是将一个数组的值映射到新数组中转换后的值的一个操作。另一方面，`Map`对象将键映射到值。它不是一个操作或转换，而是一个数据存储，允许你根据键访问值。你给`Map`一个键，然后得到一个值；从某种意义上说，它将键映射到值。
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 25.1**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 25.1**'
- en: '**[Q1:](kindle_split_038_split_001.xhtml#ch25qa2q0a1)**'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_038_split_001.xhtml#ch25qa2q0a1)**'
- en: ''
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following are valid ways to create a new `Map`?
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪些是创建新`Map`的有效方式？
- en: ''
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 25.1 answer**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 25.1 答案**'
- en: '**[A1:](kindle_split_038_split_001.xhtml#ch25qa1q1)**'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_038_split_001.xhtml#ch25qa1q1)**'
- en: ''
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a and b are both invalid. c, d, and e are all valid.
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a和b都是无效的。c、d和e都是有效的。
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 25.2\. Using maps
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.2\. 使用映射
- en: At this point you may be asking, “But aren’t `Map`s just `Object`s too? Does
    JavaScript treat them differently from other objects?” To answer this question
    we first need to define some terms. In this lesson as I’ve been comparing `Map`s
    to `Object`s, I’ve been implying what’s commonly referred to as a *POJO (plain
    old JavaScript object)*, meaning a plain `Object` used as a data structure with
    its properties used as keys and values. A `Map`’s keys are not its properties.
    A `Map` extends from `Object` just like all other objects, and its properties
    must be strings. But a map stores its keys and values internally, not as properties,
    which is how it gets away with being able to use any datatype.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，你可能想知道：“但是`Map`不也是`Object`吗？JavaScript是否与其他对象不同对待它们？”为了回答这个问题，我们首先需要定义一些术语。在本课中，当我将`Map`与`Object`进行比较时，我一直在暗示通常所说的*POJO（纯旧JavaScript对象）*，这意味着一个用作数据结构的普通`Object`，其属性用作键和值。`Map`的键不是其属性。`Map`就像所有其他对象一样扩展自`Object`，并且其属性必须是字符串。但是映射内部存储其键和值，而不是作为属性，这就是它能够使用任何数据类型的原因。
- en: 'If you use `Object.keys` to get a map’s properties, you won’t get the keys
    that you set: instead you’ll get an empty array:^([[2](kindle_split_038_split_002.xhtml#ch25fn02)])'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `Object.keys` 来获取映射的属性，你不会得到你设置的键：相反，你会得到一个空数组:^([[2](kindle_split_038_split_002.xhtml#ch25fn02)])
- en: ²
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Even though the `Map` does have properties such as `size`, they aren’t listed
    because they’re on the `Map` prototype, not the specific instance.
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使 `Map` 确实有 `size` 等属性，但它们没有被列出，因为它们在 `Map` 原型上，而不是在特定实例上。
- en: '[PRE61]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Returns []**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 []**'
- en: 'If you do want to get a `Map`’s keys (not properties), you can use `Map.prototype.keys`
    like so:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想获取 `Map` 的键（不是属性），你可以像这样使用 `Map.prototype.keys`：
- en: '[PRE62]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* { “My First Key”, 3, /\S/g }**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* { “我的第一个键”，3，/\S/g }**'
- en: 'This doesn’t return an array of the keys; instead it returns an iterator that
    allows you to iterate the keys. But remember you can easily turn an iterator into
    an array if needed:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会返回键的数组；相反，它返回一个迭代器，允许你迭代键。但请记住，如果需要，你可以轻松地将迭代器转换为数组：
- en: '[PRE63]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* [ “My First Key”, 3, /\S/g ]**'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [ “我的第一个键”，3，/\S/g ]**'
- en: 'Maps also have `Map.prototype.values` for getting, you guessed it, the values.
    And likewise, it returns an iterator, not an array:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 映射也有 `Map.prototype.values` 用于获取，正如你所猜的，它返回一个迭代器，而不是数组：
- en: '[PRE64]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* { “My First Value”, “My key is a number!”, ... }**'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* { “我的第一个键”，3，/\S/g }**'
- en: Sets actually have both these methods as well. But both `Set.prototype.keys`
    and `Set.prototype.values` return the same thing, since a `Set` doesn’t use keys,
    only values. You’ll actually notice that the APIs of `Map` and `Set` are very
    consistent with each other but not identical. For example, they both have the
    `size` property as well as the methods shown in [table 25.1](kindle_split_038_split_002.xhtml#ch25table01)
    in common.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，集合（Set）也有这两种方法。但 `Set.prototype.keys` 和 `Set.prototype.values` 返回相同的内容，因为集合不使用键，只使用值。你实际上会注意到
    `Map` 和 `Set` 的 API 非常一致，但并不完全相同。例如，它们都有 `size` 属性以及 [表 25.1](kindle_split_038_split_002.xhtml#ch25table01)
    中显示的相同方法。
- en: Table 25.1\. Common methods shared by Map and Set
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 25.1\. Map 和 Set 共享的常见方法
- en: '| Method | Description |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| clear | Removes all values from the Map (or Set). |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| clear | 从映射（或集合）中移除所有值。 |'
- en: '| delete | Removes a specified value from the Map (or Set). |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| delete | 从映射（或集合）中移除指定的值。 |'
- en: '| entries | Returns an iterator for accessing all the keys and values. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| entries | 返回一个迭代器，用于访问所有键和值。 |'
- en: '| forEach | Similar to the same method on an Array. Loops over all the keys
    and values of a Map. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| forEach | 与数组上的相同方法类似。遍历映射的所有键和值。 |'
- en: '| has | Checks if a Map has a given key (or a Set has a given value). |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| has | 检查映射是否具有给定的键（或集合是否具有给定的值）。 |'
- en: '| keys | Returns an iterator for accessing all the keys. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| keys | 返回一个迭代器，用于访问所有键。 |'
- en: '| values | Returns an iterator for accessing all the values. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| values | 返回一个迭代器，用于访问所有值。 |'
- en: 'However, `Set` has the method `Set.prototype.add` for adding values and `Map`
    uses the confusingly named `Map.prototype.set` method for adding entries:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Set` 有 `Set.prototype.add` 方法用于添加值，而 `Map` 使用令人困惑的命名 `Map.prototype.set`
    方法来添加条目：
- en: '[PRE65]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`Map` also has the method `Map.prototype.get` for retrieving a value for a
    specific key:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 还有一个 `Map.prototype.get` 方法用于检索特定键的值：'
- en: '[PRE66]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* “My next value”**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “我的下一个值”**'
- en: '***2* undefined**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* undefined**'
- en: I am not sure why the TC39 committee went so far as to ensure that the API be
    consistent, even including a redundant `keys` method on `Set`, only to fall short
    and not actually have identical APIs.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定为什么 TC39 委员会走这么远，确保 API 的一致性，甚至包括在 `Set` 上包含冗余的 `keys` 方法，但最终却未能实现完全相同的
    API。
- en: It’s also worth noting that while the methods on `Set` deal with the values
    as parameters, such as `delete(value)`, `Map`s deal with keys such as `delete(key)`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然 `Set` 上的方法处理参数作为值，例如 `delete(value)`，但 `Map` 处理键，例如 `delete(key)`。
- en: '|  |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 25.2**'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 25.2**'
- en: '**[Q1:](kindle_split_038_split_002.xhtml#ch25qa4q0a1)**'
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_038_split_002.xhtml#ch25qa4q0a1)**'
- en: ''
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between the last two lines of code?
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后两行代码有什么区别？
- en: ''
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '|  |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 25.2 answer**'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 25.2 答案**'
- en: '**[A1:](kindle_split_038_split_002.xhtml#ch25qa3q1)**'
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_038_split_002.xhtml#ch25qa3q1)**'
- en: ''
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Object.keys(myMap)` returns the map’s own enumerable properties (it has none).'
  id: totrans-427
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.keys(myMap)` 返回映射的自身可枚举属性（它没有）。'
- en: '`myMap.keys()` returns the keys associated with the stored data (“a” and “b”).'
  id: totrans-428
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myMap.keys()` 返回与存储数据关联的键（“a”和“b”）。'
- en: '|  |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 25.3\. When to use maps
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.3\. 何时使用映射
- en: You may be asking, “Should I now use a `Map` anytime I need keys and values?”
    The answer is probably not. Most of the time you’ll still probably want to use
    regular objects. Regular objects are lighter-weight and more expressive when all
    you need is a structure to pass around values.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“我现在是否应该每次需要键和值时都使用`Map`？”答案可能是否定的。大多数时候，你可能仍然希望使用常规对象。当你需要传递值的结构时，常规对象更轻量级且更具表现力。
- en: 'Say, for example, you have a function where you can specify options like `width`
    and `height`. Doing so is easy with object destructuring like so:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个可以指定选项如`width`和`height`的函数。这样做使用对象解构就像这样：
- en: '[PRE68]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can’t destructure a `Map` by the names of its keys; again this would assume
    that all the `Map`’s keys are strings. What if the `Map`’s keys were some type
    of object such as dates? They would be impossible to destructure this way. `Map`s
    as well as all iterables can be destructured, but with array-style destructuring:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '你不能通过键的名称解构`Map`；再次强调，这会假设`Map`的所有键都是字符串。如果`Map`的键是某种对象，比如日期呢？这样解构是不可能的。`Map`以及所有可迭代对象都可以解构，但使用数组风格的解构： '
- en: '[PRE69]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* [“width”, 400]**'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [“width”, 400]**'
- en: '***2* [“height”, 90]**'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* [“height”, 90]**'
- en: '***3* <date object>, “now”]**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* <日期对象>, “now”]**'
- en: 'You could use nested array destructuring to access the keys and values like
    so:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用嵌套数组解构来访问键和值，如下所示：
- en: '[PRE70]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* “width”**'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “width”**'
- en: '***2* 400**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 400**'
- en: '***3* “height”**'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* “height”**'
- en: '***4* 90**'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 90**'
- en: 'Not only is this far more verbose, it also assumes the width is the first item
    in the `Map` and the height is the second. This is because this type of destructuring
    is based on index or position in the `Map`, not on the name of the key or property:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅更加冗长，还假设宽度是`Map`中的第一个项目，高度是第二个。这是因为这种解构类型基于索引或位置，而不是基于键或属性的名称：
- en: '[PRE71]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* “width”**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “width”**'
- en: '***2* 400**'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 400**'
- en: '***3* “height”**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* “height”**'
- en: '***4* 90**'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 90**'
- en: Plain objects do have some limitations, though, and that’s where the `Map` steps
    in. Plain objects have keys, so you can organize your data by specific values,
    but objects don’t guarantee any specific order. Arrays, on the other hand, do
    guarantee their order, but you can only access values in an array by an index,
    not a specific identifier. With maps you can do both.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 普通对象确实有一些限制，这就是`Map`介入的地方。普通对象有键，因此你可以通过特定的值来组织你的数据，但对象不保证任何特定的顺序。另一方面，数组确实保证它们的顺序，但你只能通过索引访问数组中的值，而不是通过特定的标识符。使用映射你可以做到这两点。
- en: So if you need to iterate keys and values and the order is important, use a
    `Map`. Even if the order isn’t important, it’s still more straightforward to iterate
    keys and values with a `Map`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你需要迭代键和值且顺序很重要，请使用`Map`。即使顺序不重要，使用`Map`迭代键和值也更直接。
- en: Let’s look at the difference. Say you’re using a faceted search on your website.
    You know, like the kind of search that allows you to narrow your search based
    on facets like price, brand, or color. You want to list all the facets used for
    the search and display them as shown in [figure 25.1](kindle_split_038_split_003.xhtml#ch25fig01).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看区别。比如说，你在网站上使用分面搜索。你知道，就像那种允许你根据价格、品牌或颜色等分面来缩小搜索范围的搜索。你想要列出用于搜索的所有方面，并按如下所示显示它们：[图25.1](kindle_split_038_split_003.xhtml#ch25fig01)。
- en: Figure 25.1\. Displaying keys and values of search facets
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图25.1\. 显示搜索方面的键和值
- en: '![](Images/25fig01.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/25fig01.jpg)'
- en: 'In order to display them, you need to iterate each facet (key and value) and
    add it to the screen. If you were using a `Map` to store the facets, you could
    iterate them like so:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示它们，你需要迭代每个方面（键和值）并将它们添加到屏幕上。如果你使用`Map`来存储方面，你可以这样迭代它们：
- en: '[PRE72]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If you were storing the facets in a plain object, to iterate them you would
    need an extra step:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将方面存储在普通对象中，要迭代它们，你需要额外的步骤：
- en: '[PRE73]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The other limitation of objects is that their properties must be strings. Sometimes
    you may need to use an object as a key. Let’s say you want to build a function
    called `Singleton` that can convert any constructor into a singleton instance.^([[3](kindle_split_038_split_003.xhtml#ch25fn03)])
    Usually special care is taken in the design of a Singleton object to ensure that
    only one instance is ever created—typically with a static `getInstance` method.
    But you can use a `Map` to easily add this functionality to any type of object,
    as the next listing shows.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的另一个限制是它们的属性必须是字符串。有时你可能需要将对象用作键。比如说，你想创建一个名为 `Singleton` 的函数，它可以将任何构造函数转换为单例实例.^([[3](kindle_split_038_split_003.xhtml#ch25fn03)])
    在设计 Singleton 对象时通常需要特别注意，以确保始终只创建一个实例——通常使用静态 `getInstance` 方法。但你可以使用 `Map` 来轻松地为任何类型的对象添加此功能，如下面的列表所示。
- en: ³
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A Singleton is a constructor/class that can have only one instance. See [https://en.wikipedia.org/wiki/Singleton_pattern](https://en.wikipedia.org/wiki/Singleton_pattern).
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Singleton 是一个只能有一个实例的构造函数/类。见 [https://en.wikipedia.org/wiki/Singleton_pattern](https://en.wikipedia.org/wiki/Singleton_pattern)。
- en: Listing 25.1\. A module that guarantees a singleton instance of any object type
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 25.1\. 一个保证任何对象类型单例实例的模块
- en: '[PRE74]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Create a map to store a single instance for each constructor. This map
    is not exported and is hidden from the rest of the application.**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个 map 来存储每个构造函数的单例实例。这个 map 不会被导出，并且对应用程序的其他部分是隐藏的。**'
- en: '***2* The Singleton function accepts a constructor as an argument.**'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Singleton 函数接受一个构造函数作为参数。**'
- en: '***3* First checks if the map already has an instance for this constructor**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 首先检查 map 是否已经为该构造函数创建了实例**'
- en: '***4* If not, it creates an instance of the constructor and adds the instance
    to the map with the constructor as the key.**'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果没有，它将为构造函数创建一个实例，并将该实例添加到 map 中，构造函数作为键。**'
- en: '***5* Retrieves and returns the single instance for the given constructor.**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 获取并返回给定构造函数的单例实例。**'
- en: 'That’s all that’s needed. Here you use a function called `Singleton` that takes
    the constructor function for any object. It uses a map to store constructors to
    instances. It first checks whether it already has an instance for a given constructor
    and if not, creates one. Then it returns the instance. This ensures that only
    one instance is ever created:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有需要的。在这里，你使用一个名为 `Singleton` 的函数，它接受任何对象的构造函数。它使用一个 map 来存储构造函数到实例的映射。它首先检查是否已经为给定的构造函数创建了一个实例，如果没有，就创建一个。然后它返回这个实例。这确保了始终只创建一个实例：
- en: '[PRE75]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* Creates an empty array**'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个空数组**'
- en: '***2* Array has length zero**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 数组长度为零**'
- en: '***3* Adds two elements to the array**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向数组添加两个元素**'
- en: '***4* Array has length two**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 数组长度为两个**'
- en: '***5* Returns true as now and later are the same object**'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回 true，因为现在和以后都是同一个对象**'
- en: 'This is just one of many use cases where you may want to use an object as a
    key. You may need DOM nodes to register themselves with an action or a way to
    tie data to DOM nodes:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是许多你可能想将对象用作键的场景之一。你可能需要 DOM 节点来注册它们自己或绑定数据到 DOM 节点：
- en: '[PRE76]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Or you may want to tie data to an object without altering the object itself.
    This could be characters in a video, DOM nodes, or objects used by frameworks
    that you aren’t supposed to change. Anytime you may want to store data about another
    object external to the object itself, a `Map` makes perfect sense.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可能想将数据绑定到对象上，而不改变对象本身。这可能是视频中的字符、DOM 节点，或者你不应该更改的框架中使用的对象。任何你想存储关于另一个对象的数据，而这些数据又不在对象本身之外时，`Map`
    都是非常合适的。
- en: 'Imagine you’re building a real estate website. You’re working with multiple
    listing services; each one provides you with a collection of listings that are
    for sale. Each listing has a listing ID (`listingId`), and to keep from colliding
    with listing IDs from other providers, each listing also has a multiple listing
    ID (`mlsId`). You’re going to be showing all the listings for a particular area,
    meaning you’re going to need to have listings from multiple providers in memory
    at once. In order to identify a listing, you need to use the `listingId` and the
    `mlsId`. Because of this, you may think it’s easier to store them in a `Map` using
    an array like `[mlsId, listingId]` as the key for each listing. This wouldn’t
    be ideal, though, because in order to get a listing from the `Map` you would need
    a reference to the exact array you used to add it, not just any array with the
    correct `mlsId` and `listingId`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在构建一个房地产网站。你正在处理多个列表服务；每个服务都为你提供了一组待售的列表。每个列表都有一个列表 ID (`listingId`)，为了避免与其他提供者的列表
    ID 发生冲突，每个列表还有一个多重列表 ID (`mlsId`)。你将展示特定区域的全部列表，这意味着你将需要同时将来自多个提供者的列表存储在内存中。为了识别一个列表，你需要使用
    `listingId` 和 `mlsId`。正因为如此，你可能认为使用类似 `[mlsId, listingId]` 的数组作为每个列表的键来存储在 `Map`
    中会更简单。但这并不理想，因为要从 `Map` 中获取一个列表，你需要引用你用来添加它的确切数组，而不仅仅是任何具有正确 `mlsId` 和 `listingId`
    的数组：
- en: '[PRE77]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* false**'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* false**'
- en: Why did the listings `Map` tell you that it didn’t have the listing that you
    know it has? Even though you used the correct `mlsId` and the correct listing
    ID, you created a new array containing them, which is a different object. A map
    looks at the object itself, not at the contents of the object. The object you
    provide to a `Map` as a key must be the same exact object. You can think of this
    as if the object must satisfy triple equals `===` equality. But that isn’t 100%
    true, either, because you can use `NaN` as a valid key in a `Map` even though
    `NaN !== NaN`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么列表 `Map` 告诉你它没有你已知的存在的那条记录？即使你使用了正确的 `mlsId` 和正确的记录 ID，你创建了一个包含它们的新的数组，这是一个不同的对象。`Map`
    是查看对象本身，而不是查看对象的内容。你提供给 `Map` 作为键的对象必须是完全相同的对象。你可以将此视为对象必须满足严格等于 `===` 的条件。但这也不是完全正确的，因为即使在
    `Map` 中，你也可以使用 `NaN` 作为有效的键，尽管 `NaN !== NaN`。
- en: Take a look at this code. It allows setting any keys and values on an object.
    But what if the key is coming from an untrusted source? How do you know the key
    won’t end up being something that would be dangerous to set on an object like
    `toString`, `proto`, and so on?
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这段代码。它允许在对象上设置任何键和值。但如果键来自不受信任的来源呢？你怎么知道键不会变成在对象如 `toString`、`proto` 等上设置会危险的东西？
- en: '[PRE78]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: By using a `Map` instead of an `Object`, it would be protected from such problems
    because a `Map`’s keys are not its properties and thus wouldn’t collide and override
    built-in properties.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Map` 而不是 `Object`，它可以避免这样的问题，因为 `Map` 的键不是它的属性，因此不会发生冲突并覆盖内置属性。
- en: '|  |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 25.3**'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 25.3**'
- en: '**[Q1:](kindle_split_038_split_003.xhtml#ch25qa6q0a1)**'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_038_split_003.xhtml#ch25qa6q0a1)**'
- en: ''
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What’s the difference between the `width` and `w` constants that are destructured
    from `myObj` and `myMap`, respectively?
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从 `myObj` 和 `myMap` 中解构的 `width` 和 `w` 常量之间有什么区别？
- en: ''
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '|  |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 25.3 answer**'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 25.3 答案**'
- en: '**[A1:](kindle_split_038_split_003.xhtml#ch25qa5q1)**'
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_038_split_003.xhtml#ch25qa5q1)**'
- en: ''
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`width` is `400` as expected but `w` is `["height", 90]`.'
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`width` 的值如预期为 `400`，但 `w` 的值为 `["height", 90]`。'
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 25.4\. What about the WeakMap?
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 25.4. 关于 `WeakMap` 呢？
- en: Similar to what you learned about the `WeakSet` in [lesson 21](kindle_split_033_split_000.xhtml#ch21),
    a `WeakMap` is a non-iterable subset of the `Map`. But whereas the `WeakSet` has
    weak references to its values, the `WeakMap` has weak references to its keys.
    Additionally, a `WeakMap` can only have objects as its keys. The `WeakMap` doesn’t
    keep its keys from becoming eligible for garbage collection. Since the `WeakMap`
    isn’t iterable, there’s no way to get a list of all the keys of a `WeakMap`. Also
    there’s no way to check if a `WeakMap` has a specific key unless you already have
    a reference to that key. Once there are no more references to a key, it will no
    longer be accessible from the `WeakMap` and will become garbage-collected.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 与你在第 21 课中学到的 `WeakSet` 类似，`WeakMap` 是 `Map` 的一个不可迭代的子集。但 whereas the `WeakSet`
    对其值有弱引用，`WeakMap` 对其键有弱引用。此外，`WeakMap` 只能以对象作为其键。`WeakMap` 不会阻止其键成为垃圾回收的候选对象。由于
    `WeakMap` 不可迭代，因此无法获取 `WeakMap` 所有键的列表。同样，除非你已经有了对该键的引用，否则无法检查 `WeakMap` 是否具有特定的键。一旦没有更多对该键的引用，它将不再可通过
    `WeakMap` 访问，并将被垃圾回收。
- en: You may want to use a `WeakMap` when you’re trying to avoid memory leaks and
    you don’t need to iterate all the keys/values in the `Map`, but only need to access
    the value once you already have a reference to the key. Say, for example, you
    want to store metadata about some objects. Maybe the objects are logged-in players
    of a game and they may sign off. Or maybe the objects are DOM nodes that may be
    removed from the DOM as the UI changes. If you store metadata based on these objects
    in a regular `Map`, you’re creating a memory leak because the `Map`’s reference
    to these objects will prevent them from being garbage-collected. A `WeakMap` wouldn’t
    prevent them from being garbage-collected and thus wouldn’t create a memory leak.
    If you need to use a `Map`, though, because you need some additional features
    like iteration, you can still use it; you just need to manage removing the objects
    from the `Map` when necessary.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 当你试图避免内存泄漏且不需要迭代 `Map` 中的所有键/值，但只需要在已有键的引用的情况下访问值时，你可能想使用 `WeakMap`。例如，你可能想存储有关某些对象的元数据。也许这些对象是游戏的登录玩家，他们可能会注销。或者，也许这些对象是随着
    UI 变化可能从 DOM 中移除的 DOM 节点。如果你在常规 `Map` 中根据这些对象存储元数据，你将创建内存泄漏，因为 `Map` 对这些对象的引用将阻止它们被垃圾回收。`WeakMap`
    不会阻止它们被垃圾回收，因此不会创建内存泄漏。但是，如果你需要使用 `Map`，因为你需要一些额外的功能，如迭代，你仍然可以使用它；你只需要在必要时管理从
    `Map` 中删除对象。
- en: Summary
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson you learned how to create and use `Map`s and why you would use
    one over a regular object.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何创建和使用 `Map`，以及为什么你会选择使用它而不是常规对象。
- en: To instantiate a new `Map` with keys and values, you use an array of array pairs
    as the parameter, not an object.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用键和值创建一个新的 `Map`，你使用数组对数组作为参数，而不是对象。
- en: '`Map`s have many of the same properties and methods as `Set`s.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map` 与 `Set` 有许多相同的属性和方法。'
- en: You use `Map.prototype.set(key, value)` to add a new key/value pair to a `Map`.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用 `Map.prototype.set(key, value)` 向 `Map` 添加新的键/值对。
- en: A `Map`’s keys are stored internally and not related to its properties.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map` 的键在内部存储，与其属性无关。'
- en: A `Map` uses array-style, not object-style destructuring.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map` 使用数组风格的解构，而不是对象风格的解构。'
- en: '`Map`s are iterated more elegantly than regular objects.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map` 的迭代比常规对象更优雅。'
- en: '`Map`s guarantee their order, unlike objects.'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map` 保证其顺序，与对象不同。'
- en: '`Map`s can have any datatype as a key.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map` 可以有任意数据类型作为键。'
- en: '`WeakMap`s must have an object as a key.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap` 必须有一个对象作为键。'
- en: '`WeakMap`s don’t prevent their keys from being garbage-collected.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap` 不会阻止其键被垃圾回收。'
- en: '`WeakMap`s are not iterable.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap` 不可迭代。'
- en: 'Let’s see if you got this:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这些：
- en: '**[Q25.1](kindle_split_050_split_018.xhtml#app01qa18q0a1)**'
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q25.1](kindle_split_050_split_018.xhtml#app01qa18q0a1)**'
- en: ''
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write the following three helper functions to alter `Map`s:'
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写以下三个辅助函数以修改 `Map`：
- en: ''
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`sortMapByKeys`—A function that returns a copy of a `Map` sorted by its keys'
  id: totrans-523
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sortMapByKeys`——一个返回按其键排序的 `Map` 副本的函数'
- en: '`sortMapByValues`—A function that returns a copy of a `Map` sorted by its values'
  id: totrans-524
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sortMapByValues`——一个返回按其值排序的 `Map` 副本的函数'
- en: '`invertMap`—A function that returns a copy of a map with its keys and values
    inverted'
  id: totrans-525
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`invertMap`——一个返回键和值反转的 `Map` 副本的函数'
- en: ''
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In real-world use, these functions need to take into account that, according
    to the definition of how `Map`s work, their keys must be unique while their values
    may contain duplicates. To simplify this exercise, assume that these functions
    will only be operating on `Map`s that have unique values.
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在实际应用中，这些函数需要考虑到，根据`Map`的工作定义，它们的键必须是唯一的，而它们的值可以包含重复项。为了简化这个练习，假设这些函数将只操作具有唯一值的`Map`。
- en: 'Lesson 26\. Capstone: Blackjack'
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第26课. 项目：黑杰克
- en: In this capstone you’re going to build a Blackjack (21) game like the one shown
    in [figure 26.1](kindle_split_039_split_000.xhtml#ch26fig01).
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将构建一个类似于[图26.1](kindle_split_039_split_000.xhtml#ch26fig01)所示的21点（黑杰克）游戏。
- en: Figure 26.1\. A Blackjack game
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图26.1. 黑杰克游戏
- en: '![](Images/26fig01.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/26fig01.jpg)'
- en: A game of cards has many sets. A deck is a *set* of cards and each player’s
    hand is also a *set* of cards. You’ll also make use of *maps* and eventually use
    a generator to create a function that slows down the looping of an iterator so
    that it can be animated on the screen.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 一副牌有许多集合。牌组是一组牌，每位玩家的手牌也是一组牌。您还将使用*映射*，并最终使用生成器创建一个函数，以减慢迭代器的循环速度，使其可以在屏幕上动画化。
- en: '|  |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'You’ll start your project using the start folder included in the code accompanying
    this book. If at any time you get stuck, you can also check out the final folder
    with the completed game. The start folder is a project already set up to use Babel
    and Browserify (see [lessons 1](kindle_split_009_split_000.xhtml#ch01)–[3](kindle_split_011_split_000.xhtml#ch03));
    you just need to run `npm install` to get set up. If you haven’t read unit 0,
    you should before doing this capstone. There’s also an included index.html file:
    this is where the game will run. It already includes all the HTML and CSS it needs;
    you just need to open it in a browser once you bundle your JavaScript files. The
    src folder is where you’ll put all your JavaScript files; there are a couple already
    included. The dest folder is where the bundled JavaScript file will go after you
    run `npm run build`. You’ll need to remember to run `npm run build` to compile
    your code anytime you make a change.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用本书附带代码中的起始文件夹来开始您的项目。如果在任何时候您遇到了困难，您也可以查看包含完成游戏的最终文件夹。起始文件夹是一个已经设置好以使用 Babel
    和 Browserify 的项目（见[第1课](kindle_split_009_split_000.xhtml#ch01)–[第3课](kindle_split_011_split_000.xhtml#ch03)）；您只需运行
    `npm install` 来设置环境。如果您还没有阅读单元0，您应该在完成这个项目之前先阅读。还有一个包含的 index.html 文件：这是游戏将运行的地方。它已经包含了所有需要的
    HTML 和 CSS；您只需在将 JavaScript 文件打包后，在浏览器中打开它。src 文件夹是您将放置所有 JavaScript 文件的地点；其中已经包含了一些。dest
    文件夹是运行 `npm run build` 后捆绑的 JavaScript 文件将存放的地方。您需要记住，每次您对代码进行更改时，都要运行 `npm run
    build` 来编译您的代码。
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Your project is going to start with a couple of modules already created, specifically
    an elements module and a templates module. In order to make the game’s code easy
    to reason about, you’ll continue to create modules for handling specific parts
    of the game. You’re going to start by building a cards module that handles all
    the hard related tasks like creating a deck, shuffling it, or counting a player’s
    hand of cards. You’ll then create a utils module that’s going to store a helper
    function you’ll need. Finally you’ll use all of these modules in your main index
    file that orchestrates the game. Because you’re properly using modules, the index
    file should be rather simple and easy to follow.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目将从已经创建的一些模块开始，具体是一个元素模块和一个模板模块。为了使游戏代码易于理解，您将继续创建处理游戏特定部分的模块。您将首先构建一个卡片模块，该模块将处理所有与创建牌组、洗牌或计算玩家手牌数量相关的困难任务。然后您将创建一个
    utils 模块，该模块将存储您需要的辅助函数。最后，您将使用所有这些模块在您的主 index 文件中编排游戏。由于您正确地使用了模块，index 文件应该相当简单且易于理解。
- en: 26.1\. The cards and the deck
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1. 牌和牌组
- en: This is a card game, after all, so get started by creating and storing your
    cards. Each card will be a simple object with a *suit* and a *face*. To assist
    in creating cards, you can store sets of the available suits and faces. Create
    a file called src/cards.js and use a `Set` to store all the possible card suits
    as shown in the next listing.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这是一个牌类游戏，所以先从创建和存储您的牌开始。每张牌将是一个简单的对象，包含一个*花色*和一个*面值*。为了帮助创建牌，您可以存储可用的花色和面值的集合。创建一个名为
    src/cards.js 的文件，并使用一个`Set`来存储所有可能的牌花色，如下所示。
- en: Listing 26.1\. src/cards.js
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表26.1. src/cards.js
- en: '[PRE80]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You can also use a set to store all the possible card faces, as the following
    listing shows.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用一个集合来存储所有可能的牌面值，如下所示。
- en: Listing 26.2\. src/cards.js
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.2\. src/cards.js
- en: '[PRE81]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You also need a way to determine each face’s value. For this you can use a `Map`,
    shown next.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一种方法来确定每个面值。为此，你可以使用一个`Map`，如下所示。
- en: Listing 26.3\. src/cards.js
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.3\. src/cards.js
- en: '[PRE82]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here you’re using a map to store the face value for each card face except for
    the ace. Since the ace’s value is contextual and can be either 1 or 11, you can’t
    store its value this way and will have to treat it differently.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用一个映射来存储每个牌面的面值，除了A牌。由于A牌的值是上下文相关的，可以是1或11，你不能用这种方式存储它的值，而必须以不同的方式处理。
- en: The game is going to render cards. Each card can be displayed face down or face
    up. The cards are going to be passed around from the deck to each player, so keeping
    track of which ones are flipped could be tricky. This becomes easy with a `Map`,
    though. You can store the actual card as the key in your `Map`, and whether or
    not it’s flipped as the value. This means as long as you have a reference to the
    card, you can determine if it’s flipped face up or face down, as shown in the
    following listing.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将要渲染牌。每张牌可以显示为面朝下或面朝上。牌将从牌堆传递给每位玩家，因此跟踪哪些牌被翻转可能会很棘手。不过，使用`Map`会使这变得简单。你可以将实际的牌作为`Map`的键，是否翻转作为值。这意味着只要你有卡片的引用，你就可以确定它是面朝上还是面朝下，如下面的列表所示。
- en: Listing 26.4\. src/cards.js
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.4\. src/cards.js
- en: '[PRE83]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now write a function for creating a deck of cards, shown in the next listing.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写一个创建牌堆的函数，如以下列表所示。
- en: Listing 26.5\. src/cards.js
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.5\. src/cards.js
- en: '[PRE84]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This function is simple. You first create a new `Set` for the deck. Then you’re
    just using `for..of` to loop through all the suits and faces to add a card to
    the deck for all the possible combinations (52, to be exact). The final thing
    you do is call `shuffle(deck)`. Any card game would require shuffling the deck
    before use, and Blackjack is no exception, so you’ll write the shuffle function.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很简单。你首先为牌堆创建一个新的`Set`。然后你只是使用`for..of`循环遍历所有花色和面值，将牌添加到牌堆中，以包含所有可能的组合（确切地说，是52种）。你做的最后一件事是调用`shuffle(deck)`。任何牌局在开始使用之前都需要洗牌，黑杰克也不例外，所以你需要编写洗牌函数。
- en: '`Set`s maintain their entries in insertion order, but they don’t store keys,
    meaning there’s no index associated with a value. Because of this, to shuffle
    a set, you’ll need to use an array.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`维护它们的条目顺序，但它们不存储键，这意味着没有与值关联的索引。正因为如此，为了洗牌，你需要使用一个数组。'
- en: Listing 26.6\. src/cards.js
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.6\. src/cards.js
- en: '[PRE85]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* You use spread to put all the Set’s values into an Array.**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你使用展开操作将集合的所有值放入一个数组中。**'
- en: '***2* The index of the current card**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当前牌的索引**'
- en: '***3* Get a random index to another card to swap with your current card.**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取一个随机索引，以与你的当前牌交换。**'
- en: '***4* Get the card at your swap index.**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取你的交换索引处的牌。**'
- en: '***5* Set the card at your swap index to be the current card.**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将你的交换索引处的牌设置为当前牌。**'
- en: '***6* Set the card at your current index to be the swapped card.**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将你的当前索引处的牌设置为交换的牌。**'
- en: '***7* Clear the Set before adding the shuffled cards back.**'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在添加洗好的牌之前清空集合。**'
- en: '***8* Add the shuffled cards back to the deck in the new order.**'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 将洗好的牌按新顺序放回牌堆中。**'
- en: In this function, you first grab all the cards from the set into an array using
    spread. You then go through each index in the array and swap the card at that
    index with another card at a random index. The same index might get chosen to
    swap several times, and that’s fine. This results in the array of cards being
    randomly shuffled. Finally you need to add them all back to the deck. You must
    first clear the deck, since each card can be in the set only once.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，你首先使用展开操作将所有卡片从集合中提取到一个数组中。然后你遍历数组的每个索引，将当前索引处的卡片与随机索引处的另一张卡片交换。同一个索引可能会被选中多次进行交换，这是可以的。这会导致卡片数组随机洗牌。最后，你需要将它们全部放回牌堆中。你必须首先清空牌堆，因为每张牌只能出现在集合中一次。
- en: Now that you have a way to create and shuffle a deck, the next thing you’ll
    need to do is deal the cards to each player. When you deal a card from the deck,
    you generally deal from the top. As you know, arrays have a built-in method for
    this type of thing called `pop`. Sets don’t have a corresponding method, so you’ll
    build your own, as shown in the next listing.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了创建和洗牌的方法，接下来你需要做的是将牌分发给每位玩家。当你从牌堆中发牌时，通常是从顶部开始发。正如你所知，数组有一个内置的用于此类操作的`pop`方法。集合没有对应的方法，所以你需要自己构建，如以下列表所示。
- en: Listing 26.7\. src/cards.js
  id: totrans-569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.7\. src/cards.js
- en: '[PRE86]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In this `pop` function, you use `Array`’s `pop` to get the last card from the
    deck. You then default the card to being face up. Most games deal face down, but
    in this game you’ll almost always want the card face up, so default it that way.
    You use `delete` to remove the card from the deck, since it obviously can’t be
    in a player’s hand and remain in the deck at the same time. Finally you return
    the card.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`pop`函数中，你使用`Array`的`pop`来获取牌堆中的最后一张牌。然后你默认牌是正面朝上。大多数游戏都是背面朝上发牌，但在这个游戏中你几乎总是希望牌是正面朝上，所以默认为这种方式。你使用`delete`来从牌堆中移除牌，因为它显然不能同时存在于玩家手中和牌堆中。最后你返回这张牌。
- en: In Blackjack, each player starts with two cards. In your game, each player’s
    hand of cards will also be represented with a `Set`. Write a small function that
    deals two cards from the deck to a given hand, as in the following listing.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在二十一点游戏中，每位玩家开始时有两张牌。在你的游戏中，每位玩家的牌手也将用`Set`来表示。编写一个小的函数，从牌堆中为给定的牌手发两张牌，如下所示。
- en: Listing 26.8\. src/cards.js
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表26.8\. `src/cards.js`
- en: '[PRE87]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The whole point of Blackjack is to have the total of your cards be as close
    to 21 as possible without going over, so you need a function to count the total
    face value of a hand of cards. You can total the face values by iterating all
    the cards and checking each card’s face with the `faceValues` map that you created
    earlier. But that won’t work for the ace, which can be either 1 or 11\. So in
    your initial loop of all the cards, you can add 1 for each ace as well as keep
    track of each ace. After the initial loop, you can add an additional 10 for each
    ace when the total of cards will still be less than or equal to 21, as shown in
    the next listing.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 二十一点的全部要点是使你的牌的总数尽可能接近21，但不能超过，因此你需要一个函数来计算牌手的总面值。你可以通过迭代所有牌并检查每张牌的面值与之前创建的`faceValues`映射来计算面值总和。但对于A来说，它可以代表1或11。因此，在所有牌的初始循环中，你可以为每个A加1，并跟踪每个A。在初始循环之后，当牌的总数仍然小于或等于21时，可以为每个A额外加10，如下所示。
- en: Listing 26.9\. src/cards.js
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表26.9\. `src/cards.js`
- en: '[PRE88]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1* Start your count at zero.**'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从零开始计数。**'
- en: '***2* Create a Set to keep track of all the aces.**'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个Set来跟踪所有的A。**'
- en: '***3* For every ace, add one, and keep track of the ace.**'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 对于每个A，加1，并跟踪A。**'
- en: '***4* If not an ace, add the value from the faceValues Map.**'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果不是A，则从`faceValues`映射中添加值。**'
- en: '***5* For all of the aces, add an additional 10 as long as it won’t result
    in the count going over 21.**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 对于所有的A，只要总数不超过21，就额外加10。**'
- en: That’s about all you need in this cards module. You now have the functions to
    create a deck of cards, shuffle that deck, deal the initial two cards to a hand,
    and count the total value of the cards in a hand. You also have a way to keep
    track of whether a given card is flipped up or down. In the next section, you’ll
    write a function to delay CPU decisions enough for the player to see what’s happening
    in real time.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在这个牌模块中你需要的一切。你现在有了创建牌堆、洗牌、将初始两张牌发到牌手手中以及计算牌手中牌的总价值的函数。你还有一个方法来跟踪给定的牌是正面朝上还是反面朝下。在下一节中，你将编写一个函数来延迟CPU的决定，以便玩家可以实时看到正在发生的事情。
- en: 26.2\. Making the CPU’s turn slow enough to see
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2\. 使CPU的回合足够慢以便可以看到
- en: The game will start by allowing the user to take cards from the deck until the
    user passes control to the dealer, at which time the dealer will be able to draw
    cards from the deck. Since the dealer is a CPU, it will be able to make decisions
    so fast that you’ll need to slow them down in order to allow the human player
    to see what’s happening.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏将通过允许用户从牌堆中抽牌开始，直到用户将控制权交给庄家，此时庄家将能够从牌堆中抽牌。由于庄家是CPU，它将能够非常快地做出决定，因此你需要减慢它们的速度，以便让人类玩家看到正在发生的事情。
- en: You can do this by using a generator function and using a `yield` anytime you
    want to add a pause. You’ll need another function that can iterate your generator
    and pause at every occurrence of `yield`. Create the file src/utils.js and add
    this function as shown in the next listing.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用生成器函数并在需要暂停时使用`yield`来实现这一点。你需要另一个函数来迭代你的生成器，并在每次出现`yield`时暂停。创建文件`src/utils.js`并添加如下所示的函数。
- en: Listing 26.10\. src/utils.js
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表26.10\. `src/utils.js`
- en: '[PRE89]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '***1* Create a new interval using the milliseconds parameter.**'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用毫秒参数创建一个新的间隔。**'
- en: '***2* Get the next iteration from the iterator.**'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从迭代器中获取下一个迭代。**'
- en: '***3* Check if the iterator is done.**'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查迭代器是否完成。**'
- en: '***4* If the iterator is done, clear the interval and invoke the callback function.**'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果迭代器已完成，则清除间隔并调用回调函数。**'
- en: '***5* Create a new interval using the milliseconds parameter.**'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用毫秒参数创建一个新的间隔。**'
- en: 'The `wait` function takes three parameters: an iterator object, the number
    of milliseconds to wait between iterations, and a callback function. You use `setInterval`
    with the given `milliseconds` parameter. Inside your interval function, the arrow
    function you pass to `setInterval`, you call `iterator.next()`. This will cause
    the iterator to attempt to retrieve the next value every `milliseconds` of time.
    You check the `done` value from your iterator to clear the interval if the iterator
    has finished. Now this will work with any iterator, causing a pause between each
    iteration, but if you use a generator it will allow you to specify when to pause
    the execution of your function anytime you use `yield`.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait` 函数接受三个参数：一个迭代器对象、迭代之间等待的毫秒数和一个回调函数。你使用带有给定 `milliseconds` 参数的 `setInterval`。在你的间隔函数内部，你传递给
    `setInterval` 的箭头函数中调用 `iterator.next()`。这将导致迭代器尝试每 `milliseconds` 毫秒检索下一个值。你检查迭代器的
    `done` 值，如果迭代器已经完成，则清除间隔。现在这可以与任何迭代器一起工作，在每次迭代之间产生暂停，但如果你使用生成器，它将允许你在使用 `yield`
    时指定何时暂停函数的执行。'
- en: For example, when using the `wait` function in [listing 26.11](kindle_split_039_split_002.xhtml#ch26ex11),
    you would first log A after one second. Then because you invoked `yield`, it would
    wait for the next interval of the `wait` function. Then it would log both B and
    C, but it would wait another second before logging D because you used another
    `yield`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用 [26.11 列表](kindle_split_039_split_002.xhtml#ch26ex11) 中的 `wait` 函数时，你会在一秒后记录
    A。然后由于你调用了 `yield`，它会等待 `wait` 函数的下一个间隔。然后它会记录 B 和 C，但在记录 D 之前会再等待一秒，因为你使用了另一个
    `yield`。
- en: Listing 26.11\. Using the `wait` function
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.11\. 使用 `wait` 函数
- en: '[PRE90]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* ‘A’ will get logged after 1 second.**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ‘A’ 将会在 1 秒后记录。**'
- en: '***2* Here you’re causing another delay.**'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你又引入了另一个延迟。**'
- en: '***3* ‘B’ and ‘C’ will get logged after 2 seconds.**'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* ‘B’ 和 ‘C’ 将会在 2 秒后记录。**'
- en: '***4* Here you’re causing another delay.**'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 你又引入了另一个延迟。**'
- en: '***5* ‘D’ will get logged after three seconds.**'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* ‘D’ 将会在 3 秒后记录。**'
- en: '***6* ‘Done.’ will get logged after the example generator has completely finished.**'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 示例生成器完全完成后将记录 ‘Done。’**'
- en: Later you’ll use this `wait` function when the dealer is deciding to draw cards
    from the deck. You’ll use `yield` to delay the next decision long enough to animate
    each card being added to the player’s hand.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当庄家决定从牌堆中抽取牌时，你会使用这个 `wait` 函数。你会使用 `yield` 来延迟下一个决策，以便有足够的时间为玩家手中添加的每一张牌进行动画处理。
- en: 26.3\. Putting the pieces together
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.3\. 组装组件
- en: Now that you’ve gotten the cards module and some necessary utils taken care
    of, you need to put it all together to complete the game. First import everything
    you’re going to need for your main game logic. Create the file src/index.js and
    add the following imports.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经处理好了卡片模块和一些必要的工具，你需要将它们全部组合起来以完成游戏。首先导入你主要游戏逻辑所需的所有内容。创建文件 src/index.js
    并添加以下导入。
- en: Listing 26.12\. src/index.js
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.12\. src/index.js
- en: '[PRE91]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: That sure is a lot of stuff you’re importing! By separating your logic into
    cohesive modules, your *glue code* (the main game logic) that ties everything
    together will be much simpler. You wrote everything in the utils.js and cards.js
    files together. The templates.js and elements.js focus mostly on interacting with
    the DOM (Document Object Model). The logic in those files doesn’t have a lot to
    do with iterators, so I omitted going over their contents, but feel free to browse
    the code.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 你导入的东西确实很多！通过将你的逻辑分成连贯的模块，将所有东西联系起来的*粘合代码*（主要游戏逻辑）将会简单得多。你将 utils.js 和 cards.js
    文件中的所有内容都写在一起。templates.js 和 elements.js 主要关注与 DOM（文档对象模型）的交互。这些文件中的逻辑与迭代器关系不大，所以我省略了它们的详细内容，但你可以自由地浏览代码。
- en: The first thing you need to play a game of cards is the deck. So create one
    using the function you imported, as shown in the following listing.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一副牌是玩牌游戏的第一步。所以使用你导入的函数创建一副牌，如下所示。
- en: Listing 26.13\. src/index.js
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.13\. src/index.js
- en: '[PRE92]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1* Creates a new Set with 52 shuffled card objects**'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个新的包含 52 张洗好的牌对象的 Set**'
- en: Now create a couple `Set`s for the dealer’s and the player’s hands, shown in
    the next listing.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建几个 `Set` 用于庄家和玩家的手牌，如下所示。
- en: Listing 26.14\. src/index.js
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.14\. src/index.js
- en: '[PRE93]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '***1* Flip the dealer’s first card face down.**'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将发牌员的第一张牌面朝下翻转。**'
- en: Here you created a new set for each player’s hand. You used the `dealInitialHand`
    function that you created earlier to deal each player their initial two cards.
    You leave all the player’s cards face up so they can see what they’re holding.
    You set the dealer’s first card to be face down and leave their second card face
    up, like an actual casino dealer would do, as shown in [figure 26.2](kindle_split_039_split_003.xhtml#ch26fig02).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你为每个玩家的手牌创建了一个新集合。你使用了之前创建的 `dealInitialHand` 函数来为每个玩家发两张初始牌。你将所有玩家的牌面朝上，这样他们就能看到自己手中的牌。你将发牌员的第一张牌面朝下，并将他们的第二张牌面朝上，就像实际的赌场发牌员那样，如图
    26.2 所示。
- en: Figure 26.2\. The dealer’s initial hand
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 26.2\. 发牌员的初始手牌
- en: '![](Images/26fig02.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/26fig02.jpg)'
- en: Now in order to generate that screenshot, you need to render each hand. You
    can do this using the `render` function you imported from the elements module,
    as the following listing shows.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了生成那个截图，你需要渲染每一只手。你可以使用从元素模块导入的 `render` 函数来完成这个操作，如下列表所示。
- en: Listing 26.15\. src/index.js
  id: totrans-622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.15\. src/index.js
- en: '[PRE94]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: OK, that should get the initial game rendered on the screen, but there won’t
    be any interactivity yet. You need to write some functions to allow the user to
    play by deciding to *hit* or to *stay*, and you need to program the dealer to
    do the same. Start with the dealer while the `wait` function you wrote earlier
    is hopefully still fresh in your memory.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这应该会在屏幕上渲染出初始游戏，但还没有任何交互性。你需要编写一些函数，允许用户通过决定要 *击* 或 *停* 来玩游戏，并且你需要编程让发牌员也这样做。从发牌员开始，希望你之前编写的
    `wait` 函数仍然记忆犹新。
- en: Create the following generator function.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下生成器函数。
- en: Listing 26.16\. src/index.js
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.16\. src/index.js
- en: '[PRE95]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '***1* Flip all the dealer’s cards face up.**'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将发牌员的所有牌面朝上翻转。**'
- en: '***2* Continue to loop while the dealer’s hand is less than the player’s.**'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在发牌员的手牌小于玩家的手牌时继续循环。**'
- en: '***3* Draw another card from the deck.**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从牌堆中再抽一张牌。**'
- en: '***4* Delay long enough to animate the card being added to the dealer’s hand.**'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 延迟足够长，以便动画化添加到发牌员手牌的牌。**'
- en: '***5* If the dealer’s hand is the same as the player’s and the total score
    is less than 17, draw another card.**'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果发牌员的手牌与玩家的手牌相同且总分小于 17，再抽一张牌。**'
- en: '***6* Wait again for the final card to animate.**'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 等待最后一张牌动画化完成。**'
- en: In this generator function, you first flip over all the dealer’s cards so the
    player can see what the dealer has. Then the dealer should continue to add cards
    until they’ve reached the player’s total score. You don’t need to worry about
    the player’s hand being over 21 because if the player busts (goes over 21), the
    game will end before the dealer needs to play.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个生成器函数中，你首先翻转发牌员的所有牌，这样玩家就能看到发牌员有什么牌。然后发牌员应该继续加牌，直到他们的总分达到玩家的总分。你不需要担心玩家的手牌超过
    21，因为如果玩家爆牌（超过 21），游戏将在发牌员需要操作之前结束。
- en: Once the dealer has tied the player, if the total score is less than 17, the
    dealer should draw another card to attempt to win. If the score is 17 or over,
    the dealer should accept the tie (push) because it’s too risky to draw another
    card.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发牌员与玩家打平，如果总分小于 17，发牌员应该再抽一张牌以尝试赢得比赛。如果分数是 17 或更高，发牌员应该接受平局（推牌），因为再抽一张牌的风险太高。
- en: In this generator function, every time the dealer draws a card, you use `yield`.
    When combined with the `wait` function you wrote in the last section, this will
    cause a delay long enough to allow the card to animate on the screen before the
    dealer needs to decide to draw another. This will create a nice effect of cards
    being added to the screen as the dealer plays.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个生成器函数中，每当发牌员抽一张牌时，你使用 `yield`。当与上一节中你编写的 `wait` 函数结合使用时，这将导致一个足够长的延迟，以便在发牌员需要决定是否再抽一张牌之前，让牌在屏幕上动画化。这将创建一个很好的效果，即随着发牌员的操作，牌被添加到屏幕上。
- en: Now you just need a small function that combines this generator with your `wait`
    function, shown in the next listing.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要一个小的函数，将这个生成器与你的 `wait` 函数结合起来，如下一列表所示。
- en: Listing 26.17\. src/index.js
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.17\. src/index.js
- en: '[PRE96]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now let’s turn our attention to the user. The user playing the game will have
    two choices, to hit or to stay. So you need to write a function for each case.
    Let’s start with hit.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们把注意力转向用户。正在玩游戏的用户将有两个选择，要“击”还是要“停”。所以你需要为每种情况编写一个函数。让我们从“击”开始。
- en: Listing 26.18\. src/index.js
  id: totrans-641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.18\. src/index.js
- en: '[PRE97]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In this `hit` function, you start by adding a card to the player’s hand from
    the deck. Then you call `updateLabel`. This changes the text from score to blackjack
    or bust if the player reaches 21 or busts, respectively. Then you check the score
    and if the player has gone bust, you hide the buttons and update the status of
    the game. Otherwise, if the player has exactly 21, you automatically invoke `stay`
    and turn the game to the dealer. You haven’t written that stay function, though,
    so do that in the next listing.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `hit` 函数中，你首先从牌堆中给玩家手中加一张牌。然后调用 `updateLabel`。这会将文本从得分改为黑杰克或爆牌，如果玩家得分达到21或爆牌。然后检查得分，如果玩家爆牌，隐藏按钮并更新游戏状态。否则，如果玩家正好得到21分，则自动调用
    `stay` 并将游戏转为庄家。不过，你还没有编写那个 `stay` 函数，所以你需要在下一个列表中完成它。
- en: Listing 26.19\. src/index.js
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.19\. src/index.js
- en: '[PRE98]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1* Hide the hit and stay buttons.**'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 隐藏 `hit` 和 `stay` 按钮。**'
- en: '***2* Reveal the dealer’s score.**'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示庄家的得分。**'
- en: '***3* Lets the dealer play out their turn**'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 让庄家进行他们的回合**'
- en: '***4* Once the dealer has finished, update their label.**'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 庄家完成后，更新其标签。**'
- en: '***5* Count both the dealer’s and the player’s hands.**'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 计算庄家和玩家的手牌总数。**'
- en: '***6* If the dealer has more than 21 or less than the player, the player wins.**'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果庄家的得分超过21或低于玩家，则玩家获胜。**'
- en: '***7* If they’re tied, it’s a push**'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 如果平局，则为平局**'
- en: '***8* Otherwise, the dealer wins**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 否则，庄家获胜**'
- en: There’s only one last step to complete this game. You need to add some event
    listeners to the hit and stay buttons, as shown in the next listing.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个游戏只剩最后一步。你需要给 `hit` 和 `stay` 按钮添加一些事件监听器，如下一个列表所示。
- en: Listing 26.20\. src/index.js
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 26.20\. src/index.js
- en: '[PRE99]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: With that, you’re finished. You should now be able to play a game of Blackjack
    against your computer. Building this game really helped me realize how much the
    odds are stacked against you when playing against the house.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，你就完成了。现在你应该能够和电脑玩一局21点游戏了。构建这个游戏真的帮助我意识到，当你和庄家对弈时，你面临的概率是多么不利。
- en: Summary
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this capstone, you built a blackjack game by breaking your logic into cohesive
    modules. You started with elements and template modules. You then created a cards
    module followed by a utils module. Your cards module represented a deck of cards
    as well as hands of cards using `Set`s. You also used a `Map` to keep track of
    whether specific cards were face up or face down. Once you had your game logic
    separated into logical modules, tying the pieces together to make your game in
    the root index file was nice and easy.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你通过将逻辑分解成模块来构建了一个21点游戏。你从元素和模板模块开始，然后创建了一个卡片模块，接着是一个工具模块。你的卡片模块使用 `Set`
    来表示牌堆和手牌。你还使用了一个 `Map` 来跟踪特定卡片是正面朝上还是背面朝下。一旦你的游戏逻辑被分离到逻辑模块中，将它们组合在一起在根索引文件中构建游戏就变得既简单又容易。
- en: You can take this game further by adding a Play Again button and keep track
    of the odds that the player beats the dealer.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加“再玩一次”按钮并跟踪玩家击败庄家的概率来进一步改进这个游戏。
