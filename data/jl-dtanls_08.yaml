- en: 7 Handling time-series data and missing values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 处理时间序列数据和缺失值
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Fetching data by using HTTP queries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP查询获取数据
- en: Parsing JSON data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析JSON数据
- en: Working with dates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理日期
- en: Handling missing values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理缺失值
- en: Plotting data with missing values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制含有缺失值的图表
- en: Interpolating missing values
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值缺失值
- en: This is the last chapter of part 1, which focuses on the Julia language. A motivating
    use case for the topics that we will cover in this chapter is working with financial
    asset prices. Imagine you want to analyze how the price of a certain stock or
    the exchange rate between two currencies evolves over time. To be able to handle
    these questions in Julia, you need to know how to work with time-series data.
    A frequent feature of real-life temporal data is that it contains missing data
    for some timestamps. Therefore, the second major topic of this chapter is handling
    missing values in Julia.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一部分的最后一章，重点关注Julia语言。本章将要涵盖的主题的一个激励用例是处理金融资产价格。想象一下，你想分析某只股票的价格或两种货币之间的汇率随时间的变化。为了能够在Julia中处理这些问题，你需要知道如何处理时间序列数据。现实生活中时间数据的常见特征是某些时间戳包含缺失数据。因此，本章的第二个主要主题是在Julia中处理缺失值。
- en: The problem we tackle in this chapter is analyzing the PLN/USD exchange rate
    that is published by the National Bank of Poland (NBP). The data is made available
    via a Web API, which is described at [https://api.nbp.pl/en.html](https://api.nbp.pl/en.html).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们解决的问题是分析波兰国家银行（NBP）发布的PLN/USD汇率。数据通过Web API提供，API描述在[https://api.nbp.pl/en.html](https://api.nbp.pl/en.html)。
- en: 'We will perform our task via the following steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤完成任务：
- en: Understand the format of the data that the Web API exposes.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解Web API公开的数据格式。
- en: Fetch the data by using HTTP GET requests for a specified range of dates.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用HTTP GET请求获取指定日期范围内的数据。
- en: Handle errors when the requested data is not available.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理请求的数据不可用时的错误。
- en: Extract the PLN/USD exchange rate from the obtained result of the query.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从查询获取的结果中提取PLN/USD汇率。
- en: Perform simple statistical analysis of the fetched data.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对获取的数据进行简单的统计分析。
- en: Plot the fetched data with a proper handling of missing values.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的处理方法绘制获取的图表数据。
- en: 'To execute this sequence of steps, you will need to learn how to handle missing
    data in Julia, work with dates, and fetch data by using the HTTP requests, as
    well as parse information passed using the JSON format ([https://www.json.org/json-en.html](https://www.json.org/json-en.html)).
    To help you learn these topics one by one, this chapter is divided into four sections:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这一系列步骤，你需要学习如何在Julia中处理缺失数据，处理日期，使用HTTP请求获取数据，以及解析使用JSON格式传递的信息([https://www.json.org/json-en.html](https://www.json.org/json-en.html))。为了帮助你逐一学习这些主题，本章分为四个部分：
- en: In section 7.1, you will learn the JSON format of the exchange-rate data that
    NBP exposes via its Web API; you will see how to perform HTTP GET requests in
    Julia and how to parse JSON data.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在7.1节中，你将学习NBP通过其Web API公开的汇率数据的JSON格式；你将了解如何在Julia中执行HTTP GET请求以及如何解析JSON数据。
- en: In section 7.2, you will learn how to handle missing values in Julia. This knowledge
    is required to understand how to process the data fetched from the NBP Web API
    since it contains missing values.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在7.2节中，你将学习如何在Julia中处理缺失值。这些知识是理解如何处理从NBP Web API获取的数据所必需的，因为其中包含缺失值。
- en: In section 7.3, you will see how to handle a series of NBP Web API queries for
    data coming from different dates and process their results as a time series. You
    will learn how to work with dates in Julia.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在7.3节中，你将了解如何处理来自不同日期的NBP Web API查询数据，并将它们的结果作为时间序列进行处理。你将学习如何在Julia中处理日期。
- en: In section 7.4, you will analyze time-series data statistically and plot it.
    We’ll pay special attention to handling missing data in both data analysis and
    visualization.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在7.4节中，你将对时间序列数据进行统计分析并绘制图表。我们将特别关注在数据分析和可视化中处理缺失数据。
- en: 7.1 Understanding the NBP Web API
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 理解NBP Web API
- en: Before you can start analyzing the exchange-rate data, you need to learn how
    to fetch it from the NBP Web API. Also, as you will soon see, the NBP Web API
    exposes information about exchange rates in JSON format, so you will also see
    how to parse it. I have chosen this data source for this chapter because the JSON
    format is commonly used by many data sources, so it is worth learning how to work
    with it. Also, you can expect that in practice, you will often need to fetch data
    via various web APIs in your data science projects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始分析汇率数据之前，你需要学习如何从NBP Web API获取它。此外，正如你很快就会看到的，NBP Web API以JSON格式公开汇率信息，因此你还将了解如何解析它。我选择这个数据源是因为JSON格式被许多数据源广泛使用，因此学习如何处理它是有价值的。此外，你可以预期在实际操作中，你通常需要在数据科学项目中通过各种Web
    API获取数据。
- en: We start by visually inspecting the data that the NBP Web API exposes. We will
    be passing sample queries via a web browser. Next, you will learn how to perform
    this operation programmatically.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过网页浏览器检查NBP Web API公开的数据。我们将通过网页浏览器传递示例查询。接下来，你将学习如何以编程方式执行此操作。
- en: 7.1.1 Getting the data via a web browser
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 通过网页浏览器获取数据
- en: 'The full specification of the Web API is available at [https://api.nbp.pl/en.html](https://api.nbp.pl/en.html).
    The API can be accessed both via a web browser and programmatically. We start
    by querying it using a web browser. For our purpose, it is enough to know one
    format of the request:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Web API的完整规范可在[https://api.nbp.pl/en.html](https://api.nbp.pl/en.html)找到。API可以通过网页浏览器和编程方式访问。我们首先使用网页浏览器查询它。就我们的目的而言，了解请求的一种格式就足够了：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this request, you should replace the YYYY-MM-DD part with a specific date,
    first passing four digits of a year, then two digits for the month, and finally
    two digits for the day. Here is an example of getting data for June 1, 2020:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个请求中，你应该将YYYY-MM-DD部分替换为特定日期，首先输入年份的四位数字，然后是月份的两位数字，最后是日期的两位数字。以下是一个获取2020年6月1日数据的示例：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you run this query in your web browser, you should get the following response
    (depending on the browser you use, the layout of the response might be a bit different):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网页浏览器中运行此查询时，你应该得到以下响应（根据你使用的浏览器，响应的布局可能略有不同）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result is returned in JSON format. You can find the format specification
    at [www.json.org/json-en.html](https://www.json.org/json-en.html). Additionally,
    if you want to learn more about JSON, consider reading *JSON for Beginners: Your
    Guide to Easily Learn JSON Programming in 7 Days* by iCode Academy (White Flower
    Publishing, 2017) or going through the MDN Web Docs tutorial at [http://mng.bz/DDKa](http://mng.bz/DDKa).
    Here, I will concentrate on explaining how this specific JSON structure should
    be interpreted.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结果以JSON格式返回。你可以在[www.json.org/json-en.html](https://www.json.org/json-en.html)找到格式规范。此外，如果你想了解更多关于JSON的信息，可以考虑阅读iCode
    Academy（白花出版社，2017年）的《JSON入门：7天内轻松学习JSON编程指南》或浏览MDN Web文档教程[http://mng.bz/DDKa](http://mng.bz/DDKa)。在这里，我将专注于解释如何解释这个特定的JSON结构。
- en: 'Figure 7.1 presents the explanation. The result contains one object with four
    fields: table, currency, code, and rates. The field that is interesting for us
    is rates, which contains an array holding a single object. This single object
    has three fields: no, effectiveDate, and mid. For us, the important field is mid,
    which stores the PLN/USD exchange rate for the day we have queried. For June 1,
    2020, the exchange rate was 3.960 PLN/USD.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1展示了说明。结果包含一个具有四个字段的对象：表格、货币、代码和汇率。对我们来说，有趣的字段是汇率，它包含一个包含单个对象的数组。这个单个对象有三个字段：no、effectiveDate和mid。对我们来说，重要的字段是mid，它存储了我们查询的那天的PLN/USD汇率。对于2020年6月1日，汇率为3.960
    PLN/USD。
- en: '![CH07_F01_Kaminski2](../Images/CH07_F01_Kaminski2.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F01_Kaminski2](../Images/CH07_F01_Kaminski2.png)'
- en: Figure 7.1 In this JSON data returned by a request to the NBP Web API, key-value
    fields are wrapped in curly braces, and arrays are wrapped in square brackets.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 在对NBP Web API进行请求返回的JSON数据中，键值字段被大括号括起来，数组被方括号括起来。
- en: 7.1.2 Getting the data by using Julia
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 使用Julia获取数据
- en: Now that we understand the structure of the data, we switch to Julia. We will
    fetch the data from the NBP Web API by using the HTTP.get function from the HTTP.jl
    package. Next, we will parse this response by using the JSON reader provided by
    the function JSON3.read from the JSON3.jl package. The following listing presents
    how to execute these steps.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了数据的结构，我们转向Julia。我们将通过使用HTTP.jl包中的HTTP.get函数从NBP Web API获取数据。接下来，我们将使用JSON3.jl包中提供的JSON读取器函数JSON3.read来解析这个响应。下面的列表展示了如何执行这些步骤。
- en: Listing 7.1 Executing the NBP Web API query and parsing the fetched JSON response
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 执行NBP Web API查询和解析获取的JSON响应
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Defines a string with the URL we query
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个包含我们查询的URL的字符串
- en: ❷ Sends an HTTP GET request to the NBP Web API
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向NBP Web API发送HTTP GET请求
- en: ❸ Parses the fetched response data as JSON
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将获取的响应数据解析为JSON
- en: We pass the query string to the HTTP.get function and get the response object.
    We can see in the printed result message that the query is successful, as it has
    a 200 OK status code. In the bottom of the response message, we see the same JSON
    data that we fetched using the web browser.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查询字符串传递给HTTP.get函数并获取响应对象。我们可以在打印的结果消息中看到查询是成功的，因为它有一个200 OK状态码。在响应消息的底部，我们看到与我们在网页浏览器中获取的相同的JSON数据。
- en: 'The response object has several fields, and the one that is important for us
    is body, which stores the vector of fetched bytes:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 响应对象包含多个字段，对我们来说重要的是body字段，它存储了获取的字节向量：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We pass this vector of bytes to the JSON reader function JSON3.read. Before
    discussing this step, let me explain how you can efficiently inspect the contents
    of response.body as a string. You can simply use the String constructor:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个字节向量传递给JSON读取器函数JSON3.read。在讨论这一步之前，让我解释一下如何高效地检查response.body的内容作为字符串。你可以简单地使用String构造函数：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This operation is efficient, which means that the string is wrapped around
    the passed vector of bytes, and no copying of data is performed. This has one
    side effect that we must bear in mind. Since we used the vector of bytes to create
    the String object, the response.body vector is emptied:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作是高效的，这意味着字符串被包裹在传递的字节向量周围，并且没有进行数据复制。这有一个我们必须注意的副作用。由于我们使用了字节向量来创建String对象，所以response.body向量被清空了：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Calling the String constructor on Vector{UInt8} consumes the data stored in
    a vector. The benefit of this behavior is that the operation is very fast. The
    downside is that you can perform the conversion only once. After the operation,
    the response.body vector is empty, so calling String(response.body) again would
    produce an empty string ("").
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '在Vector{UInt8}上调用String构造函数会消耗存储在向量中的数据。这种行为的优点是操作非常快。缺点是转换只能进行一次。操作完成后，response.body向量是空的，因此再次调用String(response.body)会产生一个空字符串(""):'
- en: 'The fact that the String constructor empties the Vector{UInt8} source that
    is passed to it is one of the rare cases in Julia when a function mutates an object
    passed to it that does not have the ! suffix in its name. Therefore, it is important
    that you remember this exception. In our example, if you wanted to preserve the
    value stored in response.body, you should have copied it before passing it to
    the String constructor as follows: String(copy(response.body)).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: String构造函数清空传递给它的Vector{UInt8}源是Julia中很少见的函数之一，当它修改的参数没有以!后缀命名时。因此，记住这个例外非常重要。在我们的例子中，如果你想保留response.body中存储的值，你应该在传递给String构造函数之前将其复制，如下所示：String(copy(response.body))。
- en: 'Now that you understand how to work with the response object, let’s turn to
    the json variable to which we have bound the return value of JSON3.read (response.body).
    A nice feature of the JSON3.read function is that the object it returns can be
    queried just like any other object in Julia. Therefore, use the dot (.) to access
    its fields:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何处理响应对象，让我们转向json变量，它是我们绑定JSON3.read（response.body）返回值的。JSON3.read函数的一个优点是它返回的对象可以像Julia中的任何其他对象一样查询。因此，使用点（.）来访问其字段：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, JSON arrays, like the one stored in the json.rates field, can be
    accessed using 1-based indexing, just like any vector in Julia. Therefore, to
    get the mid field of the first object stored in the json.rates, you can write
    this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，JSON数组，例如存储在json.rates字段中的数组，可以使用基于1的索引来访问，就像Julia中的任何向量一样。因此，要获取存储在json.rates中的第一个对象的mid字段，你可以编写如下代码：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, I’ll introduce a useful function that can be used to ensure correctness
    of one specific use case of getting the data from the array in Julia. If we know
    and want to check that an array contains exactly one element, and we want to extract
    it, we can use the only function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将介绍一个有用的函数，它可以用来确保在Julia中从数组获取数据的一个特定用例的正确性。如果我们知道并想检查一个数组恰好包含一个元素，并且我们想提取它，我们可以使用唯一函数：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An important property of the only function is that it will throw an error if
    our vector contains zero or more than one element:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一函数的一个重要属性是，如果我们的向量包含零个或多个元素，它将抛出一个错误：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The only function is quite useful when writing production code, as it allows
    you to easily catch bugs if your data does not meet the assumptions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写生产代码时，唯一的功能非常有用，因为它允许你轻松地捕获数据不符合假设时出现的错误。
- en: 7.1.3 Handling cases when an NBP Web API query fails
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 处理NBP Web API查询失败的情况
- en: 'Before we proceed to fetching data for a wider range of dates, let’s discuss
    one more feature of the NBP Web API. The scenario I want to consider is what happens
    if we do not have data on the PLN/USD exchange rate for a given day. First, execute
    the following query in your browser:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续获取更广泛日期范围的数据之前，让我们讨论NBP Web API的一个更多功能。我想考虑的场景是，如果我们没有给定日期的PLN/USD汇率数据会发生什么。首先，在你的浏览器中执行以下查询：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should get the following response:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下响应：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We see that in this case, the data has no date for June 6, 2020\. Let’s see
    how this scenario is handled when we try to execute the query programmatically
    in the next listing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到在这种情况下，数据没有2020年6月6日的日期。让我们看看当我们尝试在下一个列表中程序化执行查询时，这个场景是如何处理的。
- en: Listing 7.2 An example of a query that throws an exception
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 抛出异常的查询示例
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The HTTP.get function throws an exception in this case with a 404 error, informing
    us that the requested page was not found. This is a new scenario that we have
    not encountered yet. Let’s discuss how to handle it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP.get函数在这种情况下抛出一个异常，返回404错误，告知我们请求的页面未找到。这是我们尚未遇到的新场景。让我们讨论如何处理它。
- en: An *exception* means that an unexpected situation happened when executing the
    query, and the Julia program is immediately terminated without producing a result.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常*意味着在执行查询时发生了意外情况，Julia程序立即终止而没有产生结果。'
- en: This behavior is useful when we encounter an unexpected situation. However,
    in this case, we could consider the situation expected. We do not want our program
    to halt when we do not get a proper query result. Alternatively, we would most
    likely want to get a result signaling that there was no data for a given day,
    as the PLN/USD exchange rate is missing for this day. Such a value in Julia is
    represented as missing, and section 7.2 details what it means and how it is used.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在我们遇到意外情况时很有用。然而，在这种情况下，我们可以认为这种情况是预期的。我们不希望我们的程序在没有得到适当的查询结果时停止。或者，我们最可能想要得到一个结果，表明给定的一天没有数据，因为这一天缺少PLN/USD汇率。在Julia中，这样的值表示为missing，7.2节详细说明了它的含义和使用方法。
- en: Let’s discuss how to handle exceptions so that they do not terminate our program
    if we do not want them to. For this, we use the try-catch-end block.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论如何处理异常，以便它们不会在我们不希望它们终止程序的情况下终止我们的程序。为此，我们使用try-catch-end块。
- en: '![CH07_F02_Kaminski2](../Images/CH07_F02_Kaminski2.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F02_Kaminski2](../Images/CH07_F02_Kaminski2.png)'
- en: Figure 7.2 The logic of handling HTTP GET errors when using the NBP Web API.
    When fetching data from a remote location, errors often happen, so your code should
    be prepared for such a situation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 使用NBP Web API处理HTTP GET错误的逻辑。当从远程位置获取数据时，错误经常发生，因此你的代码应该为这种情况做好准备。
- en: 'The code in listing 7.3 does the following (see also figure 7.2):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3中的代码执行以下操作（也请参阅图7.2）：
- en: Tries to execute our query in the try part of the block
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在块的try部分执行我们的查询
- en: If the query succeeds, returns its result
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果查询成功，则返回其结果
- en: If the query fails, executes the contents of the catch part of the block
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果查询失败，则执行块的catch部分的代码
- en: Listing 7.3 Using the try-catch-end block to handle exceptions
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 使用try-catch-end块处理异常
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ In the try part, we execute the code that should normally work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在try部分，我们执行应该正常工作的代码。
- en: ❷ Extracts the mid field of the only entry of the rates vector in the fetched
    request response
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从获取的请求响应中提取唯一条目（利率向量）的中场
- en: ❸ If code we try to execute throws an error, stores the error information in
    variable e
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果我们尝试执行的代码抛出错误，将错误信息存储在变量e中
- en: ❹ Checks if the error is caused by a status error of the HTTP server; in such
    a case, produces a missing value
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查错误是否由HTTP服务器的状态错误引起；在这种情况下，产生一个缺失值
- en: ❺ If the error has another cause, rethrows it so that the programmer is informed
    that an unexpected situation happened
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果错误有其他原因，重新抛出它，以便程序员知道发生了意外情况
- en: We can see that for the valid date of June 1, 2020, we get the parsed value
    3.968, and for the invalid date of June 6, 2020, a missing value is produced.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，对于有效的日期2020年6月1日，我们得到解析值3.968，而对于无效日期2020年6月6日，则产生一个缺失值。
- en: 'Let’s recap the structure of the try-catch-end block in the following pseudocode:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下伪代码中回顾一下try-catch-end块的结构：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we are trying to perform three operations we have already discussed:
    fetching the data, parsing it in JSON format, and extracting the exchange rate.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在尝试执行我们已经讨论过的三个操作：获取数据，以JSON格式解析它，并提取汇率。
- en: Now look at the catch part of listing 7.3\. First note the e after the catch
    keyword. This syntax means that we will bind the exception information with the
    variable called e.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看列表7.3中的捕获部分。首先注意捕获关键字后面的e。这种语法意味着我们将异常信息绑定到名为e的变量上。
- en: Next, we use e isa HTTP.ExceptionRequest.StatusError to check whether the exception
    is indeed the problem with the HTTP request This is exactly the type of the exception
    that we saw in listing 7.2\. If there’s a problem with the HTTP request, we produce
    the missing value. However, we do this only if we get this kind of exception.
    In all other cases, we use the rethrow function to re-raise the same exception
    that we just caught.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用e isa HTTP.ExceptionRequest.StatusError来检查异常是否确实是HTTP请求的问题。这正是我们在列表7.2中看到的异常类型。如果有HTTP请求的问题，我们产生缺失值。但是，我们只在这种情况下这样做。在其他所有情况下，我们使用rethrow函数重新抛出我们刚刚捕获的相同异常。
- en: You might ask why we do that. The reason is that we could have gotten an exception
    raised by, for example, the only function. As you already know, this function
    raises an exception if it gets an array that does not have exactly one element.
    If this were the case, we would not want to hide such a problem by producing missing,
    but rather prefer to explicitly warn the user that something unexpected happened
    (we expected a one-element array and got something else).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我们为什么这样做。原因是我们可能会得到由例如唯一函数引发的异常。正如你所知道的那样，如果这个函数接收到一个没有恰好一个元素的数组，它将引发异常。如果这种情况发生，我们不想通过产生缺失值来隐藏这样的问题，而是更愿意明确警告用户发生了意外情况（我们期望一个元素数组，但得到了其他东西）。
- en: Do not blindly catch any exception in your code
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要盲目地在你的代码中捕获任何异常。
- en: It is a good practice that, if you catch exceptions in your code, you should
    always check their type and catch only the exceptions you want to handle gracefully.
    There are many exception types (for example, OutOfMemoryError) that you almost
    never want to silently hide and that could potentially be thrown in an arbitrary
    part of your code. For example, if a Julia program runs out of memory, it is most
    likely not able to proceed correctly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码中捕获异常，一个好的做法是始终检查它们的类型，并且只捕获你想优雅处理的异常。有许多异常类型（例如，OutOfMemoryError），你几乎不希望默默地隐藏，并且它们可能在代码的任意部分抛出。例如，如果一个Julia程序耗尽内存，它很可能无法正确继续执行。
- en: In this section, I have discussed only the simplest use case of the try-catch-end
    block. I discuss this topic so late in the book because, while you need to know
    how to handle exceptions, they should be reserved for exceptional situations.
    In normal situations, it is a better practice to write code in a way that does
    not throw exceptions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我仅讨论了try-catch-end块的最简单用法。我在书中这么晚才讨论这个话题，因为虽然你需要知道如何处理异常，但它们应该保留用于异常情况。在正常情况下，更好的做法是以不抛出异常的方式编写代码。
- en: This recommendation is based on two reasons. First, handling exceptions is relatively
    slow, so having code that heavily uses the try-catch-end block might degrade its
    performance. Second, such code is usually more difficult to reason about.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个建议基于两个原因。首先，处理异常相对较慢，因此大量使用try-catch-end块可能会降低其性能。其次，这样的代码通常更难推理。
- en: If you would like to learn more about handling exceptions, check the “Exception
    Handling” section of the Julia Manual ([http://mng.bz/lR9B](http://mng.bz/lR9B)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于异常处理的信息，请查看Julia手册中的“异常处理”部分（[http://mng.bz/lR9B](http://mng.bz/lR9B)）。
- en: 7.2 Working with missing data in Julia
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 在Julia中处理缺失数据
- en: In our example in section 7.1, we decided to produce missing if the data on
    the PLN/USD exchange rate was missing in the NBP Web API. In this section, we
    will define the missing value and discuss why it is used in data science projects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 7.1 节的例子中，我们决定如果 NBP Web API 中的 PLN/USD 汇率数据缺失，则产生缺失。在本节中，我们将定义缺失值并讨论为什么它在数据科学项目中使用。
- en: Learning to work with a missing value is important because most real-life data
    has quality issues. One of the most common cases you will need to handle in practice
    is when some features of the objects you want to analyze have not been collected.
    For example, imagine you’re analyzing data about the body temperature of a patient
    in a hospital. You expect the measurement to be made every hour. However, sometimes
    the measurement is not made or not recorded. These cases are represented as missing
    in the data you will analyze.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何处理缺失值非常重要，因为大多数现实生活中的数据都存在质量问题。在实践中最常见的处理情况之一是，你想要分析的对象的一些特征尚未收集。例如，想象你正在分析一家医院中患者的体温数据。你期望每小时进行一次测量。然而，有时测量并未进行或未记录。这些情况在你要分析的数据中表现为缺失。
- en: 7.2.1 Definition of the missing value
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 缺失值的定义
- en: 'Let’s start with the definition of the missing value from the Julia Manual
    ([https://docs.julialang.org/en/v1/manual/missing/](https://docs.julialang.org/en/v1/manual/missing/)):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Julia 手册中缺失值的定义开始（[https://docs.julialang.org/en/v1/manual/missing/](https://docs.julialang.org/en/v1/manual/missing/))：
- en: Julia provides support for representing missing values in the statistical sense,
    that is, for situations where no value is available for a variable in an observation,
    but a valid value theoretically exists.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 提供了对表示统计意义上的缺失值的支持，即对于观察中某个变量的值不存在，但理论上存在有效值的情况。
- en: 'This situation is represented as a missing value having a Missing type. The
    Julia language (similarly to R, but unlike, for example, Python) is designed with
    a built-in concept of a missing value. In your code, you do not need to use sentinel
    values to represent the absence of data. You can easily check if a value is missing
    by using the ismissing function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况表示为具有 Missing 类型的缺失值。Julia 语言（类似于 R，但与 Python 等不同）设计时内置了缺失值的概念。在你的代码中，你不需要使用哨兵值来表示数据的缺失。你可以通过使用
    ismissing 函数轻松检查一个值是否缺失：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s recall another value introduced in chapter 3: nothing (of type Nothing).
    How is nothing different? You should use nothing to indicate an objective absence
    of the value, whereas missing represents a value that exists but has not been
    recorded.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下第 3 章中引入的另一个值：无（类型为 Nothing）。无与缺失有何不同？你应该使用无来表示值的客观不存在，而缺失表示一个存在但未被记录的值。
- en: 'To make sure that the difference between missing and nothing is clear, let
    me give a nontechnical example. Assume we have a person, and we ask the brand
    of their car. We can have three situations:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保缺失值和无之间的区别清晰，让我举一个非技术性的例子。假设我们有一个人的信息，我们询问他们的车品牌。我们可以有以下三种情况：
- en: The person has a car, and we know the brand; then we just give it.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个人有一辆车，我们知道品牌；然后我们只需给出它。
- en: We know that the person has a car, but we do not know the brand; then we should
    produce missing since objectively this brand name exists, but we do not know it.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道这个人有车，但我们不知道品牌；那么我们应该产生缺失，因为从客观上讲，这个品牌名称存在，但我们不知道它。
- en: We know that the person does not have a car, and we produce nothing because
    the value is objectively absent.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们知道这个人没有车，我们产生无，因为该值在客观上是不存在的。
- en: Indeed, in some cases there is a thin line between using missing and nothing
    (as in the preceding example—what if we did not even know if the person had a
    car?). However, in practice it is quite easy to decide, given the context of the
    application, whether missing or nothing is more suitable. In the data science
    world, the missing value is predominantly encountered in source data when, for
    some reason, its recording failed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在某些情况下，使用缺失值和无之间的界限很微妙（如前例所示——如果我们甚至不知道这个人是否有车怎么办？）。然而，在实际应用中，根据应用上下文，决定使用缺失值还是无通常很容易。在数据科学领域，缺失值主要在源数据中遇到，当由于某种原因记录失败时。
- en: 7.2.2 Working with missing values
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 处理缺失值
- en: The definition of missing has an important influence on the design of the programming
    languages that natively support it (like Julia or R). In this section, we discuss
    the most important aspects of working with missing values.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的定义对原生支持它的编程语言的设计（如 Julia 或 R）有重要影响。在本节中，我们讨论了处理缺失值的最重要方面。
- en: Propagating missing values in functions
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的缺失值传播
- en: 'The principle is that many functions silently propagate missing—that is, if
    they get missing as an input, they return missing in their output. Here are a
    few examples:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 原则是许多函数会静默地传播缺失值——也就是说，如果它们以缺失值作为输入，它们会以缺失值作为输出返回。以下是一些例子：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One important case of missing propagation is in the context of tests that should
    produce a Bool value:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失传播的一个重要情况是在应该产生布尔值的测试上下文中：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This behavior is often called *three-valued-logic* ([http://mng.bz/o59Z](http://mng.bz/o59Z)),
    as you can get true, false, or missing from a logical operation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为通常被称为 *三值逻辑* ([http://mng.bz/o59Z](http://mng.bz/o59Z))，因为你可以从逻辑运算中获得真、假或缺失。
- en: 'Three-valued-logic is a logically consistent way of handling missing values.
    However, in the context of logical tests, we should be careful if we potentially
    have missing data. The reason is that passing missing as a condition to the conditional
    statement produces an error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 三值逻辑是处理缺失值的一种逻辑上一致的方法。然而，在逻辑测试的上下文中，如果我们可能遇到缺失数据，我们应该小心。原因是将缺失值作为条件传递给条件语句会产生错误：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The design of handling missing in Julia requires you to explicitly decide whether
    missing should be treated as true or false. This is achieved with the coalesce
    function, which you might know from SQL ([http://mng.bz/BZ1r](http://mng.bz/BZ1r)).
    Its definition is simple: coalesce returns its first nonmissing positional argument,
    or missing if all its arguments are missing.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中处理缺失值的设计要求你明确决定缺失值应该被处理为真还是假。这是通过 coalesce 函数实现的，你可能从 SQL 中了解过它（[http://mng.bz/BZ1r](http://mng.bz/BZ1r)）。其定义很简单：coalesce
    返回其第一个非缺失的位置参数，或者如果所有参数都是缺失的，则返回缺失。
- en: 'The use of coalesce is most common with handling logical conditions. If you
    write coalesce(condition, true), you say that if the condition evaluates to missing,
    you want this missing to be treated as true. Similarly, coalesce(condition, false)
    means that you want to treat missing as false. Here is an example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: coalesce 的使用最常见于处理逻辑条件。如果你写 coalesce(condition, true)，这意味着如果条件评估为缺失，你希望这个缺失被视为真。同样，coalesce(condition,
    false) 表示你希望将缺失视为假。以下是一个例子：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: missing values in logical conditions
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑条件中的缺失值
- en: If your data potentially contains missing values that you might use in logical
    conditions, always make sure to wrap them in coalesce with the second argument
    being true or false, depending on how you want the missing to be treated in the
    condition.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据可能包含你可能在逻辑条件中使用的缺失值，请始终确保用 coalesce 包裹它们，第二个参数根据你希望如何处理条件中的缺失值来设置为真或假。
- en: Using comparison operators guaranteeing a Boolean result
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用保证布尔结果的比较运算符
- en: 'Sometimes, however, it is useful to treat missing values in comparisons like
    any other values, without special treatment featuring three-valued logic. If needed
    in your code, you can use the isless function for testing ordering and isequal
    for testing equality. These two functions are guaranteed to return either true
    or false, no matter what value is passed to them. Here are some examples:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，然而，将缺失值在比较中像其他任何值一样处理，而不使用具有三值逻辑的特殊处理，是有用的。如果需要在你的代码中这样做，你可以使用 isless 函数来测试排序，使用
    isequal 来测试相等。这两个函数保证无论传递给它们的值是什么，都会返回真或假。以下是一些例子：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As a special rule, in isless comparisons of missing against numbers, missing
    is always treated as greater than all numbers, so we have the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条特殊规则，在 isless 对缺失值与数字的比较中，缺失值始终被视为大于所有数字，所以我们有以下结果：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In isequal comparisons, missing is treated as equal only to itself.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 isequal 比较中，缺失值仅被视为等于自身。
- en: In addition to the isequal function that guarantees to return a Bool value,
    Julia provides yet another way to compare values for equality that also always
    returns a Bool value. This comparison is performed using the === operator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保证返回布尔值的 isequal 函数之外，Julia 还提供了另一种比较值以返回布尔值的方法。这种比较是通过 === 运算符执行的。
- en: 'The difference between the isequal function and the === operator is that, for
    values that support the notion of equality, isequal is usually implemented to
    compare the values themselves, while === tests whether two values are technically
    identical (in the sense that no program could distinguish them). The distinction
    between comparing content versus technical identity is most often seen when working
    with mutable collections like vectors. Here is an example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`isequal`函数与`===`运算符的区别在于，对于支持相等概念的价值，`isequal`通常被实现为比较值本身，而`===`测试两个值在技术上是否相同（即没有程序可以区分它们）。比较内容与技术身份之间的区别通常在处理如向量之类的可变集合时最为明显。以下是一个示例：'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The a and b vectors have the same contents, so the isequal test returns true.
    However, they are technically different, as they have a different memory location.
    Therefore, the === test returns false. You will see more examples of using the
    === operator in part 2\. Finally, Julia has the !== operator, which always gives
    an opposite answer than ===.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 向量a和b具有相同的内容，因此`isequal`测试返回true。然而，它们在技术上不同，因为它们有不同的内存位置。因此，`===`测试返回false。你将在第2部分中看到更多使用`===`运算符的示例。最后，Julia有`!==`运算符，它总是给出与`===`相反的答案。
- en: Relationship between ===, ==, and isequal
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`===`、`==`和`isequal`之间的关系'
- en: 'Here are the rules that govern how the === and == operators and the isequal
    function are related in Julia:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是控制`===`和`==`运算符以及`isequal`函数之间关系的规则：
- en: The === operator always returns a Bool value and allows us to compare any values
    for identity (in the sense that no program could distinguish them).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`===`运算符始终返回一个Bool值，并允许我们比较任何值以确定其身份（即没有程序可以区分它们）。'
- en: The == operator falls back by default to ===. If a type supports a notion of
    equality in a logical sense (like numbers, strings, or arrays), it defines a special
    method for the == operator. For example, numbers are compared based on their numeric
    value, and arrays are compared based on their contents.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==`运算符默认回退到`===`。如果一个类型在逻辑上支持相等概念（如数字、字符串或数组），它为`==`运算符定义了一个特殊方法。例如，数字是根据它们的数值进行比较的，而数组是根据它们的内容进行比较的。'
- en: 'Therefore, special methods for the == operator are implemented for them. When
    performing comparisons using the == operator, the user must remember the following
    special rules:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，为它们实现了`==`运算符的特殊方法。当使用`==`运算符进行比较时，用户必须记住以下特殊规则：
- en: Comparison against a missing value using == always returns missing.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`==`与缺失值进行比较始终返回缺失值。
- en: Comparison against floating-point NaN values always returns false (see chapter
    2 for more examples of this rule).
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浮点NaN值进行比较始终返回false（有关此规则的更多示例，请参阅第2章）。
- en: Comparison of floating-point positive zero (0.0) and negative zero (-0.0) returns
    true.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点正零（0.0）和负零（-0.0）的比较返回true。
- en: 'The isequal function behaves like the == operator except that it always returns
    a Bool value, and the special rules are defined differently for it:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isequal`函数的行为类似于`==`运算符，但总是返回一个Bool值，并且为其定义了不同的特殊规则：'
- en: Comparison against a missing value using isequal returns false, except if two
    missing values are compared, and then it returns true.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`isequal`与缺失值进行比较返回false，除非两个缺失值进行比较，此时返回true。
- en: Comparison against a floating-point NaN value returns false, except if two NaN
    values are compared, and then it returns true.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与浮点NaN值进行比较返回false，除非两个NaN值进行比较，此时返回true。
- en: Comparison of floating-point positive zero (0.0) and negative zero (-0.0) returns
    false.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点正零（0.0）和负零（-0.0）的比较返回false。
- en: isequal is used to compare keys in dictionaries
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`isequal`用于比较字典中的键。'
- en: It is important to remember that when key-value pairs are stored in the Dict
    dictionary, equality of keys is determined using the isequal function. For example,
    since 0.0 is not equal to -0.0 when compared with isequal, the dictionary Dict(0.0
    => "zero", -0.0 => "negative zero") stores two key-value pairs, one corresponding
    to the 0.0 key and the other to the -0.0 key.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，当键值对存储在`Dict`字典中时，键的相等性是通过`isequal`函数确定的。例如，由于0.0与`isequal`比较时不等于-0.0，字典`Dict(0.0
    => "zero", -0.0 => "negative zero")`存储了两个键值对，一个对应于0.0键，另一个对应于-0.0键。
- en: The same rule applies to grouping and joining data frames (these topics are
    discussed in part 2).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的规则适用于分组和连接数据帧（这些主题将在第2部分中讨论）。
- en: Replacing missing values in collections
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合中替换缺失值
- en: Let’s go back to another common usage of the coalesce function, which is missing
    data imputation. Assume you have a vector that has missing values, as shown in
    the following listing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 coalesce 函数的另一种常见用法，即缺失数据插补。假设你有一个包含缺失值的向量，如下所示。
- en: Listing 7.4 A vector containing missing values
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 包含缺失值的向量
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The x vector contains both integers and missing values, so its element type,
    as explained in chapter 3, is Union{Missing, Int64}. Assume we want to replace
    all missing values with 0. This is easily done by broadcasting the coalesce function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: x 向量包含整数和缺失值，所以它的元素类型，如第 3 章所述，是 Union{Missing, Int64}。假设我们想用 0 替换所有缺失值。这可以通过广播
    coalesce 函数轻松完成：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Skipping missing values in computations
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算中跳过缺失值
- en: 'The propagation of missing values is also sometimes undesirable if they are
    hidden in the collections (like the vector x from listing 7.4). Consider, for
    example, the sum function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺失值隐藏在集合中（如列表 7.4 中的向量 x），则有时也会不希望传播缺失值。例如，考虑 sum 函数：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result is logically correct. We have missing values we want to add, so
    the result is unknown. However, we might very commonly want to add all the nonmissing
    values in the vector. To do this, use the skipmissing function to create a wrapper
    around the x vector:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 结果在逻辑上是正确的。我们有想要添加的缺失值，所以结果是未知的。然而，我们可能非常常见地想要添加向量中的所有非缺失值。为此，使用 skipmissing
    函数创建一个围绕 x 向量的包装器：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now the y variable is bound to a new object that stores the x vector inside
    it, but when y is iterated, it skips missing values stored in x. Now, if you run
    sum on y, you will get the expected result:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 y 变量绑定到一个新对象，它在其内部存储 x 向量，但当你迭代 y 时，它会跳过存储在 x 中的缺失值。现在，如果你在 y 上运行 sum，你会得到预期的结果：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Typically, you would write this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会这样写：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now you might ask why in Julia we create a special object that skips missing
    values. In other languages, like R, functions usually take a keyword argument
    to let the user decide whether missing values should be skipped.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问，为什么在 Julia 中我们创建一个特殊对象来跳过缺失值。在其他语言中，比如 R，函数通常通过关键字参数让用户决定是否跳过缺失值。
- en: 'There are two considerations. First, writing skipmissing(x) is efficient. No
    copying is done here: it is just a way to make sure that no missing values will
    be passed to the function taking skipmissing(x) as an argument. The second reason
    is composability of the design. If we have a skipmissing(x) object, the functions
    that we write (like sum, mean, and var) do not have to explicitly handle missing
    values. They can have one implementation, and the user chooses what should be
    operated on by passing an appropriate argument.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个考虑因素。首先，编写 skipmissing(x) 是高效的。这里没有进行复制：这只是确保不会将缺失值传递给以 skipmissing(x) 作为参数的函数的一种方式。第二个原因是设计的可组合性。如果我们有一个
    skipmissing(x) 对象，我们编写的函数（如 sum、mean 和 var）不需要显式处理缺失值。它们可以有一个实现，用户通过传递适当的参数来选择要操作的内容。
- en: Why is this a benefit? In other ecosystems, some functions have an appropriate
    keyword argument for handling missing values, while others do not, and in the
    latter case, the user has to manually handle this. In Julia, handling missing
    values is abstracted to a higher level.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么好处？在其他生态系统中，一些函数有适当的关键字参数来处理缺失值，而另一些则没有，在后一种情况下，用户必须手动处理。在 Julia 中，处理缺失值被抽象到了更高的层次。
- en: Enabling missing propagation in a function
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中启用缺失值传播
- en: 'One final scenario of missing propagation involves functions that do not propagate
    missing values by default because their designers have decided against it. Let’s
    write a simple function that has this behavior:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种缺失值传播的场景涉及那些默认不传播缺失值的函数，因为它们的设计者决定不这样做。让我们编写一个具有这种行为的简单函数：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This function accepts only Int values as arguments; it errors if it gets a
    missing value:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只接受 Int 类型的参数；如果它接收到缺失值，则会报错：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, in some scenarios, even if the function’s designer has not envisioned
    that someone might want to pass missing to it, we want to create another function,
    based on the original one that propagates missing values. This feature is provided
    by the passmissing function from the Missings.jl package. Here is an example of
    its use:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些场景中，即使函数的设计者没有预见到有人可能想要传递缺失值给它，我们仍然想创建另一个基于原始函数并传播缺失值的函数。这个功能由 Missings.jl
    包中的 passmissing 函数提供。以下是其使用的一个示例：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The idea is simple. The passmissing function takes a function as its argument
    and returns a new function. The returned function, fun2 in this case, returns
    missing if any of its positional arguments are missing. Otherwise, it calls fun
    with the passed arguments.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单。passmissing 函数接受一个函数作为其参数，并返回一个新的函数。返回的函数，在本例中为 fun2，如果其任何位置参数是缺失值，则返回缺失值。否则，它使用传递的参数调用
    fun。
- en: Now you know the basic functionalities of the Julia language that are built
    around the missing value. If you would like to learn more, refer to the Julia
    Manual ([https://docs.julialang.org/en/v1/manual/missing/](https://docs.julialang.org/en/v1/manual/missing/))
    or the documentation of the Missings.jl package ([https://github.com/JuliaData/Missings.jl](https://github.com/JuliaData/Missings.jl)).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了围绕缺失值构建的 Julia 语言的基本功能。如果你想了解更多，请参阅 Julia 手册([https://docs.julialang.org/en/v1/manual/missing/](https://docs.julialang.org/en/v1/manual/missing/))或
    Missings.jl 包的文档([https://github.com/JuliaData/Missings.jl](https://github.com/JuliaData/Missings.jl))。
- en: To wrap up, let me mention that allowing a missing value in collections (for
    example, Vector{Union{Missing, Int}}) has a small performance and memory-consumption
    overhead in comparison to the same collection type that does not allow a missing
    value (for example, Vector{Int}). However, in most cases, this is not noticeable.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，让我提一下，在集合（例如，Vector{Union{Missing, Int}}）中允许缺失值与不允许缺失值的相同集合类型相比，会有轻微的性能和内存消耗开销（例如，Vector{Int}）。然而，在大多数情况下，这并不明显。
- en: Exercise 7.1 Given a vector v = ["1", "2", missing, "4"], parse it so that strings
    are converted to numbers and the missing value remains a missing value.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.1 给定向量 v = ["1", "2", missing, "4"]，解析它，以便将字符串转换为数字，而缺失值保持为缺失值。
- en: 7.3 Getting time-series data from the NBP Web API
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 从 NBP Web API 获取时间序列数据
- en: We are now ready to get back to our problem of analyzing the PLN/USD exchange
    rate. For this example, assume we want to get the data for all days of June 2020\.
    Using what you learned in section 7.1, we will create a function that fetches
    the data from a single day and then apply it to all days in question. But how
    can we list all days in June 2020?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以回到我们的问题，即分析 PLN/USD 汇率。在这个例子中，假设我们想要获取 2020 年 6 月所有天的数据。使用你在 7.1 节中学到的知识，我们将创建一个函数，从单日获取数据，然后将其应用于所有相关日期。但我们如何列出
    2020 年 6 月的所有天？
- en: You need to learn how to work with dates in Julia first. After we are done with
    this, we will come back to our main task.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要学习如何在 Julia 中处理日期。完成这个之后，我们将回到我们的主要任务。
- en: Time-series analysis is often needed in data science projects. To properly handle
    such data, you need to know how to add timestamps to observations. This can be
    conveniently achieved using the Dates module from the Julia standard library.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 时间序列分析在数据科学项目中通常是必需的。为了正确处理此类数据，你需要知道如何向观测值添加时间戳。这可以通过使用 Julia 标准库中的 Dates 模块方便地实现。
- en: 7.3.1 Working with dates
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 与日期一起工作
- en: 'In this section, I will show you how to manipulate dates in Julia. The support
    for dates is provided by the Dates standard module. The easiest way to create
    a date object is to pass to the Date constructor a string in the YYYY-MM-DD format
    you saw in section 7.1\. Here is an example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示如何在 Julia 中操作日期。日期支持由 Dates 标准模块提供。创建日期对象的最简单方法是将字符串传递给 Date 构造函数，该字符串的格式与你在
    7.1 节中看到的 YYYY-MM-DD 格式相同。以下是一个示例：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we can inspect the object bound to the variable d, first checking its type,
    and then extracting the year, month, and date parts:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以检查绑定到变量 d 的对象，首先检查其类型，然后提取年、月和日期部分：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In addition to natural functions like year, month, and day, Julia provides
    several more-advanced functions. Here, let me show you how to query a date for
    its day-of-the-week number and name in English:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像年、月和日这样的自然函数之外，Julia 还提供了几个更高级的函数。在这里，让我向你展示如何查询日期的星期数和英文名称：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can find a complete list of available functions in the “API Reference” section
    of the Julia Manual ([http://mng.bz/derv](http://mng.bz/derv)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Julia 手册的“API 参考”部分找到可用函数的完整列表([http://mng.bz/derv](http://mng.bz/derv))。
- en: If you have strings containing dates that do not follow the YYYY-MM-DD format,
    you can use the DateFormat object to specify a custom date format. See the “Constructors”
    section of the Julia Manual ([http://mng.bz/rn6e](http://mng.bz/rn6e)) for details.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些不遵循 YYYY-MM-DD 格式的日期字符串，你可以使用 DateFormat 对象来指定自定义日期格式。有关详细信息，请参阅 Julia
    手册的“构造函数”部分([http://mng.bz/rn6e](http://mng.bz/rn6e))。
- en: 'Another common way of constructing the date is to pass the numbers representing
    the year, month, and day that make up the date:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 构建日期的另一种常见方式是传递表示日期的年、月和日的数字：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The last constructor gives us an easy way to create a vector of dates from June
    2020, using broadcasting, as shown in the following listing.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个构造函数为我们提供了一个简单的方法来创建从2020年6月开始的日期向量，使用广播，如下所示。
- en: Listing 7.5 Creating a vector of all dates in June 2020
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 创建2020年6月所有日期的向量
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This way of creating a sequence of date objects is easy, but only for dates
    spanning within one month. What if we want dates from May 20, 2020 to July 5,
    2020? To solve this question, we need to use a duration measure. For our purpose,
    the Day duration is proper. For instance, Day(1) is an object representing a time
    interval equal to one day:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种创建日期对象序列的方式很简单，但仅适用于跨一个月的日期。如果我们想要从2020年5月20日到2020年7月5日的日期呢？为了解决这个问题，我们需要使用持续时间度量。对于我们的目的，日持续时间是合适的。例如，Day(1)是一个表示等于一天的时间间隔的对象：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now the important thing is that you can add dates with durations to get new
    dates. For example, to get the next day after June 1, 2020, you can write this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重要的是，你可以添加带有持续时间的日期来获取新的日期。例如，要获取2020年6月1日之后的第二天，你可以这样写：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You might have guessed how we can write a range of dates separated by one day.
    You can achieve this by using a range. All dates from May 20, 2020 to July 5,
    2020 inclusive are as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了如何写一个由一天分隔的日期范围。你可以通过使用范围来实现这一点。以下是从2020年5月20日到2020年7月5日（包括）的所有日期：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can check that this range produces the expected set of values by using
    the collect function on it to convert it into a Vector:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用collect函数来检查这个范围是否产生了预期的值集，将其转换为Vector：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Other measures of time duration exist, such as Week and Year. You can learn
    more about them and the rules of date arithmetic in the “TimeType-Period Arithmetic”
    section of the Julia Manual ([http://mng.bz/VyBW](http://mng.bz/VyBW)).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着其他时间持续度的度量，例如周和年。你可以在Julia手册的“TimeType-Period Arithmetic”部分中了解更多关于它们和日期算术规则的信息（[http://mng.bz/VyBW](http://mng.bz/VyBW)）。
- en: Finally, Julia also allows you to work with time and date-time objects. The
    details can be found in the “Dates” section of the Julia Manual ([https://docs.julialang.org/en/v1/stdlib/Dates/](https://docs.julialang.org/en/v1/stdlib/Dates/)).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Julia还允许你与时间和日期时间对象一起工作。详细信息可以在Julia手册的“Dates”部分中找到（[https://docs.julialang.org/en/v1/stdlib/Dates/](https://docs.julialang.org/en/v1/stdlib/Dates/)）。
- en: Exercise 7.2 Create a vector containing the first day of each month in the year
    2021.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 练习7.2 创建一个包含2021年每月第一天日期的向量。
- en: 7.3.2 Fetching data from the NBP Web API for a range of dates
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 从NBP Web API获取一系列日期的数据
- en: Now that we’ve created a dates vector of dates for which we want to get the
    PLN/USD exchange rate data (in listing 7.5), let’s write a function in the next
    listing that gets data for a specific date. We’ll follow the steps explained in
    section 7.1 so that we can easily collect the data for all required dates.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了一个包含我们想要获取PLN/USD汇率数据的日期向量（在列表7.5中），那么让我们在下一个列表中编写一个函数来获取特定日期的数据。我们将遵循第7.1节中解释的步骤，这样我们就可以轻松地收集所有所需日期的数据。
- en: Listing 7.6 Function for fetching the PLN/USD exchange rate data for a specific
    date
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 获取特定日期PLN/USD汇率数据的函数
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This function collects our code from section 7.1 with a few small changes. First,
    we accept date with a Date as its argument, so we are sure that the user does
    not call our get_rate function with an arbitrary value that would get interpolated
    into the query string. Also note that I define the get_rate function to accept
    only a scalar Date. This is the recommended style of defining functions in Julia,
    as I explained in chapter 5\. Later we will broadcast this function over the dates
    vector to get a vector of PLN/USD exchange rates.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数对我们的第7.1节中的代码进行了一些小的修改。首先，我们接受一个Date作为其参数，这样我们就可以确保用户不会用任意值调用我们的get_rate函数，这个值会被插入到查询字符串中。此外，请注意，我将get_rate函数定义为只接受标量Date。这是在Julia中定义函数的推荐风格，正如我在第5章中解释的那样。稍后我们将在这个日期向量上广播这个函数，以获取PLN/USD汇率向量。
- en: 'Next, to form the query string, we interpolate date into it. As we discussed
    in chapter 6, the interpolation is done by using the $ character followed by the
    name of the interpolated variable. Here is an example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了形成查询字符串，我们将日期插入其中。正如我们在第6章中讨论的，插入是通过使用$字符后跟插入变量的名称来完成的。以下是一个示例：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To give one more example, here is a way to interpolate the first value from
    the dates vector that we defined in listing 7.5 (the interpolated parts are in
    bold):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了再举一个例子，这里有一种方法来插值我们在列表7.5中定义的dates向量中的第一个值（插值部分是加粗的）：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This time, as an example, we interpolate the expression dates[1], so to make
    sure it gets properly interpolated, we wrap it in parentheses. If we omitted the
    parentheses, the whole dates vector would get interpolated, followed by the [1]
    character sequence, which is not what we want (again the interpolated part is
    in bold):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，作为一个例子，我们插值dates[1]，为了确保它得到适当的插值，我们将其括在括号中。如果我们省略括号，整个dates向量都会被插值，然后是[1]字符序列，这并不是我们想要的（再次强调，插值部分是加粗的）：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The final change is, following the rule I introduced in chapter 2, that we explicitly
    write the return keyword in two places in the code to make sure that the value
    that will be returned by the get_rate function is clearly visible.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的修改是，根据我在第二章中介绍的规则，我们在代码中明确写出return关键字两次，以确保get_rate函数将返回的值清晰可见。
- en: Now we are all set to fetch the exchange PLN/USD exchange rates for June 2020
    in the next listing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在下一列表中获取2020年6月的PLN/USD汇率。
- en: Listing 7.7 Fetching the PLN/USD exchange rates for June 2020
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7 获取2020年6月的PLN/USD汇率
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We use the dot (.) after the get_rate function to apply it to all elements of
    the dates vector. Additionally, the result is a Vector having the element type
    Union{Float64, Missing}, which means that in the result, we have a mixture of
    missing values and floating-point numbers.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在get_rate函数后面使用点（.）来将其应用于dates向量的所有元素。此外，结果是一个具有元素类型Union{Float64, Missing}的Vector，这意味着在结果中，我们有缺失值和浮点数的混合。
- en: 7.4 Analyzing data fetched from the NBP Web API
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 分析从NBP Web API获取的数据
- en: 'Having defined the dates variable in listing 7.5 and the rates variable in
    listing 7.7, let’s analyze the data to understand its content. We want to do the
    following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表7.5中定义了dates变量，在列表7.7中定义了rates变量后，让我们分析数据以了解其内容。我们想要做以下事情：
- en: 'Calculate basic summary statistics of the data: the mean and standard deviation
    of the rates vector'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算数据的基本摘要统计量：率的向量的平均值和标准差
- en: Analyze for which days of the week we encounter missing data in our vector
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析我们向量中缺失数据出现的星期几
- en: Display the PLN/USD exchange rate on a plot
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图表上显示PLN/USD汇率
- en: The key new skill you will acquire is performing this analysis while considering
    the temporal nature of data and proper handling of missing values.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得的关键新技能是在考虑数据的时序性质和适当处理缺失值的同时进行此分析。
- en: 7.4.1 Computing summary statistics
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 计算摘要统计量
- en: 'First, we want to calculate the mean and standard deviation of the rates vector
    defined in listing 7.7\. Our first attempt uses the mean and std functions from
    the Statistics module:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要计算列表7.7中定义的率的向量的平均值和标准差。我们的第一次尝试使用了Statistics模块中的mean和std函数：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Unfortunately, this is not what we expect. As explained in section 7.2, we
    need to additionally use the skipmissing function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这并不是我们预期的结果。如第7.2节所述，我们需要额外使用skipmissing函数：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the analyzed period, the PLN/USD exchange rate is just below 4 PLN/USD with
    a standard deviation of around 0.02.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析期间，PLN/USD汇率略低于4 PLN/USD，标准差约为0.02。
- en: 7.4.2 Finding which days of the week have the most missing values
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 找出哪些星期几缺失值最多
- en: As discussed in section 7.3, the dayname function returns the English name of
    the given day. Therefore, we can use the proptable function that you learned in
    chapter 6 to get the desired result by cross-tabulating dayname.(dates) and ismissing
    .(rates), as shown in the next listing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如第7.3节所述，dayname函数返回给定日期的英文名称。因此，我们可以使用你在第6章中学到的proptable函数，通过交叉表dayname.(dates)和ismissing
    .(rates)来获取所需的结果，如下一列表所示。
- en: Listing 7.8 Frequency table of proportions of days with missing data in rates
    vector
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8 率向量中缺失数据天数的频率表
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can see that we always have missing data for Saturday and Sunday. For all
    other days, no data is missing except for Thursday. Let’s find which Thursdays
    are problematic. For this, create a Boolean vector that finds the indices in our
    vector that meet both conditions using broadcasting:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，周六和周日我们总是有缺失数据。对于其他所有日子，除了周四，没有数据缺失。让我们找出哪些周四有问题。为此，创建一个布尔向量，使用广播找到满足两个条件的索引：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We can use this Boolean vector to find elements of the dates vector for which
    the condition is true, as the following listing shows.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个布尔向量来找到日期向量中满足条件的元素，如下列所示。
- en: Listing 7.9 Finding Thursdays on which the rates vector contains a missing value
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.9 查找汇率向量包含缺失值的星期四
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can see that a single day meets our condition. You could confirm that this
    date was a national holiday in Poland, so the result seems reasonable.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，一个单独的日子符合我们的条件。你可以确认这个日期在波兰是一个国家假日，所以结果看起来是合理的。
- en: 'You’ll learn more details in part 2 that are relevant to this example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第2部分学到更多与此示例相关的细节：
- en: In the table presented in listing 7.8, the days are ordered alphabetically.
    In part 2, you will learn that you can order the rows to follow the standard order
    of the days of the week by using the CategoricalArrays.jl package.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表7.8中展示的表中，日期是按字母顺序排序的。在第2部分，你将了解到，你可以使用CategoricalArrays.jl包按一周中日期的标准顺序对行进行排序。
- en: In listing 7.9, the condition used looks a bit complex. In part 2, you will
    learn that you can make the selection more easily if you keep the dates and rates
    vectors in a DataFrame.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表7.9中，所使用的条件看起来有点复杂。在第2部分，你将了解到，如果你将日期和汇率向量保存在DataFrame中，你可以更容易地进行选择。
- en: 7.4.3 Plotting the PLN/USD exchange rate
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 绘制 PLN/USD 汇率图
- en: 'As a final step, let’s create a plot of the PLN/USD exchange rate. Start with
    the simplest approach, passing the dates and rates vectors to the plot function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们创建一个PLN/USD汇率图的图表。从最简单的方法开始，将日期和汇率向量传递给绘图函数：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Figure 7.3 shows the plot. It does not look very nice, as it contains gaps in
    places where we have missing values in the rates vector.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3显示了该图表。它看起来不太美观，因为它在汇率向量中缺失值的地方有间隙。
- en: '![CH07_F03_Kaminski2](../Images/CH07_F03_Kaminski2.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F03_Kaminski2](../Images/CH07_F03_Kaminski2.png)'
- en: Figure 7.3 In this basic plot of dates against the rates vector, we have gaps
    in places where values in the vector are missing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 在这个日期与汇率向量的基本图表中，我们在向量中值缺失的地方有间隙。
- en: 'To fix the plot, let’s skip the days in both dates and rates vectors in places
    where the rates vector contains missing values. We can again use the Boolean vector
    of valid indices. The syntax is slightly tricky:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个图表，让我们跳过日期和汇率向量中包含缺失值的那些日子。我们再次可以使用有效的索引的布尔向量。语法稍微有点棘手：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How should we read it? For a single value passed, !ismissing is a negation of
    the return value produced by the ismissing function. Now we know that we need
    to prefix the bang (!) operator with a dot (.) to broadcast it, but we need to
    suffix the dot (.) to the ismissing part, which gives us the syntax that I have
    used.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何读取它？对于传递的单个值，!ismissing是ismissing函数产生的返回值的否定。现在我们知道我们需要在感叹号(!)操作符前加上点(.)来广播它，但我们需要在ismissing部分后加上点(.)，这给了我们我使用的语法。
- en: 'Therefore, the plot with skipped missing values can be produced using the following
    command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以通过以下命令生成跳过缺失值的图表：
- en: '[PRE54]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Similarly to the note made at the end of section 7.4.2, this operation could
    have been done more cleanly if the data were stored in a DataFrame. We will discuss
    this topic in part 2.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与7.4.2节末尾提到的笔记类似，如果数据存储在DataFrame中，这个操作可以做得更干净。我们将在第2部分讨论这个话题。
- en: Figure 7.4 shows the result you should get. Observe that on the plot’s x-axis,
    the observations are properly spaced according to their dates. This effectively
    means that in figure 7.4, visually we have *linearly interpolated* the values
    for the days for which the data was missing in figure 7.3—that is, the dots in
    the plot are connected by straight lines.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4显示了你应该得到的结果。观察图表的x轴，观测值根据它们的日期适当地间隔。这意味着在图7.4中，从视觉上看，我们对图7.3中数据缺失的日期进行了线性插值——即图表中的点通过直线连接。
- en: '![CH07_F04_Kaminski2](../Images/CH07_F04_Kaminski2.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F04_Kaminski2](../Images/CH07_F04_Kaminski2.png)'
- en: Figure 7.4 A plot of dates against the rates vector with skipped missing values.
    The plot, unlike in figure 7.3, is continuous.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 跳过缺失值的日期与汇率向量图表。与图7.3不同，这个图表是连续的。
- en: 'You can perform linear interpolation of your data by using the Impute.interp
    function from the Impute.jl package. Given a vector, this function fills all missing
    values between two nonmissing values by using linear interpolation:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Impute.jl包中的Impute.interp函数执行数据的线性插值。给定一个向量，这个函数通过线性插值使用两个非缺失值之间的所有缺失值：
- en: '[PRE55]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The Impute.jl package has many more features that facilitate handling of missing
    data. I recommend you check the package’s repository ([https://github.com/invenia/Impute.jl](https://github.com/invenia/Impute.jl))
    for details.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Impute.jl包具有许多更多功能，这些功能有助于处理缺失数据。我建议你查看该包的仓库（[https://github.com/invenia/Impute.jl](https://github.com/invenia/Impute.jl)）以获取详细信息。
- en: 'To conclude our project, let’s add a scatterplot of dates against the rates_
    filled vector to the plot shown in figure 7.4 to check that linear interpolation
    was indeed used there:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的项目，让我们将日期与`rates_filled`向量的散点图添加到图7.4所示的图表中，以检查是否确实使用了线性插值：
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We use the scatter! function (with ! at the end) to update the previous plot
    with additional data. Figure 7.5 shows the result of our operation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用带有感叹号结尾的 `scatter!` 函数来更新之前的图表，并添加额外的数据。图7.5展示了我们操作的结果。
- en: '![CH07_F05_Kaminski2](../Images/CH07_F05_Kaminski2.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F05_Kaminski2](../Images/CH07_F05_Kaminski2.png)'
- en: Figure 7.5 A plot of dates against the rates vector with skipped missing values
    and an added scatterplot of the rates_filled vector that holds missing data imputed
    using linear interpolation. The shape of the plot is the same as in figure 7.4.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：一个日期与利率向量的散点图，跳过了缺失值，并添加了一个散点图，该散点图表示使用线性插值填充的缺失数据。该图表的形状与图7.4相同。
- en: If you would like to learn more about attributes that you can pass to plotting
    functions provided by the Plots.jl package, the “Attributes” section of its manual
    ([https://docs.juliaplots.org/stable/attributes/](https://docs.juliaplots.org/stable/attributes/))
    is a good starting point. In the context of plots presented in figures 7.3-7.5,
    you might, for example, find it useful to define custom ticks on the x-axis by
    using the xticks keyword argument so they use a different spacing or display format
    than the one used by default. Using this functionality, let’s reproduce figure
    7.4 with x-axis ticks for dates for which we have nonmissing data. Figure 7.6
    presents the result we want.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于可以传递给Plots.jl包提供的绘图函数的属性，其手册中的“属性”部分（[https://docs.juliaplots.org/stable/attributes/](https://docs.juliaplots.org/stable/attributes/））是一个很好的起点。在图7.3-7.5所展示的图表的上下文中，例如，你可能会发现使用xticks关键字参数定义自定义的x轴刻度很有用，这样它们就可以使用与默认不同的间距或显示格式。使用这个功能，让我们用具有非缺失数据的日期的x轴刻度来重现图7.4。图7.6展示了我们想要的结果。
- en: '![CH07_F06_Kaminski2](../Images/CH07_F06_Kaminski2.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![CH07_F06_Kaminski2](../Images/CH07_F06_Kaminski2.png)'
- en: Figure 7.6 Adding x-axis ticks at dates for which we have data in a plot of
    dates against the rates vector with skipped missing values.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：在日期与利率向量的散点图中添加了具有数据的日期的x轴刻度，跳过了缺失值。
- en: Figure 7.6, in comparison to figure 7.4, has three changes. First, we have x-axis
    ticks located at dates. We achieve this by adding the xticks=dates[rates_ok] keyword
    argument to the plot call. Second, since we now have a lot of ticks, we print
    them vertically, which is achieved by the xrot=90 keyword argument. Third, now
    that the labels take up much more vertical space, we increase the bottom margin
    of the plot with the bottommargin=5Plots.mm keyword argument.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 与图7.4相比，图7.6有三个变化。首先，我们有了位于日期处的x轴刻度。我们通过在绘图调用中添加xticks=dates[rates_ok]关键字参数来实现这一点。其次，由于现在有很多刻度，我们垂直打印它们，这是通过xrot=90关键字参数实现的。第三，由于标签占据了更多的垂直空间，我们通过bottommargin=5Plots.mm关键字参数增加了图表的底部边距。
- en: You might ask what 5Plots.mm means. This expression defines a value that represents
    5 millimeters. This functionality is provided by the Measures.jl package and is
    available in the Plots.jl package. We need to use the Plots. prefix, as Plots.jl
    does not export the mm constant. The capability to define dimensions of the plot
    in Plots.jl by using absolute measures of length (millimeters, in our case) is
    often useful when you want to create production-quality plots.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问5Plots.mm代表什么。这个表达式定义了一个代表5毫米的值。这个功能由Measures.jl包提供，并在Plots.jl包中可用。我们需要使用Plots.前缀，因为Plots.jl没有导出mm常量。在Plots.jl中使用长度的绝对度量（在我们的例子中是毫米）来定义图表的尺寸的能力，当你想要创建生产质量的图表时通常很有用。
- en: 'Here is the complete code producing figure 7.6:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成图7.6的完整代码：
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To wrap up this chapter, try the following more advanced exercise.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本章内容，尝试以下更高级的练习。
- en: Exercise 7.3 The NBP Web API allows you to get a sequence of rates for a period
    of dates. For example, the query ["https://api.nbp.pl/api/exchangerates/rates/a/usd/2020-06-01/2020-06-30/?format=json"](https://api.nbp.pl/api/exchangerates/rates/a/usd/2020-06-01/2020-06-30/?format=json)
    returns a sequence of rates from June 2020 for dates when the rate is present—in
    other words, dates for which there is no rate are skipped. Your task is to parse
    the result of this query and confirm that the obtained result is consistent with
    the data we collected in the dates and rates vectors.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.3 NBP Web API 允许你获取一段时间内日期的汇率序列。例如，查询 ["https://api.nbp.pl/api/exchangerates/rates/a/usd/2020-06-01/2020-06-30/?format=json"](https://api.nbp.pl/api/exchangerates/rates/a/usd/2020-06-01/2020-06-30/?format=json)
    返回了 2020 年 6 月的汇率序列，这些汇率存在于特定日期——换句话说，没有汇率的日期会被跳过。你的任务是解析这个查询的结果，并确认获得的结果与我们收集的日期和汇率向量中的数据一致。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: JSON is a storage format often used to exchange data. It allows you to handle
    complex data structures, including both objects (providing key-value mapping)
    and arrays (storing sequences of values).
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 是一种常用于交换数据的存储格式。它允许你处理复杂的数据结构，包括对象（提供键值映射）和数组（存储值序列）。
- en: The HTTP.get function from the HTTP.jl package can be used to send HTTP GET
    request messages. If the request fails, this function throws the HTTP .ExceptionRequest.StatusError
    exception.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 HTTP.jl 包的 HTTP.get 函数可以用来发送 HTTP GET 请求消息。如果请求失败，此函数会抛出 HTTP .ExceptionRequest.StatusError
    异常。
- en: You can handle the exceptions thrown by Julia by using try-catch-end blocks.
    Use this functionality with care and catch only exceptions that you really want
    to handle.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用 try-catch-end 块来处理 Julia 抛出的异常。请谨慎使用此功能，并仅捕获你真正想要处理的异常。
- en: 'You can parse JSON data in Julia by using the JSON3.read function from the
    JSON3.jl package. The resulting value can be accessed using standard Julia syntax:
    object keys can be retrieved using the dot (.) syntax, and array elements using
    indexing.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用 JSON3.jl 包中的 JSON3.read 函数在 Julia 中解析 JSON 数据。结果值可以使用标准的 Julia 语法访问：可以使用点（.）语法检索对象键，使用索引访问数组元素。
- en: Julia provides the missing value for situations where no value is available
    for a variable in an observation, but a valid value theoretically exists. This
    special value was introduced in Julia since it is often needed, as real-life data
    is rarely complete.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 提供了缺失值，用于在观察中某个变量的值不存在，但理论上存在有效值的情况。这个特殊值在 Julia 中被引入，因为它经常被需要，因为现实生活中的数据很少是完整的。
- en: 'Many standard Julia functions propagate missing values: if they get missing
    as an argument, they return missing as a result. As a consequence, if you use
    these functions, you do not need to add any special code to handle missing data.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多标准的 Julia 函数会传播缺失值：如果它们接收到缺失值作为参数，它们会返回缺失值作为结果。因此，如果你使用这些函数，你不需要添加任何特殊代码来处理缺失数据。
- en: Use the coalesce function to provide the default value for missing if you have
    a variable that might take this value. It is especially useful when writing logical
    conditions. You write coalesce(x, false) if you want the expression to produce
    false if x is missing, and leave the value of x otherwise.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个可能取此值的变量，可以使用 coalesce 函数为缺失值提供默认值。这在编写逻辑条件时特别有用。如果你想表达式在 x 缺失时产生 false，而在其他情况下保留
    x 的值，则编写 coalesce(x, false)。
- en: If you have a data collection that contains missing values, you can use the
    skipmissing wrapper to efficiently create (without copying data) another collection
    that has these missing values removed.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的数据集中包含缺失值，你可以使用 skipmissing 包装器来高效地创建（不复制数据）另一个集合，该集合已移除这些缺失值。
- en: If you have a function that does not accept missing values by default, you can
    wrap it with the passmissing function to turn it into a function that propagates
    missing values.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个默认不接受缺失值的函数，你可以使用 passmissing 函数将其包装成传播缺失值的函数。
- en: The Dates standard module provides functionality for working with date, time,
    and date-time objects. You will likely use this module if you work with temporal
    data.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dates 标准模块提供了处理日期、时间和日期时间对象的功能。如果你处理时间数据，你可能会使用这个模块。
- en: You can use the Date object to represent instances of time as a date. Several
    objects (such as Day and Month) allow you to represent time periods. You can perform
    arithmetic operations on objects representing instances and periods of time. This
    built-in feature of the Dates standard module is useful as rules of arithmetic
    involving dates are complex, so you do not need to implement them yourself.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用日期对象来表示日期作为时间的实例。几个对象（如Day和Month）允许您表示时间段。您可以对表示时间和时间段实例的对象执行算术运算。日期标准模块的这项内置功能很有用，因为涉及日期的算术规则很复杂，所以您不需要自己实现它们。
- en: Julia provides many convenience functions, such as dayofweek and dayname, that
    allow you to query Date objects. Such information is often needed when analyzing
    temporal data.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia提供了许多便利函数，例如dayofweek和dayname，允许您查询日期对象。在分析时间数据时，此类信息通常很有用。
- en: When plotting data by using the plot function from the Plots.jl package, missing
    data is skipped. You need to take this into account when designing your plots.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用来自Plots.jl包的plot函数绘制数据时，缺失的数据会被跳过。在设计您的图表时，您需要考虑这一点。
- en: Plots.jl properly handles Date objects passed to it and ensures that spacing
    of points on the plot follows the distance between dates in the calendar. This
    is an important feature, as the distance on the plot is proportional to an interval
    between dates.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Plots.jl正确处理传递给它的日期对象，并确保图表上点的间距遵循日历中日期之间的距离。这是一个重要特性，因为图表上的距离与日期之间的间隔成正比。
- en: If you want to perform linear interpolation of missing values in a time series
    of data, you can use the Impute.interp function from the Impute.jl package. Using
    this package saves you the effort of implementing the interpolation code yourself.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想在数据序列的缺失值上执行线性插值，可以使用来自Impute.jl包的Impute.interp函数。使用此包可以节省您实现插值代码的精力。
