- en: 7 Doing it with style
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 以风格行事
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Application styling
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序风格
- en: Integrating Bootstrap styling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Bootstrap 风格
- en: Creating a scalable MyBlog
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可扩展的 MyBlog
- en: Using Blueprint namespaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蓝图命名空间
- en: Application configuration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序配置
- en: Integrating the Flask Debug Toolbar
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Flask 调试工具栏
- en: Configuring logging information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置日志信息
- en: Creating a web application pulls together many concepts and technologies. To
    create an engaging application, it’s necessary to think about the look and feel,
    or style. For a web application, this is largely provided by using CSS styling
    applied to the HTML content.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网络应用程序需要整合许多概念和技术。为了创建引人入胜的应用程序，有必要考虑外观和感觉，或风格。对于网络应用程序，这主要是由应用于 HTML 内容的
    CSS 风格提供的。
- en: Integrating good styling practices raises the bar of complexity an application
    encapsulates. To help maintain growing complexity, it’s necessary to think about
    project structure and the use of namespaces. Project structure and namespaces
    help the project grow and scale in a way that keeps the complexity manageable.
    This chapter lays the foundation for the MyBlog application so that it can grow
    and evolve in a way that will help you maintain clarity about the goals of the
    application and stay ahead of the complexity curve.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 集成良好的风格实践提高了应用程序封装的复杂性。为了帮助维持不断增长复杂性，有必要考虑项目结构和命名空间的使用。项目结构和命名空间有助于项目以保持可管理复杂性的方式增长和扩展。本章为
    MyBlog 应用程序奠定了基础，以便它可以以有助于您保持对应用程序目标清晰并领先于复杂性曲线的方式增长和演变。
- en: 7.1 Application styling
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 应用程序风格
- en: Creating an application with interesting and useful features is necessary to
    keep users actively engaged in any application. The feature set is essential,
    but it’s not the only thing needed to capture and keep users’ attention. The way
    your application looks is a critical factor in what your users will expect in
    a modern computer system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有有趣和有用功能的网络应用程序对于保持用户在任何应用程序中的积极参与是必要的。功能集是必不可少的，但并非唯一需要吸引并保持用户注意力的因素。应用程序的外观是用户对现代计算机系统期望的关键因素。
- en: Look at any popular cell phone app and you’ll know this is true. The best apps
    have both useful feature sets and an engaging visual experience for their users.
    Even apps with compelling features will be hard pressed to find users willing
    to accept and use them if the app looks clunky and unpolished.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 看看任何流行的手机应用程序，你就会知道这是真的。最好的应用程序既有有用的功能集，又为用户提供引人入胜的视觉体验。即使应用程序具有吸引人的功能，如果应用程序看起来笨拙且未经打磨，也很难找到愿意接受和使用它们的用户。
- en: 'The browser’s CSS styling code controls a web application’s visual look to
    determine how to render the HTML code to the screen. The first web application
    from chapter 6 used simple, hand-crafted CSS code to apply a distinct look and
    feel. Continuing to hand-code CSS styles for the MyBlog application is possible
    but has the following drawbacks:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的 CSS 风格代码控制网络应用程序的视觉外观，以确定如何将 HTML 代码渲染到屏幕上。第 6 章的第一个网络应用程序使用了简单、手工编写的 CSS
    代码来应用独特的外观和感觉。继续为 MyBlog 应用程序手动编写 CSS 风格是可能的，但存在以下缺点：
- en: It takes effort to create appealing CSS styles.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建吸引人的 CSS 风格需要付出努力。
- en: As an application grows, it becomes challenging to maintain style consistency
    across an entire application.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，在整个应用程序中保持风格一致性变得具有挑战性。
- en: Normalizing styles for consistent rendering across multiple browsers is tricky.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个浏览器之间进行样式标准化以实现一致的渲染是棘手的。
- en: Phones and tablets are becoming the primary interface between an application
    and your users; making a web application responsive to those devices is vital.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机和平板电脑正成为应用程序与用户之间的主要接口；使网络应用程序对那些设备做出响应是至关重要的。
- en: 7.1.1 Creating appealing styles
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 创建吸引人的风格
- en: The first web application from chapter 6 had a single page with relatively simple
    styles applied to it that consisted of two files—`myblog.css` and `index.css`—each
    of which was about a page of text long. Continuing to create custom styles leads
    to many CSS files containing hundreds of lines of code. It becomes apparent very
    quickly that this is additional hard work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章的第一个网络应用程序只有一个页面，上面应用了相对简单的样式，由两个文件组成——`myblog.css` 和 `index.css`——每个文件大约有一页的文本长。继续创建自定义样式会导致许多包含数百行代码的
    CSS 文件。很快就会很明显，这需要额外的辛勤工作。
- en: 7.1.2 Styling consistency
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 风格一致性
- en: A web application with even moderate complexity will have multiple pages associated
    with it that users will navigate around. Making sure the buttons, lists, panels,
    and other visual elements look the same across all pages is important to the cohesive
    picture you’re trying to paint across the entire application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是具有中等复杂性的网络应用，也会与其关联多个页面，用户会在这些页面之间导航。确保按钮、列表、面板和其他视觉元素在所有页面上的外观一致，对于你在整个应用中试图描绘的统一画面来说非常重要。
- en: Giving those visual elements the same style, even in different use cases within
    the application, is challenging. Maintaining that consistent style as your application
    scales upward with more features and pages compounds that challenge.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在应用的不同用例中，给这些视觉元素相同的样式也是一项挑战。随着你的应用随着更多功能和页面的增加而扩展，保持这种一致样式会加剧这个挑战。
- en: 7.1.3 Normalizing styles
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 样式标准化
- en: Like myself, you probably use a single web browser most of the time. Even if
    you use one at home and another at work, you might be unaware of the importance
    of styling consistency and the need to normalize styles across browsers. When
    you’re building an application and generating HTML code without any styles applied
    to it, the browser will render the HTML using its default styles.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 和我一样，你可能大多数时间都使用单个网络浏览器。即使你在家里和工作场所使用不同的浏览器，你也可能没有意识到样式一致性以及在不同浏览器间标准化样式的必要性。当你构建一个应用并生成没有任何样式应用到的HTML代码时，浏览器会使用其默认样式来渲染HTML。
- en: Each browser applies its default style to headers, paragraphs, fonts, and spacing
    between elements. If you could suppress the CSS style when navigating to web applications
    that you’re familiar with, you’d see how the pages are rendered with the browser’s
    default style. If you were to do the same thing using multiple browsers like Chrome,
    Firefox, Safari, Edge, and others across multiple operating systems, you’d see
    the pages rendered differently between those browsers—sometimes subtly, sometimes
    dramatically. Giving any web application you create a consistent look across the
    different browsers and operating systems means creating CSS code to override those
    browsers’ default styling.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器都会将其默认样式应用到标题、段落、字体以及元素之间的间距。如果你能在导航到你所熟悉的网络应用时抑制CSS样式，你就会看到页面是如何使用浏览器的默认样式进行渲染的。如果你要在多个操作系统上使用多个浏览器（如Chrome、Firefox、Safari、Edge等）做同样的事情，你就会看到这些浏览器之间渲染页面的不同——有时细微，有时显著。为任何你创建的网络应用在不同浏览器和操作系统上提供一致的外观意味着创建CSS代码来覆盖这些浏览器的默认样式。
- en: 7.1.4 Responsive design
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 响应式设计
- en: We’ve already talked about the advantages of providing application features
    using web browsers as the platform to deliver the experience. One of the implications
    is that web browsers are everywhere—on mobile phones, tablets, laptops, and desktops.
    They are even integrated into cars and household appliances. These devices can
    and do have varied presentation capabilities, including screen size, screen resolution,
    speed, and accessibility.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了使用网络浏览器作为平台提供应用功能的优势。其中的一项影响是网络浏览器无处不在——在手机、平板电脑、笔记本电脑和台式机上。它们甚至被集成到汽车和家用电器中。这些设备可以并且确实具有不同的展示能力，包括屏幕大小、屏幕分辨率、速度和可访问性。
- en: Because the internet is widely available, your web application can run on any
    of these devices that can access its URL. Attempting to style your application
    for all of these devices is impossible; there are just too many of them. Also,
    new ones with new capabilities are continually being introduced.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于互联网的广泛可用性，你的网络应用可以在任何可以访问其URL的设备上运行。尝试为所有这些设备进行样式设计是不可能的；它们的数量太多了。此外，还不断有新的设备推出，它们具有新的功能。
- en: Because it is impossible to code for so many devices, it’s necessary to use
    responsive design principles. Responsive design means using fluid, proportion-based
    grids; media queries; and flexible images. Using these tools creates a design
    layout that automatically adjusts to the screen size of the device. The Bootstrap
    framework provides much of what’s needed to create a web application that uses
    responsive design ideas and implementations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于为这么多设备编码是不可能的，因此有必要使用响应式设计原则。响应式设计意味着使用流体、基于比例的网格；媒体查询；以及灵活的图像。使用这些工具可以创建一个设计布局，它会自动调整到设备的屏幕大小。Bootstrap框架提供了创建使用响应式设计理念和实现网络应用所需的大部分功能。
- en: 7.2 Integrating Bootstrap
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 集成Bootstrap
- en: I wouldn’t present the styling speedbumps involved in developing the MyBlog
    web application without proposing a solution. The solution I’ve chosen is the
    Bootstrap CSS framework created by Twitter ([https://getbootstrap.com/](https://getbootstrap.com/)).
    The Bootstrap framework addresses the problems raised previously, frees you from
    solving many styling concerns, and lets you focus on the application design and
    implementation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在不提出解决方案的情况下，我不会展示在开发 MyBlog 网页应用程序中遇到的样式速度障碍。我选择的解决方案是 Twitter 创建的 Bootstrap
    CSS 框架（[https://getbootstrap.com/](https://getbootstrap.com/)）。Bootstrap 框架解决了之前提出的问题，让您免于解决许多样式问题，并让您专注于应用程序的设计和实现。
- en: Adopting Bootstrap relieves you from having to create the CSS style code that
    creates the MyBlog presentation. Using Bootstrap gives the MyBlog application
    an attractive, consistent user interface; normalizes that interface across browsers
    and operating systems; and resolves many responsive design problems. The use of
    Bootstrap means you’ll still need to add CSS class names to the MyBlog web application’s
    HTML elements, but the reduction in the amount of custom CSS code required is
    well worth it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 采用 Bootstrap 可以让您免于编写创建 MyBlog 展示所需的 CSS 样式代码。使用 Bootstrap 为 MyBlog 应用程序提供了一个吸引人、一致的用户界面；在浏览器和操作系统之间标准化该界面；并解决了许多响应式设计问题。使用
    Bootstrap 意味着您仍然需要将 CSS 类名添加到 MyBlog 网页应用程序的 HTML 元素中，但所需的自定义 CSS 代码量减少是非常值得的。
- en: Using Bootstrap to style your web-based applications also means your applications
    will have a Bootstrap “look” to them. This “look” can be advantageous because
    the visual presentation is attractive, well known, and understood. The choice
    to use Bootstrap is a good one because this book focuses on becoming an accomplished
    Python developer, with some web page design skills. Using Bootstrap doesn’t exclude
    you from completely customizing your design, and it provides an excellent jumping-off
    point if you want to pursue the possibilities offered by customizing your application
    design.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Bootstrap 对您的 Web 应用程序进行样式化还意味着您的应用程序将具有 Bootstrap 的“外观”。这种“外观”可能是有利的，因为视觉呈现是吸引人的、广为人知且易于理解的。选择使用
    Bootstrap 是一个好的选择，因为这本书的重点是成为一个熟练的 Python 开发者，并具备一些网页设计技能。使用 Bootstrap 并不会阻止您完全自定义设计，如果您想探索自定义应用程序设计提供的可能性，它提供了一个出色的起点。
- en: Bootstrap version
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 版本
- en: The MyBlog application uses Bootstrap version 5\. Version 5 focuses more on
    modern browsers, making the CSS code more future friendly, more straightforward
    to implement, and possibly faster to render.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog 应用程序使用 Bootstrap 版本 5。版本 5 更注重现代浏览器，使 CSS 代码更具未来友好性，更易于实现，并且可能更快地渲染。
- en: This version also drops any dependency on the jQuery JavaScript library and
    instead uses straight JavaScript. There is absolutely nothing wrong with jQuery;
    it’s a powerful library to access and manipulate HTML elements. However, since
    its creation, browser support for JavaScript has become much more consistent and
    powerful, making dependence on jQuery a choice rather than a necessity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本还取消了任何对 jQuery JavaScript 库的依赖，而是直接使用 JavaScript。jQuery 没有任何问题；它是一个强大的库，用于访问和操作
    HTML 元素。然而，自从其创建以来，浏览器对 JavaScript 的支持已经变得更加一致和强大，使得对 jQuery 的依赖成为一个选择而不是必需。
- en: 7.2.1 The previous example, now with Bootstrap
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 现在的先前列举的例子，加入了 Bootstrap
- en: The last example web application in chapter 6 used hand-coded CSS for styling.
    Figure 7.1 presents a refresher on that page before getting started on making
    changes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 章的最后一个小节中使用的最后一个 Web 应用程序使用了手动编写的 CSS 进行样式化。图 7.1 在开始进行更改之前，对该页面进行了回顾。
- en: '![](../../OEBPS/Images/CH07_F01_Farrell.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F01_Farrell.png)'
- en: Figure 7.1 A look at the web page from chapter 6, figure 6.5, before we start
    making changes
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 在开始进行更改之前，查看第 6 章中的网页，图 6.5
- en: Your initial goal is to replace all of the hand-coded CSS style information
    with that supplied by Bootstrap. It will be the same application with the same
    content and functionality but styled entirely with Bootstrap CSS-style classes.
    Figure 7.2 presents the destination that the upcoming changes will create.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您的初始目标是用 Bootstrap 提供的样式替换所有手动编写的 CSS 样式信息。这将是一个具有相同内容和功能的应用程序，但完全使用 Bootstrap
    CSS 样式类进行样式化。图 7.2 展示了即将进行的更改将创建的目标。
- en: '![](../../OEBPS/Images/CH07_F02_Farrell.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F02_Farrell.png)'
- en: Figure 7.2 The page goal to achieve by replacing the custom CSS with **Bootstrap
    styling**
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 通过替换自定义 CSS 使用 **Bootstrap 样式**要达到的页面目标
- en: The first step on your way to replacing the hand-coded CSS styles with Bootstrap
    is making the Bootstrap framework available to the MyBlog web application. Rather
    than download the Bootstrap framework and copy the necessary files into your `static/css`
    and `static/js` directories, you’re going to access the files directly from a
    CDN (content delivery network). Using a CDN to access Bootstrap relieves you from
    having to copy files for this chapter and the chapters to come. It also relieves
    Flask from having to serve the files, as the CDN will handle that. The MyBlog
    application will use the [https://www.jsdelivr.com/](https://www.jsdelivr.com/)
    CDN and is the delivery mechanism recommended on the Bootstrap home page.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在用 Bootstrap 替换手写 CSS 样式的第一步，你需要使 Bootstrap 框架对 MyBlog 网络应用程序可用。你将直接从 CDN（内容分发网络）访问文件，而不是下载
    Bootstrap 框架并将必要的文件复制到你的 `static/css` 和 `static/js` 目录中。使用 CDN 访问 Bootstrap 可以让你不必复制本章和后续章节的文件。这也让
    Flask 不必提供文件，因为 CDN 将处理这些文件。MyBlog 应用程序将使用 [https://www.jsdelivr.com/](https://www.jsdelivr.com/)
    CDN，这是 Bootstrap 主页上推荐的分发机制。
- en: Base.xhtml
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Base.xhtml
- en: 'You’re changing the style of the application only, so the `app.py` file doesn’t
    need to change. Because Bootstrap will be used for all of the MyBlog pages, you’ll
    add it to the `base.xhtml` template, making it available to any template that
    inherits from it. You’ll also need to update the hand-coded style information
    in the template file with Bootstrap style classes as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你只更改了应用程序的样式，所以不需要更改 `app.py` 文件。因为 Bootstrap 将用于所有 MyBlog 页面，所以你将把它添加到 `base.xhtml`
    模板中，使其对继承自它的任何模板都可用。你还需要更新模板文件中的手写样式信息，如下使用 Bootstrap 样式类：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Creates the CSS variable background-URL referencing the banner image, applied
    here because it uses url_for() in a template processed by Jinja2
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建了引用横幅图片的 CSS 变量背景-URL，在这里应用是因为它使用 Jinja2 处理的模板中的 url_for()
- en: ② Includes the Bootstrap-minimized CSS files from the CDN
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从 CDN 包含 Bootstrap-minimized CSS 文件
- en: ③ Creates the banner section content and its styles
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建了横幅部分的内容及其样式
- en: ④ Creates the content section enclosing style, which is provided by child templates
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建了包含样式的内容部分，该样式由子模板提供
- en: ⑤ Creates the Bootstrap footer that sticks to the bottom of the page
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 创建了固定在页面底部的 Bootstrap 页脚
- en: ⑥ Includes the Bootstrap-bundled, minimized JavaScript code
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 包含了 Bootstrap-bundled，最小化的 JavaScript 代码
- en: The template code creates the content and style basis of the MyBlog application.
    Every template that inherits from the `base.xhtml` template will have these content
    and style elements. The `base.xhtml` template gives a foundation for the look
    and feel of the entire application as well as eases the work of doing so.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模板代码创建了 MyBlog 应用程序的内容和样式基础。继承自 `base.xhtml` 模板的每个模板都将具有这些内容和样式元素。`base.xhtml`
    模板为整个应用程序的外观和感觉提供了一个基础，同时也简化了这项工作。
- en: Base.css
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Base.css
- en: 'The `base.xhtml` template has its own `base.css` file that overrides some of
    the Bootstrap styling for the banner. It also has a CSS media query as follows
    that makes the application responsive in a specific way for smaller devices:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`base.xhtml` 模板拥有自己的 `base.css` 文件，该文件覆盖了一些 Bootstrap 对横幅的样式。它还包含以下 CSS 媒体查询，使得应用在较小设备上以特定方式响应：'
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Modifies the Bootstrap card style to remove the border, make the radius 0,
    and remove the background image clipping
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ① 修改了 Bootstrap 卡片样式，移除了边框，将半径设置为 0，并移除了背景图像裁剪
- en: ② Sets the default visibility of the banner to none, or invisible
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将横幅的默认可见性设置为无，或不可见
- en: ③ Uses a CSS media query to override the .banner setting to be visible if the
    screen size is greater than 768 pixels
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 CSS 媒体查询覆盖 .banner 设置，使其在屏幕尺寸大于 768 像素时可见
- en: The interesting part of the `base.css` file is the `.banner` and `@media` sections.
    The first sets the `.banner` `display` value to `none`, preventing it from being
    rendered to the display. The `@media` section takes advantage of the cascading
    nature of CSS to affect how the banner is displayed. In CSS, the last defined
    style overrides any previously defined style. The `@media` section acts as a conditional
    statement in the CSS. If the screen size is greater than 768 pixels, then set
    the display value to `block`, meaning it will be rendered to the display. The
    background portion defines how to display the background image and gets that image
    from the CSS variable `background-url` defined in the `base.xhtml` template.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`base.css` 文件中有趣的部分是 `.banner` 和 `@media` 部分。第一个设置了 `.banner` 的 `display` 值为
    `none`，防止它被渲染到显示中。`@media` 部分利用 CSS 的级联特性来影响横幅的显示方式。在 CSS 中，最后定义的样式会覆盖之前定义的任何样式。`@media`
    部分在 CSS 中充当一个条件语句。如果屏幕尺寸大于 768 像素，则将显示值设置为 `block`，这意味着它将被渲染到显示中。背景部分定义了如何显示背景图像，并从
    `base.xhtml` 模板中定义的 CSS 变量 `background-url` 获取该图像。'
- en: If the screen size is less than 768 pixels, the initial `.banner` definition
    of `none` stands, and the banner image isn’t rendered to the display. The `@media`
    query gives MyBlog control over displaying the banner image, giving small-screen
    devices more display real estate to show MyBlog content. You’ll see an example
    of how the media query affects the display after going over the changes to the
    `index.xhtml` file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果屏幕尺寸小于 768 像素，则初始的 `.banner` 定义 `none` 保持不变，横幅图像不会被渲染到显示中。`@media` 查询使 MyBlog
    能够控制横幅图像的显示，为小屏幕设备提供更多显示空间来显示 MyBlog 内容。您将在查看 `index.xhtml` 文件更改后看到媒体查询如何影响显示的示例。
- en: Index.xhtml
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Index.xhtml
- en: 'As before, the `index.xhtml` file holds the content of the home page. The content
    is the same, but like the `base.xhtml` file, the styling information is updated
    to use Bootstrap. Here’s the updated `index.xhtml` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`index.xhtml` 文件包含首页的内容。内容相同，但像 `base.xhtml` 文件一样，样式信息已更新为使用 Bootstrap。以下是更新的
    `index.xhtml` 文件：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Creates the home page content, styled using a Bootstrap responsive container
    and card
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建了使用 Bootstrap 响应式容器和卡片样式的首页内容
- en: ② Converts the template parameter data["banner_colors"] to JSON so it can be
    used by the page’s JavaScript
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将模板参数数据 `data["banner_colors"]` 转换为 JSON，以便页面 JavaScript 可以使用
- en: 'The home-page content changes are all about styling the content presentation
    and not about the content itself. When the changes are complete, the directory
    structure should look like `examples/CH_07/examples/01`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首页内容的变化都是关于内容呈现的样式，而不是内容本身。当更改完成后，目录结构应该看起来像 `examples/CH_07/examples/01`：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From that directory, execute the following commands from a Mac or Linux terminal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从该目录中，在 Mac 或 Linux 终端中执行以下命令：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or as follows for a Windows system terminal:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于 Windows 系统的终端，如下所示：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The MyBlog web server will run, and you can navigate with your browser to `127.0.0.1:5000`
    and see the application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog 网络服务器将运行，您可以使用浏览器导航到 `127.0.0.1:5000` 并查看应用程序。
- en: The application shows the modified banner containing the image at the top of
    the display. It also shows the Bootstrap sticky footer at the bottom of the page.
    These elements come from the `base.xhtml` template and will be present on every
    page that inherits from it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序显示了包含显示顶部图像的修改后的横幅。它还显示了页面底部的 Bootstrap 粘性页脚。这些元素来自 `base.xhtml` 模板，并将存在于继承自它的每一页上。
- en: The current timestamp is displayed in a Bootstrap card, and the list of available
    colors is contained in another card. Additionally, the button that changes the
    color of the banner background is styled as a Bootstrap button.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当前时间戳显示在一个 Bootstrap 卡片中，可用的颜色列表包含在另一个卡片中。此外，更改横幅背景颜色的按钮被样式化为 Bootstrap 按钮。
- en: The display banner is rendered if the browser screen size is greater than 768
    pixels, which is most likely correct for a desktop or laptop computer. This is
    what’s presented in figure 7.3\. If you resize the browser window to be narrower,
    eventually you’ll cross the 768-pixel boundary and the web application display
    will change. Figure 7.4 shows the updated page. The absence of the banner text
    and image demonstrates the conditional implied by the `@media` query in the `base.css`
    file. The conditional becomes false, and the initial definition of the `.banner`
    CSS class becomes active, setting the display value to `none`. Using the media
    query gives the web application more vertical screen real estate for smaller devices
    like tablets and mobile phones.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器屏幕大小大于 768 像素时，将渲染显示横幅，这很可能适用于台式机或笔记本电脑。这就是图 7.3 中展示的内容。如果你调整浏览器窗口使其变窄，最终你会越过
    768 像素的边界，Web 应用显示将发生变化。图 7.4 展示了更新后的页面。横幅文本和图像的缺失展示了 `base.css` 文件中 `@media`
    查询所隐含的条件。当条件变为假时，`.banner` CSS 类的初始定义变为活动状态，将显示值设置为 `none`。使用媒体查询为平板电脑和手机等小型设备提供了更多的垂直屏幕空间。
- en: '![](../../OEBPS/Images/CH07_F03_Farrell.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F03_Farrell.png)'
- en: Figure 7.3 The page displayed after incorporating Bootstrap styling
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 添加 Bootstrap 样式后的页面显示
- en: '![](../../OEBPS/Images/CH07_F04_Farrell.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F04_Farrell.png)'
- en: Figure 7.4 Changing the browser size activates the media query to remove the
    banner.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 改变浏览器大小激活媒体查询以移除横幅。
- en: 7.3 Helping MyBlog grow
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 帮助MyBlog成长
- en: At this point in the development, the MyBlog app has expanded on the basic Flask
    example application often found in Flask documentation. Everything we’ve added
    extends what this basic example can do with the addition of functionality and
    styling and the use of Jinja2 templates. Continuing to extend the capabilities
    of the code we’ve written so far is possible, but doing so would hinder developing
    a fully featured and extensible application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个开发阶段，MyBlog 应用已经扩展了 Flask 文档中常见的 Flask 示例应用的基本功能。我们所添加的一切都是通过添加功能、样式以及使用
    Jinja2 模板来扩展这个基本示例所能做到的。继续扩展我们迄今为止编写的代码的功能是可能的，但这样做会阻碍开发一个功能齐全且可扩展的应用。
- en: All new functionality would have to be included in the `app.py` file as a long
    list of functions decorated with `@app.route(...)` to connect that functionality
    to the Flask application. Doing so breaks the concept of single responsibility
    and makes naming the web application URL endpoint function handlers awkward.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的功能都必须包含在 `app.py` 文件中，作为装饰有 `@app.route(...)` 的函数长列表，以将此功能连接到 Flask 应用。这样做打破了单一责任的概念，并使得为
    Web 应用 URL 端点函数处理程序命名变得尴尬。
- en: The mental demand of working in many technical domains in a single large file
    would be even harder. The `app.py` file would contain all of the parts necessary
    for a full-featured blogging application—authentication, authorization, database
    access, user management, and creating and presenting the blogging content.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个大文件中工作，涉及许多技术领域的精神需求将会更加困难。`app.py` 文件将包含一个全功能博客应用所需的所有部分——认证、授权、数据库访问、用户管理以及创建和展示博客内容。
- en: You’ve seen how to break up functionality along logical or complex boundaries
    by using modules to create namespaces and create namespace containers for functionality.
    The same approach will be used in the MyBlog application. However, one thing that
    needs attention to make that possible as you move forward is the Flask app instance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何通过使用模块创建命名空间和命名空间容器来按逻辑或复杂边界拆分功能。在 MyBlog 应用中，我们将采用相同的方法。然而，在前进的过程中，需要注意一点，那就是
    Flask 应用实例。
- en: 7.3.1 The Flask app instance
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 Flask 应用实例
- en: In the current version of the `app.py` program file, the Flask module is imported
    and the Flask application instance variable `app` is created directly. Creating
    the Flask app instance in the root application file works fine for a sample application
    whose purpose is to build a working example web server quickly.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本的 `app.py` 程序文件中，直接导入了 Flask 模块并创建了 Flask 应用实例变量 `app`。在根应用文件中创建 Flask
    应用实例对于快速构建示例 Web 服务器的工作示例应用来说是可行的。
- en: Why is this structure a problem when you want to use modules to namespace functionality
    in the web application? Because any feature or functionality you’d want to add
    to the web application with a URL endpoint function like `hello_world()` will
    need access to the app instance variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么当您想使用模块在Web应用程序中命名空间功能时，这种结构成为问题？因为您想通过具有`hello_world()`等URL端点功能的Web应用程序添加的任何功能或功能都需要访问app实例变量。
- en: With the current MyBlog application setup, creating modules to contain features
    and functionality becomes difficult because those modules will need access to
    the `app` instance. The current structure is illustrated in figure 7.5\. That
    presents a problem. The `app.py` code could import modules to access additional
    functionality, but those same modules would need access to the `app` instance.
    If those modules import the `app` instance from `app.py` to gain access, a circular
    reference problem is created that Python won’t allow. Adding features and functionality
    to the current implementation of MyBlog leads to a structure that’s difficult
    to scale upward.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前MyBlog应用设置中，创建包含功能和功能的模块变得困难，因为这些模块将需要访问`app`实例。当前结构如图7.5所示。这提出了一个问题。`app.py`代码可以导入模块以访问附加功能，但那些相同的模块也需要访问`app`实例。如果这些模块从`app.py`导入`app`实例以获取访问权限，则会创建Python不允许的循环引用问题。向MyBlog当前实现添加功能和功能会导致难以向上扩展的结构。
- en: '![](../../OEBPS/Images/CH07_F05_Farrell.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F05_Farrell.png)'
- en: Figure 7.5 The application code structure where features are contained in the
    `app.py` file
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 应用代码结构，其中功能包含在`app.py`文件中
- en: Resolving the app instance problem
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 解决应用实例问题
- en: To resolve the problem of modules accessing the Flask `app` instance, you’ll
    need to change the application’s structure. The Flask `app` instance is the central
    hub around which the features of a Flask-based application revolve. Besides the
    `@app.route(...)` functionality seen so far, more functionality and features will
    need access to the `app` instance, as presented in later chapters.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决模块访问Flask `app`实例的问题，您需要更改应用的结构。Flask `app`实例是围绕其旋转的Flask应用功能的中心枢纽。除了迄今为止看到的`@app.route(...)`功能外，更多功能和特性将需要访问`app`实例，如后续章节所述。
- en: 'Given the central role of the `app` instance, how do you gain access to it
    when needed? You’ll be following a two-step process to resolve the problem: putting
    the bulk of the application code into a Python package and creating a factory
    function to instantiate the Flask `app` instance.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`app`实例的核心作用，当需要访问它时，您将遵循两步过程来解决问题：将大部分应用代码放入Python包中，并创建一个工厂函数来实例化Flask的`app`实例。
- en: The use and creation of packages were presented in earlier chapters and used
    to create module namespaces. As a refresher, creating a package means creating
    a directory and adding an `__init__.py` file to the directory. The existence of
    this file lets Python import modules from the package. Adding packages can continue
    to any reasonable depth by creating packages within packages to create meaningful
    namespace hierarchies.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中介绍了包的使用和创建，并用于创建模块命名空间。作为一个复习，创建一个包意味着创建一个目录并在目录中添加一个`__init__.py`文件。此文件的存在允许Python从包中导入模块。通过在包中创建包来创建有意义的命名空间层次结构，可以继续添加包，直到合理的深度。
- en: In earlier chapters, the `__init__.py` file needs only exist to make a directory
    a Python package. Part of the activity of importing a module from a package also
    includes executing any Python code in the `__init__.py` file. The `__init__.py`
    file in many packages doesn’t contain code, but Python code can be added to it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，`__init__.py`文件只需存在即可使目录成为Python包。从包中导入模块的活动的一部分也包括执行`__init__.py`文件中的任何Python代码。许多包中的`__init__.py`文件不包含代码，但可以向其中添加Python代码。
- en: Any module in the package automatically has access to the code and variables
    in the package `__init__.py` file, and the `__init__.py` file has access to the
    package’s sibling modules. Packages will be useful when creating the application
    factory function to create the Flask `app` instance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 包中的任何模块都可以自动访问包的`__init__.py`文件中的代码和变量，而`__init__.py`文件可以访问包的兄弟模块。当创建用于创建Flask
    `app`实例的应用程序工厂函数时，包将非常有用。
- en: MyBlog restructuring
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog重构
- en: You’re at an excellent point to restructure the file layout of the MyBlog application
    to create a meaningful hierarchy. Having an intentional file structure helps use
    the files contained in the directory structure that are related and useful to
    your projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在正处于一个很好的位置来重构 MyBlog 应用程序的文件布局，以创建一个有意义的层次结构。有一个有意的文件结构有助于使用与项目相关的和有用的目录结构中的文件。
- en: The first thing to do is rename the `app.py` file to `myblog.py`. Then create
    a directory named `app`, which is the root package directory for the MyBlog application.
    Move the `static` and `templates` directories into the `app` directory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是将`app.py`文件重命名为`myblog.py`。然后创建一个名为`app`的目录，这是 MyBlog 应用的根包目录。将`static`和`templates`目录移动到`app`目录中。
- en: 'Inside the `app` directory, create an `__init__.py` file, which turns the `app`
    directory into a Python package. The directory structure should now look like
    this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app`目录内创建一个`__init__.py`文件，这将`app`目录转换为 Python 包。目录结构现在应该看起来像这样：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Application factory
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序工厂
- en: 'The renamed `myblog.py` file creates the Flask `app` instance directly and
    then uses it to connect URL endpoints to functionality. Our goal is to get more
    control over creating the `app` instance and make using it with external modules
    easier. To do this, you’re going to implement an application factory function
    called `create_app``()` inside the app package `__init__.py` file. Edit the `app/__init__.py`
    file and add this code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名的`myblog.py`文件直接创建 Flask `app` 实例，然后使用它将 URL 端点连接到功能。我们的目标是获得更多控制创建`app`实例的能力，并使其与外部模块的使用更加容易。为此，你将在应用包的`__init__.py`文件中实现一个名为`create_app()`的应用工厂函数。编辑`app/__init__.py`文件并添加以下代码：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① The support classes used by the home() function
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ① 被`home()`函数使用的支持类
- en: ② Creates the Flask app instance inside the application factory create_app()
    function
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在应用程序工厂函数`create_app()`内部创建 Flask 应用实例
- en: ③ Begins a context manager to initialize the rest of the app
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 开始上下文管理器以初始化应用程序的其余部分
- en: ④ Returns the app instance to the caller
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将应用实例返回给调用者
- en: 'This code is basically everything in the `myblog.py` file placed inside the
    app package `__init__.py` file. Because this replicates almost all of the code
    in `myblog.py`, this file needs to be updated to this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上是将`myblog.py`文件中的所有内容放入应用包的`__init__.py`文件中。因为这个文件几乎复制了`myblog.py`中的所有代码，所以这个文件需要更新为以下内容：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All that `myblog.py` does now is import the application factory `create_app`
    and then call it to create the Flask `app` instance. Change your working directory
    to `examples/CH_07/examples/02` and execute the commands to run the application
    from a Mac or Linux terminal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`myblog.py`文件所做的一切就是导入应用工厂`create_app`，然后调用它来创建 Flask `app` 实例。将你的工作目录更改为`examples/CH_07/examples/02`，并在
    Mac 或 Linux 终端中执行以下命令来运行应用程序：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or for a Windows system terminal:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于 Windows 系统终端：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Navigating to `127.0.0.1:5000` in your browser will show the same application
    view as before but using the new MyBlog application structure. Figure 7.6 shows
    the application page and its functionality.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中导航到`127.0.0.1:5000`将显示与之前相同的应用程序视图，但使用新的 MyBlog 应用程序结构。图 7.6 显示了应用程序页面及其功能。
- en: The next step is to move the `home()` function to an external module where other
    features can be added. To do this, you’ll make use of the Flask Blueprints capability.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`home()`函数移动到外部模块，以便可以添加其他功能。为此，你将利用 Flask 蓝图功能。
- en: '![](../../OEBPS/Images/CH07_F06_Farrell.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F06_Farrell.png)'
- en: Figure 7.6 The restructured application renders the previous page identically.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 重新结构化的应用程序渲染了之前的页面。
- en: 7.4 Namespaces
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 命名空间
- en: Any interesting application will have many features that necessitate interaction
    between those features, which adds complexity. The MyBlog web application is no
    different and will acquire functionality focused on particular application parts.
    Rather than roll all the other functional areas of code into one big Python file,
    it’s better to break the work into modules so you can work in one functional domain
    at a time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有趣的应用程序都将有许多功能，这些功能需要这些功能之间的交互，这增加了复杂性。MyBlog 网络应用程序也不例外，它将获得专注于特定应用程序部分的功能。与其将所有其他功能区域的代码滚入一个大的
    Python 文件中，不如将工作分解成模块，这样你就可以一次在一个功能域中工作。
- en: Just like you’ve seen in previous chapters where Python packages and modules
    contain high-level namespaces, the same idea will be applied here. In a web application,
    this separation of concerns includes creating modules for the URL endpoints that
    provide functionality and are to be placed into namespaces. The Flask framework
    implements namespaces through Blueprints.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在前面的章节中看到的那样，Python 包和模块包含高级命名空间，同样的想法将在这里应用。在 Web 应用程序中，这种关注点的分离包括为提供功能并将其放置在命名空间中的
    URL 端点创建模块。Flask 框架通过 Blueprints 实现命名空间。
- en: 7.4.1 Flask Blueprints
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 Flask 蓝图
- en: In the MyBlog application, when the `@app.route("/")` decorator is applied to
    a function, the function is registered with the server so it will be called when
    the URL endpoint path `"/"` is accessed by a browser. As the decorator’s name
    implies, the `"/"` URL path parameter passed in is an application route being
    defined.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MyBlog 应用程序中，当`@app.route("/")`装饰器应用于一个函数时，该函数会被服务器注册，以便在浏览器访问 URL 端点路径`"/"`时被调用。正如装饰器名称所暗示的，传入的`"/"`
    URL 路径参数是一个正在定义的应用程序路由。
- en: The `@app.route` decorator lets you connect a URL route to the Flask application
    so it can process a request for the route with the decorated function. All of
    the URL routes could be handled this way, but in a larger application, this becomes
    unwieldy. The Flask web framework provides a feature called Blueprints to implement
    separate modules that service URL endpoints or routes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`@app.route`装饰器允许你将 URL 路由连接到 Flask 应用程序，以便它可以处理由装饰过的函数处理的该路由的请求。所有 URL 路由都可以这样处理，但在更大的应用程序中，这会变得难以管理。Flask
    网络框架提供了一个名为 Blueprints 的功能，用于实现服务 URL 端点或路由的独立模块。'
- en: Flask Blueprints lets you separate specific functionality into modules. A Blueprint
    is useful when creating logically distinct features like authentication, authorization,
    and other parts of a web application. In chapter 8, you’ll be adding user authentication
    to the MyBlog application. Authentication secures access to almost all other pages
    and features the MyBlog application provided to users.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Flask Blueprints 允许你将特定功能分离到模块中。当创建逻辑上独立的特性，如认证、授权和 Web 应用程序的其它部分时，蓝图非常有用。在第
    8 章中，你将向 MyBlog 应用程序添加用户认证。认证保护了 MyBlog 应用程序提供给用户的几乎所有页面和功能的访问。
- en: Getting authentication working and contained in one place is valuable, but this
    functionality could be used in an entirely different web application with little
    trouble once complete. You could make almost any functionality you’ve created
    available to other projects by placing the Blueprint in a shared library for all
    your application projects to use. You could also put it in a repository like GitHub,
    where a team of developers could access it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 获取认证并使其在一个地方工作是有价值的，但一旦完成，这个功能可以轻松地用于完全不同的网络应用程序。你可以通过将蓝图放置在所有应用程序项目共享的库中，使你创建的几乎所有功能都对其他项目可用。你还可以将其放入像
    GitHub 这样的仓库中，这样一组开发者就可以访问它。
- en: 7.4.2 Add Blueprints to MyBlog
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 将蓝图添加到 MyBlog
- en: The MyBlog application creates the app instance inside the application factory
    `create_app()` function in the app package. The home page is also contained in
    the `create_app()` function. A little later in this chapter, you’re going to add
    an about page to the application. Let’s create a namespace for the home page and
    the future about page where they both can live. We’ll call that namespace `intro`,
    as the home and about page will be introductory to the MyBlog application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog 应用程序在应用程序包中的`create_app()`工厂函数内创建 app 实例。主页也包含在`create_app()`函数中。在本章稍后，你将向应用程序添加一个关于页面。让我们为主页和未来的关于页面创建一个命名空间，它们都可以在其中存在。我们将该命名空间称为`intro`，因为主页和关于页面将是
    MyBlog 应用程序的介绍性内容。
- en: To do this, you’ll create an intro package within the app package. As a first
    step, create an `intro` subdirectory within the `app` directory. In that subdirectory,
    create an empty `__init__.py` file, which makes the `intro` directory a Python
    package.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你将在应用程序包内创建一个 intro 包。作为第一步，在`app`目录内创建一个`intro`子目录。在那个子目录中，创建一个空的`__init__.py`文件，这使得`intro`目录成为一个
    Python 包。
- en: The content
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 内容
- en: 'There’s a bit of a chicken-and-egg problem with how a Blueprint is created
    and used, but let’s start with the `intro` namespace’s functionality. In the `intro`
    subdirectory, create an `intro.py` file with this content:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和使用蓝图时存在一定的鸡生蛋、蛋生鸡的问题，但让我们先从`intro`命名空间的功能开始。在`intro`子目录下，创建一个`intro.py`文件，内容如下：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Imports the as-yet-undefined intro Blueprint instance intro_bp
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入尚未定义的 intro Blueprint 实例 intro_bp
- en: ② Notices how the home function is decorated with the intro_bp Blueprint instance
    route function rather than @app.route
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ② 注意到主页函数是用 intro_bp Blueprint 实例的路由函数装饰的，而不是 @app.route
- en: The intro package
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: intro 包
- en: 'The `intro.py` file contains Blueprint functionality and uses the as-yet-undefined
    `intro_bp` Blueprint instance. The `intro_bp` instance naming is a convention;
    adding `_bp` to the end of the instance name indicates a Flask Blueprint. The
    next step is to edit the empty `app/intro/__init__.py` file and create the `intro_bp`
    instance:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`intro.py` 文件包含 Blueprint 功能，并使用尚未定义的 `intro_bp` Blueprint 实例。`intro_bp` 实例的命名是一种约定；在实例名称末尾添加
    `_bp` 表示 Flask Blueprint。下一步是编辑空的 `app/intro/__init__.py` 文件并创建 `intro_bp` 实例：'
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Imports the Blueprint class from the flask module
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 flask 模块导入 Blueprint 类
- en: ② Creates a Blueprint instance, initializing its name, filename, and paths to
    the static and template files
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个 Blueprint 实例，初始化其名称、文件名以及静态和模板文件的路径
- en: ③ Imports the intro module functionality
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 导入 intro 模块的功能
- en: Because the `__init__.py` file is inside a package, this code will be run every
    time anything within the package is imported, including the just-created `intro.py`
    module. The first thing the code does is import the Blueprint class from the flask
    module. It then creates the `intro_bp` instance by instantiating the Blueprint
    class with some parameters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `__init__.py` 文件位于一个包中，所以每次导入包内的任何内容时，包括刚刚创建的 `intro.py` 模块，都会运行此代码。代码首先执行的操作是从
    flask 模块导入 Blueprint 类。然后通过使用一些参数实例化 Blueprint 类来创建 `intro_bp` 实例。
- en: The parameters give the Blueprint a name, pass it the Python filename, and set
    the `static_folder` and `template_folder` parameters with path strings relative
    to the Blueprint location. This means the `intro_bp` Blueprint instance expects
    to find the templates it will render and the static assets those templates might
    require on a path relative to where the file containing the definition `intro_bp`
    Blueprint exists in the application file structure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 参数赋予 Blueprint 一个名称，传递 Python 文件名，并使用与 Blueprint 位置相关的路径字符串设置 `static_folder`
    和 `template_folder` 参数。这意味着 `intro_bp` Blueprint 实例期望在相对于包含 `intro_bp` Blueprint
    定义文件的文件结构中的路径上找到它将渲染的模板以及这些模板可能需要的静态资源。
- en: The `static_url_path` parameter is set to ensure that the Blueprint relative
    path doesn’t conflict with the root `static` folder. The value assigned to the
    parameter is the relative path from the root directory to the Blueprint `static`
    directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`static_url_path` 参数被设置为确保 Blueprint 相对路径不与根 `static` 文件夹冲突。分配给参数的值是从根目录到 Blueprint
    `static` 目录的相对路径。'
- en: This means that the `index.xhtml` template that provides the home page’s content
    needs to move somewhere the `intro_bp` Blueprint can find. It also means the static
    assets (CSS files, JavaScript, and images) need to move as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着提供主页内容的 `index.xhtml` 模板需要移动到 `intro_bp` Blueprint 可以找到的地方。这也意味着静态资源（CSS
    文件、JavaScript 和图片）也需要移动。
- en: Updated MyBlog directory
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的 MyBlog 目录
- en: 'The result of restructuring the directory to put all the files related to the
    intro Blueprint exists in the `examples/CH_07/examples/03` directory from the
    code repository:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将目录重构以放置所有与 intro Blueprint 相关的文件的结果位于代码仓库的 `examples/CH_07/examples/03` 目录中：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this directory structure, two pairs of `templates` and `static` directories
    exist, the first being the original at the project root from the previous example
    and the second being the set under the intro package. The second set is what the
    `intro_bp` Blueprint instance will use when looking for `templates` and `static`
    files because of the values passed to the `static_folder` and `template_folder`
    parameters when the instance was created.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个目录结构中，存在两对 `templates` 和 `static` 目录，第一对是来自上一个示例的项目根目录中的原始目录，第二对是在 intro
    包下设置的。第二对是 `intro_bp` Blueprint 实例在查找 `templates` 和 `static` 文件时将使用的，因为实例创建时传递给
    `static_folder` 和 `template_folder` 参数的值。
- en: If those two parameters had not been set, the `intro_bp` instance would have
    looked for `templates` and `static` assets in the app root `static` and `templates`
    directories under the `app` directory. Having the `templates` and `static` folders
    under the Blueprint packages you create makes the Blueprint more self-contained
    and portable to other projects.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个参数没有被设置，`intro_bp`实例将会在`app`目录下的`static`和`templates`目录中寻找`templates`和`static`资源。在创建的蓝图（Blueprint）包下拥有`templates`和`static`文件夹使得蓝图更加自包含，并且可以方便地移植到其他项目中。
- en: 'One additional change needs to be made to the `index.xhtml` file so it can
    access the static assets referenced by the HTML code. The `<script>...</script>`
    tags that reference the JavaScript that reacts to the button clicks on the home
    page need to be updated in this way:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对`index.xhtml`文件进行一项额外的修改，以便它可以访问由HTML代码引用的静态资源。需要按照以下方式更新引用主页面上按钮点击响应的JavaScript的`<script>...</script>`标签：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The only change is the addition of the single character (`.`) in front of `static`
    in the `url_for(...)` statement. The `url_for(...)` statement will resolve this
    path to the `static` directory relative to the `intro_bp` Blueprint, and the `index.js`
    file will be pulled correctly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是在`url_for(...)`语句中`static`前添加了一个单字符（`.`）。`url_for(...)`语句将解析此路径为相对于`intro_bp`蓝图（Blueprint）的`static`目录，并且`index.js`文件将被正确地拉取。
- en: App package changes
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包更改
- en: 'Before you move on to create the new about page, take a look at the `app/__init__.py`
    file. All of the code related to the home page has just been moved to the `intro`
    module, so the file needs to be updated as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续创建新的关于页面之前，先查看一下`app/__init__.py`文件。所有与主页相关的代码都已经移动到了`intro`模块中，因此该文件需要按照以下方式更新：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Imports the intro module containing the intro Blueprint
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入包含intro蓝图的intro模块
- en: ② Registers the intro Blueprint with the app
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ② 注册intro蓝图到应用中
- en: This code shows the application factory `create_app()` function simplified to
    remove the home page’s code, which is now part of the `intro` Blueprint. This
    is all that’s needed in the MyBlog application to get things rolling when the
    `flask` `run` command is called. By default, the `flask` `run` command looks in
    the application (which was in the `FLASK_ENV` environment variable) for a Flask
    instance named `app`. Finding the `app` instance will start to run the application,
    serving any URL endpoints that have been configured and registered with the app.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了简化后的应用程序工厂`create_app()`函数，移除了现在作为`intro`蓝图一部分的主页代码。在MyBlog应用程序中，当调用`flask`
    `run`命令时，只需要这些内容。默认情况下，`flask` `run`命令会在应用程序（在`FLASK_ENV`环境变量中）中查找名为`app`的Flask实例。找到`app`实例后，将启动应用程序，为已配置并注册到应用程序的任何URL端点提供服务。
- en: 7.4.3 Create the about page
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.3 创建关于页面
- en: 'To demonstrate how the `intro_bp` Blueprint instance can contain features and
    functionality, you’ll add an about page to the MyBlog application. To do so, add
    a new handler function to the `intro.py` file and register it with the instance
    by decorating it with a route as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示`intro_bp`蓝图实例可以包含功能和功能，你将在MyBlog应用程序中添加一个关于页面。为此，在`intro.py`文件中添加一个新的处理函数，并通过以下方式使用路由装饰它进行注册：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Decorates the about() function and registers it as the handler for the new
    route "/about" using the intro_bp Blueprint instance
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ① 装饰about()函数并将其注册为新的路由"/about"的处理程序，使用intro_bp蓝图实例
- en: ② Retrieves and renders the about.xhtml template file from the intro_bp relative
    templates directory
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从intro_bp相关的模板目录检索并渲染about.xhtml模板文件
- en: 'This code creates a URL endpoint route to `"/about"` and registers the `about()`
    function as the handler when that route is navigated to by a browser. To render
    an about HTML page, an `about.xhtml` template is created in the `app/intro/templates`
    directory that’s relative to the `intro_bp` Blueprint:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个指向`"/about"`的URL端点路由，并在浏览器导航到该路由时注册`about()`函数作为处理程序。为了渲染关于HTML页面，在`app/intro/templates`目录中创建了一个`about.xhtml`模板，该目录相对于`intro_bp`蓝图：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Like index.xhtml, the about page inherits from base.xhtml and gets the same
    features it provides.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ① 与index.xhtml类似，关于页面继承自base.xhtml，并获得了它提供相同的特性。
- en: ② The about page replaces the content block with Bootstrap-styled text information
    about the MyBlog application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ② 关于页面用Bootstrap风格的文本信息替换了内容块，关于MyBlog应用程序。
- en: If you run the MyBlog application and navigate to `127.0.0.1:5000/about` in
    a browser, the server will respond by rendering the `about.xhtml` file to the
    display window. Figure 7.7 is a screenshot of the about page. The about page uses
    Bootstrap styles in the same manner as the home page.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行MyBlog应用程序并在浏览器中导航到`127.0.0.1:5000/about`，服务器将通过渲染`about.xhtml`文件到显示窗口来响应。图7.7是关于页面的截图。关于页面使用Bootstrap样式的方式与主页相同。
- en: '![](../../OEBPS/Images/CH07_F07_Farrell.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F07_Farrell.png)'
- en: Figure 7.7 The new about page rendered using Bootstrap styling
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 使用Bootstrap样式渲染的新关于页面
- en: 7.4.4 Refactored app instance
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.4 重构应用实例
- en: At this point, the MyBlog application—and Flask `app` instance in particular—has
    been refactored to better support a growing web application. Figure 7.8 shows
    how the `create_app()` function connects to the functionality contained in the
    external `intro` module, which has access to the `app` instance inside that function’s
    scope. The `app` instance is returned by the `create_app` function imported inside
    the scope of the `myblog.py` code. The reference to the `app` instance is held
    by `myblog.py` for the life of the application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，MyBlog应用程序（特别是Flask `app`实例）已经被重构，以更好地支持不断增长的Web应用程序。图7.8显示了`create_app()`函数如何连接到外部`intro`模块中包含的功能，该模块在该函数的作用域内可以访问`app`实例。`app`实例由在`myblog.py`代码作用域内导入的`create_app`函数返回。`app`实例的引用由`myblog.py`在整个应用程序的生命周期中持有。
- en: '![](../../OEBPS/Images/CH07_F08_Farrell.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F08_Farrell.png)'
- en: Figure 7.8 The visual structure of the refactored My**Blog application**
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 重构后的My**Blog应用程序的视觉结构
- en: 7.5 Navigation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 导航
- en: The MyBlog application now has two pages—the home and about pages. You can navigate
    to them directly by entering the URL into the browser, but that’s not very convenient.
    Websites provide clickable links to navigate around the application; you’ll add
    that navigation using Bootstrap.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog应用程序现在有两个页面——主页和关于页面。你可以通过在浏览器中输入URL直接导航到它们，但这不是很方便。网站提供可点击的链接来在应用程序中导航；你将通过使用Bootstrap来添加这个导航。
- en: The MyBlog site navigation is provided by a Bootstrap navbar added to the `base.xhtml`
    template so it’s rendered on any page inheriting from it, essentially sitewide.
    The Bootstrap navbar is visually attractive and responsive to device size. It
    contracts to be a drop-down menu for small devices.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog网站的导航是通过添加到`base.xhtml`模板中的Bootstrap导航栏来提供的，因此它会在继承自它的任何页面上渲染，本质上是在整个网站上。Bootstrap导航栏视觉上吸引人，并能根据设备大小做出响应。在小设备上它会收缩成一个下拉菜单。
- en: You can also add some interactive touches by making the currently active page’s
    menu item visibly highlighted. This means that if the about page is being viewed,
    the about menu item is highlighted. You’ll add this by making use of features
    in Jinja2.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使当前活动页面的菜单项明显突出显示来添加一些交互式效果。这意味着如果正在查看关于页面，关于菜单项将被突出显示。你将通过利用Jinja2中的功能来实现这一点。
- en: 7.5.1 Creating navigation information
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 创建导航信息
- en: 'There are two parts to adding the navbar and making it interactive. The first
    thing to do is edit the `base.xhtml` template file in the root templates folder
    and add this code at the top of the file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 添加导航栏并使其交互式有两个部分。首先要做的事情是编辑根模板文件夹中的`base.xhtml`模板文件，并在文件顶部添加以下代码：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① This is a Jinja2 comment in the template.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这是在模板中的Jinja2注释。
- en: ② Creates a variable named nav_items containing a list of dictionaries with
    navigation information in each dictionary item
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个名为nav_items的变量，包含一个字典列表，每个字典项中都有导航信息
- en: The `{% set ... %}` block allows you to create a variable just as you would
    in Python code used by other parts of the template. The `nav_items` list variable
    holds the navigation information necessary to build the Bootstrap navbar links.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% set ... %}`块允许你创建一个变量，就像在模板的其他部分使用的Python代码中一样。`nav_items`列表变量持有构建Bootstrap导航栏链接所需的导航信息。'
- en: 'Look at the link information in the `nav_items` structure. The home-page link
    is ''`intro_bp.home`'', not just `home`. This would appear in an HTML link in
    a template like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 查看nav_items结构中的链接信息。主页链接是"`intro_bp.home`"，而不是仅仅`home`。这将在模板中的HTML链接中显示，如下所示：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `url_for` function knows how to find the page relative to the `intro` Blueprint
    and uses the `intro` Blueprint instance `intro_bp`. It then finds the URL endpoint
    `home` relative to that. You’ll see how this is used when rendering the navbar
    next.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`url_for`函数知道如何找到相对于`intro` Blueprint的页面，并使用`intro` Blueprint实例`intro_bp`。然后，它找到相对于该实例的`home`
    URL端点。你将在渲染导航栏时看到这一点是如何使用的。'
- en: 7.5.2 Displaying navigation information
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 显示导航信息
- en: 'The second part of creating the navbar is further down in the `base.xhtml`
    template file. Just above the `{% block content %}{% endblock %},` insert this
    code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 创建导航栏的第二部分位于`base.xhtml`模板文件的下方。在`{% block content %}{% endblock %}`上方插入以下代码：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① This begins the Bootstrap navbar styling section and sets the color and style
    of the navbar.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这开始Bootstrap导航栏样式部分，并设置导航栏的颜色和样式。
- en: ② Creates the MyBlog brand icon as a clickable link to the home page
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建MyBlog品牌图标作为可点击链接到主页
- en: ③ Iterates over the nav_items variable
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 遍历nav_items变量
- en: ④ Compares the current page to the current nav_item link
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 比较当前页面与当前nav_item链接
- en: ⑤ Outputs a highlighted link if the comparison was true
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果比较为真，则输出高亮链接
- en: ⑥ Outputs a normal link if the comparison was false
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果比较为假，则输出普通链接
- en: There’s quite a bit going on here. Much of the code is about getting Bootstrap-style
    classes in the right places with the correct context and information. This is
    a lot of styling information to work with and learn when using Bootstrap. However,
    it’s minuscule when compared to providing the same styling functionality with
    handwritten CSS code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行中。大部分代码都是关于在正确的上下文中将Bootstrap样式的类放在正确的位置。当使用Bootstrap时，这是一些大量的样式信息需要处理和学习。然而，与使用手写的CSS代码提供相同的样式功能相比，这微不足道。
- en: An interesting part of the template code is the `for` loop and the `if` statement
    within it. The `for` loop iterates over the previously created `nav_items` list,
    pulling out one `nav_item` at a time. The `if` statement uses the built-in object
    and attribute `request.endpoint` to determine if the page currently being built
    is the same as the `nav_item["link"]` value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 模板代码中的一个有趣部分是`for`循环和其中的`if`语句。`for`循环遍历之前创建的`nav_items`列表，每次拉出一个`nav_item`。`if`语句使用内置对象和属性`request.endpoint`来确定当前构建的页面是否与`nav_item["link"]`值相同。
- en: If the current page is equal to the `nav_item` link, the navbar menu item is
    an HTML link containing the class `active` and the HTML attribute `aria-current=
    "page"`. The Bootstrap `active` class adds visual highlighting to the menu item.
    The HTML attribute `aria-current="page"` helps users navigating to the page that
    are using a screen reader for accessibility. If the current page is not equal
    to the `nav_item` link, the navbar menu item is rendered in its default state
    with no highlight applied.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前页面等于`nav_item`链接，则导航栏菜单项是一个包含类`active`和HTML属性`aria-current= "page"`的HTML链接。Bootstrap的`active`类为菜单项添加了视觉突出显示。HTML属性`aria-current="page"`帮助使用屏幕阅读器的用户导航到页面，以实现无障碍访问。如果当前页面不等于`nav_item`链接，则导航栏菜单项以默认状态渲染，没有应用突出显示。
- en: 7.5.3 MyBlog’s current look
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.3 MyBlog的当前外观
- en: 'If you change your working directory to `examples/CH_07/examples/04`, there’s
    a fully functional example program that implements what we’ve gone through. Use
    the following commands to run the application for Mac and Linux users:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将工作目录更改为`examples/CH_07/examples/04`，那里有一个完全功能性的示例程序，实现了我们所讨论的内容。使用以下命令为Mac和Linux用户运行应用程序：
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And these commands for Windows users:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Windows用户的命令：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When the application is running, use your browser to navigate to `127.0.0.1:5000`,
    and you’ll see the application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，使用你的浏览器导航到`127.0.0.1:5000`，你会看到应用程序。
- en: Figure 7.9 shows the current MyBlog application with the newly added Bootstrap
    navbar directly below the banner. This is the expanded view, with the home-page
    menu item highlighted by the `base.xhtml` template code shown previously.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9显示了带有新添加的Bootstrap导航栏的当前MyBlog应用程序，位于横幅下方。这是展开视图，主页菜单项通过之前显示的`base.xhtml`模板代码突出显示。
- en: '![](../../OEBPS/Images/CH07_F09_Farrell.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F09_Farrell.png)'
- en: Figure 7.9 The MyBlog application displaying a Bootstrap navbar
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 MyBlog应用程序显示Bootstrap导航栏
- en: If you start to minimize the browser window horizontally, you’ll see that the
    navbar navigation will be reduced to a dropdown button on the right side of the
    navbar (figure 7.10). If you click that button, the navigation menu items will
    appear, allowing access to the Home and About links. This shows the advantages
    of using Bootstrap’s responsive design features.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始水平缩小浏览器窗口，你会看到导航栏导航将减少到导航栏右侧的下拉按钮（图7.10）。点击该按钮，导航菜单项将出现，允许访问主页和关于链接。这显示了使用Bootstrap响应式设计功能的优点。
- en: '![](../../OEBPS/Images/CH07_F10_Farrell.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F10_Farrell.png)'
- en: Figure 7.10 Bootstrap has its own media queries to manage smaller screens, adjusting
    the menu bar.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 Bootstrap有其自己的媒体查询来管理较小的屏幕，调整菜单栏。
- en: 7.6 Application configuration
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 应用程序配置
- en: The MyBlog application has come a long way since its first incarnation, and
    there’s work to do to improve it further. The development you’re embarking on
    targets making the configuration, sustainability, and maintainability of the application
    better and easier.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 自从MyBlog应用程序首次发布以来，它已经取得了长足的进步，并且还有工作要做以进一步改进它。你即将开始的开发工作旨在使应用程序的配置、可持续性和可维护性更好、更简单。
- en: 7.6.1 Configuration files
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 配置文件
- en: The MyBlog application will eventually rely on functionality that needs configuration
    data—sending an email to an email service, accessing a database to store users
    and blog posts, and providing security data for the Flask application itself.
    In addition to the configuration data needed by the MyBlog feature set, you’ll
    want to set up distinct data for development and production environments.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog应用程序最终将依赖于需要配置数据的功能——向电子邮件服务发送电子邮件、访问数据库以存储用户和博客文章，以及为Flask应用程序本身提供安全数据。除了MyBlog功能集所需的配置数据之外，你还将想要为开发和生产环境设置不同的数据。
- en: The configuration data creates an environment in which the MyBlog application
    will run. A development environment often provides additional debugging services
    and access to the inner workings of the application. If you develop an application
    in a team, different configuration data is needed to create a staging environment.
    A staging environment is where the team can test the various parts of the application
    before being pushed into production. A production environment removes the debug
    information and restricts access to only the feature set intended to be publicly
    available.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 配置数据创建了一个环境，MyBlog应用程序将在其中运行。开发环境通常提供额外的调试服务和对应用程序内部运作的访问。如果你在一个团队中开发应用程序，需要不同的配置数据来创建一个预发布环境。预发布环境是团队可以在将应用程序推入生产之前测试应用程序各个部分的地方。生产环境会移除调试信息，并限制只对打算公开提供的功能集进行访问。
- en: 7.6.2 Private information
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 私人信息
- en: Any application whose feature set includes accessing systems or services requiring
    usernames, passwords, or API keys needs to keep that information private. For
    example, the MyBlog application will automatically send emails to users and administrators.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含访问需要用户名、密码或API密钥的系统或服务的功能集的应用程序都需要保护这些信息不被泄露。例如，MyBlog应用程序会自动向用户和管理员发送电子邮件。
- en: The MyBlog application won’t handle sending an email directly but will instead
    use an external SMTP email server. The app will need to authenticate the email
    server with a username and password and possibly an API key. Although the MyBlog
    application will need access to this information, you don’t want this information
    to become available in the public domain.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog应用程序不会直接处理发送电子邮件，而是会使用外部的SMTP电子邮件服务器。应用程序需要使用用户名和密码以及可能是一个API密钥来验证电子邮件服务器。尽管MyBlog应用程序需要访问这些信息，但你不想这些信息变成公共领域的内容。
- en: It would be easy to embed this information directly in the code, but that pretty
    much assures that it would become public. Unintentionally making private data
    public could happen as easily as embedding private information in the code and
    then checking that code into a publicly accessible repository like GitHub. Services
    like GitHub provide a valuable resource to developers, but they don’t automatically
    protect you from publishing things you didn’t intend to.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将此信息嵌入代码中很容易，但这几乎可以保证它会变成公开信息。无意中将私人数据公开可能就像在代码中嵌入私人信息并将其检查到像GitHub这样的公开可访问的存储库中一样容易。像GitHub这样的服务为开发者提供了宝贵的资源，但它们不会自动保护你不发布你无意发布的内容。
- en: As a developer, you’ll want to protect yourself and your employer so the services
    your application uses aren’t abused. Besides being good practice, if the services
    cost money, failing to protect them could cost more than you expected.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你将想要保护自己和你的雇主，确保你的应用程序使用的服务不会被滥用。除了是良好的实践之外，如果这些服务需要付费，未能保护它们可能会让你付出比预期更多的代价。
- en: One way to separate private information from an application but still have access
    to it is to store the information in separate files that the application can access
    at runtime. These files aren’t checked into a repository, so they are at less
    risk of becoming public. Additionally, multiple versions can be maintained for
    the different environments in which the application can run, like development,
    staging, and production.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一种将私有信息与应用程序分离但仍然可以访问的方法是将信息存储在应用程序在运行时可以访问的单独文件中。这些文件不会被提交到版本库中，因此它们不太可能被公开。此外，可以为应用程序可以运行的不同环境（如开发、测试和生产）维护多个版本。
- en: 7.7 Flask Debug Toolbar
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 Flask Debug Toolbar
- en: To make introducing configuration files more interesting, you’ll be using them
    to add the Flask Debug Toolbar ([https://github.com/pallets-eco/flask-debugtoolbar](https://github.com/pallets-eco/flask-debugtoolbar))
    to the MyBlog application when it’s running in development mode. The toolbar is
    useful when developing a Flask application. It shows internal information right
    in the browser window that would otherwise only be available by debugging the
    application itself or by examining log information.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使引入配置文件更有趣，你将使用它们在开发模式下运行 MyBlog 应用程序时，将其添加到 Flask Debug Toolbar ([https://github.com/pallets-eco/flask-debugtoolbar](https://github.com/pallets-eco/flask-debugtoolbar))。当开发
    Flask 应用程序时，该工具栏非常有用。它直接在浏览器窗口中显示内部信息，否则这些信息只能通过调试应用程序本身或检查日志信息才能获得。
- en: 'The configuration files you’ll add will control information the Debug Toolbar
    requires to run and dynamically installs the toolbar only in development environments.
    The Debug Toolbar module needs to exist in the currently active Python virtual
    environment as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您将添加的配置文件将控制调试工具栏运行所需的信息，并且仅在开发环境中动态安装工具栏。调试工具栏模块需要存在于当前活动的 Python 虚拟环境中，如下所示：
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 7.7.1 FlaskDynaConf
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.1 FlaskDynaConf
- en: 'The configuration information is stored in TOML files, which are human readable
    and support data types for the information contained within them. To gain access
    to the configuration TOML files, you’ll need to install the `dynaconf` module
    into the current Python virtual environment as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 配置信息存储在 TOML 文件中，这些文件是可读的，并支持其中包含的信息的数据类型。要访问配置 TOML 文件，您需要将 `dynaconf` 模块安装到当前的
    Python 虚拟环境中，如下所示：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The module contains a class specific to Flask that will automatically add configuration
    information to the Flask configuration system. The Flask Debug Toolbar requires
    the Flask app to have a `SECRET_KEY` value. The `SECRET_KEY` value is also used
    for security aspects of a Flask application used in later chapters. In the configuration
    file, it looks like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块包含一个针对 Flask 的特定类，该类会自动将配置信息添加到 Flask 配置系统中。Flask Debug Toolbar 需要Flask应用有一个
    `SECRET_KEY` 值。该 `SECRET_KEY` 值也用于后续章节中使用的 Flask 应用的安全方面。在配置文件中，它看起来是这样的：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: tip Following my own advice, the actual secret key used during the example code
    development isn’t revealed. The secret key’s value should be a cryptographically
    strong string of characters that isn’t publicly known.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：遵循自己的建议，示例代码开发中实际使用的密钥值没有公开。密钥值应该是一个不易被公众所知的、具有加密强度的字符串。
- en: 'You can generate a `SECRET_KEY` value with the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码生成一个 `SECRET_KEY` 值：
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① Sample output
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ① 示例输出
- en: 'The `secrets` module provides cryptographically strong random values better
    suited to manage private information. The printed results are copied between the
    quotes as the `secret_key` value in a file named `.secrets.toml`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`secrets` 模块提供了更适合管理私有信息的加密强度随机值。打印结果作为文件名为 `.secrets.toml` 中的 `secret_key`
    值被复制在引号之间：'
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The file structure contains sections, indicated by the `[default]` line, and
    a set of key/value pairs of data. Because the `secret_key` is defined within the
    `[default]` section, that value is available in any other section unless it is
    overridden explicitly by another `secret_key` key/value pair. Completing the configuration
    to add the Flask Debug Toolbar requires the creation of another TOML file, `settings.toml`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构包含由 `[default]` 行指示的章节，以及一组数据的关键/值对。因为 `secret_key` 在 `[default]` 章节中定义，所以该值在任意其他章节中都是可用的，除非它被另一个
    `secret_key` 关键/值对明确覆盖。完成配置以添加 Flask Debug Toolbar 需要创建另一个 TOML 文件，`settings.toml`：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① No default information is currently defined.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ① 当前没有定义默认信息。
- en: ② Begins the definition of configuration information for development environments
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ② 开始定义开发环境配置信息
- en: ③ Enables the Flask debug mode
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 启用 Flask 调试模式
- en: ④ Begins the definition of the configuration for production environments
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 开始定义生产环境的配置
- en: ⑤ Disables the Flask debug mode
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 禁用 Flask 调试模式
- en: 'The configuration is separated into three sections—`[default]` (currently empty),
    `[development]`, and `[production]`—and could be divided into as many as needed.
    Notice the listed values have data types, and the `extension` key’s value is a
    list of strings. The `flask_debug` key/value pair has a value of `true`, which
    is a Boolean. Each section (aside from `[default]`) is keyed to the Flask environment
    variable initialized before running the application:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 配置分为三个部分——`[default]`（目前为空）、`[development]` 和 `[production]`——可以根据需要分成更多部分。注意列出的值具有数据类型，`extension`
    键的值是一个字符串列表。`flask_debug` 键/值对具有布尔值 `true`。每个部分（除 `[default]` 外）都与在运行应用程序之前初始化的
    Flask 环境变量相关联：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Only the information under the `[default]` and the indicated environment will
    be read from the `settings.toml` file at run time. The `settings.toml` files can
    be included in the repository, as it’s useful to anyone wanting to work on the
    application and doesn’t contain secret information. The `secrets.toml` file should
    be excluded from the project repository because it contains information that shouldn’t
    be publicly available.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，只会从 `settings.toml` 文件中读取 `[default]` 和指示的环境下的信息。`settings.toml` 文件可以包含在存储库中，因为它对任何想要在应用程序上工作的人来说都很有用，并且不包含机密信息。`secrets.toml`
    文件应从项目存储库中排除，因为它包含不应公开的信息。
- en: Configuring MyBlog
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 MyBlog
- en: 'To use the configuration information, you need to make changes to the MyBlog
    application. Because the configuration is central to the application, make the
    following changes to the `app/__init__.py` file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用配置信息，您需要修改 MyBlog 应用程序。因为配置对应用程序至关重要，所以请在 `app/__init__.py` 文件中进行以下更改：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① Imports the Flask-specific dynaconf class
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入 Flask 特定的 dynaconf 类
- en: ② Creates an instance of the FlaskDynaconf class, activating the module loader
    feature
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建 FlaskDynaconf 类的实例，激活模块加载功能
- en: ③ Informs dynaconf where to look for configuration *.toml files
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 告知 dynaconf 在何处查找配置 *.toml 文件
- en: ④ Configures the Flask app based on the dynaconf-read configuration files
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 根据 dynaconf-read 配置文件配置 Flask 应用程序
- en: ⑤ Translates the SECRET_KEY string into a bytearray as recommended by the Flask
    documentation
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将 SECRET_KEY 字符串转换为字节序列，如 Flask 文档中建议的那样
- en: The `FlaskDynaconf` class searches for configuration files based on file-naming
    patterns and directory structures and finds both the `.secrets.toml` and `settings
    .toml` files. It parses them and configures the Flask `app.config` object accordingly.
    Running the MyBlog application in `examples/CH_07/examples/05` in the development
    environment renders the home page in the browser and presents the Flask Debug
    Toolbar on the right side of the screen (figure 7.11).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlaskDynaconf` 类根据文件命名模式和目录结构搜索配置文件，并找到 `.secrets.toml` 和 `settings .toml`
    文件。它解析它们并根据需要配置 Flask 的 `app.config` 对象。在开发环境中运行 `examples/CH_07/examples/05`
    下的 MyBlog 应用程序，在浏览器中渲染主页，并在屏幕右侧显示 Flask 调试工具栏（图 7.11）。'
- en: '![](../../OEBPS/Images/CH07_F11_Farrell.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F11_Farrell.png)'
- en: Figure 7.11 The rendered page now includes the Flask Debug Toolbar.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 渲染的页面现在包括 Flask 调试工具栏。
- en: The initial view doesn’t show much difference except for the small tab in the
    upper right corner of the window labeled FDT for Flask Debug Toolbar. Clicking
    on this tab opens the toolbar and presents some information about the page as
    well as the tools it makes available. Figure 7.12 displays the expanded toolbar.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 初始视图没有太多区别，除了窗口右上角的小标签页，标签页上标有 FDT，代表 Flask 调试工具栏。点击此标签页将打开工具栏，并显示有关页面以及它提供的工具的一些信息。图
    7.12 显示了扩展的工具栏。
- en: '![](../../OEBPS/Images/CH07_F12_Farrell.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F12_Farrell.png)'
- en: Figure 7.12 The Flask Debug Toolbar expanded view showing the tools available
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 展示了可用的 Flask 调试工具栏的扩展视图
- en: Clicking on the Templates menu item loads the working area of the display with
    information about the home page template (figure 7.13). This includes the context
    variables used by the template, the URL that was requested, and the information
    about the session.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“模板”菜单项将加载显示的工作区域，其中包含有关主页模板的信息（图 7.13）。这包括模板使用的上下文变量、请求的 URL 以及有关会话的信息。
- en: '![](../../OEBPS/Images/CH07_F13_Farrell.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F13_Farrell.png)'
- en: Figure 7.13 The information about the current template is displayed after selecting
    the Templates tool.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 选择模板工具后，将显示当前模板的信息。
- en: Not all the menu options provide useful information. The Logging selection doesn’t
    show anything currently but will after adding a logging configuration in the next
    section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有菜单选项都提供有用的信息。在下一节添加日志配置后，日志选择将不会显示任何内容，但之后会显示。
- en: 7.8 Logging information
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 日志信息
- en: Flask uses the Python logging module to log information to standard output (`STDOUT`),
    as you’ve seen when running the MyBlog application from the terminal command line.
    Almost any coding from a developer leads to inserting print statements into the
    code to get information out of a running application. A better approach to output
    this kind of information is to use the Python logging system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Flask使用Python日志模块将信息记录到标准输出（`STDOUT`），正如你在从终端命令行运行MyBlog应用程序时所看到的那样。几乎任何开发者的编码都会导致在代码中插入打印语句以获取运行应用程序的信息。输出这类信息的一个更好的方法是使用Python日志系统。
- en: Logging is a simple way to get a snapshot of what’s happening at that point
    of execution in the application. The same facility is available when developing
    a web application through the logging system. Logging information to `STDOUT`
    is beneficial in a long-running server application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志是一种简单的方法，可以获取应用程序在执行过程中的快照。当通过日志系统开发Web应用程序时，同样可以提供这种功能。将日志信息记录到`STDOUT`对于长时间运行的服务器应用程序来说是有益的。
- en: The logging system has advantages over print statements; it supports severity
    levels for the logged information. The severity levels allow you to raise and
    lower the level of logs the application will produce. For example, you can output
    useful development information at the `DEBUG` level. The configuration of the
    application running in a production environment can be raised above the `DEBUG`
    level and none of the developer debug logs will be produced. The debug log statements
    can be left in place in the code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 日志系统相对于打印语句有优势；它支持记录信息的严重级别。严重级别允许你提高或降低应用程序将产生的日志级别。例如，你可以在`DEBUG`级别输出有用的开发信息。在生产环境中运行的应用程序的配置可以提高到`DEBUG`级别以上，这样就不会产生任何开发者的调试日志。调试日志语句可以保留在代码中。
- en: 'It can also provide a standardized format that’s chronologically arranged and
    useful when looking for events or the order of operations for a sequence of events.
    The Python logging system supports multiple paths, or handlers, for logged messages
    with different endpoints. These endpoints can be as simple as logging to `STDOUT`
    or more sophisticated, like sending an email or text message to a service in response
    to a logged message. For the MyBlog application, the logging configuration is
    relatively simple: sending logs to `STDOUT` with a particular message format.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以提供一个按时间顺序排列的标准格式，这在查找事件或一系列事件的操作顺序时非常有用。Python日志系统支持多个路径，或处理程序，用于记录不同端点的消息。这些端点可以像记录到`STDOUT`那样简单，也可以更复杂，例如在记录消息后向服务发送电子邮件或短信。对于MyBlog应用程序，日志配置相对简单：以特定的消息格式将日志发送到`STDOUT`。
- en: 7.8.1 Configuration
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8.1 配置
- en: The Python logging module supports configuration from a dictionary, and that’s
    what MyBlog will use. Configuring the logging system is another responsibility
    you’ll add to the app package’s `create_app()` function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Python日志模块支持从字典中进行配置，这正是MyBlog将要使用的。配置日志系统是你要添加到应用程序包的`create_app()`函数中的另一个责任。
- en: As mentioned, the logging system uses logging levels, ranging from `NOTSET`
    to `CRITICAL`, where `NOTSET` equals 0 and `CRITICAL` equals 50\. In my experience,
    `NOTSET` is never used and is there to “round out the set.” Besides providing
    some context about the logged message, the logging system’s level acts as a simple
    filter. If the logging system’s level is set to `INFO` for a particular logger,
    only messages with a level equal to `INFO` or higher will be logged.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，日志系统使用日志级别，从`NOTSET`到`CRITICAL`，其中`NOTSET`等于0，`CRITICAL`等于50。在我的经验中，`NOTSET`很少使用，它存在是为了“完善集合”。除了提供一些关于记录消息的上下文信息外，日志系统的级别还充当一个简单的过滤器。如果特定记录器的日志系统级别设置为`INFO`，则只有级别等于`INFO`或更高的消息会被记录。
- en: The `DEBUG` (value 10) and `INFO` (value 20) levels are of interest for the
    development and production environments in which the MyBlog application runs.
    In development, the level can be set to `DEBUG,` and all logged messages with
    a level of `DEBUG` or higher will be logged. In a production environment, the
    level can be set to `INFO,` all log messages with a level of `INFO` or higher
    will be logged, and `DEBUG`-level messages will be ignored.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEBUG`（值 10）和 `INFO`（值 20）级别对于 MyBlog 应用程序运行的开发和生产环境都很有兴趣。在开发环境中，可以将级别设置为
    `DEBUG,`，所有级别为 `DEBUG` 或更高的日志消息都将被记录。在生产环境中，可以将级别设置为 `INFO,`，所有级别为 `INFO` 或更高的日志消息都将被记录，而
    `DEBUG` 级别的消息将被忽略。'
- en: 'By differentiating the two environment’s logging levels, you can add `DEBUG`-level
    messages into an application during development and leave them in place. In a
    production environment, those messages won’t be logged. The Python dictionary
    to configure logging is created by reading a logging configuration YAML file with
    a support function in `app/__init__.py`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过区分两个环境的日志级别，你可以在开发期间将 `DEBUG` 级别的消息添加到应用程序中，并保留它们。在生产环境中，这些消息不会被记录。配置日志的 Python
    字典是通过在 `app/__init__.py` 中使用支持函数读取日志配置 YAML 文件创建的：
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `_configure_logging()` function has a leading underbar character, a convention
    indicating it’s intended to be private to the module. The leading underbar is
    only a convention and does not add any privacy protections to the function.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`_configure_logging()` 函数有一个前置下划线字符，这是一个表示它打算仅对模块私有的约定。前置下划线仅是一个约定，并不会给函数添加任何隐私保护。'
- en: 'The function creates an `env_logging_level` variable based on the environment
    string passed to the function. The variable is used to create the configuration
    dictionary to control the logging level console `STDOUT` handler. The logging
    configuration information is in a file named `logging_config.yaml` at the project
    directory level:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 函数根据传递给函数的环境字符串创建一个 `env_logging_level` 变量。该变量用于创建配置字典以控制控制台 `STDOUT` 处理程序的日志级别。日志配置信息位于项目目录级别的名为
    `logging_config.yaml` 的文件中：
- en: '[PRE32]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① Disables any existing loggers created by Flask
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ① 禁用 Flask 创建的任何现有日志记录器
- en: ② Configures only one handler to send errors to STDOUT
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ② 仅配置一个处理程序将错误发送到 STDOUT
- en: 'The structure creates the formatters used by the handlers, which the loggers
    use. The formatters change the logging message default format used by the MyBlog
    application. Add a `logging_level` configuration key/value to the `settings.toml`
    file to both the development and production sections as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 结构创建由日志记录器使用的格式化程序，这些格式化程序改变了 MyBlog 应用程序使用的默认日志消息格式。将 `logging_level` 配置键/值添加到
    `settings.toml` 文件的开发和生产部分，如下所示：
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Two changes need to be made to the `create_app()` function in `app/__init__.py`
    to use the dictionary returned by the `_configure_logging()` function. Add these
    two lines at the bottom of the import section
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对 `app/__init__.py` 中的 `create_app()` 函数进行两项更改，以使用 `_configure_logging()`
    函数返回的字典。在导入部分的底部添加这两行代码
- en: '[PRE34]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'and add this line to the `create_app()` function immediately below the code
    that converts the `app.config[SECRET_KEY]` to a bytearray:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 并在将 `app.config[SECRET_KEY]` 转换为 bytearray 的代码下方立即添加此行到 `create_app()` 函数中：
- en: '[PRE35]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ① Calling the function configures logging for the MyBlog application
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ① 调用函数配置 MyBlog 应用的日志记录
- en: 'You can now add `DEBUG`-level log messages where needed to help develop the
    MyBlog application. The home and about pages can be modified as follows to demonstrate
    this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以在需要的地方添加 `DEBUG` 级别的日志消息，以帮助开发 MyBlog 应用程序。主页和关于页面可以按以下方式修改以演示这一点：
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ① Sends a DEBUG-level message to the logging system that the home page has been
    rendered
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ① 向日志系统发送一条 DEBUG 级别的消息，表示主页已被渲染
- en: ② Sends a DEBUG-level message to the logging system that the home page has been
    rendered
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ② 向日志系统发送一条 DEBUG 级别的消息，表示主页已被渲染
- en: 'When starting and running the MyBlog application, a `DEBUG` log message will
    be present in the logging output whenever the application home or about pages
    are accessed. If you run the code in `examples/CH_07/examples/06` and navigate
    to the about and home pages, the log output will look similar to this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动和运行 MyBlog 应用程序时，每当访问应用程序的主页或关于页面时，日志输出中都会出现一条 `DEBUG` 级别的日志消息。如果你在 `examples/CH_07/examples/06`
    目录下运行代码，并导航到关于和主页，日志输出将类似于以下内容：
- en: '[PRE37]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you set the environment variable `FLASK_ENV=production` and run the MyBlog
    application, any `DEBUG` messages generated by the app won’t be present in the
    logging output. Suppressing `DEBUG` messages is useful in production environments
    to keep from cluttering the logging output with development information.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置环境变量 `FLASK_ENV=production` 并运行 MyBlog 应用程序，则应用程序生成的任何 `DEBUG` 消息都不会出现在日志输出中。在生产环境中抑制
    `DEBUG` 消息可以避免在日志输出中添加开发信息。
- en: 7.9 Adding a favicon
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.9 添加 favicon
- en: A favicon is a graphic image used as a shortcut to represent a website. Supporting
    a favicon gives the MyBlog application some additional professionalism, so we’ll
    add one.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: favicon 是用作代表网站的快捷方式的图形图像。支持 favicon 为 MyBlog 应用程序提供了一些额外的专业性，因此我们将添加一个。
- en: The code in `examples/CH_07/examples/07` includes two versions of the MyBlog
    brand graphic; one in the .ico format (icon) and one in the .svg format (Scalable
    Vector Graphics). The first will give a browser window tab holding the MyBlog
    application the small brand icon. The second appears alongside the MyBlog text
    in the navigation bar. In this context, the brand icon is a visual shorthand associated
    with the MyBlog application.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`examples/CH_07/examples/07` 目录中的代码包含 MyBlog 品牌图形的两个版本；一个是 .ico 格式（图标），另一个是
    .svg 格式（可缩放矢量图形）。第一个版本将为 MyBlog 应用程序的浏览器窗口标签页提供小品牌图标。第二个版本将出现在导航栏中的 MyBlog 文本旁边。在此上下文中，品牌图标是与
    MyBlog 应用程序相关联的视觉简写。'
- en: 'The `favicon.ico` file has to be served from the MyBlog application when requested
    by the browser. The browser expects to find it in the root folder, which won’t
    be part of any Flask Blueprint in MyBlog. The `favicon.ico` is made available
    by adding a route to it directly in the `app/__init__.py` file, inside the `app.app_
    context()` context manager:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器请求时，`favicon.ico` 文件必须由 MyBlog 应用程序提供。浏览器期望在根文件夹中找到它，它不会是 MyBlog 中的任何 Flask
    Blueprint 的一部分。通过在 `app/__init__.py` 文件中直接添加一个路由到它，在 `app.app_context()` 上下文管理器内部，`favicon.ico`
    文件被提供：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The code registers the URL route where the browser is looking for the `favicon()`
    function. Flask uses the `send_from_directory()` function to get the file’s path,
    the filename, and the mime type and return it to the browser. The `send_from_
    directory()` function must be imported to make it available. The code in the repository
    does this.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码注册了浏览器正在寻找的 `favicon()` 函数的 URL 路由。Flask 使用 `send_from_directory()` 函数来获取文件的路径、文件名和
    MIME 类型，并将其返回给浏览器。必须导入 `send_from_directory()` 函数以使其可用。仓库中的代码就是这样做的。
- en: 'You’ll also add the MyBlog brand SVG image in the navigation bar built in the
    `base.xhtml` template. The image is added immediately before the MyBlog text in
    the navbar brand section of the template:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在 `base.xhtml` 模板中构建的导航栏中添加 MyBlog 品牌SVG图像。图像添加在模板的导航栏品牌部分 MyBlog 文本之前：
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This HTML code adds an image link that finds the `myblog_brand_icon.svg` file
    in the application root static folder and scales it appropriately for display
    in the navigation bar. Running the MyBlog application in `examples/CH_07/examples/07`
    presents a browser display that includes the `favicon.ico` and `myblog_brand_icon
    .svg` image files.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 HTML 代码添加了一个图像链接，它找到应用程序根静态文件夹中的 `myblog_brand_icon.svg` 文件，并适当地缩放以在导航栏中显示。在
    `examples/CH_07/examples/07` 中运行 MyBlog 应用程序会显示包含 `favicon.ico` 和 `myblog_brand_icon.svg`
    图像文件的浏览器显示。
- en: The `favicon.ico` file is displayed in the browser tab containing the MyBlog
    application. The `myblog_brand_icon.svg` file is displayed immediately to the
    left of the MyBlog text in the navigation bar. Both are shown in the figure 7.14
    screenshot of the application. The brand graphic and name are clickable links
    returning the user to the application’s home page.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`favicon.ico` 文件在包含 MyBlog 应用程序的浏览器标签页中显示。`myblog_brand_icon.svg` 文件在导航栏中 MyBlog
    文本立即左侧显示。两者都在图 7.14 应用程序截图中显示。品牌图形和名称是可点击的链接，将用户返回到应用程序的主页。'
- en: '![](../../OEBPS/Images/CH07_F14_Farrell.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F14_Farrell.png)'
- en: Figure 7.14 The browser display, including the favicon and MyBlog brand SVG
    images
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 浏览器显示，包括 favicon 和 MyBlog 品牌SVG图像
- en: 7.10 Closing thoughts
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10 结束语
- en: Having Bootstrap integrated into the application goes a long way toward making
    MyBlog look polished and professional while at the same time reducing the development
    workload of creating that look and feel. The refactoring work done to MyBlog gives
    you a good foundation from which to grow the application further. Adding new features
    will be simpler because backtracking to address initial assumptions will be avoided.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将Bootstrap集成到应用程序中对于使MyBlog看起来更加精致和专业大有裨益，同时减少了创建这种外观和感觉的开发工作量。对MyBlog进行的重构工作为您提供了一个良好的基础，可以在此基础上进一步扩展应用程序。添加新功能将更加简单，因为可以避免回溯到初始假设。
- en: By adding external configuration files to MyBlog, you’ve enabled the creation
    of multiple run-time environments and moved sensitive information to a more protected
    space. The use of configuration files also lets you add the Flask Debug Toolbar
    and logging levels to the MyBlog application.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向MyBlog添加外部配置文件，您已经启用了多个运行时环境的创建，并将敏感信息移动到了更安全的空间。使用配置文件还允许您将Flask调试工具栏和日志级别添加到MyBlog应用程序中。
- en: You’ve taken some web development concepts and tools in hand where we can examine
    them with a magnifying glass to see their details and how they fit together. Being
    able to look closely at how modules work and connect will be key to adding new
    features. The next chapter will build on this excellent foundation by adding user
    authentication and creation, allowing the MyBlog application to secure pages to
    logged-in users only.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经掌握了某些Web开发概念和工具，我们可以用放大镜仔细检查它们的细节以及它们是如何相互配合的。能够仔细观察模块的工作方式和连接方式对于添加新功能至关重要。下一章将在此基础上构建，通过添加用户身份验证和创建功能，使MyBlog应用程序能够仅对已登录用户安全地显示页面。
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: By using the Bootstrap styling framework, we get good-looking and powerful styles
    and user interactions but keep the focus of our Python work. This helps to reduce
    technical domain switching between Python and CSS/JavaScript UI work.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Bootstrap样式框架，我们获得了美观且强大的样式和用户交互，同时保持了Python工作的重点。这有助于减少在Python和CSS/JavaScript
    UI工作之间的技术领域切换。
- en: Moving from custom CSS to a framework like Bootstrap not only reduces styling
    workload but makes a website’s look and feel more consistent across different
    browsers and operating systems.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从自定义CSS迁移到像Bootstrap这样的框架不仅减少了样式工作量，而且使网站在不同浏览器和操作系统上的外观和感觉更加一致。
- en: Restructuring the simple web application from the previous chapter allows us
    to keep complexity manageable and extensibility possible.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对上一章中的简单Web应用程序进行重构使我们能够保持复杂度可控且可扩展。
- en: Flask’s Blueprint feature gives us a convenient way to structure the related
    web application URL endpoints into namespaces.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask的蓝图功能为我们提供了一个方便的方式来将相关的Web应用程序URL端点组织到命名空间中。
- en: Configuration files for an application should have public and private components.
    Public configuration information can be stored in repositories so others can work
    on the app and access the public configuration. Private or secret configuration
    information should never be present in a repository, as that risks exposure of
    the information.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的配置文件应包含公共和私有组件。公共配置信息可以存储在存储库中，以便其他人可以在此应用程序上工作并访问公共配置。私有或机密配置信息绝不应出现在存储库中，因为这可能导致信息泄露。
- en: Logging information from a web application is useful to monitor the application’s
    health and use. It also provides useful information about how to see and find
    problems that aid with debugging an application.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Web应用程序的日志信息对于监控应用程序的健康状况和使用情况非常有用。它还提供了有关如何查看和发现问题的有用信息，这些信息有助于调试应用程序。
