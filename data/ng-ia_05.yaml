- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Services
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 服务
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Services and their role
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务及其角色
- en: Creating many different types of services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建许多不同类型的服务
- en: Using services to help retrieve and manage data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务来帮助检索和管理数据
- en: Replacing logic from controllers with services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用服务替换控制器中的逻辑
- en: Understanding how dependency injection works with services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解依赖注入如何与服务一起工作
- en: In chapters 4-5, we had the Dashboard component, which generated some data for
    the rest of the application to consume. But that was only because we didn’t want
    to introduce more complexity into the example. This isn’t ideal in most scenarios,
    because that logic is hard to reuse and makes the component unnecessarily complex.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4-5 章中，我们有了仪表板组件，它为应用程序的其余部分生成了一些数据。但这仅仅是因为我们不想在示例中引入更多的复杂性。在大多数情况下，这并不理想，因为这种逻辑难以重用，并使组件变得不必要地复杂。
- en: Your application will need to manage many tasks, and many of them will fall
    outside of the responsibility of components, such as managing data access, managing
    configuration across the app, and utility functions. The Angular HttpService is
    a great example of a service that makes it easy to reuse logic for making HTTP
    requests without having to implement it repeatedly. Although Angular and many
    libraries provide services for you to consume, you can and should make your own
    too.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序将需要管理许多任务，其中许多任务将超出组件的责任范围，例如管理数据访问、管理应用程序范围内的配置以及实用函数。Angular 的 HttpService
    是一个很好的例子，它使得在不重复实现的情况下重用制作 HTTP 请求的逻辑变得容易。尽管 Angular 和许多库为你提供了可以消费的服务，但你也可以也应该创建自己的服务。
- en: '*Services* are fundamentally JavaScript objects that provide commonly used
    logic in a way that other parts of the application can easily consume. For example,
    applications that require a user to log in will need to have a service to help
    manage the user’s state. Or you might have a service that helps manage how you
    make requests to your API and encapsulates the logic necessary away from the components
    using it.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务* 基本上是 JavaScript 对象，它们以其他应用程序部分可以轻松消费的方式提供常用逻辑。例如，需要用户登录的应用程序将需要一个服务来帮助管理用户状态。或者你可能有一个服务，它帮助管理如何向你的
    API 发送请求，并将必要的逻辑封装在使用的组件之外。'
- en: Shared code across your application is almost always best placed inside of a
    service. In Angular, most of the time a service also is something that you can
    inject into your controllers using dependency injection, though there is no exact
    definition of what makes an object a service.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中共享的代码几乎总是最好放在服务中。在 Angular 中，大多数情况下，服务也是你可以通过依赖注入将其注入到控制器中的东西，尽管没有确切的定义来界定什么使一个对象成为服务。
- en: 'To help you out, I’ve come up with several loose classifications that are useful
    in providing insight into the various ways a service can be created. A service
    could fit into more than one of these categories, but I usually try to keep my
    services focused on one of these roles:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你，我想出了几种松散的分类，这些分类在提供关于服务可以创建的各种方式的见解方面非常有用。一个服务可能适合这些类别中的多个，但我通常尽量使我的服务专注于这些角色之一：
- en: '*Injectable* services are the typical Angular services that provide a feature
    for the application and work with Angular’s DI system to be injected into components.
    An example would be a service that handles how to load data from an API.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可注入*的服务是典型的 Angular 服务，为应用程序提供功能并与 Angular 的 DI 系统一起工作以注入到组件中。一个例子是处理如何从 API
    加载数据的服务。'
- en: '*Non-injectable*services are JavaScript objects that aren’t tied into Angular’s
    DI system and are just imported into the file. This can be useful to make a service
    available outside of Angular’s DI, such as in the application’s main file.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可注入*的服务是未与 Angular 的 DI 系统绑定且仅导入到文件中的 JavaScript 对象。这可以用来在 Angular 的 DI 之外使服务可用，例如在应用程序的主文件中。'
- en: '*Helper* services are services that make it easier to use a component or feature.
    An example would be a service to help manage the currently active alert on the
    page.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*辅助*服务是使使用组件或功能更容易的服务。一个例子是帮助管理当前页面上活动的警报的服务。'
- en: '*Data* services are for sharing data across the application. An example is
    an object holding data for the logged-in user.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据*服务用于在应用程序中共享数据。一个例子是包含登录用户数据的对象。'
- en: In chapter 4, it would have been more appropriate to extract data logic into
    a service to separate it from the component. In chapter 5, we talked about designing
    components to focus on a particular role, and that should include keeping the
    controller focused on the minimal tasks needed to manage data by delegating those
    responsibilities to services. *Components* are for displaying the UI, and *services*
    are meant to help manage data or other reusable snippets of logic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，将数据逻辑提取到服务中，以将其与组件分离会更合适。在第5章中，我们讨论了设计组件以专注于特定角色，这应该包括保持控制器专注于通过将责任委托给服务来管理数据的最低限度的任务。*组件*用于显示UI，而*服务*旨在帮助管理数据或其他可重用的逻辑片段。
- en: The goal of a service is to be responsible for a specific set of tasks, which
    in turn helps keep other aspects of your application focused. The size of a service
    isn’t as important as keeping it on task.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的目标是负责一组特定的任务，这反过来又帮助保持应用程序其他方面的专注。服务的大小并不像保持其专注于任务那样重要。
- en: We’re going to look at different ways to use services, and I’ve even named a
    few service patterns that I find to be most common.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨使用服务的方法，我还命名了一些我认为最常见的服务模式。
- en: 6.1 Setting up the chapter example
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 设置章节示例
- en: We’re going to build a fantasy stock-trading application that uses generated
    data which changes several times a minute to simulate real market changes (see
    [figure 6.1](#figure6.1)). You’ll be able to buy and sell stock, but unlike the
    real stock market, you can always reset your account if you lose it all.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个使用生成数据的应用程序，这些数据每分钟变化几次，以模拟真实市场的变化（见[图6.1](#figure6.1)）。你将能够买卖股票，但与真实股票市场不同，如果你输光了所有资金，你总是可以重置你的账户。
- en: '![c06-1.png](image_fi/293313c06/c06-1.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![c06-1.png](image_fi/293313c06/c06-1.png)'
- en: '[**Figure 6.1**](#figureanchor6.1) Fantasy Portfolio stock trading application,
    powered by services'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图6.1**](#figureanchor6.1) 由服务驱动的幻想投资组合股票交易应用程序'
- en: The stock prices change steadily over time (for better or worse), just like
    a real stock market. The stock API automatically handles the changes, so every
    time data is requested it will be refreshed with new values. If you hold onto
    a stock for a few minutes, you can easily gain or lose money. If you want to see
    how your portfolio holds, check it the next day and see whether you made good
    or bad investments, because the value might have drifted up or down by 25%. Your
    portfolio is also stored, so if you return later it will remember your status,
    but you’ll also be able to start over if you lose too much money.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 股票价格随着时间的推移稳步变化（好或坏），就像真实的股票市场一样。股票API自动处理这些变化，所以每次请求数据时，它都会用新的值刷新。如果你持有股票几分钟，你很容易就能赚钱或亏钱。如果你想看看你的投资组合表现如何，第二天检查一下，看看你是否做出了好的或坏的投资，因为价值可能已经上升或下降了25%。你的投资组合也会被保存，所以如果你稍后回来，它会记住你的状态，但你也可以在亏得太多时从头开始。
- en: We’ll use several services to help us manage this application. First we’ll create
    a service to help manage the user’s account data, such as what stocks they’ve
    purchased and how much money they have left in their account. Another service
    will help us provide configuration data to the application to tell us where the
    API service is located. We’ll use the Http library from Angular inside of a service
    to help us load data from the API. Finally we’ll create a service that helps us
    manage the storing of data in local storage, so the experience persists between
    reloads. Each of these fits into one of the categories discussed in the chapter
    introduction.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用几个服务来帮助我们管理这个应用程序。首先，我们将创建一个服务来帮助管理用户的账户数据，例如他们购买了哪些股票以及他们在账户中剩余多少钱。另一个服务将帮助我们向应用程序提供配置数据，告诉我们API服务位于何处。我们将在服务中使用Angular的Http库来帮助我们从API加载数据。最后，我们将创建一个服务来帮助我们管理在本地存储中的数据存储，以便在重新加载之间保持体验。每个服务都符合章节引言中讨论的某个类别。
- en: Unlike previous chapters, this time we’ll start with an application that already
    has some components set up, which will let us focus on building services and not
    worry about implementing other aspects already covered in previous chapters. Some
    code snippets are commented out because they’ll throw errors if enabled, and we’ll
    uncomment them as we build the services that will support them properly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节不同，这次我们将从一个已经设置了一些组件的应用程序开始，这样我们可以专注于构建服务，而不必担心实现之前章节中已经涵盖的其他方面。一些代码片段被注释掉了，因为如果启用它们，将会抛出错误，我们将在构建支持这些服务的服务时取消注释它们。
- en: In this chapter, we’ll use the Clarity UI library from a team at VMware. It
    builds on top of Bootstrap 4 for the CSS grid and layout, but provides a design
    specification that fits their company guidelines. We’ll use a few of the components,
    and you can quickly get a feel for how this particular UI library behaves in comparison
    to ones we’ve used in other chapters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用来自VMware团队中的Clarity UI库。它建立在Bootstrap 4的CSS网格和布局之上，但提供了一个符合他们公司指南的设计规范。我们将使用一些组件，你可以快速了解这个特定的UI库与其他章节中使用的库相比是如何表现的。
- en: 6.1.1 Getting the chapter files
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 获取章节文件
- en: 'You have two choices for setting up this chapter project. You can download
    the project as a zip file from GitHub or clone the repository using Git. If you’re
    using Git, run the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这个章节项目你有两种选择。你可以从GitHub下载项目作为zip文件，或者使用Git克隆仓库。如果你使用Git，请运行以下命令：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can download and unzip the project files from [https://github.com/angular-in-action/portfolio/archive/start.zip](https://github.com/angular-in-action/portfolio/archive/start.zip).
    Either way, you should now have a copy of the code on your computer, and you’ll
    need to also install the node modules for the project. Navigate to the directory
    and run the following to install the modules, and then preview the project:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以从[https://github.com/angular-in-action/portfolio/archive/start.zip](https://github.com/angular-in-action/portfolio/archive/start.zip)下载并解压项目文件。无论哪种方式，你现在都应该在电脑上有一个代码副本，你还需要安装项目的node模块。导航到目录并运行以下命令来安装模块，然后预览项目：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Initially, the application looks a little empty, because it can’t properly render
    until we set up the services to help manage data. As you see in [figure 6.2](#figure6.2),
    the application has a basic layout, with a header and two cards.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，应用程序看起来有点空，因为它不能正确渲染，直到我们设置服务来帮助管理数据。正如你在[图6.2](#figure6.2)中看到的那样，应用程序有一个基本的布局，包括一个页眉和两个卡片。
- en: '![c06-2.png](image_fi/293313c06/c06-2.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![c06-2.png](image_fi/293313c06/c06-2.png)'
- en: '[**Figure 6.2**](#figureanchor6.2) Starting point of chapter example; basic
    header and cards as placeholders'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图6.2**](#figureanchor6.2) 本章示例的起点；使用页眉和卡片作为占位符'
- en: Most of the display is currently commented out (because it would throw many
    errors at this point), so we just see the scaffolding. As we generate services,
    data will start to appear, as you saw in [figure 6.1](#figure6.1). However, the
    layout and structure are fairly straightforward, and you can review it if you’re
    interested in using the Clarity UI library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大部分显示内容都被注释掉了（因为在这个阶段会抛出很多错误），所以我们只能看到框架。随着我们生成服务，数据将开始出现，就像你在[图6.1](#figure6.1)中看到的那样。然而，布局和结构相当直接，如果你对使用Clarity
    UI库感兴趣，可以查看它。
- en: 6.1.2 Sample data
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 示例数据
- en: This application requires stock data, and I’ll quickly cover how it’s being
    generated and provided to the application. The list of stocks that are loaded
    by the application are a subset of the technology stocks from the New York Stock
    Exchange, which is about 160 stocks. You’ll likely recognize some of the stocks
    but not others; they’re real companies and symbols. But the prices associated
    with each one are randomly assigned. There is a back-end process running that
    changes the price values every 5 seconds. The calculations are weighted so that
    most of the changes are 1–2 cent changes, but stocks can also quickly swing up
    to 40 cents every 5 seconds, though that’s far less likely.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序需要股票数据，我会快速介绍它是如何生成并提供给应用程序的。应用程序加载的股票列表是纽约证券交易所技术股票的一个子集，大约有160只股票。你可能认识其中的一些股票，但不是全部；它们是真实的公司和符号。但是，与每个相关的价格都是随机分配的。有一个后端进程每5秒钟更改价格值。计算是加权的，所以大多数变化是1-2美分的变动，但股票也可以在5秒内迅速上涨到40美分，尽管这种情况很少发生。
- en: We’ll create a service that will help us load this data into our application
    from the remote service. Using it, we’ll refresh the data in our application regularly
    to show the latest stock data to the user.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个服务，帮助我们从远程服务加载数据到我们的应用程序中。使用它，我们将定期刷新应用程序中的数据，以向用户展示最新的股票数据。
- en: You can also see the code powering the API changes by looking at the API project
    at [https://github.com/angular-in-action/api](https://github.com/angular-in-action/api).
    You could also run the services locally yourself, but that’s not covered here.
    If you need help, it would be best to post an issue on the API repository. It’s
    unlikely that you’ll need to run it yourself, but you might in case you want to
    tweak its behavior or the service is down.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过查看 API 项目 [https://github.com/angular-in-action/api](https://github.com/angular-in-action/api)
    来查看驱动 API 变化的代码。你也可以自己本地运行服务，但这在这里没有涵盖。如果你需要帮助，最好在 API 存储库上发布一个问题。你不太可能需要自己运行它，但如果你想要调整其行为或服务不可用，你可能需要这样做。
- en: All right, let’s get to building some services. We’re going to start with a
    service that will help us load those stock prices so we can start to see data
    in our application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始构建一些服务。我们将从一个帮助我们加载股票价格的服务开始，这样我们就可以在我们的应用程序中开始看到数据了。
- en: 6.2 Creating Angular services
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 创建 Angular 服务
- en: We’ll build our first service, which will help us maintain account information
    for our fantasy portfolio. It will help provide data to the rest of the application
    about how much money is available in the account, how much has been invested,
    the current list of stocks owned, and so on. The focus of this service is to manage
    the account, just as you would manage a bank or investing account.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建我们的第一个服务，它将帮助我们维护我们的幻想投资组合的账户信息。它将帮助向应用程序的其他部分提供有关账户中可用资金、已投资金额、当前拥有的股票清单等信息。这个服务的重点是管理账户，就像你管理银行或投资账户一样。
- en: 'The application already has a file generated for you, but if you were to create
    a new service yourself, you can use the CLI like you see here. The last parameter
    is the name of the service, which is used in the filename as well as the class
    name, so this would generate a service named `AccountService`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已经为你生成了一个文件，但如果你要自己创建一个新的服务，你可以像这里看到的那样使用 CLI。最后一个参数是服务的名称，它既用于文件名也用于类名，因此这将生成一个名为
    `AccountService` 的服务：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In [figure 6.3](#figure6.3) you can see the result we’re working toward. The
    header will soon display some basic account information for the user.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 6.3](#figure6.3) 中，你可以看到我们正在努力实现的结果。标题很快将显示用户的一些基本账户信息。
- en: '![c06-3.png](image_fi/293313c06/c06-3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![c06-3.png](image_fi/293313c06/c06-3.png)'
- en: '[**Figure 6.3**](#figureanchor6.3) The result of creating the Account service
    is a display of account information in the top bar.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 6.3**](#figureanchor6.3) 创建账户服务的结果是在顶部栏中显示账户信息。'
- en: Open up src/app/services/account.service.ts. We’re going to add some of the
    basic properties that are needed by replacing its contents with what you see in
    the following listing. We’ll expand this service several times throughout the
    application, but this will get us started with showing some of the basic data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/app/services/account.service.ts。我们将添加一些基本属性，通过替换其内容为以下列表中看到的内容来实现。我们将在整个应用程序中多次扩展这个服务，但这将帮助我们开始展示一些基本数据。
- en: '**Listing 6.1** Account Service Basics'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6.1** 账户服务基础'
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This service contains several properties and methods to manage an account. At
    the top we import our dependencies, which include the `Injectable` decorator and
    the `Stock` interface (which describes the typing information for a stock). The
    `defaultBalance` constant is declared, because eventually we’ll use it in several
    places and want to have one place to reference it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务包含几个属性和方法来管理账户。在顶部，我们导入我们的依赖项，包括 `Injectable` 装饰器和 `Stock` 接口（它描述了股票的类型信息）。声明了
    `defaultBalance` 常量，因为最终我们将在几个地方使用它，并希望有一个地方可以引用它。
- en: The `Injectable` decorator is used to wire the class to work with the Angular
    dependency injection system. It doesn’t take any parameters, like the `Component`
    decorator does. Any class that you want to register with DI, you’ll need to decorate
    with `Injectable`. This doesn’t immediately make the service available to use
    elsewhere in the application—we’ll get to that shortly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Injectable` 装饰器用于将类连接到 Angular 依赖注入系统。它不接收任何参数，就像 `Component` 装饰器一样。任何你想注册到
    DI 的类，你都需要用 `Injectable` 装饰器来装饰。这不会立即使服务在其他地方可用——我们很快就会看到这一点。'
- en: The rest of the class implements logic of the Account service, which includes
    having a number of private properties that can’t be manipulated directly and getter
    methods for those properties to read the values.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类的其余部分实现了账户服务的逻辑，包括拥有一些不能直接操作的私有属性和用于读取这些属性值的获取器方法。
- en: 'The service exposes two methods: one to purchase and one to sell a stock. An
    important aspect of this application is that you can only buy a single instance
    of a stock, which simplifies a few other aspects of our application. The Account
    service will retain a list of the stocks that have been purchased at what price,
    and when they’re sold it can calculate the return on that investment.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务公开了两个方法：一个用于购买股票，另一个用于销售股票。这个应用程序的一个重要方面是您只能购买单个股票实例，这简化了我们应用程序的几个其他方面。账户服务将保留已购买股票及其价格列表，当它们被出售时，可以计算该投资的回报。
- en: The last few methods are for calculating various values, such as the current
    value of all the stocks or debits and credits, and resetting the values. In JavaScript,
    adding or subtracting float numbers can sometimes cause odd results, such as 0.1+0.2=0.30000000000000004—many
    pixels have been spent on the topic if you search for it. To avoid such behaviors,
    currency values are first converted to cents, then the math is done, and then
    they’re converted back to currency.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几个方法用于计算各种值，例如所有股票的当前价值或借方和贷方，以及重置这些值。在 JavaScript 中，添加或减去浮点数有时会导致奇怪的结果，例如
    0.1+0.2=0.30000000000000004——如果您搜索这个话题，会发现很多关于这个问题的讨论。为了避免这种行为，货币值首先转换为分，然后进行数学运算，然后再转换回货币。
- en: We wanted to use this service to show data in the header, which is defined in
    the App component. We need to make it available so that the App component template
    can read the property values from the Account service. Open up the src/app/app.component.ts
    file and modify the top part of it to match what you see in the following listing.
    The rest of the file will remain the same for now.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用这个服务在页眉中显示数据，页眉是在 App 组件中定义的。我们需要使其可用，以便 App 组件模板可以从账户服务中读取属性值。打开 src/app/app.component.ts
    文件，并修改其顶部部分以匹配以下列表中的内容。现在文件的其他部分将保持不变。
- en: '**Listing 6.2** App Component Consuming the Account Service'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6.2**  App 组件消费账户服务'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the constructor method, Angular can use the type annotation of a property
    to determine what should be assigned to that property. In this example, that means
    the DI system will provide a copy of `AccountService` and store it on the `accountService`
    property. We’ll dig a bit further into how this works shortly, but first let’s
    finish up our first service.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数方法中，Angular 可以使用属性的类型注解来确定应该分配给该属性的内容。在这个例子中，这意味着依赖注入系统将提供一个 `AccountService`
    的副本，并将其存储在 `accountService` 属性上。我们稍后会进一步探讨它是如何工作的，但首先让我们完成我们的第一个服务。
- en: We use the Account service inside of the `reset` method, which will allow the
    user to click a button to start the simulation over again. In this listing, I’ve
    also skipped over a lot of code to focus on the changes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `reset` 方法中使用账户服务，这将允许用户点击按钮重新开始模拟。在这个列表中，我也跳过了很多代码，以便专注于更改。
- en: 'For the Account service to be injectable, we need to make sure it’s registered
    in the providers array. Open up src/app/app.module.ts and import the Account service:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使账户服务可注入，我们需要确保它在提供者数组中已注册。打开 src/app/app.module.ts 文件并导入账户服务：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then in the NgModule, add the `AccountService` to the `providers` array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 NgModule 中，将 `AccountService` 添加到 `providers` 数组：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the second part of wiring up a service to be consumed, as it makes the
    component (or more specifically, the injector) aware of how to inject the service.
    If you don’t add a service to the `providers` array, the DI system will never
    be aware of it and will fail to compile the service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将服务连接起来以便消费的第二部分，因为它使组件（或更具体地说，注入器）了解如何注入服务。如果您不将服务添加到 `providers` 数组中，依赖注入系统将永远不会知道它，并且无法编译该服务。
- en: We need to take a quick look at our Investments and Stocks components, so we
    can implement the purchase and sale of a stock. These both need to use the Account
    service in nearly the same way.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要快速查看我们的投资和股票组件，以便我们可以实现股票的购买和销售。这两个组件几乎需要以相同的方式使用账户服务。
- en: 'The Stocks component gets the list of all stocks through an input binding (passed
    from the App component), and has a button to buy a stock. It uses a paginated
    data grid to allow the user to look at the whole list of stocks without having
    to display them all at once. We’ll need to call the Account service’s `purchase`
    method when the Buy button is clicked. To do this, we need to open up the src/app/stocks/stocks.component.ts
    file and implement the `buy` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 股票组件通过输入绑定（从应用程序组件传递过来）获取所有股票的列表，并有一个购买股票的按钮。它使用分页数据网格，使用户能够查看所有股票的整个列表，而无需一次性显示所有股票。当点击购买按钮时，我们需要调用账户服务的
    `purchase` 方法。为此，我们需要打开 `src/app/stocks/stocks.component.ts` 文件并实现 `buy` 方法：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Investments component displays a list of the stocks the user currently owns,
    and it looks at the Account service for this information. Instead of using a binding,
    it looks at the service to determine whether the list of stocks owned has changed,
    and also calls the Account service’s `sell` method when the Sell button is clicked.
    We need to make the changes to the Investments component to support these two
    scenarios.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 投资组件显示用户目前拥有的股票列表，并查看账户服务以获取这些信息。它不是使用绑定，而是查看服务以确定拥有的股票列表是否已更改，并且在点击卖出按钮时调用账户服务的
    `sell` 方法。我们需要对投资组件进行更改以支持这两种情况。
- en: Open up src/app/investments/investments.component.ts and replace its contents
    with the code you see in the following listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/app/investments/investments.component.ts` 并将其内容替换为以下列表中看到的代码。
- en: '**Listing 6.3** Investments Component Controller'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6.3** 投资组件控制器'
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The Investments controller doesn’t accept an input binding for the list of stocks
    the user has bought, so instead it implements the `DoCheck` lifecycle hook. If
    you recall from chapter 4, this hook runs anytime the change detection runs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 投资控制器不接受用户购买的股票列表的输入绑定，因此它实现了 `DoCheck` 生命周期钩子。如果您还记得第 4 章，这个钩子会在任何更改检测运行时执行。
- en: In the `ngDoCheck` method, we first check whether the list of owned stocks has
    changed, and if so we update the internal `stocks` value. Then we check whether
    the local `cost` or `value` properties have changed on the service, and if so
    we update our internal properties. It’s a way to grab the values from the service
    and store them in the component. This allows us to maintain an internal state
    that only changes when the values change in the service, much like an input binding.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ngDoCheck` 方法中，我们首先检查拥有的股票列表是否已更改，如果是，则更新内部的 `stocks` 值。然后我们检查服务上的本地 `cost`
    或 `value` 属性是否已更改，如果是，则更新我们的内部属性。这是一种从服务中获取值并将它们存储在组件中的方法。这允许我们维护一个内部状态，只有当服务中的值发生变化时，该状态才会改变，就像输入绑定一样。
- en: We also implement the `sell` method so the button to sell a stock calls the
    Account service to sell the item. Once the item is sold, the Account service will
    update its own values, and then change detection will trigger the `ngDoCheck`
    method to run and update with the current values.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了 `sell` 方法，以便卖出股票的按钮调用账户服务来卖出项目。一旦项目卖出，账户服务将更新其自身的值，然后更改检测将触发 `ngDoCheck`
    方法运行并更新当前值。
- en: Look at the templates for these components and see how the templates directly
    bind to values stored on the service. This is entirely valid, and change detection
    will still fire when those values change.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这些组件的模板，看看模板是如何直接绑定到存储在服务上的值的。这是完全有效的，当这些值发生变化时，更改检测仍然会触发。
- en: Finally, update the src/app/app.component.html file by uncommenting the `div`
    with the class `header-nav`. This will show the top bar, which will now be populated
    with the values from the Account service.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过取消注释 `src/app/app.component.html` 文件中的具有 `header-nav` 类的 `div` 来更新文件。这将显示顶部栏，现在它将填充来自账户服务的值。
- en: Now that we’ve seen a service in action, we can spend a little more time looking
    at how the services are injected.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了一个服务的实际应用，我们可以花更多的时间来查看服务是如何被注入的。
- en: 6.3 Dependency injection and injector trees
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 依赖注入和注入树
- en: Services usually rely on Angular’s dependency injection system, which is how
    we’re able to include dependencies in our components. To get a sense of how services
    are injected into your application, we should dig a little further into how DI
    works. The basic rules aren’t complex, but they do allow you to create some interesting
    and potentially complex scenarios (on purpose or by accident).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通常依赖于 Angular 的依赖注入系统，这是我们能够在组件中包含依赖的方式。为了了解服务是如何注入到您的应用程序中的，我们应该进一步挖掘 DI
    的工作原理。基本规则并不复杂，但它们确实允许您创建一些有趣且可能复杂的场景（有意或无意）。
- en: 'You’ve seen it working in all the chapters with examples, and in the last section
    we injected the Account service into the Investments component, like you see here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在所有章节的示例中看到了它的工作情况，在最后一节中，我们将 Account 服务注入到 Investments 组件中，就像您在这里看到的那样：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Chapter 3 discussed the basics of dependency injection. *Dependency injection*
    works by having an injector (the entity that can inject a dependency when requested)
    and a provider (an entity that knows how to construct and instantiate objects).
    A module has the top-level injector for all the entities inside that module.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章讨论了依赖注入的基本原理。*依赖注入* 通过拥有一个注入器（当请求依赖项时可以注入依赖项的实体）和一个提供者（知道如何构建和实例化对象的实体）来工作。一个模块拥有该模块内部所有实体的顶级注入器。
- en: In chapter 4, we saw how components are constructed into a component tree, with
    the App component being the root that the rest of the components stem from. What
    we haven’t discussed yet is the fact that every component has an injector.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我们看到了组件是如何构建成组件树，其中 App 组件是根组件，其他组件都由此衍生。我们还没有讨论的事实是，每个组件都有一个注入器。
- en: Anytime you declare a `providers` array in the component metadata, that component
    will get its own injector. For a component that doesn’t have any providers declared,
    it will share the injector of its parent (or its parent’s parent if it doesn’t
    have one, or parent’s parent’s parent, and so on). This is similar to how events
    bubble up—the injector will look up the injector tree until it finds what was
    requested (or throws an error when it cannot find it).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在组件元数据中声明 `providers` 数组时，该组件将获得自己的注入器。对于一个没有声明任何提供者的组件，它将共享其父组件（或如果它没有父组件，则是父组件的父组件，依此类推）的注入器。这与事件冒泡的方式类似——注入器将遍历注入器树，直到找到所需的内容（或者在找不到时抛出错误）。
- en: This is the foundation of the hierarchical injection system, which is a fancy
    name for what the previous paragraph described. Injectors are created in a hierarchy
    (the injector tree that mirrors the component tree), but they also allow us to
    isolate what parts of the application can inject a particular object or even override
    how a higher-order injector works.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是分层注入系统的基础，这是一个对前一段描述的更华丽的称呼。注入器在层次结构中创建（与组件树相对应的注入器树），但它们还允许我们隔离应用程序的哪些部分可以注入特定的对象，甚至可以覆盖更高阶注入器的工作方式。
- en: In larger applications, isolation becomes more important for managing complexity
    and preventing conflicts. Imagine a large application, like an accounting program
    or an e-commerce platform. In that situation, it’s realistic for multiple teams
    to work on the same application, and it’s likely that some services will be named
    the exact same thing. If these services were all registered at the topmost level,
    they would conflict. But if they’re properly managed and registered at a lower
    level, closer to where they’re used, then conflicts could be avoided. This is
    the principle of isolation at work.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序中，隔离对于管理复杂性和防止冲突变得更加重要。想象一个大型应用程序，比如会计程序或电子商务平台。在这种情况下，多个团队在同一应用程序上工作是很现实的，而且很可能某些服务的名称完全相同。如果这些服务都在最高级别注册，它们将发生冲突。但是，如果它们得到适当的管理和在较低级别注册，更接近它们的使用位置，那么冲突就可以避免。这就是隔离原则在起作用。
- en: '![c06-4.png](image_fi/293313c06/c06-4.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![c06-4.png](image_fi/293313c06/c06-4.png)'
- en: '[**Figure 6.4**](#figureanchor6.4) Module level providers are injected from
    the module, and component level providers create individual instances at their
    level in the component tree. Highlighted blocks are where services are provided.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 6.4**](#figureanchor6.4) 模块级别的提供者从模块中注入，而组件级别的提供者在组件树中的相应级别创建单个实例。高亮块是提供服务的位置。'
- en: In [figure 6.4](#figure6.4), the left side shows that if you declare the provider
    for the Posts service at the module level, it’s available to anything inside of
    that module. When the Blogs or Forum components request the service to be injected,
    it goes up through the component injector hierarchy to the App component and then
    App module to find the provider. Both components get a reference to the same instance
    of the service, because the service was provided by the same provider.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6.4](#figure6.4)中，左侧显示如果您在模块级别声明Posts服务的提供者，它对该模块内的任何内容都是可用的。当Blogs或Forum组件请求注入服务时，它会通过组件注入器层次结构向上到App组件，然后到App模块以找到提供者。这两个组件都获取到同一实例的服务引用，因为服务是由同一个提供者提供的。
- en: On the right side, the Forums and Blogs components both provide and inject the
    Posts service themselves, so they don’t have to go up the hierarchy to find the
    service, which means they’re getting separate instances created. Even though the
    App module has the provider, it’s never reached, because the components both provided
    a service by the same name.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，Forums和Blogs组件都提供并注入了Posts服务，因此它们不需要向上到层次结构中查找服务，这意味着它们正在获取单独创建的实例。尽管App模块有提供者，但它从未被触及，因为这两个组件都提供了相同名称的服务。
- en: This means there’s not a single global registry of all of the dependencies to
    inject (unlike how NodeJS modules are a flat list of packages), but (potentially)
    numerous injectors that each maintain their own list. This grants us a level of
    flexibility not found in flat dependency lists.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着没有所有依赖项的单个全局注册表（与NodeJS模块是包的平面列表不同），而是（可能）有多个注入器，每个注入器维护自己的列表。这为我们提供了在平面依赖项列表中找不到的灵活性。
- en: 'We’re also able to remap a provider at one node in the tree. Like our Posts
    service example earlier, imagine that the Forums component wanted to inject a
    different version of the service (perhaps due to refactoring or needing to pass
    in a value that isn’t a service). Using this syntax, we can provide a different
    class that will be injected as the same name:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能够在一个树节点处重映射提供者。像我们之前提到的Posts服务示例一样，想象一下Forums组件想要注入服务的不同版本（可能是由于重构或需要传递一个不是服务的值）。使用这种语法，我们可以提供不同的类，该类将以相同的名称注入：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are several different ways to override a provider, depending on exactly
    how you need to modify the provider. Table 6.1 has a list of the providers and
    basic examples with the different capabilities they enable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您需要修改提供者的具体方式，有几种不同的方法可以覆盖提供者。表6.1列出了提供者及其它们所启用的基本示例和不同能力。
- en: '**Table 6.1** Ways to override a provider with a secondary value or implementation'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6.1** 使用次要值或实现覆盖提供者的方法'
- en: '| **Provider type** | **Purpose** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **提供者类型** | **用途** |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alias | You can have the injector remap one service to another. This might
    be useful if you can’t modify a component directly but need to change the service.
    It doesn’t create a new instance of the service. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 别名 | 您可以让注入器将一个服务重映射到另一个服务。如果您不能直接修改组件但需要更改服务，这可能很有用。它不会创建服务的新实例。 |'
- en: '|  | `providers: [{provide: PostsService, useExisting: PostsServiceV2}]` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  | `providers: [{provide: PostsService, useExisting: PostsServiceV2}]` |'
- en: '| Class | The injector can inject a new instance of a different service in
    place of an existing service. This is useful if you want to replace an existing
    service with a new instance. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 注入器可以在现有服务的地方注入不同服务的新实例。如果您想用新实例替换现有服务，这很有用。 |'
- en: '|  | `providers: [{provide: PostsService, useClass: PostsServiceV2}]` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  | `providers: [{provide: PostsService, useClass: PostsServiceV2}]` |'
- en: '| Factory | In some cases, you’ll need to use a Factory pattern to construct
    the instance of a service yourself, typically because a configuration type value
    is needed during construction that isn’t known ahead of time. You would need to
    create a factory function that returns a new instance of the service and that’s
    used by the injector. You’ll have to declare any dependencies of that service
    that need to be injected. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 工厂 | 在某些情况下，您可能需要使用工厂模式自己构建服务的实例，通常是因为在构建过程中需要配置类型值，而这个值在事先是未知的。您需要创建一个工厂函数，该函数返回服务的新实例，并由注入器使用。您必须声明该服务需要注入的任何依赖项。
    |'
- en: '|  | `providers: [{provide: PostsService, useFactory: PostsServiceFactory,
    deps: [HttpClient]}]` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  | `providers: [{provide: PostsService, useFactory: PostsServiceFactory,
    deps: [HttpClient]}]` |'
- en: '| Value | A value can be injected in place of a service, meaning you don’t
    need to create a full class. For example, a static value is already injected,
    such as a configuration object, and you want to override it at runtime. You can
    also replace a service with a simple object definition, which is particularly
    useful for mocking during testing. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 一个值可以用来替代服务，这意味着你不需要创建一个完整的类。例如，一个静态值已经注入，比如配置对象，而你希望在运行时覆盖它。你也可以用一个简单的对象定义来替换服务，这在测试期间的模拟特别有用。|'
- en: '|  | `providers: [{provide: PostsService, useValue: PostsServiceV2}]` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  | `providers: [{provide: PostsService, useValue: PostsServiceV2}]` |'
- en: 'There’s one more nuance to be aware of: When you register a provider, the name
    of the object is captured as a token and used to look up the value later. While
    you’re passing a reference to the service itself in the `providers` array, internally
    DI takes the name of the service as the token to look up that service.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的细微差别：当你注册提供者时，对象的名称被捕获为一个令牌，并在以后查找值时使用。虽然你在`providers`数组中传递服务本身的引用，但内部DI使用服务的名称作为令牌来查找该服务。
- en: When we inject a service and give it a type value, internally DI looks for a
    service based on the name of that type and returns the corresponding value. In
    cases where we override the default provider value, DI understands to return the
    overridden value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们注入一个服务并给它一个类型值时，内部依赖注入（DI）会根据该类型的名称查找服务，并返回相应的值。在我们覆盖默认提供者值的情况下，DI会理解返回覆盖的值。
- en: 'Why do we want to use DI instead of regular module loading in JavaScript? There
    are a few key reasons you’ll usually want to make your services injectable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们想在JavaScript中使用依赖注入而不是常规模块加载？通常有几个关键原因会让你想要让你的服务可注入：
- en: It allows you to focus on consuming services and not worry about how to create
    them.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许你专注于消费服务，而不必担心如何创建它们。
- en: It resolves external dependencies for you, simplifying consumption.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为你解决了外部依赖，简化了消费。
- en: It’s easier to test your Angular entities because you can always inject a mock
    service instead of the real thing.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的Angular实体更容易，因为你总是可以注入一个模拟服务而不是真实的服务。
- en: It can allow you to control the injection of a service without having to worry
    about where another piece of the application might also inject the service.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以让你在不担心应用程序的其他部分可能在何处也注入服务的情况下控制服务的注入。
- en: It gives you a clean instance of the service for each injector tree.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为每个注入树提供了一个干净的服务实例。
- en: 'DI is powerful and is vital for our applications to be easy to manage, but
    keeping up with the nuances can be a little challenging if you try to combine
    these capabilities all of the time. Here are a few tips to keep in mind when it
    comes to DI and services:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）功能强大，对于我们的应用程序易于管理至关重要，但如果你总是尝试结合这些功能，跟上这些细微差别可能会有些挑战。以下是一些关于DI和服务的注意事项：
- en: '*Inject at the lowest level —*Instead of adding everything to the App module
    `providers` array, try to add it to the lowest component `providers` array. This
    will minimize the “surface area” of your service to only be available to the components
    that might use it.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在最低级别注入*— 不要将所有内容都添加到App模块的`providers`数组中，尝试将其添加到最低组件的`providers`数组中。这将最小化服务的“表面面积”，使其仅对可能使用它的组件可用。'
- en: '*Name your services wisely —*Give your services semantic and meaningful names.
    PostsService might be clear enough, or perhaps BlogPostsService, depending on
    the context. I find it’s easier to type a few more characters than it is to guess
    what a service named BPService might be, especially when multiple people are working
    on your application.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*明智地为服务命名*— 给你的服务起有语义和有意义的名字。PostsService可能已经足够清晰，或者根据上下文可能是BlogPostsService。我发现，与猜测一个名为BPService的服务可能是什么相比，多打几个字符更容易，尤其是在多个人在开发你的应用程序时。'
- en: '*Keep services focused —*Rather than creating one mega service that you inject
    everywhere with lots of abilities, make a sensible number of services that do
    specific tasks. The longer your service is, the harder it is to maintain and test,
    and it will likely become tangled in your application.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保持服务专注*— 不要创建一个包含大量能力并注入到各个地方的大服务，而是创建一个合理数量的服务，执行特定的任务。你的服务越长，维护和测试就越困难，它很可能会在你的应用程序中变得混乱。'
- en: '*Keep services meaningful —*On the flip side of keeping services focused, you’ll
    need to balance the utility of adding another service. Do you need a service for
    something that’s used only once? It may add more complexity for little benefit,
    so strike the right balance between number of services and their roles.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保持服务有意义*—*在保持服务专注的同时，你还需要平衡添加另一个服务的实用性。你是否需要一个只使用一次的服务？这可能会增加很少的好处而带来更多的复杂性，所以要在服务数量和它们的作用之间找到合适的平衡。'
- en: '*Use consistent patterns —*Follow the same design for your services for consistency.
    For example, if you have several services that handle making REST API calls, you’d
    likely want to give them the same kinds of methods, like `get`to load an object,
    or `save` to store a record.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用一致的模式*—*为了保持一致性，为你的服务遵循相同的设计。例如，如果你有多个处理 REST API 调用的服务，你可能会希望给它们提供相同类型的操作，比如
    `get` 来加载一个对象，或者 `save` 来存储一条记录。'
- en: That wraps up most of what you’ll want to know about DI in Angular. The many
    ways it can be used make it flexible and powerful. But you can also bypass DI
    for some scenarios where it’s not required or available, as we’ll discover next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就总结了你可能想要了解的 Angular 中关于依赖注入的大部分内容。它可以用多种方式使用，这使得它既灵活又强大。但也可以在某些不需要或不可用依赖注入的场景中绕过它，正如我们接下来将要发现的那样。
- en: 6.4 Services without dependency injection
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 无依赖注入的服务
- en: Now that you’ve seen how to use services and dependency injection together,
    let’s look at services that bypass DI. There are some situations where you may
    not need to use dependency injection, or you may need to have a service that can
    be used before Angular is fully ready. For example, you may want to create a service
    that can be used to set configuration before Angular starts or you may want to
    create a helper service for generic actions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何结合使用服务和依赖注入，让我们来看看绕过依赖注入的服务。在某些情况下，你可能不需要使用依赖注入，或者你可能需要一个在 Angular
    完全准备好之前就可以使用的服务。例如，你可能想创建一个在 Angular 开始之前可以用来设置配置的服务，或者你可能想创建一个用于通用操作的辅助服务。
- en: 'This approach is using JavaScript modules for exporting and importing values
    across files. This is no different than how you’d use JavaScript modules in any
    project. In short, most of the time you’ll make your services injectable. There
    is very little reason not to, except when your service is used outside of Angular’s
    application lifecycle. Think of it like this: If Angular hasn’t started to render
    the application yet, there’s no way for Angular to inject a service for you to
    consume.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用 JavaScript 模块在文件之间导出和导入值。这与你在任何项目中使用 JavaScript 模块的方式没有区别。简而言之，大多数时候，你会使你的服务可注入。没有太多理由不这样做，除非你的服务在
    Angular 的应用程序生命周期之外使用。可以这样想：如果 Angular 尚未开始渲染应用程序，那么 Angular 就无法为你注入一个服务来使用。
- en: We’re going to build a class with static methods for getting and setting configuration
    values to be used throughout the application. We won’t make this an injectable
    service, because we want to use it before the application is bootstrapped—we want
    to set the configuration values before Angular starts rendering, so there’s no
    chance of a configuration value not being set when Angular needs it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个具有静态方法的类，用于获取和设置配置值，以便在整个应用程序中使用。我们不会将其制作成一个可注入的服务，因为我们想在应用程序启动之前使用它——我们想在
    Angular 开始渲染之前设置配置值，这样在 Angular 需要时就不会有配置值未设置的情况发生。
- en: Start by opening up the src/app/services/config.service.ts file and use the
    code from the following listing to replace its contents. This is a basic static
    class to maintain configuration, though we only have one property in this example.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 src/app/services/config.service.ts 文件，并使用以下列表中的代码替换其内容。这是一个基本的静态类，用于维护配置，尽管在这个例子中我们只有一个属性。
- en: '**Listing 6.4** Config service without using DI'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6.4** 不使用依赖注入的配置服务'
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this service, there’s a single property for storing the URL to the API and
    two static methods for getting and setting that property. We could add more properties
    as needed, but for this application it’s the only configuration we’ll use. There
    are many ways you could have written this service, but the key here is that it’s
    a plain JavaScript class and doesn’t use DI.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个服务中，有一个属性用于存储 API 的 URL，以及两个静态方法用于获取和设置该属性。根据需要，我们可以添加更多属性，但在这个应用程序中，我们只使用这种配置。你可以用很多种方式编写这个服务，但关键在于它是一个普通的
    JavaScript 类，并且不使用依赖注入。
- en: Now let’s use this to set the value in the src/main.ts file before the application
    is bootstrapped. Open up the file and add the two lines in bold in the following
    listing after the current imports.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在应用程序引导之前在 src/main.ts 文件中设置这个值。打开文件，并在当前导入之后添加以下列表中的粗体两行。
- en: '**Listing 6.5** Main file'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6.5** 主文件'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you recall, the main.ts file is our entry point for the application. This
    is the first code to be executed when the application starts, so this will set
    the API URL immediately. That allows us to use the Config service anytime in the
    application to get this value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，main.ts 文件是应用程序的入口点。这是应用程序启动时首先执行的代码，因此这将立即设置 API URL。这允许我们在应用程序中的任何时候使用
    Config 服务来获取这个值。
- en: You could certainly use DI and make a service that handles configuration that
    way, but this is an alternative you may consider if you need configuration set
    as early as possible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以使用 DI 来创建一个处理配置的服务，但如果你需要尽早设置配置，这是一个你可能考虑的替代方案。
- en: Now we’ll use this Config service in another service that will manage loading
    the stock data, and we’ll dig into the HttpClient service that Angular provides.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这个 Config 服务在另一个服务中，该服务将管理加载股票数据，我们将深入研究 Angular 提供的 HttpClient 服务。
- en: 6.5 Using the HttpClient service
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 使用 HttpClient 服务
- en: Angular comes with its own HttpClient service that helps with requesting data
    from an API. We saw the Http service in action in the chapter 2 example application,
    but we need to give it a little more attention. In addition, we’ll use the Config
    and Account services we created to enable most of the rest of the application
    to start working.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 自带 HttpClient 服务，可以帮助从 API 请求数据。我们在第 2 章示例应用程序中看到了 Http 服务的作用，但我们需要给它更多的关注。此外，我们将使用我们创建的
    Config 和 Account 服务来使应用程序的大部分其他部分开始工作。
- en: HttpClient is part of its own module, so you have to make sure it’s included
    in your project. It’s part of the @angular/common package, which you’ve probably
    installed, but if not, use npm to install it. If you’re using your own tooling
    and module loader, like SystemJS, you’ll have to ensure it’s aware of this module.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: HttpClient 是它自己的模块的一部分，所以你必须确保它在你的项目中。它是 @angular/common 包的一部分，你可能已经安装了，如果没有，请使用
    npm 安装它。如果你使用自己的工具和模块加载器，如 SystemJS，你必须确保它知道这个模块。
- en: It’s considered best practice to never use HttpClient in the component controller
    directly (yet many articles and even the documentation may demonstrate this case),
    because this helps create a separation of concerns. That’s why we’ll create a
    new service that will use the HttpClient service and abstract some of the logic
    from the controller.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是最佳实践的是永远不要在组件控制器中直接使用 HttpClient（尽管许多文章甚至文档可能展示了这种情况），因为这有助于创建关注点的分离。这就是为什么我们将创建一个新的服务，该服务将使用
    HttpClient 服务并从控制器中抽象一些逻辑。
- en: The HttpClient service uses observables for handling aspects of the response.
    Because it returns an observable, you could also use RxJS to convert it to a promise
    (not covered here, but found in RxJS documentation), though I generally discourage
    that unless there’s a strong reason.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: HttpClient 服务使用可观察对象来处理响应的各个方面。因为它返回一个可观察对象，你也可以使用 RxJS 来将其转换为承诺（这里没有涵盖，但在 RxJS
    文档中可以找到），尽管我通常不鼓励这样做，除非有充分的理由。
- en: By the end of this section, the application will look like [figure 6.5](#figure6.5),
    where data gets loaded, and the data will finally fill in the cards. It will display
    the list of stocks in the data grid and in the price ticker.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，应用程序将看起来像[图 6.5](#figure6.5)，其中数据被加载，数据最终将填充到卡片中。它将在数据网格和价格指示器中显示股票列表。
- en: '![c06-5.png](image_fi/293313c06/c06-5.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![c06-5.png](image_fi/293313c06/c06-5.png)'
- en: '[**Figure 6.5**](#figureanchor6.5) Data loaded into the application using the
    Stocks service with the HttpClient'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 6.5**](#figureanchor6.5) 使用 HttpClient 和股票服务加载到应用程序中的数据'
- en: To get started, open up src/app/services/stocks.service.ts and replace the contents
    with what you see in the following listing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，打开 src/app/services/stocks.service.ts 并将其内容替换为以下列表中的内容。
- en: '**Listing 6.6** Stocks service wrapping the use of the HttpClient service'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6.6** 包装 HttpClient 服务使用的股票服务'
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The Stocks service serves one primary function: to facilitate the loading of
    data. We keep the focus on this by having one method that uses the HttpClient
    service to request data and return a subscription for the result. It starts by
    importing dependencies, as you should expect by now, and that includes the Config
    service we created earlier and the HttpClient service from the @angular/common/http
    package. Then the `StockService` class is decorated with `Injectable`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Stocks 服务主要提供一项功能：便于加载数据。我们通过一个使用 HttpClient 服务请求数据并返回结果订阅的方法来保持对此的关注。它首先导入依赖项，正如你现在所期望的，这包括我们之前创建的
    Config 服务和来自 @angular/common/http 包的 HttpClient 服务。然后 `StockService` 类被装饰为 `Injectable`。
- en: The constructor injects the HttpClient service into the class, but notice we
    don’t do the same for Config because it isn’t an injectable service, remember—it’s
    only an object with static methods, so we can call it directly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将 HttpClient 服务注入到类中，但请注意我们并没有对 Config 做同样的事情，因为它不是一个可注入的服务，记住——它只是一个具有静态方法的对象，因此我们可以直接调用它。
- en: Now the important part of the service is the `getStocks` method. When it’s called,
    it will return an observable for the response that the HttpClient will create
    so we can elsewhere use `subscribe` to get the response data. The HttpClient has
    methods for other HTTP verbs, like `post`, `put`, and `delete`. You can read more
    about these in the documentation at [https://angular.io/guide/http](https://angular.io/guide/http).
    There’s no error handling here because that will need to be handled at the call
    site of this method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务的重要部分是 `getStocks` 方法。当它被调用时，它将返回 HttpClient 将创建的响应的可观察对象，这样我们就可以在其他地方使用
    `subscribe` 来获取响应数据。HttpClient 有其他 HTTP 动词的方法，如 `post`、`put` 和 `delete`。你可以在[https://angular.io/guide/http](https://angular.io/guide/http)的文档中了解更多信息。这里没有错误处理，因为那需要在方法的调用位置进行处理。
- en: In some ways, this simple service abstracts away the use of HttpClient from
    our components, because we shouldn’t have to care where the data is coming from.
    Controllers should ask for data and receive it from a service instead of having
    to construct the URL and make HTTP requests directly. This is considered a best
    practice in most programming paradigms.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，这个简单的服务抽象掉了 HttpClient 在我们的组件中的使用，因为我们不应该关心数据是从哪里来的。控制器应该请求数据并从服务中接收数据，而不是必须构造
    URL 并直接进行 HTTP 请求。这在大多数编程范式中被认为是最佳实践。
- en: When put all together, we’ll use the `getStocks` method to set up our HTTP request
    and then subscribe to it to trigger the request and handle the response. Note
    that calling `getStocks` won’t fire the HTTP request—only when we subscribe to
    it will it fire. Open up the src/app/app.component.ts file and replace it with
    the code from the following listing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些放在一起时，我们将使用 `getStocks` 方法来设置我们的 HTTP 请求，然后订阅它以触发请求并处理响应。请注意，调用 `getStocks`
    不会触发 HTTP 请求——只有当我们订阅它时，它才会触发。打开 src/app/app.component.ts 文件，并用以下列表中的代码替换它。
- en: '**Listing 6.7** App component controller to use Stocks service'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6.7**  App 组件控制器以使用 Stocks 服务'
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Before we can use the service, it has to be imported and added to the `providers`
    array. Then it gets injected into the component as an argument for the constructor.
    This is the same thing we did for the Account service, except here we’re doing
    it in the component itself. This means only the App component and any child components
    will have access to this service, instead of the entire module.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用服务之前，必须将其导入并添加到 `providers` 数组中。然后它作为构造函数的参数注入到组件中。这与我们为 Account 服务所做的是同一件事，只是在这里我们是在组件本身中做的。这意味着只有
    App 组件及其任何子组件才能访问此服务，而不是整个模块。
- en: When the App component initializes, it will call the `ngOnInit` method to load
    the data once and then set an interval to reload every 15 seconds. Note that it
    will also check whether the `refresh` property is true before reloading, because
    we’ll have a toggle to optionally disable refreshing data. When the component
    is destroyed, we use `ngOnDestroy` to clear the interval to prevent memory leaks.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当 App 组件初始化时，它将调用 `ngOnInit` 方法一次性加载数据，然后设置一个间隔每 15 秒重新加载。请注意，在重新加载之前，它还会检查
    `refresh` 属性是否为 true，因为我们会有一个切换来可选地禁用数据刷新。当组件被销毁时，我们使用 `ngOnDestroy` 来清除间隔以防止内存泄漏。
- en: The `load` method is a private method that uses the Stocks service in order
    to load the data. We call `getStocks().subscribe()` to construct the HTTP request
    and fire it. When the response is received, we store the result on the `stocks`
    property. We also have an error handler to log in to the console if there was
    an error.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`方法是一个私有方法，它使用Stocks服务来加载数据。我们调用`getStocks().subscribe()`来构造HTTP请求并触发它。当收到响应时，我们将结果存储在`stocks`属性上。我们还有一个错误处理器，如果发生错误，它会将错误记录到控制台。'
- en: 'The last step we’ll take is to uncomment everything else inside of the src/app/app.component.html
    file, except for the first line that has the alert component. Doing this will
    make all the components now appear in our application, filled in with data! You’ll
    notice that the App component binds the data into the different components, as
    in the following sample code. Anytime the data is reloaded, the binding will update,
    and the components will refresh their copy of data and display:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要进行的最后一步是取消src/app/app.component.html文件中除第一行包含alert组件之外的所有内容的注释。这样做将使所有组件现在都出现在我们的应用程序中，并填充了数据！你会注意到App组件将数据绑定到不同的组件中，如下面的示例代码所示。每次数据重新加载时，绑定都会更新，组件将刷新其数据副本并显示：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Because we created a service to handle the complexities of building the HTTP
    request to load data, we kept our controller much more focused. The component
    doesn’t have to know how data was returned—it could be hard coded or loaded dynamically—it
    only knows how to ask the service for data. You’ll want to follow this pattern
    anytime you have data access. The component does need to understand how to handle
    the response from the service, and in this case the component only needs to understand
    that it’s given back an observable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们创建了一个服务来处理构建HTTP请求以加载数据的复杂性，我们使控制器保持得更加专注。组件不需要知道数据是如何返回的——它可能是硬编码的或动态加载的——它只知道如何请求服务中的数据。当你有数据访问时，你想要遵循这个模式。组件确实需要理解如何处理来自服务的响应，在这种情况下，组件只需要理解它得到了一个可观察对象。
- en: You’ll likely create several services like this in your applications, and over
    time you’ll probably come up with specific patterns that you prefer to reuse.
    I’ve found it useful to create a base HttpClient service and extend that to create
    specific services for various API endpoints. The design you choose for your services
    can depend greatly on the API design.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在你的应用程序中创建几个这样的服务，随着时间的推移，你可能会想出你喜欢的特定模式来重复使用。我发现创建一个基本的HttpClient服务并将其扩展以创建针对各种API端点的特定服务是有用的。你为服务选择的设计可以极大地取决于API设计。
- en: Although HttpClient is the most common service to use to load data, your application
    can still use other protocols like Websockets, push notifications, or other APIs
    such as audio recording. Services can be designed to abstract the complexities
    of each data source and allow your components to remain focused.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HttpClient是加载数据最常用的服务，但你的应用程序仍然可以使用其他协议，如Websockets、推送通知或其他API，例如音频录制。服务可以被设计为抽象每个数据源的复杂性，并允许组件保持专注。
- en: Now let’s look at how we can intercept requests and responses to handle scenarios
    where we want to do additional work, such as adding common headers or even targeting
    a specific type of response. We can easily transform both requests and responses
    from a common point, and that’s powerful.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何可以拦截请求和响应来处理我们想要执行额外工作的情况，比如添加常见的头信息或针对特定类型的响应。我们可以轻松地从共同点转换请求和响应，这是强大的。
- en: 6.5.1 HttpInterceptor
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 HttpInterceptor
- en: Often you’ll want to intercept HTTP requests or responses before they’re handled
    elsewhere in the application. For example, you may want to add an authorization
    header to all outgoing requests to a particular domain or you may want to capture
    any error responses and log them. The HttpClient provides a nice way to intercept
    requests and responses for these types of purposes by making a service that implements
    the `HttpInterceptor` interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在它们在其他地方处理之前拦截HTTP请求或响应。例如，你可能想要向特定域的所有出站请求添加一个授权头，或者你可能想要捕获任何错误响应并将它们记录下来。HttpClient通过创建一个实现`HttpInterceptor`接口的服务，提供了一个很好的方式来拦截请求和响应，用于这些类型的目的。
- en: In our case, we’d like to add a bit of logic when the Stocks API data is returned
    so that we can update our account balance. When we buy some stocks, the current
    value of the stocks and our portfolio are tracked in the Account service. When
    we get the latest data from the API, we want to also update the Account service
    state to reflect the most recent pricing (and hopefully we’ve made money and not
    lost it).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，当股票API数据返回时，我们希望在其中添加一些逻辑，以便我们可以更新我们的账户余额。当我们购买一些股票时，股票的当前价值和我们的投资组合会在账户服务中进行跟踪。当我们从API获取最新数据时，我们希望也更新账户服务的状态，以反映最新的定价（并且我们希望我们赚了钱而不是亏了钱）。
- en: 'An `HttpInterceptor` is crafted like most Angular services, but it must have
    a method by the name of `intercept`. You’ll always intercept the request and then
    optionally follow it through to also intercept the response. To see this in action,
    let’s make an interceptor that will intercept any requests for the stock data
    and update the Account service with the latest prices. Generate a new service
    using the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpInterceptor` 的构建方式与大多数Angular服务类似，但它必须有一个名为 `intercept` 的方法。你将始终拦截请求，然后可选地跟随它以拦截响应。为了看到这个动作，让我们创建一个拦截器，它将拦截对股票数据的任何请求，并使用最新价格更新账户服务。使用以下命令生成一个新的服务：'
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open up the new file at src/services/interceptor.service.ts and replace its
    contents with the values from the following listing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 src/services/interceptor.service.ts 的新文件，并用以下列表中的值替换其内容。
- en: '**Listing 6.8** HTTPInterceptor'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 6.8** HTTPInterceptor'
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There’s a bit of setup required, and we can take this slowly. After we import
    dependencies, we declare a service with `Injectable` and have it implement the
    `HttpInterceptor` interface. This interface checks whether we have the `intercept`
    method on our class and throws a compile error if not. We also need access to
    the Account service, so we inject it in the constructor.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些设置，我们可以慢慢来。在我们导入依赖项之后，我们使用 `Injectable` 声明一个服务，并使其实现 `HttpInterceptor` 接口。此接口检查我们的类上是否有
    `intercept` 方法，如果没有，则抛出编译错误。我们还需要访问账户服务，因此我们在构造函数中注入它。
- en: The `intercept` method is what will be called for any HTTP request, and you’re
    given two parameters. The first is the `HttpRequest` object, which has data about
    what URL is being called, the payload, any headers, and so forth. The second parameter
    is the `HttpHandler object, which is how we’ll tell Angular that we’re done modifying
    the request. If we don’t, the request will fail.`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`intercept` 方法将在任何HTTP请求中被调用，并且你将获得两个参数。第一个是 `HttpRequest` 对象，它包含有关被调用URL、有效载荷、任何头信息等的数据。第二个参数是
    `HttpHandler` 对象，这是我们告诉Angular我们已经完成请求修改的方式。如果我们不这样做，请求将失败。'
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
