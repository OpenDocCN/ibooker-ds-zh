- en: Chapter 1\. Introduction to Entity Resolution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 介绍实体解析
- en: All around the world vast quantities of data are being collected and stored,
    and more data is being added every day. This data records the world we live in
    and the changing attributes and characteristics of the people, places, and things
    around us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在全球范围内，大量的数据正在被收集和存储，每天都在增加。这些数据记录了我们生活的世界，以及我们周围的人、地点和事物的变化属性和特征。
- en: Within this global ecosystem of data processing, organizations independently
    collect overlapping sets of information about the same real-world entity. And
    each organization has its own approach to organizing and cataloging the data it
    holds.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个全球数据处理的生态系统中，组织独立地收集关于同一现实世界实体的重叠信息集。每个组织都有自己的方法来组织和编目其持有的数据。
- en: Companies and institutions seek to derive valuable insights from this raw data.
    Advanced analytical techniques have been developed to discern patterns in the
    data, extract meaning, and even attempt to predict the future. The performance
    of these algorithms depends on the quality and richness of the data fed into them.
    By combining data from more than one organization, often a richer, more complete
    dataset can be created, from which more valuable conclusions can be drawn.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 公司和机构希望从这些原始数据中获取有价值的洞见。已经开发了先进的分析技术来识别数据中的模式，提取含义，甚至尝试预测未来。这些算法的性能取决于输入的数据质量和丰富程度。通过结合来自多个组织的数据，通常可以创建更丰富、更完整的数据集，从中可以得出更有价值的结论。
- en: This book will guide you through how to join these heterogeneous datasets to
    create richer sets of data about the world in which we live. This process of joining
    datasets is known by a variety of names including name matching, fuzzy matching,
    record linking, entity reconciliation, and entity resolution. In this book we
    will use the term *entity resolution* to describe the overall process of resolving,
    that is, joining, data together that refers to real-world entities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将指导您如何合并这些异构数据集，创建关于我们生活世界的更丰富的数据集。这个合并数据集的过程被称为各种名字，包括名称匹配、模糊匹配、记录链接、实体协调和实体解析。在本书中，我们将使用术语*实体解析*来描述解析即连接数据的整体过程，这些数据涉及到现实世界中的实体。
- en: What Is Entity Resolution?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是实体解析？
- en: Entity resolution is a key analytic technique to identify data records that
    refer to the same real-world entity. This matching process enables the removal
    of duplicate entries within a single source and the joining of disparate data
    sources when common unique identifiers are not available.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实体解析是一种关键的分析技术，用于识别指向同一现实世界实体的数据记录。这种匹配过程使得可以在单个来源内去重条目，并在没有公共唯一标识符的情况下连接不同的数据源。
- en: Entity resolution enables enterprises to build rich and comprehensive data assets,
    to reveal relationships, and to construct networks for marketing and risk management
    purposes. It is often a key prerequisite to harness the full potential of machine
    learning and AI.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实体解析使企业能够构建丰富和全面的数据资产，揭示关系，并为营销和风险管理目的构建网络。这往往是充分利用机器学习和人工智能潜力的关键前提。
- en: For example, healthcare providers often need to join records from across different
    practices or historical archives held on different platforms. In financial services,
    customer databases need to be reconciled to offer the most relevant products and
    services or to enable fraud detection. To enhance resilience or provide transparency
    on environmental and social issues, corporations need to join supply chain records
    with sources of risk intelligence.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在医疗服务领域，经常需要从不同的实践或历史档案中联合记录。在金融服务中，需要调和客户数据库，以提供最相关的产品和服务或启用欺诈检测。为了增强抗灾能力或提供环境和社会问题的透明度，公司需要将供应链记录与风险情报来源进行联接。
- en: Why Is Entity Resolution Needed?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要实体解析？
- en: In everyday life as individuals, we are assigned a lot of numbers—according
    to my healthcare provider, I am identified by one number, another by my employer,
    another by my national government, and so on. When I sign up for services, I’m
    often assigned a number (or more than one sometimes) by my bank, chosen retailer,
    or online provider. Why all these numbers? Back in a simpler time, when services
    were delivered in a local community, customers were known personally and interactions
    were conducted face to face, it was obvious who you were dealing with. Exchanges
    were often discrete transactions with no need to refer to any prior business and
    no need to keep records associated with individual customers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常生活中，作为个体，我们被分配了很多编号——根据我的医疗服务提供者，我通过一个编号进行识别，通过我的雇主又通过另一个编号，再通过我的国家政府，等等。当我注册服务时，通常我的银行、选择的零售商或在线服务提供商会为我分配一个（有时是多个）编号。为什么会有这么多编号？在更简单的时代，当服务是在本地社区提供时，客户是以个人身份认识的，互动是面对面进行的，很明显你知道你在处理谁。交流通常是离散的交易，没有必要参考任何先前的业务，也不需要保留与个别客户关联的记录。
- en: 'As more and more services began to be provided remotely and offered on a wider
    regional or even national basis, a means of identifying who was who became necessary.
    Names were clearly insufficiently unique, so names were often combined with location
    to create a composite identifier: Mrs. Jones became Mrs. Jones from Bromley as
    opposed to Mrs. Jones from Harrow. As records migrated from paper to electronic
    form, the assignment of a unique machine-readable number began the era of numeric,
    and alphanumeric, identifiers that surround us today.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的服务开始远程提供，并在更广泛的区域甚至国家范围内提供，有必要找到一种识别谁是谁的方法。名字显然不够唯一，因此通常将名字与位置结合起来创建一个复合标识符：琼斯夫人变成了来自布罗姆利的琼斯夫人，而不是来自哈罗的琼斯夫人。随着记录从纸质形式迁移到电子形式，分配一个唯一的机器可读编号开始了今天围绕我们的数字和字母数字混合标识符的时代。
- en: Within the confines of their own domain these identifiers usually work well.
    I identify myself with my unique number and it’s clear that I’m the same returning
    individual. This identifier allows a common context to be quickly established
    between two parties and reduces the possibility of misunderstanding. These identifiers
    typically have nothing in common, vary in length and format, and are assigned
    according to different schemes. There is no mechanism to translate between them
    or to identify that individually and collectively they refer to me and not another
    individual.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们各自领域的限制内，这些标识符通常运作良好。我用我的唯一编号来识别自己，很明显我是同一个回头客。这种标识符允许快速建立两方之间的共同语境，并减少误解的可能性。这些标识符通常没有共同之处，在长度和格式上有所不同，并根据不同的方案分配。没有机制可以在它们之间进行转换，或者识别它们单独和集体地指代的是我，而不是另一个个体。
- en: However, when business is depersonalized, and I don’t know the person I’m dealing
    with and they don’t know me, what happens if I register for the same service more
    than once? Perhaps I’ve forgotten to identify with my unique number or a new application
    is being submitted on my behalf. A second number will be created that also identifies
    me. This duplication makes it more difficult for the service provider to offer
    a personalized service as they must now join together two different records to
    understand fully who I am and what my needs might be.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当业务被去人化时，我不认识我正在交易的人，他们也不认识我，如果我多次注册相同的服务会发生什么？也许我忘记了用我的唯一编号进行标识，或者有人代表我提交了新的申请。将创建第二个也能标识我身份的编号。这种重复使得服务提供者更难以提供个性化服务，因为他们现在必须合并两个不同的记录才能充分了解我是谁以及我的需求是什么。
- en: Within larger organizations, the problem of matching up customer records becomes
    even more challenging. Different functions or business lines may maintain their
    own records that are specifically tailored to their purpose but were designed
    independently of each other.  A common problem is how to construct a comprehensive
    (or 360 degree) view of a customer. Customers may have interacted with different
    parts of an organization over many years. They may have done so in different contexts—as
    an individual, as part of a joint household, or perhaps in an official capacity
    associated with a company or other legal entity. In the course of these different
    interactions, the same person may have been assigned a multiplicity of identifiers
    in various systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的组织中，匹配客户记录的问题变得更加具有挑战性。不同的功能或业务线可能会维护适合其目的的记录，但这些记录是独立设计的。 一个常见的问题是如何构建客户的综合（或360度）视图。客户可能在多年来与组织的不同部分进行了交互。他们可能在不同的上下文中进行交互——作为个人，作为联合家庭的一部分，或者可能是与公司或其他法律实体相关联的官方能力。在这些不同的交互过程中，同一个人可能在各种系统中被分配了多个标识符。
- en: This situation commonly arises due to (often historic) mergers and acquisitions,
    where overlapping sets of customers are to be amalgamated and treated consistently
    as a single population. How do we match up a customer from one domain with one
    from another?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况通常是由于（经常是历史性的）合并和收购而引起的，其中要将重叠的客户集合合并并一致地对待为一个整体人口。我们如何将一个领域的客户与另一个领域的客户进行匹配？
- en: This challenge of joining records also occurs when bringing together datasets
    supplied by different organizations. Because there is typically no universally
    adopted standard or common key between enterprises, especially with respect to
    individuals, the joining of their data is a commonly overlooked and nontrivial
    exercise.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当将由不同组织提供的数据集合并在一起时，也会出现记录合并的挑战。由于通常不存在广泛采用的标准或个体之间的公共键，特别是与个人相关的键，因此合并它们的数据通常被忽视并且不是一项微不足道的任务。
- en: Main Challenges of Entity Resolution
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体解析的主要挑战
- en: If our assigned unique identifiers are all different and don’t match up, how
    can we identify that two records refer to the same entity? Our best approach is
    to compare individual attributes of those entities, such as their name, and if
    they share enough similarities, make our best judgment that they are a match.
    This sounds simple enough, right? Let’s delve into some of the reasons why that
    isn’t as straightforward as it sounds.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分配的唯一标识符都不同且无法匹配，我们如何确定两个记录指的是同一个实体？我们最好的方法是比较这些实体的各个属性，例如他们的名称，如果它们有足够多的相似之处，就做出我们最好的判断，即它们是匹配的。这听起来足够简单，对吧？让我们深入了解一些为什么这并不像听起来那么简单的原因。
- en: Lack of Unique Names
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称的缺乏唯一性
- en: First, there is the challenge of recognizing uniqueness between names or labels.
    The repeated assignment of the same name to different real-world entities presents
    an obvious challenge in differentiating who is who. Perhaps you searched the internet
    for your own name. Chances are, unless your name is particularly uncommon, you
    will have found plenty of doppelgangers with exactly the same name as yourself.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，存在着识别名称或标签之间的唯一性的挑战。将相同的名称重复分配给不同的现实实体明显存在一个难题，即区分谁是谁。也许你在互联网上搜索过自己的名字。除非你的名字特别不常见，否则你很可能会发现有很多与你完全相同的同名者。
- en: Inconsistent Naming Conventions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名规范不一致
- en: Names are recorded in a variety of ways and data structures. Sometimes names
    are described in full, but often abbreviations are present or less significant
    parts of the name are omitted. For example, my name might be expressed, entirely
    correctly, as any of the variations in [Table 1-1](#table-1-1).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 名称以各种方式和数据结构记录。有时名称会完整描述，但通常会出现缩写或省略名称的不太重要的部分。例如，我的名字可能像[表1-1](#table-1-1)中的任何一个变体一样完全正确地表达。
- en: Table 1-1\. Name variations
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-1. 名称变体
- en: '| Name |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 名称 |'
- en: '| --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Michael Shearer |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·谢拉 |'
- en: '| Michael William Shearer |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·威廉·谢拉 |'
- en: '| Michael William Robert Shearer |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·威廉·罗伯特·谢拉 |'
- en: '| Michael W R Shearer |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·W·R·谢拉 |'
- en: '| M W R Shearer |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| M W R 谢拉 |'
- en: '| M W Shearer |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| M W 谢拉 |'
- en: None of these names exactly match each other but all refer to the same person,
    the same real-world entity. Titles, nicknames, shortened forms, or accented characters
    all frustrate the process of finding an exact match. Double-barreled or hyphenated
    last names add further permutations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名字互不完全匹配，但都指向同一个人，同一个现实世界的实体。头衔、昵称、缩写形式或重音字符都会使找到精确匹配的过程受挫。复姓或带连字符的姓氏会进一步增加变数。
- en: In an international context, naming practices vary enormously across the globe.
    Personal names may be present at the start or the end of a name and family names
    may or may not be present. Family names may also vary according to the sex and
    marital status of the individual. Names may be written in a variety of alphabets/character
    sets or translated differently between languages.^([1](ch01.html#id292))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在国际背景下，命名惯例在全球范围内差异巨大。个人姓名可能出现在名字的开头或结尾，而姓氏可能有也可能没有。姓氏也可能根据个体的性别和婚姻状况而异。姓名可能用各种字母表/字符集写成，或在不同语言之间翻译得不同。^([1](ch01.html#id292))
- en: Data Capture Inconsistencies
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据捕获的不一致性
- en: The process of capturing and recording names or labels usually reflects the
    data standards of the acquirer. At the most basic level, some data acquisition
    processes will employ uppercase characters only, others lowercase, while many
    will permit mixed case with initial letters capitalized.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 捕捉和记录名字或标签的过程通常反映了获取者的数据标准。在最基本的层次上，一些数据获取过程将仅使用大写字母，其他人则使用小写字母，而许多人则允许混合大小写，其中首字母大写。
- en: A name may be heard only in conversation without the opportunity to clarify
    the correct spelling or may be incorrectly transcribed in a hurry. Names or labels
    are often mistyped during manual rekeying or accidentally omitted. Sometimes different
    conventions are used that can easily be interpreted incorrectly if the original
    context is lost. For example, even a simple name can be recorded as “First name,
    Last name," or perhaps as “Last name, First name," or even transposed completely
    into the wrong fields.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 名字可能仅在对话中听到，没有机会澄清正确的拼写，或者可能在匆忙中被错误地转录。在手动重新键入过程中，名字或标签经常会被误输入或者意外省略。有时，如果原始上下文丢失，可能会使用不同的约定，这些约定很容易被误解。例如，即使是一个简单的名字，也可能被记录为“名字，姓氏”，或者“姓氏，名字”，甚至完全错误地转置到错误的字段中。
- en: International data capture can lead to inconsistencies in transliteration between
    one script and another, or to transcription errors when captured verbally.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 国际数据捕获可能导致不同脚本之间的音译不一致，或在口头捕获时出现转录错误。
- en: Worked Example
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作示例
- en: Let’s consider a simple fictitious example to illustrate how these challenges
    might manifest themselves. To begin with, imagine the only information we have
    is the name, as shown in [Table 1-2](#table-1-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的虚构例子，来说明这些挑战可能如何显现。首先，想象我们唯一拥有的信息是如 [表 1-2](#table-1-2) 中所示的名字。
- en: Table 1-2\. Example records
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-2\. 示例记录
- en: '| **Name  ** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **名称  ** |'
- en: '| --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Michael Shearer  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·谢拉 |'
- en: '| Micheal William Shearer |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·威廉·谢拉 |'
- en: Is it likely that a “Michael Shearer” refers to the same entity as a “Micheal
    William Shearer”? Absent any other information, there is a fair chance that both
    refer to the same person. The second, with the addition of a middle name, has
    extra information but otherwise they are nearly identical and a comparison of
    the two last names would produce an exact match. Notice I slipped in a common
    misspelling of my first name. Did you spot it?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: “迈克尔·谢拉”和“迈克尔·威廉·谢拉”是否指的是同一个实体？在没有其他信息的情况下，两者很可能指的是同一个人。第二个名字增加了一个中间名，但除此之外它们几乎相同，比较两个姓氏将产生完全匹配。请注意，我偷偷加了一个常见的拼写错误。你发现了吗？
- en: What if we add another attribute—can that help improve our matching accuracy?
    If you can’t remember your membership number, a service provider will often ask
    for a date of birth to help identify you (they also do this for security reasons).
    Date of birth is a particularly helpful attribute because it doesn’t change and
    has a large number of potential values (known as *high cardinality*). Also, the
    composite structure of individual values for day, month, and year may give us
    clues to the likelihood of a match when an exact equivalence isn’t established.
    For example, consider [Table 1-3](#table-1-3).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再增加一个属性，能帮助提高匹配准确性吗？如果你记不住会员号码，服务提供商通常会要求提供出生日期来帮助识别您（出于安全考虑）。出生日期是一个特别有用的属性，因为它不会改变，并且具有大量潜在值（称为*高基数*）。此外，日期的组合结构，包括日、月和年的个体值，可能会在确立精确等价关系时为我们提供线索。例如，参考[表 1-3](#table-1-3)。
- en: Table 1-3\. Example records—2
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-3\. 示例记录—2
- en: '| **Name    ** | **Date of birth ** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **姓名    ** | **出生日期 ** |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Michael Shearer   | 1/4/1970    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·谢勒   | 1970年1月4日    |'
- en: '| Micheal William Shearer   | 14 January 1970   |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·威廉·谢勒   | 1970年1月14日   |'
- en: At first glance the date of birth is not equivalent between the two records,
    so we might be tempted to discount the match. If these two individuals are born
    10 days apart, they are unlikely to be the same person! However, there is only
    a single-digit difference between the two, with the former lacking the leading
    digit 1 in the day subfield—could this be a typo? It’s hard to tell. If the records
    were from different sources, we would also have to consider whether the data format
    was consistent—do we have the UK format of DD/MM/YYYY or the US format of MM/DD/YYYY?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，两个记录的出生日期并不相等，因此我们可能会认为它们不匹配。如果这两个人的出生日期相差10天，他们不太可能是同一个人！然而，这两者之间只有个位数的差异，前者在日期子字段中缺少前导数字1——这可能是打字错误吗？很难说。如果这些记录来自不同的来源，我们还需要考虑数据格式是否一致——是英国的DD/MM/YYYY格式还是美国的MM/DD/YYYY格式？
- en: What if we add a place of birth? Again, this attribute shouldn’t change but
    it can be expressed at different levels of granularity or with different punctuation.
    [Table 1-4](#table-1-4) shows the enriched records.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们增加了出生地点呢？虽然这个属性不应改变，但可以用不同级别的细化或不同的标点符号来表达。[表 1-4](#table-1-4)展示了增强记录。
- en: Table 1-4\. Example records—3
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-4\. 示例记录—3
- en: '| **Name    ** | **Date of birth ** | **Place of birth   ** |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| **姓名    ** | **出生日期 ** | **出生地点   ** |'
- en: '| --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Michael Shearer   | 1/4/1970    | Stow-on-the-Wold |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·谢勒   | 1970年1月4日    | 斯托·奥恩·瓦尔德 |'
- en: '| Micheal William Shearer   | 14 January 1970   | Stow on the Wold |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·威廉·谢勒   | 1970年1月14日   | 斯托·奥恩·瓦尔德 |'
- en: Here there is no exact match on the place of birth between either record, although
    both could be factually correct.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有任何一个记录的出生地点完全匹配，尽管两者都可能属实。
- en: Therefore, place of birth, which may be recorded at different levels of specificity,
    doesn’t help us as much as we thought it might. What about something more personal,
    like a phone number? Of course, many of us do change our phone number throughout
    our life but with the ability to keep a cherished and well‑socialized mobile phone
    number when swapping between providers, this number is a more sticky attribute
    that we can use. However, even here we have challenges. Individuals may possess
    more than one number (a work and a personal number, for example), or the identifier
    may be recorded in a variety of formats, including spaces or hyphens. It may include
    or exclude an international dialing prefix.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，出生地点，可能以不同的精确级别记录，并不能像我们之前想象的那样帮助我们。那么像手机号码这样更私人化的信息呢？当然，我们中的许多人在一生中会更换电话号码，但是如果能够在换供应商时保留一部受喜爱和社交广泛的手机号码，这个号码就成为一个更具粘性的属性，我们可以使用它。然而，即使在这里，我们也面临挑战。个人可能拥有多个号码（例如工作和个人号码），或者标识符可能以各种格式记录，包括空格或连字符。它可能包含或不包含国际拨号前缀。
- en: '[Table 1-5](#table-1-5) shows our complete records.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-5](#table-1-5)展示了我们的完整记录。'
- en: Table 1-5\. Example records—4
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-5\. 示例记录—4
- en: '| **Name    ** | **Date of birth ** | **Place of birth   ** | **Mobile number**
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **姓名    ** | **出生日期 ** | **出生地点   ** | **手机号码** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Michael Shearer   | 1/4/1970    | Stow-on-the-Wold | 07700 900999 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·谢勒   | 1970年1月4日    | 斯托·奥恩·瓦尔德 | 07700 900999 |'
- en: '| Micheal William Shearer   | 14 January 1970   | Stow on the Wold | 0770-090-0999
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔·威廉·谢勒   | 1970年1月14日   | 斯托·奥恩·瓦尔德 | 0770-090-0999 |'
- en: As you can see, this resolution challenge is quickly becoming quite complicated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，这个解析挑战很快就变得非常复杂。
- en: Deliberate Obfuscation
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故意模糊化
- en: The vast majority of data inconsistencies that frustrate the matching process
    arise through inattentive but well-meaning data capture processes. However, for
    some uses we must consider the scenario where data has been maliciously obfuscated
    to disguise the true identity of the entity and prevent associations that might
    reveal a criminal intent or association.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数导致匹配过程中数据不一致的情况，都是通过粗心但出于善意的数据捕获过程引起的。然而，对于某些用途，我们必须考虑数据被恶意混淆的情况，以掩盖实体的真实身份，并防止可能揭示犯罪意图或关联的关联。
- en: Match Permutations
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配排列
- en: If I asked you to match your name against a simple table of, say, 30 names,
    you could probably do so within a few seconds. A longer list might take minutes
    but it is still a practical task. However, if I asked you to compare a list of
    100 names with a second list of 100 names, the task becomes a lot more laborious
    and prone to error.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我让你将你的名字与一个简单的表格，比如说30个名字的表格，进行匹配，你可能可以在几秒钟内完成。一个更长的列表可能需要几分钟，但这仍然是一个实际的任务。然而，如果我要求你将一个包含100个名字的列表与另一个包含100个名字的列表进行比较，这个任务就变得更加繁琐和容易出错了。
- en: Not only does the number of potential matches expand to 10,000 (100 × 100),
    but if you want to do so in one pass through the second table you have to hold
    all 100 names from the first table in your head—not easy!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅潜在匹配数量增加到10,000（100 × 100），而且如果您想在第二个表中一次通过这样做，您必须将第一个表中的所有100个名称都记在脑子里——这并不容易！
- en: 'Similarly, if I asked you to deduplicate a list of 100 names in a single list,
    you’d actually have to compare:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我让你在一个列表中对100个名字进行去重，你实际上需要进行比较：
- en: The first name against the remaining 99, then
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个名字与剩余的99个名字，然后
- en: The second name against the remaining 98 and so on.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个名字与剩余的98个名字等等。
- en: In fact, you’d have 4,950 comparisons to make. At one per second that’s about
    80 minutes of work just to compare two short lists. For much larger datasets,
    the number of potential combinations becomes impractical, even for the most performant
    hardware.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您需要进行4,950次比较。以每秒一次的速度计算，仅仅对两个短列表进行比较就需要大约80分钟的工作时间。对于更大的数据集，潜在的组合数量变得不切实际，即使对于性能最佳的硬件也是如此。
- en: Blind Matching?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 盲匹配？
- en: So far we have assumed that the sets of data we seek to match are fully transparent
    to us—that the values of the attributes are readily available, in full, and have
    not been obscured or masked in any way. In some cases this ideal is not possible
    due to privacy constraints or geopolitical factors that prevent data from moving
    across borders. How can we find matches without being able to see the data? This
    feels like magic, but as we will see in [Chapter 10](ch10.html#chapter_10), there
    are cryptographic techniques that enable matching to still take place without
    requiring full exposure of the list to be matched against.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设我们寻求匹配的数据集对我们是完全透明的——即属性的值是readily available的，完整的，并且没有以任何方式被模糊或掩盖。在某些情况下，由于隐私约束或地缘政治因素阻止数据跨越国界移动，这种理想情况是不可能的。如何在看不到数据的情况下找到匹配项？这看起来像魔术，但正如我们将在[第10章](ch10.html#chapter_10)中看到的那样，有加密技术可以使匹配仍然发生，而不需要完全暴露要匹配的列表。
- en: The Entity Resolution Process
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体解析过程
- en: 'To overcome the challenges mentioned, the basic entity resolution process is
    divided into four sequential steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服上述挑战，基本的实体解析过程被分为四个连续步骤：
- en: Data standardization
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据标准化
- en: Record blocking
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录阻塞
- en: Attribute comparison
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性比较
- en: Match classification
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配分类
- en: 'After match classification additional postprocessing steps may be required:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配分类之后，可能需要进行额外的后处理步骤：
- en: Clustering
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类
- en: Canonicalization
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范化
- en: Let’s describe each of these steps briefly in turn.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次简要描述每一个步骤。
- en: Data Standardization
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据标准化
- en: Before we can compare records we need to ensure that we have consistent data
    structures so that we can test for equivalence between attributes. We also need
    to ensure that the formatting of those attributes is consistent. This processing
    step usually involves splitting fields and removing null values and extraneous
    characters. It is often bespoke to the source dataset.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们比较记录之前，我们需要确保我们有一致的数据结构，以便我们可以测试属性之间的等价性。我们还需要确保这些属性的格式一致。这个处理步骤通常涉及到字段的拆分，删除空值和多余字符。它通常是针对源数据集定制的。
- en: Record Blocking
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录阻塞
- en: To overcome the challenge of impractically high volumes of record comparisons,
    a process called *blocking* is often used. Instead of comparing every record with
    every other record, only subsets of record pairs, preselected based on ready equivalence
    between certain attributes, are compared in their entirety. This filtering approach
    concentrates the resolution process on those records with the highest propensity
    to match.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服记录比较的数量不切实际高的挑战，通常会使用一种称为*阻塞*的过程。该过程不是将每个记录与每个其他记录进行比较，而是仅对根据某些属性之间的就绪等价性预先选择的记录对进行全面比较。这种过滤方法集中了解析过程在那些最有可能匹配的记录上。
- en: Attribute Comparison
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性比较
- en: The process of comparing individual attributes between the pairs of records
    selected by the blocking process occurs next. The degree of equivalence can be
    established based on an exact match between attributes or a similarity function.
    This process produces a set of equivalence measures between two record pairs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是通过阻塞过程选择的记录对之间比较各个属性的过程。等价度可以根据属性之间的精确匹配或相似性函数来确定。该过程产生了两个记录对之间的等价度量集合。
- en: Match Classification
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配分类
- en: The final step in the basic entity resolution process is to conclude whether
    the collective similarity between individual attributes is sufficient to declare
    two records a match, i.e., to resolve that they refer to the same real-world entity.
    This judgment can be made according to a set of manually defined rules or can
    be based on a machine learning probabilistic approach.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 基本实体解析过程的最后一步是确定个体属性之间的集体相似性是否足以声明两个记录匹配，即解析它们是否指向同一现实世界的实体。这种判断可以根据一组手动定义的规则进行，也可以基于机器学习的概率方法。
- en: Clustering
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚类
- en: Once our match classification is complete, we may group our records into connected
    clusters via their matching pairs. The inclusion of a record pair in a cluster
    may be determined by an additional match confidence threshold. Records without
    pairs above this threshold will form standalone clusters. If our matching criteria
    allow for different equivalence criteria, then our clusters may be intransitive;
    i.e., record A may be paired with record B, and record B paired with record C,
    but record C may not be paired to record A. As a result, clusters may be highly
    interconnected or more loosely coupled.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的匹配分类完成，我们可以通过它们的匹配对将记录分组为连接的群集。将记录对包含在群集中可能是通过额外的匹配置信度阈值来确定的。未达到此阈值的记录将形成独立的群集。如果我们的匹配标准允许不同的等价标准，则我们的群集可能是不传递的；即记录A可能与记录B配对，记录B可能与记录C配对，但记录C可能无法与记录A配对。因此，群集可能高度相互关联或松散耦合。
- en: Canonicalization
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范化
- en: Post resolution there may be a need to determine which attribute values should
    be used to represent an entity. If approximate matching techniques have been used
    to determine equivalence, or if an additional variable attribute is present in
    the pair or cluster but has not been used in the matching process, then there
    may be a need to decide which value is the most representative. The resulting
    canonical attribute values are then used to describe the resolved entity in onward
    calculations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解析后可能需要确定应使用哪些属性值来表示实体。如果使用近似匹配技术确定了等价性，或者如果一对或群集中存在但未在匹配过程中使用的附加可变属性，则可能需要决定哪个值最具代表性。然后，生成的规范属性值用于后续计算中描述解析的实体。
- en: Worked Example
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作示例
- en: Returning to our simple example, let’s apply the steps to our data. First, let’s
    standardize our data, splitting the name attribute, standardizing the date of
    birth, and removing the extra characters in the place of birth and mobile number
    fields. [Table 1-6](#table-1-6) shows our cleansed records.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们简单的示例，让我们将这些步骤应用到我们的数据上。首先，让我们标准化我们的数据，分割名字属性，标准化出生日期，并删除出生地点和手机号码字段中的额外字符。[表 1-6](#table-1-6)
    显示了我们经过清理的记录。
- en: 'Table 1-6\. Step 1: Data standardized records'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-6\. 第1步：数据标准化记录
- en: '| **First name  ** | **Last name** | **Date of birth ** | **Place of birth 
     ** | **Mobile number** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **名字  ** | **姓氏** | **出生日期 ** | **出生地点   ** | **手机号码** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Michael   | Shearer | 1/4/1970    | Stow on the Wold | 07700 900999 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔   | 谢拉 | 1970年1月4日    | 斯托·翁·沃尔德 | 07700 900999 |'
- en: '| Micheal   | Shearer | 1/14/1970   | Stow on the Wold | 07700 900999 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔   | 谢拉 | 1970年1月14日   | 斯托·翁·沃尔德 | 07700 900999 |'
- en: In this simple example, we have only one pair to consider, so we don’t need
    to apply blocking. We’ll return to this in [Chapter 5](ch05.html#chapter_5).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们只需要考虑一个配对，因此不需要应用阻塞技术。我们将在[第5章](ch05.html#chapter_5)中讨论这个问题。
- en: Next we’ll compare the individual attributes for exact matches. [Table 1-7](#table-1-7)
    shows the comparison between each attribute as either a “Match” or a “No match.”
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将比较每个属性的精确匹配情况。[表格1-7](#table-1-7)显示了每个属性的比较结果，可以是“匹配”或“无匹配”。
- en: 'Table 1-7\. Step 3: Attribute comparison'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1-7\. 第三步：属性比较
- en: '| **Attribute** | **Value record 1** | **Value record 2** | **Comparison**
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **值记录1** | **值记录2** | **比较结果** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| First name | Michael  | Micheal  | No match |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 名字 | 迈克尔  | 米迦勒  | 无匹配 |'
- en: '| Last name | Shearer | Shearer | Match |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 姓氏 | 谢勒 | 谢勒 | 匹配 |'
- en: '| Date of birth | 1/4/1970 | 1/14/1970 | No match |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 出生日期 | 1970年1月4日 | 1970年1月14日 | 无匹配 |'
- en: '| Place of birth | Stow on the Wold | Stow on the Wold | Match |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 出生地 | 斯托-瓦尔德 | 斯托-瓦尔德 | 匹配 |'
- en: '| Mobile number | 07700 900999 | 07700 900999 | Match |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 手机号码 | 07700 900999 | 07700 900999 | 匹配 |'
- en: Finally, we apply step 4 to determine whether we have an overall match. A simple
    rule might be if the majority of the attributes match, then we conclude the overall
    record is a match, as in this case.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应用第4步确定是否存在总体匹配。一个简单的规则可能是，如果大多数属性匹配，则我们得出总体记录匹配的结论，就像在这种情况下一样。
- en: 'Alternatively, we might consider various combinations of matching attributes
    to be sufficient for us to declare a match.  In our example, to declare a match
    we could look for either:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以考虑各种匹配属性的组合是否足以声明匹配。在我们的例子中，为了声明匹配，我们可以寻找以下任一条件：
- en: Name match AND (date of birth OR place of birth match), or
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名匹配和（出生日期或出生地匹配），或
- en: Name match AND mobile number match
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名匹配和手机号匹配
- en: We can take this approach a step further and assign a *relative weighting* to
    each of our attribute comparisons; a mobile number match is worth perhaps twice
    as much as a date of birth match, and so on. Combining these weighted scores produces
    an overall match score that can be considered against a given confidence threshold.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步采取这种方法，并为我们的每个属性比较分配一个*相对权重*；例如，手机号码匹配可能比出生日期匹配的价值高出两倍，等等。结合这些加权分数产生一个总体匹配分数，可以根据给定的置信度阈值来考虑。
- en: We will look more at different approaches to determine these relative weightings,
    using statistical techniques and machine learning, in [Chapter 4](ch04.html#chapter_4).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更多地研究不同方法来确定这些相对权重，使用统计技术和机器学习，在[第4章](ch04.html#chapter_4)中。
- en: As we have seen, different attributes may be stronger or weaker in helping us
    determine whether we have a match. Earlier, we considered the likelihood of finding
    a match for a name that is quite common versus one that is found more infrequently.
    For example, in a UK context, a match on a last name of Smith is likely to be
    less informative than a match on Shearer—there are fewer Shearers than Smiths,
    so a match is inherently less likely to begin with (a lower prior probability).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，不同的属性在帮助我们确定是否存在匹配时可能具有不同的强度。之前，我们考虑了在找到一个相当常见的名字与找到一个较少见的名字之间找到匹配的可能性。例如，在英国的情况下，史密斯姓的匹配可能比谢勒姓的信息量要少—谢勒姓的人比史密斯姓的人少，因此匹配本身的可能性从一开始就较低（较低的先验概率）。
- en: This probabilistic approach works particularly well when some of the values
    of a categorical attribute (one with a finite set of values)  are significantly
    more common than others. If we consider a city attribute as part of an address
    match in a UK dataset, then London is likely to occur much more frequently than,
    say, Bath, and therefore may be weighted less.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种概率方法在某些分类属性的值（即有限值集合的属性）中特别有效，其中某些值比其他值更常见。如果我们考虑一个城市属性作为英国数据集中地址匹配的一部分，那么伦敦出现的频率可能远远高于巴斯，因此可能会受到较少的加权。
- en: Note that we haven’t been able to determine which date of birth is definitively
    correct, so we are left with a canonicalization challenge.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们尚未能够确定哪个出生日期是确切正确的，因此我们面临一个规范化的挑战。
- en: Measuring Performance
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 衡量性能
- en: Statistical approaches may help us to decide how to evaluate and combine all
    the clues that comparing individual attributes gives us, but how do we decide
    whether the combination is good enough or not? How do we set the confidence threshold
    to declare a match? This depends on what is important to us and how we propose
    to use our newly found matches.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 统计方法可能帮助我们决定如何评估和结合比较各个属性所提供的所有线索，但我们如何决定组合是否足够好？如何设置置信度阈值来声明匹配？这取决于我们重视什么以及我们打算如何使用我们新发现的匹配。
- en: Do we care more about being sure we spot every potential match and we are OK
    if in the process we declare a few matches that turn out to be false? This measure
    is known as *recall*. Or we don’t want to waste our time with incorrect matches
    but if we miss a few true matches along the way that’s OK. This is called *precision*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更关心确保发现每一个潜在的匹配，如果在这个过程中声明了一些后来被证明是错误的匹配，我们也能接受吗？这个度量称为*召回率*。或者，我们不想浪费时间在不正确的匹配上，但如果在此过程中错过了一些真实的匹配，我们可以接受。这称为*精确度*。
- en: When comparing two records, there are four different scenarios that can arise.
    [Table 1-8](#table-1-8) lists the different combinations of match decision and
    ground truth.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两条记录时，可能出现四种不同的情况。[表1-8](#table-1-8) 列出了匹配决策和实际情况的不同组合。
- en: Table 1-8\. Matching classifications
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表1-8. 匹配分类
- en: '| **You decide** | **Ground truth** | **Instance of** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **你决定** | **实际情况** | **实例** |'
- en: '| --- | --- | --- |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Match | Match | True positive (TP) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 匹配 | 匹配 | 真正阳性 (TP) |'
- en: '| Match | Not match | False positive (FP) |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 匹配 | 不匹配 | 假阳性 (FP) |'
- en: '| Not match | Match | False negative (FN) |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 不匹配 | 匹配 | 假阴性 (FN) |'
- en: '| Not match | Not match | True negative (TN) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 不匹配 | 不匹配 | 真负 (TN) |'
- en: If our recall measure is high, then we are only declaring relatively few false
    negatives, i.e., when we declare a match we rarely overlook a good candidate.
    If our precision is high, then when we declare a match we nearly always get it
    right.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的召回率测量很高，那么我们只宣布相对较少的假阴性，即当我们声明匹配时，我们很少会错过一个好的候选。如果我们的精确度很高，那么当我们声明匹配时，我们几乎总是做对的。
- en: At one extreme, imagine we declare every candidate pair a match; we would have
    zero false negatives and our measure of recall would be a perfect (1.0); we’d
    never overlook a match. Of course our precision would be very poor as we’d declare
    lots of nonmatches incorrectly as matches. Alternatively, imagine we declare a
    match in the ideal case, when every attribute is exactly equivalent; then we will
    never declare a match in error and our precision will be perfect (1.0), at the
    expense of our recall, which will be very poor as a lot of good matches pass us
    by.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个极端情况下，假设我们声明每一个候选对都是匹配的；我们将没有任何假阴性，我们的召回率度量将是完美的（1.0）；我们永远不会漏掉一个匹配。当然，我们的精确度将非常低，因为我们会错误地声明大量不匹配为匹配。或者，想象在理想情况下，当每个属性完全等效时，我们才宣布匹配；那么我们将永远不会错误地宣布匹配，我们的精确度将是完美的（1.0），但代价是我们的召回率将非常低，因为很多好的匹配都会错过。
- en: Ideally, of course, we’d like high recall and precision simultaneously—our matches
    are both correct and comprehensive—but this is tricky to achieve! [Chapter 6](ch06.html#chapter_6)
    describes this process in more detail.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们当然希望同时具备高召回率和精确度——我们的匹配既正确又全面——但这很难实现！[第6章](ch06.html#chapter_6) 更详细地描述了这个过程。
- en: Getting Started
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: So, how can we solve these challenges?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何解决这些挑战呢？
- en: Hopefully this chapter has given you a good understanding of what entity resolution
    is, why it is needed, and the main steps in the process. Subsequent chapters will
    guide you, hands-on, through a set of worked real-world examples based on publicly
    available data.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 希望本章为您提供了对实体解析是什么，为什么需要它以及过程中的主要步骤的良好理解。接下来的章节将通过一组基于公开数据的实际工作示例，手把手地指导您。
- en: Fortunately, in addition to commercial options, there are several open‑source
    Python libraries that do much of the hard work for us. These frameworks provide
    the scaffolding upon which we can construct a bespoke matching process that suits
    our data and context.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，除了商业选项外，还有几个开源的Python库可以为我们做大部分的繁重工作。这些框架为我们构建适合我们数据和背景的定制匹配过程提供了支持。
- en: Before we begin, we’ll take a short detour in the next chapter to set up our
    analytic environment and review some of the foundational Python data science libraries
    we will use, and then we’ll consider the first step in our entity resolution process—standardizing
    our data ready for matching.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们将在下一章节中进行一个小的偏离，来设置我们的分析环境，并回顾我们将使用的一些基础 Python 数据科学库，然后我们将考虑我们实体解析过程的第一步——准备我们的数据以便匹配。
- en: ^([1](ch01.html#id292-marker)) For further details on global naming conventions,
    see [this guide](https://oreil.ly/Hzu6D).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch01.html#id292-marker)) 关于全局命名惯例的详细信息，请参阅[此指南](https://oreil.ly/Hzu6D)。
