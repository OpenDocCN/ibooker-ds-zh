- en: Part 2\. Groovy tools
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分。Groovy工具
- en: 'Welcome to [part 2](#part02): “Groovy tools.” In these two chapters, I address
    two of the major ways Groovy is often introduced into an organization: namely,
    build processes and testing.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[第二部分](#part02)：“Groovy工具。”在这两章中，我讨论了Groovy通常被引入组织的两种主要方式：即构建过程和测试。
- en: '[Chapter 5](kindle_split_016.html#ch05) on build processes reviews the dominant
    build tools in the Java world, Ant and Maven, and shows how to add Groovy dependencies
    to each. It also covers the Ant tasks that work with Groovy and the major Groovy
    plugins for Maven. Finally, it provides an introduction to Gradle, one of the
    most important projects in the Groovy world, and includes examples covering several
    interesting build tasks.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](kindle_split_016.html#ch05)关于构建过程回顾了Java世界中的主导构建工具Ant和Maven，并展示了如何将Groovy依赖项添加到每个工具中。它还涵盖了与Groovy一起工作的Ant任务和Maven的主要Groovy插件。最后，它介绍了Gradle，这是Groovy世界中最重要项目之一，并包括涵盖几个有趣构建任务的示例。'
- en: '[Chapter 6](kindle_split_017.html#ch06) on testing starts with JUnit tests
    in both Java and Groovy and then looks at the JUnit subclass `GroovyTestCase`
    and its descendants and what additional capabilities they bring. Then it covers
    the `MockFor` and `StubFor` classes in the Groovy library, which are great ways
    to build mock objects and also provide some insight into Groovy metaprogramming.
    Finally, the chapter ends with a good overview of the Spock testing framework,
    which includes mocking capabilities of its own.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](kindle_split_017.html#ch06)关于测试从Java和Groovy中的JUnit测试开始，然后探讨了JUnit子类`GroovyTestCase`及其后代，以及它们带来的额外功能。接着，它涵盖了Groovy库中的`MockFor`和`StubFor`类，这些是构建模拟对象的好方法，同时也提供了一些关于Groovy元编程的见解。最后，本章以Spock测试框架的良好概述结束，该框架本身也包含一些模拟功能。'
- en: Chapter 5\. Build processes
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章。构建过程
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Adding Groovy to Ant builds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Groovy添加到Ant构建中
- en: Using Maven with Groovy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven与Groovy
- en: Groovy Grapes and `@Grab`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy葡萄和`@Grab`
- en: 'The future: Gradle'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来：Gradle
- en: Building source code is almost always a pain point in development organizations.
    An ideal build process is automated end-to-end, including compilation, running
    tests, generating reports, and producing any required artifacts. The process needs
    to be fast enough that it can be done frequently, especially given modern agile
    approaches, and yet flexible enough to adapt to the exigencies of individual teams.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发组织中，构建源代码几乎总是痛点。一个理想的构建过程是自动化端到端，包括编译、运行测试、生成报告和生成任何所需的工件。该过程需要足够快，以便可以频繁执行，尤其是在现代敏捷方法下，同时还需要足够灵活，以适应各个团队的紧急需求。
- en: In the Java world two primary approaches to automated builds have emerged over
    time. Both are open source projects from Apache. The first is Ant ([http://ant.apache.org](http://ant.apache.org)),
    which uses a library of tasks configured in XML backed by Java classes. The other
    is Maven ([http://maven.apache.org](http://maven.apache.org)), which offers a
    rich array of options and promises to make the entire process simple, but uses
    a highly opinionated API that requires a degree of mastery to use effectively.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java世界中，随着时间的推移，已经出现了两种主要的自动化构建方法。两者都是Apache的开源项目。第一个是Ant ([http://ant.apache.org](http://ant.apache.org))，它使用配置在XML中的任务库，由Java类支持。另一个是Maven
    ([http://maven.apache.org](http://maven.apache.org))，它提供了一系列丰富的选项，承诺使整个过程简单化，但使用了一个高度有偏见的API，需要一定的掌握才能有效使用。
- en: To start I want to address the goals of any build process, and then see how
    the various tools attempt to meet them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我想讨论任何构建过程的目标，然后看看各种工具是如何尝试满足这些目标的。
- en: 5.1\. The build challenge
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1。构建挑战
- en: A software build combines several features that individually seem like they
    ought to be easy but in practice become complicated. To build your code you must
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 软件构建结合了几个功能，单独看起来似乎应该很容易，但在实践中却变得复杂。为了构建你的代码，你必须
- en: Download any necessary dependencies.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载任何必要的依赖项。
- en: Compile the source code with the dependencies properly resolved, handling any
    cross-language issues that may arise.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确解析的依赖项编译源代码，处理可能出现的跨语言问题。
- en: Run the unit, integration, and/or functional tests.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单元、集成和/或功能测试。
- en: Produce the desired artifacts, whatever they may be.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成所需的工件，无论它们是什么。
- en: Optionally, other tasks might include checking code out of source code control,
    generating documentation, and even deploying the results into production.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的任务可能包括从源代码控制中检出代码、生成文档，甚至将结果部署到生产环境中。
- en: '|  |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The IDE build**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**IDE构建**'
- en: Some companies still do their builds inside integrated development environments
    (IDEs). Although this is not in itself a bad thing, it often leads to long-term
    problems. Sooner or later such companies wind up with a special computer that
    no one is allowed to touch, even though the original owner left or transferred
    to another division long ago, because it’s the only system where the build still
    works.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司仍然在集成开发环境（IDE）内部进行构建。尽管这本身并不是一件坏事，但它往往会导致长期问题。迟早，这些公司会拥有一台特殊的计算机，没有人敢触摸，即使原始所有者很久以前就离开了或者转到了其他部门，因为它是唯一一个构建仍然可以工作的系统。
- en: Current thinking is that the source code control system should manage all aspects
    of a build, from the required scripts to the JAR dependencies. That way you can
    always be sure the build is correct and self-sufficient, which avoids the whole
    “at least it works on my machine” problem.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的观点是，源代码控制系统应该管理构建的所有方面，从所需的脚本到 JAR 依赖项。这样，你就可以始终确信构建是正确的并且自给自足的，这避免了整个“至少在我的机器上它能工作”的问题。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In fact, the recent trend in development processes is toward continuous delivery,
    where a single command performs the whole sequence from build to deployment in
    one motion.^([[1](#ch05fn01)])
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，近年来在开发过程中的趋势是持续交付，其中一条命令就可以在一次操作中完成从构建到部署的整个序列。（^[[1](#ch05fn01)]）
- en: ¹ See Jez Humble and Dave Farley’s book *Continuous Delivery* (Addison Wesley,
    2010) for details. (Available through its companion website, http://continuousdelivery.com/.)
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 请参阅 Jez Humble 和 Dave Farley 的著作 *持续交付*（Addison Wesley，2010）以获取详细信息。（可通过其配套网站
    http://continuousdelivery.com/ 获取。）
- en: 'There are two primary build tools in the Java world: Ant and Maven. Ant is
    older and is gradually being replaced, but it is still common in the industry
    and is the foundation of everything that came afterward. Maven is used extensively
    in the Java industry but tends to trigger strong feelings in developers.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 世界中有两种主要的构建工具：Ant 和 Maven。Ant 较老，正在逐渐被取代，但它仍在行业中很常见，并且是之后所有事物的基石。Maven
    在 Java 行业中得到了广泛的应用，但往往会在开发者中引起强烈的情感。
- en: A guide to the technologies covered in this chapter is shown in [figure 5.1](#ch05fig01).
    I’ll start with the Apache Ant project in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖的技术指南如图 5.1 所示。下一节，我将从 Apache Ant 项目开始介绍。
- en: Figure 5.1\. Guide to technologies in this chapter. Java approaches are based
    on Ant or Maven. Groovy supplies Ant tasks for compilation and executing scripts.
    Gant is used by Grails but will eventually be replaced by Gradle. The `AntBuilder`
    class is useful and built into Gradle. There are two separate plugins available
    for Maven builds. Groovy Grapes make it easy to deliver code (normally scripts)
    to a client without compiling it first. Ultimately, though, the future belongs
    to Gradle.
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1\. 本章节技术指南。Java 方法基于 Ant 或 Maven。Groovy 为编译和执行脚本提供了 Ant 任务。Gant 被用于 Grails，但最终将被
    Gradle 取代。`AntBuilder` 类很有用，并且内置在 Gradle 中。有两个独立的插件可用于 Maven 构建。Groovy Grapes
    使得在没有先编译的情况下向客户端交付代码（通常是脚本）变得容易。然而，最终，未来属于 Gradle。
- en: '![](05fig01_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig01_alt.jpg)'
- en: '5.2\. The Java approach, part 1: Ant'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. Java 方法，第 1 部分：Ant
- en: Apache Ant is a Java-based build tool, based on the older “make” technology
    but without many of its difficulties. The name Ant represents either “another
    neat tool” or a tool that lifts far more than its own weight, depending on whom
    you ask. Ant build files are written in XML, so they are inherently cross-platform,
    and because Java classes implement the XML tasks, a single API suffices for all
    operating systems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Ant 是一个基于 Java 的构建工具，基于较老的“make”技术，但避免了其中许多困难。Ant 的名字代表“另一个整洁的工具”或一个能够承担远超自身重量的工具，这取决于你问的是谁。Ant
    构建文件是用 XML 编写的，因此它们本质上是跨平台的，并且由于 Java 类实现了 XML 任务，因此单个 API 就足以适用于所有操作系统。
- en: That’s the good news. The (somewhat) bad news is that Ant is an extremely low-level
    API, so many build files consist of lots of twisty little tasks, all alike.^([[2](#ch05fn02)])
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是好消息。有些（多少有些）坏消息是，Ant 是一个非常底层的 API，因此许多构建文件由许多扭曲的小任务组成，它们都一样。（^[[2](#ch05fn02)]）
- en: ² Yes, an Adventure (or Zork) reference. I just mean they’re small, they’re
    many, and they’re easy to get lost in.
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 是的，一个冒险（或 Zork）的引用。我的意思是它们很小，很多，而且很容易在其中迷路。
- en: Let me start with a “Hello, World” example in the next listing, based on a sample
    from the Ant tutorial provided by Apache at the Ant website.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从下一列表中的“Hello, World”示例开始，这个示例基于 Apache 在 Ant 网站上提供的 Ant 教程中的样本。
- en: 'Listing 5.1\. build.xml: A simple Ant build file for a “Hello, World” Java
    application'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. build.xml：一个简单的 Ant 构建“Hello, World” Java 应用程序的构建文件
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By default, this file is called build.xml and resides in the root directory
    of the project. The root element of the project file is called `<project>`, which
    is given a `name`, a base directory, and the name of a default task to run if
    none is supplied on the command line.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此文件名为 build.xml，位于项目的根目录中。项目文件的根元素称为 `<project>`，它被赋予一个 `name`、一个基本目录以及一个默认任务，如果命令行中没有提供，则运行此任务。
- en: At the top of the file a series of properties are set, including the locations
    of various directories. Note that one property can refer to another by using the
    `${...}` syntax.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部设置了一系列属性，包括各种目录的位置。请注意，一个属性可以通过使用 `${...}` 语法来引用另一个属性。
- en: A series of `<task>` elements (`clean`, `compile`, `jar`, `run`, `clean-compile`,
    and `main`) are defined to represent individual actions during the build process.
    Some tasks depend on others, which is expressed using the `depends` attribute
    of the `<task>` element.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一系列 `<task>` 元素（`clean`、`compile`、`jar`、`run`、`clean-compile` 和 `main`），以表示构建过程中的单个操作。一些任务依赖于其他任务，这通过
    `<task>` 元素的 `depends` 属性来表示。
- en: All the defined tasks ultimately delegate to a library of predefined Ant tasks.
    Here those tasks include file-based tasks like `mkdir` and `delete`, and Java-related
    tasks like `javac`, `jar`, and `java`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所定义的所有任务最终都会委托给一组预定义的 Ant 任务。这里这些任务包括基于文件的任务，如 `mkdir` 和 `delete`，以及与 Java 相关的任务，如
    `javac`、`jar` 和 `java`。
- en: Executing this build without arguments means typing `ant` at the command line,
    which will execute the default `main` task. Because `main` depends on `clean`
    and `run` it will execute those tasks first, which will execute their own individual
    dependencies, and so on. The result looks like the following listing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不带参数执行此构建意味着在命令行中键入 `ant`，这将执行默认的 `main` 任务。因为 `main` 依赖于 `clean` 和 `run`，它将首先执行这些任务，这些任务将执行它们自己的依赖项，依此类推。结果如下所示。
- en: Listing 5.2\. Execution of the default task in the “Hello, World” Ant build
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. “Hello, World” Ant 构建中默认任务的执行
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each task outputs its own name, followed by the included built-in Ant tasks
    indented underneath. The build completed successfully, though that can be misleading.
    The `BUILD` `SUCCESSFUL` statement at the end means that Ant finished all the
    tasks. The individual tasks may or may not have worked.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务都会输出其自己的名称，然后是包含在下面的缩进内置 Ant 任务。构建成功完成，尽管这可能具有误导性。最后的 `BUILD` `SUCCESSFUL`
    语句表示 Ant 完成了所有任务。个别任务可能成功也可能失败。
- en: The tasks chosen here are typical, but there is no standard. Each organization
    (and even each developer) is free to choose their own. Reusing tasks between different
    builds also requires an `import` statement (or copy-and-paste reuse), plus some
    effort to make sure the tasks are not tied to a particular project structure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择的任务很典型，但没有标准。每个组织（甚至每个开发者）都可以自由选择自己的。在不同构建之间重用任务还需要一个 `import` 语句（或复制粘贴重用），以及一些确保任务不与特定项目结构绑定的努力。
- en: Again, the benefit here is that this is all completely portable. The Ant build
    should work just as well on Mac OS X as it does on Windows or Linux. The downside
    is that this is a trivial Hello World application and the build file is already
    over 35 lines long. Once you add in the `junit` and `junitreport` tasks, to say
    nothing of customizing the classpath with third-party libraries, the size of this
    file will grow quickly. A more extensive build file, including the JUnit 4 libraries
    and a test case, can be found in the chapter source code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里的优势是这一切都是完全可移植的。Ant 构建应该在 Mac OS X 上与在 Windows 或 Linux 上一样好。缺点是这个只是一个简单的
    Hello World 应用程序，构建文件已经超过 35 行长。一旦添加了 `junit` 和 `junitreport` 任务，更不用说使用第三方库自定义类路径了，这个文件的大小会迅速增长。一个更广泛的构建文件，包括
    JUnit 4 库和一个测试用例，可以在章节源代码中找到。
- en: Rather than do that here, however, let me show you how to introduce Groovy into
    this system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里不做这个，而是让我向你展示如何将 Groovy 引入这个系统。
- en: 5.3\. Making Ant Groovy
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 将 Ant 与 Groovy 结合
- en: Ant is not as common in Java builds as it used to be, but switching build tools
    is a major decision for most organizations and not to be undertaken lightly. If
    you’re working with a large installed base of Ant builds, then Groovy can still
    contribute.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ant 在 Java 构建中不像以前那样常见，但切换构建工具对于大多数组织来说是一个重大的决定，不应轻率行事。如果你正在使用大量已安装的 Ant 构建，那么
    Groovy 仍然可以做出贡献。
- en: 'Four approaches are available:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法可供选择：
- en: Groovy scripting code can be added directly to an Ant build file.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy 脚本代码可以直接添加到 Ant 构建文件中。
- en: Groovy scripts and classes can be compiled and executed in Ant builds using
    special Ant tasks for that purpose.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy 脚本和类可以使用专门为此目的的 Ant 任务在 Ant 构建中编译和执行。
- en: The Groovy standard library contains a special class called `groovy.util.AntBuilder`
    that can replace the XML build file with Groovy scripting code that does the same
    thing.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy 标准库中包含一个名为 `groovy.util.AntBuilder` 的特殊类，它可以替换执行相同功能的 Groovy 脚本 XML 构建文件。
- en: There’s a Groovy DSL available, called Gant, which provides an alternative to
    `AntBuilder`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用 Groovy DSL，称为 Gant，它提供了对 `AntBuilder` 的替代方案。
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: AntBuilder
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: AntBuilder
- en: Even if you don’t use Ant, the `AntBuilder` class is worth knowing about because
    it’s embedded in other build tools, like Gant and Gradle.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不使用 Ant，了解 `AntBuilder` 类也是值得的，因为它嵌入在其他构建工具中，如 Gant 和 Gradle。
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The following subsections will tackle each of these Groovy and Ant topics in
    turn.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将依次处理这些 Groovy 和 Ant 主题。
- en: 5.3.1\. The <groovy> Ant task
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1\. `<groovy>` Ant 任务
- en: Ant has two hooks that allow you to add Groovy to a standard build file. The
    `<groovy>` and `<groovyc>` tasks use the Groovy libraries to execute Groovy scripts
    and compile Groovy source files, respectively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ant 有两个钩子，允许您将 Groovy 添加到标准构建文件中。`<groovy>` 和 `<groovyc>` 任务分别使用 Groovy 库执行
    Groovy 脚本和编译 Groovy 源文件。
- en: Starting first with `<groovy>`, defining the associated task in an Ant build
    lets you write Groovy code directly into the build file. The following listing
    shows a trivial example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先从 `<groovy>` 开始，在 Ant 构建中定义相关任务，可以直接将 Groovy 代码写入构建文件。下面的列表显示了一个简单的示例。
- en: Listing 5.3\. A trivial Ant build that executes Groovy code in a task
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 一个简单的 Ant 构建，在任务中执行 Groovy 代码
- en: '![](098fig01_alt.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](098fig01_alt.jpg)'
- en: The `environment` property allows the build to access system properties in the
    operating system. Here the `env` variable is used to access the current value
    of `GROOVY_HOME`, the installation directory for Groovy. The `<path>` element
    assigns the groovy-all JAR file (found in the embeddable directory) to the `groovy.classpath`
    ID.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`environment` 属性允许构建访问操作系统的系统属性。在这里，`env` 变量用于访问 `GROOVY_HOME` 的当前值，Groovy
    的安装目录。`<path>` 元素将 groovy-all JAR 文件（位于可嵌入目录中）分配给 `groovy.classpath` ID。'
- en: The `<taskdef>` element then defines the `groovy` task as a reference to the
    `org.codehaus.groovy.ant.Groovy` class, which is resolved in the groovy-all JAR
    file. Once the `groovy` task has been defined it can be used to execute arbitrary
    Groovy code. A straight print of “Hello, World!” is executed, and then the Ant
    `echo` task is also called.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`<taskdef>` 元素定义 `groovy` 任务为对 `org.codehaus.groovy.ant.Groovy` 类的引用，该类在 groovy-all
    JAR 文件中解析。一旦定义了 `groovy` 任务，就可以使用它来执行任意 Groovy 代码。执行了“Hello, World!”的直接打印，然后还调用了
    Ant 的 `echo` 任务。'
- en: It’s therefore easy enough to add Groovy code to an existing Ant build file,
    which can be useful if looping or conditional logic is needed in the build. It’s
    notoriously difficult to “program” in XML, and technologies that tend that direction
    (like Ant and XSLT) often result in awkward, complex build files. Adding Groovy
    scripting code might help the build file without modifying the underlying source
    code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很容易将 Groovy 代码添加到现有的 Ant 构建文件中，这在构建中需要循环或条件逻辑时非常有用。在 XML 中“编程”是出了名的困难，而且倾向于这个方向的技术（如
    Ant 和 XSLT）往往会导致笨拙、复杂的构建文件。添加 Groovy 脚本代码可能有助于构建文件，而无需修改底层源代码。
- en: 5.3.2\. The <groovyc> Ant task
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2\. `<groovyc>` Ant 任务
- en: Say you follow the advice in this book and decide to add Groovy modules to your
    implementation code. If you’re still going to build with Ant you’ll need a compilation
    task, similar to `<javac>`, for Groovy. That task is `<groovyc>`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 假如您遵循本书中的建议并决定将 Groovy 模块添加到您的实现代码中。如果您仍然使用 Ant 进行构建，您将需要一个类似于 `<javac>` 的编译任务来编译
    Groovy。这个任务就是 `<groovyc>`。
- en: 'The basic `<groovyc>` task definition is simple enough:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`<groovyc>` 任务定义非常简单：'
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The name of the task is `<groovyc>`, and it’s backed by the `Groovyc` class
    in the `org.codehaus.groovy.ant` package. This class is part of the Groovy Ant
    JARs referenced in the earlier build file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的名称是 `<groovyc>`，它由 `org.codehaus.groovy.ant` 包中的 `Groovyc` 类支持。这个类是前面构建文件中引用的
    Groovy Ant JAR 文件的一部分。
- en: The result of this task definition is that you can compile Groovy classes with
    `<groovyc>` while you compile Java classes with `<javac>`. This enforced separation
    of code bases can lead to difficulties, however, if there are cross dependencies.
    For example, a Groovy class may implement a Java interface and reference a Java
    class, which in turn uses a Groovy class, and so on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务定义的结果是，您可以在使用 `<javac>` 编译 Java 类的同时使用 `<groovyc>` 编译 Groovy 类。这种强制分离代码库的方法可能会导致困难，如果有交叉依赖关系。例如，一个
    Groovy 类可能实现了 Java 接口并引用了一个 Java 类，而这个 Java 类又使用了一个 Groovy 类，依此类推。
- en: 'A good way to resolve these issues is to use the *joint-compilation* approach.
    Ant lets you embed the `<javac>` task inside the `<groovyc>` task. The nested
    tag approach results in a `<groovyc>` task that looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的好方法是使用 *联合编译* 方法。Ant 允许您在 `<groovyc>` 任务内部嵌入 `<javac>` 任务。嵌套标签方法导致一个看起来像这样的
    `<groovyc>` 任务：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The nested `<javac>` task doesn’t imply the Java compiler is running. As a child
    of the `<groovyc>` task it lets the Groovy joint compiler do all the work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的 `<javac>` 任务并不意味着 Java 编译器正在运行。作为 `<groovyc>` 任务的子任务，它允许 Groovy 联合编译器完成所有工作。
- en: The source directory, destination directory, and classpath variables defined
    in the `<groovyc>` task are passed down to the nested `<javac>` task. The joint-compilation
    approach means that Groovy will compile the Groovy sources and create stubs for
    them, then call the Java compiler to do the same for the Java sources, and resume
    the compilation process with the Groovy compiler. The result is that you can mix
    Java and Groovy sources without a problem.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<groovyc>` 任务中定义的源目录、目标目录和类路径变量被传递到嵌套的 `<javac>` 任务中。联合编译方法意味着 Groovy 将编译
    Groovy 源代码并为它们创建存根，然后调用 Java 编译器为 Java 源代码做同样的事情，并使用 Groovy 编译器继续编译过程。结果是，您可以无问题地混合
    Java 和 Groovy 源代码。
- en: Therefore, to extend the Ant build file presented [section 5.2](#ch05lev1sec2)
    to include Groovy files, make the additions and changes shown in the next listing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了将 Ant 构建文件扩展到包括 Groovy 文件，请按照下一个列表所示进行添加和更改。
- en: Listing 5.4\. Extending the “Hello, World” build to mix Java and Groovy sources
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4. 将“Hello, World”构建扩展以混合 Java 和 Groovy 源代码
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The rest is the same as before.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的与之前相同。
- en: If you’re committed to Ant builds using XML, that’s all there is to it. If,
    however, you’re willing to switch your build language to Groovy, there are a couple
    of other alternatives. The next two subsections use Groovy for the build language
    but are still fundamentally based on Ant.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您坚持使用 XML 进行 Ant 构建，那么这就是全部内容。然而，如果您愿意将构建语言切换到 Groovy，还有其他一些替代方案。接下来的两个小节使用
    Groovy 作为构建语言，但仍然基于 Ant。
- en: 5.3.3\. Writing your build in Groovy with AntBuilder
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3. 使用 AntBuilder 在 Groovy 中编写构建
- en: The standard Groovy library includes a class called `groovy.util.AntBuilder`.
    To use it you need to add the Java-based Ant JAR library files to your classpath,
    but once you do, `AntBuilder` lets you replace the XML syntax with Groovy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Groovy 库包括一个名为 `groovy.util.AntBuilder` 的类。要使用它，您需要将基于 Java 的 Ant JAR 库文件添加到您的类路径中，但一旦这样做，`AntBuilder`
    就允许您用 Groovy 语法替换 XML 语法。
- en: Any task defined by Ant can be used through the `AntBuilder` class. For example,
    the following listing shows a simple script that makes a copy of its own source,
    verifies that it worked, and then deletes the copy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ant 定义的任何任务都可以通过 `AntBuilder` 类使用。例如，以下列表显示了一个简单的脚本，该脚本复制其自身的源代码，验证其是否成功，然后删除副本。
- en: Listing 5.5\. `antbuilder.groovy`, which copies itself
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5. `antbuilder.groovy`，该脚本复制自身
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Builder code and regular Groovy code are freely intermixed in this example.
    The Ant tasks used here are `echo`, `copy`, and `delete`, but it would be easy
    enough to use others like `javac`, `junitreport`, or even optional Ant tasks like
    `mail`. As long as the required Ant libraries are in the classpath, each will
    work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，构建代码和常规 Groovy 代码可以自由混合。这里使用的 Ant 任务是 `echo`、`copy` 和 `delete`，但很容易使用其他任务，如
    `javac`、`junitreport`，甚至是可选的 Ant 任务如 `mail`。只要所需的 Ant 库在类路径中，每个任务都可以正常工作。
- en: There’s actually a simplification available. The `with` syntax is available
    as a part of Groovy’s metaprogramming capabilities. It can simplify the previous
    listing down to that shown in the next listing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有一个简化的方法可用。`with` 语法是 Groovy 元编程能力的一部分。它可以简化前面的列表，使其变为下一个列表所示的内容。
- en: Listing 5.6\. Simplifying the build script using the `with` method
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6. 使用 `with` 方法简化构建脚本
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `with` method invokes the contained methods on the Ant builder.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 方法调用 Ant 构建器中的包含方法。'
- en: '`AntBuilder` can be used to script entire build files. It’s useful for creating
    a build file quickly, especially if you already know the corresponding Ant tasks
    well. Because `AntBuilder` is part of the standard Groovy library it can be used
    wherever you need to do build-related tasks. Even better, Gradle build files include
    an instance of `AntBuilder`, making the migration path from Ant to Gradle much
    simpler.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`AntBuilder` 可以用来编写整个构建文件。这对于快速创建构建文件非常有用，尤其是如果你已经非常熟悉相应的 Ant 任务。因为 `AntBuilder`
    是标准 Groovy 库的一部分，所以你可以在需要执行与构建相关的任务的地方使用它。更好的是，Gradle 构建文件包含一个 `AntBuilder` 实例，这使得从
    Ant 迁移到 Gradle 的路径变得更加简单。'
- en: A more interesting example is given in the next listing, which is a port of
    the original Ant build shown in [listing 5.1](#ch05ex01).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表提供了一个更有趣的示例，它是 [列表 5.1](#ch05ex01) 中显示的原始 Ant 构建的移植。
- en: Listing 5.7\. A Groovy `AntBuilder` script port of the build.xml file from [listing
    5.1](#ch05ex01)
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. 将 [列表 5.1](#ch05ex01) 中的 build.xml 文件移植到 Groovy `AntBuilder` 脚本
- en: '![](ch05ex07-0.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex07-0.jpg)'
- en: '![](ch05ex07-1.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex07-1.jpg)'
- en: You execute this script with the `groovy` command. Inside the `with` block,
    all methods like `mkdir`, `javac`, and `junit` are passed to the builder instance.
    Formally this means that the `delegate` property for the `with` block is the `AntBuilder`
    instance. Because this is a Groovy script you could add any code you wish to do
    other processing. It’s notoriously awkward do arrange loops and conditionals inside
    XML files, for instance, but here that would be easy.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `groovy` 命令来执行此脚本。在 `with` 块内部，所有像 `mkdir`、`javac` 和 `junit` 这样的方法都被传递给构建器实例。正式来说，这意味着
    `with` 块的 `delegate` 属性是 `AntBuilder` 实例。因为这是一个 Groovy 脚本，你可以添加任何你想要的代码来进行其他处理。例如，在
    XML 文件中安排循环和条件是众所周知的尴尬，但在这里这会变得很容易。
- en: For all of its simplicity, though, `AntBuilder` is still just Ant under the
    hood. Groovy wouldn’t be Groovy if there wasn’t a domain-specific language (DSL)
    alternative. The best of breed is Gradle, which is discussed later in this chapter.
    There’s another approach, however, which you may encounter in practice. For completeness
    the next subsection contains a brief discussion of Groovy Ant, known as Gant.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`AntBuilder` 在底层仍然是 Ant。如果没有特定领域的语言（DSL）替代品，Groovy 就不会是 Groovy。在本章后面将讨论的
    Gradle 是最佳选择。然而，在实践中你可能会遇到另一种方法。为了完整性，下一个子节简要讨论了 Groovy Ant，也称为 Gant。
- en: 5.3.4\. Custom build scripts with Gant
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.4\. 使用 Gant 创建自定义构建脚本
- en: Although the future of build files in Groovy belongs to Gradle, Gant still occupies
    one special niche in the Groovy ecosystem. As of this writing, the latest version
    of the Grails framework (2.3)^([[3](#ch05fn03)]) still implements its build scripts
    in Gant.^([[4](#ch05fn04)]) If you need to create a custom build script for a
    Grails application, Gant is still useful. If you’re not planning to do that, you
    can comfortably skip this subsection.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Groovy 中构建文件的未来属于 Gradle，但 Gant 仍然在 Groovy 生态系统中占据一个特殊的细分市场。截至本文写作时，Grails
    框架的最新版本（2.3）^([[3](#ch05fn03)]) 仍然使用 Gant 实现其构建脚本.^([[4](#ch05fn04)）。如果你需要为 Grails
    应用程序创建自定义构建脚本，Gant 仍然是有用的。如果你不打算这样做，你可以舒适地跳过这个子节。
- en: ³ Grails is discussed in chapter 8 on databases and chapter 10 on web development.
    The home page for Grails is [http://grails.org](http://grails.org).
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ Grails 在第 8 章数据库和第 10 章网络开发中被讨论。Grails 的主页是 [http://grails.org](http://grails.org)。
- en: ⁴ Gant will continue to be included in Grails through at least version 2.3.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ Gant 将至少在 Grails 2.3 版本中继续被包含。
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Gant Use Case
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Gant 用例
- en: Grails commands are implemented as Gant scripts, so if you need to customize
    a Grails command or create a new one, Gant is the tool of choice.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 命令作为 Gant 脚本实现，所以如果你需要自定义一个 Grails 命令或创建一个新的命令，Gant 是首选的工具。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Gant scripts in Grails are also an excellent choice of sample code. To keep
    this section simple I’ll review parts of an existing Grails Gant script, called
    `Clean.groovy`. The script can be found in the scripts directory under the root
    of the Grails distribution. As with all Grails Gant scripts, it’s invoked using
    the script name in lowercase, substituting dashes for camel case; so for the `Clean`
    script the command would be `grails` `clean`, and for the `CreateDomainObject`
    script the command is `grails` `cre``ate-domain-object`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 中的 Gant 脚本也是一个极好的示例代码选择。为了使本节内容简单，我将回顾一个现有的 Grails Gant 脚本的一部分，名为 `Clean.groovy`。该脚本位于
    Grails 发行版的根目录下的 scripts 目录中。与所有 Grails Gant 脚本一样，它通过小写脚本名来调用，将驼峰式命名替换为连字符；因此，对于
    `Clean` 脚本，命令将是 `grails clean`，而对于 `CreateDomainObject` 脚本，命令是 `grails create-domain-object`。
- en: 'Here’s the `Clean` script in its entirety (minus the copyright statement):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Clean`脚本的完整内容（不包括版权声明）：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `grailsScript` command loads a different Gant script, called `_GrailsClean`.
    By convention (and Grails is all about conventions), scripts that begin with an
    underscore are internal scripts that can’t be executed from the command line.
    The first line thus loads a series of tasks, and the second line makes the `cleanAll`
    task the default.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`grailsScript`命令加载了一个不同的Gant脚本，称为`_GrailsClean`。按照惯例（Grails的一切都是关于惯例），以下划线开头的脚本是内部脚本，不能从命令行执行。因此，第一行加载了一系列任务，第二行将`cleanAll`任务设置为默认任务。'
- en: 'Turning now to the `_GrailsClean` script, let me highlight a couple of small
    sections from it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转向`_GrailsClean`脚本，让我从其中突出几个小节：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The resemblance to Ant is not accidental. Gant scripts contain targets, and
    targets can be invoked as though they were method calls. Here the target defined
    with the name `cleanAll` invokes two other tasks (`clean` and `cleanTestReports`)
    and then invokes the `updateStatus` method on the predefined `grailsConsole` object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与Ant的相似性并非偶然。Gant脚本包含目标，目标可以被调用，就像方法调用一样。在这里，名为`cleanAll`的目标调用了两个其他任务（`clean`和`cleanTestReports`），然后调用了预定义的`grailsConsole`对象上的`updateStatus`方法。
- en: 'The `clean` task uses the `depends` method (again analogous to the same functionality
    in Ant) to make sure that the `cleanCompiledSources` and `cleanWarFile` tasks
    are invoked when the `clean` task is invoked. Here’s a snippet from the `cleanCompiledSources`
    task:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean`任务使用`depends`方法（再次类似于Ant中的相同功能）来确保在调用`clean`任务时调用`cleanCompiledSources`和`cleanWarFile`任务。以下是`cleanCompiledSources`任务的片段：'
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The task goes on to delete many more items, delegating to an internal `AntBuilder`
    object in each case. The `cleanWarFile` task shows how you can mix in Groovy logic
    code inside a script:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 任务继续删除更多项目，每次都委托给一个内部的`AntBuilder`对象。`cleanWarFile`任务展示了如何在脚本中混合Groovy逻辑代码：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is straightforward Groovy code that simply defines some variables and sets
    their properties based on the current configuration, and then invokes the `delete`
    method on the `ant` object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段简单的Groovy代码，它只是定义了一些变量，并根据当前配置设置它们的属性，然后对`ant`对象调用`delete`方法。
- en: That’s enough Gant for this book.^([[5](#ch05fn05)])
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书关于Gant的内容就到这里了.^([[5](#ch05fn05)])
- en: ⁵ Additional information on Gant can be found at the Groovy website. There’s
    also a decent tutorial in the book *Grails in Action* (Manning, 2009), by Peter
    Ledbrook and Glen Smith. Finally, the Grails user guide has a section on creating
    Gant scripts specifically for Grails.
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵有关Gant的更多信息，可以在Groovy网站上找到。在Peter Ledbrook和Glen Smith合著的书籍*Grails in Action*（Manning，2009）中也有一个不错的教程。最后，Grails用户指南有一个专门关于创建Gant脚本的章节。
- en: 5.3.5\. Ant summary
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.5. Ant总结
- en: That also concludes the discussion of Ant and Ant-based approaches, both in
    Java and Groovy. The “Lessons learned” sidebar shows the details.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这也结束了关于Ant和基于Ant的方法的讨论，无论是Java还是Groovy。在“经验教训”侧边栏中显示了详细信息。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (Ant)**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**经验教训（Ant）**'
- en: If you have an existing Ant build, you can add `<groovyc>` and `<groovy>` tasks
    to it.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你有一个现有的Ant构建，你可以向其中添加`<groovyc>`和`<groovy>`任务。
- en: Gant is only used by Grails, and not for very much longer.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gant只用于Grails，并且不会使用很长时间。
- en: '`AntBuilder` is rare by itself but is built into and useful in Gradle'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AntBuilder`本身很少见，但它内置在Gradle中，并且非常有用'
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'It’s time now to examine the other major build tool in the Java world: Maven.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候检查Java世界中的另一个主要构建工具：Maven了。
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Ant limitations**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ant的局限性**'
- en: When it was released Ant was a major improvement over previous build processes.
    Still, it has major issues that complicate life, especially in larger builds.
    Here’s a brief list of complexities associated with using Ant. This is not intended
    to be a criticism of Ant, but rather to highlight the issues that lead to the
    next-generation tools.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当它发布时，Ant是比之前的构建过程的一个重大改进。然而，它仍然存在一些主要问题，这些问题使得生活复杂化，尤其是在较大的构建中。以下是使用Ant时与复杂性相关的一些简要列表。这并不是对Ant的批评，而是为了突出导致下一代工具的问题。
- en: '*Ant builds are based* *on XML*, *and XML is not a scripting language.* Builds
    inevitably need to be customized and usually vary depending on whether the project
    is in development, test, or production mode. Ant allows you to set properties,
    but properties aren’t variables. It’s especially difficult to do complex branching
    logic in an XML file.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ant 构建基于 XML*，*而 XML 不是一个脚本语言*。构建不可避免地需要定制，并且通常取决于项目是在开发、测试还是生产模式。Ant 允许你设置属性，但属性不是变量。在
    XML 文件中执行复杂的分支逻辑尤其困难。'
- en: '*Ant says nothing about* *dependency management*. It assumes you have all the
    required libraries available and that you can build a file set to hold them and
    use that as your classpath. The Ivy project (also from Apache) fills that gap,
    and the combination of Ant and Ivy is much more common now than Ant alone.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ant 没有提及* *依赖管理*。它假设你已经有所有必需的库可用，并且你可以构建一个文件集来保存它们，并将其用作类路径。Ivy 项目（也是来自 Apache）填补了这一空白，现在
    Ant 和 Ivy 的组合比单独使用 Ant 更为常见。'
- en: '*XML was designed to be processed by programs, not people*. Reading a short
    XML file isn’t hard. Reading a long, involved one is, and even the trivial build
    file presented in this section is over 50 lines long when a few basic tasks are
    included.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*XML 是为了被程序处理而设计的，而不是给人阅读的*。阅读一个简短的 XML 文件并不难。阅读一个长而复杂的文件就困难多了，甚至在这个章节中展示的简单构建文件，当包含一些基本任务时，也有超过
    50 行长。'
- en: '*The built-in Ant tasks are very low level*. As a result, Ant build files quickly
    grow long and complex and involve a lot of repetition.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*内置的 Ant 任务非常低级*。因此，Ant 构建文件很快就会变得又长又复杂，并且涉及大量的重复。'
- en: For all these reasons and others Ant was ripe for a higher-level replacement.
    That role was filled by the Maven project, which is either a blessing or a curse
    depending on your experiences with it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因以及其他原因，Ant 已经准备好被一个更高级别的替代品所取代。这个角色由 Maven 项目填补，这取决于你对它的经验，要么是祝福，要么是诅咒。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '5.4\. The Java approach, part 2: Maven'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. Java 方法，第二部分：Maven
- en: I’m going to confess up front that Maven is hard to talk about rationally. Its
    best features (establishing a conventional project layout, managing dependencies,
    providing a rich plugin architecture) are also considered some of its worst features
    (difficult to work outside its conventions, hard to manage transitive dependencies,
    the whole “download the internet” problem). I can honestly say I’ve never encountered
    a technology that’s both common in the industry and yet loathed with the white-hot
    intensity of a thousand suns.^([[6](#ch05fn06)]) Bring up Maven in a group of
    developers, and someone will refuse to discuss “the M word.” Yet, at the same
    time, somebody else will quietly say that they can make it do anything and don’t
    understand what all the fuss is about.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '我将坦白地说 Maven 很难理性地讨论。它的最佳特性（建立传统项目布局、管理依赖项、提供丰富的插件架构）也被认为是最糟糕的特性（难以在其约定之外工作、难以管理传递依赖项、整个“下载整个互联网”问题）。我可以诚实地说我从未遇到过一种在行业中普遍存在，却又被像一千个太阳一样炽热地憎恨的技术。在开发者群体中提起
    Maven，有人会拒绝讨论“M 话题”。然而，与此同时，另一个人会悄悄地说他们可以让它做任何事情，并且不理解为什么会有这么大的争议。 '
- en: ⁶ Except possibly for every Microsoft technology ever.
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 除非是每一个微软技术。
- en: My own experience isn’t so black-and-white. I find that if a project was designed
    using Maven from the beginning, it tends to work well with the system. It’s also
    hard to use that system without Maven. On the other hand, adding Maven to a system
    that wasn’t started with it can be quite painful. In addition, friends have also
    assured me that once a system gets above a certain size, the whole process becomes
    an unmanageable mess.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己的经验并非如此黑白分明。我发现，如果一个项目从一开始就使用 Maven 设计，它通常与系统配合得很好。没有 Maven 也很难使用那个系统。另一方面，将
    Maven 添加到一个没有从它开始的项目中可能会相当痛苦。此外，朋友们也向我保证，一旦系统规模超过一定程度，整个过程就会变得难以管理。
- en: Perhaps the best way to stay above the fray is to say that Maven has a highly
    opinionated API. To be successful you have to do things the Maven way. Plus, like
    Ant, you’re coding your build in XML, which is never easy. The multi-project build
    capabilities are awkward, too.^([[7](#ch05fn07)])
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最好的办法是说明 Maven 有一个高度意见化的 API。为了成功，你必须按照 Maven 的方式做事。此外，就像 Ant 一样，你是在 XML 中编写构建代码，这从来都不是一件容易的事。多项目构建功能也很尴尬。^([[7](#ch05fn07)])
- en: ⁷ Admittedly that doesn’t sound terribly “above the fray,” but at least I’m
    trying.
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 虽然这听起来并不太“超然”，但至少我在尝试。
- en: I will note that the standard Maven project layout (shown in [figure 5.2](#ch05fig02))
    has become common throughout the industry. Also, people may complain about Maven’s
    approach to dependency management, but I haven’t seen anything dramatically better.
    Gradle (the proposed replacement, discussed later in this chapter) uses Maven
    repositories and Ivy dependency management and suffers from the same “download
    the internet” problem. Dependency management is just hard, no matter how you approach
    it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我要指出，标准的 Maven 项目布局（如图 5.2 所示）在业界已经变得很普遍。此外，人们可能会对 Maven 的依赖管理方法提出抱怨，但我还没有看到任何显著更好的方法。Gradle（本章后面将讨论的替代品）使用
    Maven 仓库和 Ivy 依赖管理，并遭受相同的“从互联网下载”问题。无论你如何处理，依赖管理都是一件困难的事情。
- en: Figure 5.2\. Standard Maven project structure used for the application in this
    section. Compiled sources are in src/main/java, and tests reside in src/test/java.
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. 本节中应用程序使用的标准 Maven 项目结构。编译后的源代码位于 src/main/java，测试代码位于 src/test/java。
- en: '![](05fig02.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig02.jpg)'
- en: Returning (at last) to the core theme of this book, the goal of this section
    is to show you how to incorporate Groovy into Maven builds. There are two ways
    to do that. I’ll start with the Groovy-Eclipse plugin and then build the same
    application using the GMaven project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（终于）到本书的核心主题，本节的目标是向您展示如何将 Groovy 集成到 Maven 构建中。有两种方法可以实现这一点。我将从 Groovy-Eclipse
    插件开始，然后使用 GMaven 项目构建相同的应用程序。
- en: 5.4.1\. The Groovy-Eclipse plugin for Maven
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. Maven 的 Groovy-Eclipse 插件
- en: The Groovy-Eclipse compiler plugin ([http://mng.bz/2rHY](http://mng.bz/2rHY))
    is a standard compiler plugin for Maven. It emerged from the effort to build a
    good Eclipse plugin for Groovy that worked with combined Groovy and Java projects.
    The Maven plugin is a way to take advantage of that effort, whether you plan to
    use the Eclipse IDE or not.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: The Groovy-Eclipse compiler plugin ([http://mng.bz/2rHY](http://mng.bz/2rHY))
    is a standard compiler plugin for Maven. It emerged from the effort to build a
    good Eclipse plugin for Groovy that worked with combined Groovy and Java projects.
    The Maven plugin is a way to take advantage of that effort, whether you plan to
    use the Eclipse IDE or not.
- en: To demonstrate its use I’ll build a small project that accesses the Yahoo! Weather
    web service and reports on the current conditions. This is easy enough to do in
    Java but becomes particularly simple in Groovy.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示其用法，我将构建一个小项目，该项目访问 Yahoo！天气网络服务并报告当前条件。这用 Java 做起来足够简单，但在 Groovy 中则变得特别简单。
- en: The Yahoo! Weather web service ([http://developer.yahoo.com/weather/](http://developer.yahoo.com/weather/))
    provides weather information in the form of an RSS feed. The web service is accessed
    from a URL of the form
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: The Yahoo! Weather web service ([http://developer.yahoo.com/weather/](http://developer.yahoo.com/weather/))
    provides weather information in the form of an RSS feed. The web service is accessed
    from a URL of the form
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The URL has two parameters, one required and one optional. The required parameter
    is `w`, a so-called WOEID (Where On Earth ID), that Yahoo uses to identify a location.
    The other parameter is `u`, which is used to specify the temperature units in
    Fahrenheit (`f`, the default) or Celsius (`c`). For unknown reasons, there’s no
    way to programmatically look up a WOEID. Instead Yahoo! directs you to its own
    weather page and suggests you search for your city.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: The URL has two parameters, one required and one optional. The required parameter
    is `w`, a so-called WOEID (Where On Earth ID), that Yahoo uses to identify a location.
    The other parameter is `u`, which is used to specify the temperature units in
    Fahrenheit (`f`, the default) or Celsius (`c`). For unknown reasons, there’s no
    way to programmatically look up a WOEID. Instead Yahoo! directs you to its own
    weather page and suggests you search for your city.
- en: A simple HTTP GET request to the proper URL returns an XML response in RSS form.
    A sample is included on Yahoo!’s web page.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 向正确的 URL 发送一个简单的 HTTP GET 请求会返回一个 RSS 格式的 XML 响应。一个示例包含在 Yahoo！的网页上。
- en: 'Suppose I decided to build a simple application to retrieve the current weather
    conditions based on this service. Maven recommends that you specify a particular
    artifact to begin the project, so I’ll start with the classic `maven-archetype-quickstart`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我决定构建一个简单的应用程序来检索基于此服务的当前天气条件。Maven 建议您指定一个特定的工件以开始项目，所以我将使用经典的 `maven-archetype-quickstart`：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Maven archetypes
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Maven 架构
- en: The Groovy-Eclipse plugin uses regular Java archetypes and adds Groovy functionality.
    The GMaven approach in the next section includes a basic archetype to get started.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: The Groovy-Eclipse plugin uses regular Java archetypes and adds Groovy functionality.
    The GMaven approach in the next section includes a basic archetype to get started.
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This generates a Java project with the standard layout, meaning the source code
    directory is src/main/java and the testing directory is src/test/java. The quick
    start archetype includes a trivial App.java and AppTest.java in those directories,
    respectively. The generator also adds a standard Maven POM file in the root directory,
    whose only dependency is on JUnit, as shown in the next listing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个具有标准布局的Java项目，这意味着源代码目录是src/main/java，测试目录是src/test/java。快速入门原型在这些目录中分别包含一个简单的App.java和AppTest.java，生成器还在根目录中添加了一个标准的Maven
    POM文件，其唯一依赖项是JUnit，如下一列表所示。
- en: Listing 5.8\. The Maven pom.xml file for a standard Java project
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8\. 标准Java项目的Maven pom.xml文件
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only change I’ve made so far from the standard is to upgrade the JUnit dependency
    to 4.10 from 3.8.1.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我到目前为止所做的唯一更改是将JUnit依赖项从3.8.1升级到4.10。
- en: To do the actual work I need a class to send the request to Yahoo and parse
    the response, and a POJO to hold the resulting weather information. Starting with
    the POJO, for a given city, region, and country I want to store the condition,
    temperature, wind chill, and humidity. The web service returns a lot more information
    than this, but this will suffice to get started.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成实际工作，我需要一个发送请求到Yahoo并解析响应的类，以及一个用于存储生成的天气信息的POJO。从POJO开始，对于一个给定的城市、地区和国家，我想存储条件、温度、风寒和湿度。Web服务返回的信息比这多得多，但这足以开始。
- en: POJOs are simple containers for data, so the constructors, getter and setter
    methods, and any necessary overrides are mostly clutter. I can therefore simplify
    my life if I use a POGO instead, as shown in the following listing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: POJOs是简单的数据容器，因此构造函数、getter和setter方法以及任何必要的覆盖方法大多是杂乱无章的。因此，如果使用POGO，我可以简化我的生活，如下一列表所示。
- en: Listing 5.9\. `Weather.groovy`, a POGO to hold weather results from the web
    service
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.9\. `Weather.groovy`，一个用于存储来自Web服务的天气结果的POGO
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `toString` method is a way to produce formatted output. Groovy’s multiline
    string makes it particularly easy.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString`方法是一种生成格式化输出的方式。Groovy的多行字符串使得这特别容易。'
- en: The other class I need is a parser for the web service. Because all I need is
    a GET request I can use the `parse` method in the `XmlSlurper` class as usual
    and drill down the resulting DOM tree to get the results I want. That’s pretty
    simple, too, as shown in the following listing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要的另一个类是Web服务的解析器。因为我只需要一个GET请求，所以我可以像往常一样使用`XmlSlurper`类的`parse`方法，并钻入生成的DOM树以获取我想要的结果。这也很简单，如下一列表所示。
- en: Listing 5.10\. `YahooParser.groovy`, which accesses and parses the weather service
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.10\. `YahooParser.groovy`，它访问并解析天气服务
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Given a WOEID, the service builds the URL and accesses the web service, parses
    the resulting RSS, and returns an instance of the `Weather` class with all the
    relevant fields populated.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个WOEID，服务构建URL并访问Web服务，解析生成的RSS，并返回一个包含所有相关字段的`Weather`类的实例。
- en: 'To complete the program I need a driver, which I can write as a Groovy script.
    That’s a one-liner, unless I want to allow the client to specify a WOEID on the
    command line:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成程序，我需要一个驱动程序，我可以将其编写为Groovy脚本。除非我想允许客户端在命令行上指定WOEID，否则这是一个单行命令：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The default WOEID in the script is for Boston, MA, and it’s stored in `RunDemo.groovy`.
    In order to demonstrate the differences when both Java and Groovy sources are
    present together, I also added a Java class to access the web service in the file
    RunInJava.java:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的默认WOEID是波士顿，马萨诸塞州，并存储在`RunDemo.groovy`中。为了演示当Java和Groovy源文件同时存在时的差异，我还添加了一个Java类来访问Web服务，该类存储在`RunInJava.java`文件中：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now comes the interesting part: how do I get Maven to handle all the Groovy
    code? The Groovy-Eclipse plugin requires two additions to the POM file. First
    I need to add Groovy as a dependency:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分：我该如何让Maven处理所有的Groovy代码？Groovy-Eclipse插件需要向POM文件添加两个修改。首先，我需要将Groovy添加为依赖项：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next I need to add the Groovy-Eclipse plugin in a `build` section below the
    dependencies:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我需要在依赖项下方的`build`部分添加Groovy-Eclipse插件：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With both of these additions Maven will compile and use Groovy code appropriately,
    except for one rather strange oddity. Normally I would add my Groovy classes to
    src/main/groovy and any Groovy tests to src/test/groovy. According to the plugin
    documentation, I can do that only if (1) there’s at least one Java class in src/main/java
    or (2) I add a lot more XML to specify the additional source directories.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个添加之后，Maven 将适当地编译和使用 Groovy 代码，除了一个相当奇怪的问题。通常我会将我的 Groovy 类添加到 src/main/groovy，并将任何
    Groovy 测试添加到 src/test/groovy。根据插件文档，我只能在以下情况下这样做：（1）src/main/java 中至少有一个 Java
    类，或者（2）我添加更多的 XML 来指定额外的源目录。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Source directories
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 源目录
- en: For the Groovy-Eclipse plugin, put Java and Groovy sources in the src/main/java
    and src/test/java directories by default.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Groovy-Eclipse 插件，默认情况下，将 Java 和 Groovy 源文件放在 src/main/java 和 src/test/java
    目录中。
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: I put my Groovy files in src/main/java and src/test/java. Now I can build the
    project using
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的 Groovy 文件放在 src/main/java 和 src/test/java。现在我可以使用以下方式构建项目：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I can even execute the project using the `exec:java` (!) task, both using the
    default WOEID and with a supplied command-line argument:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至可以使用 `exec:java` (!) 任务执行项目，无论是使用默认的 WOEID 还是提供命令行参数：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I can supply a command-line argument using `–Dexec.args`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用 `–Dexec.args` 来提供一个命令行参数：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A guiding principle in this book is that Java is good at tools, libraries, and
    (existing) infrastructure, and that Groovy is good at everything else. It’s hard
    to imagine a better demonstration of that than the current example. The entire
    application was written in Groovy, at a code savings on the order of 10 to 1\.
    The infrastructure treated the code as though it was all Java, and I was even
    able to use the Java `exec` task to execute the Groovy script to drive the application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个指导原则是，Java 在工具、库和（现有）基础设施方面做得很好，而 Groovy 在其他所有方面都做得很好。很难想象比当前示例更好的证明。整个应用程序都是用
    Groovy 编写的，代码节省量在 10 到 1 的数量级。基础设施将代码视为全部是 Java，我甚至能够使用 Java 的 `exec` 任务来执行 Groovy
    脚本以驱动应用程序。
- en: The Groovy-Eclipse compiler plugin is a funded project, because it’s used inside
    the IDEs provided by SpringSource (a division of VMware).^([[8](#ch05fn08)]) The
    quality of the plugin, especially for cross-compilation, is therefore quite high.
    Just because it has the name “Eclipse” wired into it, there’s no reason not to
    use it in a Maven project. There’s no implication that the plugin is exclusive
    to the IDE. You can use it anywhere, as I did with the Maven project in this section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy-Eclipse 编译器插件是一个资助项目，因为它被用于 SpringSource（VMware 的一个部门）提供的 IDE 中。因此，该插件的质量，特别是对于交叉编译，相当高。仅仅因为它名字中有“Eclipse”，并不意味着不能在
    Maven 项目中使用它。插件并不是 IDE 独有的。你可以用它来任何地方，就像我在本节中用 Maven 项目做的那样。
- en: ⁸ Now part of Pivotal, which is owned by VMware, which is owned by EMC...
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 现在是 Pivotal 的一部分，由 VMware 拥有，而 VMware 又由 EMC 拥有...
- en: The other way to add Groovy to a project built with Maven is to use the GMaven
    project, discussed in the next section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Groovy 添加到使用 Maven 构建的项目中的另一种方法是使用 GMaven 项目，这在下一节中讨论。
- en: 5.4.2\. The GMaven project
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. GMaven 项目
- en: GMaven is an alternative approach for adding Groovy into Maven projects. It
    works with combined Java and Groovy sources by generating stubs for the Groovy
    files as part of the build sequence.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: GMaven 是将 Groovy 添加到 Maven 项目的另一种方法。它通过在构建序列中生成 Groovy 文件的存根，与结合 Java 和 Groovy
    的源文件一起工作。
- en: 'To help users get started, the project provides a Maven archetype called `gmaven-archetype-basic`.
    To use the archetype, execute the following at the command line:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助用户入门，项目提供了一个名为 `gmaven-archetype-basic` 的 Maven 架构。要使用该架构，请在命令行中执行以下操作：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This again produces a project in standard Maven structure, in which the sources
    are in src/main/groovy and the tests are in src/test/groovy. The plugin expects
    both Java and Groovy sources to reside in those directories.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这又产生了一个标准 Maven 结构的项目，其中源文件位于 src/main/groovy，测试文件位于 src/test/groovy。插件期望 Java
    和 Groovy 源文件都位于这些目录中。
- en: The generated POM is shown in the following listing, with some modifications
    discussed in the listing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 POM 如下所示，其中一些修改在列表中讨论。
- en: Listing 5.11\. The Maven pom.xml file produced by the GMaven project
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. GMaven 项目生成的 Maven pom.xml 文件
- en: '![](ch05ex11-0.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex11-0.jpg)'
- en: '![](ch05ex11-1.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex11-1.jpg)'
- en: The POM needs a Groovy dependency. It doesn’t have to be global, but it was
    just as easy to add it that way here. The provider was adjusted to 2.1.5 in order
    to use Groovy version 2.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: POM需要Groovy依赖项。它不必是全局的，但在这里添加它同样简单。提供者已调整为2.1.5，以便使用Groovy版本2。
- en: 'Building the system is done with a standard Maven `install`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的Maven `install`命令构建系统：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: During the build process, Java stubs are generated for each Groovy file. The
    stubs themselves are quite minimal; they’re only used to resolve the inter-language
    dependencies rather than execution. As an example, here’s a portion of the stub
    generated for the `Weather` class, whose Groovy implementation was shown in the
    previous section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，为每个Groovy文件生成Java占位符。这些占位符本身相当简单；它们仅用于解决跨语言依赖关系，而不是执行。例如，以下是之前章节中显示的`Weather`类的占位符的一部分。
- en: Listing 5.12\. Part of the Java stub generated from `Weather.groovy`
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.12\. 从`Weather.groovy`生成的Java占位符的一部分
- en: '![](112fig01_alt.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](112fig01_alt.jpg)'
- en: Any Java class can be treated as though it was Groovy source by implementing
    the `GroovyObject` interface, as the stub does here. The first five methods in
    the stub provide no-op implementations for all the methods in that interface.
    The rest of the stub consists of empty implementations for the remaining methods,
    which in this case are the getters and setters and the `toString` method.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Java类都可以通过实现`GroovyObject`接口来被视为Groovy源代码，就像这里的占位符所做的那样。占位符中的前五种方法为该接口中的所有方法提供了无操作实现。其余的占位符为剩余的方法提供了空实现，在这种情况下是获取器和设置器以及`toString`方法。
- en: 'The stub generated for the `RunDemo` class is slightly different, in an interesting
    way. The Groovy implementation is just a couple lines of scripting code. As noted
    in the demonstration in [chapter 3](kindle_split_013.html#ch03) where I executed
    a compiled Groovy script from the `java` command, every Groovy script is ultimately
    converted to a class by the compiler, and the corresponding RunDemo.java stub
    illustrates this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为`RunDemo`类生成的占位符略有不同，以一种有趣的方式。Groovy实现只是几行脚本代码。正如在第3章[演示](kindle_split_013.html#ch03)中提到的，我从`java`命令执行了一个编译后的Groovy脚本，每个Groovy脚本最终都会被编译器转换为一个类，相应的RunDemo.java占位符说明了这一点：
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The class extends `groovy.lang.Script`, has a default constructor and a constructor
    that takes a `groovy.lang.Binding`, a standard Java `main` method, and a `run`
    method. All Groovy scripts look like this to the JVM. Running the script is like
    executing the `main` method, which delegates to the `run` operation here.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 该类扩展了`groovy.lang.Script`，有一个默认构造函数和一个接受`groovy.lang.Binding`的构造函数，一个标准的Java
    `main`方法，以及一个`run`方法。所有Groovy脚本对JVM来说看起来都像这样。运行脚本就像执行`main`方法一样，它将委托给这里的`run`操作。
- en: 'As before, to run the program using the Maven you call the `exec:java` task
    with the right arguments. In this case that means the main class is either `RunDemo`
    or `RunInJava`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，要使用Maven运行程序，需要使用带有正确参数的`exec:java`任务。在这种情况下，这意味着主类是`RunDemo`或`RunInJava`：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Either way, the result is the same as in the previous section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，结果都与上一节相同。
- en: The GMaven project has been quiet recently, but it’s still alive. As demonstrated,
    the archetype works and the stub generation allows the plugin to delegate compilation
    to the standard Maven tools.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最近GMaven项目比较安静，但它仍然存在。正如所示，原型工作正常，占位符生成允许插件将编译委托给标准的Maven工具。
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (Maven)**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**教训（Maven）**'
- en: 'There are two separate ways to add Groovy to Maven builds, each with benefits
    and drawbacks: the “Groovy Eclipse” plugin and GMaven.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Groovy到Maven构建有两种独立的方式，每种方式都有其优点和缺点：“Groovy Eclipse”插件和GMaven。
- en: If at all possible, consider moving to Gradle.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能的话，考虑迁移到Gradle。
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.4.3\. Maven summary
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.3\. Maven总结
- en: 'There are two ways to add Groovy dependencies to a Maven project: the Groovy-Eclipse
    plugin and the GMaven project. My advice (which may change as the projects evolve)
    is'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 向Maven项目添加Groovy依赖有两种方式：Groovy-Eclipse插件和GMaven项目。我的建议（可能会随着项目的演变而改变）是
- en: '**1**.  For an already existing Maven build, add the Groovy-Eclipse plugin.
    It works, and a company that has a significant interest in the success of Groovy
    financially supports development of the plugin itself. The fact that the name
    includes the word *Eclipse* is irrelevant.'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  对于已经存在的Maven构建，添加Groovy-Eclipse插件。它有效，并且有一家公司从财务上支持插件本身的发展。名字中包含单词*Eclipse*并不重要。'
- en: '**2**.  For new projects either plugin will work, but the existence of a Maven
    archetype makes it particularly easy to get started with GMaven.'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 对于新项目，任一插件都可以工作，但 Maven 架构的存在使得 GMaven 的启动变得特别容易。'
- en: '**3**.  It’s quite interesting that both plugins expect Java and Groovy sources
    to reside together. There’s a significant integration lesson there somewhere.'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 真是很有趣，这两个插件都期望 Java 和 Groovy 源文件放在一起。这里有一个重要的集成课程。'
- en: 'Moving now from hybrid approaches to purely Groovy solutions, I’ll address
    first the short and sweet Grapes approach before moving to the real destination:
    Gradle.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从混合方法转向纯 Groovy 解决方案，我将首先介绍简洁的 Grape 方法，然后再转向真正的目的地：Gradle。
- en: 5.5\. Grapes and @Grab
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. Grape 和 @Grab
- en: The Grape mechanism allows you to declare library dependencies directly inside
    a Groovy script. This is useful when you need to deliver a script to a client
    that doesn’t already have the required dependencies but is willing to download
    them as part of the build process.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Grape 机制允许你在 Groovy 脚本中直接声明库依赖项。当你需要向客户端交付一个脚本，而客户端尚未拥有所需的依赖项，但愿意在构建过程中下载它们时，这很有用。
- en: The overall API is called Grape (Groovy Adaptable/Advanced Packaging Engine)
    and starts with the `groovy.lang.Grab` annotation. It uses an Ivy resolver to
    identify and download dependencies. Its primary use case is on scripts, so that
    they can be delivered to a client without any setup requirements other than having
    Groovy installed. At runtime Groovy will download and install any declared libraries
    and their transitive dependencies as part of the execution process.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 API 被称为 Grape（Groovy 可适应/高级打包引擎），并以 `groovy.lang.Grab` 注解开始。它使用 Ivy 解析器来识别和下载依赖项。它的主要用例是脚本，这样它们就可以在没有任何设置要求（除了安装
    Groovy）的情况下交付给客户端。在运行时，Groovy 将下载并安装任何声明的库及其传递依赖项，作为执行过程的一部分。
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Grape Use Case
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Grape 用例
- en: Grape allows you to deliver a simple script that can be executed by a client
    without any setup necessary other than installing Groovy, making it particularly
    convenient for testers or QA people.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Grape 允许你交付一个简单的脚本，客户端可以执行它，而无需进行任何设置，除了安装 Groovy，这使得它对于测试人员或 QA 人员特别方便。
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To demonstrate the Grape system, let me choose the Math library from the Apache
    Commons project ([http://commons.apache.org/math/](http://commons.apache.org/math/)).
    Specifically, I want to work with the complex numbers package. The package includes
    a class called `Complex`, which represents complex numbers. Although the class
    is interesting in itself, it also makes for a nice demonstration of Groovy’s metaprogramming
    capabilities.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 Grape 系统，让我选择 Apache Commons 项目中的 Math 库（[http://commons.apache.org/math/](http://commons.apache.org/math/)）。具体来说，我想使用复数包。该包包含一个名为
    `Complex` 的类，它表示复数。尽管这个类本身很有趣，但它也很好地展示了 Groovy 的元编程能力。
- en: 'In Maven syntax the library has a group ID of `org.apache.commons`, an artifact
    ID of `commons-math3`, and a version of 3.0\. Therefore, the format of the `@Grab`
    annotation is as shown in the following script:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Maven 语法中，该库的组 ID 为 `org.apache.commons`，工件 ID 为 `commons-math3`，版本为 3.0。因此，`@Grab`
    注解的格式如下所示：
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `@Grab` annotation downloads both the given library and its dependencies.
    The syntax uses Maven structure, using colons to connect the group ID, the artifact
    ID, and the version number. Alternatively, you can specify the sections individually:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Grab` 注解下载了给定的库及其依赖项。语法使用 Maven 结构，使用冒号连接组 ID、工件 ID 和版本号。或者，你可以单独指定部分：'
- en: '[PRE28]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The behavior is equivalent in either case.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 两种情况下的行为是等效的。
- en: There isn’t much more to Grapes than this. In order to show an interesting example
    that requires an external Java library, let me present a simple case of Groovy
    metaprogramming. There’s nothing about it that requires Grapes in particular,
    but it shows how a small amount of metaprogramming can make a Java library class
    groovier. Using Grapes in the script allows me to send it to a client without
    compiling it or providing the library dependencies. The Grape annotations will
    handle the rest.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，Grapes 没有什么更多了。为了展示一个需要外部 Java 库的有趣示例，让我提出一个简单的 Groovy 元编程案例。这并不特别需要 Grape，但它展示了少量的元编程如何使
    Java 库类更加 Groovy。在脚本中使用 Grape 允许我将其发送给客户端，而无需编译它或提供库依赖项。Grape 注解将处理其余部分。
- en: The `Complex` class represents a complex number, which combines real and imaginary
    parts. The class contains a two-argument constructor, as shown, that takes the
    real and imaginary parts as parameters. Many methods are defined on the class,
    so that it generalizes basic numerical computations to the complex domain.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Complex`类表示一个复数，它结合了实部和虚部。该类包含一个两个参数的构造函数，如所示，它接受实部和虚部作为参数。该类定义了许多方法，以便将基本的数值计算推广到复数域。'
- en: 'Recall that in Groovy every operator delegates to a method call. Interestingly
    enough, the `Complex` class already has a method called `multiply` for computing
    the product of two complex numbers. Because the `*` operator in Groovy uses the
    `multiply` method, that operator can be used immediately:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在Groovy中，每个操作符都委托给一个方法调用。有趣的是，`Complex`类已经有一个名为`multiply`的方法，用于计算两个复数的乘积。因为Groovy中的`*`操作符使用`multiply`方法，所以可以直接使用该操作符：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Again, this is a Java class. Fortunately, the developers of the class chose
    to include a method called `multiply`, so Groovy can use the `*` operator with
    complex numbers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个Java类。幸运的是，该类的开发者选择包含一个名为`multiply`的方法，因此Groovy可以使用`*`操作符与复数一起使用。
- en: What about all the other mathematical operations? Most don’t line up as cleanly.
    For example, the class uses `add` instead of `plus` and `subtract` instead of
    `minus`. It’s easy to connect them, however, by adding the appropriate methods
    to the metaclass associated with `Complex` when viewed through Groovy.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，其他所有数学运算呢？大多数都不那么整洁。例如，该类使用`add`而不是`plus`，使用`subtract`而不是`minus`。然而，通过向与`Complex`关联的元类添加适当的方法，可以轻松地将它们连接起来，通过Groovy查看。
- en: 'As a reminder, every class accessed through Groovy contains a metaclass, and
    the metaclass is an `Expando`. This means that methods and properties can be added
    to the metaclass as desired, and the resulting members will be part of any instantiated
    object. Here’s how to add several mathematical operations to `Complex`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，通过Groovy访问的每个类都包含一个元类，元类是一个`Expando`。这意味着可以按需向元类添加方法和属性，结果成员将属于任何实例化的对象。以下是如何向`Complex`添加几个数学运算的方法：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That takes care of the `+`, `-`, `/`, `**`, and negation operators, respectively.
    In each case, the relevant method is defined on the metaclass by setting it equal
    to a closure. The associated closure takes a `Complex` argument (in the case of
    binary operators) and invokes the desired existing method on the closure’s delegate,
    passing along the argument.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这就解决了`+`、`-`、`/`、`**`和取反操作符的问题。在每种情况下，相关的方法都是通过将闭包设置为等于一个闭包来定义在元类上的。相关的闭包接受一个`Complex`参数（在二元操作符的情况下）并在闭包的委托上调用所需的现有方法，同时传递参数。
- en: '|  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Closure Delegates
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 闭包委托
- en: Every closure has a `delegate` property. By default the delegate points to the
    object that the closure was invoked on.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每个闭包都有一个`delegate`属性。默认情况下，委托指向闭包被调用的对象。
- en: '|  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'After adding those methods to the metaclass, the operators can be used in the
    Groovy script:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这些方法添加到元类之后，可以在Groovy脚本中使用操作符：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To complete this part of the story I want to demonstrate the famous equation
    known as Euler’s identity,^([[9](#ch05fn09)]) which is expressed as
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个故事的一部分，我想展示著名的欧拉恒等式，这个恒等式被称为欧拉公式，^([[9](#ch05fn09)])，它表达为
- en: ⁹ Leonhard Euler (1707 – 1783) was one of the most brilliant mathematicians
    of all time. His work spanned virtually every field of math and science, and his
    collected works filled between 60 and 80 quarto volumes. The transcendental number
    `e` is named after him.
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 莱昂哈德·欧拉（1707 – 1783）是有史以来最杰出的数学家之一。他的工作几乎涵盖了数学和科学的每一个领域，他的全集占据了60到80个四开本。超越数`e`是以他的名字命名的。
- en: '*e*^(*iπ*)=–1'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*^(*iπ*)=–1'
- en: This equation connects the imaginary numbers (*i*) and the transcendental numbers
    (*e* and *π*) to the negative numbers (–1). Euler found this expression so profound
    he had it inscribed on his tombstone.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个等式将虚数（*i*）、超越数（*e*和*π*）与负数（–1）联系起来。欧拉认为这个表达式非常深刻，以至于他在自己的墓碑上刻下了它。
- en: The `java.lang.Math` class contains constants `Math.E` and `Math.PI`, and the
    `Complex` class has the constant `Complex.I`. To make the formula look better
    I’ll use static imports for all of them.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.Math`类包含常量`Math.E`和`Math.PI`，而`Complex`类有常量`Complex.I`。为了使公式看起来更好，我将使用静态导入来导入它们。'
- en: 'One final addition is necessary to make this work. `Math.E` in Java is of type
    double, and I want to raise it to a `Complex` power. The easiest way to do that
    is to convert the double to an instance of the `Complex` class and then use the
    `pow` method in the `Complex` class. Returning to Groovy metaprogramming, I need
    a `power` method (which corresponds to the `**` operator) on `Double` that takes
    a `Complex` argument:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 需要最后添加一个功能才能使其工作。Java中的`Math.E`是double类型，我想将其提升到`Complex`的幂。最简单的方法是将double转换为`Complex`类的实例，然后使用`Complex`类中的`pow`方法。回到Groovy元编程，我需要一个`power`方法（对应于`**`运算符），它接受一个`Complex`参数：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With all that machinery in place the resulting code is a bit anticlimactic,
    but that’s a good thing:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些机制就绪后，生成的代码略显平淡，但这是一件好事：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As usual in Groovy, accessing the `real` or `imaginary` property is equivalent
    to calling the `getReal` or `getImaginary` method, respectively. The expression
    does generate a real part of –1, but the imaginary part isn’t exactly zero due
    to the round-off error associated with Java doubles. On my machine it evaluates
    to a number less than the bound shown, which is certainly close enough.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，通常访问`real`或`imaginary`属性相当于调用`getReal`或`getImaginary`方法。该表达式确实生成了-1的实部，但由于与Java双精度浮点数相关的舍入误差，虚部并不正好为零。在我的机器上，它评估为一个小于显示边界的数字，这当然足够接近了。
- en: 'There are a few additional annotations available in the Grapes system. One
    is `@GrabConfig`, used in the next example when loading a database driver. The
    following script uses the `groovy.sql.Sql` class to generate an H2 database and
    add some data to it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grapes系统中还有一些额外的注释可用。其中一个是`@GrabConfig`，在下一个示例中用于加载数据库驱动程序。以下脚本使用`groovy.sql.Sql`类生成一个H2数据库并向其中添加一些数据：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The annotations provide the driver, so the `Sql` class can be used normally.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注释提供了驱动程序，因此可以使用`Sql`类正常工作。
- en: Because a member of a class can only have a single instance of a particular
    annotation, the `@Grapes` annotation is used to combine multiple `@Grab` annotations.
    The next listing computes complex values and stores them in a database table.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类的成员只能有一个特定注释的单例，因此使用`@Grapes`注释来组合多个`@Grab`注释。下一个列表计算复数值并将它们存储在数据库表中。
- en: Listing 5.13\. Using Apache Commons Math and a database driver together
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.13. 使用Apache Commons Math和数据库驱动程序一起
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The script creates a table to hold x and y coordinates at 20 points along a
    circle. The `ComplexUtils.polar2Complex` method takes a radius (here using one
    for simplicity) and an angle (in radians) along the circle and generates a complex
    number, which is then stored in the database.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本创建了一个表格，用于存储圆周上20个点的x和y坐标。`ComplexUtils.polar2Complex`方法接受一个半径（这里为了简单起见使用一个半径）和一个圆周上的角度（以弧度为单位），并生成一个复数，然后将其存储在数据库中。
- en: The Grapes system is simple and effective, but limited in practice. The additions
    work in a script, but for a larger system it’s more common to use a full-scale
    build tool, like Gradle, which is the subject of the next section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Grapes系统简单有效，但在实践中有限制。这些添加在脚本中工作，但对于更大的系统，更常见的是使用完整的构建工具，如Gradle，这是下一节的主题。
- en: 5.6\. The Gradle build system
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6. Gradle构建系统
- en: Gradle is proposed as a next-generation build solution. Gradle combines the
    flexibility of Groovy builds with a powerful domain-specific language (DSL) that
    configures a rich set of classes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 提议Gradle作为下一代构建解决方案。Gradle结合了Groovy构建的灵活性以及一个强大的领域特定语言（DSL），它可以配置丰富的类集。
- en: As with virtually all Groovy projects of any significant size, Gradle is written
    in both Java and Groovy. Gradle is essentially a DSL for builds.^([[10](#ch05fn10)])
    It defines a language of syntax and semantics that allows you to write a build
    file quickly and easily.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与几乎所有有意义的Groovy项目一样，Gradle是用Java和Groovy编写的。Gradle本质上是一个用于构建的DSL。[10](#ch05fn10)
    它定义了一种语法和语义的语言，允许你快速轻松地编写构建文件。
- en: '^(10) Mandatory DSL jokes: “JavaScript is a DSL for finding browser bugs”;
    “Java is a DSL for generating stack traces”; “Maven is a DSL for downloading the
    internet.”'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([10] 必须的DSL笑话：“JavaScript是用于查找浏览器错误的DSL”；“Java是用于生成堆栈跟踪的DSL”；“Maven是用于下载互联网的DSL。”)
- en: Gradle doesn’t come with an installer. Instead you just download a ZIP file,
    set the `GRADLE_HOME` environment variable to wherever you unzip it, and add the
    $GRADLE_ HOME/bin directory to your path, and you’re ready to go. In fact, you
    don’t even need to install Groovy first, because Gradle comes with its own version
    of Groovy.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 不附带安装程序。你只需下载一个 ZIP 文件，将 `GRADLE_HOME` 环境变量设置为解压缩的位置，并将 `$GRADLE_HOME/bin`
    目录添加到你的路径中，你就可以开始了。实际上，你甚至不需要先安装 Groovy，因为 Gradle 自带其自己的 Groovy 版本。
- en: '|  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How projects in the Groovy ecosystem include Groovy**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**Groovy生态系统中的项目如何包含Groovy**'
- en: One of the dirty little secrets of Groovy is that the major versions are not
    always binary compatible. Code compiled with one version doesn’t necessarily work
    with any other.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 的一个不为人知的秘密是，主版本并不总是二进制兼容的。用某个版本编译的代码不一定与任何其他版本兼容。
- en: This means that projects in the Groovy ecosystem have a choice. They can either
    be compiled with different versions of Groovy and make the Groovy version number
    part of their own version, or they can bundle in a particular version of Groovy.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Groovy 生态系统中的项目有选择权。它们可以选择用不同版本的 Groovy 进行编译，并将 Groovy 版本号作为它们自己版本的一部分，或者它们可以捆绑一个特定的
    Groovy 版本。
- en: The Spock framework (discussed in [chapter 6](kindle_split_017.html#ch06)) takes
    the former approach. Spock versions are in the form 0.7-groovy-2.0, meaning Spock
    version 0.7 compiled with Groovy version 2.0.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Spock 框架（在第 6 章中讨论）采取了前一种方法。Spock 版本的形式为 0.7-groovy-2.0，这意味着 Spock 版本 0.7 是用
    Groovy 版本 2.0 编译的。
- en: The Grails and Gradle projects take the other approach. Grails 1.3.9, for example,
    includes a copy of Groovy 1.7.8, Grails 2.0.3 includes Groovy 1.8.6, and Grails
    2.2.1 includes Groovy 2.0.8\. To see the Groovy version included in your Gradle
    distribution, run the `gradle` `–v` command.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 和 Gradle 项目采取了另一种方法。例如，Grails 1.3.9 包含了 Groovy 1.7.8 的副本，Grails 2.0.3
    包含 Groovy 1.8.6，而 Grails 2.2.1 包含 Groovy 2.0.8。要查看 Gradle 分发版中包含的 Groovy 版本，请运行
    `gradle –v` 命令。
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For Grails, the bundled Groovy version locks you into that version for the entire
    application. For Gradle, however, the bundled Groovy version is used only to execute
    the build script itself. You’re free to use any version of Groovy in your own
    projects, and Gradle will correctly build them.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Grails 来说，捆绑的 Groovy 版本会将整个应用程序锁定在该版本。然而，对于 Gradle 来说，捆绑的 Groovy 版本仅用于执行构建脚本本身。你可以在自己的项目中使用任何版本的
    Groovy，Gradle 都会正确地构建它们。
- en: When you run the `gradle` `–v` command, in addition to showing the Gradle and
    Groovy versions, Gradle also reports the included versions of Ant and Ivy, as
    well as the JVM and OS.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `gradle –v` 命令时，除了显示 Gradle 和 Groovy 版本外，Gradle 还会报告包含的 Ant 和 Ivy 版本，以及
    JVM 和 OS。
- en: Gradle builds range from extremely simple to quite powerful. I’ll start with
    the simplest possible example and build from there.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 构建的范围从极其简单到相当强大。我将从一个最简单的例子开始，并在此基础上构建。
- en: 5.6.1\. Basic Gradle builds
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.1\. 基本Gradle构建
- en: Gradle is a plugin-based architecture. Most Gradle tutorials start by defining
    what a task is and showing how to call one. Rather than do that here, let me instead
    show you a minimal build file and go from there.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 是一个基于插件的架构。大多数 Gradle 教程都是从定义任务是什么以及如何调用一个任务开始的。在这里，我不再那样做，而是展示一个最小的构建文件，并从那里开始。
- en: 'Here’s the smallest possible Gradle build for a Java project, in a file called
    build.gradle:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 Java 项目的最小 Gradle 构建示例，在名为 build.gradle 的文件中：
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `apply` syntax indicates that the build is using the Java plugin. When
    you run the `build` command using this file, Gradle executes tasks in several
    stages, as shown:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 语法表示构建正在使用 Java 插件。当你使用此文件运行 `build` 命令时，Gradle 会分几个阶段执行任务，如下所示：'
- en: '[PRE37]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Each word after the colon is a Gradle *task*. Gradle constructs a Directed Acyclic
    Graph (DAG) out of the specified tasks, paying attention to their dependencies,
    and then executes them in order. This minimal project has no source code, so the
    compile tasks are up to date without running at all. In fact, the only task that
    does anything is the `jar` task, which creates a JAR file in the build/libs directory.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号后面的每个单词都是一个 Gradle *任务*。Gradle 会根据指定的任务构建一个有向无环图（DAG），注意它们的依赖关系，然后按顺序执行它们。这个最小项目没有源代码，因此编译任务无需运行就已是最新状态。实际上，唯一执行任何操作的任务是
    `jar` 任务，它在构建目录的 `libs` 中创建一个 JAR 文件。
- en: If you’re doing any testing your project will need to include the JUnit dependency.
    Consider a simple project that uses standard Maven structure, so that any Java
    classes are contained in src/main/java, and any tests are in src/test/java. The
    next listing shows a POJO called `Greeting` with a single `String` property called
    `message`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在進行任何測試，你的項目將需要包含 JUnit 依賴。考慮一個使用標準 Maven 結構的簡單項目，這樣任何 Java 類別都包含在 src/main/java
    中，任何測試都包含在 src/test/java 中。下一個列表展示了一個名為 `Greeting` 的 POJO，它有一個單一的 `String` 屬性名為
    `message`。
- en: Listing 5.14\. A `Greeting` POJO to demonstrate a Gradle build
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14\. 用於展示 Gradle 建築的 `Greeting` POJO
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The following listing is a JUnit test called `GreetingTest`, which checks the
    getter and setter.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是一個名為 `GreetingTest` 的 JUnit 測試，它檢查 getter 和 setter。
- en: Listing 5.15\. A JUnit test for the `Greeting` POJO
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.15\. `Greeting` POJO 的 JUnit 測試
- en: '[PRE39]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The next listing shows a Gradle build file with a JUnit dependency during the
    testing phase. It’s still a “Hello, World” example, but it does introduce some
    essential concepts.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 下一個列表展示了一個在測試階段具有 JUnit 依賴的 Gradle 建築文件。這仍然是一個“Hello, World”示例，但它引入了一些基本概念。
- en: Listing 5.16\. A build.gradle file for the POJO application with testing
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.16\. POJO 應用程序的 build.gradle 文件
- en: '![](120fig01_alt.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![圖片描述](120fig01_alt.jpg)'
- en: The terms `repositories` and `dependencies` are part of the Gradle DSL. Any
    required libraries are listed in the `dependencies` block. There are several legal
    forms for listing dependencies. The one used here is a string separated by colons.
    Using Maven syntax is not an accident, as shown in the `repositories` section.
    Many different types of repositories can be used, but here the standard Maven
    central repository is declared.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`repositories` 和 `dependencies` 是 Gradle DSL 的部分。任何所需的庫都列在 `dependencies` 块中。有幾種合法的依賴列表形式。這裡使用的是由冒號分隔的字符串。使用
    Maven 語法不是偶然的，如 `repositories` 部分所示。可以使用多種不同類型的存儲庫，但這裡聲明了標準 Maven 中央存儲庫。'
- en: Executing the build this time runs the same series of tasks, but now any tests
    are executed and a JUnit report in HTML form is produced in the build/reports/tests
    directory.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 本次執行建築時運行相同的任務系列，但現在任何測試都會執行，並在 build/reports/tests 目錄中生成 HTML 格式的 JUnit 报告。
- en: That demonstrated that a Gradle build can be applied to a Java project with
    no Groovy dependencies. To show that the same process works on mixed Java/Groovy
    projects, I’ll add a Groovy test case, called `GroovyGreetingTests`, in the src/test/groovy
    directory. The test case is shown in the next listing.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 這證明了 Gradle 构建可以應用於沒有 Groovy 依賴的 Java 项目。為了展示相同的過程在混合 Java/Groovy 項目上也能正常工作，我將在
    src/test/groovy 目錄中添加一個名為 `GroovyGreetingTests` 的 Groovy 測試用例。測試用例在下一個列表中展示。
- en: Listing 5.17\. A Groovy test for the POJO, making this a mixed Java/Groovy project
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.17\. POJO 的 Groovy 測試，使這成為一個混合 Java/Groovy 项
- en: '[PRE40]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The new build.gradle file requires a Groovy dependency. Prior to Gradle version
    1.6 the name of the dependency was “groovy”. Now the preferred notation is to
    declare the Groovy dependency as a standard compile-time requirement. The complete
    build.gradle file is shown in the following listing.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 build.gradle 文件需要 Groovy 依賴。在 Gradle 版本 1.6 之前，依賴的名称是“groovy”。現在，推薦的表示法是將
    Groovy 依賴聲明為標準編譯時間要求。完整的 build.gradle 文件在以下列表中展示。
- en: Listing 5.18\. A build.gradle file for a mixed Java/Groovy project
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.18\. 混合 Java/Groovy 项目的 build.gradle 文件
- en: '[PRE41]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The other change to the build file is that the Java plugin has been replaced
    by the Groovy plugin, which includes the Java tasks already. The new plugin adds
    a couple of tasks to the build, as shown here:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 建築文件的其他更改是將 Java 插件替換為 Groovy 插件，該插件已經包含了 Java 任務。新的插件為建築添加了幾個任務，如下所示：
- en: '[PRE42]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both the `compileGroovy` and `compileTestGroovy` tasks are new, but everything
    else proceeds normally. The classes are compiled, the tests run, and the HTML
    test report is produced.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`compileGroovy` 和 `compileTestGroovy` 任務都是新的，但其他一切正常進行。類別被編譯，測試運行，並生成了 HTML
    測試報告。'
- en: That’s the basic structure of a Gradle build file when dealing with Java, Groovy,
    or mixed Java/Groovy projects. Similar files are shown throughout this book. To
    illustrate some interesting Gradle features I’ll now consider several use cases
    that often come up in practice.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 那是处理 Java、Groovy 或混合 Java/Groovy 项目时的 Gradle 构建文件的基礎結構。類似的文件在這本書中都有展示。為了說明一些有趣的
    Gradle 特性，我現在將考慮幾個在實踐中經常出現的用例。
- en: 5.6.2\. Interesting configurations
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.2\. 有趣的配置
- en: Gradle builds are used throughout this book. I’ll bring up lots of different
    options when discussing specific examples in context, but here I can discuss a
    few interesting ideas.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用了Gradle构建。当讨论上下文中的特定示例时，我会提出很多不同的选项，但在这里我可以讨论一些有趣的想法。
- en: Custom source sets
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自定义源集
- en: 'First, one of the running themes in this book is that separating Groovy source
    code from Java source code is rather artificial. What if you wanted to use the
    same source folder for both, as an Eclipse project might do? Here’s an easy customized
    project layout to do so:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，本书中的一个主要主题是，将Groovy源代码与Java源代码分开相当不自然。如果你想要使用相同的源文件夹来处理两者，就像Eclipse项目可能做的那样？这里有一个简单的自定义项目布局来实现这一点：
- en: '[PRE43]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Source sets* are collections of source code in a Gradle build. Here, by assigning
    the `srcDirs` property of both the src/main/java and src/test/java folders to
    an empty list, the Java compiler won’t run at all. Instead, the Groovy compiler
    is used for all classes in the src directory, which will presumably hold both
    Java and Groovy classes.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*源集*是Gradle构建中源代码的集合。在这里，通过将src/main/java和src/test/java文件夹的`srcDirs`属性分配给空列表，Java编译器根本不会运行。相反，Groovy编译器用于src目录中的所有类，这些类可能包含Java和Groovy类。'
- en: Copying JARs
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复制JAR文件
- en: 'Another useful tactic is to make a local copy of the dependent libraries. The
    following task does that:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的策略是制作依赖库的本地副本。以下任务就是这样做的：
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `collectJars` task is a kind of `Copy` task—one of the built-in task types
    in Gradle. Running `collectJars` copies the JAR files in the runtime classpath
    into the output/lib folder in the build directory. Spock uses this task to make
    a complete distribution.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectJars`任务是一种`Copy`任务——Gradle中内置的任务类型之一。运行`collectJars`会将运行时类路径中的JAR文件复制到构建目录中的输出/lib文件夹。Spock使用此任务来制作完整的发行版。'
- en: Inputs and outputs
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入和输出
- en: Another neat capability of Gradle is that it can skip tasks that aren’t necessary.
    It does this by creating hashes of files and directories and checking whether
    or not they have changed. The following listing shows an example taken from the
    samples^([[11](#ch05fn11)]) that come with Gradle.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的另一个出色功能是它可以跳过不必要的任务。它是通过创建文件和目录的哈希值并检查它们是否已更改来做到这一点的。以下列表显示了一个从Gradle附带示例中取出的示例。
- en: ^(11) See the userguide/tasks/incrementalBuild/inputsAndOutputs directory in
    the download distribution. Gradle comes with a huge number of very simple samples
    like this one.
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（11）请参阅下载分布中userguide/tasks/incrementalBuild/inputsAndOutputs目录。Gradle附带大量非常简单的示例，就像这个一样。
- en: Listing 5.19\. Inputs/outputs example from the `incrementalBuilds` Gradle sample
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.19\. `incrementalBuilds` Gradle示例中的输入/输出示例
- en: '![](123fig01_alt.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](123fig01_alt.jpg)'
- en: The `srcFile` and `destDir` properties of the script are assigned to the `ext`
    map, which puts them in the project but avoids any potential conflict with existing
    `Project` properties. The `inputs` and `outputs` properties can be assigned to
    either files or directories (in other words, the word `file` is interpreted as
    a `java.io.File`). If both properties are the same as during the previous run,
    the code inside the `doLast` block is skipped.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的`srcFile`和`destDir`属性被分配给`ext`映射，这使得它们位于项目中，但避免了与现有的`Project`属性可能发生的任何潜在冲突。`inputs`和`outputs`属性可以分配给文件或目录（换句话说，单词`file`被解释为`java.io.File`）。如果这两个属性与上次运行时相同，则`doLast`块内的代码将被跳过。
- en: Ant integration
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Ant集成
- en: One of the nice features of Gradle is that it includes an instance of `groovy.ant.AntBuilder`
    as part of the build. That means that anything that can be done with Ant can be
    handled inside a Gradle build. That has a couple of consequences. First, if you
    already have an Ant build file, you can invoke its tasks inside a Gradle build.
    You can even make the Gradle tasks dependent on the Ant tasks.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的一个很好的特性是它包含了一个`groovy.ant.AntBuilder`实例作为构建的一部分。这意味着任何可以用Ant完成的事情都可以在Gradle构建中处理。这有几个后果。首先，如果你已经有了Ant构建文件，你可以在Gradle构建中调用其任务。你甚至可以使Gradle任务依赖于Ant任务。
- en: 'Consider this example, from the Gradle samples.^([[12](#ch05fn12)]) The Ant
    build file is build.xml, and it contains a single task called `hello`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子，来自Gradle示例.^([[12](#ch05fn12)]) Ant构建文件是build.xml，它包含一个名为`hello`的单个任务：
- en: ^(12) See userguide/ant/dependsOnAntTarget in the distribution.
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（12）请参阅分布中的userguide/ant/dependsOnAntTarget。
- en: '[PRE45]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The Gradle build is in the file build.gradle:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle构建在文件build.gradle中：
- en: '[PRE46]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `intro` task depends on the `hello` task from the Ant build, which is imported
    using the `ant` variable (an instance of `AntBuilder`). Running `gradle` `intro`
    executes both tasks:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`intro`任务依赖于Ant构建中的`hello`任务，该任务通过`ant`变量（`AntBuilder`的一个实例）导入。运行`gradle intro`会执行这两个任务：'
- en: '[PRE47]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Wrapper task
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 包装器任务
- en: 'Finally, a client can execute a Gradle build even if they don’t have Gradle
    installed. Gradle comes with a special `Wrapper` task, which has a version property:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，即使客户端没有安装Gradle，也可以执行Gradle构建。Gradle附带一个特殊的`Wrapper`任务，它有一个版本属性：
- en: '[PRE48]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Running this task generates scripts for both Windows and Unix, called `gradlew.bat`
    and `gradlew`, respectively, along with a minimal Gradle JAR distribution. When
    executed the wrappers first download and install a local copy of Gradle and then
    execute the build.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此任务会为Windows和Unix生成脚本，分别称为`gradlew.bat`和`gradlew`，以及一个最小的Gradle JAR发行版。当执行时，包装器首先下载并安装Gradle的本地副本，然后执行构建。
- en: Gradle is a very powerful system, and a thorough investigation is well beyond
    the scope of this book.^([[13](#ch05fn13)]) Hopefully this section will provide
    you with enough of an introduction to get you started.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle是一个非常强大的系统，对其彻底的调查超出了本书的范围.^([[13](#ch05fn13)]) 希望这一节能为你提供足够的介绍，让你开始。
- en: ^(13) The book *Gradle in Action* (Manning, 2013) by Benjamin Muschko is both
    well written and thorough. I highly recommend it.
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([13](#ch05fn13)) 书籍《Gradle in Action》（Manning，2013）由Benjamin Muschko撰写，既写得很好又全面。我强烈推荐它。
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (Grapes and Gradle)**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（Grapes和Gradle）**'
- en: '`@Grab` is helpful for Groovy scripts.'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Grab`对Groovy脚本很有帮助。'
- en: Gradle uses Groovy build files to configure your build but downloads the internet
    like Maven.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gradle使用Groovy构建文件来配置你的构建，但像Maven一样从互联网上下载。
- en: Gradle does not have artifacts like Maven, but people are working on ways to
    create standard builds for various goals.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gradle没有像Maven那样的工件，但人们正在研究为各种目标创建标准构建的方法。
- en: In addition to the discussion in this chapter, every project in this book includes
    a Gradle build highlighting a variety of capabilities.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了本章的讨论之外，本书中的每个项目都包含一个Gradle构建，突出其各种功能。
- en: '|  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.7\. Summary
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7\. 摘要
- en: This chapter looked at build tools useful for both Groovy and Java projects.
    Ant is very common but low level. Groovy provides both a raw `groovy` task and
    a `groovyc` compiler task, which can be useful in combined projects.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了适用于Groovy和Java项目的构建工具。Ant非常常见但处于较低级别。Groovy提供了原始的`groovy`任务和`groovyc`编译任务，这在组合项目中可能很有用。
- en: Maven is a higher-level tool, but it can be difficult to customize. In this
    chapter I presented both the GMaven project as a way to add Groovy to Maven and
    the Groovy-Eclipse plugin approach, which tends to be more robust for cross-compilation
    issues.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Maven是一个高级工具，但可能难以定制。在本章中，我介绍了GMaven项目作为将Groovy添加到Maven的方法，以及Groovy-Eclipse插件方法，这种方法在跨编译问题时通常更稳健。
- en: Groovy includes an `@Grab` annotation with its so-called Grapes capability,
    which can be used to add dependencies directly to a Groovy script. It’s powerful,
    but it’s restricted to Groovy builds.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy包含一个`@Grab`注解，其所谓的Grapes功能可以用来直接将依赖项添加到Groovy脚本中。它功能强大，但仅限于Groovy构建。
- en: Finally, I presented the Gradle build tool. This chapter included a basic discussion
    of Gradle and mentioned several more advanced capabilities. Gradle is used throughout
    this book to demonstrate interesting mechanisms in each chapter.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我介绍了Gradle构建工具。本章包括了对Gradle的基本讨论，并提到了几个更高级的功能。Gradle在本书中被用来展示每个章节中的有趣机制。
- en: Chapter 6\. Testing Groovy and Java projects
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 测试Groovy和Java项目
- en: '*This chapter covers*'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using `GroovyTestCase` and its subclasses
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GroovyTestCase`及其子类
- en: Testing scripts as well as classes
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试脚本以及类
- en: The `MockFor` and `StubFor` classes in the Groovy library
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy库中的`MockFor`和`StubFor`类
- en: The Spock testing framework
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spock测试框架
- en: The rise of automated testing is one of the most significant software development
    productivity improvements in the past 20 years. Automated tests, running as part
    of your build process, are very easy to set up, catch problems right away, and
    give you the freedom to refactor your code without worrying that you’re breaking
    something unrelated.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试的兴起是过去20年中软件开发生产率最显著的提升之一。作为构建过程一部分运行的自动化测试很容易设置，可以立即发现问题，并给你在重构代码时无需担心破坏相关无关内容的自由。
- en: 'Testing is the cornerstone of many of the “agile” development processes, from
    more modern techniques like SCRUM to Kanban back to the original Extreme Programming
    (XP) movement. There are two other benefits of automated testing, however, that
    aren’t nearly as publicized:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是许多“敏捷”开发流程的基石，从更现代的技术如SCRUM到Kanban，再到原始的极限编程（XP）运动。然而，自动化测试还有两个其他的好处，但它们并没有得到足够的宣传：
- en: '**1**.  *Tests are executable documentation.*'
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 测试是可执行的文档。'
- en: ''
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any major open source project is a communal effort by some of the best developers
    in the world, many of whom are working on their own time. They’re highly motivated
    to write code, not documentation. The result is that the documentation quality
    tends to be inferior to the code quality, if it’s even up to date in the first
    place.
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何主要的开源项目都是世界上一些最好的开发者共同努力的结果，其中许多人是在自己的时间里工作的。他们高度致力于编写代码，而不是文档。结果是，文档的质量往往低于代码的质量，如果它甚至最初是更新的话。
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: My own experience is that the better the developer, the more he or she cares
    about testing. The best developers write complete tests, and these tests run all
    the time as part of a continuous integration system. If a test breaks, the system
    notifies the project committers right away. As a result, the tests are excellent
    examples of how the developers intend the system to be used.
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我自己的经验是，开发者越好，他们就越关心测试。最好的开发者编写完整的测试，这些测试作为持续集成系统的一部分始终运行。如果一个测试失败，系统会立即通知项目提交者。因此，测试是开发者如何打算使用系统的绝佳例子。
- en: ''
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whenever you work with a major open source project, download the source. You
    may or may not look at the details, but the tests are invaluable.
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论何时您与一个主要的开源项目一起工作，请下载源代码。您可能不会查看细节，但测试是无价的。
- en: '**2**.  *Tests aren’t part of production code.*'
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 测试不是生产代码的一部分。'
- en: ''
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This isn’t as big a deal from a developer point of view, but it’s a huge issue
    for managers. One of the reasons companies are reluctant to adopt new languages
    is that they aren’t sure how well they work in a production environment. Production
    code often involves complex approval processes and performance assessments that
    can be extremely conservative.
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，这并不是什么大问题，但对于管理者来说却是一个巨大的问题。公司不愿意采用新语言的一个原因是不确定它们在生产环境中表现如何。生产代码通常涉及复杂的审批流程和性能评估，这些评估可能非常保守。
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you would like to try Groovy in your system, testing is one easy way to do
    it. Groovy has many testing capabilities built into the language, all of which
    work with both Groovy and Java code. Best of all from a management point of view,
    at runtime Groovy’s just another JAR file.
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您想在您的系统中尝试Groovy，测试是一个简单的方法。Groovy语言内置了许多测试功能，这些功能都可以与Groovy和Java代码一起工作。从管理的角度来看，最好的是，在运行时Groovy只是一个JAR文件。
- en: This chapter reviews the Groovy APIs and libraries that make testing easier.
    First I’ll review how Java developers normally test applications, focusing on
    the JUnit library. Then I’ll show how Groovy enhances that process through its
    `GroovyTestCase` extension. Next I’ll show how to test scripts written in Groovy,
    using subclasses of `GroovyTestCase`. From there I’ll discuss testing classes
    in isolation using mocks and stubs. This involves the built-in mock and stub capabilities
    in Groovy, both through the `Expando` class and through Groovy’s `MockFor` and
    `StubFor` classes. Finally I’ll show you a glimpse of the future in the form of
    the powerful Spock framework, a pure Groovy library that simplifies testing for
    both Java and Groovy projects.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了使测试更简单的Groovy API和库。首先，我会回顾Java开发者通常如何测试应用程序，重点关注JUnit库。然后，我会展示Groovy如何通过其`GroovyTestCase`扩展来增强这个过程。接下来，我会展示如何使用`GroovyTestCase`的子类测试用Groovy编写的脚本。从那里，我会讨论使用模拟和存根来单独测试类。这涉及到Groovy内置的模拟和存根功能，无论是通过`Expando`类，还是通过Groovy的`MockFor`和`StubFor`类。最后，我会向您展示未来的一瞥，即强大的Spock框架，这是一个纯Groovy库，它简化了Java和Groovy项目的测试。
- en: '[Figure 6.1](#ch06fig01) is a guide to the technologies discussed in this chapter.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.1](#ch06fig01)是本章讨论的技术的指南。'
- en: Figure 6.1\. Java tests in this chapter are from JUnit. The standard Groovy
    library includes a subclass of JUnit’s `TestCase` called `GroovyTestCase`, and
    its subclasses are useful as well. The Spock framework is a very popular alternative
    testing API that includes a JUnit test runner. Groovy makes it easy to create
    mock objects through library classes like `Expando`, `MockFor`, and `StubFor`.
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 本章中的 Java 测试来自 JUnit。标准的 Groovy 库包括 JUnit 的 `TestCase` 的一个子类，称为 `GroovyTestCase`，其子类也很有用。Spock
    框架是一个非常流行的替代测试 API，它包括一个 JUnit 测试运行器。Groovy 通过 `Expando`、`MockFor` 和 `StubFor`
    等库类使创建模拟对象变得容易。
- en: '![](06fig01_alt.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01_alt.jpg)'
- en: 6.1\. Working with JUnit
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 使用 JUnit
- en: The agile development community created JUnit ([http://junit.org](http://junit.org))
    as a great tool for automating tests. While other Java testing tools exist, JUnit
    has been so influential that nearly every Java developer I encounter has either
    used it or heard of it. JUnit’s success has spawned an entire family of comparable
    tools for other languages (known collectively as “xUnit”). JUnit is simple, easy
    to use, and ubiquitous in the Java world. As I’ll show in this chapter, the available
    Groovy tools also are easy to use and easy to learn, and some of them are based
    directly on JUnit.^([[1](#ch06fn01)])
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷开发社区创建了 JUnit ([http://junit.org](http://junit.org)) 作为自动化测试的伟大工具。虽然存在其他 Java
    测试工具，但 JUnit 的影响如此之大，以至于我遇到的几乎每一位 Java 开发者都使用过它或听说过它。JUnit 的成功催生了一系列用于其他语言的类似工具（统称为“xUnit”）。JUnit
    简单、易于使用，在 Java 世界中无处不在。正如我将在本章中展示的，可用的 Groovy 工具也易于使用和学习，其中一些直接基于 JUnit.^([[1](#ch06fn01)])
- en: ¹ Now known more commonly as “agile” development, because most Fortune 500 companies
    don’t want to be associated with “extreme” anything.
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 现在更常被称为“敏捷”开发，因为大多数财富 500 强公司不想与“极端”任何事情联系在一起。
- en: '|  |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Adding JUnit to your projects (a review from [chapter 5](kindle_split_016.html#ch05))**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**将 JUnit 添加到您的项目中（第 5 章的回顾[chapter 5](kindle_split_016.html#ch05))**'
- en: JUnit is an open source project created by two of the founders of Extreme Programming,¹
    Erich Gamma and Kent Beck. The JUnit library can be downloaded from the home site
    ([http://junit.org](http://junit.org)), but it’s built into most of the common
    IDEs, including Eclipse, NetBeans, and IntelliJ IDEA. It also can be retrieved
    from the Maven central repository, using a POM dependency of the form
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 是由极限编程的两位创始人 Erich Gamma 和 Kent Beck 创建的开源项目。JUnit 库可以从其主页([http://junit.org](http://junit.org))下载，但它已内置到大多数常见的
    IDE 中，包括 Eclipse、NetBeans 和 IntelliJ IDEA。它还可以通过 Maven 中央仓库检索，使用以下形式的 POM 依赖项
- en: '[PRE49]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As an alternative, JUnit version 4.5 and above enables the artifact ID `junit`-dep
    instead, which does not include the so-called Hamcrest matchers ([http://code.google.com/p/hamcrest/](http://code.google.com/p/hamcrest/))
    that simplify the syntax in certain cases. Like most cool projects, the source
    code for JUnit now resides at GitHub, at [https://github.com/junit-team/junit.](https://github.com/junit-team/junit.)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，JUnit 4.5 及以上版本启用 artifact ID `junit`-dep，它不包括所谓的 Hamcrest 匹配器([http://code.google.com/p/hamcrest/](http://code.google.com/p/hamcrest/))，这些匹配器在某些情况下简化了语法。像大多数酷项目一样，JUnit
    的源代码现在位于 GitHub 上，在 [https://github.com/junit-team/junit.](https://github.com/junit-team/junit.)
- en: Most of the Gradle build files in this book (especially for the projects in
    this chapter) include JUnit as a “test-compile” dependency. That means classes
    in the API (like `org.junit.TestCase` and `org.junit.Assert`) are only available
    for test classes.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数 Gradle 构建文件（特别是本章中的项目）都将 JUnit 作为“test-compile”依赖项。这意味着 API 中的类（如 `org.junit.TestCase`
    和 `org.junit.Assert`）仅对测试类可用。
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: When writing JUnit tests in Groovy, you have two options. You can write a JUnit
    test with annotations as usual, but implement it in Groovy, or you can extend
    the `GroovyTestCase` class. The only difference is that `GroovyTestCase` adds
    a few additional methods to the `TestCase` class from JUnit.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Groovy 中编写 JUnit 测试时，你有两种选择。你可以像往常一样使用注解编写 JUnit 测试，但用 Groovy 实现，或者你可以扩展
    `GroovyTestCase` 类。唯一的区别是 `GroovyTestCase` 为 JUnit 的 `TestCase` 类添加了一些额外的方法。
- en: 'Because this book is all about integration, I’d like to examine the following
    cases:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这本书全部关于集成，我想检查以下情况：
- en: Use a standard Groovy JUnit test to check a Java implementation.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准的 Groovy JUnit 测试来检查 Java 实现。
- en: Use a standard Java JUnit test to check a Groovy implementation.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准的 Java JUnit 测试来检查 Groovy 实现。
- en: Write a Groovy test that extends `GroovyTestCase` to see what additions it provides.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个扩展 `GroovyTestCase` 的 Groovy 测试，以查看它提供了哪些新增功能。
- en: In each case I need something to test. Because I plan to mix the languages,
    one way I’ve found that makes that easier is to declare my methods in a Java interface
    and then implement it in both languages. That’s actually a pretty general rule.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，我都需要一些东西来测试。因为我计划混合使用语言，我找到的一种使这更容易的方法是在Java接口中声明我的方法，然后在两种语言中实现它。这实际上是一个相当通用的规则。
- en: '|  |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy implements Java
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy实现了Java
- en: Groovy classes can implement Java interfaces as easily as Java classes can.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy类可以像Java类一样轻松地实现Java接口。
- en: '|  |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next listing shows a Java interface, called `UtilityMethods`, containing
    three method declarations.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了一个Java接口，称为`UtilityMethods`，包含三个方法声明。
- en: Listing 6.1\. A Java interface with three methods
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1. 一个包含三个方法的Java接口
- en: '[PRE50]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In true test-driven development (TDD) I would now write the tests, watch them
    fail, and then write the correct implementations. Because the subject of this
    chapter is the tests rather than the implementations, let me present the implementations
    first.^([[2](#ch06fn02)])
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在真正的测试驱动开发（TDD）中，我现在会编写测试，观察它们失败，然后编写正确的实现。因为本章的主题是测试而不是实现，让我先展示实现。^([[2](#ch06fn02)])
- en: ² I try to use TDD, but more often I use GDD, which stands for Guilt-Driven
    Development. If I write code and it’s not tested, I feel guilty and write a test
    for it.
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我尝试使用TDD（测试驱动开发），但更经常使用GDD（罪恶驱动开发）。如果我编写了代码但没有进行测试，我会感到内疚，并为它编写一个测试。
- en: The following listing is the Java implementation of the `UtilityMethods` interface.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是`UtilityMethods`接口的Java实现。
- en: Listing 6.2\. The Java implementation of the UtilityMethods interface
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2. `UtilityMethods`接口的Java实现
- en: '[PRE51]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The implementations will not be surprising to anyone with a Java background.
    The Groovy implementation, shown in the next listing, is somewhat shorter.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有Java背景的人来说，实现不会令人惊讶。下一个列表中显示的Groovy实现要短一些。
- en: Listing 6.3\. The Groovy implementation of the UtilityMethods interface
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3. `UtilityMethods`接口的Groovy实现
- en: '![](130fig01_alt.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图片](130fig01_alt.jpg)'
- en: There is, in fact, a subtle bug in the implementation of the `isPrime` method.
    The tests will detect it and give me a chance to explain the trap.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`isPrime`方法的实现中有一个微妙的错误。测试将检测到它，并给我一个机会来解释陷阱。
- en: In the next subsection I’ll use Java to test the Groovy implementation and fix
    the bug. Then I’ll use Groovy to test the Java implementation, and finally I’ll
    write the test as a subclass of `GroovyTestCase` to see how that can help.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我将使用Java来测试Groovy实现并修复错误。然后我将使用Groovy来测试Java实现，最后我将编写一个作为`GroovyTestCase`子类的测试，看看这能帮到什么。
- en: 6.1.1\. A Java test for the Groovy implementation
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1. 一个针对Groovy实现的Java测试
- en: The following listing contains a JUnit 4 test, written in Java, to test the
    Groovy implementation. It includes a static import for the methods in the `org.junit.Assert`
    class and `@Test` annotations for the individual tests.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表包含一个JUnit 4测试，用Java编写，用于测试Groovy实现。它包括对`org.junit.Assert`类中方法的静态导入和单个测试的`@Test`注解。
- en: Listing 6.4\. A Java JUnit test to check the Groovy implementation
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4. 一个用于检查Groovy实现的Java JUnit测试
- en: '![](ch06ex04-0.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06ex04-0.jpg)'
- en: '![](ch06ex04-1.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch06ex04-1.jpg)'
- en: In JUnit 3 tests extended the `org.junit.TestCase` class, and test methods were
    detected by reflection. `TestCase` had all the needed assert methods in it. Now,
    in JUnit 4, tests don’t have a superclass and are detected through the `@Test`
    annotation. The assert methods are now static methods in the `Assert` class, leading
    to probably the most common use of static imports in all of Java. If you do a
    static import on the `Assert` class you can write the assert methods the same
    way they looked in the older version.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 3中，测试扩展了`org.junit.TestCase`类，测试方法是通过反射检测的。`TestCase`中包含了所有需要的断言方法。现在，在JUnit
    4中，测试没有超类，并且通过`@Test`注解进行检测。断言方法现在是`Assert`类中的静态方法，这导致了Java中最常见的静态导入使用。如果你对`Assert`类进行静态导入，你可以像在旧版本中一样编写断言方法。
- en: The only other interesting part of this is the use of the `expected` property
    of the `@Test` annotation, which declares that the test only passes if the expected
    exception is thrown. [Figure 6.2](#ch06fig02) shows the result.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的另一个有趣的部分是`@Test`注解的`expected`属性的用法，它声明只有当抛出预期异常时测试才通过。[图6.2](#ch06fig02)显示了结果。
- en: Figure 6.2\. The `isPrime` method has a bug, but the rest are fine.
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2. `isPrime`方法有一个错误，但其他部分都正常。
- en: '![](06fig02.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig02.jpg)'
- en: The test detected that the Groovy implementation is returning true for all cases.
    The Groovy implementation divides the given number by all the integers from 2
    up to the square root of the number minus 1, looking for any that come out even.
    That algorithm is fine. The problem is that if a composite (non-prime) number
    is detected, the method is supposed to return false.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 测试检测到 Groovy 实现对所有情况都返回 true。Groovy 实现将给定的数字除以从 2 到数字平方根减 1 的所有整数，寻找任何能被整除的数。这个算法是好的。问题是如果检测到合数（非质数），该方法应该返回
    false。
- en: Unfortunately, a return from inside a closure doesn’t behave the way a regular
    Java developer expects. In fact, when you return from a closure it’s like you’re
    returning from a method within another method. It only returns from the closure,
    not the method containing it.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，从闭包内部返回的行为并不像常规 Java 开发者所期望的那样。实际上，当你从闭包返回时，就像是从另一个方法内部的方法返回一样。它只从闭包返回，而不是包含它的方法。
- en: 'That’s a trap worthy of a callout:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个值得注意的陷阱：
- en: '|  |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Return From Closure
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从闭包返回
- en: A return from inside a closure only returns from the closure, not the method
    that contains it.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 从闭包内部返回只会从闭包返回，而不会从包含它的方法返回。
- en: '|  |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Probably the easiest fix is to switch to a loop, where returns work as expected.
    Here’s one proper implementation:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最简单的修复方法是切换到循环，其中返回行为如预期。下面是一个正确的实现：
- en: '[PRE52]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now the test passes. Next I’ll show a Groovy test for the Java implementation.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试通过了。接下来我将展示一个针对 Java 实现的 Groovy 测试。
- en: 6.1.2\. A Groovy test for the Java implementation
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 一个针对 Java 实现的 Groovy 测试
- en: You can implement JUnit tests using Groovy as easily as Java, with the attendant
    code simplifications. The next listing shows such a test.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Groovy 实现 JUnit 测试，就像使用 Java 一样简单，并且伴随着代码简化。下面的列表展示了这样一个测试。
- en: Listing 6.5\. A Groovy JUnit test for a Java implementation
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 一个针对 Java 实现的 Groovy JUnit 测试
- en: '![](133fig01_alt.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](133fig01_alt.jpg)'
- en: There are some code simplifications here, but this is still recognizably a standard
    JUnit test. Initial data can be provided by coercing a range into an array of
    integers. The `every` method in `Collection` lets me check all the return values
    in one statement. Otherwise this is the same as before.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码简化，但这仍然是一个可识别的标准 JUnit 测试。可以通过将范围强制转换为整数数组来提供初始数据。`Collection` 中的 `every`
    方法让我可以在一个语句中检查所有返回值。否则这与之前相同。
- en: 'One other note: due to the Groovy Truth,^([[3](#ch06fn03)]) `assert` in Groovy
    is the same as `assertTrue` and `assertNotNull`. Also, the Groovy `assert` has
    excellent debugging output. As a result, most Groovy developers use `assert` in
    their tests rather than any of the assert methods from the `org.junit.Assert`
    class.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个注意事项：由于 Groovy 的真值规则，^([[3](#ch06fn03)]) Groovy 中的 `assert` 与 `assertTrue`
    和 `assertNotNull` 相同。此外，Groovy 的 `assert` 具有出色的调试输出。因此，大多数 Groovy 开发者更倾向于在测试中使用
    `assert` 而不是 `org.junit.Assert` 类中的任何断言方法。
- en: ³ Non-null references are true, non-zero numbers are true, non-empty collections
    are true, non-empty strings are true, and so on.
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 非空引用为真，非零数字为真，非空集合为真，非空字符串为真，等等。
- en: Finally, let me show a test class that extends `GroovyTestCase` and see what
    extra capabilities that brings.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我展示一个扩展 `GroovyTestCase` 的测试类，看看它带来了哪些额外功能。
- en: 6.1.3\. A GroovyTestCase test for a Java implementation
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 一个针对 Java 实现的 GroovyTestCase 测试
- en: Groovy provides the class `groovy.util.GroovyTestCase` as part of its standard
    library. As mentioned earlier, it extends `org.junit.TestCase`. The following
    listing shows one such test for the Java implementation.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 通过其标准库提供 `groovy.util.GroovyTestCase` 类。如前所述，它扩展了 `org.junit.TestCase`。下面的列表展示了一个针对
    Java 实现的此类测试。
- en: Listing 6.6\. A GroovyTestCase test for the Java implementation
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.6\. 一个针对 Java 实现的 GroovyTestCase 测试
- en: '![](ch06ex06-0.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex06-0.jpg)'
- en: '![](ch06ex06-1.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![](ch06ex06-1.jpg)'
- en: There are a few new features here. First, `GroovyTestCase` includes a static,
    protected property called `log` of type `java.util.logging.Logger`. It’s not exactly
    difficult to add a logger to a test yourself, but providing one automatically
    is a convenience.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新特性。首先，`GroovyTestCase` 包含一个静态的受保护属性 `log`，其类型为 `java.util.logging.Logger`。自己添加一个日志记录器到测试中并不难，但自动提供一个是方便的。
- en: Next, the class adds an `assertLength` method. It has three overloads. In each,
    the first argument is the expected length of the array. The second argument is
    an array of integers, an array of characters, or an array of type `Object`. Here
    I’m using the method to check that the number of positive integers returned is
    as expected.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，该类添加了一个`assertLength`方法。它有三个重载版本。在每个版本中，第一个参数是数组的预期长度。第二个参数是一个整数数组、字符数组或`Object`类型的数组。在这里，我使用这个方法来检查返回的正整数数量是否符合预期。
- en: The class also provides an `assertArrayEquals` method, which takes two `Object`
    arrays as arguments. The docs say that this method checks that the arrays are
    equivalent and contain the same elements.^([[4](#ch06fn04)])
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还提供了一个`assertArrayEquals`方法，它接受两个`Object`数组作为参数。文档说明，此方法检查数组是否等效且包含相同的元素.^([[4](#ch06fn04)])
- en: ⁴ That sounds like it’s from the Department of Redundancy Department, but it’s
    not.
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 这听起来像是冗余部门的，但并非如此。
- en: Another added method is `assertContains`. That method has two overloads, one
    for characters and one for integers, so it’s only useful in those cases.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 另外添加了一个方法`assertContains`。该方法有两个重载版本，一个用于字符，一个用于整数，因此仅在那些情况下有用。
- en: Finally, the superclass also provides the `shouldFail` method, which takes either
    an exception type and a closure or just a closure. It expects an exception when
    the closure is run, so it behaves much as the `@Test` annotation with an expected
    property.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，超类还提供了一个`shouldFail`方法，它接受一个异常类型和一个闭包，或者只接受一个闭包。它期望在运行闭包时抛出异常，因此它的行为与具有预期属性的`@Test`注解非常相似。
- en: The `GroovyTestCase` class has a few additional methods that don’t appear here,
    like `assertScript`, `shouldFailWithCause`, and the ever-popular `notYetImplemented`.
    See the GroovyDocs for details.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroovyTestCase`类还有一些额外的没有在这里列出的方法，如`assertScript`、`shouldFailWithCause`和广受欢迎的`notYetImplemented`。有关详细信息，请参阅GroovyDocs。'
- en: 'The interesting part is that this test can be run from the command line. The
    `groovy` command acts as a text-based JUnit runner for `GroovyTestCase` subclasses.
    The result looks similar to this:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这个测试可以从命令行运行。`groovy`命令充当基于文本的JUnit运行器，用于`GroovyTestCase`子类。结果看起来像这样：
- en: '[PRE53]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The Java interface and implementation classes are compiled and reside in the
    project’s bin directory, so they need to be added to the classpath when running
    the Groovy script.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Java接口和实现类被编译并存储在项目的bin目录中，因此在运行Groovy脚本时需要将它们添加到类路径中。
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (JUnit)^([[5](#ch06fn05)])**'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lessons learned (JUnit)^([[5](#ch06fn05)])**'
- en: '**1**.  JUnit is the most common Java unit-testing framework in the industry.'
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. JUnit是业界最常用的Java单元测试框架。'
- en: '**2**.  Normal JUnit tests are based on annotations. The `@Test` annotation
    has a property called `expected`. Such tests only pass if the expected exception
    is thrown.'
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 正常的JUnit测试基于注解。`@Test`注解有一个名为`expected`的属性。这样的测试只有在抛出预期异常时才会通过。'
- en: '**3**.  Version 4 tests do not have a superclass. Instead, all of the assert
    methods are static methods in the `org.junit.Assert class.`'
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 版本4的测试没有超类。相反，所有的断言方法都是`org.junit.Assert`类中的静态方法。'
- en: '**4**.  By the Groovy truth, `assert`, `assertTrue`, and `assertNotNull` are
    all the same.'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 根据Groovy的真理，`assert`、`assertTrue`和`assertNotNull`都是相同的。'
- en: '**5**.  Because the Groovy `assert` provides so much debugging information
    when it fails, it’s normally preferred over the standard JUnit `assertEquals`
    methods.'
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 因为Groovy的`assert`在失败时提供了大量的调试信息，所以通常比标准的JUnit `assertEquals`方法更受欢迎。'
- en: '**6**.  `GroovyTestCase` extends `TestCase` from JUnit and adds a handful of
    convenience methods, like `assertLength` and `shouldFail`.'
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**. `GroovyTestCase`扩展了JUnit中的`TestCase`类，并添加了一些便利方法，如`assertLength`和`shouldFail`。'
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: ⁵ Before I leave this section, I should mention that the palindromes used in
    the examples come from the Gigantic List of Palidromes page at [www.derf.net/palindromes/old.palindrome.html](http://www.derf.net/palindromes/old.palindrome.html).
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 在我离开这个部分之前，我应该提到，示例中使用的回文来自[www.derf.net/palindromes/old.palindrome.html](http://www.derf.net/palindromes/old.palindrome.html)上的“巨大的回文列表”页面。
- en: Testing a script written in Groovy involves special circumstances, especially
    if input data is supplied from outside. That’s the subject of the next section.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用Groovy编写的脚本涉及特殊的情况，特别是如果输入数据来自外部时。这是下一节的主题。
- en: 6.2\. Testing scripts written in Groovy
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 使用Groovy编写的脚本测试
- en: Testing scripts is a bit different from testing classes. You don’t normally
    instantiate a script and call a method on it, although you can. Instead, it’s
    easiest just to execute the script and let its own internal `assert` statements
    do any correctness checks.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本与测试类略有不同。你通常不会实例化一个脚本并在其上调用方法，尽管你可以这样做。相反，最简单的方法是执行脚本，并让它的内部`assert`语句进行任何正确性检查。
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using assert
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用断言
- en: When Groovy developers write scripts, they typically add asserts to demonstrate
    that the script works properly.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 当Groovy开发者编写脚本时，他们通常会添加断言来演示脚本是否正常工作。
- en: '|  |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Running a script inside a test case is easy enough if no input or output variables
    are involved. Because scripts normally contain `assert` statements that verify
    their correctness, the key is simply to execute the script programmatically. That’s
    what the `GroovyShell` class is for.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本中没有涉及输入或输出变量，在测试用例中运行脚本就足够简单了。因为脚本通常包含验证其正确性的`assert`语句，所以关键是简单地以编程方式执行脚本。这就是`GroovyShell`类的作用。
- en: 'Here’s a simple example. Consider a short but powerful script that accesses
    the Internet Chuck Norris Database,^([[6](#ch06fn06)]) reproduced from [chapter
    4](kindle_split_014.html#ch04):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子。考虑一个访问互联网Chuck Norris数据库的简短但强大的脚本，该脚本从[第4章](kindle_split_014.html#ch04)复制而来：
- en: ⁶ Arguably, this is why the internet was invented.
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 这可能是互联网被发明的原因。
- en: '[PRE54]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This script, when executed, accesses the RESTful web service at the URL shown,
    retrieves a random joke in JavaScript Object Notation (JSON) form, parses (or,
    rather, slurps) it, and prints the resulting joke. The script uses the safe dereference
    operator to avoid `NullPointerException`s in case something goes wrong, but it
    has an `assert` statement to check that something actually was retrieved. When
    executed, the result is something like To test this script all I need to do is
    execute it and let the embedded `assert` statement do the work. I can execute
    it programmatically as in the following listing.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个脚本执行时，它会访问显示的URL上的RESTful网络服务，以JavaScript对象表示法（JSON）的形式检索一个随机笑话，解析（或者更确切地说，是吞噬）它，并打印出结果笑话。脚本使用安全的解引用操作符来避免`NullPointerException`，以防出现错误，但它有一个`assert`语句来检查是否确实检索到了某些内容。当执行时，结果类似于：为了测试这个脚本，我只需要执行它，让嵌入的`assert`语句来完成工作。我可以像以下列表中那样以编程方式执行它。
- en: Listing 6.7\. A class to hold all the script tests
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 用于存储所有脚本测试的类
- en: '[PRE56]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `GroovyShell` class, discussed in [chapter 3](kindle_split_013.html#ch03)
    on Groovy and Java integration, has an `evaluate` method that takes a `File` argument.
    I simply point the `File` to the script in question, and the `evaluate` method
    on the shell executes it.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_013.html#ch03)中讨论的`GroovyShell`类有一个`evaluate`方法，它接受一个`File`参数。我只需将`File`指向相关的脚本，shell上的`evaluate`方法就会执行它。
- en: What if I want to check the results? In this case the result is random, but
    if my script has an actual result based on input values, is there something that
    can be done then?
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想检查结果呢？在这种情况下，结果是随机的，但如果我的脚本基于输入值有实际的结果，那么可以做什么呢？
- en: To handle this I’m going to need a binding for the script (again discussed in
    [chapter 3](kindle_split_013.html#ch03)). A binding is an object that allows input
    and output variables to be accessed from the script.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，我需要一个脚本的绑定（再次在第3章中讨论）。绑定是一个对象，它允许从脚本中访问输入和输出变量。
- en: '|  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Script Binding
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 脚本绑定
- en: Any variable that isn’t declared in a script is part of the binding and can
    be accessed from outside.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在脚本中未声明的变量都是绑定的一部分，可以从外部访问。
- en: '|  |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Consider the classic “Hello, World!” script in Groovy. I’ll put it in a package
    in the next listing, but other than that it’s the same script described in [appendix
    B](kindle_split_024.html#app02), “Groovy by feature.”
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑Groovy中的经典“Hello, World!”脚本。我将在下一个列表中将其放入一个包中，但除此之外，它与[附录B](kindle_split_024.html#app02)，“Groovy
    by feature”中描述的脚本相同。
- en: Listing 6.8\. The “Hello, World!” script
  id: totrans-498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.8\. “Hello, World!”脚本
- en: '[PRE57]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This script doesn’t contain any `assert` statements, but because it prints to
    the console I’d like to be able to check the output. To do so I can assign the
    `out` property of the corresponding binding to a `StringBuffer`, which I can access
    after the script executes.^([[7](#ch06fn07)]) The following test has been added
    to the `ScriptTests` class started in [listing 6.7](#ch06ex07).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本不包含任何 `assert` 语句，但由于它打印到控制台，我希望能够检查输出。为此，我可以将对应绑定的 `out` 属性分配给一个 `StringBuffer`，我可以在脚本执行后访问它。[^7](#ch06fn07)
    以下测试已被添加到在 [列表 6.7](#ch06ex07) 中开始的 `ScriptTests` 类。
- en: ⁷ This isn’t documented well at all, so consider it more value added for you
    by reading this book. Guillaume Laforge told me about it (and wrote it, too),
    so he gets the real credit.
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 这部分内容没有很好地记录，所以请考虑这是通过阅读这本书为你提供的额外价值。Guillaume Laforge 告诉了我关于它的事情（并且也写了它），所以他应该得到真正的荣誉。
- en: Listing 6.9\. A test that captures script output
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 捕获脚本输出的测试
- en: '[PRE58]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `out` property of the binding is assigned to a `PrintWriter` wrapped around
    a `StringWriter`, so that when the `println` method in the script is executed,
    the output goes to the writer instead of the console. Then, after executing the
    script using the shell, I can check that the proper statement was printed by accessing
    the writer and trimming its output.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定的 `out` 属性被分配给一个围绕 `StringWriter` 的 `PrintWriter`，这样当脚本中的 `println` 方法执行时，输出就会流向该写入器而不是控制台。然后，在通过
    shell 执行脚本后，我可以通过访问写入器并修剪其输出，来检查是否打印了正确的语句。
- en: Normally a binding is used to pass input variables into a script. Here’s a slight
    variation on the previous example, using a `name` variable.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，绑定用于将输入变量传递到脚本中。以下是对上一个示例的微小变化，使用了 `name` 变量。
- en: Listing 6.10\. A script with a binding variable
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 带有绑定变量的脚本
- en: '[PRE59]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Again, the only real difference here is that the `print` statement uses a `name`
    variable that is not declared inside the script. That means it can be passed in
    from outside, as shown in the following test.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里唯一的真正区别是 `print` 语句使用了一个在脚本内部未声明的 `name` 变量。这意味着它可以像以下测试中所示的那样从外部传递。
- en: Listing 6.11\. Setting a binding variable to test a script
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11\. 设置绑定变量以测试脚本
- en: '[PRE60]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `name` variable is set to Dolly, and the result is confirmed as before.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 变量被设置为 Dolly，结果与之前确认一致。'
- en: '6.2.1\. Useful subclasses of GroovyTestCase: GroovyShellTestCase'
  id: totrans-512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. GroovyTestCase 的有用子类：GroovyShellTestCase
- en: The combination of script and binding is sufficiently common that the Groovy
    API now includes the class `groovy.util.GroovyShellTestCase`. This is a subclass
    of `GroovyTestCase` that instantiates a `GroovyShell` inside the `setUp` method.
    The shell is provided as a protected attribute, but the class also includes a
    `withBinding` method that takes a `Map` of parameters and a closure to execute.
    The following listing shows tests for the Groovy scripts in this section.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本和绑定的组合足够常见，以至于 Groovy API 现在包括了类 `groovy.util.GroovyShellTestCase`。这是一个 `GroovyTestCase`
    的子类，它在 `setUp` 方法中实例化了一个 `GroovyShell`。shell 被作为一个受保护的属性提供，但该类还包括一个 `withBinding`
    方法，该方法接受一个参数 `Map` 和一个要执行的闭包。以下列表展示了本节中 Groovy 脚本的测试。
- en: Listing 6.12\. Testing Groovy scripts using GroovyShellTestCase
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. 使用 GroovyShellTestCase 测试 Groovy 脚本
- en: '![](140fig01_alt.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![140fig01_alt.jpg](140fig01_alt.jpg)'
- en: The first test finds the script to run and executes it using the shell instantiated
    in the superclass. The other tests use the `withBinding` method to override the
    `out` variable and provide an input parameter. The results are the same as instantiating
    the `GroovyShell` and `Binding` classes directly.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试找到要运行的脚本，并使用在超类中实例化的 shell 来执行它。其他测试使用 `withBinding` 方法覆盖 `out` 变量并提供一个输入参数。结果与直接实例化
    `GroovyShell` 和 `Binding` 类相同。
- en: 'The previous example showed how to capture standard output from a script, but
    normally scripts return concrete values. The `withBinding` method returns whatever
    the script returns. As a trivial example, consider the following powerful Groovy
    calculator, saved in a file called `calc.groovy`:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了如何从脚本中捕获标准输出，但通常脚本会返回具体的值。`withBinding` 方法返回脚本返回的任何内容。作为一个简单的例子，考虑以下强大的
    Groovy 计算器，保存在一个名为 `calc.groovy` 的文件中：
- en: '[PRE61]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Because none of the three variables (`x`, `y`, and `z`) are declared, they can
    all be accessed through the script’s binding. The next listing shows a test for
    this script that validates the returned value.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 由于三个变量（`x`、`y` 和 `z`）都没有声明，它们都可以通过脚本的绑定来访问。下一个列表展示了对此脚本进行测试的示例，该测试验证了返回的值。
- en: Listing 6.13\. A test for the addition script, calc.groovy
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.13\. 对加法脚本 calc.groovy 的测试
- en: '[PRE62]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The last line of the closure accesses the `z` variable, whose value is retrieved
    from the binding.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的最后一行访问了 `z` 变量，其值是从绑定中检索的。
- en: There’s one other subclass of `GroovyTestCase` available in the standard library,
    called `GroovyLogTestCase`, which helps when testing logging. That class is the
    subject of the next subsection.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中还有一个名为 `GroovyLogTestCase` 的 `GroovyTestCase` 子类，用于测试日志记录。这个类是下一小节的主题。
- en: '6.2.2\. Useful subclasses of GroovyTestCase: GroovyLogTestCase'
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. GroovyTestCase 的有用子类：GroovyLogTestCase
- en: Good developers don’t rely on capturing standard output. Instead they use loggers
    to direct output to locations that can be accessed later. For some time now Java
    has had a basic logging capability built into it, which can act as the front end
    on logging API implementations.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的开发者不会依赖于捕获标准输出。相反，他们使用日志记录器将输出定向到可以稍后访问的位置。Java 早已内置了基本的日志记录功能，可以作为日志 API
    实现的前端。
- en: The Java logging classes, like `Logger` and `Level`, reside in the `java.util.logging`
    package. As an example of their use, consider the following minor variation on
    the calculator script from the previous section, stored in a file called `calc_with_`
    `logger.groovy`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: Java 日志类，如 `Logger` 和 `Level`，位于 `java.util.logging` 包中。以下是一个使用这些类的例子，它是上一节中计算器脚本的微小变化，存储在一个名为
    `calc_with_logger.groovy` 的文件中。
- en: Listing 6.14\. A script that uses a logger
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.14\. 使用日志记录器的脚本
- en: '[PRE63]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The static `getLogger` method from the `Logger` class is a factory method that
    creates a `Logger` instance for this particular component. Here I’m using the
    name of the script, which becomes the name of the generated class. Once again,
    the variables `x`, `y`, and `z` are part of the script binding. The logger provides
    methods corresponding to various log levels. In the standard, the built-in levels
    include `finest`, `finer`, `fine`, `info`, `warning`, and `severe`. In this particular
    case, the input parameters are being logged at info level. To execute this script
    with `x` and `y` set to `3` and `4`, use the following code:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger` 类的静态 `getLogger` 方法是一个工厂方法，用于为这个特定组件创建一个 `Logger` 实例。在这里，我使用了脚本的名称，它将成为生成的类的名称。再次强调，变量
    `x`、`y` 和 `z` 是脚本绑定的部分。日志提供与各种日志级别相对应的方法。在标准中，内置的级别包括 `finest`、`finer`、`fine`、`info`、`warning`
    和 `severe`。在这个特定的情况下，输入参数正在以信息级别进行日志记录。要将此脚本执行为 `x` 和 `y` 设置为 `3` 和 `4`，请使用以下代码：'
- en: '[PRE64]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The result is similar to this (dates and times may vary):'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 结果类似于这个（日期和时间可能有所不同）：
- en: '[PRE65]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The default logger includes a console “appender,” which directs all log output
    to the console. The mechanisms for capturing standard output don’t work here,
    though. Instead, Groovy provides a class called `GroovyLogTestCase`, which includes
    a static method called `stringLog` for that purpose. The next listing shows a
    test demonstrating its use.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的日志记录器包括一个控制台“附加器”，将所有日志输出定向到控制台。但是，捕获标准输出的机制在这里不起作用。相反，Groovy 提供了一个名为 `GroovyLogTestCase`
    的类，其中包含一个名为 `stringLog` 的静态方法，用于此目的。下面的列表展示了演示其使用的一个测试。
- en: Listing 6.15\. Capturing log output in a test case
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.15\. 在测试用例中捕获日志输出
- en: '[PRE66]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `stringLog` method returns the log output as a string, which is used to
    check that the logger is working correctly.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`stringLog` 方法返回日志输出作为字符串，用于检查日志记录器是否正常工作。'
- en: Most of the scripts in this book are tested using the techniques described in
    this section. If the script (or any class, for that matter) has dependencies,
    however, there’s a bit more work to be done.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数脚本都是使用本节中描述的技术进行测试的。然而，如果脚本（或任何类）有依赖项，则需要做更多的工作。
- en: '|  |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (testing scripts)**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lessons learned (testing scripts)**'
- en: '**1**.  Groovy scripts provide their own challenges, especially when trying
    to capture input or output data and logging results.'
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. Groovy 脚本提供自己的挑战，尤其是在尝试捕获输入或输出数据以及记录结果时。'
- en: '**2**.  Groovy source code can be executed programmatically through the `GroovyShell`
    and `Binding` classes, which then execute any contained `assert` methods.'
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. Groovy 源代码可以通过 `GroovyShell` 和 `Binding` 类程序化执行，然后执行任何包含的 `assert` 方法。'
- en: '**3**.  Special subclasses of `GroovyTestCase` are available to simplify script
    testing.'
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 可用于简化脚本测试的 `GroovyTestCase` 的特殊子类。'
- en: '|  |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: True unit testing means testing an isolated class. The success or failure of
    the test should not rely on any associated objects. Any dependent objects should
    be replaced by mocks or stubs that return predetermined values when accessed.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的单元测试意味着测试一个独立的类。测试的成功或失败不应依赖于任何相关对象。任何依赖对象都应被模拟或存根对象替换，当访问时返回预定的值。
- en: This is another area that’s significantly easier to handle when using Groovy
    than it is when using Java. Groovy has several built-in mechanisms for creating
    mock or stub objects, which I’ll review in the next section.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用Groovy时比使用Java更容易处理的一个领域。Groovy有几个内置机制用于创建模拟或存根对象，我将在下一节中对其进行回顾。
- en: 6.3\. Testing classes in isolation
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 隔离测试类
- en: In object-oriented programs no class is an island. Classes normally have dependencies.
    An integration test uses all of the dependencies together with the class under
    test (often called the CUT for that reason), but to truly test a given class you
    need to isolate it from its environment.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的程序中，没有哪个类是孤岛。类通常有依赖关系。集成测试使用所有依赖关系以及正在测试的类（通常称为CUT，即原因），但要真正测试一个给定的类，你需要将其从其环境中隔离出来。
- en: To isolate a class you need to provide it with what it needs from the dependencies
    in order to do its job. For example, if a class processes data it extracts from
    the rest of the system, you need to supply that data in a controlled manner that
    doesn’t involve the rest of the system.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隔离一个类，你需要提供它从依赖关系中需要的东西，以便它能够完成其工作。例如，如果一个类处理从系统其余部分提取的数据，你需要以受控的方式提供这些数据，而不涉及系统的其余部分。
- en: Formally, the class being tested is known as the *caller*, and the classes it
    depends on are known as *collaborators*. The goal is to provide controlled implementations
    of all the collaborators so the caller can be tested by itself.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，正在被测试的类被称为*调用者*，它所依赖的类被称为*协作者*。目标是提供所有协作者的受控实现，以便调用者可以单独进行测试。
- en: In this section we’ll look at an example similar to the one shown in [chapter
    7](kindle_split_019.html#ch07) on Spring. It’s simple enough to follow without
    being totally artificial. The example is a classic bank account. There’s an `Account`
    class, an `AccountDAO` interface, a `File-AccountDAO` implementation, and an `AccountService`
    class. The layout is shown in [figure 6.3](#ch06fig03). The idea is that the service
    will have a method called `transferFunds` that sets transaction boundaries, the
    DAO class does persistence for the `Account`, and the `Account` itself is just
    an entity that will be saved and restored from some persistence structure.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一个与[第7章](kindle_split_019.html#ch07)中展示的类似示例。它足够简单，易于理解，但又不完全是人为的。示例是一个经典的银行账户。有一个`Account`类，一个`AccountDAO`接口，一个`File-AccountDAO`实现，以及一个`AccountService`类。布局如图[6.3](#ch06fig03)所示。想法是服务将有一个名为`transferFunds`的方法，该方法设置事务边界，DAO类为`Account`执行持久化，而`Account`本身只是一个将被保存和从某些持久化结构中恢复的实体。
- en: Figure 6.3\. A UML diagram of a simple banking system that uses a service, and
    a DAO implementation based on flat files. Dashed open arrows represent dependencies,
    solid open arrows are associations, and the dashed closed arrow indicates implementation.
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. 使用服务和一个基于平面文件的DAO实现的简单银行系统的UML图。虚线开放箭头表示依赖关系，实线开放箭头是关联，虚线闭合箭头表示实现。
- en: '![](06fig03_alt.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig03_alt.jpg)'
- en: In this case I’ll use a simple file for persistence. Normally I would use a
    database, but I want to illustrate how to do a unit test in Groovy with a stub
    representing the file. In the process I’ll get to discuss the difference between
    unit tests and integration tests. So far the tests in this chapter haven’t tried
    to mock any dependent objects, so they can be considered integration tests. Now
    I’ll look at doing true unit tests.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将使用一个简单的文件进行持久化。通常我会使用数据库，但我想说明如何使用代表文件的存根在Groovy中进行单元测试。在这个过程中，我将讨论单元测试和集成测试之间的区别。到目前为止，本章中的测试还没有尝试模拟任何依赖对象，因此它们可以被认为是集成测试。现在我将查看如何进行真正的单元测试。
- en: In addition to the basic classes, [figure 6.3](#ch06fig03) also shows where
    the techniques in the following subsections (coerced closures and expandos) will
    be used for testing.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本类之外，[图6.3](#ch06fig03)还显示了以下小节（强制闭包和展开）中将要使用的技术。
- en: A (programmatic) client would use the banking system by invoking methods on
    the service class, `AccountService`, which presumably would be transactional.
    The service class uses implementations of the `AccountDAO` interface to work with
    individual accounts. The `Account` class itself is a simple POJO.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: （程序性）客户端会通过在服务类`AccountService`上调用方法来使用银行系统，这个服务类可能具有事务性。服务类使用`AccountDAO`接口的实现来处理单个账户。`Account`类本身是一个简单的POJO。
- en: The next sections show the implementation code for the service and DAO, and
    illustrate how to use coerced closures and expandos to represent dependent objects.
    Specifically, when testing the logic in the service class a closure is used to
    represent the DAO. When testing the DAO implementation an expando stands in for
    the `File` class.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的几节展示了服务和DAO的实现代码，并说明了如何使用强制闭包和扩展来表示依赖对象。具体来说，当在服务类中测试逻辑时，使用闭包来表示DAO。当测试DAO实现时，扩展体代替了`File`类。
- en: 6.3.1\. Coerced closures
  id: totrans-557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 强制闭包
- en: Let me start with the `AccountService`, as shown in the next listing.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 让我从下一列表中的`AccountService`开始。
- en: 'Listing 6.16\. `AccountService` (in Java): uses the `AccountDAO` to find `Accounts`'
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.16\. `AccountService`（Java）：使用`AccountDAO`查找`Accounts`
- en: '![](144fig01_alt.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![144fig01_alt.jpg](144fig01_alt.jpg)'
- en: 'Again, to keep things simple, the `AccountService` has only two business methods:
    a `transferFunds` method to move money from one account to another, and a `get-Balance`
    method that delegates to the corresponding method in `Account`. Both methods take
    integer `id`s as arguments and use the `AccountDAO` to look up the corresponding
    accounts. Therefore, in order to do its job the `AccountService` needs an `AccountDAO`
    instance.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，为了保持简单，`AccountService`只有两个业务方法：一个`transferFunds`方法用于将资金从一个账户转移到另一个账户，一个`get-Balance`方法委托给`Account`中的相应方法。这两个方法都接受整数`id`作为参数，并使用`AccountDAO`查找相应的账户。因此，为了完成其工作，`AccountService`需要一个`AccountDAO`实例。
- en: The `AccountService` is tied to the `AccountDAO`. A true unit test would test
    this class in isolation, meaning I need to provide some kind of stub for the `AccountDAO`
    class. `AccountDAO` is actually an interface, as shown in the next listing.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountService`与`AccountDAO`相关联。真正的单元测试会单独测试这个类，这意味着我需要为`AccountDAO`类提供一个某种存根。`AccountDAO`实际上是一个接口，如下一列表所示。'
- en: Listing 6.17\. The `AccountDAO` interface, with CRUD methods for the `Account`
    class
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.17\. `AccountDAO`接口，包含`Account`类的CRUD方法
- en: '[PRE67]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If I create a stub implementation of the `AccountDAO` interface, I need to
    implement all these methods. Notice, however, that the `AccountService` only uses
    one method out of the interface: `findAccountById`. That’s the only method I actually
    need. Unfortunately, I can’t implement only that method. When implementing an
    interface I need to implement all its methods, whether I plan to use them or not.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我创建了一个`AccountDAO`接口的存根实现，我需要实现所有这些方法。但是请注意，`AccountService`只使用接口中的一个方法：`findAccountById`。这正是我实际需要的方法。不幸的是，我无法只实现这个方法。在实现接口时，我需要实现所有它的方法，无论我是否打算使用它们。
- en: I can use a Groovy technique to avoid all the extra work. If I provide a closure
    with the same argument list as the method I care about, I can then “coerce” the
    closure into the interface. The closure becomes the implementation of all the
    methods in the interface with the same argument list.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用Groovy技术来避免所有额外的劳动。如果我为关心的方法提供具有相同参数列表的闭包，我就可以将闭包“强制”为接口。闭包成为具有相同参数列表的接口中所有方法的实现。
- en: 'In this case I want to provide an implementation for the `findAccountById`
    method, which takes an integer `id` and returns an `Account`. I’m going to use
    a map to accomplish this:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我想为`findAccountById`方法提供一个实现，该方法接受一个整数`id`并返回一个`Account`。我将使用一个映射来完成这个任务：
- en: '[PRE68]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `Account` class (not shown, but it’s a simple POJO contained in the book
    source code) has a two-argument constructor that takes an `id` and an initial
    `balance`. I instantiated two accounts with IDs 1 and 2 and added them to a map
    under the ID values. Now I need the closure that implements my method:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account`类（未显示，但它是一个简单的POJO，包含在书籍源代码中）有一个接受`id`和初始`balance`的两个参数的构造函数。我创建了两个ID为1和2的账户，并将它们添加到以ID值为基础的映射中。现在我需要实现我的方法的闭包：'
- en: '[PRE69]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: That’s a one-argument closure whose dummy variable, again called `id`, returns
    the `Account` stored under that ID. With that machinery in place I can provide
    a stub implementation for the DAO to the service class, as shown in the next listing.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单参数闭包，其占位符变量再次称为`id`，返回存储在该ID下的`Account`。有了这个机制，我可以为服务类提供一个DAO的存根实现，如以下列表所示。
- en: Listing 6.18\. A JUnit 4 test case for the `AccountService`, in Groovy, with
    a stubbed DAO
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.18\. `AccountService`的JUnit 4测试用例，使用Groovy编写，并带有存根化的DAO
- en: '![](145fig01_alt.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![](145fig01_alt.jpg)'
- en: In the `setUp` method (with the `@Before` annotation), I use the `as` operator
    to treat the closure as an `AccountDAO` interface. That means the closure will
    be used as an implementation for all the methods in the interface. Because the
    only method used in the DAO interface was `findAccountById`, I can assign a single
    coerced closure to the `dao` property in the service (which goes through the `setDao`
    method, as usual), and I’m done. The `testTransferFunds` method verifies that
    the initial balances of the two accounts are as expected, does the transfer, and
    then checks that the updated balances are correct, keeping in mind that comparing
    doubles requires a third argument representing the precision.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setUp`方法（带有`@Before`注解）中，我使用`as`运算符将闭包视为`AccountDAO`接口。这意味着闭包将被用作接口中所有方法的实现。因为DAO接口中使用的唯一方法是`findAccountById`，所以我可以将一个转换后的闭包分配给服务中的`dao`属性（通常通过`setDao`方法进行），然后完成。`testTransferFunds`方法验证两个账户的初始余额是否符合预期，执行转账操作，然后检查更新的余额是否正确，考虑到比较双精度浮点数需要一个表示精度的第三个参数。
- en: If I need to implement multiple methods in the interface using a closure, I
    can supply a map of closures to method names, where each closure has the proper
    argument list. For example, the following listing shows a map of closures representing
    the entire `AccountDAO` interface and a few tests showing how it works.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我需要在接口中使用闭包实现多个方法，我可以提供一个闭包到方法名的映射，其中每个闭包都有正确的参数列表。例如，以下列表显示了一个表示整个`AccountDAO`接口的闭包映射和一些展示其工作方式的测试。
- en: Listing 6.19\. Using a map of closures to implement an interface
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.19\. 使用闭包映射实现接口
- en: '![](146fig01_alt.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![](146fig01_alt.jpg)'
- en: The bottom line is that closures can be used as the implementation of an interface,
    and that this is an easy and very powerful technique for providing stub implementations
    of collaborators.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 核心观点是闭包可以用作接口的实现，而且这是一种简单且非常强大的技术，用于提供协作者的存根实现。
- en: Next I want to test the DAO implementation class that uses a flat file to store
    the accounts. The goal in this case will be to provide a stub that stands in for
    the `java.io.File` class.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我想测试使用平面文件存储账户的DAO实现类。在这种情况下，目标将是提供一个存根来代替`java.io.File`类。
- en: 6.3.2\. The Expando class
  id: totrans-580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. Expando类
- en: I’m going to use a file as my persistence mechanism, but for the testing environment
    I’m going to keep a cache of accounts in a map. This means that when I initialize
    the DAO I need to read the file and store the accounts found there in a map, and
    any time I make a change to an account I need to write the results back to a file.
    When reading the data I can just use the map—unless the file has been changed,
    in which case I’ll have to re-read the file.^([[8](#ch06fn08)])
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 我打算使用文件作为我的持久化机制，但在测试环境中，我将保持一个账户的缓存映射。这意味着当我初始化DAO时，我需要读取文件并将找到的账户存储在映射中，每次我对账户进行更改时，我需要将结果写回文件。在读取数据时，我只需使用映射——除非文件已被更改，在这种情况下，我必须重新读取文件.^([[8](#ch06fn08)])
- en: ⁸ I got the idea of using an expando this way from Jeff Brown, indefatigable
    coauthor of *Definitive Guide to Grails 2* (Apress, 2013).
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我从Jeff Brown那里得到了这种使用expando的想法，他是《Grails 2 definitive guide》（Apress，2013年）不知疲倦的合著者。
- en: 'To start, here are the attributes in my `FileAccountDAO` class:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是我的`FileAccountDAO`类中的属性：
- en: '[PRE70]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: I deliberately declared the variable representing the accounts file to be of
    type `def` rather than `File`, for reasons I’ll explain when I create the stub.
    The other attributes are a map to represent the accounts cache (using generics,
    which Groovy compiles successfully but doesn’t enforce^([[9](#ch06fn09)])), a
    `private` `static` integer that will be my primary key generator, and a Boolean
    flag to indicate whether the accounts cache needs to be refreshed.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意将表示账户文件的变量声明为 `def` 类型而不是 `File` 类型，原因将在创建存根时解释。其他属性是一个映射，用于表示账户缓存（使用泛型，Groovy
    可以成功编译但不会强制执行^([[9](#ch06fn09)]))，一个 `private` `static` 整数，将作为我的主要键生成器，以及一个布尔标志，用于指示账户缓存是否需要刷新。
- en: ⁹ That’s another subtle trap. The syntax for Java generics compiles in Groovy,
    but just because you declared a `List<Integer>` doesn’t mean you can’t add instances
    of `String`, `Date`, or `Employee` if you want to. In Groovy, think of the generic
    declaration as nothing more than documentation.
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 这又是一个微妙的陷阱。Java 泛型的语法在 Groovy 中可以编译，但仅仅因为你声明了一个 `List<Integer>` 并不意味着你不能添加
    `String`、`Date` 或 `Employee` 的实例。在 Groovy 中，将泛型声明视为仅仅是文档。
- en: 'Here’s the method used to read the accounts from the file:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用来从文件中读取账户的方法：
- en: '[PRE71]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Each account is stored as plain text, with a comma separating the `id` from
    the `balance`. Reading accounts uses the `splitEachLine` method that takes two
    arguments: the delimiter (a comma in this case) and a closure that defines what
    to do with the resulting list. The closure says to parse the ID and balance into
    the proper data types, instantiate an account with the resulting values, and save
    it in the map. Then I need to set the `nextId` variable to one more than the max
    of the IDs used so far, which gives me an opportunity to use the cool Elvis operator.^([[10](#ch06fn10)])
    Finally, because this method refreshes the cache, I can set the `dirty flag` to
    `false`.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 每个账户都以纯文本形式存储，用逗号将 `id` 和 `balance` 分隔开。读取账户使用 `splitEachLine` 方法，该方法接受两个参数：分隔符（在这种情况下是逗号）和一个闭包，该闭包定义了对结果列表的操作。闭包指示将
    ID 和余额解析到适当的数据类型，使用结果值实例化一个账户，并将其保存到映射中。然后我需要将 `nextId` 变量设置为迄今为止使用的 ID 的最大值加一，这给了我使用酷炫的
    Elvis 操作符的机会.^([[10](#ch06fn10)]) 最后，因为此方法刷新了缓存，我可以将 `dirty flag` 设置为 `false`。
- en: ^(10) I don’t really go out of my way to find excuses to use the cool Elvis
    operator, but I don’t pass them up when they present themselves either.
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10) 我并不是刻意寻找使用酷炫的 Elvis 操作符的借口，但当我遇到它们时，也不会错过。
- en: 'The corresponding method to write out the accounts is shown next:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例显示了写入账户的相应方法：
- en: '[PRE72]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `withWriter` method is from the Groovy JDK and is added to the `java.io.File`
    class. It provides an output writer wrapped around the file that closes automatically
    when the closure argument completes. The closure writes the ID and balance of
    each account to a single line in the file, separated by a comma. Because this
    method changes the file, it sets the `dirty` flag to `true` so that the class
    knows the cache needs to be refreshed.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '`withWriter` 方法来自 Groovy JDK，并被添加到 `java.io.File` 类中。它提供了一个包装在文件周围的输出写入器，当闭包参数完成时自动关闭。闭包将每个账户的
    ID 和余额写入文件的同一行，用逗号分隔。因为此方法会更改文件，所以它将 `dirty` 标志设置为 `true`，以便类知道缓存需要刷新。'
- en: With those methods in place, the next listing shows the complete DAO implementation.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法到位之后，下一列表显示了完整的 DAO 实现。
- en: Listing 6.20\. The complete `FileAccountDAO` implementation, in Groovy
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.20\. 完整的 `FileAccountDAO` 实现示例，使用 Groovy
- en: '![](148fig01.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![图片](148fig01.jpg)'
- en: The business methods are straightforward, based on the accounts cache (the map).
    The only complication is determining whether or not the cache needs to be refreshed
    before returning a value. Methods that change the accounts force a write to the
    file. Methods that retrieve them just need to check if a read is necessary.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 业务方法很简单，基于账户缓存（映射）。唯一的复杂性是确定在返回值之前是否需要刷新缓存。更改账户的方法会强制写入文件。检索它们的方法只需要检查是否需要读取。
- en: That’s a fair amount of code, and I would feel very uncomfortable if it wasn’t
    tested. An integration test would simply supply an actual file to the DAO, and
    I have such a test in the book’s source code. A unit test, however, would remove
    the dependency on the `File` class. That’s where the `Expando` comes in.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当多的代码，如果它没有被测试，我会感到非常不舒服。集成测试会简单地向 DAO 提供一个实际的文件，我在书中的源代码中就有这样一个测试。然而，单元测试会消除对
    `File` 类的依赖。这就是 `Expando` 发挥作用的地方。
- en: The `groovy.util.Expando` class creates an object with no attributes or methods
    of its own, other than the ones it inherits. The cool part is that you can treat
    an instance of `Expando` as though it was a map, where the keys are the names
    of properties or methods, and the values are the property values or method implementations.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy.util.Expando` 类创建了一个没有任何属性或自己方法的对象，除了它继承的方法。酷的地方在于你可以将 `Expando` 的实例当作一个映射来处理，其中键是属性或方法的名称，值是属性值或方法实现。'
- en: '|  |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Expando
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Expando
- en: A `groovy.util.Expando` is a class that creates an empty object to which you
    can add properties and methods as desired.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy.util.Expando` 是一个类，你可以创建一个空对象，然后根据需要向其中添加属性和方法。'
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To see this in action, let me create an `Expando` to act as a replacement for
    the file in my DAO. First I have to see what methods in `File` need to be represented.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个动作，让我创建一个 `Expando` 来作为我的 DAO 中文件的替代品。首先，我必须看到 `File` 中哪些方法需要表示。
- en: 'Here are the methods in `AccountDAO` that use the `accountsFile` dependency.
    The methods I need to mock are in bold:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `AccountDAO` 中使用 `accountsFile` 依赖项的方法。我需要模拟的方法用粗体标出：
- en: '[PRE73]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Examining the previous listing shows that I’m using `splitEachLine` and `withWriter`
    in the `File` class and the `println` method from the `Writer` class, so these
    methods need to be implemented in the `Expando`.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面的列表显示，我在 `File` 类中使用了 `splitEachLine` 和 `withWriter`，以及 `Writer` 类的 `println`
    方法，因此这些方法需要在 `Expando` 中实现。
- en: 'All of those methods are already implemented in the `String` class. Therefore,
    why not use a string to represent the file? I’ll add a string property to the
    `Expando` and then implement all the needed methods so that they delegate to the
    corresponding methods on the string. Here’s the resulting code:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法已经在 `String` 类中实现了。因此，为什么不使用字符串来表示文件呢？我将在 `Expando` 中添加一个字符串属性，然后实现所有需要的功能，以便它们委托到字符串上的相应方法。以下是生成的代码：
- en: '[PRE74]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: First I instantiate the `Expando`. Next I add a `data` property to it and assign
    it to an empty string. The `println` method is then implemented through the `append`
    method on `String`. The `withWriter` method is assigned a closure that returns
    a new `StringWriter`. Finally, the `splitEachLine` method is assigned to a two-argument
    closure that delegates to the corresponding existing method on `String`.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我实例化 `Expando`。然后，我向其中添加一个 `data` 属性并将其分配给一个空字符串。然后通过 `String` 上的 `append`
    方法实现 `println` 方法。`withWriter` 方法被分配一个返回新的 `StringWriter` 的闭包。最后，`splitEachLine`
    方法被分配给一个接受两个参数的闭包，该闭包委托到 `String` 上对应现有的方法。
- en: 'All that’s left is to substitute the `Expando` for the file in the DAO:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是用 `Expando` 替换 DAO 中的文件：
- en: '[PRE75]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here at last is the reason I needed to declare the `accountsFile` variable with
    `def` rather than `File`. An `Expando` isn’t a file and isn’t related to the `File`
    class in any way, so a `File` reference would be a problem. If I use `def` to
    declare the variable instead, I can freely assign the `Expando` variable to my
    variable. Duck typing does the rest; every time a method is invoked on the variable,
    the corresponding method is called on the `Expando`.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这就是为什么我需要用 `def` 而不是 `File` 来声明 `accountsFile` 变量的原因。`Expando` 不是一个文件，并且与
    `File` 类没有任何关系，所以 `File` 引用会是一个问题。如果我用 `def` 来声明变量，我就可以自由地将 `Expando` 变量分配给我的变量。鸭子类型会完成剩下的工作；每次在变量上调用方法时，都会在
    `Expando` 上调用相应的方法。
- en: '|  |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Dynamic Typing to The Rescue
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态类型来拯救
- en: If I declare a reference using `def`, I can assign it to anything. When I invoke
    methods on it I’m relying on the methods being there in whatever class I’ve used.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我使用 `def` 声明一个引用，我可以将其分配给任何东西。当我调用它的方法时，我依赖于在所使用的任何类中都有这些方法。
- en: '|  |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The next listing shows the complete unit test for the file DAO.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了文件 DAO 的完整单元测试。
- en: Listing 6.21\. `FileAccountDAO` unit test, using an `Expando` to stub the `File`
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.21\. 使用 `Expando` 模拟 `File` 的 `FileAccountDAO` 单元测试
- en: '[PRE76]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In a way, I got lucky with this example. The variable I needed to stub, `accountsFile`,
    was exposed as a property, so I could assign the `Expando` to it from outside.
    What if that’s not the case? What if the variable is instantiated inside the class?
    Can anything be done then?
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，我在这个例子中很幸运。我需要模拟的变量 `accountsFile` 被公开为一个属性，所以我可以从外部将其分配给它。如果情况不是这样呢？如果变量是在类内部实例化的呢？那时能做些什么呢？
- en: If I’m limited to Java, I’m out of luck.^([[11](#ch06fn11)]) In fact, even mocking
    frameworks have trouble with this situation. Fortunately, Groovy has a built-in
    mechanism for handling exactly this problem. The classes I need are called `StubFor`
    and `MockFor`.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我受限于Java，我就没有运气了.^([11](#ch06fn11))) 事实上，甚至模拟框架也难以处理这种情况。幸运的是，Groovy有一个内置机制来处理这个问题。我需要的类被称为`StubFor`和`MockFor`。
- en: ^(11) Unless I have AspectJ available, but even then the solution is complicated.
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([11](http://en.wikipedia.org/wiki/Integration_testing)) 除非我有AspectJ可用，但即使那样，解决方案也很复杂。
- en: 6.3.3\. StubFor and MockFor
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3. StubFor和MockFor
- en: A typical Groovy developer doesn’t necessarily spend a lot of time metaprogramming,
    but they sure reap the benefits of it. I use builders in several places in this
    book. Domain-specific languages (DSLs) like GORM, are built through metaprogramming
    techniques. The whole Groovy JDK is created through metaclass manipulation. In
    the last section I used an `Expando` to create a test object, and that only works
    in a language that supports metaprogramming. After a while you get used to metaprogramming
    capabilities and aren’t really surprised by their benefits any more.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Groovy开发者不一定花很多时间进行元编程，但他们确实享受到了它的好处。我在这本书的几个地方使用了构建器。像GORM这样的领域特定语言（DSL）是通过元编程技术构建的。整个Groovy
    JDK是通过元类操作创建的。在上一个章节中，我使用了一个`Expando`来创建测试对象，而这只适用于支持元编程的语言。过了一段时间，你会习惯于元编程的能力，并且不再对它们的益处感到惊讶。
- en: In this section I’m going to show a technique that, even after all my years
    of programming in Groovy, still feels like magic. I know it works, and I use it
    wherever I can, but every time it happens I have to take a moment to sit back
    and smile at how cool it is.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将展示一种技巧，即使在我多年的Groovy编程经验之后，它仍然感觉像是魔法。我知道它有效，并且我会在任何可能的地方使用它，但每次发生这种情况，我都要花点时间坐下来，微笑着欣赏它的酷炫。
- en: Let me go directly to the example I want to show and then explain the stub technique.
    Rather than use the bank account system described so far, let me remind you of
    the geocoder example I’ve used in several chapters of this book. The next listing
    shows the `Geocoder` class that’s part of the Groovy Baseball system described
    in [chapter 2](kindle_split_012.html#ch02).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 让我直接展示我想展示的例子，然后解释存根技术。与其使用迄今为止描述的银行账户系统，不如让我提醒你我在本书的几个章节中使用的地理编码器示例。下面的列表显示了Groovy棒球系统中的一部分`Geocoder`类，该系统在[第2章](kindle_split_012.html#ch02)中描述。
- en: Listing 6.22\. The Groovy Baseball `Geocoder` class, revisited
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.22。回顾Groovy棒球`Geocoder`类
- en: '![](152fig01_alt.jpg)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![图片](152fig01_alt.jpg)'
- en: I have a test for this class, but it’s most definitely an integration test.
    The following listing shows a JUnit 4 test for the geocoder, written in Groovy.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个类编写了一个测试，但毫无疑问，它是一个集成测试。下面的列表显示了一个用Groovy编写的JUnit 4测试，用于地理编码器。
- en: 'Listing 6.23\. `GeocoderIntegrationTests.groovy`: a JUnit 4 test for the geocoder'
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.23。`GeocoderIntegrationTests.groovy`：地理编码器的JUnit 4测试
- en: '![](152fig02_alt.jpg)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![图片](152fig02_alt.jpg)'
- en: A `Stadium` has a street, city, state, latitude, and longitude, and the geocoder’s
    job is to take the address, invoke Google’s geocoder service using it, and use
    the result to update the latitude and longitude. After setting up a `Stadium`
    instance corresponding to Google’s home office, the test invokes the `fillInLatLng`
    method and checks that the updated latitude and longitude values are within tolerances.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Stadium`（体育场）有街道、城市、州、纬度和经度，地理编码器的任务是获取地址，使用Google的地理编码服务，并使用结果更新纬度和经度。在设置与Google总部办公室对应的`Stadium`实例后，测试调用`fillInLatLng`方法，并检查更新的纬度和经度值是否在公差范围内。
- en: This works just fine, but to do its job it has to access the Google geocoder
    service. That’s why it’s an integration test.^([[12](#ch06fn12)])
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很正常，但它要完成其工作，必须访问Google地理编码服务。这就是为什么它是一个集成测试.^([12](#ch06fn12)))
- en: ^(12) See [http://en.wikipedia.org/wiki/Integration_testing](http://en.wikipedia.org/wiki/Integration_testing)
    for the definition of an integration test.
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([12](http://en.wikipedia.org/wiki/Integration_testing)) 请参阅关于集成测试的定义。
- en: What happens if I’m not online? More formally, is there any way I can test the
    logic in the `fillInLatLng` method without relying on the external URL?
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我没有在线怎么办？更正式地说，有没有任何方法可以在不依赖外部URL的情况下测试`fillInLatLng`方法中的逻辑？
- en: The online access is being handled through the `parse` method of `XmlSlurper`.
    That method takes a URL, accesses it, downloads the XML response, parses it into
    a DOM tree, and returns the root element. In a normal mock I’d like to replace
    the expression “`new XmlSlurper().parse(url)`” with a pre-defined DOM tree. If
    the slurper had been supplied from outside this class, I could create a stub and
    force the `parse` method to return what I want. Unfortunately, the slurper is
    instantiated right inside the method.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在线访问是通过`XmlSlurper`的`parse`方法处理的。该方法接受一个 URL，访问它，下载 XML 响应，将其解析为 DOM 树，并返回根元素。在一个正常的模拟中，我想用预定义的
    DOM 树替换表达式“`new XmlSlurper().parse(url)`”。如果`slurper`是从外部提供到这个类中的，我可以创建一个存根并强制`parse`方法返回我想要的。不幸的是，`slurper`是在方法内部实例化的。
- en: Here’s where Groovy’s `MockFor` and `StubFor` classes come in.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 Groovy 的`MockFor`和`StubFor`类就派上用场了。
- en: '|  |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Stubs vs. mocks**'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**存根与模拟**'
- en: Mocks have strong expectations, while stubs do not. That means that a test involving
    a mock fails if the collaborator methods are not called the proper number of times
    and in the proper order. With stubs, expectations are looser; you don’t need to
    call the methods in the proper order, though it does enforce the multiplicity
    requirement.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象有强烈的期望，而存根则没有。这意味着如果协作方法没有被正确次数和顺序调用，涉及模拟对象的测试将失败。对于存根，期望更宽松；你不需要按正确的顺序调用方法，尽管它确实强制了多重性要求。
- en: Conceptually, a stub is simply a stand-in for the collaborator, so the focus
    is on the caller. Because a mock’s expectations are strong, you’re effectively
    testing the interaction between the caller and the collaborator, known as the
    *protocol*.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，存根只是协作对象的替代品，因此重点是调用者。因为模拟的期望很强，你实际上是在测试调用者和协作者之间的交互，这被称为*协议*。
- en: '|  |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 6.4](#ch06fig04) shows how I want the stub to work.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.4](#ch06fig04) 展示了我希望存根如何工作。'
- en: Figure 6.4\. The geocoder relies on an `XmlSlurper` instantiated locally to
    do its job. The goal is to modify its `parse` method to return the needed value,
    even though the slurper is a local variable in the test method.
  id: totrans-645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4。地理编码器依赖于在本地实例化的`XmlSlurper`来完成其工作。目标是修改其`parse`方法以返回所需值，即使`slurper`是测试方法中的局部变量。
- en: '![](06fig04_alt.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig04_alt.jpg)'
- en: 'I want the `parse` method of the slurper to return the root of a DOM tree that
    looks like what the Google geocoder would have returned had I been able to access
    it. The easiest way to get that value is to set up the proper XML tree and parse
    it ahead of time:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让`slurper`的`parse`方法返回一个 DOM 树的根，这个树看起来就像谷歌地理编码器返回的那样，如果我能够访问它的话。获取这个值的最简单方法是在测试之前设置正确的
    XML 树并解析它：
- en: '[PRE77]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The XML string has the proper latitude and longitude for the Google home office.
    To get the proper root value I invoke the `parseText` method of the `XmlSlurper`.
    My `Geocoder` class can take that root and walk the tree as usual to get the latitude
    and longitude.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: XML 字符串具有谷歌总部办公室的正确纬度和经度。为了获取正确的根值，我调用`XmlSlurper`的`parseText`方法。我的`Geocoder`类可以接受这个根并像通常一样遍历树以获取纬度和经度。
- en: 'The challenge is this: how do I get my own `Geocoder` to use this implementation
    when there’s no obvious way to inject it? The solution is to use the `StubFor`
    class and set the expectations around it:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战是：在没有明显方法注入的情况下，我如何让我的`Geocoder`使用这个实现？解决方案是使用`StubFor`类并围绕它设置期望：
- en: '[PRE78]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `StubFor` constructor takes a class reference and builds a stub around it.
    Then I “demand” that the `parse` method return the root of the tree calculated
    in the previous fragment.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '`StubFor` 构造函数接受一个类引用并在其周围构建一个存根。然后我“要求”`parse`方法返回之前片段中计算出的树的根。'
- en: 'To get Groovy to use the new stub, invoke the test inside a closure argument
    to the `use` method:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 Groovy 使用新的存根，请在`use`方法的闭包参数中调用测试：
- en: '[PRE79]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `use` closure is the key. Through the magic of Groovy metaprogramming, when
    the `parse` method of `XmlSlurper` is accessed inside the `fillInLatLng` method,
    the demanded version is used rather than the actual implementation. The result
    is that the business logic of the `fillInLatLng` method is tested, without relying
    on the slurper itself.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`use`闭包是关键。通过 Groovy 元编程的魔力，当在`fillInLatLng`方法内部访问`XmlSlurper`的`parse`方法时，使用的是所需版本而不是实际实现。结果是测试了`fillInLatLng`方法的业务逻辑，而不依赖于`slurper`本身。'
- en: The next listing shows the complete test. To make absolutely sure that the online
    version of the geocoder is not being used, I created a stadium with the wrong
    address. The only way the test passes is if the slurper returns the rigged values.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了完整的测试。为了确保绝对不使用地理编码器的在线版本，我创建了一个地址错误的体育场。测试通过的唯一方式是如果 slurper 返回了预设的值。
- en: 'Listing 6.24\. GeocoderUnitTest.groovy: tests geocoder even if not online'
  id: totrans-657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 6.24\. GeocoderUnitTest.groovy: 测试地理编码器即使不在线'
- en: '![](154fig01_alt.jpg)'
  id: totrans-658
  prefs: []
  type: TYPE_IMG
  zh: '![154fig01_alt.jpg](154fig01_alt.jpg)'
- en: The test sets up a `Stadium` instance that deliberately has the wrong address.
    The correct root of the DOM tree is generated using the string data, and the `demand`
    property of the stub is used to return it. By executing the test inside the `use`
    block, the correct answer is supplied at the proper moment, and the test succeeds.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设置了一个地址错误的 `Stadium` 实例。使用字符串数据生成正确的 DOM 树根，并使用存根的 `demand` 属性返回它。通过在 `use`
    块内执行测试，正确的答案在适当的时候提供，测试成功。
- en: The `StubFor` and `MockFor` APIs are far more extensive than what’s being shown
    here. You can demand that a method returns different preset values each time you
    call it. You can verify that the methods are called the proper number of times
    in the proper order by using the `verify` method on `StubFor` (`MockFor` does
    that automatically). See the API for details.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '`StubFor` 和 `MockFor` API 的功能远比这里展示的要多。你可以要求每次调用方法时返回不同的预设值。你可以通过在 `StubFor`
    上使用 `verify` 方法（`MockFor` 会自动这样做）来验证方法是否以正确的次数和顺序被调用。有关详细信息，请参阅 API。'
- en: The only real limitation on the `StubFor` and `MockFor` classes is that they
    can only be used to replace Groovy implementations. You can’t supply a Java class
    and have it work. Still, if your service is implemented in Groovy, they are an
    invaluable addition to your testing arsenal.^([[13](#ch06fn13)])
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '`StubFor` 和 `MockFor` 类的唯一真正限制是它们只能用来替换 Groovy 实现。你不能提供一个 Java 类并让它工作。尽管如此，如果你的服务是用
    Groovy 实现的，它们仍然是你的测试工具箱中的无价之宝。^([[13](#ch06fn13)])'
- en: '^(13) Candor compels me to admit that I worked out how to use `StubFor` and
    `MockFor` over a few days, and then did what I should have done originally: looked
    them up in *Groovy in Action*. GinA (as it was then known; the second edition
    is ReGinA) had it all laid out over a few pages, nice and neat. There’s a reason
    that *Groovy in Action* is still my all-time favorite technical book.'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（13）坦白地说，我花了几天时间才弄清楚如何使用 `StubFor` 和 `MockFor`，然后做了我最初应该做的事情：在 *Groovy in Action*
    中查找它们。GinA（那时它被称为；第二版是 ReGinA）在几页纸上详细介绍了，非常整洁。这就是为什么 *Groovy in Action* 仍然是我有史以来最喜欢的技术书籍。
- en: '|  |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (mocking dependencies)**'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（模拟依赖项）**'
- en: '**1**.  To easily create a stub of an interface, use closures to implement
    the methods. This is known as *closure coercion*.'
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 要轻松创建接口的存根，使用闭包来实现方法。这被称为 *闭包强制转换*。'
- en: '**2**.  The `Expando` class has no properties or methods, but both can be added
    at runtime to configure an object to do what you want.'
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. `Expando` 类没有属性或方法，但两者都可以在运行时添加以配置对象执行你想要的操作。'
- en: '**3**.  The `StubFor` and `MockFor` classes in the standard library can be
    used to create mock objects *even when they’re replacing local variables* in the
    test fixture.^([[14](#ch06fn14)])'
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 在标准库中的 `StubFor` 和 `MockFor` 类可以用来创建模拟对象，即使它们在测试用例中替换了局部变量。^([[14](#ch06fn14)])'
- en: ''
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^(14) If you read nothing else in this chapter, take a look at that.
  id: totrans-669
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（14）如果你在这个章节中什么都不读，那就看看这一点。
- en: '|  |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: So far every technique in this chapter has been based on existing classes in
    the Groovy standard library. One new testing library, however, has been gaining
    momentum in the Groovy community, and not just because it has a clever name. The
    Spock framework is simple to learn, easy to use, and the subject of the next section.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章中介绍的所有技术都是基于 Groovy 标准库中的现有类。然而，有一个新的测试库在 Groovy 社区中越来越受欢迎，不仅仅是因为它有一个巧妙的名称。Spock
    框架易于学习，易于使用，并且是下一节的主题。
- en: '6.4\. The future of testing: Spock'
  id: totrans-672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 测试的未来：Spock
- en: The Spock framework yields more productivity for less effort than any other
    framework I’ve encountered. Spend a small amount of time with Spock (for example,
    through the discussions in this section), and you can immediately be productive.
    Spock provides both tests and a solid mocking capability in an easy-to-use package.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 与我遇到的其他任何框架相比，Spock 框架以更少的努力带来更高的生产力。花一点时间与 Spock 一起（例如，通过本节中的讨论），你就可以立即变得高效。Spock
    提供了测试和强大的模拟能力，易于使用。
- en: According to the developer of the framework,^([[15](#ch06fn15)]) the name Spock
    is a blend of “specification” and “mock.” That may even be true. It seems more
    likely, however, that somebody just liked the name Spock and the rest is clever
    rationalization.^([[16](#ch06fn16)]) The result, inevitably, is that any discussion
    of the framework results in a series of *Star Trek*-related puns. My original
    plan was to avoid them, but it’s practically impossible.^([[17](#ch06fn17)])
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 根据框架的开发者，^([15](#ch06fn15))，Spock这个名字是“specification”和“mock”的结合。这可能甚至是真的。然而，似乎更有可能的是，有人只是喜欢Spock这个名字，其余的都是巧妙的合理化。不可避免的结果是，关于该框架的任何讨论都会导致一系列与《星际迷航》相关的双关语。我最初的计划是避免它们，但事实上这是不可能的。^([16](#ch06fn16))^([17](#ch06fn17))
- en: ^(15) Peter Niederweiser, who is active and helpful on the Spock email list.
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([15](#ch06fn15)) 活跃并乐于助人的Peter Niederweiser，他在Spock邮件列表上。
- en: ^(16) Of which I totally approve.
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([16](#ch06fn16)) 我完全赞同。
- en: ^(17) For example, Spock is a *logical* framework for *enterprise* testing.
    Test well, and prosper. I have been, and always shall be, your friendly testing
    framework.
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([17](#ch06fn17)) 例如，Spock是一个用于企业测试的*逻辑*框架。测试得好，就能繁荣昌盛。我一直是，也永远将是，你友好的测试框架。
- en: 6.4.1\. The Search for Spock
  id: totrans-678
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 寻找Spock
- en: The main site for Spock is [http://spockframework.org,](http://spockframework.org,)
    which actually redirects to a Google code project at [https://code.google.com/p/spock/.](https://code.google.com/p/spock/.)
    There you’ll find wiki pages with lots of good information. Like most cool projects
    these days, the source code is hosted at GitHub at [https://github.com/spockframework/spock.](https://github.com/spockframework/spock.)
    You can clone the repository and do a manual build, or you can install the distribution
    from the standard Maven repository.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: Spock的主要网站是[http://spockframework.org，](http://spockframework.org,) 实际上重定向到[https://code.google.com/p/spock/](https://code.google.com/p/spock/)的Google代码项目。在那里你可以找到包含大量有用信息的维基页面。像大多数现代酷项目一样，源代码托管在GitHub上，网址为[https://github.com/spockframework/spock.](https://github.com/spockframework/spock。)你可以克隆存储库并手动构建，或者你可以从标准的Maven仓库安装发行版。
- en: Spock versions are tied to Groovy versions. The latest release version of Spock
    is 0.7-groovy-2.0\. Don’t let the low version number deter you.^([[18](#ch06fn18)])
    The Spock API is simple and easy to use and understand, and its adoption has been
    very rapid.^([[19](#ch06fn19)])
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: Spock版本与Groovy版本相关联。Spock的最新发布版本是0.7-groovy-2.0。不要让低版本号让你气馁。^([18](#ch06fn18))
    Spock API简单易用易懂，其采用速度非常快。^([19](#ch06fn19))
- en: ^(18) Version 1.0 is due out by the time this book appears in print.
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([18](#ch06fn18)) 当这本书印刷出版时，1.0版本应该已经发布。
- en: ^(19) The Spock plugin will be included in Grails by default starting in version
    2.3.
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([19](#ch06fn19)) 从版本2.3开始，Spock插件将默认包含在Grails中。
- en: The Gradle file in the next listing shows the appropriate dependencies to build
    this chapter’s source code.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的Gradle文件显示了构建本章源代码所需的适当依赖关系。
- en: Listing 6.25\. Building and testing with Spock using Gradle
  id: totrans-684
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.25\. 使用Gradle构建和测试Spock
- en: '[PRE80]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The repository at Maven central holds the Groovy distribution and the Spock
    release versions. The dependency is decoded in the usual way, with the group being
    “org.spockframework,” the name (or artifact ID, in Maven speak) being “spock-core,”
    and the version number of 0.7-groovy-2.0\. Note that the Spock version is tied
    to a Groovy version.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: Maven中央仓库保存了Groovy发行版和Spock发布版本。依赖关系以通常的方式解码，组为“org.spockframework”，名称（或Maven中的工件ID）为“spock-core”，版本号为0.7-groovy-2.0。请注意，Spock版本与Groovy版本相关联。
- en: 6.4.2\. Test well, and prosper
  id: totrans-687
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2\. 测试得好，就能繁荣昌盛
- en: Spock tests all extend a superclass called `spock.lang.Specification`. In addition
    to its own methods, the `Specification` class includes the `@RunWith` annotation
    from JUnit. The result is that Spock tests can be run within the normal JUnit
    testing infrastructure.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: Spock测试都扩展了一个名为`spock.lang.Specification`的父类。除了它自己的方法外，`Specification`类还包括JUnit的`@RunWith`注解。结果是，Spock测试可以在正常的JUnit测试基础设施中运行。
- en: The tests themselves all have a common form. Each test method (known as a *fixture*)
    is declared using the `def` keyword, followed by a string that describes what
    the test is supposed to accomplish. Fixture methods normally take no arguments.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身都有一种常见的格式。每个测试方法（称为*固定装置*）都使用`def`关键字声明，后面跟着一个描述测试预期完成什么的字符串。固定装置方法通常不接收任何参数。
- en: '[Listing 6.26](#ch06ex26) shows a simple Spock test to verify some `String`
    behavior. By convention, Spock test cases end in `Spec`. That isn’t a requirement,^([[20](#ch06fn20)])
    but it does help to keep the Spock tests easily identifiable, especially when
    your system uses both Spock and JUnit tests together.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6.26](#ch06ex26) 展示了一个简单的 Spock 测试，用于验证一些 `String` 的行为。按照惯例，Spock 测试用例以
    `Spec` 结尾。这并不是一个要求，^([[20](#ch06fn20)]) 但它确实有助于使 Spock 测试易于识别，尤其是在你的系统同时使用 Spock
    和 JUnit 测试时。'
- en: ^(20) Spock tests in Grails *do* have to end in `Spec`.
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([20](#ch06fn20)) 在 Grails 中，Spock 测试确实必须以 `Spec` 结尾。
- en: Listing 6.26\. A specification verifying basic `java.lang.String` behavior
  id: totrans-692
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.26\. 一个验证基本 `java.lang.String` 行为的规范
- en: '[PRE81]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The class extends `spock.lang.Specification`, which is what makes it a Spock
    test. The spec is testing a `String`, so it has an attribute named `llap`. In
    the `setup` method, the `llap` variable is assigned to the string “Live Long and
    Prosper.” The `setup` method runs before each test, similar to `@Before` in JUnit
    4\. JUnit 3 contains a method called `setUp` that does the same thing, but in
    Spock the `setup` method is written in lowercase, with a `def` keyword.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 该类扩展了 `spock.lang.Specification`，这使得它成为一个 Spock 测试。该规范正在测试一个 `String`，因此它有一个名为
    `llap` 的属性。在 `setup` 方法中，`llap` 变量被赋值为字符串 “Live Long and Prosper。” `setup` 方法在每次测试之前运行，类似于
    JUnit 4 中的 `@Before`。JUnit 3 包含一个名为 `setUp` 的方法，它执行相同的功能，但在 Spock 中，`setup` 方法以小写形式编写，并使用
    `def` 关键字。
- en: The test methods, known as feature methods in the Spock documentation, are written
    in block structure. In each of the test methods shown here, there’s a single block
    called `expect`. The `expect` block consists of a series of Boolean expressions,
    each of which must evaluate to true for the test to pass.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法，在 Spock 文档中被称为特性方法，是以块结构编写的。在下面显示的每个测试方法中，都有一个名为 `expect` 的单个块。`expect`
    块由一系列布尔表达式组成，每个表达式都必须评估为真，测试才能通过。
- en: The three sample tests check (1) the number of characters in the test string;
    (2) that there are four words in the test string, based on splitting the string
    at non-word boundaries; and (3) that the test string has a total of six vowels,
    again based on a regular expression.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个示例测试检查（1）测试字符串中的字符数；（2）基于在非单词边界处拆分字符串，测试字符串中有四个单词；（3）测试字符串总共有六个元音，再次基于正则表达式。
- en: 'Like JUnit 4, Spock tests can verify that exceptions are thrown. Spock tests
    can also verify that exceptions are not thrown. Consider the following two tests,
    which are added to the previous listing:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JUnit 4 类似，Spock 测试可以验证是否抛出了异常。Spock 测试还可以验证没有抛出异常。考虑以下两个测试，它们被添加到之前的列表中：
- en: '[PRE82]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: These tests use the `when`/`then` blocks, which are used as a stimulus/response
    pair. Any code can be added to the `when` block, but the `then` block must consist
    of Boolean expressions, as with `expect`. The expressions are evaluated automatically,
    using the Groovy Truth. This means that non-null references, non-empty strings,
    and non-zero numbers all evaluate to true.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试使用 `when`/`then` 块，这些块用作刺激/响应对。`when` 块中可以添加任何代码，但 `then` 块必须由布尔表达式组成，就像
    `expect` 一样。这些表达式会自动使用 Groovy 真值进行评估。这意味着非空引用、非空字符串和非零数字都会评估为真。
- en: The `charAt` method in `String` throws an exception if its argument is negative
    or beyond the end of the string. The previous two tests show both conditions,
    using the `thrown()` and `notThrown()` methods. The `thrown` method can return
    the exception if you want to process it further, using one of two variations in
    syntax
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类中的 `charAt` 方法如果其参数是负数或者超出了字符串的末尾，将会抛出一个异常。前两个测试展示了这两种情况，使用了 `thrown()`
    和 `notThrown()` 方法。如果你想进一步处理异常，可以使用 `thrown` 方法返回异常，语法上有两种变体。'
- en: '[PRE83]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: or
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE84]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: where the `Exception` can be any specific exception class.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `Exception` 可以是任何特定的异常类。
- en: Consider the following test, which also introduces the extremely useful `old`
    method.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下测试，它还介绍了极其有用的 `old` 方法。
- en: Listing 6.27\. Another spec, illustrating the `old` method
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.27\. 另一个示例，展示了 `old` 方法
- en: '[PRE85]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `tokenize` method takes a set of delimiters as arguments and divides the
    string at those positions. The result is an `ArrayList` of words. That’s interesting
    enough, but the cool part is in the test that appends a new word to the list.
    In this case, the size of the list is evaluated twice, once before the `when`
    block is executed and once afterward. The expression shows that the result afterward
    is equal to the result beforehand, plus one.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokenize` 方法接受一组分隔符作为参数，并在这些位置分割字符串。结果是单词的 `ArrayList`。这已经很有趣了，但酷的部分在于测试中向列表添加新单词的部分。在这种情况下，列表的大小被评估了两次，一次是在
    `when` 块执行之前，一次是在之后。表达式显示，之后的结果是之前的结果加上一。'
- en: 6.4.3\. Data-driven specifications
  id: totrans-709
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.3\. 数据驱动规范
- en: 'Spock tests have one additional feature beyond what appears in other testing
    frameworks: data-driven^([[21](#ch06fn21)]) specifications. The idea is that if
    you provide a collection of data in a format that Groovy can iterate over, then
    the test will run each entry through any supplied Boolean conditions.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: Spock 测试除了在其他测试框架中出现的特性外，还有一个额外的特性：数据驱动的^([[21](#ch06fn21)])规范。其理念是，如果你以 Groovy
    可以迭代的格式提供一组数据，那么测试将运行每个条目通过任何提供的布尔条件。
- en: ^(21) Shouldn’t Data run on Android? (Yeah, that was particularly bad. Sorry.)
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(21) 数据应该在 Android 上运行吗？（是的，那特别糟糕。抱歉。）
- en: This is easier to show than to describe. Consider the test shown on the main
    page of the Spock website, repeated in the next listing. It feeds names from a
    data table into `expect`, using three different sources of data.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这比描述更容易展示。考虑 Spock 网站主页上显示的测试，在下一个列表中重复。它使用数据表中的名称输入到 `expect` 中，使用三个不同的数据源。
- en: Listing 6.28\. Data-driven Spock test
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.28\. 数据驱动 Spock 测试
- en: '[PRE86]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `where` block in the first test contains a data table. The column names
    (`name` and `length`) are variables, which are referenced in the `expect` block.
    Groovy takes each row of the table and evaluates the `expect` condition. It’s
    an elegant system that’s easy to understand and quite powerful. While the data
    table is a powerful construct, in fact any collection that Groovy knows how to
    iterate over works as well.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试中的 `where` 块包含一个数据表。列名（`name` 和 `length`）是变量，在 `expect` 块中引用。Groovy 会评估表中的每一行，并评估
    `expect` 条件。这是一个易于理解且功能强大的优雅系统。虽然数据表是一个强大的结构，但实际上 Groovy 知道的任何可迭代的集合都可以工作。
- en: The second and third tests illustrate the same process but supply the data via
    collections. The second test uses separate lists for the `name` and `length` values.
    This means that to understand the test data you have to match up the collection
    indexes. For example, “Spock” goes with 5, “Kirk” goes with 4, and so on. The
    third test is a bit easier to visualize, because the data is organized into ordered
    pairs. Which mechanism you use (data table, sets of pairs, individual collections,
    and so on) is purely a question of style.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个测试说明了相同的过程，但通过集合提供数据。第二个测试使用单独的列表来存储 `name` 和 `length` 的值。这意味着要理解测试数据，你必须匹配集合的索引。例如，“Spock”对应
    5，“Kirk”对应 4，依此类推。第三个测试更容易可视化，因为数据被组织成有序对。你使用哪种机制（数据表、有序对集合、单个集合等）纯粹是一个风格问题。
- en: Another interesting part of Spock is the `@Unroll` annotation. Without it, the
    name listed in the test output would be the name of the test itself. With it,
    each row of the `where` block creates a different name.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: Spock 的另一个有趣的部分是 `@Unroll` 注解。没有它，测试输出中列出的名称将是测试本身的名称。有了它，`where` 块的每一行都会创建一个不同的名称。
- en: '[Figure 6.5](#ch06fig05) shows the results of executing this test in the Groovy
    and Grails Tool Suite (which is just Eclipse plus lots of plugins) as a JUnit
    test. In addition to demonstrating that Spock tests run with the existing JUnit
    infrastructure, the test also shows the difference in output that results with
    the `@Unroll` annotation. The second and third tests use the name of the method
    as their output. The first test, marked with `@Unroll`, shows up under “unrooted
    tests,” where each test gets its own unique name based on the test data.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.5](#ch06fig05) 展示了在 Groovy 和 Grails 工具套件（这仅仅是 Eclipse 加上许多插件）中执行此测试的结果，作为一个
    JUnit 测试。除了演示 Spock 测试与现有的 JUnit 基础设施一起运行外，测试还显示了使用 `@Unroll` 注解产生的输出差异。第二个和第三个测试使用方法名作为它们的输出。标记有
    `@Unroll` 的第一个测试出现在“未根测试”下，其中每个测试都根据测试数据获得其唯一的名称。'
- en: Figure 6.5\. Results of the Spock data-driven tests. The test with the `@Unroll`
    annotation is shown in the Eclipse output as “unrooted,” showing different output
    messages for each set of data.
  id: totrans-719
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5。Spock数据驱动测试的结果。带有`@Unroll`注解的测试在Eclipse输出中显示为“未根植”，显示针对每组数据的不同输出消息。
- en: '![](06fig05.jpg)'
  id: totrans-720
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig05.jpg)'
- en: What if the class you plan to test has dependencies? Those dependencies need
    to be stubbed or mocked, as discussed earlier. Fortunately, Spock has its own
    mocking capabilities built in.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算测试的类有依赖关系怎么办？这些依赖关系需要像之前讨论的那样进行存根或模拟。幸运的是，Spock内置了自己的模拟能力。
- en: 6.4.4\. The trouble with tribbles
  id: totrans-722
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.4。三文鱼的问题
- en: The `Specification` class from Spock contains a method called `Mock` that is
    used to create mock objects. If your dependency is based on an interface, the
    `Mock` method can generate a mock object directly, using Java’s dynamic proxy
    mechanism. If it’s a class, `Mock` will extend the class using the CGLIB library.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: Spock中的`Specification`类包含一个名为`Mock`的方法，用于创建模拟对象。如果你的依赖基于接口，`Mock`方法可以直接生成模拟对象，使用Java的动态代理机制。如果是类，`Mock`将使用CGLIB库扩展该类。
- en: It’s time for a relatively simple (and relatively silly) example. A tribble^([[22](#ch06fn22)])
    is a small, furry animal that breeds prolifically, likes Vulcans, and hates Klingons.
    Here’s a `Tribble` class, written in Groovy.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候举一个相对简单（而且相对愚蠢）的例子了。三文鱼是一种小型、毛茸茸的动物，繁殖力强，喜欢伏尔甘人，讨厌克林贡人。下面是一个用Groovy编写的`Tribble`类。
- en: ^(22) See [http://en.wikipedia.org/wiki/The_Trouble_With_Tribbles](http://en.wikipedia.org/wiki/The_Trouble_With_Tribbles)
    for details, in the unlikely event you haven’t seen that particular *Star Trek*
    (original series) episode. It holds up remarkably well after 35 (!) years.
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([22](#ch06fn22)) 有关详细信息，请参阅[http://en.wikipedia.org/wiki/The_Trouble_With_Tribbles](http://en.wikipedia.org/wiki/The_Trouble_With_Tribbles)，除非你还没有看过那个特定的*星际迷航*（原版系列）剧集。35年（！）后仍然非常出色。
- en: Listing 6.29\. A `Tribble` class in Groovy
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.29。Groovy中的`Tribble`类
- en: '[PRE87]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: What do you get when you feed a tribble? Not a fat tribble, but rather a lot
    of hungry little tribbles. The `feed` method returns a list containing the original
    tribble plus 10 more.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 给三文鱼喂食会得到什么？不是胖三文鱼，而是一大群饥饿的小三文鱼。`feed`方法返回一个包含原始三文鱼加上10个更多三文鱼的列表。
- en: The overloaded `react` method takes either a Vulcan or a Klingon as an argument.
    If it’s a Vulcan, the tribble soothes the Vulcan and purrs contentedly. If it’s
    a Klingon, the tribble annoys the Klingon and reacts badly. The `Tribble` class
    has a dependency on both `Vulcan` and `Klingon`.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的`react`方法接受伏尔甘人或克林贡人作为参数。如果是伏尔甘人，三文鱼会安抚伏尔甘人并满意地咕噜。如果是克林贡人，三文鱼会惹恼克林贡人并做出不良反应。`Tribble`类依赖于`Vulcan`和`Klingon`。
- en: 'To keep things simple, both `Vulcan` and `Klingon` are interfaces. The `Vulcan`
    interface is shown here:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，`Vulcan`和`Klingon`都是接口。这里显示了`Vulcan`接口：
- en: '[PRE88]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Vulcans have a `soothe` method, called by the tribble, and a `decideIfLogical`
    method that isn’t necessary for this test. That’s one of the problems with implementing
    stubs, by the way; you have to implement all the interface methods, even the ones
    that aren’t relevant to the test in question.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 伏尔甘人有一种被称为“安抚”的方法，由三文鱼触发，还有一种“decideIfLogical”方法，这个方法对这个测试来说并不必要。顺便说一句，实现存根的一个问题是你必须实现所有接口方法，即使这些方法与所讨论的测试无关。
- en: 'Klingons are a bit different:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 克林贡人有点不同：
- en: '[PRE89]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Tribbles `annoy` Klingons. Klingons also `fight` and `howlAtDeath`,^([[23](#ch06fn23)])
    two methods that aren’t needed here. To test the `Tribble` class, I need to create
    mock objects for both the `Vulcan` and `Klingon` classes, set their expectations
    appropriately, and test that the tribble behaves appropriately around each.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 三文鱼会“惹恼”克林贡人。克林贡人也会“战斗”和“howlAtDeath”，^([23](#ch06fn23)) 这两个方法在这里并不需要。为了测试`Tribble`类，我需要为`Vulcan`和`Klingon`类创建模拟对象，适当地设置它们的期望，并测试三文鱼在每种情况下的行为是否适当。
- en: '^(23) Klingons in *Star Trek: The Next Generation* howl at death. They didn’t
    in the original series, as far as I know.'
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([23](#ch06fn23)) 在*星际迷航：下一代*中，克林贡人在死亡时会嚎叫。据我所知，在原版系列中他们并没有这样做。
- en: 'Let me show the tests one by one. First I’ll check to see that the `feed` method
    works properly:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 让我逐个展示测试。首先我会检查`feed`方法是否正常工作：
- en: '[PRE90]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `when` block invokes the `feed` method. The `then` block checks that there
    are 11 elements in the returned collection and that each is a tribble. There’s
    nothing new or unusual about this test. Moving on to the test for reacting to
    Vulcans, however, I need to mock the `Vulcan` interface.^([[24](#ch06fn24)])
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`块调用`feed`方法。`then`块检查返回的集合中有11个元素，并且每个元素都是三文鱼。这个测试没有什么新奇的或不同寻常的地方。然而，当进行对
    Vulcans 的反应测试时，我需要模拟`Vulcan`接口.^([[24](#ch06fn24)])'
- en: ^(24) When I mock a Vulcan, I feel like Dr. McCoy.
  id: totrans-740
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (24) 当我模拟一个 Vulcans 时，我感觉像麦克医生。
- en: '[PRE91]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'There are two ways to use the `Mock` method in Spock. The first is shown here:
    instantiate the class, and assign it to a variable of the proper type. The method
    will implement the interface of the declared type. The second way is to use the
    interface type as an argument to the `Mock` method, which isn’t shown here.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spock中使用`Mock`方法有两种方式。第一种如下所示：实例化类，并将其分配给适当类型的变量。该方法将实现声明类型的接口。第二种方式是将接口类型作为`Mock`方法的参数，这里没有展示。
- en: Once the mock has been created, the `when` block uses the mock as the argument
    to the `react` method. In the `then` block, first the proper reaction is checked,
    and then comes the interesting part. The last line says that the test passes only
    if the `soothe` method is called on the mock exactly one time, ignoring any returned
    value.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了模拟，`when`块使用模拟作为`react`方法的参数。在`then`块中，首先检查适当的反应，然后是有趣的部分。最后一行表示只有当在模拟上恰好调用一次`soothe`方法时，测试才通过，忽略任何返回值。
- en: This is a very flexible system. The cardinality can be anything, including using
    an underscore as a wild card (for example, `(3.._)` means three or more times).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常灵活的系统。基数可以是任何东西，包括使用下划线作为通配符（例如，`(3.._)`表示三次或更多）。
- en: 'Moving on to the `Klingon` interface, the following test does multiple checks:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Klingon`接口，以下测试进行了多项检查：
- en: '[PRE92]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: After mocking the `Klingon`^([[25](#ch06fn25)]) and invoking the `react` method,
    the `then` block first checks to see that the `annoy` method on the mock is invoked
    exactly once and, using the right-shift operator, implements the method by throwing
    an exception. The next line checks that the `howlAtDeath` method is not invoked
    at all. Because the `annoy` method throws an exception, there is no returned reaction.
    The last line then verifies that annoying the Klingon did in fact throw the expected
    exception.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟了`克林贡人`^([[25](#ch06fn25)])并调用了`react`方法之后，`then`块首先检查模拟上的`annoy`方法是否恰好被调用一次，并使用右移运算符通过抛出异常来实现该方法。下一行检查`howlAtDeath`方法根本未被调用。因为`annoy`方法抛出了异常，所以没有返回反应。最后一行验证确实抛出了预期的异常。
- en: ^(25) How do you mock a Klingon? From a galaxy far, far away (rimshot).
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (25) 你如何模拟一个克林贡人？来自遥远的星系（rimshot）。
- en: The idea is that even if the mock is configured to throw an exception, the tribble
    test still passes. The test verifies that the exception is thrown without making
    the test itself fail.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是即使模拟被配置为抛出异常，三文鱼测试仍然可以通过。测试验证了异常被抛出，而没有使测试本身失败。
- en: 6.4.5\. Other Spock capabilities
  id: totrans-750
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.5. 其他Spock功能
- en: The capabilities shown so far hopefully provide a teaser for Spock. There are
    more features in Spock that go beyond the scope of this chapter. For example,
    the `@Ignore` annotation on a test skips that test, but there’s also an `@IgnoreRest`
    annotation that skips all the other tests instead. The `@IgnoreIf` annotation
    checks a Boolean condition and skips the test if the condition evaluates to true.
    There’s also a `@Stepwise` annotation for tests that have to be executed in a
    particular order, and a `@Timeout` annotation for tests that are taking too long
    to execute.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止展示的功能可能为Spock提供了一个预告。Spock还有更多功能超出了本章的范围。例如，测试上的`@Ignore`注解会跳过该测试，但还有一个`@IgnoreRest`注解会跳过所有其他测试。`@IgnoreIf`注解检查一个布尔条件，如果条件评估为真则跳过测试。还有一个`@Stepwise`注解用于必须按特定顺序执行的测试，以及一个`@Timeout`注解用于执行时间过长的测试。
- en: '|  |'
  id: totrans-752
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (Spock)**'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '**从Spock中学到的经验**'
- en: '**1**.  Spock tests extend `spock.lang.Specification`'
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. `Spock`测试扩展`spock.lang.Specification`'
- en: '**2**.  The `Specification` class has a JUnit runner, so Spock tests run in
    your existing JUnit infrastructure.'
  id: totrans-755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. `Specification`类有一个JUnit运行器，因此Spock测试可以在你的现有JUnit基础设施中运行。'
- en: '**3**.  Spock test names are descriptive sentences. The framework uses AST
    transformations to convert them to legal Groovy.'
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. `Spock`测试名称是描述性句子。框架使用AST转换将它们转换为合法的Groovy。'
- en: '**4**.  The tests are composed of blocks, like `expect` or `when/then`. Expressions
    in an `expect` or `then` block are evaluated for the Groovy Truth automatically.'
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**.  测试由块组成，如 `expect` 或 `when/then`。`expect` 或 `then` 块中的表达式会自动评估Groovy的真理。'
- en: '**5**.  The `old` method from `spock.lang.Specification` evaluates its argument
    before the `when` block is executed.'
  id: totrans-758
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**.  `spock.lang.Specification` 中的 `old` 方法在执行 `when` 块之前评估其参数。'
- en: '**6**.  The `where` block is used to iterate over test data, either from a
    table, a database result, or any data structure over which Groovy can iterate.'
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**.  `where` 块用于遍历测试数据，这些数据可以来自表格、数据库结果或Groovy可以遍历的任何数据结构。'
- en: '**7**.  Spock has its own built-in mocking capabilities.'
  id: totrans-760
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**7**.  Spock 拥有内置的模拟能力。'
- en: '|  |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The wiki for Spock contains many examples, as well as detailed documentation
    about mock details (called *interactions*) and more. The source code also comes
    with a Spock example project that you can use as a basis for your project. Spock
    is built with Gradle, which configures all the dependencies, and can plug into
    other APIs like Spring. See the docs and APIs for details.^([[26](#ch06fn26)])
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: Spock的wiki包含许多示例，以及关于模拟细节（称为*交互*）的详细文档和更多内容。源代码还附带了一个Spock示例项目，你可以将其作为你项目的起点。Spock是用Gradle构建的，它配置了所有依赖项，并且可以连接到其他API，如Spring。有关详细信息，请参阅文档和API。^([26](#ch06fn26)))
- en: ^(26) See also the Manning book *Spock in Action*, by Ken Sipe, coming soon.
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([26] 见Manning出版的《Spock in Action》，作者Ken Sipe，即将上市。)
- en: 6.5\. Summary
  id: totrans-764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 摘要
- en: This chapter covered a lot of ground in the testing arena. Groovy brings a simple
    `assert` statement into play that can be used for scripts and includes the `GroovyTestCase`
    class that extends JUnit’s capabilities. When it comes to managing dependencies,
    you can build a stub implementation of an interface using closures, and you can
    build a more complete stub using the `Expando` class.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在测试领域覆盖了大量的内容。Groovy 引入了一个简单的 `assert` 语句，它可以用于脚本，并包括扩展JUnit功能的 `GroovyTestCase`
    类。在管理依赖项方面，你可以使用闭包构建接口的存根实现，也可以使用 `Expando` 类构建更完整的存根。
- en: Groovy also has the `StubFor` and `MockFor` classes, which can be used to test
    interactions. They can even create mock objects for classes that are instantiated
    as local variables, which is pretty amazing.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 还提供了 `StubFor` 和 `MockFor` 类，它们可以用于测试交互。它们甚至可以为作为局部变量实例化的类创建模拟对象，这相当令人印象深刻。
- en: Finally, if you’re willing to add an additional library, the Spock testing framework
    provides a simple yet versatile API that still runs on your existing JUnit-based
    infrastructure. It also has its own mock abilities and integrates with other libraries,
    like Spring and Tapestry.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你愿意添加额外的库，Spock 测试框架提供了一个简单而灵活的API，它仍然运行在你的现有基于JUnit的基础设施上。它还拥有自己的模拟能力，并与其他库，如Spring和Tapestry集成。
- en: Adding Groovy also adds a wide variety of options for testing Java and mixed
    Java/Groovy projects. Hopefully the techniques in this chapter will help you decide
    where you can get the most benefit from them.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Groovy也为测试Java和混合Java/Groovy项目提供了广泛的选择。希望本章中的技术能帮助你决定在哪里从中获得最大的收益。
