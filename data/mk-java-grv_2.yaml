- en: Part 3\. Groovy in the real world
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3部分。现实世界中的Groovy
- en: In [part 3](#part03), “Groovy in the real world,” I try to address the sorts
    of challenges Java developers face on a regular basis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3部分](#part03)，“现实世界中的Groovy”，我试图解决Java开发者经常面临的一些挑战。
- en: I start with the Spring framework, which is probably the most commonly used
    open source project in the Java world. Spring and Groovy are old friends and work
    together beautifully. [Chapter 7](kindle_split_019.html#ch07) shows how to use
    Groovy classes as Spring beans anywhere in your system, including aspects. It
    then shows Spring capabilities unique to dynamic languages, like refreshable beans,
    inline scripted beans, and the `BeanBuilder` class from Grails.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我从Spring框架开始，这可能是Java世界中应用最广泛的开源项目。Spring和Groovy是老朋友，它们配合得非常完美。[第7章](kindle_split_019.html#ch07)展示了如何在系统的任何地方使用Groovy类作为Spring
    bean，包括方面。然后展示了Spring针对动态语言的独特功能，如可刷新的bean、内联脚本bean和来自Grails的`BeanBuilder`类。
- en: '[Chapter 8](kindle_split_020.html#ch08) covers Groovy interactions with persistent
    storage. Groovy includes a very useful façade over JDBC known as the `groovy.sql.Sql`
    class, which is effective when working with relational databases. The chapter
    also provides an example of working with the GMongo project, a Groovy wrapper
    around the Java API for working with MongoDB. This is a typical Groovy idiom—taking
    a Java library and making it easier to use. Finally, the chapter discusses many
    of the issues associated with GORM, the Grails Object Relational Mapping layer
    from Grails, which is probably the most common domain-specific language in Groovy
    used today.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](kindle_split_020.html#ch08)涵盖了Groovy与持久存储的交互。Groovy包含一个非常有用的JDBC封装，称为`groovy.sql.Sql`类，当与关系型数据库一起工作时非常有效。本章还提供了一个使用GMongo项目的示例，这是一个围绕Java
    API的Groovy包装器，用于与MongoDB一起工作。这是一个典型的Groovy惯用语——将Java库变得更容易使用。最后，本章讨论了许多与GORM相关的问题，GORM是Grails的面向对象关系映射层，可能是目前Groovy中应用最广泛的领域特定语言。'
- en: '[Chapter 9](kindle_split_021.html#ch09) focuses on RESTful web services, with
    an emphasis on the JAX-RS 2.0 specification. Most of the JAX-RS capabilities operate
    the same way under Groovy as under Java, but examples are provided to show how
    to work with hypermedia applications as well.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](kindle_split_021.html#ch09)专注于RESTful Web服务，重点在于JAX-RS 2.0规范。大多数JAX-RS功能在Groovy和Java下操作方式相同，但提供了示例来展示如何处理超媒体应用程序。'
- en: The last chapter in this section is about web application development. [Chapter
    10](kindle_split_022.html#ch10) starts with a nice example of Groovy metaprogramming
    using categories. Specifically, the `ServletCategory` class is presented as an
    example of what can be done quickly and easily with Groovy. Next comes a discussion
    of groovlets, which are Groovy scripts executed through a servlet that make it
    easy to get a simple application running. The chapter concludes with a demonstration
    of the Grails framework as a beautiful combination of Groovy DSLs that combine
    and configure Spring/Hibernate-based web applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本节最后一章是关于Web应用程序开发的。在第10章([Chapter 10](kindle_split_022.html#ch10))中，我从一个使用分类的Groovy元编程的好例子开始，具体来说，`ServletCategory`类被作为一个使用Groovy快速轻松完成工作的例子。接下来是关于groovlets的讨论，这些是通过servlet执行的Groovy脚本，使得运行简单的应用程序变得容易。本章最后展示了Grails框架作为Groovy
    DSLs的美丽组合，这些DSLs结合并配置基于Spring/Hibernate的Web应用程序。
- en: Chapter 7\. The Spring framework
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章。Spring框架
- en: '*This chapter covers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using Groovy classes in Spring applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spring应用程序中使用Groovy类
- en: Refreshable beans
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可刷新的bean
- en: Inline scripted beans
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联脚本bean
- en: The Grails `BeanBuilder` class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grails的`BeanBuilder`类
- en: Spring AOP with Groovy classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Groovy类进行Spring AOP
- en: As Java frameworks go, Spring is one of the most successful. Spring brought
    the ideas of dependency injection, complex object lifecycle management, and declarative
    services for POJOs to the forefront of Java development. It’s a rare project that
    doesn’t at least consider taking advantage of all Spring has to offer, including
    the vast array of Spring “beans” included in its library. Spring touches almost
    every facet of enterprise Java development, in most cases simplifying them dramatically.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java框架中，Spring是最成功的之一。Spring将依赖注入、复杂对象生命周期管理和POJO的声明式服务等理念带到了Java开发的 forefront。几乎很少有项目不考虑充分利用Spring所提供的一切，包括其库中包含的众多Spring“bean”。Spring几乎触及了企业Java开发的各个方面，在大多数情况下，它极大地简化了这些方面。
- en: In this chapter I’ll look at how Groovy interacts with the Spring framework.
    As it turns out, Groovy and Spring are old friends. Spring manages Groovy beans
    as easily as it handles Java. Spring includes special capabilities for working
    with code from dynamic languages, however, which I’ll review here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将探讨Groovy如何与Spring框架交互。实际上，Groovy和Spring是老朋友。Spring管理Groovy bean就像它处理Java
    bean一样容易。Spring包括与动态语言代码交互的特殊功能，我将在下面进行回顾。
- en: Groovy can be used to implement beans or to configure them. In this chapter
    I’ll try to review all the ways Groovy can help Spring. [Figure 7.1](#ch07fig01)
    contains a guide to the technologies discussed in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy可以用来实现bean或配置它们。在本章中，我将尝试回顾Groovy如何帮助Spring的所有方式。[图7.1](#ch07fig01)包含本章讨论的技术指南。
- en: Figure 7.1\. Guide to the Spring technologies with Groovy. Spring manages POGOs
    as easily as POJOs, so the examples include Groovy implementations of both normal
    beans and aspects. Closure coercion is used to implement the `RowMapper` interface
    in a `JdbcTemplate`. Refreshable beans are Groovy source files that can be modified
    at runtime. Inline scripted beans are included inside XML configuration files.
    Grails provides a `BeanBuilder` class for configuring beans. Finally, Spock has
    a library that allows it to be used with Spring’s test context feature.
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 使用Groovy的Spring技术指南。Spring管理POGO就像管理POJO一样容易，所以示例包括正常bean和方面的Groovy实现。在`JdbcTemplate`中，使用闭包强制转换实现`RowMapper`接口。可刷新的bean是可以在运行时修改的Groovy源文件。内联脚本bean包含在XML配置文件中。Grails提供了一个`BeanBuilder`类来配置bean。最后，Spock有一个库，允许它与Spring的测试上下文功能一起使用。
- en: '![](07fig01_alt.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig01_alt.jpg)'
- en: To show how Groovy helps Spring, I need to review what Spring is all about and
    how it’s used and configured. I’ll start with a simple, but non-trivial, sample
    application. Rather than show all the pieces (which are in the source code repository
    for the book), I’ll highlight the overall architecture and the Groovy parts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Groovy如何帮助Spring，我需要回顾Spring是什么，以及它是如何被使用和配置的。我将从一个简单但非平凡的示例应用开始。而不是展示所有组件（这些组件在本书的源代码库中），我将突出整体架构和Groovy部分。
- en: 7.1\. A Spring application
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 一个Spring应用
- en: For all its benefits, Spring is a hard framework to demonstrate to developers
    unfamiliar with it. The “Hello, World” application in Spring makes you question
    why you’d ever want it, because it replaces a couple of lines of simple, easy-to-understand,
    strongly typed Java with several additional lines of code, plus about 20 lines
    of XML. That’s not exactly a ringing endorsement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring有诸多好处，但它对于不熟悉它的开发者来说是一个难以展示的框架。Spring中的“Hello, World”应用会让你质疑为什么你想要它，因为它用几行额外的代码和大约20行XML替换了几个简单、易于理解、强类型的Java代码行。这并不完全是一个响亮的推荐。
- en: To see the real value of Spring you have to see a real application, even if
    it’s simplified in various ways. The following application models the service
    and persistence layers of an account management application. The presentation
    layer is arbitrary, so the following code could be used in either a client-side
    or a server-side application. In this case, I’ll demonstrate the functionality
    through both unit and integration tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正看到Spring的价值，你必须看到实际的应用，即使它在各种方式上被简化了。以下的应用模型了一个账户管理应用的服务和持久层。表示层是任意的，所以以下代码可以用于客户端或服务器端应用。在这种情况下，我将通过单元测试和集成测试来演示其功能。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Java and Groovy Spring Beans
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Java和Groovy Spring Beans
- en: Rather than build the entire application in Java and then convert it to Groovy
    as in other chapters, to save space this application mixes both languages. The
    point is that Spring managed beans can be implemented in either Java or Groovy,
    whichever is most convenient.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他章节中在Java中构建整个应用然后转换为Groovy不同，为了节省空间，这个应用混合了两种语言。重点是Spring管理的bean可以用Java或Groovy实现，哪种更方便就用哪种。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Consider an application that manages bank accounts. I’ll have a single entity
    class representing an account, with only an `id` and a `balance`, along with `deposit`
    and `withdraw` methods.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个管理银行账户的应用。我将有一个代表账户的单个实体类，它只有`id`和`balance`，以及`deposit`和`withdraw`方法。
- en: 'The next listing shows the `Account` class in Groovy, which has a serious advantage
    over its Java counterpart: it makes it easy to work with a `java.math.BigDecimal`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了Groovy中的`Account`类，它比其Java对应物有明显的优势：它使得与`java.math.BigDecimal`一起工作变得容易。
- en: Listing 7.1\. An `Account` POGO in Groovy that uses `BigDecimal`
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1\. 使用`BigDecimal`的Groovy `Account` POGO
- en: '![](169fig01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](169fig01.jpg)'
- en: 'Financial calculations are one of the reasons we need `java.math.BigDecimal`
    and `java.math.BigInteger`. Using `BigDecimal` keeps round-off errors from being
    sent into an account where it can accumulate over time.^([[1](#ch07fn01)]) It’s
    easy to show how quickly round-off errors can become a problem. Consider the following
    two lines:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 财务计算是我们需要 `java.math.BigDecimal` 和 `java.math.BigInteger` 的原因之一。使用 `BigDecimal`
    可以防止舍入误差进入账户，随着时间的积累，这些误差可能会累积起来.^([[1](#ch07fn01)]) 很容易展示舍入误差如何迅速变成问题。考虑以下两行代码：
- en: ¹ If you haven’t seen *Office Space* yet ([http://mng.bz/c6o8](http://mng.bz/c6o8)),
    you have a real treat ahead of you.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 如果你还没有看过 *Office Space* ([http://mng.bz/c6o8](http://mng.bz/c6o8))，你面前有一份真正的美味。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line uses doubles, while the second line uses `java.math.BigDecimal`.
    The first evaluates to 0.8999999999999999, while the second evaluates to 0.9\.
    In the `double` case I’ve only done a single calculation and already I have enough
    error to show up.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用双精度浮点数，而第二行使用 `java.math.BigDecimal`。第一行计算结果为 0.8999999999999999，而第二行计算结果为
    0.9。在 `double` 的情况下，我仅仅进行了一次计算，就已经有足够的误差显示出来。
- en: When coding in Java working with `BigDecimal` is awkward because it’s a class
    rather than a primitive. That means you can’t use your normal +, *, - operators
    and have to use the class’s API instead.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中编码时，使用 `BigDecimal` 是尴尬的，因为它是一个类而不是原始类型。这意味着你不能使用你正常的 +, *, - 操作符，而必须使用类的
    API。
- en: Because Groovy has operator overloading, however, none of that is necessary.
    I can simply declare the balance to be a `BigDecimal`, and everything else just
    works, even if I use the `Account` class from Java.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 Groovy 具有操作符重载，因此这些都不必要。我可以简单地声明余额为 `BigDecimal`，然后其他所有事情都正常工作，即使我使用 Java
    的 `Account` 类。
- en: 'One additional comment about the `Account`: at the moment no constraints are
    being applied to ensure that the balance stays positive. This is as simple as
    I can make it, just for exposition purposes.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Account` 的一个额外说明：目前没有应用约束来确保余额保持正值。这只是为了说明目的，尽可能简单。
- en: The overall design for using the `Account` class is shown in [figure 7.2](#ch07fig02).
    This is a very simple form of a layered architecture, with transactional support
    in the service layer and a persistence layer that consists of an interface and
    a DAO class, discussed shortly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Account` 类的整体设计如图 7.2 所示。这是一种非常简单的分层架构形式，服务层提供事务支持，持久层由一个接口和一个 DAO 类组成，将在稍后讨论。
- en: Figure 7.2\. A simple account management application. Transactions are demarcated
    in the service layer. The persistence layer consists of a single DAO class that
    implements an interface and uses the Spring *JdbcTemplate* to access an embedded
    database.
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2\. 一个简单的账户管理应用程序。事务在服务层中定义。持久层由一个实现接口并使用 Spring *JdbcTemplate* 访问嵌入式数据库的单个
    DAO 类组成。
- en: '![](07fig02_alt.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig02_alt.jpg)'
- en: The persistence layer follows the normal Data Access Object design pattern.
    The next listing shows a Java interface, called `AccountDAO`, written in Java.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 持久层遵循正常的 Data Access Object 设计模式。下面的列表显示了一个名为 `AccountDAO` 的 Java 接口，用 Java
    编写。
- en: Listing 7.2\. The `AccountDAO` interface, in Java
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. `AccountDAO` 接口，Java 编写
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The interface contains typical methods for transferring `Account` objects to
    the database and back. There’s a method to create new accounts, update an account,
    and delete an account; a method to find an account by `id`; and one to return
    all the accounts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口包含将 `Account` 对象传输到数据库和返回的典型方法。有一个创建新账户、更新账户和删除账户的方法；一个通过 `id` 查找账户的方法；以及一个返回所有账户的方法。
- en: The implementation of the interface, using a Groovy class called `JdbcAccountDAO`,
    works with the `JdbcTemplate` from Spring. Rather than show the whole class (which
    is available in the book source code), let me present just the structure and then
    emphasize the Groovy aspect afterward. An outline of the class is shown in the
    following listing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为 `JdbcAccountDAO` 的 Groovy 类实现接口，与 Spring 的 `JdbcTemplate` 一起工作。而不是展示整个类（可在书籍源代码中找到），让我只展示结构，然后之后强调
    Groovy 方面。类的概要如下所示。
- en: Listing 7.3\. Implementing the `AccountDAO` using `JdbcTemplate`, in Groovy
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 使用 `JdbcTemplate` 实现 `AccountDAO`，Groovy 编写
- en: '![](171fig01_alt.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](171fig01_alt.jpg)'
- en: The various `query` methods take an argument of type `RowMapper<T>`, whose definition
    is
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 各种 `查询` 方法接受一个类型为 `RowMapper<T>` 的参数，其定义如下
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you execute one of the `query` methods in `JdbcTemplate`, Spring takes
    the `ResultSet` and feeds each row through an implementation of the `RowMapper`
    interface. The job of the `mapRow` method is then to convert that row into an
    instance of the domain class. The normal Java implementation would be to create
    an inner class called, say, `AccountMapper`, whose `mapRow` method would extract
    the data from the `ResultSet` row and convert it into an `Account` instance. Providing
    an instance of the `AccountMapper` class to the `queryForObject` method would
    then return a single `Account`. The same instance can be supplied to the `query`
    method, which then returns a collection of `Account`s.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`JdbcTemplate`中执行`query`方法之一时，Spring会获取`ResultSet`并将每一行通过`RowMapper`接口的实现传递。`mapRow`方法的任务是将该行转换为域类的实例。正常的Java实现可能是创建一个名为`AccountMapper`的内部类，其`mapRow`方法会从`ResultSet`行中提取数据并将其转换为`Account`实例。将`AccountMapper`类的实例提供给`queryForObject`方法后，将返回一个单独的`Account`。相同的实例也可以提供给`query`方法，该方法然后返回`Account`的集合。
- en: This is exactly the type of closure coercion demonstrated in [chapter 6](kindle_split_017.html#ch06).
    A variable called `accountMapper` is defined and assigned to a closure with the
    same arguments as the required `mapRow` method. The variable is then used in both
    the `findAccountById` and `findAllAccounts` methods.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是第6章中展示的闭包强制转换的类型。定义了一个名为`accountMapper`的变量，并将其分配给一个与所需的`mapRow`方法具有相同参数的闭包。然后，该变量在`findAccountById`和`findAllAccounts`方法中都被使用。
- en: 'There are two uses for Groovy here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个使用Groovy的地方：
- en: '**1**.  A Groovy class implemented a Java interface, which makes integration
    easy and simplifies the code.'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 一个Groovy类实现了Java接口，这使得集成变得容易并简化了代码。'
- en: '**2**.  Closure coercion eliminated the expected inner class.'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 闭包强制转换消除了预期的内部类。'
- en: In the example in the book source code I also included the service class referenced
    in [figure 7.2](#ch07fig02). It uses Spring’s `@Transactional` annotation to ensure
    that each method operates in a required transaction. There is nothing inherently
    Groovy about it, so again I’ll just show an outline of the implementation in the
    next listing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中源代码的示例中，我还包括了[图7.2](#ch07fig02)中引用的服务类。它使用Spring的`@Transactional`注解来确保每个方法都在所需的交易中操作。它本身并没有Groovy的特性，所以在这里我将只展示下一个列表中实现的概要。
- en: Listing 7.4\. A portion of the `AccountService` class in Java
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. Java中`AccountService`类的一部分
- en: '![](172fig01_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](172fig01_alt.jpg)'
- en: The `@Autowired` annotation is used by Spring to plug in (*inject*) an instance
    of a class implementing the `AccountDAO` interface into the service class. See
    the Spring documentation ^([[2](#ch07fn02)]) for more details on autowiring.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Autowired`注解由Spring用于将实现`AccountDAO`接口的类的实例（*注入*）到服务类中。有关自动装配的更多详细信息，请参阅Spring文档^([[2](#ch07fn02)])。'
- en: ² [http://mng.bz/m9M3](http://mng.bz/m9M3)
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² [http://mng.bz/m9M3](http://mng.bz/m9M3)
- en: The service implementation is in Java mostly because there’s no great advantage
    to implementing it in Groovy, though I could easily have done so.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实现主要在Java中，因为没有在Groovy中实现它的明显优势，尽管我可以轻松地做到这一点。
- en: The last piece of the puzzle is the Spring bean configuration file. The configuration
    in the book source code uses a combination of XML and a component scan for the
    repository and service classes. Again, nothing in it uses Groovy, so I won’t present
    it here. For the record, the sample uses Spring’s `<embedded-database>` tag to
    set up a sample H2 database in memory that is reinitialized on each run. The rest
    is as described.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图中的最后一部分是Spring的bean配置文件。书中源代码中的配置使用XML和组件扫描的组合来配置存储库和服务类。同样，其中没有任何内容使用Groovy，所以在这里不会展示。记录在案，该示例使用Spring的`<embedded-database>`标签在内存中设置一个示例H2数据库，每次运行都会重新初始化。其余部分如描述所述。
- en: Returning now to Groovy, I want to show the Gradle build file in the next listing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到Groovy，我想展示下一个列表中的Gradle构建文件。
- en: Listing 7.5\. The Gradle build file for the account application
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5\. 账户应用的Gradle构建文件
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The build file is typical of projects presented in this book so far. It declares
    both the Groovy and Eclipse plugins. It uses Maven central for the repository.
    The dependencies include Groovy and Spock, as usual. Spring is added by declaring
    the `spring-context` and `spring-jdbc` dependencies. Those dependencies wind up
    adding several other Spring-related JARs. The `h2database` dependency is used
    for the H2 driver needed by the embedded database.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件是本书迄今为止介绍的项目中典型的。它声明了 Groovy 和 Eclipse 插件。它使用 Maven central 作为仓库。依赖项包括 Groovy
    和 Spock，如常。通过声明 `spring-context` 和 `spring-jdbc` 依赖项添加了 Spring。这些依赖项最终添加了几个其他与
    Spring 相关的 JAR 文件。`h2database` 依赖项用于嵌入式数据库所需的 H2 驱动程序。
- en: One interesting addition is the `spock-spring` dependency. Spring includes a
    powerful testing framework of its own, which is based on JUnit and automatically
    caches the Spring application context. The `spock-spring` dependency lets Spock
    tests work with the Spring testing context.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的补充是 `spock-spring` 依赖项。Spring 包含一个基于 JUnit 的强大测试框架，它自动缓存 Spring 应用程序上下文。`spock-spring`
    依赖项允许 Spock 测试与 Spring 测试上下文一起工作。
- en: The first test class is a Spock test for the `JdbcAccountDAO`. The following
    listing shows some of the tests from the complete set.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试类是对 `JdbcAccountDAO` 的 Spock 测试。以下列表显示了完整测试集的一些测试。
- en: Listing 7.6\. Spock tests for the `JdbcAccountDAO` implementation
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. `JdbcAccountDAO` 实现的 Spock 测试
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `@ContextConfiguration` annotation tells the test runner how to find the
    Spring bean configuration file. Adding `@Transactional` means that each test runs
    in a required transaction that (and this is the cool part) rolls back automatically
    at the end of each test, implying that the database is reinitialized at the beginning
    of each test. The DAO is autowired into the test class. The individual tests check
    that all the methods in the DAO work as expected.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ContextConfiguration` 注解告诉测试运行器如何找到 Spring bean 配置文件。添加 `@Transactional`
    表示每个测试都在一个必需的事务中运行，在每个测试结束时自动回滚（这部分很酷），意味着数据库在每个测试开始时重新初始化。DAO 自动注入到测试类中。各个测试检查
    DAO 中的所有方法是否按预期工作。'
- en: The next listing shows the tests for the service class, which includes using
    the `old` method from Spock described in [chapter 6](kindle_split_017.html#ch06)
    on testing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了服务类的测试，其中包括使用 [第 6 章](kindle_split_017.html#ch06) 中描述的 Spock 的 `old`
    方法进行测试。
- en: Listing 7.7\. Spock tests for the service class
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7\. 服务类的 Spock 测试
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As before, the annotations let the Spock test work with Spring’s test framework,
    which caches the application context. I used the `old` operation from Spock to
    check changes in the account balance after a deposit or withdrawal. No other additions
    are needed to use Spock with the Spring test context.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，注解允许 Spock 测试与 Spring 的测试框架一起工作，该框架缓存应用程序上下文。我使用了 Spock 的 `old` 操作来检查存款或取款后的账户余额变化。使用
    Spock 与 Spring 测试上下文不需要其他添加。
- en: This application, though simple, illustrates a lot of Spring’s capabilities,
    from declarative transaction management to autowiring to simplified JDBC coding
    to effective testing. From Spring’s point of view, Groovy beans are just bytecodes
    by another name. As long as the groovy-all JAR file is in the classpath, Spring
    is quite happy to use beans written in Groovy.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个应用程序很简单，但它展示了 Spring 的许多功能，从声明式事务管理到自动装配，再到简化 JDBC 编码，再到有效的测试。从 Spring 的角度来看，Groovy
    bean 只是另一种名称的字节码。只要 groovy-all JAR 文件在类路径中，Spring 就非常乐意使用用 Groovy 编写的 bean。
- en: Spring manages beans from Groovy as easily as it manages beans from Java. There
    are special capabilities that Spring offers beans from dynamic languages, though.
    I’ll illustrate them in the next sections, beginning with beans that can be modified
    in a running system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 管理 Groovy 中的 bean 和管理 Java 中的 bean 一样容易。尽管如此，Spring 为动态语言提供的 bean 也具有一些特殊功能。我将在下一节中展示这些功能，从可以在运行系统中修改的
    bean 开始。
- en: 7.2\. Refreshable beans
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 可刷新的 bean
- en: Since version 2.0, Spring has provided special capabilities for beans from dynamic
    languages like Groovy. One particularly interesting, if potentially dangerous,
    option is to deploy what are known as *refreshable* beans.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2.0 版本以来，Spring 为 Groovy 等动态语言提供了特殊功能。一个特别有趣、但可能危险的选项是部署所谓的 *可刷新* bean。
- en: For refreshable beans, rather than compile classes as usual, you deploy the
    actual source code and tell Spring where to find it and how often to check to
    see if it has changed. Spring checks the source code at the end of each refresh
    interval, and if the file has been modified it reloads the bean. This gives you
    the opportunity to change deployed classes even while the system is still running.^([[3](#ch07fn03)])
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可刷新的bean，而不是像往常一样编译类，你需要部署实际的源代码，并告诉Spring在哪里可以找到它以及多久检查一次是否有变化。Spring在每个刷新间隔结束时检查源代码，如果文件已被修改，它将重新加载bean。这给了你在系统仍在运行时更改已部署类的机会.^([[3](#ch07fn03)])
- en: '³ Yes, that’s a scary notion to me, too. The Spider-Man corollary applies:
    With Great Power Comes Great Responsibility.'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 是的，这也让我感到害怕。蜘蛛侠的推论也适用：能力越大，责任越大。
- en: I’ll demonstrate a somewhat contrived but hopefully amusing example. In the
    previous section I presented an application for managing accounts. Let me now
    assume that the account manager, presumably some kind of bank, decides to get
    into the mortgage business. I now need a class representing a mortgage application,
    which a client would submit for approval. I’m also going to need a mortgage evaluator,
    which I’ll implement both in Java and in Groovy. The overall system is shown in
    [figure 7.3](#ch07fig03).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我将演示一个稍微有些牵强但希望有趣的例子。在前一节中，我介绍了一个用于管理账户的应用程序。现在，让我假设账户管理员，可能是一种银行，决定进入抵押贷款业务。我现在需要一个代表抵押贷款申请的类，客户会提交这个申请以供批准。我还需要一个抵押贷款评估器，我将在Java和Groovy中实现它。整个系统如图7.3所示。[图7.3](#ch07fig03)。
- en: Figure 7.3\. The `GroovyEvaluator` is a refreshable bean. The source code is
    deployed, and Spring checks it for changes after each refresh interval. If it
    has changed, Spring reloads the bean.
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. `GroovyEvaluator`是一个可刷新的bean。源代码已部署，Spring在每个刷新间隔后检查其变化。如果它已更改，Spring将重新加载bean。
- en: '![](07fig03_alt.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig03_alt.jpg)'
- en: To keep this example simple, the mortgage application class only has fields
    representing the loan amount, the interest rate, and the number of years desired,
    as shown in the next listing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子简单，抵押贷款申请类只包含代表贷款金额、利率和所需年数的字段，如下一列表所示。
- en: Listing 7.8\. A trivial mortgage application class in Groovy
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8\. Groovy中的简单抵押贷款申请类
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As before, Groovy is used just to reduce the amount of code and to make it easier
    to work with `BigDecimal` instances. An instance of this class is submitted to
    the bank, which runs it through a mortgage evaluator to decide whether or not
    to approve it. The following listing shows a Java interface representing the evaluator,
    which will be implemented in both Java and Groovy.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用Groovy只是为了减少代码量，并使其更容易处理`BigDecimal`实例。这个类的实例被提交给银行，银行会运行它通过抵押贷款评估器来决定是否批准它。以下列表显示了一个代表评估器的Java接口，它将在Java和Groovy中实现。
- en: Listing 7.9\. The `Evaluator` interface in Java
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9\. Java中的`Evaluator`接口
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The interface contains only one method, `approve`, which takes a mortgage application
    as an argument and returns `true` if the application is approved and `false` otherwise.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接口只包含一个方法，`approve`，它接受一个抵押贷款申请作为参数，如果申请被批准则返回`true`，否则返回`false`。
- en: Pretend now that it is currently the summer of 2008\. The general public is
    blissfully unaware of terms like *credit default swaps*, and banks are eager to
    loan as much money as possible to as many people as possible. In other words,
    here’s a Java implementation of the `Evaluator` interface.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在是2008年的夏天。公众对像*信用违约掉期*这样的术语一无所知，而银行则急于尽可能多地贷款给尽可能多的人。换句话说，这里是一个`Evaluator`接口的Java实现。
- en: Listing 7.10\. A Java evaluator, with a rather lenient loan policy
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.10\. 一个相当宽容的Java评估器
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s a very forgiving loan policy, but if everyone else is doing it, what
    could go wrong?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常宽容的贷款政策，但如果每个人都这样做，可能会出什么问题？
- en: What went wrong, of course, is that in the late summer and early fall of 2008,
    Bear Stearns collapsed, Lehman Brothers went bankrupt, and the U.S. economy nearly
    collapsed. The bank needs to stop the bleeding as soon as possible. If the evaluator
    in place is the Java evaluator just shown, then the system has to be taken out
    of service in order to modify it. The fear is that if the system is taken offline,
    then customers might worry that it will never come back again.^([[4](#ch07fn04)])
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，出了问题的是，在 2008 年夏末和秋初，贝尔斯登崩溃，雷曼兄弟破产，美国经济几乎崩溃。银行需要尽快止血。如果现有的评估器是刚刚显示的 Java
    评估器，那么系统必须停机以便修改。担心的是，如果系统离线，客户可能会担心它永远不会再回来.^([[4](#ch07fn04)])
- en: '⁴ That’s an It’s a *Wonderful Life* reference: “George, if you close those
    doors, you’ll never open them again!”'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 这是一个《美好人生》的引用：“乔治，如果你关上这些门，你就再也打不开它们了！”
- en: There’s another possibility, however. Consider the Groovy version of the mortgage
    evaluator, whose behavior is equivalent to the Java version, as shown in the following
    listing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种可能性。考虑一下贷款评估器的 Groovy 版本，其行为与 Java 版本等效，如下所示。
- en: Listing 7.11\. A Groovy mortgage evaluator deployed as source code
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 作为源代码部署的 Groovy 贷款评估器
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, it simply returns `true`, just as the Java version did. Rather than compiling
    this class and deploying it as usual, however, this time I want to create a refreshable
    bean. To do so, I need to work with the `lang` namespace in the Spring configuration
    file (assuming I’m using XML; alternatives exist for Java configuration files).
    I also need to deploy the source code itself, rather than the compiled version
    of this file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，它简单地返回 `true`，就像 Java 版本一样。然而，这次我不想编译这个类并像往常一样部署它，而是想创建一个可刷新的 bean。为此，我需要在
    Spring 配置文件中的 `lang` 命名空间中工作（假设我正在使用 XML；对于 Java 配置文件也有其他选择）。我还需要部署源代码本身，而不是该文件的编译版本。
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Deploying source
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部署源代码
- en: Note that for refreshable beans you deploy the source, not the compiled bean.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于可刷新的 bean，你需要部署源代码，而不是编译后的 bean。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next listing shows the bean configuration file with both evaluators. Note
    the addition of the `lang` namespace and the Groovy bean.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了包含两个评估器的 bean 配置文件。注意添加了 `lang` 命名空间和 Groovy bean。
- en: Listing 7.12\. The bean configuration file with the refreshable Groovy evaluator
    bean
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12\. 包含可刷新 Groovy 评估器 bean 的 bean 配置文件
- en: '![](177fig01_alt.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](177fig01_alt.jpg)'
- en: 'Groovy provides a namespace for beans from dynamic languages, including Groovy,
    BeanShell, and JRuby. One of the elements declared in that namespace is `<lang:
    groovy>`, whose `script-source` attribute is used to point to the source code
    of a Groovy class. Note that unlike the Java evaluator bean in the same file,
    this attribute points to the actual source file, rather than the compiled bean.
    The other important attribute for the element is `refresh-check-delay`, which
    indicates the time period, in milliseconds, after which Spring will check to see
    if the source file has changed. Here the delay has been set to one second.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'Groovy 为动态语言（包括 Groovy、BeanShell 和 JRuby）的 bean 提供了一个命名空间。该命名空间中声明的一个元素是 `<lang:
    groovy>`，其 `script-source` 属性用于指向 Groovy 类的源代码。注意，与同一文件中的 Java 评估器 bean 不同，此属性指向实际的源文件，而不是编译后的
    bean。对于该元素来说，另一个重要的属性是 `refresh-check-delay`，它表示 Spring 在多长时间（以毫秒为单位）后检查源文件是否已更改。这里延迟已设置为
    1 秒。'
- en: Now comes the fun part.^([[5](#ch07fn05)]) The next listing shows a demo application
    that loads the Groovy evaluator bean and calls the `approve` method 10 times,
    sleeping for one second between each call.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是好玩的部分.^([[5](#ch07fn05)]) 下一个列表显示了一个演示应用程序，该应用程序加载 Groovy 评估器 bean 并调用 `approve`
    方法 10 次，每次调用之间暂停 1 秒。
- en: ⁵ Seriously. This is a fun demo to do in front of a live audience. Try it and
    see.
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 严肃地说。这是一个在观众面前做的有趣演示。试试看。
- en: Listing 7.13\. A demo application that loads the Groovy bean and calls `approve`
    10 times
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. 加载 Groovy bean 并调用 `approve` 方法 10 次的演示应用程序
- en: '![](178fig01_alt.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](178fig01_alt.jpg)'
- en: The idea is to start the demo running and then, while the iteration is going,
    edit the source code to change the return value of the `approve` method from `true`
    to `false`.^([[6](#ch07fn06)]) The output of the program resembles
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是启动演示程序，然后在迭代进行的同时，编辑源代码以将 `approve` 方法的返回值从 `true` 更改为 `false`。^([[6](#ch07fn06)])
    程序的输出类似于
- en: ⁶ Did you notice that the approve method was invoked with a null argument, acknowledging
    that the mortgage application doesn’t matter at all? That’s part of the gag, so
    be sure to chuckle when you do it.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 你注意到审批方法被一个null参数调用，承认抵押贷款申请根本无关紧要吗？这是玩笑的一部分，所以当你这样做的时候，一定要笑一笑。
- en: '![](178fig02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](178fig02.jpg)'
- en: The source code is changed halfway through the loop to stop the bleeding. If
    Congress should then spring^([[7](#ch07fn07)]) into action and award a massive
    government bailout, it can be changed back.^([[8](#ch07fn08)])
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中途更改源代码以阻止出血。如果国会随后迅速采取行动并授予巨额政府救助金，则可以将其改回.^([[8](#ch07fn08)])
- en: ⁷ Ouch. Yes, a bad pun, but an irresistible one.
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 哎呀。是的，这是一个糟糕的双关语，但却是无法抗拒的。
- en: ⁸ Or not.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 或者不。
- en: The ability to change the implementation of a bean inside a running system is
    powerful, but obviously risky. Spring only makes it available to beans from dynamic
    languages like Groovy.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行系统中更改bean的实现能力非常强大，但显然也很危险。Spring只将其提供给像Groovy这样的动态语言bean。
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A real use case for refreshable beans**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**可刷新bean的真实用例**'
- en: As much fun as the banking application illustrated in this section is, few companies
    will allow you to deploy source code into production and then edit it while the
    system is running. So when would you actually use this capability?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本节中展示的银行应用程序很有趣，但很少有公司会允许你在系统运行时将源代码部署到生产环境中并进行编辑。那么你实际上会在什么时候使用这个功能呢？
- en: Some problems only occur when a system is under load. Think of a refreshable
    bean as an adaptable probe that can be inserted into a Spring-based system by
    a server-side developer in a controlled fashion. You have the freedom to do more
    than just change a log level or some other property (which you could in principle
    do with JMX, the Java Management Extensions). You can change what the probe is
    doing in real time and diagnose what’s actually going on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些问题只有在系统负载下才会出现。想象一下，一个可刷新的bean就像是一个可适应的探测器，可以被服务器端开发者以受控的方式插入到基于Spring的系统。你不仅可以改变日志级别或其他属性（原则上你可以使用JMX，Java管理扩展来实现），你还可以实时改变探测器的行为并诊断实际发生的情况。
- en: Dierk Koenig, lead author of *Groovy in Action* (Manning, 2007), calls this
    pattern “keyhole surgery.” It’s used as a minimally invasive procedure when you
    don’t know what you’re going to find when you go in.^([[9](#ch07fn09)])
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Dierk Koenig，*Groovy in Action*（Manning，2007）的主要作者，称这种模式为“钥匙孔手术”。当不知道进入时会发现什么时，它被用作一种微创手术.^([[9](#ch07fn09)])
- en: ⁹ Check out Dierk’s presentation “Seven Groovy Usage Patterns for Java Developers”
    on [www.slideshare.net](http://www.slideshare.net) for more details.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 查看Dierk的演示文稿“Seven Groovy Usage Patterns for Java Developers”在[www.slideshare.net](http://www.slideshare.net)上以获取更多详细信息。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Before discussing the other Spring capability restricted to beans from dynamic
    languages, namely inline scripted beans, let me introduce another idea. One of
    the great features of Spring is that it provides a convenient infrastructure for
    aspect-oriented programming. I want to discuss what that means and how to use
    Groovy to implement an aspect.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论其他仅限于动态语言bean的Spring能力，即内联脚本bean之前，让我先介绍另一个想法。Spring的伟大之处之一是它提供了一个方便的基础设施来支持面向切面编程。我想讨论这意味着什么以及如何使用Groovy来实现一个切面。
- en: 7.3\. Spring AOP with Groovy beans
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 使用Groovy bean的Spring AOP
- en: Many of Spring’s capabilities are implemented using aspect-oriented programming
    (AOP). Spring provides the infrastructure for developing aspects. The interesting
    part is that aspects can be written as easily in Groovy as in Java.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Spring的许多功能都是使用面向切面编程（AOP）实现的。Spring提供了开发切面的基础设施。有趣的是，切面可以用Groovy和Java一样容易地编写。
- en: AOP is a big subject, but I can summarize a few of the key features here.^([[10](#ch07fn10)])
    Aspects are designed to handle *crosscutting concerns*, which are features that
    apply to many different locations. Examples of crosscutting concerns include logging,
    security, and transactions. Each of them needs to be applied at multiple locations
    in a system, which results in considerable duplication, as well as tangling of
    different kinds of functionality in the same feature.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: AOP是一个很大的主题，但在这里我可以总结一些关键特性。切面被设计来处理*横切关注点*，这些是适用于许多不同位置的功能。横切关注点的例子包括日志记录、安全和事务。每个都需要在系统的多个位置应用，这会导致相当多的重复，以及同一功能中不同类型功能的纠缠。
- en: ^(10) A complete discussion of AOP can be found in *AspectJ in Action*, 2^(nd)
    edition (Manning, 2009), by Ramnivas Laddad, [www.mannin10g.com/laddad2/](http://www.mannin10g.com/laddad2/).
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([10](#ch07fn10)) 关于 AOP 的完整讨论可以在 Ramnivas Laddad 的 *AspectJ in Action* 第二版（Manning，2009）中找到，[www.mannin10g.com/laddad2/](http://www.mannin10g.com/laddad2/)。
- en: Crosscutting concerns are written as methods, known as *advice*. The next issue
    is where to apply the advice. The generic term for all available locations where
    advice can be applied is *joinpoints*. The set of selected joinpoints for a given
    aspect is known as a *pointcut*. The combination of an advice and a pointcut is
    what defines an *aspect*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 跨切面关注点被编写为方法，称为 *建议*。下一个问题是建议应用的位置。所有可用的建议应用位置统称为 *切入点*。给定 Aspect 的所选切入点的集合称为
    *切入点集合*。建议和切入点的组合定义了 *Aspect*。
- en: The sample application for this section and the next is shown in [figure 7.4](#ch07fig04).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本节和下一节的示例应用如图 7.4 所示。[figure 7.4](#ch07fig04)。
- en: Figure 7.4\. Spring AOP in action. `ChangeLogger` is a Java aspect that logs
    a message before each set method. `UpdateReporter` does the same in Groovy but
    reports on existing values. The `GroovyAspect` is an inline scripted bean defined
    inside the configuration file.
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.4\. Spring AOP 的实际应用。`ChangeLogger` 是一个记录每个 `set` 方法前消息的 Java Aspect。`UpdateReporter`
    在 Groovy 中做同样的事情，但报告现有值。`GroovyAspect` 是在配置文件内部定义的内联脚本 Bean。
- en: '![](07fig04_alt.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig04_alt.jpg)'
- en: The following listing shows an example of an aspect, using Spring annotations,
    written in Java. This aspect is applied whenever a `set` method is about to be
    called, and it logs which method is being invoked and what the new value will
    be.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了一个使用 Spring 注解编写的 Aspect 示例，该 Aspect 在每次即将调用 `set` 方法时应用，并记录被调用的方法和新的值。
- en: Listing 7.14\. A Java aspect that logs changes to properties
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. 一个记录属性变更的 Java Aspect
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `@Aspect` annotation tells Spring this is an aspect. The `@Before` annotation
    defines the pointcut using AspectJ pointcut language. ^([[11](#ch07fn11)]) This
    particular pointcut applies at all methods that begin with the letters `set` that
    take a single argument and return `void`. The `trackChange` method is the advice.
    The `JoinPoint` argument is supplied by Spring when the aspect is called. It provides
    context for the execution. In this case, the `JoinPoint` has methods to retrieve
    the signature of the method being advised, as well as the arguments supplied to
    the method and the target object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Aspect` 注解告诉 Spring 这是一个 Aspect。`@Before` 注解使用 AspectJ 切入点语言定义了切入点。^([11](#ch07fn11))
    这个特定的切入点应用于所有以字母 `set` 开头、接受单个参数并返回 `void` 的方法。`trackChange` 方法是建议。`JoinPoint`
    参数由 Spring 在 Aspect 被调用时提供。它提供了执行上下文。在这种情况下，`JoinPoint` 提供了检索被建议方法签名、方法提供的参数和目标对象的方法。'
- en: ^(11) The documentation for AspectJ is hosted with Eclipse, of all places. See
    [http://www.eclipse.org/aspectj/](http://www.eclipse.org/aspectj/) for details.
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([11](#ch07fn11)) AspectJ 的文档托管在 Eclipse 上，详情请见 [http://www.eclipse.org/aspectj/](http://www.eclipse.org/aspectj/)。
- en: To demonstrate this aspect in action, I need to configure Spring to apply the
    aspect, and I need an object to advise. The latter is easy enough. The next listing
    shows a simple class with three properties.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个 Aspect 的实际应用，我需要配置 Spring 应用该 Aspect，并且需要一个被建议的对象。后者很容易实现。下一个列表展示了一个具有三个属性的简单类。
- en: Listing 7.15\. A simple POJO with three `set` methods
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. 具有三个 `set` 方法的简单 POJO
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The class is called `POJO`, and it has three properties, called `one`, `two`,
    and `three`. Each has a getter and a setter. The aspect will run before each of
    the `set` methods.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被称为 `POJO`，它有三个属性，分别称为 `one`、`two` 和 `three`。每个属性都有一个 getter 和一个 setter。Aspect
    将在每个 `set` 方法之前运行。
- en: Spring’s AOP infrastructure has some restrictions compared to full AOP solutions.
    Spring restricts pointcuts to only public method boundaries on Spring-managed
    beans. I therefore need to add the `POJO` bean to Spring’s configuration file.
    I also need to tell Spring to recognize the `@Aspect` annotation and to generate
    the needed proxy. The resulting bean configuration file is presented in the following
    listing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与完整的 AOP 解决方案相比，Spring 的 AOP 基础设施有一些限制。Spring 限制切入点仅限于 Spring 管理的 Bean 的公共方法边界。因此，我需要在
    Spring 的配置文件中添加 `POJO` Bean。我还需要告诉 Spring 识别 `@Aspect` 注解并生成所需的代理。结果 Bean 配置文件在下面的列表中展示。
- en: Listing 7.16\. The Spring bean configuration file for AOP
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.16\. AOP 的 Spring Bean 配置文件
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `aop` namespace provides the `<aspect-autoproxy>` element, which tells Spring
    to generate proxies for all classes annotated with `@Aspect`. The `tracker` bean
    is the Java aspect shown previously. The `pojo` bean is the `POJO` class just
    discussed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`aop`命名空间提供了`<aspect-autoproxy>`元素，它告诉Spring为所有带有`@Aspect`注解的类生成代理。`tracker`豆（bean）是之前展示的Java方面。`pojo`豆是刚刚讨论的`POJO`类。'
- en: Now I need to call the `set` methods in order to see the aspect in action. The
    next listing shows a test case based on JUnit 4 that uses Spring’s JUnit 4 test
    runner, which caches the application context in between tests.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我需要调用`set`方法来查看方面（aspect）的实际效果。下面的列表显示了一个基于JUnit 4的测试用例，它使用了Spring的JUnit
    4测试运行器，该运行器在测试之间缓存应用程序上下文。
- en: Listing 7.17\. A JUnit 4 test case to exercise the POJO
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.17\. 一个用于测试POJO的JUnit 4测试用例
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Spring injects an instance of the `POJO` into the test and executes the test,
    which simply calls the three setters and checks that they work properly. The interesting
    part is in the console output, which shows the aspect in play:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Spring将`POJO`的实例注入到测试中并执行测试，该测试简单地调用三个setter并检查它们是否正常工作。有趣的部分在于控制台输出，它显示了方面在起作用：
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The aspect reports the name of each `set` method and its argument when it’s
    called. Everything works as advertised.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当方面被调用时，它会报告每个`set`方法的名称及其参数。一切如预期般工作。
- en: There’s one issue, though. What if you want to know the current value of each
    property before the setter changes it? There’s no obvious way to find out. The
    joinpoint gives access to the target, and I know that a `set` method is being
    called, but while I know conceptually that for every setter there’s a getter,
    figuring out how to invoke it isn’t trivial. Determining the proper `get` method
    could probably be done with a combination of reflection and string manipulation,
    but there’s work involved.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题。如果你想在setter更改属性之前知道每个属性的当前值，没有明显的方法可以找到。连接点（joinpoint）提供了对目标对象的访问，我知道正在调用`set`方法，但尽管在概念上我知道对于每个setter都有一个getter，但确定如何调用它并不简单。确定适当的`get`方法可能需要结合反射和字符串操作，但这需要做些工作。
- en: At least, there’s work involved unless I appeal to Groovy. I can do everything
    I just described in a handful of lines of Groovy, as the next listing demonstrates.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，除非我求助于Groovy，否则需要做些工作。我可以像下一列表所示的那样，用几行Groovy代码完成我刚才描述的所有操作。
- en: Listing 7.18\. A Groovy aspect for printing property values before they are
    changed
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.18\. 在属性更改之前打印属性值的Groovy方面
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `UpdateReporter` class is written in Groovy. It has the `@Aspect` and `@Before`
    annotations exactly as the Java aspect did. The method being invoked is computed
    the same way the Java aspect did, with the only minor difference being that Groovy
    accesses the `signature` and `name` properties rather than explicitly invoking
    the associated `getSignature` and `getName` methods. That’s a case of foreshadowing,
    actually, because it means that all I really need to do is to figure out the name
    of the property.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateReporter`类是用Groovy编写的。它具有与Java方面相同的`@Aspect`和`@Before`注解。被调用的方法是以与Java方面相同的方式计算的，唯一的细微差别是Groovy访问`signature`和`name`属性，而不是显式调用相关的`getSignature`和`getName`方法。这实际上是一个预示，因为它意味着我真正需要做的只是找出属性的名称。'
- en: The property is found by taking the name of the `set` method, subtracting out
    the letters `set`, and converting the result to standard property syntax. Now
    that I have the name of the property, I just need to access it from the target,
    which is done on the next line. I used a Groovy string to make sure that the property
    is evaluated. The result is that in three lines of Groovy I now know what the
    original value of the property is. All that remains is to log it to standard output.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是通过取`set`方法的名称，减去字母`set`，并将结果转换为标准属性语法来找到的。现在我已经有了属性的名称，我只需要从目标对象中访问它，这将在下一行完成。我使用Groovy字符串来确保属性被评估。结果是，在三条Groovy代码中，我现在知道了属性的原始值。剩下的只是将其记录到标准输出。
- en: 'To run this aspect I just added a corresponding bean to the configuration file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个方面，我只需在配置文件中添加相应的豆：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now if I run the same test case the output is as shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果运行相同的测试用例，输出将如下所示：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both the Groovy aspect and the Java aspect are executing on the `set` methods
    of the POJO. The advantage of the Groovy aspect is that it’s easily able to determine
    the existing value of the property before changing it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy方面和Java方面都在执行POJO的`set`方法。Groovy方面的优势是它能够轻松地确定在更改之前属性的现有值。
- en: Life isn’t quite as simple as I’m describing it. The string manipulation that
    processed the `set` method determined a property name. If the property doesn’t
    actually exist (or, rather, the `get` method doesn’t exist), accessing it isn’t
    going to work. Still, asking that each setter has a corresponding getter doesn’t
    seem to be too much to expect, especially because Groovy POGOs do that automatically.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 生活并不像我描述的那么简单。处理 `set` 方法的字符串操作确定了一个属性名称。如果该属性实际上不存在（或者，更确切地说，`get` 方法不存在），访问它将不起作用。尽管如此，要求每个设置器都有一个相应的获取器似乎并不算过分的要求，尤其是在
    Groovy POGO 会自动执行这一点的情况下。
- en: To finish this section, [listing 7.19](#ch07ex19) shows an aspect added to the
    banking example from the beginning of this chapter, tracing methods in the `Account`
    class. Because `Account` is a POGO, I don’t have explicit setter methods. I don’t
    necessarily want to track all the getters, either, because one of them is `getMetaClass`,
    and that’s not a business method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这一节，[列表 7.19](#ch07ex19) 展示了从本章开头添加到银行示例中的方面，跟踪 `Account` 类中的方法。因为 `Account`
    是一个 POGO，我没有显式的设置器方法。我也不一定想跟踪所有的获取器，因为其中一个是 `getMetaClass`，而这不是一个业务方法。
- en: One way around that is to use a Java interface implemented by the POGO. Instead,
    here I’m going to use explicit pointcuts and put them together.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方法是通过 POGO 实现的 Java 接口。相反，这里我将使用显式切点并将它们组合起来。
- en: Here’s the complete `AccountAspect` listing with the pointcuts and advice.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是包含切点和通知的完整 `AccountAspect` 列表。
- en: Listing 7.19\. An aspect tracking methods in the `Account` POGO
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.19\. 跟踪 `Account` POGO 中方法的方面
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `@Pointcut` annotation is how you create a *named* pointcut. The name is
    set by the name of the method on which it’s applied. The three pointcuts here
    match the `deposit`, `withdraw`, and `getBalance` methods in the `Account` class.
    The `@Before` advice combines them using an `or` expression and logs the method
    calls. When running the `AccountSpec` tests, the (truncated) output is similar
    to this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Pointcut` 注解是用来创建一个 *命名* 切点的。这个名称由应用其上的方法的名称设置。这里的三个切点分别对应 `Account` 类中的
    `deposit`、`withdraw` 和 `getBalance` 方法。`@Before` 通知通过 `or` 表达式将它们组合起来并记录方法调用。当运行
    `AccountSpec` 测试时，(截断的) 输出类似于以下内容：'
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `JoinPoint` can be used to get more information, but those are AOP details
    rather than Groovy.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `JoinPoint` 获取更多信息，但这些是 AOP 的细节，而不是 Groovy。
- en: In both of these examples the aspect was provided in its own class. Spring provides
    an alternative, however, in the form of beans defined right in the bean definition
    file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，方面都是通过其自己的类提供的。然而，Spring 提供了一种替代方案，即直接在 Bean 定义文件中定义 Bean。
- en: 7.4\. Inline scripted beans
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. 内联脚本化 Bean
- en: Another capability Spring provides to beans from dynamic languages is that they
    can be coded right inside the XML configuration.^([[12](#ch07fn12)])
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 为动态语言提供的另一个功能是，Bean 可以直接在 XML 配置中编码.^([12](#ch07fn12)）
- en: ^(12) I have to admit that in several years of using Spring and Groovy I’ve
    never found a compelling use case for inline scripted beans that couldn’t have
    been handled with regular classes. If you have one, please let me know.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([12](#ch07fn12)) 我必须承认，在使用 Spring 和 Groovy 的几年中，我从未找到过不能通过常规类处理的内联脚本化 Bean
    的有说服力的用例。如果您有，请告诉我。
- en: Here’s an example. The following sections can be used in a bean configuration
    file, as shown in the next listing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。以下部分可以用于 Bean 配置文件，如下一列表所示。
- en: Listing 7.20\. Additions to bean configuration file for an inline scripted aspect
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.20\. 为内联脚本化方面添加的 Bean 配置文件
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `<inline-script>` tag wraps the source code for the Groovy bean. I took
    the added step of wrapping the code in a `CDATA` section, so the XML parser will
    leave the Groovy source alone when validating the XML.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`<inline-script>` 标签包装了 Groovy Bean 的源代码。我采取了额外的步骤，将代码包装在 `CDATA` 部分中，这样在验证
    XML 时，XML 解析器将不会修改 Groovy 源代码。'
- en: Rather than use annotations, this time the code is written as though it was
    any other bean. As a result I had to add the `<config>` element as well. As usual,
    an aspect is a combination of a pointcut and an advice. In this case the pointcut
    is contained in the `<before>` element, but this time it applies to every one-argument
    method in the system. The advice is the `audit` method in the `aspectScript` bean,
    which just prints the name of the method being invoked and the name of the object
    containing it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用注解不同，这次代码的编写方式就像它是任何其他bean一样。因此，我不得不添加`<config>`元素。通常，一个方面是切点（pointcut）和通知（advice）的组合。在这种情况下，切点包含在`<before>`元素中，但这次它适用于系统中的每个单参数方法。通知是`aspectScript`
    bean中的`audit`方法，它只是打印被调用的方法名称和包含它的对象名称。
- en: 'The resulting output adds more lines to the console:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的输出会在控制台添加更多行：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The original motivation for inline scripted beans was that you could do as much
    processing as you liked in the script before releasing the bean. ^([[13](#ch07fn13)])
    Now that Spring has moved to version 3.x, however, there are additional options
    for configuring beans.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 内联脚本bean的原始动机是在释放bean之前可以在脚本中进行尽可能多的处理。^([[13](#ch07fn13)]) 然而，随着Spring迁移到3.x版本，配置bean的选项也有所增加。
- en: ^(13) As I say, it’s a reach. The Spring docs suggest that this is a good opportunity
    for scripted validators, but I don’t see it.
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（13）正如我说的，这是一个很大的跳跃。Spring文档建议这是一个脚本验证器的好机会，但我看不到。
- en: 7.5\. Groovy with JavaConfig
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5. Groovy与JavaConfig
- en: Spring introduced a third way to configure beans in version 3.0\. Originally
    all beans were configured using XML. Then version 2.0 introduced annotations (assuming
    JDK 1.5 is available) like `@Component`, `@Service`, and `@Repository` and component
    scans that picked them up.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Spring在3.0版本中引入了配置bean的第三种方式。最初，所有bean都是通过XML配置的。然后，在2.0版本中引入了注解（假设JDK 1.5可用），如`@Component`、`@Service`和`@Repository`，以及用于拾取它们的组件扫描。
- en: In version 3.0 Spring introduced a Java configuration option. Instead of defining
    all your beans in a central location in XML, or spreading annotations throughout
    the code base in Java, now you can define the beans in a Java class annotated
    with `@Configuration`. Inside the configuration file, individual beans are annotated
    with `@Bean`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.0版本中，Spring引入了Java配置选项。不再需要在XML中的中央位置定义所有bean，或者将注解分散在Java代码库中，现在你可以在一个带有`@Configuration`注解的Java类中定义bean。在配置文件中，单个bean用`@Bean`注解。
- en: One of the advantages of this approach is that the configuration information
    is strongly typed, because it’s all written in Java. Another advantage, though,
    is that you’re now free to write whatever code you want, as long as you ultimately
    return the proper object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优点是配置信息是强类型的，因为它们都是用Java编写的。然而，另一个优点是现在你可以自由地编写任何你想要的代码，只要最终返回正确的对象。
- en: Consider the following example. In the account manager example discussed previously,
    say I want to charge a processing fee once a month.^([[14](#ch07fn14)]) To do
    so I create a class that processes accounts, called, naturally enough, `AccountProcessor`.
    I want the `Account Processor` to get all the accounts and charge each one a fee
    of one dollar.^([[15](#ch07fn15)])
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。在之前讨论的账户管理器示例中，假设我想每月收取一次处理费.^([[14](#ch07fn14)]) 为了这样做，我创建了一个处理账户的类，很自然地命名为`AccountProcessor`。我想让`Account
    Processor`获取所有账户并对每个账户收取一美元的费用.^([[15](#ch07fn15)])
- en: ^(14) Gee, I feel more like a real banker already.
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（14）哇，我感觉自己更像一个真正的银行家了。
- en: ^(15) It’s not much, but it’s a start.
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（15）不多，但这是一个开始。
- en: If I did this in the traditional way, I would inject the `AccountDAO` into the
    `AccountProcessor`. Then, in a `processAccounts` method, I would use the DAO to
    retrieve the accounts and charge the fee on each. With the Java configuration
    option, however, I have an alternative.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我以传统的方式这样做，我会将`AccountDAO`注入到`AccountProcessor`中。然后，在`processAccounts`方法中，我会使用DAO检索账户并对每个账户收费。然而，使用Java配置选项，我有一个替代方案。
- en: The following listing shows the `AccountProcessor` class, in Java this time.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了`AccountProcessor`类，这次是Java版本。
- en: Listing 7.21\. An account processor that debits each account by one dollar
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.21. 一个扣除每个账户一美元的账户处理器
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instead of injecting the `AccountDAO` into the processor, I gave it a list of
    accounts as an attribute. The `processAccounts` method runs through them, withdrawing
    a dollar from each and returning the total. Without the dependency on the `AccountDAO`,
    this processor could be used on any collection of accounts from any source. This
    has the extra benefit of always retrieving the complete set of accounts from the
    DAO. Injecting the account list would initialize it when the application starts
    but not update it later.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有将 `AccountDAO` 注入到处理器中，而是给它提供了一个账户列表作为属性。`processAccounts` 方法会遍历它们，从每个账户中提取一美元并返回总额。没有对
    `AccountDAO` 的依赖，这个处理器可以用于任何来源的任何账户集合。这还有一个额外的好处，即总是从 DAO 中检索完整的账户集合。注入账户列表会在应用程序启动时初始化它，但不会在之后更新它。
- en: So how does the collection of accounts get into my processor? The next listing
    shows the Java configuration file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，账户集合是如何进入我的处理器的呢？下面的列表显示了 Java 配置文件。
- en: Listing 7.22\. A Java configuration file that declares the `AccountProcessor`
    bean
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.22\. 声明 `AccountProcessor` Bean 的 Java 配置文件
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `@Configuration` annotation indicates that this is a Java configuration
    file that defines beans for Spring. Each bean is defined with the `@Bean` annotation.
    The name of the method is the name of the bean, and the return type is the class
    for the bean. Inside the method my job is to instantiate the bean, configure it
    appropriately, and return it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration` 注解表示这是一个定义 Spring 中 Bean 的 Java 配置文件。每个 Bean 都使用 `@Bean` 注解定义。方法名是
    Bean 的名称，返回类型是 Bean 的类。在方法内部，我的任务是实例化 Bean，适当地配置它，并返回它。'
- en: The implementation of a bean method can be as simple as instantiating the bean
    and returning it, setting whatever properties are needed along the way. In this
    case, though, I decided to autowire in the `AccountDAO` bean (which was picked
    up in the component scan) and then use the DAO to retrieve all the accounts and
    put them in the processor.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Bean 方法的实现可以简单到只是实例化 Bean 并返回它，在过程中设置所需的任何属性。不过，在这种情况下，我决定自动装配 `AccountDAO`
    Bean（在组件扫描中被选中）并使用 DAO 来检索所有账户并将它们放入处理器中。
- en: The next listing shows a Spock test to prove that the system is working. It
    relies on the embedded database again, which, as you may recall, configures three
    accounts.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了一个 Spock 测试，以证明系统正在运行。它再次依赖于嵌入式数据库，正如你可能记得的，它配置了三个账户。
- en: Listing 7.23\. A Spock test to check the behavior of the `AccountProcessor`
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.23\. 检查 `AccountProcessor` 行为的 Spock 测试
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Both the `AccountProcessor` and the `AccountDAO` beans are autowired into the
    test. The DAO is used to retrieve the accounts. Then, when the processor processes
    the accounts, three dollars are returned.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountProcessor` 和 `AccountDAO` Bean 都被自动装配到测试中。DAO 用于检索账户。然后，当处理器处理账户时，返回三美元。'
- en: The other test condition relies on the fact that the initial balance for each
    account is divisible by 10\. Therefore, after subtracting one from each account,
    the updated balances should all end in the digit 9\. It’s kind of kludgy, but
    it works.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试条件依赖于每个账户的初始余额都能被 10 整除的事实。因此，从每个账户中减去一美元后，更新的余额都应该以数字 9 结尾。这有点笨拙，但它是有效的。
- en: The point of this exercise was to show that with the Java configuration option
    you can write whatever code you want to configure the bean before releasing it.
    There’s not much Groovy can add to that, though it’s worth proving that the Java
    configuration option works on a Groovy class as well.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的目的是表明，使用 Java 配置选项，你可以在释放 Bean 之前编写任何代码来配置 Bean。尽管如此，Groovy 并没有太多可以添加的，尽管证明
    Java 配置选项也可以在 Groovy 类上工作是有价值的。
- en: Normally I wouldn’t use Spring to manage basic entity instances. Spring specializes
    in managing back-end services, especially those that would normally be designed
    as singletons. Spring beans are all assumed to be singletons unless otherwise
    specified. Still, you can tell Spring to provide a new instance each time by making
    the scope of the bean equal to `prototype`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我不会使用 Spring 来管理基本的实体实例。Spring 专注于管理后端服务，尤其是那些通常被设计为单例的服务。除非另有说明，Spring
    容器中的所有 Bean 都假定是单例的。然而，你可以通过将 Bean 的作用域设置为 `prototype` 来告诉 Spring 每次都提供一个新实例。
- en: '[Listing 7.24](#ch07ex24) shows a Java (actually, a Groovy) configuration file,
    with a single bean definition of type `Account` called `prototypeAccount`. It
    uses the `AccountDAO` to generate a new bean each time a `prototypeAccount` is
    requested, essentially making Spring a factory for `Account` beans, all of which
    start with an initial balance of 100.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.24](#ch07ex24) 展示了一个 Java（实际上是 Groovy）配置文件，其中有一个类型为 `Account` 的单例 `prototypeAccount`
    的 bean 定义。它使用 `AccountDAO` 在每次请求 `prototypeAccount` 时生成一个新的 bean，本质上使 Spring 成为
    `Account` beans 的工厂，所有这些 beans 都以 100 为初始余额开始。'
- en: Listing 7.24\. A Spring configuration file in Groovy as a factory for Accounts
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.24\. 作为账户工厂的 Groovy 格式的 Spring 配置文件
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `@Configuration` and `@Bean` annotations are the same as their counterparts
    in the Java configuration file. The `AccountDAO` is autowired in as before. This
    time, though, the `@Scope` annotation is used to indicate that the `prototypeAccount`
    is not a singleton. The implementation uses the DAO to create each new account
    with the given balance and then populates an `Account` object with the generated
    ID.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Configuration` 和 `@Bean` 注解与 Java 配置文件中的对应注解相同。`AccountDAO` 仍然按照之前的方式自动装配。不过这次，使用了
    `@Scope` 注解来表明 `prototypeAccount` 不是一个单例。实现方式是使用 DAO 创建每个新的账户，并使用生成的 ID 填充一个 `Account`
    对象。'
- en: To prove this is working properly, here is another Spock test in the next listing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这是正常工作的，下面是另一个 Spock 测试。
- en: Listing 7.25\. A Spock test for the prototype `Accounts`
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.25\. 对原型 `Accounts` 的 Spock 测试
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This time the application context itself is autowired into the test, because
    I want to call its `getBean` method myself multiple times. The test then gets
    three instances of `prototype-Account` and verifies first that their account numbers
    are consecutive and then that all three have the expected balance.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这次应用程序上下文本身被自动装配到测试中，因为我想要多次调用它的 `getBean` 方法。然后测试获取三个 `prototype-Account` 实例，并首先验证它们的账户号码是连续的，然后验证所有三个都有预期的余额。
- en: The bottom line is that you can use Groovy to create a Spring configuration
    file as easily as you can use Java, and in both cases you have the full power
    of the language to do whatever additional configuration you might want before
    releasing the beans.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你可以像使用 Java 一样轻松地使用 Groovy 创建 Spring 配置文件，在两种情况下，你都有语言的全部力量来做任何你可能想要的额外配置，然后再发布
    beans。
- en: All of the techniques so far have discussed how to use capabilities defined
    in Spring. There’s one new capability, however, that allows you to define complex
    beans using a builder notation. This mechanism came from the Grails project but
    can be used anywhere.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有讨论的技术都涉及如何使用 Spring 中定义的能力。然而，有一个新的能力允许你使用构建器符号定义复杂的 beans。这种机制来自 Grails
    项目，但可以在任何地方使用。
- en: 7.6\. Building beans with the Grails BeanBuilder
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6\. 使用 Grails BeanBuilder 构建 beans
- en: So far in this book I haven’t said much about Grails, the powerful framework
    that combines Groovy DSLs with Spring MVC and Hibernate. I’ll discuss Grails much
    more in [chapter 10](kindle_split_022.html#ch10) on Groovy web applications, but
    part of it is relevant here. Normally innovations in Spring find their way into
    Grails, usually in the form of a plugin, but every once in a while a Grails innovation
    goes the other way.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中我并没有过多地介绍 Grails，这是一个结合了 Groovy DSLs、Spring MVC 和 Hibernate 的强大框架。我将在第
    10 章[关于 Groovy 网络应用](kindle_split_022.html#ch10)中更详细地讨论 Grails，但其中一部分内容与这里相关。通常，Spring
    的创新会以插件的形式进入 Grails，但偶尔 Grails 的创新也会反过来。
- en: The Grails `BeanBuilder` is an example. The `grails.spring.BeanBuilder` class
    uses Groovy’s builder syntax to create Spring configuration files. Everything
    you can do in regular configuration files you can do using the Grails `BeanBuilder`
    class. The best part, and the part most relevant for discussion here, is that
    you don’t need to be working on a Grails project to use the `BeanBuilder`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 的 `BeanBuilder` 是一个例子。`grails.spring.BeanBuilder` 类使用 Groovy 的构建器语法来创建
    Spring 配置文件。你可以使用 Grails `BeanBuilder` 类做任何在常规配置文件中能做的事情。最好的部分，也是这里讨论最相关的部分，是你不需要在
    Grails 项目中工作就可以使用 `BeanBuilder`。
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Rumor has it that the Grails `BeanBuilder` class will be added to the core Spring
    libraries in version 4, which will make using it trivial. Still, the process described
    here is useful for any general external library.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 据说 Grails 的 `BeanBuilder` 类将在版本 4 中添加到核心 Spring 库中，这将使使用它变得非常简单。尽管如此，这里描述的过程对任何通用外部库都是有用的。
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The version of Spring used for the examples in this chapter is 3.2, which doesn’t
    include the `BeanBuilder`. A few versions ago Grails was reformulated to split
    its dependencies into separate JARs as much as possible, the same way Spring was
    refactored in version 3\. The Grails distribution thus contains a JAR file called
    grails-spring-2.2.2.jar, corresponding to Grails version 2.2.2.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的Spring版本是3.2，它不包括`BeanBuilder`。在几个版本之前，Grails被重新构建，尽可能地将依赖关系拆分为单独的JAR文件，就像Spring在3.0版本中重构一样。因此，Grails发行版包含一个名为grails-spring-2.2.2.jar的JAR文件，对应于Grails版本2.2.2。
- en: The Grails-Spring JAR could simply be added to my projects as an external JAR
    dependency, but because the rest of my project was built with Gradle I prefer
    to list my additional dependency that way too. The Grails-Spring JAR itself depends
    on Simple Logging Framework for Java (SLF4J), so its dependencies must be added
    too.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Grails-Spring JAR可以简单地作为外部JAR依赖项添加到我的项目中，但由于我的其余项目是用Gradle构建的，我更喜欢以那种方式列出我的附加依赖项。Grails-Spring
    JAR本身依赖于Java简单日志框架（SLF4J），因此必须添加其依赖项。
- en: The following listing shows the complete build file, which assumes the project
    is using traditional Maven structure.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了完整的构建文件，它假设项目使用传统的Maven结构。
- en: Listing 7.26\. The complete Gradle build file, including Grails-Spring dependencies
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.26。完整的Gradle构建文件，包括Grails-Spring依赖关系
- en: '![](191fig01_alt.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](191fig01_alt.jpg)'
- en: The additions shown in the build file are all that’s necessary to use the Grails
    `BeanBuilder` in a regular application. The Grails-Spring dependency (and SLF4J)
    are listed in the regular way. Any additional required JARs (and there are several)
    will then be downloaded automatically.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件中显示的添加内容是使用Grails `BeanBuilder`在常规应用程序中所需的所有内容。Grails-Spring依赖关系（以及SLF4J）以常规方式列出。任何其他必需的JAR文件（有几个）将自动下载。
- en: To demonstrate how to use the `BeanBuilder`, let me take a different approach
    from the earlier examples. The `BeanBuilder` is a class provided by an open source
    project. Open source projects by definition make their source code available.
    While browsing through the implementation of an open source project is certainly
    educational, I’d like to point out an oft-overlooked resource. The better open
    source projects are loaded with test cases. Because nobody is really fond of writing
    documentation,^([[16](#ch07fn16)]) sometimes it’s hard to figure out exactly how
    to use a particular capability in a project. If you’re lucky, whoever wrote the
    feature you want also wrote test cases for it. Then the tests demonstrate in great
    detail how the feature is intended to be used. Test cases are executable documentation,
    illustrating the ways the author meant for you to use the feature.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用`BeanBuilder`，我将采用与早期示例不同的方法。`BeanBuilder`是一个由开源项目提供的类。根据定义，开源项目会使其源代码可用。虽然浏览开源项目的实现确实具有教育意义，但我想要指出一个经常被忽视的资源。更好的开源项目充满了测试用例。由于没有人真正喜欢编写文档[^16]，有时很难确切地了解如何在项目中使用特定的功能。如果你很幸运，编写你想要的功能的人也为其编写了测试用例。然后，测试用例会详细展示如何使用该功能。测试用例是可执行的文档，说明了作者希望您如何使用该功能。
- en: ^(16) Other than in book form, I mean. Writing books is both fun and easy. That’s
    my story, and I’m sticking to it.
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[16] 我的意思是除了书籍形式之外。写书既有趣又容易。这就是我的故事，我会坚持下去。
- en: 'In the case of the Grails `BeanBuilder`, there’s a test case called `grails.spring
    .BeanBuilderTests`, which has a couple of very nice properties:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grails `BeanBuilder`的情况下，有一个名为`grails.spring.BeanBuilderTests`的测试用例，它有几个非常不错的属性：
- en: It was originally authored by Graeme Rocher, the head of the Grails project
    and possibly the best developer I’ve ever met.^([[17](#ch07fn17)])
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它最初由Grails项目的负责人Graeme Rocher编写，他可能是我遇到过的最好的开发者[^17]。
- en: ^(17) Except for maybe Guillaume Laforge, Dierk Koenig, Paul King, Andres Almiray,
    or a few others. The Groovy ecosystem is filled with wicked-smart developers.
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[17] 除了Guillaume Laforge、Dierk Koenig、Paul King、Andres Almiray或少数其他人之外。Groovy生态系统充满了非常聪明的开发者。
- en: The test case has nearly 30 different tests in it, demonstrating everything
    you might want to do with the class.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该测试用例中几乎有30个不同的测试，展示了您可能想对该类做的所有事情。
- en: In this section I want to review some basic features of the `BeanBuilderTests`
    class. In fact, I copied the class into the book source code just to make sure
    everything worked. I needed to remove a couple of tests that weren’t relevant
    to running `BeanBuilder` independently from Grails, but everything else tested
    successfully.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我想回顾一下 `BeanBuilderTests` 类的一些基本功能。实际上，我把这个类复制到书籍源代码中，只是为了确保一切正常工作。我需要移除一些与独立运行
    `BeanBuilder`（不依赖于 Grails）无关的测试，但其他所有测试都成功通过了。
- en: 'Before I continue, I should highlight this approach as a good general rule:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我继续之前，我应该强调这种做法是一个很好的通用规则：
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Test Cases
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试用例
- en: Downloading the source code of an open source project is useful even if you
    never look at the implementation. The test cases alone are often more valuable
    than the actual documentation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你从不查看实现，下载开源项目的源代码也是有用的。仅测试用例本身通常比实际文档更有价值。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That advice might be more useful than anything else said in this book.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这些建议可能比这本书中说的任何其他内容都更有用。
- en: The next listing shows the first test case in the `BeanBuilderTests` class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了 `BeanBuilderTests` 类中的第一个测试用例。
- en: Listing 7.27\. The `BeanBuilderTests` class with its first test case
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.27\. 包含其第一个测试用例的 `BeanBuilderTests` 类
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To use `BeanBuilder` all you have to do is instantiate the class. This is similar
    to using `MarkupBuilder`, `SwingBuilder`, `AntBuilder`, or any of the wide range
    of builders written in Groovy. Here the builder is assigned to the variable `bb`,
    so using the builder starts with `bb.beans`, which is like creating a root `<beans>`
    element in a Spring configuration file. The curly braces then indicate child elements.
    Here the child element is an `importBeans` element, which reads the file test.xml
    from the classpath. Before proceeding, here’s the text of test.xml:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `BeanBuilder`，你只需要实例化这个类。这类似于使用 `MarkupBuilder`、`SwingBuilder`、`AntBuilder`
    或任何用 Groovy 编写的广泛范围内的构建器。在这里，构建器被分配给变量 `bb`，因此使用构建器从 `bb.beans` 开始，就像在 Spring
    配置文件中创建一个根 `<beans>` 元素一样。大括号表示子元素。在这里，子元素是一个 `importBeans` 元素，它从类路径中读取 test.xml
    文件。在继续之前，这是 test.xml 的文本：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a typical beans configuration file containing a single bean definition.
    The bean is an instance of `java.lang.String` whose value is `hello` and whose
    name is `foo`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的 beans 配置文件，包含一个单独的 bean 定义。该 bean 是一个 `java.lang.String` 类型的实例，其值为 `hello`，名称为
    `foo`。
- en: Returning to the test case, after importing the XML file the `createApplicationContext`
    method is invoked, which makes the beans available through the application context.
    Then the test calls `getBean` to return the `foo` bean and checks that its value
    is `hello`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到测试用例，在导入 XML 文件后，会调用 `createApplicationContext` 方法，这使得 bean 通过应用程序上下文可用。然后测试调用
    `getBean` 返回 `foo` bean，并检查其值为 `hello`。
- en: The conclusions to be drawn are that to use the `BeanBuilder` you must (1) instantiate
    the class, (2) define the beans using normal builder syntax, (3) create the application
    context from the builder, and (4) access and use the beans in the normal way.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可以得出的结论是，要使用 `BeanBuilder`，你必须（1）实例化类，（2）使用正常的构建器语法定义 bean，（3）从构建器创建应用程序上下文，（4）以正常方式访问和使用
    bean。
- en: The next listing contains another test in the test case that illustrates setting
    a bean’s properties.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表包含另一个测试用例，展示了设置 bean 属性。
- en: Listing 7.28\. Setting bean properties in the `BeanBuilder`, from BeanBuilderTests
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.28\. 在 `BeanBuilder` 中设置 bean 属性，来自 BeanBuilderTests
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside the builder the syntax uses the bean name followed by the bean class
    in parentheses. In this case, `bean1` is the name or ID of an instance of the
    `Bean1` class. Near the bottom of the file you’ll find the definition of `Bean1`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建器内部，语法使用 bean 名称后跟括号中的 bean 类。在这种情况下，`bean1` 是 `Bean1` 类的一个实例的名称或 ID。在文件底部附近，你可以找到
    `Bean1` 的定义：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In fact, several beans are defined at the bottom of the class. Unlike Java,
    Groovy source files can have multiple classes defined in them. The `Bean1` class
    contains attributes of type `String`, `int`, `Properties`, and `List`. The test
    case assigns the `name` to `homer` and the `age` to `45`, uses the map syntax
    to assign the `overweight` and `height` properties, and sets the list to the names
    of the children.^([[18](#ch07fn18)])The tests then assert that the bean is in
    the application context and that, after retrieving it, all the properties have
    been set as described.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在类的底部定义了几个豆类。与 Java 不同，Groovy 源文件可以包含多个类定义。`Bean1` 类包含类型为 `String`、`int`、`Properties`
    和 `List` 的属性。测试用例将 `name` 分配给 `homer`，将 `age` 分配给 `45`，使用映射语法分配 `overweight` 和
    `height` 属性，并将列表设置为孩子的名字.^([[18](#ch07fn18)])然后测试断言豆类在应用程序上下文中，并且在检索后，所有属性都已按描述设置。
- en: ^(18) Leaving out Maggie, who sadly always seems to be an afterthought.
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (18) 略去了玛吉，她总是让人感到像是事后才想起的。
- en: You’re not limited to defining a single bean, of course. The next listing shows
    a test that creates several beans and sets their relationships.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不仅限于定义单个豆类。接下来的列表显示了一个创建多个豆类并设置它们关系的测试。
- en: Listing 7.29\. Defining several related beans with the `BeanBuilder`
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.29\. 使用 `BeanBuilder` 定义多个相关豆类
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The beans named `homer`, `bart`, and `lisa` are all instances of the `Bean1`
    class. The `marge` bean is an instance of `Bean2`, which adds a reference of type
    `Bean1` called `bean1`. Here the `bean1` reference in `marge` is assigned to `homer`.
    The `Bean1` class also has a `children` attribute of type `List`, so it’s assigned
    to a list containing `bart` and `lisa`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `homer`、`bart` 和 `lisa` 的豆类都是 `Bean1` 类的实例。`marge` 豆类是 `Bean2` 类的实例，它添加了一个类型为
    `Bean1` 的引用，名为 `bean1`。在这里，`marge` 中的 `bean1` 引用被分配给了 `homer`。`Bean1` 类还有一个类型为
    `List` 的 `children` 属性，因此它被分配给包含 `bart` 和 `lisa` 的列表。
- en: I don’t want to go through all the tests here, but there are a couple of features
    that should be highlighted. For example, you can define beans at different scopes,
    as shown in the next listing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想在这里通过所有测试，但有几个特性应该被强调。例如，你可以定义不同作用域的豆类，如下一个列表所示。
- en: Listing 7.30\. Defining beans at different scopes
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.30\. 在不同作用域中定义豆类
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By setting the `scope` attribute on `myBean` to `prototype`, retrieving the
    bean twice results in separate instances. The scope of `myBean2` is singleton
    by default, so asking for it twice results in two references to the same object.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `myBean` 的 `scope` 属性设置为 `prototype`，检索两次豆类会产生不同的实例。`myBean2` 的作用域默认为单例，因此请求两次将导致两个对同一对象的引用。
- en: You can also use tags from different Spring namespaces. Earlier in this chapter
    I created an aspect using Groovy. The following listing shows a similar case using
    the `BeanBuilder`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用来自不同 Spring 命名空间的标签。在本章早些时候，我使用 Groovy 创建了一个方面。以下列表显示了使用 `BeanBuilder`
    的类似情况。
- en: Listing 7.31\. Defining an aspect using `BeanBuilder`
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.31\. 使用 `BeanBuilder` 定义方面
- en: '[PRE33]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `aop` namespace is declared using `xmlns`. In the builder that’s interpreted
    as a (non-existent) method call, whose interpretation is to make the namespace
    available under the `aop` prefix. The `fred` bean is an instance of `AdvisedPerson`,
    whose definition is
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `xmlns` 声明 `aop` 命名空间。在解释为（不存在的）方法调用的构建器中，其解释是在 `aop` 前缀下使命名空间可用。`fred` 豆类是
    `AdvisedPerson` 类的实例，其定义如下
- en: '[PRE34]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `birthdayCardSenderAspect` is an instance of `BirthdayCardSender`, which
    is defined at the bottom of the file:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`birthdayCardSenderAspect` 是 `BirthdayCardSender` 类的实例，该类在文件底部定义：'
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using the `config` element from the `aop` namespace, the builder declares an
    aspect called `sendBirthdayCard` that references the aspect. After any execution
    of the birthday method in an advised person, the aspect’s `onBirthday` method
    is executed, which adds the person to the `peopleSentCards` collection. The test
    then verifies that the aspect did in fact run.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `aop` 命名空间中的 `config` 元素，构建器声明了一个名为 `sendBirthdayCard` 的方面，该方面引用了方面。在任何被建议的人执行生日方法之后，方面的
    `onBirthday` 方法将被执行，这会将这个人添加到 `peopleSentCards` 集合中。然后测试验证方面确实已运行。
- en: Other tests illustrate other capabilities in `BeanBuilder`. For example, if
    the property you’re trying to set requires a hyphen, you put the property in quotes.
    Some tests show examples like
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 其他测试展示了 `BeanBuilder` 中的其他功能。例如，如果你正在尝试设置的属性需要连字符，你将属性放在引号中。一些测试显示了如下示例
- en: '[PRE36]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: or
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE37]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See the test file for a wide range of examples. The bottom line is that anything
    you can do in a regular Spring bean configuration file, you can do with the Grails
    `BeanBuilder`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅测试文件以获取广泛的示例。底线是，你可以在常规Spring bean配置文件中完成的任何事情，都可以使用Grails的`BeanBuilder`来完成。
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (Spring with Groovy)**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习心得（Spring与Groovy）**'
- en: '**1**.  Spring manages POGOs the same way it manages POJOs, so beans can be
    implemented in Groovy as easily as in Java.'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. Spring以与POJO相同的方式管理POGOS，因此beans可以用Groovy实现，就像用Java一样容易。'
- en: '**2**.  Closure coercion eliminates the need for anonymous inner classes.'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 闭包强制转换消除了匿名内部类的需要。'
- en: '**3**.  By adding a single JAR file, Spock tests work inside the Spring test
    context.'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 通过添加单个JAR文件，Spock测试可以在Spring测试上下文中运行。'
- en: '**4**.  Refreshable beans allow you to modify the system without restarting
    it.'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 可刷新的beans允许你在不重新启动系统的情况下修改系统。'
- en: '**5**.  Inline scripted beans are embedded in configuration files.'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 内联脚本beans嵌入在配置文件中。'
- en: '**6**.  The Grails `BeanBuilder` gives yet another way to configure Spring.'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**. Grails的`BeanBuilder`提供了另一种配置Spring的方法。'
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.7\. Summary
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7. 摘要
- en: This chapter demonstrated all the places where Groovy can work productively
    with the Spring framework. In addition to writing Spring beans in Groovy, which
    sometimes results in significant code savings, there are features of Spring unique
    to beans from dynamic languages. I showed both refreshable beans, in which you
    deploy the source code and can revise it without stopping the system, and inline
    scripted beans, in which the beans are defined directly in the configuration file.
    Groovy beans can also be Spring AOP aspects, as shown. Finally, I reviewed tests
    from the `BeanBuilder` class from Grails, which can be used to create Spring bean
    definitions using the normal Groovy builder syntax, even outside of Grails.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示了Groovy可以在哪些地方与Spring框架高效地协同工作。除了在Groovy中编写Spring beans，这有时会导致代码量显著减少之外，还有Spring特有的动态语言beans的特性。我展示了可刷新的beans，其中你可以部署源代码并可以修改它而无需停止系统，以及内联脚本beans，其中beans直接在配置文件中定义。Groovy
    beans也可以作为Spring AOP方面，如所示。最后，我回顾了来自Grails的`BeanBuilder`类的测试，该类可以使用正常的Groovy构建器语法创建Spring
    bean定义，即使在Grails之外也是如此。
- en: In the next chapter, it’s time to look at database development and manipulation.
    There, in addition to the cool capabilities of the `groovy.sql.Sql` class, I’ll
    also use another contribution from the Grails project, the Grails Object Relational
    Mapping (GORM) capability.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨数据库开发和操作。在那里，除了`groovy.sql.Sql`类的酷炫功能之外，我还会使用Grails项目的一个贡献，即Grails对象关系映射（GORM）功能。
- en: Chapter 8\. Database access
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章 数据库访问
- en: '*This chapter covers*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: JDBC and the Groovy `Sql` class
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDBC和Groovy的`Sql`类
- en: Simplifying Hibernate and JPA using GORM
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GORM简化Hibernate和JPA
- en: Working with the NoSQL database
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与NoSQL数据库一起工作
- en: Virtually every significant application uses persistent data in one form or
    another. The vast majority of them save the data in relational databases. To make
    it easy to switch from one database to another, Java provides the JDBC^([[1](#ch08fn01)])
    API. While JDBC does handle the required tasks, its low-level nature leads to
    many lines of code to handle even the simplest tasks.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个重要的应用程序都以某种形式使用持久数据。其中绝大多数将数据保存在关系数据库中。为了便于在不同数据库之间切换，Java提供了JDBC^([[1](#ch08fn01)])
    API。虽然JDBC可以处理所需的任务，但其低级性质导致处理甚至最简单的任务也需要很多行代码。
- en: ¹ You would think that JDBC stands for Java Database Connectivity. Everyone
    would agree with you, except for the people at Sun (now Oracle) who created the
    API. They claim that JDBC is a trademarked acronym that doesn’t stand for anything.
    Clearly lawyers were involved somewhere in the process. I’m not going to be bound
    by such silliness, and if I get sued as a result, I’ll be sure to blog about it.
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 你可能会认为JDBC代表Java Database Connectivity。每个人都可能会同意你的看法，除了创建该API的Sun（现在是Oracle）的人。他们声称JDBC是一个商标化的首字母缩略词，不代表任何东西。显然，在这个过程中涉及到了律师。我不会被这种愚蠢的东西所束缚，如果因此被起诉，我肯定会写博客关于这件事。
- en: Because the software is object-oriented and the database is relational, there’s
    a mismatch at the boundary. The open source Hibernate project attempts to bridge
    that gap at a higher level of abstraction. Java includes the Java Persistence
    API (JPA) as a uniform interface to Hibernate and other object-relational mapping
    (ORM) tools.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件是面向对象的，而数据库是关系型的，因此在边界处存在不匹配。开源的 Hibernate 项目试图在更高层次的抽象上弥合这一差距。Java 包括 Java
    持久化 API（JPA），作为对 Hibernate 和其他对象关系映射（ORM）工具的统一接口。
- en: Groovy, as usual, provides some simplifications to the Java APIs. For raw SQL,
    the Groovy standard library includes the `groovy.sql.Sql` class. For ORM tools
    like Hibernate, the Grails project created a domain-specific language (DSL) called
    GORM. Finally, many of the so-called “No SQL” databases that have become popular
    recently also provide Groovy APIs to simplify their use. [Figure 8.1](#ch08fig01)
    shows the technologies covered in this chapter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，Groovy 为 Java API 提供了一些简化。对于原始 SQL，Groovy 标准库包括 `groovy.sql.Sql` 类。对于像
    Hibernate 这样的 ORM 工具，Grails 项目创建了一个特定领域的语言（DSL）称为 GORM。最后，最近变得流行的许多所谓的“非 SQL”数据库也提供了
    Groovy API 以简化其使用。[图 8.1](#ch08fig01) 展示了本章涵盖的技术。
- en: Figure 8.1\. Java uses JDBC and JPA, with Hibernate being the most common JPA
    provider. Most NoSQL databases have a Java API that can be wrapped by Groovy;
    in this chapter GMongo is used to access MongoDB. GORM is a Groovy DSL on top
    of Spring and Hibernate. Finally, the `groovy.sql.Sql` class makes it easy to
    use raw SQL with a relational database.
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1\. Java 使用 JDBC 和 JPA，其中 Hibernate 是最常用的 JPA 提供商。大多数 NoSQL 数据库都有一个 Java
    API，可以被 Groovy 包装；在本章中，使用 GMongo 访问 MongoDB。GORM 是基于 Spring 和 Hibernate 的 Groovy
    DSL。最后，`groovy.sql.Sql` 类使得使用关系型数据库的原始 SQL 变得容易。
- en: '![](08fig01.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig01.jpg)'
- en: With relational databases everything ultimately comes down to SQL, so I’ll start
    there.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系型数据库中，一切最终都归结为 SQL，所以我会从这里开始。
- en: '8.1\. The Java approach, part 1: JDBC'
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. Java 方法，第 1 部分：JDBC
- en: JDBC is a set of classes and interfaces that provide a thin layer over raw SQL.
    That’s a significant engineering achievement, actually. Providing a unified API
    across virtually every relational database is no trivial task, especially when
    each vendor implements significantly different variations in SQL itself.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC 是一组类和接口，在原始 SQL 上提供了一层薄层。这实际上是一项重大的工程成就。在几乎每个关系型数据库上提供统一的 API 并非易事，尤其是在每个供应商在
    SQL 本身中实现了显著不同的变体时。
- en: Still, if you already have the SQL worked out, the JDBC API has classes and
    methods to pass it to the database and process the results.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果你已经解决了 SQL 问题，JDBC API 提供了类和方法来传递它到数据库并处理结果。
- en: The following listing shows a simple example, based on a single persistent class
    called `Product`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了一个基于单个持久化类 `Product` 的简单示例。
- en: Listing 8.1\. The `Product` class, a POJO mapped to a database table
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. `Product` 类，一个映射到数据库表的 POJO
- en: '[PRE38]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Product` class has only three attributes, one of which (`id`) will represent
    the primary key in the database. The rest of the class is simply constructors,
    getters and setters, and (not shown) the normal `toString`, `equals`, and `hashCode`
    overrides. The complete version is available in the book source code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product` 类只有三个属性，其中之一（`id`）将代表数据库中的主键。类的其余部分只是构造函数、getter 和 setter，以及（未展示）正常的
    `toString`、`equals` 和 `hashCode` 重写。完整的版本可在本书源代码中找到。'
- en: The next listing shows the `ProductDAO` interface.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了 `ProductDAO` 接口。
- en: Listing 8.2\. A DAO interface for the `Product` class
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. `Product` 类的 DAO 接口
- en: '[PRE39]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To implement the interface I need to know the table structure. Again, to keep
    things simple, assume I only have a single table, called `product`. For the purposes
    of this example the table will be created in the DAO implementation class, using
    the H2 database.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现接口，我需要知道表结构。再次，为了简化，假设我只有一个名为 `product` 的表。为了本例的目的，该表将在 DAO 实现类中使用 H2 数据库创建。
- en: The implementation class is `JDBCProductDAO`. A couple of excerpts are shown
    ahead. Java developers will find both the code and the attendant painful verbosity
    quite familiar.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类是 `JDBCProductDAO`。下面展示了几个摘录。Java 开发者会发现代码及其伴随的繁琐相当熟悉。
- en: The following listing shows the beginnings of the implementation, including
    constants to represent the URL and driver class.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了实现的开端，包括表示 URL 和驱动类常量。
- en: Listing 8.3\. A JDBC implementation of the DAO interface
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. DAO 接口的 JDBC 实现
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `import` statements have been mercifully omitted. The private method to
    create and populate the table is shown in the next listing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 已经仁慈地省略了 `import` 语句。创建和填充表的私有方法在下一个列表中显示。
- en: Listing 8.4\. Adding creation and population of the `Product` table to the DAO
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 将 `Product` 表的创建和填充添加到 DAO 中
- en: '![](202fig01_alt.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](202fig01_alt.jpg)'
- en: A phrase often used when describing Java is that the essence is buried in ceremony.
    JDBC code is probably the worst offender in the whole API. The “essence” here
    is to create the table and add a few rows. The “ceremony” is all the boilerplate
    surrounding it. As the listing shows, `try`/`catch` blocks are needed because
    virtually everything in JDBC throws a checked `SQLException`. In addition, because
    it’s absolutely necessary to close the database connection whether an exception
    is thrown or not, the connection must be closed in a `finally` block. To make
    matters even uglier, the `close` method itself also throws an `SQLException`,
    so it, too, must be wrapped in a `try`/`catch` block, and of course the only way
    to avoid a potential `NullPointerException` is to verify that the connection and
    statement references are not null when they’re closed.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 Java 时常用的一句话是，本质被埋藏在仪式中。JDBC 代码可能是整个 API 中最糟糕的违规者。这里的“本质”是创建表并添加几行。而“仪式”则是围绕它的所有样板代码。正如列表所示，需要
    `try`/`catch` 块，因为 JDBC 中几乎所有的操作都会抛出检查的 `SQLException`。此外，由于无论是否抛出异常，都必须关闭数据库连接，因此必须在
    `finally` 块中关闭连接。更糟糕的是，`close` 方法本身也会抛出 `SQLException`，因此它也必须被包裹在 `try`/`catch`
    块中，当然，避免潜在的 `NullPointerException` 的唯一方法是在关闭时验证连接和语句引用不是 null。
- en: This boilerplate is repeated in every method in the DAO. For example, the following
    listing shows the implementation of the `findProductById` method.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这种样板代码在 DAO 的每个方法中都会重复。例如，以下列表显示了 `findProductById` 方法的实现。
- en: Listing 8.5\. The `findProductById` method with all the required ceremony
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. 带有所有必要仪式的 `findProductById` 方法
- en: '![](202fig02_alt.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](202fig02_alt.jpg)'
- en: As with so many things in Java, the best thing you can say about this code is
    that eventually you get used to it. All that’s being done here is to execute a
    `select` statement with a `where` clause including the necessary product ID and
    converting the returned database row into a `Product` object. Everything else
    is ceremony.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 中许多事物一样，你能说的最好的关于这段代码的事情就是最终你会习惯它。这里所做的一切只是执行一个带有 `where` 子句的 `select`
    语句，该子句包括必要的产品 ID，并将返回的数据库行转换为 `Product` 对象。其他一切都是仪式。
- en: I could go on to show the remaining implementation methods, but suffice it to
    say that the details are equally buried. See the book source code for details.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以继续展示剩余的实现方法，但可以说细节同样被埋藏。请参阅书籍源代码以获取详细信息。
- en: '|  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (JDBC)**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lessons learned (JDBC)**'
- en: '**1**.  JDBC is a very verbose, low-level set of classes for SQL access to
    relational databases.'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. JDBC 是一组用于访问关系型数据库的 SQL 访问的非常冗长、低级的类。'
- en: '**2**.  The Spring `JdbcTemplate` class (covered in [chapter 7](kindle_split_019.html#ch07))
    is a good choice if Groovy is not available.'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 如果没有 Groovy，Spring 的 `JdbcTemplate` 类（在第 7 章[chapter 7](kindle_split_019.html#ch07)中介绍）是一个不错的选择。'
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Years ago this was the only realistic option for Java. Now other options exist,
    like Spring’s `JdbcTemplate` (discussed in [chapter 7](kindle_split_019.html#ch07)
    on Spring) and object-relational mapping tools like Hibernate (discussed later
    in this chapter). Still, if you already know SQL and you want to implement a DAO
    interface, Groovy provides a very easy alternative: the `groovy.sql.Sql` class.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，这是 Java 的唯一可行选项。现在有其他选项存在，如 Spring 的 `JdbcTemplate`（在第 7 章[chapter 7](kindle_split_019.html#ch07)中讨论）和对象关系映射工具如
    Hibernate（在本章后面讨论）。尽管如此，如果您已经了解 SQL 并且想实现 DAO 接口，Groovy 提供了一个非常简单的替代方案：`groovy.sql.Sql`
    类。
- en: '8.2\. The Groovy approach, part 1: groovy.sql.Sql'
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. Groovy 方法，第 1 部分：groovy.sql.Sql
- en: The `groovy.sql.Sql` class is a simple façade over JDBC. The class takes care
    of resource management for you, as well as creating and configuring statements
    and logging errors. It’s so much easier to use than regular JDBC that there’s
    never any reason to go back.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy.sql.Sql` 类是 JDBC 的一种简单封装。该类为您处理资源管理，包括创建和配置语句以及记录错误。与常规 JDBC 相比，使用起来容易得多，因此根本没有任何理由要回头。'
- en: The next listing shows the part of the class that sets up the connection to
    the database and initializes it.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了设置数据库连接并初始化它的类部分。
- en: Listing 8.6\. A `ProductDAO` implementation using the `groovy.sql.Sql` class
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. 使用 `groovy.sql.Sql` 类实现的 `ProductDAO`
- en: '![](204fig01_alt.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](204fig01_alt.jpg)'
- en: The `groovy.sql.Sql` class contains a static factory method called `newInstance`
    that returns a new instance of the class. The method is overloaded for a variety
    of parameters; see the GroovyDocs for details.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy.sql.Sql` 类包含一个名为 `newInstance` 的静态工厂方法，它返回该类的新实例。该方法具有多种参数的重载；请参阅 GroovyDocs
    获取详细信息。'
- en: The `execute` method takes an SQL string and, naturally enough, executes it.
    Here I’m using a multiline string to make the `create` `table` and `insert` `into`
    statements easier to read. The `Sql` class takes care of opening a connection
    and closing it when finished.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute` 方法接受一个 SQL 字符串，并自然地执行它。在这里，我使用多行字符串来使 `create` `table` 和 `insert`
    `into` 语句更容易阅读。`Sql` 类负责打开连接并在完成后关闭它。'
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Sql class
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Sql 类
- en: The `groovy.sql.Sql` class does everything raw JDBC does, and handles resource
    management as well.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy.sql.Sql` 类执行了原始 JDBC 所做的一切，并且还处理资源管理。'
- en: '|  |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The same `execute` method can be used to delete products:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的 `execute` 方法可以用来删除产品：
- en: '[PRE41]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `execute` method not only creates the prepared statement, it also inserts
    the provided ID into it and executes it. It’s hard to get much simpler than that.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute` 方法不仅创建了预编译的语句，还将提供的 ID 插入其中并执行它。这已经足够简单了。'
- en: 'Inserting products can use the same method, but with a list of parameters:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 插入产品可以使用相同的方法，但需要参数列表：
- en: '[PRE42]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The class has another method called `executeInsert`, which is used if any of
    the columns are auto-generated by the database. That method returns a list containing
    the generated values. In this example the `id` values are supplied in the program.
    Auto-generated values will be considered in [section 8.3](#ch08lev1sec3) on Hibernate
    and JPA.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还有一个名为 `executeInsert` 的方法，当任何列由数据库自动生成时使用。该方法返回包含生成值的列表。在这个例子中，`id` 值由程序提供。自动生成的值将在
    [第 8.3 节](#ch08lev1sec3) 中讨论 Hibernate 和 JPA。
- en: Retrieving products involves a minor complication. There are several useful
    methods for querying. Among them are `firstRow`, `eachRow`, and `rows`. The `firstRow`
    method is used when a single row is required. Either `eachRow` or `rows` can be
    used if there are multiple rows in the result set. In that case, `eachRow` returns
    a map of column names to column values, and the `rows` method returns a list of
    maps, one for each row.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 获取产品涉及一个小的复杂性。有几个有用的查询方法。其中 `firstRow`、`eachRow` 和 `rows` 是其中之一。当只需要单行时使用 `firstRow`
    方法。如果有多个行在结果集中，可以使用 `eachRow` 或 `rows`。在这种情况下，`eachRow` 返回一个列名到列值的映射，而 `rows`
    方法返回一个映射列表，每个映射对应一行。
- en: The complication is that the returned column names are in all capitals. For
    example, the query
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂之处在于返回的列名都是大写的。例如，查询
- en: '[PRE43]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: returns
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: '[PRE44]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: for an `id` of `1`. Normally I’d like to use that map as the argument to the
    `Product` constructor, but because the `Product` attributes are all lowercase
    that won’t work.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `id` 为 `1` 的情况。通常我想要将这个映射作为 `Product` 构造函数的参数，但由于 `Product` 属性都是小写，所以这行不通。
- en: One possible solution is to transform the map into a new one with lowercase
    keys. That’s what the `collectEntries` method in the `Map` class is for. The resulting
    implementation of the `findProductById` method is therefore
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是将映射转换为一个具有小写键的新映射。这正是 `Map` 类中的 `collectEntries` 方法的作用。因此，`findProductById`
    方法的实现如下
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It would be easy enough to generalize this to the `getAllProducts` method by
    using `eachRow` and transforming them one at a time. A somewhat more elegant solution
    is to use the `rows` method and transform the resulting list of maps directly:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `eachRow` 并逐个转换它们，很容易将这个方法推广到 `getAllProducts` 方法。一个稍微更优雅的解决方案是使用 `rows`
    方法并直接转换结果列表中的映射：
- en: '[PRE46]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This solution is either incredibly elegant or too clever by half, depending
    on your point of view. Collecting^([[2](#ch08fn02)]) everything together (except
    for the initialization shown in the constructor already), the result is shown
    in the following listing.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案要么非常优雅，要么过于聪明，这取决于你的观点。收集^([[2](#ch08fn02)]) 所有一切（除了在构造函数中已经显示的初始化之外），结果如下所示。
- en: ² No pun intended.
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 没有故意开玩笑。
- en: Listing 8.7\. The complete `SqlProductDAO` class, except for the parts already
    shown
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. 除了已经显示的部分之外，完整的 `SqlProductDAO` 类
- en: '[PRE47]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'By the way, there’s one other option available,^([[3](#ch08fn03)]) but only
    if the `Person` class is implemented in Groovy. If so, I can add a constructor
    to the `Person` class that handles the case conversion there:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，还有一个可用的选项，^([[3](#ch08fn03)]) 但仅当`Person`类是用Groovy实现的。如果是这样，我可以在`Person`类中添加一个构造函数来处理那里的大小写转换：
- en: ³ Thanks to Dinko Srkoc on the Groovy Users email list for this helpful suggestion.
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 感谢Groovy Users电子邮件列表上的Dinko Srkoc提供的这个有用的建议。
- en: '[PRE48]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With this constructor, the `getAllProducts` method reduces to
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个构造函数，`getAllProducts`方法简化为
- en: '[PRE49]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It’s hard to beat that for elegance.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于优雅来说很难超越。
- en: '|  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Going meta**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**进入元领域**'
- en: The “elegant” solution in the chapter breaks down if the class attributes use
    camel case, which is normal. The corresponding database table entries would then
    use underscores to separate the words.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类属性使用驼峰式命名，这在正常情况下是常见的，那么章节中的“优雅”解决方案就会崩溃。相应的数据库表条目将使用下划线来分隔单词。
- en: As shown by Tim Yates on the Groovy Users email list,^([[4](#ch08fn04)]) you
    can use Groovy metaprogramming to add a `toCamelCase` method to the `String` class
    to do the conversion. The relevant code is
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如Groovy Users电子邮件列表上的Tim Yates所示，^([[4](#ch08fn04)]) 你可以使用Groovy元编程向`String`类添加一个`toCamelCase`方法来进行转换。相关的代码是
- en: ⁴ See [http://groovy.329449.n5.nabble.com/Change-uppercase-Sql-column-names-to-lowercase-td5712088.html](http://groovy.329449.n5.nabble.com/Change-uppercase-Sql-column-names-to-lowercase-td5712088.html)
    for the complete discussion.
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 有关完整讨论，请参阅[http://groovy.329449.n5.nabble.com/Change-uppercase-Sql-column-names-to-lowercase-td5712088.html](http://groovy.329449.n5.nabble.com/Change-uppercase-Sql-column-names-to-lowercase-td5712088.html)。
- en: '[PRE50]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Every Groovy class has a metaclass retrieved by the `getMetaClass` method. New
    methods can be added to the metaclass by assigning closures to them, as is done
    here. A no-arg closure is used, which implies that the new method will take zero
    arguments.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Groovy类都有一个通过`getMetaClass`方法检索到的元类。可以通过将闭包分配给它们来向元类添加新方法，就像这里所做的那样。使用了一个无参闭包，这意味着新方法将接受零个参数。
- en: Inside the closure the `delegate` property refers to the object on which it
    was invoked. In this case it’s the string being converted. The database table
    columns are in uppercase separated by underscores, so the delegate is converted
    to lowercase and then split at the underscores, resulting in a list of strings.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包内部，`delegate`属性指向它被调用的对象。在这种情况下，它是被转换的字符串。数据库表列是大写字母，由下划线分隔，因此将`delegate`转换为小写，然后在下划线处分割，结果得到一个字符串列表。
- en: Then the spread-dot operator is used on the list to invoke the `capitalize`
    method on each one, which capitalizes only the first letter. The `join` method
    then reassembles the string.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用扩展点操作符在列表上调用每个元素的`capitalize`方法，这只会将第一个字母转换为大写。然后`join`方法重新组装字符串。
- en: Then comes the fun part. The `with` method takes a closure, and inside that
    closure any method without a reference is invoked on the delegate. The `take`
    and `drop` methods are used on lists (or, in this case, a character sequence).
    The `take` method retrieves the number of elements specified by its argument.
    Here that value is 1, so it returns the first letter, which is made lowercase.
    The `drop` method returns the rest of the elements after the number in the argument
    is removed, which in this case means the rest of the string.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是更有趣的部分。`with`方法接受一个闭包，在该闭包内部，任何没有引用的方法都会在`delegate`上被调用。`take`和`drop`方法用于列表（或在这种情况下，字符序列）。`take`方法检索其参数指定的元素数量。这里该值是1，因此返回第一个字母，并将其转换为小写。`drop`方法返回在移除参数中的数字后的其余元素，在这种情况下意味着字符串的其余部分。
- en: The result is that you can call the method on a string and convert it. `'FIRST_NAME'
    .toLowerCase()` becomes `'firstName'`, and so on.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，你可以在字符串上调用该方法并将其转换。`'FIRST_NAME' .toLowerCase()`变为`'firstName'`，依此类推。
- en: Welcome to the wonderful world of Groovy metaprogramming.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到Groovy元编程的奇妙世界。
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The advantages of `groovy.sql.Sql` over raw JDBC are obvious. If I have SQL
    code already written, I always use it.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`groovy.sql.Sql`相对于原始JDBC的优点是显而易见的。如果我已经编写了SQL代码，我总是使用它。'
- en: '|  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (Groovy SQL^([[5](#ch08fn05)]))**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（Groovy SQL^([[5](#ch08fn05)]))**'
- en: '**1**.  The `groovy.sql.Sql` class makes working with raw SQL better in every
    way: resource management, multiline strings, closure support, and mapping of result
    sets to maps.'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  `groovy.sql.Sql`类在各个方面都使处理原始SQL变得更好：资源管理、多行字符串、闭包支持以及将结果集映射到映射。'
- en: '**2**.  Related examples in this book can be found in [chapter 7](kindle_split_019.html#ch07)
    on Spring and [chapter 9](kindle_split_021.html#ch09) on REST.'
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  本书中相关的示例可以在第7章（关于Spring）[第7章](kindle_split_019.html#ch07)和第9章（关于REST）[第9章](kindle_split_021.html#ch09)中找到。'
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '⁵ Worst SQL Joke Ever Told: SQL query walks into a bar, selects two tables
    and says, “Mind if I join you?” (rimshot). (Warning: NoSQL version later in this
    chapter.)'
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 世界上最糟糕的SQL笑话：SQL查询走进酒吧，选择两张表，然后说，“介意我加入你们吗？”（响指）。（警告：本章后面的NoSQL版本。）
- en: Rather than write all that SQL, you can instead use one of the object-relational
    mapping (ORM) tools available, the most prevalent of which is still Hibernate.
    The Java Persistence API (JPA) specification acts as a front-end on ORM tools
    and is the subject of the next section.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编写所有那些SQL代码，你可以使用可用的对象关系映射（ORM）工具之一，其中最普遍的还是Hibernate。Java持久化API（JPA）规范作为ORM工具的前端，是下一节的主题。
- en: '8.3\. The Java approach, part 2: Hibernate and JPA'
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. Java方法，第2部分：Hibernate和JPA
- en: One approach to simplifying JDBC is to automate as much of it as possible. The
    early years of Java saw attempts to add ORM tools directly to the specification,
    with varying degrees of success. First came Java Data Objects, which worked directly
    with compiled bytecodes and are largely forgotten today. Then came Enterprise
    JavaBeans (EJB) entity beans, which were viewed by the community as a mess in
    the first couple of versions.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 简化JDBC的一种方法是通过尽可能自动化它。Java的早期年份见证了将ORM工具直接添加到规范中的尝试，成功率各不相同。首先是Java数据对象（JDO），它直接与编译后的字节码工作，今天在很大程度上已被遗忘。然后是企业JavaBeans（EJB）实体bean，社区在最初的几个版本中将其视为一团糟。
- en: As frequently happens when there’s a need and only an unpopular specification
    available, the open source community developed a practical alternative. In this
    case the project that emerged was called Hibernate, which still aims to be the
    ORM tool of choice in the Java world when dealing with relational databases.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要某种功能而只有不受欢迎的规范可用时，这种情况经常发生，开源社区开发了一个实用的替代方案。在这种情况下，出现的项目被命名为Hibernate，它仍然旨在在处理关系数据库时成为Java世界的首选ORM工具。
- en: 'In regular JDBC a `ResultSet` is connected to the data source as long as the
    connection is open, and goes away when the connection is closed. In the EJB world,
    therefore, you needed two classes to represent an entity: one that was always
    connected, and one that was never connected. The former was called something analogous
    to `ProductEJB`, and the latter was a `ProductTO`, or transfer object.^([[6](#ch08fn06)])
    When getting a product from the database the `ProductEJB` held the data for a
    single row, and its data was transferred to a `ProductTO` for display. The transfer
    object wasn’t connected, so it could get stale, but at least it didn’t use up
    a database connection, which is a scarce commodity. Transferring the data from
    the EJB to the TO was done by a session EJB, where the transaction boundaries
    occurred. The session EJBs formed the service layer, which also held business
    logic. The whole process was much like that shown in [figure 8.2](#ch08fig02).'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规JDBC中，`ResultSet`只要连接打开就连接到数据源，连接关闭时就会消失。因此，在EJB世界中，你需要两个类来表示一个实体：一个始终连接，一个从不连接。前者被称为类似于`ProductEJB`的东西，后者是`ProductTO`，或传输对象。[6](#ch08fn06)
    当从数据库获取产品时，`ProductEJB`保存单行数据，并将其数据传输到`ProductTO`以进行显示。传输对象不连接，因此可能会过时，但至少它没有使用数据库连接，这是一种稀缺的商品。从EJB到TO的数据传输是通过会话EJB完成的，事务边界在那里发生。会话EJBs构成了服务层，也包含了业务逻辑。整个过程与[图8.2](#ch08fig02)中所示的过程非常相似。
- en: ⁶ Older terms included Data Transfer Object (DTO) and Value Object (VO).
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 旧术语包括数据传输对象（DTO）和值对象（VO）。
- en: Figure 8.2\. Controllers contact transactional session EJBs, which acquire database
    data through entity EJBs. The data is copied to transfer objects and returned
    to the controller.
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 控制器与事务会话EJBs进行交互，通过实体EJBs获取数据库数据。数据被复制到传输对象中，并返回给控制器。
- en: '![](08fig02_alt.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig02_alt.jpg)'
- en: The result is that the `ProductEJB` class and the `ProductTO` class were essentially
    identical, in that they both contained the same method signatures, even though
    the implementations were different. Martin Fowler (author of *Patterns of Enterprise
    Application Architecture* [Addison-Wesley, 2002], *Refactoring* [Addision-Wesley,
    1999], and several other books) calls that an anti-pattern and says that it’s
    a symptom of a flawed design.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，`ProductEJB` 类和 `ProductTO` 类在本质上相同，因为它们都包含相同的方法签名，尽管实现不同。马丁·福勒（*企业应用架构模式*
    [Addison-Wesley, 2002]，*重构* [Addision-Wesley, 1999]，以及其他几本书的作者）称这为反模式，并说这是设计有缺陷的症状。
- en: One of the key differences between Hibernate and EJBs is the concept of a Hibernate
    session. The innovation was that, rather than one class of objects that were always
    connected and another class of objects that were never connected, what was needed
    was a set of objects that were sometimes connected and sometimes not. In Hibernate,
    when objects are part of a Hibernate session, the framework promises to keep them
    in sync with the database. When the session closes, the object is disconnected,
    thereby becoming its own transfer object. Any time an object is retrieved through
    Hibernate, it becomes part of a Hibernate session.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 和 EJBs 之间的一个关键区别是 Hibernate 会话的概念。创新之处在于，而不是一类始终连接的对象和另一类永远不会连接的对象，需要的是一组有时连接有时不连接的对象。在
    Hibernate 中，当对象是 Hibernate 会话的一部分时，框架承诺将它们与数据库保持同步。当会话关闭时，对象断开连接，从而成为它自己的传输对象。任何时候通过
    Hibernate 获取的对象，都成为 Hibernate 会话的一部分。
- en: You retrieve a Hibernate session via a session factory. The session factory
    reads all the mapping metadata, configures the framework, and performs any necessary
    preprocessing. It’s supposed to be instantiated only once, acting as a singleton.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过会话工厂检索 Hibernate 会话。会话工厂读取所有映射元数据，配置框架，并执行任何必要的预处理。它应该只实例化一次，作为单例。
- en: Those readers who are familiar with the Spring framework (as discussed in [chapter
    7](kindle_split_019.html#ch07)) should suddenly become interested, because managing
    singletons is one of the things that Spring is all about. Another of its capabilities
    is declarative transaction management, which fits in nicely too. The result is
    that designs in the EJB 2.x world were replaced by a combination of Spring for
    the declarative transactions and the session factory and Hibernate for the entity
    beans.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 那些熟悉 Spring 框架的读者（如第 7 章所述[kindle_split_019.html#ch07]）可能会突然产生兴趣，因为管理单例是 Spring
    所关注的事情之一。它的另一个能力是声明式事务管理，这也非常适合。结果是，EJB 2.x 世界的架构被 Spring 的声明式事务和会话工厂以及 Hibernate
    的实体 Bean 的组合所取代。
- en: In version 3 of EJB the architecture was redesigned again to fit more closely
    with that used by Spring and Hibernate. The entity beans part led to the creation
    of the Java Persistence API. The JPA world uses the same concepts but labels them
    differently.^([[7](#ch08fn07)]) The Hibernate `Session` becomes an `EntityManager`.
    The `SessionFactory` is an `EntityManagerFactory`. Objects that are managed (that
    is, in the Hibernate session) compose a *persistence context*.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EJB 的第 3 版中，架构再次进行了重新设计，以更紧密地适应 Spring 和 Hibernate 所使用的架构。实体 Bean 部分导致了 Java
    持久化 API 的创建。JPA 世界使用相同的概念，但标签不同.^([[7](#ch08fn07)]) Hibernate 的 `Session` 变成了
    `EntityManager`。`SessionFactory` 是 `EntityManagerFactory`。被管理的对象（即，在 Hibernate
    会话中）组成一个 *持久化上下文*。
- en: ⁷ Of course it does. Using the same terms would be too easy.
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 当然，这是肯定的。使用相同的术语会太容易了。
- en: Finally, in the original Hibernate, mapping from entity classes to database
    tables was done through XML files. Over time XML has become less popular and has
    been replaced by annotations. Hibernate and JPA share many annotations, which
    is fortunate.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在原始的 Hibernate 中，实体类到数据库表的映射是通过 XML 文件完成的。随着时间的推移，XML 已经变得不那么受欢迎，并被注解所取代。Hibernate
    和 JPA 共享许多注解，这是幸运的。
- en: It’s time for an example, which will bring Spring, Hibernate, and JPA together.
    [Chapter 7](kindle_split_019.html#ch07) on the Spring framework discusses Spring
    in some detail. Here I’ll just highlight the parts needed for the example.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候举一个例子了，这个例子将 Spring、Hibernate 和 JPA 结合在一起。Spring 框架的第 7 章[kindle_split_019.html#ch07]详细讨论了
    Spring。在这里，我将只突出示例所需的各个部分。
- en: To start I’ll need a database. For that I’ll use H2, a pure Java file- or memory-based
    database. Spring provides an embedded database bean to make it easy to work with
    H2\. The relevant bean from the Spring configuration file is
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要一个数据库。为此，我将使用H2，一个基于Java文件或内存的纯Java数据库。Spring提供了一个嵌入式数据库bean，以便更容易地与H2一起工作。Spring配置文件中相关的bean是
- en: '[PRE51]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The schema and test-data SQL files define a single table, called `PRODUCT`,
    with three rows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 架构和测试数据SQL文件定义了一个名为`PRODUCT`的单个表，包含三行：
- en: '[PRE52]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Spring provides a bean to represent the `EntityManagerFactory`, which has a
    handful of properties to set:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一个表示`EntityManagerFactory`的bean，它有几个属性可以设置：
- en: '[PRE53]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `LocalContainerEntityManagerFactoryBean`^([[8](#ch08fn08)]) class uses the
    data source bean defined previously, scans the given packages for entities, and
    uses Hibernate as its implementation.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalContainerEntityManagerFactoryBean`类使用之前定义的数据源bean，扫描给定的包以查找实体，并使用Hibernate作为其实施。'
- en: ⁸ Extremely long class names are a Spring staple. My favorite is `AbstractTransactional-Data-Source-Spring-ContextTests`,
    which has 49 characters and is even deprecated. What’s yours?
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 极长的类名是Spring的常规。我最喜欢的是`AbstractTransactional-Data-Source-Spring-ContextTests`，它有49个字符，甚至已被弃用。你的呢？
- en: 'The entity itself is the `Product` class, this time with a sprinkling of JPA
    (or Hibernate) annotations:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 实体本身是`Product`类，这次添加了一些JPA（或Hibernate）注解：
- en: '[PRE54]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `@Entity` and `@Id` annotations declare `Product` to be a class mapped to
    a database table and identify the primary key, respectively. Because, by an amazing
    coincidence,^([[9](#ch08fn09)]) the `Product` attribute names and the database
    column names happen to match, I don’t need the additional physical annotations
    like `@Table` and `@Column`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity`和`@Id`注解声明`Product`是一个映射到数据库表的类，并分别标识主键。由于一个惊人的巧合，^([[9](#ch08fn09)])
    `Product`属性名和数据库列名恰好匹配，所以我不需要额外的物理注解，如`@Table`和`@Column`。'
- en: ⁹ Not really.
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 并非如此。
- en: The `ProductDAO` interface is the same as that shown in [section 8.1](#ch08lev1sec1)
    on JDBC, except that now the `insertProduct` method returns the new database-generated
    primary key. The `JpaProductDAO` implementation class is where the action happens,
    and it’s shown in the next listing.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDAO`接口与[第8.1节](#ch08lev1sec1)中展示的JDBC接口相同，但现在`insertProduct`方法返回新的数据库生成的主键。`JpaProductDAO`实现类是动作发生的地方，它将在下一个列表中展示。'
- en: Listing 8.8\. The `JpaProductDAO` class, which uses JPA classes to implement
    the DAO
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8。使用JPA类实现DAO的`JpaProductDAO`类
- en: '![](211fig01_alt.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![211fig01_alt.jpg](211fig01_alt.jpg)'
- en: The JPA implementation is wonderfully spare, but that’s because it assumes the
    transaction management is handled elsewhere and that Spring will handle allocating
    and closing the necessary database resources.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: JPA实现非常简洁，但这是因为它假设事务管理由其他地方处理，并且Spring将处理分配和关闭必要的数据库资源。
- en: I would never be comfortable writing that much code without a decent test case.
    Spring’s test context framework manages the application context, allows the test
    fixture to be injected, and, if a transaction manager is supplied, automatically
    rolls back transactions at the end of each test.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我绝不会在没有合适的测试用例的情况下编写这么多代码。Spring的测试上下文框架管理应用程序上下文，允许测试固定值被注入，并且如果提供了事务管理器，则在每次测试结束时自动回滚事务。
- en: 'To handle the transactions I used another Spring bean, `JpaTransactionManager`,
    which uses the entity manager factory previously specified:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理事务，我使用了另一个Spring bean，`JpaTransactionManager`，它使用之前指定的实体管理器工厂：
- en: '[PRE55]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The resulting test case is shown in the following listing.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的测试用例如下所示。
- en: Listing 8.9\. A Spring test case for the JPA DAO implementation
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9。JPA DAO实现的Spring测试用例
- en: '[PRE56]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The tests check each of the DAO methods. My favorite is `testDelete`, which
    deletes every row in the table, verifies that they’re gone, and *doesn’t add them
    back in*, which has the side effect of giving any DBAs heart palpitations. Fortunately,
    Spring rolls back all the changes when the test is finished, so nothing is lost,
    but a good time is had by all.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 测试检查每个DAO方法。我最喜欢的是`testDelete`，它删除表中的每一行，验证它们已经消失，并且*不会将它们重新添加回去*，这会产生副作用，让任何数据库管理员心跳加速。幸运的是，Spring在测试完成后回滚所有更改，所以没有东西丢失，但大家都有了一个愉快的时光。
- en: The last piece of the puzzle is the Maven build file. You can see it, as usual,
    in the book source code.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是Maven构建文件。您可以在书籍源代码中看到它，就像往常一样。
- en: That’s a fair amount of code and configuration, and I’ve only got one class
    and one database table. Frankly, if I can’t make that work, I might as well give
    it up. It’s when you add relationships that life gets complicated.^([[10](#ch08fn10)])
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当多的代码和配置，而我只有一个类和一个数据库表。坦白说，如果我不能让它工作，我可能就放弃吧。当你添加关系时，生活就会变得复杂。（[[10](#ch08fn10)]）
- en: ^(10) On many levels; sometimes the jokes just write themselves.
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([10]) 在许多层面上；有时笑话会自己写出来。
- en: '|  |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (Hibernate and JPA)**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lessons learned (Hibernate and JPA)**'
- en: '**1**.  The Java Persistence API manages object-relational mapping providers
    that convert objects to table rows and back again.'
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. Java 持久性 API 管理对象关系映射提供程序，这些程序将对象转换为表行，然后再转换回来。'
- en: '**2**.  Hibernate is the most common JPA provider in the industry.'
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. Hibernate 是业界最常用的 JPA 提供商。'
- en: '**3**.  ORM tools provide transitive persistence, persistence contexts, SQL
    code generation, and more.'
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. ORM 工具提供传递持久性、持久化上下文、SQL 代码生成等功能。'
- en: '**4**.  Like all Java libraries, they’re still pretty verbose.'
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 与所有 Java 库一样，它们仍然相当冗长。'
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy can help this situation in a couple of ways, which will be discussed
    in the next section.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 可以通过几种方式帮助这种情况，这些将在下一节中讨论。
- en: '8.4\. The Groovy approach, part 2: Groovy and GORM'
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '8.4. The Groovy approach, part 2: Groovy and GORM'
- en: Before getting into the Grails Object-Relational Mapping (GORM) part of Grails,
    let me identify a couple of places where Groovy can simplify the example application
    from the previous section.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨 Grails 对象关系映射（GORM）之前，让我指出几个 Groovy 可以简化上一节示例应用的地方。
- en: 8.4.1\. Groovy simplifications
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1. Groovy 简化
- en: The entity class `Product` could be written as a POGO. That wouldn’t change
    the behavior, but it would cut the size of the class by about two-thirds. That
    and the other Spring-related parts of the application could be converted to Groovy,
    which is shown in more detail in [chapter 7](kindle_split_019.html#ch07) on Spring.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类 `Product` 可以写成 POGO。这不会改变行为，但可以将类的尺寸减少大约三分之二。还有应用程序的其他与 Spring 相关的部分也可以转换为
    Groovy，这在第 7 章（[kindle_split_019.html#ch07](https://example.org/kindle_split_019.html#ch07)）中会有更详细的展示。
- en: A Gradle build file is contained in the book source code. It looks like most
    of the build files shown in earlier chapters, but it’s considerably shorter and
    easier to read than the corresponding Maven build.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍源代码中包含一个 Gradle 构建文件。它看起来与前面章节中显示的大多数构建文件相似，但它比相应的 Maven 构建文件短得多，也更容易阅读。
- en: 8.4.2\. Grails Object-Relational Mapping (GORM)
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2. Grails 对象关系映射（GORM）
- en: The Grails framework consists of a set of Groovy DSLs on top of Spring and Hibernate.
    Because the combination of Spring and Hibernate is a very common architecture
    in the Java world, Grails is a natural evolution that simplifies the coding and
    integration issues.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 框架由一组基于 Spring 和 Hibernate 的 Groovy DSLs 组成。由于 Spring 和 Hibernate 的组合在
    Java 世界中是一个非常常见的架构，Grails 是一个自然的演变，它简化了编码和集成问题。
- en: Grails is discussed in more detail in [chapter 10](kindle_split_022.html#ch10)
    on web applications, but the Hibernate integration part is relevant here. Grails
    combines Groovy domain-specific languages (DSLs) to make configuring the domain
    classes easy.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 在第 10 章（[kindle_split_022.html#ch10](https://example.org/kindle_split_022.html#ch10)）中详细讨论了
    Web 应用程序，但 Hibernate 集成部分与此相关。Grails 结合 Groovy 领域特定语言（DSLs）来简化配置领域类。
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Domain Classes
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 领域类
- en: In Grails the term *domain* is like *entity* in JPA. Domain classes map to database
    tables.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grails 中，术语 *domain* 与 JPA 中的 *entity* 类似。领域类映射到数据库表。
- en: '|  |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Consider a small but nontrivial domain model based on the same `Product` class
    used earlier in this chapter. The next listing shows the `Product` class, now
    in Groovy.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个基于本章前面使用过的相同 `Product` 类的小型但非平凡的领域模型。下面的列表显示了 `Product` 类，现在是在 Groovy 中。
- en: Listing 8.10\. The `Product` class, this time as a POGO in a Grails application
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10. `Product` 类，这次是在 Grails 应用程序中的 POGO
- en: '[PRE57]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In Grails each domain class implicitly has a primary key called `id` of some
    integer type, which isn’t shown here but exists nevertheless. The `constraints`
    block here is part of GORM.^([[11](#ch08fn11)]) Each line in the constraints block
    is actually a method call, where the name of the method is the attribute name.
    The `blank` constraint implies, naturally enough, that the name of the product
    can’t be an empty string. The `price` constraint sets a minimum value of 0, and
    the `d` makes it a double, because the constraint type must match the attribute
    data type.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grails 中，每个领域类隐式地有一个名为 `id` 的主键，它是某种整型，这里没有展示但确实存在。这里的 `constraints` 块是 GORM
    的一部分^([[11](#ch08fn11)])。`constraints` 块中的每一行实际上是一个方法调用，其中方法名是属性名。`blank` 约束自然地意味着产品的名称不能是空字符串。`price`
    约束设置最小值为 0，而 `d` 使其成为双精度浮点数，因为约束类型必须与属性数据类型匹配。
- en: ^(11) The lizard creature that Captain Kirk fought in the *Star Trek* original
    series episode “Arena” was a Gorn, not a GORM. I mean, who ever heard of Grails
    Object-Relational Napping, anyway? (Though there’s probably a “lazy loading” joke
    in there somewhere.)
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([11](#ch08fn11)) 在《星际迷航》原系列剧集“竞技场”中，指挥官柯克与之战斗的爬行动物是戈恩，而不是 GORM。我的意思是，谁听说过
    Grails 对象关系式睡眠呢？(尽管可能有一个“懒加载”的笑话在其中。)
- en: This application will have three more domain classes, representing customers,
    orders, and lines on the orders. Next up is the `Customer` class, shown in the
    next listing.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将拥有另外三个领域类，代表客户、订单和订单上的行。接下来是 `Customer` 类，在下一个列表中展示。
- en: Listing 8.11\. The `Customer` class. Customers have many orders (hopefully).
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. `Customer` 类。客户拥有多个订单（希望如此）。
- en: '![](214fig01.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![图片](214fig01.jpg)'
- en: Customers have a `name` attribute and a `Set` representing their orders.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 客户有一个 `name` 属性和一个表示其订单的 `Set`。
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Grails hasmany
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Grails hasmany
- en: In Grails the `hasMany` property implies a one-to-many relationship. By default,
    the contained objects form a set.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grails 中，`hasMany` 属性表示一对一关系。默认情况下，包含的对象形成一个集合。
- en: '|  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `name` cannot be blank. The `Order` class is shown in the following listing.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 不能为空。`Order` 类在下面的列表中展示。'
- en: Listing 8.12\. The `Order` class, which has many orders and belongs to a customer
  id: totrans-470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. `Order` 类，包含多个订单且属于某个客户
- en: '![](215fig01_alt.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![图片](215fig01_alt.jpg)'
- en: There’s a lot going on here. First, an order contains a `Set` of order lines.
    Orders also belong to a specific customer. The customer reference implies that
    you can navigate from an order to its associated customer. By assigning it to
    the `belongsTo` property in this way, a cascade-delete relationship exists between
    the two classes. If a customer is deleted from the system, all of its orders are
    deleted as well.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行。首先，一个订单包含一个订单行的 `Set`。订单也属于特定的客户。客户引用意味着你可以从订单导航到其关联的客户。通过将其分配给 `belongsTo`
    属性，这两个类之间存在级联删除关系。如果从系统中删除客户，所有订单也会被删除。
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Grails belongsto
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Grails belongsto
- en: In Grails, the word `belongsTo` implies a cascade-delete relationship.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grails 中，单词 `belongsTo` 表示级联删除关系。
- en: '|  |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `getPrice` method computes the price of the order by summing up the prices
    on each order line. It too is a derived quantity and is therefore not saved in
    the database.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPrice` 方法通过计算每个订单行的价格来计算订单的价格。它也是一个派生量，因此不会保存到数据库中。'
- en: The `dateCreated` and `lastUpdated` properties are automatically maintained
    by Hibernate. When an order is first saved, its `dateCreated` value is set; and
    every time it’s modified, `lastUpdated` is saved as well.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`dateCreated` 和 `lastUpdated` 属性由 Hibernate 自动维护。当订单首次保存时，其 `dateCreated` 值被设置；每次修改时，`lastUpdated`
    也会被保存。'
- en: Finally, the `mapping` block is used to customize how the class is mapped to
    a database table. By default, Grails will generate a table whose name matches
    the class name. Because the word `order` is an SQL keyword, the resulting DDL
    statement would have problems. In the `mapping` block the generated table name
    is specified to be `orders`, rather than `order`, to avoid that problem. Also,
    Hibernate treats all associations as lazy. In this case, that means that if an
    order is loaded, a separate SQL query will be required to load the order lines
    as well. In the mapping block, the `fetch` `join` relationship means that all
    the associated order lines will be loaded at the same time as the order, via an
    inner join.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`mapping` 块用于自定义类如何映射到数据库表。默认情况下，Grails 将生成一个与类名匹配的表。因为 `order` 是一个 SQL 关键字，所以生成的
    DDL 语句会有问题。在 `mapping` 块中，指定的生成表名是 `orders`，而不是 `order`，以避免这个问题。此外，Hibernate 将所有关联都视为延迟加载。在这种情况下，这意味着如果加载了一个订单，还需要一个单独的
    SQL 查询来加载订单行。在映射块中，`fetch` `join` 关系意味着所有关联的订单行将与订单一起通过内部连接加载。
- en: The `OrderLine` class contains the product being ordered and the quantity, as
    shown in the following listing.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderLine` 类包含正在订购的产品和数量，如下面的列表所示。'
- en: Listing 8.13\. The `OrderLine` POGO, which is assembled to build an `Order`
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. 组装以构建 `Order` 的 `OrderLine` POGO
- en: '[PRE58]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `getPrice` method multiplies the quantity times the price of the product
    to get the price of the order line. This, in turn, is summed in order to get the
    total price, as you saw earlier.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPrice` 方法将数量乘以产品的价格以获取订单行的价格。然后，它将这个值加起来，以获得之前看到的总价。'
- en: Note also that the `OrderLine` class does not have a reference to the `Order`
    it belongs to. This is a unidirectional cascade-delete relationship. If the order
    is deleted, all the order lines go, but you cannot navigate from an order line
    to its associated order.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`OrderLine` 类没有对其所属的 `Order` 的引用。这是一个单向级联删除关系。如果订单被删除，所有订单行也会被删除，但你不能从订单行导航到其关联的订单。
- en: When you declare a `hasMany` relationship, Grails then provides methods for
    adding the contained objects to their containers. To illustrate one of those methods,
    here’s the file `BootStrap.groovy`, which is a configuration file used in a Grails
    application for initialization code. The next listing shows code that instantiates
    a customer, two products, an order, and some order lines and saves them all to
    the database.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明一个 `hasMany` 关系时，Grails 会提供方法来将包含的对象添加到它们的容器中。为了说明这些方法之一，这里有一个名为 `BootStrap.groovy`
    的文件，它是 Grails 应用中用于初始化代码的配置文件。接下来的列表显示了创建一个客户、两个产品、一个订单和一些订单行并将它们全部保存到数据库中的代码。
- en: Listing 8.14\. Initialization code in `BootStrap.groovy`
  id: totrans-486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14\. `BootStrap.groovy` 中的初始化代码
- en: '[PRE59]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The code in the `init` closure is executed when the application is started.
    The `addToOrderLines` method comes from declaring that an `Order` has many `OrderLine`
    instances. The `save` method first validates each object against its constraints
    and then saves it to the database.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，会执行 `init` 闭包中的代码。`addToOrderLines` 方法来自于声明一个 `Order` 有多个 `OrderLine`
    实例。`save` 方法首先验证每个对象是否符合其约束，然后将它们保存到数据库中。
- en: Grails uses Hibernate’s ability to generate a database schema. An entity relationship
    diagram (ERD) for the generated database is shown in [figure 8.3](#ch08fig03).^([[12](#ch08fn12)])
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 使用 Hibernate 生成数据库模式的能力。生成的数据库的实体关系图（ERD）显示在 [图 8.3](#ch08fig03)^([[12](#ch08fn12)])
    中。
- en: ^(12) This diagram was generated using MySQL Workbench, which is a free tool
    available at [www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/).
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[(12)](http://www.mysql.com/products/workbench/) 这个图表是使用 MySQL Workbench 生成的，这是一个可在
    [www.mysql.com/products/workbench/](http://www.mysql.com/products/workbench/)
    获取的免费工具。
- en: Figure 8.3\. An entity relationship diagram for the generated database, given
    the domain classes listed in the text
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3\. 给定文本中列出的域类的生成的数据库实体关系图
- en: '![](08fig03_alt.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![08fig03_alt](08fig03_alt.jpg)'
- en: In this case the database is MySQL version 5, so the data type for `id` is `BIGINT`.
    It also converts the camel case properties `dateCreated` and `lastUpdated` into
    underscores in the table. Because the relationship between `Order` and `OrderLine`
    was unidirectional, Hibernate generates a join table between them called `orders_order_line`.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据库是 MySQL 版本 5，因此 `id` 的数据类型是 `BIGINT`。它还将驼峰式属性 `dateCreated` 和 `lastUpdated`
    转换为表中的下划线。由于 `Order` 和 `OrderLine` 之间的关系是单向的，Hibernate 在它们之间生成一个名为 `orders_order_line`
    的连接表。
- en: Grails also adds a column called `version` to each table. Hibernate uses this
    for optimistic locking. That means whenever a row of a table is modified and saved,
    Hibernate will automatically increment the version column by one. That’s an attempt
    to get locking behavior without actually locking a row and paying the resulting
    performance penalty. If the application involves many reads but only a few writes,
    this works well. If there are too many writes, Grails also adds an instance method
    called `lock` to each domain class that locks the row. That’s called *pessimistic
    locking* and will result in worse performance, so it’s only used when necessary.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 还为每个表添加了一个名为 `version` 的列。Hibernate 使用这个列来实现乐观锁。这意味着每当一个表的行被修改并保存时，Hibernate
    会自动将版本列增加一。这是尝试在不实际锁定行并支付性能惩罚的情况下获得锁定行为的一种尝试。如果应用程序涉及许多读取但只有少量写入，这将工作得很好。如果有太多的写入，Grails
    还为每个域类添加了一个名为 `lock` 的实例方法来锁定行。这被称为 *悲观锁*，会导致性能下降，因此仅在必要时使用。
- en: Grails does far more than this. For example, Grails uses Groovy to generate
    dynamic finder methods for each domain class. For the `Product` class, Grails
    generates static methods on the domain class that include
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 做的远不止这些。例如，Grails 使用 Groovy 为每个域类生成动态的查找方法。对于 `Product` 类，Grails 在域类上生成静态方法，包括
- en: '`Product.list()`, which returns all product instances'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product.list()`, 返回所有产品实例'
- en: '`Product.findByName(...)`, which returns the first product matching the name'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product.findByName(...)`, 返回第一个匹配名称的产品'
- en: '`Product.findAllByPriceGreaterThan(...)`, which returns all the products whose
    prices are greater than the argument'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product.findAllByPriceGreaterThan(...)`, 返回所有价格大于参数的产品'
- en: '`Product.findAllByNameIlikeAndPriceGreaterThan(...,...)`, which returns products
    whose names satisfy a case-insensitive SQL `like` clause and which have prices
    greater than the second argument'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Product.findAllByNameIlikeAndPriceGreaterThan(...,...)`, 返回名称满足不区分大小写的 SQL
    `like` 子句且价格大于第二个参数的产品'
- en: There are many more; see the Grails documentation^([[13](#ch08fn13)]) for details.
    In each case Grails uses the mappings to generate SQL code satisfying the desired
    conditions.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多；有关详细信息，请参阅 Grails 文档^([13](#ch08fn13)))。在每种情况下，Grails 都使用映射来生成满足所需条件的 SQL
    代码。
- en: ^(13) See [http://grails.org/doc/latest/](http://grails.org/doc/latest/) for
    the Grails documentation. [Chapter 6](kindle_split_017.html#ch06) in those docs
    discusses GORM in detail.
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([13]) 有关 Grails 文档，请参阅 [http://grails.org/doc/latest/](http://grails.org/doc/latest/)。这些文档中的
    [第 6 章](kindle_split_017.html#ch06) 详细讨论了 GORM。
- en: 'Grails also uses Groovy to provide a builder for criteria queries. Hibernate
    has an API for criteria queries that allows you to build up a query programmatically.
    The Java API works but is still quite verbose. Grails dramatically simplifies
    it so that you can write expressions like this:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 还使用 Groovy 提供了构建器用于构建查询条件。Hibernate 有一个用于构建查询条件的 API，允许您以编程方式构建查询。Java
    API 可以工作，但仍然相当冗长。Grails 极大地简化了它，使得您可以编写如下表达式：
- en: '[PRE60]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This generates an SQL statement to find all products whose names include the
    letter *e* and whose prices are between $2.50 and $10.00\. It returns the first
    10 matching products in descending order by price.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成一个 SQL 语句来查找所有名称中包含字母 *e* 且价格在 $2.50 到 $10.00 之间的产品。它按价格降序返回前 10 个匹配产品。
- en: One of the fundamental principles in Hibernate is the concept of a Hibernate
    session. As stated in the previous section, Hibernate ensures that any object
    inside a Hibernate session (what JPA calls a persistence context) will be kept
    in sync with the database. In Hibernate, objects can be in one of three states,^([[14](#ch08fn14)])
    as shown in [figure 8.4](#ch08fig04).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 的一个基本原则是 Hibernate 会话的概念。如前所述，Hibernate 确保任何在 Hibernate 会话中（JPA 所称的持久化上下文）的对象都将与数据库保持同步。在
    Hibernate 中，对象可以处于三种状态之一，^([14](#ch08fn14)))，如图 8.4 所示。
- en: ^(14) The Hibernate docs defining the states can be found at [http://mng.bz/Q9Ry](http://mng.bz/Q9Ry).
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([14]) 定义状态的 Hibernate 文档可以在 [http://mng.bz/Q9Ry](http://mng.bz/Q9Ry) 找到。
- en: Figure 8.4\. New and deleted objects are transient. When they are saved they
    become persistent, and when the session closes they become detached. Knowing the
    state of an object is key to understanding how it works in Hibernate.
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4\. 新的和已删除的对象是瞬时的。当它们被保存时，它们变为持久，当会话关闭时，它们变为分离。了解对象的状态是理解它在 Hibernate 中如何工作的关键。
- en: '![](08fig04.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig04.jpg)'
- en: Any object retrieved through Hibernate—for example, by using one of the dynamic
    finders or criteria queries—is placed in the persistent state and will stay in
    sync with the database while it remains in that state. Newly created objects that
    have not yet been saved are transient, and objects that are in memory when the
    Hibernate session is closed are then detached. Detached objects are no longer
    connected to the database.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Hibernate检索到的任何对象——例如，通过使用动态查找器或条件查询之一——都会被放置在持久状态中，并且在该状态下会与数据库保持同步。新创建的尚未保存的对象是瞬时的，而当Hibernate会话关闭时内存中的对象则变为分离的。分离的对象不再与数据库连接。
- en: The key question is, when is the Hibernate session created, and when is it closed?
    Over time a common practice has been established to scope the session to a single
    HTTP request. This is known in the Hibernate literature as the Open Session in
    View (OSIV) pattern, and it’s implemented through a request interceptor. The Spring
    framework comes with a library class to do this automatically, which Grails uses
    by default.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 关键问题是，Hibernate会话何时创建，何时关闭？随着时间的推移，已经形成了一种常见的做法，即把会话范围限定在单个HTTP请求中。在Hibernate文献中，这被称为视图中的打开会话（OSIV）模式，并且通过请求拦截器来实现。Spring框架自带了一个库类来自动完成这项工作，Grails默认使用它。
- en: '|  |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: OSIV Bean
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: OSIV Bean
- en: Grails uses an OSIV bean from Spring to scope the Hibernate session to each
    HTTP request. The bean intercepts incoming requests and creates the session, and
    then it intercepts the outgoing responses and closes the session.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: Grails使用Spring中的OSIV Bean来将Hibernate会话范围限定到每个HTTP请求。该Bean拦截传入的请求并创建会话，然后它拦截传出的响应并关闭会话。
- en: '|  |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Finally, transactions are managed using Spring’s declarative transaction capabilities,
    using the `@Transactional` annotation. All Grails service methods are transactional
    by default, but their behavior can be customized using the annotation.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，事务是通过Spring的声明式事务能力来管理的，使用`@Transactional`注解。所有Grails服务方法默认都是事务性的，但可以使用注解来定制其行为。
- en: Setting up all this infrastructure—managing the sessions and transactions, mapping
    domain classes to tables, establishing relationships, handling optimistic locking,
    generating dynamic finders and criteria queries, and scoping the Hibernate session
    to each request—requires a lot of work when putting Spring and Hibernate together
    manually. Grails does all of this for you, and much more besides.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 设置所有这些基础设施——管理会话和事务、将域类映射到表、建立关系、处理乐观锁定、生成动态查找器和条件查询、以及将Hibernate会话范围限定到每个请求——在手动将Spring和Hibernate结合使用时需要做大量的工作。Grails为你完成所有这些，以及更多。
- en: The Spring framework is one of the most common open source projects in all of
    Java, and Hibernate is still the most common ORM tool. Any project considering
    using them together owes it to itself to consider using Grails.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架是Java中所有开源项目中最为常见的之一，Hibernate仍然是使用最广泛的ORM工具。任何考虑将它们结合使用的项目都应该考虑使用Grails。
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (Groovy and GORM)**'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（Groovy和GORM）**'
- en: '**1**.  Groovy simplifies all database access by using POGOs instead of POJOs,
    using closures for result set processing, and making building and testing easier.'
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. Groovy通过使用POGs（Plain Old Groovy Objects）而不是POJOs（Plain Old Java Objects）、使用闭包进行结果集处理以及简化构建和测试，简化了所有数据库访问。'
- en: '**2**.  The GORM API makes configuring Hibernate-based applications easy. When
    combined with Spring (as in Grails), transactions and the Hibernate session become
    simple, too.'
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. GORM API使得配置基于Hibernate的应用程序变得简单。当与Spring（如Grails中那样）结合使用时，事务和Hibernate会话也变得简单。'
- en: '**3**.  It’s not so easy to use GORM outside of Grails, which is tightly tied
    to Spring. Trying to do so is rare enough in the industry that the process wasn’t
    covered in this chapter.'
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 在Grails之外使用GORM并不容易，因为它与Spring紧密绑定。在业界尝试这样做的情况足够罕见，以至于这个过程在本章中没有涉及。'
- en: '|  |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Recent versions of Grails can also map to non-relational databases, but you
    can also use regular Groovy to do that, as the next section shows.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: Grails的最新版本也可以映射到非关系型数据库，但也可以使用常规Groovy来完成，下一节将展示这一点。
- en: 8.5\. Groovy and NoSQL databases
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5\. Groovy和NoSQL数据库
- en: One of the most interesting trends in software development in the past few years^([[15](#ch08fn15)])
    has been the growth of alternative, non-relational databases. The generic term
    NoSQL (which the majority of the community interpret as “Not Only SQL”) refers
    to a range of schema-less databases that are not based on relational approaches.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年软件开发中最有趣的趋势之一^([[15](#ch08fn15)]) 就是替代性、非关系型数据库的增长。通用术语NoSQL（大多数社区将其解释为“不仅限于SQL”）指的是一系列无模式的数据库，这些数据库不是基于关系型方法。
- en: ^(15) Other than the rise of dynamic languages on the JVM, of course.
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (15) 当然，除了在JVM上动态语言的兴起之外。
- en: The subject of NoSQL databases is already large and rapidly growing, and it’s
    well beyond the scope of this book. But many of the databases have a Java API,
    and some of them also have Groovy wrappers that simplify them.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库的主题已经很大，并且正在迅速增长，这已经超出了本书的范围。但许多数据库都有Java API，其中一些也有简化它们的Groovy包装器。
- en: One of the most interesting is MongoDB,^([[16](#ch08fn16)]) whose Java API is
    rather awkward but is dramatically improved through a Groovy wrapper called GMongo.
    The GMongo project, whose GitHub repository is located at [https://github.com/poiati/gmongo](https://github.com/poiati/gmongo),
    is the product of Paulo Poiati and is the subject of this section.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最有趣的一个是MongoDB，^([[16](#ch08fn16)]) 其Java API相当笨拙，但通过一个名为GMongo的Groovy包装器得到了显著改进。GMongo项目，其GitHub仓库位于[https://github.com/poiati/gmongo](https://github.com/poiati/gmongo)，是Paulo
    Poiati的作品，也是本节的主题。
- en: ^(16) See [www.mongodb.org/](http://www.mongodb.org/) for downloads and documentation.
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (16) 有关下载和文档，请参阅[www.mongodb.org/](http://www.mongodb.org/)。
- en: MongoDB is a document-oriented database that stores its data in binary JSON
    (BSON) format. This makes it perfect for storing data downloaded from RESTful
    web services, which often produce JSON data on request.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个面向文档的数据库，它以二进制JSON（BSON）格式存储其数据。这使得它非常适合存储从RESTful网络服务下载的数据，这些服务通常在请求时产生JSON数据。
- en: 8.5.1\. Populating Groovy vampires
  id: totrans-532
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.1. 填充Groovy吸血鬼
- en: This example came about because I was wandering in a bookstore recently and
    noticed that while there was only one bookshelf labeled “Computer,” there were
    three others labeled “Teen Paranormal Romance.” Rather than lament the decline
    of Western Civilization I chose to take this as evidence that I needed to add
    Groovy vampires to my book.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是因为我最近在书店闲逛时注意到，虽然只有一个书架被标记为“计算机”，但还有三个其他书架被标记为“青少年超自然浪漫”。我选择将此视为我需要在我的书中添加Groovy吸血鬼的证据，而不是哀叹西方文明的衰落。
- en: Consider the web service provided by the movie review site Rotten Tomatoes,
    [http://developer.rottentomatoes.com](http://developer.rottentomatoes.com). If
    you register for an API key, you can make HTTP GET requests that search for movies,
    cast members, and more. The data is returned in JSON form. The base URL for the
    API is located at [http://api.rottentomatoes.com/api/public/v1.0](http://api.rottentomatoes.com/api/public/v1.0).
    All requests start with that URL.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 以电影评论网站Rotten Tomatoes提供的网络服务为例，[http://developer.rottentomatoes.com](http://developer.rottentomatoes.com)。如果你注册了一个API密钥，你可以进行HTTP
    GET请求来搜索电影、演员阵容等。数据以JSON形式返回。API的基本URL位于[http://api.rottentomatoes.com/api/public/v1.0](http://api.rottentomatoes.com/api/public/v1.0)。所有请求都以该URL开始。
- en: For example, searching for information about the movie *Blazing Saddles*^([[17](#ch08fn17)])
    is done by accessing [http://api.rottentomatoes.com/api/public/v1.0/movies.json?q=Blazing%20Saddles&apiKey=...](http://api.rottentomatoes.com/api/public/v1.0/movies.json?q=Blazing%20Saddles&apiKey=...)
    (supply the API key in the URL). The result is a JSON object that looks like the
    following listing.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，搜索关于电影*Blazing Saddles*^([[17](#ch08fn17)]) 的信息是通过访问[http://api.rottentomatoes.com/api/public/v1.0/movies.json?q=Blazing%20Saddles&apiKey=...](http://api.rottentomatoes.com/api/public/v1.0/movies.json?q=Blazing%20Saddles&apiKey=...)（在URL中提供API密钥）来完成的。结果是如下所示的一个JSON对象。
- en: ^(17) That’s not a vampire movie, obviously, but the urge to save Mongo in MongoDB
    is irresistible. “Mongo only pawn in game of life” is a brilliant line and arguably
    the peak of the Alex Karras oeuvre.
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (17) 显然，这并不是一部吸血鬼电影，但拯救MongoDB中的Mongo的冲动是无法抗拒的。“Mongo只是生命游戏中的一个小卒”是一句精彩的话，可以说是亚历克斯·卡拉斯作品的巅峰之作。
- en: Listing 8.15\. A portion of the JSON object representing the movie *Blazing
    Saddles*
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.15。代表电影*Blazing Saddles*的JSON对象的一部分
- en: '[PRE61]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In addition to the data shown, the JSON object also has links to the complete
    cast list, reviews, and more. Another reason to use a database like MongoDB for
    this data is that not every field appears in each movie. For example, some movies
    contain a critic’s score and some do not. This fits with the whole idea of a schema-less
    database based on JSON.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示的数据外，JSON对象还有指向完整的演员列表、评论等链接。使用像MongoDB这样的数据库来存储这些数据的另一个原因是并非每个字段都出现在每部电影中。例如，一些电影包含评论家的评分，而另一些则没有。这与基于JSON的无模式数据库的整体理念相符。
- en: First, to populate the MongoDB I’ll use an instance of the `com.gmongo.GMongo`
    class. This class wraps the Java API directly. In fact, if you look at the class
    in `GMongo.groovy`, you’ll see that it consists of
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了填充MongoDB，我将使用`com.gmongo.GMongo`类的一个实例。这个类直接封装了Java API。实际上，如果你查看`GMongo.groovy`中的类，你会看到它由
- en: '[PRE62]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There follow various constructors and simple patch methods. The `@Delegate`
    annotation from Groovy is an Abstract Syntax Tree (AST) transformation^([[18](#ch08fn18)])
    that exposes the methods in the `com.mongodb.Mongo` class, which comes from the
    Java API, through GMongo. The AST transformation means you don’t need to write
    all the delegate methods by hand.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着是各种构造函数和简单的修补方法。Groovy的`@Delegate`注解是一个抽象语法树（AST）转换^([[18](#ch08fn18)]），它通过GMongo暴露了来自Java
    API的`com.mongodb.Mongo`类中的方法。AST转换意味着你不需要手动编写所有代理方法。
- en: ^(18) Discussed in [chapter 4](kindle_split_014.html#ch04) on integration and
    in [appendix B](kindle_split_024.html#app02), “Groovy by feature,” and used in
    many other places in this book.
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（18）在[第4章](kindle_split_014.html#ch04)中讨论了积分，在[附录B](kindle_split_024.html#app02)中，“Groovy
    by feature”，以及本书的许多其他地方使用了。
- en: Initializing a database is as simple as
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化数据库就像
- en: '[PRE63]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: MongoDB uses `movies` as the name of the database, and collections inside it,
    like `vampireMovies`, are properties of the database. The `drop` method clears
    the collection.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB使用`movies`作为数据库名称，其中包含的集合，如`vampireMovies`，是数据库的属性。`drop`方法清除集合。
- en: 'Searching Rotten Tomatoes consists of building a GET request with the proper
    parameters. In this case, the following code searches for vampire movies:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索Rotten Tomatoes包括构建带有正确参数的GET请求。在这种情况下，以下代码搜索吸血鬼电影：
- en: '[PRE64]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The API key is stored in an external file. Building the query string starts
    with a map of parameters, which is transformed into a map of strings of the form
    “key=value” and then joined with an ampersand. The full URL is then the base URL
    with an appended query string. Getting the movies and saving them into the database
    is almost trivial:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥存储在外部文件中。构建查询字符串从参数映射开始，该映射被转换为形式为“key=value”的字符串映射，然后与和号连接。完整的URL是基本URL加上附加的查询字符串。获取电影并将它们保存到数据库中几乎是微不足道的：
- en: '[PRE65]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `JsonSlurper` receives text data in JSON form from the URL and converts
    it to JSON objects. Saving the results into the database is as simple as appending
    the whole collection.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonSlurper`从URL接收JSON格式的文本数据并将其转换为JSON对象。将结果保存到数据库就像附加整个集合一样简单。'
- en: 'The API has a limit of 30 results per page. The search results include a property
    called `next` that points to the next available page, assuming there is one. The
    script therefore needs to loop that many times to retrieve the available data:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: API每页有30个结果的限制。搜索结果包括一个名为`next`的属性，它指向下一个可用的页面，假设有。因此，脚本需要循环这么多次数来检索可用数据：
- en: '[PRE66]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: That’s all there is to it. Using a relational database would require mapping
    the movie structure to relational tables, which would be a bit of a challenge.
    Because MongoDB uses BSON as its native format, even a collection of JSON objects
    can be added with no work at all.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。使用关系型数据库需要将电影结构映射到关系表，这将是一个挑战。因为MongoDB使用BSON作为其原生格式，即使是JSON对象的集合也可以不加任何工作地添加。
- en: There’s an Eclipse plugin, called MonjaDB, which connects to MongoDB databases.
    [Figure 8.5](#ch08fig05) shows a portion of the vampireMovies database.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为MonjaDB的Eclipse插件，它连接到MongoDB数据库。[图8.5](#ch08fig05)显示了vampireMovies数据库的一部分。
- en: Figure 8.5\. A portion of the vampire movies database, using the MonjaDB plugin
    for Eclipse
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5. 使用Eclipse的MonjaDB插件的部分吸血鬼电影数据库
- en: '![](08fig05_alt.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![08fig05_alt.jpg](08fig05_alt.jpg)'
- en: 8.5.2\. Querying and mapping MongoDB data
  id: totrans-558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.2. 查询和映射MongoDB数据
- en: Now that the data is in the database I need to be able to search it and examine
    the results. This can be done in a trivial fashion, using the `find` method, or
    the data can be mapped to Groovy objects for later processing.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据已经存储在数据库中，我需要能够搜索它并检查结果。这可以通过 `find` 方法以简单的方式完成，或者可以将数据映射到 Groovy 对象以供后续处理。
- en: 'The `find` method on the collection returns all JSON objects satisfying a particular
    condition. If all I want is to see how many elements are in the collection, the
    following suffices:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 集合上的 `find` 方法返回满足特定条件的所有 JSON 对象。如果我只是想查看集合中有多少元素，以下就足够了：
- en: '[PRE67]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With no arguments, the `find` method returns the entire collection. The `count`
    method then returns the total number.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有参数，`find` 方法将返回整个集合。然后 `count` 方法返回总数。
- en: Mapping JSON to Groovy brings home the difference between a strongly typed language,
    like Groovy, and a weakly typed language, like JSON. The JSON data shown is a
    mix of strings, dates, integers, and enumerated values, but the JSON object has
    no embedded type information. Mapping this to a set of Groovy objects takes some
    work.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 映射到 Groovy 展示了强类型语言（如 Groovy）和弱类型语言（如 JSON）之间的差异。显示的 JSON 数据是字符串、日期、整数和枚举值的混合，但
    JSON 对象没有嵌入的类型信息。将此映射到一组 Groovy 对象需要一些工作。
- en: For example, the following listing shows a `Movie` class that holds the data
    in the JSON object.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下列表展示了包含 JSON 对象数据的 `Movie` 类。
- en: Listing 8.16\. `Movie.groovy`, which wraps the JSON data
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16\. 包装 JSON 数据的 `Movie.groovy`
- en: '[PRE68]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `Movie` class has attributes for each contained element, with the data
    types specified. It contains maps for the release dates, posters, ratings, and
    additional links, and a list for the abridged cast. A `CastMember` is just a POGO:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`Movie` 类为每个包含的元素提供了属性，并指定了数据类型。它包含发布日期、海报、评级和附加链接的映射，以及简略演员列表。`CastMember`
    只是一个 POGO：'
- en: '[PRE69]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'A `Rating` holds a string and an integer:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rating` 包含一个字符串和一个整数：'
- en: '[PRE70]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Just to keep things interesting, the MPAA rating is a Java `enum`, though it
    could just as easily have been implemented in Groovy:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持内容的趣味性，MPAA 评级是一个 Java `enum`，尽管它同样可以用 Groovy 实现：
- en: '[PRE71]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Converting a JSON movie to a `Movie` instance is done through a static method
    in the `Movie` class. A portion of the `fromJSON` method is shown in the next
    listing.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 电影转换为 `Movie` 实例是通过 `Movie` 类中的静态方法完成的。`fromJSON` 方法的部分内容将在下一个列表中展示。
- en: Listing 8.17\. A portion of the method that converts JSON movies to `Movie`
    instances
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.17\. 将 JSON 电影转换为 `Movie` 实例的方法的一部分
- en: '[PRE72]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The complete listing can be found in the book source code but isn’t fundamentally
    different from what’s being shown here.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的列表可以在书籍源代码中找到，但与这里展示的基本上没有区别。
- en: A test to prove the conversion is working is shown in the following listing.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了验证转换是否正常工作的测试。
- en: Listing 8.18\. A JUnit test to verify the JSON conversion
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.18\. 验证 JSON 转换的 JUnit 测试
- en: '![](225fig01_alt.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![225fig01_alt.jpg](225fig01_alt.jpg)'
- en: '|  |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (NoSQL^([[19](#ch08fn19)]))**'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lessons learned (NoSQL^([[19](#ch08fn19)]))**'
- en: '**1**.  NoSQL databases like MongoDB, Neo4J, and Redis are becoming quite common
    for specific use cases.'
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  像 MongoDB、Neo4J 和 Redis 这样的 NoSQL 数据库正在成为特定用例的常见选择。'
- en: '**2**.  Most NoSQL databases make a Java-based API available, which can be
    called directly from Groovy.'
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  大多数 NoSQL 数据库都提供基于 Java 的 API，可以直接从 Groovy 中调用。'
- en: '**3**.  Often a Groovy library will be available that wraps the Java API and
    simplifies it. Here, GMongo is used as an example.'
  id: totrans-584
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  通常，Groovy 库会提供包装 Java API 并简化它的功能。这里，以 GMongo 为例。'
- en: '|  |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '^(19) NoSQL version of Worst SQL Joke Ever Told: DBA walks into a NoSQL bar;
    can’t find a table, so he leaves.'
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(19) 最糟糕的 SQL 笑话的 NoSQL 版本：DBA 走进 NoSQL 酒吧；找不到表，所以他就离开了。
- en: 'Once the mapping works, finding all vampire movies that have a critic’s consensus
    is as simple as the following script:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦映射成功，查找所有有评论家共识的吸血鬼电影就像以下脚本一样简单：
- en: '[PRE73]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It’s hard to be much simpler than that. Working with MongoDB^([[20](#ch08fn20)])
    is just as easy as using a traditional relational database.^([[21](#ch08fn21)])
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经非常简单了。使用 MongoDB^([[20](#ch08fn20)]) 与使用传统的关系型数据库一样简单.^([[21](#ch08fn21)])
- en: '^(20) A detailed treatment of MongoDB is contained in the book *MongoDB in
    Action* (Manning, 2011) by Kyle Banker: [www.manning.com/banker/](http://www.manning.com/banker/).'
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(20) 有关 MongoDB 的详细说明，请参阅 Kyle Banker 所著的书籍 *MongoDB in Action* (Manning, 2011)：[www.manning.com/banker/](http://www.manning.com/banker/)。
- en: ^(21) For some reason, none of the *Twilight* movies were returned from the
    “vampire” query. I thought about fixing that, and ultimately decided it wasn’t
    a bug, but a feature.
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（21）由于某种原因，从“吸血鬼”查询中没有返回任何《暮光之城》电影。我考虑过修复这个问题，但最终决定这不是一个错误，而是一个特性。
- en: 8.6\. Summary
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6. 摘要
- en: Virtually every significant application requires persistent data. The vast majority
    of those are based on relational databases. In the Java world, relational persistence
    uses either JDBC or an object-relational mapping tool like Hibernate or JPA. This
    chapter reviewed both approaches and examined how Groovy can simplify them.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个重要的应用程序都需要持久化数据。其中绝大多数都是基于关系型数据库。在Java领域，关系型持久化使用JDBC或Hibernate或JPA等对象关系映射工具。本章回顾了这两种方法，并探讨了Groovy如何简化它们。
- en: The Groovy `Sql` class removes most of the clutter that accompanies raw JDBC.
    Any code that uses JDBC directly can be significantly simplified using the `Sql`
    class.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy的`Sql`类移除了伴随原始JDBC的大部分杂乱。任何直接使用JDBC的代码都可以使用`Sql`类显著简化。
- en: Many modern applications use JPA for persistence, especially with Hibernate
    as the underlying API and the Spring framework to handle singletons and transactions.
    Just configuring such an application is a nontrivial task. On the other hand,
    the Grails framework handles all of it elegantly and with a minimum of effort.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代应用程序使用JPA进行持久化，特别是Hibernate作为底层API，Spring框架处理单例和事务。仅配置这样的应用程序就是一个非平凡的任务。另一方面，Grails框架优雅地处理所有这些，并且几乎不需要任何努力。
- en: Finally, many so-called NoSQL databases have a Java API. Some, like MongoDB,
    include a Groovy wrapper that makes working with the underlying databases simple.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，许多所谓的NoSQL数据库都有Java API。其中一些，如MongoDB，包括一个Groovy包装器，使得与底层数据库的工作变得简单。
- en: Chapter 9\. RESTful web services
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. RESTful Web服务
- en: '*This chapter covers*'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The REST architectural style
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST架构风格
- en: Implementing REST in Java using JAX-RS
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JAX-RS在Java中实现REST
- en: Using a Groovy client to access RESTful services
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Groovy客户端访问RESTful服务
- en: Hypermedia
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超媒体
- en: RESTful web services dominate API design these days, because they provide a
    convenient mechanism for connecting client and server applications in a highly
    decoupled manner. Mobile applications especially use RESTful services, but a good
    RESTful design mimics the characteristics that made the web so successful in the
    first place.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful Web服务在当今的API设计中占主导地位，因为它们提供了一种方便的机制，以高度解耦的方式连接客户端和服务器应用程序。特别是移动应用程序使用RESTful服务，但一个好的RESTful设计模仿了最初使网络如此成功的特点。
- en: After discussing REST in general, I’ll talk about the server side, then about
    the client side, and finally the issue of hypermedia. [Figures 9.1](#ch09fig01),
    [9.2](#ch09fig02), and [9.3](#ch09fig03) show the different technologies in this
    chapter.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了REST的一般情况之后，我将讨论服务器端，然后是客户端，最后是超媒体问题。[图9.1](#ch09fig01)，[9.2](#ch09fig02)，和[9.3](#ch09fig03)展示了本章中的不同技术。
- en: Figure 9.1\. Server-side JAX-RS technologies in this chapter. JAX-RS 2.0 is
    annotation-based but includes builders for the responses. URIs are mapped to methods
    in resources, which are assigned using annotations. Resources are returned as
    representations using content negotiation from client headers.
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1. 本章中的服务器端JAX-RS技术。JAX-RS 2.0基于注解，但包括响应的构建器。URI映射到资源中的方法，这些方法通过注解分配。资源作为使用客户端头的内容协商的表示返回。
- en: '![](09fig01_alt.jpg)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig01_alt.jpg)'
- en: Figure 9.2\. Client-side REST technologies in this chapter. Unlike JAX-RS 1.x,
    version 2.0 includes client classes. Apache also has a common client, which is
    wrapped by Groovy in the HttpBuilder project. Finally, you can use standard Groovy
    classes to parse requests and build responses manually.
  id: totrans-607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2. 本章中的客户端REST技术。与JAX-RS 1.x不同，2.0版本包括客户端类。Apache也有一个通用的客户端，它在Groovy的HttpBuilder项目中进行了封装。最后，您可以使用标准的Groovy类手动解析请求和构建响应。
- en: '![](09fig02.jpg)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig02.jpg)'
- en: Figure 9.3\. Hypermedia approaches in this chapter. Hypermedia in JAX-RS is
    done through transitional links in the HTTP headers, structural links in the message
    body, or customized responses using builders and slurpers.
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3. 本章中的超媒体方法。在JAX-RS中，超媒体通过HTTP头中的过渡链接、消息体中的结构链接或使用构建器和解析器定制的响应来实现。
- en: '![](09fig03.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig03.jpg)'
- en: 9.1\. The REST architecture
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. REST架构
- en: The term Representational State Transfer (REST) comes from the 2000 PhD thesis^([[1](#ch09fn01)])
    by Roy Fielding, a person with one of the all-time great resumes.^([[2](#ch09fn02)])
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 代表性状态转移（Representational State Transfer，REST）这个术语来自 Roy Fielding 2000 年的博士论文^([[1](#ch09fn01)）]，他是一位拥有史上最伟大简历的人之一.^([[2](#ch09fn02)）
- en: ¹ “Architectural Styles and the Design of Network-based Software Architectures,”
    available online at [www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).
  id: totrans-613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ “Architectural Styles and the Design of Network-based Software Architectures，”可在
    [www.ics.uci.edu/~fielding/pubs/dissertation/top.htm](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)
    上在线获取。
- en: ² Fielding is a cofounder of the Apache Software Foundation; was on the IETF
    working groups for the URI, HTTP, and HTML specifications; and helped set up some
    of the original web servers. I place him easily in the Top Ten of CS resumes,
    along with people like James Duncan Davidson (creator of the first versions of
    both Tomcat *and* Ant; he basically owned the 90s), Sir Timothy Berners-Lee (create
    the web → knighthood FTW), and Haskell Curry (whose first name is the definitive
    functional programming language, and whose last name is a fundamental coding technique;
    if your *name* is your resume, you win).
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 菲尔德宁是 Apache 软件基金会的共同创始人；曾是 URI、HTTP 和 HTML 规范的 IETF 工作组成员；并帮助建立了一些原始的 Web
    服务器。我将他轻松地列入了 CS 简历的前十名，与像 James Duncan Davidson（Tomcat 和 Ant 的第一版创造者；他基本上拥有 90
    年代）、Sir Timothy Berners-Lee（创建了网络 → 勋章 FTW）和 Haskell Curry（其名字是终极函数式编程语言，其姓氏是一种基本的编码技术；如果你的
    *名字* 就是你的简历，你就赢了）等人并列。
- en: 'In his thesis, Fielding defines the REST architecture in terms of addressable
    resources and their interactions. When restricted to HTTP requests made over the
    web (not a requirement of the architecture, but its most common use today), RESTful
    web services are based on the following principles:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的论文中，菲尔德宁将 REST 架构定义为可寻址资源和它们之间的交互。当限制在通过互联网（不是架构的要求，但今天最常见的使用方式）发出的 HTTP
    请求时，RESTful 网络服务基于以下原则：
- en: '***Addressable resource—*** Items are accessible to clients through URIs.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可寻址资源—*** 项目可以通过 URI 被客户端访问。'
- en: '***Uniform interface—*** Resources are accessed and modified using the standard
    HTTP verbs GET, POST, PUT, and DELETE.^([[3](#ch09fn03)])'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***统一接口—*** 使用标准的 HTTP 动词 GET、POST、PUT 和 DELETE 访问和修改资源.^([[3](#ch09fn03)])'
- en: ³ Some services support HEAD requests as GET requests that return headers with
    empty responses and OPTIONS requests as an alternate way to specify what types
    of requests are valid at a particular address. PATCH requests are proposed as
    a way to do a partial update.
  id: totrans-618
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 一些服务支持将 HEAD 请求作为返回空响应的 GET 请求，将 OPTIONS 请求作为在特定地址指定有效请求类型的一种替代方式。PATCH 请求被提议作为一种进行部分更新的方法。
- en: '***Content negotiation—*** The client can request different representations
    of resources, usually by specifying the desired MIME type in the `Accept` header
    of a request.'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***内容协商—*** 客户端可以请求不同格式的资源表示，通常通过在请求的 `Accept` 头部中指定所需的 MIME 类型。'
- en: '***Stateless services—*** Interactions with resources are done through self-contained
    requests.'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***无状态服务—*** 与资源的交互是通过自包含的请求完成的。'
- en: Web services based on these ideas are intended to be highly scalable and extensible,
    because they follow the mechanisms that make the web itself highly scalable and
    extensible.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些想法的 Web 服务旨在具有高度的可扩展性和可扩展性，因为它们遵循使 Web 本身具有高度可扩展性和可扩展性的机制。
- en: 'Part of the scalability of a RESTful web service comes from the terms *safe*
    and *idempotent*:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful 网络服务可扩展性的部分来源于 *安全* 和 *幂等* 这两个术语：
- en: '***Safe—*** Does not modify the state of the server'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***安全—*** 不修改服务器的状态'
- en: '***Idempotent—*** Can be repeated without causing any additional effects'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***幂等性—*** 可以重复执行而不产生任何额外效果'
- en: GET requests are both safe and idempotent. PUT and DELETE requests are idempotent
    but not safe. They can be repeated (for example, if there’s a network error) without
    making any additional changes.^([[4](#ch09fn04)]) POST requests are neither safe
    nor idempotent.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: GET 请求既安全又幂等。PUT 和 DELETE 请求是幂等的但不安全。它们可以重复执行（例如，如果出现网络错误）而不产生任何额外变化.^([[4](#ch09fn04)）POST
    请求既不安全也不幂等。
- en: ⁴ Sometimes it’s hard to picture DELETE requests as idempotent, but if you delete
    the same row multiple times, it’s still gone.
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 有时很难想象 DELETE 请求是幂等的，但如果你多次删除同一行，它仍然会消失。
- en: Another key concept is Hypermedia as the Engine of Application State, which
    has the truly unfortunate, unpronounceable acronym HATEOAS. Most REST advocates^([[5](#ch09fn05)])
    I know simply say “[hypermedia](#ch09lev1sec5)” instead.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键概念是作为应用程序状态引擎的超媒体，它有一个真正不幸、难以发音的首字母缩略词HATEOAS。我所知道的许多REST倡导者^([[5](#ch09fn05)])只是简单地说是“[超媒体](#ch09lev1sec5)”。
- en: ⁵ Often known, believe it or not, as RESTafarians.
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 通常被称为RESTafarians。
- en: The principles defined in this section are architectural and are thus independent
    of implementation language. In the next section I’ll address^([[6](#ch09fn06)])
    the Java-specific specification intended to implement RESTful services, JAX-RS.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中定义的原则是架构性的，因此与实现语言无关。在下一节中，我将讨论针对实现RESTful服务的Java特定规范，即JAX-RS。
- en: ⁶ Sorry.
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ 对不起。
- en: '9.2\. The Java approach: JAX-RS'
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. Java方法：JAX-RS
- en: The Java EE specification includes the Java API for RESTful Services. Version
    1.18 is from JSR 311\. The new version, 2.0, is an implementation of JSR 339 and
    was released in May of 2013.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: Java EE规范包括RESTful服务的Java API。版本1.18来自JSR 311。新版本2.0是JSR 339的实现，并于2013年5月发布。
- en: In this section I’ll implement a set of CRUD methods on a simple POJO.^([[7](#ch09fn07)])
    The JAX-RS part doesn’t depend on this, so I’ll discuss that separately. I’ll
    start with the basic infrastructure and then move to REST.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将在一个简单的POJO上实现一组CRUD方法.^([[7](#ch09fn07)]) JAX-RS部分不依赖于这一点，所以我将单独讨论。我将从基本基础设施开始，然后转向REST。
- en: ⁷ Yes, that’s a URL-driven database, and yes, that violates hypermedia principles.
    I promise to get to that later.
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 是的，这是一个URL驱动的数据库，是的，这违反了超媒体原则。我保证稍后会解释这一点。
- en: '|  |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**What do Java developers actually use for REST?**'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java开发者实际上使用什么来实现REST？**'
- en: In this book I normally start with what Java developers use for a particular
    problem, then show how Groovy can help the Java implementations, and finally discuss
    what Groovy offers as an alternative. When I describe what Java developers typically
    use, I default to what the Java SE or EE specification provides.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我通常从Java开发者针对特定问题使用的解决方案开始，然后展示Groovy如何帮助Java实现，最后讨论Groovy提供的替代方案。当我描述Java开发者通常使用的内容时，我默认使用Java
    SE或EE规范提供的内容。
- en: That’s not the case with REST. In addition to the spec, JAX-RS, Java developers
    use several third-party alternatives. Among the most popular are Restlet ([http://restlet.org/](http://restlet.org/)),
    RestEasy ([www.jboss.org/resteasy](http://www.jboss.org/resteasy)), and Restfulie
    ([http://restfulie.caelum.com.br/](http://restfulie.caelum.com.br/)), and there
    are other alternatives as well.^([[8](#ch09fn08)]) It’s hard at this point to
    know which, if any, is going to be the REST framework of choice for Java developers
    in a few years.^([[9](#ch09fn09)])
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 对于REST来说，情况并非如此。除了规范，Java开发者还使用几个第三方替代方案。其中最受欢迎的是Restlet ([http://restlet.org/](http://restlet.org/))、RestEasy
    ([www.jboss.org/resteasy](http://www.jboss.org/resteasy)) 和 Restfulie ([http://restfulie.caelum.com.br/](http://restfulie.caelum.com.br/))，还有其他替代方案。在这个时候很难知道，如果有的话，哪个将成为几年后Java开发者选择的REST框架.^([[8](#ch09fn08)])^([[9](#ch09fn09)))
- en: ⁸ Spring REST doesn’t follow the JAX-RS specification. Apache CXF was designed
    for JAX-WS, but the latest version has JAX-RS support. Apache Wink is another
    JAX-RS 1.x implementation.
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ Spring REST不遵循JAX-RS规范。Apache CXF是为JAX-WS设计的，但最新版本支持JAX-RS。Apache Wink是另一个JAX-RS
    1.x实现。
- en: ⁹ If I had to bet, I’d go with Restlet. Most of the good REST people I know
    really like it.
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 如果我必须下注，我会选择Restlet。我所知道的许多优秀的REST开发者都非常喜欢它。
- en: Therefore, I’m basing this chapter on the JAX-RS specification, even though
    it’s not necessarily the most popular alternative. When the alternative is not
    blindingly obvious, the spec usually wins.^([[10](#ch09fn10)])
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将本章基于JAX-RS规范，尽管它可能不是最受欢迎的替代方案。当替代方案不是显而易见的时候，规范通常获胜.^([[10](#ch09fn10)])
- en: ^(10) Except when it doesn’t. See, for example, JDO, which is still part of
    Java EE.
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10) 除了它不这么做的时候。例如，JDO仍然是Java EE的一部分。
- en: '|  |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The application in this section exposes a POGO called `Person` as a JAX-RS 2.0
    resource. The application supports GET, POST, PUT, and DELETE operations and (eventually)
    supports hypermedia links.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的应用程序将一个名为`Person`的POGO作为JAX-RS 2.0资源公开。该应用程序支持GET、POST、PUT和DELETE操作，并最终支持超媒体链接。
- en: The infrastructure for the project includes the POJO, Spock tests, and a DAO
    implementation based on an H2 database. While the implementations are interesting,
    they are ancillary to the real goal of discussing RESTful services and how Groovy
    can simplify their development. Therefore they will not be presented in detail
    in this chapter. As usual, the complete classes, including Gradle build files
    and tests, can be found in the book source code repository.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的基础设施包括 POJO、Spock 测试和基于 H2 数据库的 DAO 实现。虽然这些实现很有趣，但它们只是讨论 RESTful 服务以及 Groovy
    如何简化其开发的真正目标的辅助内容。因此，它们将不会在本章中详细介绍。通常，包括 Gradle 构建文件和测试在内的完整类可以在本书的源代码仓库中找到。
- en: As a brief summary, the `Person` class is shown in the next listing.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 简要总结一下，`Person` 类将在下一列表中展示。
- en: Listing 9.1\. A `Person` POGO, used in the RESTful web service
  id: totrans-647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 用于 RESTful 网络服务的 `Person` POGO
- en: '[PRE74]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The DAO interface for the `Person` objects includes finder methods, as well
    as methods to create, update, and delete a `Person`. It’s shown in the following
    listing.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 对象的 DAO 接口包括查找方法，以及创建、更新和删除 `Person` 的方法。具体内容如下所示。'
- en: Listing 9.2\. The DAO interface with the CRUD methods for `Person`
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. 包含 `Person` CRUD 方法的 DAO 接口
- en: '[PRE75]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The implementation of the DAO is done in Groovy using the `groovy.sql.Sql`
    class, just as in [chapter 8](kindle_split_020.html#ch08) on databases. The only
    part that differs from that chapter is that the `id` attribute is generated by
    the database. Here’s how to use the `Sql` class to retrieve the generated ID:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: DAO 的实现使用 Groovy 的 `groovy.sql.Sql` 类完成，就像在第 8 章（关于数据库）中一样。与该章节不同的是，`id` 属性由数据库生成。以下是使用
    `Sql` 类检索生成的 ID 的方法：
- en: '[PRE76]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `executeInsert` method returns the collection of generated values, and in
    this case the new ID is found as the first element of the first row.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '`executeInsert` 方法返回生成的值的集合，在这种情况下，新的 ID 被找到为第一行中的第一个元素。'
- en: The Spock test for the DAO is similar to those shown in [chapter 6](kindle_split_017.html#ch06)
    on testing or [chapter 8](kindle_split_020.html#ch08) on databases. The only new
    part is that the `when`/`then` block in Spock is repeated to insert and then delete
    a new `Person`. When Spock sees a repeat of the `when`/`then` pair, it executes
    them sequentially. [Listing 9.3](#ch09ex03) shows this test, which inserts a row
    representing Peter Quincy Taggart,^([[11](#ch09fn11)]) verifies that he’s stored
    properly, and then deletes the row. Recall that the seriously cool `old` method
    in Spock evaluates its argument before executing the `when` block, so it can be
    compared to the rest of the expression evaluated after the `when` block is done.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: DAO 的 Spock 测试与第 6 章（关于测试）或第 8 章（关于数据库）中展示的类似。唯一的新部分是 Spock 中的 `when`/`then`
    块被重复用于插入和删除一个新 `Person`。当 Spock 看到重复的 `when`/`then` 对时，它会按顺序执行它们。[列表 9.3](#ch09ex03)
    展示了这个测试，它插入了一个代表 Peter Quincy Taggart 的行，^([[11](#ch09fn11)]) 验证他是否被正确存储，然后删除该行。回想一下，Spock
    中非常酷的 `old` 方法在执行 `when` 块之前评估其参数，因此它可以与 `when` 块完成后评估的表达式的其余部分进行比较。
- en: ^(11) Remember him? Commander of the NSEA Protector? “Never give up, never surrender?”
    That’s *Galaxy Quest*, a *Star Trek* parody, but arguably one of the better *Star
    Trek* movies. Did you know that the designation of the Protector was NTE-3120,
    and that NTE stood for “Not The Enterprise”? By Grabthar’s hammer, that’s the
    kind of research you are obligated to do when you write a Groovy/Java integration
    book.
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (11) 记得他吗？NSEA 保护队的指挥官？“永不放弃，永不屈服？”这是《银河护卫队》，一部《星际迷航》的恶搞电影，但可以说是其中较好的电影之一。你知道保护者的编号是
    NTE-3120，而 NTE 代表“不是企业”吗？按照 Grabthar 的锤子，当你写一本 Groovy/Java 集成书籍时，这就是你必须要做的类型的研究。
- en: Listing 9.3\. The Spock test method to insert and delete a new `Person`
  id: totrans-657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 插入和删除新 `Person` 的 Spock 测试方法
- en: '[PRE77]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now that the preliminaries are out of the way it’s time to look at the features
    provided by the JAX-RS API.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初步工作已经完成，是时候看看 JAX-RS API 提供的功能了。
- en: 9.2.1\. JAX-RS resource and tests
  id: totrans-660
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. JAX-RS 资源和测试
- en: Moving now to the RESTful part of the application, there are several features
    of the JAX-RS API involved in the implementation. Here I’ll use a `PersonResource`
    class to implement the CRUD methods.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转向应用程序的 RESTful 部分，JAX-RS API 的几个特性都涉及到了实现。在这里，我将使用 `PersonResource` 类来实现
    CRUD 方法。
- en: '|  |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Collection and item Resources
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 集合和项目资源
- en: 'Normally two resources are provided: one for a collection of person instances
    and one for an individual person. In this case both are combined to keep the sample
    short.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 通常提供两个资源：一个用于人员实例的集合，一个用于单个人员。在这种情况下，两者都合并以保持示例简短。
- en: '|  |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'First, each method that’s tied to a particular type of HTTP request uses one
    of these annotations: `@GET`, `@POST`, `@PUT`, or `@DELETE`. For example, the
    `findAll` method can be implemented as follows:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个与特定类型的 HTTP 请求绑定的方法使用这些注解之一：`@GET`、`@POST`、`@PUT` 或 `@DELETE`。例如，`findAll`
    方法可以如下实现：
- en: '[PRE78]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A GET request returns the HTTP status code 200 for a successful request. The
    `@Produces` annotation identifies to the client the MIME type of the response.
    In this case I want to return JSON or XML:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 成功请求返回 HTTP 状态码 200。`@Produces` 注解向客户端标识响应的 MIME 类型。在这种情况下，我希望返回 JSON 或 XML：
- en: '[PRE79]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The annotation accepts an array of `MediaType` instances, which are used for
    content negotiation based on the `Accept` header in the incoming request.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 该注解接受 `MediaType` 实例数组，这些实例用于根据传入请求的 `Accept` 头进行内容协商。
- en: 'If I want to specify the response header, JAX-RS provides a factory class called
    `Response` using the builder design pattern. Here’s the implementation of the
    `findById` method that uses it:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想指定响应头，JAX-RS 提供了一个名为 `Response` 的工厂类，使用构建者设计模式。以下是使用它的 `findById` 方法的实现：
- en: '[PRE80]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `ok` method on the `Response` class sets the response status code to 200\.
    It takes an object as an argument, which is added to the response. The `@PathParam`
    annotation also converts the input ID from a string to a `long` automatically.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 类上的 `ok` 方法将响应状态码设置为 200。它接受一个对象作为参数，并将其添加到响应中。`@PathParam` 注解还自动将输入
    ID 从字符串转换为 `long` 类型。'
- en: Inserting a new instance is a bit more complicated, because the newly inserted
    instance needs its own URI. Because in this case the generated URI will contain
    an ID generated by the database, the resource method is tied to HTTP POST requests,
    which are neither safe nor idempotent.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 插入新实例稍微复杂一些，因为新插入的实例需要自己的 URI。因为在这种情况下，生成的 URI 将包含数据库生成的 ID，所以资源方法绑定到 HTTP POST
    请求，这些请求既不安全也不幂等。
- en: '|  |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Implementation detail
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现细节
- en: The `create` method returns a URL that includes the primary key from the database
    table. That detail is not something you want to expose to the client. Some unique
    identifier is required; here the ID is used for simplicity.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 方法返回一个包含数据库表主键的 URL。这个细节不是你想暴露给客户端的。需要一个唯一的标识符；在这里，为了简单起见，使用 ID。'
- en: '|  |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The new URI is added to the response as part of its `Location` header. The
    new URI is generated using the `UriBuilder` class from JAX-RS, based on the incoming
    URI:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 URI 作为其 `Location` 头的一部分添加到响应中。新的 URI 是使用 JAX-RS 的 `UriBuilder` 类根据传入的 URI
    生成的：
- en: '[PRE81]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `uriInfo` reference in that expression refers to a `UriInfo` object injected
    from the application context. This is added as an attribute to the implementation:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中的 `uriInfo` 引用指向从应用程序上下文注入的 `UriInfo` 对象。这被添加为属性到实现中：
- en: '[PRE82]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In general, the response from any insert method in a REST application is either
    “no content” or the entity itself. Here in the `create` method I decided to use
    the entity, because it includes the generated ID in case the client wants it.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，REST 应用程序中任何插入方法的响应要么是“无内容”，要么是实体本身。在这里的 `create` 方法中，我决定使用实体，因为它包含了生成的 ID，以防客户端需要它。
- en: 'Putting it all together, the `create` method is as follows:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，`create` 方法如下：
- en: '[PRE83]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `@POST` annotation sets the HTTP status code in the response to 201.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`@POST` 注解将响应的 HTTP 状态码设置为 201。'
- en: 'The URL patterns for the resource are summarized as follows:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 资源 URL 模式总结如下：
- en: The base resource pattern is `/people`. A GET request at that URL returns all
    the `Person` instances. The plural form of `Person` is used for this reason.
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础资源模式是 `/people`。在该 URL 发起的 GET 请求返回所有 `Person` 实例。使用 `Person` 的复数形式是因为这个原因。
- en: A POST request at the same URL (`/person`) creates a new `Person`, assigns it
    a URL of its own, and saves it in the database.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相同的 URL (`/person`) 上发起 POST 请求创建一个新的 `Person`，为其分配一个自己的 URL，并将其保存到数据库中。
- en: A sub-resource at `/people/lastname/{like}` uses a URL template (the `like`
    parameter) to do an SQL-like query and find all `Person` instances who have a
    last name satisfying the clause.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/people/lastname/{like}` 的子资源使用 URL 模板（`like` 参数）执行类似 SQL 的查询，并找到所有姓氏满足该条件的
    `Person` 实例。'
- en: A sub-resource using the URL template `{id}` supports a GET request that returns
    the `Person` instance with that ID.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 URL 模板 `{id}` 的子资源支持返回具有该 ID 的 `Person` 实例的 GET 请求。
- en: PUT and DELETE requests at the `{id}` URL update and delete `Person` instances,
    respectively.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `{id}` URL 上执行 PUT 和 DELETE 请求分别更新和删除 `Person` 实例。
- en: The following listing shows the complete `PersonResource` class for managing
    `Person` instances.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了用于管理 `Person` 实例的完整 `PersonResource` 类。
- en: Listing 9.4\. Java resource class for `Person` POJO
  id: totrans-694
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. 用于 `Person` POJO 的 Java 资源类
- en: '![](ch09ex04-0.jpg)'
  id: totrans-695
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex04-0.jpg)'
- en: '![](ch09ex04-1.jpg)'
  id: totrans-696
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex04-1.jpg)'
- en: To verify that everything is working properly, I’ll again present a test class
    using Spock. Testing a RESTful API requires a server where the application can
    be deployed. The Jersey reference implementation includes a server called Grizzly
    for that.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否正常工作，我再次使用 Spock 提供一个测试类。测试 RESTful API 需要一个可以部署应用程序的服务器。Jersey 引用实现包括一个名为
    Grizzly 的服务器用于此目的。
- en: 'The Spock test methods `setupSpec` and `shutdownSpec` are executed once each,
    before and after the individual tests, respectively. They therefore become the
    appropriate places to start and stop the server, as shown:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: Spock 测试方法 `setupSpec` 和 `shutdownSpec` 分别在单个测试之前和之后各执行一次。因此，它们成为启动和停止服务器的合适位置，如下所示：
- en: '[PRE84]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `createHttpServer` method starts a server on the specified URI and deploys
    a RESTful application to it. The `MyApplication` class is very simple:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`createHttpServer` 方法在指定的 URI 上启动服务器并将 RESTful 应用程序部署到它上面。`MyApplication` 类非常简单：'
- en: '[PRE85]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The class `MyApplication` extends a JAX-RS class called `ResourceConfig`, which
    has a constructor that takes the desired resources and features as arguments.
    The `JacksonFeature` used here provides the mechanism to convert from `PersonResource`
    instances to JSON and back.^([[12](#ch09fn12)])
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `MyApplication` 继承了一个名为 `ResourceConfig` 的 JAX-RS 类，该类的构造函数接受所需的资源和特性作为参数。这里使用的
    `JacksonFeature` 提供了将 `PersonResource` 实例转换为 JSON 以及反向转换的机制.^([[12](#ch09fn12)])
- en: ^(12) As soon as I mention JSON, I’m talking about representations, not resources.
    Again, I’ll discuss that in [section 9.5](#ch09lev1sec5) on hypermedia.
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(12) 一提到 JSON，我就是在谈论表示，而不是资源。再次强调，我将在第 9.5 节（#ch09lev1sec5）中讨论超媒体。
- en: Note the convenience of the safe-dereference operator, `?.`, used when shutting
    down the server. That will avoid a null pointer exception when the server fails
    to start properly.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在关闭服务器时使用的方便的 safe-dereference 运算符 `?.`，这将在服务器无法正确启动时避免空指针异常。
- en: 'The first actual test verifies that the server is up and running, using the
    `isStarted` method on the `HttpServer` class:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实际测试验证服务器已启动并运行，使用 `HttpServer` 类上的 `isStarted` 方法：
- en: '[PRE86]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Again, the `isStarted` method is invoked using the standard Groovy idiom of
    accessing a property. There’s no reason you couldn’t call the method instead,
    though, if you prefer.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，使用标准 Groovy 语法访问属性来调用 `isStarted` 方法。当然，如果你更喜欢，你也可以直接调用该方法。
- en: The rest^([[13](#ch09fn13)]) of the test methods require a client to generate
    the HTTP request using the proper verb. GET requests are trivial with Groovy,
    because you can take advantage of the `getText` method that the Groovy JDK adds
    to the `java.net.URL` class. So the request to retrieve all the instances could
    be written as
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 其余^([[13](#ch09fn13)]) 的测试方法需要客户端使用适当的动词生成 HTTP 请求。在 Groovy 中，GET 请求很简单，因为你可以利用
    Groovy JDK 添加到 `java.net.URL` 类中的 `getText` 方法。因此，检索所有实例的请求可以写成如下：
- en: ^(13) Again, no pun intended.
  id: totrans-709
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(13) 再次强调，这里没有双关语。
- en: '[PRE87]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: While that would work, the response would then need to be parsed to get the
    proper information. Often that isn’t a problem, but here I’m using an alternative.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样也可以工作，但响应需要被解析以获取适当的信息。通常这不会是问题，但在这里我使用了一个替代方案。
- en: 'The class `RESTClient` is part of the HttpBuilder ([http://groovy.codehaus.org/modules/http-builder/](http://groovy.codehaus.org/modules/http-builder/))
    project. I’ll discuss that further in [section 9.4](#ch09lev1sec4) on Groovy clients,
    but for now let me say it defines Groovy classes that wrap Java classes supplied
    by Apache’s `HttpClient` project. The test therefore contains an attribute of
    type `RESTClient`, as follows:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `RESTClient` 是 HttpBuilder ([http://groovy.codehaus.org/modules/http-builder/](http://groovy.codehaus.org/modules/http-builder/))
    项目的组成部分。我将在第 9.4 节（#ch09lev1sec4）中进一步讨论 Groovy 客户端，但到目前为止，让我说它定义了由 Apache 的 `HttpClient`
    项目提供的 Java 类的 Groovy 类。因此，测试中包含了一个类型为 `RESTClient` 的属性，如下所示：
- en: '[PRE88]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The client points to the proper endpoint, and the second argument specifies
    the content type for the `Accept` header in the request. A GET request using this
    client returns an object that can be interrogated for header properties as well
    as data:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端指向正确的端点，第二个参数指定请求中 `Accept` 头部的内容类型。使用此客户端的 GET 请求返回一个对象，可以查询头部属性以及数据：
- en: '[PRE89]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Other finder methods are tested similarly. To keep the tests independent, the
    insert and delete methods are tested together; first a person is inserted, then
    it’s verified, and then it’s deleted again. The test uses another feature of Spock:
    each block (`when`/`then`/`expect`, and so on) can be given a string to describe
    its purpose. It’s not exactly behavior-driven development, but it’s as close as
    Spock comes at the moment.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 其他查找方法以类似的方式进行测试。为了保持测试的独立性，插入和删除方法一起测试；首先插入一个人，然后验证，然后再次删除。测试使用了 Spock 的另一个特性：每个块（`when`/`then`/`expect`
    等）都可以提供一个字符串来描述其目的。这并不完全是行为驱动开发，但它是 Spock 目前所能达到的最接近的方式。
- en: 'The insert and delete test looks like the following:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和删除测试看起来如下：
- en: '[PRE90]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Given a JSON object representing a person, a POST request adds it to the system.
    The returned object holds the status code (201), the content type (application/json),
    the returned person object (in the `data` property), and the URI for the new resource
    in the `Location` header. Deleting the object is done by sending a DELETE request
    to the new URI and verifying that the total number of stored instances goes down
    by one.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个表示人的 JSON 对象，通过 POST 请求将其添加到系统中。返回的对象包含状态码（201）、内容类型（application/json）、返回的人对象（在
    `data` 属性中），以及新资源的 URI 在 `Location` 头部。删除对象是通过向新 URI 发送 DELETE 请求并验证存储的实例总数减少一个来完成的。
- en: Updates are done through a PUT request. To ensure that PUT requests are idempotent,
    the complete object needs to be specified in the body of the request. This is
    why PUT requests aren’t normally used for inserts; the client doesn’t know the
    ID of the newly inserted object, so POST requests are used for that instead.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 更新是通过 PUT 请求完成的。为了确保 PUT 请求是幂等的，需要在请求体中指定完整对象。这就是为什么 PUT 请求通常不用于插入；客户端不知道新插入对象的
    ID，所以使用 POST 请求代替。
- en: The complete test is shown in the next listing.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试在下一列表中展示。
- en: Listing 9.5\. A Spock test for the `PersonResource` with a convenient test server
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 使用方便的测试服务器的 `PersonResource` 的 Spock 测试
- en: '![](ch09ex05-0.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex05-0.jpg)'
- en: '![](ch09ex05-1.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex05-1.jpg)'
- en: The JAX-RS annotations are easy enough to use. Building a URL-driven API with
    them isn’t difficult. The 2.0 version of the spec also includes a client-side
    API, but that’s not shown here.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS 注解的使用很简单。使用它们构建 URL 驱动的 API 并不难。规范 2.0 版本还包括客户端 API，但这里没有展示。
- en: '|  |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (JAX-RS)**'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '**（JAX-RS）学到的经验教训**'
- en: JAX-RS 2.0 is part of the Java EE specification and, like most of the recent
    specs, is annotation-based.
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JAX-RS 2.0 是 Java EE 规范的一部分，和大多数最近的规范一样，是基于注解的。
- en: It’s very easy to build a hyperlink-driven database using JAX-RS.
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 构建超链接驱动的数据库非常容易。
- en: Hypermedia mechanisms do exist in JAX-RS, but they’re well hidden.
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JAX-RS 中确实存在超媒体机制，但它们隐藏得很好。
- en: '|  |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Instead, I want to illustrate the Groovy implementation of the same specifications,
    mostly to illustrate the code simplifications. After that I’ll deal with the issue
    of hypermedia.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我想展示相同规范的 Groovy 实现，主要是为了说明代码简化。之后我会处理超媒体的问题。
- en: 9.3\. Implementing JAX-RS with Groovy
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 使用 Groovy 实现 JAX-RS
- en: Groovy doesn’t change JAX-RS in any fundamental way, though as usual it simplifies
    the implementation classes. JAX-RS is already simplifying the implementation by
    providing its own kind of DSL, so the Groovy modifications are minimal.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Groovy 并没有以任何根本的方式改变 JAX-RS，但像往常一样，它简化了实现类。JAX-RS 已经通过提供自己的 DSL 来简化实现，因此
    Groovy 的修改是最小的。
- en: The previous section used Groovy implementations but didn’t present them. Here
    I’ll show just enough to illustrate the Groovy features.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节使用了 Groovy 实现，但没有展示。这里我将展示足够的示例来说明 Groovy 功能。
- en: 'To begin, here’s the `Person` POGO. Note the `@XmlRootElement` annotation,
    used to control the serialization of the `Person` for the response. Normally that’s
    used for Java API for XML Binding (JAXB), but the presence of the Jackson JSON
    parser causes the serialization process to produce JSON objects instead:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是 `Person` POGO。注意 `@XmlRootElement` 注解，它用于控制响应中 `Person` 的序列化。通常这用于 Java
    API for XML Binding (JAXB)，但由于 Jackson JSON 解析器的存在，序列化过程会生成 JSON 对象：
- en: '[PRE91]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Getters, setters, and constructors are all generated in the normal manner. The
    `@EqualsAndHashCode` AST transformation takes care of `equals` and `hashCode`
    method implementations. The `@ToString` annotation could also have been used,
    but the desired `toString` method is barely longer than that, so I just wrote
    it out.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 属性获取器、设置器和构造函数都是按常规方式生成的。`@EqualsAndHashCode` AST 转换负责 `equals` 和 `hashCode`
    方法的实现。`@ToString` 注解也可以使用，但所需的 `toString` 方法几乎和它一样长，所以我只是直接写出来。
- en: 'Speaking of AST transformations, the `@Singleton` annotation is applied to
    the `JdbcPersonDAO` class when implemented in Groovy. That automatically implements
    and enforces the `singleton` property on the class by making the constructor private,
    adding a static `instance` variable, and so on. That class implements the same
    interface as before. Here’s the beginning of the class:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 说到 AST 转换，当在 Groovy 中实现时，`@Singleton` 注解应用于 `JdbcPersonDAO` 类。这通过使构造函数私有、添加静态
    `instance` 变量等方式自动实现并强制类的 `singleton` 属性。该类实现了与之前相同的接口。以下是类的开头：
- en: '[PRE92]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '|  |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovy and Java interfaces
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovy 和 Java 接口
- en: Java tools prefer Java interfaces. Most Java/Groovy integration problems vanish
    if you use Java interfaces with Groovy implementations.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: Java 工具更喜欢 Java 接口。如果你使用 Java 接口和 Groovy 实现来集成，大多数 Java/Groovy 集成问题都会消失。
- en: '|  |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'There’s one slight syntax variation required by the switch from Java to Groovy.
    The `@Produces` and `@Consumes` annotations take a list of media types that they
    support. In the Java implementation this is expressed as an array, using the braces
    notation:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 转换到 Groovy 需要一点语法上的变化。`@Produces` 和 `@Consumes` 注解接受它们支持的媒体类型列表。在 Java
    实现中，这表示为一个使用花括号表示法的数组：
- en: '[PRE93]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: In Groovy, braces indicate closures. Square brackets delimit a list, however,
    so the Groovy implementation just replaces the braces with brackets.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，花括号表示闭包。然而，方括号用于界定列表，因此 Groovy 的实现只是将花括号替换为方括号。
- en: '|  |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Braces vs. Brackets
  id: totrans-749
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 花括号与方括号
- en: Groovy uses curly braces for closures, so the literal notation to define a Java
    array should use square brackets for a `java.util .ArrayList` instead.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 使用花括号定义闭包，因此定义 Java 数组的字面表示法应该使用方括号来表示 `java.util.ArrayList`。
- en: '|  |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The complete `PersonResource` implementation in Groovy is shown in the next
    listing.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了 Groovy 中 `PersonResource` 的完整实现。
- en: Listing 9.6\. A Groovy implementation of the `PersonResource` class
  id: totrans-753
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. `PersonResource` 类的 Groovy 实现
- en: '[PRE94]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Most discussions of JAX-RS end at this point, with a working, URL-driven database.
    True REST is more flexible than that, however. A RESTful service is supposed to
    act like the web, in that it presents a single URL to the client, which accesses
    it and receives additional links in return. This is known as HATEOAS, or simply
    hypermedia.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关于 JAX-RS 的讨论都止步于此，有一个工作状态、由 URL 驱动的数据库。然而，真正的 REST 比这更灵活。RESTful 服务应该像网络一样行动，向客户端提供一个单一的
    URL，客户端访问它并返回额外的链接。这被称为 HATEOAS，或简单地称为超媒体。
- en: '|  |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lessons learned (JAX-RS with Groovy)**'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '**从 JAX-RS 与 Groovy 中学到的经验教训**'
- en: Groovy doesn’t significantly change JAX-RS.
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy 并没有显著改变 JAX-RS。
- en: The real Groovy simplifications are in the POGO and DAO classes. The resource
    implementation is essentially the same in both languages.
  id: totrans-759
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy 的真正简化在于 POGO 和 DAO 类。两种语言中的资源实现基本上是相同的。
- en: '|  |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Hypermedia links are exposed to clients, which consume them. JAX-RS 1.x doesn’t
    include a client-side API. Version 2.0 does, and there’s a convenient project
    in the Groovy ecosystem known as HttpBuilder for performing HTTP requests. Both
    are the subjects of the next section.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 超媒体链接暴露给客户端，客户端消费它们。JAX-RS 1.x 不包括客户端 API。2.0 版本包括了一个，Groovy 生态系统中的 HttpBuilder
    项目是一个方便的项目，用于执行 HTTP 请求。这两个都是下一节的主题。
- en: 9.4\. RESTful Clients
  id: totrans-762
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. RESTful 客户端
- en: 'Accessing a RESTful web service involves creating an HTTP request of the proper
    type and adding any necessary information to the body. One of the biggest changes
    in JAX-RS when moving from version 1 to version 2 is the addition of a standard
    client API. The API includes `Client` and `WebTarget` classes, which are used
    as follows:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 RESTful 网络服务涉及创建适当类型的 HTTP 请求，并将任何必要的信息添加到体中。当从版本 1 迁移到版本 2 时，JAX-RS 最大的变化之一是添加了标准客户端
    API。该 API 包括 `Client` 和 `WebTarget` 类，其使用方法如下：
- en: '[PRE95]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: A `Client` instance is created from a `ClientBuilder`, which in turn leads to
    a `Web-Target`. A GET request uses the `get` method, whose argument is the data
    type of the returned object. This example is taken from a hypermedia test, shown
    in the next section.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `ClientBuilder` 创建一个 `Client` 实例，它又指向一个 `Web-Target`。GET 请求使用 `get` 方法，其参数是返回对象的数据类型。此示例取自下一节中展示的媒体超文本测试。
- en: In Groovy, the Groovy JDK makes GET requests trivial. Groovy adds the `toURL`
    method to `java.lang.String`, which converts a `String` into an instance of `java.net.URL`.
    The Groovy JDK also adds the `getText` method to `java.net.URL`. Pulling information
    from the web can therefore be as simple as
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，Groovy JDK 使得 GET 请求变得非常简单。Groovy JDK 将 `toURL` 方法添加到 `java.lang.String`
    中，将 `String` 转换为 `java.net.URL` 的实例。Groovy JDK 还将 `getText` 方法添加到 `java.net.URL`
    中。因此，从网络获取信息可以像这样简单：
- en: '[PRE96]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Making POST, PUT, and DELETE requests is done in Groovy the same way it’s done
    in Java, which isn’t fun. Instead, client access is best done through a library.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，与 Java 一样，使用 POST、PUT 和 DELETE 请求并不有趣。相反，最好通过库来访问客户端。
- en: One of the most popular HTTP libraries is the open source Apache HTTP Client
    library ([http://hc.apache.org/httpcomponents-client-ga/index.html](http://hc.apache.org/httpcomponents-client-ga/index.html)),
    which is part of the Apache HttpComponents project.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的 HTTP 库之一是开源的 Apache HTTP 客户端库 ([http://hc.apache.org/httpcomponents-client-ga/index.html](http://hc.apache.org/httpcomponents-client-ga/index.html))，它是
    Apache HttpComponents 项目的一部分。
- en: 'Rather than show the details of that library I’d rather focus on the corresponding
    Groovy project, HttpBuilder. The HttpBuilder project ([http://groovy.codehaus.org/modules/http-builder/](http://groovy.codehaus.org/modules/http-builder/))
    follows the classic Groovy idiom: wrap a Java library and make it easier to use.
    While the documentation on the website isn’t bad, I recommend looking at the test
    cases in the source code for guidance on how to use the API.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 我更愿意关注相应的 Groovy 项目 HttpBuilder，而不是展示那个库的细节。HttpBuilder 项目 ([http://groovy.codehaus.org/modules/http-builder/](http://groovy.codehaus.org/modules/http-builder/))
    遵循经典的 Groovy 习惯：封装一个 Java 库并使其更容易使用。虽然网站上的文档还不错，但我建议查看源代码中的测试用例，以了解如何使用 API。
- en: Like most cool projects, the source code is hosted at GitHub at [https://github.com/jgritman/httpbuilder](https://github.com/jgritman/httpbuilder).
    The API includes a convenient class for REST applications called `RESTClient`,
    which I used in the tests in this chapter. The corresponding test class, `RESTClientTests`,
    shows how to access Twitter using all the standard HTTP verbs.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数酷项目一样，源代码托管在 GitHub 上，地址为 [https://github.com/jgritman/httpbuilder](https://github.com/jgritman/httpbuilder)。API
    包含一个方便的用于 REST 应用的类 `RESTClient`，我在本章的测试中使用了它。相应的测试类 `RESTClientTests` 展示了如何使用所有标准
    HTTP 动词访问 Twitter。
- en: 'I used the `RESTClient` class in the `PersonResourceSpec` tests. The `RESTClient`
    class has a constructor that takes two arguments, the base URL and a content type:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 `PersonResourceSpec` 测试中使用了 `RESTClient` 类。`RESTClient` 类有一个构造函数，它接受两个参数，即基础
    URL 和内容类型：
- en: '[PRE97]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In this case I’m running the Grizzly test server on port 1234, and for this
    demo the data is in JSON form. The test for the GET method produces the following:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我在端口 1234 上运行 Grizzly 测试服务器，并且对于这个演示，数据以 JSON 格式存在。GET 方法的测试产生了以下结果：
- en: '[PRE98]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `RESTClient` provides a `get` method that takes a `path` parameter. The
    response comes back with special properties for (most of) the typical headers.
    Other headers can be retrieved either by requesting the `allHeaders` property
    or by calling `get-Header("...")` with the required header. Any returned entity
    in the body of the response is in the `data` property.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESTClient` 提供了一个 `get` 方法，它接受一个 `path` 参数。响应返回具有（大多数）典型头部的特殊属性。其他头部可以通过请求
    `allHeaders` 属性或通过调用 `get-Header("...")` 并提供所需的头部来检索。响应体中的任何返回实体都在 `data` 属性中。'
- en: See the rest^([[14](#ch09fn14)]) of the `PersonResourceSpec` class for examples
    of POST, PUT, and DELETE requests.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `PersonResourceSpec` 类的其余部分（^[[14](#ch09fn14)]），以获取 POST、PUT 和 DELETE 请求的示例。
- en: ^(14) Again, sorry. At some point (and that may already have happened), when
    I say, “No pun intended,” you’re simply not going to believe me.
  id: totrans-778
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([14](#ch09fn14)) 再次，抱歉。在某个时刻（这可能已经发生），当我说，“没有这个意思，”你可能根本不会相信我。
- en: '|  |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (REST clients)**'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（REST客户端）**'
- en: JAX-RS 2.0 includes classes for building REST clients.^([[15](#ch09fn15)])
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JAX-RS 2.0 包含用于构建REST客户端的类.^([[15](#ch09fn15)])
- en: ^(15) The JAX-RS client classes are very easy to use, too, which is unfortunate
    when you’re trying to show how cool Groovy is, but helpful for users. Oh well.
  id: totrans-782
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([15](#ch09fn15)) JAX-RS客户端类也非常容易使用，这在尝试展示Groovy有多酷的时候很不幸，但对于用户来说很有帮助。哦，算了。
- en: The Groovy project HttpBuilder wraps the Apache HttpClient project and makes
    it easier to use.
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovy项目的HttpBuilder包装了Apache HttpClient项目，使其更容易使用。
- en: '|  |'
  id: totrans-784
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Both the `RESTClient` and the JAX-RS 2.0 client are used in the test cases in
    the hypermedia section, which is as good a segue as any to finally discuss HATEOAS
    in Java.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 在超媒体部分的测试用例中，`RESTClient` 和 JAX-RS 2.0 客户端都被使用，这为最终讨论Java中的HATEOAS提供了一个很好的过渡。
- en: 9.5\. Hypermedia
  id: totrans-786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5. 超媒体
- en: A series of resource URLs is not a RESTful web service. At best, it’s a URL-driven
    database. Yet applications like that, which claim to be RESTful services, are
    all over the web.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列资源URL不是一个RESTful网络服务。充其量，它是一个URL驱动的数据库。然而，像这样的应用程序，它们声称是RESTful服务，遍布整个网络。
- en: A true^([[16](#ch09fn16)]) REST application understands that specific resource
    URLs may evolve, despite attempts to keep them as stable as possible. The idea
    therefore is to make requests that discover the subsequent URLs to follow. We’re
    so accustomed to having a fixed API that this can be a difficult concept to adopt.
    Instead of knowing exactly what you’re going to get back from any given request,
    you know how to make the first request and interrogate the result for whatever
    may come next. This is similar to the way we browse the web, which is no coincidence.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真正的^([16](#ch09fn16)) REST应用理解到，尽管尝试尽可能保持稳定，但特定的资源URL可能会发生变化。因此，请求的目的是发现后续的URL。我们习惯于有一个固定的API，因此这个概念可能很难接受。你不知道任何给定请求会返回什么，但你知道如何发出第一个请求，并查询结果以了解接下来可能发生什么。这与我们浏览网页的方式相似，这并非巧合。
- en: ^(16) The word *true* here is defined as “at least trying to follow the principles
    in Roy Fielding’s thesis.”
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([16](#ch09fn16)) 这里的“真正”被定义为“至少尝试遵循Roy Fielding的论文中的原则。”
- en: It does place a higher burden on the client and the server, though. The server
    needs to add some sort of metadata to explain what the subsequent resources are
    and how to access them, and the client needs to read those responses and interpret
    them correctly.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这给客户端和服务器带来了更高的负担。服务器需要添加一些类型的元数据来解释后续资源是什么以及如何访问它们，客户端需要读取这些响应并正确解释它们。
- en: This section will illustrate the ways you can add links to the service responses.
    I’ll start by showing an example from a public API, then demonstrate how to add
    links to the HTTP response headers or to the response bodies, and finally demonstrate
    how to customize the output however you want.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将说明你可以如何向服务响应中添加链接。我会从一个公共API的例子开始，然后演示如何将链接添加到HTTP响应头或响应体中，最后演示如何自定义输出方式。
- en: '9.5.1\. A simple example: Rotten Tomatoes'
  id: totrans-792
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.1. 一个简单的例子：烂番茄
- en: As a simple example, consider the API provided by the movie review website Rotten
    Tomatoes used in [chapter 8](kindle_split_020.html#ch08) on Groovy with databases.
    The Rotten Tomatoes API only supports GET requests, so it isn’t a full RESTful
    service.^([[17](#ch09fn17)])
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的例子，考虑在[第8章](kindle_split_020.html#ch08)中使用的电影评论网站烂番茄提供的API。烂番茄API只支持GET请求，因此它不是一个完整的RESTful服务.^([17](#ch09fn17)])
- en: ^(17) RESTful services that only support GET can be called GETful services.
    If they’re stateless, too, doesn’t that make them FORGETful services? Thank you,
    thank you. I’ll be here all week. Try the veal, and don’t forget to tip your waitresses.
  id: totrans-794
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([17](#ch09fn17)) 只支持GET的RESTful服务可以被称为GETful服务。如果它们也是无状态的，那么它们不就成了FORGETful服务？谢谢，谢谢。我整个星期都会在这里。尝试牛排，别忘了给服务员小费。
- en: 'Using the site’s URL-based API to query for movies including the word *trek*
    looks like this:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于URL的API查询包含单词 *trek* 的电影看起来是这样的：
- en: '[PRE99]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Out of the resulting 151 (!) movies,^([[18](#ch09fn18)]) if I select *Star
    Trek Into Darkness*, I get a JSON object that looks like the following (with a
    lot of parts elided):'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的151 (!) 部电影中，^([[18](#ch09fn18)]) 如果我选择 *星际迷航：暗黑无界*，我会得到一个如下所示的JSON对象（省略了很多部分）：
- en: ^(18) Including one called, I kid you not, *Star Trek versus Batman*. The Enterprise
    goes back in time to the 1960s and gets taken over by the Joker and Catwoman.
    Seriously.
  id: totrans-798
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（18）包括一个名为，我必须说的是，*星际迷航与蝙蝠侠*。企业号回到20世纪60年代，被小丑和猫女占领。真的。
- en: '[PRE100]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The movie object (a resource using a JSON representation) includes an entry
    called `links`, which itself is a map of keys and values. The keys in the `links`
    objects all point to additional resources, such as a full cast listing or reviews.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 电影对象（使用JSON表示的资源）包含一个名为`links`的条目，它本身是一个键值映射。`links`对象中的所有键都指向其他资源，例如完整的演员列表或评论。
- en: The Rotten Tomatoes service adds links to the individual resources rather than
    appending them to the response headers. The site uses its own format rather than
    some other standard.^([[19](#ch09fn19)]) It also handles content negotiation by
    embedding the “.json” string in the URL itself.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: Rotten Tomatoes服务将链接添加到单个资源中，而不是将其附加到响应头中。该网站使用自己的格式而不是其他标准.^([[19](#ch09fn19)])
    它还通过在URL本身嵌入“ .json”字符串来处理内容协商。
- en: ^(19) Attempts at standardizing JSON links include [www.subbu.org/blog/2008/10/generalized-linking](http://www.subbu.org/blog/2008/10/generalized-linking)
    and [www.mnot.net/blog/2011/11/25/linking_in_json](http://www.mnot.net/blog/2011/11/25/linking_in_json).
  id: totrans-802
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（19）尝试标准化JSON链接包括[www.subbu.org/blog/2008/10/generalized-linking](http://www.subbu.org/blog/2008/10/generalized-linking)和[www.mnot.net/blog/2011/11/25/linking_in_json](http://www.mnot.net/blog/2011/11/25/linking_in_json)。
- en: The client, of course, needs to know all of that, but by including a `links`
    section in the response the server is identifying exactly what’s expected next.
    The client can simply present those links to the user, or it can try to place
    them in context, which requires additional understanding.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端当然需要知道所有这些信息，但通过在响应中包含一个`links`部分，服务器可以明确指出接下来期望的内容。客户端可以简单地展示这些链接给用户，或者尝试将它们置于上下文中，这需要额外的理解。
- en: Generating a good client for a hypermedia-based RESTful service is not a trivial
    task.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 为基于超媒体的RESTful服务生成一个好的客户端不是一个简单任务。
- en: 'Notice one interesting point: the entire API uses JSON to express the objects.
    So far in this chapter I’ve used the term *resource* to represent not only the
    server-side object exposed to the client, but also how it’s expressed. Formally,
    the term *representation* is used to describe the form of the resource.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一个有趣的观点：整个API使用JSON来表示对象。到目前为止，在本章中，我使用术语*资源*不仅代表服务器端暴露给客户端的对象，还代表其表示方式。正式来说，术语*表示*用来描述资源的形态。
- en: '|  |'
  id: totrans-806
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Representation
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表示
- en: A representation is an immutable, self-descriptive, stateless snapshot of a
    resource, which may contain links to other resources.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 表示是一个不可变、自描述、无状态的资源快照，可能包含指向其他资源的链接。
- en: '|  |'
  id: totrans-809
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The most common representations are XML and JSON, with JSON becoming almost
    ubiquitous.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的表示形式是XML和JSON，其中JSON几乎无处不在。
- en: '|  |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The Richardson maturity model: a rigged demo**'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '**理查森成熟度模型：一个精心设计的演示**'
- en: The Richardson Maturity Model (RMM) is based on a 2008 presentation made by
    Leonard Richardson, who described multiple levels of REST adoption.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 理查森成熟度模型（RMM）基于Leonard Richardson在2008年的一次演讲，他描述了REST采用的多个级别。
- en: 'RMM has four levels, numbered from zero to three:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: RMM有四个级别，编号从零到三：
- en: '***Level 0: Plain old XML (POX) over HTTP—*** HTTP is merely a transport protocol,
    and the service is essentially remote procedure calls using it. Sounds a lot like
    SOAP, doesn’t it? That’s no accident.'
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***零级：通过HTTP的简单老式XML（POX）—*** HTTP仅仅是一个传输协议，服务本质上是通过它进行的远程过程调用。听起来很像SOAP，对吧？这并非巧合。'
- en: '***Level 1: Addressable resources—*** Each URI corresponds to a resource on
    the server side.'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***第一级：可寻址资源—*** 每个URI对应服务器端的一个资源。'
- en: '***Level 2: Uniform interface—*** The API utilizes only the HTTP verbs GET,
    PUT, POST, and DELETE (plus maybe OPTIONS and TRACE).'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***第二级：统一接口—*** API仅使用HTTP动词GET、PUT、POST和DELETE（可能还包括OPTIONS和TRACE）。'
- en: '***Level 3: Hypermedia—*** The representation of the response contains links
    defining additional steps in the process. The server may even define custom MIME
    types to specify how the additional metadata is included.'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***第三级：超媒体—*** 响应的表示包含定义过程额外步骤的链接。服务器甚至可以定义自定义MIME类型来指定如何包含额外的元数据。'
- en: Now, honestly, I have no objections to this model. It’s fundamental to Roy Fielding’s
    thesis to include all of it; you’re not really adopting REST unless you have hypermedia,
    too.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，老实说，我对这个模型没有任何异议。它对Roy Fielding的论文来说是基本的；除非你也有超媒体，否则你并不是真正采用了REST。
- en: The word *maturity*, however, carries a lot of emotional baggage. Who wants
    their implementation to be less mature? It also can’t be a coincidence that SOAP
    is considered maturity level 0\. The model is fine, but there’s no need to load
    it down with judgmental overtones that make it feel like a rigged demo.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单词*maturity*却带有许多情感负担。谁愿意他们的实现不够成熟？这也并非巧合，SOAP被认为是成熟度级别0。模型是好的，但无需给它加上带有评判色彩的语气，使其感觉像是一场被操纵的演示。
- en: '|  |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Hypermedia^([[20](#ch09fn20)]) in JAX-RS works through links, which come in
    two types:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS中的超媒体^([[20](#ch09fn20)])通过链接工作，链接有两种类型：
- en: ^(20) Believe it or not, neither the words hypermedia nor HATEOAS *appears at
    all* in the JSR 339 specification. I have no explanation for this.
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（20）信不信由你，超媒体和HATEOAS这两个词在JSR 339规范中根本**没有出现**。我对此没有解释。
- en: Transitional links in HTTP headers
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP头中的过渡链接
- en: Structural links embedded in the response
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应中嵌入的结构链接
- en: '[Figure 9.4](#ch09fig04) shows both in a single HTTP response.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.4](#ch09fig04) 在单个HTTP响应中显示了两者。'
- en: Figure 9.4\. Transitional links appear in the HTTP response headers, while structural
    links are part of the response objects. In each case the links can be used to
    access other resources from this one.
  id: totrans-827
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. 过渡链接出现在HTTP响应头中，而结构链接是响应对象的一部分。在每种情况下，链接都可以用来访问其他资源。
- en: '![](09fig04_alt.jpg)'
  id: totrans-828
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig04_alt.jpg)'
- en: Version 2.0 of the JAX-RS specification supports transitional links using the
    `Link` and `LinkBuilder` classes, and structural links using a special JAXB serializer.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS规范的2.0版本支持使用`Link`和`LinkBuilder`类进行过渡链接，以及使用特殊的JAXB序列化器进行结构链接。
- en: 'To illustrate both, I’ll continue with the `Person` example from earlier by
    adding links to each instance. Each person has three possible links:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明两者，我将继续使用之前提到的`Person`示例，并为每个实例添加链接。每个人有三种可能的链接：
- en: A `self` link, containing the URL for that person
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`self`链接，包含该人的URL
- en: A `prev` link, pointing to the person with an ID one less than the current person
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`prev`链接，指向ID比当前人ID小1的人
- en: A `next` link, pointing to the person with an ID one greater than the current
    person
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`next`链接，指向ID比当前人ID大1的人
- en: This is a rather contrived case, but it has the advantage of simplicity.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当牵强的例子，但它具有简单性的优势。
- en: First I’ll add the links to the HTTP headers and show how to use them. Then
    I’ll use structural links instead, using the JAXB serializer. Finally, I’ll take
    control of the output generation process and customize the output writer using
    Groovy’s `JsonBuilder`.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先将链接添加到HTTP头中，并展示如何使用它们。然后，我将使用结构链接，使用JAXB序列化器。最后，我将控制输出生成过程，并使用Groovy的`JsonBuilder`自定义输出写入器。
- en: 9.5.2\. Adding transitional links
  id: totrans-836
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.2\. 添加过渡链接
- en: 'To create transitional links, the JAX-RS API starts with the inner class `Response`
    `.Response-Builder` in the `javax.ws.rs.core` package. `ResponseBuilder` has three
    relevant methods:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建过渡链接，JAX-RS API从`javax.ws.rs.core`包中的内部类`Response` `.Response-Builder`开始。`ResponseBuilder`有三个相关方法：
- en: '[PRE101]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The first two add a single `Link` header to the HTTP response. The third adds
    a series of headers to the response. Here’s an example from the `PersonResource`
    class:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例向HTTP响应添加单个`Link`头。第三个示例向响应添加一系列头。以下是从`PersonResource`类中的一个示例：
- en: '[PRE102]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The `link` method in this case uses the request URI as the first argument and
    sets the `rel` property to `self`. The corresponding test accesses the link as
    follows:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`link`方法使用请求URI作为第一个参数，并将`rel`属性设置为`self`。相应的测试如下访问链接：
- en: '[PRE103]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This example returns only a single `Link` header. For multiple links (for example,
    the three transitional links `prev`, `next`, and `self` for each individual person),
    the method `getHeaders('Link')` retrieves them all.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅返回一个`Link`头。对于多个链接（例如，每个个人的三个过渡链接`prev`、`next`和`self`），`getHeaders('Link')`方法检索所有这些链接。
- en: In the `PersonResource` the links are set with a private method, shown in the
    next listing.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PersonResource`中，链接是通过一个私有方法设置的，如下一列表所示。
- en: Listing 9.7\. Setting `prev`, `self`, and `next` link headers for each person
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7\. 为每个人设置`prev`、`self`和`next`链接头
- en: '![](247fig01_alt.jpg)'
  id: totrans-846
  prefs: []
  type: TYPE_IMG
  zh: '![](247fig01_alt.jpg)'
- en: So-called “self” links are generated for each person. Next and previous links
    are generated for those elements between the first and last. The links themselves
    are simply generated by string manipulation.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 所以所谓的“self”链接为每个人生成。对于位于第一个和最后一个元素之间的元素，生成下一个和上一个链接。链接本身是通过字符串操作生成的。
- en: 'Adding the links to the resource is done with the `links` method:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`links`方法将链接添加到资源中：
- en: '[PRE104]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: It turns out that converting the `Link` headers into something useful isn’t
    simple with the `RESTClient`. In this case the JAX-RS `Client` class works better.
    The `Client` class has a method called `getLink`, which takes a string argument,
    in which the string is the relation type. That method returns an instance of the
    `javax.ws.rs` `.core.Link` class, which corresponds to specification RFC 5988,
    Web Linking, of the IETF.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，使用`RESTClient`将`Link`头转换为有用的内容并不简单。在这种情况下，JAX-RS的`Client`类效果更好。`Client`类有一个名为`getLink`的方法，该方法接受一个字符串参数，其中字符串是关系类型。该方法返回一个`javax.ws.rs.core.Link`类的实例，对应于IETF的RFC
    5988，Web链接规范。
- en: I’ll demonstrate the hypermedia capability by walking through the links one
    by one in a client. The following listing is a JUnit test case, written in Groovy,
    that accesses the `next` links.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过在客户端逐个遍历链接来演示超媒体功能。以下列表是一个JUnit测试用例，用Groovy编写，它访问`next`链接。
- en: Listing 9.8\. Walking through the data using link headers
  id: totrans-852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8\. 使用链接头遍历数据
- en: '![](248fig01_alt.jpg)'
  id: totrans-853
  prefs: []
  type: TYPE_IMG
  zh: '![](248fig01_alt.jpg)'
- en: The client uses the `getLink` method with the relation type (`next` or `prev`),
    which returns a `Link` instance. The `getUri` method then returns an instance
    of `java.net.URI`, which can be followed by the client on the next iteration.^([[21](#ch09fn21)])
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用`getLink`方法与关系类型（`next`或`prev`）一起使用，该方法返回一个`Link`实例。然后`getUri`方法返回一个`java.net.URI`实例，客户端可以在下一次迭代中跟随它.^([[21](#ch09fn21)])
- en: ^(21) I have to mention that this is probably one of the only times in the last
    decade that I really could have used a `do`/`while` loop. Ironically, that’s just
    about the only Java construct not supported by Groovy.
  id: totrans-855
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(21) 我必须提到，这可能是过去十年中我真正可以使用`do`/`while`循环的唯一几次之一。具有讽刺意味的是，这正是Groovy不支持的唯一Java结构。
- en: If you would rather put the links in the body of the response, you need a different
    approach, as described in the next section.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意在响应体中放置链接，则需要采用不同的方法，下一节将进行描述。
- en: 9.5.3\. Adding structural links
  id: totrans-857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.3\. 添加结构化链接
- en: Structural links in JAX-RS are instances of the `Link` class inside the entity
    itself. Converting them to XML or JSON then requires a special serializer, which
    is provided by the API.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS中的结构化链接是实体内部的`Link`类的实例。将它们转换为XML或JSON需要特殊的序列化器，该序列化器由API提供。
- en: 'Here’s the `Person` class, expanded to hold the `self`, `next`, and `prev`
    links as attributes:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Person`类，扩展以包含`self`、`next`和`prev`链接作为属性：
- en: '[PRE105]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The `prev`, `self`, and `next` links are instances of the `javax.ws.rs.core.Link`
    class, as before. `Link.JaxbAdapter` is an inner class that tells JAXB how to
    serialize the links.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev`、`self`和`next`链接是`javax.ws.rs.core.Link`类的实例，与之前一样。`Link.JaxbAdapter`是一个内部类，它告诉JAXB如何序列化链接。'
- en: 'Setting the values of the link references is done in the resource, this time
    using an interesting Groovy mechanism:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源中设置链接引用的值，这次使用了一个有趣的Groovy机制：
- en: '[PRE106]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The same `getLinks` private method is used as in the headers section, but this
    time the links are added to the `Person` instance. By calling `link.rel` (which
    calls the `getRel` method) and injecting the result into a string, the effect
    is to call `p.self`, `p.next`, or `p.prev`, as the case may be. In each case,
    that will call the associated setter method and assign the attribute to the link
    on the right-hand side.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 与头部分节中使用的相同`getLinks`私有方法，但这次链接被添加到`Person`实例中。通过调用`link.rel`（这会调用`getRel`方法）并将结果注入到一个字符串中，效果是调用`p.self`、`p.next`或`p.prev`，具体情况而定。在每种情况下，这将调用相关的setter方法并将属性分配给右侧的链接。
- en: 'A test of the structural links using the `RESTClient` looks like this:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RESTClient`测试结构化链接如下：
- en: '[PRE107]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The response wraps a `Person` instance, accessed by calling `getData`. Then
    the individual links are retrieved as the `prev`, `self`, and `next` properties.
    The result is a `Link` instance whose `getHref` method can be used to verify the
    links.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 响应封装了一个`Person`实例，通过调用`getData`来访问。然后检索单个链接作为`prev`、`self`和`next`属性。结果是`Link`实例，其`getHref`方法可用于验证链接。
- en: 'There’s only one problem, and it’s more of a nuisance than anything else. In
    the Rotten Tomatoes example at the beginning of the hypermedia section, the links
    were not top-level attributes of the movies. Instead, each movie representation
    contained a JSON object whose key was `links`, and which contained the list of
    individual links and relations. Here’s the snippet from the Rotten Tomatoes response:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个问题，这更像是一个麻烦，而不是其他。在超媒体部分的开始处，Rotten Tomatoes 示例中的链接不是电影的最顶层属性。相反，每个电影表示都包含一个键为
    `links` 的 JSON 对象，其中包含单个链接和关系的列表。以下是 Rotten Tomatoes 响应的片段：
- en: '[PRE108]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: In the JAX-RS approach using the serializer, the relation is the attribute name.
    What if I want to make a collection of links as shown in the movie example? For
    that I need to take control of the serialization process.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用序列化器的 JAX-RS 方法中，关系是属性名。如果我想创建一个类似于电影示例中的链接集合，该怎么办？为此，我需要控制序列化过程。
- en: 9.5.4\. Using a JsonBuilder to control the output
  id: totrans-871
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.5.4\. 使用 JsonBuilder 控制输出
- en: To customize output generation, JAX-RS includes an interface called `javax.ws.rs.ext`
    `.MessageBodyWriter<T>`. This interface is the contract for converting a Java
    type into a stream. It contains three methods to be implemented.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义输出生成，JAX-RS 包含一个名为 `javax.ws.rs.ext` 的接口 `.MessageBodyWriter<T>`。此接口是将 Java
    类型转换为流的契约。它包含三个需要实现的方法。
- en: 'The first method is called `isWriteable`, and it returns true for types supported
    by this writer. For the `Person` class the implementation is simple:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法被称为 `isWriteable`，对于本写器支持的类型，它返回 true。对于 `Person` 类，实现很简单：
- en: '[PRE109]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The method returns true only for `Person` instances and only if the specified
    media type is JSON.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅在 `Person` 实例上返回 true，并且只有当指定的媒体类型是 JSON 时才返回 true。
- en: 'The second method is called `getSize`, and it’s deprecated in JAX-RS 2.0\.
    Its implementation is supposed to return -1:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法被称为 `getSize`，在 JAX-RS 2.0 中已被弃用。它的实现应该返回 -1：
- en: '[PRE110]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `writeTo` method does all the work. Here I use `groovy.json.JsonBuilder`
    to generate the output in the form I want, as shown in the following listing.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeTo` 方法完成所有工作。在这里，我使用 `groovy.json.JsonBuilder` 生成我想要的输出形式，如下所示。'
- en: Listing 9.9\. Using a `JsonBuilder` to produce nested links
  id: totrans-879
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. 使用 `JsonBuilder` 生成嵌套链接
- en: '![](251fig01_alt.jpg)'
  id: totrans-880
  prefs: []
  type: TYPE_IMG
  zh: '![](251fig01_alt.jpg)'
- en: One special quirk is notable here. The method calls `toString` on the individual
    `Link` instances. As the JavaDocs for `Link` make clear, the `toString` and `valueOf(String)`
    methods in `Link` are used to convert to and from strings.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有一个特殊的怪癖值得注意。方法对单个 `Link` 实例调用 `toString`。正如 `Link` 的 JavaDocs 所明确指出的，`Link`
    中的 `toString` 和 `valueOf(String)` 方法用于将字符串转换为和从字符串转换。 '
- en: 'The `MessageBodyReader` interface is quite similar. In that case there are
    only two methods: `isReadable` and `readFrom`. The implementation of `isReadable`
    is the same as the `isWriteable` method:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageBodyReader` 接口相当类似。在这种情况下，只有两个方法：`isReadable` 和 `readFrom`。`isReadable`
    的实现与 `isWriteable` 方法相同：'
- en: '[PRE111]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `readFrom` method uses a `JsonSlurper` to convert string input into a `Person`,
    as shown in the next listing.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFrom` 方法使用 `JsonSlurper` 将字符串输入转换为 `Person`，如下所示。'
- en: Listing 9.10\. Parsing a `Person` instance from a string
  id: totrans-885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. 从字符串解析 `Person` 实例
- en: '[PRE112]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The `readFrom` method uses the `JsonSlurper`’s `parseText` method to convert
    the input text data into a JSON object and then instantiates a `Person` based
    on the resulting properties. If links exist in the body, they’re converted using
    the `valueOf` method.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFrom` 方法使用 `JsonSlurper` 的 `parseText` 方法将输入文本数据转换为 JSON 对象，然后根据结果属性实例化一个
    `Person`。如果正文中存在链接，它们将使用 `valueOf` 方法进行转换。'
- en: 'To use the `MessageBodyWriter`, I need to add an `@Provider` annotation to
    the implementation class and make sure it’s loaded in the application. The latter
    is done by adding the provider to the `MyApplication` class:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `MessageBodyWriter`，我需要在实现类上添加 `@Provider` 注解，并确保它在应用程序中加载。后者是通过将提供者添加到
    `MyApplication` 类中完成的：
- en: '[PRE113]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In this case both the `PersonProvider` and the `JacksonFeature` are used. The
    `Person` provider converts individual `Person` instances to JSON, and the `JacksonFeature`
    handles collections. A test of the resulting structure looks like this:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，同时使用了 `PersonProvider` 和 `JacksonFeature`。`Person` 提供者将单个 `Person` 实例转换为
    JSON，而 `JacksonFeature` 处理集合。对结果结构的测试如下所示：
- en: '[PRE114]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The response body now has a `links` element, which contains `prev`, `self`,
    and `next` as child elements.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体现在有一个 `links` 元素，它包含作为子元素的 `prev`、`self` 和 `next`。
- en: '|  |'
  id: totrans-893
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (hypermedia)**'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（超媒体）**'
- en: JAX-RS mostly ignores hypermedia but does make some methods available for it.
  id: totrans-895
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JAX-RS主要忽略了超媒体，但确实为它提供了一些方法。
- en: Transitional link headers are added by the `link` and `links` methods in `Response-Builder`.
  id: totrans-896
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过渡链接头是通过`Response-Builder`中的`link`和`links`方法添加的。
- en: Structural links in the body are added through a special JAXB annotation.
  id: totrans-897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过特殊的JAXB注解在正文中添加结构链接。
- en: You can manage the parsing and response generation stages yourself by writing
    a provider class that implements `MessageBodyReader` and/or `Message-BodyWriter`.
  id: totrans-898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过编写一个实现`MessageBodyReader`和/或`Message-BodyWriter`的提供者类来自己管理解析和响应生成阶段。
- en: '|  |'
  id: totrans-899
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Between the transitional links, the structural links with the JAXB serializer,
    and the Groovy `JsonBuilder`, hopefully you now have enough mechanisms to implement
    hypermedia links in any way your application requires. The choice of which to
    use is largely a matter of style, but there are some guidelines:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 在过渡链接、与JAXB序列化器的结构链接和Groovy的`JsonBuilder`之间，希望你现在有足够的机制以任何你应用程序需要的方式实现超媒体链接。选择使用哪种方法在很大程度上是一个风格问题，但有一些指导原则：
- en: Structural links are contained in the response, so the client has to parse the
    response to get them.
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构链接包含在响应中，因此客户端必须解析响应才能获取它们。
- en: Transitional links are in the HTTP headers. That gets them out of the response
    but forces the client to parse the HTTP response headers to retrieve them.
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡链接在HTTP头中。这使它们从响应中分离出来，但迫使客户端解析HTTP响应头以检索它们。
- en: Custom links can be anything, so they must be clearly documented.
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义链接可以是任何东西，因此它们必须被清楚地记录。
- en: Examples of all three approaches can be found on the web.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上可以找到所有三种方法的示例。
- en: 9.6\. Other Groovy approaches
  id: totrans-905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6. 其他Groovy方法
- en: There are three other approaches in the Groovy ecosystem that I should mention
    for RESTful web services. Here I’ll specifically discuss groovlets, the Ratpack
    project, and Grails.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy生态系统中有三种其他方法我应该提到，用于RESTful Web服务。在这里，我将特别讨论groovlets、Ratpack项目和Grails。
- en: 9.6.1\. Groovlets
  id: totrans-907
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.1. Groovlets
- en: Groovlets are discussed in [chapter 10](kindle_split_022.html#ch10) on web applications
    as well as the simple example in [chapter 2](kindle_split_012.html#ch02), but
    essentially they’re groovy scripts that receive HTTP requests and return HTTP
    responses. Groovlets contain many implicit variables, including `request`, `response`,
    `session`, and `params` (to hold input variables).
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: Groovlets在第10章[kindle_split_022.html#ch10]中讨论了Web应用程序，以及第2章[kindle_split_012.html#ch02]中的简单示例，但本质上它们是接收HTTP请求并返回HTTP响应的Groovy脚本。Groovlets包含许多隐式变量，包括`request`、`response`、`session`和`params`（用于存储输入变量）。
- en: In a groovlet you can use the `getMethod` method on the request object to determine
    if the request is a GET, PUT, POST, or DELETE. Then you can build the response
    accordingly.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 在groovlet中，你可以使用请求对象的`getMethod`方法来确定请求是GET、PUT、POST还是DELETE。然后你可以相应地构建响应。
- en: The book source code has a project in [chapter 10](kindle_split_022.html#ch10)
    called `SongService`, which demonstrates how to use a groovlet. The service itself
    is a groovlet, which is shown in the following listing.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的源代码有一个名为`SongService`的项目，位于第10章[kindle_split_022.html#ch10]，它展示了如何使用groovlet。该服务本身就是一个groovlet，如下所示。
- en: Listing 9.11\. A groovlet that processes and produces XML
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.11. 处理并生成XML的groovlet
- en: '![](ch09ex11-0.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex11-0.jpg)'
- en: '![](ch09ex11-1.jpg)'
  id: totrans-913
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09ex11-1.jpg)'
- en: The groovlet uses `request.method` in a `switch` statement to determine the
    correct implementation. Then it uses a built-in `MarkupBuilder` called `html`
    to produce XML, and an `XmlSlurper` to convert XML to song instances. Now that
    groovlets have a builtin `JsonBuilder` as well,^([[22](#ch09fn22)]) JSON could
    easily be used instead.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: groovlet使用`request.method`在`switch`语句中确定正确的实现。然后它使用一个名为`html`的内置`MarkupBuilder`来生成XML，并使用`XmlSlurper`将XML转换为歌曲实例。现在groovlets也有内置的`JsonBuilder`，因此JSON可以很容易地被使用。
- en: ^(22) That’s my great contribution to Groovy—the implicit `json` object in groovlets,
    which I not only added, but with which I managed to break the build in the process.
    Sigh. If you’re interested, details can be found at [http://mng.bz/5Vn6](http://mng.bz/5Vn6).
  id: totrans-915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([22](#ch09fn22)) 这是我对Groovy的巨大贡献——groovlet中的隐式`json`对象，我不仅添加了它，而且在添加的过程中还成功地破坏了构建。唉。如果你感兴趣，详细信息可以在[http://mng.bz/5Vn6](http://mng.bz/5Vn6)找到。
- en: This approach is pretty low-level, but it may be useful for quick-and-dirty
    implementations or if you need such detailed control.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相当底层，但可能对快速实现或需要这种详细控制的情况很有用。
- en: 9.6.2\. Ratpack
  id: totrans-917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.2. Ratpack
- en: The second alternative is to look at the Ratpack project ([https://github.com/ratpack/ratpack](https://github.com/ratpack/ratpack)).
    Ratpack is a Groovy project that follows the same ideas as the Sinatra^([[23](#ch09fn23)])
    project in the Ruby world. Ratpack is called a “micro” framework, in that you
    write simple Groovy scripts that govern how to handle individual requests.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是查看Ratpack项目（[https://github.com/ratpack/ratpack](https://github.com/ratpack/ratpack)）。Ratpack是一个Groovy项目，它遵循Ruby世界中的Sinatra^([[23](#ch09fn23)])项目的相同理念。Ratpack被称为“微型”框架，因为你编写简单的Groovy脚本，以控制如何处理单个请求。
- en: ^(23) Sinatra, Ratpack, get it? If nothing else, it’s a great name.
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（23）Sinatra，Ratpack，明白了吗？如果其他什么都没有，那也是一个很棒的名字。
- en: 'For example, a simple Ratpack script looks like this:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个简单的Ratpack脚本看起来像这样：
- en: '[PRE115]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The project shows a lot of promise, and Sinatra is very popular in the Ruby
    world, so it’s probably worth a look. The project has recently come under the
    control of Luke Daley, who is a major player in the Groovy world, so I expect
    significant improvements soon.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目显示出很大的潜力，Sinatra在Ruby世界中非常受欢迎，所以它可能值得一看。该项目最近被Luke Daley接管，他是Groovy世界中的主要人物，所以我期待很快会有显著的改进。
- en: 9.6.3\. Grails and REST
  id: totrans-923
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.3\. Grails 和 REST
- en: 'Finally, Grails has REST capabilities as well. For example, in a Grails application
    you can edit the `URLMappings.groovy` file as follows:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Grails也有REST功能。例如，在一个Grails应用程序中，你可以按照以下方式编辑`URLMappings.groovy`文件：
- en: '[PRE116]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The result is that GET, POST, PUT, and DELETE requests for products will be
    directed to the `show`, `save`, `update`, and `delete` actions in the `ProductController`,
    respectively. Grails also automatically parses and generates XML and/or JSON,
    as desired.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，对于产品的GET、POST、PUT和DELETE请求将分别被导向`ProductController`中的`show`、`save`、`update`和`delete`操作。Grails还可以自动解析和生成所需的XML和/或JSON。
- en: There’s also a JAX-RS plugin available for Grails. At the moment it’s based
    on JAX-RS version 1, but the implementation can use either the Jersey reference
    implementation or Restlets. Of course, once again, nothing is said about hypermedia
    in either case, though anything you can do in Groovy you can, of course, do in
    Grails as well.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Grails，还有一个可用的JAX-RS插件。目前它基于JAX-RS版本1，但实现可以使用Jersey参考实现或Restlets。当然，在两种情况下都没有提到超媒体，尽管你可以在Groovy中做的任何事情，当然也可以在Grails中做。
- en: REST capabilities are a major design goal of Grails 3.0, so by then the situation
    will no doubt change.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: REST功能是Grails 3.0的主要设计目标，因此到那时情况无疑会发生变化。
- en: 9.7\. Summary
  id: totrans-929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7\. 总结
- en: The topic of RESTful web services is very hot these days, for good reason. The
    REST architecture enables developers to build flexible, highly decoupled applications
    that take advantage of the same features that made the web itself so successful.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，RESTful Web服务的主题非常热门，这是有充分理由的。REST架构使开发者能够构建灵活、高度解耦的应用程序，这些应用程序利用了使Web本身如此成功的相同特性。
- en: In the Java world many libraries are available for implementing the REST architecture.
    This chapter focused on the JAX-RS 2.0 specification and how Groovy can be used
    with it. In addition to the basic URL-driven database, hypermedia can be implemented
    using transitional links in the HTTP headers, structural links in the entity bodies,
    or even through a Groovy `JsonBuilder`. Hopefully some combination of techniques
    in this chapter will enable you to build the service you want.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java世界中，有许多库可用于实现REST架构。本章重点介绍了JAX-RS 2.0规范以及Groovy如何与之结合使用。除了基本的URL驱动数据库之外，还可以通过HTTP头中的过渡链接、实体体内的结构链接，甚至通过Groovy的`JsonBuilder`来实现超媒体。希望本章中的一些技术组合能够帮助你构建你想要的服务。
- en: Chapter 10\. Building and testing web applications
  id: totrans-932
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 构建和测试Web应用程序
- en: '*This chapter covers*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Groovy servlets and `ServletCategory`
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy servlets 和 `ServletCategory`
- en: Groovlets
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovlets
- en: Unit and integration testing of web apps
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用的单元和集成测试
- en: The Groovy killer app, Grails
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Groovy杀手级应用，Grails
- en: While Java on the desktop has its adherents, Java found a true home on the server
    side. Java’s growth and adoption in the early days neatly follow that of the web
    itself. It’s a rare Java developer who hasn’t at least worked on a web application.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java在桌面上有其支持者，但Java在服务器端找到了真正的归宿。Java在早期的发展和采用与Web本身的发展紧密相连。很少有Java开发者没有至少参与过一个Web应用程序的开发。
- en: In this chapter I’m going to look at modern web application development and
    where Groovy can make the process simpler and easier. Sometimes Groovy just simplifies
    the code. Other times it provides helpful testing tools, like Gradle and HTTPBuilder.
    Finally, there’s the most famous framework in the Groovy ecosystem, Grails. I’ll
    review them all and try to place them in the overall context of web applications.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将探讨现代 Web 应用程序开发以及 Groovy 如何使这个过程更加简单和容易。有时 Groovy 只是简化了代码。有时它提供了有用的测试工具，如
    Gradle 和 HTTPBuilder。最后，还有 Groovy 生态系统中最著名的框架 Grails。我将回顾它们所有，并尝试将它们放在 Web 应用程序的整体环境中。
- en: '[Figure 10.1](#ch10fig01) is a guide to the technologies discussed in this
    chapter.'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1](#ch10fig01) 是本章讨论的技术指南。'
- en: Figure 10.1\. Guide to the technologies in this chapter. Spring provides mock
    objects for testing that are also used in Grails. Using plugins and some configuration,
    Gradle builds can do integration testing of web applications. The `ServletCategory`
    class makes session, request, and other objects easier to use. Groovlets are a
    quick way to build simple applications. Finally, the HTTPBuilder project provides
    a programmatic web client, and Grails applications use Groovy DSLs and elegant
    metaprogramming to combine Spring and Hibernate in a standard convention-over-configuration
    framework.
  id: totrans-941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1。本章技术指南。Spring 提供了用于测试的模拟对象，这些对象也用于 Grails。使用插件和一些配置，Gradle 构建可以执行 Web
    应用的集成测试。`ServletCategory` 类使会话、请求和其他对象更容易使用。Groovlets 是构建简单应用的一种快速方式。最后，HTTPBuilder
    项目提供了一个程序性 Web 客户端，Grails 应用程序使用 Groovy DSL 和优雅的元编程将 Spring 和 Hibernate 结合到一个标准的约定优于配置框架中。
- en: '![](10fig01.jpg)'
  id: totrans-942
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig01.jpg)'
- en: 10.1\. Groovy servlets and ServletCategory
  id: totrans-943
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1。Groovy servlets 和 ServletCategory
- en: Groovy doesn’t add a lot to basic servlet development, but the standard library
    does provide a category class that illustrates what Groovy’s metaprogramming can
    do. The following listing shows a trivial servlet, `HelloGroovyServlet.groovy`,
    part of a web application implemented in Groovy.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 并没有为基本的 servlet 开发添加很多功能，但标准库确实提供了一个类别类，展示了 Groovy 的元编程能力。以下列表显示了一个简单的
    servlet，`HelloGroovyServlet.groovy`，这是使用 Groovy 实现的 Web 应用程序的一部分。
- en: Listing 10.1\. A simple servlet implemented in Groovy
  id: totrans-945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1。使用 Groovy 实现的简单 servlet
- en: '[PRE117]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Other than the normal Groovy simplifications (omitting the word `public`, lack
    of semicolons, use of `writer` rather than `getWriter()`, and the optional parentheses
    on `print`), this isn’t much different from a Java implementation. Use Groovy
    if you prefer the slightly shorter code, but really the choice of language is
    a matter of style.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常的 Groovy 简化（省略 `public` 关键字，缺少分号，使用 `writer` 而不是 `getWriter()`，以及 `print`
    上的可选括号）之外，这与 Java 实现并没有太大的不同。如果你更喜欢稍微简短的代码，可以使用 Groovy，但真正选择语言的问题是一个风格问题。
- en: What Groovy does provide is a category class to simplify the code even further.
    Category classes are an example of Groovy’s metaprogramming capabilities. They
    show how to add methods to existing classes in a specified block of code, unlike
    using the metaclass object to add them everywhere in your program. If you ever
    wanted to understand categories, `ServletCategory` is a great, extremely simple,
    useful example.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 提供的是一种类别类，可以进一步简化代码。类别类是 Groovy 元编程能力的一个例子。它们展示了如何在指定的代码块中向现有类添加方法，而不是像使用元类对象那样在程序中的任何地方添加它们。如果你曾经想了解类别，`ServletCategory`
    是一个极好、极其简单、非常有用的例子。
- en: '|  |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Categories
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类别
- en: Use a Groovy category to add methods to existing classes when you only need
    those methods under specific circumstances. Category methods are only available
    in a `use` block.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只需要在特定情况下使用那些方法时，使用 Groovy 类别向现有类添加方法。类别方法仅在 `use` 块中可用。
- en: '|  |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 10.2](#ch10fig02) shows a sample of the GroovyDocs for the `groovy.servlet.Servlet-Category`
    class.'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2](#ch10fig02) 展示了 `groovy.servlet.Servlet-Category` 类的 GroovyDocs 示例。'
- en: Figure 10.2\. The GroovyDocs for `ServletCategory`. Each method is static and
    is added to the class listed in the first argument.
  id: totrans-954
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2。`ServletCategory` 的 GroovyDocs。每个方法都是静态的，并添加到第一个参数中列出的类。
- en: '![](10fig02_alt.jpg)'
  id: totrans-955
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig02_alt.jpg)'
- en: A Groovy category consists of static methods having one or more arguments. The
    first argument to the method is the class that receives the method. In `Servlet-Category`
    there are only four methods, with lots of overloads (see [table 10.1](#ch10table01)).
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Groovy 类别由一个或多个参数的静态方法组成。方法的第一参数是接收该方法的类。在 `Servlet-Category` 中只有四个方法，有很多重载（见
    [表 10.1](#ch10table01)）。
- en: Table 10.1\. The `ServletCategory` methods for different scopes
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 10.1. 不同作用域的 `ServletCategory` 方法
- en: '| Method Name | First Argument |'
  id: totrans-958
  prefs: []
  type: TYPE_TB
  zh: '| 方法名称 | 第一个参数 |'
- en: '| --- | --- |'
  id: totrans-959
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| get(arg, String key) | ServletContext, HttpSession, ServletRequest, PageContext
    |'
  id: totrans-960
  prefs: []
  type: TYPE_TB
  zh: '| get(arg, String key) | ServletContext, HttpSession, ServletRequest, PageContext
    |'
- en: '| getAt(arg, String key) | Same as above |'
  id: totrans-961
  prefs: []
  type: TYPE_TB
  zh: '| getAt(arg, String key) | 与上面相同 |'
- en: '| putAt(arg, String key, Object value) | Same as above |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '| putAt(arg, String key, Object value) | 与上面相同 |'
- en: '| set(arg, String key, Object value) | Same as above |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
  zh: '| set(arg, String key, Object value) | 与上面相同 |'
- en: See a pattern? The job of this category is to make it easy to add attributes
    at page scope (`PageContext`), request scope (`ServletRequest`), session scope
    (`HttpSession`), and application scope (`ServletContext`). Remember that in Groovy
    all operators correspond to methods. In this case, the `get` and `set` methods
    correspond to the dot operator, and the `getAt` and `putAt` methods implement
    the array subscript operator. Before I show an example, take a look at a portion
    of the actual implementation class, `groovy.servlet.ServletCategory`, in the following
    listing, implemented in Java.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了模式吗？这个分类的任务是使在页面作用域（`PageContext`）、请求作用域（`ServletRequest`）、会话作用域（`HttpSession`）和应用作用域（`ServletContext`）中添加属性变得容易。记住，在
    Groovy 中，所有操作符都对应于方法。在这种情况下，`get` 和 `set` 方法对应于点操作符，而 `getAt` 和 `putAt` 方法实现了数组索引操作符。在我展示示例之前，请看一下实际实现类
    `groovy.servlet.ServletCategory` 的以下部分，它是在 Java 中实现的。
- en: Listing 10.2\. Methods for `HttpSession` from `groovy.servlet.ServletCategory`
  id: totrans-965
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2. 来自 `groovy.servlet.ServletCategory` 的 `HttpSession` 方法
- en: '[PRE118]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The first interesting thing to note is that this class is written in Java (!),
    even though it’s being used in Groovy. When overloading operators, Groovy doesn’t
    care which language you use to implement the methods, only that you use the operators
    that delegate to the methods in Groovy. In this case, I don’t even plan to use
    the methods directly. Instead, I’m using the dot operator and/or the array subscript
    notation to invoke them implicitly.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 首先值得注意的是，这个类是用 Java 编写的 (!)，尽管它是在 Groovy 中使用的。当重载操作符时，Groovy 不关心你使用哪种语言来实现方法，只关心你使用的是否是委托给
    Groovy 中方法的操作符。在这种情况下，我甚至不打算直接使用这些方法。相反，我使用点操作符和/或数组索引表示法来隐式调用它们。
- en: The other important detail here is that all the methods are delegating to either
    the `getAttribute` or `setAttribute` method. The effect is that either the dot
    operator or the subscript operator can be used to add attributes to the page,
    request, session, or application scope.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 这里另一个重要的细节是，所有方法都是委托给 `getAttribute` 或 `setAttribute` 方法。结果是，可以使用点操作符或索引操作符将属性添加到页面、请求、会话或应用作用域。
- en: '|  |'
  id: totrans-969
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: ServletCategory
  id: totrans-970
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ServletCategory
- en: Whether you use `ServletCategory` or not, its combination of metaprogramming
    and operator overloading make it an excellent example of how Groovy helps Java.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否使用 `ServletCategory`，它的元编程和操作符重载的结合使其成为 Groovy 如何帮助 Java 的一个优秀示例。
- en: '|  |'
  id: totrans-972
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Categories in Groovy 2.0**'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '**Groovy 2.0 中的分类**'
- en: Groovy 2.0 introduced an alternative syntax for defining categories. In the
    `ServletCategory` discussed in this section, the category class contains static
    methods whose first argument is the class being modified. In the new notation
    you can use annotations and instance methods instead.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 2.0 引入了一种用于定义分类的替代语法。在本节中讨论的 `ServletCategory` 中，分类类包含静态方法，其第一个参数是要修改的类。在新语法中，你可以使用注解和实例方法。
- en: As an example, consider formatting numbers as currency. The j`ava.text.NumberFormat`
    class has a method called `getCurrencyInstance`, which has both a no-arg method
    that formats for the current locale and an overloaded version that takes a `java.util.Locale`
    argument. The classic way to add an `asCurrency` method to `Number` that employs
    the currency formatter is
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑将数字格式化为货币。`java.text.NumberFormat` 类有一个名为 `getCurrencyInstance` 的方法，它有一个无参数方法用于格式化当前区域设置，还有一个重载版本，它接受一个
    `java.util.Locale` 参数。向 `Number` 类添加一个 `asCurrency` 方法，并使用货币格式化器，经典的方式如下
- en: '[PRE119]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The new way to implement a category uses the `@Category` annotation, which takes
    the class to be modified as an argument. Then instance methods are used inside
    the category, and the `this` reference refers to the object where the category
    is invoked. The analogous implementation for the currency category is
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 实现分类的新方法使用 `@Category` 注解，它接受要修改的类作为参数。然后在分类内部使用实例方法，`this` 引用指向分类被调用的对象。货币分类的类似实现如下
- en: '[PRE120]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note also the use of the `mixin` method to add the category to the `Number`
    class.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意使用 `mixin` 方法将类别添加到 `Number` 类。
- en: Presumably, if the `ServletCategory` was being implemented now, it would use
    the annotation approach. The result is the same either way, of course.^([[1](#ch10fn01)])
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在正在实现 `ServletCategory`，它可能会使用注解方法。当然，无论哪种方式，结果都是相同的.^([[1](#ch10fn01)])
- en: ¹ The book source code includes the two ways of doing the currency category
    as well as a test case.
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 书籍源代码包括两种实现货币类别的方法以及一个测试用例。
- en: '|  |'
  id: totrans-983
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: An example will make this clear. The next listing shows a class called `HelloName-Servlet`,
    implemented in Groovy, which receives a `name` parameter and replies with the
    standard welcome.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将举例说明。下一列表展示了一个名为 `HelloName-Servlet` 的类，它使用 Groovy 实现，接收一个 `name` 参数，并返回标准的欢迎信息。
- en: Listing 10.3\. The `HelloNameServlet` class, which uses the `ServletCategory`
  id: totrans-985
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.3. 使用 `ServletCategory` 的 `HelloNameServlet` 类
- en: '![](262fig01_alt.jpg)'
  id: totrans-986
  prefs: []
  type: TYPE_IMG
  zh: '![](262fig01_alt.jpg)'
- en: This class works with attributes in both the request and the session. After
    getting the session from the request (which is standard “property access means
    get method” style, not the category), the `use` block defines the region where
    the category is active. Inside the `use` block, a `name` attribute is added to
    the `request` using the dot notation, whose value is either supplied by the user
    in the form of a parameter, or consists of the default value `World`. Next, a
    `count` attribute is placed in the session; its value is either incremented from
    its existing value or set to `1` if it doesn’t already exist.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类同时与请求和会话中的属性一起工作。在从请求中获取会话（这是标准的“属性访问意味着获取方法”风格，而不是类别）之后，`use` 块定义了类别活跃的区域。在
    `use` 块内部，使用点符号向 `request` 添加了一个 `name` 属性，其值要么由用户以参数的形式提供，要么由默认值 `World` 组成。接下来，在会话中放置一个
    `count` 属性；其值要么从现有值中递增，要么如果它不存在，则设置为 `1`。
- en: The test class, `HelloNameServletTest`, is shown in the next listing. It uses
    the Spring API mock objects to test the `doGet` method both with and without a
    supplied name.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类 `HelloNameServletTest` 在下一列表中展示。它使用 Spring API 模拟对象来测试 `doGet` 方法，无论是带参数还是不带参数。
- en: Listing 10.4\. The `HelloNameServletTest` class, which uses Spring’s mock objects
  id: totrans-989
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4. 使用 Spring 模拟对象的 `HelloNameServletTest` 类
- en: '[PRE121]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The `ServletCategory` isn’t needed in the tests, because I’m already using mock
    objects rather than the Servlet API classes. Note that the tests check both the
    `request` and `session` attributes and the forwarded URL from the `doGet` method.
    The `Servlet-``Category` class is a simple example of how to use Groovy’s metaprogramming
    capabilities to simplify an API.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中不需要 `ServletCategory`，因为我已经使用模拟对象而不是 Servlet API 类。请注意，测试检查了 `request` 和
    `session` 属性以及从 `doGet` 方法转发的 URL。`Servlet-``Category` 类是使用 Groovy 的元编程能力简化 API
    的简单示例。
- en: As a simple alternative to normal servlet development, Groovy provides groovlets.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 作为正常 servlet 开发的简单替代方案，Groovy 提供了 groovlets。
- en: 10.2\. Easy server-side development with groovlets
  id: totrans-993
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 使用 groovlets 进行简单的服务器端开发
- en: Groovlets are groovy scripts that are executed in response to HTTP requests.
    A built-in library class called `groovy.servlet.GroovyServlet` executes them.
    Like all Groovy scripts, they’re associated with a binding that holds many pre-instantiated
    variables.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: Groovlets 是响应 HTTP 请求执行的 Groovy 脚本。一个内置的库类 `groovy.servlet.GroovyServlet` 执行它们。像所有
    Groovy 脚本一样，它们与一个绑定相关联，该绑定包含许多预实例化的变量。
- en: 'To use a groovlet, first configure the `GroovyServlet` to receive mapped requests.
    A typical way of doing so is to add the following XML to the standard web application
    deployment descriptor, web.xml:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 groovlet，首先配置 `GroovyServlet` 以接收映射的请求。这样做的一种典型方式是将以下 XML 添加到标准的 Web 应用程序部署描述符
    web.xml 中：
- en: '[PRE122]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `GroovyServlet` class is part of the standard Groovy library. Here it’s
    mapped to the URL pattern `*.groovy`, which means that any URL that ends in that
    pattern will be directed to this servlet. For example, the URL http://localhost/.../hello.groovy
    would match a script named `hello.groovy` in the root of the web application.
    Keep in mind that this is literally the source file, not the compiled class.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroovyServlet` 类是标准 Groovy 库的一部分。在这里，它被映射到 URL 模式 `*.groovy`，这意味着任何以该模式结尾的
    URL 都将被导向这个 servlet。例如，URL http://localhost/.../hello.groovy 将匹配到 Web 应用程序根目录下的名为
    `hello.groovy` 的脚本。请记住，这实际上是源文件，而不是编译后的类。'
- en: '|  |'
  id: totrans-998
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Groovlets
  id: totrans-999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Groovlets
- en: Groovlets are deployed as source code, not compiled.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: Groovlets 以源代码的形式部署，而不是编译。
- en: '|  |'
  id: totrans-1001
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: When invoked, the `GroovyServlet` class finds the script whose name ends the
    URL, pre-instantiates a series of variables, creates an instance of the `GroovyScriptEngine`
    class, and executes the script. The actual script code can be placed in any accessible
    directory from the web application root, or in any subdirectory of /WEB-INF/groovy.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，`GroovyServlet`类找到以URL结尾的脚本名称，预先实例化一系列变量，创建`GroovyScriptEngine`类的一个实例，并执行脚本。实际的脚本代码可以放置在Web应用根目录下的任何可访问目录中，或者放置在/WEB-INF/groovy的任何子目录中。
- en: The key to the simplicity of groovlets is this already-configured infrastructure.
    With this in place a developer has a lot less work to do.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: groovlet简单性的关键是这个已经配置好的基础设施。有了这个，开发者需要做的工作就少多了。
- en: 10.2.1\. A “Hello, World!” groovlet
  id: totrans-1004
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 一个“Hello, World!” groovlet
- en: Because every technology needs a “Hello, World!” application, here’s a groovlet
    to greet the user. Assume that the `GroovyServlet` has already been configured,
    and add a file called `hello.groovy` in the root of a web application. In a standard
    Maven structure that would be src/main/webapp/hello.groovy. The contents of the
    groovlet are
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每种技术都需要一个“Hello, World!”应用程序，所以这里有一个用于问候用户的groovlet。假设`GroovyServlet`已经配置好了，并在Web应用的根目录下添加一个名为`hello.groovy`的文件。在一个标准的Maven结构中，这将是src/main/webapp/hello.groovy。groovlet的内容如下
- en: '[PRE123]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: It’s a simple groovlet, but it should still be tested. Integration-testing of
    web applications is discussed later in this chapter, but the syntax in the next
    listing uses the same mechanism for transmitting a GET request (use the Groovy
    JDK to convert a string to a `URL` and then call URL’s `getText` method) that
    was used in several earlier chapters.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的groovlet，但它仍然应该被测试。本章后面将讨论Web应用的集成测试，但下一个列表中的语法使用的是与前面几个章节中相同的机制来传输GET请求（使用Groovy
    JDK将字符串转换为`URL`，然后调用URL的`getText`方法）。
- en: Listing 10.5\. `HelloGroovletTest`, an integration test for the `hello` groovlet
  id: totrans-1008
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5\. `HelloGroovletTest`，`hello` groovlet的集成测试
- en: '[PRE124]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: There’s nothing particularly surprising or unusual about this test, which is
    simple because the groovlet only responds to GET requests.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试没有什么特别令人惊讶或不寻常的地方，因为它很简单，因为groovlet只响应GET请求。
- en: Unit tests are also doable, based on the fact that the `GroovyServlet` is executing
    the groovlet as a script with predefined variables. For example, the next listing
    shows a unit test for the groovlet that uses an instance of the `GroovyShell`
    class and the `Bind``ing` class in a manner similar to that described in [chapter
    6](kindle_split_017.html#ch06) on testing.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`GroovyServlet`将groovlet作为具有预定义变量的脚本执行的事实，单元测试也是可以完成的。例如，下一个列表显示了使用`GroovyShell`类和`Binding`类进行单元测试的groovlet，其方式类似于在第6章（kindle_split_017.html#ch06）中描述的测试。
- en: Listing 10.6\. A unit test for the groovlet using `GroovyShell` and `Binding`
  id: totrans-1012
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. 使用`GroovyShell`和`Binding`对groovlet进行的单元测试
- en: '![](265fig01_alt.jpg)'
  id: totrans-1013
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](265fig01_alt.jpg)'
- en: The interesting parts of this test are first that the groovlet expects a map
    of input parameters, so the test has to provide one, and that I need a way to
    capture the output stream from the groovlet, which is done through the `out` variable
    of the binding.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的有趣之处首先在于groovlet期望一个输入参数的映射，因此测试必须提供一个，并且我需要一种方法来捕获groovlet的输出流，这通过绑定中的`out`变量来完成。
- en: Recall from [chapter 6](kindle_split_017.html#ch06) that Groovy also provides
    a subclass of `GroovyTestCase`, called `GroovyShellTestCase`, which is designed
    to test scripts like this. The following listing shows the same unit test using
    `GroovyShellTestCase`. Note that it’s noticeably simpler.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第6章](kindle_split_017.html#ch06)，Groovy还提供了一个名为`GroovyTestCase`的子类，称为`GroovyShellTestCase`，它被设计用来测试此类脚本。下面的列表显示了使用`GroovyShellTestCase`的相同单元测试。请注意，它明显更简单。
- en: Listing 10.7\. Using `GroovyShellTestCase` to simplify unit-testing groovlets
  id: totrans-1016
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. 使用`GroovyShellTestCase`简化groovlet的单元测试
- en: '![](265fig02_alt.jpg)'
  id: totrans-1017
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](265fig02_alt.jpg)'
- en: The `GroovyShellTestCase` class instantiates a `GroovyShell` internally and
    allows you to pass a map of binding parameters through the `withBinding` method.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroovyShellTestCase` 类内部实例化一个 `GroovyShell` 并允许你通过 `withBinding` 方法传递一个绑定参数的映射。'
- en: 10.2.2\. Implicit variables in groovlets
  id: totrans-1019
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. groovlet中的隐含变量
- en: The previous example shows that groovlets expect that all the request parameters
    are bundled into a map called `params`. Groovlets operate in an environment containing
    many implicit variables. [Table 10.2](#ch10table02) shows the complete list.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子显示groovlets期望所有请求参数都被打包到一个名为`params`的映射中。Groovlets在一个包含许多隐含变量的环境中运行。[表10.2](#ch10table02)显示了完整的列表。
- en: Table 10.2\. Implicit variables available in groovlets
  id: totrans-1021
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.2. Groovlets中可用的隐式变量
- en: '| Variable | Represents | Notes |'
  id: totrans-1022
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 代表 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-1023
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| request | ServletRequest |   |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
  zh: '| request | ServletRequest |   |'
- en: '| response | ServletResponse |   |'
  id: totrans-1025
  prefs: []
  type: TYPE_TB
  zh: '| response | ServletResponse |   |'
- en: '| session | getSession(false) | May be null |'
  id: totrans-1026
  prefs: []
  type: TYPE_TB
  zh: '| session | getSession(false) | 可能为null |'
- en: '| context | ServletContext |   |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
  zh: '| context | ServletContext |   |'
- en: '| application | ServletContext (same as context) |   |'
  id: totrans-1028
  prefs: []
  type: TYPE_TB
  zh: '| application | ServletContext (与context相同) |   |'
- en: '| params |   | Map of request parameters |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
  zh: '| params |   | 请求参数映射 |'
- en: '| headers |   | Map of request/response headers |'
  id: totrans-1030
  prefs: []
  type: TYPE_TB
  zh: '| headers |   | 请求/响应头映射 |'
- en: '| out | response.getWriter() |   |'
  id: totrans-1031
  prefs: []
  type: TYPE_TB
  zh: '| out | response.getWriter() |   |'
- en: '| sout | response.getOutputStream() |   |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '| sout | response.getOutputStream() |   |'
- en: '| html | new MarkupBuilder(out) |   |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
  zh: '| html | new MarkupBuilder(out) |   |'
- en: The previous example used only the `params` variable. Now I’ll discuss a slightly
    more elaborate example, which was used in the Groovy Baseball application first
    presented in [chapter 2](kindle_split_012.html#ch02).
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子只使用了`params`变量。现在我将讨论一个稍微复杂一点的例子，这个例子首先在[第2章](kindle_split_012.html#ch02)中介绍的Groovy
    Baseball应用程序中使用。
- en: The following listing shows the complete source.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了完整的源代码。
- en: Listing 10.8\. The `GameService` groovlet from the Groovy Baseball application
  id: totrans-1036
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8. Groovy Baseball应用程序中的`GameService` groovlet
- en: '![](267fig01_alt.jpg)'
  id: totrans-1037
  prefs: []
  type: TYPE_IMG
  zh: '![](267fig01_alt.jpg)'
- en: The goal of the `GameService` groovlet is to get the date provided by the user
    interface, invoke the `getGames` method in the `GetGameData` service, and provide
    the results to the user in XML form. The groovlet sets the `contentType` header
    in the response to XML, retrieves the input parameters representing the requested
    date, normalizes them to the proper form if necessary, calls the game service,
    and uses the built-in markup builder to write out the game results as a block
    of XML.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameService` groovlet的目标是获取用户界面提供的日期，调用`GetGameData`服务中的`getGames`方法，并将结果以XML形式提供给用户。groovlet在响应中设置`contentType`头为XML，检索表示请求日期的输入参数，如果需要则将它们规范化到适当的形式，调用游戏服务，并使用内置的标记构建器将游戏结果写入XML块。'
- en: 'Using the markup builder to write out XML is helpful here. One of the problems
    faced by current web applications is that JavaScript code used in the user interface
    can’t parse the Java or Groovy objects produced by the server side. An intermediate
    format is needed that both sides can interpret and generate. There are only two
    realistic options for that: XML and JavaScript Object Notation (JSON). The recent
    trend has been to use JSON objects as much as possible, but the markup builder
    inside groovlets makes it easy to produce XML instead. The amount of XML generated
    by this application is minimal, so it’s not a problem to parse-in the user interface.'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标记构建器来写入XML在这里很有帮助。当前Web应用面临的一个问题是用户界面中使用的JavaScript代码无法解析服务器端产生的Java或Groovy对象。需要一个中间格式，双方都可以解释和生成。为此，只有两个现实的选择：XML和JavaScript对象表示法（JSON）。最近的趋势是尽可能多地使用JSON对象，但groovlets内部的标记构建器使得生成XML变得容易。该应用程序生成的XML量很少，所以解析用户界面中的XML不是问题。
- en: '|  |'
  id: totrans-1040
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Producing XML
  id: totrans-1041
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成XML
- en: Use the `html` markup builder in groovlets to write out XML when needed, not
    to produce a web page in HTML.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要时使用groovlets中的`html`标记构建器来写入XML，而不是生成HTML网页。
- en: '|  |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This demonstration is simple, but that’s the point. Groovlets are a convenient
    way to receive input data, access back-end services, and produce responses or
    forward the user to a new destination. Because they have a built-in way to convert
    objects into XML (and it wouldn’t be hard to add a `JsonBuilder` to convert to
    JSON instead^([[2](#ch10fn02)])), they’re ideal as a front-end for RESTful web
    services.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示很简单，但这就是重点。Groovlets是一种方便的方式，可以接收输入数据，访问后端服务，并生成响应或将用户转发到新的目的地。因为它们有一个内置的方式将对象转换为XML（并且添加一个`JsonBuilder`以转换为JSON也不难^([[2](#ch10fn02)]))，所以它们是RESTful
    Web服务的理想前端。
- en: ² In fact, I helped do exactly that. That’s open source for you; if you get
    an idea, go do it.
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 事实上，我确实帮了那个忙。这就是开源的魅力；如果你有想法，就去实现它。
- en: '|  |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (groovlets)**'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习到的经验（groovlets）**'
- en: Groovlets are Groovy scripts executed by an embedded servlet.
  id: totrans-1048
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovlets是由嵌入式servlet执行的Groovy脚本。
- en: Groovlets contain implicit objects for request parameters, the HTTP session,
    and more.
  id: totrans-1049
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovlets包含请求参数、HTTP会话等隐式对象。
- en: Groovlets use builders to generate formatted output.
  id: totrans-1050
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Groovlets使用构建器来生成格式化的输出。
- en: '|  |'
  id: totrans-1051
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Before demonstrating the Grails framework, let me now discuss the issue of testing
    web applications, both in isolation as unit tests and automated integration tests
    using Gradle.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示 Grails 框架之前，现在让我讨论一下测试 Web 应用程序的问题，包括作为单元测试的独立测试和利用 Gradle 自动化的集成测试。
- en: 10.3\. Unit-and integration-testing web components
  id: totrans-1053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3. 单元测试和集成测试 Web 组件
- en: '[Chapter 6](kindle_split_017.html#ch06) discussed techniques for unit-testing
    Java and Groovy classes and demonstrated how Groovy’s mock capabilities provide
    a standard library of mocks and stubs to support unit tests. It’s easy to test
    individual classes and to run those tests automatically as part of a build process.'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6 章](kindle_split_017.html#ch06)讨论了单元测试 Java 和 Groovy 类的技术，并展示了 Groovy 的模拟能力如何提供一套标准库的模拟和存根来支持单元测试。测试单个类以及将这些测试作为构建过程的一部分自动运行是非常容易的。'
- en: Testing is so important that most modern web frameworks consider testability
    a major design goal, so they try to make the individual components easy to test.
    For example, one of the major differences between the original Struts framework
    and the more modern Struts 2, Spring MVC, JSF, or any of a number of others is
    how their parts are designed with testing in mind. Despite this, testing of web
    components is far less pervasive than you might expect.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 测试如此重要，以至于大多数现代 Web 框架都将可测试性视为一个主要的设计目标，因此它们试图使各个组件易于测试。例如，原始 Struts 框架与更现代的
    Struts 2、Spring MVC、JSF 或其他许多框架之间的一个主要区别是它们的组件是如何考虑测试而设计的。尽管如此，Web 组件的测试程度远不如预期。
- en: Still, unit-testing and integration-testing web applications is as important
    as testing anything else in the system, and doing so automatically is critical.
    Integration-testing a web application by making a tester manually enter data in
    forms and click links is an extremely expensive and error-prone mechanism. There
    has to be a better way, and fortunately Groovy helps a lot in that area.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，单元测试和集成测试 Web 应用程序与测试系统中的任何其他内容一样重要，并且自动执行这些测试是至关重要的。通过手动在表单中输入数据并点击链接来集成测试
    Web 应用程序是一种极其昂贵且容易出错的机制。必须有一种更好的方法，幸运的是 Groovy 在这个领域提供了大量帮助。
- en: To lay the foundation, however, I’ll begin with a library of mock classes that
    comes from one of the biggest Java libraries of them all, the Spring framework.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了打下基础，我将从 Spring 框架中最大的 Java 库之一提供的模拟类库开始。
- en: 10.3.1\. Unit-testing servlets with Spring
  id: totrans-1058
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1. 使用 Spring 单元测试 Servlet
- en: 'The Spring framework is one of the most popular open source libraries in the
    Java world. [Chapter 7](kindle_split_019.html#ch07) on Groovy and Spring discusses
    it in some detail, but I want to use it here for two reasons: (1) Spring provides
    a great collection of mock objects for unit-testing web applications, and (2)
    Spring is one of the underlying technologies for Grails, so knowing more about
    how Spring works helps you use Grails more effectively.'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架是 Java 世界中最受欢迎的开源库之一。[第 7 章](kindle_split_019.html#ch07)关于 Groovy 和
    Spring 的讨论中对其进行了详细阐述，但我在这里想要提及它有两个原因：(1) Spring 为单元测试 Web 应用程序提供了一套优秀的模拟对象，(2)
    Spring 是 Grails 的底层技术之一，因此了解 Spring 的工作原理有助于你更有效地使用 Grails。
- en: 'To illustrate the challenge and highlight the dependencies that need to be
    mocked during testing, let me start with a simple servlet class, written in Java,
    called `HelloServlet`:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明挑战并突出测试过程中需要模拟的依赖关系，让我从一个简单的名为 `HelloServlet` 的 Java Servlet 类开始，以展示其结构：
- en: '[PRE125]'
  id: totrans-1061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Servlets are all created by inheritance, normally by extending `javax.servlet.http`
    `.HttpServlet`. `HttpServlet` is an abstract class with no abstract methods. It
    receives HTTP requests and delegates them to a `do` method corresponding to each
    HTTP verb, like `doGet`, `doPost`, `doPut`, `doTrace`, or `doOptions`. Each of
    these methods takes two arguments, one of type `HttpServletRequest` and one of
    type `HttpServletResponse`.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: Servlets 都是通过继承创建的，通常是通过扩展 `javax.servlet.http.HttpServlet`。`HttpServlet` 是一个没有抽象方法的抽象类。它接收
    HTTP 请求并将它们委托给对应于每个 HTTP 动词的 `do` 方法，如 `doGet`、`doPost`、`doPut`、`doTrace` 或 `doOptions`。这些方法都接受两个参数，一个是
    `HttpServletRequest` 类型，另一个是 `HttpServletResponse` 类型。
- en: The `HelloServlet` class overrides the `doGet` method to respond to HTTP GET
    requests. It uses the `resp` argument (an instance of `HttpServletResponse`) to
    get the associated output writer, which is used to print to the output stream.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '`HelloServlet` 类重写了 `doGet` 方法以响应 HTTP GET 请求。它使用 `resp` 参数（`HttpServletResponse`
    的一个实例）来获取相关的输出写入器，该写入器用于向输出流打印。'
- en: 'Even in a class this simple, it’s apparent that unit testing is going to be
    a challenge. As a reminder of what unit testing is all about, let me say this:'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个简单的类中，单元测试的挑战性也是显而易见的。为了提醒大家单元测试的要点，让我说：
- en: '|  |'
  id: totrans-1065
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Unit-Testing Web Components
  id: totrans-1066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单元测试Web组件
- en: The goal of unit-testing web applications is to run tests outside of a container.
    This requires mock objects for all the container-provided classes and services.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试Web应用程序的目的是在容器外运行测试。这需要所有由容器提供的类和服务的模拟对象。
- en: '|  |'
  id: totrans-1068
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this case I need objects representing the two arguments of type `HttpServlet-Request`
    and `HttpServletResponse`. In most cases I’ll also need objects representing `HttpSession`,
    `ServletContext`, and possibly more.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我需要代表类型为`HttpServlet-Request`和`HttpServletResponse`的两个对象。在大多数情况下，我还需要代表`HttpSession`、`ServletContext`，以及可能还有更多的对象。
- en: This is where the set of mock classes from the Spring framework helps. The Spring
    API includes a package called `org.springframework.mock.web` that, as described
    in the API, contains “a comprehensive set of Servlet API 2.5^([[3](#ch10fn03)])
    mock objects, targeted at usage with Spring’s web MVC framework.” Fortunately
    they can be used with any web application, whether it’s based on Spring MVC or
    not.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 正是Spring框架中的模拟类集合提供了帮助。Spring API包括一个名为`org.springframework.mock.web`的包，正如API中所述，它包含“一套全面的Servlet
    API 2.5模拟对象，旨在与Spring的Web MVC框架一起使用。”幸运的是，它们可以与任何Web应用程序一起使用，无论它是否基于Spring MVC。
- en: ³ The mock objects work for Servlet 3.0 as well, with some minor exceptions
    listed in the JavaDocs.
  id: totrans-1071
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 模拟对象在Servlet 3.0中同样适用，尽管JavaDocs中列出了少数例外。
- en: The next listing shows a JUnit test for the `doGet` method of my “Hello, World!”
    servlet.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了对我“Hello, World!” servlet的`doGet`方法的JUnit测试。
- en: 'Listing 10.9\. `HelloServletJavaTest`: a servlet test class using mock objects'
  id: totrans-1073
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.9\. `HelloServletJavaTest`：使用模拟对象的servlet测试类
- en: '[PRE126]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The `try/catch` blocks do their best to bury the essence in ceremony, but the
    intent is clear. The method instantiates the servlet and mock objects representing
    the servlet request and servlet response classes, and then it invokes the `doGet`
    method on the servlet with the mocks as arguments. The good part is that the `MockHttpServletResponse`
    class has a method called `getContentAsString`, which captures the data written
    to the output writer in the servlet so it can be compared to the expected answer.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '`try/catch`块尽力将本质隐藏在仪式之中，但意图是清晰的。该方法实例化了servlet以及代表servlet请求和servlet响应类的模拟对象，然后使用模拟对象作为参数在servlet上调用`doGet`方法。好事是`MockHttpServletResponse`类有一个名为`getContentAsString`的方法，它可以捕获写入servlet输出流中的数据，以便与预期的答案进行比较。'
- en: Note that the mock classes are being used not as Spring beans in the traditional
    sense (as they are in [chapter 7](kindle_split_019.html#ch07) on Spring), but
    simply as an available API.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模拟类并不是作为传统意义上的Spring beans（如[第7章](kindle_split_019.html#ch07)中所述）来使用的，而仅仅是作为一个可用的API。
- en: 'Unit-testing servlets is that simple, as illustrated in [figure 10.3](#ch10fig03).
    Instantiate the servlet, provide it with whatever mock objects it needs, invoke
    the proper `do` method, and check the results. This example showed `getContentAsString`;
    additional tests in this chapter will illustrate two other convenient methods:
    `getForwardedUrl` and `getRedirectedUrl`. With these classes and methods available,
    no deployment to a servlet container is required.'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 如图10.3所示，单元测试Servlet非常简单。实例化servlet，提供它需要的任何模拟对象，调用适当的`do`方法，并检查结果。这个例子展示了`getContentAsString`；本章中的其他测试将展示另外两个方便的方法：`getForwardedUrl`和`getRedirectedUrl`。有了这些类和方法，就不需要部署到servlet容器中。
- en: Figure 10.3\. Servlet tests using Spring mocks. The Spring API provides mock
    classes for the request, response, and session, and captures outputs, forwards,
    and redirected URLs.
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3\. 使用Spring模拟的Servlet测试。Spring API为请求、响应和会话提供了模拟类，并捕获输出、转发和重定向的URL。
- en: '![](10fig03.jpg)'
  id: totrans-1079
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig03.jpg)'
- en: So far, however, I haven’t used Groovy at all. What does Groovy provide to make
    servlet development and testing easier? I’ll answer that in the next section.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，我完全没有使用Groovy。Groovy提供了什么来使Servlet开发和测试更容易？我将在下一节回答这个问题。
- en: Unit testing isn’t always enough, though. I’d like to prove that my application
    classes work in practice as well, so I want to do an integration test, too. That
    means I need a servlet container, some way to deploy my web application, and a
    way to trigger requests types other than simple GETs. That’s the subject of the
    next section.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单元测试很重要，但并不总是足够。我想证明我的应用程序类在实际中也能正常工作，所以我还想进行集成测试。这意味着我需要一个servlet容器，一种部署我的Web应用程序的方法，以及一种触发除简单GET请求之外的其他请求类型的方法。这是下一节的主题。
- en: 10.3.2\. Integration testing with Gradle
  id: totrans-1082
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. 使用Gradle进行集成测试
- en: Gradle is a build tool implemented in Groovy, which was discussed extensively
    in [chapter 5](kindle_split_016.html#ch05) on build processes. Gradle uses Groovy
    builder syntax to specify repositories, library dependencies, and build tasks.
    Executing a build using one of the normal plugins (like the Groovy plugin used
    throughout this book) downloads any needed dependencies, compiles and tests the
    code, and prepares a final report of the results. One of the advantages of working
    with Gradle is its large variety of available plugins. In this chapter I’m working
    with web applications, and Gradle understands their structure as well as regular
    Java or Groovy applications. All you need to do is include the `war` plugin, and
    everything works. Even better, Gradle also includes a `jetty` plugin, which is
    designed for testing web applications.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle是一个用Groovy实现的构建工具，这在第5章（关于构建过程）中进行了广泛讨论。[kindle_split_016.html#ch05]。Gradle使用Groovy构建器语法来指定仓库、库依赖项和构建任务。使用正常插件（如本书中使用的Groovy插件）执行构建会下载任何需要的依赖项，编译和测试代码，并准备最终的结果报告。与Gradle一起工作的一个优点是它提供了大量的可用插件。在本章中，我正在处理Web应用程序，Gradle理解它们的结构以及常规的Java或Groovy应用程序。你只需要包含`war`插件，一切就会工作。更好的是，Gradle还包含一个`jetty`插件，它专为测试Web应用程序而设计。
- en: 'Simply add the following line to a Gradle build:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地添加以下行到Gradle构建文件中：
- en: '[PRE127]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The project will then use the default Maven structure of a web application.
    That means the web directory src/main/webapp will hold any view layer files, like
    HTML, CSS, and JavaScript. That directory will also contain the WEB-INF subdirectory,
    which contains the web deployment descriptor, web.xml. The source structure can
    be mapped any way you want, but for this section I’ll stick with the default Maven
    approach.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 项目将使用Web应用程序的默认Maven结构。这意味着web目录src/main/webapp将包含任何视图层文件，如HTML、CSS和JavaScript。该目录还将包含WEB-INF子目录，其中包含web部署描述符web.xml。源结构可以按任何方式映射，但在这个部分，我将坚持使用默认的Maven方法。
- en: Consider a web application that holds `HelloServlet` from the previous section.
    The project layout is shown in [figure 10.4](#ch10fig04).
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含上一节中的`HelloServlet`的Web应用程序。项目布局如图10.4所示。[figure 10.4](#ch10fig04)。
- en: Figure 10.4\. Web project layout. The integrationTest directories are discussed
    later in this chapter. The project has the standard Maven structure for a web
    application.
  id: totrans-1088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4\. Web项目布局。集成测试目录将在本章后面讨论。该项目具有Web应用程序的标准Maven结构。
- en: '![](10fig04.jpg)'
  id: totrans-1089
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig04.jpg)'
- en: At this stage, the Gradle build file is very simple, as shown in the following
    listing.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，Gradle构建文件非常简单，如下所示。
- en: Listing 10.10\. Gradle build file for web application, using the `war` plugin
  id: totrans-1091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.10\. 使用`war`插件的Web应用程序的Gradle构建文件
- en: '![](271fig01_alt.jpg)'
  id: totrans-1092
  prefs: []
  type: TYPE_IMG
  zh: '![图片](271fig01_alt.jpg)'
- en: The listing includes the `war` plugin. As usual, dependencies come from Maven
    central. The dependent libraries include JUnit and the Spring API libraries used
    for unit-testing. The interesting feature is the `providedCompile` dependency.
    That tells Gradle that the servlet and JSP APIs are required during compilation
    but not at deployment, because the container will provide them.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中包含了`war`插件。通常，依赖项来自Maven中央仓库。依赖的库包括JUnit和用于单元测试的Spring API库。有趣的功能是`providedCompile`依赖项。这告诉Gradle在编译期间需要servlet和JSP
    API，但在部署时不需要，因为容器将提供它们。
- en: The `war` plugin really shines when it’s combined with the `jetty` plugin. Jetty
    is a lightweight, open source servlet container hosted by the Eclipse foundation.^([[4](#ch10fn04)])
    This makes it convenient for testing web applications, and Gradle includes a `jetty`
    plugin with the standard distribution.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`jetty`插件结合使用时，`war`插件表现得非常出色。Jetty是由Eclipse基金会托管的一个轻量级、开源的servlet容器。[4](#ch10fn04)这使得测试Web应用程序变得方便，Gradle的标准分发中包含了一个`jetty`插件。
- en: ⁴ See [www.eclipse.org/jetty/](http://www.eclipse.org/jetty/) for details.
  id: totrans-1095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴有关详细信息，请参阅[www.eclipse.org/jetty/](http://www.eclipse.org/jetty/)。
- en: 10.3.3\. Automating Jetty in the Gradle build
  id: totrans-1096
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3. 在Gradle构建中自动化Jetty
- en: 'To use Jetty in Gradle, you need to add the plugin dependency, but you also
    need to configure some settings:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Gradle中使用Jetty，你需要添加插件依赖项，但还需要配置一些设置：
- en: '[PRE128]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The `httpPort` variable is the port that Jetty will use for HTTP requests. Using
    8080 is typical, because it’s the default port for both Tomcat and Jetty, but
    it’s certainly not required. The Jetty container will listen for shutdown requests
    on the `stopPort`, and the plugin will send the `stopKey` to Jetty when it’s time
    to shut down.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpPort`变量是Jetty将用于HTTP请求的端口。使用8080是典型的，因为它既是Tomcat也是Jetty的默认端口，但这绝对不是必需的。Jetty容器将在`stopPort`上监听关闭请求，当需要关闭时，插件将向Jetty发送`stopKey`。'
- en: 'Adding the plugin and properties to the Gradle build enables three new tasks:'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 将插件和属性添加到Gradle构建中可以启用三个新任务：
- en: '**1**.  `jettyRun`, which starts the server and deploys the application'
  id: totrans-1101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. `jettyRun`，用于启动服务器并部署应用程序'
- en: '**2**.  `jettyRunWar`, which creates a WAR file before deployment'
  id: totrans-1102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. `jettyRunWar`，在部署前创建WAR文件'
- en: '**3**.  `jettyStop`, which stops the server'
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. `jettyStop`，用于停止服务器'
- en: That’s helpful, but I want to automate the process of deploying my application
    so that I can run an integration test without human intervention. To make that
    happen, I need the `jettyRun` and `jettyRunWar` tasks to run in “daemon” mode,
    which means that after starting, control will be returned to the build so it can
    continue with other tasks.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有帮助，但我想自动化部署应用程序的过程，这样我就可以在没有人为干预的情况下运行集成测试。为了实现这一点，我需要`jettyRun`和`jettyRunWar`任务以“守护”模式运行，这意味着启动后，控制权将返回到构建，以便它可以继续执行其他任务。
- en: 'Therefore, I add the following line to the build:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我在构建中添加了以下行：
- en: '[PRE129]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Remember that the spread-dot operator (`*.`) in Groovy here means to set the
    `daemon` property on each element of the collection. Without the star, the dot
    operator would try to set the property on the collection itself, which wouldn’t
    work.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在Groovy中这里的扩展点运算符（`*.`）意味着要为集合中的每个元素设置`daemon`属性。如果没有星号，点运算符将尝试在集合本身上设置属性，这是不会工作的。
- en: 'The test itself can then be defined as a private method in the build file and
    called from inside a Gradle task, as follows:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身可以在构建文件中定义为私有方法，并在Gradle任务内部调用，如下所示：
- en: '[PRE130]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `intTest` task is defined using the left-shift operator (`<<`), which is
    an alias for adding a `doLast` closure. In other words, this defines the task
    but doesn’t execute it. Because the task depends on the `jettyRun` task, `jettyRun`
    will be called first if this task is invoked. The task calls the private `callServlet`
    method, which converts a `String` to a URL, accesses the site, and compares the
    response to the expected value. Once the method completes, the `intTest` task
    tells Jetty to shut down, and I’m finished.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '`intTest`任务使用左移运算符（`<<`）定义，它是添加`doLast`闭包的别名。换句话说，这定义了任务但不执行它。因为任务依赖于`jettyRun`任务，所以如果调用此任务，`jettyRun`将首先被调用。任务调用私有的`callServlet`方法，该方法将`String`转换为URL，访问网站，并将响应与预期值进行比较。一旦方法完成，`intTest`任务告诉Jetty关闭，我就完成了。'
- en: I can invoke the `intTest` task directly from the command line, but I’d rather
    make it part of my normal build process. To do that, I notice that in the directed
    acyclic graph (DAG, see [chapter 5](kindle_split_016.html#ch05)) formed by the
    Gradle build file, the next task after the test task is completed is called `check`.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以直接从命令行调用`intTest`任务，但我想让它成为我的正常构建过程的一部分。为了做到这一点，我注意到在Gradle构建文件形成的有向无环图（DAG，见第5章）中，测试任务完成后紧接着的任务被称为`check`。
- en: 'That sounded way more complicated than it actually was. All I needed to do
    was run Gradle with the `–m` flag to keep it from actually executing, which gives
    the following output:'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来比实际要复杂得多。我需要做的只是用`–m`标志运行Gradle，以防止它实际执行，这会产生以下输出：
- en: '[PRE131]'
  id: totrans-1113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'As you can see, the `check` task occurs right after the `test` task completes,
    and the `intTest` task doesn’t execute at all unless I call for it. To put my
    task into the process, I set it as a dependency of the `check` task:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`check`任务在`test`任务完成后立即发生，而`intTest`任务根本不会执行，除非我调用它。为了将我的任务放入流程中，我将它设置为`check`任务的依赖项：
- en: '[PRE132]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now if I run the same build task again, the integration test runs at the proper
    time:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果再次运行相同的构建任务，集成测试将在适当的时间运行：
- en: '[PRE133]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Note that the `jettyRun` task is also triggered before the tests. Now everything
    works the way I want.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`jettyRun`任务在测试之前也会被触发。现在一切按我想要的方式工作。
- en: From one perspective, this is quite a feat of engineering. The class structure
    in Gradle makes it easy to define new tasks, I can make sure my task runs at the
    proper time, and I can even embed the test as Groovy code right in my build file.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个角度来看，这相当是一项工程壮举。Gradle中的类结构使得定义新任务变得容易，我可以确保我的任务在正确的时间运行，我甚至可以将测试作为Groovy代码直接嵌入到构建文件中。
- en: The problem, of course, is that I can embed the test as Groovy code right in
    my build file. That works in this instance, but doing business logic (even testing)
    in a build file can’t be a good long-term solution. Test cases aren’t part of
    a build; a build calls them. Inside the build, they’re hard to maintain and not
    easily reusable.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，问题是，我可以将测试作为Groovy代码直接嵌入到我的构建文件中。在这个例子中，这行得通，但在构建文件中进行业务逻辑（甚至测试）不能是一个好的长期解决方案。测试用例不是构建的一部分；构建调用它们。在构建内部，它们难以维护且不易重用。
- en: 10.3.4\. Using an integration-test source tree
  id: totrans-1121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.4. 使用集成测试源树
- en: A good way to separate the testing infrastructure from the actual tests is to
    create a special source tree for it. That provides a convenient location for the
    tests, which will run automatically at the proper point in the build.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试基础设施与实际测试分开的一个好方法是为其创建一个特殊的源树。这为测试提供了一个方便的位置，它们将在构建的正确时间自动运行。
- en: Gradle projects have a `sourceSets` property, which can be used to map source
    directories if they don’t fit the default Maven pattern. An example of this was
    given in [chapter 5](kindle_split_016.html#ch05). Here I want to add an additional
    testing directory. For both the Java and Groovy plugins, simply defining a source
    set name generates the proper tasks.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle项目有一个`sourceSets`属性，可以用来映射源目录，如果它们不符合默认的Maven模式。[第五章](kindle_split_016.html#ch05)中给出了一个例子。在这里，我想添加一个额外的测试目录。对于Java和Groovy插件，只需定义一个源集名称就可以生成正确的任务。
- en: 'In the current build I add a source set called `integrationTest`:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的构建中，我添加了一个名为`integrationTest`的源集：
- en: '[PRE134]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This causes Gradle to generate tasks called `compileIntegrationTestJava`, `compileIntegrationTestGroovy`,
    `processIntegrationTestResources`, and `integrationTest-``Classes`. The directory
    tree now includes src/integrationTest/java, src/integrationTest/groovy, and src/integrationTest/resources.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致Gradle生成名为`compileIntegrationTestJava`、`compileIntegrationTestGroovy`、`processIntegrationTestResources`和`integrationTest-Classes`的任务。目录树现在包括src/integrationTest/java、src/integrationTest/groovy和src/integrationTest/resources。
- en: 'For this source set I would like the compile and runtime dependencies to match
    their counterparts in the regular test directory:'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个源集，我希望编译和运行时依赖与常规测试目录中的对应项相匹配：
- en: '[PRE135]'
  id: totrans-1128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'As before, I’ll use the `intTest` task, but now I need to configure it to have
    the proper classpath and test directories. Here’s the new version of the task:'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我会使用`intTest`任务，但现在我需要配置它以拥有正确的类路径和测试目录。以下是任务的最新版本：
- en: '[PRE136]'
  id: totrans-1130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The `testClassesDir` property points to the compiled test sources. The classpath
    is set to the runtime classpath of the source set, which is simply the runtime
    classpath of the regular tests. I can now place integration tests into the src/integrationTest
    directory tree, and they’ll be executed at the proper time.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '`testClassesDir`属性指向编译后的测试源。类路径设置为源集的运行时类路径，这仅仅是常规测试的运行时类路径。我现在可以将集成测试放入src/integrationTest目录树中，它们将在正确的时间执行。'
- en: 'One final issue remains before presenting the integration tests. It’s easy
    to create an HTTP GET request: you convert the string URL to an instance of `java.net.URL`
    and then access its `text` property, as shown previously. It’s not as simple to
    create POST, PUT, and DELETE requests, however. These are discussed in some detail
    in [chapter 8](kindle_split_020.html#ch08), but for now I’ll use a third-party
    open source library.'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示集成测试之前，还有一个问题需要解决。创建HTTP GET请求很简单：你将字符串URL转换为`java.net.URL`的一个实例，然后访问它的`text`属性，如前所述。然而，创建POST、PUT和DELETE请求并不那么简单。这些在[第八章](kindle_split_020.html#ch08)中有详细讨论，但到目前为止，我将使用第三方开源库。
- en: 'The HTTPBuilder library ([http://groovy.codehaus.org/modules/http-builder/](http://groovy.codehaus.org/modules/http-builder/))
    is a Groovy wrapper around Apache’s HttpClient library. It uses Groovy to make
    it easy to execute HTTP requests and process the responses. To use it, I added
    the following dependency to my Gradle build file:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPBuilder库([http://groovy.codehaus.org/modules/http-builder/](http://groovy.codehaus.org/modules/http-builder/))是Apache
    HttpClient库的Groovy包装器。它使用Groovy使其易于执行HTTP请求并处理响应。为了使用它，我在Gradle构建文件中添加了以下依赖项：
- en: '[PRE137]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: With this addition, the following listing now shows a variety of integration
    tests. The test class includes tests both with the HTTPBuilder client and without.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此添加之后，以下列表现在显示了各种集成测试。测试类包括使用HTTPBuilder客户端和不使用客户端的测试。
- en: 'Listing 10.11\. `ServletIntegrationTests.groovy`: accessing deployed servlets'
  id: totrans-1136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.11\. `ServletIntegrationTests.groovy`：访问部署的servlet
- en: '![](275fig01_alt.jpg)'
  id: totrans-1137
  prefs: []
  type: TYPE_IMG
  zh: '![](275fig01_alt.jpg)'
- en: The listing demonstrates three different types of tests. The first shows a simple
    GET request without any library dependencies. The second uses the HTTPBuilder^([[5](#ch10fn05)])
    library to execute a GET request, and the last does the same with a POST request.
    The detailed syntax comes from the library documentation.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表展示了三种不同类型的测试。第一种显示了一个没有任何库依赖的简单GET请求。第二种使用HTTPBuilder^([[5](#ch10fn05)])库执行GET请求，最后一种使用POST请求完成同样的操作。详细的语法来自库文档。
- en: ⁵ HTTPBuilder includes a class called `RESTClient`, which is used extensively
    in the discussion of REST in [chapter 9](kindle_split_021.html#ch09).
  id: totrans-1139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵HTTPBuilder包括一个名为`RESTClient`的类，它在第9章（kindle_split_021.html#ch09）关于REST的讨论中被广泛使用。
- en: With this infrastructure in place, both unit and integration tests can be added
    to a standard project tree, and both can be executed with an embedded Jetty server
    using a plugin in the Gradle build.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础设施到位的情况下，单元测试和集成测试都可以添加到标准项目树中，并且都可以使用Gradle构建中的插件通过嵌入的Jetty服务器执行。
- en: '|  |'
  id: totrans-1141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Gradle Integration Tests
  id: totrans-1142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Gradle集成测试
- en: Using Gradle’s `web` and `jetty` plugins with an integration source tree, web
    applications can be tested in “live” mode during a normal build.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle的`web`和`jetty`插件与集成源树一起，可以在正常构建期间以“实时”模式测试Web应用程序。
- en: '|  |'
  id: totrans-1144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1145
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The Geb web testing framework**'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '**Geb网络测试框架**'
- en: Geb ([www.gebish.org](http://www.gebish.org)) (pronounced “jeb,” with a soft
    *g*) is a Groovy testing tool based on Spock that allows tests to be written using
    a page-centric approach to web applications. Website interactions can be scripted
    in terms of page objects, rather than simple screen scraping. It uses a jQuery-like
    syntax along with Groovy semantics to do browser automation, using the WebDriver
    library under the hood.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: Geb ([www.gebish.org](http://www.gebish.org))（发音为“jeb”，带有一个轻柔的*g*）是一个基于Spock的Groovy测试工具，它允许使用以页面为中心的方法编写网络应用的测试。网站交互可以用页面对象来脚本化，而不是简单的屏幕抓取。它使用类似jQuery的语法以及Groovy语义来执行浏览器自动化，底层使用WebDriver库。
- en: The Geb project shows a lot of promise and has a growing number of adherents.
    It’s certainly worth considering as a functional testing tool, along with alternatives
    like Canoo WebTest ([http://webtest.canoo.com](http://webtest.canoo.com)) and
    the Selenium^([[6](#ch10fn06)]) ([http://seleniumhq.org](http://seleniumhq.org))
    JavaScript library. An entire chapter could be written covering those tools alone,
    but this book is arguably already long enough.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: Geb项目显示出很大的潜力，并且有越来越多的支持者。它当然值得考虑作为一个功能测试工具，以及像Canoo WebTest ([http://webtest.canoo.com](http://webtest.canoo.com))和Selenium^([[6](#ch10fn06)])
    ([http://seleniumhq.org](http://seleniumhq.org)) JavaScript库这样的替代品。仅关于这些工具就可以写一整章，但本书可能已经足够长了。
- en: ⁶ By the way, do you know why it’s called Selenium? When it was developed, there
    was a much-loathed product called Mercury Test Runner. As it happens, the element
    Selenium (Se) is the cure for Mercury (Hg) poisoning.
  id: totrans-1149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶顺便问一下，你知道为什么它叫Selenium吗？当它被开发时，有一个非常令人讨厌的产品叫做Mercury Test Runner。碰巧的是，元素Selenium（Se）是治疗水银（Hg）中毒的良药。
- en: Because this an active area of development, I recommend the testing presentations
    at Slide Share by Paul King (for example, [www.slideshare.net/paulk_asert/make-tests-groovy](http://www.slideshare.net/paulk_asert/make-tests-groovy)),
    one of the coauthors of *Groovy in Action* (Manning, 2007) and an outstanding
    developer, as a helpful reference.^([[7](#ch10fn07)])
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个活跃的开发领域，我建议参考Paul King在Slide Share上的测试演示（例如，[www.slideshare.net/paulk_asert/make-tests-groovy](http://www.slideshare.net/paulk_asert/make-tests-groovy)），他是*Groovy
    in Action*（Manning，2007）的合著者之一，也是一位杰出的开发者，作为有益的参考资料.^([[7](#ch10fn07)])
- en: '⁷ I’ll just say it here: everything Paul King says is right. Start with that
    assumption and you’ll be fine.'
  id: totrans-1151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷我就在这里说：Paul King说的每一句话都是对的。从这个假设开始，你就会做得很好。
- en: '|  |'
  id: totrans-1152
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Groovy has other classes that support server-side configuration, like `ServletBinding`,
    which extends the regular script `Binding` class.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy有其他支持服务器端配置的类，例如`ServletBinding`，它扩展了常规脚本`Binding`类。
- en: '|  |'
  id: totrans-1154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (testing)**'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: '**经验教训（测试）**'
- en: Spring provides a library of mock objects for unit-testing web applications.
    The same library is built into Grails.
  id: totrans-1156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring 提供了一个用于单元测试 Web 应用的模拟对象库。这个库同样被集成到了 Grails 中。
- en: The web and Jetty plugins in Gradle make it easy to build and deploy web applications.
    With some work, Gradle can do automatic integration testing.
  id: totrans-1157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gradle 的 Web 和 Jetty 插件使得构建和部署 Web 应用程序变得容易。经过一些工作，Gradle 可以进行自动集成测试。
- en: '|  |'
  id: totrans-1158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Larger applications require more structure to be easily maintainable. The Java
    world is full of web frameworks, from Struts (both versions 1 and 2) to Tapestry
    to Wicket to JSF to Spring MVC and more. In the Groovy world, one particular framework
    is dominant, to the point of attracting developers to Groovy just so they can
    use this framework. That’s the definition of a killer app: an application so cool
    people will learn a new language just to use it. That framework, as most readers
    well know, is called Grails.'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 较大的应用程序需要更多的结构以便易于维护。Java 世界充满了 Web 框架，从 Struts（1 和 2 版本）到 Tapestry，再到 Wicket，JSF，Spring
    MVC 以及更多。在 Groovy 世界中，有一个特定的框架占主导地位，以至于吸引开发者学习 Groovy 只是为了使用这个框架。这就是杀手级应用的定义：一个如此酷的应用程序，以至于人们会为了使用它而学习一门新的语言。正如大多数读者所熟知，这个框架被称为
    Grails。
- en: This is a book about using Java and Groovy together, so I won’t present a standard
    tutorial on how to get started with Grails. There are plenty of references for
    that available.^([[8](#ch10fn08)]) Instead, I’ll show a simple, but hopefully
    nontrivial, application, discuss some of the architectural choices made when creating
    Grails, and show how existing Java classes can be incorporated into a Grails application.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本关于如何结合使用 Java 和 Groovy 的书，因此我不会提供一个标准的 Grails 入门教程。关于这一点，有大量的参考资料可用.^([[8](#ch10fn08)])
    相反，我将展示一个简单但可能不平凡的示例应用程序，讨论在创建 Grails 时做出的某些架构选择，并展示如何将现有的 Java 类集成到 Grails 应用程序中。
- en: ⁸ See especially the excellent *Grails in Action*, by Peter Ledbrook and Glen
    Smith (Manning, 2009).
  id: totrans-1161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 特别推荐 Peter Ledbrook 和 Glen Smith 所著的《Grails in Action》（Manning，2009）。
- en: '10.4\. Grails: the Groovy “killer app”'
  id: totrans-1162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4\. Grails：Groovy 的“杀手级应用”
- en: It’s hard to overstate the impact on the Java world made by the Ruby on Rails
    (RoR) comet that streaked across the Java sky back in 2005\. Java web development
    at the time consisted of a series of layers composed of a wide mix of technologies,
    each with its own configuration files and dependencies. Just starting a new web
    application was a challenge.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 很难过分强调 Ruby on Rails（RoR）彗星在 2005 年横扫 Java 天空时对 Java 世界产生的影响。当时的 Java Web 开发由一系列由各种技术组成的层组成，每种技术都有自己的配置文件和依赖关系。仅仅开始一个新的
    Web 应用程序就是一个挑战。
- en: Ruby on Rails, with its strong emphasis on the DRY (Don’t Repeat Yourself) principle
    and Convention over Configuration, demonstrated how much simpler life could be.
    While a lot of Java web developers embraced the RoR approach, not everyone was
    in a position to simply abandon the Java world. The big question was, how do we
    bring the rapid development principles from the RoR world into Java enterprise
    development?
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby on Rails，由于其强调 DRY（不要重复自己）原则和约定优于配置，展示了生活可以多么简单。虽然许多 Java Web 开发者接受了 RoR
    方法，但并非每个人都处于可以简单地放弃 Java 世界的情况。关键问题是，我们如何将 RoR 世界中的快速开发原则带入 Java 企业开发？
- en: I’ll address that in a moment, but first I want to discuss every web application
    ever created,^([[9](#ch10fn09)]) from the 30,000-foot level. [Figure 10.5](#ch10fig05)
    shows the standard architecture.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在稍后解决这个问题，但首先我想从 30,000 英尺的高度讨论每一个创建过的 Web 应用程序，^([[9](#ch10fn09)]) 如 [图 10.5](#ch10fig05)
    所示的标准架构。
- en: ⁹ True for most non-web applications as well. These layers are pretty universal.
  id: totrans-1166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 对于大多数非 Web 应用程序也是如此。这些层相当普遍。
- en: Figure 10.5\. The layered design of every Java web application ever made. Presentation
    layer classes, including controllers, go through transactional services to access
    persistent data.
  id: totrans-1167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.5\. 所有 Java Web 应用程序的分层设计。表示层类，包括控制器，通过事务服务访问持久数据。
- en: '![](10fig05.jpg)'
  id: totrans-1168
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig05.jpg)'
- en: The user interface in the standard model is a browser, also known as a lightweight
    client, as opposed to a heavyweight (desktop) Java client. The browser presents
    views to the user, who occasionally submits information back to the server side.
    The information goes through controllers, which are classes that decide where
    to go, what business logic to invoke, and what view to use when the request has
    been processed.
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 标准模型中的用户界面是一个浏览器，也称为轻量级客户端，与重量级（桌面）Java客户端相对。浏览器向用户展示视图，用户偶尔会将信息提交回服务器端。信息通过控制器传递，控制器是一类决定去哪里、调用什么业务逻辑以及请求处理完毕后使用什么视图的类。
- en: A key principle of Java web application development is to keep the controllers
    thin, meaning minimal in the amount of actual processing that they do. Instead,
    the business logic is delegated to service classes. The services are needed also
    as transactional boundaries, because data access is handled through a set of classes
    in a data access layer. The data access classes follow the Data Access Object
    (DAO) design pattern, which encapsulates^([[10](#ch10fn10)]) a data source and
    transforms entities into database tables and back.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: Java Web应用开发的一个关键原则是保持控制器瘦，这意味着它们实际处理的数量最小。相反，业务逻辑被委托给服务类。服务类还需要作为事务边界，因为数据访问是通过数据访问层中的一系列类来处理的。数据访问类遵循数据访问对象（DAO）设计模式，它封装了^([[10](#ch10fn10)])数据源，并将实体转换为数据库表，反之亦然。
- en: ^(10) Encapsulates. Sigh. Can’t we just say “wraps”? Why does every term from
    OOP have to be so overly complicated? Why can’t we just “make” or “create” something,
    rather than “instantiate” it? And I get the whole “many forms” idea, but who thought
    the term “polymorphism” was exactly what we needed? Who talks like that (other
    than me, after all these years)?
  id: totrans-1171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^[(10)](#ch10fn10) 封装。唉。我们难道不能只说“包裹”吗？为什么每个来自面向对象编程（OOP）的术语都必须如此复杂？为什么我们不能只是“制作”或“创建”某物，而不是“实例化”它？而且我完全理解“多种形式”的概念，但谁会认为“多态”这个术语正是我们所需要的？谁会那样说（毕竟，这么多年了，除了我之外）？
- en: While I’m on the subject, I need to show you one more figure that’s inevitable
    in the web application world. It’s the standard Model-View-Controller (MVC) architecture,
    illustrated in [figure 10.6](#ch10fig06).
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我谈到这个话题时，我需要向你展示一个在Web应用领域中不可避免的一个图示。那就是标准的模型-视图-控制器（MVC）架构，如图10.6所示。[figure
    10.6](#ch10fig06)。
- en: Figure 10.6\. The Model-View-Controller (MVC) architecture, little changed since
    the days of Smalltalk. Views display model objects, which are created and configured
    by controllers.
  id: totrans-1173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6。模型-视图-控制器（MVC）架构，自Smalltalk时代以来变化不大。视图显示模型对象，这些对象由控制器创建和配置。
- en: '![](10fig06.jpg)'
  id: totrans-1174
  prefs: []
  type: TYPE_IMG
  zh: '![10fig06.jpg](10fig06.jpg)'
- en: The basic idea behind MVC is separation of concerns. Views display model objects,
    collect data from users, and submit it to controllers. Controllers create and
    configure model objects and forward them to the views. While the controllers and
    views are tightly coupled, the model objects are not tied to either. If anything
    in the system is reusable, it’s the model classes. By the way, noticeably absent
    from this architecture are the services from the previous figure, but the approach
    is an oversimplification anyway, so I choose not to worry about it.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: MVC背后的基本思想是关注点的分离。视图显示模型对象，从用户那里收集数据，并将其提交给控制器。控制器创建和配置模型对象，并将它们转发到视图。虽然控制器和视图紧密耦合，但模型对象并不与它们绑定。如果系统中的任何内容是可重用的，那就是模型类。顺便说一下，从这种架构中明显缺失的是前一个图中的服务，但这种方法本身就是一种过度简化，所以我选择不去担心它。
- en: 'Grails is typical of the MVC-based, layered architecture just described, with
    some interesting variations that are discussed in this section. Grails is notable
    for several reasons:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: Grails是前面描述的基于MVC的分层架构的典型代表，它有一些有趣的变体，将在本节中讨论。Grails有几个显著的特点：
- en: Grails is *built on* *top of existing, mature technologies*. Grails combines
    a series of Groovy domain-specific languages (DSLs) on top of Spring and Hibernate.
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grails是*建立在*现有成熟技术之上的。Grails在Spring和Hibernate之上结合了一系列Groovy领域特定语言（DSLs）。
- en: Grails is a *complete stack framework* (in much the same way as RoR) that combines
    open source solutions from the view layer to the persistence layer and everything
    in between.
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grails是一个*完整的堆栈框架*（与RoR非常相似），它将视图层到持久化层以及中间的所有开源解决方案结合起来。
- en: Grails has an *interactive scripting* capability that makes it easy to rapidly
    prototype applications.
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grails具有一种*交互式脚本*能力，这使得快速原型化应用变得容易。
- en: The design of Grails is based on a *plugin system* that makes it very easy to
    extend.^([[11](#ch10fn11)])
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grails的设计基于一个*插件系统*，这使得它非常容易扩展.^([11](#ch10fn11)))
- en: ^(11) At latest count, there are over 800 plugins available for Grails (of widely
    varying quality).
  id: totrans-1181
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([11](#ch10fn11)) 至少到目前为止，有超过800个插件可供Grails使用（质量参差不齐）。
- en: Grails applications *deploy on existing Java-based infrastructure*.
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grails应用程序*部署在现有的基于Java的基础设施上*。
- en: Grails relies on the Spring framework for its internal infrastructure, so anything
    Spring can do, Grails can do, either directly or through a plugin. Persistence
    is managed through the Hibernate Object-Relational Mapping layer, which is powerful
    enough but can also be replaced for the modern family of NoSQL databases.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: Grails依赖于Spring框架的内部基础设施，因此Spring能做的任何事情，Grails都能直接或通过插件做到。持久性通过Hibernate对象关系映射层管理，它足够强大，但也可以用现代的NoSQL数据库家族来替换。
- en: To show how Grails fits into the standard architecture, I’ll walk through the
    components of an example.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示Grails如何融入标准架构，我将遍历一个示例组件。
- en: 10.4.1\. The quest for the holy Grails
  id: totrans-1185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1\. 寻找圣杯的旅程
- en: Grails can be used to design arbitrarily complex web applications, but one of
    its sweet spots is to provide a web interface on a set of database tables. I’ll
    come back to that after showing the components, because it’s both a blessing and
    a curse.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: Grails可以用来设计任意复杂的Web应用程序，但其中一个亮点是提供一个数据库表集的Web界面。在展示组件之后，我会回到这一点，因为它既是祝福也是诅咒。
- en: '|  |'
  id: totrans-1187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Grails
  id: totrans-1188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Grails
- en: The goal of this section is to demonstrate a portion of a small but nontrivial
    Grails application. [Chapter 8](kindle_split_020.html#ch08) examines GORM in more
    detail. [Chapter 9](kindle_split_021.html#ch09) on REST briefly talks about REST
    in Grails. Finally, [chapter 7](kindle_split_019.html#ch07) on Spring talks about
    the underlying infrastructure.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是演示一个小但非平凡的Grails应用程序的一部分。[第8章](kindle_split_020.html#ch08)更详细地探讨了GORM。[第9章](kindle_split_021.html#ch09)简要介绍了Grails中的REST。[最后，第7章](kindle_split_019.html#ch07)介绍了Spring，讨论了底层基础设施。
- en: '|  |'
  id: totrans-1190
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Consider a web application with four domain classes: `Quest`, `Task`, `Knight`,
    and `Castle`.'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含四个域类的Web应用程序：`Quest`、`Task`、`Knight`和`Castle`。
- en: '|  |'
  id: totrans-1192
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Domain Classes
  id: totrans-1193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 域类
- en: In Grails, instances of domain classes map to database table rows.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grails中，域类的实例映射到数据库表行。
- en: '|  |'
  id: totrans-1195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The Grails approach to convention over configuration means that there’s a specific
    directory for everything, as illustrated in [figure 10.7](#ch10fig07). Domain
    classes have their own directory, as do controllers, services, and views. This
    makes it easy to understand a Grails application you haven’t written, because
    they all store their elements in the same place.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: Grails对约定优于配置的方法意味着有一个特定的目录用于所有内容，如图10.7所示。[图10.7](#ch10fig07)。域类有自己的目录，控制器、服务、视图也是如此。这使得理解一个你没有编写的Grails应用程序变得容易，因为它们都将元素存储在相同的位置。
- en: Figure 10.7\. Standard layout for all Grails applications. Adherence to convention
    over configuration makes it easy to find the various components, from controllers
    to services to domain classes to views.
  id: totrans-1197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.7\. 所有Grails应用程序的标准布局。遵循约定优于配置的规则使得查找各种组件变得容易，从控制器到服务，再到域类和视图。
- en: '![](10fig07.jpg)'
  id: totrans-1198
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig07.jpg)'
- en: Grails domain classes are normally written in Groovy, though that’s not required.
    In the application shown in the next listing, a quest has a name and is associated
    with many tasks and knights.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: Grails域类通常用Groovy编写，尽管这不是必需的。在下一列表中所示的应用程序中，一个任务有一个名称，并与许多任务和骑士相关联。
- en: Listing 10.12\. The `Quest` domain class
  id: totrans-1200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.12\. `Quest`域类
- en: '[PRE138]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The `Quest` has a `name` property and an override of `toString` to return it.
    The keyword `hasMany` is part of GORM, the Grails Object-Relational Mapping DSL,
    which programmatically configures Hibernate. Other ORM tools are available, but
    Hibernate is the default. The `hasMany` keyword implies a foreign key relationship
    between both the `Knight` and `Task` tables and the `Quest` table.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Quest`有一个`name`属性和一个覆盖的`toString`方法来返回它。关键字`hasMany`是GORM的一部分，即Grails对象关系映射DSL，它以编程方式配置Hibernate。其他ORM工具也是可用的，但Hibernate是默认的。`hasMany`关键字暗示了`Knight`和`Task`表与`Quest`表之间的外键关系。'
- en: Domain classes also have constraints, which are enforced by Grails when creating
    new instances. For the `Quest`, the `name` field cannot be empty.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 域类也有约束，Grails在创建新实例时强制执行这些约束。对于`Quest`，`name`字段不能为空。
- en: The `Task` class is shown in the next listing. `Task`s have a `name`, a `priority`,
    a start and end date, and a completion marker.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了`Task`类。`Task`具有名称、优先级、开始和结束日期以及完成标记。
- en: Listing 10.13\. `Task`s belong to a `Quest`
  id: totrans-1205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.13。`Task`属于一个`Quest`
- en: '[PRE139]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: The constraints closure states that `Task`s must have a name, a priority that
    falls between 1 and 5, and an end date that’s greater than or equal to the start
    date. The other notable part of this class is the `belongsTo` keyword, which implies
    a cascade delete relationship between quests and tasks. If a `Quest` is deleted,
    all its associated `Task`s are removed from the database as well.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 约束闭合状态表明`Task`必须有一个名称，一个介于1和5之间的优先级，以及一个大于或等于开始日期的结束日期。这个类中另一个值得注意的部分是`belongsTo`关键字，它暗示了任务和任务之间的级联删除关系。如果一个`Quest`被删除，所有相关的`Task`也会从数据库中移除。
- en: '`Knight`s are associated with both `Quest`s and `Castle`s, but not through
    a cascade delete. In fact, a `Knight` can be between `Quest`s and not belong to
    a `Castle`, so both references are listed as `nullable` in the next listing.'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Knight`与`Quest`和`Castle`都有关联，但不是通过级联删除。实际上，一个`Knight`可以在`Quest`之间，但不属于一个`Castle`，所以这两个引用在下一个列表中都被列为`nullable`。'
- en: Listing 10.14\. The `Knight` class, which is associated with a `Quest` and a
    `Castle`
  id: totrans-1209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.14。与`Quest`和`Castle`关联的`Knight`类
- en: '[PRE140]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The last domain class is `Castle`, which has a name, a city, a state, and a
    computed latitude/longitude pair, as shown in the following listing.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个域类是`Castle`，它有一个名称、一个城市、一个州以及一个计算出的经纬度对，如下所示。
- en: Listing 10.15\. The `Castle`, which stores location information
  id: totrans-1212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.15。存储位置信息的`Castle`
- en: '[PRE141]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The `hasMany` variable in `Castle` indicates that the `Knight` table will have
    a foreign key to the `Castle` table.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Castle`中的`hasMany`变量表示`Knight`表将有一个外键指向`Castle`表。'
- en: 'In a trivial Grails demonstration, all the associated controllers would be
    scaffolded. In Grails, that means they have a single property, called `scaffold`,
    as shown:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的Grails演示中，所有相关的控制器都会被scaffold。在Grails中，这意味着它们有一个名为`scaffold`的单个属性，如下所示：
- en: '[PRE142]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The `scaffold` term tells Grails to dynamically (that is, at runtime) generate
    views to `list`, `show`, `edit`, `update`, and `delete` a quest. The code for
    each of those actions is produced at runtime, so it’s not visible here. Eventually,
    however, I need to customize the controllers and views, so I need to generate
    the static versions.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: '`scaffold`术语告诉Grails动态（即在运行时）生成用于`list`、`show`、`edit`、`update`和`delete`任务的视图。每个动作的代码在运行时生成，所以这里没有显示。然而，最终我需要自定义控制器和视图，所以我需要生成静态版本。'
- en: A portion of the `Castle` controller is shown in the next listing.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了`Castle`控制器的一部分。
- en: Listing 10.16\. The static `Castle` controller class
  id: totrans-1219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.16。静态`Castle`控制器类
- en: '[PRE143]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The `list` action checks to see if the `params` map already contains a key called
    `max`. If so it’s converted to an integer and reset to the minimum of the provided
    value and 100\. If the parameter doesn’t exist, then 10 is used as the `max`.
    Starting in Grails 2.0, request parameters can be used as arguments to controller
    actions, and type conversions will be done automatically.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`动作检查`params`映射是否已经包含一个名为`max`的键。如果是，则将其转换为整数并重置为提供的值和100之间的最小值。如果参数不存在，则使用10作为`max`。从Grails
    2.0开始，请求参数可以用作控制器动作的参数，并且类型转换将自动进行。'
- en: '|  |'
  id: totrans-1222
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Controllers
  id: totrans-1223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 控制器
- en: Grails controllers contain methods called *actions* that map to URLs. They either
    forward to other resources, render outputs directly, or redirect to other URLs.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: Grails控制器包含称为*actions*的方法，这些方法映射到URL。它们要么转发到其他资源，直接渲染输出，要么重定向到其他URL。
- en: '|  |'
  id: totrans-1225
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: More important for the architecture discussion, however, is the map provided
    as the return value of the action. The map contains two keys, `castleInstanceList`
    and `castleInstanceTotal`. The former is associated with a list of 10 castles
    (or whatever the `max` parameter evaluates to), and the latter gives their total
    number. That’s fine, but it’s how those values are computed that’s truly interesting.
    Grails adds both a `list` method and a `count` method as static methods on the
    domain classes.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于架构讨论来说，更重要的是作为动作返回值的映射。该映射包含两个键，`castleInstanceList`和`castleInstanceTotal`。前者与10座城堡（或`max`参数评估的任何值）的列表相关联，后者给出它们的总数。这很好，但真正有趣的是这些值的计算方式。Grails在域类上添加了`list`方法和`count`方法作为静态方法。
- en: '|  |'
  id: totrans-1227
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: No Dao Classes
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 没有Dao类
- en: Instead of Data Access Objects, Grails uses Groovy metaprogramming to add static
    methods to the domain classes. This follows the Active Record^([[12](#ch10fn12)])
    approach, which is unusual in Java frameworks but very popular in Ruby.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据访问对象不同，Grails 使用 Groovy 元编程向领域类添加静态方法。这遵循了 Active Record^([[12](#ch10fn12)])
    方法，这在 Java 框架中不常见，但在 Ruby 中非常流行。
- en: ^(12) From Martin Fowler’s *Patterns of Enterprise Application Architecture*
    (Addison-Wesley Professional, 2002). See [http://en.wikipedia.org/wiki/Active_record](http://en.wikipedia.org/wiki/Active_record)
    for a brief summary.
  id: totrans-1230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (12) 来自马丁·福勒的《企业应用架构模式》（Addison-Wesley Professional，2002年）。有关简要总结，请参阅 [http://en.wikipedia.org/wiki/Active_record](http://en.wikipedia.org/wiki/Active_record)。
- en: '|  |'
  id: totrans-1231
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: According to the standard architecture, a controller is supposed to access DAO
    classes through a service layer. In the static scaffolding there’s no service
    layer. That’s fine if the application really is little more than a web-driven
    database, but in general applications need more than that.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 根据标准架构，控制器应该通过服务层访问 DAO 类。在静态脚手架中没有服务层。如果应用程序确实只是稍微多于一个由 Web 驱动的数据库，那么这没问题，但在一般情况下，应用程序需要更多。
- en: '|  |'
  id: totrans-1233
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Services
  id: totrans-1234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务
- en: Business logic in Grails should be placed in services, which are transactional,
    Spring-managed beans that can be automatically injected into other artifacts.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grails 中，业务逻辑应该放在服务中，这些服务是事务性的、由 Spring 管理的豆，可以自动注入到其他组件中。
- en: '|  |'
  id: totrans-1236
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This application does contain a service. It’s the `Geocoder`, familiar from
    the Groovy Baseball application. In the next listing it operates on `Castle`s.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序确实包含一个服务。它是来自 Groovy Baseball 应用程序的 `Geocoder`。在下一个列表中，它操作 `Castle`s。
- en: Listing 10.17\. The `Geocoder`, yet again, which works on `Castle`s this time
  id: totrans-1238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.17\. `Geocoder`，这次它操作 `Castle`s
- en: '[PRE144]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: That much code certainly has to be tested.^([[13](#ch10fn13)]) Grails has had
    testing capabilities from the beginning, which were originally based on JUnit
    subclasses. Since version 2.0, Grails test cases use annotations (specifically,
    the `@TestFor` annotation) to control so-called *mixin* classes. The `@TestFor`
    annotation applied to a controller or service test automatically instantiates
    the test and assigns it to an attribute.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 这样多的代码当然必须经过测试.^([[13](#ch10fn13)]) Grails 从一开始就具有测试能力，最初基于 JUnit 子类。从版本 2.0
    开始，Grails 测试用例使用注解（特别是，`@TestFor` 注解）来控制所谓的 *mixin* 类。将 `@TestFor` 注解应用于控制器或服务测试会自动实例化测试并将其分配给一个属性。
- en: ^(13) In pure test-driven development (TDD), the test would be written first.
    Then you watch it fail, implement the service, and watch the test eventually pass.
  id: totrans-1241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (13) 在纯测试驱动开发（TDD）中，首先编写测试。然后观察它失败，实现服务，并观察测试最终通过。
- en: For example, the next listing shows the test for the `GeocoderService` class.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下一个列表显示了 `GeocoderService` 类的测试。
- en: Listing 10.18\. The unit test for the `GeocoderService`
  id: totrans-1243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.18\. `GeocoderService` 的单元测试
- en: '![](284fig01_alt.jpg)'
  id: totrans-1244
  prefs: []
  type: TYPE_IMG
  zh: '![284fig01_alt.jpg]'
- en: '|  |'
  id: totrans-1245
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Test Cases
  id: totrans-1246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试用例
- en: Grails generates a unit-test class for each artifact (domain class, controller,
    or service) that it produces. The default implementations fail on purpose to encourage
    you to implement them properly.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 为它生成的每个组件（领域类、控制器或服务）生成一个单元测试类。默认实现故意失败，以鼓励您正确实现它们。
- en: '|  |'
  id: totrans-1248
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In a Grails application, services use Spring’s dependency injection. Here the
    `Geocoder` service is injected into `CastleController` to update the latitude
    and longitude before an instance is saved in a database. Injecting a service is
    done by declaring an attribute with the same name as the service with a lowercase
    first letter.^([[14](#ch10fn14)]) To illustrate, the following code is another
    section of the `CastleController` implementation.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grails 应用程序中，服务使用 Spring 的依赖注入。在这里，`Geocoder` 服务被注入到 `CastleController` 中，以便在数据库中保存实例之前更新纬度和经度。通过声明一个与服务同名的属性（首字母小写）来注入服务.^([[14](#ch10fn14)])
    例如，以下代码是 `CastleController` 实现的另一个部分。
- en: ^(14) In Spring parlance, this is “autowiring by name.”
  id: totrans-1250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (14) 在 Spring 术语中，这被称为“按名称自动装配”。
- en: Listing 10.19\. Dependency injection of a service into a controller
  id: totrans-1251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.19\. 将服务注入到控制器中
- en: '![](284fig02_alt.jpg)'
  id: totrans-1252
  prefs: []
  type: TYPE_IMG
  zh: '![284fig02_alt.jpg]'
- en: Services are injected by name (the term is *autowiring* in Spring) into the
    controller, so declaring a variable of the same name as the service using a lowercase
    first letter tells Grails to provide an instance of the service at that point.
    The service is used inside the `save` method to update the `Castle` before saving
    it.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通过名称注入到控制器中（在 Spring 中术语是 *autowiring*），因此使用与服务相同名称的变量并使用小写字母开头告诉 Grails 在该点提供一个服务的实例。该服务在
    `save` 方法中使用，以在保存之前更新 `Castle`。
- en: '|  |'
  id: totrans-1254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Grails Services
  id: totrans-1255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Grails 服务
- en: Use Grails applications with the standard, layered architecture. Let controllers
    delegate to services, and let the transactional services work with the databases.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的分层架构的 Grails 应用程序。让控制器委托给服务，并让事务性服务与数据库协同工作。
- en: '|  |'
  id: totrans-1257
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As noted earlier in this section, Grails has a rich set of available plugins.
    One that’s useful in this application is the Google Visualization plugin, which
    provides a custom library of GSP tags that generate JavaScript for Google Maps
    applications.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节前面所述，Grails 有一个丰富的可用插件集。在这个应用程序中，有用的一个插件是 Google Visualization 插件，它提供了一个用于生成
    Google Maps 应用 JavaScript 的自定义 GSP 标签库。
- en: As with everything else, Grails manages plugin installations in a standard way.
    The file `BuildConfig.groovy` in the grails-app/conf folder has a section on plugins.
    Adding the proper statement to that file causes Grails to automatically download
    and install the plugin on its next application start.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一切一样，Grails 以标准方式管理插件安装。grails-app/conf 文件夹中的 `BuildConfig.groovy` 文件有一个关于插件的章节。向该文件添加适当的语句会导致
    Grails 在下一次应用程序启动时自动下载并安装插件。
- en: 'Here’s the relevant section of the `BuildConfig.groovy` file:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `BuildConfig.groovy` 文件的相关部分：
- en: '[PRE145]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The documentation for the Google Visualization plugin says that to use it, add
    the tag `<gvisualization:apiImport` `/>` to the `<head>` section of the GSP where
    you want the map to appear. Then the plugin provides a `<gvisualization:map` `/>`
    tag to produce the map itself. The `map` tag uses `columns` and `data` attributes
    for the information for the map points, which I need to specify.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: Google Visualization 插件的文档说明，为了使用它，需要在希望地图出现的 GSP 的 `<head>` 部分添加 `<gvisualization:apiImport`
    `/>` 标签。然后插件提供了一个 `<gvisualization:map` `/>` 标签来生成 Google 地图应用的 JavaScript。`map`
    标签使用 `columns` 和 `data` 属性来指定地图点的信息，这是我需要指定的。
- en: The Quest application provides a nice demonstration of the process involved.
    Suppose I want the map to appear on the list.gsp page associated with the castles.
    Grails maps the URL [http://<host>:<port>/holygrails/castle/list](http://<host>:<port>/holygrails/castle/list)
    to the list action in the `CastleController` class. The last expression in that
    action is a map (a Groovy one rather than a Google one), so Grails automatically
    adds the entries to the HTTP request and forwards to the list.gsp page.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: Quest 应用程序提供了一个很好的过程演示。假设我想让地图出现在与城堡关联的 list.gsp 页面上。Grails 将 URL [http://<host>:<port>/holygrails/castle/list](http://<host>:<port>/holygrails/castle/list)
    映射到 `CastleController` 类中的 list 动作。该动作中的最后一个表达式是一个映射（Groovy 的而不是 Google 的），因此
    Grails 自动将条目添加到 HTTP 请求中，并将其转发到 list.gsp 页面。
- en: The goal, therefore, is to add the information needed by the map to the proper
    controller action. As usual, the data should come from a service, and I already
    have the `GeocoderService` available. The next listing shows the additional methods.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，目标是向适当的控制器动作添加地图所需的信息。像往常一样，数据应来自服务，我已经有 `GeocoderService` 可用。下一个列表显示了添加的额外方法。
- en: Listing 10.20\. Methods added to the `GeocoderService` to support the mapping
    plugin
  id: totrans-1265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.20\. 添加到 `GeocoderService` 的方法以支持映射插件
- en: '![](286fig01_alt.jpg)'
  id: totrans-1266
  prefs: []
  type: TYPE_IMG
  zh: '![](286fig01_alt.jpg)'
- en: The `list` action in the `CastleController` is already returning a list of castles
    and the total count, which are used to display them in a table. I might as well
    use the same action to return the columns and data for the map.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: '`CastleController` 中的 `list` 动作已经返回了一个城堡列表和总数，这些用于在表格中显示它们。我也可以使用相同的动作来返回地图的列和数据。'
- en: 'The revised `list` action in `CastleController` looks like this:'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '`CastleController` 中修订的 `list` 动作如下所示：'
- en: '[PRE146]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The following listing shows the additions made to the view, list.gsp, in order
    to display a map of castles.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了为显示城堡地图而添加到视图 list.gsp 的修改。
- en: Listing 10.21\. Modifications to `list.gsp` to display a Google Map of castles
  id: totrans-1271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.21\. 对 `list.gsp` 的修改以显示城堡的 Google 地图
- en: '![](286fig02_alt.jpg)'
  id: totrans-1272
  prefs: []
  type: TYPE_IMG
  zh: '![](286fig02_alt.jpg)'
- en: The result is shown in [figure 10.8](#ch10fig08), which displays the castles
    on a Google Map. The plugin generates the JavaScript required by the Google Maps
    API.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图 10.8 所示，它显示了 Google 地图上的城堡。插件生成了 Google 地图 API 所需的 JavaScript 代码。
- en: Figure 10.8\. Displaying the castles on a Google Map. The `Castle` domain classes
    have their latitude and longitude coordinates set by the `GeocoderService`. The
    Google Visualization plugin generates the proper JavaScript to add them to a Google
    Map.
  id: totrans-1274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.8. 在 Google 地图上显示城堡。`Castle` 领域类通过 `GeocoderService` 设置了纬度和经度坐标。Google
    可视化插件生成必要的 JavaScript 代码，将它们添加到 Google 地图上。
- en: '![](10fig08_alt.jpg)'
  id: totrans-1275
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig08_alt.jpg)'
- en: Grails is a large, powerful framework with lots of features, and the features
    it lacks are provided with plugins. If you spend any time with Groovy, it’s worth
    a look whenever you have to build web applications.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 是一个功能强大、特性丰富的框架，拥有众多特性，而它所缺少的特性则通过插件提供。如果你花时间学习 Groovy，那么在构建网络应用程序时，它总是值得一看。
- en: '|  |'
  id: totrans-1277
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Lessons learned (Grails)**'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: '**（Grails）学到的经验教训**'
- en: Grails is a convention-over-configuration framework for producing web applications.
  id: totrans-1279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Grails 是一个基于约定优于配置的框架，用于生成网络应用程序。
- en: Grails domain classes are managed by Hibernate and mapped to database tables.
  id: totrans-1280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Grails 领域类由 Hibernate 管理，并映射到数据库表。
- en: Grails services are Spring-managed beans that are autowired by name into other
    artifacts. They use Spring’s transaction management by default.
  id: totrans-1281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Grails 服务是 Spring 管理的豆，它们通过名称自动注入到其他组件中。它们默认使用 Spring 的交易管理。
- en: The plugin design of the Grails architecture makes it easy to add additional
    capabilities.
  id: totrans-1282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Grails 架构的插件设计使得添加额外功能变得容易。
- en: '|  |'
  id: totrans-1283
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Grails uses Spring and Hibernate under the hood, so it mixes Groovy-based domain-specific
    languages on top of major Java libraries.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: Grails 在底层使用 Spring 和 Hibernate，因此它将基于 Groovy 的领域特定语言混合在主要的 Java 库之上。
- en: 10.5\. Summary
  id: totrans-1285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5. 摘要
- en: This chapter examined ways Groovy helps with testing and building web applications.
    Unit tests are similar to their Java counterparts, but the Gradle build framework
    provides a great way to do integration testing of deployed applications.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了 Groovy 如何帮助进行测试和构建网络应用程序。单元测试与它们的 Java 对应物类似，但 Gradle 构建框架提供了一个很好的方法来进行已部署应用程序的集成测试。
- en: The Groovy JDK includes classes like `ServletCategory`, which simplify the implementation
    of web components. Groovy also has a built-in web scripting engine called groovlets,
    which makes it easy to work with requests, responses, sessions, and input parameters
    in a web application.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy JDK 包含像 `ServletCategory` 这样的类，这些类简化了网络组件的实现。Groovy 还有一个内置的网络脚本引擎，称为
    groovlets，这使得在 Web 应用程序中处理请求、响应、会话和输入参数变得容易。
- en: Finally, this chapter includes a brief discussion of Grails, possibly the biggest
    Java/Groovy integration success story of them all.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章简要讨论了 Grails，这可能是所有 Java/Groovy 集成成功故事中最大的一个。
