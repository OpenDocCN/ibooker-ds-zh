- en: 8 Automated testing for microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 微服务的自动化测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Automated testing of microservices
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务的自动化测试
- en: Unit testing and integration testing with Jest
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 进行单元测试和集成测试
- en: End-to-end testing with Cypress
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress 进行端到端测试
- en: Adding automated testing to your continuous delivery pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自动化测试添加到你的持续交付管道中
- en: To this point in the book while building microservices, we have tested our code
    manually. In this chapter, though, we’ll shift up a gear and learn how to apply
    automated testing to our microservices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在构建微服务的过程中，我们一直是手动测试我们的代码。然而，在这一章中，我们将提高一个档次，学习如何将自动化测试应用到我们的微服务中。
- en: So far, we have primarily done our testing by running our code and visually
    inspecting the output. In various chapters, we used our web browser, the output
    from the command line, or changes in the local filesystem to check the results
    of our code. In other chapters, we used more specific tools like Robo3T in chapter
    3 or the RabbitMQ dashboard in chapter 5.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要是通过运行我们的代码并视觉检查输出来进行测试。在各个章节中，我们使用了我们的网络浏览器、命令行输出或本地文件系统的变化来检查代码的结果。在其他章节中，我们使用了更具体的工具，如第
    3 章中的 Robo3T 或第 5 章中的 RabbitMQ 仪表板。
- en: Methods of manual testing are many and varied. I want you to know that manual
    testing is OK and perfectly valid. You should start with manual testing and continue
    with it until you are comfortable enough to use automated testing, and your product
    is well enough understood that it’s worth making the investment in that. I can
    recommend tools for manual testing like Postman or REST Client for Visual Studio
    Code. These will help you to manually test your REST APIs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试的方法多种多样。我想让你知道手动测试是完全可以接受的，并且是完全有效的。你应该从手动测试开始，并继续进行，直到你足够熟悉，可以使用自动化测试，并且你的产品足够了解，值得进行这样的投资。我可以推荐一些手动测试工具，比如
    Postman 或 Visual Studio Code 的 REST 客户端。这些工具将帮助你手动测试你的 REST API。
- en: At a point, though, manual testing becomes tedious and time-consuming. You will
    want to turn to automated testing. Of course, automated testing is generally useful
    in the realm of software development, but with microservices, it becomes essential
    as we grow our application. It’s also important for small teams because, at some
    point, the burden of manual testing becomes overwhelming to the point that all
    you’ll be doing is testing. There’s no reason you should carry a heavy testing
    burden when great testing tools are within easy reach!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某个时候，手动测试会变得繁琐且耗时。你将想要转向自动化测试。当然，自动化测试在软件开发领域通常是很有用的，但在微服务中，随着我们应用的增长，它变得至关重要。对于小型团队来说，这也同样重要，因为在某个时候，手动测试的负担会变得如此沉重，以至于你将只会进行测试。当有如此容易获取的优秀测试工具时，你没有理由承担沉重的测试负担！
- en: Think of this chapter as a guided tour through the testing landscape as it applies
    to microservices. We’ll start with an introduction to testing, then we’ll look
    at more advanced examples of unit testing, integration testing, and end-to-end
    testing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章视为一次针对微服务测试领域的导游。我们将从测试的介绍开始，然后我们将查看单元测试、集成测试和端到端测试的更高级示例。
- en: Automated testing is an advanced topic. I’ve included it in this book because
    I believe it really is essential for scaling microservices. If you haven’t done
    automated testing before, you might find this chapter a little overwhelming. Hopefully
    not, but otherwise, feel free to skip this chapter and come back to it again later.
    Just know that automated testing is important and that even though you don’t need
    it in the early days, eventually you will definitely need it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试是一个高级主题。我把它包含在这本书中，因为我相信它对于微服务的扩展确实是必不可少的。如果你之前没有进行过自动化测试，你可能会觉得这一章有点令人不知所措。希望不是这样，但如果你觉得难以理解，请随意跳过这一章，稍后再回来。只需知道自动化测试很重要，尽管在早期你可能不需要它，但最终你肯定会需要它。
- en: 8.1 New tools
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 新工具
- en: As modern developers, we are spoiled with great testing tools that are free,
    easily available, and straightforward to learn. In this chapter, we’ll learn automated
    testing with two popular and important testing tools. We’ll use Jest and Cypress
    to test our microservices to ensure these are robust.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为现代开发者，我们被丰富的免费、易于获取且易于学习的测试工具所宠溺。在本章中，我们将学习使用两个流行且重要的测试工具进行自动化测试。我们将使用 Jest
    和 Cypress 来测试我们的微服务，以确保它们的健壮性。
- en: Jest is a tool for testing JavaScript code; Cypress is a tool we’ll use for
    end-to-end testing. Both Jest and Cypress are written in JavaScript. If you are
    building microservices in a different language than JavaScript, then you probably
    wouldn’t pick Jest. Instead, you’d pick the best testing tool for your particular
    language.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是一个用于测试 JavaScript 代码的工具；Cypress 是我们将用于端到端测试的工具。Jest 和 Cypress 都是用 JavaScript
    编写的。如果你用不同于 JavaScript 的语言构建微服务，那么你可能不会选择 Jest。相反，你会选择最适合你特定语言的测试工具。
- en: Cypress is a great tool for testing web pages regardless of what language you
    use in the backend. If you aren’t using JavaScript as the language for your microservices,
    Cypress is still a great choice for your end-to-end testing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 是一个无论你使用什么后端语言都非常适合测试网页的出色工具。如果你不使用 JavaScript 作为你的微服务语言，Cypress 仍然是一个很好的端到端测试选择。
- en: Toward the end of the chapter, we’ll learn how to add automated testing to the
    continuous delivery (CD) pipeline we started in the previous chapter. This means
    our tests will be invoked automatically as we push code changes to our hosted
    code repository. That’s important because it makes the testing process a checkpoint
    before production. Broken code or failing tests will automatically halt deployment
    and alert us to problems as these are automatically detected.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，我们将学习如何将自动化测试添加到我们在上一章中开始的持续交付 (CD) 管道中。这意味着我们的测试将在我们将代码更改推送到托管代码仓库时自动调用。这很重要，因为它使得测试过程成为生产前的检查点。有问题的代码或失败的测试将自动停止部署，并在这些问题自动检测到时提醒我们。
- en: Table 8.1 New tools in chapter 8
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 第 8 章中的新工具
- en: '| Tool | Version | Purpose |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 版本 | 目的 |'
- en: '| Jest | 26.2.2 | Jest is a tool for automated testing of JavaScript code.
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Jest | 26.2.2 | Jest 是一个用于自动化测试 JavaScript 代码的工具。|'
- en: '| Cypress | 4.12.1 | Cypress is a tool for automated testing of web pages.
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Cypress | 4.12.1 | Cypress 是一个用于网页自动化测试的工具。|'
- en: 8.2 Getting the code
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 获取代码
- en: To follow along with this chapter you need to download the code or clone the
    repository.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，你需要下载代码或克隆仓库。
- en: 'Download a zip file of the code from here:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从这里下载代码的 zip 文件：
- en: '[https://github.com/bootstrapping-microservices/chapter-8](https://github.com/bootstrapping-microservices/chapter-8)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/bootstrapping-microservices/chapter-8](https://github.com/bootstrapping-microservices/chapter-8)'
- en: 'You can clone the code using Git like this:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Git 如下克隆代码：
- en: '`git clone https://github.com/bootstrapping-microservices/chapter-8.git`'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/bootstrapping-microservices/chapter-8.git`'
- en: For help on installing and using Git, see chapter 2\. If you have problems with
    the code, log an issue against the repository in GitHub.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安装和使用 Git 的帮助，请参阅第 2 章。如果你遇到代码问题，请在 GitHub 仓库中记录一个问题。
- en: 8.3 Testing for microservices
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 微服务测试
- en: Like any code that we write, microservices need to be well tested so we can
    know the code is robust, difficult to break, and can gracefully handle problems.
    Testing gives us peace of mind that our code functions in both normal and unexpected
    circumstances.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们编写的任何代码一样，微服务需要经过良好的测试，这样我们才能知道代码是健壮的、难以破坏的，并且可以优雅地处理问题。测试让我们对我们的代码在正常和意外情况下都能正常工作感到安心。
- en: Effective testing emulates production as closely as possible. This includes
    both the environment, the configuration of the code, and the test data that we
    use. Using Docker and Docker Compose allows us to configure our testing environment
    to be like the production environment.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的测试尽可能模拟生产环境。这包括环境、代码配置以及我们使用的测试数据。使用 Docker 和 Docker Compose 允许我们配置测试环境，使其类似于生产环境。
- en: This makes the “it worked on my computer” excuse for broken code much less useful
    in modern development. Usually, when it works on your computer (in a correctly
    configured Docker environment), you can be fairly sure it’s going to work in the
    production environment. Having a stable environment for our code is a crucial
    factor for reliable testing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得“在我的电脑上运行正常”这个理由在现代开发中对于有问题的代码来说变得不那么有用。通常，当你在正确配置的 Docker 环境中运行时，你可以相当确信它将在生产环境中运行。为我们的代码提供一个稳定的运行环境是可靠测试的关键因素。
- en: Manual testing is a good starting point and is a skill worth cultivating. But
    at a certain point, automated testing is necessary to scale up our application.
    As the number of microservices grows, we will rely more and more on automation
    to keep the application running and to help us maintain a rapid pace of development.
    In the previous chapter, we created our CD pipeline to automate deployment. Now,
    let’s turn our attention to bringing automated testing online.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试是一个好的起点，并且是一项值得培养的技能。但到了某个阶段，自动化测试对于扩展我们的应用程序是必要的。随着微服务数量的增长，我们将越来越多地依赖自动化来保持应用程序的运行并帮助我们保持快速的开发节奏。在前一章中，我们创建了我们的持续交付（CD）管道来自动化部署。现在，让我们将注意力转向将自动化测试上线。
- en: 8.4 Automated testing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 自动化测试
- en: Automated testing, put simply, is *code-driven* testing. We write code to exercise
    our code and verify that it works correctly. This sounds like circular logic,
    but we break out of it after a single iteration. We have our application code
    or *code under test* and then we have our test code (or just *tests*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，自动化测试是*代码驱动*测试。我们编写代码来执行我们的代码并验证其正确性。这听起来像是循环逻辑，但我们在一次迭代后就打破了它。我们拥有应用程序代码或*被测试的代码*，然后我们拥有测试代码（或只是*测试*）。
- en: Often the test code directly invokes the code under test, but it can also be
    invoked indirectly, for example, through HTTP requests or RabbitMQ messages. The
    test code then verifies that the result is correct, either by checking the output
    or checking the behavior.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，测试代码直接调用被测试的代码，但它也可以通过HTTP请求或RabbitMQ消息间接调用。然后，测试代码验证结果是否正确，无论是通过检查输出还是检查行为。
- en: Throughout this chapter, you’ll learn a handful of automated testing techniques.
    You’ll be able to apply these techniques over and over again to create a comprehensive
    suite of tests for your application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习一些自动化测试技术。你将能够反复应用这些技术，为你的应用程序创建一个全面的测试套件。
- en: 'Testing for microservices can be applied at multiple levels. We can test individual
    functions, we can test whole microservices, we can test groups of microservices
    together, or we can test the whole application (until the application grows too
    large; more about that later). These levels of testing are related to the following
    three types of automated testing:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务测试可以在多个级别上应用。我们可以测试单个函数，可以测试整个微服务，可以一起测试微服务组，或者可以测试整个应用程序（直到应用程序变得太大；关于这一点稍后会有更多介绍）。这些测试级别与以下三种类型的自动化测试相关：
- en: '*Unit testing* —Tests isolated code and individual functions'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元测试* —测试隔离的代码和单个函数'
- en: '*Integration testing* —Tests whole microservices'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*集成测试* —测试整个微服务'
- en: '*End-to-end testing* —Tests groups of microservices and/or the entire application
    including the front end'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*端到端测试* —测试微服务组以及/或整个应用程序（包括前端）'
- en: You may have heard of these types of testing before. If not, don’t worry because
    we’ll look at each in turn.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前听说过这些测试类型。如果没有，不要担心，因为我们将逐一查看每种。
- en: Figure 8.1 shows a diagram that is called the *testing pyramid*. It relates
    the types of automated testing to each other and gives you an idea of how many
    of each type of test you should have in your test suite.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1显示了一个被称为*测试金字塔*的图表。它将自动化测试类型相互关联，并给你一个关于在你的测试套件中应该有多少每种类型测试的想法。
- en: '![](../Images/CH08_F01_Davis4.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F01_Davis4.png)'
- en: Figure 8.1 The testing pyramid indicates the relative amounts of each type of
    test we should have.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 测试金字塔显示了我们应该拥有的每种类型测试的相对数量。
- en: Unit tests run quickly, so you can afford to have many of these. These are,
    therefore, at the foundation of the testing pyramid. Integration testing and end-to-end
    testing are higher in the pyramid. These types of tests are slower to run, so
    you can’t afford to have as many of those. (The diminishing area as we go up the
    pyramid indicates that we’ll have less and less of these types of tests.) This
    means we should have fewer integration tests than unit tests and fewer end-to-end
    tests than integration tests.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试运行速度快，因此你可以拥有很多这样的测试。因此，它们是测试金字塔的基础。集成测试和端到端测试位于金字塔的更高位置。这些类型的测试运行速度较慢，因此你无法拥有那么多。（随着我们向上移动金字塔，减少的区域表示我们将越来越少地使用这些类型的测试。）这意味着我们应该比单元测试更少地拥有集成测试，比集成测试更少地拥有端到端测试。
- en: Figure 8.2 illustrates what end-to-end testing looks like for a cut-down version
    of FlixTube. In that figure, I show end-to-end testing first, because it’s the
    type of testing most like manual testing; that is, we test against the whole application
    in a manner similar to how our customer would use it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2展示了FlixTube简化版本的端到端测试的样子。在那张图中，我首先展示了端到端测试，因为它是最像手动测试的测试类型；也就是说，我们以类似于客户使用它的方式测试整个应用程序。
- en: End-to-end testing is the easiest type of testing to understand, even though
    it’s actually quite involved, and we don’t get to it until near the end of this
    chapter. End-to-end testing is closest to manual testing because we have to load
    the entire application to test it, just like we do when testing manually. Figure
    8.2 shows running Cypress tests against a cut-down version of our whole application
    that is running on Docker Compose.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是最容易理解的测试类型，尽管实际上它相当复杂，我们直到本章快结束时才能触及它。端到端测试与手动测试最为接近，因为我们必须加载整个应用程序来测试它，就像我们手动测试时做的那样。图8.2显示了针对在Docker
    Compose上运行的我们整个应用程序的简化版本运行Cypress测试。
- en: '![](../Images/CH08_F02_Davis4.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2](../Images/CH08_F02_Davis4.png)'
- en: Figure 8.2 End-to-end testing of a simplified version of FlixTube using Cypress
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 使用Cypress对FlixTube简化版本进行端到端测试
- en: Automated testing coupled with CD is like an early warning system. When the
    alarm goes off, we can be thankful, as it gives us the opportunity to stop problems
    going into production and potentially impacting our customers. Automated testing
    (like automated deployment) is best started early in the project because trying
    to bolt automated testing onto a legacy application (one not designed to be tested)
    can be extremely difficult.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试与持续交付（CD）结合就像是一个早期预警系统。当警报响起时，我们可以感到庆幸，因为它给了我们停止问题进入生产并可能影响我们的客户的机会。自动化测试（就像自动化部署一样）最好在项目早期开始，因为试图将自动化测试附加到一个遗留应用程序（一个未设计为可测试的应用程序）可能非常困难。
- en: But don’t start automated testing too early in the development lifecycle. It’s
    a balancing act. When starting a new product, you should first begin with a prototyping
    phase prior to adding automated testing. *Prototyping* allows you to experiment
    with your product before committing to it. If you aren’t sure exactly what your
    product is yet (e.g., you are still experimenting) or if you are still trying
    to validate your business model, then you might want to hold off on automated
    testing and stick with manual testing for a bit longer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要在开发生命周期的早期就开始自动化测试。这是一个平衡行为。当开始一个新产品时，你应该首先从原型设计阶段开始，然后再添加自动化测试。*原型设计*允许你在做出承诺之前对你的产品进行实验。如果你还不确定你的产品是什么（例如，你仍在实验）或者如果你仍在尝试验证你的商业模式，那么你可能想要推迟自动化测试，并继续进行更长时间的手动测试。
- en: Building infrastructure for testing is a significant investment in your product.
    For the purpose of this chapter, let’s imagine that we are ready to make the automated
    testing commitment for FlixTube.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为测试构建基础设施是对你产品的重大投资。为了本章的目的，让我们假设我们已经准备好为FlixTube做出自动化测试的承诺。
- en: Note The true payoff with automated testing is that it will save you from countless
    hours of routine testing, not to mention that it can stop deployment of broken
    code that might have otherwise gone into production and caused havoc.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：自动化测试的真正回报是它能让你摆脱无数小时的常规测试，更不用说它还能阻止可能已经进入生产并造成混乱的损坏代码的部署。
- en: As amazing as automated testing is, it is not a panacea! It is not a replacement
    for good exploratory testing (e.g., manual testing) by actual humans. That still
    needs to happen because it’s the only way to find the bugs that the development
    team couldn’t even imagine.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自动化测试非常神奇，但它并不是万能的！它不能替代由真实人类进行的良好探索性测试（例如，手动测试）。这仍然需要发生，因为这是发现开发团队甚至无法想象的错误唯一的方式。
- en: Automated testing isn’t just about proving that your code works. It also serves
    as an invaluable communication tool, a kind of *executable documentation* that
    demonstrates how the code is intended to be used. It also gives you a safe framework
    in which to refactor and restructure your application. This allows you to continuously
    move towards a simpler and more elegant architecture. Let’s now work through each
    type of testing and look at examples of tests applied to the metadata microservice
    and then to the FlixTube application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试不仅仅是证明你的代码能正常工作。它还作为一个无价的沟通工具，一种*可执行文档*，展示了代码应该如何使用。它还为你提供了一个安全的框架，可以在其中重构和重构你的应用程序。这让你可以持续地向更简单、更优雅的架构迈进。现在，让我们逐一分析每种测试类型，并查看应用于元数据微服务和
    FlixTube 应用程序的测试示例。
- en: 8.5 Testing with Jest
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 使用 Jest 进行测试
- en: Testing is a huge topic, so let’s start by looking at some simpler examples
    that aren’t directly related to microservices. The code we’ll look at in this
    section is generally applicable for testing JavaScript code, regardless of whether
    that code is in a front end, a backend, or even in a mobile or desktop application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个非常大的主题，所以让我们先看看一些简单的例子，这些例子与微服务没有直接关系。在本节中，我们将查看的代码通常适用于测试 JavaScript 代码，无论这些代码是在前端、后端，还是在移动或桌面应用程序中。
- en: If you can already write an automated test with Jest, and you understand mocking,
    feel free to skip this section and move directly to section 8.6\. In that section,
    we’ll start to relate automated testing to microservices.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经能够使用 Jest 编写自动化测试，并且理解模拟，那么你可以自由地跳过本节，直接进入 8.6 节。在那个部分，我们将开始将自动化测试与微服务联系起来。
- en: For this section, imagine we are creating a JavaScript math library for use
    in our microservices. We’ll use Jest to do our testing. That’s a JavaScript testing
    tool and framework. Figure 8.3 gives you an idea of how we’ll use it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，假设我们正在为我们的微服务创建一个 JavaScript 数学库。我们将使用 Jest 进行测试。那是一个 JavaScript 测试工具和框架。图
    8.3 给出了我们将如何使用它的想法。
- en: '![](../Images/CH08_F03_Davis4.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F03_Davis4.png)'
- en: Figure 8.3 Automated testing with Jest
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 使用 Jest 进行自动化测试
- en: In the figure, on the left, we have math.test.js. This is a file that contains
    the tests that we’ll run against our math library. On the right, we have math.js.
    This is the file that contains the code for our math library. When we run Jest,
    it loads our test code, which in turn, runs the code we are testing. From our
    tests, we can directly invoke our code to test it and then verify in the result
    that everything went as expected.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，左侧是 math.test.js。这是一个包含我们将对其运行测试的测试的文件。右侧是 math.js。这是一个包含我们数学库代码的文件。当我们运行
    Jest 时，它会加载我们的测试代码，然后反过来运行我们正在测试的代码。从我们的测试中，我们可以直接调用我们的代码来测试它，并在结果中验证一切是否如预期进行。
- en: 8.5.1 Why Jest?
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 为什么选择 Jest？
- en: Jest is arguably the most popular testing tool and framework for JavaScript.
    It is easy to set up with minimal configuration, so it’s great for beginners.
    It’s fast, and it can run tests in parallel. Jest also has great support for live
    reloading; you can run it in *watch* mode, where it reloads by itself while you
    are coding.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 可以说是最流行的 JavaScript 测试工具和框架。它易于设置，配置简单，非常适合初学者。它运行速度快，可以并行运行测试。Jest 还提供了出色的实时重新加载支持；你可以在*监视*模式下运行它，在你编码时它会自动重新加载。
- en: Jest was created by Facebook, so you know it has great support behind it. But
    it also has a huge following and many contributors outside of Facebook. The API
    is extensive, supports multiple styles of testing, and has various ways of validating
    tests and creating mocks. And Jest has great support for creating mock objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是由 Facebook 创建的，所以你知道它背后有强大的支持。但它也有大量的追随者和许多来自 Facebook 以外的贡献者。API 非常全面，支持多种测试风格，并提供了多种验证测试和创建模拟的方法。Jest
    在创建模拟对象方面也有出色的支持。
- en: 'There are other great features that we won’t even touch on in this chapter.
    (At the end of the chapter, you’ll find a link to learn more about Jest.) Jest
    is open source and free to use. You can find the code here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中还有一些其他非常棒的功能，我们甚至不会在这里提及。（在章节末尾，你可以找到一个链接，了解更多关于 Jest 的信息。）Jest 是一个开源且免费使用的工具。你可以在以下链接找到代码：
- en: '[https://github.com/facebook/jest](https://github.com/facebook/jest)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/facebook/jest](https://github.com/facebook/jest)'
- en: 8.5.2 Setting up Jest
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 设置 Jest
- en: We’ll start by looking at example-1 in the chapter-8 code repository. This example
    is small enough that you can type it out directly if you like. If you don’t want
    to do that, you can get the code from GitHub to follow along.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看第 8 章代码仓库中的 example-1。这个例子足够小，如果你愿意，可以直接输入。如果你不想这样做，你可以从 GitHub 获取代码来跟随学习。
- en: 'You can run these tests for yourself and make changes to those to see what
    happens. Example-1 already has Jest in its package.json, so we’ll simply install
    dependencies for the project:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以亲自运行这些测试，并对它们进行修改以查看会发生什么。Example-1 已经在 package.json 中包含了 Jest，所以我们将简单地安装项目的依赖项：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can install Jest into a new Node.js project like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样将 Jest 安装到新的 Node.js 项目中：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We used the `--save-dev` argument to save Jest as a dev dependency in package.json.
    Jest is something we’ll only use in our development or testing environment, so
    we save it as a dev dependency so that it’s excluded from our production environment.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `--save-dev` 参数将 Jest 保存为 package.json 中的开发依赖。Jest 是我们只在开发或测试环境中使用的东西，所以我们将其保存为开发依赖，以便从我们的生产环境中排除。
- en: If you look in the package.json file, you’ll see that I’ve installed Jest version
    26.2.2\. When you install Jest in the future, you will see a later version. Much
    of what you learn here will still be valid because Jest is stable (it’s up to
    version 26!).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 package.json 文件，你会看到我已经安装了 Jest 版本 26.2.2。当你将来安装 Jest 时，你会看到更新的版本。这里学到的许多内容仍然有效，因为
    Jest 是稳定的（它已经更新到 26 版本了！）
- en: The following listing shows the Jest configuration from example-1\. This is
    actually the default configuration that was generated by Jest. I didn’t change
    it except to remove comments.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 example-1 的 Jest 配置。这实际上是 Jest 生成的默认配置。我没有做任何修改，除了移除注释。
- en: Listing 8.1 Configuration file for Jest (chapter-8/example-1/jest.config.js)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 Jest 的配置文件（第 8 章/example-1/jest.config.js）
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Automatically clears mocks between every test (I’ll explain mocks soon)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ① 自动在每次测试之间清除模拟（我很快会解释模拟）
- en: ② This is the environment for testing Node.js.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这是测试 Node.js 的环境。
- en: 'When starting a fresh project, create your own Jest configuration file like
    this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当开始一个新项目时，创建你自己的 Jest 配置文件如下：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you initialize your Jest configuration, it asks you a few questions. If
    you accept all the defaults, then your configuration file will look similar to
    listing 8.1\. I only changed `clearMocks` to `true` (default is `false`) to help
    stop tests from interfering with each other.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你初始化 Jest 配置时，它会问你几个问题。如果你接受所有默认设置，那么你的配置文件将类似于列表 8.1。我只将 `clearMocks` 改为 `true`（默认为
    `false`），以帮助防止测试相互干扰。
- en: Just to remind you, `npx` is a command that comes with Node.js and allows us
    to run npm modules as command-line applications. There are many npm installable
    modules that work this way, including Jest. You might recall the `wait-port` command
    we used with `npx` back in chapter 5.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了提醒你，`npx` 是 Node.js 中的一个命令，它允许我们以命令行应用程序的方式运行 npm 模块。有许多可安装的 npm 模块以这种方式工作，包括
    Jest。你可能还记得我们在第 5 章中使用 `npx` 的 `wait-port` 命令。
- en: When you generate the configuration file as in the listing, you’ll see it contains
    many options that are commented out. Reading through the generated configuration
    file is a great way to understand what’s possible with Jest. Because it’s not
    necessary for this example, I removed the comments to have a minimal configuration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你生成如列表所示的配置文件时，你会看到它包含许多被注释掉的选项。阅读生成的配置文件是了解 Jest 所能实现功能的好方法。因为在这个例子中并不需要，所以我移除了注释以获得一个最小化的配置。
- en: Figure 8.4 shows the structure of the example-1 Node.js project with Jest installed.
    You can see the familiar package.json and package-lock.json files that are in
    every Node.js project that we learned about in chapter 2\. As for Jest, note that
    this project contains the Jest configuration file (content shown in listing 8.1)
    and the files for our code and tests. The code for our maths library is in math.js,
    and the code for our tests is in math.test.js. As with any other npm module, Jest
    itself is installed under the node_modules directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 展示了安装了 Jest 的 example-1 Node.js 项目的结构。你可以看到熟悉的 package.json 和 package-lock.json
    文件，这些文件在我们第 2 章中学到的每个 Node.js 项目中都有。至于 Jest，请注意，该项目包含 Jest 配置文件（内容如列表 8.1 所示）以及我们的代码和测试文件。我们的数学库代码在
    math.js 中，测试代码在 math.test.js 中。与任何其他 npm 模块一样，Jest 本身安装在 node_modules 目录下。
- en: '![](../Images/CH08_F04_Davis4.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_Davis4.png)'
- en: Figure 8.4 The structure of a fairly typical Node.js project with Jest installed
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 安装了 Jest 的相当典型的 Node.js 项目的结构
- en: Note that the test file is named after the code that it tests. When creating
    math.test.js, we simply appended .test.js to the name of our library. This naming
    convention is how Jest locates our test code. Jest automatically loads code with
    *.test* in the name. This is a default convention with Jest, but we can configure
    it differently if we want a different convention.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试文件是以它所测试的代码命名的。在创建math.test.js时，我们只是简单地将.test.js添加到我们库的名称中。这种命名约定是Jest定位我们的测试代码的方式。Jest自动加载名称中包含*.test*的代码。这是Jest的默认约定，但如果我们想有不同的约定，我们可以进行配置。
- en: Notice how the test file (math.test.js) is right next to the code file (math.js)
    in the same directory. This is another convention, and one that is fairly common.
    We could have placed these two files anywhere within the directory structure of
    our project, and it wouldn’t make much difference. Another common convention is
    to have all tests separated from the application code and located under a test
    or tests subdirectory that is next to or just under the src subdirectory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试文件（math.test.js）是如何紧挨着代码文件（math.js）放在同一目录下的。这是另一个约定，而且相当常见。我们本可以将这两个文件放在项目目录结构中的任何地方，这不会有多大区别。另一个常见的约定是将所有测试与应用程序代码分离，并位于紧挨着或位于src子目录下的test或tests子目录中。
- en: You might have noticed that the Jest configuration file is actually a JavaScript
    file itself. This means you can use JavaScript code in your configuration. It’s
    actually quite common for JavaScript and Node.js tools to have an executable configuration
    file, and I think it’s pretty cool that JavaScript can be used as its own configuration
    language.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，Jest配置文件实际上是一个JavaScript文件本身。这意味着你可以在配置中使用JavaScript代码。实际上，JavaScript和Node.js工具拥有可执行配置文件是很常见的，我认为JavaScript可以用作其自身的配置语言是非常酷的。
- en: 8.5.3 The math library to test
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.3 要测试的数学库
- en: Now imagine we have added the first function to our new math library. The following
    listing shows the `square` function. This is a simple function that takes one
    number and returns the square of that number.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们已经向我们的新数学库添加了第一个函数。下面的列表显示了`square`函数。这是一个简单的函数，它接受一个数字并返回该数字的平方。
- en: Listing 8.2 A starting point for our new math library (chapter-8/example-1/src/math.js)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2 我们新数学库的起点（chapter-8/example-1/src/math.js）
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① A simple JavaScript function computes the square of a number. This is the
    code we’ll test.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ① 一个简单的JavaScript函数计算一个数字的平方。这是我们将要测试的代码。
- en: ② You can add more functions for your math library here as you develop it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ② 你可以在开发过程中在此处为你的数学库添加更多函数。
- en: ③ Exports the “square” function so we can use it in our code modules. This is
    also how we access it from our test code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 导出“square”函数，以便我们可以在代码模块中使用它。这也是我们从测试代码中访问它的方式。
- en: ④ Other functions are exported here as you add them to your math library.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 随着你将更多函数添加到你的数学库中，这里将导出其他函数。
- en: In the future, we would add many more functions to math.js. But for now, we’ll
    keep it short so it can be a simple demonstration of automated testing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，我们将向math.js添加更多函数。但到目前为止，我们会保持它简短，这样它就可以作为一个简单的自动化测试演示。
- en: 8.5.4 Your first Jest test
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.4 你的第一个Jest测试
- en: The `square` function is a simple function with a simple result, and more complex
    functions always depend on simpler functions like this. To be sure that the complex
    functions work, we must first test the simple functions. Yes, even though this
    function is simple, we still want to test it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`square`函数是一个简单的函数，具有简单的结果，而更复杂的函数总是依赖于像这样的简单函数。为了确保复杂函数正常工作，我们必须首先测试简单函数。是的，尽管这个函数很简单，我们仍然想测试它。'
- en: Of course, this is JavaScript. We can easily test this function manually using
    the Node.js REPL. But it’s almost as easy to get this function covered under automated
    testing, which (combined with many other tests for many other functions) can save
    us time in the future. Not to mention that I’m demonstrating testing here, so
    if only for that purpose alone, let’s write our first automated test.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是JavaScript。我们可以很容易地使用Node.js REPL手动测试这个函数。但将其纳入自动化测试中几乎同样容易，这（结合对许多其他函数的许多其他测试）可以在未来为我们节省时间。不用说，我在这里演示测试，所以仅为此目的，让我们编写我们的第一个自动化测试。
- en: Listing 8.3 shows the code that tests our nascent math library. The `describe`
    function defines a test suite called `square` function. The `test` function defines
    our first test called `can square two`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3显示了测试我们初生的数学库的代码。`describe`函数定义了一个名为`square`函数的测试套件。`test`函数定义了我们第一个测试，名为`can
    square two`。
- en: Listing 8.3 A first test with Jest (chapter-8/example-1/src/math.test.js)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 使用 Jest 的第一个测试（chapter-8/example-1/src/math.test.js）
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Imports the code we are testing
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入我们正在测试的代码
- en: ② Creates a test suite called “square function”
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个名为“square function”的测试套件
- en: ③ Creates a test called “can square two”
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建一个名为“can square two”的测试
- en: ④ Invokes the “square” function and captures the result
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 调用“square”函数并捕获结果
- en: ⑤ Sets an expectation that the result will be 4\. If the expectation is not
    satisfied, the test fails.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 设置一个期望，结果将是 4。如果期望没有得到满足，测试将失败。
- en: We have named this test suite after the function it is testing. You can imagine
    in the future that we might have other test suites in this file for other functions
    in our maths library (you’ll see some more examples of this soon).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个测试套件命名为它所测试的函数。你可以想象在将来，我们可能会在这个文件中为我们的数学库中的其他函数有其他测试套件（你很快就会看到更多这方面的示例）。
- en: In listing 8.3, we imported our `square` function from the file math.js. In
    our test `can square two`, we then called it with the number 2 as input. You can
    see that the name of the test implies what the test is actually doing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.3 中，我们从 math.js 文件中导入了我们的 `square` 函数。然后，在我们的测试 `can square two` 中，我们用数字
    2 作为输入调用它。你可以看到测试的名称暗示了测试实际上在做什么。
- en: Note A good name for a test allows you to instantly understand what is being
    tested.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一个好的测试名称可以让你立即了解正在测试的内容。
- en: We then use the `expect` and `toBe` functions to verify that the result of the
    `square` function is the number 4\. Various combinations of functions can be chained
    onto the `expect` function (see the Jest docs for more examples at [https://jestjs.io/docs/
    en/expect](https://jestjs.io/docs/en/expect), which gives a rich syntax for describing
    the expected output of the code being tested).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用 `expect` 和 `toBe` 函数来验证 `square` 函数的结果是否为数字 4。可以将各种函数组合链接到 `expect` 函数上（更多示例请参阅
    Jest 文档[https://jestjs.io/docs/en/expect](https://jestjs.io/docs/en/expect)，它提供了丰富的语法来描述正在测试的代码的预期输出）。
- en: 8.5.5 Running your first test
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.5 运行你的第一个测试
- en: 'Now that we have looked at the code to test and the tests themselves, we are
    ready to run Jest and see what a successful test run looks like (trust me, I already
    know this code works). From the terminal in the example-1 directory, run the tests
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看要测试的代码和测试本身，我们准备运行 Jest，看看成功的测试运行看起来像什么（相信我，我已经知道这段代码是有效的）。在 example-1
    目录的终端中，按照以下方式运行测试：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can see the output of the successful test run in figure 8.5\. We have one
    test and one test suite, both have completed successfully.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 8.5 中看到成功测试运行的输出。我们有一个测试和一个测试套件，两者都成功完成。
- en: '![](../Images/CH08_F05_Davis4.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F05_Davis4.png)'
- en: Figure 8.5 The output of our successful test run with Jest
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 使用 Jest 成功测试运行的输出
- en: 8.5.6 Live reload with Jest
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.6 使用 Jest 进行实时重新加载
- en: 'Live reloading is important for developer productivity, especially while testing.
    While coding and writing tests, you can run Jest in live reload mode as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实时重新加载对于开发者生产力至关重要，尤其是在测试时。在编码和编写测试时，你可以按照以下方式以实时重新加载模式运行 Jest：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That command works for all projects and runs all tests when any code changes.
    If you are using Git, you can also use this command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令适用于所有项目，在代码更改时运行所有测试。如果你使用 Git，你还可以使用此命令：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second version has better performance because it uses Git to know which
    files have changed (rather than just blindly running all the tests). This is a
    great way to work. Change some code and the tests automatically run and show you
    if anything has been broken!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本性能更好，因为它使用 Git 来知道哪些文件已更改（而不是盲目地运行所有测试）。这是一种很好的工作方式。更改一些代码，测试就会自动运行，并显示是否有什么被破坏了！
- en: 8.5.7 Interpreting test failures
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.7 解释测试失败
- en: All is good and well when our tests are passing, but what about when we have
    a problem in our code and our tests are failing? Don’t wait until you accidentally
    break your code to find out!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的测试通过时，一切都很顺利，但如果我们代码中出现问题，测试失败时怎么办？不要等到你意外破坏了代码才知道！
- en: 'Let’s try it now. It’s as simple as changing the behavior of our code. For
    instance, try changing the `square` function to return the wrong result:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。这就像改变我们代码的行为一样简单。例如，尝试将 `square` 函数更改为返回错误的结果：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how I replaced the multiplication operator with the binary AND operator.
    Let’s see what our tests have to say about this.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何将乘法运算符替换为二进制 AND 运算符。让我们看看我们的测试对此有何看法。
- en: You can see the output of the now failing test in figure 8.6\. When a test fails,
    Jest finishes with a nonzero exit code. This indicates that a failure happened.
    We’ll make use of this later in our CD pipeline to prevent deployment in circumstances
    when our tests have failed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图8.6中看到现在失败的测试输出。当一个测试失败时，Jest会以非零退出码结束。这表明发生了失败。我们将在我们的CD管道中利用这一点，以防止在测试失败的情况下进行部署。
- en: '![](../Images/CH08_F06_Davis4.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F06_Davis4.png)'
- en: Figure 8.6 The output of a failed test in Jest
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 Jest中失败的测试输出
- en: This test failed because we changed the expected behavior of our code. We broke
    our own code on purpose to see the result, but you can also imagine how a simple
    typo in our regular development process could have caused this problem in production
    code. If you didn’t have the automated test in place, this problem could easily
    fall through the cracks of manual testing and later be discovered by a customer.
    That’s embarrassing, to say the least, but it can cause real problems for our
    business, depending on the nature of the actual bug.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试失败是因为我们更改了代码的预期行为。我们故意破坏了自己的代码以查看结果，但你也可以想象在我们的常规开发过程中一个简单的打字错误是如何在生产代码中引起这个问题的。如果你没有设置自动测试，这个问题很容易在手动测试中遗漏，后来被客户发现。这至少是尴尬的，但根据实际错误的性质，它可能会对我们的业务造成真正的问题。
- en: Of course, the intention here is not just to test the `square` function. That
    by itself won’t be effective. What we need is to have a large proportion of our
    code covered by such tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里的意图不仅仅是测试`square`函数。仅此本身不会有效。我们需要的是让大量代码被这样的测试覆盖。
- en: 'A large body of tests gives us an automatic verification system that we run
    to prove, without a doubt, that our code works as intended. More importantly,
    it proves to us that our code continues to work in the future as we evolve it.
    It’s handy to note that you can simulate failing code anywhere you like by throwing
    an exception like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一大批测试为我们提供了一个自动验证系统，我们可以运行它来毫无疑问地证明我们的代码按预期工作。更重要的是，它证明我们的代码在未来的演变中仍然按预期工作。值得注意的是，你可以在任何你想要的地方通过抛出异常来模拟失败的代码，如下所示：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The best way to be fearless in the face of errors is to ruthlessly try and cause
    those in your own code. Once you have seen all the errors, it takes away the fear,
    and you can focus on understanding and fixing the problem. Simulating or causing
    problems in code to make sure that our application handles it gracefully is known
    as *chaos engineering* (check the end of chapter 10 for a reference to learn more
    about this).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 面对错误时无所畏惧的最佳方式是残忍地尝试在自己的代码中引发这些错误。一旦你看到了所有的错误，恐惧就会消失，你可以专注于理解和解决问题。为了确保我们的应用程序能够优雅地处理问题，在代码中模拟或引发问题被称为*混沌工程*（有关更多信息的参考，请查看第10章末尾）。
- en: 8.5.8 Invoking Jest with npm
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.8 使用npm调用Jest
- en: 'In chapter 2, we introduced the idea of adding npm scripts to our package.json
    file so that we can use the conventional npm commands like `npm start`*.* In chapter
    2, we also configured the start script. We’ll do the same for the test script
    here. Once we have configured package.json for this, we can run our test suite
    by typing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们介绍了向package.json文件添加npm脚本的思路，以便我们可以使用常规的npm命令，如`npm start`*.* 在第2章中，我们还配置了start脚本。这里我们也将为test脚本做同样的事情。一旦我们为package.json配置了这些，我们就可以通过输入以下命令来运行我们的测试套件：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This convention means that we can easily run tests for any Node.js project.
    We don’t have to know if the project is using Jest or some other testing tool!
    Indeed, you’ll see later in this chapter how we’ll also run Cypress tests with
    the same command. The following listing shows our package.json with a test script
    to run our Jest tests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约定意味着我们可以轻松地为任何Node.js项目运行测试。我们不需要知道项目是否正在使用Jest或其他测试工具！实际上，你将在本章后面看到我们如何使用相同的命令运行Cypress测试。以下列表显示了我们的package.json文件，其中包含一个用于运行Jest测试的测试脚本。
- en: Listing 8.4 Package.json with npm scripts for running Jest (chapter-8/example-1/package.json)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 包含运行Jest的npm脚本的package.json（chapter-8/example-1/package.json）
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Setup for running Jest by invoking “npm test”
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ① 通过调用“npm test”运行Jest的设置
- en: ② Setup for running Jest in live reload mode
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ② 为在实时重新加载模式下运行Jest进行设置
- en: ③ Installs Jest as a dev dependency
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将Jest作为开发依赖项安装
- en: ④ This project doesn’t have any production dependencies yet.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 这个项目目前还没有任何生产依赖。
- en: 'Note also in listing 8.4, there’s an npm script called test:watch. This is
    configured so that we can run our tests in live reload mode like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在列表8.4中，还有一个名为test:watch的npm脚本。它被配置为我们可以以这种方式运行我们的测试，在实时重新加载模式下：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The test:watch script is my own personal convention-it isn’t an npm standard.
    I use it so that no matter which testing tool I use, I can easily remember how
    to run my tests with live reload enabled.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试：watch 脚本是我的个人约定——它不是 npm 标准。我使用它，以便无论我使用哪种测试工具，我都能轻松记住如何启用实时重载来运行我的测试。
- en: 8.5.9 Populating your test suite
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.9 填充您的测试套件
- en: So far, we have only seen a single test, but I’d also like to give you a taste
    of what it looks like as we grow this test suite. Listing 8.5 shows what math.test.js
    looks like after adding a second test. (Example-1 doesn’t actually contain this
    new test, but feel free to add it yourself and experiment with it.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了一个测试，但我也想给你展示一下，随着测试套件的扩展，它看起来会是什么样子。列表 8.5 展示了在添加第二个测试后 math.test.js
    的样子。（示例-1 实际上不包含这个新测试，但你可以自由添加它并对其进行实验。）
- en: Listing 8.5 Adding the next test (additions to chapter-8/example-1/src/math.test.js)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 添加下一个测试（对 chapter-8/example-1/src/math.test.js 的添加）
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Omits the previous test for brevity
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为了简洁起见省略了之前的测试
- en: ② Creates the test “can square zero”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建测试“can square zero”
- en: ③ Add more tests to your “square” function test suite here
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在您的“square”函数测试套件中添加更多测试
- en: ④ Add more tests suites for the math library here
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在此处为数学库添加更多测试套件
- en: As listing 8.5 shows, we can add more tests to our `square` function test suite
    by adding more instances of the `test` function nested inside the test suite’s
    `describe` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 8.5 所示，我们可以通过在测试套件的 `describe` 函数内部添加更多 `test` 函数的实例来向我们的 `square` 函数测试套件添加更多测试。
- en: The new test, `can square zero`, is an example of an edge case. We don’t need
    to add any more tests for squaring positive numbers; `can square two` is enough
    to cover all positive cases, so we could rename it `can square positive number`.
    Then to complete this small test suite for the `square` function, you should probably
    also add a test called `can square negative number`. I’ll leave that to you if
    you’d like to continue working on this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 新的测试，`can square zero`，是一个边缘情况的例子。我们不需要为平方正数添加更多测试；`can square two` 就足以涵盖所有正数情况，因此我们可以将其重命名为
    `can square positive number`。然后，为了完成对 `square` 函数的这个小测试套件的补充，你可能还需要添加一个名为 `can
    square negative number` 的测试。如果你愿意继续工作，我会把这个留给你。
- en: As we develop our math library, we’ll add more math functions and more test
    suites. For example, we’ll add functions like `squareRoot` and `average` and their
    test suites `square root function` and `average function`. Remember, we named
    our test file math.test.js, and that name is general enough that we can add new
    test suites to it using the `describe` function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开发数学库，我们将添加更多数学函数和更多测试套件。例如，我们将添加 `squareRoot` 和 `average` 函数及其测试套件“平方根函数”和“平均函数”。记住，我们命名了测试文件为
    math.test.js，这个名字足够通用，我们可以使用 `describe` 函数向其中添加新的测试套件。
- en: We could also have separate JavaScript code files for each test suite, for instance,
    square.test.js, square-root.test.js and average.test.js. Note that these are all
    appended with *.test.js* so that Jest can automatically find them. As we add new
    libraries in the future, we’ll add new test files, as many as we need, to contain
    all the tests that we create.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为每个测试套件创建单独的 JavaScript 代码文件，例如，square.test.js、square-root.test.js 和 average.test.js。请注意，这些文件都是以
    *.test.js 结尾，这样 Jest 可以自动找到它们。随着我们未来添加新的库，我们将添加新的测试文件，数量根据需要而定，以包含我们创建的所有测试。
- en: You can structure your tests in any way you want. That means you can name those
    how you like and structure these across files to suit your own needs. When working
    for a company, however, you’ll be expected to follow their existing style and
    conventions. Whatever convention you follow, I would only ask (on behalf of developers
    everywhere) that you use *meaningful names* for your tests. Names that make it
    easy to understand the purpose of the test. Thank you very much.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以任何你想要的方式组织你的测试。这意味着你可以按你喜欢的方式命名它们，并将它们跨文件组织以适应你的需求。然而，当你在公司工作时，你将被期望遵循他们现有的风格和约定。无论你遵循哪种约定，我都代表全世界的开发者请求（请使用
    *有意义的名称* 为你的测试命名。名称应该使测试的目的易于理解。非常感谢。）
- en: 8.5.10 Mocking with Jest
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.10 使用 Jest 进行模拟
- en: JavaScript is a great language for creating mocks! The dynamic nature of JavaScript
    makes it particularly easy to create automated tests as well. But what is mocking?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是创建模拟的绝佳语言！JavaScript 的动态特性使得创建自动化测试变得特别容易。但模拟是什么？
- en: Definition *Mocking* is where we replace real dependencies in our code with
    fake or simulated versions of those.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的定义是：在我们代码中用虚假或模拟的版本替换真实依赖项。
- en: The dependencies that we replace can be functions, objects, or even entire code
    modules. In JavaScript, it’s easy to create functions and piece together new objects
    and data structures that we can use as mocks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以替换的依赖项可以是函数、对象，甚至是整个代码模块。在JavaScript中，创建函数和组合新的对象和数据结构作为模拟是非常容易的。
- en: Why do we do this? The purpose of mocking is to isolate the code we are testing.
    Isolating particular sections of code allows us to focus on just testing only
    that code and nothing else. Isolation is important for unit testing and test-driven
    development.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要这样做？模拟的目的是隔离我们正在测试的代码。隔离特定的代码部分使我们能够只测试那部分代码，而无需测试其他内容。隔离对于单元测试和测试驱动开发非常重要。
- en: Not only does mocking help isolate the code we are testing, but it can also
    entirely eliminate the code and processes that would make testing slow. For example,
    we can eliminate database queries, network transactions, and filesystem operations.
    These are the kinds of things that can take a huge amount of time *compared* to
    the code we are testing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟不仅有助于隔离我们正在测试的代码，而且还可以完全消除那些会使测试变慢的代码和过程。例如，我们可以消除数据库查询、网络事务和文件系统操作。这些都是与我们要测试的代码相比可能需要花费大量时间的事情。
- en: 'In section 8.6, we’ll learn about unit testing and see a real example of mocking,
    but let’s first understand mocking by examining a simple example. Let’s say that
    instead of using the multiply operator in our `square` function, we’ll use the
    `multiply` function as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8.6节中，我们将学习单元测试，并看到一个真实的模拟示例，但让我们首先通过检查一个简单的例子来理解模拟。假设我们不是在`square`函数中使用乘法运算符，而是使用以下`multiply`函数：
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You might well ask, why are we using a function to do multiplication when there’s
    already a perfectly good operator? That’s a good point. Well, I introduced the
    `multiply` function here primarily because I need a simple example by which to
    explain mocking. But if you’d like, I can also concoct a great reason why we need
    this!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，既然已经有了完美的运算符，为什么还要用函数来做乘法呢？这是一个很好的问题。嗯，我在这里引入`multiply`函数主要是为了提供一个简单的例子来解释模拟（mocking）。但如果你想，我也可以编造一个很好的理由来说明为什么我们需要这个函数！
- en: Let’s just say that we want our math library to work with abstract data types.
    Instead of working with ordinary numbers, we want it to be able to work with vectors
    (arrays of numbers), and in this case, the `multiply` function could very well
    be an extremely complex function that does the computation in parallel on a graphics
    processing unit (GPU).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就让我们说，我们希望我们的数学库能够与抽象数据类型一起工作。而不是使用普通数字，我们希望它能够处理向量（数字数组），在这种情况下，`multiply`函数可能是一个非常复杂的函数，它可以在图形处理单元（GPU）上并行进行计算。
- en: 'Now to isolate our code in the `square` function (which arguably isn’t much),
    we need to mock the `multiply` function. That means we must replace it with another
    function-one that we can control. We can do this using a primitive form of *dependency
    injection* (DI). DI is a technique where we inject dependencies into our code
    rather than hard-coding them. We control what the dependencies are, and that’s
    useful for isolating code for unit testing. In this case, we inject the `multiply`
    function into the `square` function like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要隔离`square`函数中的代码（从理论上讲可能并不多），我们需要模拟`multiply`函数。这意味着我们必须用另一个函数来替换它——一个我们可以控制的函数。我们可以通过一种原始的*依赖注入（Dependency
    Injection，DI）*形式来实现这一点。DI是一种技术，我们将依赖项注入到我们的代码中，而不是硬编码它们。我们控制依赖项是什么，这对于隔离代码进行单元测试很有用。在这种情况下，我们将`multiply`函数注入到`square`函数中，如下所示：
- en: '[PRE16]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This works because functions are first-class citizens in JavaScript, and these
    can be passed around like any other value or object. Now let’s make use of this
    from our test. When we call the `square` function, we’ll pass in our mock version
    of `multiply`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以可行，是因为在JavaScript中，函数是一等公民，它们可以像任何其他值或对象一样传递。现在让我们从我们的测试中利用这一点。当我们调用`square`函数时，我们将传递我们的模拟版本`multiply`：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Creates a mock version of the “multiply” function
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建“multiply”函数的模拟版本
- en: ② Expects the “square” function to pass the right inputs to the “multiply” function
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ② 期望“square”函数将正确的输入传递给“multiply”函数
- en: ③ Hard-codes the mock function to return 4
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将模拟函数硬编码为返回4
- en: ④ Passes the mock function into the “square” function instead of the real “multiply”
    function
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将模拟函数传递给“square”函数而不是真实的“multiply”函数
- en: ⑤ Expects to get back the hard-coded value of 4
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 期望得到硬编码的值4
- en: 'You are now probably wondering, what’s the point of all this? Given that our
    mock function returns a hard-coded value of 4, what are we actually testing here?
    You can read it like this: “we are testing that the `square` function invokes
    the `multiply` function with inputs 2 and 2, and the result received from `multiply`
    is the value returned from the `square` function.”'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能想知道，所有这些有什么意义？鉴于我们的模拟函数返回一个硬编码的值 4，我们在这里实际上测试了什么？你可以这样理解：“我们正在测试 `square`
    函数是否以输入 2 和 2 调用 `multiply` 函数，并且从 `multiply` 收到的结果是 `square` 函数返回的值。”
- en: You might note at this point that we have just implemented the `square` function,
    tested it, and proved that it works-and the real version of the `multiply` function
    doesn’t even exist yet! This is one of the superpowers of test-driven development
    (TDD). TDD allows us to reliably test incomplete versions of our code. If that
    doesn’t impress you, I don’t know what will!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们刚刚实现了 `square` 函数，对其进行了测试，并证明了它的工作——而 `multiply` 函数的真实版本甚至还没有存在！这是测试驱动开发（TDD）的超级能力之一。TDD
    允许我们可靠地测试代码的不完整版本。如果这还不能让你印象深刻，我不知道还有什么能做到了！
- en: To make this code work for real, we still need to implement the `multiply` function.
    This can, in turn, have automated tests applied to it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此代码真正工作，我们仍然需要实现 `multiply` 函数。这反过来又可以对其应用自动化测试。
- en: OK, so this is a crazy made-up example, but we needed a way to introduce the
    concept of mocking. It’s pretty rare to see DI implemented at such a granular
    level as I have demonstrated just now. Coming up soon, though, you’ll see a more
    realistic example that replaces entire code modules with mocks.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这是一个疯狂编造的例子，但我们需要一种方法来介绍模拟的概念。像我现在展示的那样，在如此细粒度级别实现依赖注入（DI）是非常罕见的。不过，很快你将看到一个更现实的例子，它使用模拟替换了整个代码模块。
- en: 8.5.11 What have we achieved?
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.11 我们取得了什么成果？
- en: We have seen a simple example of testing with Jest and how mocking is used to
    isolate the code we are testing. Let’s wrap up this section with a general recipe
    for testing with Jest.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用 Jest 进行测试的简单示例以及如何使用模拟来隔离我们正在测试的代码。让我们以使用 Jest 进行测试的一般方法来结束本节。
- en: Creating tests with Jest
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jest 创建测试
- en: Create a file for the code you are testing (e.g., math.js).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你正在测试的代码创建一个文件（例如，math.js）。
- en: Create a file for your test that matches Jest’s naming convention (e.g., math.test.js).
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的测试创建一个与 Jest 命名约定匹配的文件（例如，math.test.js）。
- en: Import functions and code modules into your test file.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数和代码模块导入测试文件中。
- en: Wrap your entire test suite in a call to the `describe` function and give it
    a descriptive name.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个测试套件包裹在 `describe` 函数的调用中，并为其提供一个描述性的名称。
- en: Add each test using a call to the `test` function and give each a descriptive
    name.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用对 `test` 函数的调用添加每个测试，并为每个测试提供一个描述性的名称。
- en: Run your tests using `npx jest` or `npm test` (if configured in package.json).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npx jest` 或 `npm test`（如果已在 package.json 中配置）运行你的测试。
- en: Template for test suites
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件的模板
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① Import functions and code modules go here.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入函数和代码模块放在这里。
- en: ② Global mocks shared between tests in this file go here.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在此文件中测试之间共享的全局模拟代码放在这里。
- en: ③ Calls to the “describe” function, which defines test suites, go here.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 调用定义测试套件的“describe”函数放在这里。
- en: ④ Mocks shared between tests in this test suite go here.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 在此测试套件中测试之间共享的模拟代码放在这里。
- en: ⑤ Calls to the “test” function, which defines each test
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 调用定义每个测试的“test”函数
- en: ⑥ Code for the test goes here.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 测试代码放在这里。
- en: ⑦ Many more tests go here.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 可以在这里添加更多测试。
- en: ⑧ More test suites can go here.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 可以在这里添加更多测试套件。
- en: Template for tests
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的模板
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ① Calls to the “test” function, which defines each test. Use a meaningful name
    for each test!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ① 调用定义每个测试的“test”函数。为每个测试使用一个有意义的名称！
- en: ② Mocks used only in this test go here.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ② 仅在此测试中使用的模拟代码放在这里。
- en: ③ Calls the function(s) to be tested and records any result
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 调用要测试的函数并记录任何结果
- en: ④ Inspect results and mocks and states the expectations of the test
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 检查结果和模拟并声明测试的期望
- en: 8.6 Unit testing
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 单元测试
- en: Unit testing for microservices works the same as any other kind of unit testing.
    We aim to test a single *unit* of code by itself and in isolation from other code.
    What is a unit? Typically, each test exercises a single function or one aspect
    of a single function.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务单元测试与其他类型的单元测试工作方式相同。我们的目标是独立于其他代码，单独测试单个 *单元* 代码。什么是单元？通常，每个测试都会对一个函数或单个函数的一个方面进行测试。
- en: What’s important with unit testing is the isolation. When we test isolated code,
    we focus our testing efforts on just that small piece of code. For example, we’d
    like to test the code for our metadata microservice, but we don’t care to test
    the code for say the Express library or the MongoDB library. Those are dependencies
    that we assume have already been tested. Instead, we want to test only the code
    that we have created. To focus on our own code, we must eliminate all other code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试中重要的是隔离。当我们测试隔离的代码时，我们集中测试精力在那一小块代码上。例如，我们希望测试我们的元数据微服务的代码，但我们不关心测试Express库或MongoDB库的代码。那些是我们假设已经测试过的依赖项。相反，我们只想测试我们创建的代码。为了专注于我们自己的代码，我们必须消除所有其他代码。
- en: Isolation of code is achieved by *mocking* its dependencies. What this means
    in terms of our metadata microservice is that we’ll substitute the real Express
    and MongoDB libraries for fake instances that we can control and bend to our will.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模拟依赖项来实现代码的隔离。对于我们元数据微服务来说，这意味着我们将用我们可以控制和操纵的假实例替换真实的Express和MongoDB库。
- en: Isolation is what makes unit tests run fast. Integration and end-to-end tests
    don’t isolate code. In those types of testing, we exercise the integration of
    code modules rather than isolated pieces of code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离是使单元测试运行快速的原因。集成和端到端测试不隔离代码。在那些类型的测试中，我们锻炼的是代码模块的集成，而不是隔离的代码片段。
- en: When running unit tests, we won’t start a real HTTP server or connect to a real
    database. This is the kind of thing that makes unit tests run quickly, and it’s
    why these are at the foundation of the testing pyramid (figure 8.1). We can afford
    to have 100s or even 1000s of unit tests for our code, and we won’t have to wait
    a long time for our suite of unit tests to complete.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行单元测试时，我们不会启动真实的HTTP服务器或连接到真实的数据库。这类事情使得单元测试运行得很快，这也是为什么这些是测试金字塔（图8.1）的基础。我们可以承担有成百上千个单元测试，而且我们不需要等待很长时间才能完成我们的单元测试套件。
- en: We’ll be using Jest to execute our unit tests. Figure 8.7 shows what we’ll do
    with it. Our test code from index.test.js (on the left) is loaded by Jest. Our
    code to be tested, the code for our metadata microservice from index.js (on the
    right) is loaded by our test code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Jest来执行我们的单元测试。图8.7显示了我们将如何使用它。我们的测试代码来自index.test.js（在左侧），由Jest加载。我们要测试的代码，即我们的元数据微服务的代码（在右侧），由我们的测试代码加载。
- en: We’ll mock Express and MongoDB instead of using the real thing. The test code
    “starts” our microservice. I say *starts* in quotes because we won’t be starting
    it in the usual way. Unlike in normal execution, Express is mocked so we aren’t
    starting a real HTTP server. Likewise, MongoDB is mocked so we aren’t connecting
    to a real database.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟Express和MongoDB而不是使用真实的东西。测试代码“启动”我们的微服务。我之所以说“启动”，是因为我们不会以通常的方式启动它。与正常执行不同，Express被模拟，所以我们不会启动一个真实的HTTP服务器。同样，MongoDB也被模拟，所以我们不会连接到真实的数据库。
- en: '![](../Images/CH08_F07_Davis4.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F07_Davis4.png)'
- en: Figure 8.7 Unit testing the metadata microservice with Jest
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 使用Jest对元数据微服务进行单元测试
- en: 8.6.1 The metadata microservice
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.1 元数据微服务
- en: 'We now move on to example-2 in the chapter 8 code repository. To follow along,
    you’ll need to install dependencies:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将转向第8章代码库中的example-2。要跟上，你需要安装依赖项：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Listing 8.6 shows the code we will test. This is a fledgling microservice that
    will become FlixTube’s metadata microservice. This is a REST API whose purpose
    is to collect, store, search, and manage the metadata associated with each video.
    The basic setup in the listing is not too different from our first microservice
    back in chapter 2.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6展示了我们将要测试的代码。这是一个初生的微服务，它将成为FlixTube的元数据微服务。这是一个REST API，其目的是收集、存储、搜索和管理与每个视频相关的元数据。列表中的基本设置与第2章中的第一个微服务并没有太大的不同。
- en: Listing 8.6 The metadata microservice for unit testing (chapter-8/example-2/src/index.js)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 单元测试的元数据微服务（第8章/example-2/src/index.js）
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① Handles requests to the /videos route
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ① 处理对/videos路由的请求
- en: ② Returns a promise so we can await the result in the test
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ② 返回一个promise，以便我们可以在测试中等待结果
- en: ③ Retrieves the records from the database
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 从数据库检索记录
- en: ④ Other handlers can go here later.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 其他处理程序可以稍后添加到这里。
- en: ⑤ Starts the Express HTTP server
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 启动Express HTTP服务器
- en: ⑥ Wraps in a promise so we can be notified when the server starts
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 使用promise包装，以便我们可以在服务器启动时得到通知
- en: ⑦ Creates an object that represents our microservice
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 创建一个代表我们的微服务的对象
- en: ⑧ Creates a function that can be used to shutdown the microservice
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 创建一个可以用来关闭微服务的函数
- en: ⑨ Closes the Express server
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 关闭Express服务器
- en: ⑩ Closes the database
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 关闭数据库
- en: ⑪ A new helper function to collect code to execute when the microservice starts
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 一个新的辅助函数，用于收集微服务启动时执行的代码
- en: ⑫ The main entry point for the microservice
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 微服务的主要入口点
- en: ⑬ Starts the microservice normally, if this script is the main module
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 如果此脚本是主模块，则正常启动微服务
- en: ⑭ Starts the microservice
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 启动微服务
- en: ⑮ Otherwise, runs the microservice under test
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 否则，在测试中运行微服务
- en: ⑯ Exports the function to start the microservice so we can call it from the
    test
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 导出启动微服务的函数，以便我们可以在测试中调用它
- en: Listing 8.6 starts a HTTP server using the Express library and connects to a
    MongoDB database using the MongoDB library. We added a single handler function
    for the HTTP GET /videos route. This route retrieves an array of video metadata
    from the database.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6使用Express库启动HTTP服务器，并使用MongoDB库连接到MongoDB数据库。我们为HTTP GET /videos路由添加了一个单独的处理函数。此路由从数据库检索视频元数据数组。
- en: The code we test here will be exercised by calling the function `startMicroservice`.
    This is a new function we added to our microservice to help make it more testable.
    Calling `startMicroservice` returns a JavaScript object that represents the microservice.
    We aren’t storing the returned object yet. We don’t need that for unit testing,
    but we will need it later when we come to integration testing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里测试的代码将通过调用函数`startMicroservice`来执行。这是我们添加到微服务中的一个新函数，以帮助使其更容易进行测试。调用`startMicroservice`返回一个表示微服务的JavaScript对象。我们目前还没有存储返回的对象。我们不需要它来进行单元测试，但当我们进行集成测试时，我们将需要它。
- en: 'We’ve made this change to the structure of our microservice in an effort to
    *design for testing*, and we’ll often find ourselves doing this, adapting our
    code to make it more amenable to testing. Note that we aren’t limited to calling
    `startMicroservice`. We could, in fact, call any exported function from any of
    our code modules. Keep that in mind because it’s what unit testing is really all
    about: testing each and every function individually. Now, let’s create some tests
    to confirm that our microservice started and that the /videos route retrieves
    the expected data.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对微服务的结构进行了此更改，旨在**为测试而设计**，我们经常会发现自己这样做，调整代码以便更容易进行测试。请注意，我们不仅限于调用`startMicroservice`。实际上，我们可以从我们的任何代码模块中调用任何导出的函数。记住这一点，因为这就是单元测试真正关注的内容：单独测试每个函数。现在，让我们创建一些测试来确认我们的微服务已启动，并且/video路由可以检索到预期的数据。
- en: 8.6.2 Creating unit tests with Jest
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.2 使用Jest创建单元测试
- en: Before we can unit test our code, we need to be able to create mocks for the
    dependencies. For this example, the dependencies we have are Express and MongoDB.
    In other situations, you will have different dependencies, like the amqp library
    for interacting with RabbitMQ.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以对代码进行单元测试之前，我们需要能够为依赖项创建模拟。对于此示例，我们的依赖项是Express和MongoDB。在其他情况下，你将会有不同的依赖项，例如用于与RabbitMQ交互的amqp库。
- en: Listing 8.7 shows the code for our tests. This file defines a single test suite
    called `metadata microservice` that contains three tests. We have called the file
    index.test.js to indicate that it tests code contained in the main source file
    index.js. As you continue to develop your microservice, you’ll end up having many
    more files like this, with tests to cover all the code in your microservice.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7显示了测试的代码。此文件定义了一个名为`metadata microservice`的单个测试套件，其中包含三个测试。我们将文件命名为index.test.js，以表明它测试的是主源文件index.js中的代码。随着你继续开发你的微服务，你最终会有更多这样的文件，包含测试以覆盖你微服务中的所有代码。
- en: The first part of the test suite is devoted to setting up mocks for the Express
    and MongoDB libraries. Note the use of `jest.fn` to create mock functions that
    we can use to detect if the function was called, and if so, then what arguments
    were passed to it. Next, note the use of `jest.doMock`, which allows us to mock
    entire Node.js modules. These tools are powerful and allow us to replace Express
    and MongoDB without having to adjust the code we are testing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件的第一部分致力于设置Express和MongoDB库的模拟。注意使用`jest.fn`创建模拟函数，我们可以使用这些函数来检测函数是否被调用，以及如果被调用，传递给它的参数是什么。接下来，注意使用`jest.doMock`，它允许我们模拟整个Node.js模块。这些工具功能强大，允许我们替换Express和MongoDB，而无需调整我们正在测试的代码。
- en: The first test in listing 8.7 checks that the HTTP server has been started on
    port 3000\. The second test checks that a handler for the /videos route has been
    registered. The third test directly invokes the /videos route handler function
    and checks that it retrieves the required data from the database.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7中的第一个测试检查HTTP服务器是否已在端口3000上启动。第二个测试检查是否已注册了/videos路由的处理程序。第三个测试直接调用/videos路由处理程序函数，并检查它是否从数据库中检索到所需的数据。
- en: This example is actually quite advanced, but I wanted to get straight to the
    point and show you some unit testing that is relevant to microservices. If you
    struggle to understand this code, don’t be too concerned. Just try to read it,
    get the gist of it, and understand which parts of it are for mocking and which
    parts are for testing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子实际上相当高级，但我想要直接切入正题，并展示一些与微服务相关的单元测试。如果你觉得这段代码难以理解，不必过于担心。只需尝试阅读它，抓住其要点，并理解哪些部分是用于模拟，哪些部分是用于测试。
- en: Listing 8.7 Testing the metadata microservice with Jest (chapter-8/example-2/src/index.test.js)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7：使用Jest测试元数据微服务（chapter-8/example-2/src/index.test.js）
- en: '[PRE22]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Defines the test suite for the “metadata microservice”
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义“metadata微服务”的测试套件
- en: ② Creates a mock “listen” function
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个模拟的“listen”函数
- en: ③ Creates a mock “get” function
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建一个模拟的“get”函数
- en: ④ Creates a mock for the Express library
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建Express库的模拟
- en: ⑤ The Express library is a factory function that creates the Express app object.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ Express库是一个工厂函数，用于创建Express应用对象。
- en: ⑥ Returns a mock for the Express app object
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 返回一个模拟的Express应用对象
- en: ⑦ A mock for the MongoDB videos collection
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ MongoDB视频集合的模拟
- en: ⑧ A mock for the MongoDB database
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ MongoDB数据库的模拟
- en: ⑨ A mock for the MongoDB client object
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ MongoDB客户端对象的模拟
- en: ⑩ Creates a mock for the MongoDB module
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 创建MongoDB模块的模拟
- en: ⑪ A mock for MongoClient
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ MongoClient的模拟
- en: ⑫ A mock for the connect function
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ connect函数的模拟
- en: ⑬ Imports the code we are testing
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 导入我们正在测试的代码
- en: ⑭ Tests that the microservice starts the HTTP server correctly
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 测试微服务是否正确启动HTTP服务器
- en: ⑮ Invokes the code under test
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 调用测试下的代码
- en: ⑯ Expects only 1 call to the “listen” function
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 期望只调用一次“listen”函数
- en: ⑰ Expects that port 3000 was passed to “listen”
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 期望将端口3000传递给“listen”
- en: ⑱ Tests that the /videos route is handled by the HTTP server
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ⑱ 测试/videos路由是否由HTTP服务器处理
- en: ⑲ Expects the Express “get” function has been called
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ⑲ 期望Express的“get”函数已被调用
- en: ⑳ Expects that the parameter to “get” was /videos
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ⑳ 期望“get”的参数是/videos
- en: ㉑ Tests that the /videos route retrieves data from the videos collection in
    the database
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ㉑ 测试/videos路由从数据库中的视频集合检索数据
- en: ㉒ Invokes the code under test
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ㉒ 调用测试下的代码
- en: ㉓ Mock Express “request” and “response” objects passed to our Express route
    handler
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ㉓ 模拟传递给Express路由处理程序的Express“request”和“response”对象
- en: ㉔ Mocks the “find” function to return some mock database records
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ㉔ 模拟“find”函数返回一些模拟数据库记录
- en: ㉕ Mocks the structure of the MongoDB library
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ㉕ 模拟MongoDB库的结构
- en: ㉖ Mocks the “find” function to return some mock database records
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ㉖ 模拟“find”函数返回一些模拟数据库记录
- en: ㉗ Extracts the /videos route “handler” function
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ㉗ 提取/videos路由的“handler”函数
- en: ㉘ Invokes the “handler” function
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ㉘ 调用“handler”函数
- en: ㉙ Expects that the “json” function is called
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ㉙ 期望调用“json”函数
- en: ㉚ Expects that the mock records were retrieved from the database
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ㉚ 期望模拟记录已从数据库中检索
- en: ㉛ More tests go here!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ㉛ 更多测试在这里！
- en: You may have noticed in listing 8.7 that I’m using `async` and `await` keywords.
    I use these a lot in my day-to-day coding, but I haven’t used these yet in this
    book. The reason I’ve introduced these here is that they fit nicely into Jest
    tests and make asynchronous code significantly easier to read.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在列表8.7中我使用了`async`和`await`关键字。我在日常编码中经常使用这些关键字，但在这本书中还没有使用过。我在这里引入这些关键字的原因是它们非常适合Jest测试，并且使异步代码的阅读变得更加容易。
- en: You might be wondering where the `jest` variable actually comes from because
    there is no `require` statement in listing 8.7 that imports it! This is standard
    JavaScript, and normally, it would be a problem, but this code is running under
    Jest. Jest automatically imports the `jest` variable for us. How nice of it to
    save us a line of code like that.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道`jest`变量实际上是从哪里来的，因为在列表8.7中没有`require`语句来导入它！这是标准的JavaScript，通常这会是个问题，但这段代码是在Jest环境下运行的。Jest会自动为我们导入`jest`变量。它真是太好了，为我们节省了一行代码。
- en: A large section at the start of listing 8.7 is dedicated to creating the mocks
    that replace Express and MongoDB. We used `jest.fn` and `jest.doMock` to create
    mocks. Jest has many other useful functions for mocking and specifying the expectations
    of the test. See the reference at the end of this chapter to read more about that.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7的开头大部分内容都是用来创建替换Express和MongoDB的模拟。我们使用了`jest.fn`和`jest.doMock`来创建模拟。Jest有许多其他用于模拟和指定测试期望的有用函数。请参阅本章末尾的参考资料以了解更多信息。
- en: We replaced Express and MongoDB with new JavaScript objects, thus providing
    our own implementations for the dependencies of the code we are testing. When
    the code calls these functions, it calls the replacement versions and not the
    usual ones from the real Express and MongoDB libraries.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用新的JavaScript对象替换了Express和MongoDB，因此为我们正在测试的代码的依赖项提供了自己的实现。当代码调用这些函数时，它调用的是替换版本，而不是来自真实Express和MongoDB库的常规版本。
- en: If we didn’t replace Express and MongoDB, then calling `startMicroservice` would
    start the real HTTP server and connect to the real database. That normal operation
    is exactly what we want to avoid when unit testing! It’s the kind of thing that
    makes automated tests run slowly. It won’t seem like much of a difference right
    now because, for the moment, we are only talking about a tiny number of tests.
    But when you get to running 100s or even 1000s of tests, you will definitely see
    a big difference.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有替换Express和MongoDB，那么调用`startMicroservice`将会启动真实的HTTP服务器并连接到真实的数据库。这种正常操作正是我们在单元测试时想要避免的！这是使自动化测试运行缓慢的那种类型的事情。现在这看起来可能并没有太大的区别，因为目前我们只是在谈论一个非常小的测试数量。但是当你运行100个甚至1000个测试时，你肯定会看到很大的不同。
- en: 8.6.3 Running the tests
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.3 运行测试
- en: 'After writing the code and the tests, we are ready to run Jest. From the terminal
    in the example-1 directory, run the tests as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码和测试之后，我们就可以运行Jest了。在example-1目录的终端中，按照以下方式运行测试：
- en: '[PRE23]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Or run
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 或者运行
- en: '[PRE24]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output should show one passing test suite with three passing tests.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该显示一个通过的一组测试，包含三个通过测试。
- en: 8.6.4 What have we achieved?
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6.4 我们取得了什么成果？
- en: We’ve learned the basics of unit testing with Jest. We mocked the Express and
    MongoDB libraries, and we tested that our microservice can start and that its
    /videos route can retrieve records from the database.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了使用Jest进行单元测试的基础知识。我们模拟了Express和MongoDB库，并测试了我们的微服务可以启动，以及它的/videos路由可以从数据库中检索记录。
- en: This might not seem like much, but you can continue to create tests like this
    to cover code across all of your microservices. You might even want to try test-driven
    development (TDD), also known as *test-first development*, where you write code
    for tests before writing the actual code being tested.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来并不多，但你可以继续创建这样的测试来覆盖你所有微服务中的代码。你可能甚至想尝试测试驱动开发（TDD），也称为*测试先行开发*，在这种方法中，你会在编写实际要测试的代码之前先编写测试代码。
- en: This is a powerful technique that can help you achieve 100% test coverage, a
    feat that can prove difficult without TDD. At the end of this chapter, you’ll
    find references to learn more about this test-focused method of development if
    you so desire.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的技术，可以帮助你实现100%的测试覆盖率，这是一个在没有TDD的情况下可能很难实现的成就。如果你愿意，在本章末尾，你会找到更多关于这种以测试为中心的开发方法的参考资料。
- en: 8.7 Integration testing
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 集成测试
- en: The next step up the testing pyramid (figure 8.1) is integration testing. It’s
    called integration testing because, instead of testing code modules in isolation
    (as we did with unit testing), the emphasis is now on testing code modules functioning
    together in an integrated fashion. When it comes to microservices, integration
    testing usually means that we are testing an entire microservice, including all
    the code modules and code libraries that it depends upon.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔（图8.1）的下一步是集成测试。它被称为集成测试，因为，与单元测试中独立测试代码模块不同，现在的重点是测试代码模块以集成方式共同工作。当涉及到微服务时，集成测试通常意味着我们正在测试整个微服务，包括它所依赖的所有代码模块和代码库。
- en: It would be nice if unit testing was enough to solve all our problems. Unit
    testing is effective because unit tests are extremely fast to run. The speed of
    unit tests means that we’ll be more likely to run these frequently and thus catch
    problems quickly. Unfortunately though, many problems can still be hidden in the
    integration between code modules where they can’t be detected by unit tests.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元测试足以解决我们所有的问题那将很理想。单元测试是有效的，因为单元测试运行得非常快。单元测试的速度意味着我们更有可能频繁运行这些测试，从而快速发现问题。不幸的是，尽管如此，许多问题仍然可能隐藏在代码模块之间的集成中，这些问题是单元测试无法检测到的。
- en: In a way, integration testing is actually easier than unit testing because we
    don’t have to be concerned with mocking. In fact, if mocking seems too hard, you
    might find it much easier to start with integration testing. Earlier, when unit
    testing, we mocked dependencies for Express and MongoDB. We won’t be doing that
    with integration testing. Instead, we’ll allow the microservice we are testing
    to start a real HTTP server and connect to a real database.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，集成测试实际上比单元测试更容易，因为我们不需要担心模拟。事实上，如果你觉得模拟太难，你可能会发现从集成测试开始要容易得多。早些时候，在单元测试时，我们模拟了Express和MongoDB的依赖项。在集成测试中，我们不会这样做。相反，我们将允许我们正在测试的微服务启动一个真实的HTTP服务器并连接到一个真实的数据库。
- en: Despite the fact that it is easier to write integration tests than unit tests,
    the setup for integration testing is more difficult. Using a real HTTP server
    limits the parallelization of our testing because we can only run a single HTTP
    server at a time on port 3000 (or indeed any other port). Using a real MongoDB
    database means that we’ll need to have a database available for use by the code
    we are testing.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编写集成测试比编写单元测试更容易，但集成测试的设置却更困难。使用真实的HTTP服务器限制了我们的测试并行化，因为我们一次只能在端口3000（或者实际上任何其他端口）上运行一个HTTP服务器。使用真实的MongoDB数据库意味着我们需要有一个数据库可供我们正在测试的代码使用。
- en: On top of that, starting the HTTP server and connecting to the database is time-consuming.
    This is what makes integration tests particularly slow compared to unit tests.
    All things considered, I won’t be surprised if you are now convinced that it’s
    actually unit testing that’s easier than integration testing!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，启动HTTP服务器和连接到数据库是耗时的。这就是为什么与单元测试相比，集成测试特别慢的原因。综合考虑，如果你现在相信实际上单元测试比集成测试更容易，我也不会感到惊讶！
- en: Note Using the right combination of tests is a balancing act, and we do need
    integration tests because that’s the only way to find problems in the integrated
    code.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用正确的测试组合是一种平衡行为，我们确实需要集成测试，因为这是发现集成代码中问题的唯一方法。
- en: Typically, when we run integration tests against a microservice, we’ll interact
    with it through its official HTTP interface instead of directly, calling its functions
    as we did for unit testing. There are other ways we could interact with it, depending
    on how the microservice is implemented. For example, if the microservice uses
    RabbitMQ, then we can also interact with it by sending it messages.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们对微服务运行集成测试时，我们会通过其官方HTTP接口与其交互，而不是直接调用其函数，就像我们在单元测试中所做的那样。根据微服务的实现方式，我们可以有其他与之交互的方法。例如，如果微服务使用RabbitMQ，我们也可以通过发送消息与之交互。
- en: Figure 8.8 shows what we’ll do with integration testing in this section. Again,
    we are using Jest to test our metadata microservice, but this time, we won’t be
    making use of Jest’s mocking facilities. Instead of directly calling code in our
    microservice to test it, we’ll send it HTTP requests and check the responses that
    come back.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8展示了在本节中我们将如何进行集成测试。再次强调，我们仍然使用Jest来测试我们的元数据微服务，但这次，我们不会使用Jest的模拟功能。我们不会直接调用微服务中的代码来测试它，而是发送HTTP请求并检查返回的响应。
- en: '![](../Images/CH08_F08_Davis4.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F08_Davis4.png)'
- en: Figure 8.8 Integration testing a microservice with Jest
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 使用Jest对微服务进行集成测试
- en: 8.7.1 The code to test
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.1 要测试的代码
- en: Now we can move to example-3 in the chapter-8 code repository. You can continue
    to follow along and run these tests. The code we’ll test is the same code as in
    example-2; nothing has changed, so look back to listing 8.6 if you’d like to revise
    that code.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转向第8章代码库中的example-3。你可以继续跟随并运行这些测试。我们将要测试的代码与example-2中的代码相同；没有变化，所以如果你想复习那段代码，可以查看列表8.6。
- en: 8.7.2 Running a MongoDB database
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.2 运行MongoDB数据库
- en: When doing integration testing, we won’t replace our database with a mock version.
    Instead, we need a real database, and we need to be able to load realistic test
    data.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行集成测试时，我们不会用模拟版本替换我们的数据库。相反，我们需要一个真实的数据库，并且我们需要能够加载真实的测试数据。
- en: 'To run the integration tests for example-3, you’ll need a real MongoDB database
    up and running. It’s not too difficult to download and install MongoDB. You can
    install it on your development workstation if you haven’t already done so. Follow
    the instructions for your platform here:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 example-3 的集成测试，你需要一个正在运行的 MongoDB 数据库。下载和安装 MongoDB 并不是特别困难。如果你还没有这样做，你可以在你的开发工作站上安装它。请按照以下说明进行操作：
- en: '[https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)'
- en: 'As an alternative, I’ve included a Docker Compose file in example-3 that starts
    MongoDB in a Docker container. You can start it like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方案，我在 example-3 中包含了一个 Docker Compose 文件，该文件在 Docker 容器中启动 MongoDB。你可以这样启动它：
- en: '[PRE25]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 8.7.3 Loading database fixtures
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.3 加载数据库固定数据
- en: With a database up and running, now we need a way to load database fixtures
    on demand. A *database fixture* is a fixed set of test data that we can load into
    our database for testing. It’s called a fixture because we use it to seed our
    database with a well-known or specific set of data.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库运行起来后，我们现在需要一种按需加载数据库固定数据的方法。一个 *数据库固定数据* 是一组固定的测试数据，我们可以将其加载到我们的数据库中进行测试。它被称为固定数据，因为我们用它来用已知或特定的数据集初始化我们的数据库。
- en: 'Doing this is particularly easy with Jest as we can simply create a JavaScript
    helper function to load data directly into our database through the regular MongoDB
    Node.js library. MongoDB is already included in the example-3 package.json, and
    you can install all dependencies for example-2 like this:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Jest 做这件事尤其简单，因为我们可以直接通过常规的 MongoDB Node.js 库创建一个 JavaScript 辅助函数，将数据直接加载到我们的数据库中。MongoDB
    已经包含在 example-3 的 package.json 文件中，你可以像这样安装 example-2 的所有依赖项：
- en: '[PRE26]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'MongoDB can be installed in a new project as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式在新的项目中安装 MongoDB：
- en: '[PRE27]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we’ll use the `--save` argument instead of `--save-dev` because MongoDB
    is actually used in our production microservice, not just in the test code. Even
    though we use it for testing, we also need it installed as a production dependency
    rather than a dev dependency.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将使用 `--save` 参数而不是 `--save-dev`，因为 MongoDB 实际上在我们的生产微服务中使用了，而不仅仅是测试代码。尽管我们用它进行测试，但我们仍然需要将其作为生产依赖项而不是开发依赖项安装。
- en: Listing 8.8 shows a simple function that we can use for loading test data. We
    can call this function from our test code, and you’ll see an example of that soon.
    We simply need to specify the name of the collection and the data records to load.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 展示了一个我们可以用来加载测试数据的简单函数。我们可以从我们的测试代码中调用这个函数，你很快就会看到一个例子。我们只需要指定要加载的集合名称和数据记录。
- en: In listing 8.8, note how we are accessing the microservice’s database through
    the `db` field of our `microservice` object (which is saved in a variable as you
    can see in listing 8.6). This saves having to make multiple connections to the
    database. We don’t need to do that because the microservice has already made the
    connection, and we can reuse it.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.8 中，注意我们是如何通过 `microservice` 对象的 `db` 字段（如列表 8.6 中所示，该对象被保存在一个变量中）访问微服务的数据库。这样做可以避免多次连接到数据库。我们不需要这样做，因为微服务已经建立了连接，我们可以重用它。
- en: Listing 8.8 A helper function to load a database fixture (extract from chapter-8/example-3/src/index.test.js)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 加载数据库固定数据的辅助函数（摘自 chapter-8/example-3/src/index.test.js）
- en: '[PRE28]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① A helper function to load a database fixture
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ① 一个用于加载数据库固定数据的辅助函数
- en: ② Resets the database (don’t try this in production!)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ② 重置数据库（不要在生产环境中尝试！）
- en: ③ Inserts the test data (our database fixture) into the database
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将测试数据（我们的数据库固定数据）插入到数据库中
- en: One of the reasons we use MongoDB in the first place is because it makes it
    so easy to load test data. You can, of course, do this kind of thing with any
    database. It’s just that some databases, like traditional SQL databases, tend
    to be more difficult to deal with.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初选择使用 MongoDB 的一个原因是因为它使得加载测试数据变得非常容易。当然，你可以用任何数据库做这样的事情。只是有些数据库，比如传统的 SQL
    数据库，处理起来可能更困难。
- en: The helper function in listing 8.8 allows us to store test data inline with
    our test code and to load it on demand into our database. This is quite convenient,
    but it’s also possible to store our test data in distinct data files. That can
    make it a bit easier to organize. In the section coming up on end-to-end testing,
    you’ll see a different way to load database fixtures.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.8中的辅助函数允许我们将测试数据内联存储在我们的测试代码中，并在需要时将其加载到我们的数据库中。这非常方便，但也可以将我们的测试数据存储在独立的数据文件中。这样可能会更容易组织。在接下来的端到端测试部分，您将看到一种不同的加载数据库固定数据的方法。
- en: 8.7.4 Creating an integration test with Jest
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.4 使用Jest创建集成测试
- en: Creating an integration test with Jest is much the same as creating a unit test
    with Jest. Because we aren’t doing any mocking, it actually simplifies our test
    code quite a bit.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jest创建集成测试与创建单元测试非常相似。因为我们没有进行任何模拟，这实际上大大简化了我们的测试代码。
- en: Instead of invoking code directly in our microservice, we’ll use HTTP requests
    to trigger the code we’d like to test. To make HTTP requests, we can use either
    the Node.js low-level http library that we used in chapter 5 or a library installed
    through npm. In this case, we’ll use the Axios library, which is a more modern
    library that directly supports `async`/`await`, so it fits nicely with Jest’s
    support for asynchronous coding.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接在我们的微服务中调用代码，而是使用HTTP请求来触发我们想要测试的代码。为了发送HTTP请求，我们可以使用我们在第5章中使用的Node.js低级http库，或者通过npm安装的库。在这种情况下，我们将使用Axios库，这是一个更现代的库，它直接支持`async`/`await`，因此它与Jest对异步编码的支持非常契合。
- en: 'Example-3 already has Axios added to the package.json file. If you installed
    all dependencies for example-3, then you already have it. Otherwise, you can install
    Axios in a new project like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Example-3已经将Axios添加到package.json文件中。如果您已安装了example-3的所有依赖项，那么您已经拥有它。否则，您可以在新项目中像这样安装Axios：
- en: '[PRE29]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are using the `--save-dev` argument here because, in this case, we’ll only
    use Axios in our tests. For that reason, it can be a dev dependency. If you plan
    to use Axios in your production code though, be sure to install it as a regular
    dependency using `--save` instead of `--save-dev`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`--save-dev`参数，因为在这种情况下，我们将在测试中使用Axios。因此，它可以是开发依赖项。如果您计划在生产代码中使用Axios，请确保使用`--save`而不是`--save-dev`将其安装为常规依赖项。
- en: Listing 8.9 shows the code for our integration tests. This is similar to the
    code for our unit tests, but instead of mocking dependencies and directly calling
    into the code to be tested, we are starting our metadata microservice as a real
    HTTP server. We then use Axios to send HTTP requests to it.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9展示了我们的集成测试代码。这与我们的单元测试代码类似，但不同的是，我们不是模拟依赖项并直接调用要测试的代码，而是将元数据微服务作为真实的HTTP服务器启动。然后我们使用Axios向其发送HTTP请求。
- en: Be careful that you don’t run listing 8.9 against a production database! The
    function that loads the database fixture first drops the entire database. Make
    sure you only ever run this against a test database! And always backup your production
    database, just to be on the safe side!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不要在生产数据库上运行列表8.9！首先加载数据库固定数据的函数会删除整个数据库。请确保您只对测试数据库运行此操作！并且始终备份您的生产数据库，以防万一！
- en: Listing 8.9 Code for integration testing the metadata microservice with Jest
    (chapter-8/example-3/src/index.test.js)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 使用Jest对元数据微服务进行集成测试的代码（chapter-8/example-3/src/index.test.js）
- en: '[PRE30]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① Sets the base URL for our database server
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为我们的数据库服务器设置基本URL
- en: ② Starts the microservice, including the HTTP server and the database connection
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ② 启动微服务，包括HTTP服务器和数据库连接
- en: ③ Shuts down the microservice
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 关闭微服务
- en: ④ The helper function that loads test data (a database fixture) into our database.
    We defined this function in listing 8.8.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 加载测试数据（数据库固定数据）到我们的数据库中的辅助函数。我们在列表8.8中定义了这个函数。
- en: ⑤ Tests that a list of videos can be retrieved via a HTTP request to the /videos
    route
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 测试通过向/videos路由发送HTTP请求可以检索视频列表
- en: ⑥ Creates test data to load into the database
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 创建测试数据以加载到数据库中
- en: ⑦ Loads the database fixture into the videos collection of the database
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将数据库固定数据加载到数据库的视频集合中
- en: ⑧ Makes a HTTP request to the route we are testing
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 向我们正在测试的路由发送HTTP请求
- en: ⑨ Expects that the received data matches our test data
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 期望接收到的数据与我们的测试数据匹配
- en: ⑩ More tests go here!
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 更多测试在这里进行！
- en: In listing 8.9, there is only one test, but we can easily add more as we develop
    the microservice. Here again, we test the /videos route. This time, though, we
    do it through its normal HTTP interface, and the microservice is using a real
    database instead of a mock.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表8.9中，只有一个测试，但随着我们开发微服务，我们可以轻松地添加更多。这一次，我们通过其正常的HTTP接口进行测试。这次，微服务使用的是真实数据库而不是模拟。
- en: We aren’t testing that the HTTP server starts as we did in the unit tests. That
    was easy to test then because we had mocked the Express library. Now, though,
    we aren’t mocking anything so it’s difficult to explicitly confirm if the HTTP
    server was started correctly. Although, we can see that we are making a HTTP request
    to the microservice, which implicitly tests that our HTTP server is functioning.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是在测试HTTP服务器是否启动，就像我们在单元测试中做的那样。那时测试起来很容易，因为我们已经模拟了Express库。现在，尽管如此，我们并没有模拟任何东西，所以很难明确确认HTTP服务器是否正确启动。尽管如此，我们可以看到我们正在向微服务发送HTTP请求，这隐含地测试了我们的HTTP服务器是否正常工作。
- en: Note in listing 8.9 how we use Jest’s `beforeAll` function to start our microservice
    before testing, and then the `afterAll` function to shutdown the microservice.
    See how we are saving a reference to the `microservice` object. This means we
    can access its database connection and shutdown the microservice when done. Shutting
    down our microservice is something we never considered before, but it’s important
    here because this might not be the only test suite, and we don’t want to leave
    this microservice running longer than necessary.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在列表8.9中我们如何使用Jest的`beforeAll`函数在测试前启动我们的微服务，然后使用`afterAll`函数关闭微服务。看看我们是如何保存`microservice`对象的引用。这意味着我们可以在完成后访问其数据库连接并关闭微服务。关闭我们的微服务是我们之前从未考虑过的事情，但在这里它很重要，因为这可能不是唯一的测试套件，我们不希望这个微服务运行时间比必要的更长。
- en: You might have realized that as we add more tests to this test suite, we’ll
    run multiple tests against the same microservice. It’s not ideal to share the
    microservice across multiple tests in this way because it makes it difficult to
    know if each test is independent of the others. But it is significantly faster
    to do it this way than to separately start and stop the microservice for each
    test in turn. We could do that to make the test suite more reliable, but you’ll
    be waiting a lot longer for it to finish!
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，随着我们向这个测试套件添加更多测试，我们将对同一个微服务运行多个测试。以这种方式在多个测试中共享微服务并不是理想的，因为它使得知道每个测试是否独立于其他测试变得困难。但这种方式比分别为每个测试启动和停止微服务要快得多。我们可以这样做以提高测试套件的可靠性，但你会等待更长的时间才能完成它！
- en: 8.7.5 Running the test
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.5 运行测试
- en: Running integration tests with Jest is the same as running unit tests. Type
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jest运行集成测试与运行单元测试相同。输入
- en: '[PRE31]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Or, because we configured it in package.json, type
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，因为我们已经在package.json中进行了配置，所以可以输入
- en: '[PRE32]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Try running this integration test for yourself. Also, try changing code to break
    the test as we did earlier when unit testing.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试亲自运行这个集成测试。同时，尝试修改代码以破坏测试，就像我们之前在单元测试中做的那样。
- en: 8.7.6 What have we achieved?
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7.6 我们取得了什么成果？
- en: In this section, we learned the basics of running integration tests with Jest.
    It’s pretty much like unit testing, but we left out the mocking. As a result,
    we ran our code integrated with its dependencies.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了使用Jest运行集成测试的基础。它与单元测试非常相似，但我们省略了模拟。因此，我们运行了与依赖项集成的代码。
- en: 'When doing integration testing, we are not trying to isolate the code under
    test (that was the point of unit testing), and we aren’t trying to mock any dependencies
    (which is what helps achieve that isolation). We are, instead, aiming to test
    the code in its integrated state! That is to say, we are testing it in combination
    with other code: code in other modules and code in external libraries.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行集成测试时，我们并不是试图隔离被测试的代码（单元测试的目的就是如此），我们也不是试图模拟任何依赖（这有助于实现隔离）。相反，我们旨在测试代码的集成状态！也就是说，我们是在与其他代码结合的情况下测试它：其他模块中的代码和外部库中的代码。
- en: In a sense, integration testing is easier than unit testing because we don’t
    have the concerns of isolation and mocking. Creating integration testing can also
    be a more efficient use of our time than writing unit tests. That’s because integration
    tests tend to cover more code, and as such, you need to spend less time writing
    tests.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，集成测试比单元测试更容易，因为我们没有隔离和模拟的担忧。创建集成测试也可能比编写单元测试更有效地利用我们的时间。这是因为集成测试通常会覆盖更多的代码，因此你需要花费更少的时间来编写测试。
- en: The big problem with integration tests is that these are slower than unit tests.
    That is why they have a higher position in the testing pyramid. Consider the unit
    and integration tests that we have already seen in this chapter. These have tested
    basically the same thing. But in the case of integration testing, we started a
    real live HTTP server that connects to a real database. That makes integration
    tests much slower to execute than unit tests.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的大问题是它们比单元测试慢。这就是为什么它们在测试金字塔中位置更高的原因。考虑一下我们在本章中已经看到的单元和集成测试。它们基本上测试了相同的内容。但在集成测试的情况下，我们启动了一个真实的HTTP服务器，连接到一个真实的数据库。这使得集成测试的执行速度比单元测试慢得多。
- en: 8.8 End-to-end testing
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 端到端测试
- en: Now we take the final step up the testing pyramid (figure 8.1). We come to end-to-end
    testing. This is similar to integration testing except now we aim to test against
    our whole application, or at least, some cut-down version of it. Here we hope
    to test our application in its entirety and as close as we can to how it appears
    in its production environment.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们迈上测试金字塔的最终一步（图8.1）。我们来到了端到端测试。这与集成测试类似，但现在我们的目标是测试整个应用程序，或者至少是其简化版本。在这里，我们希望测试我们的应用程序的完整性，并尽可能接近其在生产环境中的表现。
- en: End-to-end testing is possibly the easiest form of testing yet. We don’t have
    to do any mocking, as we did with unit tests. However, we do need database fixtures
    so that we can load realistic test data.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试可能是最简单的测试形式。我们不需要像单元测试那样进行模拟。然而，我们需要数据库固定数据，以便我们可以加载真实的测试数据。
- en: Traditionally, it would have been difficult to do end-to-end testing against
    a distributed application. That’s because it takes a lot of effort to start all
    the services. Fortunately, we are now empowered by Docker Compose, which we learned
    in chapters 4 and 5 and have used since to develop our application. We will now
    use Docker Compose as a convenient way to boot our microservices application for
    automated end-to-end testing.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，对分布式应用程序进行端到端测试可能会有所困难。这是因为启动所有服务需要大量的努力。幸运的是，我们现在有了Docker Compose的帮助，我们在第4章和第5章中学习了它，并自那时起用它来开发我们的应用程序。现在我们将使用Docker
    Compose作为启动我们的微服务应用程序进行自动化端到端测试的便捷方式。
- en: At this point, we are leaving Jest behind and moving onto Cypress, a testing
    tool for loading and testing web pages. Cypress is powerful and has many features.
    Here you’ll only learn the basics, but that’s enough to get started and give you
    a taste of what it can do. We’ll use Cypress to run tests against our application
    through its front end as served by the gateway microservice. You can see what
    this looks like in figure 8.9.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们正在放弃Jest，转向Cypress，这是一个用于加载和测试网页的测试工具。Cypress功能强大，具有许多特性。在这里，你将只学习基础知识，但这足以让你开始并了解它能做什么。我们将使用Cypress通过网关微服务提供的前端来运行针对我们应用程序的测试。你可以在图8.9中看到这看起来是什么样子。
- en: '![](../Images/CH08_F09_Davis4.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F09_Davis4.png)'
- en: Figure 8.9 End-to-end testing our entire application with Cypress and Docker
    Compose
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 使用Cypress和Docker Compose进行端到端测试的整个应用程序
- en: Running end-to-end tests requires that we start our whole application and do
    the testing in a web browser. This makes end-to-end tests the slowest of all the
    types of testing and is what earns these their place at the top of the testing
    pyramid.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 运行端到端测试需要我们启动整个应用程序，并在浏览器中进行测试。这使得端到端测试成为所有测试类型中最慢的一种，也是它们位于测试金字塔顶端的原因。
- en: That said, having a handful of end-to-end tests should be an important part
    of your testing strategy. End-to-end testing covers a lot of ground, so even though
    these can take significant time to run, they deliver a lot of bang for buck. Also,
    this type of testing exercises your application through the front end, which happens
    to be the point of view of your customer. Needless to say, this *is* the most
    important perspective from which we can test our application, and it is the primary
    reason we place such a high value on end-to-end tests.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，拥有少量端到端测试应该是您测试策略的重要组成部分。端到端测试覆盖了大量的内容，尽管这些测试可能需要花费大量时间运行，但它们提供了很高的性价比。此外，这种测试通过前端来测试您的应用程序，而前端恰好是客户的角度。不用说，这确实是我们可以测试应用程序最重要的视角，也是我们将端到端测试的价值看得如此之高的主要原因。
- en: We now move on to example-4, the final example for chapter 8\. Example-4 contains
    a docker-compose.yaml that boots a cut-down version of FlixTube.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在转向第8章的最后一个示例——example-4。Example-4包含一个docker-compose.yaml文件，它启动了FlixTube的简化版本。
- en: 8.8.1 Why Cypress?
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.1 为什么选择Cypress？
- en: Cypress is simply a fantastic all-in-one-tool for testing web pages. It’s a
    visual solution and has a great user interface; we can actually watch it going
    through the motions of testing our application’s front end. You can get a feel
    for what this looks like in figure 8.10, but to truly understand how powerful
    it is, you must try it for yourself.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 简直是一个测试网页的绝佳全能工具。它是一个视觉解决方案，拥有出色的用户界面；我们实际上可以观察它测试我们应用程序前端的过程。您可以在图
    8.10 中看到它的样子，但要真正理解它的强大之处，您必须亲自尝试。
- en: Cypress uses Chrome by default for running tests, but it also automatically
    detects other browsers on our workstations. We can easily switch between these
    for cross-browser testing.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 默认使用 Chrome 来运行测试，但它也会自动检测我们工作站上的其他浏览器。我们可以轻松地在这些浏览器之间切换，以进行跨浏览器测试。
- en: '![](../Images/CH08_F10_Davis4.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F10_Davis4.png)'
- en: Figure 8.10 The Cypress UI (user interface)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 Cypress UI（用户界面）
- en: Cypress has a great user interface, but it can also run from the terminal in
    *headless* mode, which means the UI is hidden. During development, we’ll spend
    a lot of time using the Cypress UI to visually test our front end. Ultimately,
    we’ll run it in headless mode so that it fits into our CD pipeline.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 拥有出色的用户界面，但它也可以在 *无头* 模式下从终端运行，这意味着用户界面是隐藏的。在开发过程中，我们将花费大量时间使用 Cypress
    UI 来直观测试我们的前端。最终，我们将以无头模式运行它，以便它能够融入我们的 CD 管道。
- en: 'When running in headless mode, we can’t directly see Cypress interacting with
    our front end, but Cypress has a super cool feature: it records videos of its
    test runs. This feature really comes into its own for automated testing. When
    a Cypress test fails, you can extract the video of the failing test from your
    CD server so that you can see what happened!'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在无头模式下运行时，我们无法直接看到 Cypress 与我们的前端交互，但 Cypress 有一个超级酷的功能：它会记录测试运行的录像。这个功能在自动化测试中尤为有用。当
    Cypress 测试失败时，您可以从您的 CD 服务器中提取失败的测试录像，以便您可以看到发生了什么！
- en: 'When running the Cypress UI, it automatically supports live reload. All you
    need to do is to update your code and tests, and Cypress automatically reloads
    and runs your tests again. Like all the great modern tools, Cypress is open source.
    You can find the code for it on GitHub here:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行 Cypress UI 时，它自动支持实时重新加载。您需要做的就是更新您的代码和测试，Cypress 将自动重新加载并再次运行您的测试。像所有伟大的现代工具一样，Cypress
    是开源的。您可以在 GitHub 上找到它的代码，链接如下：
- en: '[https://github.com/cypress-io/cypress](https://github.com/cypress-io/cypress)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/cypress-io/cypress](https://github.com/cypress-io/cypress)'
- en: Cypress has other great features that will no doubt impress you. There are references
    at the end of the chapter so you can continue to learn more about Cypress.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 还拥有其他令人印象深刻的出色功能。您可以在本章末尾找到参考资料，以便继续学习更多关于 Cypress 的知识。
- en: It’s not all roses with Cypress, however, and I’d be remiss if I didn’t point
    out a major problem with it. Cypress is based on the Electron framework. This
    means that it’s large and can be quite slow to download/install. This also means
    it can be difficult, though still possible, to make it work efficiently in your
    CD pipeline.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Cypress 并非全是优点，如果我不指出它存在的一个主要问题，那将是我失职。Cypress 基于 Electron 框架。这意味着它体积庞大，下载/安装可能相当慢。这也意味着在您的持续集成/持续部署（CD）管道中使其高效运行可能很困难，尽管仍然可行。
- en: For this book and FlixTube, we integrate Cypress and our end-to-end tests into
    a single code repository. For real projects in the future, though, you might want
    to split your Cypress tests out to a separate testing repository. Although, normally,
    it’s nice to keep our tests collocated with the code being tested, with Cypress
    (because it’s so big), it can make sense to have these in separate repositories.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书和 FlixTube，我们将 Cypress 和我们的端到端测试集成到单个代码仓库中。然而，对于未来的真实项目，您可能希望将 Cypress 测试分离到单独的测试仓库中。尽管通常将测试与被测试的代码放在一起是件好事，但鉴于
    Cypress（它体积庞大），将这些放在单独的仓库中是有意义的。
- en: 8.8.2 Installing Cypress
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.2 安装 Cypress
- en: 'Example-4 already has Cypress added to its package.json. You can install dependencies
    like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Example-4 已经在 package.json 中添加了 Cypress。您可以使用以下方式安装依赖项：
- en: '[PRE33]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can install Cypress to a new project like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以这样将 Cypress 安装到新项目中：
- en: '[PRE34]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because Cypress, like Jest, is a tool only required for testing, we’ll use `--save-dev`
    to save it as a dev dependency. As mentioned, Cypress is large and installation
    can take some time. Now might be a good time for a coffee break!
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Cypress，就像 Jest 一样，仅是用于测试的工具，所以我们将使用 `--save-dev` 来将其保存为开发依赖项。正如之前提到的，Cypress
    是一个庞大的工具，安装可能需要一些时间。现在可能是一个喝咖啡的好时机！
- en: You can see in figure 8.11 the structure of the example-4 project with Cypress
    installed. This is similar to other project structures we have worked with in
    earlier chapters. We have a docker-compose.yaml file to build and run our application,
    and we have code for our microservices in subdirectories.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图 8.11 中看到安装了 Cypress 的 example-4 项目的结构。这与我们在前几章中处理的其他项目结构类似。我们有一个 docker-compose.yaml
    文件来构建和运行我们的应用程序，并且我们在子目录中有微服务的代码。
- en: '![](../Images/CH08_F11_Davis4.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F11_Davis4.png)'
- en: Figure 8.11 Example-4 project structure with Cypress installed
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 安装了 Cypress 的 Example-4 项目结构
- en: Some of the structure that you see in figure 8.11 is automatically created for
    you the first time you start Cypress in a new project. Particularly, Cypress creates
    many example test files under the subdirectory cypress/integration/examples. I
    haven’t included those examples in the chapter-8 code repository, but you can
    easily generate these yourself by installing Cypress in a new project and running
    it. You should try doing that because browsing through those example tests is
    a great way to learn more about the capabilities of Cypress.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 中你看到的一些结构是在你第一次在新项目中启动 Cypress 时自动为你创建的。特别是，Cypress 在 cypress/integration/examples
    子目录下创建了多个示例测试文件。我没有将这些示例包含在第 8 章的代码仓库中，但你可以通过在新项目中安装 Cypress 并运行它来轻松生成这些文件。你应该尝试这样做，因为浏览这些示例测试是了解
    Cypress 功能的绝佳方式。
- en: Listing 8.10 shows the Cypress configuration file. This is a JSON file where
    we can set configuration options for Cypress. For this example, we only need two
    options. The first is the `baseUrl`, where we set the base URL for the web page
    we are testing. We’ll run it locally (by booting our application with Docker Composer),
    so the hostname is `localhost`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 展示了 Cypress 配置文件。这是一个 JSON 文件，在其中我们可以设置 Cypress 的配置选项。对于本例，我们只需要两个选项。第一个是
    `baseUrl`，在这里我们设置要测试的网页的基础 URL。我们将本地运行它（通过使用 Docker Compose 启动我们的应用程序），因此主机名为
    `localhost`。
- en: The container that runs our gateway is configured to serve the front end on
    port 4000, which makes the base URL http://localhost:4000\. Setting the base URL
    in the Cypress configuration file is optional. But it’s useful in that we can
    easily redirect our entire Cypress test suite to a new location just by changing
    that line in the configuration file.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的网关的容器被配置为在端口 4000 上提供前端服务，这使得基础 URL 为 http://localhost:4000。在 Cypress 配置文件中设置基础
    URL 是可选的。但这样做很有用，因为我们只需更改配置文件中的那一行就可以轻松地将整个 Cypress 测试套件重定向到新位置。
- en: Listing 8.10 Configuration file for Cypress (chapter-8/example-4/cypress.json)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 Cypress 的配置文件（第 8 章/example-4/cypress.json）
- en: '[PRE35]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ① Sets the base URL that we will use to run tests against
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ① 设置我们将用于运行测试的基础 URL
- en: ② Sets the URL for the database fixtures REST API
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置数据库固定值 REST API 的 URL
- en: The other field we set in listing 8.10 is not a standard Cypress configuration
    option. We need a way to load database fixtures into our database. For reasons
    that I’ll explain soon, we’ll use a separate REST API to do that. The `dbFixturesUrl`
    field in the configuration file sets the base URL for that REST API.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 中我们设置的另一个字段不是标准的 Cypress 配置选项。我们需要一种方法将数据库固定值加载到我们的数据库中。由于我将很快解释的原因，我们将使用一个单独的
    REST API 来完成这个任务。配置文件中的 `dbFixturesUrl` 字段设置了该 REST API 的基础 URL。
- en: 8.8.3 Starting the Cypress UI
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.3 启动 Cypress UI
- en: 'Now we are ready to start Cypress and run some tests. In your terminal, run
    the following command from example-4 in the chapter-8 code repository:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好启动 Cypress 并运行一些测试了。在你的终端中，从第 8 章代码仓库中的 example-4 运行以下命令：
- en: '[PRE36]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This opens the first level of the Cypress UI and shows a list of your Cypress
    test suites. Example-4 only contains a single test suite. Double click the test
    suite named front-end.spec.js to open the next level of the Cypress UI.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 Cypress UI 的第一层，并显示你的 Cypress 测试套件列表。Example-4 只包含一个测试套件。双击名为 front-end.spec.js
    的测试套件以打开 Cypress UI 的下一层。
- en: What you see now is a single test to run against the FlixTube UI. The test runs
    automatically, but at this point, the test should fail because we haven’t started
    our application yet.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在看到的是一个针对 FlixTube UI 运行的单个测试。测试会自动运行，但在这个阶段，测试应该会失败，因为我们还没有启动我们的应用程序。
- en: 8.8.4 Setting up database fixtures
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.4 设置数据库固定值
- en: Before we start our application, we must be able to load database fixtures.
    When using Jest earlier, we were able to load data into our database directly
    from the test code. We can’t do this directly from Cypress because it runs in
    the browser (Cypress is an Electron application-based on the Chromium rendering
    engine, the basis for the Chrome web browser), and the regular MongoDB npm library
    doesn’t work there. We need a different solution for loading database fixtures.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始应用程序之前，我们必须能够加载数据库固定数据。在之前使用 Jest 时，我们能够直接从测试代码中将数据加载到数据库中。我们不能直接从 Cypress
    中这样做，因为它是运行在浏览器中的（Cypress 是基于 Chromium 渲染引擎的 Electron 应用程序，是 Chrome 浏览器的基础），并且常规的
    MongoDB npm 库在那里不起作用。我们需要一个不同的解决方案来加载数据库固定数据。
- en: To load test data into our database, we’ll use a separate REST API to manage
    our database. That means we can make HTTP requests to load and unload database
    fixtures. We are already using Docker Compose, so it’s not difficult to add an
    extra container into our application. Figure 8.12 shows the structure of our application
    including the new database fixtures REST API.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 要将测试数据加载到我们的数据库中，我们将使用一个单独的 REST API 来管理我们的数据库。这意味着我们可以通过 HTTP 请求来加载和卸载数据库固定数据。我们已经在使用
    Docker Compose，因此将额外的容器添加到我们的应用程序中并不困难。图 8.12 显示了包括新的数据库固定数据 REST API 在内的应用程序结构。
- en: 'Creating such a REST API is quite a bit of work. However, I already have one
    that I’ve used for testing projects in the past. I’ve included a copy of the code
    for it under the example-4 project (find it under example-4/db-fixtures-rest-api).
    You can also find a standalone copy of the code on GitHub:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样的 REST API 需要做很多工作。然而，我已经有一个过去用于测试项目的。我在 example-4 项目中包含了它的代码副本（在 example-4/db-fixtures-rest-api
    下找到）。你还可以在 GitHub 上找到代码的独立副本：
- en: '[https://github.com/ashleydavis/db-fixture-rest-api](https://github.com/ashleydavis/db-fixture-rest-api)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/ashleydavis/db-fixture-rest-api](https://github.com/ashleydavis/db-fixture-rest-api)'
- en: '![](../Images/CH08_F12_Davis4.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F12_Davis4.png)'
- en: Figure 8.12 Using the database fixtures REST API to seed our database with test
    data prior to running tests with Cypress
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 在运行 Cypress 测试之前使用数据库固定数据 REST API 为数据库播种测试数据
- en: We won’t cover the internals of the database fixtures REST API in this book.
    We have to draw the line somewhere, but feel free to look over this code on your
    own. Learning to read the code of others is a valuable experience. Be assured
    that you won’t find anything particularly new here; after all, it’s just a Node.js
    REST API built on Express. That’s similar to the microservices you have already
    seen in this book.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中介绍数据库固定数据 REST API 的内部结构。我们必须在某处划线，但请随意查看你自己的代码。阅读他人的代码是一种宝贵的经验。请放心，你在这里不会找到任何特别新的东西；毕竟，它只是一个基于
    Express 的 Node.js REST API，这与你在本书中已经看到的微服务类似。
- en: Listing 8.11 is an extract from the example-4 docker-compose.yaml file. It shows
    that we integrate the database fixtures REST API into our application the same
    way as any other microservice.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 是 example-4 docker-compose.yaml 文件的摘录。它显示我们将数据库固定数据 REST API 集成到我们的应用程序中的方式与任何其他微服务相同。
- en: Listing 8.11 Loading the db fixtures REST API with Docker Compose (extract from
    chapter-8/example-3/docker-compose.yaml)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 使用 Docker Compose 加载 db 固定数据 REST API（摘自第 8 章示例 3 的 docker-compose.yaml）
- en: '[PRE37]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① Configures a MongoDB database server
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ① 配置 MongoDB 数据库服务器
- en: ② Configures the database fixtures REST API
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ② 配置数据库固定数据 REST API
- en: ③ The gateway and metadata microservices are defined here.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 网关和元数据微服务在此定义。
- en: Listing 8.11 adds the database fixtures REST API to our application, but we
    still need a way to talk to it from our Cypress tests. For that, we’ll make an
    extension to Cypress that we can use from our tests to load database fixtures.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 将数据库固定数据 REST API 添加到我们的应用程序中，但我们仍然需要一个方法从我们的 Cypress 测试中与之通信。为此，我们将创建一个
    Cypress 扩展，我们可以在测试中使用它来加载数据库固定数据。
- en: Listing 8.12 is a snippet of code that shows how we can add a new command to
    Cypress. This is an example of how we can extend Cypress to do new things. This
    particular command is called `loadFixture`, and we’ll use it in our Cypress tests
    to load database fixtures.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 是一段代码片段，展示了我们如何向 Cypress 添加新命令。这是一个展示如何扩展 Cypress 来执行新功能的例子。这个特定的命令被称为
    `loadFixture`，我们将在 Cypress 测试中使用它来加载数据库固定数据。
- en: Listing 8.12 Loading a database fixture under Cypress (extract from chapter-8/example-3/cypress/support/commands.js)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 在 Cypress 下加载数据库固定数据（摘自第 8 章示例 3 的 cypress/support/commands.js）
- en: '[PRE38]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ① Defines a Cypress command (an extension to Cypress) to load database fixtures
    via the new REST API
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义一个 Cypress 命令（Cypress 的扩展）通过新的 REST API 加载数据库固定数据
- en: ② Unloads test data from the previous test (by calling another helper function)
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ② 通过调用另一个辅助函数从上一个测试中卸载数据（测试数据）
- en: ③ Reads the URL of the REST API from the Cypress configuration file
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 从 Cypress 配置文件中读取 REST API 的 URL
- en: ④ Makes a HTTP GET request to the REST API to load the database fixture
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 向 REST API 发送 HTTP GET 请求以加载数据库固定数据
- en: ⑤ Expects that the fixture was successfully loaded (fails the test otherwise)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 预期固定数据已成功加载（否则测试失败）
- en: The `loadFixture` command makes a HTTP GET request to the database fixtures
    REST API and causes it to load a database fixture from a file (in this case, example-4/fixtures/two-videos/videos.js).
    In a moment, you’ll see how we invoke this command from our test code.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadFixture` 命令向数据库固定数据 REST API 发送 HTTP GET 请求，并使其从文件（在这种情况下，example-4/fixtures/two-videos/videos.js）中加载数据库固定数据。稍后，您将看到我们如何在测试代码中调用此命令。'
- en: 8.8.5 Booting your application
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.5 启动您的应用程序
- en: We have Cypress installed and ready to go, and we have the ability to load database
    fixtures. Before we can test our application, we must boot it!
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装并准备好了 Cypress，并且我们有能力加载数据库固定数据。在我们能够测试我们的应用程序之前，我们必须启动它！
- en: Listing 8.11 was an extract of the Docker Compose file for example-4\. The complete
    file contains the configuration for a cut-down version of FlixTube with gateway
    and metadata microservices. This is nowhere near the full application, but it’s
    enough that we can write a test to confirm that the list of videos is retrieved
    from the database and displayed in the front end.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 是 example-4 的 Docker Compose 文件的摘录。完整的文件包含了一个带有网关和元数据微服务的 FlixTube 简化版本的配置。这远非完整的应用程序，但足以让我们编写一个测试来确认视频列表是从数据库中检索并在前端显示的。
- en: 'In this case, I’ve simplified FlixTube just so that I can present it as a simple
    example for this chapter. Generally, though, it’s good to know that we always
    have the option of cutting back our application to make it easier to test. As
    our application grows larger, it will eventually become too big to be tested on
    a single computer using end-to-end tests. At this point, we are forced to chop
    up our application into smaller testable units. Now, let’s start the application
    using our old friend Docker Compose:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将 FlixTube 简化，以便将其作为本章的一个简单示例。然而，一般来说，了解我们总是有选择缩减应用程序以使其更容易测试的选项是很好的。随着我们的应用程序越来越大，最终它将变得太大，无法使用端到端测试在单个计算机上进行测试。在这种情况下，我们被迫将应用程序分割成更小的可测试单元。现在，让我们使用我们的老朋友
    Docker Compose 启动应用程序：
- en: '[PRE39]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 8.8.6 Creating an end-to-end test with Cypress
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.6 使用 Cypress 创建端到端测试
- en: Writing end-to-end tests with Cypress is a bit different from writing tests
    with Jest. In listing 8.13, we use a similar overall structure composed of `describe`
    and `it` functions instead of `describe` and `test` (we used those with Jest).
    `describe` and `it` come from the Mocha style of testing.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cypress 编写端到端测试与使用 Jest 编写测试略有不同。在列表 8.13 中，我们使用由 `describe` 和 `it` 函数组成的类似整体结构，而不是
    Jest 中的 `describe` 和 `test`（我们使用了那些）。`describe` 和 `it` 来自 Mocha 测试风格。
- en: Mocha is a different testing framework for JavaScript that is still popular,
    so you might have already heard about it. Cypress happens to be based on Mocha,
    and that is why these tests look the way they do. Jest actually supports the `describe`
    and `it` format as well, so if you wanted, you could use that same format with
    both testing tools.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 是一个流行的 JavaScript 测试框架，您可能已经听说过它。Cypress 正是基于 Mocha，这就是为什么这些测试看起来是这样的。实际上，Jest
    也支持 `describe` 和 `it` 格式，所以如果您愿意，您可以使用相同的格式使用这两个测试工具。
- en: Listing 8.13 An end-to-end test of FlixTube with Cypress (extract from chapter-8/example-4/cypress/integration/front-end.spec.js)
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 使用 Cypress 对 FlixTube 进行端到端测试（来自第 8 章的 example-4/cypress/integration/front-end.spec.js）
- en: '[PRE40]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① Defines the test suite
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义测试套件
- en: ② Tests that we can load the list of videos in the FlixTube UI
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ② 测试我们能否在 FlixTube UI 中加载视频列表
- en: ③ Loads the fixture named two-videos into the videos collection of the metadata
    database
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将名为 two-videos 的固定数据加载到元数据数据库的视频集合中
- en: ④ Makes Cypress visit the FlixTube home page
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 让 Cypress 访问 FlixTube 的主页
- en: ⑤ Verifies the details of the first video
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 验证第一段视频的详细信息
- en: ⑥ Checks that two videos (those loaded from the database fixture) are displayed
    in the UI
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 检查两个视频（从数据库固定数据加载的视频）是否在 UI 中显示
- en: ⑦ Verifies the details of the second video
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 验证第二段视频的详细信息
- en: The first line of code in our test is a call to our `loadFixtures` command,
    accessed through the Cypress `cy` object. The Cypress interface also contains
    many other functions for loading, interacting with, and testing web pages.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试中的第一行代码是对我们的 `loadFixtures` 命令的调用，通过 Cypress 的 `cy` 对象访问。Cypress 接口还包含许多其他用于加载、交互和测试网页的功能。
- en: On the next line, we call `cy.visit`. This is the most important thing you need
    to know about Cypress. This function is how you make Cypress visit a web page.
    All other Cypress commands operate relative to the page that is visited.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们调用 `cy.visit`。这是你需要了解的 Cypress 中最重要的事情。这个函数是 Cypress 访问网页的方式。所有其他 Cypress
    命令都是相对于访问的页面操作的。
- en: Here we are visiting the `/` (root) route on our web page. Note that this is
    relative to the base URL that we specified earlier in the Cypress configuration
    file. This navigates the Cypress browser to the FlixTube home page.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里正在访问网页上的`/`（根）路由。请注意，这相对于我们在 Cypress 配置文件中之前指定的基本 URL。这会将 Cypress 浏览器导航到
    FlixTube 主页。
- en: Next, we use `cy.get` to get an element from the browser’s DOM hierarchy and
    run tests against it. It checks that we have two videos in the video list and
    then checks the names and links for each. We know these videos should be displayed
    in the front end because we have seeded our metadata microservice’s database with
    the two-videos database fixture on the first line of this test. That database
    fixture loads test data (you can see it in example-4/fixtures/two-videos/videos.js)
    into the database with all the details of these two videos.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `cy.get` 从浏览器的 DOM 层级中获取一个元素并对它进行测试。它检查我们在视频列表中有两个视频，然后检查每个视频的名称和链接。我们知道这些视频应该在前端显示，因为我们在这个测试的第一行用两个视频的数据库固定文件初始化了我们的元数据微服务的数据库。这个数据库固定文件将测试数据（你可以在
    example-4/fixtures/two-videos/videos.js 中看到）加载到数据库中，包含这两个视频的所有详细信息。
- en: If you already have Cypress open, then you’ll have run this test already. The
    result should look like figure 8.10\. You might need to refresh the Cypress UI
    to run the test after you started the application in the previous section. At
    this point, you can experiment with breaking this code and seeing the tests fail,
    just like we did earlier with the unit and integration tests.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经打开了 Cypress，那么你可能已经运行了这个测试。结果应该看起来像图 8.10。你可能需要在上一节启动应用程序后刷新 Cypress UI
    来运行测试。在这个时候，你可以尝试破坏这段代码并观察测试失败，就像我们之前在单元和集成测试中做的那样。
- en: Here’s an example. Open the file example-4/gateway/src/views/video-list.hbs.
    This is the HTML that is rendered for the FlixTube home page (in the format of
    a Handlebars template). Try changing this HTML so that something different is
    displayed for each video in the list. Once you break the tests, you’ll see red
    for failure instead of the green for success that was shown in figure 8.10.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。打开文件 example-4/gateway/src/views/video-list.hbs。这是为 FlixTube 主页渲染的 HTML（以
    Handlebars 模板格式）。尝试更改这个 HTML，以便在列表中的每个视频上显示不同的内容。一旦破坏了测试，你会看到红色表示失败，而不是图 8.10
    中显示的绿色成功。
- en: Just be careful that you never run this test against a production database.
    Loading a database fixture wipes out the relevant database collections, and you
    never want to lose production data. You shouldn’t be able to do this in production
    anyway, because you would never run the database fixtures REST API in production!
    That gives us the capability to load database fixtures, but we only need it for
    development and testing environments.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 只要注意，你永远不要在生产数据库上运行这个测试。加载数据库固定文件会清除相关的数据库集合，你永远不希望丢失生产数据。实际上，你也不应该在生产环境中这样做，因为你在生产环境中永远不会运行数据库固定文件的
    REST API！这给了我们加载数据库固定文件的能力，但我们只需要在开发和测试环境中使用它。
- en: Note Running the database fixtures REST API in a production environment also
    gives external access to your database. This is a recipe for disaster, so be careful
    never to instantiate it in production.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在生产环境中运行数据库固定文件的 REST API 也会使外部访问你的数据库。这是一个灾难性的配方，所以请务必不要在生产环境中实例化它。
- en: There’s so much more you can do with Cypress! This includes clicking buttons
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 Cypress 做的事情还有很多！这包括点击按钮
- en: '[PRE41]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and typing values into input fields:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在输入字段中输入值：
- en: '[PRE42]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Cypress even provides facilities to mock your backend REST APIs. You can use
    this to isolate the user interface for testing! This allows you to do a kind of
    TDD for user interfaces which, frankly, I find quite amazing. There are references
    at the end of this chapter so you can continue learning about Cypress.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 还提供了模拟你的后端 REST API 的功能。你可以使用这个功能来隔离用户界面进行测试！这允许你进行一种针对用户界面的 TDD（测试驱动开发），坦白说，我觉得这非常令人惊讶。本章末尾有参考资料，你可以继续学习关于
    Cypress 的知识。
- en: 8.8.7 Invoking Cypress with npm
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.7 使用 npm 调用 Cypress
- en: 'Now we can get set up to invoke our Cypress tests with npm just like we did
    with Jest. Example-4 is a separate project to the other examples, and we use a
    different testing tool (Cypress instead of Jest). Nevertheless, we’d like to be
    able to run Cypress with the conventional npm test script like this:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设置使用 npm 调用我们的 Cypress 测试，就像我们使用 Jest 一样。Example-4 是一个独立于其他示例的项目，我们使用不同的测试工具（Cypress
    而不是 Jest）。尽管如此，我们希望能够像这样使用传统的 npm test 脚本来运行 Cypress：
- en: '[PRE43]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Listing 8.14 shows the setup in package.json to make this work. We have configured
    the test script to invoke `cypress run`, which executes Cypress in headless mode.
    This allows us to run Cypress tests from the terminal just like we did earlier
    with Jest tests.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14 展示了在 package.json 中的设置，以便实现这一功能。我们已配置测试脚本以调用 `cypress run`，这将以无头模式执行
    Cypress。这允许我们从终端运行 Cypress 测试，就像我们之前使用 Jest 测试那样。
- en: Listing 8.14 Package.json with npm scripts for running Cypress (chapter-8/example-4/package.json)
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14 包含 npm 脚本的 package.json 以运行 Cypress（章节-8/示例-4/package.json）
- en: '[PRE44]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ① Invoking the command “npm run cypress” opens the Cypress UI
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ① 调用命令“npm run cypress”打开 Cypress UI
- en: ② Invoking “npm test” runs Cypress in headless mode to run tests entirely from
    the command line
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用“npm test”命令以无头模式运行 Cypress，从而完全从命令行运行测试
- en: The other script we set up is `npm run test:watch` to invoke `cypress open`,
    which opens the Cypress UI. I like this configuration because I feel that running
    the Cypress UI (which automatically does live reload) is functionally similar
    to running Jest in live reload mode (with Jest’s `--watch`/`--watchAll` argument).
    When I want this functionality, I simply invoke `npm run test:watch`, and I don’t
    have to think about whether I’m in a Jest project or a Cypress project. I just
    get the result that I’m expecting.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的另一个脚本是为 `npm run test:watch` 调用 `cypress open`，这将打开 Cypress UI。我喜欢这种配置，因为我感觉运行
    Cypress UI（它会自动进行实时重载）在功能上与在 Jest 的实时重载模式下运行 Jest 类似（使用 Jest 的 `--watch`/`--watchAll`
    参数）。当我需要这个功能时，我只需调用 `npm run test:watch`，而无需考虑我是在 Jest 项目中还是在 Cypress 项目中。我只是得到了我预期的结果。
- en: 8.8.8 What have we achieved?
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8.8 我们取得了什么成果？
- en: We’ve almost come to the end of our journey through the testing landscape. We’ve
    seen unit testing, integration testing, and now end-to-end testing.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了对测试领域的探索。我们看到了单元测试、集成测试，现在还有端到端测试。
- en: 'We’ve understood the relative performance of tests: integration tests are slower
    than unit tests and end-to-end tests are slower than integration tests. And we’ve
    seen how each unit test covers only a small amount of isolated code. Integration
    and end-to-end testing can be very effective because these cover much more code
    with fewer tests.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了测试的相对性能：集成测试比单元测试慢，端到端测试比集成测试慢。我们还看到了每个单元测试仅覆盖一小部分隔离代码的情况。集成和端到端测试可以非常有效，因为这些测试覆盖了更多的代码，但测试数量较少。
- en: The question now is how many of each type of test should you have? The answer
    to this is never set in stone.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，你应该有多少种类型的测试？这个答案并不是一成不变的。
- en: But what I can say is that you can, and probably should, have 100s or 1,000s
    of unit tests. You’ll need to have much fewer integration tests and very few end-to-end
    tests. It’s difficult to say how many because it really depends on how long you
    are willing to wait for a test to run to completion. If you are happy to wait
    overnight or over a weekend for your test suite to complete, then you can probably
    afford to have 100s or 1,000s of end-to-end tests as well.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 但我可以说的是，你可以，也许应该，拥有 100 个或 1,000 个单元测试。你需要更少的集成测试和非常少的端到端测试。很难说具体数量，因为这实际上取决于你愿意等待测试完成的时间长度。如果你愿意等待一整夜或整个周末来让测试套件完成，那么你可能也能承担起拥有
    100 个或 1,000 个端到端测试的成本。
- en: As developers, though, we crave fast and comprehensive feedback. For this, you
    can’t beat unit tests. If you can have a huge amount of code coverage through
    many extremely fast unit tests, then this is what you should have! That’s because
    this is what will get used by your developers as they are coding throughout every
    moment of their working day. If your test suite is slow, developers will tend
    not to use it and not to update it. That’s not good for anyone.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，作为开发者，我们渴望快速和全面的反馈。在这方面，单元测试是无与伦比的。如果你可以通过许多非常快速的单元测试实现大量的代码覆盖率，那么这就是你应该拥有的！这是因为这就是开发者会在他们工作日的每一刻编码时使用的。如果你的测试套件运行缓慢，开发者往往不会使用它，也不会更新它。这对任何人来说都不是好事。
- en: At the end of the day, it’s not black and white. There isn’t even a clear distinction
    between the different types of tests. Where does unit testing end and integration
    testing begin? It’s not clear. All tests fall on a spectrum, and it’s a spectrum
    with many shades of grey.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，事情并非非黑即白。不同类型的测试之间甚至没有明确的区分。单元测试在哪里结束，集成测试又从哪里开始？这并不明确。所有测试都落在光谱上，这是一个有着许多灰度的光谱。
- en: 8.9 Automated testing in the CD pipeline
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.9 持续集成（CD）管道中的自动化测试
- en: 'We have a suite of automated tests. Now we arrive at the real point of automated
    testing: to put it on automatic!'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一套自动化测试。现在我们来到了自动化测试的真正目的：让它自动运行！
- en: To truly be automatic, our tests need to operate directly on our hosted code
    repository. When a developer pushes code changes to the code repository, we’d
    like to automatically run the test suite to check the health of the code. To achieve
    this, we must add the tests to our CD pipeline, where they will be an automatic
    checkpoint in front of production deployment. If the tests pass, our code goes
    to production. If they fail, our code will not be deployed. It’s as simple as
    that. Figure 8.13 illustrates this scenario.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正实现自动化，我们的测试需要直接在我们的托管代码仓库上运行。当开发者将代码更改推送到代码仓库时，我们希望自动运行测试套件来检查代码的健康状况。为了实现这一点，我们必须将测试添加到我们的
    CD 管道中，这样它们就会在生产部署之前成为一个自动检查点。如果测试通过，我们的代码就会部署到生产环境。如果它们失败，我们的代码将不会被部署。就是这样简单。图
    8.13 说明了这种情况。
- en: '![](../Images/CH08_F13_Davis4.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 Davis4](../Images/CH08_F13_Davis4.png)'
- en: Figure 8.13 Automated testing within the CD pipeline
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 持续集成（CD）管道中的自动化测试
- en: 'The reason we spent time earlier discussing the configuration of the npm test
    script in package.json is because that’s how we’ll integrate our automated tests
    into our CD pipeline. As we learned in the previous chapter, a CD pipeline can
    be as simple as running a shell script (even though some vendors offer fancy GUIs).
    Adding our automated tests then is easy. Assuming our npm test script is configured,
    we can simply invoke the following from our deployment shell script:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前花时间讨论 npm test 脚本在 package.json 中的配置，原因在于这是我们如何将自动化测试集成到我们的 CD 管道中的方式。正如我们在上一章所学，CD
    管道可以简单到只是运行一个 shell 脚本（尽管一些供应商提供了花哨的图形用户界面）。添加我们的自动化测试很容易。假设我们的 npm test 脚本已经配置好，我们只需从我们的部署
    shell 脚本中调用以下命令即可：
- en: '[PRE45]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As an example, let’s consider adding automated tests to example-4 from chapter
    7\. Listing 8.15 shows the YAML file for configuring Bitbucket Pipelines. This
    is the same as the one we used in chapter 7, but now we are invoking `npm test`
    prior to invoking the deployment script.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，让我们考虑将自动化测试添加到第 7 章的 example-4 中。列表 8.15 显示了配置 Bitbucket Pipelines 的 YAML
    文件。这与第 7 章中使用的相同，但现在我们在调用部署脚本之前先调用 `npm test`。
- en: If the automated tests fail, that is to say, that if `npm test` returns a nonzero
    exit code, which both Jest and Cypress do if any tests fail, then the pipeline
    itself fails and is aborted. Failing tests, therefore, prevent deployment to production.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自动化测试失败，也就是说，如果 `npm test` 返回非零退出码，Jest 和 Cypress 都会在任何测试失败时这样做，那么管道本身就会失败并终止。因此，失败的测试会阻止代码部署到生产环境。
- en: Listing 8.15 Running tests in the CD pipeline (an update to chapter-7/example-4/bitbucket-pipelines.yaml)
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15 在持续集成（CD）管道中运行测试（第 7 章示例-4/bitbucket-pipelines.yaml 的更新）
- en: '[PRE46]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ① Runs tests for the video-streaming microservice from chapter 7
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: ① 运行第 7 章中视频流微服务的测试
- en: Having Jest running in our CD pipeline is fairly easy. The `npm install` in
    listing 8.15 installs it.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的持续集成（CD）管道中运行 Jest 相对简单。列表 8.15 中的 `npm install` 命令会安装它。
- en: Running Cypress is more complicated. Because Cypress is so big, you’ll need
    to configure caching in your CD server so that Cypress isn’t redownloaded every
    time the pipeline is invoked. That’s getting a bit too involved and is specific
    to your CD provider, so we don’t cover it in this book.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Cypress 更为复杂。因为 Cypress 非常庞大，您需要在 CD 服务器上配置缓存，以便每次流水线调用时 Cypress 都不会重新下载。这有点过于复杂，并且特定于您的
    CD 提供商，因此我们在这本书中不涉及它。
- en: We also need a command in our deployment script that boots our application before
    running the Cypress tests. This makes things more difficult and is much more advanced.
    Although beyond the scope of this book, it’s definitely worthwhile that you look
    into this so you can have end-to-end tests running automatically in your deployment
    pipeline.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在部署脚本中添加一个命令，在运行 Cypress 测试之前启动我们的应用程序。这使得事情变得更加复杂，并且更加高级。虽然这超出了本书的范围，但您确实值得深入研究，以便在您的部署管道中自动运行端到端测试。
- en: 8.10 Review of testing
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.10 测试概览
- en: Before finishing the chapter, here is a quick review of Jest and Cypress and
    how we use these to run tests.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，这里快速回顾一下 Jest 和 Cypress，以及我们如何使用这些工具来运行测试。
- en: Table 8.2 Review of testing commands
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.2 测试命令概览
- en: '| Command | Description |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `npx jest --init` | Initializes the Jest configuration file. |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| `npx jest --init` | 初始化 Jest 配置文件。 |'
- en: '| `npx jest` | Runs tests under Jest. |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| `npx jest` | 在 Jest 下运行测试。 |'
- en: '| `npx jest --watch` | Runs tests with live reload enabled to rerun tests when
    code has changed. It uses Git to know which files have changed. |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| `npx jest --watch` | 启用实时重新加载功能运行测试，当代码发生变化时重新运行测试。它使用 Git 来确定哪些文件已更改。 |'
- en: '| `npx jest --watchAll` | As above, except it monitors all files for changes
    and not just those that are reported changed by Git. |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| `npx jest --watchAll` | 与上述类似，但它监视所有文件的变化，而不仅仅是 Git 报告已更改的文件。 |'
- en: '| `npx cypress open` | Opens the Cypress UI so that you can run tests. Live
    reload works out of the box; you can update your code and the tests rerun automatically.
    |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| `npx cypress open` | 打开 Cypress UI，以便您可以运行测试。实时重新加载默认启用；您可以更新代码，测试将自动重新运行。
    |'
- en: '| `npx cypress run` | Executes Cypress tests with Cypress running in headless
    mode. This allows you to do Cypress testing from the command line (or CD pipeline)
    without having to display the user interface. |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| `npx cypress run` | 在无头模式下运行 Cypress 测试。这允许您从命令行（或 CD 流水线）进行 Cypress 测试，而无需显示用户界面。
    |'
- en: '| `npm test` | The npm script convention for running tests. Runs Jest or Cypress
    (or even both), depending on how you configured your package.json file.This is
    the command you should run in your CD pipeline to execute your test suite. |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| `npm test` | npm 运行测试的脚本约定。根据您在 package.json 文件中的配置，运行 Jest 或 Cypress（甚至两者都运行）。这是您应在
    CD 流水线中运行的命令以执行测试套件。 |'
- en: '| `npm run test:watch` | This is my personal convention for running tests in
    live reload mode. You need to configure this script in your package.json file
    to use it. |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| `npm run test:watch` | 这是我在实时重新加载模式下运行测试的个人约定。您需要配置 package.json 文件中的此脚本才能使用它。
    |'
- en: 8.11 Continue your learning
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.11 继续你的学习
- en: 'In this chapter, we learned the basics of automated testing. There’s enough
    here to kick start your own testing regime, but testing is such a huge subject
    and is a specialization in its own right. To explore the subject further, refer
    to the following books:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了自动化测试的基础知识。这里的内容足以启动您自己的测试计划，但测试是一个如此庞大的主题，并且本身就是一种专业。要进一步探索这个主题，请参考以下书籍：
- en: '*Unit Testing Principles, Practices, and Patterns* by Vladimir Khorikov (Manning,
    2020)'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《单元测试原则、实践和模式》*，作者：弗拉基米尔·科里科夫（Vladimir Khorikov）（Manning, 2020）'
- en: '*The Art of Unit Testing*, 2nd ed., by Roy Osherove (Manning, 2013)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《单元测试的艺术》（第 2 版）*，作者：罗伊·奥斯霍夫（Roy Osherove）（Manning, 2013）'
- en: '*Testing Java Microservices* by *Alex Soto Bueno, Andy Gumbrecht,* and *Jason
    Porter (Manning, 2018)*'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《测试 Java 微服务》*，作者：*亚历克斯·索托·布埃诺（Alex Soto Bueno）、安迪·冈布雷希特（Andy Gumbrecht）和贾森·波特（Jason
    Porter）*（Manning, 2018）'
- en: '*Testing Microservices with Mountebank* by *Brandon Byars (Manning, 2018)*'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《使用 Mountebank 测试微服务》*，作者：*布兰登·拜尔斯（Brandon Byars）*（Manning, 2018）'
- en: 'Also see *Exploring JavaScript Testing* by Elyse Kolker Gordon (Manning, 2019),
    which is a free collection of chapters about testing from other books available
    from Manning:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 还可参见 Elyse Kolker Gordon 著的 *《探索 JavaScript 测试》*（Manning, 2019），这是一本关于测试的免费章节集合，来自
    Manning 出版的其他书籍：
- en: '[https://www.manning.com/books/exploring-javascript-testing](https://www.manning.com/books/exploring-javascript-testing)'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.manning.com/books/exploring-javascript-testing](https://www.manning.com/books/exploring-javascript-testing)'
- en: 'To learn more about Jest, see the Jest web page and *Getting Started* guide
    here:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Jest 的信息，请参阅 Jest 网页和此处提供的 *《入门》* 指南：
- en: '[https://jestjs.io/](https://jestjs.io/)'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jestjs.io/](https://jestjs.io/)'
- en: '[https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started)'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started)'
- en: 'To learn more about Cypress, see the Cypress web page and documentation here:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Cypress 的信息，请查看以下 Cypress 网页和文档：
- en: '[https://www.cypress.io/](https://www.cypress.io/)'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.cypress.io/](https://www.cypress.io/)'
- en: '[https://docs.cypress.io/guides/getting-started/installing-cypress.html](https://docs.cypress.io/guides/getting-started/installing-cypress.html)'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.cypress.io/guides/getting-started/installing-cypress.html](https://docs.cypress.io/guides/getting-started/installing-cypress.html)'
- en: '[https://docs.cypress.io/guides/core-concepts/introduction-to-cypress.html](https://docs.cypress.io/guides/core-concepts/introduction-to-cypress.html)'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.cypress.io/guides/core-concepts/introduction-to-cypress.html](https://docs.cypress.io/guides/core-concepts/introduction-to-cypress.html)'
- en: Summary
  id: totrans-530
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Automated testing is essential for scaling up to large numbers of microservices.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试对于扩展到大量微服务至关重要。
- en: You learned how unit testing, integration testing, and end-to-end testing fit
    together in the testing pyramid.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了单元测试、集成测试和端到端测试如何在测试金字塔中相互配合。
- en: We created and executed unit tests and integration tests using Jest.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 Jest 创建并执行了单元测试和集成测试。
- en: We created end-to-end tests using Docker Compose and Cypress.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 Docker Compose 和 Cypress 创建了端到端测试。
- en: You learned how to use database fixtures to populate your database with test
    data for integration and end-to-end testing.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了如何使用数据库固定值来为集成和端到端测试填充测试数据。
- en: You learned how to fit automated testing into your continuous delivery (CD)
    pipeline.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了如何将自动化测试整合到你的持续交付（CD）管道中。
