- en: 3 Driving the robot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 驱动机器人
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Controlling DC motors to make robots move forward and backward
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制直流电机使机器人前进和后退
- en: Implementing software-configured motor power adjustments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现软件配置的电机功率调整
- en: Turning the robot left and right
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制机器人左右转动
- en: Spinning the robot in place
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原地旋转机器人
- en: Refactoring the code using the `functools` library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`functools`库重构代码
- en: This chapter will teach you how to move the robot in different directions using
    the Python code to control the power given to DC motors. The left and right wheels
    of the robot each have a dedicated motor attached to them. Controlling the motors
    makes a whole array of movements possible. Python functions will be generated
    for each of the main movement operations to create an easy-to-use and readable
    set of methods to control the robot’s movements. Once all these functions have
    been implemented, a number of refactoring techniques will be applied to simplify
    and consolidate the code base.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会你如何使用Python代码控制直流电机的功率来使机器人向不同方向移动。机器人的左右轮各有一个专用的电机连接。控制电机可以使一系列动作成为可能。将为每个主要动作操作生成Python函数，以创建一组易于使用和阅读的方法来控制机器人的动作。一旦所有这些函数都已实现，将应用一系列重构技术来简化并巩固代码库。
- en: 3.1 What’s a robot chassis kit?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 什么是机器人底盘套件？
- en: '*Robot chassis kits* are a great way to build mobile robots. In the previous
    chapter, we saw how the Raspberry Pi provides computing power for the robot and
    how the CRICKIT HAT add-on controls connected motors. The chassis kit provides
    the body, motors, and wheels to get your robot moving around. There are many different
    robot chassis kits that can be used with the Raspberry Pi. The one recommended
    in this book is an inexpensive and flexible option that lets you build many different
    robot configurations. The kit comes with the following main parts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器人底盘套件*是构建移动机器人的好方法。在前一章中，我们看到了树莓派如何为机器人提供计算能力，以及CRICKIT HAT附加组件如何控制连接的电机。底盘套件提供了身体、电机和轮子，使你的机器人能够移动。有许多不同的机器人底盘套件可以与树莓派一起使用。本书推荐的一个选择是价格低廉且灵活，让你能够构建许多不同的机器人配置。套件包括以下主要部件：'
- en: Two DC motors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个直流电机
- en: Two wheels
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个轮子
- en: One caster ball that acts as a third wheel
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用作第三轮的万向球
- en: Three aluminum frames and mounting hardware to create a three-layer robot
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三个铝制框架和安装硬件构建三层机器人
- en: Figure 3.1 shows the main parts that come with the kit. Having three layers
    as opposed to a two-layer arrangement provides the expanded space and flexibility
    to install the Raspberry Pi and power hardware on different layers. The DC motors
    are kept on the bottom layer. These layers in the robot chassis can be seen in
    the images found in the robot assembly guide that is part of appendix C. Check
    the hardware-purchasing guide in appendix A for more details on the recommended
    chassis kit.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1展示了套件中的主要部件。与双层布局相比，三层提供了更大的空间和灵活性，可以在不同层上安装树莓派和电源硬件。直流电机保持在底层。机器底盘中的这些层可以在附录C中找到的机器人组装指南中的图像中看到。有关推荐的底盘套件的更多详细信息，请参阅附录A中的硬件购买指南。
- en: '![](../Images/CH03_F01_Alsabbagh.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F01_Alsabbagh.png)'
- en: 'Figure 3.1 Chassis kit: the kit comes with three aluminum frames to support
    three-layer robots.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 底盘套件：套件包含三个铝制框架，用于支撑三层机器人。
- en: 3.2 Hardware stack
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 硬件堆栈
- en: Figure 3.2 shows the hardware stack discussed, and the specific components used
    in this chapter are highlighted. As the book progresses, more hardware components
    will be incorporated into the robot projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2展示了所讨论的硬件堆栈，以及本章中使用的具体组件被突出显示。随着本书的进展，更多的硬件组件将被纳入机器人项目中。
- en: '![](../Images/CH03_F02_Alsabbagh.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F02_Alsabbagh.png)'
- en: 'Figure 3.2 Hardware stack: the robot will move around using two DC motors.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 硬件堆栈：机器人将使用两个直流电机移动。
- en: As mentioned in the previous section, two DC motors will be used in this chapter.
    One will be attached to the left wheel and the other to the right wheel. The center
    wheel will use a caster ball that can turn smoothly in any direction and has no
    motor attached. The DC motors will be connected to the CRICKIT HAT, which will
    power and control them. Ethernet can be used to connect to the robot, but a Wi-Fi
    connection provides the ability for the robot to move around untethered.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，本章将使用两个直流电机。一个将连接到左轮，另一个将连接到右轮。中心轮将使用一个可以平滑转向任何方向的万向球，且没有连接电机。直流电机将连接到CRICKIT
    HAT，它将为它们提供动力和控制。可以使用以太网连接到机器人，但Wi-Fi连接提供了机器人无束缚移动的能力。
- en: For details on assembling and configuring the robot hardware, check the robot
    assembly guide in appendix C. It shows how to assemble the robot used in this
    and other chapters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有关组装和配置机器人硬件的详细信息，请参阅附录C中的机器人组装指南。它展示了如何组装本章和其他章节中使用的机器人。
- en: 3.3 Software stack
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 软件栈
- en: Details of the specific software used in this chapter are illustrated in figure
    3.3 and described in the text that follows. The application layer makes use of
    the libraries and the Python interpreter below it. The Python interpreter runs
    on Linux, which in turn runs on the hardware.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所使用的特定软件的详细信息如图3.3所示，并在随后的文本中进行描述。应用层使用了底层的库和Python解释器。Python解释器在Linux上运行，而Linux又运行在硬件上。
- en: '![](../Images/CH03_F03_Alsabbagh.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_Alsabbagh.png)'
- en: 'Figure 3.3 Software stack: this chapter covers how to control DC motors with
    Python.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 软件栈：本章将介绍如何使用Python控制直流电机。
- en: Building on the knowledge from chapter 2, we will continue using the Python
    Adafruit CRICKIT library to interact with DC motors. In this chapter, we will
    control multiple DC motors using the same script. We will also learn how to control
    the motor direction and speed. On the Linux level, we will use environment variables
    such as `ROBO_DC_ADJUST_R` to pass configuration values to our Python scripts
    to set motor power adjustments. In this way, we don’t have to hard-code configuration
    values directly into our Python code. The Python `time` module will be used to
    control the duration of the motor running during different movement operations.
    The `time` module is part of the Python standard library and provides a standard
    mechanism to pause script execution through the `sleep` function. Finally, we
    will bring all these pieces together to create the `motor.py` script and library
    at the end of the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在第二章的知识基础上，我们将继续使用Python Adafruit CRICKIT库与直流电机交互。在本章中，我们将使用相同的脚本控制多个直流电机。我们还将学习如何控制电机的方向和速度。在Linux级别，我们将使用环境变量，如`ROBO_DC_ADJUST_R`，将配置值传递给我们的Python脚本以设置电机功率调整。这样，我们就不必直接将配置值硬编码到我们的Python代码中。Python的`time`模块将用于控制不同运动操作中电机运行的时间。`time`模块是Python标准库的一部分，它提供了一个通过`sleep`函数暂停脚本执行的标准机制。最后，我们将把这些部分组合起来，在章节末尾创建`motor.py`脚本和库。
- en: 3.4 Writing a move forward function
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 编写向前移动函数
- en: In this section, we will learn how to create a Python function that will make
    the robot move forward when called. We do this by turning on both the left and
    right DC motors at the same time, letting them run for a specific time, and then
    stopping them. This will make the robot move forward and come to a stop.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何创建一个Python函数，当调用该函数时，机器人将向前移动。我们通过同时打开左轮和右轮的直流电机，让它们运行特定的时间，然后停止它们来实现这一点。这将使机器人向前移动并停止。
- en: An important safety aspect when dealing with robots is having a mechanism to
    perform an emergency stop. The CRICKIT HAT has a hardware switch to turn the board
    on and off. We can use the switch as our emergency stop, as it will cut power
    to all connected motors. It has the added benefit that we can turn the board right
    back on and start our applications again without having to reboot the Raspberry
    Pi.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理机器人时，一个重要的安全方面是拥有一个执行紧急停止的机制。CRICKIT HAT有一个硬件开关可以打开和关闭板子。我们可以使用这个开关作为我们的紧急停止，因为它将切断所有连接电机的电源。它还有一个额外的优点，即我们可以立即重新打开板子并再次启动我们的应用程序，而无需重新启动Raspberry
    Pi。
- en: 'First, we’ll import the CRICKIT library to control the motors and the `time`
    library to control how long we move forward:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将导入CRICKIT库来控制电机，以及`time`库来控制移动前进的时间：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we’ll define `MOTOR_R` and `MOTOR_L`, which will map to the right and
    left motors. When wiring the robot, make sure to connect the right DC motor to
    motor connection 1 and the left DC motor to motor connection 2\. All the code
    in the book will follow this convention:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义 `MOTOR_R` 和 `MOTOR_L`，它们将映射到右侧和左侧电机。在布线机器人时，请确保将右侧直流电机连接到电机连接1，将左侧直流电机连接到电机连接2。书中所有的代码都将遵循此约定：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we define a helper function called `set_throttle`, which accepts two
    arguments and sets the throttle for the specified motor to the specified value:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个名为 `set_throttle` 的辅助函数，它接受两个参数，并将指定电机的节流设置到指定的值：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can now define the `forward` function itself, which will move the robot
    forward. When called, it first sets both motors to run at the 90% speed in the
    forward direction by calling `set_throttle` on both motors. Then, by calling `sleep`,
    it waits for 0.2 seconds. Finally, calling `set_throttle` again on both motors
    ends the movement. In this way, calling the `forward` function will move the robot
    forward for 0.2 seconds and then cause it to come to a full stop:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义 `forward` 函数本身，该函数将使机器人向前移动。当被调用时，它首先通过在两个电机上调用 `set_throttle` 将两个电机设置为以90%的速度向前运行。然后，通过调用
    `sleep`，它等待0.2秒。最后，再次在两个电机上调用 `set_throttle` 结束移动。这样，调用 `forward` 函数将使机器人向前移动0.2秒，然后使其完全停止：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The full script can be saved as `forward.py` on the Pi and then executed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `forward.py` 在Pi上，然后执行。
- en: 'Listing 3.1 `forward.py`: Making the motors move forward with a function'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 `forward.py`：使用函数使电机向前移动
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When running the script, both motors should move in the forward direction, making
    the whole robot move forward. If one of the wheels is moving in the backward direction
    instead of forward, just switch the connecting wires for that DC motor. The DC
    motor wires can be connected either way, and flipping the connected wires will
    also flip the direction of a positive throttle. The book follows the convention
    that a positive throttle results in a forward movement and a negative throttle
    results in a backward movement. If the wheel direction has not yet been confirmed,
    be mindful not to put your robot on the edge of a table, as it might drive in
    the wrong direction and fall off the table.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行脚本时，两个电机应向前移动，使整个机器人向前移动。如果其中一个轮子向后移动而不是向前移动，只需切换该直流电机的连接线。直流电机线可以任意连接，翻转连接线也会翻转正节流的方向。本书遵循的约定是正节流导致向前移动，负节流导致向后移动。如果尚未确认车轮方向，请注意不要将您的机器人放在桌子的边缘，因为它可能会向错误的方向行驶并从桌子上掉下来。
- en: Warning The motor speed was set at 90% strength instead of a full 100% strength.
    This is done for power safety reasons. Using certain USB power banks to power
    the CRICKIT HAT and rapidly switching DC motor directions will cause power disruptions
    and disconnection to the I2C connection between the Raspberry Pi and CRICKIT HAT.
    The 90% strength provides a high level of throttle and a good level of safety
    to protect against these problems. You could use even higher values, but the mentioned
    values have been tested and are reliable in practice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：电机速度被设置为90%的强度而不是100%的全强度。这是出于电力安全原因。使用某些USB移动电源为CRICKIT HAT供电并快速切换直流电机方向会导致电力中断，并切断Raspberry
    Pi和CRICKIT HAT之间的I2C连接。90%的强度提供了高水平的节流和良好的安全水平，以防止这些问题。您可以使用更高的值，但提到的值已经过测试，并在实践中是可靠的。
- en: 3.5 Using environment variables for configuration
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 使用环境变量进行配置
- en: Frequently, some configuration values, specific to a particular machine or hardware
    device, will need to be set and read by a Python application. Some examples are
    security credentials or configurable settings that should not have values hard-coded
    directly into your Python scripts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，某些特定于特定机器或硬件设备的配置值需要由Python应用程序设置和读取。一些例子是安全凭证或不应直接硬编码到Python脚本中的可配置设置。
- en: In our case, our robot needs a power configuration setting for each of the two
    DC motors. In the physical world setting, the same throttle on two motors often
    won’t make them move at exactly the same speed. This is due to slight variations
    in the physical motors. Because one motor will often spin a little faster than
    the other, it will make the robot veer a little to the left or right instead of
    moving in a perfectly straight line. The solution is to tweak the throttle settings
    between the two motors to get them spinning at similar speeds. Then the robot
    will drive more on a straight path when moving forward. We will create two configuration
    values to adjust the power of each motor. This is a pragmatic and simple solution
    that will meet the needs of the projects in this book. A more advanced solution
    would require us to add hardware sensors and logic in our software to constantly
    adjust the power on the two motors by taking sensor data into account to keep
    the robot driving straight.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们的机器人需要为两个直流电机中的每一个设置一个电源配置。在物理世界设置中，两个电机上的相同油门通常不会使它们以完全相同的速度移动。这是由于物理电机之间微小的差异造成的。因为一个电机通常会旋转得比另一个电机快一点，这会使机器人稍微向左或向右偏移，而不是以完美的直线移动。解决方案是调整两个电机之间的油门设置，使它们以相似的速度旋转。这样，当机器人向前移动时，它将更多地沿着直线行驶。我们将创建两个配置值来调整每个电机的功率。这是一个实用且简单的解决方案，将满足本书中项目的需求。一个更高级的解决方案将需要我们在软件中添加硬件传感器和逻辑，通过考虑传感器数据来不断调整两个电机的功率，以保持机器人直线行驶。
- en: 'To solve this problem, we implement a common technique using environment variables
    in Linux to set our configuration values and then read and use these values in
    Python. The solution should meet the following requirements:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们实现了一个在Linux中使用环境变量设置我们的配置值，然后在Python中读取和使用这些值的常用技术。解决方案应满足以下要求：
- en: Configuration values should be read in Python from a specific set of named environment
    variables.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置值应在Python中从一组特定的命名环境变量中读取。
- en: Configuration values should be optional, and if environment variables are not
    set, they should fall back to specific default values.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置值应该是可选的，如果环境变量未设置，它们应回退到特定的默认值。
- en: All environment variables are string values. Type casting should be performed
    to set them to an appropriate data type, such as floating-point values.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有环境变量都是字符串值。应该执行类型转换，将它们设置为适当的数据类型，例如浮点值。
- en: Environment variables can be set and viewed in a terminal session. This can
    be a local terminal session or a remote session over SSH. The default terminal
    or shell software on the Raspberry Pi OS is called Bash. For more details and
    help with terminal use and software, see the Raspberry Pi Documentation ([https://raspberrypi.com/documentation/usage/terminal](https://raspberrypi.com/documentation/usage/terminal)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可以在终端会话中设置和查看。这可以是一个本地终端会话或通过SSH的远程会话。Raspberry Pi OS上的默认终端或shell软件称为Bash。有关终端使用和软件的更多详细信息，请参阅Raspberry
    Pi文档([https://raspberrypi.com/documentation/usage/terminal](https://raspberrypi.com/documentation/usage/terminal))。
- en: First, we will define the naming of the environment variables and how they will
    be set. It is often a good idea to let all your environment variables start with
    the same prefix. This way, when listing all the existing environment variables,
    it will be easy to find the ones that are ours. We will use the prefix `ROBO_`
    for all our variables. Run the command `$` `env`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义环境变量的命名以及它们如何被设置。通常，让所有环境变量以相同的前缀开始是一个好主意。这样，当列出所有现有环境变量时，将很容易找到我们自己的变量。我们将使用前缀
    `ROBO_` 为所有变量命名。运行命令 `$` `env`。
- en: 'Execute this command to set a new environment variable that will adjust the
    amount of power given to the right DC motor. The value of `0.8` will make the
    throttle lower for the right DC motor and 80% of the normal throttle to slow down
    the right motor. This could be an adjustment made when you find your right motor
    moving faster than the left one and want to slow it down so that the two motors
    have similar speeds:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令以设置一个新的环境变量，该变量将调整分配给右侧直流电机的功率。`0.8` 的值将使右侧直流电机的油门降低，并达到正常油门的80%，以减慢右侧电机的速度。这可能是在你发现你的右侧电机比左侧电机移动得更快时进行的调整，你想减慢它的速度，以便两个电机具有相似的速度：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When executing the `env` command again, you should see our new variable in
    the output. We can take the output of this command and use the Bash `|` feature
    to pipe the output into another command that will filter the output. The `grep`
    command filters the output and only shows lines that have the `ROBO_` text in
    them. We can run the following command to filter the output of the `env` command
    and only list our variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行`env`命令时，你应该在输出中看到我们新的变量。我们可以将此命令的输出用作Bash `|`功能的输入，将输出管道传输到另一个命令，该命令将过滤输出。`grep`命令过滤输出，只显示包含`ROBO_`文本的行。我们可以运行以下命令来过滤`env`命令的输出，并仅列出我们的变量：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These values are only available in our current Bash session. If you open a new
    session or reboot the machine, these values will be lost. To make the environment
    variable permanent, it should be placed in your .bashrc file. Edit this file and
    add the `export` line. Now open a new Bash session and confirm the value has been
    set.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值仅在当前的Bash会话中可用。如果你打开一个新的会话或重新启动机器，这些值将会丢失。要使环境变量永久，它应该放在你的`.bashrc`文件中。编辑此文件并添加`export`行。现在打开一个新的Bash会话并确认值已被设置。
- en: 'We can now dive into a Python REPL (read–evaluate–print loop) and start reading
    the values from these environment variables. We will import the `os` module and
    then start accessing the values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以深入到Python REPL（读取-评估-打印循环）并开始从这些环境变量中读取值。我们将导入`os`模块，然后开始访问这些值：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we access a value that has not been set, a `KeyError` exception will be
    raised:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问一个未设置的值时，将引发`KeyError`异常：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The way to deal with optional values is to use the `get` method that provides
    default values when the environment variable does not exist:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可选值的方法是使用`get`方法，当环境变量不存在时提供默认值：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now typecast our variable into a `float`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的变量类型转换为`float`：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we have everything in place, we can upgrade our previous implementation
    of the `forward` function with these new changes. It is important to note that
    we don’t have to set both environment variables, as each of them is optional.
    We will save our two configuration values into variables:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经一切就绪，我们可以使用这些新更改升级我们之前实现的`forward`函数。需要注意的是，我们不必设置两个环境变量，因为它们都是可选的。我们将把我们的两个配置值保存到变量中：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will keep our power adjustment values in a dictionary called `ADJUST` so
    that they can be accessed more easily:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的功率调整值保存在一个名为`ADJUST`的字典中，以便更容易地访问：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In a similar fashion, we will access our DC motor objects through a dictionary
    called `MOTOR`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们将通过一个名为`MOTOR`的字典来访问我们的直流电机对象：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The implementation of the `set_throttle` function can now be updated to receive
    the name of the motor as a string and apply a throttle value that gets adjusted
    based on the values in `ADJUST`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_throttle`函数的实现现在可以更新为接收电机名称作为字符串，并应用基于`ADJUST`中值的调整后的节流值：'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, our `forward` function can be updated to refer to motors using the
    values `''R''` and `''L''`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以更新我们的`forward`函数，使其使用值`'R'`和`'L'`来引用电机：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The full script can be saved as `envforward.py` on the Pi and then executed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为`envforward.py`在Pi上，然后执行。
- en: 'Listing 3.2 `envforward.py`: Reading configuration values from environment
    variables'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 `envforward.py`：从环境变量中读取配置值
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the script is run, the robot will move forward based on the specific power
    adjustments defined for each motor in the environment configuration values. This
    will enable power adjustments on each wheel and allow it to drive in more of a
    straight line.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本运行时，机器人将根据环境配置值中为每个电机定义的特定功率调整来前进。这将允许对每个轮子的功率进行调整，并使其能够以更直的线路行驶。
- en: 'Going deeper: The physics of robotic motion'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：机器人运动物理学
- en: As your robot projects tackle more complex tasks in challenging environments,
    the topic of the physics of how robots move becomes increasingly important. For
    example, if your robot needs to drive on a variety of surfaces that might be slippery
    at times, then a traction control system can be incorporated into the robot to
    handle these different surfaces.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的机器人项目在具有挑战性的环境中处理更复杂的任务，机器人运动物理学的主题变得越来越重要。例如，如果你的机器人需要在可能有时会滑动的各种表面上行驶，那么可以将牵引控制系统集成到机器人中，以处理这些不同的表面。
- en: Another scenario might be driving the robot over a surface that is not level
    but has a slope. The slope might be downward or upward. If the slope is upward,
    we may want to provide more power to the DC motors to achieve the same speed we
    would have on a level surface. If, on the other hand, the robot is driving downward,
    then we would want to reduce the power provided to the DC motors so that we don’t
    go too fast. This type of control is a standard feature that is part of the cruise
    control systems found in many cars. The same systems can be applied to our robots.
    We would need to add sensors to measure our speed and adjust power accordingly.
    The following figure provides an illustration of the additional power and force
    that must be given to the motors when robots drive uphill to counter the force
    of gravity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种场景可能是让机器人驱动一个不平坦但有斜坡的表面。斜坡可能是向上的或向下的。如果斜坡是向上的，我们可能需要给直流电机提供更多的功率，以实现我们在水平表面上相同的速度。另一方面，如果机器人正在向下行驶，那么我们希望减少提供给直流电机的功率，以免速度过快。这种控制是一种标准功能，是许多汽车巡航控制系统中的一部分。同样的系统也可以应用于我们的机器人。我们需要添加传感器来测量我们的速度并相应地调整功率。以下图提供了当机器人在上坡时必须提供给电机的额外功率和力的说明。
- en: '![](../Images/CH03_F04_Alsabbagh.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F04_Alsabbagh.png)'
- en: 'Driving on a slope: when driving up a slope, more power needs to be given to
    the motors.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在斜坡上驾驶：当向上坡行驶时，需要给电机提供更多的功率。
- en: The guide on electric traction and steering for robotic vehicles provided by
    Allied Motion ([http://mng.bz/ZRoZ](http://mng.bz/ZRoZ)) is an excellent reference
    on the topics of both steering and traction control in robotics. Topics such as
    the characteristics of the wheels and operating surfaces are covered. It also
    includes a comparison of the different ways in which traction solutions can be
    created with their associated tradeoffs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Allied Motion提供的关于机器人车辆电动牵引和转向的指南([http://mng.bz/ZRoZ](http://mng.bz/ZRoZ))是关于机器人转向和牵引控制主题的优秀参考资料。涵盖了诸如车轮和操作表面的特性等内容。它还包括了关于如何创建牵引解决方案及其相关权衡的比较。
- en: 3.6 Controlling the speed and duration of movements
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 控制运动的速度和持续时间
- en: In the next upgrade, we will add the ability to control the speed and duration
    at which we move the robot forward. Currently, the duration is hard-coded in the
    `forward` function and is set at 0.2 seconds. We will add an optional argument
    to the function so that it will still default to 0.2 seconds, but the code calling
    the function can provide other values. The speed at which the robot moves forward
    can be controlled by changing the level of throttle provided to the motors. We
    will define three speed settings—low, medium, and high—and then one of these levels
    can be specified when calling movement functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个升级中，我们将添加控制机器人前进速度和持续时间的功能。目前，持续时间在`forward`函数中是硬编码的，设置为0.2秒。我们将向函数添加一个可选参数，这样它仍然默认为0.2秒，但调用函数的代码可以提供其他值。机器人前进的速度可以通过改变提供给电机的油门级别来控制。我们将定义三个速度设置——低、中、高——然后在调用运动函数时指定这些级别之一。
- en: 'We will add the optional `duration` argument to control how long we run the
    motors:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加可选的`duration`参数来控制电机运行的时间：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `THROTTLE_SPEED` dictionary will map the three speed levels to their associated
    throttle levels. The speed level 0 is used to stop the motors:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`THROTTLE_SPEED`字典将把三个速度级别映射到它们相关的油门级别。速度级别0用于停止电机：'
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now update our `forward` function to set the desired speed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新我们的`forward`函数来设置期望的速度：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `set_throttle` function will now use the new `THROTTLE_SPEED` dictionary
    too:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_throttle`函数现在也将使用新的`THROTTLE_SPEED`字典：'
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The full script can be saved as `speedforward.py` on the Pi and then executed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`speedforward.py`在Pi上，然后执行。
- en: 'Listing 3.3 `speedforward.py`: Controlling the speed of motors moving forward'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 `speedforward.py`：控制向前移动的电机速度
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The script makes some function calls to `forward` to demonstrate the new functionality.
    It will move the robot for a custom duration of half a second. Then it will move
    the robot forward at each of the three speed levels. The robot will stop moving
    once the last call to the `forward` function is made because the function ends
    by stopping both motors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本对`forward`函数进行了一些函数调用，以展示新的功能。它将使机器人以自定义的半秒持续时间移动。然后它将以三个速度级别中的每一个将机器人向前移动。一旦对`forward`函数的最后一个调用完成，机器人将停止移动，因为函数通过停止两个电机来结束。
- en: 3.7 Moving backward
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 向后移动
- en: Now that we have implemented a function for forward movement, we will move on
    to implement a function to make the robot move backward. These are some of the
    main movement functions we need to implement to achieve a full range of motion.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一个向前移动的函数，接下来我们将继续实现使机器人向后移动的函数。这些是我们需要实现的主要移动函数，以实现完整的运动范围。
- en: 'First, we will enhance the `set_throttle` function with a `factor` argument.
    This argument will be used to control whether the throttle will have a positive
    value to move the motor forward or a negative value to move the motor backward:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过添加一个`factor`参数来增强`set_throttle`函数。这个参数将用于控制油门是具有正值以驱动电机向前移动还是具有负值以驱动电机向后移动：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we need to implement the new `backward` function. It is very similar
    to the `forward` function, with the main difference being the value of the `factor`
    parameter:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现新的`backward`函数。它与`forward`函数非常相似，主要区别在于`factor`参数的值：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The full script can be saved as `backward.py` on the Pi and then executed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`backward.py`在Pi上，然后执行。
- en: 'Listing 3.4 `backward.py`: Making the motors move in a backward direction'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 `backward.py`：使电机向后移动
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The script demonstrates the use of the new function by moving the robot forward
    and backward three times.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通过使机器人向前和向后移动三次来演示新函数的使用。
- en: 3.8 Turning right
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 向右转
- en: Turning right requires providing different throttle levels to the left and right
    motor. To better understand the forces at play, we can have a look at the wheel
    layout in figure 3.4\. The left and right wheels have the motors attached to them
    and can have varying levels of throttle applied. The center wheel is a caster
    ball that can move freely in any direction. The figure shows that to turn right,
    we should apply a stronger throttle to the left wheel motor. This will make the
    left wheel turn faster and thus turn the robot right.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 向右转需要向左右电机提供不同的油门级别。为了更好地理解作用中的力，我们可以查看图3.4中的轮子布局。左右轮子上有连接的电机，可以施加不同级别的油门。中心轮子是一个万向球，可以在任何方向上自由移动。该图显示，为了向右转，我们应该向左轮电机施加更强的油门。这将使左轮转得更快，从而将机器人向右转。
- en: '![](../Images/CH03_F05_Alsabbagh.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F05_Alsabbagh.png)'
- en: 'Figure 3.4 Wheel layout: a stronger throttle on the left wheel turns the robot
    right.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 轮子布局：左轮更强的油门会使机器人向右转。
- en: Now we have everything we need to implement the function to move the robot right.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了实现使机器人向右移动的函数所需的一切。
- en: 'The new `right` function has some similarities to previous functions. Essentially,
    we are moving in a forward direction but turning right. This is done by giving
    twice as much throttle to the left wheel:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`right`函数与之前的一些函数有相似之处。本质上，我们是在向前移动的同时向右转。这是通过给左轮提供两倍的油门来实现的：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The full script can be saved as `right.py` on the Pi and then executed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`right.py`在Pi上，然后执行。
- en: 'Listing 3.5 `right.py`: Turning the robot right'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 `right.py`：使机器人向右转
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The script calls the `right` function to make the robot turn right for 1 second.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本调用`right`函数使机器人向右转1秒。
- en: 3.9 Moving left and spinning in either direction
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.9 向左移动和任意方向旋转
- en: 'We can now implement a complete set of functions to perform all the movements
    needed for our robot. Here are the requirements we would like to be fulfilled
    by our set of functions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以实施一套完整的函数，以执行机器人所需的所有移动。以下是我们的函数集需要满足的要求：
- en: Creating a set of Python functions to make the robot move forward, backward,
    right, and left, as well as spin right and left.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一组Python函数，使机器人能够向前、向后、向右和向左移动，以及向右和向左旋转。
- en: Each of these functions should allow us to set the duration and speed of the
    movement operation.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些函数中的每一个都应该允许我们设置移动操作的时间和速度。
- en: We have written much of what we need to complete our set of functions. We can
    now implement the remaining three movement functions. Figure 3.5 shows the direction
    of throttle that needs to be applied on each motor to make the robot spin to the
    right.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了完成我们的函数集所需的大部分内容。现在我们可以实现剩余的三个移动函数。图3.5显示了为了使机器人向右旋转，需要在每个电机上施加的油门方向。
- en: '![](../Images/CH03_F06_Alsabbagh.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F06_Alsabbagh.png)'
- en: 'Figure 3.5 Spinning: throttle needs to be applied on the left and right motors
    to make the robot spin.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 旋转：需要在左右电机上施加油门，使机器人旋转。
- en: 'The new `left` function is essentially just like the `right` function, except
    with the stronger throttle being put on the right wheel so that the robot will
    turn left:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `left` 函数基本上与 `right` 函数相同，只是更强的油门被放在右轮上，这样机器人就会向左转：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `spin_right` function will make the robot spin in place by having the wheels
    turn at full speed in opposite directions. The right wheel will spin backward,
    and the left wheel will spin forward, making the robot spin clockwise:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`spin_right` 函数将通过让轮子以全速相反方向转动，使机器人原地旋转。右轮将向后旋转，左轮将向前旋转，使机器人顺时针旋转：'
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `spin_left` function will spin the robot, but this time in an anticlockwise
    direction:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`spin_left` 函数将使机器人旋转，但这次是逆时针方向：'
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The full script can be saved as `fullmotor.py` on the Pi and then executed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为 Pi 上的 `fullmotor.py` 并执行。
- en: 'Listing 3.6 `fullmotor.py`: Creating functions to perform all supported robot
    movements'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3.6 `fullmotor.py`: 创建函数以执行所有支持的机器人运动'
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The script now has all the movement functions implemented. It can even be imported
    as a Python module and used by other Python scripts. When the script is run directly,
    it will make the robot turn left and then spin right and left. If, however, the
    module is imported to be used as a library, then it won’t perform those demonstration
    movements. This is achieved by checking the value of the `__name__` variable to
    detect whether the Python code is being run directly or imported as a library.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本现在已实现了所有运动函数。甚至可以将其作为 Python 模块导入并用于其他 Python 脚本。当脚本直接运行时，它将使机器人向左转然后向右和左旋转。然而，如果模块被导入作为库使用，则不会执行这些演示运动。这是通过检查
    `__name__` 变量的值来实现的，以检测 Python 代码是直接运行还是作为库导入。
- en: 3.10 Refactoring by finding common logic
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.10 通过查找共同逻辑进行重构
- en: Code *refactoring* is the process of changing or simplifying how your application
    is implemented internally without changing any of its external behavior. In our
    case, we want to simplify the implementation of the `motor` library without changing
    any of the names of the functions or the arguments they receive. We will do this
    by making a simpler, more readable, and more maintainable version of this library.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构是改变或简化应用程序内部实现的过程，而不改变其外部行为。在我们的情况下，我们想要简化 `motor` 库的实现，而不改变任何函数的名称或它们接收的参数。我们将通过创建一个更简单、更易读、更易于维护的库版本来实现这一点。
- en: One way to refactor code is to look for logic that is similar or shared between
    different functions and then centralize that logic in one function to avoid duplication.
    We can see that our movement functions all share a very similar structure of setting
    the throttle on the left and right motors, sleeping for some period, and then
    stopping the throttle on both motors. Let’s create a centralized function to implement
    this functionality and then have the other functions call the main centralized
    function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构的一种方法是在不同的函数之间寻找相似或共享的逻辑，然后将这种逻辑集中在一个函数中，以避免重复。我们可以看到我们的运动函数都共享一个非常相似的结构，即设置左右电机的油门，暂停一段时间，然后停止两个电机的油门。让我们创建一个集中化的函数来实现这个功能，然后让其他函数调用这个主要集中化的函数。
- en: 'The centralized `movement` function must take the `duration` and `speed` arguments
    like the other functions, but it also receives the factor values for both the
    left and right motors, as these vary within different functions. With this implementation,
    it should meet the needs of all the functions we have implemented:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 集中化的 `movement` 函数必须像其他函数一样接受 `duration` 和 `speed` 参数，但它还接收左右电机的系数值，因为这些值在不同的函数中会有所不同。使用这种实现，它应该满足我们已实现的所有函数的需求：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now call the `movement` function from a new version of the `forward`
    function. The implementation is very simple and essentially passes all its arguments
    as is. We can implement a similar set of changes to migrate all the old functions
    to use the new approach:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从新的 `forward` 函数中调用 `movement` 函数。实现非常简单，基本上是原样传递所有参数。我们可以实施一系列类似的更改，将所有旧函数迁移到使用新方法：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The full script can be saved as `commonmotor.py` on the Pi and then imported.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为 Pi 上的 `commonmotor.py` 并导入。
- en: 'Listing 3.7 `commonmotor.py`: Consolidating common logic into a common function'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3.7 `commonmotor.py`: 将共同逻辑合并到公共函数中'
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The implementation for each function is much simpler now. This will make the
    code much more maintainable, as all the real work is being done by the `set_throttle`
    and `movement` functions. It is also more readable, as each call is essentially
    just changing some parameters on the `movement` function call.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数的实现现在都变得更加简单。这将使代码的可维护性大大提高，因为所有实际的工作都是由`set_throttle`和`movement`函数完成的。它也更容易阅读，因为每个调用本质上只是更改`movement`函数调用的一些参数。
- en: 'Going deeper: Code refactoring'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：代码重构
- en: The process of code refactoring is an important part of software development.
    The Agile Alliance ([https://www.agilealliance.org/glossary/refactoring](https://www.agilealliance.org/glossary/refactoring))
    has a nice definition of what refactoring is and some of its benefits. When we
    first implement a piece of software, our goal is often just to get the thing working.
    Once we have it working, the code base will naturally grow as we add more features
    to the software. Refactoring is when we make the time to step back and not add
    any new functionality but think of ways of cleaning up or simplifying our code
    base.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构的过程是软件开发的重要部分。敏捷联盟（[https://www.agilealliance.org/glossary/refactoring](https://www.agilealliance.org/glossary/refactoring)）对重构是什么以及其一些好处有一个很好的定义。当我们首次实现一个软件组件时，我们的目标通常只是让事情工作。一旦它开始工作，代码库将随着我们向软件添加更多功能而自然增长。重构是我们花时间后退一步，不添加任何新功能，而是考虑清理或简化我们的代码库的方法。
- en: One of the benefits of a cleaner code base is improved maintainability. In the
    long run, having a cleaner code base will save us a lot of time as the code becomes
    more manageable. It can make the software more reliable by making it easier to
    find and fix bugs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁的代码库的一个好处是提高了可维护性。从长远来看，拥有一个更清洁的代码库将为我们节省大量时间，因为代码变得更加易于管理。它可以通过使查找和修复错误变得更加容易来使软件更加可靠。
- en: Another important concept related to refactoring is the design principle of
    Don’t Repeat Yourself (DRY). When we apply the DRY principle to our code, we want
    to avoid repetition in our code and logic. In section 3.10, we found logic that
    was duplicated and reduced that duplication by integrating it into one common
    function. Many good-quality frameworks and libraries apply a DRY philosophy to
    their software design and support creating projects that avoid repetition. The
    Python Django web framework is a good example of this, and its documentation ([https://docs.djangoproject.com](https://docs.djangoproject.com))
    has a page dedicated to its design philosophies. It mentions DRY and other design
    principles that create a cleaner code base.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与重构相关的一个重要概念是“不要重复自己”（DRY）的设计原则。当我们将DRY原则应用于我们的代码时，我们希望避免代码和逻辑中的重复。在第3.10节中，我们发现了重复的逻辑，并通过将其集成到一个公共函数中减少了这种重复。许多高质量的框架和库在他们的软件设计中应用了DRY哲学，以支持创建避免重复的项目。Python
    Django Web框架是这一点的良好例子，其文档（[https://docs.djangoproject.com](https://docs.djangoproject.com)）有一个专门介绍其设计哲学的页面。它提到了DRY和其他创建更清洁代码库的设计原则。
- en: 3.11 Refactoring by using functools
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.11 使用functools进行重构
- en: The `functools` module is part of the Python standard library, and it provides
    several different functionalities around callable objects and functions. Specifically,
    we will use `partial` to simplify the way we define functions, which is a perfect
    tool for scenarios where one function is essentially very similar to a call to
    another function, as is our case.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools`模块是Python标准库的一部分，它提供了关于可调用对象和函数的几个不同功能。具体来说，我们将使用`partial`来简化我们定义函数的方式，这对于一个函数本质上非常类似于对另一个函数的调用的场景来说是一个完美的工具，正如我们的情况。'
- en: The way `partial` works is that it takes some existing function as its first
    argument and a set of positional and keyword arguments. Then it returns a new
    function that would call the original function with those provided arguments.
    We can use it to simplify our function definitions. For more details on `partial`
    and example functions created using `partial`, check the Python documentation
    ([https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html))
    on the `functools` module.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`的工作方式是，它接受一些现有的函数作为其第一个参数，以及一组位置参数和关键字参数。然后它返回一个新的函数，该函数将使用提供的参数调用原始函数。我们可以用它来简化我们的函数定义。有关`partial`和使用`partial`创建的示例函数的更多详细信息，请参阅Python文档（[https://docs.python.org/3/library/functools.html](https://docs.python.org/3/library/functools.html)）中的`functools`模块。'
- en: 'We first import `partial` from the `functools` module:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从`functools`模块导入`partial`：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The new definition of the `forward` function is now essentially a direct call
    to `movement`, as it has default values that directly map to the defaults of the
    `forward` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`forward` 函数的新定义现在基本上是一个直接调用 `movement`，因为它具有直接映射到 `forward` 函数默认值的默认值：'
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the case of `backward`, the only change to the arguments of `movement` is
    to set both the left and right motors to turn in reverse:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `backward` 的情况下，对 `movement` 参数的唯一更改是将左右电机都设置为反向转动：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We continue the process for `right` and `left`, which use all the default values
    except for reducing the right and left motor speeds to make the robot turn:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续对 `right` 和 `left` 进行处理，它们使用所有默认值，除了将左右电机速度降低以使机器人转向：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `spin_right` and `spin_left` are created using a similar approach:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`spin_right` 和 `spin_left` 是通过类似的方法创建的：'
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We also add a `noop` function that will help us with performance testing in
    later chapters:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个 `noop` 函数，它将帮助我们在后面的章节中进行性能测试：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The full script can be saved as `motor.py` on the Pi and then imported.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `motor.py` 并在 Pi 上导入。
- en: 'Listing 3.8 `motor.py`: Simplifying the way functions are defined'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 3.8 `motor.py`: 简化函数定义的方式'
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can take the final version of our `motor` library for a spin by starting
    a Python REPL session in the same path. In the following session, the robot is
    moved forward and backward. Then it turns right for half a second and then left
    at the lowest speed. Next, it spins right for a second and spins left for 2 seconds.
    The last call will perform no operation but should execute successfully with no
    errors:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在相同路径中启动 Python REPL 会话来测试我们的 `motor` 库的最终版本。在以下会话中，机器人向前和向后移动。然后它向右转半秒，然后以最低速度向左转。接下来，它向右旋转一秒，向左旋转两秒。最后的调用将不会执行任何操作，但应该成功执行且无错误：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can import this library into all sorts of applications and call different
    movement functions to create many different projects. You could write a program
    that responds to user input to move the robot in different directions. Or you
    could program the robot to drive around an obstacle course with the correct forward
    and turn movements so as not to collide with any objects.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此库导入各种应用程序并调用不同的运动函数来创建许多不同的项目。您可以编写一个程序，该程序响应用户输入以使机器人向不同方向移动。或者，您可以编程机器人以正确的向前和转向动作在障碍赛中驾驶，以免撞到任何物体。
- en: 'Going deeper: The power of libraries'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：库的力量
- en: It is one thing to write a standalone program and a very different thing to
    write a library that provides functionality for many different pieces of software.
    The earlier scripts in this chapter were standalone scripts that could be executed
    to move the robot around. They were limited in the actions they could perform
    but were a great starting point. As we built up the functionality, we were able
    to package it all into a library. As we create the different projects in the book,
    we will often import the `motor` library from this chapter and use its functionality.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个独立的程序和编写一个为许多不同软件提供功能的库是两回事。本章早期脚本是一些独立的脚本，可以执行以移动机器人。它们在可执行的操作方面有限，但是一个很好的起点。随着我们构建功能，我们能够将它们全部打包成一个库。随着我们在书中创建不同的项目，我们通常会导入本章的
    `motor` 库并使用其功能。
- en: Well-designed libraries can provide a bundle of reusable functionality that
    we can easily incorporate into our own programs. We can combine them to create
    all sorts of powerful and complex applications by building on the great works
    of others or, as Isaac Newton said, “by standing on the shoulders of giants.”
    In this book, we will use libraries we create as well as a rich set of open source
    Python libraries that we can easily install and incorporate into our robot projects.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的库可以提供一系列可重用的功能，我们可以轻松地将它们集成到自己的程序中。我们可以通过构建在他人伟大作品的基础上，或者，正如艾萨克·牛顿所说，“站在巨人的肩膀上”，将它们结合起来创建各种强大而复杂的应用程序。在这本书中，我们将使用我们创建的库以及一套丰富的开源
    Python 库，这些库我们可以轻松安装并集成到我们的机器人项目中。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Robot chassis kits are a flexible and inexpensive way to build mobile robots.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人底盘套件是构建移动机器人的灵活且经济的方式。
- en: The right and left wheels each have their own dedicated DC motor.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右轮和左轮各自配备有专用的直流电机。
- en: Environment variables in Linux can be used to pass configuration values to Python
    scripts, which can then be used to configure motor power adjustments.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 中，可以使用环境变量将配置值传递给 Python 脚本，然后可以使用这些值来配置电机功率调整。
- en: Configuration values can be made optional by detecting missing environment variables
    and setting default values to fall back on.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过检测缺失的环境变量并设置默认值以备不时之需，使配置值成为可选的。
- en: By simultaneously turning on the left and right DC motor, forward motion of
    the robot can be achieved.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过同时开启左、右直流电机，可以实现机器人的前进运动。
- en: The robot’s speed can be controlled by changing the throttle level of DC motors.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人的速度可以通过改变直流电机的油门级别来控制。
- en: Backward motion can be achieved by reversing the throttle direction of both
    DC motors.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过反转两个直流电机的油门方向，可以实现后退运动。
- en: To turn the robot right, we need to apply a stronger throttle to the left wheel
    motor in comparison to the right wheel motor.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使机器人向右转，我们需要对左轮电机施加比右轮电机更强的油门。
- en: To make the robot spin, we need to apply a throttle on both motors in an opposite
    direction.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使机器人旋转，我们需要在相反方向上对两个电机施加油门。
- en: Refactoring code can simplify how your application is implemented without altering
    the way the functions in your library get called.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重构可以简化应用程序的实现方式，而不会改变库中函数的调用方式。
- en: Creating functions can become faster and simpler using `partial`.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `partial` 可以使创建函数变得更快、更简单。
