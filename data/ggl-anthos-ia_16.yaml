- en: 16 Breaking the monolith
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 打破单体
- en: Phil Taylor
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 菲尔·泰勒
- en: This chapter covers
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Modernizing legacy applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代化遗留应用程序
- en: Using Anthos for modernization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Anthos进行现代化
- en: Benefits of Anthos for microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anthos对微服务的优势
- en: Real-world examples
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现实世界的例子
- en: Antipatterns to avoid
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免的反模式
- en: Developing and supporting applications at scale in today’s markets is harder
    than ever before. With the rapid acceleration of business markets, applications
    rapidly evolve from early-stage prototypes to large-scale applications. With traditional
    deployment methodologies and processes, we can evolve our architectures and organically
    find and fix problems as the application scales. Because of the speed at which
    teams need to move today to keep up with business demands, our architecture and
    deployment processes need to be agile and scalable from day 1\. Thankfully, recent
    innovations in containers and container platforms like Anthos coupled with modern
    development patterns, such as microservice architectures, help us easily build
    and deploy applications, without compromising on efficiency, performance, or quality.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今市场上开发和支持大规模应用程序比以往任何时候都更难。随着商业市场的快速加速，应用程序迅速从早期原型发展到大规模应用程序。使用传统的部署方法和流程，我们可以随着应用程序的扩展而演进我们的架构，并有机地发现和修复问题。由于团队需要以多快的速度移动才能跟上业务需求，我们的架构和部署流程需要从第一天起就具有敏捷性和可扩展性。幸运的是，容器和容器平台（如Anthos）的最新创新，以及现代开发模式，如微服务架构，帮助我们轻松构建和部署应用程序，而不会牺牲效率、性能或质量。
- en: 16.1 Modernizing legacy applications
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 现代化遗留应用程序
- en: Although these new patterns and tools are great for greenfield development projects,
    it can be frustrating and sometimes overwhelming to support our legacy applications.
    Many teams face the challenge of keeping the airplane flying while rebuilding
    it midflight. It can be tempting to put all your eggs in one basket and focus
    only on rebuilding your application using modern, software architecture patterns
    and containers. We have seen several teams take this approach and fail. The teams
    who have the most success see the journey as a series of incremental improvements
    to the original design.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些新的模式和工具非常适合绿地开发项目，但支持我们的遗留应用程序可能会令人沮丧，有时甚至令人不知所措。许多团队面临着在飞行中重建飞机的挑战。可能会很有诱惑力将所有的鸡蛋都放在一个篮子里，只专注于使用现代、软件架构模式和容器来重建你的应用程序。我们已经看到几个团队采取了这种方法并失败了。最成功的团队将这个过程视为对原始设计的一系列渐进式改进。
- en: 'We recommend the following approach when thinking about how to move from monolithic
    legacy design to modern architecture design:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑如何从单体遗留设计迁移到现代架构设计时，我们推荐以下方法：
- en: Modernize the legacy application development and deployment process.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代化遗留应用程序的开发和部署流程。
- en: Consider language and/or framework upgrades or replacements that may improve
    the development and deployment life cycle. For example, if we have a Java WebSphere
    application, we may consider moving this to an Apache Tomcat web server framework
    if the application is not heavily tied into the features of WebSphere.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑语言和/或框架升级或替换，这可能会改善开发和部署生命周期。例如，如果我们有一个Java WebSphere应用程序，如果我们认为应用程序并没有与WebSphere的功能紧密绑定，我们可能会考虑将其迁移到Apache
    Tomcat web服务器框架。
- en: Modernize to containers where you can use Migrate for Anthos to rapidly move
    your application’s operating environment from VMs to containers. This will help
    make incremental improvements to the operations of your application that should
    give your team time to focus on modernization efforts.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中现代化，你可以使用Migrate for Anthos快速将你的应用程序的运行环境从虚拟机迁移到容器。这将有助于对应用程序的操作进行渐进式改进，这应该会给你的团队时间来专注于现代化工作。
- en: Adding a continuous integration pipeline for building and unit-testing your
    application can help teams identify and fix problems faster. In turn, this will
    provide them a quick feedback loop that will give them the confidence they need
    to start modernizing the application.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个持续集成管道，用于构建和单元测试你的应用程序，可以帮助团队更快地识别和修复问题。反过来，这将为他们提供一个快速反馈循环，这将给他们提供开始现代化应用程序所需的信心。
- en: Adding a continuous deployment pipeline that deploys your application to a lower
    environment and performs automated integration or user acceptance testing will
    further increase the productivity of the team.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个持续部署管道，将你的应用程序部署到较低的环境，并执行自动集成或用户验收测试，这将进一步提高团队的生产力。
- en: Adding end-to-end observability and instrumentation is key at this phase. We
    can no longer rely on logging into a dedicated virtual machine to view logs or
    debug our application. We need the ability to monitor and investigate incidents
    that may be occurring across a large set of nodes in our operating environment.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个阶段，添加端到端的可观察性和仪表化至关重要。我们不能再依赖于登录到专用的虚拟机来查看日志或调试我们的应用程序。我们需要能够监控和调查可能在我们操作环境的大量节点上发生的故障。
- en: Using a managed container operating environment like GKE or Anthos here will
    allow your teams to focus on software and deployment innovations rather than operating
    the container environment.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像GKE或Anthos这样的托管容器操作环境，将使您的团队能够专注于软件和部署创新，而不是运营容器环境。
- en: 'Next, you will want to modernize the legacy application itself, not just the
    development and deployment process. This will create agility, velocity, and efficiency
    for the development teams and infrastructure. Breaking the application into smaller
    domains and decoupling its capabilities into individual services with well-known
    contracts will create additional efficiencies. For example, you will be able to
    build and test a single business domain service in isolation, allowing for rapid
    iteration of capabilities. Standard contracts between services will create a well-defined
    boundary to determine when you are introducing breaking changes that may affect
    other dependent services. You will have two options: incrementally extract and
    rewrite capabilities or rewrite the entire application. Most of the time, this
    choice will depend on the business’s goals and appetite for investment. We will
    cover the first option briefly here because it is the most common approach we
    see customers adopting.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将希望使旧应用程序本身现代化，而不仅仅是开发和部署过程。这将为开发团队和基础设施创造敏捷性、速度和效率。将应用程序分解成更小的领域，并将其实体化到具有已知契约的独立服务中，将创造额外的效率。例如，您将能够独立构建和测试单个业务领域服务，从而允许快速迭代功能。服务之间的标准契约将创建一个明确的边界，以确定何时引入可能影响其他依赖服务的破坏性更改。您将有两个选择：逐步提取和重写功能或重写整个应用程序。大多数情况下，这个选择将取决于企业的目标和投资意愿。我们将简要介绍第一种选择，因为它是我们看到客户采用的最常见方法。
- en: You have ways to peel off capabilities on the edge and rewrite them to be cloud
    native. We would like to say it’s always so easy in real life. A lot of teams
    start with common services like authentication and authorization or logging. This
    approach will allow your teams to take smaller bites of the apple to start moving
    your application architecture into a modern microservices design.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您有方法在边缘剥离功能并重写它们以成为云原生。我们想说的是，在现实生活中这总是那么容易。许多团队从常见的服务开始，如身份验证和授权或日志记录。这种方法将使您的团队能够逐步采取较小的步骤，开始将您的应用程序架构迁移到现代微服务设计。
- en: 'At this point, you might be asking yourself, why not just use Migrate for Anthos
    on the legacy application and be done with it?. The answer depends on your particular
    use case and the life of the application. That approach may be well suited for
    an application that is scheduled to sunset or be replaced. For applications that
    will be around longer, you will want to eventually rewrite them to take advantage
    of modern architecture patterns like microservices and serverless architecture.
    The many advantages to the aforementioned architectures are highlighted here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，你可能自己会问，为什么不直接使用适用于旧应用的Anthos迁移，然后就此结束呢？答案取决于您的特定用例和应用程序的生命周期。这种方法可能非常适合计划停用或被替换的应用程序。对于将长期存在的应用程序，您最终将希望重新编写它们，以利用现代架构模式，如微服务和无服务器架构。以下列出了上述架构的许多优势：
- en: Development advantages
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发展优势
- en: Smaller teams focus on a single business problem domain.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型团队专注于单一的业务问题领域。
- en: Modern techniques for development and testing of code support the 100% autonomous
    build, test, and deployment of services. Although it is possible to achieve 100%
    test coverage and automated deployments with legacy applications, the amount of
    effort required is significantly greater than starting with a design that supports
    it up front.
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的开发和测试的现代技术支持服务的100%自主构建、测试和部署。尽管使用旧应用程序可以实现100%的测试覆盖率和自动化部署，但所需的努力比从一开始就支持它的设计要大得多。
- en: Decoupled services allow us to choose the technology stack that is best suited
    for the business capabilities the team is building.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦的服务允许我们选择最适合团队构建的业务能力的技术堆栈。
- en: Different teams can manage different microservices. This approach is often used
    to create a service per team where the team needs to understand only the business
    domain that applies to the service they’re developing. Consider a service that
    contains payment and taxation logic. In this scenario, the developer needs to
    understand concepts like payment transactions and gateways, PCI compliance, and
    federal or local tax rules. By splitting the service domain boundary between payments
    and taxes, we can reduce the domain knowledge required by the developers supporting
    each service. With a microservices approach, the payment team no longer needs
    to understand the intricacies of federal or local tax rules; they simply need
    to understand the API contact for adding the appropriate taxes to a given transaction.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的团队可以管理不同的微服务。这种做法通常用于为每个团队创建一个服务，其中团队只需要理解适用于他们正在开发的服务的企业领域。考虑一个包含支付和税务逻辑的服务。在这种情况下，开发者需要理解支付交易和网关、PCI合规性以及联邦或地方税务规则等概念。通过在支付和税务之间分割服务领域边界，我们可以减少支持每个服务的开发者所需的领域知识。采用微服务方法，支付团队不再需要理解联邦或地方税务规则的复杂性；他们只需要理解添加适当税费到特定交易的API接口。
- en: Operational advantages
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运营优势
- en: '*Increased reliability/high availability*—Each application service is compiled
    and deployed separately by design. This reduces the blast radius of service outages
    to a single microservice.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提高可靠性和高可用性*——每个应用程序服务都是单独设计编译和部署的。这减少了服务中断的影响范围，仅限于单个微服务。'
- en: '*Portability*—Containers create mobility, allowing us to run a service where
    it makes sense, on-prem or in a cloud provider. Although this can be accomplished
    with VMs, container platforms have made it easier to deploy and schedule the workloads
    in other environments or automatically move workloads to better operating nodes
    with zero downtime.'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可移植性*——容器创造了移动性，允许我们在合理的地方运行服务，无论是在本地还是在云服务提供商处。尽管这也可以通过虚拟机实现，但容器平台使得在其他环境中部署和调度工作负载或自动将工作负载移动到更好的操作节点（零停机时间）变得更加容易。'
- en: '*Lower operating costs*—Containers provide a higher density than VMs, yielding
    additional savings compared to VMs or physical environments.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*降低运营成本*——容器比虚拟机具有更高的密度，与虚拟机或物理环境相比，可以节省更多成本。'
- en: '*Elasticity of demand for individual services*—With a microservice design,
    we can automatically scale up services to meet demand and scale them back during
    idle times for cost efficiency. This is also possible with VM-based designs, but
    teams traditionally scale the entire VM due to lack of understanding of how to
    scale an individual service running within the VM.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单个服务的需求弹性*——采用微服务设计，我们可以自动扩展服务以满足需求，并在空闲时间缩小规模以实现成本效益。这也适用于基于虚拟机的架构，但团队传统上由于缺乏理解如何在虚拟机内部扩展单个服务，因此会扩展整个虚拟机。'
- en: '*Automated deployment pipelines*—Using a container-based solution allows us
    to more easily automate end-to-end operations.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动化部署管道*——使用基于容器的解决方案，我们可以更轻松地自动化端到端操作。'
- en: '*Self-healing*—By moving services that require high availability into the container
    platform, we can more easily set up automations to handle common failure and recovery
    tasks. Kubernetes provides liveness and readiness checks as well as rescheduling
    capabilities natively, which make this a simple task in most cases.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自我修复*——通过将需要高可用性的服务迁移到容器平台，我们可以更轻松地设置自动化来处理常见的故障和恢复任务。Kubernetes提供了原生的存活性和就绪性检查以及重新调度功能，这在大多数情况下是一个简单任务。'
- en: 16.2 Using Anthos for modernization
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 使用Anthos进行现代化
- en: 'Anthos provides a complete solution to run our containerized applications or
    legacy applications we want to migrate to containers. Anthos can help us modernize
    in place, move our workloads to the cloud, and enable hybrid application strategies
    more easily with capabilities for keeping clusters consistent between cloud and
    on-prem environments and advanced service mesh networking. See figure 16.1 for
    an overview of the Anthos components described here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Anthos提供了一个完整的解决方案来运行我们的容器化应用程序或我们希望迁移到容器的传统应用程序。Anthos可以帮助我们在原地现代化，将我们的工作负载迁移到云端，并利用保持云和本地环境之间集群一致性以及高级服务网格网络的能力，更轻松地实现混合应用程序策略。请参阅图16.1，了解此处描述的Anthos组件概述：
- en: Anthos Config Management provides an easy way to centrally manage configuration
    as code.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anthos 配置管理提供了一种简单的方法来集中管理配置代码。
- en: Anthos Service Mesh provides a way for us to specify loosely coupled service
    dependencies, establish secure communication channels between services, and instrument
    a centralized observability system.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anthos 服务网格为我们提供了一种指定松散耦合的服务依赖关系、在服务之间建立安全通信通道以及配置集中可观察性系统的方法。
- en: Anthos GKE provides a reliable and consistent runtime environment for our Kubernetes-based
    workloads on-prem or in public cloud environments.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Anthos GKE 为我们的基于 Kubernetes 的工作负载在本地或公共云环境中提供了一个可靠和一致的计算环境。
- en: Cloud Logging and Cloud Monitoring provide centralized tooling for monitoring,
    auditing, and troubleshooting clusters and workloads.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud Logging 和 Cloud Monitoring 提供了集中式工具，用于监控、审计和故障排除集群和工作负载。
- en: '![16-01](../../OEBPS/Images/16-01.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![16-01](../../OEBPS/Images/16-01.png)'
- en: Figure 16.1 Overview of Anthos components
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 Anthos 组件概述
- en: 16.2.1 Approach to modernization
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.1 现代化方法
- en: 'As we discussed in the introduction, a couple of ways to modernize your applications
    exist, and the path you choose may be different, depending on the specific application
    and business needs. Some applications or components in your application may not
    be great candidates for containerization. Some factors that may affect your decision
    to containerize your application or a component of your application follow:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在引言中讨论的那样，存在几种方法可以使您的应用程序现代化，您选择的路径可能因具体的应用程序和业务需求而异。您的应用程序中的一些应用程序或组件可能不适合容器化。以下是一些可能影响您决定将应用程序或应用程序组件容器化的因素：
- en: '*Using GCE*—If the application is business critical and poses too high of a
    risk, you may consider migrating this application to Google Compute Engine (GCE)
    VMs before proceeding with containerization. By moving the application to GCE
    first, you mitigate the risk of having to learn new operational patterns to support
    the application. This can give your team the time they need to learn Kubernetes
    and Anthos applied to less critical workloads first.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 GCE*——如果应用程序是业务关键型且风险过高，您在容器化之前可能需要考虑将此应用程序迁移到 Google Compute Engine（GCE）虚拟机。通过首先将应用程序迁移到
    GCE，您可以降低学习新操作模式以支持应用程序的风险。这可以给您的团队时间来首先学习 Kubernetes 和 Anthos 在不太关键的工作负载中的应用。'
- en: '*Licensing constraints*—For example, your application may depend on a software
    application that does not allow containerization.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*许可限制*——例如，您的应用程序可能依赖于一个不允许容器化的软件应用程序。'
- en: '*Operational support*—The team that supports your application is not ready
    to take on the new tool chain required to support a containerized application.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运营支持*——支持您的应用程序的团队尚未准备好承担支持容器化应用程序所需的新工具链。'
- en: '*Other factors*—These include regulatory compliance requirements, performance
    when interacting with other applications, and existing hardware investments.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*其他因素*——这包括法规遵从性要求、与其他应用程序交互时的性能以及现有的硬件投资。'
- en: Consider figure 16.2, which visualizes the high-level flow of modernizing a
    Java application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑图 16.2，它可视化了一个 Java 应用程序现代化的高级流程。
- en: '![16-02](../../OEBPS/Images/16-02.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![16-02](../../OEBPS/Images/16-02.png)'
- en: Figure 16.2 Modernizing a Java application
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 现代化 Java 应用程序
- en: 'The approach would be the same regardless of the technology stack you originally
    used to build your application. Also keep in mind that this is a simple example—your
    application may consist of multiple application components or services, which
    all need to interact to create the end-to-end application user experience. Based
    on the criteria listed earlier, you will need to decide which application components
    you will replatform into containers and which ones you will keep as VMs. Then
    you can work through the modernization plan as illustrated. The following outline
    adds a little more clarity to each step:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您最初使用哪种技术堆栈来构建应用程序，方法都是相同的。同时，请记住，这是一个简单的示例——您的应用程序可能由多个应用程序组件或服务组成，它们都需要交互以创建端到端的应用程序用户体验。根据前面列出的标准，您需要决定哪些应用程序组件将重新部署到容器中，哪些将保留为虚拟机。然后，您可以按照图示的工作流程进行现代化计划。以下大纲为每个步骤添加了更多的清晰度：
- en: '*Step 0*—Identify the target application or component to be modernized.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤 0*——确定要现代化的目标应用程序或组件。'
- en: '*Step 1*—If the application is suitable, we will use Anthos Migrate (chapter
    15) to containerize the target application.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤 1*——如果应用程序适合，我们将使用 Anthos Migrate（第 15 章）来容器化目标应用程序。'
- en: '*Step 2*—If the application is too complex, we will manually containerize the
    application. We will go into more detail on this approach in the next section.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤2*—如果应用过于复杂，我们将手动容器化应用。我们将在下一节中详细介绍这种方法。'
- en: '*Step 3*—Update your existing CI/CD pipeline, or build a new one that will
    build, test, and deploy the application to Anthos.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤3*—更新现有的CI/CD管道，或构建一个新的管道，用于构建、测试和部署应用到Anthos。'
- en: '*Step 4*—Operate your application using Anthos to manage configuration, security,
    and connectivity to legacy applications.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤4*—使用Anthos来管理配置、安全性和与遗留应用的连接来运行你的应用。'
- en: '*Step 5*—Refactor your application into a microservices architecture.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤5*—将你的应用重构为微服务架构。'
- en: '*Step 6*—Move legacy applications not currently suited for containers to Compute
    Engine, then modernize them by refactoring each application into microservices,
    using modern open source frameworks designed for cloud native applications.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*步骤6*—将目前不适合容器化的遗留应用迁移到Compute Engine，然后通过将每个应用重构为微服务，使用为云原生应用设计的现代开源框架来现代化它们。'
- en: Legacy applications not in scope for the modernization plan will remain in their
    current form and will likely remain in a legacy data center. We will use Anthos
    Service Mesh for securing connections to these workloads, such as ERP systems
    and core mainframe applications.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不在现代化计划范围内的遗留应用将保持其当前形式，并可能继续留在遗留数据中心。我们将使用Anthos Service Mesh来保护对这些工作负载的连接，例如ERP系统和核心主机应用。
- en: Figure 16.3 illustrates a three-tiered Java application, aka monolithic. In
    some cases, the legacy app will use a commercial Java application server (e.g.,
    WebSphere, WebLogic). If you have analyzed the application source and it is not
    taking advantage of proprietary features of the commercial application server,
    now would be a good time to move to an open source application server (Apache
    Tomcat, JBOSS) and eliminate unnecessary licensing costs. After all, you will
    be rebuilding the application deployment anyway, and public container images are
    available as starting points for either of the open source application servers
    mentioned. If your team is considering a redesign or rewrite, you may also want
    to consider moving to modern Java frameworks within your application, like Spring
    Boot ([https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot)).
    If you go down this path, you may also consider using the Spring Cloud GCP ([https://spring.io/projects/spring-cloud-gcp](https://spring.io/projects/spring-cloud-gcp))
    project, which will accelerate your migration and provide libraries for interacting
    with common GCP services like Pub/Sub, Cloud Spanner, and Cloud Storage. If you
    are looking to avoid getting locked in to a specific vendor, you may consider
    abstracting the aforementioned services by using interface design to abstract
    away the cloud provider-specific implementations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3展示了三层Java应用，也称为单体应用。在某些情况下，遗留应用将使用商业Java应用服务器（例如，WebSphere、WebLogic）。如果你已经分析了应用源代码，并且它没有利用商业应用服务器的专有功能，那么现在是迁移到开源应用服务器（Apache
    Tomcat、JBOSS）并消除不必要的许可成本的好时机。毕竟，你将重新构建应用部署，并且公共容器镜像可以作为上述开源应用服务器的起点。如果你的团队正在考虑重新设计或重写，你还可以考虑将应用中的现代Java框架迁移到Spring
    Boot ([https://spring.io/projects/spring-boot](https://spring.io/projects/spring-boot))。如果你选择这条路径，你还可以考虑使用Spring
    Cloud GCP ([https://spring.io/projects/spring-cloud-gcp](https://spring.io/projects/spring-cloud-gcp))项目，这将加速你的迁移并提供与常见GCP服务（如Pub/Sub、Cloud
    Spanner和Cloud Storage）交互的库。如果你希望避免锁定到特定供应商，你还可以通过使用接口设计来抽象上述服务，从而抽象出云提供商特定的实现。
- en: '![16-03](../../OEBPS/Images/16-03.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![16-03](../../OEBPS/Images/16-03.png)'
- en: Figure 16.3 Traditional three-tiered Java application
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 传统三层Java应用
- en: Once you have figured out which applications or application components are best
    suited for containerization, you can follow the next steps.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了哪些应用或应用组件最适合容器化，你就可以遵循下一步。
- en: Containerize your application
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化你的应用
- en: 'The first step in the journey is getting your application running inside a
    container. If you’re containerizing an ASP.NET application, you will have two
    approaches to consider: port to .NET Core or use Windows classic Kubernetes nodes.
    The approach you choose will depend on how easily you can port the application
    for ASP.NET to .NET Core and how long the application will be supported. In general,
    we recommend porting the application to .NET Core, which will run on Linux, thus
    simplifying your Anthos clusters. Additionally, as with Java applications, it
    might potentially require a major rewrite.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 旅程的第一步是在容器内运行你的应用程序。如果你正在容器化 ASP.NET 应用程序，你将有两个选择考虑：迁移到 .NET Core 或使用 Windows
    经典 Kubernetes 节点。你选择的方法将取决于你将 ASP.NET 应用程序迁移到 .NET Core 的难易程度以及应用程序将得到多长时间的支持。一般来说，我们建议将应用程序迁移到
    .NET Core，这样它将在 Linux 上运行，从而简化你的 Anthos 集群。此外，与 Java 应用程序一样，它可能需要彻底的重写。
- en: 'In this chapter, we will focus on the steps required to replatform a typical
    enterprise Java application to containers running on Anthos. A couple of tools
    are available for Java developers to make the process of building a container
    image for an application easier, which plug into an existing build workflow (see
    figure 16.4). If your team is not comfortable writing container image descriptors,
    you may consider using tools such as the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注将典型的企业级 Java 应用程序重新部署到在 Anthos 上运行的容器所需的步骤。Java 开发者有一些工具可以使用，使构建应用程序容器镜像的过程更加容易，这些工具可以集成到现有的构建工作流程中（见图
    16.4）。如果你的团队不习惯编写容器镜像描述符，你可以考虑使用以下工具：
- en: '*Jib* ([https://github.com/GoogleContainerTools/jib](https://github.com/GoogleContainerTools/jib))—Integrates
    with Maven and doesn’t require a Docker daemon on the build machine. Developers
    follow a typical build process, and Jib builds and outputs an optimized container
    image for your application. The optimized container image splits dependencies
    from classes, making it fast and efficient on future builds. Only the layers that
    have changed will be rebuilt.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jib* ([https://github.com/GoogleContainerTools/jib](https://github.com/GoogleContainerTools/jib))—与
    Maven 集成，在构建机器上不需要 Docker 守护进程。开发者遵循典型的构建过程，Jib 为你的应用程序构建并输出一个优化的容器镜像。优化的容器镜像将依赖项从类中分离出来，使其在未来的构建中快速高效。只有发生变化的层才会被重新构建。'
- en: '*Google Cloud buildpacks* ([http://mng.bz/dJKo](http://mng.bz/dJKo))—Buildpacks
    are designed to abstract the container image-building process, so the developer
    can follow a normal build process. Based on the CNCF v3 specification, these buildpacks
    output container images following best practices designed to run on GCP container
    services: Anthos, Cloud Run, or GKE.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Google Cloud buildpacks* ([http://mng.bz/dJKo](http://mng.bz/dJKo))—Buildpacks
    被设计用来抽象容器镜像构建过程，这样开发者可以遵循正常的构建过程。基于 CNCF v3 规范，这些 buildpacks 会输出遵循最佳实践的容器镜像，以便在
    GCP 容器服务上运行：Anthos、Cloud Run 或 GKE。'
- en: '![16-04](../../OEBPS/Images/16-04.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![16-04](../../OEBPS/Images/16-04.png)'
- en: Figure 16.4 Docker build vs. Jib/buildpack flow
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 Docker 构建 vs. Jib/buildpack 流程
- en: Once you have chosen your path and containerized your application, it’s time
    to connect it to a CI/CD build pipeline for faster deployment iterations. At this
    point, you have containerized the monolith. Later in this chapter, we will discuss
    how to refactor it into microservices.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了你的路径并容器化了你的应用程序，就是时候将其连接到 CI/CD 构建管道以实现更快的部署迭代了。在这个时候，你已经容器化了单体应用程序。在本章的后面部分，我们将讨论如何将其重构为微服务。
- en: Build and deploy your application using modern CI/CD
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代 CI/CD 构建和部署你的应用程序
- en: Next, we want to build a CI/CD pipeline to manage our new build process and
    deploy our application. This will create more efficiencies in our development
    process by eliminating manual tasks in favor of automation, thus allowing us to
    build, validate, and ship code faster. As we refactor to microservices, we decouple
    our application services into independently deployed components, which increases
    the overall complexity to deploy and manage our modern application. Without well-defined
    and complete CI/CD pipelines and an automated approach to address quality control
    and deployments, we see teams slow down rather than speed up.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要构建一个 CI/CD 管道来管理我们的新构建过程并部署我们的应用程序。这将通过消除手动任务以自动化任务来提高我们的开发过程的效率，从而允许我们更快地构建、验证和发布代码。随着我们重构到微服务，我们将应用程序服务解耦成独立部署的组件，这增加了部署和管理我们现代应用程序的整体复杂性。如果没有定义良好且完整的
    CI/CD 管道以及用于解决质量控制和支持部署的自动化方法，我们看到的团队速度减慢而不是加快。
- en: Figure 16.5 depicts the necessary stages and flow for building a CI/CD pipeline
    to build and deploy a Kubernetes application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5展示了构建CI/CD管道的必要阶段和流程，以构建和部署Kubernetes应用程序。
- en: '![16-05](../../OEBPS/Images/16-05.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![16-05](../../OEBPS/Images/16-05.png)'
- en: Figure 16.5 Example CI/CD pipeline for a Kubernetes application
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 Kubernetes应用程序的示例CI/CD管道
- en: Operating your application on Anthos
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Anthos上运行您的应用程序
- en: At this point, you can use Anthos as a consistent Kubernetes operating environment
    to reduce your operational overhead while increasing development cycle velocity.
    Refer to chapter 5 for more information on operating your application. Moving
    your applications into containers and adding CI/CD pipelines should give your
    operators and developers more cycles to focus on modernizing additional applications
    or move on to a deeper modernization (refactoring into microservices) of an application
    you already have running on Anthos.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以使用Anthos作为一致的Kubernetes操作环境，以减少您的运营开销，同时提高开发周期速度。有关运行应用程序的更多信息，请参阅第5章。将您的应用程序迁移到容器中并添加CI/CD管道，应该会给您的操作员和开发者更多的时间来关注现代化其他应用程序，或者继续对已经在Anthos上运行的现有应用程序进行更深入的现代化（重构为微服务）。
- en: Refactoring your application into microservices
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的应用程序重构为微服务
- en: 'What we have learned since the invention of public cloud platforms is that
    one architecture stands above all others for cloud native applications: microservices.
    The microservices architecture was pioneered by companies like Google and has
    since been adopted by mainstream companies performing in the elite DevOps space
    (see [http://mng.bz/rd4J](http://mng.bz/rd4J)). This chapter is not intended to
    be the holy grail of building microservice applications—plenty of good books on
    the topic are out there. We will take the time to highlight the architecture and
    key advantages to this approach, though. As illustrated in figure 16.6, with a
    monolithic architecture, we couple all of the service code into a single compiled
    application, which creates a hard coupling between the technical components and
    the teams building them. It also means that when that application is running in
    a single process, known side effects exist: an application crash in one component
    may take out the entire app, and scaling the application means scaling all components,
    which leads to waste in our computing environment.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 自从公共云平台发明以来，我们所学到的是，对于云原生应用程序而言，有一种架构优于所有其他架构：微服务。微服务架构由像谷歌这样的公司开创，此后已被主流公司采用，这些公司在精英DevOps领域表现突出（见[http://mng.bz/rd4J](http://mng.bz/rd4J)）。本章的目的不是成为构建微服务应用程序的圣杯——关于这个主题有很多好书。尽管如此，我们将花时间突出这种架构和这种方法的关键优势。如图16.6所示，在单体架构中，我们将所有服务代码耦合到一个单一的编译应用程序中，这会在技术组件和构建它们的团队之间创建硬耦合。这也意味着当该应用程序在单个进程中运行时，存在已知副作用：一个组件的应用程序崩溃可能会使整个应用程序崩溃，并且扩展应用程序意味着扩展所有组件，这会导致我们计算环境中的浪费。
- en: '![16-06](../../OEBPS/Images/16-06.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![16-06](../../OEBPS/Images/16-06.png)'
- en: Figure 16.6 Monolith vs. microservice architecture
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6单体架构与微服务架构对比
- en: 'Most teams use domain-driven design (see [http://mng.bz/Vp4y](http://mng.bz/Vp4y))
    in the design and creation of their microservices. With a microservice architecture,
    we decouple the services responsible for separate business domains into their
    own isolated services. This allows us to decouple the teams responsible for developing
    each service, reducing the domain expertise required. We standardize interactions
    between services by using industry best practices for protocols and data payloads,
    which provides the following technical and development benefits as outcomes to
    a microservices-based architecture:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数团队在设计创建微服务时使用领域驱动设计（见[http://mng.bz/Vp4y](http://mng.bz/Vp4y)）。在微服务架构中，我们将负责不同业务领域的服务解耦到它们自己的独立服务中。这使得我们可以将负责开发每个服务的团队解耦，减少所需的领域专业知识。我们通过使用行业最佳实践来标准化服务之间的交互，包括协议和数据负载，这为基于微服务的架构提供了以下技术和开发效益：
- en: We decompose an app into a set of smaller services that are easier to understand.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将应用程序分解为一系列更易于理解的小服务。
- en: They are faster to develop and easier to maintain because we limited the breadth
    of domain knowledge required.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们限制了所需的领域知识范围，它们开发更快，维护也更简单。
- en: They can be developed independently by a team focused on that service, increasing
    overall product development velocity.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些服务可以由专注于该服务的团队独立开发，从而提高整体产品开发速度。
- en: They are deployed and scaled independently; we’re scaling services, not servers.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以独立部署和扩展；我们正在扩展服务，而不是服务器。
- en: They make it easy to enable continuous deployment on complex applications because
    we can limit our test boundaries to a single service during service development
    iterations.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得在复杂应用程序上启用持续部署变得容易，因为我们可以在服务开发迭代期间将测试边界限制为单个服务。
- en: 'The business benefits follow:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 商业效益如下：
- en: We gain increased deployment frequency, resulting in reduced time to market
    for new features and patches. We can iterate development and add new capabilities
    to a single service with little or no effect to other application services.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们增加了部署频率，从而减少了新特性和补丁的上市时间。我们可以迭代开发，并向单个服务添加新功能，而对其他应用程序服务的影响很小或没有。
- en: We get better infrastructure utilization because we scale services, not servers.
    Because we have more cleanly defined application service boundaries, we can deploy
    services individually and scale only the ones we need to scale. In the past, it
    was common for operations teams to scale an entire server or VM because scaling
    an individual service was a complex task, and they didn’t understand the application
    well enough to split it up.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们获得了更好的基础设施利用率，因为我们扩展的是服务，而不是服务器。因为我们有更清晰定义的应用程序服务边界，我们可以单独部署服务，并仅扩展需要扩展的服务。在过去，运维团队通常会扩展整个服务器或虚拟机，因为单个服务的扩展是一个复杂任务，而且他们并不足够了解应用程序来将其拆分。
- en: We achieve faster mean time to recovery for security patches. Because microservices
    are mainly deployed using containers, we simply patch the code and redeploy the
    application using a Kubernetes rolling update with zero downtime. In the past,
    we would have attempted to patch the VM and do an in-place upgrade of the application.
    Most operations teams would agree this led to more downtime than was typically
    planned.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了安全补丁的更快的平均恢复时间。因为微服务主要是使用容器部署的，我们只需修补代码，然后使用Kubernetes滚动更新重新部署应用程序，实现零停机时间。在过去，我们可能会尝试修补虚拟机并就地升级应用程序。大多数运维团队都会同意这比通常计划的时间导致更多的停机时间。
- en: We experience reduced deployment failure or rollback. Because we have isolated
    the service boundaries, the scope of our deployments is also reduced. Combining
    this with automated testing and deployment of the application, our success rate
    increases significantly.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们经历了部署失败或回滚的减少。因为我们已经隔离了服务边界，我们的部署范围也相应减少。结合应用程序的自动化测试和部署，我们的成功率显著提高。
- en: 'You can take two approaches when choosing to refactor your application into
    a microservices architecture: first, spin up a team focused on rewriting the entire
    application using a greenfield approach. This approach will be less disruptive
    to your production application, but it will add more risk to the overall project
    because you need the entire application to be rewritten before you can realize
    the benefits. The second approach is to apply the strangler fig pattern ([http://mng.bz/xdgd](http://mng.bz/xdgd))
    to slowly iterate away the design of the legacy application and refactor it into
    microservices.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择将应用程序重构为微服务架构时，你可以采取两种方法：首先，组建一个专注于使用绿色田野方法重写整个应用程序的团队。这种方法对生产应用程序的干扰较小，但会增加整体项目的风险，因为在你能够实现效益之前，你需要重写整个应用程序。第二种方法是应用绞杀榕模式([http://mng.bz/xdgd](http://mng.bz/xdgd))，逐步迭代掉遗留应用程序的设计，并将其重构为微服务。
- en: We recommend using the strangler fig pattern because it reduces the risk in
    adopting the new design patterns and overall refactoring of the application into
    a microservices architecture. This method may add a little more work to the overall
    project because we need to extract the logic and work it back into the existing
    application. It allows us to incrementally improve our application architecture,
    providing more and more value each time we create a new production release, which
    reduces the amount of risk and starts to provide value more quickly to the business.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用绞杀榕模式，因为它降低了采用新设计模式和将应用程序整体重构为微服务架构的风险。这种方法可能会给整体项目增加一点工作量，因为我们需要提取逻辑并将其重新整合到现有应用程序中。它允许我们逐步改进应用程序架构，每次创建新的生产版本时都提供更多价值，从而减少风险并更快地向业务提供价值。
- en: 'Many teams struggle with the simple question, where do we start? The answer
    will be different for each application. However, the pattern is generally the
    same: look for features that support the application and are easy to decouple.
    For example, a centralized authentication and authorization service is usually
    a good choice.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 许多团队在简单的问题上挣扎，即我们从哪里开始？答案将因每个应用而异。然而，模式通常是相同的：寻找支持应用且易于解耦的功能。例如，集中式身份验证和授权服务通常是一个不错的选择。
- en: 'Consider using the framework Google recommends ([http://mng.bz/Alqo](http://mng.bz/Alqo))
    for evaluating which feature to move first. A summary of the framework follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用谷歌推荐的框架([http://mng.bz/Alqo](http://mng.bz/Alqo))来评估哪个功能应该首先移动。以下是对该框架的总结：
- en: Business process
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务流程
- en: Design and development
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和开发
- en: Operations
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运维
- en: People and teams
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人员和团队
- en: Business process
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 业务流程
- en: You should evaluate and consider the effects that moving the feature will have
    on the business users. Developers and operations teams need to learn a lot of
    new concepts to successfully modernize an application. Early in your modernization
    process you should avoid moving business-critical systems or features.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该评估和考虑移动功能对商业用户可能产生的影响。开发者和运维团队需要学习许多新概念才能成功实现应用的现代化。在您的现代化过程中早期，应避免移动业务关键系统或功能。
- en: Design and development
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 设计和开发
- en: 'Next, you should evaluate the complexity of the feature, its dependencies,
    and the amount of refactoring required to move it. Consider the following factors:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您应该评估功能的复杂性、其依赖关系以及移动它所需的重构量。考虑以下因素：
- en: Data usage, number of schemas (isolated or shared), and size
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据使用、模式数量（隔离或共享）和大小
- en: Dependencies on other features
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对其他功能的依赖
- en: Other features that depend on this feature
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于此功能的其他功能
- en: Connectivity requirements
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接性需求
- en: Design elements that may create complexity in refactoring or have no clear solution
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重构中可能增加复杂性或没有明确解决方案的设计元素
- en: Operations
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运维
- en: 'While evaluating which features to move first, you should consider the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估哪些功能应首先移动时，您应考虑以下因素：
- en: Service-level agreements with the business
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与商业的SLA服务
- en: Maintenance windows and tolerance for downtime
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护窗口和停机容忍度
- en: Consider focusing on features that are more lenient on downtime and don’t have
    critical business SLAs requiring high availability.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑专注于对停机时间更宽容且没有要求高可用性的关键业务SLA的功能。
- en: People and teams
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 人员和团队
- en: In the early stage, it is preferable to focus on teams that are in support of
    modernization and have well-defined processes. If possible, avoid teams that are
    holding out or where processes are available only through tribal knowledge.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期阶段，最好专注于支持现代化且拥有明确流程的团队。如果可能，避免那些抵制或流程仅通过部落知识可用的团队。
- en: Optimize your on-prem legacy applications using Anthos Service Mesh
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Anthos Service Mesh优化您的本地遗留应用
- en: 'Most people taking this approach to modernize their application will end up
    with some components or dependencies still running on VMs. We can use Anthos Service
    Mesh (ASM) to add observability and security capabilities in managing these workloads,
    consistent with our Kubernetes workloads. The benefits ASM provides to VMs are
    listed here (and see figure 16.7):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数采用这种方法来现代化其应用的人最终会有些组件或依赖仍然运行在虚拟机上。我们可以使用Anthos Service Mesh (ASM)来为这些工作负载添加可观察性和安全功能，与我们的Kubernetes工作负载保持一致。ASM为虚拟机提供的优势列在这里（并参见图16.7）：
- en: Use the same declarative policy and security management framework as containers
    running on Anthos.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与在Anthos上运行的容器相同的声明式策略和安全管理系统框架。
- en: No code changes required; once the VM registers with Anthos, it is treated like
    a service running in GKE.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需代码更改；一旦虚拟机注册到Anthos，它就像在GKE中运行的服务一样被处理。
- en: Take advantage of the same observability you get from your container workloads
    in a single dashboard; metrics appear just like a service running in GKE.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用您从容器工作负载中在单个仪表板中获得的相同可观察性；指标就像在GKE中运行的服务一样出现。
- en: '![16-07](../../OEBPS/Images/16-07.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![16-07](../../OEBPS/Images/16-07.png)'
- en: Figure 16.7 Integrating VMs with Anthos Service Mesh
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 将虚拟机与Anthos Service Mesh集成
- en: 16.3 Benefits of Anthos for microservices
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 Anthos为微服务带来的好处
- en: 'The goal of a microservice architecture is to decouple the business service
    logic into individual, self-contained services to provide acceleration of development
    and optimization of performance. The drawback is that you are creating complexity
    in the configuration, deployment, and maintenance operations of your application.
    The packages that you need to reinstall due to updates in the common software
    introduce a pain in the neck every time you have to redo and update lots of different
    environments. Anthos solves the most common problems associated with supporting
    these types of applications:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的目标是将业务服务逻辑解耦成独立的、自包含的服务，以提供开发加速和性能优化。缺点是您正在创建应用程序配置、部署和维护操作中的复杂性。由于通用软件的更新，您需要重新安装的软件包每次您必须重新做和更新大量不同环境时都会带来不便。Anthos解决了与支持这些类型的应用程序相关的最常见问题：
- en: '*Consistency*—A consistent runtime environment across multiple public cloud
    and on-prem data centers.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一致性*—在多个公共云和本地数据中心之间提供一致的运行时环境。'
- en: '*Automation*—A key to success with microservices is your ability to automate
    the deployment of your entire application. Anthos provides configuration as code
    to enable this capability. You can apply configuration and security policies and
    even deploy your application components using ACM.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动化*—在微服务中取得成功的关键是您自动化整个应用程序部署的能力。Anthos提供配置为代码的功能来实现这一能力。您可以应用配置和安全策略，甚至使用ACM部署应用程序组件。'
- en: '*Dependency management and security*—Increased complexity in decoupled services
    is more easily managed using a service mesh. Instead of embedding physical service-to-service
    dependencies in our applications, a popular pattern in microservices-based solutions
    is to embed logical references that are resolved by the service mesh. ASM provides
    this capability as well as the ability to inject security policy, enforce mutual
    TLS, and bridge traditional VMs into your application as though they were other
    Kubernetes-based services.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖管理和安全*—在解耦服务中，使用服务网格可以更轻松地管理增加的复杂性。我们不是在应用程序中嵌入物理服务间的依赖关系，而是采用在基于微服务解决方案中流行的模式，嵌入由服务网格解析的逻辑引用。ASM提供了这一功能，以及注入安全策略、强制执行双向TLS和将传统虚拟机桥接到您的应用程序，就像它们是其他基于Kubernetes的服务一样。'
- en: '*Observability*—Understanding your application’s performance is more difficult
    once you have broken it into microservices. Instead of monitoring one Java process
    with a sophisticated tool, you will need to monitor lots of services for performance
    and understand when one is degraded or broken. Anthos Service Mesh provides the
    ability to visualize and inspect your application performance as well as set service-level
    objectives (SLOs) so you can be alerted or have automated processes remediate
    service performance.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可观察性*—一旦将应用程序分解成微服务，理解应用程序的性能就会变得更加困难。您将需要监控大量服务以了解性能，并了解何时某个服务性能下降或损坏。Anthos服务网格提供了可视化和检查应用程序性能的能力，以及设置服务级别目标（SLOs），这样您就可以收到警报或自动处理服务性能。'
- en: 16.4 Real-world examples
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 现实世界示例
- en: Lots of real-world examples exist where we need to run compute workloads close
    to the user (aka running on the edge). These are great use cases for Anthos, which
    provides the ability to apply configuration and security policies as code. Two
    easy-to-identify use cases are retail and manufacturing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多现实世界的例子，其中我们需要在用户附近（即边缘）运行计算工作负载。这些是Anthos的绝佳用例，它提供了将配置和安全策略作为代码应用的能力。两个易于识别的用例是零售和制造。
- en: 'Imagine you are a large cruise line. You have developed a new user experience
    using many of the concepts we have described in this book. Your team has built
    a new microservices-based architecture with web and mobile application user experiences.
    This new digital experience is used to provide lots of shipboard capabilities
    to your customers, like activity planning, meal ordering, events, announcements,
    and concierge services. The problem you keep having is a lack of consistency in
    the fleet. You are running into problems keeping the hardware and software updated
    on each ship, leading to an inconsistent user experience, outages, and many more
    problems. The effort to update is a time-consuming human effort to apply patches
    and upgrade software. So, even though your development team took a modern approach,
    you are struggling to operate this complex solution. You need Anthos. Although
    it won’t eliminate the process of updating hardware or core networking changes,
    it will handle everything else, lessening the gap between manual and automated
    processes and reducing your overhead to operate the solution. Anthos will provide
    you with the following capabilities to get a handle on your environments and avoid
    configuration and deployment problems:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一家大型邮轮公司。你们团队利用本书中描述的许多概念开发了一种新的用户体验。你们团队构建了一个基于微服务的架构，其中包括网页和移动应用程序的用户体验。这种新的数字体验被用来向客户提供大量的船载功能，如活动规划、餐点订购、活动、公告和礼宾服务。你一直面临的问题是船队缺乏一致性。你难以在每艘船上更新硬件和软件，导致用户体验不一致、断电以及更多问题。更新工作需要消耗大量的人力，包括应用补丁和升级软件。因此，尽管你们开发团队采取了现代化的方法，但你们在运营这个复杂解决方案时仍然感到吃力。你需要Anthos。尽管它不能消除更新硬件或核心网络更改的过程，但它将处理其他所有事情，缩小手动和自动化流程之间的差距，并降低你运营解决方案的额外开销。Anthos将为你提供以下功能，以掌握你的环境并避免配置和部署问题：
- en: '*Anthos GKE*—Provides a managed Kubernetes distribution that ensures you are
    running the same runtime platform on each environment.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Anthos GKE*——提供托管Kubernetes分发版，确保你在每个环境中运行相同的运行时平台。'
- en: '*Anthos Service Mesh*—Provides security and observability capabilities to ensure
    your container environment and workloads are secure and your developers can easily
    find problems by using SLOs.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Anthos Service Mesh*——提供安全和可观察性功能，确保你的容器环境和工作负载是安全的，并且你的开发者可以通过使用SLOs轻松地找到问题。'
- en: '*Anthos Configuration Management*—Provides a centralized policy-as-code approach
    to core cluster configuration, security policies, and application deployment consistency.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Anthos Configuration Management*——提供集中式的策略即代码方法，用于核心集群配置、安全策略和应用程序部署一致性。'
- en: Now imagine that your team has built the solution with Anthos at the center
    of operations. Your team has designed each cluster and documented your core cluster
    configuration and security policies as code using Anthos Config Management. To
    bring a new shipboard data center online, it’s as simple as racking and stacking
    the gear, getting the hardware on the network, installing Anthos, and then registering
    the cluster with the control plane and ACM. Then ACM will bootstrap the cluster
    with the right configuration and security policies.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，如果你的团队已经将Anthos作为运营的核心构建了解决方案。你们团队已经设计了每个集群，并使用Anthos Config Management将核心集群配置和安全策略作为代码进行文档化。要将新的船载数据中心上线，只需简单地将设备上架、将硬件接入网络、安装Anthos，然后使用控制平面和ACM注册集群。然后ACM将使用正确的配置和安全策略引导集群。
- en: 16.5 Antipatterns to avoid
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 需要避免的反模式
- en: 'We have discovered several antipatterns over the years while helping teams
    modernize their applications into a microservice architecture:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，在帮助团队将应用程序现代化并转型为微服务架构的过程中，我们发现了几个反模式：
- en: '*Tempting big bang approaches*—Many teams decide to scrap what they have and
    start over, rewriting the entire application all at once into a microservice architecture.
    In our experience, this tends to lead to a waterfall approach, with significantly
    longer efforts and overrun budgets before the business can realize the benefits.
    A better approach is to peel the onion, one layer at a time, as we have mentioned
    earlier in the chapter. This fits better into a lean or agile approach to modernizing
    the application and starts to provide benefits much faster.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*诱惑性的大爆炸方法*—许多团队决定放弃他们已有的东西，从头开始，一次性将整个应用程序重写为微服务架构。根据我们的经验，这往往会导致瀑布式方法，在业务能够实现效益之前，需要付出更长的时间和超出预算的努力。一个更好的方法是像我们之前在章节中提到的，一层层地剥洋葱，这样更适合精益或敏捷方法来现代化应用程序，并且可以更快地开始提供效益。'
- en: '*Ignoring architecture design principles of microservices* ([http://mng.bz/ZoMR](http://mng.bz/ZoMR))—To
    correctly create microservices, we isolate all functionality within a new service.
    This typically means moving the interface logic, the business logic, and the data
    schemas required for stateful services. Many teams stumble here and leave the
    data schemas in a shared data store. This can be tempting when teams don’t understand
    the services boundaries well or don’t understand how to solve downstream capabilities
    like analytics or reporting. In a mature microservice-based solution, all components
    must be isolated and independently versioned and deployed.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*忽视微服务架构设计原则* ([http://mng.bz/ZoMR](http://mng.bz/ZoMR))—为了正确创建微服务，我们将所有功能隔离在新的服务中。这通常意味着移动接口逻辑、业务逻辑以及状态服务所需的数据模式。许多团队在这里会遇到困难，并留下数据模式在共享数据存储中。当团队不很好地理解服务边界或不知道如何解决下游能力，如分析或报告时，这可能会很有吸引力。在一个成熟的基于微服务的解决方案中，所有组件都必须是隔离的，并且可以独立版本化和部署。'
- en: '*Data-driven migration* ([http://mng.bz/Rl6Z](http://mng.bz/Rl6Z))—Given the
    first antipattern we discussed, it becomes tempting to focus heavily on the data
    and attempt to use the data boundaries as service boundaries. This is typically
    a mistake in legacy systems and generally results in migration thrashing (lots
    of migration iterations to get it right). Instead, consider an intermediary step
    where you focus on logic first and data second. This will allow you to get the
    business service boundaries correct and better understand how to split out the
    data.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据驱动迁移* ([http://mng.bz/Rl6Z](http://mng.bz/Rl6Z))—鉴于我们之前讨论的第一个反模式，人们可能会倾向于过分关注数据，并试图使用数据边界作为服务边界。这在遗留系统中通常是一个错误，通常会导致迁移震荡（许多迁移迭代才能正确）。相反，考虑一个中间步骤，首先关注逻辑，其次关注数据。这将使你能够正确地确定业务服务边界，并更好地理解如何分割数据。'
- en: '*Decoupling capabilities not code* ([http://mng.bz/2adg](http://mng.bz/2adg))—Developers
    and technical managers take ownership of the code written, which is why they are
    tempted to extract and reuse existing code when refactoring the monolithic code
    base into microservices, when, in reality, a high cost and low value results from
    this approach. Most organizations and teams will benefit from a rewrite of the
    code. This allows them to revisit the business process, potentially optimize legacy
    processes, and improve the code base in the process (add unit tests, standardize
    on new languages, etc.). In some cases, it makes sense to reuse existing code—a
    good example would be to extract a complex algorithm that is not well understood
    or documented. In this situation, it would be safer to extract and reuse the code
    and then modernize at a later stage, once the team understands what it is doing
    and can safely rewrite.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解耦功能而非代码* ([http://mng.bz/2adg](http://mng.bz/2adg))—开发人员和技术经理负责编写代码，这就是为什么他们在重构单体代码库到微服务时，会倾向于提取和重用现有代码，但实际上，这种方法会产生高成本和低价值。大多数组织和团队将从代码的重写中受益。这允许他们重新审视业务流程，可能优化遗留流程，并在过程中改进代码库（添加单元测试，采用新语言等）。在某些情况下，重用现有代码是有意义的——一个很好的例子是提取一个复杂但理解或文档不佳的算法。在这种情况下，提取和重用代码，然后在团队理解了他们在做什么并且可以安全地重写之后，再进行现代化是更安全的。'
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Modernizing legacy applications doesn’t always have to start with a complete
    rewrite or refactor. Moving the application into containers can help reduce operational
    burden and give your team time to innovate on the next version of the app.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代化遗留应用程序不一定要从完全重写或重构开始。将应用程序迁移到容器中可以帮助减少运营负担，并给你的团队时间来创新下一个版本的软件。
- en: While modernizing your application, look for opportunities to reduce technical
    debt, like migrating your web server framework or updating core libraries.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代化应用程序的过程中，寻找机会减少技术债务，例如迁移您的网络服务器框架或更新核心库。
- en: Other ways to reduce technical debt include removing code for bootstrapping
    TLS security or observing and relying on Anthos for these capabilities at the
    platform level.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少技术债务的其他方法包括移除用于引导TLS安全性的代码或观察并依赖Anthos在平台级别提供这些功能。
- en: Consider new design patterns like microservices if you will be rewriting or
    refactoring your application.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您将重写或重构应用程序，请考虑使用微服务这样的新设计模式。
- en: Avoid taking a big bang approach—give preference to incremental improvements
    to the application.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免采取大爆炸式的方法——优先考虑对应用程序进行渐进式改进。
- en: Use Anthos for consistent runtimes, automation, dependency management, security,
    and observability to ensure development teams have a consistent set of capabilities
    to rely on in their operating environments.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Anthos提供一致的运行时、自动化、依赖管理、安全性和可观察性，以确保开发团队在其操作环境中有一套一致的能力可以依赖。
