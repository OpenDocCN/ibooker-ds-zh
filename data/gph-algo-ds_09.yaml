- en: 7 Inferring co-occurrence networks based on bipartite networks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 基于二部网络推断共现网络
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Extracting hashtags from tweets with Cypher query language
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cypher查询语言从推文中提取标签
- en: Calculating the Jaccard similarity coefficient
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算Jaccard相似系数
- en: Constructing and analyzing monopartite networks using the Jaccard similarity
    coefficient
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jaccard相似系数构建和分析单部网络
- en: Using the label propagation algorithm to evaluate the community structure of
    a network
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签传播算法评估网络的社区结构
- en: Using PageRank to find the most important node within a community
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PageRank在社区内找到最重要的节点
- en: In the previous chapter, you learned how to transform a custom graph pattern
    into direct relationships to use them as an input to graph algorithms like PageRank.
    In this chapter, you will focus on bipartite networks and how to project them
    into monopartite networks. Let’s start with a quick refresher on bipartite networks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何将自定义图模式转换为直接关系，以便将它们用作PageRank等图算法的输入。在本章中，你将专注于二部网络以及如何将它们投影到单部网络。让我们先快速回顾一下二部网络。
- en: A bipartite network contains two sets or types of nodes. For example, figure
    7.1 shows the bipartite network of tweets on the left and their hashtags on the
    right. As you can observe, the relationships always points from one type of node
    to another. There are no direct connections between tweets or hashtags.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 二部网络包含两个集合或类型的节点。例如，图7.1显示了左侧的推文二部网络和右侧的标签。正如你所观察到的，关系总是从一个类型的节点指向另一个类型的节点。推文或标签之间没有直接连接。
- en: '![07-01](../../OEBPS/Images/07-01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![07-01](../../OEBPS/Images/07-01.png)'
- en: Figure 7.1 Bipartite network of tweets and hashtags
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 推文和标签的二部网络
- en: Imagine you work in a marketing analytics role for a company that deals with
    natural language processing (NLP) and knowledge graphs. Your boss decides it might
    be worthwhile to improve the hashtag strategy for the content published on Twitter.
    You have been assigned the task of identifying relevant hashtags to target the
    company’s ideal customer as best as possible. Since the Twitter dataset you have
    used so far contains tweets about NLP and knowledge graphs, you can analyze the
    hashtags in the dataset to identify which the company should target.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个处理自然语言处理（NLP）和知识图谱的公司担任市场分析角色。你的老板决定改进发布在Twitter上的内容标签策略可能是有价值的。你被分配了识别相关标签以尽可能好地定位公司理想客户的任务。由于你迄今为止使用的Twitter数据集包含关于NLP和知识图谱的推文，你可以分析数据集中的标签以确定公司应该定位哪些标签。
- en: Your first thought might be to use the PageRank algorithm to identify the most
    important hashtags. Remember, graph algorithms like PageRank expect monopartite
    networks as input or at least networks where the influence can flow throughout
    the connections. With a bipartite network, one type of node has only incoming
    relationships, and the other type has only outgoing connections. If you were to
    execute PageRank on the example bipartite network of tweets and hashtags, which
    nodes do you think would come out on top?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个想法可能是使用PageRank算法来识别最重要的标签。记住，像PageRank这样的图算法期望输入单部网络或至少是影响力可以贯穿连接的网络。对于二部网络，一种类型的节点只有入度关系，另一种类型的节点只有出度连接。如果你要对推文和标签的二部网络示例执行PageRank，你认为哪些节点会排在最前面？
- en: Since tweets don’t have any incoming relationships, their PageRank score will
    equal the chance of a web surfer randomly landing on them. With the default value
    of the damping factor of 0.85, the PageRank score for nodes with no incoming connections
    is 0.15\. On the other hand, hashtags have only incoming relationships. The influence
    flows from tweets to hashtags but does not flow further, as there are no outgoing
    connections from hashtags. In practice, the PageRank rank of hashtags would be
    equal to their count of incoming relationships (in-degree). However, the actual
    values of PageRank and in-degree would be different due to distinct score calculation
    techniques.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于推文没有任何入度关系，它们的PageRank分数将等于网络冲浪者随机访问它们的概率。默认情况下，阻尼因子为0.85，没有入度连接的节点的PageRank分数为0.15。另一方面，标签只有入度关系。影响力从推文流向标签，但不会进一步流动，因为没有从标签出发的出度连接。在实践中，标签的PageRank排名将等于它们入度关系的数量。然而，由于不同的分数计算技术，PageRank和入度的实际值会有所不同。
- en: Remember, the goal is to determine the most important and relevant hashtags
    in the dataset. If the definition of hashtag importance is as simple as their
    frequency, then using the in-degree metric of the `Tag` nodes would suffice.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，目标是确定数据集中最重要的和相关的标签。如果标签重要性的定义仅仅是它们的频率，那么使用`Tag`节点的入度指标就足够了。
- en: However, some of the hashtags in the dataset might not be relevant to the marketing
    targeting objective. You could completely miss other relevant hashtags by looking
    at only the most frequently mentioned hashtags, as you don’t know whether the
    dataset is skewed toward a particular topic. Additionally, strategically combining
    hashtags could significantly improve the reach of content by targeting a wider
    audience instead of only using the most frequently mentioned ones. So your mission
    is to find important hashtags as well as other hashtags that could be used in
    combination to increase virality. A well-known technique used to identify communities
    of hashtags that are commonly used together is to examine how often pairs of hashtags
    co-occur in tweets. By analyzing how often pairs of hashtags co-occur in the same
    tweet, you build a co-occurrence network. The term *co-occurrence network* refers
    to a network construction method that analyzes relationships between various entities
    in a text. In the case of tweets and their hashtags, you can use the co-occurrence
    network method to analyze relationships between hashtags appearing in the text
    of a tweet.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据集中的某些标签可能并不与营销目标相关。仅通过查看最常提到的标签，你可能会完全错过其他相关的标签，因为你不知道数据集是否偏向于特定主题。此外，战略性地组合标签可以通过针对更广泛的受众而不是仅使用最常提到的标签来显著提高内容的覆盖范围。因此，你的任务是找到重要的标签，以及可以组合使用以增加病毒性的其他标签。用于识别常用标签社区的一种常用技术是检查标签对在推文中共现的频率。通过分析标签对在相同推文中共现的频率，你构建了一个共现网络。术语“共现网络”指的是一种网络构建方法，它分析文本中各种实体之间的关系。在推文及其标签的情况下，你可以使用共现网络方法来分析推文文本中出现的标签之间的关系。
- en: Figure 7.2 shows the co-occurrence network of keywords in medical articles.
    Co-occurrence networks are constructed by connecting pairs of entities in the
    text using a set of criteria defining co-occurrences. The co-occurrence definition
    can vary from scenario to scenario. In this example, co-occurrence is defined
    as two keywords occurring in the same article. The more times a pair of keywords
    are present in the same article, the stronger the connection is between the two.
    A similar technique was used to analyze the scientific literature surrounding
    the COVID-19 research (Al-Zaman, 2021; Andersen et al., 2020). Additionally, researchers
    have also used the biomedical literature co-occurrence network to predict new
    links (Kastrin et al., 2014).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2显示了医学文章中关键词的共现网络。共现网络是通过使用定义共现的一组标准将文本中的实体对连接起来构建的。共现的定义可能因场景而异。在这个例子中，共现被定义为两个关键词出现在同一篇文章中。一对关键词在同一篇文章中出现的次数越多，它们之间的联系就越强。类似的技巧被用来分析围绕COVID-19研究的科学文献（Al-Zaman，2021；Andersen等人，2020）。此外，研究人员还使用生物医学文献共现网络来预测新的链接（Kastrin等人，2014）。
- en: '![07-02](../../OEBPS/Images/07-02.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![07-02](../../OEBPS/Images/07-02.png)'
- en: Figure 7.2 Co-occurrence network of medical keywords
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 医学关键词共现网络
- en: However, you are not limited to analyzing only the co-occurrence of keywords
    in a given text. In the *Game of Thrones* analysis (Beveridge et al., 2018), Andrew
    Beveridge popularized analyzing books through the lens of co-occurrence entity
    networks. The *Game of Thrones* book analysis consists of two steps. First, Beveridge
    identified all of the characters in the book. In the next step, he defined a co-occurrence
    event between a pair of characters if they appear within 15 words of one another.
    In this context, a co-occurrence event can be understood as an interaction between
    a pair of characters. In my previous works, I have used this technique to construct
    a co-occurrence or interaction network between characters in the book *Harry Potter
    and the Philosopher’s Stone*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不仅限于分析给定文本中关键词的共现。在《权力的游戏》分析（Beveridge等，2018）中，Andrew Beveridge通过共现实体网络的角度普及了分析书籍的方法。《权力的游戏》书籍分析包括两个步骤。首先，Beveridge确定了书中的所有角色。在下一步中，他定义了一对角色如果在彼此15个单词之内出现，则它们之间存在共现事件。在这种情况下，共现事件可以理解为角色之间的互动。在我之前的工作中，我使用这种技术构建了《哈利·波特与魔法石》书中角色之间的共现或互动网络。
- en: Just by looking at figure 7.3, you can evaluate which are the main characters
    in the first Harry Potter book and evaluate how they interact with each other.
    The node size is based on the node degree, so the more connections a node has,
    the bigger the node size is. It only makes sense that Harry Potter has the most
    interactions with other characters, as the book narrative is mostly written from
    his perspective.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只需看图7.3，你就可以评估《哈利·波特》第一本书中的主要角色，并评估它们之间的互动。节点大小基于节点度，所以节点连接越多，节点大小就越大。哈利·波特与其他角色互动最多是合情合理的，因为这本书的叙述主要从他的视角来写。
- en: '![07-03](../../OEBPS/Images/07-03.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![07-03](../../OEBPS/Images/07-03.png)'
- en: Figure 7.3 Co-occurrence network of characters in the first Harry Potter book
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 《哈利·波特》第一本书中字符共现网络
- en: The first two examples of the co-occurrence analysis demonstrate scenarios where
    keywords or entities are extracted from a text and then connected using an arbitrary
    co-occurrence event. The third example I’ve prepared is visualizing how the ingredients
    co-occur in various dishes or recipes. Again, the node size in figure 7.4 is based
    on the number of connections it has. In the center of the left-hand side community,
    you can observe eggs, flours, sugar, and milk. I would imagine that the dishes
    with those ingredients mostly fall under bread, pancakes, or sweets. For some
    reason, peanut butter is also frequently present in this community. You can observe
    main-dish types of ingredients on the right-hand side, including onions, tomato
    sauce, potatoes, and meat. Interestingly, one research paper (Cooper, 2020) uses
    the ingredient co-occurrence network to analyze packaged food in the United States.
    Another research paper (Kular et al., 2011) uses the ingredient co-occurrence
    network to examine the relationships between cuisines and various cultures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 共现分析的前两个例子展示了从文本中提取关键词或实体，然后通过任意共现事件连接的情景。我准备的第三个例子是可视化各种菜肴或食谱中成分的共现情况。再次强调，图7.4中的节点大小基于其连接数。在左侧社区的中心，你可以观察到鸡蛋、面粉、糖和牛奶。我想象这些成分的菜肴大多属于面包、煎饼或甜点。出于某种原因，花生酱也频繁出现在这个社区中。在右侧，你可以观察到主菜类型的成分，包括洋葱、番茄酱、土豆和肉类。有趣的是，一篇研究论文（Cooper，2020）使用成分共现网络分析美国的包装食品。另一篇研究论文（Kular等，2011）使用成分共现网络来研究菜系与各种文化之间的关系。
- en: '![07-04](../../OEBPS/Images/07-04.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![07-04](../../OEBPS/Images/07-04.png)'
- en: Figure 7.4 Co-occurrence network of ingredients in dishes
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 菜肴中成分的共现网络
- en: Let’s now circle back to the task of identifying the most optimal strategy to
    use and combining various hashtags that will reach users with knowledge graphs
    and NLP interest. You can start with a hypothesis that if two hashtags co-occur
    within the same tweet, they are somehow related or fall under a similar topic.
    Based on that hypothesis, the co-occurrence network method would connect hashtags
    that might have the same or similar overall topic. The co-occurrence network can
    also help you produce various groups of hashtags that could be used together.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到识别最优化策略的任务，结合使用知识图谱和NLP兴趣来找到能够触达用户的各种标签。你可以从一个假设开始，即如果两个标签在同一个推文中同时出现，它们可能在某种程度上相关或属于相似的主题。基于这个假设，共现网络方法会将可能具有相同或相似整体主题的标签连接起来。共现网络还可以帮助你产生可以一起使用的各种标签组合。
- en: 'Figure 7.5 shows the process of constructing a co-occurrence network of hashtags
    based on the original bipartite network of tweets and hashtags. On the left-hand
    side of the visualization is the original bipartite network. A tweet can contain
    multiple hashtags. For example, tweet A has the #Growth and #Startup hashtags.
    In this example, the co-occurrence is defined as a pair of hashtags co-occurring
    in the same tweet. Hence, on the right-hand side of the visualization, where the
    co-occurrence network is visualized, there is a relationship between the #Finance
    and the #Startup hashtags, as they appear in the same tweet. If you look at tweet
    D, you’ll notice it has three hashtags: #Data, #ML, and #NLP. Since the hashtags
    co-occur in the same tweet, there is a relationship between all three hashtags,
    as indicated on the right-hand side of figure 7.5.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5展示了基于原始推文和标签的二分网络构建标签共现网络的过程。在可视化的左侧是原始的二分网络。一条推文可以包含多个标签。例如，推文A包含#Growth和#Startup标签。在这个例子中，共现被定义为在同一个推文中同时出现的标签对。因此，在右侧的可视化中，即共现网络可视化的部分，#Finance和#Startup标签之间存在关系，因为它们出现在同一个推文中。如果你看推文D，你会注意到它有三个标签：#Data、#ML和#NLP。由于这些标签在同一个推文中共现，因此所有三个标签之间都有关系，如图7.5的右侧所示。
- en: '![07-05](../../OEBPS/Images/07-05.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![07-05](../../OEBPS/Images/07-05.png)'
- en: Figure 7.5 Constructing a co-occurrence network of tags based on whether they
    co-occur in the same tweet
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 基于标签在同一个推文中是否共现构建标签共现网络
- en: This data transformation can be described with the following Cypher statement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这项数据转换可以用以下Cypher语句来描述。
- en: Listing 7.1 Describing the construction of a hashtag co-occurrence network with
    a Cypher statement
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 使用Cypher语句描述构建标签共现网络的过程
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Hashtags are used to index or define the topic of a tweet. By analyzing the
    co-occurrence network of hashtags, you learn which hashtags often overlap and
    potentially fall under the same overall topic. Constructing a Twitter hashtag
    co-occurrence network was used in multiple studies. For example, you could analyze
    how hashtags help drive virality. One study (Pervin, 2015) concluded that the
    popularity of a hashtag rises when it co-occurs with similar hashtags. On the
    other hand, the popularity of a hashtag drops if dissimilar hashtags accompany
    it. Social networks like Twitter are becoming increasingly relevant for spreading
    information about present social movements or events. Researchers have identified
    strategic combinations of hashtags that can be used to help gain visibility from
    different social circles, thus increasing the virality of certain social movements
    (Wang et al., 2016; Gleason, 2013). Another paper studies how the hashtag co-occurrence
    connections differ from their semantic similarity (Türker & Sulak, 2018). Finally,
    one exciting article (Vitale, 2018) uses the hashtag co-occurrence network to
    provide novel information and trends regarding smoking habits.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 标签用于索引或定义推文的主题。通过分析标签的共现网络，你可以了解哪些标签经常重叠，并可能属于相同的整体主题。构建Twitter标签共现网络已在多项研究中使用。例如，你可以分析标签如何帮助推动病毒式传播。一项研究（Pervin，2015）得出结论，当标签与相似标签共现时，其流行度会上升。另一方面，如果标签与不相似的标签一起出现，其流行度会下降。像Twitter这样的社交网络在传播有关当前社会运动或事件的信息方面变得越来越重要。研究人员已经确定了可以用来帮助从不同的社交圈中获得可见性的标签组合策略，从而增加某些社会运动的病毒性（Wang等，2016；Gleason，2013）。另一篇论文研究了标签共现连接与它们的语义相似性之间的差异（Türker
    & Sulak，2018）。最后，一篇令人兴奋的文章（Vitale，2018）使用标签共现网络提供有关吸烟习惯的新信息和趋势。
- en: To find the most relevant groups of hashtags within the knowledge graph and
    natural language domain, you must first identify which hashtags are often used
    together and could potentially form a topic that reaches a specific audience of
    users. Here, you circle back to the previous hypothesis. If two hashtags frequently
    co-occur in the same tweet, you can assume they are related and fall under the
    same topic. To find communities or clusters of hashtags that form a topic, you
    can utilize community detection algorithms like the *label propagation algorithm*
    (LPA). The LPA is an algorithm to evaluate the community structure of a network.
    Most of the literature on the internet introduces the LPA as a semisupervised
    algorithm in which you can input initial communities for some nodes in the network.
    However, here you will use the unsupervised variant of the LPA, as you won’t present
    any initial communities. The unsupervised variant of the LPA works as follows.
    First, it assigns a unique community label to each node. Then, it iterates over
    the network and updates each node label to the one most of its neighbors have.
    The idea behind this iteration is that a single community label can quickly become
    dominant in a densely connected group of nodes. Once the LPA reaches convergence,
    the algorithm stops, and the resulting node labels represent their communities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在知识图谱和自然语言领域内找到最相关的标签组，你必须首先确定哪些标签经常一起使用，并且有可能形成一个针对特定用户群体的主题。在这里，你回到了之前的假设。如果两个标签在同一个推文中频繁共现，你可以假设它们是相关的，并属于同一主题。为了找到形成主题的标签社区或聚类，你可以利用社区检测算法，如*标签传播算法*（LPA）。LPA是一种评估网络社区结构的算法。互联网上的大部分文献都将LPA介绍为一种半监督算法，其中你可以为网络中某些节点的初始社区输入。然而，在这里，你将使用LPA的无监督变体，因为你不会提供任何初始社区。LPA的无监督变体工作如下。首先，它为每个节点分配一个唯一的社区标签。然后，它遍历网络，并将每个节点的标签更新为其大多数邻居所拥有的标签。这种迭代背后的想法是，单个社区标签可以迅速在紧密连接的节点组中占据主导地位。一旦LPA达到收敛，算法停止，结果节点标签代表它们的社区。
- en: 'Communities represent densely connected groups of nodes with sparser links
    between groups. For example, figure 7.6 shows two groups or communities of hashtags.
    The left community contains #Finance, #Growth, and #Startup hashtags. You could
    assign the left community as a more business-oriented topic. On the other side,
    the right community in figure 7.6 consists of #ML, #Data, and #NLP hashtags. Again,
    you could try to deduce the overall topic of the right community. In this example,
    something like a computer science or data science-oriented topic would fit.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 社区代表节点之间紧密连接的群体，群体之间则通过稀疏的链接相连。例如，图7.6展示了两个由标签组成的群体或社区。左侧的社区包含#Finance、#Growth和#Startup标签。你可以将左侧社区分配为一个更偏向商业化的主题。在图7.6的另一侧，右侧的社区由#ML、#Data和#NLP标签组成。同样，你可以尝试推断右侧社区的整体主题。在这个例子中，类似于计算机科学或数据科学导向的主题可能比较合适。
- en: '![07-06](../../OEBPS/Images/07-06.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![07-06](../../OEBPS/Images/07-06.png)'
- en: Figure 7.6 Identifying communities within the hashtag co-occurrence network
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 在标签共现网络中识别社区
- en: After you have identified communities of hashtags that form topics, you can
    use the PageRank algorithm to find the most central nodes within communities.
    Remember, we assume the co-occurrence between a pair of hashtags implies that
    they are somewhat related or similar. If you were to execute the PageRank algorithm
    on each community separately, you would identify the most central nodes of the
    communities. You can assume the most central nodes in the community are its representatives,
    as the PageRank algorithm treats every relationship as a vote. In the example
    of a hashtag co-occurrence network, it is a vote of similarity or relatedness.
    So the most similar hashtags to all the other hashtags in the community will rank
    the highest, which you can interpret as community representatives. To follow the
    exercises in this chapter, you need to have the Twitter network imported into
    the Neo4j database, as described in chapter 3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在你确定了形成主题的标签社区之后，你可以使用PageRank算法来找到社区中最中心的节点。记住，我们假设一对标签之间的共现意味着它们在某种程度上是相关或相似的。如果你要在每个社区分别执行PageRank算法，你会识别出社区中最中心的节点。你可以假设社区中最中心的节点是其代表，因为PageRank算法将每条关系视为一次投票。在标签共现网络示例中，这是一次相似度或相关性的投票。所以，与社区中所有其他标签最相似的标签将排名最高，你可以将其解释为社区代表。为了跟随本章的练习，你需要将Twitter网络导入到第3章中描述的Neo4j数据库中。
- en: 7.1 Extracting hashtags from tweets
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 从推文中提取标签
- en: Before you can infer the hashtag co-occurrence network, you first must extract
    hashtags from the tweet’s content. You will only extract hashtags from tweets
    that are not retweets, as the retweets have the same hashtags as the original
    tweets and would only skew the results. The process of extracting hashtags, shown
    in listing 7.2, is elementary text processing. You split the tweet text by the
    whitespace or newline characters to create a list of words. Then, you need to
    filter out words that start with a hashtag (`#`) sign. Once you have completed
    these two steps, you have successfully extracted hashtags from a tweet and can
    store them in the database.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够推断出标签共现网络之前，您首先必须从推文内容中提取标签。您只会从非转发推文中提取标签，因为转发推文与原始推文具有相同的标签，这只会扭曲结果。提取标签的过程，如列表7.2所示，是基本的文本处理。您通过空格或换行符分割推文文本，以创建一个单词列表。然后，您需要过滤掉以哈希符号（`#`）开头的单词。一旦完成这两个步骤，您就成功从推文中提取了标签，并且可以将它们存储在数据库中。
- en: Listing 7.2 Extracting hashtags from tweets that are not retweets
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 从非转发推文中提取标签
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Matches all tweets that are not retweets
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配所有非转发推文
- en: ❷ Replaces all newline characters with a whitespace
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将所有换行符替换为空格
- en: ❸ Splits the content of each tweet with a whitespace character to extract words
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用空格字符分割每条推文的内容以提取单词
- en: ❹ Uses list comprehension to filter words that start with the hashtag character
    and removes commas from hashtags
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用列表推导式过滤以哈希字符开头的单词，并从标签中删除逗号
- en: ❺ Filters tweets in which there is at least a one hashtag
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 过滤至少包含一个标签的推文
- en: Table 7.1 shows the extracted hashtags.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1显示了提取的标签。
- en: Table 7.1 Extracted hashtags
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 提取的标签
- en: '| Hashtags |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 标签 |'
- en: '| ["#mindset", "#nlp", "#meditation", "#heartmath", "#bioresonance", "#mindcoaching",
    "#anxiety", "#hypnosis", "#mentalhealth"] |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| ["#心态", "#自然语言处理", "#冥想", "#心算", "#生物共振", "#心智教练", "#焦虑", "#催眠", "#心理健康"]
    |'
- en: '| ["#sql", "#code", "#datascience", "#ai", "#ml", "#machinelearning", "#iot",
    "#iiot", "#iotpl", "#python", "#rstats", "#cloud", "#cybersecurity"] |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| ["#sql", "#代码", "#数据科学", "#人工智能", "#机器学习", "#机器学习", "#物联网", "#IIoT", "#物联网平台",
    "#python", "#rstats", "#云", "#网络安全"] |'
- en: '| ["#coaching", "#nlp", "#progressnotperfection", "#growthmindset", "#trainyourbrain",
    "#parentyourselffirst"] |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| ["#教练", "#自然语言处理", "#进步而非完美", "#成长心态", "#训练你的大脑", "#先养育自己"] |'
- en: '| ["#acl2021nlp"] |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ["#acl2021nlp"] |'
- en: '| ["#medium", "#machinelearning", "#nlp", "#deeplearning", "#autocorrect",
    "#spellcheck", "#ai", "#tds", "#python"] |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| ["#medium", "#机器学习", "#自然语言处理", "#深度学习", "#自动纠正", "#拼写检查", "#人工智能", "#tds",
    "#python"] |'
- en: Interestingly, the NLP hashtag refers to *natural language processing* in the
    tech community, while the personal development community uses NLP as an acronym
    for *neuro-linguistic programming*. While I was aiming to scrape only tweets around
    natural language processing and knowledge graph topics, it seems there are also
    some self-development tweets in the dataset. Having more diverse topics in your
    dataset is not a problem. It makes your analysis more interesting, as you will
    learn the driving hashtags behind more computer science-oriented topics, and you
    can later analyze self-help topics on your own.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，NLP标签在技术社区中指的是**自然语言处理**，而个人发展社区则将NLP作为**神经语言程序学**的缩写。虽然我旨在抓取关于自然语言处理和知识图谱主题的推文，但似乎数据集中也有一些自我提升的推文。数据集中有更多不同的主题并不是问题。这使得您的分析更有趣，因为您将了解更多计算机科学导向主题背后的驱动标签，并且您可以稍后自行分析自我帮助主题。
- en: 'Most marketing platforms allow you to specify keywords or hashtags and exclude
    undesired ones. Since your objective as a marketing analytics person is to design
    a targeting strategy on Twitter, you can also prepare a list of hashtags to be
    excluded. The company deals with NLP, so you would want to target the #nlp hashtag.
    You have learned that the #nlp hashtag is also popular in self-help topics, and
    since self-help topics are not relevant to the company, it makes sense to exclude
    the hashtags that fall under the self-help topics.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数营销平台允许您指定关键词或标签，并排除不需要的标签。由于您作为营销分析师的目标是在Twitter上设计定位策略，您也可以准备一个要排除的标签列表。该公司从事NLP业务，因此您会想定位到`#nlp`标签。您已经了解到`#nlp`标签在自我帮助主题中也非常流行，由于自我帮助主题与公司无关，排除属于自我帮助主题的标签是有意义的。
- en: The Cypher statement in listing 7.2 starts by matching all the tweets that don’t
    have an outgoing `RETWEETS` relationship. To create a list of words for each tweet,
    you use the combination of the `replace` and `split` functions. First, you use
    the `replace` function to replace all newline characters with whitespace characters.
    The syntax for the `replace` function is as follows.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2中的Cypher语句首先匹配所有没有出向`RETWEETS`关系的推文。为了为每条推文创建一个单词列表，你使用`replace`和`split`函数的组合。首先，你使用`replace`函数将所有换行符替换为空白字符。`replace`函数的语法如下。
- en: Listing 7.3 `replace` function syntax
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 `replace`函数语法
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`replace` is a basic function in most scripting languages and query language,
    so I hope it doesn’t need any additional explanation. Similarly, `split` is also
    a very basic function and has the following syntax.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace`是大多数脚本语言和查询语言中的一个基本函数，因此我希望它不需要任何额外的解释。同样，`split`也是一个非常基本的函数，其语法如下。'
- en: Listing 7.4 `split` function syntax
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 `split`函数语法
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The input to the `split` function is a string and a delimiter character, while
    the output is a list of elements; again, a basic function available in most, if
    not all, programming languages. The last thing to do is to filter words that start
    with a hashtag (`#`) character. You can filter out hashtags from the list of words
    by using the *list comprehension* syntax, shown in the following listing. At first
    sight, it seems that the list comprehension function took some inspiration from
    the Python syntax.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`函数的输入是一个字符串和一个分隔符字符，输出是一个元素列表；再次强调，这是大多数（如果不是所有）编程语言中可用的一项基本功能。最后要做的就是过滤以`#`字符开头的单词。你可以使用以下列表推导式语法来从单词列表中过滤掉标签。乍一看，似乎列表推导式函数从Python语法中汲取了一些灵感。'
- en: Listing 7.5 List comprehension syntax
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 列表推导式语法
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The list comprehension syntax is wrapped by square brackets. The `element`
    `IN` `list` syntax is used to define a variable to reference an element in the
    list. Unlike Python, element manipulation and transformation can be defined right
    after the pipe `|` character instead of directly in the variable assignment. You
    have removed commas and lowercased the text in the element transformation part
    of the list comprehension syntax to not differentiate between #NLP and #nlp hashtags.
    You can also filter items in the list by using the `WHERE` clause.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式语法被方括号包围。使用`element IN list`语法来定义一个变量以引用列表中的元素。与Python不同，元素操作和转换可以直接在管道`|`字符之后定义，而不是直接在变量赋值中。你在列表推导式语法的元素转换部分去除了逗号并将文本转换为小写，以避免区分#NLP和#nlp标签。你也可以使用`WHERE`子句来过滤列表中的项目。
- en: Finally, you use the `size()` function to filter tweets with at least a single
    hashtag. The `size()` function returns the number of items in a list. In the previous
    chapter, you learned to use the `size()` function to access the node degree in
    an optimized way, but it can also be used to count the length of a list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用`size()`函数来过滤至少包含一个标签的推文。`size()`函数返回列表中的项目数。在前一章中，你学习了如何以优化的方式使用`size()`函数来访问节点度，但它也可以用来计算列表的长度。
- en: Before continuing with the co-occurrence analysis, you will extract hashtags
    and store them in the database. Every time you add a new node label in the database,
    it is advisable to identify the unique property of the node and define a unique
    constraint. With the hashtags, each node should represent a single hashtag, so
    you can simply define a unique constraint on the `id` property of `Tag` nodes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行共现分析之前，你将提取标签并将其存储在数据库中。每次你在数据库中添加一个新的节点标签时，建议识别节点的唯一属性并定义唯一约束。对于标签，每个节点应代表一个单独的标签，因此你可以在`Tag`节点的`id`属性上简单地定义唯一约束。
- en: Listing 7.6 Defining a unique constraint for `Tag` nodes on the `id` property
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 在`id`属性上为`Tag`节点定义唯一约束
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, you can execute the following Cypher statement to extract and store
    hashtags in the database.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以执行以下Cypher语句来提取并存储标签到数据库中。
- en: Listing 7.7 Extracting hashtags and storing them in the database
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7 提取标签并存储到数据库中
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Transforming a list of elements into individual rows with the UNWIND clause
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用UNWIND子句将元素列表转换为单独的行
- en: The Cypher statement in listing 7.7 introduces the `UNWIND` clause. The `UNWIND`
    clause is used to transform a list of elements into rows, similar to a `FOR` loop
    in various scripting languages. Essentially, you iterate over each element in
    the list and, in this case, merge a `Tag` node and connect it to the `Tweet` node.
    The `UNWIND` clause is always followed by the `AS` operator to assign a reference
    variable to the element value in the produced rows. The following Cypher statement
    demonstrates a simple usage of the `UNWIND` clause.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 中的 Cypher 语句引入了 `UNWIND` 子句。`UNWIND` 子句用于将元素列表转换为行，类似于各种脚本语言中的 `FOR`
    循环。本质上，您会遍历列表中的每个元素，在这种情况下，合并一个 `Tag` 节点并将其连接到 `Tweet` 节点。`UNWIND` 子句始终跟随着 `AS`
    操作符，以将生成的行中的元素值分配给引用变量。以下 Cypher 语句演示了 `UNWIND` 子句的简单用法。
- en: Listing 7.8 `UNWIND` clause syntax
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 `UNWIND` 子句语法
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Table 7.2 shows the elements displayed as rows.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 显示了作为行显示的元素。
- en: Table 7.2 The UNWIND clause transforming a list of elements into rows
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 将元素列表转换为行的 UNWIND 子句
- en: '| `i` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `i` |'
- en: '| 1 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 1 |'
- en: '| 2 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 2 |'
- en: '| 3 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 3 |'
- en: Exercise 7.1
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.1
- en: Hashtags are now stored and connected to the `Tweet` nodes in the database.
    Before jumping to the co-occurrence analysis, investigate which hashtags appear
    in most tweets and retweets. Remember, you only stored hashtags for original tweets
    (not retweets) in the database. Therefore, first, match the original tweets in
    which the hashtags appeared. Next, count how many times those tweets were retweeted,
    and then return the top five hashtags by the sum of combined counts of original
    tweets and retweets. Since not all tweets are retweeted, use the `OPTIONAL` `MATCH`
    to count the number of retweets.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标签现在已存储并连接到数据库中的 `Tweet` 节点。在跳转到共现分析之前，调查哪些标签出现在最多的推文和转发中。记住，您只在数据库中存储了原始推文的标签（不是转发）。因此，首先匹配出现标签的原始推文。接下来，计算这些推文被转发的次数，然后返回原始推文和转发总计数之和最高的前五个标签。由于并非所有推文都被转发，使用
    `OPTIONAL` `MATCH` 来计算转发次数。
- en: Table 7.3 shows the most popular hashtags.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.3 显示了最受欢迎的标签。
- en: Table 7.3 The most popular hashtags in tweets and retweets
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.3 推文和转发中最受欢迎的标签
- en: '| `hashtag` | `originalTweetsCount` | `retweetCount` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `hashtag` | `originalTweetsCount` | `retweetCount` |'
- en: '| #nlp | 1,848 | 7,532 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| #nlp | 1,848 | 7,532 |'
- en: '| #ai | 1,554 | 7,169 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| #ai | 1,554 | 7,169 |'
- en: '| #machinelearning | 1,474 | 7,007 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| #machinelearning | 1,474 | 7,007 |'
- en: '| #datascience | 1,455 | 6,736 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| #datascience | 1,455 | 6,736 |'
- en: '| #bigdata | 1,358 | 6,577 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| #bigdata | 1,358 | 6,577 |'
- en: 'The most popular hashtags are #nlp, #ai, #machinelearning, and #datascience.
    Judging by the retweet count, they must frequently co-occur in the same tweets,
    as there are 12,000 tweets and retweets in total. Next, you will proceed with
    the co-occurrence part of the hashtag analysis.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '最受欢迎的标签是 #nlp、#ai、#machinelearning 和 #datascience。根据转发计数，它们必须在同一推文中频繁共同出现，因为总共有
    12,000 条推文和转发。接下来，您将进行标签分析的共现部分。'
- en: 7.2 Constructing the co-occurrence network
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 构建共现网络
- en: You can use Cypher query language to evaluate which hashtags most frequently
    co-occur.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Cypher 查询语言来评估哪些标签最频繁地共同出现。
- en: Exercise 7.2
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.2
- en: Evaluate which hashtags most frequently co-occur. Use the `MATCH` clause to
    define a graph pattern where two hashtags are present in the same tweet, and then
    use the `count()` function to count the number of tweets in which a pair of hashtags
    co-occur. Return only the top five most co-occurring pairs of hashtags.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 评估哪些标签最频繁地共同出现。使用 `MATCH` 子句定义一个图模式，其中两个标签出现在同一推文中，然后使用 `count()` 函数计算一对标签共同出现的推文数量。仅返回最常见的五个共同出现的标签对。
- en: The solution to exercise 7.2 is as follows.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.2 的解决方案如下。
- en: Listing 7.9 Examining the top five most co-occurring pairs of hashtags
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 检查最常见的五个共同出现的标签对
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Removing duplicates from the results
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从结果中删除重复项
- en: Table 7.4 shows the most frequently co-occurring pairs of hashtags.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.4 显示了最常见的共同出现的标签对。
- en: Table 7.4 Top five most frequently co-occurring pairs of hashtags
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.4 最常见的五个共同出现的标签对
- en: '| `tag1` | `tag2` | `cooccurrences` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `tag1` | `tag2` | `cooccurrences` |'
- en: '| #ai | #nlp | 1,507 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| #ai | #nlp | 1,507 |'
- en: '| #machinelearning | #nlp | 1,428 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| #machinelearning | #nlp | 1,428 |'
- en: '| #datascience | #nlp | 1,410 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| #datascience | #nlp | 1,410 |'
- en: '| #ai | #machinelearning | 1,410 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| #ai | #machinelearning | 1,410 |'
- en: '| #datascience | #ai | 1,405 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| #datascience | #ai | 1,405 |'
- en: Exercise 7.2 did not mention that you should, ideally, remove duplicates from
    the output, as you haven’t learned how to do that yet. Since every hashtag will
    appear as the `h1` variable as well as the `h2` variable, the results will contain
    duplicates. The strategy of deduplicating results with the `id(h1)` `<` `id(h2)`
    is the most commonly used that I’ve seen in practice.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 练习7.2没有提到理想情况下你应该从输出中移除重复项，因为你还没有学到如何做到这一点。由于每个标签号都将作为`h1`变量以及`h2`变量出现，结果将包含重复项。使用`id(h1)`
    `<` `id(h2)`来去重结果是最常见的策略，我在实践中也经常看到。
- en: You could use a similar Cypher statement to project the co-occurrence network
    with Cypher projection. The resulting co-occurrence network based on the Cypher
    statement in listing 7.9 would look like figure 7.1.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似的Cypher语句使用Cypher投影来投影共现网络。基于列表7.9中的Cypher语句生成的共现网络将类似于图7.1。
- en: 'Figure 7.7 shows a sample hashtag co-occurrence network, where the relationship
    weight represents the count of co-occurrences. You might wonder why there are
    two relationships between each pair of nodes in the opposite direction. If #NLP
    co-occurs with hashtag #AI, that directly implies that hashtag #AI also co-occurs
    with hashtag #NLP. In the context of graphs, you could say that the `CO_OCCUR`
    relationship is undirected, as the direction of the connection is not essential.
    However, the Graph Data Science (GDS) library has no concept of undirected relationships.
    A key concept behind an undirected relationship is that it allows traversals in
    both directions. You can replicate this functionality in a directed network by
    transforming a single undirected connection into two directed links that point
    in the opposite direction.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7展示了样本标签共现网络，其中关系权重代表共现次数。你可能会想知道为什么每个节点对之间有两个指向相反方向的关系。如果#NLP与标签#AI共现，这直接意味着标签#AI也与标签#NLP共现。在图论中，你可以认为`CO_OCCUR`关系是无向的，因为连接的方向并不重要。然而，图数据科学（GDS）库没有无向关系的概念。无向关系背后的一个关键概念是它允许双向遍历。你可以在有向网络中通过将单个无向连接转换为两个指向相反方向的定向链接来复制这种功能。
- en: '![07-07](../../OEBPS/Images/07-07.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![07-07](../../OEBPS/Images/07-07.png)'
- en: Figure 7.7 Sample weighted and undirected co-occurrence network
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 样本加权无向共现网络
- en: Note The GDS library has no notion of undirected relationships. When dealing
    with an undirected network in GDS, you represent each relationship in the network
    as two directed relationships that point in the opposite direction. In the node
    similarity algorithm example, the algorithm’s output is an undirected network,
    where each undirected relationship is represented as two directed relationships,
    as shown in figure 7.8\. The GDS library also allows transforming a single relationship
    into two relationships that point in the opposite direction during projection
    time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：GDS库没有无向关系的概念。当在GDS中处理无向网络时，你将网络中的每个关系表示为两个指向相反方向的定向关系。在节点相似度算法示例中，算法的输出是一个无向网络，其中每个无向关系都表示为两个定向关系，如图7.8所示。GDS库还允许在投影时间将单个关系转换为两个指向相反方向的链接。
- en: '![07-08](../../OEBPS/Images/07-08.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![07-08](../../OEBPS/Images/07-08.png)'
- en: Figure 7.8 A single undirected relationship represented as two directed relationships
    that point in the opposite direction
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 表示为两个指向相反方向的定向关系的单一无向关系
- en: 7.2.1 Jaccard similarity coefficient
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 Jaccard相似系数
- en: While there is nothing wrong with using the count of co-occurrences as the relationship
    weight, a more common approach is to use the *Jaccard similarity coefficient*
    to evaluate the similarity between nodes. The Jaccard similarity coefficient is
    simple to understand, as it only involves dividing the intersection by the union
    of two sets.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用共现次数作为关系权重没有问题，但更常见的方法是使用*Jaccard相似系数*来评估节点之间的相似度。Jaccard相似系数很容易理解，因为它只涉及将两个集合的交集除以并集。
- en: Figure 7.9 visualizes two baskets, where each basket contains a set of products.
    For example, basket A includes a couch, speakers, phone, and TV, while basket
    B contains a phone, TV, and headphones. If you want to calculate the Jaccard similarity
    coefficient between the two baskets, you first calculate the intersection and
    union of the two sets of products. Both baskets contain a phone and TV, the intersection
    of the two sets. There are five different products spread across both baskets,
    which is the union of the two sets. To calculate the Jaccard similarity coefficient,
    you simply divide the intersection (2) by the union (5) of the two sets, which
    results in 0.4\. The added benefit of the Jaccard similarity coefficient is that
    it provides a metric that can be used to evaluate—in this example, how similar
    two baskets are based on their products.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9可视化两个篮子，其中每个篮子包含一组产品。例如，篮子A包括沙发、扬声器、手机和电视，而篮子B包含手机、电视和耳机。如果你想计算两个篮子之间的Jaccard相似系数，你首先计算两个产品集合的交集和并集。两个篮子都包含手机和电视，这是两个集合的交集。在两个篮子中分散着五种不同的产品，这是两个集合的并集。要计算Jaccard相似系数，你只需将两个集合的交集（2）除以并集（5），结果为0.4。Jaccard相似系数的附加好处是它提供了一个可以用来评估的指标——在这个例子中，基于产品评估两个篮子的相似程度。
- en: '![07-09](../../OEBPS/Images/07-09.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![07-09](../../OEBPS/Images/07-09.png)'
- en: Figure 7.9 An example of two baskets with overlapping products
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 两个具有重叠产品的篮子的示例
- en: Jaccard similarity coefficient ranges from values 0 to 1\. When there is no
    intersection of members between two sets, the Jaccard similarity coefficient equals
    0\. For example, let’s say basket A contains a sandwich and juice, while basket
    B contains a TV. There is no intersection of items between baskets A and B, which
    consequently indicates that the Jaccard similarity coefficient between the two
    baskets is 0\. On the other hand, the Jaccard similarity coefficient between two
    sets with identical members is 1\. When two sets have the Jaccard similarity coefficient
    of 1, it implies the two sets have the same number of members, with identical
    members in both sets. In this example, both baskets A and B contain a sandwich
    and juice. However, if you were to add or remove any item from either basket,
    the Jaccard similarity would no longer be 1\. The process of evaluating the hashtag
    overlap with the Jaccard similarity coefficient is shown in figure 7.10.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Jaccard相似系数的范围是0到1。当两个集合的成员之间没有交集时，Jaccard相似系数等于0。例如，假设篮子A包含三明治和果汁，而篮子B包含电视。篮子A和B之间没有项目的交集，这进而表明两个篮子之间的Jaccard相似系数为0。另一方面，具有相同成员的两个集合的Jaccard相似系数为1。当两个集合的Jaccard相似系数为1时，这意味着两个集合具有相同数量的成员，且两个集合中的成员相同。在这个例子中，篮子A和B都包含三明治和果汁。然而，如果你在任一篮子中添加或删除任何项目，Jaccard相似系数将不再为1。使用Jaccard相似系数评估标签重叠的过程如图7.10所示。
- en: '![07-10](../../OEBPS/Images/07-10.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![07-10](../../OEBPS/Images/07-10.png)'
- en: Figure 7.10 Using the Jaccard similarity coefficient to examine hashtag overlap
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 使用Jaccard相似系数检查标签重叠
- en: 'In a graph context, a typical input to the Jaccard similarity algorithm is
    a bipartite network consisting of two types or sets of nodes. The idea behind
    using the Jaccard similarity algorithm is to project a monopartite graph based
    on the bipartite input graph. Figure 7.10 shows the process to transform a network
    consisting of tweets and hashtags to a monopartite network of hashtags based on
    how many tweets they have in common. The process is the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论背景下，Jaccard相似系数算法的典型输入是由两种类型或集合的节点组成的二分网络。使用Jaccard相似系数算法背后的想法是基于二分输入图投影一个单分图。图7.10显示了将包含推文和标签的网络转换为基于它们共同拥有的推文数量形成的单分标签网络的转换过程。这个过程如下：
- en: For each hashtag, you first collect the set of tweets in which it appeared.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个标签，你首先收集包含它的推文集合。
- en: In the next step, you iterate over each pair of hashtags and calculate the Jaccard
    similarity coefficient by dividing the intersection of the two sets by their union.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一步中，你遍历每一对标签，通过将两个集合的交集除以它们的并集来计算Jaccard相似系数。
- en: Finally, you have the option to store the similarity coefficient between a pair
    of nodes in the form of a relationship.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以选择将一对节点之间的相似系数以关系的形式存储。
- en: The semantics of the inferred relationships depends on the domain. You could
    choose the `CO_OCCUR` type of relationships in the hashtag example. In the basket
    example, the inferred relationship could have a `SIMILAR` type.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 推断关系的语义取决于领域。在标签示例中，你可以选择`CO_OCCUR`类型的关系。在篮子示例中，推断的关系可能具有`SIMILAR`类型。
- en: The Jaccard similarity coefficient is a symmetric similarity metric. If node
    A is similar to node B, that directly implies node B is similar to node A. Like
    the preceding Cypher projection example, the resulting co-occurrence or similarity
    network will be undirected. Also, you can store the resulting Jaccard similarity
    coefficient between nodes as relationship properties.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Jaccard相似度系数是一种对称相似度度量。如果节点A与节点B相似，这直接意味着节点B与节点A相似。就像前面的Cypher投影示例一样，生成的共现或相似度网络将是无向的。此外，你还可以将节点之间的Jaccard相似度系数存储为关系属性。
- en: 7.2.2 Node similarity algorithm
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 节点相似度算法
- en: Since the Jaccard similarity coefficient can be used to evaluate how similar
    a pair of nodes are, the GDS developers decided it made sense to name the algorithm
    the *node similarity algorithm*. The node similarity algorithm compares sets of
    nodes based on their neighbors using the Jaccard similarity coefficient or the
    overlap coefficient. A typical input is a bipartite network consisting of two
    types of nodes. Nodes with outgoing relationships are being compared, while their
    outgoing neighbors are used to construct the comparison set. Figure 7.11 shows
    a simple network of users and musical genres.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jaccard相似度系数可以用来评估一对节点之间的相似程度，因此GDS开发者决定将其命名为*节点相似度算法*。节点相似度算法通过Jaccard相似度系数或重叠系数，根据节点的邻居来比较节点集合。一个典型的输入是由两种类型节点组成的二分网络。正在比较的是具有输出关系的节点，而它们的输出邻居被用来构建比较集。图7.11显示了用户和音乐类型的简单网络。
- en: '![07-11](../../OEBPS/Images/07-11.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![07-11](../../OEBPS/Images/07-11.png)'
- en: Figure 7.11 How the node similarity algorithm constructs comparison sets and
    evaluates similarity
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 节点相似度算法如何构建比较集并评估相似度
- en: The `LISTENS` relationships are directed from users to genres. In this scenario,
    the node similarity algorithm will compare users based on their outgoing neighborhood,
    which consists of the musical genres they are listening to. Realizing which nodes
    are being compared by the node similarity algorithm is crucial to executing the
    algorithm correctly. In our Twitter social network, the `HAS_TAG` relationships
    point from `Tweet` to `Tag` nodes. If you were to avoid reversing the direction
    of the relationship, you would effectively be comparing tweets based on how many
    tags they have in common. The GDS library allows reversing the relationship direction
    during projection, so you don’t have to transform the underlying stored graph.
    When you want to transform the relationship direction during projection, you need
    to use the configuration map syntax to describe the projected relationships, as
    shown in the following listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`LISTENS`关系是从用户指向音乐类型的。在这种情况下，节点相似度算法将根据用户的输出邻居（即他们正在收听的音乐类型）来比较用户。意识到节点相似度算法正在比较哪些节点对于正确执行算法至关重要。在我们的Twitter社交网络中，`HAS_TAG`关系是从`Tweet`节点指向`Tag`节点。如果你避免反转关系方向，你实际上会根据它们有多少共同标签来比较推文。GDS库允许在投影期间反转关系方向，因此你不需要转换底层存储的图。当你想在投影期间转换关系方向时，你需要使用配置映射语法来描述投影关系，如下所示。'
- en: Listing 7.10 Configuration map to describe the relationship type and its orientation
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.10 描述关系类型及其方向的配置映射
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead of simply specifying the relationship as a string, you need to construct
    a relationship configuration map. The `ALIAS_OF_TYPE` key specifies under which
    name the projected relationship will be available in the in-memory graph. The
    alias doesn’t need be identical to relationship types stored in the database.
    Each alias key has a value that consists of a map describing which relationship
    types should be projected, their orientation, and optional properties. You can
    manipulate and transform the relationship direction with the `orientation` key.
    It has three possible values:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是简单地用字符串指定关系，你需要构建一个关系配置映射。`ALIAS_OF_TYPE`键指定了投影关系将在内存图中以哪个名称可用。别名不需要与数据库中存储的关系类型相同。每个别名键都有一个值，该值由一个映射描述，说明哪些关系类型应该被投影，它们的方向以及可选属性。你可以使用`orientation`键来操作和转换关系方向。它有三个可能的值：
- en: '`NATURAL`—Each relationship is projected the same way as it is stored in the
    database.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NATURAL`—每个关系以与在数据库中存储相同的方式被投影。'
- en: '`REVERSE`—Each relationship is reversed during graph projection.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REVERSE`—在图投影过程中，每个关系都被反转。'
- en: '`UNDIRECTED`—Each relationship is projected in both natural and reverse orientation.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNDIRECTED`—每个关系在自然方向和反向方向都被投影。'
- en: With the `orientation` configuration, you have the option to project the relationship
    as is, reverse its direction, or treat it as undirected. As mentioned, to treat
    a relationship as undirected, the engine simply duplicates the relationship in
    the opposite direction.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`orientation`配置，你可以选择按原样投影关系、反转其方向，或将其视为无向的。如前所述，为了将关系视为无向的，引擎只需在相反方向上复制该关系。
- en: Moving on to the hashtag co-occurrence task, you need to project both `Tweet`
    and `Tag` nodes and include the `HAS_TAG` relationship with a reversed direction.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来进行标签共现任务，你需要投影`Tweet`和`Tag`节点，并包括反向方向的`HAS_TAG`关系。
- en: Listing 7.11 Projects `Tweet` and `Tag` nodes and includes reversed `HAS_TAG`
    relationships
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11 投影`Tweet`和`Tag`节点并包含反向的`HAS_TAG`关系
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Projected graph name
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 投影的图名称
- en: ❷ Projects multiple node labels using list syntax
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用列表语法投影多个节点标签
- en: ❸ Projects reversed HAS_TAG relationships
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 投影反向的HAS_TAG关系
- en: Listing 7.11 introduces two new native projection syntax options. First, you
    can specify multiple node labels to be projected using a list. In listing 7.11,
    you described both `Tweet` and `Tag` nodes to be projected. Second, you used the
    configuration map syntax to describe the projected relationships. The projected
    relationships will be available under the `REVERSED_HAS_TAG` alias and contain
    `HAS_TAG` connections with a reversed relationship direction.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11介绍了两种新的原生投影语法选项。首先，你可以使用列表指定要投影的多个节点标签。在列表7.11中，你描述了要投影的`Tweet`和`Tag`节点。其次，你使用了配置映射语法来描述投影的关系。投影的关系将在`REVERSED_HAS_TAG`别名下可用，并包含反向关系方向的`HAS_TAG`连接。
- en: Now that you have the network of tweets and hashtags projected, you can use
    the node similarity algorithm to infer a monopartite network. You can affect how
    dense or sparse the inferred network will be with `topK` and `similarityCutoff`
    parameters of the node similarity algorithm. The `similarityCutoff` parameter
    defines the threshold value of the Jaccard similarity coefficient between a pair
    of nodes that are still regarded as similar. For example, if the `similarityCutoff`
    is 0.5, then the relationships will be considered only between the pairs of nodes
    with a Jaccard similarity score of 0.5 or higher. On the other hand, the `topK`
    parameter specifies the limit on the number of similar relationships per node.
    As you can directly affect how many relationships should be stored with the `topK`
    and the `similarityCutoff` parameters, you consequently describe how sparse or
    dense the inferred co-occurrence network will be.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将推文和标签的网络投影出来，你可以使用节点相似度算法来推断一个单部分网络。你可以通过节点相似度算法的`topK`和`similarityCutoff`参数来影响推断网络的密集程度或稀疏程度。`similarityCutoff`参数定义了被视为相似的一对节点之间的Jaccard相似系数的阈值值。例如，如果`similarityCutoff`是0.5，那么只有Jaccard相似度分数为0.5或更高的节点对之间的关系将被考虑。另一方面，`topK`参数指定了每个节点相似关系的数量限制。由于你可以直接通过`topK`和`similarityCutoff`参数来影响应该存储多少关系，因此你相应地描述了推断的共现网络的稀疏程度或密集程度。
- en: Defining how sparse or dense the inferred co-occurrence network between hashtags
    should be will directly correlate with how broad the communities of hashtags that
    form a topic will be. For example, if you use the `topK` value of 1, each node
    will have only a single outgoing relationship to its most similar neighbor. However,
    if you were to increase the `topK` value to 2, each node would have two outgoing
    relationships that specify which two nodes are the most similar to it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 定义标签共现网络的稀疏程度或密集程度将直接关联到形成主题的标签社区的范围。例如，如果你使用`topK`值为1，每个节点将只有一个指向其最相似邻居的出度关系。然而，如果你将`topK`值增加到2，每个节点将有两个出度关系，指定了哪两个节点是最相似的。
- en: 'Figure 7.12 shows a comparison of inferred co-occurrence networks if different
    `topK` values are used. As mentioned, the input to the node similarity algorithm
    is usually a bipartite network. In this example, you have a bipartite network
    of tweets and hashtags. The node similarity algorithm will then evaluate how similar
    the hashtags are based on the number of tweets they appear in together. Once the
    Jaccard similarity coefficient between pairs of hashtags is calculated, the algorithm
    will output the results as relationships between hashtags. You can observe a co-occurrence
    network with the `topK` value of 1 on the left-hand side of figure 7.12\. Using
    the `topK` value of 1, each hashtag will have a single outgoing relationship,
    indicating its most similar hashtag. The resulting co-occurrence network on the
    left-hand side of figure 7.12 has eight nodes and eight relationships. For example,
    the #data hashtag is the most similar to the #datascience hashtag. Even though
    I previously stated that the Jaccard similarity coefficient is a symmetric similarity
    metric, the #datascience hashtag does not have a reverse relationship to the #data
    hashtag. Why is that so? The reason is that once you apply a `topK` filter to
    the node similarity algorithm, you lose the guarantee that all relationships will
    be symmetric. If you were to set the `topK` value to the number of the nodes in
    the inferred co-occurrence network, all relationships would be symmetric.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12展示了使用不同`topK`值时推断出的共现网络的比较。如前所述，节点相似度算法的输入通常是一个二分网络。在这个例子中，您有一个由推文和标签组成的二分网络。节点相似度算法将根据它们共同出现的推文数量来评估标签之间的相似度。一旦计算出标签对之间的Jaccard相似度系数，算法将输出标签之间的关系。您可以在图7.12的左侧观察到`topK`值为1的共现网络。使用`topK`值为1，每个标签将有一个单一的输出关系，表示其最相似的标签。图7.12左侧的共现网络有八个节点和八个关系。例如，#data标签与#datascience标签最相似。尽管我之前提到Jaccard相似度系数是一个对称的相似度度量，但#datascience标签并没有与#data标签的逆向关系。为什么是这样呢？原因是，一旦您对节点相似度算法应用`topK`过滤器，您就会失去所有关系都是对称的保证。如果您将`topK`值设置为推断出的共现网络中的节点数量，所有关系都将是对称的。
- en: '![07-12](../../OEBPS/Images/07-12.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![07-12](../../OEBPS/Images/07-12.png)'
- en: Figure 7.12 Comparison of how different `topK` values affect the density of
    the resulting co-occurrence network
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 不同`topK`值对结果共现网络的密度影响比较
- en: Returning to your scenario, once the co-occurrence network is created, the idea
    is to use an algorithm like the label propagation algorithm to find communities
    of tightly connected hashtags. A *community* is defined as a group of densely
    interconnected nodes that might have sparser connections with other groups. When
    using a lower `topK` value, there will be fewer connections in the inferred co-occurrence
    network. Consequently, the size of communities will be smaller, as there will
    be fewer densely interconnected nodes. Since the communities will be smaller,
    there will be more of them throughout the network. You defined that each community
    of hashtags will be regarded as a single topic. Therefore, by adjusting the `topK`
    value of the node similarity algorithm, you are essentially influencing how large
    the resulting communities of hashtags will be. The larger the community of hashtags
    is, the broader the resulting topic will be. When the communities of hashtags
    are larger, you might produce a less-granular targeting strategy. On the other
    hand, using a smaller `topK` value would help you find smaller communities of
    hashtags and, consequently, devise a narrower marketing strategy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 回到您的场景，一旦创建了共现网络，想法是使用标签传播算法等算法来找到紧密连接的标签社区。一个**社区**被定义为密集互联的节点群，这些节点群可能与其他群体有较稀疏的连接。当使用较低的`topK`值时，推断出的共现网络中的连接会更少。因此，社区的大小会变小，因为密集互联的节点会更少。由于社区会更小，整个网络中会有更多的社区。您定义了每个标签社区将被视为一个单一主题。因此，通过调整节点相似度算法的`topK`值，您实际上是在影响结果标签社区的大小。标签社区越大，结果主题就越广泛。当标签社区较大时，您可能会产生一个更粗粒度的定位策略。另一方面，使用较小的`topK`值将有助于您找到较小的标签社区，从而制定更窄的营销策略。
- en: 'In figure 7.12, you can observe that when using a `topK` value of 1, the community
    detection algorithm identified two communities in the resulting co-occurrence
    network. One community consists of #ai, #datascience, #data, and #blockchain hashtags,
    while the other community contains #ml, #graph, #network, #algorithm. When you
    use a higher `topK` value, the resulting co-occurrence network will be more interconnected,
    and consequently, a community detection algorithm will identify larger communities.
    A larger community of hashtags will result in broader topics, in your use case.
    On the right-hand side of figure 7.12, you can observe that using a `topK` value
    of 2 produces a more densely connected co-occurrence network. Since the nodes
    are more densely connected, a community detection algorithm identified larger
    and fewer communities. In figure 7.12, the algorithm identified only a single
    community of hashtags when using a higher `topK` value of 2.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '在图 7.12 中，你可以观察到当使用 `topK` 值为 1 时，社区检测算法在结果共现网络中识别出两个社区。一个社区包括 #ai、#datascience、#data
    和 #blockchain 标签，而另一个社区包含 #ml、#graph、#network 和 #algorithm。当你使用更高的 `topK` 值时，结果共现网络将更加互联互通，因此社区检测算法将识别出更大的社区。在你的用例中，更大的标签社区将导致更广泛的话题。在图
    7.12 的右侧，你可以观察到使用 `topK` 值为 2 产生了一个更密集连接的共现网络。由于节点连接更加密集，社区检测算法识别出更大且数量更少的社区。在图
    7.12 中，当使用更高的 `topK` 值为 2 时，算法仅识别出一个标签社区。'
- en: Defining the `topK` parameter and the `similarityCutoff` parameter is a mix
    of science and art and depends on your use case. By default, the `topK` parameter
    value is 10 and the `similarityCutoff` is 1E-42, just slightly above zero. You
    can evaluate how dense the inferred network would be with default parameter values
    using the `stats` mode of the node similarity algorithm.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `topK` 参数和 `similarityCutoff` 参数是科学与艺术的结合，并且取决于你的用例。默认情况下，`topK` 参数值为 10，`similarityCutoff`
    为 1E-42，略高于零。你可以使用节点相似度算法的 `stats` 模式评估默认参数值下推断网络的密集程度。
- en: Listing 7.12 Evaluating the Jaccard coefficient distribution with default parameters
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 使用默认参数评估 Jaccard 系数的分布
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Table 7.5 shows the resulting distribution.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.5 展示了结果分布。
- en: Table 7.5 Similarity distribution of the node similarity algorithm with default
    parameters
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.5 使用默认参数的节点相似度算法的相似度分布
- en: '| `nodesCompared` | `similarityPairs` | `similarityDistribution` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `nodesCompared` | `similarityPairs` | `similarityDistribution` |'
- en: '| 2,093 | 13,402 | { "p1": 0.0005411244928836823,"max": 1.000007625669241,"p50":
    0.4400005303323269,"p10": 0.007575776427984238,"p75": 1.000007625669241,"p25":
    0.11111116036772728,"mean": 0.4971548691088963,"stdDev": 0.39913025157864984 }
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 2,093 | 13,402 | { "p1": 0.0005411244928836823,"max": 1.000007625669241,"p50":
    0.4400005303323269,"p10": 0.007575776427984238,"p75": 1.000007625669241,"p25":
    0.11111116036772728,"mean": 0.4971548691088963,"stdDev": 0.39913025157864984 }
    |'
- en: Executing the node similarity algorithm with default parameters would create
    13,402 relationships between 2,093 hashtags. The average similarity score of those
    relationships is 0.49\. Note that this distribution summary does not include the
    similarity score between all pairs of nodes but only for the top 10 similar neighbors
    of a node, as that is the default `topK` value. Interestingly, the median value
    (`p50`) is close to the average similarity value, and around 25% of relationships
    have the maximum possible similarity score of 1\. When the similarity score is
    1, a pair of hashtags are always together in a tweet. You can use the `similarityCutoff`
    parameter to exclude relationships between pairs of hashtags with a similarity
    score lower than the threshold.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认参数执行节点相似度算法将在 2,093 个标签之间创建 13,402 个关系。这些关系的平均相似度得分为 0.49。请注意，此分布摘要不包括所有节点对之间的相似度得分，而仅包括节点的
    top 10 个相似邻居的得分，因为这是默认的 `topK` 值。有趣的是，中位数值 (`p50`) 接近平均相似度值，大约 25% 的关系具有最大可能的相似度得分
    1。当相似度得分为 1 时，一对标签总是在一条推文中一起出现。你可以使用 `similarityCutoff` 参数排除相似度得分低于阈值的标签对之间的关系。
- en: Listing 7.13 Using the `similarityCutoff` parameter to define the similarity
    score threshold
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13 使用 `similarityCutoff` 参数定义相似度得分阈值
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Table 7.6 shows the resulting distribution.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.6 展示了结果分布。
- en: Table 7.6 Similarity distribution of the node similarity algorithm using the
    `similarityCutoff` parameter
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.6 使用 `similarityCutoff` 参数的节点相似度算法的相似度分布
- en: '| `nodesCompared` | `similarityPairs` | `similarityDistribution` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `nodesCompared` | `similarityPairs` | `similarityDistribution` |'
- en: '| 2,093 | 7,733 | { "p1": 0.3333320617675781,"max": 1.000007625669241,"p50":
    1.0000057220458984,"p10": 0.3636360168457031,"p75": 1.0000057220458984,"p25":
    0.5000019073486328,"mean": 0.7893913483135638,"stdDev": 0.2606311318508915 } |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 2,093 | 7,733 | { "p1": 0.3333320617675781,"max": 1.000007625669241,"p50":
    1.0000057220458984,"p10": 0.3636360168457031,"p75": 1.0000057220458984,"p25":
    0.5000019073486328,"mean": 0.7893913483135638,"stdDev": 0.2606311318508915 } |'
- en: You can observe that by setting the `similarityCutoff` value to 0.33, only 7,733
    relationships would be created, instead of 13,402 with default parameter values.
    The 25th percentile value is 0.5, and interestingly, the median value is already
    the maximum score of 1\. The average node degree of the resulting network would
    be around 4\. As indicated by the similarity distribution, the relationships would
    be created between pairs of very similar or highly co-occurring hashtags, as the
    median value is already 1.0.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以观察到，将`similarityCutoff`值设置为0.33，只会创建7,733个关系，而不是默认参数值下的13,402个。第25百分位数是0.5，有趣的是，中位数已经是最大分数1.0。结果网络的平均节点度数大约为4。根据相似度分布，关系将在非常相似或高度共现的标签对之间创建，因为中位数已经是1.0。
- en: Exercise 7.3
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 练习7.3
- en: Test out various combinations of the `topK` and `similarityCutoff` parameters
    using the `stats` mode of the node similarity algorithm, and evaluate how changing
    their values affects the density of the inferred network.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用节点相似度算法的`stats`模式测试`topK`和`similarityCutoff`参数的各种组合，并评估它们值的变化如何影响推断网络的密度。
- en: Unfortunately, there is no clear-cut solution to defining the `topK` and `similarityCutoff`
    parameters. This reminds me of the Goldilocks dilemma; they have to be just right.
    If you infer too dense a graph, further analysis of the inferred network might
    not produce valuable insights. The same applies if you infer too sparse a graph.
    As a beginner, you are advised to try various parameter configurations and inspect
    downstream results. Later, you could apply automatic hyperparameter optimization
    methods when you grasp the underlying data structure and how configuration values
    affect results.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，没有明确的解决方案来定义`topK`和`similarityCutoff`参数。这让我想起了金发女孩困境；它们必须恰到好处。如果你推断出一个过于密集的图，进一步分析推断出的网络可能不会产生有价值的见解。同样，如果你推断出一个过于稀疏的图，也是如此。作为初学者，建议你尝试各种参数配置并检查下游结果。在掌握底层数据结构和配置值如何影响结果之后，你可以应用自动超参数优化方法。
- en: With the hashtag co-occurrence example, you will use the `similarityCutoff`
    value of 0.25 and the `topK` value of 50\. As you will execute other graph algorithms
    on the inferred co-occurrence network, you will use the `mutate` mode of the node
    similarity algorithm. The `mutate` mode stores the inferred network to the in-memory
    graph, which allows you to use the results of the node similarity algorithm as
    input to other graph algorithms, as shown in the following listing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签共现示例中，你将使用`similarityCutoff`值为0.25和`topK`值为50。由于你将在推断出的共现网络上执行其他图算法，你将使用节点相似度算法的`mutate`模式。`mutate`模式将推断出的网络存储到内存图中，这允许你将节点相似度算法的结果作为其他图算法的输入，如下面的列表所示。
- en: Listing 7.14 Mutating the hashtag co-occurrence network to the in-memory graph
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.14 将标签共现网络转换为内存图
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The inferred co-occurrence network of hashtags contains 2,093 nodes and 9,992
    relationships.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 推断出的标签共现网络包含2,093个节点和9,992个关系。
- en: 7.3 Characterization of the co-occurrence network
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 标签共现网络的特性
- en: Before moving on to the community detection part, you will consolidate your
    knowledge of characterizing a network using graph algorithms. Now that you are
    dealing with a monopartite graph, you can apply the same algorithms as in the
    previous chapters for network characterization.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到社区检测部分之前，你需要巩固使用图算法来表征网络的知识。现在你正在处理一个单部分图，你可以应用与前面章节相同的算法来表征网络。
- en: 7.3.1 Node degree centrality
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 节点度中心性
- en: You can use the node degree algorithm to further evaluate the node degree distribution
    of the inferred co-occurrence network. The thing is that the projected `tags`
    graph now contains `Tweet` and `Tag` nodes as well as `REVERSE_HAS_TAG` and `CO_OCCURRENCE`
    relationships. You can filter which nodes or relationships the algorithm should
    consider at the algorithm execution time with the `nodeLabels` and `relationshipTypes`
    parameters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用节点度算法进一步评估推断出的共现网络的节点度分布。问题是现在投影的 `tags` 图包含 `Tweet` 和 `Tag` 节点以及 `REVERSE_HAS_TAG`
    和 `CO_OCCURRENCE` 关系。你可以在算法执行时使用 `nodeLabels` 和 `relationshipTypes` 参数来过滤算法应考虑的节点或关系。
- en: Listing 7.15 Evaluating the node degree distribution of the hashtag co-occurrence
    network
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.15 评估标签共现网络的节点度分布
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Table 7.7 shows the resulting distribution.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.7 显示了结果分布。
- en: Table 7.7 Node degree distribution of the hashtag co-occurrence network
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.7 标签共现网络的节点度分布
- en: '| `p99` | 21.00011444091797 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `p99` | 21.00011444091797 |'
- en: '| `min` | 0.0 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 0.0 |'
- en: '| `max` | 40.00023651123047 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 40.00023651123047 |'
- en: '| `mean` | 5.351917056393738 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 5.351917056393738 |'
- en: '| `p90` | 13.000053405761719 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `p90` | 13.000053405761719 |'
- en: '| `p50` | 3.0000076293945312 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `p50` | 3.0000076293945312 |'
- en: '| `p999` | 29.00011444091797 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `p999` | 29.00011444091797 |'
- en: '| `p95` | 17.00011444091797 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `p95` | 17.00011444091797 |'
- en: '| `p75` | 8.000053405761719 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `p75` | 8.000053405761719 |'
- en: Both the `nodeLabels` and the `relationshipTypes` parameters expect a list as
    an input. The ability to filter nodes and relationships at algorithm execution
    time is a convenient feature that allows you to analyze various parts of the projected
    graph or analyze a newly inferred network.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodeLabels` 和 `relationshipTypes` 参数都期望输入一个列表。在算法执行时过滤节点和关系的能力是一个方便的特性，它允许你分析投影图的各个部分或分析一个新推断出的网络。'
- en: The average node degree of the hashtag co-occurrence network is 5.3\. Some of
    the hashtags have no `CO_OCCURRENCE` relationships, while at least 1 hashtag frequently
    co-occurs with 40 other hashtags. The `topK` parameter value of 50 did not affect
    the resulting network, as the highest degree is only 41\.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 标签共现网络的平均节点度为 5.3。一些标签没有 `CO_OCCURRENCE` 关系，而至少有一个标签经常与 40 个其他标签共现。`topK` 参数值为
    50 对结果网络没有影响，因为最高度数仅为 41。
- en: 7.3.2 Weakly connected components
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 弱连通分量
- en: The weakly connected component (WCC) algorithm does not need an introduction,
    as it was already presented in previous chapters. However, you should complete
    the two exercises in this section to consolidate your knowledge of executing and
    interpreting the results of the WCC algorithm.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 弱连通分量（WCC）算法无需过多介绍，因为它已在之前的章节中介绍过。然而，你应该完成本节中的两个练习，以巩固你对执行和解释 WCC 算法结果的知识。
- en: Exercise 7.4
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.4
- en: Execute the WCC algorithm on the hashtag co-occurrence network and store the
    results to the database as a node property `tcWcc`. Provide the `nodeLabels` and
    `relationshipTypes` parameters so that the algorithm will only consider the desired
    subset of the projected graph. Use the `write` mode of the algorithm to store
    the results to the database.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签共现网络上执行 WCC 算法，并将结果存储到数据库中的节点属性 `tcWcc` 中。提供 `nodeLabels` 和 `relationshipTypes`
    参数，以便算法只考虑投影图的所需子集。使用算法的 `write` 模式将结果存储到数据库中。
- en: Table 7.8 shows the resulting statistics.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.8 显示了结果统计。
- en: Table 7.8 Summary statistics for the WCC algorithm executed on the hashtag co-occurrence
    network
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.8 在标签共现网络上执行 WCC 算法的结果汇总统计
- en: '| `componentCount` | `componentDistribution` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `componentCount` | `componentDistribution` |'
- en: '| 469 | { "p99": 19,"min": 1,"max": 491,"mean": 3.9808102345415777,"p90": 6,"p50":
    2,"p999": 491,"p95": 11,"p75": 3 } |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 469 | { "p99": 19,"min": 1,"max": 491,"mean": 3.9808102345415777,"p90": 6,"p50":
    2,"p999": 491,"p95": 11,"p75": 3 } |'
- en: The `write` mode of the WCC algorithm also provides the high-level summary of
    the results, similar to the `stats` mode. There are 469 components in the hashtag
    co-occurrence network, and the largest contains 491 members, which is around 25%
    of the whole network. You can imagine you are dealing with quite a disconnected
    network, as most of the components have 10 or fewer members.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: WCC 算法的 `write` 模式也提供了结果的高级总结，类似于 `stats` 模式。标签共现网络中有 469 个组件，其中最大的包含 491 个成员，约占整个网络的
    25%。你可以想象你正在处理一个非常不连通的网络，因为大多数组件的成员数在 10 个或以下。
- en: Exercise 7.5
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.5
- en: Identify how many components have 10 or fewer members. First, you will need
    to count how many members are in each component based on their `tcWcc` property.
    After the first aggregation, you need to apply the filter and ignore components
    with more than 10 members. In the last step, you simply use the `count` function
    again to count the number of filtered components.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 识别有多少组件的成员数不超过10人。首先，你需要根据它们的`tcWcc`属性计算每个组件的成员数。在第一次聚合后，你需要应用过滤器并忽略成员数超过10人的组件。在最后一步，你只需再次使用`count`函数来计算过滤后的组件数量。
- en: 'By completing exercise 7.5, you can observe that 445 components out of 467
    have 10 or fewer members. One of the reasons the inferred network is so disconnected
    is because you are dealing with a tiny subset of the Twitter social network. I
    think adding more data would help to connect some of the components. On the other
    hand, hashtags like #meditation or #selfhelp will probably never frequently co-occur
    with AI or machine learning, and even if they do by some chance, they will never
    reach the similarity threshold where the co-occurrence relationship will be created
    between them.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成7.5练习，你可以观察到467个组件中有445个组件成员数不超过10人。推断出的网络如此不连通的一个原因是你正在处理Twitter社交网络的一个非常小的子集。我认为添加更多数据将有助于连接一些组件。另一方面，像#meditation或#selfhelp这样的标签可能永远不会频繁地与AI或机器学习一起出现，即使偶尔发生，它们也不会达到相似度阈值，从而在它们之间创建共现关系。
- en: 7.4 Community detection with the label propagation algorithm
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 使用标签传播算法进行社区检测
- en: So far, you have only learned how to use the WCC and strongly connected components
    (SCC) algorithms to evaluate the community structure. In this last part of this
    chapter, you will learn how to use the label propagation algorithm (LPA) to find
    nonoverlapping communities of hashtags. What is the difference between a community
    and a component? With the WCC algorithm, a component consists of nodes that can
    reach one another in the graph when ignoring the relationship direction. On the
    other hand, a community is defined as a group of densely interconnected nodes
    that might have sparser connections with other groups. Figure 7.13 shows a network
    that consists of only a single WCC.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只学习了如何使用WCC和强连通组件（SCC）算法来评估社区结构。在本章的最后部分，你将学习如何使用标签传播算法（LPA）来找到标签的非重叠社区。社区和组件之间的区别是什么？使用WCC算法时，组件由在图中忽略关系方向时可以相互到达的节点组成。另一方面，社区被定义为由密集连接的节点组成的组，这些节点可能与其他组有较稀疏的连接。图7.13显示了一个只包含单个WCC的网络。
- en: '![07-13](../../OEBPS/Images/07-13.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![07-13](../../OEBPS/Images/07-13.png)'
- en: Figure 7.13 Example visualization of a network community structure
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 示例：网络社区结构的可视化
- en: When you run a community detection algorithm like LPA on this network, the algorithm
    will identify groups of highly connected nodes. There are three communities in
    figure 7.13\. For example, there is a community on the left-hand side where members
    are highly connected. Similarly, there is another community with densely connected
    nodes on the right-hand side of the visualization, while one of those nodes also
    has connections to the central community. You can execute the `mutate` mode of
    the label propagation algorithm with the following Cypher statement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在网络上运行社区检测算法，如LPA时，该算法将识别高度连接的节点组。图7.13中有三个社区。例如，左侧有一个成员高度连接的社区。同样，在可视化的右侧还有一个由密集连接的节点组成的社区，而其中一个节点也与中心社区有连接。你可以使用以下Cypher语句执行标签传播算法的`mutate`模式。
- en: Listing 7.16 Executing the label propagation algorithm on the hashtag co-occurrence
    network and storing the results to the in-memory graph
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.16 在标签共现网络上执行标签传播算法并将结果存储到内存图
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, most of the graph algorithms follow the same syntax, which makes
    it easy to try out various graph algorithms. Again, you had to use the `nodeLabels`
    and the `relationshipTypes` parameters to select the hashtag co-occurrence network.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，大多数图算法遵循相同的语法，这使得尝试各种图算法变得容易。再次强调，你必须使用`nodeLabels`和`relationshipTypes`参数来选择标签共现网络。
- en: Note The label propagation algorithm is a nondeterministic algorithm, which
    means it has the potential to yield different results, even when applied to the
    same dataset multiple times. This inherent nondeterminism arises from the algorithm’s
    random nature of deciding the order in which nodes should update their labels.
    Therefore, such nondeterminism can result in variations across different outcomes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：标签传播算法是一个非确定性算法，这意味着它有可能产生不同的结果，即使多次应用于同一数据集。这种固有的非确定性源于算法在决定节点更新标签顺序时的随机性。因此，这种非确定性可能导致不同结果之间的差异。
- en: If you want to evaluate the results with Cypher, you need to store the mutated
    `community` property from the in-memory graph to the Neo4j stored graph. You can
    store the node properties from the in-memory graph to the database with the `gds.graph
    .writeNodeProperties` procedure. Run the following Cypher statement to store the
    mutated `community` property from the in-memory graph to the database.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用Cypher评估结果，您需要将内存中图的突变`community`属性存储到Neo4j存储图中。您可以使用`gds.graph.writeNodeProperties`过程将内存中图的节点属性存储到数据库中。运行以下Cypher语句将内存中图的突变`community`属性存储到数据库中。
- en: Listing 7.17 Writing the mutated in-memory graph node properties to the database
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.17 将内存中图节点的突变属性写入数据库
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The algorithm results are now available as the `community` node property of
    the `Tag` nodes. In the following listing, you will inspect the five largest communities
    and examine some of their members.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 算法结果现在作为`Tag`节点的`community`属性可用。在下面的列表中，您将检查五个最大的社区并检查其中的一些成员。
- en: Listing 7.18 Inspecting the five largest communities of hashtags
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.18 检查标签的五大社区
- en: '[PRE17]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Table 7.9 shows the resulting communities of hashtags.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.9显示了标签的结果社区。
- en: Table 7.9 Top five largest communities of hashtags
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.9 标签的五大最大社区
- en: '| `community` | `communitySize` | `exampleMembers` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `community` | `communitySize` | `exampleMembers` |'
- en: '| 15,809 | 43 | ["#mentalism", "#respect", "#special-needs", "#mondayvibes",
    "#goals", "#mindset", "#anxiety"] |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 15,809 | 43 | ["#mentalism", "#respect", "#special-needs", "#mondayvibes",
    "#goals", "#mindset", "#anxiety"] |'
- en: '| 15,828 | 42 | ["#auto_tagging", "#data_entry", "#itrules", "#writingcommunity",
    "#feg", "#crypto", "#tsa"] |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 15,828 | 42 | ["#auto_tagging", "#data_entry", "#itrules", "#writingcommunity",
    "#feg", "#crypto", "#tsa"] |'
- en: '| 17,537 | 35 | ["#programming", "#ml", "#iiot", "#iotpl", "#rstats", "#cybersecurity",
    "#serverless"] |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 17,537 | 35 | ["#programming", "#ml", "#iiot", "#iotpl", "#rstats", "#cybersecurity",
    "#serverless"] |'
- en: '| 16,093 | 34 | ["#nlpimpulse", "#iserlohn", "#zoom", "#selbstbild", "#selbstwert",
    "#spiegelbild", "#werte"] |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 16,093 | 34 | ["#nlpimpulse", "#iserlohn", "#zoom", "#selbstbild", "#selbstwert",
    "#spiegelbild", "#werte"] |'
- en: '| 16,271 | 31 | ["#artproject", "#nft", "#art", "#nfts", "#oculusquest", "#gaming",
    "#xrhub"] |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 16,271 | 31 | ["#artproject", "#nft", "#art", "#nfts", "#oculusquest", "#gaming",
    "#xrhub"] |'
- en: The largest community of hashtags has 43 members. From the looks of it, the
    overall topic of the largest community is focused on mental health and personal
    growth. At first, I wasn’t expecting these types of tweets in the dataset, but
    now I know that NLP can refer to both *natural language processing* and *neuro-linguistic
    programming*. The third- and fourth-largest communities are centered around computer
    science and software development. On the other hand, the fifth-largest community
    seems to revolve around nonfungible tokens (NFTs) and, interestingly, VR topics,
    like Oculus Quest, are also mentioned. You can remove the limit on the members
    as well as the limit of rows to further analyze the community structure.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 标签的最大的社区有43个成员。从表面上看，最大的社区的整体主题集中在心理健康和个人成长上。起初，我没有预料到数据集中会有这类推文，但现在我知道NLP可以指代**自然语言处理**和**神经语言编程**。第三和第四大的社区围绕着计算机科学和软件开发。另一方面，第五大的社区似乎围绕着非同质化代币（NFTs）以及有趣的是，还提到了VR主题，如Oculus
    Quest。您还可以取消成员数量以及行数的限制，以进一步分析社区结构。
- en: Exercise 7.6
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 练习7.6
- en: Identify the community of hashtags, where
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 识别包含以下标签的社区：
- en: '`#nlp` is a member'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#nlp`是成员之一'
- en: '`#graph` is a member'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#graph`是成员之一'
- en: Table 7.10 shows the resulting communities.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.10显示了结果社区。
- en: 'Table 7.10 Communities where #nlp or #graph are members'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.10 包含#nlp或#graph成员的社区
- en: '| 15,699 | ["#graphdatabases", "#hcm", "#peopleanalytics", "#hranalytics",
    "#graphdatascience", "#twitch", "#graph", "#neo4j"] |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 15,699 | ["#graphdatabases", "#hcm", "#peopleanalytics", "#hranalytics",
    "#graphdatascience", "#twitch", "#graph", "#neo4j"] |'
- en: '| 17,533 | ["#datascience", "#ai", "#machinelearning", "#iot", "#python", "#nlp",
    "#100daysofcode", "#deeplearning", "#artificialintelligence", "#bigdata", "#robots"]
    |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 17,533 | ["#datascience", "#ai", "#machinelearning", "#iot", "#python", "#nlp",
    "#100daysofcode", "#deeplearning", "#artificialintelligence", "#bigdata", "#robots"]
    |'
- en: 'The results of exercise 7.6 provide recommendations for hashtags that you can
    use to devise a marketing strategy for your company. For example, suppose you
    want to target the natural language processing community. In that case, you should
    try to combine the #nlp hashtag with other relevant hashtags, like #datascience,
    #deeplearning, or #machinelearning, to reach a wider audience. On the other hand,
    you should exclude topics of hashtags that are not relevant, like the self-help
    domain, in this example. You could also explore other communities and search for
    other hashtags that might be relevant to your company.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '练习 7.6 的结果为你提供了可以用来为公司制定营销策略的标签推荐。例如，假设你想要针对自然语言处理社区。在这种情况下，你应该尝试将 #nlp 标签与其他相关标签（如
    #datascience、#deeplearning 或 #machinelearning）结合起来，以触及更广泛的受众。另一方面，你应该排除不相关的标签主题，例如本例中的自我帮助领域。你还可以探索其他社区并寻找可能对你公司相关的其他标签。'
- en: 7.5 Identifying community representatives with PageRank
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 使用 PageRank 识别社区代表
- en: Sometimes you get larger communities of hashtags from the label propagation
    algorithm. In the marketing strategy example, you might want to identify a few
    of the most central hashtags of a community to concentrate on, since it probably
    doesn’t make sense to use 50 or more hashtags in your content.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会从标签传播算法中得到更大的标签社区。在营销策略示例中，你可能想识别社区中几个最中心的标签，以便集中精力，因为在你内容中使用 50 个或更多的标签可能没有意义。
- en: You can run the PageRank algorithm to find representatives of communities. To
    find representatives with the PageRank algorithm, you need to execute it on each
    community separately. Unfortunately, you can’t filter by mutated node properties
    at algorithm execution time. But you can use the *graph-filtering* feature, shown
    in the following listing, which allows you to filter an existing in-memory graph
    by specifying node and relationship filters.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行 PageRank 算法来找到社区的代表。要使用 PageRank 算法找到代表，你需要分别对每个社区执行它。不幸的是，你无法在算法执行时根据突变节点属性进行过滤。但你可以使用以下列表中显示的
    *图过滤* 功能，它允许你通过指定节点和关系过滤器来过滤现有的内存图。
- en: Listing 7.19 Subgraph projection syntax
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.19 子图投影语法
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can use the `nodeFilter` parameter to filter nodes based on node properties
    or labels. Similarly, you can use `relationshipFilter` parameter to filter relationships
    based on their properties and types. Filter predicates are Cypher predicates for
    either a node or a relationship. The filter predicate always needs to evaluate
    to `true` or `false`. Variable names within predicates are not arbitrarily chosen.
    A node predicate must refer to variable `n`, while the relationship predicate
    must refer to variable `r`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `nodeFilter` 参数根据节点属性或标签来过滤节点。同样，你也可以使用 `relationshipFilter` 参数根据其属性和类型来过滤关系。过滤谓词是针对节点或关系的
    Cypher 谓词。过滤谓词始终需要评估为 `true` 或 `false`。谓词内的变量名不是任意选择的。节点谓词必须引用变量 `n`，而关系谓词必须引用变量
    `r`。
- en: The reason you have used the `mutate` mode of the label propagation algorithm
    is that you can now use the mutated properties for subgraph projections. If you
    had used the `write` mode directly, the label propagation algorithm results would
    not be available in the in-memory graph, so you wouldn’t be able to filter on
    them.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用标签传播算法的 `mutate` 模式的原因是现在你可以使用突变属性进行子图投影。如果你直接使用 `write` 模式，标签传播算法的结果将不会在内存图中可用，因此你无法根据它们进行过滤。
- en: 'For example, the community with the #ml hashtag contains 35 members. Instead
    of manually evaluating which are the most important within the group, you can
    use the PageRank algorithm to identify the representatives of the group. The following
    Cypher statement projects a subgraph that contains only the community of hashtags
    in which the #ml hashtag is a member.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，包含 #ml 标签的社区有 35 个成员。你不必手动评估组内哪些成员最重要，可以使用 PageRank 算法来识别该组的代表。以下 Cypher
    语句投影了一个只包含 #ml 标签作为成员的标签社区子图。'
- en: Listing 7.20 Projecting a subgraph that contains only the largest community
    of hashtags
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.20 投影只包含最大标签社区子图
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Filtering nodes in a specific community
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 过滤特定社区的节点
- en: ❷ A wildcard operator can be used when you don’t want to apply any filters.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当你不想应用任何过滤器时，可以使用通配符运算符。
- en: ❸ Any parameters used in the subgraph projection from outer operations need
    to passed through the parameters configuration value.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在从外部操作到子图投影中使用的任何参数都需要通过参数配置值传递。
- en: 'The fifth parameter is the configuration map, where you can define any parameters
    calculated before the subgraph projection procedure. In the Cypher statement in
    listing 7.20, you first match the #ml hashtag node and retrieve its `community`
    property. The `community` property is then passed to the subgraph projection procedure
    as a parameter. Finally, you can execute the PageRank algorithm on the newly projected
    `ml-community` in-memory graph to identify its representatives.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '第五个参数是配置映射，其中你可以定义在子图投影过程之前计算的任何参数。在列表 7.20 中的 Cypher 语句中，你首先匹配 #ml 标签节点并检索其
    `community` 属性。然后，`community` 属性作为参数传递给子图投影过程。最后，你可以在新投影的 `ml-community` 内存图上执行
    PageRank 算法以识别其代表。'
- en: Listing 7.21 Identifying representatives of the largest community with the PageRank
    algorithm
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.21 使用 PageRank 算法识别最大社区的代表
- en: '[PRE20]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Table 7.11 shows the resulting communities.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.11 显示了生成的社区。
- en: Table 7.11 Top five representatives of the largest community of hashtags
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.11 最大的标签社区的前五个代表
- en: '| `tag` | `score` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `标签` | `得分` |'
- en: '| #serverless | 1.9529458990718058 |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| #serverless | 1.9529458990718058 |'
- en: '| #iiot | 1.8179378938658664 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| #iiot | 1.8179378938658664 |'
- en: '| #usa? | 1.6916560123489326 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| #usa? | 1.6916560123489326 |'
- en: '| #coders | 1.4975137459724255 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| #coders | 1.4975137459724255 |'
- en: '| #frenchtech | 1.4975137459724253 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| #frenchtech | 1.4975137459724253 |'
- en: 'Interestingly, the most central hashtags in the same community as the #ml are
    #serverless, #iiot, and, unexpectedly, #usa. It might be that some internet of
    things (IoT) event was taking place in the United States during the window the
    tweets were scraped. On the other hand, it is not surprising that #ml coappears
    in tweets that talk about serverless or IoT technologies. You must also realize
    that you are dealing with a tiny sample of tweets. The results would probably
    change if you increased the number of tweets in your analysis, as you wouldn’t
    be so dependent on what was going on during the three-day windows during which
    most of the tweets were created. Since the results of the community detection
    algorithm are nondeterministic, you might get results different from table 7.11.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '有趣的是，与 #ml 同社区的标签中，最中心的标签是 #serverless、#iiot 和出人意料的是 #usa。可能是在抓取推文的时间窗口内，美国发生了某些物联网（IoT）事件。另一方面，#ml
    与关于无服务器或 IoT 技术的推文共现并不令人惊讶。你也必须意识到你正在处理一个很小的推文样本。如果你增加了分析中的推文数量，结果可能会改变，因为你不会那么依赖于大多数推文在创建的三天窗口期间发生的事情。由于社区检测算法的结果是非确定性的，你可能会得到与表
    7.11 不同的结果。'
- en: Exercise 7.7
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.7
- en: Find representatives of other communities. You need to use the subgraph projection
    feature to filter relevant nodes and then use the PageRank algorithm to find its
    representatives.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 找到其他社区的代表。你需要使用子图投影功能来过滤相关节点，然后使用 PageRank 算法找到其代表。
- en: Congratulations! You have learned how to infer a co-occurrence network and analyze
    its community structure. The most crucial step in analyzing the hashtag co-occurrence
    network was the definition of the `topK` and `similarityCutoff` parameters of
    the node similarity algorithm. As discussed, the `topK` and the `similarityCutoff`
    parameters will directly affect how dense the inferred co-occurrence network will
    be. Consequently, the density of the co-occurrence network will correlate with
    how large the identified communities will be, which in the hashtag co-occurrence
    example means how broad the resulting topics will be. I recommend you test out
    various configurations of the two parameters and examine how they affect the resulting
    hashtag communities.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经学会了如何推断共现网络并分析其社区结构。分析标签共现网络中最关键的一步是定义节点相似性算法的 `topK` 和 `similarityCutoff`
    参数。正如所讨论的，`topK` 和 `similarityCutoff` 参数将直接影响推断出的共现网络的密度。因此，共现网络的密度将与识别出的社区的大小相关，在标签共现的例子中意味着生成的主题将有多广泛。我建议你测试这两个参数的各种配置，并检查它们如何影响生成的标签社区。
- en: 7.5.1 Dropping the projected in-memory graphs
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 丢弃投影的内存图
- en: It is important to remember to release the projected in-memory graph once you
    are done with the analysis to free up memory for other analysis. The following
    Cypher statement will drop all currently projected graphs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析完成后，记得释放投影的内存图以释放内存供其他分析使用。以下 Cypher 语句将删除所有当前投影图。
- en: Listing 7.22 Releasing all projected graphs from memory
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.22 从内存中释放所有投影图
- en: '[PRE21]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Listing all projected graphs
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列出所有投影图
- en: ❷ Releasing each projected graph from memory
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从内存中释放每个投影图
- en: 7.6 Solutions to exercises
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 练习题解答
- en: The solution to exercise 7.1 is as follows.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题 7.1 的解答如下。
- en: Listing 7.23 Retrieving the top five hashtags by the sum of the combined tweet
    and retweet count
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.23 通过合并推文和转发计数之和检索前五个热门标签
- en: '[PRE22]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The solution to exercise 7.2 is as follows.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题 7.2 的解答如下。
- en: Listing 7.24 Examining the top five most co-occurring pairs of hashtags
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.24 检查前五个最常共现的标签对
- en: '[PRE23]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Removing duplicates from the results
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从结果中移除重复项
- en: The solution to exercise 7.4 is as follows.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题 7.4 的解答如下。
- en: Listing 7.25 Executing the WCC algorithm on the hashtag co-occurrence network
    and storing the results to the database
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.25 在标签共现网络上执行 WCC 算法并将结果存储到数据库中
- en: '[PRE24]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The solution to exercise 7.5 is as follows.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题 7.5 的解答如下。
- en: Listing 7.26 Identifying how many components have 10 or fewer members
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.26 识别有多少个组件有 10 个或更少的成员
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The solution to exercise 7.6 is as follows.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 练习题 7.6 的解答如下。
- en: 'Listing 7.27 Identifying the members that are in the same community as the
    #nlp hashtag'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7.27 识别与 #nlp 标签处于同一社区中的成员'
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Inferring monopartite networks is a frequent step in graph analysis.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推断单连通网络是图分析中常见的步骤。
- en: The Jaccard similarity coefficient can be calculated by dividing the intersection
    by the union of two sets.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jaccard 相似系数可以通过将两个集合的交集除以并集来计算。
- en: The GDS library uses two directed relationships that point in the opposite direction
    to represent an undirected relationship.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDS 库使用两个指向相反方向的有向关系来表示无向关系。
- en: The Jaccard similarity coefficient can be calculated with the `gds.nodeSimilarity`
    algorithm in GDS.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GDS 中，可以使用 `gds.nodeSimilarity` 算法计算 Jaccard 相似系数。
- en: The `similarityCutoff` parameter of the node similarity algorithm is used to
    define the threshold value of the similarity between a pair of nodes still regarded
    as similar.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点相似度算法的 `similarityCutoff` 参数用于定义一对节点之间相似性的阈值值，仍被视为相似。
- en: The `similarityCutoff` parameter of the node similarity algorithm is used to
    specify the limit on the number of similar relationships per node.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点相似度算法的 `similarityCutoff` 参数用于指定每个节点相似关系的数量限制。
- en: The `stats` mode of the node similarity algorithm can be used to evaluate the
    density of the inferred similarity network.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点相似度算法的 `stats` 模式可以用来评估推断相似度网络的密度。
- en: Cypher implements basic text functions, like the `replace` and `split` functions.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 实现了基本的文本函数，如 `replace` 和 `split` 函数。
- en: Cypher syntax offers a list comprehension syntax, which is useful for filtering
    or transforming elements in a list.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher 语法提供了一种列表推导语法，这对于过滤或转换列表中的元素非常有用。
- en: The `UNWIND` clause is used to transform a list of elements into rows, similar
    to a `for` loop in various scripting languages.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNWIND` 子句用于将元素列表转换为行，类似于各种脚本语言中的 `for` 循环。'
- en: You can change the relationship direction or treat it as undirected during inmemory
    graph projection.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存图投影期间，您可以更改关系方向或将它视为无向的。
- en: The GDS library uses two directed relationships that point in opposite directions
    to represent an undirected relationship.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDS 库使用两个指向相反方向的有向关系来表示无向关系。
- en: Parameters `nodeLabels` and `relationshipTypes` can be used to consider only
    a subset of the projected graph as an input to a graph algorithm.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数 `nodeLabels` 和 `relationshipTypes` 可以用来考虑仅将投影图的一个子集作为图算法的输入。
- en: The label propagation algorithm is used to evaluate the community structure
    of a network.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签传播算法用于评估网络的社区结构。
- en: The label propagation algorithm is not deterministic, meaning the algorithm
    output may vary between different executions.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签传播算法是非确定性的，这意味着算法的输出可能在不同的执行之间有所不同。
- en: Communities represent densely connected groups of nodes with sparser links between
    groups.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区代表节点之间紧密连接的密集组，组与组之间的链接较为稀疏。
- en: You can use the graph filtering feature to project a new graph that contains
    a subset of an existing in-memory graph.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用图过滤功能来投影一个包含现有内存图中子集的新图。
- en: PageRank can be used to find representatives of communities in a co-occurrence
    network.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PageRank 可以用来在共现网络中找到社区的代表。
