- en: 13 Container and Pod security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 容器和 Pod 安全性
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Reviewing security basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查安全基础知识
- en: Exploring best practices for container security
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索容器安全最佳实践
- en: Constraining Pods with a security context and resource limits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全上下文和资源限制约束 Pod
- en: If we try to secure our computers in a secure building, locked in a guarded
    vault, inside a Faraday cage, with a biometric login, not connected to the internet
    . . . , add up all of these precautions, and they still aren’t enough for our
    computers to be truly secure. As Kubernetes practitioners, we need to make reasonable
    security decisions based on our business needs. If we lock all of our Kubernetes
    clusters in a Faraday cage, unplugged from the internet, we make our clusters
    unusable. But if we do not focus on security, we allow people (like bitcoin miners,
    for example) to waltz in and invade our clusters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们试图在安全的建筑中保护我们的计算机，将其锁在受保护的保险库中，放在法拉第笼内，使用生物识别登录，不连接到互联网……，将这些预防措施加起来，它们仍然不足以确保我们的计算机真正安全。作为
    Kubernetes 实践者，我们需要根据我们的业务需求做出合理的安全决策。如果我们把所有的 Kubernetes 集群锁在法拉第笼中，断开与互联网的连接，我们将使我们的集群无法使用。但如果我们不关注安全，就会让像比特币矿工这样的人随意进入并入侵我们的集群。
- en: 'As Kubernetes matures and is used more widely, common vulnerabilities and exposures
    (CVEs) in Kubernetes become a frequent occurrence. Here is a way to think about
    security: there is a risk that your system will get hacked! When you do get hacked,
    the questions to ask are'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Kubernetes 的成熟和更广泛的应用，Kubernetes 中的常见漏洞和暴露（CVE）变得频繁发生。以下是关于安全性的思考方式：你的系统被黑客攻击的风险！当你被黑客攻击时，需要问的问题是
- en: What can they get?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以获取什么？
- en: What can they do?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们能做什么？
- en: What data can they get into?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可以获取哪些数据？
- en: Security is a series of tradeoffs that are often hard decisions. By using Kubernetes,
    we introduce a system that can scare people when they realize that it can often
    have the capability to create an internet-facing load balancer with one API call.
    But by utilizing simple and basic practices, we can reduce the impact of a security
    risk. Admittedly, most companies do not plan for the basics, such as performing
    security updates on containers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是一系列权衡，通常是艰难的决定。通过使用 Kubernetes，我们引入了一个系统，当人们意识到它可以通过一个 API 调用创建一个面向互联网的负载均衡器时，可能会感到害怕。但通过利用简单和基本的做法，我们可以减少安全风险的影响。诚然，大多数公司并没有为基本的安全措施做规划，例如对容器进行安全更新。
- en: Security is a balancing act; it can slow down businesses, but businesses thrive
    when they operate at full speed. Security is great, but going down the security
    rabbit hole can burn money and slow down businesses and organizations. We have
    to balance practical security measures that we can automate and make judgement
    calls when we start going down that rabbit hole.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是一种平衡行为；它可能会减缓业务发展，但企业只有在全速运转时才能繁荣。安全性固然重要，但过度追求安全性可能会导致资金浪费，并减缓业务和组织的发展。我们必须在可以自动化的实际安全措施和开始深入探索时做出判断。
- en: You do not need to build all of the security precautions yourself. There is
    a growing set of tools that track containers running inside of Kubernetes and
    determine what possible security holes exist; for example, the Open Policy Agent
    (OPA), which we will cover in chapter 14\. At the end of the day, however, a computer
    on the internet is simply *not* secure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要自己构建所有的安全预防措施。有一套不断增长的工具可以跟踪 Kubernetes 内运行的容器，并确定可能存在的安全漏洞；例如，Open Policy
    Agent（OPA），我们将在第 14 章中介绍。然而，最终，互联网上的计算机仅仅是*不安全*的。
- en: As we talked about in the first chapter of this book, DevOps is built on automation,
    as is Kubernetes. In this chapter, we’ll discuss what you need to do to automate
    your Kubernetes security. To begin, the following sections walk through some security
    concepts so that we get into the proper mindset.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书第一章中讨论的那样，DevOps 和 Kubernetes 都是建立在自动化基础上的。在本章中，我们将讨论您需要做什么来自动化 Kubernetes
    的安全性。首先，以下部分将介绍一些安全概念，以便我们进入正确的思维模式。
- en: Note Although the following two chapters could be an entire book, our intention
    is to make these chapters a practical handbook and not a definitive guide. When
    you understand the handbook, you can then learn more about each topic.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管以下两章可能是一整本书的内容，但我们的目的是使这些章节成为一本实用的手册，而不是一本权威指南。当你理解了这本手册后，你就可以更深入地了解每个主题。
- en: 13.1 Blast radius
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 爆炸半径
- en: When something blows up, the blast radius is the distance from the center of
    the explosion to the edge of the explosion. Now, how the heck does this apply
    to computer security (compusec or cybersecurity)? When a computer system is compromised,
    there is an explosion, and usually in more ways than one. Suppose you have multiple
    containers running inside of multiple nodes with multiple security components.
    How far does the explosion go?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当某物爆炸时，爆炸半径是从爆炸中心到爆炸边缘的距离。现在，这种爆炸是如何应用到计算机安全（compusec或网络安全）中的呢？当计算机系统被入侵时，会发生爆炸，通常不止一种方式。假设你在多个节点上运行多个容器，每个容器都有多个安全组件。爆炸会蔓延多远？
- en: Can a compromised Pod access another Pod?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被入侵的Pod能否访问另一个Pod？
- en: Can a compromised Pod be used to create another Pod?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被入侵的Pod能否用来创建另一个Pod？
- en: Can a compromised Pod be used to control a node?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被入侵的Pod能否用来控制一个节点？
- en: Can you jump from node01 to node02?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能从node01跳转到node02吗？
- en: Can you go from the Pod to an external database?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能从Pod访问外部数据库吗？
- en: Can you get into, say, an LDAP system?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能进入，比如说，一个LDAP系统吗？
- en: Can a hacker get into your source control or Secrets?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑客能否进入你的源代码控制或机密信息？
- en: Think of a security intrusion as ground zero of a big explosion. How far that
    explosion or intrusion travels is the blast radius. By implementing easy security
    standards, however, such as not running a process as a root or using RBAC, we
    can limit the distance when stuff goes BOOM.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将安全侵入视为大爆炸的零点。爆炸或侵入蔓延的距离就是爆炸半径。然而，通过实施简单的安全标准，例如不作为root运行进程或使用RBAC，我们可以在东西爆炸时限制其距离。
- en: 13.1.1 Vulnerabilities
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 漏洞
- en: A *vulnerability* is where something is weak. (There is a crack in the dam.)
    In terms of security, we are always trying to prevent the vulnerability (or crack
    in the dam) instead of patching it. The next two chapters are set up to cover
    the vulnerabilities of Kubernetes from the inside out, as well as how we can reinforce
    security.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *漏洞* 是指某处存在弱点。（大坝上有一个裂缝。）在安全方面，我们总是试图防止漏洞（或大坝上的裂缝）而不是修补它。接下来的两章将安排从内到外覆盖Kubernetes的漏洞，以及我们如何加强安全。
- en: 13.1.2 Intrusion
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.2 侵入
- en: An *intrusion* is what all of us do not want! It is a break-in, where an attacker
    exploits a vulnerability and gets into our system. For example, a bad actor (intruder)
    gets control of a Pod and has access to `curl` or `wget`. Then the intruder creates
    another Pod that runs as a root on the host network. You now have a fully compromised
    cluster.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *侵入* 是我们都不希望的事情！它是一种入侵，攻击者利用漏洞并进入我们的系统。例如，一个恶意行为者（入侵者）控制了一个Pod，并有权访问`curl`或`wget`。然后入侵者创建了一个以root身份在主机网络上运行的另一个Pod。现在你有一个完全被入侵的集群。
- en: 13.2 Container security
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 容器安全
- en: The most obvious place to start with Kubernetes security is at the container
    level, because, after all, every Kubernetes cluster is pretty much guaranteed
    to run in a few containers. As much as you can secure a cluster, your front line
    is your container. It’s wise to keep in mind that the custom software that runs
    inside a container is vulnerable to attacks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes安全方面，最明显的地方是从容器级别开始，因为毕竟，每个Kubernetes集群几乎都保证在几个容器中运行。尽管你可以保护集群，但你的前线是你的容器。记住，运行在容器内的自定义软件容易受到攻击是明智的。
- en: When you run an application and open it to the world, people can be malicious.
    For example, one time we noticed that CPU levels for a node had gone nuts. A developer
    had deployed an application that had a known bug! Bitcoin miners utilized that
    Pod for mining, and it all happened within a few hours. Never forget that, as
    secure as you can make your container, if you are running a software application
    that has a critical issue, you leave yourself wide open to an attack. It takes
    a short amount of time, maybe minutes, for a hacker to find a cluster and seconds
    to put a bitcoin miner inside a container running software with a known CVE. With
    that in mind, let’s outline some best practices for securing containers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个应用程序并将其向世界开放时，人们可能是恶意的。例如，有一次我们注意到某个节点的CPU级别变得疯狂。一位开发者部署了一个有已知错误的应用程序！比特币矿工利用这个Pod进行挖矿，这一切都在几个小时内发生。永远不要忘记，尽管你可以使你的容器尽可能安全，但如果你运行一个有关键问题的软件应用程序，你将使自己容易受到攻击。黑客找到集群可能只需要几分钟，将比特币矿工放入运行有已知CVE的软件容器中可能只需要几秒钟。考虑到这一点，让我们概述一些保护容器的最佳实践。
- en: 13.2.1 Plan to update containers and custom software
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 计划更新容器和自定义软件
- en: Updating is the number one thing that we consistently see companies *not* doing.
    Frankly, this is scary, scarier than the worst horror movie you have ever seen.
    Large companies leak data because they have not updated software dependencies
    or even overhauled the base image.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更新是我们一直看到公司**没有**做的事情。坦白说，这很可怕，比你看过的最糟糕的恐怖电影还要可怕。大公司泄露数据，因为他们没有更新软件依赖项，甚至没有彻底更新基础镜像。
- en: It’s best to build the capacity for updates into your software pipelines early
    on, just in case a security vulnerability occurs. If you get pushback, you can
    gently remind the pushers about the bad publicity linked to companies who leak
    customer information. Also, a leak often costs companies millions of dollars.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在软件管道中早期就构建更新能力，以防出现安全漏洞。如果你遇到阻力，你可以温和地提醒推动者与泄露客户信息的公司相关的负面宣传。此外，泄露通常会使公司损失数百万美元。
- en: Update your containers as new base container versions are released and when
    new CVEs come out. The CVE Program houses cybersecurity vulnerability notices
    that are created when those issues are found. You can review these issues at [https://cve.mitre.org/](https://cve.mitre.org/).
    Also, plan to update custom software dependencies. You need to not only update
    the container around the software but also the software itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当发布新的基础容器版本和新 CVE 时更新你的容器。CVE 计划包含了当这些问题被发现时创建的网络安全漏洞通知。你可以在 [https://cve.mitre.org/](https://cve.mitre.org/)
    上审查这些问题。此外，计划更新自定义软件依赖项。你需要不仅更新围绕软件的容器，还要更新软件本身。
- en: 13.2.2 Container screening
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 容器筛选
- en: Container screening is a system that reports if your containers have a vulnerability
    (as an example, think of when OpenSSL contained the Heartbleed bug back in 2014).
    A system that screens your images is not a nice to have, but a *must* in today’s
    landscape. You really need to screen the software in your containers for vulnerabilities
    and update the image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 容器筛选是一个报告你的容器是否存在漏洞的系统（例如，想想 2014 年 OpenSSL 包含 Heartbleed 漏洞的情况）。筛选你的镜像的系统不是锦上添花，而是当今环境中的**必须**。你真的需要筛选容器中的软件漏洞并更新镜像。
- en: The software consists of what is installed, including OpenSSL and Bash. Not
    only must the software be updated, but the base images must also be defined with
    the `FROM` element. It is a lot of work. We personally know how much time and
    money this costs. Set up CI/CD and other tooling to quickly build, test, and deploy
    your containers. Many commercial container registries contain systems that screen
    your containers, but admittedly, if nobody is looking at those notifications,
    then they are ignored. Build a system to watch for those notifications, or get
    commercial software that can help with this.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包括已安装的内容，包括 OpenSSL 和 Bash。不仅必须更新软件，还必须使用 `FROM` 元素定义基础镜像。这是一项大量工作。我们个人知道这需要多少时间和金钱。设置
    CI/CD 和其他工具以快速构建、测试和部署你的容器。许多商业容器注册库包含筛选你的容器的系统，但诚然，如果没有人查看那些通知，那么它们就会被忽略。建立一个系统来监视那些通知，或者获取可以帮助你完成这项工作的商业软件。
- en: 13.2.3 Container users—do not run as root
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.3 容器用户——不要以 root 身份运行
- en: Don’t run as the root user inside a container. There is the notion of *popping
    a shell*, which means that you escape the container’s Linux namespace and have
    access to a command-line shell. From the shell, you can access the API server
    and possibly the node. If you have access to a shell, you may have the permissions
    to download a script from the internet and run it. Running as the root user gives
    you the same root permission on the container and maybe root on the host system
    if you pop the container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在容器内部以 root 用户身份运行。有一种“弹出外壳”的概念，这意味着你逃离了容器的 Linux 命名空间，并可以访问命令行外壳。从外壳中，你可以访问
    API 服务器和可能的主机。如果你可以访问外壳，你可能拥有从互联网下载脚本并运行的权限。以 root 用户身份运行会给你在容器中相同的 root 权限，如果弹出容器，可能还有主机系统的
    root 权限。
- en: 'You can define a new user when you define a container and create a specific
    user and group with `adduser`. Then run your application as that user. The following
    is an example from a Debian container that creates a user:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个容器并使用 `adduser` 创建特定的用户和组时，你可以定义一个新的用户。然后，以该用户身份运行你的应用程序。以下是一个来自 Debian
    容器的示例，展示了如何创建用户：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, you can run your application using that user:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用该用户运行你的应用程序：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running as the root user within a container has many of the same consequences
    as operating as the root user on the host system: `root` is `root`. Also, in a
    Pod manifest, you are able to define the `runAsUser` and `fsGroup`. We will cover
    both later.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内以 root 用户身份运行具有与在主机系统上作为 root 用户操作相同的许多后果：“root” 就是 “root”。此外，在 Pod 清单中，您可以定义
    `runAsUser` 和 `fsGroup`。我们稍后会介绍这两个概念。
- en: 13.2.4 Use the smallest container
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.4 使用最小的容器
- en: It is a good idea to use a lightweight container OS that is built to run only
    as a container. This limits the number of binaries in a container, and thus, limits
    your vulnerabilities. Projects like Google’s distroless provide lightweight container
    options that are language-specific.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个专为作为容器运行而构建的轻量级容器操作系统是一个好主意。这限制了容器中的二进制文件数量，从而限制了您的漏洞。像 Google 的 distroless
    这样的项目提供了针对特定语言的轻量级容器选项。
- en: Restricting what’s in your runtime container to precisely what’s necessary for
    your app is a best practice employed by Google and other tech giants that have
    used containers in production for many years. It improves the signal to noise
    of scanners (e.g., CVE) and reduces the burden of establishing provenance to just
    what you need.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的运行时容器中的内容限制为仅适用于您的应用程序所必需的内容是 Google 和其他已经使用容器在生产环境中运行多年的技术巨头采用的最佳实践。这提高了扫描器（例如，CVE）的信号与噪声比，并将建立来源的负担仅限于您所需的内容。
- en: —Open Web Application Foundation’s Security Cheat Sheet ([http://mng.bz/g42v](http://mng.bz/g42v))
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: —Open Web Application Foundation 的安全备忘录 ([http://mng.bz/g42v](http://mng.bz/g42v))
- en: 'Google’s distroless project includes a base layer, as well as containers for
    running different programming languages, like Java. The following shows an example
    of a Go application using the golang container to build our software, followed
    by a distroless container:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的 distroless 项目包括一个基础层，以及用于运行不同编程语言的容器，例如 Java。以下是一个使用 golang 容器构建我们的软件的
    Go 应用程序示例，随后是一个 distroless 容器：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And then there is extra software. Say that you install cURL to download a binary
    during the creation process of a container. cURL then needs to be removed. The
    Alpine distribution handles this elegantly by removing components used in the
    build automatically, but Debian and others do not. If your application does not
    need it, don’t install it. The more you have installed, the greater your number
    of possible vulnerabilities. Even the example missed creating a new user to run
    the binary. Only run as root if you have to.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有额外的软件。比如说，在创建容器的过程中安装 cURL 来下载二进制文件。cURL 需要被移除。Alpine 发行版通过自动移除构建过程中使用的组件优雅地处理这个问题，但
    Debian 和其他发行版则不行。如果您的应用程序不需要它，就不要安装它。安装的越多，可能存在的漏洞数量就越多。即使是示例也遗漏了创建一个新用户来运行二进制文件。只有在必要时才以
    root 身份运行。
- en: 13.2.5 Container provenance
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.5 容器来源
- en: One of the key security concerns for running Kubernetes clusters is knowing
    what container images are running inside each Pod and being able to account for
    their origins. Establishing *container provenance* means having the ability to
    trace the source of a container to a trusted point of origin and ensuring your
    organization follows the desired processes during artifact (container) creation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Kubernetes 集群时的一个关键安全问题是了解每个 Pod 内运行的容器镜像，并能够追溯其来源。建立 *容器来源* 意味着能够将容器的来源追溯到可信赖的起点，并确保您的组织在创建（容器）工件时遵循期望的过程。
- en: Do not deploy a container from a container registry that your company does not
    control. Open source projects are amazing, but build and push those containers
    into your repository after you construct them locally. Container tags are not
    immutable; only the SHAs are. There is zero guarantee that the container is actually
    the container that you think it is. Container provenance allows for a user or
    a Kubernetes cluster to ensure that a deployed container can be identified, thus
    guaranteeing the source.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不要从您公司不控制的容器注册库部署容器。开源项目很棒，但请在本地构建容器后将其构建和推送到您的仓库中。容器标签不是不可变的；只有 SHA 值是不可变的。没有任何保证说容器实际上就是您认为的那个容器。容器来源允许用户或
    Kubernetes 集群确保部署的容器可以被识别，从而保证来源的可靠性。
- en: The Kubernetes team builds an image base layer for all of the containers that
    run inside a Kubernetes cluster. Doing this allows the team to know that the image
    has a safe origin, is consistent and validated, and has a specific provenance.
    A safe origin also means that all images come from a known source. Consistency
    and validation ensure that specific steps are completed when we build an image
    and provide a more hermetic environment. Lastly, provenance guarantees that the
    container’s source is known and that it does not change before running.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 团队为 Kubernetes 集群内部运行的所有容器构建了一个镜像基础层。这样做使得团队能够知道该镜像有一个安全的来源，是一致的且经过验证的，并且具有特定的来源。安全的来源还意味着所有镜像都来自已知来源。一致性和验证确保我们在构建镜像时完成特定的步骤，并提供了一个更密封的环境。最后，来源保证了容器的来源是已知的，并且在运行之前不会发生变化。
- en: 13.2.6 Linters for containers
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.6 容器代码检查工具
- en: 'Automation is key to reducing workload and improving systems. Security is a
    lot of work, let’s be honest, but you can run a linter like hadolint to find common
    problems with containers and custom software that can cause security vulnerabilities.
    The following is a short list of linters that we have used in the past:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是减少工作负载和提高系统性能的关键。诚实地讲，安全性是一项大量工作，但您可以使用 hadolint 这样的代码检查工具来查找可能导致安全漏洞的容器和自定义软件中的常见问题。以下是我们过去使用的一些代码检查工具的简要列表：
- en: hadolint for Dockerfiles ([https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint))
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile 的 hadolint ([https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint))
- en: The `go vet` command ([https://golang.org/cmd/vet/](https://golang.org/cmd/vet/))
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go vet` 命令 ([https://golang.org/cmd/vet/](https://golang.org/cmd/vet/))'
- en: Flake8 for Python ([http://flake8.pycqa.org/en/latest/](http://flake8.pycqa.org/en/latest/))
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flake8 for Python ([http://flake8.pycqa.org/en/latest/](http://flake8.pycqa.org/en/latest/))
- en: ShellCheck for Bash ([https://www.shellcheck.net/](https://www.shellcheck.net/))
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ShellCheck for Bash ([https://www.shellcheck.net/](https://www.shellcheck.net/))
- en: Now that you have your container security under control, let’s look at the next
    level—the Pod.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经控制了容器安全性，让我们看看下一个级别——Pod。
- en: 13.3 Pod security
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 Pod 安全性
- en: Kubernetes allows us to define the permissions for a user in a Pod and for a
    Pod outside of the Linux namespace (for instance, can a Pod mount a volume on
    a node?). Compromising a Pod can compromise a cluster! Commands such as `nsenter`
    can be used to enter a root process (/proc/1), create a shell, and act the same
    as a root on the actual node that runs the compromised Pod. The Kubernetes API
    allows for defining a Pod permissions and further secures the Pod, nodes, and
    overall cluster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 允许我们定义 Pod 中用户和 Pod 外 Linux 命名空间（例如，Pod 是否可以在节点上挂载卷？）的权限。Pod 被破坏可能会破坏整个集群！可以使用
    `nsenter` 命令进入 root 进程 (/proc/1)，创建一个 shell，并在实际运行被破坏 Pod 的节点上以 root 身份执行。Kubernetes
    API 允许定义 Pod 权限，并进一步保护 Pod、节点和整个集群。
- en: Note Some Kubernetes distributions, such as OpenShift, add far more security
    layers, and you may need to add more configurations to use API configurations
    such as a security context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一些 Kubernetes 发行版，例如 OpenShift，添加了更多的安全层，您可能需要添加更多配置才能使用如安全上下文这样的 API 配置。
- en: 13.3.1 Security context
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 安全上下文
- en: 'Remember how we mentioned you should not run a container using the root user?
    Kubernetes also allows a user to define a user ID for a Pod. In the Pod definition,
    you are able to specify three IDs:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们提到过您不应该使用 root 用户运行容器吗？Kubernetes 也允许用户为 Pod 定义一个用户 ID。在 Pod 定义中，您可以指定三个
    ID：
- en: '`runAsUser`—The user ID used to start the process'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAsUser`—启动进程所使用的用户 ID'
- en: '`runAsGroup`—The group used for the process user'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAsGroup`—用于进程用户的组'
- en: '`fsGroup`—A second group ID used to mount any volumes and all files created
    by the Pod’s processes'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fsGroup`—用于挂载任何卷和 Pod 进程创建的所有文件的第二个组 ID'
- en: 'If you have a container that runs as the root, you can force it to run as a
    different user ID. But, again, you should not have a container that runs as root
    because you can allow the user to accidentally miss the `securityContext` definition.
    The following YAML snippet contains a Pod with a security context:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的容器以 root 身份运行，您可以强制它以不同的用户 ID 运行。但，再次强调，您不应该有以 root 身份运行的容器，因为您可能会让用户意外遗漏
    `securityContext` 定义。以下 YAML 片段包含了一个具有安全上下文的 Pod：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ When the Pod starts, NGINX runs with user ID 3042.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当 Pod 启动时，NGINX 以用户 ID 3042 运行。
- en: ❷ The user ID 3042 belongs to group 4042.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用户 ID 3042 属于组 4042。
- en: ❸ If the NGINX process writes any files, they are written with the group ID
    of 5042.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果 NGINX 进程写入任何文件，它们将以组 ID 5042 写入。
- en: ❹ Changes the ownership of the volume before mounting the volume to the Pod
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在将卷挂载到Pod之前更改卷的所有权
- en: ❺ A mount point
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一个挂载点
- en: 'Let’s walk through this using a `kind` cluster. First, start your cluster:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`kind`集群来了解这个过程。首先，启动你的集群：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, create a NGINX deployment using the default container:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用默认容器创建NGINX部署：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You now have a running NGINX Pod. Next, `exec` into the Docker container that
    runs the `kind` cluster:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个正在运行的NGINX Pod。接下来，`exec`进入运行`kind`集群的Docker容器：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The process for NGINX is started as root.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ NGINX的进程是以root身份启动的。
- en: 'We can see that the NGINX process is running as root, and, yes, that is not
    the most secure. To prevent this, clean house and launch the other Pod. The next
    command removes the NGINX Pod:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到NGINX进程是以root身份运行的，是的，这不是最安全的。为了防止这种情况，清理环境并启动另一个Pod。下一个命令删除了NGINX Pod：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, create the Pod with the security context using the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令创建具有安全上下文的Pod：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And guess what happens? The Pod fails to start. Take a look at the logs:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜会发生什么？Pod启动失败。查看日志：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command outputs
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令输出
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What is the problem here? Why did this not work? The problem is that NGINX needs
    specific configurations in order to run as a non-root user, and many applications
    require configurations to run as the root. For this specific case, take a look
    at [http://mng.bz/ra4Z](http://mng.bz/ra4Z) or [http://mng.bz/Vl4O](http://mng.bz/Vl4O)
    for more information.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是什么？为什么它不起作用？问题是NGINX需要特定的配置才能以非root用户身份运行，而许多应用程序需要配置才能以root身份运行。对于这个特定的情况，请查看[http://mng.bz/ra4Z](http://mng.bz/ra4Z)或[http://mng.bz/Vl4O](http://mng.bz/Vl4O)以获取更多信息。
- en: 'The take away is this: don’t run your containers as root, and use a security
    context to ensure that they are not running as root.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 吸取的教训是：不要以root身份运行你的容器，并使用安全上下文来确保它们不以root身份运行。
- en: tip SSL certificates are a pain, and the code that uses those certificates can
    be just as difficult. You can often run into a problem with code that checks that
    a certificate’s user matches the process ID user. This creates havoc when you
    mount a TLS certificate as a Secret, which does not use the `fsGroup`. A current
    limitation in Kubernetes is when a mounted Secret does not match the `fsGroup`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：SSL证书很麻烦，使用这些证书的代码可能同样困难。你经常会遇到代码检查证书的用户是否与进程ID用户匹配的问题。当你将TLS证书作为Secret挂载时，这不会使用`fsGroup`，这就会造成混乱。Kubernetes的一个当前限制是当挂载的Secret与`fsGroup`不匹配时。
- en: 13.3.2 Escalated permissions and capabilities
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 提升的权限和能力
- en: 'Within the Linux security model, traditional UNIX permissions fall into two
    categories that describe a process—privileged and unprivileged:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux安全模型中，传统的UNIX权限分为两个类别，描述了一个进程——特权和非特权：
- en: A *privileged user* is a root or one whose effective user ID is zero because
    we can use `sudo` to act as the root.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*特权用户*是root用户或其有效用户ID为零的用户，因为我们可以使用`sudo`来充当root。
- en: An *unprivileged user* is a user whose ID is not zero.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*无特权用户*是一个ID不是零的用户。
- en: When you are a privileged user, the Linux kernel bypasses all Linux permission
    checks. That is why you can run the dreaded command `rm -rf /` as root. Most distros
    now at least ask if you want to delete the entire filesystem. When you have unprivileged
    access, all security permission checking is, in effect, based on the process’s
    ID.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你是一个特权用户时，Linux内核会绕过所有Linux权限检查。这就是为什么你可以作为root运行令人恐惧的命令`rm -rf /`。现在大多数发行版至少会询问你是否要删除整个文件系统。当你拥有无特权访问权限时，所有安全权限检查实际上都是基于进程ID的。
- en: When defining an unprivileged user and giving them an ID, you are able to provide
    the user with *capabilities*. These capabilities give an unprivileged user permission
    to do certain things, like making changes to file UIDs and GIDs. All of these
    capability names are prefixed with `CAP`; the capability that we just mentioned
    is `CAP_CHOWN`. That is great in Linux, but why do we care?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义一个无特权的用户并给他们一个ID时，你能够为用户提供*能力*。这些能力赋予无特权用户执行某些操作的权限，例如更改文件UID和GID。所有这些能力名称都以`CAP`为前缀；我们刚才提到的能力是`CAP_CHOWN`。这在Linux中是很好的，但为什么我们关心呢？
- en: 'Remember that we said not to run as root? Say we have a Pod that says that
    it needs to make a node networking iptables change or manage BPF (Berkley Packet
    Filter), such as a CNI provider, and we do not want to run that Pod as root. Kubernetes
    allows you to set the Pod’s security context, define the user ID, and then add
    specific capabilities. Here is an example of the YAML:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们说过不要以root用户运行吗？假设我们有一个Pod，它声称需要做出节点网络iptables更改或管理BPF（伯克利包过滤器），例如一个CNI提供者，而我们不想以root用户运行这个Pod。Kubernetes允许你设置Pod的安全上下文，定义用户ID，然后添加特定能力。以下是一个YAML示例：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Gives the user CAP_NET_ADMIN and CAT_BPF capabilities
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 给用户赋予CAP_NET_ADMIN和CAT_BPF能力
- en: One thing you will notice is that we removed the `CAP` prefix. Instead of `CAP_NET_ADMIN`,
    we have `NET_ADMIN`. We can do a lot of fun things using CAP permissions, including
    allowing a Pod to reboot a node with `CAP_SYS_BOOT`. Also, inside of CAP permission
    exists a subset that is called `CAP_SYS`. These are very powerful permissions.
    For instance, `CAP_SYS_ADMIN` basically sets root permissions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们移除了`CAP`前缀。`CAP_NET_ADMIN`变成了`NET_ADMIN`。我们可以使用CAP权限做很多有趣的事情，包括允许Pod使用`CAP_SYS_BOOT`重启节点。此外，在CAP权限中存在一个子集，称为`CAP_SYS`。这些权限非常强大。例如，`CAP_SYS_ADMIN`基本上设置了root权限。
- en: We have DaemonSets, Pods, and Deployments that administer our Kubernetes cluster,
    set iptables rules, bootstrap Kubernetes components, and so forth. There are so
    many use cases. Again, when you can, don’t run as root, but give the process the
    fewest permissions as possible via a CAP privilege. Admittedly, this is not as
    fine-grain as we might like. For instance, there is no one permission to mount
    a filesystem. In that case, you should use CAP_SYS_ADMIN.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有DaemonSets、Pods和Deployments来管理我们的Kubernetes集群，设置iptables规则，引导Kubernetes组件等等。有如此多的用例。再次强调，当你能的时候，不要以root用户运行，而是通过CAP权限给予尽可能少的权限。诚然，这并不像我们希望的那样精细。例如，没有挂载文件系统的单个权限。在这种情况下，你应该使用CAP_SYS_ADMIN。
- en: 13.3.3 Pod Security Policies (PSPs)
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.3 Pod安全策略（PSP）
- en: Note As of Kubernetes v1.21, PSPs are deprecated and are scheduled for removal
    in the v1.25 release, and they are being replaced by Pod Security Admission (see
    [http://mng.bz/5QQ4](http://mng.bz/5QQ4)). We are including this section because
    many people have used PSPs previously, and at the time of writing this book, Pod
    Security Standards are just in Beta.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：截至Kubernetes v1.21，PSP已被弃用，并计划在v1.25版本中删除，它们正被Pod安全准入（见[http://mng.bz/5QQ4](http://mng.bz/5QQ4)）所取代。我们包括这一部分是因为很多人之前使用过PSP，在撰写本书时，Pod安全标准还处于Beta测试阶段。
- en: 'In order to enforce the creation of proper Pod security contexts, you can define
    a Pod Security Policy (PSP) that enforces a defined security context setup. Like
    all other Kubernetes constructs, the PodSecurityPolicy is an API object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制创建适当的Pod安全上下文，你可以定义一个Pod安全策略（PSP），该策略强制执行定义的安全上下文设置。像所有其他Kubernetes结构一样，PodSecurityPolicy是一个API对象：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code snippet sets a variety of arbitrary rules around SELinux, users,
    and so on. Note that you can’t simply make every container secure. If you look
    at hyperkube, networking, storage plugins, and so on, you’ll see that these are
    system-level administrative infrastructure tools, which perform privileged actions
    (for example, setting iptables rules), that cannot simply be run in an unprivileged
    manner. Now, as we enable PSPs, you’ll find that many Pods may fail, and this
    can happen at unpredictable times. This is because PSPs are implemented at admission
    time by admission controllers. Let’s take a look at the life cycle of a security
    audit for containers in a Kubernetes cluster:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段设置了关于SELinux、用户等方面的各种任意规则。请注意，你不能简单地使每个容器都安全。如果你查看hyperkube、网络、存储插件等，你会看到这些是系统级管理基础设施工具，它们执行特权操作（例如，设置iptables规则），不能以非特权方式运行。现在，当我们启用PSP时，你会发现许多Pod可能会失败，并且这可能在不可预测的时间发生。这是因为PSP是由准入控制器在准入时实现的。让我们看看Kubernetes集群中容器安全审计的生命周期：
- en: Day0—Pods can do anything, include running as root and making files on hosts.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0天——Pod可以做任何事情，包括以root用户运行和在主机上创建文件。
- en: Day1—Developers build containers based on day0 functionality.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1天——开发者基于第0天的功能构建容器。
- en: Day2—Security auditors get a hold of this book.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2天——安全审计员拿到了这本书。
- en: Day3—RBAC is added to clusters. Now API calls are restricted to administrative
    accounts.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3天——RBAC被添加到集群中。现在API调用被限制在管理账户。
- en: Day4—PSPs get added to your cluster.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4天——PSP被添加到你的集群中。
- en: Day5—Half of your nodes go down for maintenance.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5天——一半的节点因维护而关闭。
- en: Day6—Several Pods are not healthily restarted.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6天——几个Pod没有健康地重启。
- en: The reason that Day 6 takes a while after the PSP addition is because once a
    Pod dies, its PSP is going to be tested in production. Thinking back to the way
    containers work, a running container already has a PID, has run any commands it
    needs, and is associated with a host network device. Thus, changing policies when
    containers are running does not securely eliminate threat vectors, but rather,
    prevents them from being introduced in new places. Figure 9.1 shows the PSP process
    for Kubernetes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第6天在PSP添加后需要一段时间的原因是，一旦Pod死亡，其PSP将在生产中进行测试。回顾一下容器的工作方式，一个正在运行的容器已经有一个PID，已经运行了它需要的任何命令，并且与主机网络设备相关联。因此，在容器运行时更改策略并不能安全地消除威胁向量，反而会阻止它们在新位置被引入。图9.1显示了Kubernetes的PSP过程。
- en: '![](../Images/CH13_F01_Love.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F01_Love.png)'
- en: Figure 13.1 Pod security policy (PSP)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 Pod安全策略（PSP）
- en: This is an important concept to take with you throughout the rest of this chapter.
    Every policy you implement might not be undoing the sins of the past. Exposed
    IP addresses, compromised SSL certificates, and open NFS mounts are still just
    as relevant in your Kubernetes data center as they were in your vSphere data center,
    and the rules of security don’t significantly get easier to implement because
    you’ve containerized your applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的概念，你应该在整个本章的其余部分都记住。你实施的每一项策略可能并不是在纠正过去的错误。暴露的IP地址、受损的SSL证书和开放的NFS挂载在Kubernetes数据中心中仍然与在vSphere数据中心中一样相关，而且由于你将应用程序容器化，安全规则并没有显著变得更容易实施。
- en: 13.3.4 Do not automount the service account token
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.4 不要自动挂载服务账户令牌
- en: By default, a service account token is automounted to a Pod. That token is used
    to authenticate with the API server in the Pod’s cluster. Yes, this is bad! Bad
    enough that one of the authors has personally used profanity to describe his disdain.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务账户令牌会自动挂载到Pod上。该令牌用于在Pod的集群中与API服务器进行身份验证。是的，这是不好的！坏到足以让一位作者亲自使用粗话来描述他的厌恶。
- en: 'Why does this API token exist? Sometimes Pods need to access the API server;
    for instance, an Operator that maintains a database may need to. That is a valid
    use case. But in reality, 99.999% of the Pods that run custom software do not
    need access to the API server. Therefore, you should disable the automounting
    of the default service account token. It is as simple as adding one line to a
    Pod YAML definition:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API令牌为什么存在呢？有时Pod需要访问API服务器；例如，维护数据库的操作员可能需要。这是一个有效的用例。但在现实中，99.999%运行自定义软件的Pod不需要访问API服务器。因此，你应该禁用默认服务账户令牌的自动挂载。这只需要在Pod
    YAML定义中添加一行即可：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Disables automount
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 禁用自动挂载
- en: Another way to address this is to turn off the default service account automount
    for all Pods. A service account (which we will talk about more later) also has
    the field `automountServiceAccountToken`. You can set any service account to not
    mount by default in that field.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方法是关闭所有Pod的默认服务账户自动挂载。服务账户（我们稍后会更多地讨论）还有一个字段`automountServiceAccountToken`。你可以设置任何服务账户在该字段中默认不挂载。
- en: 13.3.5 Root-like Pods
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.5 类似root的Pod
- en: With all the configurations that we have covered, it becomes like a balancing
    act between a Pod and a privileged user, an unprivileged user, or a unprivileged
    user with certain capabilities. But why is this? Why do we not just run all of
    our Pods as unprivileged users? Because many Kubernetes components need to act
    as a system administrator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了所有的配置，这就像在Pod和具有特权的用户、无特权的用户，或者具有某些能力的无特权的用户之间进行平衡。但为什么是这样呢？为什么我们不直接以无特权的用户运行所有的Pod呢？因为许多Kubernetes组件需要作为系统管理员来操作。
- en: 'Many Kubernetes components act as root, and these Pods mostly fall under the
    category of networking. The kubelet runs as root, but rarely runs inside a Pod.
    In every node, we have CNI Pods that configure the networking for a cluster, and
    those Pods need networking capability privileges. Although we cannot get around
    some security exposures, you can reduce your risk with Pods that are root-like,
    including Operators:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Kubernetes组件以root身份运行，这些Pod大多属于网络类别。kubelet以root身份运行，但很少在Pod内部运行。在每个节点上，我们都有CNI
    Pod来配置集群的网络，这些Pod需要网络能力权限。尽管我们无法避免某些安全漏洞，但你可以通过类似root的Pod来降低风险，包括操作员：
- en: Limit access to those Pods by putting them into a `kube-system` or other namespaces.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将它们放入`kube-system`或其他命名空间来限制对这些Pod的访问。
- en: Give them the least root-like permissions possible.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给予它们尽可能少的类似root的权限。
- en: Monitor them.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控它们。
- en: 13.3.6 The security outskirts
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.6 安全外围
- en: Kubernetes supports three other levels of Pod security that utilize Linux kernel
    functionality via modules or other built-in kernel features. These include
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持三个其他级别的Pod安全，这些安全级别通过模块或其他内置的内核功能利用Linux内核功能。这些包括
- en: '*AppArmor*—Profiles that run under a Linux kernel module provide process-level
    control.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AppArmor*—在Linux内核模块下运行的配置文件提供进程级别的控制。'
- en: '*seccomp*—Using functionality contained within the Linux kernel, secures a
    process so that it only can make defined security calls, or the process is SIGKILLed.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*seccomp*—通过Linux内核中包含的功能，确保进程只能执行定义的安全调用，否则进程会被SIGKILL终止。'
- en: '*SELinux*—Security-Enhanced Linux, another Linux kernel module, provides security
    policies that include mandatory access controls.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SELinux*—安全增强型Linux，另一个Linux内核模块，提供了包括强制访问控制在内的安全策略。'
- en: We are going to briefly mention these features, but won’t go into them in detail.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要提及这些功能，但不会深入探讨。
- en: If you are a RHEL shop, then running SELinux is understandable, but admittedly
    still hurts one author’s head. If you are running a popular open source database
    or software component that has a maintained AppArmor profile, then it may make
    sense to use the profile. seccomp is incredibly powerful, but it takes a lot of
    work to maintain. Admittedly, both AppArmor profiles and seccomp are complex,
    and complexity often creates brittle security.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一家RHEL商店，那么运行SELinux是可以理解的，但诚实地讲，这还是让一位作者头疼。如果你运行的是一个有维护的AppArmor配置文件的流行开源数据库或软件组件，那么使用该配置文件可能是有意义的。seccomp功能非常强大，但维护它需要大量工作。诚实地讲，AppArmor配置文件和seccomp都是复杂的，而复杂性往往会导致脆弱的安全。
- en: 'There are always use cases that require another level of process security,
    but as with most things, we try to follow a few guidelines, mainly: KISS (Keep
    it simple, stupid), the law of diminishing returns, and the 80/20 rule (before
    you start implementing one of these measures, get 80% of the security done).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一些用例需要另一个级别的进程安全，但就像大多数事情一样，我们试图遵循一些指导原则，主要是：KISS（保持简单，傻瓜），递减回报定律，以及80/20规则（在你开始实施这些措施之前，先完成80%的安全工作）。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: If we do not have a focus on security, we allow people to waltz in and invade
    our clusters. Security is a series of tradeoffs that are often fraught with hard
    decisions, but by utilizing simple and basic practices, we can reduce the impact
    of a security risk.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有关注安全，就会让人们随意进入并入侵我们的集群。安全是一系列充满艰难决策的权衡，但通过利用简单和基本的做法，我们可以减少安全风险的影响。
- en: You do not need to implement all of the security precautions yourself. There
    is a growing set of tools that track containers and determine what possible security
    holes exist.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要自己实现所有的安全预防措施。有一套不断增长的工具可以跟踪容器并确定可能存在的安全漏洞。
- en: The most obvious place to start with Kubernetes security is at the container
    level. Container provenance allows you to trace the source of a container to a
    trusted point of origin.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes安全的最明显起点是在容器级别。容器来源允许你追踪容器的来源到一个可信的起点。
- en: Don’t run your containers as root, especially if your environment uses containers
    that are *not* built by your organization.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要以root用户运行你的容器，尤其是如果你的环境使用的是**不是**由你的组织构建的容器。
- en: To find common problems with containers that can cause security vulnerabilities,
    run a linter like hadolint.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找到可能导致安全漏洞的容器常见问题，运行一个linter，如hadolint。
- en: If your application does not need it, don’t install extra software. The more
    you have installed, the greater your number of possible vulnerabilities.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序不需要它，不要安装额外的软件。安装的越多，你可能存在的漏洞数量就越多。
- en: To secure individual Pods, you should disable the automounting of the default
    service account token. Alternatively, you can turn off the default service account
    automount for all Pods.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保单个Pod的安全，你应该禁用默认服务账户令牌的自动挂载。或者，你也可以关闭所有Pod的默认服务账户自动挂载。
- en: Give a process the fewest permissions possible via a `CAP` privilege.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`CAP`权限给进程尽可能少的权限。
- en: DevOps is built on automation, as is Kubernetes, and security automation is
    key to reducing workload and improving systems.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps建立在自动化之上，Kubernetes也是如此，安全自动化是减少工作负载和改进系统的关键。
- en: Update your containers and software dependencies.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新你的容器和软件依赖。
