- en: 4 Interaction testing using mock objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 使用模拟对象进行交互测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining interaction testing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义交互测试
- en: Reasons to use mock objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模拟对象的原因
- en: Injecting and using mocks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入和使用模拟对象
- en: Dealing with complicated interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理复杂的接口
- en: Partial mocks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分模拟
- en: In the previous chapter, we solved the problem of testing code that depends
    on other objects to run correctly. We used stubs to make sure that the code under
    test received all the inputs it needed so that we could test the unit of work
    in isolation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们解决了测试依赖于其他对象才能正确运行的代码的问题。我们使用存根来确保被测试的代码收到了它需要的所有输入，这样我们就可以单独测试工作单元。
- en: 'So far, you’ve only written tests that work against the first two of the three
    types of exit points a unit of work can have: *returning a value* and *changing
    the state of the system* (you can read more about these types in chapter 1). In
    this chapter, we’ll look at how you can test the third type of exit point—a call
    to a third-party function, module, or object. This is important, because often
    we’ll have code that depends on things we can’t control. Knowing how to check
    that type of code is an important skill in the world of unit testing. Basically,
    we’ll find ways to prove that our unit of work ends up calling a function that
    we don’t control and identify what values were sent as arguments.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只编写了针对工作单元可能拥有的三种类型的出口点中的前两种类型的测试：*返回值*和*改变系统状态*（你可以在第1章中了解更多关于这些类型的信息）。在本章中，我们将探讨如何测试第三种类型的出口点——调用第三方函数、模块或对象。这很重要，因为通常我们会有依赖于我们无法控制的代码。知道如何检查这种类型的代码是单元测试领域的重要技能。基本上，我们将找到方法来证明我们的工作单元最终调用了我们无法控制的函数，并识别发送作为参数的值。
- en: The approaches we’ve looked at so far won’t do here, because third-party functions
    usually don’t have specialized APIs that allow us to check if they were called
    correctly. Instead, they internalize their operations for clarity and maintainability.
    So, how can you test that your unit of work interacts with third-party functions
    correctly? You use mocks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止探讨的方法在这里不起作用，因为第三方函数通常没有专门的API允许我们检查它们是否被正确调用。相反，它们为了清晰性和可维护性而内部化其操作。那么，你如何测试你的工作单元是否正确地与第三方函数交互呢？你使用模拟。
- en: 4.1 Interaction testing, mocks, and stubs
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 交互测试、模拟和存根
- en: '*Interaction testing* is checking how a unit of work interacts with and sends
    messages (i.e., calls functions) to a dependency beyond its control. Mock functions
    or objects are used to assert that a call was made correctly to an external dependency.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*交互测试*是检查工作单元如何与和控制之外的依赖项交互，并发送消息（即调用函数）。使用模拟函数或对象来断言是否正确地调用了外部依赖项。'
- en: 'Let’s recall the differences between mocks and stubs as we covered them in
    chapter 3\. The main difference is in the flow of information:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在第3章中我们讨论的模拟和存根之间的区别。主要区别在于信息流：
- en: '*Mock*—Used to break outgoing dependencies. Mocks are fake modules, objects,
    or functions that we assert were called in our tests. A mock represents an *exit
    point* in a unit test. If we don’t assert on it, it’s not used as a mock.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模拟*——用于断开传出的依赖。模拟是我们断言在测试中被调用的虚假模块、对象或函数。模拟代表单元测试中的一个*出口点*。如果我们不对它进行断言，它就不会作为模拟使用。'
- en: It is normal to have no more than a single mock per test, for maintainability
    and readability reasons. (We’ll discuss this more in part 3 of this book about
    writing maintainable tests.)
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于测试的可维护性和可读性而言，每个测试最多只有一个模拟对象是正常的。（我们将在本书关于编写可维护测试的第三部分中进一步讨论这个问题。）
- en: '*Stub*—Used to break incoming dependencies. Stubs are fake modules, objects,
    or functions that provide fake behavior or data to the code under test. We do
    not assert against them, and we can have many stubs in a single test.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存根*——用于断开传入的依赖。存根是提供虚假行为或数据的虚假模块、对象或函数，用于被测试的代码。我们不对它们进行断言，并且可以在单个测试中拥有多个存根。'
- en: Stubs represent waypoints, not exit points, because the data or behavior flows
    *into* the unit of work. They are points of interaction, but they do not represent
    an ultimate outcome of the unit of work. Instead, they are an interaction *on
    the way* to achieving the end result we care about, so we don’t treat them as
    exit points.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存根代表的是途径点，而不是出口点，因为数据或行为是流向工作单元的。它们是交互点，但并不代表工作单元的最终结果。相反，它们是通往我们关心的最终结果的交互途径，因此我们不将它们视为出口点。
- en: Figure 4.1 shows these two side by side.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1显示了这两个对象并排展示。
- en: '![04-01](../Images/04-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![04-01](../Images/04-01.png)'
- en: Figure 4.1 On the left, an exit point that is implemented as invoking a dependency.
    On the right, the dependency provides indirect input or behavior and is not an
    exit point.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 左边，一个实现为调用依赖项的出口点。右边，依赖项提供间接输入或行为，不是一个出口点。
- en: 'Let’s look at a simple example of an exit point to a dependency that we do
    not control: calling a logger.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子，这是一个我们不控制的依赖项的出口点：调用日志记录器。
- en: 4.2 Depending on a logger
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 依赖于日志记录器
- en: Let’s take this Password Verifier function as our starting example, and we’ll
    assume we have a complicated logger (which is a logger that has more functions
    and parameters, so the interface may present more of a challenge). One of the
    requirements of our function is to call the logger when verification has passed
    or failed, as follows.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个密码验证器函数作为我们的起始示例，并假设我们有一个复杂的日志记录器（它具有更多函数和参数，因此接口可能更具挑战性）。我们函数的一个要求是在验证通过或失败时调用日志记录器，如下所示。
- en: Listing 4.1 Depending directly on a complicated logger
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 直接依赖于复杂的日志记录器
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Exit point
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 出口点
- en: 'Figure 4.2 illustrates this. Our `verifyPassword` function is the entry point
    to the unit of work, and we have a total of two exit points: one that returns
    a value, and another that calls `log.info()`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2展示了这一点。我们的`verifyPassword`函数是工作单元的入口点，我们总共有两个出口：一个返回值，另一个调用`log.info()`。
- en: '![04-02](../Images/04-02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![04-02](../Images/04-02.png)'
- en: Figure 4.2 The entry point to the Password Verifier is the `verifyPassword`
    function. One exit point returns a value, and the other calls `log.info()`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 密码验证器的入口点是`verifyPassword`函数。一个出口点返回一个值，另一个调用`log.info()`。
- en: Unfortunately, we cannot verify that `logger` was called by using any traditional
    means, or without using some Jest tricks, which I usually use only if there’s
    no other choice, as they tend to make tests less readable and harder to maintain
    (more on that later in this chapter).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法使用任何传统方法来验证`logger`是否被调用，或者不使用一些Jest技巧，因为我通常只有在没有其他选择时才会使用这些技巧，因为它们往往会使得测试更难以阅读和维护（关于这一点，本章后面会详细说明）。
- en: 'Let’s do what we like to do with dependencies: *abstract them*. There are many
    ways to create a seam in our code. Remember, *seams* are places where two pieces
    of code meet—we can use them to inject fake things. Table 4.1 lists the most common
    ways to abstract dependencies.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用我们喜欢的方式处理依赖项：*抽象它们*。在我们的代码中创建接口有许多方法。记住，*接口*是两段代码相遇的地方——我们可以利用它们来注入假数据。表4.1列出了抽象依赖项最常见的方法。
- en: Table 4.1 Techniques for injecting fakes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 注入伪造的技术
- en: '| Style | Technique |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 风格 | 技术 |'
- en: '| Standard | Introduce parameter |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 标准 | 引入参数 |'
- en: '| Functional | Use curryingConvert to higher-order functions |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 函数式 | 使用柯里化转换为高阶函数 |'
- en: '| Modular | Abstract module dependency |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 模块化 | 抽象模块依赖 |'
- en: '| Object oriented | Inject untyped objectInject interface |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 面向对象 | 注入未类型化对象注入接口 |'
- en: '4.3 Standard style: Introduce parameter refactoring'
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 标准风格：引入参数重构
- en: The most obvious way we can start this journey is by introducing a new parameter
    into our code under test.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始这段旅程的最明显方式是在我们正在测试的代码中引入一个新参数。
- en: Listing 4.2 Mock logger parameter injection
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 模拟日志参数注入
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following listing shows how we could write the simplest of tests for this,
    using a simple closure mechanism.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了我们可以如何使用简单的闭包机制编写这个最简单的测试。
- en: Listing 4.3 Handwritten mock object
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 手写模拟对象
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice first that we are naming the variable `mockXXX` (`mockLog` in this example)
    to denote the fact that we have a mock function or object in the test. I use this
    naming convention because I want you, as a reader of the test, to know that you
    should expect an assert (also known as *verification*) against that mock at the
    end of the test. This naming approach removes the element of surprise for the
    reader and makes the test much more predictable. Only use this naming convention
    for things that are actually mocks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们给变量命名`mockXXX`（在这个例子中是`mockLog`）以表明我们在测试中有一个模拟函数或对象。我使用这种命名约定是因为我想让你，作为测试的读者，知道你应该在测试结束时对那个模拟进行断言（也称为*验证*）。这种命名方法消除了读者的惊喜元素，使得测试更加可预测。仅对实际是模拟的事物使用这种命名约定。
- en: 'Here’s our first mock object:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个模拟对象：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It only has one function, which mimics the signature of the logger’s `info`
    function. It then saves the parameter being passed to it (`text`) so that we can
    assert that it was called later in the test. If the `written` variable has the
    correct text, this proves that our function was called, which means we have proven
    that the exit point is invoked correctly from our unit of work.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有一个功能，模仿了日志记录器`info`函数的签名。然后它保存传递给它的参数（`text`），以便我们可以在测试的稍后阶段断言它被调用。如果`written`变量包含正确的文本，这证明了我们的函数被调用，这意味着我们已经证明了从我们的工作单元正确调用了出口点。
- en: On the `verifyPassword2` side, the refactoring we did is pretty common. It’s
    pretty much the same as we did in the previous chapter, where we extracted a *stub*
    as a dependency. Stubs and mocks are often treated the same way in terms of refactoring
    and introducing seams in our application’s code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`verifyPassword2`这一侧，我们进行的重构相当常见。这几乎与我们在上一章中做的一样，当时我们提取了一个*存根*作为依赖项。在重构和引入应用程序代码中的接口方面，存根和模拟通常被同等对待。
- en: What did this simple refactoring into a parameter provide us with?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的重构为参数提供了什么？
- en: We do not need to explicitly import (via `require`) the `logger` in our code
    under test anymore. That means that if we ever change the real dependency of the
    logger, the code under test will have one less reason to change.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再需要在测试代码中显式地导入（通过`require`）`logger`了。这意味着，如果我们更改了`logger`的实际依赖项，测试代码将减少一个需要更改的理由。
- en: 'We now have the ability to inject *any logger* of our choosing into the code
    under test, as long as it lives up to the same interface (or at least has the
    `info` method). This means that we can provide a mock logger that does our bidding
    for us: the mock logger helps us verify that it was called correctly.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有能力将任何我们选择的`logger`注入到测试代码中，只要它符合相同的接口（或者至少有`info`方法）。这意味着我们可以提供一个为我们服务的模拟日志记录器：模拟日志记录器帮助我们验证它是否被正确调用。
- en: 'Note The fact that our mock object only mimics a part of the `logger`’s interface
    (it’s missing the `debug` function) is a form of duck typing. I discussed this
    idea in chapter 3: if it walks like a duck, and it talks like a duck, then we
    can use it as a fake object.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们的模拟对象只模拟了`logger`接口的一部分（缺少`debug`函数），这是一种鸭子类型的形式。我在第三章讨论了这个想法：如果它像鸭子走路，如果它像鸭子说话，那么我们可以将其用作一个假对象。
- en: 4.4 The importance of differentiating between mocks and stubs
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 区分模拟和存根的重要性
- en: Why do I care so much about what we name each thing? If we can’t tell the difference
    between mocks and stubs, or we don’t name them correctly, we can end up with tests
    that are testing multiple things and that are less readable and harder to maintain.
    Naming things correctly helps us avoid these pitfalls.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我如此关心我们给每个事物取的名字？如果我们无法区分模拟和存根，或者我们没有正确命名它们，我们可能会得到测试多个事物且可读性差、更难维护的测试。正确命名事物有助于我们避免这些陷阱。
- en: 'Given that a mock represents a requirement from our unit of work (“it calls
    the logger,” “it sends an email,” etc.) and that a stub represents incoming information
    or behavior (“the database query returns false,” “this specific configuration
    throws an error”), we can set a simple rule of thumb: It should be OK to have
    multiple stubs in a test, but you don’t usually want to have more than a *single
    mock* per test, because that would mean you’re testing more than one requirement
    in a single test.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模拟代表了我们工作单元的要求（“它调用日志记录器”，“它发送电子邮件”等），而存根代表传入的信息或行为（“数据库查询返回false”，“这个特定的配置抛出错误”），我们可以设定一个简单的规则：在测试中拥有多个存根是可以接受的，但你通常不希望每个测试中只有一个*模拟*，因为这意味着你在单个测试中测试了多个要求。
- en: 'If we can’t (or won’t) differentiate between things (naming is key to that),
    we can end up with multiple mocks per test or asserting our stubs, both of which
    can have negative effects on our tests. Keeping naming consistent gives us the
    following benefits:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法（或不愿意）区分事物（命名是关键），我们可能会在每个测试中拥有多个模拟，或者断言我们的存根，这两者都可能对我们的测试产生负面影响。保持命名一致性给我们带来以下好处：
- en: '*Readability*—Your test name will become much more generic and harder to understand.
    You want people to be able to read the name of the test and know everything that
    happens or is tested inside of it, without needing to read the test’s code.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可读性*—你的测试名称将变得更加通用，更难以理解。你希望人们能够阅读测试名称并了解其中发生或测试的所有内容，而无需阅读测试代码。'
- en: '*Maintainability*—You could, without noticing or even caring, assert against
    stubs if you don’t differentiate between mocks and stubs. This produces little
    value to you and increases the coupling between your tests and internal production
    code. Asserting that you queried a database is a good example of this. Instead
    of testing that a database query returns some value, it would be much better to
    test that the application’s behavior changes after we change the input from the
    database.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性*——如果你没有区分模拟和存根，你可能会不经意或甚至不在乎地针对存根进行断言。这对你几乎没有价值，并且增加了你的测试和内部生产代码之间的耦合。断言你查询了数据库就是一个很好的例子。与其测试数据库查询返回某些值，不如测试在改变数据库输入后，应用程序的行为是否发生变化。'
- en: '*Trust*—If you have multiple mocks (requirements) in a single test, and the
    first mock verification fails the test, most test frameworks won’t execute the
    rest of the test (below the failing assert line) because an exception has been
    thrown. This means that the other mocks aren’t verified, and you won’t get the
    results from them.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信任*——如果你在单个测试中有多个模拟（需求），并且第一个模拟验证失败导致测试失败，大多数测试框架不会执行测试的其余部分（在失败的断言行以下），因为已经抛出了异常。这意味着其他模拟没有被验证，你不会从它们那里得到结果。'
- en: To drive the last point home, imagine a doctor who only sees 30% of their patient’s
    symptoms, but still needs to make a decision—they might make the wrong decision
    about treatment. If you can’t see where all the bugs are, or that two things are
    failing instead of just one (because one of them is hidden after the first failure),
    you’re more likely to fix the wrong thing or to fix it in the wrong place.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调最后一点，想象一个只看到患者30%症状的医生，但仍然需要做出决定——他们可能会在治疗上做出错误的决定。如果你看不到所有错误在哪里，或者两件事物都在失败而不是只有一件（因为其中一件在第一次失败后被隐藏），你更有可能修复错误的事物或错误地修复它。
- en: '*XUnit Test Patterns* (*Addison-Wesley, 2007)*, by *Gerard Meszaros,* calls
    this situation *assertion roulette* ([http://xunitpatterns.com/Assertion%20Roulette.html](http://xunitpatterns.com/Assertion%20Roulette.html)).
    I like this name. It’s quite a gamble. You start commenting out lines of code
    in your test, and lots of fun ensues (and possibly alcohol).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*《XUnit 测试模式》* (*Addison-Wesley, 2007*)，由 *Gerard Meszaros* 编著，称这种情况为 *断言轮盘赌*
    ([http://xunitpatterns.com/Assertion%20Roulette.html](http://xunitpatterns.com/Assertion%20Roulette.html))。我喜欢这个名字。这相当是一场赌博。你开始注释掉测试中的代码行，随之而来的是很多乐趣（以及可能还有酒精）。'
- en: Not everything is a mock
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有事物都是模拟
- en: It’s unfortunate that people still tend to use the word “mock” for anything
    that isn’t real, such as “mock database” or “mock service.” Most of the time they
    really mean they are using a stub.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，人们仍然倾向于使用“mock”这个词来指代任何非真实的事物，例如“mock 数据库”或“mock 服务”。大多数时候他们真正意味着他们正在使用一个存根。
- en: It’s hard to blame them, though. Frameworks like Mockito, jMock, and most isolation
    frameworks (I don’t call them mocking frameworks, for the same reasons I’m discussing
    right now), use the word “mock” to denote both mocks and stubs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很难责怪他们。像 Mockito、jMock 以及大多数隔离框架（我不称它们为模拟框架，原因和我在讨论的相同），使用“mock”这个词来表示模拟和存根。
- en: There are newer frameworks, such as Sinon and testdouble in JavaScript, NSubstitute
    and FakeItEasy in .NET, and others, that have helped start a change in the naming
    conventions. I hope this persists.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一些新的框架，例如 JavaScript 中的 Sinon 和 testdouble，.NET 中的 NSubstitute 和 FakeItEasy，以及其他一些框架，它们帮助启动了命名约定的变革。我希望这种变革能够持续下去。
- en: 4.5 Modular-style mocks
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 模块化风格的存根
- en: I covered modular dependency injection in the previous chapter, but now we’re
    going to look at how we can use it to inject mock objects and simulate answers
    on them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上一章中介绍了模块化依赖注入，但现在我们将看看我们如何可以使用它来注入模拟对象并在它们上模拟答案。
- en: 4.5.1 Example of production code
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 生产代码示例
- en: 'Let’s look at a slightly more complicated example than we saw before. In this
    scenario, our `verifyPassword` function depends on two external dependencies:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个比之前更复杂的例子。在这个场景中，我们的 `verifyPassword` 函数依赖于两个外部依赖项：
- en: A logger
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个日志记录器
- en: A configuration service
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个配置服务
- en: The configuration service provides the logging level that is required. Usually
    this type of code would be moved into a special logger module, but for the purposes
    of this book’s examples, I’m putting the logic that calls `logger.info` and `logger.debug`
    directly in the code under test.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 配置服务提供所需的日志级别。通常这类代码会被移动到一个特殊的日志记录器模块中，但为了本书示例的目的，我将调用 `logger.info` 和 `logger.debug`
    的逻辑直接放在被测试的代码中。
- en: Listing 4.4 A hard modular dependency
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 一个硬模块化依赖
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Calling the logger
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用日志记录器
- en: Let’s assume that we realized we have a bug when we call the logger. We’ve changed
    the way we check for failures, and now we call the logger with a `PASSED` result
    when the number of failures is positive instead of zero. How can we prove that
    this bug exists, or that we’ve fixed it, with a unit test?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在调用日志记录器时意识到我们有一个错误。我们已经更改了检查失败的方式，现在当失败次数为正而不是零时，我们用 `PASSED` 结果调用日志记录器。我们如何通过单元测试来证明这个错误存在，或者我们已经修复了它？
- en: Our problem here is that we are importing (or requiring) the modules directly
    in our code. If we want to replace the logger module, we have to either replace
    the file or perform some other dark magic through Jest’s API. I wouldn’t recommend
    that usually, because using these techniques leads to more pain and suffering
    than is usual when dealing with code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的问题是我们在代码中直接导入（或要求）模块。如果我们想替换日志记录器模块，我们必须替换文件或通过 Jest 的 API 执行一些其他黑暗魔法。我不建议这样做，因为使用这些技术会导致比处理代码时通常更多的痛苦和折磨。
- en: 4.5.2 Refactoring the production code in a modular injection style
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 以模块注入风格重构生产代码
- en: We can abstract away the module dependencies into their own object and allow
    the user of our module to replace that object as follows.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将模块依赖项抽象成它们自己的对象，并允许我们的模块用户按以下方式替换该对象。
- en: Listing 4.5 Refactoring to a modular injection pattern
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 重构为模块注入模式
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Holding original dependencies
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 保留原始依赖项
- en: ❷ The layer of indirection
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 间接层
- en: ❸ A function that resets the dependencies
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个重置依赖项的函数
- en: ❹ A function that overrides the dependencies
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一个覆盖依赖项的函数
- en: ❺ Exposing the API to the users of the module
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 向模块用户公开 API
- en: There’s more production code here, and it seems more complex, but this allows
    us to replace dependencies in our tests in a relatively easy manner if we are
    forced to work in such a modular fashion.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些生产代码，看起来更复杂，但如果我们被迫以模块化的方式工作，这允许我们相对容易地替换测试中的依赖项。
- en: The `originalDependencies` variable will always hold the original dependencies,
    so that we never lose them between tests. `dependencies` is our layer of indirection.
    It defaults to the original dependencies, but our tests can direct the code under
    test to replace that variable with custom dependencies (without knowing anything
    about the internals of the module). `injectDependencies` and `resetDependencies`
    are the public API that the module exposes for overriding and resetting the dependencies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`originalDependencies` 变量将始终保留原始依赖项，这样我们就不至于在测试之间丢失它们。`dependencies` 是我们的间接层。它默认为原始依赖项，但我们的测试可以指导被测试代码用自定义依赖项替换该变量（而无需了解模块的内部结构）。`injectDependencies`
    和 `resetDependencies` 是模块公开的 API，用于覆盖和重置依赖项。'
- en: 4.5.3 A test example with modular-style injection
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 模块式注入的测试示例
- en: The following listing shows what a test for modular injection might look like.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了模块注入测试可能的样子。
- en: Listing 4.6 Testing with modular injection
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 使用模块注入进行测试
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As long as we don’t forget to use the `resetDependencies` function after each
    test, we can now inject modules pretty easily for test purposes. The obvious main
    caveat is that this approach requires each module to expose inject and reset functions
    that can be used from the outside. This might or might not work with your current
    design limitations, but if it does, you can abstract them both into reusable functions
    and save yourself a lot of boilerplate code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们记得在每个测试后使用 `resetDependencies` 函数，现在我们就可以很容易地为测试目的注入模块。明显的最大缺点是，这种方法要求每个模块公开可以从外部使用的注入和重置函数。这可能或可能不适用于您当前的设计限制，但如果适用，您可以将它们都抽象成可重用的函数，从而节省大量的样板代码。
- en: 4.6 Mocks in a functional style
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 函数式风格的模拟
- en: Let’s jump into a few of the functional styles we can use to inject mocks into
    our code under test.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们可以用来将模拟注入到被测试代码中的几种函数式风格。
- en: 4.6.1 Working with a currying style
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.1 使用柯里化风格工作
- en: Let’s implement the currying technique introduced in chapter 3 to perform a
    more functional-style injection of our logger. In the following listing, we’ll
    use `lodash`, a library that facilitates functional programming in JavaScript,
    to get currying working without too much boilerplate code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现第 3 章中介绍的柯里化技术，以执行更函数式风格的日志记录器注入。在以下列表中，我们将使用 `lodash`，这是一个促进 JavaScript
    函数式编程的库，以在不产生太多样板代码的情况下实现柯里化。
- en: Listing 4.7 Applying currying to our function
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 将柯里化应用于我们的函数
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only change is the call to `_.curry` on the first line, and closing it off
    at the end of the code block.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的改变是在第一行调用 `_.curry`，并在代码块末尾关闭它。
- en: The following listing demonstrates what a test for this type of code might look
    like.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表演示了这种类型代码的测试可能的样子。
- en: Listing 4.8 Testing a curried function with dependency injection
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 使用依赖注入测试柯里化函数
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our test invokes the function with the first two arguments (injecting the `rules`
    and `logger` dependencies, effectively returning a partially applied function),
    and then invokes the returned function `injectedVerify` with the final input,
    thus showing the reader two things:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试用前两个参数调用该函数（注入 `rules` 和 `logger` 依赖项，实际上返回一个部分应用函数），然后使用最终输入调用返回的函数 `injectedVerify`，从而向读者展示两件事：
- en: How this function is meant to be used in real life
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数在现实生活中是如何使用的
- en: What the dependencies are
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项是什么
- en: Other than that, it’s pretty much the same as in the previous test.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，其他方面与之前的测试几乎相同。
- en: 4.6.2 Working with higher-order functions and not currying
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6.2 与高阶函数一起工作而不使用柯里化
- en: Listing 4.9 is another variation on the functional programming design. We’re
    using a higher-order function, but without currying. You can tell that the following
    code does not contain currying because we always need to send in all of the parameters
    as arguments to the function for it to be able to work correctly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 是函数式编程设计的另一种变体。我们使用高阶函数，但没有使用柯里化。你可以从以下代码中看出它不包含柯里化，因为我们始终需要将所有参数作为参数发送给函数，以便它能够正确工作。
- en: Listing 4.9 Injecting a mock in a higher-order function
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 在高阶函数中注入模拟
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Returning a preconfigured verifier
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回预配置的验证器
- en: This time I’m explicitly making a factory function that returns a *preconfigured
    verifier function* that already contains the `rules` and `logger` in its closure’s
    dependencies.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我明确地创建了一个工厂函数，该函数返回一个*预配置的验证器函数*，它已经在其闭包的依赖项中包含了 `rules` 和 `logger`。
- en: Now let’s look at the test for this. The test needs to first call the `makeVerifier`
    factory function and then call the function that’s returned by that function (`passVerify`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看对这个的测试。测试需要首先调用 `makeVerifier` 工厂函数，然后调用那个函数返回的函数 (`passVerify`)。
- en: Listing 4.10 Testing using a factory function
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 使用工厂函数进行测试
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Calling the factory function
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用工厂函数
- en: ❷ Calling the resulting function
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用生成的函数
- en: 4.7 Mocks in an object-oriented style
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 以面向对象风格使用模拟
- en: Now that we’ve covered some functional and modular styles, let’s look at the
    object-oriented styles. People coming from an object-oriented background will
    feel much more comfortable with this type of approach, and people coming from
    a functional background will hate it. But life is about accepting people’s differences.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些函数式和模块化风格，让我们来看看面向对象风格。来自面向对象背景的人会对此类方法感到更加舒适，而来自函数式背景的人可能会讨厌它。但生活就是关于接受人们的不同之处。
- en: 4.7.1 Refactoring production code for injection
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.1 对生产代码进行重构以实现注入
- en: Listing 4.11 shows what this type of injection might look like in a class-based
    design in JavaScript. Classes have constructors, and we use the constructor to
    force the caller of the class to provide parameters. This is not the only way
    to accomplish that, but it’s very common and useful in an object-oriented design
    because it makes the requirement of those parameters explicit and practically
    undeniable in strongly typed languages such as Java or C, and when using TypeScript.
    We want to make sure whoever uses our code knows what is expected to configure
    it properly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 展示了在 JavaScript 的基于类的设计中这种类型的注入可能看起来是什么样子。类有构造函数，我们使用构造函数来强制类的调用者提供参数。这不是实现这一点的唯一方法，但在面向对象的设计中非常常见且有用，因为它使得这些参数的要求明确，在强类型语言如
    Java 或 C 以及使用 TypeScript 时几乎不可否认。我们想确保使用我们代码的任何人都能知道如何正确配置它。
- en: Listing 4.11 Class-based constructor injection
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 基于类的构造函数注入
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is just a standard class that takes a couple of constructor parameters
    and then uses them inside the `verify` function. The following listing shows what
    a test might look like.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个标准的类，它接受几个构造函数参数，然后在 `verify` 函数中使用它们。以下列表展示了测试可能的样子。
- en: Listing 4.12 Injecting a mock logger as a constructor parameter
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 将模拟日志记录器作为构造函数参数注入
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Mock injection is straightforward, much like with stubs, as we saw in the previous
    chapter. If we were to use properties rather than a constructor, it would mean
    that the dependencies are *optional*. With a constructor, we’re explicitly saying
    they’re not optional.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟注入与上章中提到的存根类似，非常简单。如果我们使用属性而不是构造函数，这意味着依赖项是*可选的*。使用构造函数，我们明确表示它们不是可选的。
- en: 'In strongly typed languages like Java or C#, it’s common to extract the fake
    logger as a separate class, like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Java 或 C# 这样的强类型语言中，通常会将伪日志记录器提取为一个单独的类，如下所示：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We simply implement the `info` function in the class, but instead of logging
    anything, we just save the value being sent as a parameter to the function in
    a publicly visible variable that we can assert again later in our test.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在类中实现 `info` 函数，但不是记录任何内容，而是将作为函数参数发送的值保存在一个公开可见的变量中，这样我们就可以在测试的稍后阶段断言它。
- en: Notice that I didn’t call the fake object `MockLogger` or `StubLogger` but `FakeLogger`.
    This is so that I can reuse this class in multiple different tests. In some tests,
    it might be used as a stub, and in others it might be used as a mock object. I
    use the word “fake” to denote anything that isn’t *real*. Another common term
    for this sort of thing is “test double.” Fake is shorter, so I like it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我没有将伪对象命名为 `MockLogger` 或 `StubLogger`，而是命名为 `FakeLogger`。这样，我就可以在多个不同的测试中重用这个类。在某些测试中，它可能被用作存根，而在其他测试中，它可能被用作模拟对象。我使用“fake”这个词来表示任何不是*真实*的东西。这类事物的另一个常见术语是“测试替身”。由于“fake”这个词更短，所以我更喜欢它。
- en: 'In our tests, we’ll instantiate the class and send it over as a constructor
    parameter, and then we’ll assert on the `logged` variable of the class, like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们将实例化这个类，并将其作为构造函数参数发送，然后我们将断言类的 `logged` 变量，如下所示：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 4.7.2 Refactoring production code with interface injection
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7.2 使用接口重构生产代码
- en: 'Interfaces play a large role in many object-oriented programs. They are one
    variation on the idea of *polymorphism*: allowing one or more objects to be replaced
    with one another as long as they implement the same interface. In JavaScript and
    other languages like Ruby, interfaces are not needed, since the language allows
    for the idea of duck typing without needing to cast an object to a specific interface.
    I won’t touch here on the pros and cons of duck typing. You should be able to
    use either technique as you see fit, in the language of your choice. In JavaScript,
    we can turn to TypeScript to use interfaces. The compiler, or *transpiler*, we’ll
    use can help ensure that we are using types based on their signatures correctly.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在许多面向对象程序中扮演着重要角色。它们是*多态*概念的一种变体：只要对象实现了相同的接口，就可以用其他对象替换一个或多个对象。在 JavaScript
    和 Ruby 等其他语言中，不需要接口，因为语言允许使用无需将对象显式转换为特定接口的鸭子类型。在这里，我不会涉及鸭子类型优缺点的讨论。你应该能够根据需要，在你的选择的语言中使用任何一种技术。在
    JavaScript 中，我们可以转向 TypeScript 来使用接口。我们将使用的编译器，或称为*转换器*，可以帮助确保我们正确地根据它们的签名使用类型。
- en: 'Listing 4.13 shows three code files: the first describes a new `ILogger` interface,
    the second describes a `SimpleLogger` that implements that interface, and the
    third is our `PasswordVerifier`, which uses only the `ILogger` interface to get
    a logger instance. `PasswordVerifier` has no knowledge of the actual type of logger
    being injected.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 显示了三个代码文件：第一个描述了一个新的 `ILogger` 接口，第二个描述了一个实现了该接口的 `SimpleLogger`，第三个是我们的
    `PasswordVerifier`，它只使用 `ILogger` 接口来获取日志记录器实例。`PasswordVerifier` 对注入的实际日志记录器类型一无所知。
- en: Listing 4.13 Production code gets an `ILogger` interface
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 生产代码获取 `ILogger` 接口
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ A new interface, which is part of production code
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个新的接口，它是生产代码的一部分
- en: ❷ The logger now implements that interface.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 日志记录器现在实现了该接口。
- en: ❸ The verifier now uses the interface.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 验证器现在使用接口。
- en: Notice that a few things have changed in the production code. I’ve added a new
    interface to the production code, and the existing logger now implements this
    interface. I’m changing the design to make the logger replaceable. Also, the `PasswordVerifier`
    class works with the interface instead of the `SimpleLogger` class. This allows
    me to replace the instance of the `logger` class with a fake one, instead of having
    a hard dependency on the real logger.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，生产代码中发生了一些变化。我向生产代码中添加了一个新的接口，并且现有的日志记录器现在实现了这个接口。我正在改变设计，使日志记录器可替换。此外，`PasswordVerifier`
    类现在与接口而不是 `SimpleLogger` 类一起工作。这允许我用一个假的实例替换 `logger` 类的实例，而不是对真实日志记录器有硬依赖。
- en: The following listing shows what a test might look like in a strongly typed
    language, but with a handwritten fake object that implements the `ILogger` interface.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个强类型语言中的测试可能的样子，但使用的是实现 `ILogger` 接口的手写模拟对象。
- en: Listing 4.14 Injecting a handwritten mock `ILogger`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 注入手写的模拟 `ILogger`
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, I’ve created a handwritten class called `FakeLogger`. All it
    does is override the one method in the `ILogger` interface and save the `text`
    parameter for future assertion. We then expose this value as a field in the `written`
    class. Once this value is exposed, we can verify that the fake logger was called
    by checking that field.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我创建了一个名为 `FakeLogger` 的手写类。它所做的只是覆盖 `ILogger` 接口中的一个方法，并将 `text` 参数保存以供未来的断言。然后我们将这个值作为
    `written` 类中的一个字段公开。一旦这个值被公开，我们就可以通过检查这个字段来验证模拟日志记录器是否被调用。
- en: I’ve done this manually because I wanted you to see that even in object-oriented
    land, the patterns repeat themselves. Instead of having a mock *function*, we
    now have a mock *object*, but the code and test work just like the previous examples.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做是手动进行的，因为我想要你看到，即使在面向对象的世界里，模式也会重复。我们不再有一个模拟 *函数*，而是一个模拟 *对象*，但代码和测试的工作方式与之前的例子一样。
- en: Interface naming conventions
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接口命名约定
- en: I’m using the naming convention of prefixing the logger interface with an “I”
    because it’s going to be used for polymorphic reasons (i.e., I’m using it to abstract
    a role in the system). This is not always the case for interface naming in TypeScript,
    such as when we use interfaces to define the structure of a set of parameters
    (basically using them as strongly typed structures). In that case, naming without
    an “I” makes sense to me.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用命名约定，在日志接口前缀一个“ I”，因为它将被用于多态原因（即，我正在用它来抽象系统中的一个角色）。在 TypeScript 的接口命名中，这并不总是如此，例如，当我们使用接口来定义一组参数的结构（基本上是作为强类型结构使用）时。在这种情况下，不带“
    I”的命名对我来说是有意义的。
- en: 'For now, think of it like this: If you’re going to implement it more than once,
    you should prefix it with an “I” to make the expected use of the interface more
    explicit.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，可以这样想：如果你打算多次实现它，你应该用“ I”前缀来使接口的预期使用更加明确。
- en: 4.8 Dealing with complicated interfaces
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 处理复杂接口
- en: What happens when the interface is more complicated, such as when it has more
    than one or two functions in it, or more than one or two parameters in each function?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当接口更复杂时会发生什么，比如当它包含一个或两个以上的函数，或者每个函数包含一个或两个以上的参数时？
- en: 4.8.1 Example of a complicated interface
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.1 复杂接口的示例
- en: Listing 4.15 is an example of such a complicated interface, and of the production
    code verifier that uses the complicated logger, injected as an interface. The
    `IComplicatedLogger` interface has four functions, each with one or more parameters.
    Every function would need to be faked in our tests, and that can lead to complexity
    and maintainability problems in our code and tests.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 是一个复杂接口的示例，以及使用复杂日志记录器（作为接口注入）的生产代码验证器。`IComplicatedLogger` 接口有四个函数，每个函数有一个或多个参数。在我们的测试中，每个函数都需要被模拟，这可能导致我们的代码和测试中的复杂性和可维护性问题。
- en: Listing 4.15 Working with a more complicated interface (production code)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 与更复杂的接口一起工作（生产代码）
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ A new interface, which is part of production code
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个新的接口，它是生产代码的一部分
- en: ❷ The class now works with the new interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 类现在使用新的接口。
- en: 'As you can see, the new `IComplicatedLogger` interface will be part of production
    code, which will make the `logger` replaceable. I’m leaving off the implementation
    of a real logger, because it’s not relevant for our examples. That’s the benefit
    of abstracting away things with an interface: we don’t need to reference them
    directly. Also notice that the type of parameter expected in the class’s constructor
    is that of the `IComplicatedLogger` interface. This allows me to replace the instance
    of the logger class with a fake one, just like we did before.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，新的 `IComplicatedLogger` 接口将成为生产代码的一部分，这将使 `logger` 可替换。我省略了真实日志记录器的实现，因为它对我们示例来说并不相关。这就是使用接口抽象事物的好处：我们不需要直接引用它们。注意，类构造函数中期望的参数类型是
    `IComplicatedLogger` 接口类型。这允许我用一个模拟实例替换日志记录器类的实例，就像我们之前做的那样。
- en: 4.8.2 Writing tests with complicated interfaces
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.2 使用复杂接口编写测试
- en: Here’s what the test looks like. It has to override each and every interface
    function, which creates long and annoying boilerplate code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个测试的样子。它必须覆盖每个接口函数，这会创建冗长且令人烦恼的样板代码。
- en: Listing 4.16 Test code with a complicated logger interface
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.16具有复杂记录器接口的测试代码
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ A fake logger class that implements the new interface
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 实现新接口的假记录器类
- en: Here, we’re declaring, again, a fake logger class (`FakeComplicatedLogger`)
    that implements the `IComplicatedLogger` interface. Look at how much boilerplate
    code we have. This will be especially true if we’re working in strongly typed
    object-oriented languages such as Java, C#, or C++. There are ways around all
    this boilerplate code, which we’ll touch on in the next chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次声明一个假记录器类（`FakeComplicatedLogger`），它实现了`IComplicatedLogger`接口。看看我们有多少样板代码。如果我们正在使用强类型面向对象语言，如Java、C#或C++，这尤其正确。有办法绕过所有这些样板代码，我们将在下一章中简要介绍。
- en: 4.8.3 Downsides of using complicated interfaces directly
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.3 直接使用复杂接口的缺点
- en: 'There are other downsides to using long, complicated interfaces in our tests:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中使用长而复杂的接口还有其他缺点：
- en: If we’re saving arguments being sent in manually, it’s more cumbersome to verify
    multiple arguments across multiple methods and calls.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在手动保存传递的参数，验证多个方法调用中的多个参数会更麻烦。
- en: It’s likely that we are depending on third-party interfaces instead of internal
    ones, and this will end up making our tests more brittle as time goes by.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很可能我们依赖于第三方接口而不是内部接口，这最终会使我们的测试随着时间的推移变得更加脆弱。
- en: Even if we are depending on internal interfaces, long interfaces have more reasons
    to change, and now so do our tests.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我们是依赖于内部接口，长接口有更多改变的理由，现在我们的测试也是如此。
- en: 'What does this mean for us? I highly recommend using only fake interfaces that
    meet both of these conditions:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们意味着什么？我强烈推荐只使用满足以下两个条件的假接口：
- en: You control the interfaces (they are not made by a third party).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你控制接口（它们不是由第三方制作的）。
- en: They are adapted to the needs of your unit of work or component.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们适应了你的工作单元或组件的需求。
- en: 4.8.4 The interface segregation principle
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8.4 接口隔离原则
- en: The second of the preceding conditions might need a bit of explanation. It relates
    to the *interface segregation principle* (ISP; [https://en.wikipedia.org/wiki/Interface_segregation_principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)).
    ISP means that if we have an interface that contains more functionality than we
    require, we should create a small, simpler adapter interface that contains just
    the functionality we need, preferably with fewer functions, better names, and
    fewer parameters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个条件中的第二个可能需要一些解释。它与*接口隔离原则*（ISP；[https://zh.wikipedia.org/wiki/接口隔离原则](https://zh.wikipedia.org/wiki/接口隔离原则)）相关。ISP意味着如果我们有一个包含比我们所需更多功能的接口，我们应该创建一个小的、更简单的适配器接口，它只包含我们所需的功能，最好有更少的函数、更好的名称和更少的参数。
- en: This will end up making our tests much simpler. By abstracting away the real
    dependencies, we won’t need to change our tests when the complicated interfaces
    change—only a single adapter class file somewhere. We’ll see an example of this
    in chapter 5.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的测试变得更加简单。通过抽象掉真实依赖项，我们不需要在复杂接口更改时更改我们的测试——只需更改某个地方的单一适配器类文件。我们将在第5章中看到这个例子。
- en: 4.9 Partial mocks
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 部分模拟
- en: It’s possible, in JavaScript and in most other languages and associated test
    frameworks, to take over existing objects and functions and “spy” on them. By
    spying on them, we can later check if they were called, how many times, and with
    which arguments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript以及大多数其他语言及其相关测试框架中，我们可以接管现有对象和函数并“监视”它们。通过监视它们，我们可以在之后检查它们是否被调用、调用了多少次以及使用了哪些参数。
- en: This essentially can turn *parts* of a real object into mock functions, while
    keeping the rest of the object as a real object. This can create more complicated
    tests that are more brittle, but it can sometimes be a viable option, especially
    if you’re dealing with legacy code (see chapter 12 for more on legacy code).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上可以将真实对象的*部分*转换为模拟函数，同时保持对象的其余部分为真实对象。这可能会创建更复杂的测试，它们更脆弱，但有时这可能是一个可行的选择，特别是如果你在处理遗留代码（有关遗留代码的更多信息，请参阅第12章）。
- en: 4.9.1 A functional example of a partial mock
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.1 部分模拟的功能示例
- en: The following listing shows what such a test might look like. We create the
    real logger, and then we simply override one of its existing real functions using
    a custom function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了这样的测试可能的样子。我们创建了一个真实的记录器，然后我们简单地使用一个自定义函数覆盖了它的一个现有真实函数。
- en: Listing 4.17 A partial mock example
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.17部分模拟示例
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Instantiating a real logger
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 实例化一个真实的记录器
- en: ❷ Mocking one of its functions
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 模拟其一个函数
- en: In this test, I’m instantiating a `RealLogger`, and in the next line I’m replacing
    one of its existing functions with a fake one. More specifically, I’m using a
    mock function that allows me to track its latest invocation parameter using a
    custom variable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我实例化了一个`RealLogger`，在下一行我将其中一个现有的函数替换为一个假的函数。更具体地说，我使用了一个模拟函数，它允许我通过一个自定义变量跟踪其最新的调用参数。
- en: The important part here is that the `testableLog` variable is a *partial mock*.
    That means that at least some of its internal implementation is not fake and might
    have real dependencies and logic in it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要部分是`testableLog`变量是一个*局部模拟*。这意味着至少其内部实现的一部分不是假的，可能包含真实的依赖项和逻辑。
- en: Sometimes it makes sense to use partial mocks, especially when you’re working
    with legacy code and you might need to isolate some existing code from its dependencies.
    I’ll touch more on that in chapter 12.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候使用局部模拟是有意义的，特别是当你与遗留代码一起工作时，你可能需要将一些现有代码与其依赖项隔离。我将在第12章中更多地讨论这一点。
- en: 4.9.2 An object-oriented partial mock example
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9.2 一个面向对象的局部模拟示例
- en: One object-oriented version of a partial mock uses inheritance to override functions
    from real classes so that we can verify they were called. The following listing
    shows how we can do this using inheritance and overrides in JavaScript.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 局部模拟的一个面向对象版本使用继承来覆盖真实类中的函数，以便我们可以验证它们是否被调用。以下列表展示了我们如何使用继承和覆盖在JavaScript中实现这一点。
- en: Listing 4.18 An object-oriented partial mock example
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.18 一个面向对象的局部模拟示例
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Inheriting from the real logger
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从真实日志记录器继承
- en: ❷ Overriding one of its functions
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 覆盖其中一个函数
- en: I inherit from the real logger class in my tests and then use the inherited
    class, not the original class, in my tests. This technique is commonly called
    Extract and Override, and you can find more about this in Michael Feathers’ book
    *Working Effectively with Legacy Code* (Pearson, 2004).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的测试中，我从真实的日志记录器类继承，然后使用继承的类，而不是原始类，在我的测试中使用。这种技术通常被称为提取和覆盖，你可以在Michael Feathers的书籍《有效地与遗留代码一起工作》（Pearson，2004）中找到更多关于这方面的内容。
- en: Note that I’ve named the fake logger class “TestableXXX” because it’s a testable
    version of real production code, containing a mix of fake and real code, and this
    convention helps me make this explicit for the reader. I also put the class right
    alongside my tests. My production code doesn’t need to know that this class exists.
    This Extract and Override style requires that my class in production code allows
    inheritance and that the function allows overriding. In JavaScript this is less
    of an issue, but in Java and C# these are explicit design choices that need to
    be made (although there are frameworks that allow us to circumvent this rule;
    we’ll discuss them in the next chapter).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我将这个假的日志记录器类命名为“TestableXXX”，因为它是一个可测试的真实生产代码版本，包含假代码和真实代码的混合，这个约定有助于我向读者明确这一点。我还将这个类直接放在我的测试旁边。我的生产代码不需要知道这个类的存在。这种提取和覆盖风格要求我的生产代码中的类允许继承，并且函数允许覆盖。在JavaScript中，这并不是一个问题，但在Java和C#中，这些是需要明确做出的设计选择（尽管有一些框架允许我们绕过这个规则；我们将在下一章讨论它们）。
- en: In this scenario, we’re inheriting from a class that we’re not testing directly
    (`RealLogger`). We use that class to test another class (`PasswordVerifier`).
    However, this technique can be used quite effectively to isolate and stub or mock
    single functions from classes that you’re directly testing. We’ll touch more on
    that later in the book when we talk about legacy code and refactoring techniques.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们从一个我们不是直接测试的类继承（`RealLogger`）。我们使用这个类来测试另一个类（`PasswordVerifier`）。然而，这种技术可以非常有效地用来隔离和存根或模拟你直接测试的类中的单个函数。我们将在本书后面讨论遗留代码和重构技术时更多地讨论这一点。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '*Interaction testing* is a way to check how a unit of work interacts with its
    outgoing dependencies: what calls were made and with which parameters. Interaction
    testing relates to the third type of exit points: a third-party module, object,
    or system. (The first two types are a return value and a state change.)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*交互测试*是一种检查工作单元如何与其外部依赖项交互的方法：调用了哪些调用以及使用哪些参数。交互测试与第三种退出点相关：第三方模块、对象或系统。（前两种是返回值和状态变化。）'
- en: To do interaction testing, you should use *mocks*, which are test doubles that
    replace outgoing dependencies. *Stubs* replace incoming dependencies. You should
    verify interactions with mocks in tests, but not with stubs. Unlike with mocks,
    interactions with stubs are implementation details and shouldn't be checked.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要进行交互测试，你应该使用*模拟*，这些是替换输出依赖的测试替身。*占位符*替换输入依赖。你应该在测试中验证与模拟的交互，而不是与占位符的交互。与模拟不同，与占位符的交互是实现细节，不应该进行检查。
- en: It’s OK to have multiple stubs in a test, but you don’t usually want to have
    more than a single mock per test, because that means you’re testing more than
    one requirement in a single test.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中拥有多个占位符是可以的，但你通常不希望每个测试中包含超过一个模拟对象，因为这意味着你在一个测试中测试了多个需求。
- en: 'Just like with stubs, there are multiple ways to inject a mock into a unit
    of work:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像处理占位符一样，有几种方法可以将模拟对象注入到工作单元中：
- en: '*Standard*—By introducing a parameter'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准*—通过引入一个参数'
- en: '*Functional*—Using a partial application or factory functions'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数式*—使用部分应用或工厂函数'
- en: '*Modular*—Abstracting the module dependency'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块化*—抽象模块依赖'
- en: '*Object-oriented*—Using an untyped object (in languages like JavaScript) or
    a typed interface (in TypeScript)'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向对象*—使用无类型对象（如在JavaScript语言中）或类型化接口（如在TypeScript中）'
- en: In JavaScript, a complicated interface can be implemented partially, which helps
    reduce the amount of boilerplate. There’s also the option of using *partial mocks*,
    where you inherit from a real class and replace only some of its methods with
    fakes.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中，可以部分实现复杂接口，这有助于减少样板代码的数量。还有使用*部分模拟*的选项，即从真实类继承并仅用伪造对象替换其中的一些方法。
