- en: Appendix B. Numerics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. 数值
- en: This appendix covers some common issues and questions about numbers in programming.
    These topics are not entirely unique to Julia; for instance, I will discuss what
    happens if the result of an integer arithmetic operation results in a higher or
    lower number than can be represented by the integer type. I will also discuss
    why floating-point numbers, unlike integers, are inaccurate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录涵盖了编程中关于数字的一些常见问题和疑问。这些主题并非完全属于Julia独特；例如，我将讨论如果整数算术运算的结果超出了整数类型能表示的范围，会发生什么。我还会讨论为什么浮点数与整数不同，它们是不准确的。
- en: B.1 Different number types and their bit lengths
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 不同数字类型及其位数长度
- en: A number is not just a number. There are different *types* of numbers, such
    as integers, real numbers, irrational numbers, and so on. For example, *integers*
    are whole numbers, such as 2, 7, 43, 820, -52, 0, 6, and -4, while *real numbers*
    contain numbers that have a decimal point, such as 3.45, 0.042, 1331.0, 78.6.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数字不仅仅是数字。存在不同类型的数字，例如整数、实数、无理数等等。例如，*整数*是整数，如2、7、43、820、-52、0、6和-4，而*实数*包含有小数点的数字，如3.45、0.042、1331.0、78.6。
- en: However, the way a mathematician and the way a programmer tend to look at numbers
    is fundamentally different. On a computer, we care about things such as the bit
    length of a number and whether the number is signed or unsigned.^([1](#pgfId-1011827))
    If you have used programming languages such as Java, C#, C, or C++, then you may
    be very familiar with this already.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数学家和程序员看待数字的方式在本质上是有区别的。在计算机上，我们关注的是数字的位数长度以及数字是有符号还是无符号的。[1](#pgfId-1011827)
    如果你已经使用过Java、C#、C或C++等编程语言，那么你可能已经非常熟悉这一点了。
- en: If your programming background is in another dynamic language, such as Python,
    Ruby, JavaScript, or Lua, these concepts may be unfamiliar to you. While Julia
    is also a dynamic language, numbers play a more central role. In, for example,
    Python and JavaScript, you don’t have to pay much attention to different number
    types. In Julia, this is more important, as numbers have been carefully designed
    to make Julia suitable for high-performance computing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编程背景是另一种动态语言，例如Python、Ruby、JavaScript或Lua，这些概念可能对你来说很陌生。虽然Julia也是一种动态语言，但数字在其中扮演着更核心的角色。例如，在Python和JavaScript中，你不必过多关注不同的数字类型。在Julia中，这一点更为重要，因为数字已经被精心设计，使Julia适合高性能计算。
- en: I’ll provide you with the basics. When filling out a form, you are probably
    familiar with restrictions on the number of digits you can enter. Computers are
    the same. If you store your numbers as four digits, then the largest number you
    could use in any calculation is 9999\. The key difference is that for a modern
    digital computer, all numbers are stored in memory as binary numbers, not decimal
    numbers. Thus the number types you select from are not 4-digit numbers, 8-digit
    numbers, and so on. Rather, the number types you pick from are, for example, 8-bit,
    16-bit, or 64-bit numbers. How does this affect you in practice?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我会为你提供基础知识。当填写表格时，你可能熟悉可以输入的数字位数限制。计算机也是如此。如果你将数字存储为四位数，那么在任何计算中你可以使用的最大数字是9999。关键的区别是，对于现代数字计算机，所有数字都是以二进制形式存储在内存中，而不是十进制形式。因此，你可以选择的数字类型不是4位数、8位数等等。相反，你可以选择的数字类型，例如，8位、16位或64位数字。这在实际操作中对你有什么影响？
- en: Numbers are written with ones and zeros. An 8-bit number is a number with 8
    binary digits. The largest number you can represent with 8 bits, written in binary
    form, is 0b11111111. The 0b prefix on this number is intended to clarify it is
    not a decimal number. Translated to decimal notation, this would be 255\. Thus,
    if you try to store 256 as an 8-bit number, it will fail. (Note that I have shortened
    the error messages for clarity.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是用一和零来表示的。8位数字是一个有8个二进制位的数字。用二进制形式表示，你可以用8位表示的最大数字是0b11111111。这个数字上的0b前缀是为了明确它不是一个十进制数。转换成十进制表示，这将等于255。因此，如果你尝试将256作为8位数字存储，它将失败。（注意，为了清晰起见，我已经缩短了错误信息。）
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: But why should you restrict the size of the numbers you work with? Why not simply
    use the largest possible number every time? Because you don’t have infinite amounts
    of memory on your computer. If you only use a few numbers, it doesn’t matter if
    they are large. However, if you process millions of numbers, then the bit length
    starts to matter. Secondly, it frequently takes a longer time to perform calculations
    on large numbers compared to small numbers. Julia defaults to 64-bit numbers because
    they are very practical to work with. A signed 64-bit integer has a maximum value
    of 9,223,372,036,854,775,807\. You are unlikely to work with larger numbers than
    that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么你应该限制你处理数字的大小？为什么不每次都简单地使用可能的最大数字呢？因为你的计算机上没有无限的内存。如果你只使用几个数字，那么它们的大小并不重要。然而，如果你处理数百万个数字，那么位长度就开始变得重要了。其次，与处理小数字相比，对大数字进行计算通常需要更长的时间。Julia
    默认使用 64 位数字，因为它们非常实用。一个有符号的 64 位整数最大值为 9,223,372,036,854,775,807。你不太可能处理比这更大的数字。
- en: 'But how do you know the largest and smallest value a number type can hold?
    Fortunately, Julia gives you the functions typemax and typemin, which let you
    find that out for yourself. However, for now, you will just have to take at face
    value how these functions work. You give them the name of a Julia number type,
    such as Int8, Int16, or UInt8, and these functions give you back the lowest and
    highest number value you can represent with that number type. For instance, an
    8-bit signed integer, Int8, cannot represent values larger than 127:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但你是如何知道数字类型可以持有的最大和最小值呢？幸运的是，Julia 提供了 typemax 和 typemin 函数，让你可以自己找出这些值。然而，目前你只需直接理解这些函数的工作方式即可。你给出
    Julia 数字类型的名称，例如 Int8、Int16 或 UInt8，这些函数就会返回你可以用该数字类型表示的最高和最低数值。例如，一个 8 位有符号整数
    Int8 无法表示大于 127 的值：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: typemin(Int8) returns the value -128 because a signed 8-bit integer cannot represent
    number values smaller than -128.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`typemin(Int8)` 返回 -128 的值，因为一个有符号的 8 位整数无法表示小于 -128 的数值。'
- en: While all these number types can seem complicated, you rarely need to think
    about them in practice. Sticking with the default types, such as Int64, is the
    best choice in most cases. You only need to consider other integer number sizes
    if you process many numbers and get into performance or memory problems. Or you
    may need a bigger number because you are working with very large values. In that
    case, you could consider Int128 or even BigInt.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些数字类型看起来可能很复杂，但在实际操作中你很少需要考虑它们。在大多数情况下，坚持使用默认类型，如 Int64，是最好的选择。只有当你处理大量数字并遇到性能或内存问题时，你才需要考虑其他整数数字大小。或者，你可能需要更大的数字，因为你正在处理非常大的值。在这种情况下，你可以考虑使用
    Int128 或甚至 BigInt。
- en: Differences between 64-bit and 32-bit Julia installation If you downloaded and
    installed a 32-bit version of Julia, then the default integer type will be Int32
    rather than Int64. Code examples in this book will assume you run 64-bit Julia.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 64 位和 32 位 Julia 安装之间的差异 如果你下载并安装了 32 位的 Julia 版本，那么默认的整数类型将是 Int32 而不是 Int64。本书中的代码示例将假设你运行的是
    64 位 Julia。
- en: Did you try to find the maximum value of a BigInt but could not get it to work?
    Read on to find out why.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你尝试找到 BigInt 的最大值，但无法让它工作吗？继续阅读以了解原因。
- en: 'To learn what type is used to represent a particular number literal, you can
    use the typeof function. Just give it a number, and it will return the number
    type used to represent that number. Actually, it can be used for any type. If
    this doesn’t make a lot of sense, don’t worry, as typeof will be covered more
    extensively later:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解用于表示特定数字字面量的类型，你可以使用 typeof 函数。只需给它一个数字，它就会返回表示该数字的数字类型。实际上，它可以用于任何类型。如果这让你感到困惑，不要担心，因为
    typeof 将在稍后更详细地介绍：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: BigInt is a very special number type, as it does not have a predefined number
    of digits. Instead, it simply keeps growing to fit all digits, so your computer
    memory is its only real limit; that’s why there is no well-defined maximum value
    for a BigInt.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: BigInt 是一个非常特殊的数字类型，因为它没有预定义的位数。相反，它简单地不断增长以适应所有位数，因此你的计算机内存是其唯一的实际限制；这就是为什么
    BigInt 没有定义良好的最大值。
- en: Why not use BigInt all the time? Then you wouldn’t have to think about what
    bit size you need. The obvious answer is that it would make for bad performance.
    Thus, you should try to limit the use of BigInt to sections of your code that
    benefit from it and which are not performance critical.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不总是使用 BigInt 呢？这样你就不必考虑你需要多少位大小了。显然的答案是这会降低性能。因此，你应该尽量将 BigInt 的使用限制在你代码中从中受益且不是性能关键的部分。
- en: B.2 Overflow and signed and unsigned numbers
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 溢出和有符号数与无符号数
- en: Let’s put together everything we have learned about number formats and bit lengths
    in chapter 2 to cover some important topics. The first is the concept of *overflow*.
    Think about mechanical counters, like the one shown in figure B.1\. It has four
    digits, so what happens when you get to 9999? It wraps around, and you get to
    0000 again.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将第2章中学到的关于数字格式和位长度的所有知识汇总起来，来探讨一些重要的话题。首先是*溢出*的概念。想想机械计数器，就像图B.1中展示的那样。它有四个数字，那么当你达到9999时会发生什么？它会回绕，然后又回到0000。
- en: '![B-01](../Images/B-01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![B-01](../Images/B-01.png)'
- en: Figure B.1 A mechanical counter. It increments each time you click the metal
    button.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图B.1 一个机械计数器。每次你点击金属按钮时，它都会增加。
- en: 'Numbers work exactly the same way on computers. Because each number type can
    hold a maximum value, you can end up performing arithmetic operations that give
    results larger than the values that can be held in your variables. Here are some
    examples of this in practice:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 数字在计算机上工作方式完全相同。因为每种数字类型都可以存储最大值，你可能会执行结果大于变量可以存储的值的算术运算。这里有一些实际例子：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Because an UInt8 can only hold values up to 255, you get a wraparound when
    you add more—or to use more accurate language, you get an overflow. In this case,
    it is easier to understand the concept by working with hexadecimal numbers. An
    8-bit number can hold a max of two hexadecimal digits, and the last digit value
    in a hexadecimal is F. For 16-bit numbers, you need much higher values to get
    overflow:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一个UInt8只能持有到255的值，所以当你添加更多时，或者用更准确的语言来说，当你溢出时，你会得到回绕。在这种情况下，通过使用十六进制数来理解这个概念更容易。一个8位数字可以存储最多两个十六进制数字，十六进制中的最后一个数字值是F。对于16位数字，你需要更高的值来得到溢出：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The way overflow works differs for signed and unsigned numbers. Look at the
    following behavior of signed and unsigned numbers, and see if you can make sense
    of it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出对于有符号数和无符号数的工作方式不同。看看以下有符号数和无符号数的行为，看看你是否能理解它：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This output looks odd, right? You are adding positive numbers and ending up
    with negative ones. How on Earth is that possible? This has to do with the fact
    that computer memory can only store numbers. There is no negative sign stored
    anywhere. Instead, you will use the wraparound behavior to simulate negative numbers.
    Returning to the mechanical counter example in figure B.1, storing four-digit
    decimal numbers; *4* + *9998* would end up as 2\. Imagine clicking four times
    on the mechanical counter starting at 9998\. The counter would wrap around and
    end up as 2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出看起来很奇怪，对吧？你正在添加正数，却得到了负数。这怎么可能呢？这与计算机内存只能存储数字的事实有关。没有任何地方存储负号。相反，你会使用回绕行为来模拟负数。回到图B.1中的机械计数器例子，存储四位十进制数；*4*
    + *9998*最终会变成2。想象一下从9998开始点击机械计数器的四次；计数器会回绕并最终变成2。
- en: That means an alternative way of thinking about the number 9998 is to imagine
    it as the number -2\. *4* + (-*2*) = *2*. This way, 9999 becomes -1, 9995 becomes
    -5, and so on. By following this logic, 1 could be interpreted as -9999\. However,
    one should not go that far; otherwise, it isn’t possible to represent positive
    numbers with four digits.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着关于数字9998的另一种思考方式是想象它为数字-2。*4* + (-*2*) = *2*。这样，9999就变成了-1，9995变成了-5，以此类推。按照这个逻辑，1可以解释为-9999。然而，不应该走得太远；否则，就无法用四个数字来表示正数。
- en: 'The scheme used on modern computers is to divide each number range roughly
    in half, so half the values are used to represent negative numbers and the other
    half are used to represent positive numbers. An unsigned 8-bit integer can represent
    numbers from 0 to 255; however a signed 8-bit integer represents values from -128
    to 127, which you already saw earlier:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机上使用的方案是将每个数字范围大致分成一半，所以一半的值用来表示负数，另一半用来表示正数。一个无符号8位整数可以表示从0到255的数字；然而，一个有符号8位整数表示的值从-128到127，这你之前已经看到了：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Thus, what is stored in memory is actually no different. The only difference
    is how to interpret what is stored there when doing different calculations. When
    using unsigned numbers, it is assumed all the numbers are positive. When using
    signed numbers, it is assumed half of the values are negative. In fact, Julia
    can show you how the exact same bits in memory can be interpreted differently
    using the reinterpret function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存储在内存中的内容实际上并没有不同。唯一的不同之处在于在进行不同计算时如何解释存储的内容。当使用无符号数时，假设所有数字都是正数。当使用有符号数时，假设一半的值是负数。实际上，Julia
    可以通过使用 reinterpret 函数向你展示内存中完全相同的位可以以不同的方式解释：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Reinterpret the unsigned 8-bit number 253 as a signed 8-bit number. 253 interpreted
    as signed is -3.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将无符号 8 位数字 253 重新解释为有符号 8 位数字。253 作为有符号数解释为 -3。
- en: ❷ Reintepret the bits in memory for the signed number -1 as an unsigned number.
    Unsigned -1 is the same as 255 for 8-bit numbers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将有符号数 -1 的内存中的位重新解释为无符号数。8 位数的无符号 -1 与 255 相同。
- en: B.3 Floating-point numbers
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 浮点数
- en: 'Integer numbers cannot represent numbers with decimal points, such as 4.25,
    80.3, or 0.233; there are different ways of representing such numbers. Historically,
    *fixed-point numbers* have been used, but on modern computers we tend to use what
    are called *floating-point numbers*. Fixed-point numbers are used for such things
    as currency calculation. The number of decimals after the decimal point is fixed
    in this type of number representation: you always have two decimals.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 整数无法表示带有小数点的数字，例如 4.25、80.3 或 0.233；表示这类数字有不同方法。历史上，*定点数*被使用，但在现代计算机中，我们倾向于使用所谓的*浮点数*。定点数用于诸如货币计算这样的用途。在这种数字表示法中，小数点后的位数是固定的：你总是有两个小数位。
- en: Computers cannot store signs or decimal points in memory. Computer memory only
    stores numbers, and it only stores them in binary format. This is not all that
    different from, say, an abacus. There is no way to explicitly store negative numbers
    or represent a decimal point on an abacus; however, one can establish conventions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机无法在内存中存储符号或小数点。计算机内存只存储数字，并且只以二进制格式存储它们。这与，比如说，算盘并没有太大区别。在算盘上无法明确存储负数或表示小数点；然而，可以建立一些惯例。
- en: 'You could simply decide, for example, that the two last digits of the numbers
    you work with are supposed to be after the decimal point. That means that if you
    wish to input 1, you actually need to input 100\. Likewise 23 becomes 2300\. In
    a similar fashion one can *simulate* fixed-point numbers using only integers.
    You could take integer numbers such as 4250 and 850 and *pretend* there is a decimal
    point before the two last digits. Thus you could interpret those numbers as 42.50
    and 8.50\. This works fine in calculations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地决定，例如，你处理的数字的最后两位应该是小数点后的数字。这意味着，如果你想输入 1，实际上你需要输入 100\. 同样，23 变成 2300\.
    以类似的方式，人们可以使用仅整数来*模拟*定点数。你可以取整数，如 4250 和 850，并*假设*在最后两位数字之前有一个小数点。因此，你可以将这些数字解释为
    42.50 和 8.50\. 在计算中，这没问题：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For calculations with money, this is the appropriate choice; as such calculations
    typically involve rounding to the nearest two decimals. But for scientific calculations
    with lots of digits after the decimal point, this is simply too impractical. That
    is why we have floating-point numbers, which are based on the idea that you can
    represent any number in this fashion (figure B.2).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于金钱的计算，这是合适的选择；因为此类计算通常涉及四舍五入到最接近的两个小数位。但对于需要很多小数位数的科学计算，这太不切实际了。这就是为什么我们有浮点数，其基于这样的想法：你可以以这种方式表示任何数字（图
    B.2）。
- en: '![B-02](../Images/B-02.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![B-02](../Images/B-02.png)'
- en: Figure B.2 Representing any decimal number using integers multiplied by a number
    with base 10 and a positive or negative exponent
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.2 使用整数乘以 10 的幂和正或负指数表示任何十进制数
- en: 'Consider the first line: The number 1234 is referred to as the *significand*.
    The second part indicates the *base* of the number. In this case the *base* is
    10, and the *exponent* is -2\. Internally, a floating-point number stores the
    significand and exponent separately. This arrangement is what allows the decimal
    point to *float*. Floating-point number types can represent much larger numbers
    than integers but with the downside that they are not entirely accurate. Why?
    That is too large of a topic to get into in this beginner’s book, but I can offer
    some hints about it. Consider a number such as ⅔. With decimal numbers we write
    this as 0.6666666666666666\. The digits just keep on going. With decimal numbers,
    the digits behind the decimal point represent fractions in which the denominator
    is a multiple of 10\. Thus we approximate as shown in figure B.3.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第一行：数字 1234 被称为*尾数*。第二部分表示数字的*基数*。在这种情况下，*基数*是 10，而*指数*是 -2。在内部，浮点数分别存储尾数和指数。这种安排使得小数点可以*浮动*。浮点数类型可以表示比整数更大的数字，但缺点是它们并不完全准确。为什么？这超出了这本入门书的范围，但我可以提供一些关于它的提示。考虑一个像
    ⅔ 这样的数字。用小数表示，我们写成 0.6666666666666666。数字只是不断继续。在小数中，小数点后的数字代表分母是 10 的倍数的分数。因此，我们近似如图
    B.3 所示。
- en: '![B-03](../Images/B-03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![B-03](../Images/B-03.png)'
- en: Figure B.3 Approximation of a fraction with decimal numbers
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 B.3 用小数表示分数的近似
- en: This can never be entirely accurate. In the examples I use in this book, this
    will generally not be a problem, but it is something worth being aware of if you
    start working seriously with floating-point numbers. But don’t assume every floating-point
    number has to be inaccurate. Many numbers can be expressed accurately, such as
    0.5 or 42.0\. For computers, floating-point numbers are obviously not represented
    as fractions using base 10, but fractions using base 2.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这永远无法完全准确。在我这本书中使用的例子中，这通常不会成问题，但如果你开始认真处理浮点数时，这是值得注意的。但不要假设每个浮点数都必须是不准确的。许多数字可以精确表示，例如
    0.5 或 42.0。对于计算机来说，浮点数显然不是用十进制表示分数，而是用二进制表示分数。
- en: '* * *'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)Signed numbers can be negative, while unsigned numbers can only be positive.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: (1.) 有符号数可以是负数，而无符号数只能为正数。
