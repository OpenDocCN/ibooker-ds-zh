- en: 7 Extending applications with multicontainer Pods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 使用多容器 Pod 扩展应用程序
- en: 'We met Pods in chapter 2, when you learned that you can run many containers
    in one Pod, but you didn’t actually do it. In this chapter, you’re going to see
    how it works and understand the patterns it enables. This is the first of the
    more advanced topics in this part of the book, but it’s not a complicated subject—it
    just helps to have all the background knowledge from the previous chapters. Conceptually,
    it’s quite simple: one Pod runs many containers, which is typically your app container
    plus some helper containers. It’s what you can do with those helpers that makes
    this feature so interesting.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章中遇到了 Pod，当时你了解到你可以在一个 Pod 中运行多个容器，但你实际上并没有这样做。在本章中，你将了解它是如何工作的，并理解它所支持的模式。这是本书这一部分更高级主题中的第一个，但它不是一个复杂的话题——只是需要所有来自前几章的背景知识。从概念上讲，它相当简单：一个
    Pod 运行多个容器，通常是你的应用程序容器和一些辅助容器。正是这些助手的功能使得这个特性如此有趣。
- en: Containers in a Pod share the same virtual environment, so when one container
    takes an action, other containers can see it and react to it. They can even modify
    the intended action without the original container knowing. This behavior lets
    you model your application so that the app container is very simple—it just focuses
    on its work, and it has helpers that take care of integrating the app with other
    components and with the Kubernetes platform. It’s a great way to add a consistent
    management API to all your apps, whether new or legacy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 中的容器共享相同的虚拟环境，因此当一个容器执行操作时，其他容器可以看到并对此做出反应。它们甚至可以在原始容器不知情的情况下修改预期的操作。这种行为允许您将应用程序建模为非常简单的容器——它只专注于自己的工作，并且有助手负责将应用程序与其他组件以及
    Kubernetes 平台集成。这是为所有应用程序添加一致的管理 API 的绝佳方式，无论是新应用程序还是遗留应用程序。
- en: 7.1 How containers communicate in a Pod
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 Pod 中容器如何通信
- en: The Pod is a virtual environment that creates a shared networking and filesystem
    space for one or more containers. The containers are isolated units; they have
    their own processes and environment variables, and they can use different images
    with different technology stacks. The Pod is a single unit, so when it is allocated
    to run on a node, all the Pod containers run on the same node. You can have one
    container running Python and another running Java, but you can’t have some Linux
    and some Windows containers in the same Pod (yet), because Linux containers need
    to run on a Linux node and Windows containers on a Windows node.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是一个虚拟环境，为一个或多个容器创建共享的网络和文件系统空间。容器是隔离的单元；它们有自己的进程和环境变量，并且可以使用不同技术栈的不同镜像。Pod
    是一个单一单元，因此当它被分配到节点上运行时，所有 Pod 容器都在同一节点上运行。您可以有一个运行 Python 的容器和另一个运行 Java 的容器，但不能在同一个
    Pod 中运行一些 Linux 和一些 Windows 容器（目前还不行），因为 Linux 容器需要在 Linux 节点上运行，而 Windows 容器需要在
    Windows 节点上运行。
- en: Containers in a Pod share the network, so each container has the same IP address—the
    IP address of the Pod. Multiple containers can receive external traffic, but they
    need to listen on different ports, and containers within the Pod can communicate
    using the localhost address. Each container has its own filesystem, but it can
    mount volumes from the Pod, so containers can exchange information by sharing
    the same mounts. Figure 7.1 shows the layout of a Pod with two containers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 中的容器共享网络，因此每个容器都有相同的 IP 地址——Pod 的 IP 地址。多个容器可以接收外部流量，但它们需要监听不同的端口，Pod 内的容器可以使用
    localhost 地址进行通信。每个容器都有自己的文件系统，但它可以从 Pod 挂载卷，因此容器可以通过共享相同的挂载来交换信息。图 7.1 展示了包含两个容器的
    Pod 布局。
- en: '![](../Images/7-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-1.jpg)'
- en: Figure 7.1 The Pod is a shared network and storage environment for many containers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 Pod 是许多容器的共享网络和存储环境。
- en: That’s all the theory we need for now, and as we go through the chapter, you’ll
    be surprised at some of the smart things you can do just with shared networking
    and disk. We’ll start with some simple exercises in this section to explore the
    Pod environment. Listing 7.1 shows the multicontainer Pod spec for a Deployment.
    Two containers are defined that happen to use the same image, and they both mount
    an `EmptyDir` volume, which is defined in the Pod.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们现在需要的所有理论，随着我们进入本章，你将对仅使用共享网络和磁盘就能做到的一些智能事情感到惊讶。我们将从本节的一些简单练习开始，以探索 Pod
    环境。列表 7.1 显示了 Deployment 的多容器 Pod 规范。定义了两个容器，它们恰好使用相同的镜像，并且它们都挂载了一个在 Pod 中定义的
    `EmptyDir` 卷。
- en: Listing 7.1 sleep-with-file-reader.yaml, a simple multicontainer Pod spec
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 sleep-with-file-reader.yaml，一个简单的多容器 Pod 规范
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a single Pod spec that runs two containers. When you deploy it, you’ll
    see that there are some differences in how you work with multicontainer Pods.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行两个容器的单个Pod规范。当你部署它时，你会看到在处理多容器Pod时有一些工作方式上的差异。
- en: Try it now Deploy listing 7.1, and run a Pod with two containers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看：部署列表7.1，并运行一个包含两个容器的Pod。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: My output, which appears in figure 7.2, shows the Pod has two containers with
    a single IP address, which both run on the same node. You can see the details
    of the Pod as a single unit, but you can’t print the logs at a Pod level; you
    need to specify a container from which to fetch the logs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我在图7.2中显示的输出表明，Pod有两个容器，具有单个IP地址，它们都在同一个节点上运行。你可以将Pod作为一个单一单元查看其详细信息，但你不能在Pod级别打印日志；你需要指定一个容器来获取日志。
- en: '![](../Images/7-2.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图7-2](../Images/7-2.jpg)'
- en: Figure 7.2 You always work with a Pod as a single unit, except when you need
    to specify a container.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：你总是将Pod作为一个单一单元来工作，除非你需要指定一个容器。
- en: Both of the containers in that exercise use the sleep image, so they’re not
    doing anything, but the containers keep running, and the Pod stays available to
    work with. The containers both mount the `EmptyDir` volume from the Pod, so that’s
    a shared part of the filesystem, and you can use it in both containers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个练习中，两个容器都使用了sleep镜像，所以它们没有做任何事情，但容器仍然在运行，Pod保持可用以供工作。这两个容器都挂载了Pod的`EmptyDir`卷，所以这是文件系统的共享部分，你可以在两个容器中使用它。
- en: Try it now One container mounts the volume as read-write and the other one as
    read-only. You can write files in one container and read them in the other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看：一个容器将卷挂载为可读写，另一个容器挂载为只读。你可以在一个容器中写入文件，并在另一个容器中读取它们。
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll see when you run this exercise that the first container can write data
    into the shared volume, and the second container can read it, but it can’t write
    data itself. That’s because the volume mount is defined as read-only for the second
    container in this Pod spec. It’s not a generic Pod limitation; mounts can be defined
    as writable for multiple containers if you need that. Figure 7.3 shows my output.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个练习时，你会看到第一个容器可以将数据写入共享卷，第二个容器可以读取它，但它本身不能写入数据。这是因为在这个Pod规范中，卷挂载被定义为第二个容器的只读。这不是一个通用的Pod限制；如果需要，挂载可以被定义为多个容器的可写。图7.3显示了我的输出。
- en: '![](../Images/7-3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图7-3](../Images/7-3.jpg)'
- en: Figure 7.3 Containers can mount the same Pod volume to share data but with different
    access levels.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：容器可以将相同的Pod卷挂载以共享数据，但具有不同的访问级别。
- en: A good old empty directory volume shows its worth again here; it’s a simple
    scratch pad that all the Pod containers can access. Volumes are defined at the
    Pod level and mounted at the container level, which means you can use any type
    of volume or PVC and make it available for many containers to use. Decoupling
    the volume definition from the volume mount also allows selective sharing, so
    one container may be able to see Secrets whereas the others can’t.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个古老的空目录卷在这里再次显示了它的价值；它是一个所有Pod容器都可以访问的简单便笺。卷在Pod级别定义，在容器级别挂载，这意味着你可以使用任何类型的卷或PVC，并将其提供给许多容器使用。将卷定义与卷挂载解耦还允许选择性共享，因此一个容器可能能够看到Secrets，而其他容器则不能。
- en: The other shared space is the network, where containers can listen on different
    ports and provide independent pieces of functionality. This is useful if your
    app container is doing some background work but doesn’t have any features to report
    on progress. Another container in the same Pod can provide a REST API, which reports
    on what the app container is doing.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个共享空间是网络，容器可以在不同的端口上监听并提供独立的功能块。如果你的应用容器正在做一些后台工作但没有任何功能来报告进度，这很有用。同一个Pod中的另一个容器可以提供一个REST
    API，报告应用容器正在做什么。
- en: Listing 7.2 shows a simplified version of this process. This is an update to
    the sleep deployment that replaces the file-sharing container with a new container
    spec that runs a simple HTTP server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2显示了此过程的简化版本。这是对sleep部署的更新，用新的容器规范替换了文件共享容器，该规范运行一个简单的HTTP服务器。
- en: Listing 7.2 sleep-with-server.yaml, running a web server in a second container
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 sleep-with-server.yaml，在第二个容器中运行Web服务器
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now the Pod will run with the original app container—the sleep container, which
    isn’t really doing anything—and a server container, which provides an HTTP endpoint
    on port 8080\. The two containers share the same network space, so the sleep container
    can access the server using the localhost address.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Pod将运行原始应用程序容器——sleep容器，它实际上并没有做什么——和一个服务器容器，该服务器容器在端口8080上提供了一个HTTP端点。这两个容器共享相同的网络空间，因此sleep容器可以使用localhost地址访问服务器。
- en: Try it now Update the sleep Deployment using the file from listing 7.2, and
    confirm that the server container is accessible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 使用7.2列表中的文件更新sleep部署，并确认服务器容器可访问。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see my output in figure 7.4\. Although these are separate containers,
    at the network level they function as though they were different processes running
    on the same machine, using the local address for communication.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图7.4中看到我的输出。尽管这些是独立的容器，但在网络层面上，它们就像在同一台机器上运行的不同进程一样工作，使用本地地址进行通信。
- en: '![](../Images/7-4.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4](../Images/7-4.jpg)'
- en: Figure 7.4 Network communication between containers in the same Pod is over
    localhost.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4显示，同一Pod中的容器之间的网络通信是通过localhost进行的。
- en: It’s not just within the Pod that the network is shared. The Pod has an IP address
    on the cluster, and if any containers in the Pod are listening on ports, then
    other Pods can access them. You can create a Service that routes traffic to the
    Pod on a specific port, and whichever container is listening on that port will
    receive the request.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 网络共享不仅限于Pod内部。Pod在集群上有一个IP地址，如果Pod中的任何容器正在监听端口，则其他Pod可以访问它们。您可以为特定端口上的Pod创建一个服务，将流量路由到该Pod，并且监听该端口的任何容器都将接收到请求。
- en: Try it now Use a kubectl command to expose the Pod port—this is a quick way
    to create a Service without writing YAML—and then test that the HTTP server is
    accessible externally.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 使用kubectl命令公开Pod端口——这是一种不编写YAML即可快速创建服务的方法，然后测试HTTP服务器是否可以从外部访问。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Figure 7.5 shows my output. From the outside world, it’s just network traffic
    going to a Service, which gets routed to a Pod. The Pod is running multiple containers,
    but that’s a detail that is hidden from the consumer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5显示了我的输出。从外部世界来看，这只是流向服务的网络流量，该服务被路由到Pod。Pod正在运行多个容器，但这是对消费者隐藏的细节。
- en: '![](../Images/7-5.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5](../Images/7-5.jpg)'
- en: Figure 7.5 Services can route network requests to any Pod containers that have
    published ports.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5显示，服务可以将网络请求路由到任何已发布端口的Pod容器。
- en: 'You should be getting a feel for how powerful running multiple containers in
    a Pod is, and in the rest of the chapter, we’ll put the ideas to work in real-world
    scenarios. There’s one thing that needs to be stressed, though: a Pod is not a
    replacement for a VM, so don’t think you can run all the components of an app
    in one Pod. You might be tempted to model an app like that, with a web server
    container and an API container running in the same Pod—don’t. A Pod is a single
    unit, and it should be used for a single component of your app. Additional containers
    can be used to support the app container, but you shouldn’t be running different
    apps in the same Pod. Doing so ruins your ability to update, scale, and manage
    those components independently.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经感受到了在Pod中运行多个容器的强大之处，在接下来的章节中，我们将将这些想法应用于实际场景。不过，有一件事需要强调：Pod不是虚拟机的替代品，所以不要以为您可以在一个Pod中运行应用程序的所有组件。您可能会倾向于将应用程序建模为那样，即一个运行在同一个Pod中的Web服务器容器和一个API容器——不要这样做。Pod是一个单一单元，应该用于您的应用程序的单个组件。可以使用额外的容器来支持应用程序容器，但您不应该在同一个Pod中运行不同的应用程序。这样做会破坏您独立更新、扩展和管理这些组件的能力。
- en: 7.2 Setting up applications with init containers
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 使用初始化容器设置应用程序
- en: 'So far we’ve run Pods with multiple containers where all the containers run
    in parallel: they start together, and the Pod isn’t considered to be ready until
    all the containers are ready. You’ll hear that referred to as the *sidecar pattern*,
    which reinforces the idea that additional containers (the sidecars) play a supporting
    role to the application container (the motorcycle). There’s another pattern that
    Kubernetes supports when you need a container to run before the app container
    to set up part of the environment. This is called an *init container*.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经运行了包含多个容器的Pod，其中所有容器都并行运行：它们同时启动，Pod只有在所有容器都准备好后才被认为是就绪的。您会听到这被称为*边车模式*，这强化了额外容器（边车）作为应用程序容器（摩托车）的辅助角色的想法。当您需要容器在应用程序容器之前运行以设置环境的一部分时，Kubernetes还支持另一种模式。这被称为*初始化容器*。
- en: Init containers work differently from sidecars. You can have multiple init containers
    defined for the Pod, and they run in sequence, in the order in which they’re written
    in the Pod spec. Each init container needs to complete successfully before the
    next one starts, and all must complete successfully before the Pod containers
    are started. Figure 7.6 shows the startup sequence for a Pod with init containers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器的工作方式与边车容器不同。你可以为 Pod 定义多个初始化容器，并且它们按顺序运行，顺序与 Pod 规范中编写的顺序相同。每个初始化容器在下一个开始之前都需要成功完成，并且所有初始化容器都必须成功完成，Pod
    容器才能启动。图 7.6 显示了具有初始化容器的 Pod 的启动顺序。
- en: '![](../Images/7-6.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-6](../Images/7-6.jpg)'
- en: Figure 7.6 Init containers are useful for startup tasks to prepare the Pod for
    the app containers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 初始化容器对于启动任务很有用，可以为应用程序容器准备 Pod。
- en: All containers can access volumes defined in the Pod, so the major use case
    is for an init container to write data that prepares the environment for the application
    container. Listing 7.3 shows a simple extension to the HTTP server in the sleep
    Pod from the previous exercise. An init container runs and generates an HTML file,
    which it writes in a mount for an `EmptyDir` volume. The server container responds
    to HTTP requests by sending the contents of that file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有容器都可以访问 Pod 中定义的卷，因此主要用例是初始化容器写入为应用程序容器准备环境的数据。列表 7.3 展示了从上一个练习中 sleep Pod
    的 HTTP 服务器的简单扩展。初始化容器运行并生成一个 HTML 文件，它将该文件写入 `EmptyDir` 卷的挂载点。服务器容器通过发送该文件的内容来响应
    HTTP 请求。
- en: Listing 7.3 sleep-with-html-server.yaml, an init container in the Pod spec
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 sleep-with-html-server.yaml，Pod 规范中的初始化容器
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example uses the same sleep image for the init container, but it can be
    any image. You might use an init container to set up the application environment
    using tools that you don’t want to be present in the running application. An init
    container can use a Docker image with the Git command line installed and clone
    a repository into the shared filesystem. The app container can access to the files
    without you having to set up the Git client in your app image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用与初始化容器相同的 sleep 镜像，但它可以是任何镜像。你可能会使用初始化容器通过安装 Git 命令行工具来设置应用程序环境，并将存储库克隆到共享文件系统中。应用程序容器可以访问这些文件，而无需你在应用程序镜像中设置
    Git 客户端。
- en: Try it now Deploy the update from listing 7.3, and see how init containers work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：部署列表 7.3 中的更新，看看初始化容器是如何工作的。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll pick up a few things from this exercise. App containers are guaranteed
    not to run until init containers complete successfully, so your app can safely
    make assumptions about the environment that the init container prepares. In this
    case, the HTML file is sure to exist before the server container starts. Init
    containers are a different part of the Pod spec, but some management features
    work in the same way as app containers—you can read the logs from init containers
    even after they have exited. My output appears in figure 7.7.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从这次练习中学到一些东西。应用程序容器只有在初始化容器成功完成后才会运行，因此你的应用程序可以安全地假设初始化容器准备的环境。在这种情况下，HTML
    文件在服务器容器启动之前肯定存在。初始化容器是 Pod 规范的另一个部分，但某些管理功能与应用程序容器的工作方式相同——即使初始化容器已经退出，你也可以读取其日志。我的输出显示在图
    7.7 中。
- en: '![](../Images/7-7.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7-7](../Images/7-7.jpg)'
- en: Figure 7.7 Init containers are useful for preparing the Pod environment for
    app and sidecar containers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 初始化容器对于为应用程序和边车容器准备 Pod 环境很有用。
- en: That still isn’t a very real-world example, though, so let’s do something better.
    We covered app configuration in chapter 4 and saw how to use environment variables,
    ConfigMaps, and Secrets to build up a hierarchy of configuration settings. That’s
    great if your app supports it, but many older apps don’t have that flexibility;
    they expect to find a single config file in one place, and they don’t go looking
    anywhere else. Let’s look at an app like that.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这仍然不是一个非常贴近现实世界的例子，所以让我们做一些更好的事情。我们在第 4 章中介绍了应用程序配置，并看到了如何使用环境变量、ConfigMaps
    和 Secrets 来构建配置设置的层次结构。如果你的应用程序支持这一点，那真是太好了，但许多较老的应用程序没有这种灵活性；它们期望在某个地方找到一个单独的配置文件，并且不会在其他地方寻找。让我们看看这样的应用程序。
- en: Try it now This chapter has a new demo app, because if I’m getting bored with
    looking at Pi, then you must be, too. This one isn’t much more fun, but at least
    it’s different. It just writes a timestamp to a log file every few seconds. It
    has an old-style configuration framework, so we can’t use any of the configuration
    techniques we’ve learned so far.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 本章有一个新的演示应用程序，因为如果我看着Pi感到无聊，那么你肯定也是。这个程序并没有更多乐趣，但至少它是不同的。它每隔几秒将时间戳写入日志文件。它有一个旧式的配置框架，因此我们无法使用我们迄今为止学到的任何配置技术。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see my output in figure 7.8\. A limited configuration framework isn’t
    the only reason this app isn’t a good citizen in a container platform—there are
    no logs in the Pod, either—but we can address all the problems with additional
    containers in the Pod.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图7.8中看到我的输出。有限的配置框架并不是这个应用程序在容器平台中不是好公民的唯一原因——Pod中也没有日志——但我们可以通过Pod中的额外容器来解决所有问题。
- en: '![](../Images/7-8.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-8.jpg)'
- en: Figure 7.8 Older apps that use a single configuration source can’t benefit from
    a configuration hierarchy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 使用单个配置源的老旧应用程序无法从配置层次结构中受益。
- en: An init container is a perfect tool to bring this app into line with the configuration
    approach we want to use for all our apps. We can store the settings in ConfigMaps,
    Secrets, and environment variables, and use an init container to read from all
    the different inputs, merge the contents, and write the output to the single file
    location that the app uses. Listing 7.4 shows the init container in the Pod spec.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化容器是一个完美的工具，可以将这个应用程序调整为我们为所有应用程序想要使用的配置方法。我们可以将设置存储在ConfigMaps、Secrets和环境变量中，并使用初始化容器从所有不同的输入中读取，合并内容，并将输出写入应用程序使用的单个文件位置。列表7.4显示了Pod规范中的初始化容器。
- en: Listing 7.4 timecheck-with-config.yaml, an init container that writes configuration
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 timecheck-with-config.yaml，一个写入配置的初始化容器
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are a few things to note before we update the deployment:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更新部署之前，有一些需要注意的事项：
- en: The init container uses the jq tool, which the app doesn’t need. The containers
    use different images, each with just the tools necessary to run that step.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化容器使用jq工具，而应用程序不需要这个工具。容器使用不同的镜像，每个镜像都只包含运行该步骤所需的工具。
- en: The command in the init container reads from a `ConfigMap` volume mount, merges
    the environment variable values, and writes out to an `EmptyDir` volume mount.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化容器中的命令从`ConfigMap`卷挂载读取，合并环境变量值，并将输出写入到`EmptyDir`卷挂载。
- en: The app container mounts the `EmptyDir` volume to the path where the config
    file needs to be. The file generated by the init container hides the default configuration
    in the app image.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序容器将`EmptyDir`卷挂载到需要配置文件的路径。由初始化容器生成的文件隐藏了应用程序镜像中的默认配置。
- en: Containers don’t share environment variables. The settings are specified for
    the init container; the app container doesn’t see those.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器不共享环境变量。设置是为初始化容器指定的；应用程序容器看不到这些设置。
- en: Containers map the volumes they need. Both containers mount the `EmptyDir` volume,
    which they share, but only the init container mounts the `ConfigMap`.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器映射它们需要的卷。两个容器都挂载了`EmptyDir`卷，它们共享这个卷，但只有初始化容器挂载了`ConfigMap`。
- en: When we apply this update, the app’s behavior will change in line with the `ConfigMap`
    and environment variables, even though the app container doesn’t use them as configuration
    sources.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用这个更新时，应用程序的行为将根据`ConfigMap`和环境变量而改变，即使应用程序容器不使用它们作为配置源。
- en: Try it now Update the timecheck app using listing 7.4 so the app container is
    configured from multiple sources.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 使用列表7.4更新timecheck应用程序，以便应用程序容器从多个源进行配置。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You’ll see when you run this that the app works with the new configuration,
    and the only change for the application container spec is that the config directory
    is mounted from the `EmptyDir` volume. My output is shown in figure 7.9.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会看到应用程序与新的配置一起工作，应用程序容器规范中唯一的变化是配置目录是从`EmptyDir`卷挂载的。我的输出显示在图7.9中。
- en: '![](../Images/7-9.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-9.jpg)'
- en: Figure 7.9 Init containers can change app behavior without changes to the app
    code or Docker image.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 初始化容器可以在不更改应用程序代码或Docker镜像的情况下改变应用程序的行为。
- en: This approach works because the config file is loaded from a dedicated directory.
    Remember that a volume mount overwrites a directory from the image, if it already
    exists. If the app loaded a config file from the same directory as the app binaries,
    you couldn’t do this because the `EmptyDir` mount would overwrite the whole app
    folder. In that scenario, you would need an additional step in the app container
    startup to copy the config file from the mount into the application directory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法之所以有效，是因为配置文件是从一个专用目录加载的。请记住，如果已经存在，卷挂载会覆盖镜像中的目录。如果应用程序从与应用程序二进制文件相同的目录加载配置文件，你就无法这样做，因为`EmptyDir`挂载会覆盖整个应用程序文件夹。在这种情况下，你需要在应用程序容器启动时添加一个额外的步骤，将配置文件从挂载复制到应用程序目录中。
- en: Applying a standard configuration approach to nonstandard apps is a great use
    for init containers, but older apps still won’t play nicely in a modern platform,
    and that’s where sidecar containers can help.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将标准配置方法应用于非标准应用程序是init容器的一个很好的用途，但较老的应用程序仍然不会在现代平台上很好地运行，这就是边车容器可以提供帮助的地方。
- en: 7.3 Applying consistency with adapter containers
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 使用适配器容器应用一致性
- en: Moving apps to Kubernetes is a great opportunity to add a layer of consistency
    across all your apps, so you deploy and manage them the same way using the same
    tools, no matter what the app is doing, or what technology stack it uses, or when
    it was developed. My fellow Docker Captain, Sune Keller, has talked about the
    service hotel ([https://bit.ly/376rBcF](https://bit.ly/376rBcF)) concept they
    use at Alm Brand. Their container platform offers a set of guarantees for “customers”
    (like high availability and security), provided they adhere to the rules (like
    pulling the configuration from the platform and writing logs out to it).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序迁移到Kubernetes是一个很好的机会，可以在所有应用程序之间添加一层一致性，这样你就可以使用相同的工具以相同的方式部署和管理它们，无论应用程序做什么，使用什么技术栈，或者何时开发。我的同事Docker
    Captain Sune Keller曾经谈到他们在Alm Brand使用的服务酒店([https://bit.ly/376rBcF](https://bit.ly/376rBcF))概念。他们的容器平台为“客户”（如高可用性和安全性）提供了一系列保证，前提是他们遵守规则（如从平台拉取配置并将其日志写入平台）。
- en: Not all apps know about the rules, and some of them can’t be applied by the
    platform from the outside, but sidecar containers run alongside the app container
    so they have a privileged position. You can use them as *adapters*, which understand
    some aspect of how the app works and adapts it to how the platform wants it to
    work. Logging is a classic example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有应用程序都知道规则，并且有些规则无法由平台从外部应用，但边车容器与应用程序容器并行运行，因此它们处于有利的地位。你可以将它们用作*适配器*，这些适配器理解应用程序工作的一些方面，并将其适应平台希望它工作的方式。日志是一个经典的例子。
- en: Every app writes some output to log entries—or should; otherwise, it would be
    entirely unmanageable, and you should refuse to work with it. Modern app platforms
    like Node.js and .NET Core write to the standard output stream, which is where
    Docker fetches container logs and where Kubernetes gets the Pod logs. Older apps
    have different ideas about logging, and they may write to files or other targets
    that never get surfaced as container logs, so you never see any Pod logs (see
    Appendix D in the ebook to learn more about logging in Docker). That’s what the
    timecheck app does, and we can fix it with a very simple sidecar container. The
    spec appears in listing 7.5.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都会将一些输出写入日志条目——或者应该这样做；否则，它将完全无法管理，你应该拒绝与之合作。现代应用程序平台，如Node.js和.NET Core，会将输出写入标准输出流，这是Docker获取容器日志和Kubernetes获取Pod日志的地方。较老的应用程序对日志有不同的看法，它们可能将日志写入文件或其他永远不会作为容器日志出现的目标，因此你永远不会看到任何Pod日志（请参阅电子书的附录D以了解更多关于Docker中的日志信息）。这就是timecheck应用程序所做的事情，我们可以通过一个非常简单的边车容器来修复它。其规范出现在列表7.5中。
- en: Listing 7.5 timecheck-with-logging.yaml, using a sidecar container to expose
    logs
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 timecheck-with-logging.yaml，使用边车容器公开日志
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All the sidecar does is mount the log volume (go `EmptyDir`!) and use the standard
    Linux `tail` command to read from the log file. The `-f` option means the command
    will follow the file; effectively, it just sits and watches for new writes, and
    when any lines are written to the file, they’re echoed to standard out. It’s a
    relay that adapts the app’s actual logging implementation to the expectations
    of Kubernetes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 边车所做的只是挂载日志卷（使用`EmptyDir`！）并使用标准的Linux `tail`命令从日志文件中读取。`-f`选项意味着命令将跟踪文件；实际上，它只是坐着并监视新的写入，当文件中写入任何行时，它们会被回显到标准输出。它是一个中继器，将应用程序的实际日志实现适配到Kubernetes的期望。
- en: Try it now Apply the update from listing 7.5, and check the app logs are available.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 应用列表7.5中的更新，并检查应用程序日志是否可用。
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There’s some inefficiency here because the app container writes logs to a file
    and then the logging container reads them back out again. There will be a small
    time lag and potentially a lot of wasted disk, but the Pod will be replaced in
    the next app update, and all the space used in the volume will be reclaimed. The
    benefit is that this Pod now behaves like every other Pod, making application
    logs available to Kubernetes but without any changes needed to the app itself,
    as is shown in figure 7.10.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些低效之处，因为应用程序容器将日志写入文件，然后日志容器再次读取它们。这将产生一小段时间延迟，并且可能浪费大量磁盘空间，但在下一个应用程序更新中，Pod
    将被替换，并且所有在卷中使用的空间都将被回收。好处是，这个 Pod 现在表现得像其他所有 Pod 一样，使应用程序日志可用于 Kubernetes，而无需对应用程序本身进行任何更改，如图
    7.10 所示。
- en: '![](../Images/7-10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-10.jpg)'
- en: Figure 7.10 Adapters bring a layer of consistency to Pods, making old apps behave
    like new apps.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 适配器为 Pods 带来一层一致性，使旧应用程序表现得像新应用程序。
- en: Receiving configuration from the platform and writing logs to the platform are
    pretty much the fundamentals for any application, but as your platform matures,
    you’ll have more expectations for standard behavior. You’ll want to be able to
    test that the application inside the container is healthy, and you’ll also want
    to be able to pull metrics from the app to see what it’s doing and how hard it’s
    working.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从平台接收配置并将日志写入平台是任何应用程序的基本操作，但随着平台的成熟，你会有更多对标准行为的期望。你希望能够测试容器内的应用程序是否健康，并且你希望能够从应用程序中提取指标以了解它在做什么以及它工作得多努力。
- en: Sidecars can help there, too, either by running custom containers, which provide
    information tailored to the app, or by having standard health and metrics container
    images, which you apply to all your Pod specs. We’ll round off the exercises using
    the timecheck app and add those features that make it a good citizen for Kubernetes.
    We’ll cheat, though, with some more static HTTP server containers, which you can
    see in listing 7.6.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 边车也能在这方面提供帮助，要么通过运行定制的容器，这些容器提供针对应用程序的信息，要么通过拥有标准的健康和指标容器镜像，你可以将这些镜像应用到所有的 Pod
    规范中。我们将使用 timecheck 应用程序来完成练习，并添加使其成为 Kubernetes 良好公民的功能。不过，我们将使用一些额外的静态 HTTP
    服务器容器来作弊，这些容器可以在列表 7.6 中看到。
- en: Listing 7.6 timecheck-good-citizen.yaml, more sidecars to extend the app
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 timecheck-good-citizen.yaml，更多边车以扩展应用程序
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The full YAML file also includes a ClusterIP Service, which publishes on port
    8080 for the health endpoint and port 8081 for the metrics endpoint. In a production
    cluster, these would be used by other components to collect monitoring stats.
    The Deployment is an extension of the previous releases, so the app uses an init
    container for configuration and has a logging sidecar along with the new sidecars.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 YAML 文件还包括一个 ClusterIP 服务，该服务在端口 8080 上发布健康端点，在端口 8081 上发布指标端点。在生产集群中，这些端口将由其他组件用于收集监控统计信息。部署是之前版本的扩展，因此应用程序使用初始化容器进行配置，并带有新的边车容器以及日志边车。
- en: Try it now Deploy the update, and check the new management endpoints for the
    health and performance of the app.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看：部署更新，并检查应用程序的健康和性能新管理端点。
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you run the exercise, you’ll see everything works as expected, as shown
    in figure 7.11\. You may also see the updates weren’t as speedy as you’re used
    to, with the new Pod taking longer to start up and the old Pod taking longer to
    terminate. The additional startup time is from having the init container, the
    app container, and all the sidecars—they all need to be ready before the new Pod
    is considered ready. The additional termination time is because the replaced Pod
    also had multiple containers, which are each given a grace period for the container
    process to shut down.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行练习时，你会看到一切按预期工作，如图 7.11 所示。你也可能看到更新没有你习惯的那么快，新的 Pod 启动时间更长，旧的 Pod 终止时间更长。额外的启动时间是初始化容器、应用程序容器和所有边车都需要准备好的时间——所有这些都需要在新的
    Pod 被认为是准备好之前完成。额外的终止时间是因为被替换的 Pod 也包含多个容器，每个容器都会给容器进程关闭一个宽限期。
- en: '![](../Images/7-11.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7-11.jpg)'
- en: Figure 7.11 Multiple adapter sidecars give the app a consistent management API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 多个适配器边车为应用程序提供了一个一致的管理 API。
- en: There is an overhead to running all these sidecar containers as adapters. You’ve
    seen that it increases deployment times, but it also increases the ongoing compute
    requirements of the app—even storage and basic sidecars, which just tail log files
    and serve simple HTTP responses, all use memory and compute cycles. But if you
    want to move existing apps to Kubernetes that don’t have those features, it’s
    an acceptable approach to get all your apps behaving in the same way, as shown
    in figure 7.12.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有这些作为适配器的边车容器会有一些开销。你已经看到这增加了部署时间，但它也增加了应用程序的持续计算需求——甚至只是跟踪日志文件和提供简单HTTP响应的基本边车，也都消耗内存和计算周期。但是，如果你想要将没有这些功能的现有应用程序迁移到Kubernetes，那么让所有应用程序以相同的方式运行是一种可接受的方法，如图7.12所示。
- en: '![](../Images/7-12.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图7-12](../Images/7-12.jpg)'
- en: Figure 7.12 A consistent management API makes it easy to work with Pods—it doesn’t
    matter how the API is provided inside the Pod.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 一致的管理API使得与Pod一起工作变得容易——无论API如何在Pod内部提供。
- en: In the previous exercise, we used an old sleep Pod we had lying around to call
    the new HTTP endpoints for the timecheck app. Remember that Kubernetes has a flat
    networking model, where Pods can send traffic to any other Pods via a Service.
    You may want more control over the network communication in your app, and you
    can do that with sidecars, too, by running a proxy container that manages the
    outgoing traffic from your app container.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们使用了一个闲置的旧sleep Pod来调用timecheck应用程序的新HTTP端点。记住，Kubernetes有一个扁平的网络模型，其中Pod可以通过Service向任何其他Pod发送流量。你可能想要对你的应用程序中的网络通信有更多的控制，你同样可以通过运行一个管理出站流量的代理容器来实现这一点。
- en: 7.4 Abstracting connections with ambassador containers
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 使用代理容器抽象连接
- en: 'The ambassador pattern lets you control and simplify outgoing connections from
    your application: your app makes network requests to the localhost address, which
    are picked up and performed by the ambassador. You can make use of a generic ambassador
    container, or one that is specific to your application components, in several
    situations. Figure 7.13 shows some examples. The logic in the ambassador might
    be geared to improving performance or increasing reliability or security.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式让你可以控制和简化应用程序的出站连接：你的应用程序向localhost地址发起网络请求，这些请求被代理捕获并执行。在几种情况下，你可以使用一个通用的代理容器，或者一个特定于你的应用程序组件的代理容器。图7.13显示了几个例子。代理中的逻辑可能是为了提高性能、增加可靠性或安全性。
- en: '![](../Images/7-13.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图7-13](../Images/7-13.jpg)'
- en: Figure 7.13 The ambassador pattern has lots of potential, from simplifying app
    logic to increasing performance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 代理模式具有很大的潜力，从简化应用程序逻辑到提高性能。
- en: Taking control of the network away from the application is hugely powerful.
    A proxy container can do service discovery, load balancing, retries, and even
    layer encryption onto an unencrypted channel. Perhaps you’ve heard of the service
    mesh architecture, using technologies like Linkerd and Istio—they’re all powered
    by proxy sidecar containers in a variation of the ambassador pattern.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序中接管网络控制是非常强大的。代理容器可以进行服务发现、负载均衡、重试，甚至在不加密的通道上添加加密层。你可能听说过服务网格架构，使用像Linkerd和Istio这样的技术——它们都是通过代理边车容器在代理模式的不同变体中实现的。
- en: We won’t use a service mesh architecture here because that would take us well
    past lunchtime and on into the night, but we’ll get a flavor of what it can do
    with a simplified example. The starting point is the random-number app we’ve used
    before. There’s a web app running in a Pod, which consumes an API running in another
    Pod. The API is the only component the web app uses, so ideally we would restrict
    network calls to any other address, but in the initial deployment that doesn’t
    happen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会使用服务网格架构，因为这会让我们远远超出午餐时间，进入夜晚，但我们将通过一个简化的例子来了解它能够做什么。起点是我们之前使用的随机数应用程序。有一个Web应用程序在一个Pod中运行，它消费另一个Pod中运行的API。API是Web应用程序使用的唯一组件，因此理想情况下，我们应该限制对任何其他地址的网络调用，但在初始部署中并没有这样做。
- en: Try it now Run the random-number app, and verify that the web app container
    can use any network address.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行随机数应用程序，并验证Web应用程序容器是否可以使用任何网络地址。
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The web Pod can reach the API using the ClusterIP Service and the domain name
    `numbers-api`, but it can also access any other address, which could be a URL
    on the public internet or another ClusterIP Service. Figure 7.14 shows the app
    can read the health endpoint of the timecheck app—that should be a private endpoint,
    and it might expose information that is useful to someone up to no good.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Web Pod可以使用ClusterIP服务和域名`numbers-api`来访问API，但它也可以访问任何其他地址，这可能是公共互联网上的URL或另一个ClusterIP服务。图7.14显示应用程序可以读取timecheck应用程序的健康端点——这应该是一个私有端点，并且可能暴露对某些人有用的信息。
- en: '![](../Images/7-14.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-14.jpg)'
- en: Figure 7.14 Kubernetes doesn’t have any default restrictions on outgoing connections
    from Pod containers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 Kubernetes对Pod容器发出的连接没有任何默认限制。
- en: You have a lot of options for restricting network access besides using a proxy
    sidecar, but the ambassador pattern comes with some additional features that make
    it worth considering. Listing 7.7 shows an update to the web app spec, using a
    simple proxy container as an ambassador.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用代理侧边车之外，您还有许多选项可以限制网络访问，但大使模式附带一些额外的功能，使其值得考虑。列表7.7显示了Web应用程序规范的更新，使用简单的代理容器作为大使。
- en: Listing 7.7 web-with-proxy.yaml, using a proxy as an ambassador
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7 web-with-proxy.yaml，使用代理作为大使
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This example shows the major pieces of the ambassador pattern: the app container
    uses localhost addresses for any services it consumes, and it’s configured to
    route all network calls through the proxy container. The proxy is a custom app
    that logs network calls, maps localhost addresses to real addresses, and blocks
    any addresses that are not listed in the map. All that becomes functionality in
    the Pod, but it’s transparent to the application container.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了大使模式的要点：应用程序容器使用localhost地址来消费任何服务，并且配置为将所有网络调用通过代理容器路由。代理是一个自定义应用程序，它记录网络调用，将localhost地址映射到实际地址，并阻止任何未列在映射中的地址。所有这些功能都成为Pod中的功能，但对应用程序容器来说是透明的。
- en: Try it now Update the random-number app, and confirm the network is now locked
    down.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 更新随机数应用程序，并确认网络现在已锁定。
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now the web app is decoupled even further from the API, because it doesn’t even
    know the URL of the API—that’s set in the ambassador, which can be configured
    independently of the app. The web app is also restricted to using a single address
    for outgoing requests, and all of those calls are logged by the proxy, as you
    see in figure 7.15.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Web应用程序与API的解耦程度更高，因为它甚至不知道API的URL——这是在大使中设置的，可以独立于应用程序进行配置。Web应用程序也被限制为使用单个地址进行出站请求，并且所有这些调用都由代理记录，如图7.15所示。
- en: '![](../Images/7-15.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-15.jpg)'
- en: Figure 7.15 All network access is via the ambassador, which can implement its
    own access rules.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 所有网络访问都通过大使进行，它可以实现自己的访问规则。
- en: The ambassador for this web app proxies HTTP calls outside of the Pod, but the
    ambassador pattern is wider than that. It plugs into the network at the transport
    layer, so it can work on any kind of traffic. A database ambassador can make some
    smart choices, like sending queries to a read-only database replica and using
    only the master database for writes. That’s going to improve performance and scale,
    while keeping complex logic out of the application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此Web应用程序的大使代理HTTP调用在Pod外部，但大使模式比这更广泛。它在传输层连接到网络，因此它可以处理任何类型的流量。数据库大使可以做出一些明智的选择，例如将查询发送到只读数据库副本，并仅使用主数据库进行写入。这将提高性能和可扩展性，同时将复杂逻辑排除在应用程序之外。
- en: We’ll round out the chapter by taking a closer look at what it means to use
    the Pod as a shared environment for many containers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过更仔细地研究将Pod作为许多容器的共享环境意味着什么来结束本章。
- en: 7.5 Understanding the Pod environment
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 理解Pod环境
- en: The Pod is a boundary around one or more containers, just like the container
    is a boundary around one or more processes. Pods create layers of virtualization
    without adding overhead, so they’re flexible and efficient. The cost of that flexibility
    is—as always—complexity, and you need to be aware of some nuances to working with
    multicontainer Pods.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是一个或多个容器的边界，就像容器是一个或多个进程的边界一样。Pod创建虚拟化层而不增加开销，因此它们灵活且高效。这种灵活性的代价是——就像往常一样——复杂性，并且您需要了解一些与多容器Pod一起工作的细微差别。
- en: The main thing to understand is that the Pod is still the single unit of compute,
    even if lots of containers are running inside it. Pods aren’t ready until all
    the containers in the Pod are ready, and Services send traffic only to Pods that
    are ready. Adding sidecars and init containers adds to the failure modes for your
    application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的主要一点是，即使 Pod 内部运行了大量的容器，Pod 仍然是单个计算单元。只有当 Pod 中的所有容器都准备好时，Pod 才会准备好，并且服务只会将流量发送到准备好的
    Pod。添加侧边容器和初始化容器增加了您应用程序的故障模式。
- en: Try it now You can break your application if an init container fails. This update
    to the numbers app won’t be successful because the init container is misconfigured.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 如果初始化容器失败，您可能会破坏您的应用程序。对数字应用程序的此更新将不会成功，因为初始化容器配置错误。
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see in this exercise that the failed init container effectively prevents
    the application from updating. The new Pod never enters the running state and
    won’t receive traffic from the Service. The Deployment never scales down the old
    ReplicaSet because the new one doesn’t reach the required level of availability,
    but the basic details of the Deployment look like the update has worked, as shown
    in figure 7.16.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这次练习中看到，失败的初始化容器有效地阻止了应用程序的更新。新的 Pod 永远不会进入运行状态，并且不会从服务接收流量。部署永远不会缩小旧的 ReplicaSet，因为新的一个没有达到所需的可用性级别，但部署的基本细节看起来像更新已经成功，如图
    7.16 所示。
- en: '![](../Images/7-16.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16](../Images/7-16.jpg)'
- en: Figure 7.16 Adding more containers to your Pod spec adds more opportunities
    for the Pod to fail
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 向您的 Pod 规范添加更多容器为 Pod 失败提供了更多机会
- en: 'The same situation will happen if a sidecar container fails on startup—the
    Pod doesn’t have all of its containers running so the Pod itself isn’t ready.
    Any deployment checks you have in place need to be extended for multicontainer
    Pods to ensure all init containers run to completion and all Pod containers are
    running. You need to be aware of the following restart conditions, too:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动时侧边容器失败，同样会出现这种情况——Pod 没有所有容器都在运行，所以 Pod 本身还没有准备好。您设置的任何部署检查都需要扩展到多容器 Pod，以确保所有初始化容器运行完成，并且所有
    Pod 容器都在运行。您还需要注意以下重启条件：
- en: If a Pod with init containers is replaced, then the new Pod runs all the init
    containers again. You must ensure your init logic can be run repeatedly.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果替换了具有初始化容器的 Pod，则新 Pod 将再次运行所有初始化容器。您必须确保您的初始化逻辑可以重复运行。
- en: If you deploy a change to the init container image(s) for a Pod, that restarts
    the Pod. Init containers all execute again, and app containers are replaced.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您将 Pod 的初始化容器镜像（s）的更改部署，则 Pod 将重新启动。初始化容器将再次执行，应用程序容器被替换。
- en: If you deploy a Pod spec change to the app container image(s), the app containers
    are replaced, but the init containers are not executed again.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您将 Pod 规范更改部署到应用程序容器镜像（s），则应用程序容器将被替换，但初始化容器不会再次执行。
- en: If an application container exits, then the Pod re-creates it. Until the container
    is replaced, the Pod is not fully running and won’t receive Service traffic.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序容器退出，则 Pod 会重新创建它。直到容器被替换，Pod 才是完整运行的，并且不会接收服务流量。
- en: The Pod is a single compute environment, but when you add multiple moving parts
    inside that environment, you need to test all the failure scenarios and make sure
    your app behaves as you expect.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是一个单一的计算环境，但是当您在该环境中添加多个移动部件时，您需要测试所有故障场景，并确保您的应用程序按预期运行。
- en: 'There’s one last part of the Pod environment that we haven’t covered: the compute
    layer. Pod containers have a shared network and can share parts of the filesystem,
    but they can’t access each other’s processes—the container boundary still provides
    compute isolation. That’s the default behavior, but in some cases, you want your
    sidecar to have access to the processes in the application container, either for
    interprocess communication or so the sidecar can fetch metrics about the app process.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涵盖 Pod 环境的最后一部分：计算层。Pod 容器有一个共享的网络，并且可以共享文件系统的一部分，但它们不能访问彼此的进程——容器边界仍然提供计算隔离。这是默认行为，但在某些情况下，您可能希望您的侧边容器可以访问应用程序容器的进程，无论是为了进程间通信还是让侧边容器可以获取有关应用程序进程的指标。
- en: 'You can enable this access with a simple setting in the Pod spec: `shareProcessNamespace:`
    `true`. That means every container in the Pod shares the same compute space and
    can see each other’s processes.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 Pod 规范中的简单设置启用此访问：`shareProcessNamespace:` `true`。这意味着 Pod 中的每个容器都共享相同的计算空间，并且可以看到彼此的进程。
- en: Try it now Deploy an update to the sleep Pod so the containers use a shared
    compute space and can access each other’s processes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 部署对睡眠 Pod 的更新，以便容器使用共享的计算空间并可以访问彼此的进程。
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see my output in figure 7.17\. The sleep container can see all the server
    container’s processes, and it could happily kill them all and leave the Pod in
    a confused state.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图 7.17 中看到我的输出。睡眠容器可以看到所有服务器容器的进程，并且它可以愉快地杀死它们所有，并使 Pod 处于混乱状态。
- en: '![](../Images/7-17.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7-17.jpg)'
- en: Figure 7.17 You can configure a Pod so all containers can see all processes-use
    with care.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 您可以配置一个 Pod，使所有容器都可以看到所有进程 - 请谨慎使用。
- en: 'That’s all for multicontainer Pods. You’ve seen in this chapter that you can
    use init containers to prepare the environment for your application container
    and run sidecar containers to add features to your app, all without changing the
    app code or the Docker image. There are some caveats to using multiple containers,
    but it’s a pattern you’ll use often to extend your applications. Just remember
    that the Pod should be one logical component: I don’t want to see you running
    Nginx, WordPress, and MySQL in a single Pod just because you can. Let’s tidy up
    now and get ready for the lab.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是多容器 Pod 的全部内容。您在本章中看到，您可以使用初始化容器为您的应用程序容器准备环境，并运行边车容器以向您的应用程序添加功能，而无需更改应用程序代码或
    Docker 镜像。使用多个容器有一些注意事项，但这是一个您将经常使用的模式来扩展您的应用程序。只需记住，Pod 应该是一个逻辑组件：我不想看到您仅仅因为可以这样做就在一个
    Pod 中运行 Nginx、WordPress 和 MySQL。现在让我们整理一下，为实验做好准备。
- en: Try it now Remove everything matching this chapter’s label.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 移除与本章标签匹配的所有内容。
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 7.6 Lab
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 实验
- en: 'It’s back to the Pi app for this lab. The Docker image `kiamol/ch05-pi` can
    actually be used in different ways, and to run it as a web app, you need to override
    the startup command in the container spec. We’ve done that in the YAML files in
    previous chapters, but now we’ve been asked to use a standard approach to setting
    up the pod. Here are the requirements and some hints:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到这个实验的 Pi 应用程序。Docker 镜像 `kiamol/ch05-pi` 实际上可以用不同的方式使用，要将它作为 Web 应用程序运行，您需要覆盖容器规范中的启动命令。我们在前几章的
    YAML 文件中已经这样做过了，但现在我们被要求使用一种标准的设置 Pod 的方法。以下是要求和一些提示：
- en: The app container needs to use a standard startup command that all Pods in our
    platform are using. It should run `/init/startup.sh`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序容器需要使用所有 Pod 在我们平台上使用的标准启动命令。它应该运行 `/init/startup.sh`。
- en: The Pod should use port 80 for the app container.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 应该使用端口 80 用于应用程序容器。
- en: The Pod should also publish port 8080 for an HTTP server, which returns the
    version number of the app,
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 还应发布端口 8080 以供 HTTP 服务器使用，该服务器返回应用程序的版本号，
- en: The app container image doesn’t contain a startup script, so you’ll need to
    use something that can create that script and make it executable for the app container
    to run.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序容器镜像不包含启动脚本，因此您需要使用可以创建该脚本并将其设置为可执行文件以供应用程序容器运行的东西。
- en: The app doesn’t publish a version API on port 8080 (or anywhere else), so you’ll
    need something that can provide that (it can just be any static text).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序没有在端口 8080（或任何其他地方）发布版本 API，因此您需要一些可以提供该功能的东西（它可以是任何静态文本）。
- en: 'The starting point is the YAML in `ch07/lab/pi`, which is broken at the moment.
    You’ll need to do some investigation into how the app ran in previous chapters
    and apply the techniques we’ve learned in this chapter. You have plenty of ways
    to approach this one, and you’ll find my sample solution in the usual place: [https://github.com/sixeyed/kiamol/blob/master/ch07/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch07/lab/README.md).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 起始点是 `ch07/lab/pi` 中的 YAML 文件，目前该文件已损坏。您需要调查应用程序在前几章中的运行情况，并应用本章学到的技术。您有多种方法可以解决这个问题，您可以在通常的位置找到我的示例解决方案：[https://github.com/sixeyed/kiamol/blob/master/ch07/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch07/lab/README.md)。
