- en: 8 Modules and packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 模块和包
- en: Functional programming, which we explored in the previous chapter, is one of
    the knottiest topics you’ll encounter in the programming world. I’m happy to tell
    you that this chapter, about Python’s modules, will provide a stark contrast,
    and will be one of the easiest in this book. Modules are important, but they’re
    also very straightforward to create and use. So if you find yourself reading this
    chapter and thinking, “Hey, that’s pretty obvious,” well, that’s just fine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中我们探讨的函数式编程，是你在编程世界中会遇到的最复杂的话题之一。我很高兴告诉你，关于Python模块的这一章将提供鲜明的对比，并将是本书中最容易的一章。模块很重要，但它们也非常简单易创建和使用。所以如果你发现自己读着这一章，想着，“嘿，这很显然”，那也没关系。
- en: What are modules in Python, and how do they help us? I’ve already mentioned
    the acronym DRY, short for “Don’t repeat yourself,” several times in this book.
    As programmers, we aim to “DRY up” our code by taking identical sections of code
    and using them multiple times. Doing so makes it easier to understand, manage,
    and maintain our code. We can also more easily test such code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的模块是什么，它们是如何帮助我们的？我已经在这本书中多次提到DRY这个缩写，代表“不要重复自己”。作为程序员，我们通过将相同的代码段多次使用来“DRY”我们的代码。这样做使得代码更容易理解、管理和维护。我们还可以更容易地测试这样的代码。
- en: When we have repeated code in a single program, we can DRY it up by writing
    a function and then calling that function repeatedly. But what if we have repeated
    code that’s used across multiple programs? We can then create a library--or, as
    it’s known in the world of Python, a *module*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在单个程序中有重复的代码时，我们可以通过编写一个函数并反复调用该函数来“DRY”它。但如果我们有在多个程序中使用的重复代码怎么办？那时我们可以创建一个库——或者，在Python的世界里，它被称为*模块*。
- en: Modules actually accomplish two things in Python. First, they make it possible
    for us to reuse code across programs, helping us to improve the reusability and
    maintainability of our code. In this way, we can define functions and classes
    once, stick them into a module, and reuse them any number of times. This not only
    reduces the amount of work we need to do when implementing a new system, but also
    reduces our cognitive load, since we don’t have to worry about the implementation
    details.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 模块在Python中实际上完成了两件事。首先，它们使我们能够在程序之间重用代码，帮助我们提高代码的可重用性和可维护性。通过这种方式，我们可以定义函数和类一次，将它们放入模块中，然后多次重用。这不仅减少了实现新系统时需要做的工作量，还减少了我们的认知负荷，因为我们不必担心实现细节。
- en: For example, let’s say that your company has come up with a special pricing
    formula that combines the weather with stock-market indexes. You’ll want to use
    that pricing formula in many parts of your code. Rather than repeating the code,
    you could define the function once, put it into a module, and then use that module
    everywhere in your program that you want to calculate and display prices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设贵公司已经提出了一种特殊的定价公式，该公式结合了天气和股市指数。你希望在代码的许多部分使用这个定价公式。与其重复代码，你可以在一个地方定义函数，将其放入模块中，然后在程序中任何需要计算和显示价格的地方使用该模块。
- en: You can define any Python object--from simple data structures to functions to
    classes--in a module. The main question is whether you want it to be shared across
    multiple programs, now or in the future.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在模块中定义任何Python对象——从简单的数据结构到函数再到类。主要问题是你是否希望它在多个程序中共享，现在或将来。
- en: Second, modules are Python’s way of creating namespaces. If two people are collaborating
    on a software project, you don’t want to have to worry about collisions between
    their chosen variable and function names, right? Each file--that is, module--has
    its own namespace, ensuring that there can’t be conflicts between them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，模块是Python创建命名空间的方式。如果两个人正在合作一个软件项目，你不想担心他们选择的变量和函数名之间会发生冲突，对吧？每个文件——即模块——都有自己的命名空间，确保它们之间不会发生冲突。
- en: Python comes with a large number of modules, and even the smallest nontrivial
    Python program will use `import` ([http://mng.bz/xWme](http://mng.bz/xWme)), to
    use one or more of them. In addition to the *standard library*, as it’s known,
    Python programmers can take advantage of a large number of modules available on
    the Python Package Index ([https://pypi.org](https://pypi.org)). In this chapter,
    we’ll explore the use and creation of modules, including packages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了大量的模块，即使是简单的非平凡Python程序也会使用`import` ([http://mng.bz/xWme](http://mng.bz/xWme))来使用其中之一或多个。除了众所周知的*标准库*之外，Python程序员可以利用Python包索引([https://pypi.org](https://pypi.org))上提供的众多模块。在本章中，我们将探讨模块的使用和创建，包括包。
- en: '*Hint* If you visit PyPI at [https://pypi.org](https://pypi.org), you’ll discover
    that the number of community-contributed, third-party packages is astonishingly
    large. Just as of this writing, there are more than 200,000 packages on PyPI,
    many of which are buggy or unmaintained. How can you know which of these packages
    is worthwhile and which isn’t? The site “Awesome Python,” at [http://mng.bz/ AA0K](http://mng.bz/AA0K),
    is an attempt to remedy this situation, with edited lists of known stable, maintained
    packages on a variety of topics. This is a good first place to check for packages
    before going to PyPI. Although it doesn’t guarantee that the package you use will
    be excellent, it certainly improves the chances of this being the case.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示* 如果你访问PyPI([https://pypi.org](https://pypi.org))，你会发现社区贡献的第三方包数量令人惊讶。就在撰写本文时，PyPI上有超过200,000个包，其中许多存在错误或未维护。你如何知道这些包中哪些是值得的，哪些不是？位于[http://mng.bz/AA0K](http://mng.bz/AA0K)的“Awesome
    Python”网站试图解决这个问题，它提供了各种主题上已知稳定、维护良好的包的编辑列表。在前往PyPI之前，这是一个检查包的好地方。虽然它不能保证你使用的包将是优秀的，但它确实提高了这种情况发生的可能性。'
- en: Table 8.1 What you need to know
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 你需要知道的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| `import` | Statement for importing modules | `import os` | [http://mng.bz/xWme](http://mng.bz/xWme)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `import` | 导入模块的语句 | `import os` | [http://mng.bz/xWme](http://mng.bz/xWme)
    |'
- en: '| `from X import Y` | Imports module X, but only defines Y as a global variable
    | `from os import sep` | [http://mng.bz/xWme](http://mng.bz/xWme) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `from X import Y` | 导入模块X，但只定义Y为全局变量 | `from os import sep` | [http://mng.bz/xWme](http://mng.bz/xWme)
    |'
- en: '| `importlib.reload` | Re-imports an already loaded module, typically to update
    definitions during development | `importlib.reload(mymod)` | [http://mng.bz/Z2PO](http://mng.bz/Z2PO)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `importlib.reload` | 重新导入已加载的模块，通常用于开发期间更新定义 | `importlib.reload(mymod)`
    | [http://mng.bz/Z2PO](http://mng.bz/Z2PO) |'
- en: '| `pip` | Command-line program for installing packages from PyPI | `pip install
    packagename` | [https://pypi.org/](https://pypi.org/) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `pip` | 用于从PyPI安装包的命令行程序 | `pip install packagename` | [https://pypi.org/](https://pypi.org/)
    |'
- en: '| `Decimal` | Class that accurately handles floating-point numbers | `from
    decimal import Decimal` | [http://mng.bz/RAX0](http://mng.bz/RAX0) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `Decimal` | 准确处理浮点数的类 | `from decimal import Decimal` | [http://mng.bz/RAX0](http://mng.bz/RAX0)
    |'
- en: Importing modules
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模块
- en: One of the catchphrases in the Python world is “batteries included.” This refers
    to the many TV commercials I saw as a child that would spend their first 29.5
    seconds enticing us to buy their exciting, fun-looking, beautiful toys ... only
    to spend the final half second saying, “batteries not included”--meaning that
    it wasn’t enough to buy the product to enjoy it, we had to buy batteries as well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python世界中的一句流行语是“内置电池”。这指的是我小时候看到的许多电视广告，它们会用前29.5秒来吸引我们购买那些看起来令人兴奋、有趣、漂亮的玩具...然而在最后的半秒会说，“电池不包含”——这意味着仅仅购买产品还不够，我们还需要购买电池。
- en: “Batteries included” refers to the fact that when you download and install Python,
    you have everything you’re going to need to get your work done. This isn’t quite
    as true as used to be the case, and PyPI (the Python Package Index, described
    separately in this chapter) provides us with a huge collection of third-party
    Python modules that we can use to improve our products. But the fact remains that
    the *standard library*, meaning the stuff that comes with Python when we install
    it, includes a huge number of modules that we can use in our programs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: “内置电池”指的是当你下载并安装Python时，你将拥有完成工作所需的一切。这并不像以前那样完全正确，PyPI（Python包索引，在本章中单独描述）为我们提供了大量的第三方Python模块，我们可以使用这些模块来改进我们的产品。但事实仍然是，*标准库*，即我们安装Python时附带的内容，包括大量我们可以在程序中使用模块。
- en: The most commonly used things in the standard library, such as lists and dicts,
    are built into the language, thanks to a namespace known as `builtins`. You don’t
    need to worry about importing things in the `builtins` module, thanks to the LEGB
    rule that I discussed back in chapter 6\. But anything else in the standard library
    must be loaded into memory before it can be used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中最常用的东西，如列表和字典，都内置在语言中，这要归功于一个名为 `builtins` 的命名空间。由于第 6 章中讨论的 LEGB 规则，你不需要担心在
    `builtins` 模块中导入东西。但标准库中的任何其他东西在使用之前都必须加载到内存中。
- en: We load such a module using the `import` statement. The simplest version of
    `import` looks like
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `import` 语句来加载这样的模块。`import` 的最简单版本看起来像
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For example, if I want to use the `os` module, then I’ll write
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想使用 `os` 模块，那么我会写
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice a couple of things about this statement:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个语句的几个方面：
- en: First, it’s not a function; you don’t say `import(os)`, but rather `import`
    `os`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它不是一个函数；你不会说 `import(os)`，而是 `import` `os`。
- en: Second, we don’t import a filename. Rather, we indicate the variable that we
    want to define, rather than the file that should be loaded from the disk. So don’t
    try to `import` `"os"` or even `import` `"os.py"`. Just as `def` defines a new
    variable that references a function, so too `import` defines a new variable that
    references a module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们不是导入一个文件名。相反，我们指出我们想要定义的变量，而不是从磁盘加载的文件。所以不要尝试 `import` `"os"` 或甚至 `import`
    `"os.py"`。就像 `def` 定义一个引用函数的新变量一样，`import` 也定义一个引用模块的新变量。
- en: When you `import` `os`, Python tries to find a file that matches the variable
    name you’re defining. It’ll typically look for `os.py` and `os.pyc`, where the
    former is the original source code and the latter is the byte-compiled version.
    (Python uses the filesystem’s timestamp to figure out which one is newer and creates
    a new byte-compiled version as necessary. So don’t worry about compiling!)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你 `import` `os` 时，Python 会尝试找到一个与你要定义的变量名称匹配的文件。它通常会查找 `os.py` 和 `os.pyc`，前者是原始源代码，后者是字节编译版本。（Python
    使用文件系统的最后修改时间来确定哪个是最新的，并在需要时创建新的字节编译版本。所以，不要担心编译！）
- en: Python looks for matching files in a number of directories, visible to you in
    `sys.path`. This is a list of strings representing directories; Python will iterate
    over each directory name until it finds a matching module name. If more than one
    directory contains a module with the same name, then the first one Python encounters
    is loaded, and any subsequent modules will be completely ignored. This can often
    lead to confusion and conflicts, in my experience, so try to choose unusual and
    distinct names for your modules.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在多个目录中查找匹配的文件，这些目录在 `sys.path` 中可见。这是一个表示目录的字符串列表；Python 会遍历每个目录名称，直到找到匹配的模块名称。如果多个目录包含具有相同名称的模块，那么
    Python 遇到的第一个将被加载，任何后续的模块都将被完全忽略。根据我的经验，这通常会导致混淆和冲突，所以尽量为你的模块选择不寻常且独特的名称。
- en: 'Now, `import` has a number of variations that are useful to know, and that
    you’ll probably see in existing code--as well as use in your own code. That said,
    the ultimate goal is the same: load a module, and define one or more module-related
    names in your namespace.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`import` 有许多变化，这些变化值得了解，你可能会在现有的代码中看到它们——以及在你自己的代码中使用。话虽如此，最终目标是一致的：加载一个模块，并在你的命名空间中定义一个或多个与模块相关的名称。
- en: If you’re happy loading a module and using its name as a variable, then `import`
    `MODULENAME` is a great way to go. But sometimes, that name is too long. For that
    reason, you’ll want to give the module name an alias. You can do that with
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对加载一个模块并使用其名称作为变量感到满意，那么 `import` `MODULENAME` 是一个很好的选择。但有时，这个名称太长了。因此，你想要给模块名称一个别名。你可以用以下方式做到这一点：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you use `as`, the name `mymod` will **not** be defined. However, the name
    `mm` will be defined. This is silly and unnecessary if your module name is going
    to be short. But if the name is long, or you’re going to be referring to it a
    lot, then you might well want to give it a shorter alias. A classic example is
    NumPy ([https://numpy.org/](https://numpy.org/)), which sits at the core of all
    of Python’s scientific and numeric computing systems, including data science and
    machine learning. That module is typically imported with an alias of `np`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `as` 时，名称 `mymod` 将**不会**被定义。然而，名称 `mm` 将会被定义。如果你的模块名称将要很短，这将是愚蠢且不必要的。但如果名称很长，或者你将频繁地引用它，那么你可能确实想要给它一个更短的别名。一个经典的例子是
    NumPy ([https://numpy.org/](https://numpy.org/))，它是所有 Python 的科学和数值计算系统的核心，包括数据科学和机器学习。该模块通常使用别名
    `np` 导入：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once you’ve imported a module, all of the names that were defined in the file’s
    global scope are available as attributes, via the module object. For example,
    the `os` module defines `sep`, which indicates what string separates elements
    of a directory path. You can access that value as `os.sep`. But if you’re going
    to use it a lot, then it’s a bit of a pain to constantly say `os.sep`. Wouldn’t
    it be nice to just call it `sep`? You can’t do that, of course, because the name
    `sep` would be a variable, whereas `os.sep` is an attribute.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入了一个模块，文件全局作用域中定义的所有名称都可通过模块对象作为属性使用。例如，`os` 模块定义了 `sep`，它表示用于分隔目录路径元素的字符串。你可以通过
    `os.sep` 访问该值。但是，如果你要经常使用它，那么不断地说 `os.sep` 就有点麻烦了。难道不希望直接叫它 `sep` 吗？当然，你不能这样做，因为
    `sep` 这个名称将是一个变量，而 `os.sep` 是一个属性。
- en: 'However, you can bridge the gap and get the attribute loaded by using the following
    syntax:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用以下语法来桥接差距并获取由属性加载的属性：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that this **won’t** define the `os` variable, but it will define the `sep`
    variable. You can use `from` `..` `import` on more than one variable too:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这**不会**定义 `os` 变量，但它将定义 `sep` 变量。你还可以在多个变量上使用 `from .. import`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, both `sep` and `path` will be defined as variables in your global scope.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`sep` 和 `path` 都将在你的全局作用域中定义为变量。
- en: 'Worried about one of these imported attributes clashing with an existing variable,
    method, or module name? Then you can use `from` `..` `import` `..` `as`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 担心这些导入的属性与现有的变量、方法或模块名称冲突？那么你可以使用 `from .. import .. as`：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There’s a final version that I often see, and that I generally advise people
    **not** to use. It looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到的一个最终版本，并且通常建议人们**不要**使用。它看起来像这样：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will load the `os` module into memory, but (more importantly) will take
    all of the attributes from `os` and define them as global variables in the current
    namespace. Given that we generally want to avoid global variables unless necessary,
    I see it as a problem when we allow the module to decide what variables should
    be defined.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 `os` 模块加载到内存中，但（更重要的是）将 `os` 的所有属性定义为当前命名空间中的全局变量。鉴于我们通常只有在必要时才希望避免全局变量，因此当允许模块决定应该定义哪些变量时，我认为这是一个问题。
- en: '*Note* Not *all* names from a module will be imported with `import` `*`. Names
    starting with `_` (underscore) will be ignored. Moreover, if the module defines
    a list of strings named `__all__`, only names specified in the module will be
    loaded with `import` `*`. However, `from` `X` `import` `Y` will always work, regardless
    of whether `__all__` is defined.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 并非模块中的所有名称都会通过 `import *` 被导入。以 `_`（下划线）开头的名称将被忽略。此外，如果模块定义了一个名为 `__all__`
    的字符串列表，则只有模块中指定的名称将通过 `import *` 被加载。然而，`from X import Y` 总是会工作，无论是否定义了 `__all__`。'
- en: At the end of the day, `import` makes functions, classes, and data available
    to you in your current namespace. Given the huge number of modules available,
    both in Python’s standard library and on PyPI, that puts a lot of potential power
    at your fingertips--and explains why so many Python programs start with several
    lines of `import` statements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`import` 使函数、类和数据在你的当前命名空间中可用。鉴于 Python 的标准库和 PyPI 上可用的模块数量巨大，这使你手头上的潜在力量很大——这也解释了为什么许多
    Python 程序都以几行 `import` 语句开始。
- en: Exercise 36 ■ Sales tax
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 36 ■ 销售税
- en: Modules allow us to concentrate on higher-level thinking and avoid digging into
    the implementation details of complex functionality. We can thus implement a function
    once, stick it into a module, and use it many times to implement algorithms that
    we don’t want to think about on a day-to-day basis. If you had to actually understand
    and wade through the calculations involved in internet security, for example,
    just to create a web application, you would never finish.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 模块使我们能够专注于更高层次的思考，并避免深入研究复杂功能的实现细节。因此，我们可以将函数实现一次，将其放入模块中，然后多次使用它来实现我们不想在日常基础上思考的算法。例如，如果你必须真正理解和处理创建网络应用程序所需的互联网安全相关的计算，你将永远无法完成。
- en: In this exercise, you’ll implement a somewhat complex (and whimsical) function,
    in a module, to implement tax policy in the Republic of Freedonia. The idea is
    that the tax system is so complex that the government will supply businesses with
    a Python module implementing the calculations for them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将在一个模块中实现一个相对复杂（且富有创意）的函数，以在自由共和国实施税收政策。想法是税收系统如此复杂，以至于政府将向企业提供实现这些计算的
    Python 模块。
- en: 'Sales tax on purchases in Freedonia depends on where the purchase was made,
    as well as the time of the purchase. Freedonia has four provinces, each of which
    charges its own percentage of tax:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Freedonia的商品销售税取决于购买地点以及购买时间。Freedonia有四个省份，每个省份都对其商品征收自己的税率：
- en: 'Chico: 50%'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Chico: 50%'
- en: 'Groucho: 70%'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Groucho: 70%'
- en: 'Harpo: 50%'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Harpo: 50%'
- en: 'Zeppo: 40%'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Zeppo: 40%'
- en: Yes, the taxes are quite high in Freedonia (so high, in fact, that they’re said
    to have a Marxist government). However, these taxes rarely apply in full. That’s
    because the amount of tax applied depends on the hour at which the purchase takes
    place. The tax percentage is always multiplied by the hour at which the purchase
    was made. At midnight (i.e., when the 24-hour clock is 0), there’s no sales tax.
    From 12 noon until 1 p.m., only 50% (12/24) of the tax applies. And from 11 p.m.
    until midnight, 95.8% (i.e., 23/24) of the tax applies.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Freedonia的税收相当高（实际上，据说他们有一个马克思主义政府）。然而，这些税收很少全额适用。这是因为税额的多少取决于购买发生的时间。税率总是乘以购买发生的小时。午夜（即24小时制的0点）没有销售税。从中午12点到下午1点，只有50%（12/24）的税额适用。而从晚上11点到午夜，95.8%（即23/24）的税额适用。
- en: 'Your job is to implement that Python module, `freedonia.py`. It should provide
    a function, `calculate_tax`, that takes three arguments: the amount of the purchase,
    the province in which the purchase took place, and the hour (an integer, from
    0-24) at which it happened. The `calculate_tax` function should return the final
    price, as a float.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是实现这个Python模块，`freedonia.py`。它应该提供一个名为`calculate_tax`的函数，该函数接受三个参数：购买金额、购买发生的省份以及购买发生的小时（一个整数，从0到24）。`calculate_tax`函数应返回最终价格，作为浮点数。
- en: Thus, if I were to invoke
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我要调用
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: a $500 purchase in Harpo province (with 50%) tax would normally be $750\. However,
    because the purchase was done at 12 noon, the tax is only half of its maximum,
    or $125, for a total of $625\. If the purchase were made at 9 p.m. (i.e, 21:00
    on a 24-hour clock), then the tax would be 87.5% of its full rate, or 43.75%,
    for a total price of $718.75.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Harpo省（含50%的税）购买500美元的商品，通常会是750美元。然而，由于购买是在中午12点进行的，因此税额仅为最大税额的一半，即125美元，总价为625美元。如果购买是在晚上9点（即24小时制的21:00）进行，那么税额将是全额的87.5%，或43.75%，总价为718.75美元。
- en: Moreover, I want you to write this solution using two separate files. The `calculate`
    `_tax` function, as well as any supporting data and functions, should reside in
    the file `freedonia.py`, a Python module. The program that calls `calculate_tax`
    should be in a file called `use_freedonia.py`, which then uses `import` to load
    the function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我希望你使用两个独立的文件来编写这个解决方案。`calculate_tax`函数以及任何支持数据和函数应位于名为`freedonia.py`的Python模块文件中。调用`calculate_tax`的程序应在一个名为`use_freedonia.py`的文件中，然后使用`import`导入该函数。
- en: Working it out
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算过程
- en: The `freedonia` module does precisely what a Python module should do. Namely,
    it defines data structures and functions that provide functionality to one or
    more other programs. By providing this layer of abstraction, it allows a programmer
    to focus on what’s important to them, such as the implementation of an online
    store, without having to worry about the nitty-gritty of particular details.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`freedonia`模块正好做了Python模块应该做的事情。也就是说，它定义了数据结构和函数，为一个或多个其他程序提供功能。通过提供这一层抽象，它允许程序员专注于对他们来说重要的事情，例如在线商店的实现，而无需担心特定细节的繁琐。'
- en: While some countries have extremely simple systems for calculating sales tax,
    others--such as the United States--have many overlapping jurisdictions, each of
    which applies its own sales tax, often at different rates and on different types
    of goods. Thus, while the Freedonia example is somewhat contrived, it’s not unusual
    to purchase or use libraries to calculate taxes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些国家有非常简单的销售税计算系统，但其他国家——例如美国——有许多重叠的司法管辖区，每个司法管辖区都适用自己的销售税，税率不同，商品类型也不同。因此，虽然Freedonia的例子有些牵强，但购买或使用库来计算税收并不罕见。
- en: Our module defines a dict (`RATES`), in which the keys are the provinces of
    Freedonia, and the values are the taxation rates that should be applied there.
    Thus, we can find out the rate of taxation in Groucho province with `RATES['Groucho']`.
    Or we can ask the user to enter a province name in the `province` variable, and
    then get `RATES[province]`. Either way, that will give us a floating-point number
    that we can use to calculate the tax.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模块定义了一个字典（`RATES`），其中键是弗里多尼亚的省份，值是应该在那里应用的税率。因此，我们可以通过`RATES['Groucho']`找到格鲁乔省的税率。或者我们可以让用户在`province`变量中输入省份名称，然后获取`RATES[province]`。无论哪种方式，这都会给我们一个可以用来计算税的浮点数。
- en: A wrinkle in the calculation of Freedonian taxation is the fact that taxes get
    progressively higher as the day goes on. To make this calculation easier, I wrote
    a `time_percentage` function, which simply takes the hour and returns it as a
    percentage of 24 hours.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 弗里多尼亚税收计算中的一个问题是，随着时间的推移，税率会逐渐提高。为了使这个计算更容易，我编写了一个`time_percentage`函数，它简单地接受小时数并返回它作为24小时的百分比。
- en: '*Note* In Python 2, integer division always returns an integer, even when that
    means throwing away the remainder. If you’re using Python 2, be sure to divide
    the current hour not by `24` (an int) but by `24.0` (a float).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 在Python 2中，整数除法始终返回一个整数，即使这意味着丢弃余数。如果你使用Python 2，请确保不要将当前小时除以`24`（一个整数），而是除以`24.0`（一个浮点数）。'
- en: Finally, the `calculate_tax` function takes three parameters--the amount of
    the sale, the name of the province in which the sale took place, and the hour
    at which the sale happened--and returns a floating-point number indicating the
    actual, current tax rate.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`calculate_tax`函数接受三个参数——销售额，销售发生的省份名称，以及销售发生的小时数——并返回一个表示实际、当前税率的浮点数。
- en: The Decimal version
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decimal`版本'
- en: If you’re actually doing calculations involving serious money, you should almost
    certainly **not** be using floats. Rather, you should use integers or the `Decimal`
    class, both of which are more accurate. (See chapter 1 for some more information
    on the inaccuracy of floats.) I wanted this exercise to concentrate on the creation
    of a module, and not the use of the `Decimal` class, so I didn’t require it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实际上在进行涉及大量金钱的计算，你几乎**不应该**使用浮点数。相反，你应该使用整数或`Decimal`类，这两个都更准确。（参见第1章了解更多关于浮点数不准确的信息。）我想这个练习应该专注于创建一个模块，而不是使用`Decimal`类，所以我并没有要求它。
- en: 'Here’s how my solution would look using `Decimal`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我的解决方案使用`Decimal`的样子：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that this code uses `Decimal` on strings, rather than floats, to ensure
    maximum accuracy. We then return a floating-point number at the last possible
    moment. Also note that any `Decimal` value multiplied or divided by a number remains
    a `Decimal`, so we only need to make a conversion at the end.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码在字符串上使用`Decimal`，而不是浮点数，以确保最大精度。然后我们在最后可能的时刻返回一个浮点数。还要注意，任何乘以或除以数字的`Decimal`值仍然是一个`Decimal`，所以我们只需要在最后进行转换。
- en: 'Here’s a program that uses our `freedonia` module:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用我们`freedonia`模块的程序：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Error checking the Pythonic way
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以Pythonic的方式检查错误
- en: Since a module will be used by many other programs, it’s important for it to
    not only be accurate, but also have decent error checking. In our particular case,
    for example, we would want to check that the hour is between 0 and 24.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个模块将被许多其他程序使用，因此它不仅需要准确，还需要有良好的错误检查。在我们的特定情况下，例如，我们希望检查小时数是否在0到24之间。
- en: Right now, someone who passes an invalid hour to our function will still get
    an answer, albeit a nonsensical one. A better solution would be to have the function
    raise an exception if the input is invalid. And while we could raise a built-in
    Python exception (e.g., `ValueError`), it’s generally a better idea to create
    your own exception class and raise it; for example
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果有人向我们的函数传递无效的小时数，我们仍然会得到一个答案，尽管这个答案是荒谬的。更好的解决方案是，如果输入无效，函数应该抛出一个异常。虽然我们可以抛出一个内置的Python异常（例如`ValueError`），但通常创建自己的异常类并抛出它是一个更好的主意；例如
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding such exceptions to your code is considered very Pythonic and helps to
    ensure that anyone using your module will not accidentally get a bad result.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将这样的异常添加到你的代码中被认为是Pythonic的，并且有助于确保任何使用你的模块的人都不会意外地得到一个错误的结果。
- en: Solution
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ This means we’ll get 0% at midnight and just under 100% at 23:59.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这意味着我们在午夜将得到0%，在23:59将接近100%。
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    oP1j](http://mng.bz/oP1j).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中找到一个版本的这段代码，网址是[http://mng.bz/ oP1j](http://mng.bz/oP1j)。
- en: Note that the Python Tutor site doesn’t support modules, so this solution was
    placed in a single file, without the use of `import`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python Tutor网站不支持模块，因此这个解决方案被放置在一个单独的文件中，没有使用`import`。
- en: Screencast solution
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'Now that you’ve written a simple function that masks more complex functionality,
    here are some other functions you can write as modules:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了一个简单的函数来掩盖更复杂的功能，这里有一些其他你可以作为模块编写的函数：
- en: Income tax in many countries is not a flat percentage, but rather the combination
    of different “brackets.” So a country might not tax you on your first $1,000 of
    income, and then 10% on the next $10,000, and then 20% on the next $10,000, and
    then 50% on anything above that. Write a function that takes someone’s income
    and returns the amount of tax they will have to pay, totaling the percentages
    from various brackets.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多国家的所得税不是固定的百分比，而是不同“档次”的组合。因此，一个国家可能不会对你前$1,000的收入征税，然后对下一个$10,000的收入征税10%，然后对下一个$10,000的收入征税20%，然后对超过那个数额的收入征税50%。编写一个函数，该函数接受某人的收入并返回他们需要支付的税款总额，包括各个档次的百分比。
- en: 'Write a module providing a function that, given a string, returns a dict indicating
    how many characters provide a `True` result to each of the following functions:
    `str.isdigit`, `str.isalpha`, and `str.isspace`. The keys should be `isdigit`,
    `isalpha`, and `isspace`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个模块，该模块提供一个函数，给定一个字符串，返回一个字典，指示有多少个字符对以下函数返回`True`：`str.isdigit`、`str.isalpha`和`str.isspace`。键应该是`isdigit`、`isalpha`和`isspace`。
- en: The `dict.fromkeys` method ([http://mng.bz/1zrV](http://mng.bz/1zrV)) makes
    it easy to create a new dict. For example, `dict.fromkeys('abc')` will create
    the dict `{'a':None,` `'b':None,` `'c':None}`. You can also pass a value that
    will be assigned to each key, as in `dict.fromkeys('abc',` `5)`, resulting in
    the dict `{'a':5,` `'b':5,` `'c':5}`. Implement a function that does the same
    thing as `dict.keys` but whose second argument is a function. The value associated
    with the key will be the result of invoking `f(key)`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict.fromkeys`方法([http://mng.bz/1zrV](http://mng.bz/1zrV))使得创建新字典变得容易。例如，`dict.fromkeys(''abc'')`将创建字典`{''a'':None,
    ''b'':None, ''c'':None}`。你还可以传递一个值，该值将被分配给每个键，例如`dict.fromkeys(''abc'', 5)`，这将创建字典`{''a'':5,
    ''b'':5, ''c'':5}`。实现一个函数，该函数与`dict.keys`的功能相同，但其第二个参数是一个函数。与键关联的值将是调用`f(key)`的结果。'
- en: Loading and reloading modules
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和重新加载模块
- en: When you use `import` to load a module, what happens? For example, if you say
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`import`来加载模块时，会发生什么？例如，如果你说
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: then Python looks for `mymod.py` in a number of directories, defined in a list
    of strings called `sys.path`. If Python encounters a file in one of those directories,
    it loads the file and stops searching in any other directories.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Python会在一系列目录中查找`mymod.py`，这些目录定义在名为`sys.path`的字符串列表中。如果Python在那些目录中的一个目录中遇到文件，它将加载该文件并停止在其他目录中搜索。
- en: '*Note* There are a number of ways to modify `sys.path`, including by setting
    the environment variable `PYTHONPATH` and creating files with a `.pth` suffix
    in your Python installation’s `site-packages` directory. For more information
    on setting `sys.path`, see the Python documentation, or read this helpful article:
    [http://mng.bz/PAP9](http://mng.bz/PAP9).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 有多种修改`sys.path`的方法，包括通过设置环境变量`PYTHONPATH`以及在Python安装的`site-packages`目录中创建具有`.pth`后缀的文件。有关设置`sys.path`的更多信息，请参阅Python文档，或阅读这篇有用的文章：[http://mng.bz/PAP9](http://mng.bz/PAP9)。'
- en: 'This means `import` normally does two distinct things: it loads the module
    and defines a new variable. But what happens if your program loads two modules,
    each of which in turn loads modules? For example, let’s say that your program
    imports both `pandas` and `scipy`, both of which load the `numpy` module. In such
    a case, Python will load the module the first time, but only define the variable
    the second time. `import` only loads a module once, but it will always define
    the variable that you’ve asked it to create.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`import`通常执行两个不同的操作：加载模块并定义一个新变量。但如果你的程序加载了两个模块，每个模块又依次加载其他模块，会发生什么？例如，假设你的程序导入了`pandas`和`scipy`，这两个模块都加载了`numpy`模块。在这种情况下，Python将第一次加载模块，但只在第二次定义变量。`import`只加载模块一次，但它总是会定义你要求它创建的变量。
- en: This is done via a dict defined in `sys` called `sys.modules`. Its keys are
    the names of modules that have been loaded, and its values are the actual module
    objects. Thus, when we say `import` `mymod`, Python first checks to see if `mymod`
    is in `sys.modules`. If so, then it doesn’t search for or load the module. Rather,
    it just defines the name.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过在`sys`模块中定义的字典`sys.modules`完成的。其键是已加载的模块的名称，其值是实际的模块对象。因此，当我们说`import mymod`时，Python首先检查`mymod`是否在`sys.modules`中。如果是，那么它不会搜索或加载该模块。相反，它只是定义了该名称。
- en: This is normally a great thing, in that there’s no reason to reload a module
    once the program has started running. But when you’re debugging a module within
    an interactive Python session, you want to be able to reload it repeatedly, preferably
    without exiting from the current Python session.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一件好事，因为一旦程序开始运行，就没有理由重新加载一个模块。但是，当你在一个交互式Python会话中调试一个模块时，你希望能够反复重新加载它，最好是无需退出当前的Python会话。
- en: In such cases, you can use the `reload` function defined in the `importlib`
    module. It takes a module object as an argument, so the module must already have
    been defined and imported. And it’s the sort of thing that you’ll likely use all
    the time in development, and almost never in actual production.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以使用`importlib`模块中定义的`reload`函数。它接受一个模块对象作为参数，因此该模块必须已经定义并导入。这通常是你在开发中会经常使用，而在实际生产中几乎不会使用的事情。
- en: '*Note* In previous versions of Python, `reload` was a built-in function. As
    of Python 3, it’s in the `importlib` module, which you must import to use it.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 在Python的先前版本中，`reload`是一个内置函数。从Python 3开始，它位于`importlib`模块中，你必须导入它才能使用。'
- en: Exercise 37 ■ Menu
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习37 ■ 菜单
- en: If you find yourself writing the same function multiple times across different
    programs or projects, you almost certainly want to turn that function into a module.
    In this exercise, you’re going to write a function that’s generic enough to be
    used in a wide variety of programs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在不同程序或项目中多次编写相同的函数，你几乎肯定希望将该函数转换为一个模块。在这个练习中，你将编写一个足够通用的函数，可以在各种程序中使用。
- en: Specifically, write a new module called “menu” (in the file `menu.py`). The
    module should define a function, also called `menu`. The function takes any number
    of key-value pairs as arguments. Each value should be a *callable,* a fancy name
    for a function or class in Python.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，编写一个新的名为“menu”的模块（在文件`menu.py`中）。该模块应定义一个名为`menu`的函数。该函数接受任意数量的键值对作为参数。每个值应该是一个*可调用对象*，在Python中是函数或类的别称。
- en: When the function is invoked, the user is asked to enter some input. If the
    user enters a string that matches one of the keyword arguments, the function associated
    with that keyword will be invoked, and its return value will be returned to `menu`’s
    caller. If the user enters a string that’s **not** one of the keyword arguments,
    they’ll be given an error message and asked to try again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，用户会被要求输入一些输入。如果用户输入的字符串与关键字参数之一匹配，则将与该关键字关联的函数将被调用，并且其返回值将被返回给`menu`的调用者。如果用户输入的字符串不是关键字参数之一，他们将会收到错误消息并被要求重试。
- en: 'The idea is that you’ll be able to define several functions, and then indicate
    what user input will trigger each function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是你可以定义几个函数，然后指明哪些用户输入将触发每个函数：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, `return_value` will contain `A` if the user chooses `a`, or
    `B` if the user chooses `b`. If the user enters any other string, they’re told
    to try again. And then we’ll print the user’s choice, just to confirm things.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果用户选择`a`，`return_value`将包含`A`；如果用户选择`b`，则包含`B`。如果用户输入任何其他字符串，系统会提示他们重试。然后我们会打印用户的选项，以确认一切。
- en: Working it out
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: The solution presented here is another example of a *dispatch table*, which
    we saw earlier in the book, in the “prefix calculator” exercise. This time, we’re
    using the `**kwargs` parameter to create that dispatch table dynamically, rather
    than with a hard-coded dict.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供的解决方案是另一种*分发表*的例子，我们在本书前面的“前缀计算器”练习中见过。这次，我们使用`**kwargs`参数动态创建分发表，而不是使用硬编码的字典。
- en: In this case, whoever invokes the `menu` function will provide the keywords--which
    function as menu options--and the functions that will be invoked. Note that these
    functions all take zero arguments, although you can imagine a scenario in which
    the user could provide more inputs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，调用`menu`函数的人将提供关键字——它们作为菜单选项——以及将被调用的函数。请注意，这些函数都不接受任何参数，尽管你可以想象一个用户可以提供更多输入的场景。
- en: We use `**` here, which we previously saw in the XML-creation exercise. We could
    have instead received a dict as a single argument, but this seems like an easier
    way for us to create the dict, using Python’s built-in API for turning `**kwargs`
    into a dict.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`**`，我们之前在XML创建练习中见过。我们本可以只接收一个作为单个参数的字典，但这似乎是我们使用Python内置API将`**kwargs`转换为字典的更简单方式。
- en: While I didn’t ask you to do so, my solution presents the user with a list of
    the valid menu items. I do this by invoking `str.join` on the dict, which has
    the effect of creating a string from the keys, with `/` characters between them.
    I also decided to use `sorted` to present them in alphabetical order.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我没有要求你这样做，但我的解决方案向用户展示了一个有效的菜单项列表。我是通过在字典上调用`str.join`来做到这一点的，它将键转换为字符串，并在它们之间插入“/”字符。我还决定使用`sorted`来按字母顺序展示它们。
- en: With this in place, we can now ask the user for input from any zero-argument
    function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们现在可以从任何零参数函数中请求用户输入。
- en: Why do we check `__name__`?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要检查`__name__`？
- en: 'One of the most famous lines in all of Python reads as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python中最著名的一行代码如下所示：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What does this line do? How does it help? This line is the result of a couple
    different things happening when we load a module:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码做什么？它如何帮助？这行代码是当我们加载模块时发生几件事情的结果：
- en: First, when a module is loaded, its code is executed from the start of the file
    until the end. You’re not just defining things; any code in the file is actually
    executed. That means you can (in theory) invoke `print` or have `for` loops. In
    this case, we’re using `if` to make some code execute conditionally when it’s
    loaded.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，当模块被加载时，其代码从文件开始执行到文件末尾。你不仅仅是定义东西；文件中的任何代码实际上都会被执行。这意味着你（理论上）可以调用`print`或拥有`for`循环。在这种情况下，我们使用`if`来在加载时条件性地执行一些代码。
- en: Second, the `__name__` variable is either defined to be `__main__`, meaning
    that things are currently running in the initial, default, and top-level namespace
    provided by Python, **or** it’s defined to be the name of the current module.
    The `if` statement here is thus checking to see if the module was run directly,
    or if it was imported by another piece of Python code.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，`__name__`变量被定义为`__main__`，这意味着当前事物正在运行在Python提供的初始、默认和顶级命名空间中，**或者**它被定义为当前模块的名称。因此，这里的`if`语句是用来检查模块是否是直接运行的，或者是否被其他Python代码导入。
- en: In other words, the line of code says, “Only execute the below code (i.e., inside
    of the `if` statement) if this is the top-level program being executed. Ignore
    the stuff in the `if` when we `import` this module.”
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这一行代码的意思是：“只有当这是正在执行的顶级程序时，才执行下面的代码（即`if`语句内部）。当我们导入这个模块时，忽略`if`中的内容。”
- en: 'You can use this code in a few different ways:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用几种不同的方式使用这段代码：
- en: Many modules run their own tests when invoked directly, rather than imported.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多模块在直接调用时运行自己的测试，而不是导入。
- en: Some modules can be run interactively, providing user-facing functionality and
    an interface. This code allows that to happen, without interfering with any function
    definitions.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些模块可以交互式运行，提供面向用户的功能和接口。这段代码允许这样做，而不会干扰任何函数定义。
- en: In some odd cases, such as the `multiprocessing` module in Windows, the code
    allows you to differentiate between versions of the program that are being loaded
    and executed in separate processes.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些奇怪的情况下，例如Windows中的`multiprocessing`模块，代码允许你区分在单独进程中加载和执行的不同版本的程序。
- en: While you can theoretically have as many `if` `__name__` `==` `'__main__'` lines
    in your code as you want, it’s typical for this line to appear only once, at the
    end of your module file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然理论上你可以在代码中放置任意多的`if` `__name__` `==` `'__main__'`行，但通常只有一行，位于模块文件末尾。
- en: You’ll undoubtedly encounter this code, and might even have written it yourself
    in the past. And now you know how it works!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你无疑会遇到这段代码，甚至可能在过去自己编写过它。现在你知道它是如何工作的了！
- en: Solution
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ “options” is a dict populated by the keyword arguments.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ “options”是一个通过关键字参数填充的字典。
- en: ❷ An infinite loop, which we’ll break out of when the user gives valid input
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个无限循环，当用户输入有效输入时我们将跳出循环
- en: ❸ Creates a string of sorted options, separated by “/”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个由“/”分隔的排序后的选项字符串
- en: ❹ Asks the user to enter an option
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 询问用户输入一个选项
- en: ❺ Has the user entered a key from “**options”?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 用户是否输入了“**options”**中的键？
- en: ❻ If so, then return the result of executing the function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果是这样，那么返回函数的执行结果。
- en: ❼ Otherwise, scold the user and have them try again.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 否则，责备用户并让他们再试一次。
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    nPW8](http://mng.bz/nPW8).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中尝试这个代码的版本：[http://mng.bz/nPW8](http://mng.bz/nPW8)。
- en: Note that the Python Tutor site doesn’t support modules, so this solution was
    placed in a single file, without the use of `import`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python Tutor 网站不支持模块，因此这个解决方案被放置在一个单独的文件中，没有使用 `import`。
- en: Screencast solution
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Now that you’ve written and used two different Python modules, let’s go beyond
    that and experiment with some more advanced techniques and problems:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写并使用了两个不同的 Python 模块，让我们超越这个范围，尝试一些更高级的技术和问题：
- en: Write a version of `menu.py` that can be imported (as in the exercise), but
    that when you invoke the file as a stand-alone program from the command line,
    tests the function. If you aren’t familiar with testing software such as `pytest`,
    you can just run the program and check the output.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 `menu.py` 的版本，它可以被导入（就像练习中那样），但当你从命令行作为一个独立程序调用文件时，会测试该函数。如果你不熟悉 `pytest`
    等测试软件，你只需运行程序并检查输出。
- en: Turn `menu.py` into a Python package and upload it to PyPI. (I suggest using
    your name or initials, followed by “menu,” to avoid name collisions.) See the
    sidebar on the difference between modules and packages, and how you can participate
    in the PyPI ecosystem with your own open-source projects.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `menu.py` 转换为 Python 包并上传到 PyPI。（我建议使用你的名字或首字母，后跟 “menu”，以避免名称冲突。）参见关于模块和包的区别的侧边栏，以及你如何通过自己的开源项目参与
    PyPI 生态系统。
- en: Define a module `stuff` with three variables--`a`, `b`, and `c`--and two functions--`foo`
    and `bar`. Define `__all__` such that `from` `stuff` `import` `*` will cause `a`,
    `c`, and `bar` to be imported, but not `b` and `foo`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个名为 `stuff` 的模块，包含三个变量——`a`、`b` 和 `c`——以及两个函数——`foo` 和 `bar`。定义 `__all__`，使得
    `from stuff import *` 会导入 `a`、`c` 和 `bar`，但不会导入 `b` 和 `foo`。
- en: Modules vs. packages
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 模块与包
- en: This chapter is all about modules--how to create, import, and use them. But
    you might have noticed that we often use another term, *package*, to discuss Python
    code. What’s the difference between a module and a package?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这章全部关于模块——如何创建、导入和使用它们。但你可能已经注意到，我们经常使用另一个术语，*包*，来讨论 Python 代码。模块和包之间有什么区别？
- en: A module is a single file, with a “.py” suffix. We can load the module using
    `import`, as we’ve seen. But what if your project is large enough that it would
    make more sense to have several separate files? How can you distribute those files
    together?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一个单独的文件，带有 “.py” 后缀。我们可以使用 `import` 来加载模块，就像我们看到的。但如果你的项目足够大，使用几个单独的文件可能更有意义，你该如何将这些文件一起分发呢？
- en: The answer is a package, which basically means a directory containing one or
    more Python modules. For example, assume you have the modules `first.py`, `second.py`,
    and `third.py`, and want to keep them together. You can put them all into a directory,
    `mypackage`. Assuming that directory is in `sys.path`, you can then say
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是一个包，这基本上意味着一个包含一个或多个 Python 模块的目录。例如，假设你有 `first.py`、`second.py` 和 `third.py`
    这几个模块，并希望将它们放在一起。你可以将它们全部放入一个名为 `mypackage` 的目录中。假设这个目录在 `sys.path` 中，然后你可以这样写
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Python will go into the `mypackage` directory, look for `first.py`, and import
    it. You can then access all of its attributes via `first.x`, `first.y`, and so
    forth.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会进入 `mypackage` 目录，寻找 `first.py`，并导入它。然后你可以通过 `first.x`、`first.y` 等方式访问它的所有属性。
- en: Alternatively, you could say
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以说
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, Python will still load the module `first`, but it’ll be available
    in your program via the long name, `mypackage.first`. You can then use `mypackage.first.x`
    and `mypackage.first.y`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Python 仍然会首先加载模块 `first`，但它将通过长名称 `mypackage.first` 在你的程序中可用。然后你可以使用
    `mypackage.first.x` 和 `mypackage.first.y`。
- en: Alternatively, you could say
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以说
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But this will only be useful if, in the mypackage directory, you have a file
    named `__init__.py`. In such a case, importing `mypackage` effectively means that
    `__init__.py` is loaded, and thus executed. You can, inside of that file, import
    one or more of the modules within the package.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只有在 `mypackage` 目录中有一个名为 `__init__.py` 的文件时才有效。在这种情况下，导入 `mypackage` 实际上意味着加载并执行了
    `__init__.py`。你可以在该文件中导入包内的一个或多个模块。
- en: What about if you want to distribute your package to others? Then you’ll have
    to create a package. If this sounds strange, that you need a package to distribute
    your package, that’s because the same term, *package*, is used for two different
    concepts. A *PyPI package*, or *distribution package*, is a wrapper around a Python
    package containing information about the author, compatible versions, and licensing,
    as well as automated tests, dependencies, and installation instructions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将你的包分发给其他人，那么你就需要创建一个包。如果你觉得这听起来很奇怪，即你需要一个包来分发你的包，那是因为同一个术语“包”被用于两个不同的概念。一个
    *PyPI 包* 或 *分发包* 是一个围绕 Python 包的包装器，其中包含有关作者、兼容版本和许可信息，以及自动化测试、依赖项和安装说明。
- en: Even more confusing than the use of “package” to describe two different things
    is the fact that both the distribution package and the Python package are directories,
    and that they should have the same name. If your distribution package is called
    `mypackage`, you’ll have a directory called `mypackage`. Inside that directory,
    among other things, will be a subdirectory called `mypackage`, which is where
    the Python package goes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 比使用“包”来描述两件不同的事情更令人困惑的是，事实是分发包和 Python 包都是目录，并且它们应该有相同的名称。如果你的分发包名为 `mypackage`，你将有一个名为
    `mypackage` 的目录。在该目录中，除了其他内容外，还将有一个名为 `mypackage` 的子目录，Python 包就是放在这里的。
- en: 'Creating a distribution package means creating a file called `setup.py` (documented
    here: [http://mng.bz/wB9q](http://mng.bz/wB9q)), and I must admit that for many
    years, I found this to be a real chore. It turns out that I wasn’t alone, and
    a number of Python developers have come up with ways to create distribution packages
    with relative ease. One that I’ve been using for a while is called “Poetry” ([http://mng.bz/2Xzd](http://mng.bz/2Xzd)),
    and makes the entire process easy and straightforward.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分发包意味着创建一个名为 `setup.py` 的文件（在此处有文档：[http://mng.bz/wB9q](http://mng.bz/wB9q)），我必须承认，多年来，我发现这是一项真正的苦差事。结果证明，我并不孤单，许多
    Python 开发者已经想出了创建分发包的相对简单的方法。我使用了一段时间的一个叫做“Poetry”的方法（[http://mng.bz/2Xzd](http://mng.bz/2Xzd)），使得整个过程变得简单直接。
- en: 'If you want to distribute packages via PyPI, you’ll need to register for a
    username and password at [https://pypi.org/](https://pypi.org/). Once you have
    that, here are the minimal steps you’ll need to take an existing package and upload
    it to PyPI with Poetry, using Unix shell commands:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要通过 PyPI 分发包，你需要在 [https://pypi.org/](https://pypi.org/) 上注册一个用户名和密码。一旦你有了这些，以下是你需要采取的最小步骤，将现有的包使用
    Poetry 通过 Unix shell 命令上传到 PyPI：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Creates a new package skeleton called mypackage
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个名为 mypackage 的新包骨架
- en: ❷ Moves into the top-level directory
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 移动到顶级目录
- en: ❸ Copies the contents of the Python package into its subdirectory
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 Python 包的内容复制到其子目录中
- en: ❹ Creates the wheelfile and tar.gz versions of your package in the dist directory
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在 dist 目录中创建你的包的 wheelfile 和 tar.gz 版本
- en: ❺ Publishes the package to PyPI; to confirm, you enter your username and password
    when prompted
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将包发布到 PyPI；为了确认，当提示时输入你的用户名和密码
- en: Note that you can’t upload the specific name `mypackage` to PyPI. I suggest
    prefacing your package name with your username or initials, unless you intend
    to publish it for public consumption.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你不能将特定的名称 `mypackage` 上传到 PyPI。我建议在你的包名称前加上你的用户名或首字母缩写，除非你打算公开发布。
- en: You could add plenty of other steps to the ones I’ve listed--for example, you
    can (and should) edit the pyproject.toml configuration file, in which you describe
    your package’s version, license, and dependencies. But creating a distribution
    package is no longer difficult. Rather, the hard part will be deciding what code
    you want to share with the community.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加很多其他步骤到我已经列出的步骤中——例如，你可以（并且应该）编辑 pyproject.toml 配置文件，在其中描述你的包的版本、许可和依赖项。但是创建分发包不再困难。相反，困难的部分将是决定你想要与社区分享哪些代码。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Modules and packages are easy to write and use, and help us to DRY up our code--making
    it shorter and more easily maintainable. This benefit is even greater when you
    take advantage of the many modules and packages in the Python standard library,
    and on PyPI. It’s thus no wonder that so many Python programs begin with several
    lines of `import` statements. As you become more fluent in Python, your familiarity
    with third-party modules will grow, allowing you to take even greater advantage
    of them in your code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和包易于编写和使用，并帮助我们实现DRY原则，使代码更短且易于维护。当你利用Python标准库和PyPI上的众多模块和包时，这种好处更为显著。因此，许多Python程序以几行`import`语句开始也就不足为奇了。随着你对Python的熟练程度提高，你对第三方模块的熟悉度也会增加，从而让你在代码中更好地利用它们。
