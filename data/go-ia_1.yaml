- en: Chapter 2\. Go quick-start
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 章\. Go 快速入门
- en: '*In this chapter*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章内容*'
- en: Reviewing a comprehensive Go program
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习全面的 Go 程序
- en: Declaring types, variables, functions, and methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明类型、变量、函数和方法
- en: Launching and synchronizing goroutines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和同步 goroutines
- en: Writing generic code using interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口编写泛型代码
- en: Handling errors as normal program logic
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误处理作为正常程序逻辑
- en: Go has its own elegance and programming idioms that make the language productive
    and fun to code in. The language designers set out to create a language that would
    let them be productive without losing access to the lower-level programming constructs
    they needed. This balance is achieved through a minimized set of keywords, built-in
    functions, and syntax. Go also provides a comprehensive standard library. The
    standard library provides all the core packages programmers need to build real-world
    web- and network-based programs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有其独特的优雅和编程习语，使得语言既高效又编程起来有趣。语言设计者旨在创建一种语言，让他们在保持对所需底层编程结构访问的同时提高生产力。这种平衡是通过最小化关键词、内置函数和语法来实现的。Go
    还提供了一个全面的标凈库。标准库提供了程序员构建真实世界基于 Web 和网络的程序所需的所有核心包。
- en: To see this in action, we’ll review a complete Go program that implements functionality
    that can be found in many Go programs being developed today. The program pulls
    different data feeds from the web and compares the content against a search term.
    The content that matches is then displayed in the terminal window. The program
    reads text files, makes web calls, and decodes both XML and JSON into struct type
    values, and it does all of this using Go concurrency to make things fast.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个动作，我们将审查一个完整的 Go 程序，该程序实现了许多当前正在开发的 Go 程序中可以找到的功能。该程序从网络上拉取不同的数据源，并将内容与搜索词进行比较。匹配的内容随后在终端窗口中显示。该程序读取文本文件，进行网络调用，并将
    XML 和 JSON 解码为结构体类型值，所有这些操作都是通过 Go 并发来实现的，以加快速度。
- en: 'You can download and review the code in your favorite editor by navigating
    to the book repository for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导航到本章的书本仓库来下载并使用你喜欢的编辑器审查代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don’t feel that you need to understand everything you read and review in this
    chapter the first, second, or even the third time. Though many of the programming
    concepts you know today can be applied when learning Go, Go also has its unique
    idioms and style. If you can liberate yourself from your current programming language
    and look at Go with a fresh set of eyes and a clear mind, you’ll find it easier
    to understand and appreciate, and you’ll see Go’s elegance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不要觉得你需要第一次、第二次甚至第三次阅读和复习本章内容时就能完全理解。尽管你今天所知道的许多编程概念在学习 Go 时都可以应用，但 Go 也有其独特的习语和风格。如果你能从当前的编程语言中解放出来，用全新的视角和清晰的头脑来看待
    Go，你会发现它更容易理解和欣赏，你也会看到 Go 的优雅。
- en: 2.1\. Program architecture
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 程序架构
- en: Before we dive into the code, let’s review the architecture behind the program
    (shown in [figure 2.1](#ch02fig01)) and see how searching all the different feeds
    is accomplished.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码之前，让我们回顾一下程序背后的架构（如图 2.1 所示）以及如何完成对所有不同源进行搜索。
- en: Figure 2.1\. The flow of the program architecture
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 程序架构流程
- en: '![](02fig01_alt.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig01_alt.jpg)'
- en: The program is broken into several distinct steps that run across many different
    goroutines. We’ll explore the code as it flows from the main goroutine into the
    searching and tracking goroutines and then back to the main goroutine. To start,
    here’s the structure of the project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 程序被分解成几个不同的步骤，这些步骤在不同的 goroutines 中运行。我们将探索代码，从主 goroutine 流入搜索和跟踪 goroutines，然后再返回主
    goroutine。首先，这是项目的结构。
- en: Listing 2.1\. Project structure for the application
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 应用程序的项目结构
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is organized into these four folders, which are listed in alphabetical
    order. The data folder contains a JSON document of data feeds the program will
    retrieve and process to match the search term. The matchers folder contains the
    code for the different types of feeds the program supports. Currently the program
    only supports one matcher that processes RSS type feeds. The search folder contains
    the business logic for using the different matchers to search content. Finally
    we have the parent folder, sample, which contains the main.go code file, which
    is the entry point for the program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码被组织到这四个文件夹中，按字母顺序列出。数据文件夹包含一个 JSON 文档，它为程序提供数据源，程序将检索和处理这些数据以匹配搜索词。匹配器文件夹包含程序支持的各类数据源的代码。目前程序只支持一个处理
    RSS 类型数据源的匹配器。搜索文件夹包含使用不同匹配器搜索内容的业务逻辑。最后，我们有父文件夹 sample，其中包含 main.go 代码文件，它是程序的入口点。
- en: Now that you’ve seen where all the code for the program is, you can begin to
    explore and understand how the program works. Let’s start with the entry point
    for the program.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了程序所有代码的位置，你可以开始探索和理解程序是如何工作的。让我们从程序的入口点开始。
- en: 2.2\. Main package
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 主包
- en: The program’s entry point can be found in the main.go code file. Even though
    there are only 21 lines of code, there are a few things going on that we have
    to mention.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的入口点可以在 main.go 代码文件中找到。尽管只有 21 行代码，但还有一些事情正在进行，我们必须提及。
- en: Listing 2.2\. main.go
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. main.go
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every Go program that produces an executable has two distinct features. One
    of those features can be found on line 18\. There you can see the function `main`
    declared. For the build tools to produce an executable, the function `main` must
    be declared, and it becomes the entry point for the program. The second feature
    can be found on line 01 of program.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个生成可执行文件的 Go 程序都有两个独特的特性。其中之一可以在第 18 行找到。在那里你可以看到函数 `main` 的声明。为了构建工具生成可执行文件，必须声明函数
    `main`，它成为程序的入口点。第二个特性可以在程序的第 01 行找到。
- en: 'Listing 2.3\. main.go: line 01'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.3\. main.go: 行 01'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see the function `main` is located in a package called `main`. If your
    `main` function doesn’t exist in package `main`, the build tools won’t produce
    an executable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到函数 `main` 位于名为 `main` 的包中。如果你的 `main` 函数不在 `main` 包中，构建工具将不会生成可执行文件。
- en: Every code file in Go belongs to a package, and main.go is no exception. We’ll
    go into much more detail about packages in [chapter 3](kindle_split_011.html#ch03),
    because packages are an important feature of Go. For now, understand that packages
    define a unit of compiled code and their names help provide a level of indirection
    to the identifiers that are declared inside of them, just like a namespace. This
    makes it possible to distinguish identifiers that are declared with exactly the
    same name in the different packages you import.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的每个代码文件都属于一个包，main.go 也不例外。我们将在 [第 3 章](kindle_split_011.html#ch03) 中详细介绍包，因为包是
    Go 的重要特性。现在，理解包定义了一个编译单元，它们的名称有助于提供一种间接层，类似于命名空间。这使得能够在不同导入的包中区分具有完全相同名称的标识符。
- en: Now turn your attention to lines 03 through 09 of the main.go code file, which
    declares imports.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将你的注意力转向 main.go 代码文件的第 03 行至第 09 行，这些行声明了导入。
- en: 'Listing 2.4\. main.go: lines 03–09'
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.4\. main.go: 行 03–09'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Imports are just that: they import code and give you access to identifiers
    such as types, functions, constants, and interfaces. In our case, the code in
    the main.go code file can now reference the `Run` function from the `search` package,
    thanks to the import on line 08\. On lines 04 and 05, we import code from the
    standard library for the `log` and `os` packages.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 导入就是那样：它们导入代码，并允许你访问诸如类型、函数、常量和接口等标识符。在我们的例子中，由于第 08 行的导入，main.go 代码文件中的代码现在可以引用
    `search` 包中的 `Run` 函数。在第 04 和第 05 行，我们导入了标准库中的 `log` 和 `os` 包的代码。
- en: All code files in a folder must use the same package name, and it’s common practice
    to name the package after the folder. As stated before, a package defines a unit
    of compiled code, and each unit of code represents a package. If you quickly look
    back at [listing 2.1](#ch02ex01), you’ll see how we have a folder in this project
    called `search` that matches the import path on line 08.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹中的所有代码文件必须使用相同的包名，通常的做法是将包名命名为文件夹名。正如之前所述，一个包定义了一个编译单元，每个代码单元代表一个包。如果你快速回顾一下
    [列表 2.1](#ch02ex01)，你会看到在这个项目中有一个名为 `search` 的文件夹，它与第 08 行的导入路径相匹配。
- en: You may have noticed that on line 07 we import the `matchers` package and use
    the blank identifier before listing out the import path.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在第07行我们导入了`matchers`包，并在列出导入路径之前使用了空标识符。
- en: 'Listing 2.5\. main.go: line 07'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.5\. main.go: 第07行'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a technique in Go to allow initialization from a package to occur, even
    if you don’t directly use any identifiers from the package. To make your programs
    more readable, the Go compiler won’t let you declare a package to be imported
    if it’s not used. The blank identifier allows the compiler to accept the import
    and call any `init` functions that can be found in the different code files within
    that package. For our program, this is required because the rss.go code file in
    the `matchers` package contains an `init` function to register the RSS matcher
    for use. We’ll come back to how all this works later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go语言中的一种技术，允许即使没有直接使用包中的任何标识符，也能从包中进行初始化。为了使你的程序更易于阅读，Go编译器不会让你声明一个未使用的包。空标识符允许编译器接受导入并调用该包内不同代码文件中可以找到的任何`init`函数。对于我们的程序来说，这是必需的，因为`matchers`包中的rss.go代码文件包含一个用于注册RSS匹配器以便使用的`init`函数。我们将在稍后回到这一切是如何工作的。
- en: The main.go code file also has an `init` function that’s declared on lines 12
    through 15.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: main.go代码文件还有一个在12到15行声明的`init`函数。
- en: 'Listing 2.6\. main.go: lines 11–15'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.6\. main.go: 第11-15行'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All `init` functions in any code file that are part of the program will get
    called before the `main` function. This `init` function sets the logger from the
    standard library to write to the `stdout` device. By default, the logger is set
    to write to the `stderr` device. In [chapter 7](kindle_split_015.html#ch07) we’ll
    talk more about the `log` package and other important packages from the standard
    library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中任何代码文件中的所有`init`函数都会在`main`函数之前被调用。这个`init`函数将标准库中的记录器设置为写入`stdout`设备。默认情况下，记录器设置为写入`stderr`设备。在第[7章](kindle_split_015.html#ch07)中，我们将更详细地讨论`log`包和其他标准库中的重要包。
- en: Finally, let’s look at the one statement that the `main` function performs on
    line 20.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看`main`函数在第20行执行的一个语句。
- en: 'Listing 2.7\. main.go: lines 19–20'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.7\. main.go: 第19-20行'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here you see a call to the `Run` function that belongs to the `search` package.
    This function contains the core business logic for the program, which requires
    a string for the search term. Once the `Run` function returns, the program will
    terminate.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到一个调用`search`包中的`Run`函数。这个函数包含了程序的核心业务逻辑，它需要一个字符串作为搜索项。一旦`Run`函数返回，程序将终止。
- en: Now we can look at the code that belongs to the `search` package.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看属于`search`包的代码。
- en: 2.3\. Search package
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 搜索包
- en: The `search` package contains the framework and business logic for the program.
    The package is organized into four different code files, each with a unique responsibility.
    As we continue to follow the logic of the program, we’ll explore each of these
    different code files.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`包包含了程序框架和业务逻辑。该包组织成四个不同的代码文件，每个文件都有独特的职责。随着我们继续跟踪程序的逻辑，我们将探索这些不同的代码文件。'
- en: Let’s briefly talk about what a matcher is, since the entire program revolves
    around the execution of matchers. A matcher in our program is a value that contains
    specific intelligence for processing a feed type. In our program we have two matchers.
    The framework implements a default matcher that has no intelligence, and in the
    `matchers` package we have an implementation of an RSS matcher. The RSS matcher
    knows how to get, read, and search RSS feeds. Later on we could extend the program
    to use matchers that could read JSON documents or CSV files. We’ll talk more about
    how to implement matchers later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈什么是匹配器，因为整个程序都是围绕匹配器的执行来进行的。在我们的程序中，匹配器是一个包含特定智能以处理特定类型源的数据值。在我们的程序中，我们有两个匹配器。框架实现了一个默认的匹配器，它没有智能，而在`matchers`包中，我们有一个RSS匹配器的实现。RSS匹配器知道如何获取、读取和搜索RSS源。稍后我们可以扩展程序以使用能够读取JSON文档或CSV文件的匹配器。我们将在稍后详细讨论如何实现匹配器。
- en: 2.3.1\. search.go
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. search.go
- en: Following are the first nine lines of code that can be found inside the search.go
    code file. This is the code file where the `Run` function is located.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是可以在search.go代码文件中找到的前九行代码。这是`Run`函数所在的代码文件。
- en: 'Listing 2.8\. search/search.go: lines 01–09'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.8\. search/search.go: 第01-09行'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you’ll see, each code file will contain the keyword `package` at the top
    with a name for the package. Each code file in the search folder will contain
    `search` for the package name. The lines from 03 through 06 import the `log` and
    `sync` packages from the standard library.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，每个代码文件顶部都会包含 `package` 关键字和包的名称。搜索文件夹中的每个代码文件都将包含 `search` 作为包名。从第 03
    行到第 06 行导入标准库中的 `log` 和 `sync` 包。
- en: When you import code from the standard library, you only need to reference the
    name of the package, unlike when you import code from outside of the standard
    library. The compiler will always look for the packages you import at the locations
    referenced by the `GOROOT` and `GOPATH` environment variables.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从标准库导入代码时，你只需要引用包名，这与从标准库外部导入代码不同。编译器总是会查找你导入的包在 `GOROOT` 和 `GOPATH` 环境变量引用的位置。
- en: Listing 2.9\. `GOROOT` and `GOPATH` environmental variables
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.9\. `GOROOT` 和 `GOPATH` 环境变量
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `log` package provides support for logging messages to the `stdout`, `stderr`,
    or even custom devices. The `sync` package provides support for synchronizing
    goroutines, which is required by our program. On line 09 you’ll see our first
    variable declaration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 包提供了将日志消息输出到 `stdout`、`stderr` 或甚至自定义设备的支持。`sync` 包提供了同步 goroutines 的支持，这是我们的程序所必需的。在第
    09 行你会看到我们的第一个变量声明。'
- en: 'Listing 2.10\. search/search.go: lines 08–09'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.10\. search/search.go: 行 08–09'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This variable is located outside the scope of any function and so is considered
    a package-level variable. The variable is declared using the keyword `var` and
    is declared as a `map` of `Matcher` type values with a key of type `string`. The
    declaration for the `Matcher` type can be found in the match.go code file, and
    we’ll describe the purpose of this type later. There’s another important aspect
    of this variable declaration: the name of the variable `matchers` starts with
    a lowercase letter.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量位于任何函数的作用域之外，因此被视为包级变量。变量使用 `var` 关键字声明，并声明为 `Matcher` 类型值的 `map`，其中键的类型为
    `string`。`Matcher` 类型的声明可以在 `match.go` 代码文件中找到，我们将在后面描述这个类型的作用。这个变量声明的另一个重要方面是变量名
    `matchers` 以小写字母开头。
- en: In Go, identifiers are either exported or unexported from a package. An exported
    identifier can be directly accessed by code in other packages when the respective
    package is imported. These identifiers start with a capital letter. Unexported
    identifiers start with a lowercase letter and can’t be directly accessed by code
    in other packages. But just because an identifier is unexported, it doesn’t mean
    other packages can’t indirectly access these identifiers. As an example, a function
    can return a value of an unexported type and this value is accessible by any calling
    function, even if the calling function has been declared in a different package.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，标识符要么从包中导出，要么未导出。导出的标识符可以在导入相应包时被其他包中的代码直接访问。这些标识符以大写字母开头。未导出的标识符以小写字母开头，不能被其他包中的代码直接访问。但是，即使标识符未导出，并不意味着其他包不能间接访问这些标识符。例如，一个函数可以返回一个未导出类型的值，而这个值可以被任何调用函数访问，即使调用函数在另一个包中声明。
- en: This variable declaration also contains an initialization of the variable via
    the assignment operator and a special built-in function called `make`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量声明还包含通过赋值运算符和特殊内置函数 `make` 对变量进行初始化。
- en: Listing 2.11\. Making a map
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.11\. 创建一个 map
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A `map` is a reference type that you’re required to `make` in Go. If you don’t
    make the `map` first and assign it to your variable, you’ll receive errors when
    you try to use the `map` variable. This is because the zero value for a `map`
    variable is `nil`. In [chapter 4](kindle_split_012.html#ch04) we’ll go into greater
    detail about maps.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，`map` 是一种引用类型，你需要使用 `make` 关键字来创建它。如果你没有先创建 `map` 并将其分配给变量，当你尝试使用 `map`
    变量时将会收到错误。这是因为 `map` 变量的零值是 `nil`。在[第 4 章](kindle_split_012.html#ch04)中，我们将更详细地介绍
    `map`。
- en: In Go, all variables are initialized to their zero value. For numeric types,
    that value is `0`; for strings it’s an empty string; for Booleans it’s `false`;
    and for pointers, the zero value is `nil`. When it comes to reference types, there
    are underlying data structures that are initialized to their zero values. But
    variables declared as a reference type set to their zero value will return the
    value of `nil`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，所有变量都被初始化为其零值。对于数值类型，该值是 `0`；对于字符串，它是空字符串；对于布尔值，它是 `false`；对于指针，零值是 `nil`。对于引用类型，存在初始化为零值的基本数据结构。但是，声明为引用类型并设置为零值的变量将返回
    `nil` 的值。
- en: Now let’s walk through the `Run` function that’s called by the `main` function,
    which you saw earlier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐步分析由 `main` 函数调用的 `Run` 函数，您之前已经见过它。
- en: 'Listing 2.12\. search/search.go: lines 11–57'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.12\. search/search.go: 行 11–57'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Run` function contains the main control logic for the program. It’s a good
    representation of how Go programs can be structured to handle the launching and
    synchronization of goroutines that run concurrently. Let’s walk through the logic
    section by section, and then explore the other code files that lend their support.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run` 函数包含程序的主要控制逻辑。它是 Go 程序如何结构化以处理并发运行的 goroutine 的良好示例。让我们逐节分析逻辑，然后探索提供支持的其它代码文件。'
- en: Let’s review how the `Run` function is declared.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 `Run` 函数是如何声明的。
- en: 'Listing 2.13\. search/search.go: lines 11–12'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.13\. search/search.go: 行 11–12'
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To declare a function in Go, use the keyword `func` followed by the function
    name, any parameters, and then any return values. In the case of `Run`, you have
    a single parameter called `searchTerm` of type `string`. The term the program
    will search against is passed into the `Run` function, and if you look at the
    `main` function again, you can see that exchange.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中声明函数时，使用关键字 `func` 后跟函数名、任何参数以及任何返回值。对于 `Run` 来说，您有一个名为 `searchTerm` 的单个参数，其类型为
    `string`。程序将要搜索的术语传递给 `Run` 函数，如果您再次查看 `main` 函数，您可以看到这一点。
- en: 'Listing 2.14\. main.go: lines 17–21'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.14\. main.go: 行 17–21'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first thing that the `Run` function does is retrieve a list of data feeds.
    These feeds are used to pull content from the internet that is then matched against
    the specified search term.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run` 函数首先做的事情是检索数据源列表。这些源用于从互联网上拉取内容，然后与指定的搜索词进行匹配。'
- en: 'Listing 2.15\. search/search.go: lines 13–17'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.15\. search/search.go: 行 13–17'
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are a few important concepts here that we need to go through. You can
    see on line 14 that we make a function call to the function `RetrieveFeeds`. This
    function belongs to the `search` package and returns two values. The first return
    value is a slice of `Feed` type values. A slice is a reference type that implements
    a dynamic array. You use slices in Go to work with lists of data. [Chapter 4](kindle_split_012.html#ch04)
    goes into greater detail about slices.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个重要的概念需要我们逐一说明。您可以看到在第 14 行，我们调用了 `RetrieveFeeds` 函数。这个函数属于 `search` 包，并返回两个值。第一个返回值是
    `Feed` 类型值的切片。切片是一个实现了动态数组的引用类型。在 Go 中，您使用切片来处理数据列表。[第 4 章](kindle_split_012.html#ch04)
    对切片进行了更详细的介绍。
- en: The second return value is an error. On line 15, the error value is evaluated
    for errors, and if an error did occur, the function `Fatal` from the `log` package
    is called. The `Fatal` function accepts an error value and will log to the terminal
    window before terminating the program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个返回值是一个错误。在第 15 行，错误值被评估以检查错误，如果确实发生了错误，则调用 `log` 包中的 `Fatal` 函数。`Fatal` 函数接受一个错误值，并在终止程序之前将其记录到终端窗口。
- en: Though not unique to Go, you can see that our functions can have multiple return
    values. It’s common to declare functions that return a value and an error value
    just like the `RetrieveFeeds` function. If an error occurs, never trust the other
    values being returned from the function. They should always be ignored, or else
    you run the risk of the code generating more errors or panics.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是 Go 独有的特性，但您可以看到我们的函数可以有多个返回值。声明返回值和错误值的函数，就像 `RetrieveFeeds` 函数一样，是很常见的。如果发生错误，永远不要相信函数返回的其他值。它们应该始终被忽略，否则您可能会使代码产生更多错误或恐慌。
- en: Let’s take a closer look at how the values being returned from the function
    are being assigned to variables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看函数返回的值是如何分配给变量的。
- en: 'Listing 2.16\. search/search.go: lines 13–14'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.16\. search/search.go: 行 13–14'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here you see the use of the short variable declaration operator (`:=`). This
    operator is used to both declare and initialize variables at the same time. The
    type of each value being returned is used by the compiler to determine the type
    for each variable, respectively. The short variable declaration operator is just
    a shortcut to streamline your code and make the code more readable. The variable
    it declares is no different than any other variable you may declare when using
    the keyword `var`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到短变量声明运算符（`:=`）的使用。这个运算符用于同时声明和初始化变量。返回的每个值的类型被编译器用来确定每个变量的类型。短变量声明运算符只是简化代码并使代码更易读的一种快捷方式。它声明的变量与使用
    `var` 关键字声明的任何其他变量没有区别。
- en: Now that we have our list of data feeds, we can move on to the next line of
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了数据源列表，我们可以继续到下一行代码。
- en: 'Listing 2.17\. search/search.go: lines 19–20'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.17\. search/search.go: 行 19–20'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: On line 20, we use the built-in function `make` to create an unbuffered channel.
    We use the short variable declaration operator to declare and initialize the channel
    variable with the call to `make`. A good rule of thumb when declaring variables
    is to use the keyword `var` when declaring variables that will be initialized
    to their zero value, and to use the short variable declaration operator when you’re
    providing extra initialization or making a function call.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 20 行，我们使用内置函数 `make` 创建一个无缓冲通道。我们使用短变量声明运算符通过调用 `make` 声明和初始化通道变量。在声明变量时，一个很好的经验法则是，当声明将初始化为零值的变量时使用
    `var` 关键字，当你提供额外的初始化或进行函数调用时使用短变量声明运算符。
- en: Channels are also a reference type in Go like maps and slices, but channels
    implement a queue of typed values that are used to communicate data between goroutines.
    Channels provide inherent synchronization mechanisms to make communication safe.
    In [chapter 6](kindle_split_014.html#ch06) we’ll go into more details about channels
    and goroutines.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，通道（Channels）也是一种类似于映射（Maps）和切片（Slices）的引用类型，但通道实现了一个类型化的值队列，用于在 goroutines
    之间通信数据。通道提供了固有的同步机制以确保通信的安全性。在[第 6 章](kindle_split_014.html#ch06)中，我们将更详细地介绍通道和
    goroutines。
- en: The next two lines of code are used later to prevent the program from terminating
    before all the search processing is complete.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行代码将在稍后用于防止程序在所有搜索处理完成之前终止。
- en: 'Listing 2.18\. search/search.go: lines 22–27'
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.18\. search/search.go: 行 22–27'
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In Go, once the `main` function returns, the program terminates. Any goroutines
    that were launched and are still running at this time will also be terminated
    by the Go runtime. When you write concurrent programs, it’s best to cleanly terminate
    any goroutines that were launched prior to letting the `main` function return.
    Writing programs that can cleanly start and shut down helps reduce bugs and prevents
    resources from corruption.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，一旦 `main` 函数返回，程序就会终止。此时仍在运行的任何已启动的 goroutines 也将由 Go 运行时终止。当你编写并发程序时，最好在让
    `main` 函数返回之前干净地终止所有已启动的 goroutines。编写能够干净启动和关闭的程序有助于减少错误并防止资源损坏。
- en: Our program is using a `WaitGroup` from the `sync` package to track all the
    goroutines we’re going to launch. A `WaitGroup` is a great way to track when a
    goroutine is finished performing its work. A `WaitGroup` is a counting semaphore,
    and we’ll use it to count off goroutines as they finish their work.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的程序正在使用 `sync` 包中的 `WaitGroup` 来跟踪我们打算启动的所有 goroutines。`WaitGroup` 是跟踪 goroutine
    完成其工作的一种很好的方式。`WaitGroup` 是一个计数信号量，我们将用它来计数完成工作的 goroutines。 '
- en: On line 23 we declare a variable of type `WaitGroup` from the `sync` package.
    Then on line 27 we set the value of the `WaitGroup` variable to match the number
    of goroutines we’re going to launch. As you’ll soon see, we’ll process each feed
    concurrently with its own goroutine. As each goroutine completes its work, it
    will decrement the count of the `WaitGroup` variable, and once the variable gets
    to zero, we’ll know all the work is done.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 23 行，我们声明了一个来自 `sync` 包的 `WaitGroup` 类型的变量。然后在第 27 行，我们将 `WaitGroup` 变量的值设置为我们将要启动的
    goroutines 的数量。正如你很快就会看到的，我们将使用各自的 goroutine 并发处理每个源数据。随着每个 goroutine 完成其工作，它将减少
    `WaitGroup` 变量的计数，一旦变量变为零，我们就知道所有工作都完成了。
- en: Next let’s look at the code that launches these goroutines for each feed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看启动每个源数据的 goroutines 的代码。
- en: 'Listing 2.19\. search/search.go: lines 29–42'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.19\. search/search.go: 行 29–42'
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code for lines 30 through 42 iterate through the list of data feeds we retrieved
    earlier and launch a goroutine for each one. To iterate over the slice of feeds,
    we use the keywords `for range`. The keyword `range` can be used with arrays,
    strings, slices, maps, and channels. When we use `for range` to iterate over a
    slice, we get two values back on each iteration. The first is the index position
    of the element we’re iterating over, and the second is a copy of the value in
    that element.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从第30行到第42行的代码遍历了我们之前检索到的数据流列表，并为每个数据流启动了一个goroutine。为了遍历feed的切片，我们使用了`for range`关键字。`range`关键字可以与数组、字符串、切片、图和通道一起使用。当我们使用`for
    range`遍历切片时，我们每次迭代会返回两个值。第一个是我们正在迭代的元素的索引位置，第二个是该元素的值的副本。
- en: If you look closer at the `for range` statement on line 30, you’ll see the use
    of the blank identifier again.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看第30行的`for range`语句，你会再次看到空白标识符的使用。
- en: 'Listing 2.20\. search/search.go: lines 29–30'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.20\. search/search.go: 行29–30'
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is the second time you see the blank identifier being used. You first saw
    it in main.go when we imported the `matchers` package. Now it’s being used as
    a substitution for the variable that would be assigned to the index value for
    the range call. When you have a function that returns multiple values, and you
    don’t have a need for one, you can use the blank identifier to ignore those values.
    In our case with this range, we won’t be using the index value, so the blank identifier
    allows us to ignore it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二次看到空白标识符的使用。你第一次在`main.go`中看到它，当时我们导入了`matchers`包。现在它被用作替换为range调用索引值的变量。当你有一个返回多个值的函数，而你不需要其中一个值时，你可以使用空白标识符来忽略这些值。在我们的这个range中，我们不会使用索引值，所以空白标识符允许我们忽略它。
- en: The first thing we do in the loop is check the map for a `Matcher` value that
    can be used to process a feed of the specific feed type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中我们首先做的事情是检查图中是否存在用于处理特定数据类型数据流的`Matcher`值。
- en: 'Listing 2.21\. search/search.go: lines 31–35'
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.21\. search/search.go: 行31–35'
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We haven’t talked about how this map gets its values yet. You’ll see later
    on how the program initializes itself and populates this map. On line 32 we check
    the map for a key that matches the feed type. When looking up a key in a map,
    you have two options: you can assign a single variable or two variables for the
    lookup call. The first variable is always the value returned for the key lookup,
    and the second value, if specified, is a Boolean flag that reports whether the
    key exists or not. When a key doesn’t exist, the map will return the zero value
    for the type of value being stored in the map. When the key does exist, the map
    will return a copy of the value for that key.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论这张图是如何获取其值的。你稍后将会看到程序是如何初始化自身并填充这张图的。在第32行，我们检查图中是否存在与数据类型匹配的键。在图中查找键时，你有两种选择：你可以为查找调用分配一个变量或两个变量。第一个变量始终是键查找返回的值，如果指定，第二个值是一个布尔标志，报告键是否存在。当键不存在时，图将返回存储在图中的值的零值。当键存在时，图将返回该键值的副本。
- en: On line 33 we check whether the key was located in the map, and if it’s not,
    we assign the default matcher to be used. This allows the program to function
    without causing any issues or interruption for feeds that the program currently
    doesn’t support. Then we launch a goroutine to perform the search.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第33行，我们检查键是否在图中找到，如果没有找到，我们分配默认的匹配器以供使用。这允许程序在没有引起任何问题或中断当前程序不支持的数据流的情况下运行。然后我们启动一个goroutine来执行搜索。
- en: 'Listing 2.22\. search/search.go: lines 37–41'
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.22\. search/search.go: 行37–41'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In [chapter 6](kindle_split_014.html#ch06) we’ll go into more detail about goroutines,
    but for now a *goroutine* is a function that’s launched to run independently from
    other functions in the program. Use the keyword `go` to launch and schedule goroutines
    to run concurrently. On line 38 we use the keyword `go` to launch an anonymous
    function as a goroutine. An *anonymous function* is a function that’s declared
    without a name. In our `for range` loop, we launch an anonymous function as a
    goroutine for each feed. This allows each feed to be processed independently in
    a concurrent fashion.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_014.html#ch06)中，我们将更详细地介绍goroutines，但到目前为止，*goroutine*是一个独立于程序中其他函数运行的函数。使用`go`关键字来启动和调度goroutines以并发运行。在第38行，我们使用`go`关键字启动一个匿名函数作为goroutine。*匿名函数*是一个没有声明的函数。在我们的`for
    range`循环中，我们为每个feed启动一个匿名函数作为goroutine。这允许每个feed以并发方式独立处理。
- en: Anonymous functions can take parameters, which we declare for this anonymous
    function. On line 38 we declare the anonymous function to accept a value of type
    `Matcher` and the address of a value of type `Feed`. This means the variable `feed`
    is a *pointer variable*. Pointer variables are great for sharing variables between
    functions. They allow functions to access and change the state of a variable that
    was declared within the scope of a different function and possibly a different
    goroutine.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数可以接受参数，我们为这个匿名函数声明了这些参数。在第38行，我们声明了匿名函数接受一个类型为`Matcher`的值和一个类型为`Feed`的值的地址。这意味着变量`feed`是一个*指针变量*。指针变量非常适合在函数之间共享变量。它们允许函数访问和更改在另一个函数的作用域内（可能是一个不同的goroutine）声明的变量的状态。
- en: On line 41 the values of the `matcher` and `feed` variables are being passed
    into the anonymous function. In Go, all variables are passed by value. Since the
    value of a pointer variable is the address to the memory being pointed to, passing
    pointer variables between functions is still considered a pass by value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第41行，`matcher`和`feed`变量的值被传递到匿名函数中。在Go中，所有变量都是按值传递的。由于指针变量的值是指向被指向内存的地址，因此函数之间传递指针变量仍然被视为按值传递。
- en: On lines 39 and 40 you see the work each goroutine is performing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第39行和第40行，你可以看到每个goroutine正在执行的工作。
- en: 'Listing 2.23\. search/search.go: lines 39–40'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.23\. search/search.go: 第39-40行'
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing the goroutine does is call a function called `Match`, which
    can be found in the match.go code file. The `Match` function takes a value of
    type `Matcher`, a pointer to a value of type `Feed`, the search term, and the
    channel where the results are written to. We’ll look at the internals of this
    function later, but for now it’s enough to know that `Match` will search the feed
    and output matches to the `results` channel.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: goroutine首先调用一个名为`Match`的函数，该函数位于`match.go`代码文件中。`Match`函数接受一个类型为`Matcher`的值、一个类型为`Feed`的值的指针、搜索词以及将结果写入的通道。我们稍后会查看这个函数的内部结构，但就目前而言，知道`Match`将搜索feed并将匹配项输出到`results`通道就足够了。
- en: 'Once the function call to `Match` completes, we execute the code on line 40,
    which is to decrement the `WaitGroup` count. Once every goroutine finishes calling
    the `Match` function and the `Done` method, the program will know every feed has
    been processed. There’s something else interesting about the method call to `Done`:
    the `WaitGroup` value was never passed into the anonymous function as a parameter,
    yet the anonymous function has access to it.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Match`函数调用完成，我们执行第40行的代码，即递减`WaitGroup`计数。一旦每个goroutine完成调用`Match`函数和`Done`方法，程序将知道每个feed都已处理。关于`Done`方法调用的另一个有趣之处是：`WaitGroup`值从未作为参数传递给匿名函数，但匿名函数仍然可以访问它。
- en: Go supports closures and you’re seeing this in action. In fact, the `searchTerm`
    and `results` variables are also being accessed by the anonymous function via
    closures. Thanks to closures, the function can access those variables directly
    without the need to pass them in as parameters. The anonymous function isn’t given
    a copy of these variables; it has direct access to the same variables declared
    in the scope of the outer function. This is the reason why we don’t use closures
    for the `matcher` and `feed` variables.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持闭包，你正在看到这一功能的应用。实际上，`searchTerm`和`results`变量也通过闭包被匿名函数访问。多亏了闭包，函数可以直接访问这些变量，而无需将它们作为参数传递。匿名函数并没有得到这些变量的副本；它直接访问的是在外部函数作用域中声明的相同变量。这就是为什么我们不使用闭包来处理`matcher`和`feed`变量。
- en: 'Listing 2.24\. search/search.go: lines 29–32'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.24\. search/search.go: 第29-32行'
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The values of the `feed` and `matcher` variables are changing with each iteration
    of the loop, as you can see on lines 30 and 32\. If we used closures for these
    variables, as the values of these variables changed in the outer function, those
    changes would be reflected in the anonymous function. All the goroutines would
    be sharing the same variables as the outer function thanks to closures. Unless
    we passed these values in as function parameters, most of the goroutines would
    end up processing the same feed using the same matcher—most likely the last one
    in the `feeds` slice.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`feed`和`matcher`变量的值在每次循环迭代中都会改变，正如你在第30行和第32行所看到的。如果我们为这些变量使用闭包，由于这些变量在外部函数中的值发生了变化，这些变化会在匿名函数中反映出来。所有goroutine都会因为闭包而与外部函数共享相同的变量。除非我们将这些值作为函数参数传递，否则大多数goroutine最终会使用相同的matcher处理相同的feed——很可能是`feeds`切片中的最后一个。'
- en: With all the search goroutines working, sending results on the `results` channel
    and decrementing the `waitGroup` counter, we need a way to display those results
    and keep the `main` function alive until all the processing is done.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有的搜索 goroutine 正在运行，在 `results` 通道上发送结果并递减 `waitGroup` 计数时，我们需要一种方式来显示这些结果，并保持
    `main` 函数在所有处理完成之前保持活跃。
- en: 'Listing 2.25\. search/search.go: lines 44–57'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.25\. search/search.go: 行 44–57'
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code between lines 45 and 56 is tricky to explain until we dive deeper into
    some of the other code in the `search` package. For now let’s describe what we
    see and come back to it later to understand the mechanics. On lines 45 through
    52 we launch yet another anonymous function as a goroutine. This anonymous function
    takes no parameters and uses closures to access both the `WaitGroup` and `results`
    variables. This goroutine calls the method `Wait` on the `WaitGroup` value, which
    is causing the goroutine to block until the count for the `WaitGroup` hits zero.
    Once that happens, the goroutine calls the built-in function `close` on the channel,
    which as you’ll see causes the program to terminate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 45 行到 56 行之间的代码难以解释，直到我们深入到 `search` 包中的其他一些代码。目前，让我们描述一下我们看到的内容，稍后再回来理解其机制。在第
    45 行到 52 行，我们启动了另一个匿名函数作为 goroutine。这个匿名函数不接受任何参数，并使用闭包来访问 `WaitGroup` 和 `results`
    变量。这个 goroutine 调用 `WaitGroup` 值上的 `Wait` 方法，这导致 goroutine 阻塞，直到 `WaitGroup` 的计数达到零。一旦发生这种情况，goroutine
    就会在通道上调用内置函数 `close`，正如你将看到的，这会导致程序终止。
- en: The final piece of code in the `Run` function is on line 56\. This is a call
    to the `Display` function, which can be found in the match.go code file. Once
    this function returns, the program terminates. This doesn’t happen until all the
    results in the channel are processed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run` 函数中的最后一部分代码在第 56 行。这是一个调用 `Display` 函数的调用，该函数可以在 match.go 代码文件中找到。一旦这个函数返回，程序就会终止。这不会发生，直到通道中的所有结果都被处理。'
- en: 2.3.2\. feed.go
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. feed.go
- en: Now that you’ve seen the `Run` function, let’s look at the code behind the function
    call to `RetrieveFeeds` on line 14 of the search.go code file. This function reads
    the data.json file and returns the slice of data feeds. These feeds drive the
    content that will be searched by the different matchers. Here are the first eight
    lines of code that can be found inside the feed.go code file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了 `Run` 函数，让我们看看在 search.go 代码文件的第 14 行对 `RetrieveFeeds` 函数调用的代码。这个函数读取
    data.json 文件，并返回数据源切片。这些源驱动着不同匹配器将要搜索的内容。以下是可以在 feed.go 代码文件中找到的前八行代码。
- en: 'Listing 2.26\. feed.go: lines 01–08'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.26\. feed.go: 行 01–08'
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code file exists in the search folder, and on line 01 the code file is
    declared to be in package `search`. You can see that on lines 03 through 06 we
    import two packages from the standard library. The `json` package provides support
    for encoding and decoding JSON and the `os` package provides support for accessing
    operating system functionality like reading files.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码文件存在于 search 文件夹中，在第 01 行代码文件被声明为包 `search`。你可以看到，在第 03 行到 06 行，我们从标准库中导入了两个包。`json`
    包提供对编码和解码 JSON 的支持，而 `os` 包提供对访问操作系统功能（如读取文件）的支持。
- en: You may have noticed that to import the `json` package, we needed to specify
    a path that includes the encoding folder. Regardless of the path we specify, the
    name of the package is `json`. The physical location of the package from within
    the standard library doesn’t change this fact. As we access functionality from
    the `json` package, we’ll use just the name `json`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，为了导入 `json` 包，我们需要指定一个包含编码文件夹的路径。无论我们指定什么路径，包的名称都是 `json`。包在标准库中的物理位置不会改变这一事实。当我们从
    `json` 包访问功能时，我们将只使用名称 `json`。
- en: On line 08 we declare a constant named `dataFile`, which is assigned a string
    that specifies the relative path to the data file on disk. Since the Go compiler
    can deduce the type from the value on the right side of the assignment operator,
    specifying the type when declaring the constant is unnecessary. We also use a
    lowercase letter for the name of the constant, which means this constant is unexported
    and can only be directly accessed by code within the `search` package.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 08 行，我们声明了一个名为 `dataFile` 的常量，它被分配了一个字符串，指定了磁盘上数据文件的相对路径。由于 Go 编译器可以从赋值操作符右侧的值中推断出类型，因此在声明常量时指定类型是不必要的。我们还使用小写字母为常量命名，这意味着这个常量是未导出的，并且只能由
    `search` 包内的代码直接访问。
- en: Next let’s look at a portion of the data.json data file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看看 data.json 数据文件的一部分。
- en: Listing 2.27\. data.json
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.27\. data.json
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The actual data file contains more than four data feeds, but [listing 2.27](#ch02ex27)
    shows a valid version of the data file. The data file contains an array of JSON
    documents. Each document in the data file provides a name of the site we’re getting
    the data from, a link to the data, and the type of data we expect to receive.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的数据文件包含超过四个数据源，但[列表2.27](#ch02ex27)展示了数据文件的有效版本。数据文件包含一个JSON文档数组。数据文件中的每个文档都提供了我们从哪里获取数据的站点名称、数据链接以及我们期望接收的数据类型。
- en: These documents need to be decoded into a slice of struct types so we can use
    this data in our program. Let’s look at the struct type that will be used to decode
    this data file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文档需要解码成结构体类型的切片，这样我们就可以在程序中使用这些数据。让我们看看将用于解码此数据文件的结构体类型。
- en: 'Listing 2.28\. feed.go: lines 10–15'
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.28\. feed.go: 第10-15行'
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: On lines 11 through 15 we declare a struct type named `Feed`, which is an exported
    type. This type is declared with three fields, each of which are strings that
    match the fields for each document in the data file. If you look at each field
    declaration, tags have been included to provide the metadata that the JSON decoding
    function needs to create the slice of `Feed` type values. Each tag maps a field
    name in the struct type to a field name in the document.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11行到第15行，我们声明了一个名为`Feed`的结构体类型，这是一个导出类型。该类型声明了三个字段，每个字段都是与数据文件中每个文档的字段匹配的字符串。如果你查看每个字段声明，标签已经包含在内，以提供JSON解码函数所需的元数据，以创建`Feed`类型值的切片。每个标签将结构体类型中的字段名称映射到文档中的字段名称。
- en: Now we can review the `RetrieveFeeds` function that we called on line 14 in
    the search.go code file. This is the function that reads the data file and decodes
    every document into a slice of `Feed` type values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回顾在search.go代码文件的第14行调用的`RetrieveFeeds`函数。这是读取数据文件并将每个文档解码成`Feed`类型值切片的函数。
- en: 'Listing 2.29\. feed.go: lines 17–36'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.29\. feed.go: 第17-36行'
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s start with the declaration of the function on line 18\. The function takes
    no parameters and returns two values. The first return value is a slice of pointers
    to `Feed` type values. The second return value is an error value that reports
    back if the function call was successful. As you’ll continue to see, returning
    error values is common practice in this code example and throughout the standard
    library.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第18行的函数声明开始。该函数不接受任何参数，并返回两个值。第一个返回值是`Feed`类型值的指针切片。第二个返回值是错误值，用于报告函数调用是否成功。正如你将继续看到的那样，返回错误值是此代码示例和整个标准库中的常见做法。
- en: Now let’s look at lines 20 through 23, where we use the `os` package to open
    the data file. The call to the `Open` method takes the relative path to our data
    file and returns two values. The first return value is a pointer to a value of
    type `File`, and the second return value is an error to check if the call to `Open`
    was successful. Immediately on line 21 we check the error value and return the
    error if we did have a problem opening the file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看第20行到第23行，我们在这里使用`os`包打开数据文件。对`Open`方法的调用接受我们数据文件的相对路径，并返回两个值。第一个返回值是指向类型为`File`的值的指针，第二个返回值是错误值，用于检查`Open`调用是否成功。在第21行立即检查错误值，如果确实有问题打开文件，则返回错误。
- en: If we’re successful in opening the file, we then move to line 27\. Here you
    see the use of the keyword `defer`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功打开了文件，那么我们就转到第27行。在这里，你可以看到关键字`defer`的使用。
- en: 'Listing 2.30\. feed.go: lines 25–27'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.30\. feed.go: 第25-27行'
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The keyword `defer` is used to schedule a function call to be executed right
    after a function returns. It’s our responsibility to close the file once we’re
    done with it. By using the keyword `defer` to schedule the call to the `close`
    method, we can guarantee that the method will be called. This will happen even
    if the function panics and terminates unexpectedly. The keyword `defer` lets us
    write this statement close to where the opening of the file occurs, which helps
    with readability and reducing bugs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`defer`用于安排在函数返回后立即执行函数调用。一旦我们处理完文件，关闭文件就是我们的责任。通过使用关键字`defer`来安排对`close`方法的调用，我们可以保证该方法将被调用。即使函数发生恐慌并意外终止，也会发生这种情况。关键字`defer`让我们将此语句放置在文件打开附近，这有助于提高可读性并减少错误。
- en: Now we can review the final lines of code in the function. Let’s look at lines
    31 through 35.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回顾函数中的最后几行代码。让我们看看第31行到第35行。
- en: 'Listing 2.31\. feed.go: lines 29–36'
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.31\. feed.go: 第29-36行'
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: On line 31 we declare a `nil` slice named `feeds` that contains pointers to
    `Feed` type values. Then on line 32 we make a call to the `Decode` method off
    the value returned by the `NewDecoder` function from the `json` package. The `NewDecoder`
    function takes the file handle we created from the method call to `Open` and returns
    a pointer to a value of type `Decoder`. From that value we call the `Decode` method,
    passing the address to the slice. The `Decode` method then decodes the data file
    and populates our slice with a set of `Feed` type values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 31 行，我们声明了一个名为 `feeds` 的空切片，其中包含指向 `Feed` 类型值的指针。然后在第 32 行，我们调用 `json` 包中
    `NewDecoder` 函数返回的值的 `Decode` 方法。`NewDecoder` 函数接受我们通过 `Open` 方法调用的文件句柄，并返回一个指向
    `Decoder` 类型值的指针。从该值中，我们调用 `Decode` 方法，传递切片的地址。然后 `Decode` 方法解码数据文件，并将一组 `Feed`
    类型值填充到我们的切片中。
- en: The `Decode` method can accept any type of value thanks to its declaration.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其声明，`Decode` 方法可以接受任何类型的值。
- en: Listing 2.32\. Using the empty interface
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.32\. 使用空接口
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The parameter for the `Decode` method accepts a value of type `interface{}`.
    This is a special type in Go and works with the reflection support that can be
    found in the `reflect` package. In [chapter 9](kindle_split_017.html#ch09) we’ll
    go into more detail about reflection and how this method works.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decode` 方法的参数接受 `interface{}` 类型的值。这是 Go 语言中的一个特殊类型，它与 `reflect` 包中可找到的反射支持一起工作。在第
    9 章 [kindle_split_017.html#ch09] 中，我们将更详细地介绍反射以及这个方法是如何工作的。'
- en: The last line of code on line 35 returns the slice and error values back to
    the calling function. In this case there’s no need for the function to check the
    error value after the call to `Decode`. The function is complete and the calling
    function can check the error value and determine what to do next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第 35 行的最后一行代码将切片和错误值返回给调用函数。在这种情况下，调用 `Decode` 后不需要函数检查错误值。函数已经完成，调用函数可以检查错误值并确定下一步要做什么。
- en: Now it’s time to see how the search code supports different types of feed implementations
    by reviewing the matcher code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过查看匹配器代码来了解搜索代码是如何支持不同类型的馈电实现的。
- en: 2.3.3\. match.go/default.go
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. match.go/default.go
- en: The match.go code file contains the support for creating different types of
    matchers that can be used by the search `Run` function. Let’s go back and look
    at the code from the `Run` function that executes the search using the different
    types of matchers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: match.go 代码文件包含创建不同类型匹配器的支持，这些匹配器可以被搜索 `Run` 函数使用。让我们回到 `Run` 函数的代码，该函数使用不同类型的匹配器执行搜索。
- en: 'Listing 2.33\. search/search.go : lines 29 - 42'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.33\. search/search.go: 行 29 - 42'
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code on line 32 looks up a matcher value based on the feed type; that value
    is then used to process a search against that specific feed. Then on line 38 through
    41, a goroutine is launched for that matcher and feed value. The key to making
    this code work is the ability of this framework code to use an interface type
    to capture and call into the specific implementation for each matcher value. This
    allows the code to handle different types of matcher values in a consistent and
    generic way. Let’s look at the code in match.go and see how we’re able to implement
    this functionality.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第 32 行的代码根据数据类型查找匹配器值；然后使用该值来处理对该特定数据源的搜索。然后在第 38 行到第 41 行，为该匹配器和数据源启动了一个 goroutine。使这段代码能够正常工作的关键是这个框架代码能够使用接口类型来捕获并调用每个匹配器值的特定实现。这允许代码以一致和通用的方式处理不同类型的匹配器值。让我们看看
    match.go 中的代码，看看我们是如何实现这个功能的。
- en: Here are the first 17 lines of code for match.go.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 match.go 的前 17 行代码。
- en: 'Listing 2.34\. search/match.go: lines 01–17'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.34\. search/match.go: 行 01–17'
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let’s jump to lines 15 through 17 and look at the declaration of the interface
    type named `Matcher`. Up until now we’ve only been declaring struct types, but
    here you see code that’s declaring an `interface` type. We’ll get into a lot more
    detail about interfaces in [chapter 5](kindle_split_013.html#ch05), but for now
    know that interfaces declare behavior that’s required to be implemented by struct
    or named types to satisfy the interface. The behavior of an interface is defined
    by the methods that are declared within the interface type.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳转到第 15 行到第 17 行，看看名为 `Matcher` 的接口类型的声明。到目前为止，我们只声明了结构体类型，但在这里你可以看到声明接口类型的代码。我们将在第
    5 章 [kindle_split_013.html#ch05] 中详细介绍接口，但到目前为止，我们知道接口声明了结构体或命名类型必须实现的行为以满足接口。接口的行为由接口类型内声明的函数定义。
- en: 'In the case of the `Matcher` interface, there’s only one method declared, `Search`,
    which takes a pointer to a value of type `Feed` and a search term of type `string`.
    The method also returns two values: a slice of pointers to values of type `Result`
    and an error value. The `Result` type is declared on lines 08 through 11.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Matcher` 接口的情况下，只声明了一个方法，即 `Search`，它接受一个指向 `Feed` 类型的值的指针和一个 `string` 类型的搜索词。该方法还返回两个值：一个指向
    `Result` 类型值的指针切片和一个错误值。`Result` 类型在第 08 到 11 行声明。
- en: You follow a naming convention in Go when naming interfaces. If the interface
    type contains only one method, the name of the interface ends with the *er* suffix.
    This is the exact case for our interface, so the name of the interface is `Matcher`.
    When multiple methods are declared within an interface type, the name of the interface
    should relate to its general behavior.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中命名接口时，你需要遵循一个命名约定。如果接口类型只包含一个方法，那么接口的名称应该以 *er* 后缀结尾。在我们的接口中，这正是这种情况，因此接口的名称是
    `Matcher`。当在接口类型中声明多个方法时，接口的名称应该与其一般行为相关。
- en: For a user-defined type to implement an interface, the type in question needs
    to implement all the methods that are declared within that interface type. Let’s
    switch to the default.go code file and see how the default matcher implements
    the `Matcher` interface.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户定义的类型实现一个接口，该类型需要实现接口类型中声明的所有方法。让我们切换到 `default.go` 代码文件，看看默认匹配器是如何实现 `Matcher`
    接口的。
- en: 'Listing 2.35\. search/default.go: lines 01–15'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.35\. search/default.go: 行 01–15'
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: On line 04 we declare a struct type named `defaultMatcher` using an empty struct.
    An empty struct allocates zero bytes when values of this type are created. They’re
    great when you need a type but not any state. For the default matcher, we don’t
    need to maintain any state; we only need to implement the interface.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 04 行，我们使用一个空的 struct 声明了一个名为 `defaultMatcher` 的 struct 类型。空的 struct 在创建此类类型的值时分配零字节。当你需要一个类型但不需要任何状态时，它们很棒。对于默认匹配器，我们不需要维护任何状态；我们只需要实现接口。
- en: On lines 13 through 15 you see the implementation of the `Matcher` interface
    by the `defaultMatcher` type. The implementation of the interface method `Search`
    just returns `nil` for both return values. Other implementations, such as the
    implementation for the RSS matcher, will implement the specific business rules
    for processing searches in their version of this method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 13 到 15 行，你可以看到 `defaultMatcher` 类型实现了 `Matcher` 接口。接口方法 `Search` 的实现只是对两个返回值都返回
    `nil`。其他实现，例如 RSS 匹配器的实现，将在这个方法的版本中实现特定的业务规则来处理搜索。
- en: The declaration of the `Search` method is declared with a value receiver of
    type `defaultMatcher`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Search` 方法的声明使用了一个类型为 `defaultMatcher` 的值接收者。'
- en: 'Listing 2.36\. search/default.go: line 13'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.36\. search/default.go: 行 13'
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The use of a receiver with any function declaration declares a method that’s
    bound to the specified receiver type. In our case, the declaration of the `Search`
    method is now bound to values of type `defaultMatcher`. This means we can call
    the method `Search` from values and pointers of type `defaultMatcher`. Whether
    we use a value or pointer of the receiver type to make the method call, the compiler
    will reference or dereference the value if necessary to support the call.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何函数声明中使用接收者声明了一个与指定接收者类型绑定的方法。在我们的例子中，`Search` 方法的声明现在绑定到了 `defaultMatcher`
    类型的值。这意味着我们可以从 `defaultMatcher` 类型的值和指针中调用 `Search` 方法。无论我们使用接收者类型的值还是指针来调用方法，编译器都会在必要时引用或取消引用值以支持调用。
- en: Listing 2.37\. Example of method calls
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.37\. 方法调用的示例
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It’s best practice to declare methods using pointer receivers, since many of
    the methods you implement need to manipulate the state of the value being used
    to make the method call. In the case of the `defaultMatcher` type, we want to
    use a value receiver because creating values of type `defaultMatcher` result in
    values of zero allocation. Using a pointer makes no sense since there’s no state
    to be manipulated.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指针接收者声明方法是一种最佳实践，因为许多你实现的方法需要操作用于方法调用的值的内部状态。在 `defaultMatcher` 类型的例子中，我们希望使用值接收者，因为创建
    `defaultMatcher` 类型的值会导致零分配。使用指针没有意义，因为没有要操作的状态。
- en: Unlike when you call methods directly from values and pointers, when you call
    a method via an interface type value, the rules are different. Methods declared
    with pointer receivers can only be called by interface type values that contain
    pointers. Methods declared with value receivers can be called by interface type
    values that contain both values and pointers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接从值和指针调用方法不同，当你通过接口类型值调用方法时，规则是不同的。具有指针接收器的声明的方法只能由包含指针的接口类型值调用。具有值接收器的声明的方法可以由包含值和指针的接口类型值调用。
- en: Listing 2.38\. Example of interface method call restrictions
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.38\. 接口方法调用限制示例
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There’s nothing else that the `defaultMatcher` type needs to do to implement
    the interface. From this point forward, values and pointers of type `defaultMatcher`
    satisfy the interface and can be used as values of type `Matcher`. That’s the
    key to making this work. Values and pointers of type `defaultMatcher` are now
    also values of type `Matcher` and can be assigned or passed to functions accepting
    values of type `Matcher`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultMatcher`类型不需要做任何事情来实现接口。从现在开始，类型为`defaultMatcher`的值和指针满足接口，可以用作类型`Matcher`的值。这是使这一切工作的关键。类型为`defaultMatcher`的值和指针现在也是类型`Matcher`的值，可以分配或传递给接受类型`Matcher`的值的函数。'
- en: Let’s look at the implementation of the `Match` function declared in the match.go
    code file. This is the function called by the `Run` function on line 39 in the
    search.go code file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在match.go代码文件中声明的`Match`函数的实现。这是在search.go代码文件的第39行由`Run`函数调用的函数。
- en: 'Listing 2.39\. search/match.go: lines 19–33'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.39\. search/match.go: 行19–33'
- en: '[PRE39]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is the function that performs the actual search using values or pointers
    that implement the `Matcher` interface. This function accepts values of type `Matcher`
    as the first parameter. Only values or pointers that implement the `Matcher` interface
    will be accepted for this parameter. Since the `defaultMatcher` type now implements
    the interface declared with a value receiver, values or pointers of type `defaultMatcher`
    can be passed into this function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用实现`Matcher`接口的值或指针执行实际搜索的函数。这个函数接受类型为`Matcher`的值作为第一个参数。只有实现`Matcher`接口的值或指针会被接受作为此参数。由于`defaultMatcher`类型现在实现了具有值接收器的接口，因此可以传递类型为`defaultMatcher`的值或指针到这个函数中。
- en: On line 23, the `Search` method is called from the `Matcher` type value that
    was passed into the function. Here the specific implementation of the `Search`
    method for the value assigned to the `Matcher` variable is executed. Once the
    `Search` method returns, the error value on line 24 is checked for an error. If
    there’s an error, the function writes the error to the log and returns. If the
    search doesn’t return an error and there are results, the results are written
    to the channel so that they can be picked up by the main function that’s listening
    on that channel.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第23行，从传递给函数的`Matcher`类型值中调用了`Search`方法。这里执行了分配给`Matcher`变量的`Search`方法的具体实现。一旦`Search`方法返回，就会检查第24行的错误值是否存在错误。如果有错误，函数将错误写入日志并返回。如果没有返回错误并且有结果，结果会被写入通道，以便它们可以被监听该通道的主函数获取。
- en: The final piece of code in match.go is the `Display` function that’s called
    by the `main` function on line 56\. This is the function preventing the program
    from terminating until all the results from the search goroutines are received
    and logged.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: match.go中的最后一部分代码是`Display`函数，它在main函数的第56行被调用。这是防止程序在收到并记录所有搜索goroutine的结果之前终止的函数。
- en: 'Listing 2.40\. search/match.go: lines 35–43'
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.40\. search/match.go: 行35–43'
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A bit of channel magic allows this function to process all of the results before
    returning. It’s based on how channels and the keyword `range` behaves when a channel
    is closed. Let’s briefly look at the code in the `Run` function again that closes
    the `results` channel and calls the `Display` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一点通道魔法允许这个函数在返回之前处理所有结果。它基于通道关闭时通道和关键字`range`的行为。让我们再次简要看看`Run`函数中的代码，该函数关闭`results`通道并调用`Display`函数。
- en: 'Listing 2.41\. search/search.go: lines 44–57'
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.41\. search/search.go: 行44–57'
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The goroutine on lines 45 through 52 waits on the `waitGroup` for all the search
    goroutines to call the `Done` method. Once the last search goroutine calls `Done`,
    the `Wait` method returns, and then the code on line 51 closes the `results` channel.
    Once the channel is closed, the goroutine terminates and is no more.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第45至52行的goroutine等待`waitGroup`，直到所有搜索goroutine调用`Done`方法。一旦最后一个搜索goroutine调用`Done`，`Wait`方法返回，然后第51行的代码关闭`results`通道。一旦通道关闭，goroutine终止，不再存在。
- en: You saw on lines 30 through 32 in the match.go code file where the search results
    were being written to the channel.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您在match.go代码文件的第30至32行看到了搜索结果被写入通道。
- en: 'Listing 2.42\. search/match.go: lines 29–32'
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.42\. search/match.go: 行29–32'
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we look back at the `for range` loop on lines 40 through 42 of the match.go
    code file, we can connect the writing of the results, the closing of the channel,
    and the processing of results all together.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾match.go代码文件的第40至42行的`for range`循环，我们可以将结果的写入、通道的关闭以及结果的处理全部联系起来。
- en: 'Listing 2.43\. search/match.go: lines 38–42'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.43\. search/match.go: 行38–42'
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `for range` loop on line 40 of the match.go code file will block until a
    result is written to the channel. As each search goroutine writes its results
    to the channel (as you see on line 31 of the code file match.go), the `for range`
    loop wakes up and is given those results. The results are then immediately written
    to the log. It seems this `for range` loop is stuck in an endless loop, but it
    isn’t. Once the channel is closed on line 51 of the search.go code file, the `for
    range` loop is terminated and the `Display` function returns.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: match.go代码文件第40行的`for range`循环将阻塞，直到通道中写入结果。随着每个搜索goroutine将结果写入通道（如代码文件match.go中的第31行所示），`for
    range`循环会唤醒并得到这些结果。然后，结果立即写入日志。这似乎表明`for range`循环陷入了一个无限循环，但实际上并非如此。一旦在search.go代码文件的第51行关闭通道，`for
    range`循环就会终止，`Display`函数返回。
- en: Before we look at the implementation of the RSS matcher, let’s review how the
    different matchers are initialized when the program starts. To see this we need
    to look back at lines 07 through 10 of the default.go code file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看RSS匹配器的实现之前，让我们回顾一下程序启动时不同匹配器的初始化方式。为了看到这一点，我们需要回顾默认的.go代码文件的第07至10行。
- en: 'Listing 2.44\. search/default.go: lines 06–10'
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.44\. search/default.go: 行06–10'
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The default.go code file has a special function declared called `init`. You
    saw this function also declared in the main.go code file, and we talked about
    how all the `init` functions in the program would be called before the `main`
    function begins. Let’s look at the imports again from the main.go code file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的.go代码文件中声明了一个特殊函数，称为`init`。您也曾在`main.go`代码文件中看到过这个函数的声明，我们讨论了程序中所有`init`函数在`main`函数开始之前会被调用的方式。让我们再次从`main.go`代码文件中查看导入。
- en: 'Listing 2.45\. main.go: lines 07–08'
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.45\. main.go: 行07–08'
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The import to the search package on line 08 allows the compiler to find the
    `init` function in the default.go code file. Once the compiler sees the `init`
    function, it’s scheduled to be called prior to the `main` function being called.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第08行的`search`包导入允许编译器在默认的.go代码文件中找到`init`函数。一旦编译器看到`init`函数，它就会被安排在调用`main`函数之前被调用。
- en: The `init` function in the default.go code file is performing a special task.
    It’s creating a value of the `defaultMatcher` type and passing that value to the
    `Register` function that can be found in the search.go code file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的.go代码文件中的`init`函数正在执行一个特殊任务。它正在创建一个`defaultMatcher`类型的值，并将该值传递给可以在`search.go`代码文件中找到的`Register`函数。
- en: 'Listing 2.46\. search/search.go: lines 59–67'
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.46\. search/search.go: 行59–67'
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function is responsible for adding the `Matcher` value to the map of registered
    matchers. All of this registration needs to happen before the `main` function
    gets called. Using `init` functions is a great way to accomplish this type of
    initialized registration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数负责将`Matcher`值添加到已注册匹配器的映射中。所有这些注册都需要在调用`main`函数之前完成。使用`init`函数是完成此类初始化注册的绝佳方式。
- en: 2.4\. RSS matcher
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. RSS匹配器
- en: The last piece of code to review is the implementation of the RSS matcher. Everything
    we’ve reviewed up to now was to allow the implementation of different matcher
    types to run and search content within the program’s framework. The structure
    of the RSS matcher is similar to the structure of the default matcher. It’s the
    implementation of the interface method `Search` that’s different and in the end
    gives each matcher its uniqueness.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要审查的代码是 RSS 匹配器的实现。到目前为止我们所审查的一切都是为了允许不同的匹配器类型在程序框架内运行和搜索内容。RSS 匹配器的结构类似于默认匹配器的结构。不同之处在于接口方法
    `Search` 的实现，最终为每个匹配器赋予其独特性。
- en: The RSS document in [listing 2.47](#ch02ex47) shows you a sample of what we
    expect to receive when we use any link in the data feed that’s typed as an RSS
    feed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.47](#ch02ex47) 中的 RSS 文档展示了当我们使用任何以 RSS 格式输入的数据源中的链接时，我们期望接收到的样本。'
- en: Listing 2.47\. Expected RSS feed document
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.47\. 预期 RSS 文档
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you take any link from [listing 2.47](#ch02ex47) and put it in a browser,
    you’ll be able to see a complete view of the expected RSS document. The implementation
    of the RSS matcher pulls down these RSS documents, searches the title and description
    fields for the search term, and sends the results over the `results` channel.
    Let’s start by looking at the first 12 lines of code for the rss.go code file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从 [列表 2.47](#ch02ex47) 中取任何链接并在浏览器中打开，你将能够看到预期 RSS 文档的完整视图。RSS 匹配器的实现会下载这些
    RSS 文档，搜索标题和描述字段中的搜索词，并通过 `results` 通道发送结果。让我们先看看 rss.go 代码文件的前 12 行代码。
- en: 'Listing 2.48\. matchers/rss.go: lines 01–12'
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.48\. matchers/rss.go: 行 01–12'
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As with every code file, we start on line 01 with the name of the package. This
    code file can be found in a folder called `matchers`, so the package name is `matchers`.
    Next we have six imports from the standard library and one import to the `search`
    package. Again, we have some packages from the standard library being imported
    from subfolders within the standard library, such as `xml` and `http`. Just like
    with the `json` package, the name of the last folder in the path represents the
    name of the package.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个代码文件一样，我们从第 01 行开始，写下包的名称。这个代码文件可以在名为 `matchers` 的文件夹中找到，因此包名是 `matchers`。接下来，我们有六个来自标准库的导入和一个到
    `search` 包的导入。同样，我们还有一些来自标准库的包是从标准库内的子文件夹导入的，例如 `xml` 和 `http`。就像对 `json` 包一样，路径中的最后一个文件夹的名称代表包的名称。
- en: There are four struct types that are used to decode the RSS document, so we
    can use the document data in our program.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种结构类型用于解码 RSS 文档，因此我们可以在程序中使用文档数据。
- en: 'Listing 2.49\. matchers/rss.go: lines 14–58'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.49\. matchers/rss.go: 行 14–58'
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you match these structures to the RSS document from any of the feed links,
    you’ll see how everything correlates. Decoding XML is identical to how we decoded
    JSON in the feed.go code file. Next we can look at the declaration of the `rssMatcher`
    type.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这些结构与任何来自 feed 链接的 RSS 文档进行匹配，你将看到它们是如何相互关联的。在 feed.go 代码文件中解码 XML 与我们解码
    JSON 的方式相同。接下来我们可以看看 `rssMatcher` 类型的声明。
- en: 'Listing 2.50\. matchers/rss.go: lines 60–61'
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.50\. matchers/rss.go: 行 60–61'
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again, this looks just like how we declared the `defaultMatcher` type. We use
    an empty struct since we don’t need to maintain any state; we just implement the
    `Matcher` interface. Next we have the implementation of the matcher `init` function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这就像我们声明 `defaultMatcher` 类型一样。我们使用一个空的 struct，因为我们不需要维护任何状态；我们只是实现了 `Matcher`
    接口。接下来是匹配器 `init` 函数的实现。
- en: 'Listing 2.51\. matchers/rss.go: lines 63–67'
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.51\. matchers/rss.go: 行 63–67'
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Just like you saw with the default matcher, the `init` function registers a
    value of the `rssMatcher` type with the program for use. Let’s look at the import
    in the main.go code file once more.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你看到默认匹配器一样，`init` 函数将 `rssMatcher` 类型的值注册到程序中以供使用。让我们再次看看 main.go 代码文件中的导入。
- en: 'Listing 2.52\. main.go: lines 07–08'
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 2.52\. main.go: 行 07–08'
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The code in the main.go code file doesn’t directly use any identifiers from
    the `matchers` package. Yet we need the compiler to schedule the call to the `init`
    function in the rss.go code file. On line 07 we accomplish this by using the blank
    identifier as the alias name for the import. This allows the compiler to not produce
    an error for declaring the import and to locate the `init` function. With all
    of the imports, types, and initialization set, let’s look at the two remaining
    methods that support the implementation of the `Matcher` interface.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`代码文件中的代码不直接使用`matchers`包中的任何标识符。然而，我们需要编译器在`rss.go`代码文件中调度对`init`函数的调用。在第07行，我们通过使用空标识符作为导入的别名名称来完成此操作。这允许编译器不产生导入声明错误，并定位到`init`函数。在设置完所有导入、类型和初始化后，让我们看看剩下的两个支持实现`Matcher`接口的方法。
- en: 'Listing 2.53\. matchers/rss.go: lines 114–140'
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.53\. matchers/rss.go: 行114–140'
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The unexported method `retrieve` performs the logic for pulling the RSS document
    from the web for each individual feed link. On line 121 you can see the use of
    the `Get` method from the `http` package. In [chapter 8](kindle_split_016.html#ch08)
    we’ll explore this package more, but for now Go makes it really easy to make web
    requests using the `http` package. When the `Get` method returns, we’ll get back
    a pointer to a value of type `Response`. After checking for errors, we need to
    schedule the call to the `Close` method, which we do on line 127.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 未导出的`retrieve`方法执行从网络中拉取每个单独的feed链接的RSS文档的逻辑。在第121行，你可以看到`http`包中`Get`方法的使用。在第8章（[kindle_split_016.html#ch08]）中，我们将更深入地探讨这个包，但到目前为止，Go使用`http`包使网络请求变得非常容易。当`Get`方法返回时，我们将得到一个指向`Response`类型值的指针。在检查错误后，我们需要调度对`Close`方法的调用，我们在第127行这样做。
- en: On line 131 we check the `StatusCode` field of the `Response` value to verify
    we received a `200`. Anything other than `200` must be handled as an error and
    we do just that. If the value isn’t `200`, we then return a custom error using
    the `Errorf` function from the `fmt` package. The last three lines of code are
    similar to how we decoded the JSON data file. This time we use the `xml` package
    and call the same function named `NewDecoder`, which returns a pointer to a `Decoder`
    value. With the pointer, we call the `Decode` method passing the address of the
    local variable named `document` of type `rssDocument`. Then the address to the
    `rssDocument` type value and the error from the `Decode` method call are returned.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在第131行，我们检查`Response`值的`StatusCode`字段，以验证我们收到了`200`。任何不是`200`的值都必须被视为错误，我们正是这样做的。如果值不是`200`，我们使用`fmt`包中的`Errorf`函数返回一个自定义错误。代码的最后三行与解码JSON数据文件的方式类似。这次我们使用`xml`包并调用名为`NewDecoder`的相同函数，它返回一个指向`Decoder`值的指针。有了这个指针，我们调用`Decode`方法，传递名为`document`的本地变量的地址，该变量是`rssDocument`类型。然后返回`rssDocument`类型值的地址和`Decode`方法调用的错误。
- en: The final method to look at implements the `Matcher` interface.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法实现了`Matcher`接口。
- en: 'Listing 2.54\. matchers/rss.go: lines 69–112'
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.54\. matchers/rss.go: 行69–112'
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We start on line 71 with the declaration of the `results` variable, which will
    be used to store and return any results that may be found.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第71行的`results`变量的声明开始，该变量将用于存储和返回可能找到的任何结果。
- en: 'Listing 2.55\. matchers/rss.go: line 71'
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.55\. matchers/rss.go: 行71'
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We use the keyword `var` and declare a `nil` slice of pointers to `Result` type
    values. The declaration of the `Result` type can be found again on line 08 of
    the match.go code file. Next on line 76 we make a web call using the `retrieve`
    method we just reviewed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用关键字`var`并声明一个指向`Result`类型值的`nil`切片。`Result`类型的声明可以在`match.go`代码文件的第08行再次找到。接下来在第76行，我们使用我们刚刚审查的`retrieve`方法进行网络调用。
- en: 'Listing 2.56\. matchers/rss.go: lines 75–79'
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.56\. matchers/rss.go: 行75–79'
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The call to the `retrieve` method returns a pointer to a value of type `rssDocument`
    and an error value. Then, as you’ve seen throughout the code, we check the error
    value for errors and return if there was an error. If no error exists, we then
    iterate through the results performing the match of the search term against the
    title and description of the retrieved RSS document.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对`retrieve`方法的调用返回一个指向`rssDocument`类型值的指针和一个错误值。然后，正如你在代码中看到的，我们检查错误值以查找错误，并在存在错误时返回。如果没有错误，我们接着遍历结果，将搜索词与检索到的RSS文档的标题和描述进行匹配。
- en: 'Listing 2.57\. matchers/rss.go: lines 81–86'
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表2.57\. matchers/rss.go: 行81–86'
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Since the value of `document.Channel.Item` is a slice of `item` type values,
    we use a `for range` loop on line 81 to iterate through all the items. On line
    83 we use the `MatchString` function from the `regexp` package to match the search
    term against the content in the `Title` field of the `channelItem` value. Then
    we check for errors on line 84\. If there are no errors, we move to lines 89 through
    94 to check the results of the match.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`document.Channel.Item`的值是`item`类型值的切片，我们在第81行使用`for range`循环遍历所有项目。在第83行，我们使用`regexp`包中的`MatchString`函数将搜索词与`channelItem`值中的`Title`字段内容进行匹配。然后我们在第84行检查错误。如果没有错误，我们转到第89行至第94行以检查匹配的结果。
- en: 'Listing 2.58\. matchers/rss.go: lines 88–94'
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.58. 匹配器/rss.go：第88-94行
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If the value of `matched` is `true` after the call to the `MatchString` method,
    we use the built-in function `append` to add the search results to the `results`
    slice. The built-in function `append` will grow the length and capacity of the
    slice as it needs to. You’ll learn more about the built-in function `append` in
    [chapter 4](kindle_split_012.html#ch04). The first parameter to `append` is the
    value of the slice you want to append to, and the second parameter is the value
    you want to append. In our case, we use a struct literal to declare and initialize
    a value of type `Result`, and then we use the ampersand (`&`) operator to get
    the address of this new value, which is stored in the slice.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`MatchString`方法后，如果`matched`的值为`true`，我们使用内置函数`append`将搜索结果添加到`results`切片中。内置函数`append`将在需要时增加切片的长度和容量。你将在第4章中了解更多关于内置函数`append`的信息。`append`的第一个参数是你想要附加的切片的值，第二个参数是你想要附加的值。在我们的情况下，我们使用结构字面量声明并初始化一个类型为`Result`的值，然后我们使用反引号（`&`）运算符获取这个新值的地址，该地址存储在切片中。
- en: After the title is checked for matches, lines 97 through 108 perform the same
    logic again for the description field. Finally, on line 111, the method returns
    the results to the calling function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 标题检查匹配后，第97行至第108行再次对描述字段执行相同的逻辑。最后，在第111行，该方法将结果返回给调用函数。
- en: 2.5\. Summary
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5. 摘要
- en: Every code file belongs to a package, and that package name should be the same
    as the folder the code file exists in.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个代码文件都属于一个包，并且该包名应该与代码文件所在的文件夹名称相同。
- en: Go provides several ways to declare and initialize variables. If the value of
    a variable isn’t explicitly initialized, the compiler will initialize the variable
    to its zero value.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go提供了多种声明和初始化变量的方式。如果一个变量的值没有明确初始化，编译器将变量初始化为其零值。
- en: Pointers are a way of sharing data across functions and goroutines.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针是跨函数和goroutine共享数据的一种方式。
- en: Concurrency and synchronization are accomplished by launching goroutines and
    using channels.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过启动goroutine和使用通道来实现并发和同步。
- en: Go provides built-in functions to support using Go’s internal data structures.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go提供了内置函数来支持使用Go的内部数据结构。
- en: The standard library contains many packages that will let you do some powerful
    things.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库包含许多包，这些包将允许你做一些强大的事情。
- en: Interfaces in Go allow you to write generic code and frameworks.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的接口允许你编写通用代码和框架。
