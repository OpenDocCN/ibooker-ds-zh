- en: Part 2\. Web development with Node
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2部分\. 使用Node进行Web开发
- en: 'Now you’re ready to learn about server-side development in more depth. Node
    has found an important niche outside server-side code: front-end build systems.
    In this part, you’ll learn how to start projects with webpack and Gulp. We’ll
    also introduce the most popular web frameworks and compare them from multiple
    developers’ perspectives to help you decide on the perfect framework for your
    projects.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好深入了解后端开发了。Node在服务器端代码之外找到了一个重要的细分市场：前端构建系统。在本部分中，你将学习如何使用webpack和Gulp开始项目。我们还将介绍最受欢迎的Web框架，并从多个开发者的角度进行比较，以帮助你决定适合你项目的最佳框架。
- en: If you want to learn in detail about Connect and Express, [chapter 6](kindle_split_017.xhtml#ch06)
    is entirely dedicated to building web applications with these modules. There’s
    also a chapter dedicated to templating and using databases with Node.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要详细了解Connect和Express，[第6章](kindle_split_017.xhtml#ch06)完全致力于使用这些模块构建Web应用程序。还有一个章节专门介绍模板和Node数据库的使用。
- en: To complete the journey of full-stack web development with Node, we’ve included
    chapters on testing and deployment, so you can prepare your first Node application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成使用Node进行全栈Web开发的旅程，我们包括了测试和部署章节，这样你就可以准备你的第一个Node应用程序。
- en: Chapter 4\. Front-end build systems
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章\. 前端构建系统
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Simplifying complex commands with npm scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用npm脚本简化复杂命令
- en: Using Gulp to manage repetitive tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Gulp管理重复性任务
- en: Bundling client-side web apps with webpack
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack打包客户端Web应用
- en: In modern web development, Node is increasingly used to run tools and services
    depended on by front-end engineers. As a Node programmer, you may be responsible
    for setting up and maintaining these tools. As a full-stack developer, you’ll
    want to use these tools to create faster and more reliable web applications. In
    this chapter, you’ll learn how to use npm scripts, Gulp, and webpack to build
    maintainable projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web开发中，Node越来越多地被用来运行前端工程师依赖的工具和服务。作为一个Node程序员，你可能负责设置和维护这些工具。作为一个全栈开发者，你将希望使用这些工具来创建更快、更可靠的Web应用程序。在本章中，你将学习如何使用npm脚本、Gulp和webpack构建可维护的项目。
- en: The benefits of using front-end build systems can be huge. They can help you
    to write more readable and future-proof code. There’s no need to worry about ES2015
    browser support when you can transpile it with Babel. Also, because you can generate
    source maps, browser-based debugging is still possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前端构建系统的益处可能很大。它们可以帮助你编写更易读和面向未来的代码。当你可以用Babel进行转译时，无需担心ES2015浏览器支持问题。此外，因为你可以生成源映射，基于浏览器的调试仍然可行。
- en: The next section provides a brief introduction to front-end development with
    Node. After that, you’ll see some examples of modern front-end technologies such
    as React that you can use with your own projects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节简要介绍了使用Node进行前端开发。之后，你将看到一些现代前端技术，如React的示例，你可以将其用于自己的项目。
- en: 4.1\. Understanding front-end development with Node
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 使用Node理解前端开发
- en: 'Recently, front-end and server-side developers have converged on using npm
    for distributing JavaScript. That means npm is used for front-end modules, such
    as React, and server-side code, such as Express. But some modules don’t neatly
    fall into either side: lodash is an example of a general-purpose library that
    can be used in Node and browsers. By packing lodash carefully, the same module
    can be consumed by Node and browsers, and the dependency within a project can
    be managed with npm.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，前端和后端开发者已经转向使用npm来分发JavaScript。这意味着npm被用于前端模块，如React，以及后端代码，如Express。但有些模块并不完全属于任何一方：lodash就是一个可以在Node和浏览器中使用的通用库的例子。通过精心打包lodash，相同的模块可以被Node和浏览器使用，并且可以在项目中使用npm管理依赖项。
- en: You may have seen other module systems dedicated to client-side development,
    such as Bower ([http://bower.io/](http://bower.io/)). You can still use these
    tools, but as a Node developer, you should consider using npm.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过其他专门针对客户端开发的模块系统，例如Bower ([http://bower.io/](http://bower.io/))。你仍然可以使用这些工具，但作为一个Node开发者，你应该考虑使用npm。
- en: Package distribution isn’t the only thing Node gets used for, however. Front-end
    developers are also increasingly dependent on tools for generating portable, backward-compatible
    JavaScript. Transpilers such as Babel ([https://babeljs.io/](https://babeljs.io/))
    are used to convert modern ES2015 into more widely supported ES5 code. Other tools
    include minifiers (for example, UglifyJS; [https://github.com/mishoo/UglifyJS](https://github.com/mishoo/UglifyJS))
    and linters (for example, ESLint, [http://eslint.org/](http://eslint.org/)) for
    verifying the correctness of your code before shipping it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Node不仅仅用于包分发。前端开发者也越来越依赖于生成可移植、向后兼容的JavaScript的工具。转换器，如Babel ([https://babeljs.io/](https://babeljs.io/))，用于将现代ES2015转换为更广泛支持的ES5代码。其他工具包括压缩器（例如，UglifyJS；[https://github.com/mishoo/UglifyJS](https://github.com/mishoo/UglifyJS)）和代码检查器（例如，ESLint，[http://eslint.org/](http://eslint.org/)），用于在发货前验证代码的正确性。
- en: Test runners are also often driven by Node. You can run the tests for UI code
    in a Node process, or use a Node script to drive tests that run in a browser.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器也通常由Node驱动。您可以在Node进程中运行UI代码的测试，或者使用Node脚本驱动在浏览器中运行的测试。
- en: It’s also typical to use these tools together. When you start juggling a transpiler,
    minifier, linter, and test runner, you’ll need a way to record how the build process
    works. Some projects use npm scripts; others use Gulp or webpack. You’ll look
    at all of these approaches in this chapter and see some related best practices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用这些工具也很典型。当您开始处理转换器、压缩器、代码检查器和测试运行器时，您需要记录构建过程的工作方式。一些项目使用npm脚本；其他项目使用Gulp或webpack。您将在本章中查看所有这些方法，并了解一些相关的最佳实践。
- en: 4.2\. Using npm to run scripts
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 使用npm运行脚本
- en: 'Node comes with npm, and npm has built-in features for running scripts. Therefore,
    you can rely on your collaborators or users being able to invoke commands such
    as `npm start` and `npm test`. To add your own command for npm start, you add
    it to the `scripts` property of your project’s package.json file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Node自带npm，npm具有运行脚本的内置功能。因此，您可以依赖您的合作者或用户能够调用`npm start`和`npm test`等命令。要为npm
    start添加自己的命令，您需要将其添加到项目package.json文件的`scripts`属性中：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Even if you don’t define `start`, `node server.js` is the default, so technically
    you can leave this blank if that’s all you need—just remember to create a file
    called server.js. Defining the `test` property is useful because you can include
    your test framework as a dependency and run it by typing `npm test`. Let’s say
    you’re using Mocha ([www.npmjs.com/package/mocha](http://www.npmjs.com/package/mocha))
    for tests, and you’ve installed it with `npm install --save-dev`. To avoid having
    to install Mocha globally, you can add the following statement to your package.json
    file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您没有定义`start`，`node server.js`也是默认的，所以技术上您可以留空，如果这就是您需要的所有内容——只需记住创建一个名为server.js的文件。定义`test`属性很有用，因为您可以将测试框架作为依赖项包含在内，并通过输入`npm
    test`来运行它。假设您正在使用Mocha ([www.npmjs.com/package/mocha](http://www.npmjs.com/package/mocha))
    进行测试，并且您已使用`npm install --save-dev`安装了它。为了避免全局安装Mocha，您可以将以下语句添加到您的package.json文件中：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice that in the previous example, arguments were passed to Mocha. You can
    also pass arguments when running npm scripts by using two hyphens:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的示例中，向Mocha传递了参数。您也可以通过使用两个短横线来在运行npm脚本时传递参数：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Table 4.1](#ch04table01) shows a breakdown of some of the available npm commands.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4.1](#ch04table01) 展示了部分可用的npm命令的分解。'
- en: Table 4.1\. npm commands
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.1\. npm命令
- en: '| Command | package.json property | Example uses |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | package.json属性 | 示例用法 |'
- en: '| --- | --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| start | scripts.start | Start a web application server or an Electron app.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 启动 | scripts.start | 启动Web应用服务器或Electron应用。|'
- en: '| stop | scripts.stop | Stop a web server. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 停止 | scripts.stop | 停止Web服务器。|'
- en: '| restart |   | Run stop and then restart. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 重启 |   | 运行停止然后重启。|'
- en: '| install, postinstall | scripts.install, scripts.postinstall | Run native
    build commands after a package is installed. Note that postinstall can be run
    only with npm **run** postinstall. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 安装, 安装后 | scripts.install, scripts.postinstall | 在安装包之后运行原生构建命令。注意，安装后只能在npm
    **run** postinstall下运行。|'
- en: More commands are available, including some for cleaning up packages before
    publishing them, and pre/post version commands for migrating between package versions.
    But for most web development tasks, `start` and `test` are the commands you want.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 更多命令可用，包括在发布前清理包的命令，以及迁移包版本的前/后版本命令。但对于大多数Web开发任务，`start`和`test`是您想要的命令。
- en: Plenty of tasks that you may want to define won’t fit into the supported command
    names. For example, let’s say you’re working on a simple project that’s written
    in ES2015 but you want to transpile it to ES5\. You can do this with `npm run`.
    In the next section, you’ll run through a tutorial that sets up a new project
    that can build ES2015 files.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要定义的大量任务可能不适合支持的命令名称。例如，假设你正在处理一个简单的项目，该项目是用 ES2015 编写的，但你希望将其转换为 ES5。你可以使用
    `npm run` 来做这件事。在下一节中，你将运行一个教程，设置一个新的项目，可以构建 ES2015 文件。
- en: 4.2.1\. Creating custom npm scripts
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.1\. 创建自定义 npm 脚本
- en: The `npm run` command, aliased from `npm run-script`, is used to define arbitrary
    scripts that are invoked with `npm run script-name`. Let’s see how to make one
    for building a client-side script with Babel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run` 命令，从 `npm run-script` 别名，用于定义任意脚本，通过 `npm run script-name` 调用。让我们看看如何创建一个使用
    Babel 构建客户端脚本的脚本。'
- en: 'Start by setting up a new project and installing the necessary dependencies:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置一个新的项目和安装必要的依赖项：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now you should have a new Node project with the basic Babel ES2015 tools and
    plugins. Next, open the package.json file and add a `babel` property under `scripts`.
    It should run the script that has been installed into the project’s `node_modules/.bin`
    folder:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一个新的 Node 项目，其中包含了基本的 Babel ES2015 工具和插件。接下来，打开 package.json 文件，并在 `scripts`
    下添加一个 `babel` 属性。它应该运行已安装到项目 `node_modules/.bin` 文件夹中的脚本：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s a sample file with ES2015 syntax that you can use; save it to browser.js:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用 ES2015 语法示例文件，你可以使用它；保存为 browser.js：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You’ll be able to test this by running `npm run babel`. If everything is configured
    correctly, you should now have a build folder with browser.js. Open browser.js
    to confirm that it’s indeed an ES5 file. It’s too long to print, so look for something
    like `var_createClass` near the top of the file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行 `npm run babel` 来测试这一点。如果一切配置正确，你现在应该有一个包含 browser.js 的构建文件夹。打开 browser.js
    以确认它确实是一个 ES5 文件。由于太长无法打印，所以请在文件顶部附近寻找类似 `var_createClass` 的内容。
- en: 'If this is all your project ever does when it builds, you could name it `build`
    instead of `babel` in the package.json file. But you can go a little further by
    adding UglifyJS as well:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目在构建时只做这些，你可以在 package.json 文件中将它命名为 `build` 而不是 `babel`。但你可以更进一步，添加 UglifyJS：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'UglifyJS can be invoked by using node_modules/.bin/uglifyjs, so add it to the
    package.json under `scripts` with the name `uglify`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 node_modules/.bin/uglifyjs 来调用 UglifyJS，所以将其添加到 package.json 中的 `scripts`
    部分，命名为 `uglify`：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you should be able to invoke `npm run uglify`. You can tie all of this
    together by combining both of these scripts. Add another `script` property called
    `build` that invokes both tasks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够调用 `npm run uglify`。你可以通过结合这两个脚本将所有这些整合在一起。添加另一个名为 `build` 的 `script`
    属性，它调用这两个任务：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Both scripts are run by typing `npm run build`. People on your team can now
    combine multiple front-end packaging tools by invoking this simple command. The
    reason this works is that Babel and UglifyJS can be run as command-line scripts,
    and both accept command-line arguments, so it’s easy to add them as one-liners
    to a package.json file. In the case of Babel, you can manage complex behavior
    by defining a .babelrc file, which you did earlier in this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 两个脚本都是通过输入 `npm run build` 来运行的。现在，你们团队的人可以通过调用这个简单的命令来组合多个前端打包工具。这样做的原因是 Babel
    和 UglifyJS 可以作为命令行脚本运行，并且它们都接受命令行参数，因此很容易将它们添加到 package.json 文件中的一行代码中。在 Babel
    的例子中，你可以通过定义一个 .babelrc 文件来管理复杂的行为，这在本章的早期部分你已经做过。
- en: 4.2.2\. Configuring front-end build tools
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.2.2\. 配置前端构建工具
- en: 'In general, you can configure front-end build tools in three ways when used
    with npm scripts:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当与 npm 脚本一起使用时，你可以通过三种方式配置前端构建工具：
- en: Specifying command-line arguments. For example, `./node_modules/.bin/uglify
    --source-map`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定命令行参数。例如，`./node_modules/.bin/uglify --source-map`。
- en: Creating a project-specific configuration file with options. This is often done
    for Babel and ESLint.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有选项的项目特定配置文件。这通常用于 Babel 和 ESLint。
- en: Adding configuration options to package.json. Babel supports this as well.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 package.json 中添加配置选项。Babel 也支持这一点。
- en: 'What if your build requirements have more steps, and include things like copying,
    concatenating, or moving files? You could create a shell script and invoke it
    with an npm script, but it may help your JavaScript-savvy collaborators if you
    use Java-Script. Many build systems provide JavaScript APIs for automating builds.
    In the next section, you’ll learn all about one such solution: Gulp.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的构建需求有更多步骤，包括复制、连接或移动文件等操作，你会怎么办？你可以创建一个 shell 脚本并通过 npm 脚本来调用它，但如果你使用 Java-Script，可能会帮助你的
    JavaScript 熟练的协作者。许多构建系统提供了用于自动化构建的 JavaScript API。在下一节中，你将了解这样一个解决方案：Gulp。
- en: 4.3\. Providing automation with Gulp
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 使用 Gulp 提供自动化
- en: '*Gulp* ([http://gulpjs.com/](http://gulpjs.com/)) is a build system based on
    streams. You can route streams together to create build processes that do more
    than just transpile or minify code. Imagine you have a project with an administration
    area that’s built with Angular, but you have a React-based public area; both subprojects
    share certain build requirements. With Gulp, you can reuse parts of the build
    process for each stage. [Figure 4.1](#ch04fig01) shows an example of these two
    build processes that share functionality.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gulp* ([http://gulpjs.com/](http://gulpjs.com/)) 是一个基于流的构建系统。你可以将流路由在一起来创建执行更多操作（不仅仅是转译或压缩代码）的构建过程。想象一下，你有一个使用
    Angular 构建的管理区域，但你有一个基于 React 的公共区域；这两个子项目共享某些构建需求。使用 Gulp，你可以为每个阶段重用构建过程的一部分。[图
    4.1](#ch04fig01) 展示了这两个共享功能的构建过程的示例。'
- en: Figure 4.1\. Two build processes that share functionality
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 两个共享功能的构建过程
- en: '![](Images/04fig01_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig01_alt.jpg)'
- en: 'Gulp helps you achieve a high level of reuse through two techniques: using
    plugins and defining your own build tasks. As the figure suggests, the build process
    is a stream, so you can pipe tasks and plugins through each other. For example,
    you can handle the React part of the previous example with Gulp Babel ([www.npmjs.com/package/gulp-babel/](http://www.npmjs.com/package/gulp-babel/))
    and the built-in gulp.src file globbing method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 通过两种技术帮助你实现高度的重用：使用插件和定义自己的构建任务。如图所示，构建过程是一个流，因此你可以将任务和插件通过彼此进行管道。例如，你可以使用
    Gulp Babel ([www.npmjs.com/package/gulp-babel/](http://www.npmjs.com/package/gulp-babel/))
    和内置的 gulp.src 文件 globbing 方法来处理上一个示例中的 React 部分：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can even add the concat stage to this chain quite easily. Before looking
    more closely at this syntax, let’s see how to set up a small Gulp project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以非常容易地将连接阶段添加到这个链中。在更仔细地查看这个语法之前，让我们看看如何设置一个小型 Gulp 项目。
- en: 4.3.1\. Adding Gulp to a project
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 将 Gulp 添加到项目中
- en: 'To add Gulp to a project, you need to install both the gulp-cli and gulp packages
    with npm. Most people install gulp-cli globally, so Gulp recipes can be run simply
    by typing `gulp`. Note that you should run `npm rm --global gulp` if you had previously
    installed the `gulp` package globally. In the next snippet, you install gulp-cli
    globally and create a new Node project that has a Gulp development dependency:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Gulp 添加到项目中，你需要使用 npm 安装 gulp-cli 和 gulp 包。大多数人会将 gulp-cli 全局安装，这样就可以简单地通过输入
    `gulp` 来运行 Gulp 脚本。请注意，如果你之前已经全局安装了 `gulp` 包，你应该运行 `npm rm --global gulp`。在下一个片段中，你将全局安装
    gulp-cli 并创建一个新的具有 Gulp 开发依赖项的 Node 项目：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next create a file called gulpfile.js:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建一个名为 gulpfile.js 的文件：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open the gulpfile. Now you’ll use Gulp to build a small React project. It’ll
    use gulp-babel ([www.npmjs.com/package/gulp-babel](http://www.npmjs.com/package/gulp-babel)),
    gulp-sourcemaps, and gulp-concat:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 gulpfile 文件。现在你将使用 Gulp 来构建一个小型 React 项目。它将使用 gulp-babel ([www.npmjs.com/package/gulp-babel](http://www.npmjs.com/package/gulp-babel))、gulp-sourcemaps
    和 gulp-concat：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember to use npm with `--save-dev` when you want to add Gulp plugins to a
    project. If you’re experimenting with new plugins and decide to remove them, you
    can use `npm uninstall --save-dev` to remove them from ./node_modules and update
    the project’s package.json file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在将 Gulp 插件添加到项目时使用 `--save-dev` 选项。如果你在尝试新的插件并决定移除它们，可以使用 `npm uninstall --save-dev`
    来从 ./node_modules 中移除它们，并更新项目的 package.json 文件。
- en: 4.3.2\. Creating and running Gulp tasks
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 创建和运行 Gulp 任务
- en: Creating Gulp tasks involves writing Node code with Gulp’s API in a file called
    gulpfile.js. Gulp’s API has methods for things like finding files and piping them
    through plugins that transform them in some way.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Gulp 任务涉及在名为 gulpfile.js 的文件中编写带有 Gulp API 的 Node 代码。Gulp 的 API 有用于查找文件并将它们通过以某种方式转换它们的插件进行管道的方法。
- en: 'To try this for yourself: Open gulpfile.js and set up a build task that uses
    gulp.src to find JSX files, Babel to process ES2015 and React, and then concat
    to join each file together, as shown in the following listing.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要亲自尝试：打开 gulpfile.js 并设置一个构建任务，使用 gulp.src 来查找 JSX 文件，使用 Babel 来处理 ES2015 和
    React，然后使用 concat 将每个文件连接起来，如下所示。
- en: Listing 4.1\. A gulpfile for ES2015 and React with Babel
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 使用 Babel 的 ES2015 和 React 的 gulpfile
- en: '![](Images/04lis01_alt.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04lis01_alt.jpg)'
- en: '[Listing 4.1](#ch04ex01) uses several Gulp plugins to capture, process, and
    write files. First you find all of the input files by using file globbing, and
    then you use the gulp-sourcemaps plugin to collect source-map metrics for client-side
    debugging. Notice that source maps require two stages: one to state that you want
    to use source maps, and another to write the source-map files. Meanwhile, gulp-babel
    is configured to process files with ES2015 and React.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.1](#ch04ex01) 使用了多个 Gulp 插件来捕获、处理和写入文件。首先，使用文件通配符找到所有输入文件，然后使用 gulp-sourcemaps
    插件收集客户端调试的源映射度量。请注意，源映射需要两个阶段：一个用于声明你想要使用源映射，另一个用于写入源映射文件。同时，gulp-babel 被配置为处理带有
    ES2015 和 React 的文件。'
- en: This Gulp task can be run by typing `gulp` in a terminal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Gulp 任务可以通过在终端中输入 `gulp` 来运行。
- en: In this example, all of the files are transformed by using a single plugin.
    It just so happens that Babel is transpiling React JSX code and converting ES2015
    to ES5\. Once that’s done, the files are concatenated using the gulp-concat plugin.
    Now that all of the transpiling is done, it’s safe to write the source maps, and
    the final build can be placed in the dist folder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有文件都通过使用单个插件进行转换。碰巧 Babel 正在转译 React JSX 代码并将 ES2015 转换为 ES5。一旦完成，文件就使用
    gulp-concat 插件进行连接。现在所有转译都已完成，可以安全地编写源映射，并将最终构建放置在 dist 文件夹中。
- en: 'You can try this gulpfile out by creating a JSX file named app/index.jsx. Here’s
    a simple JSX file that you can use to test Gulp:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个名为 app/index.jsx 的 JSX 文件来尝试这个 gulpfile。以下是一个简单的 JSX 文件，你可以用它来测试 Gulp：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Gulp makes it easy to express build stages in JavaScript, and by using `gulp.task()`,
    you can add your own tasks to this file. Tasks usually follow the same pattern:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 使得用 JavaScript 表达构建阶段变得容易，通过使用 `gulp.task()`，你可以向此文件添加自己的任务。任务通常遵循相同的模式：
- en: '***Source—*** Gather input files'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***源文件—*** 收集输入文件'
- en: '***Transpile—*** Pipe them through a plugin that transforms them'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***转译—*** 通过一个插件将它们转换'
- en: '***Concat—*** Pipe the files together to create a monolithic build'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***合并—*** 将文件连接起来创建一个单体构建'
- en: '***Output—*** Set a file destination or move the output files'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***输出—*** 设置文件目标或移动输出文件'
- en: 'In the previous example, `sourcemaps` is a special case because it requires
    two pipes: one for configuration and a final one to output the files. That makes
    sense because source maps depend on mapping the original line numbers to the transpiled
    build’s line numbers.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，`sourcemaps` 是一个特殊情况，因为它需要两个管道：一个用于配置，另一个用于输出文件。这是有道理的，因为源映射依赖于将原始行号映射到转译构建的行号。
- en: 4.3.3\. Watching for changes
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3\. 监视更改
- en: The last thing front-end developers want is a build/refresh cycle. The simplest
    way to streamline builds is to use a Gulp plugin to watch the filesystem for changes.
    But alternatives exist. Some libraries work well with hot reloading, and more-generic
    DOM and CSS-based projects can work well with the LiveReload ([http://livereload.com/](http://livereload.com/))
    project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发者最不想看到的就是构建/刷新周期。简化构建的最简单方法就是使用 Gulp 插件来监视文件系统中的更改。但还有其他选择。一些库与热重载配合得很好，而更通用的基于
    DOM 和 CSS 的项目也可以与 LiveReload ([http://livereload.com/](http://livereload.com/))
    项目很好地工作。
- en: 'As an example, you can add gulp-watch ([www.npmjs.com/package/gulp-watch](http://www.npmjs.com/package/gulp-watch))
    to the previous project in [listing 4.1](#ch04ex01). Add the package to the project:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以在 [列表 4.1](#ch04ex01) 中的上一个项目中添加 gulp-watch ([www.npmjs.com/package/gulp-watch](http://www.npmjs.com/package/gulp-watch))。将包添加到项目中：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now remember to load the package in gulpfile.js:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请记住在 gulpfile.js 中加载该包：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And add a watch task that calls the default task from the previous example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 并添加一个监视任务，调用上一个示例中的默认任务：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This defines a task called `watch`, and then uses `watch()` to watch React JSX
    files for changes. Whenever a file changes, the default build task will run. With
    minor modifications, this recipe could be used to build Syntactically Awesome
    Style Sheets (SASS) files, optimize images, or pretty much anything else you might
    need for front-end projects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为 `watch` 的任务，然后使用 `watch()` 来监视 React JSX 文件的变化。每当文件发生变化时，默认的构建任务就会运行。经过一些小的修改，这个配方可以用来构建
    Syntactically Awesome Style Sheets (SASS) 文件，优化图像，或者几乎任何你可能需要的用于前端项目的东西。
- en: 4.3.4\. Using separate files for larger projects
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.4\. 为大型项目使用单独的文件
- en: 'As projects grow, they tend to need more Gulp tasks. Eventually, you’ll end
    up with a long file that’s hard to understand. You can fix this, however: break
    up your code into separate modules.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的增长，它们往往需要更多的 Gulp 任务。最终，你可能会得到一个难以理解的冗长文件。然而，你可以这样做：将你的代码拆分成单独的模块。
- en: 'As you’ve seen, Gulp uses Node’s module system for loading plugins. There’s
    no special plugin-loading system; it just uses standard modules. You can also
    use Node’s module system to split up long gulpfiles, to make your files more maintainable.
    To use separate files, you need to follow these steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Gulp 使用 Node 的模块系统来加载插件。没有特殊的插件加载系统；它只是使用标准模块。你也可以使用 Node 的模块系统来拆分长的 gulpfiles，使你的文件更易于维护。要使用单独的文件，你需要遵循以下步骤：
- en: Create a folder called gulp, and a subfolder called tasks.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 gulp 的文件夹，以及一个名为 tasks 的子文件夹。
- en: Define your tasks by using the usual `gulp.task()` syntax in separate files.
    One file per task is a good rule of thumb.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在单独的文件中使用常规的 `gulp.task()` 语法来定义你的任务。每个任务一个文件是一个很好的经验法则。
- en: Create a file called gulp/index.js to require each Gulp task file.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 gulp/index.js 的文件，用于引入每个 Gulp 任务文件。
- en: Require the gulp/index.js file in gulpfile.js.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 gulpfile.js 中引入 gulp/index.js 文件。
- en: 'The file tree should look like the following snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 文件树应该看起来像以下片段：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This technique can help you organize projects with complex build tasks, but
    it can also be paired with the gulp-help ([www.npmjs.com/package/gulp-help](http://www.npmjs.com/package/gulp-help))
    module. This module allows you to document Gulp tasks; running `gulp help` shows
    information about each task. This helps when you’re working in a team, or if you
    switch between lots of projects that use Gulp. [Figure 4.2](#ch04fig02) shows
    what the output looks like.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以帮助你组织具有复杂构建任务的项目，但它也可以与 gulp-help ([www.npmjs.com/package/gulp-help](http://www.npmjs.com/package/gulp-help))
    模块结合使用。此模块允许你记录 Gulp 任务；运行 `gulp help` 会显示每个任务的信息。当你在一个团队中工作，或者在不同使用 Gulp 的众多项目之间切换时，这很有帮助。[图
    4.2](#ch04fig02) 展示了输出看起来像什么。
- en: Figure 4.2\. Sample gulp-help output
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 示例 gulp-help 输出
- en: '![](Images/04fig02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig02.jpg)'
- en: Gulp is a general-purpose project-automation tool. It’s good when adding cross--platform
    housekeeping scripts to projects—for example, running complex client-side tests
    or bringing up fixtures for a database. Although it can be used for building client-side
    assets, there are also tools specifically designed to do that, which means they
    typically require less code and configuration than Gulp. One such tool is webpack,
    which focuses on bundling JavaScript and CSS modules. The next section demonstrates
    how to use webpack for a React project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 是一个通用的项目自动化工具。当向项目中添加跨平台的维护脚本时很好——例如，运行复杂的客户端测试或为数据库提供固定值。尽管它可以用于构建客户端资源，但也有专门为此目的设计的工具，这意味着它们通常比
    Gulp 需要更少的代码和配置。其中一个这样的工具是 webpack，它专注于打包 JavaScript 和 CSS 模块。下一节将演示如何为 React
    项目使用 webpack。
- en: 4.4\. Building web apps with webpack
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 使用 webpack 构建 web 应用程序
- en: 'webpack is specifically designed to build web applications. Imagine that you’re
    working with a designer who has already created a static site for a single-page
    web app, and you want to adapt it to build more-efficient CSS and ES2015 JavaScript.
    With Gulp, you write JavaScript code to drive the build system, so this would
    involve writing a gulpfile and several build tasks. With webpack, you write a
    configuration file and then bring in new functionality by using plugins and loaders.
    In some cases, no extra configuration is required: you type `webpack` on the command-line
    with an argument for the source-file path, and it’ll build your project. Skip
    to [section 4.4.4](#ch04lev2sec10) to see what this looks like.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 是专门为构建 Web 应用程序而设计的。想象一下，你正在与一个已经为单页 Web 应用程序创建了一个静态站点的设计师合作，你想要将其调整为构建更高效的
    CSS 和 ES2015 JavaScript。使用 Gulp，你编写 JavaScript 代码来驱动构建系统，因此这将涉及编写 gulpfile 和几个构建任务。使用
    webpack，你编写一个配置文件，然后通过使用插件和加载器引入新的功能。在某些情况下，不需要额外的配置：你只需在命令行上输入 `webpack` 并指定源文件路径的参数，它就会构建你的项目。跳转到
    [章节 4.4.4](#ch04lev2sec10) 以查看其外观。
- en: One of the advantages of webpack is that it’s easier to quickly set up a build
    system that supports incremental builds. If you set it up to automatically build
    when files change, it won’t need to rebuild the entire project when a single file
    changes. As a result, builds can be faster and easier to understand.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 的一大优点是它更容易快速设置一个支持增量构建的构建系统。如果你将其设置为在文件更改时自动构建，那么在单个文件更改时，它不需要重新构建整个项目。因此，构建可以更快且更容易理解。
- en: This section shows you how to use webpack for a small React project. First,
    let’s define the terminology webpack uses.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何使用 webpack 为一个小型 React 项目。首先，让我们定义 webpack 使用的术语。
- en: 4.4.1\. Using bundles and plugins
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.1\. 使用包和插件
- en: Before setting up a webpack project, some terminology should be clarified. webpack
    plugins are used to change the behavior of the build process. This can include
    things like automatically uploading assets to Amazon S3 ([https://github.com/MikaAK/s3-plugin-webpack](https://github.com/MikaAK/s3-plugin-webpack))
    or removing duplicated files from the output.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 webpack 项目之前，应该明确一些术语。webpack 插件用于改变构建过程的行为。这可以包括自动将资源上传到 Amazon S3 ([https://github.com/MikaAK/s3-plugin-webpack](https://github.com/MikaAK/s3-plugin-webpack))
    或从输出中删除重复文件。
- en: In contrast to plugins, loaders are transformations that are applied to resource
    files. If you need to convert SASS to CSS, or ES2015 to ES5, you need a loader.
    *Loaders* are functions that transform input source text into output. They can
    be asynchronous or synchronous. Plugins are instances of classes that can hook
    into webpack’s more low-level APIs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与插件不同，加载器是对资源文件应用的转换。如果你需要将 SASS 转换为 CSS，或将 ES2015 转换为 ES5，你需要一个加载器。*加载器*是函数，将输入源文本转换为输出。它们可以是异步的或同步的。插件是类的实例，可以钩入
    webpack 的更底层 API。
- en: If you need to convert React code, CoffeeScript, SASS, or any other transpiled
    languages, you’re looking for a *loader*. If you need to instrument your JavaScript,
    or manipulate sets of files in some way, you’ll need a *plugin*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要转换 React 代码、CoffeeScript、SASS 或任何其他转译语言，你正在寻找一个 *loader*。如果你需要对你的 JavaScript
    进行检测，或者以某种方式操作文件集，你需要一个 *plugin*。
- en: In the next section you’ll see how to use the Babel loader to convert a React
    ES2015 project to a browser-friendly bundle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到如何使用 Babel 加载器将 React ES2015 项目转换为浏览器友好的包。
- en: 4.4.2\. Configuring and running webpack
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.2\. 配置和运行 webpack
- en: 'You’re going to re-create the React example from [listing 4.1](#ch04ex01) by
    using webpack. To get started, install React in a new project:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过使用 webpack 重新创建 [列表 4.1](#ch04ex01) 中的 React 示例。要开始，在一个新项目中安装 React：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last line installs Babel’s ES2015 plugin and the React transformer for Babel.
    Now you need to make a file called webpack.config.js that instructs webpack on
    where to find the input file, where to write the output, and what loaders to use.
    You’re going to use babel-loader with some extra settings for React, as shown
    in the next listing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行安装了 Babel 的 ES2015 插件和 React 转换器。现在你需要创建一个名为 webpack.config.js 的文件，该文件指导
    webpack 在哪里找到输入文件，在哪里写入输出，以及使用哪些加载器。你将使用带有一些额外设置的 babel-loader，如下一列表所示。
- en: Listing 4.2\. A webpack.config.js file
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. webpack.config.js 文件
- en: '![](Images/04lis02_alt.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4.2](Images/04lis02_alt.jpg)'
- en: 'This configuration file encapsulates everything you need to successfully build
    a React app with ES2015\. The settings are easy to follow: define an `entry`,
    which is the main file that loads the application. Then specify the directory
    where the output should be written; this directory will be created if it doesn’t
    yet exist. Next, define a loader and associate it with a file glob search by using
    the `test` property. Finally, make sure to set any options for the loader. In
    this example, these options load the ES2015 and React Babel plugins.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件封装了你成功构建一个使用 ES2015 的 React 应用的所有必需内容。设置非常简单：定义一个 `entry`，这是加载应用程序的主要文件。然后指定输出应该写入的目录；如果该目录尚不存在，则会创建它。接下来，定义一个
    loader 并通过使用 `test` 属性将其与文件 glob 搜索关联起来。最后，确保为 loader 设置任何选项。在这个例子中，这些选项加载了 ES2015
    和 React Babel 插件。
- en: You need to include a sample React JSX file in app/index.jsx; use the snippet
    from [section 4.3.2](#ch04lev2sec4). Now running ./node_modules/.bin/webpack will
    compile an ES5 version of the file with the React dependencies.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在 app/index.jsx 中包含一个示例 React JSX 文件；使用 [第 4.3.2 节](#ch04lev2sec4) 中的片段。现在运行
    ./node_modules/.bin/webpack 将编译一个带有 React 依赖项的 ES5 版本的文件。
- en: 4.4.3\. Using webpack development server
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.3\. 使用 webpack 开发服务器
- en: If you want to avoid having to rebuild the project whenever a React file changes,
    you can use the webpack development server ([http://webpack.github.io/docs/webpack-dev-server.html](http://webpack.github.io/docs/webpack-dev-server.html)).
    In the book’s source code, this can be found under webpack--hotload-example (ch04-front-end/webpack-hotload-example).
    This small Express server will run webpack with your webpack configuration file
    when files change, and then serve the changed assets to the browser. You should
    run it on a different port to your main web server, and this means your script
    tags will have to include different URLs during development. The server builds
    assets and stores them in memory rather than in your webpack output folder. You
    can also use webpack-dev-server for hot module loading, in a similar way to LiveReload
    servers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要避免每次 React 文件更改时都重新构建项目，你可以使用 webpack 开发服务器 ([http://webpack.github.io/docs/webpack-dev-server.html](http://webpack.github.io/docs/webpack-dev-server.html))。在本书的源代码中，这可以在
    webpack--hotload-example (ch04-front-end/webpack-hotload-example) 下找到。这个小 Express
    服务器会在文件更改时运行 webpack 与你的 webpack 配置文件，然后向浏览器提供更改后的资源。你应该在主 Web 服务器之外的不同端口上运行它，这意味着你的脚本标签在开发期间将包含不同的
    URL。服务器构建资源并将它们存储在内存中，而不是在你的 webpack 输出文件夹中。你还可以使用 webpack-dev-server 进行热模块加载，类似于
    LiveReload 服务器。
- en: 'To add webpack-dev-server to a project, follow these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 webpack-dev-server 添加到项目中，请按照以下步骤操作：
- en: Install webpack-dev-server with `npm i --save-dev webpack-dev-server@ 1.14.1`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm i --save-dev webpack-dev-server@1.14.1` 安装 webpack-dev-server。
- en: Add a `publicPath` option to the `output` property in webpack.config.js.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 webpack.config.js 的 `output` 属性中添加一个 `publicPath` 选项。
- en: Add an index.html file to your build directory to act as a harness to load your
    JavaScript and CSS bundles. Ensure that the port is the port specified in the
    next step.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个 index.html 文件添加到你的构建目录中，作为加载你的 JavaScript 和 CSS 打包文件的 harness。确保端口与下一步指定的端口相同。
- en: Run the server with the options you want. For example, `webpack-dev-server --hot
    --inline --content-base dist/ --port 3001`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你想要的选项运行服务器。例如，`webpack-dev-server --hot --inline --content-base dist/ --port
    3001`。
- en: Visit http://localhost:3001/ and load the app.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 http://localhost:3001/ 并加载应用程序。
- en: 'Open webpack.config.js from [listing 4.2](#ch04ex02) and change the `output`
    property to include a `publicPath`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [列表 4.2](#ch04ex02) 打开 webpack.config.js 并将 `output` 属性更改为包含 `publicPath`：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create a new file called dist/index.html, as shown in the next listing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 dist/index.html 的新文件，如下所示。
- en: Listing 4.3\. An example HTML template for a React web app
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 一个 React 网络应用的示例 HTML 模板
- en: '![](Images/04lis03_alt.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/04lis03_alt.jpg)'
- en: 'Next open package.json and add the command that runs the webpack server under
    the `scripts` property:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来打开 package.json 并在 `scripts` 属性下添加运行 webpack 服务器的命令：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `--hot` option makes the dev server use hot module reloading. If you edit
    the example React file in app/index.jsx, you should see the browser refresh. The
    refresh mechanism is specified with the `--inline` option. Inline refresh means
    the dev server will inject code to manage refreshing the bundle. There’s also
    an iframe version that wraps the entire page in an iframe.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`--hot` 选项使开发服务器使用热模块重新加载。如果你编辑 app/index.jsx 中的示例 React 文件，你应该看到浏览器刷新。刷新机制由
    `--inline` 选项指定。内联刷新意味着开发服务器将注入代码来管理刷新包。还有一个 iframe 版本，它将整个页面包裹在一个 iframe 中。'
- en: 'Now run the dev server:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行开发服务器：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Running the webpack development server will trigger the build and start a server
    listening on port 3001\. You can test everything by going to http://localhost:3001
    in a browser.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 webpack 开发服务器将触发构建并启动一个监听 3001 端口的服务器。你可以在浏览器中通过访问 http://localhost:3001
    来测试一切。
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Hot reloading**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**热重载**'
- en: Because of React and other frameworks including AngularJS, there are framework-specific
    hot module reloading projects. Some take into account data-flow frameworks such
    as Redux and Relay, which means code can be refreshed while the current state
    is maintained. This is the ideal way to perform code reloading, because you don’t
    have to keep running through steps to re-create the UI state that you’re working
    on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 React 和其他框架（包括 AngularJS），存在针对特定框架的热模块重载项目。一些考虑了数据流框架，如 Redux 和 Relay，这意味着可以在保持当前状态的同时刷新代码。这是执行代码重载的理想方式，因为你不需要重复执行步骤来重新创建你正在工作的
    UI 状态。
- en: The example we’ve given you here, however, is less React-specific and is a good
    way to get you started with webpack dev servers. Be sure to experiment to find
    the best option for your project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这里提供的示例不那么特定于 React，并且是开始使用 webpack 开发服务器的好方法。务必进行实验，以找到最适合你项目的选项。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.4.4\. Loading CommonJS modules and assets
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.4.4\. 加载 CommonJS 模块和资源
- en: We’ve been using React and Babel in this chapter, but if you’re using webpack
    with a more vanilla, CommonJS project, then webpack can provide everything you
    need without a CommonJS browser shim. It’s even capable of loading CSS files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中使用了 React 和 Babel，但如果你使用 webpack 与更纯净的 CommonJS 项目一起使用，那么 webpack 可以提供你需要的一切，无需
    CommonJS 浏览器补丁。它甚至能够加载 CSS 文件。
- en: webpack and CommonJS
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: webpack 和 CommonJS
- en: 'To use CommonJS module syntax with webpack, you don’t need to set anything
    up. Let’s say you have a file that uses `require`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 webpack 中使用 CommonJS 模块语法，你不需要进行任何设置。假设你有一个使用 `require` 的文件：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And another that defines the `hello` function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个定义了 `hello` 函数的文件：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then you need only a small webpack config file to define the entry point (the
    first snippet), and the build destination path:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你只需要一个小的 webpack 配置文件来定义入口点（第一个代码片段）和构建目标路径：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This example clarifies how different Gulp and webpack are. webpack is entirely
    focused on building bundles, and as part of that, is capable of generating bundles
    with CommonJS shims. If you open dist/bundle.js, you’ll see the `webpackBootstrap`
    shim at the top of the file, and then each file from the original source tree
    is wrapped in closures to simulate the module system. The following snippet is
    part of the bundle:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了 Gulp 和 webpack 的不同之处。webpack 完全专注于构建包，作为其中的一部分，能够生成带有 CommonJS 补丁的包。如果你打开
    dist/bundle.js，你会在文件顶部看到 `webpackBootstrap` 补丁，然后每个原始源树中的文件都被封装在闭包中以模拟模块系统。以下代码片段是包的一部分：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The code comments show where the modules are defined, and the files have access
    to `module` and `exports` objects as arguments to their closures to simulate the
    CommonJS module API.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 代码注释显示了模块的定义位置，文件通过其闭包的参数访问 `module` 和 `exports` 对象，以模拟 CommonJS 模块 API。
- en: Using npm packages with webpack
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 webpack 包含 npm 包
- en: 'You can take this a step further by including modules downloaded from npm.
    Let’s say you want to use jQuery. Rather than making it a `script` tag on the
    page, you can install it with `npm i --save-dev jquery`, and then load it just
    like a Node module:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过包含从 npm 下载的模块来进一步操作。假设你想使用 jQuery。你不必在页面上创建一个 `script` 标签，而是可以使用 `npm i
    --save-dev jquery` 安装它，然后就像加载 Node 模块一样加载它：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That means webpack gives you CommonJS modules and access to modules from npm
    out of the box without any additional configuration!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 webpack 默认为你提供 CommonJS 模块和访问 npm 模块的能力，无需任何额外配置！
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Finding loaders and plugins**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找加载器和插件**'
- en: The webpack website has a list of loaders ([https://webpack.github.io/docs/list-of-loaders.html](https://webpack.github.io/docs/list-of-loaders.html))
    and plugins ([https://webpack.github.io/docs/list-of-plugins.html](https://webpack.github.io/docs/list-of-plugins.html)).
    You can also find webpack tools on npm; the `webpack` keyword is a good place
    to start ([www.npmjs.com/browse/keyword/webpack](http://www.npmjs.com/browse/keyword/webpack)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: webpack 网站有一个加载器列表（[https://webpack.github.io/docs/list-of-loaders.html](https://webpack.github.io/docs/list-of-loaders.html)）和插件列表（[https://webpack.github.io/docs/list-of-plugins.html](https://webpack.github.io/docs/list-of-plugins.html)）。你还可以在
    npm 上找到 webpack 工具；`webpack` 关键字是一个不错的起点（[www.npmjs.com/browse/keyword/webpack](http://www.npmjs.com/browse/keyword/webpack)）。
- en: '|  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.5\. Summary
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 摘要
- en: If you need to automate simple tasks or invoke scripts, npm scripts are perfect.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要自动化简单的任务或调用脚本，npm脚本非常完美。
- en: Gulp can be used to write more-complex tasks with JavaScript and is cross--platform.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gulp可以用JavaScript编写更复杂的任务，并且是跨平台的。
- en: When gulpfiles get too long, you can divide the code into separate files.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当gulp文件过长时，你可以将代码分成单独的文件。
- en: webpack can be used to generate client-side bundles.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webpack可以用来生成客户端包。
- en: If you just need to build a client-side bundle, using webpack might be less
    work than setting up the equivalent script with Gulp.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只需要构建客户端包，使用webpack可能比设置等效的Gulp脚本要简单。
- en: webpack supports hot module reloading, which means you’ll see code changes without
    refreshing your browser.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webpack支持热模块重新加载，这意味着你将看到代码更改而无需刷新浏览器。
- en: Chapter 5\. Server-side frameworks
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 服务器端框架
- en: '*This chapter covers*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Working with popular Node web frameworks
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与流行的Node Web框架一起工作
- en: Choosing the right framework
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的框架
- en: Building web apps with web frameworks
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Web框架构建Web应用程序
- en: This chapter is all about server-side web development. It answers questions
    including how do I choose the perfect framework for a given project, and what
    are the advantages and disadvantages of each framework?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这章全部关于服务器端Web开发。它回答了诸如我如何为特定项目选择完美的框架，以及每个框架的优缺点是什么等问题？
- en: Deciding on the right framework is difficult because it’s hard to compare them
    on a level playing field. Most people don’t have time to learn all of them, so
    we tend to make superficial decisions about the frameworks we have experience
    with. In some cases, you might use different frameworks together. Express, for
    instance, could be used for larger applications, whereas microservices that support
    larger applications could be written in hapi.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的框架很困难，因为很难在公平的竞争环境中比较它们。大多数人没有时间学习所有这些框架，所以我们往往只对那些我们有经验的框架做出肤浅的决定。在某些情况下，你可能会同时使用不同的框架。例如，Express可以用于大型应用程序，而支持大型应用程序的微服务可以编写在hapi中。
- en: 'Imagine you’re building a content management system (CMS). It’s used to manage
    legal documents collected by a research firm. It can output PDFs and has an e-commerce
    component. Such a system could be built with separate frameworks as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在构建一个内容管理系统（CMS）。它用于管理由研究公司收集的法律文件。它可以输出PDF，并具有电子商务组件。这样的系统可以用以下方式使用单独的框架构建：
- en: '***Document upload, download, and reading—*** Express'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***文档上传、下载和阅读——*** Express'
- en: '*PDF generator microservice—*hapi'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PDF生成微服务——*hapi'
- en: '***E-commerce component—*** Sails.js'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***电子商务组件——*** Sails.js'
- en: The perfect framework for a given project is dependent on the needs of the project
    and the team working on it. In this chapter, we use personas—hypothetical people—as
    a way of exploring which framework is right for a specific type of project. You’ll
    learn about Koa, hapi, Sails.js, DerbyJS, Flatiron, and LoopBack through these
    imaginary programmers. The personas are defined in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定项目，完美的框架取决于项目的需求和团队的需求。在本章中，我们使用角色——假设的人——作为一种探索特定类型项目适合哪种框架的方式。通过这些虚构的程序员，你将了解Koa、hapi、Sails.js、DerbyJS、Flatiron和LoopBack。角色在下一节中定义。
- en: 5.1\. Personas
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 角色
- en: We want to avoid selling a single framework that you’ll use for every project.
    It’s much better to be eclectic and use a mix of tools that suit each problem.
    Using personas to think about design is a widespread practice, in part because
    it helps designers to empathize with users.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想推销一个你将在每个项目中使用的单一框架。更好的做法是多样化，使用适合每个问题的工具组合。使用角色来思考设计是一种普遍的做法，部分原因是因为它有助于设计师与用户产生共鸣。
- en: In this chapter, personas are used to help you to think about frameworks in
    the third person, to see how different classes of projects suit different solutions.
    The personas are defined in terms of professional situation and development tools.
    You should be able to identify with at least one of the three people we’ve invented
    here.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，角色被用来帮助你从第三人称的角度思考框架，看看不同类别的项目适合不同的解决方案。角色是根据专业情况和开发工具来定义的。你应该能够与我们这里创造的三个角色中的至少一个产生共鸣。
- en: '5.1.1\. Phil: agency developer'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. Phil：代理开发者
- en: 'Phil has been working for three years as a full-stack web developer. He’s done
    a little Ruby, Python, and client-side JavaScript:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Phil作为一名全栈Web开发者工作了三年。他做过一点Ruby、Python和客户端JavaScript：
- en: '***Job situation—*** Employee, full-stack developer'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工作情况——*** 员工，全栈开发者'
- en: '***Work type—*** Front-end engineering, server-side development'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工作类型—*** 前端工程，服务器端开发'
- en: '***Computer—*** MacBook Pro'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***计算机—*** MacBook Pro'
- en: '***Tools—*** Sublime Text, Dash, xScope, Pixelmator, Sketch, GitHub'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工具—*** Sublime Text, Dash, xScope, Pixelmator, Sketch, GitHub'
- en: '***Background—*** High school education; started as a hobbyist programmer'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***背景—*** 高中教育；最初是一名业余程序员'
- en: A typical day for Phil involves working with designers and user-experience experts
    in agile-style meetings to develop or review new features, as well as maintenance
    and bug fixes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Phil 的典型一天涉及与设计师和用户体验专家在敏捷风格的会议中一起开发或审查新功能，以及维护和错误修复。
- en: '5.1.2\. Nadine: open source developer'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. Nadine：开源开发者
- en: 'Nadine moved to contracting after a successful early career working as a corporate
    web developer:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Nadine 在作为企业级网络开发者成功起步后转向了合同工：
- en: '***Job situation—*** Contractor, JavaScript specialist'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工作情况—*** 合同工，JavaScript 专家'
- en: '***Work type—*** Server-side programming, occasional high-performance programming
    in Go and Erlang. Also writes a popular open source, web-based movie catalog app'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工作类型—*** 服务器端编程，偶尔使用 Go 和 Erlang 进行高性能编程。还编写了一个流行的开源、基于 Web 的电影目录应用程序'
- en: '***Computer—*** High-end PC, Linux'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***计算机—*** 高端 PC，Linux'
- en: '***Tools—*** Vim, tmux, Mercurial, anything in the shell'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工具—*** Vim, tmux, Mercurial, shell 中的任何东西'
- en: Background—Computer science degree
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景—计算机科学学位
- en: Nadine’s day usually involves balancing clocking enough hours for her two major
    clients with working on her open source projects. Her client work is test-driven,
    but her open source projects are more feature-driven.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Nadine 的一天通常涉及在为她的两个主要客户工作足够的时间与从事她的开源项目之间取得平衡。她的客户工作是以测试驱动的，但她的开源项目更注重功能驱动。
- en: '5.1.3\. Alice: product developer'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3\. Alice：产品开发者
- en: 'Alice works on a successful iOS app but also helps with her company’s web APIs:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 在一个成功的 iOS 应用程序上工作，同时也帮助她的公司处理 Web API：
- en: '***Job situation—*** Employee, programmer'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工作情况—*** 员工，程序员'
- en: '***Work type—*** iOS development; also responsible for web apps and web services'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工作类型—*** iOS 开发；也负责 Web 应用程序和网络服务'
- en: '***Computer—*** MacBook Pro, iPad Pro'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***计算机—*** MacBook Pro, iPad Pro'
- en: '***Tools—*** Xcode, Atom, Babel, Perforce'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***工具—*** Xcode, Atom, Babel, Perforce'
- en: '***Background—*** Science degree; one of the first five employees at her current
    startup'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***背景—*** 科学学位；她当前创业公司的前五名员工之一'
- en: Alice grudgingly works with Xcode, Objective-C, and Swift, but secretly prefers
    Java-Script and is excited by ES2015 and Babel. She relishes developing new web
    services to support her company’s iOS and desktop apps, and wants to work on React-based
    web apps more often.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 不情愿地使用 Xcode、Objective-C 和 Swift，但秘密地更喜欢 JavaScript，并对 ES2015 和 Babel
    感到兴奋。她喜欢开发新的网络服务来支持她公司的 iOS 和桌面应用程序，并希望更频繁地从事基于 React 的网络应用程序开发。
- en: Now that the personas have been defined, let’s define the term *framework*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经定义了角色，让我们来定义术语 *框架*。
- en: 5.2\. What is a framework?
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 什么是框架？
- en: Some of the server-side frameworks discussed in this chapter are technically
    not frameworks at all. The term *framework* is unfortunately overloaded and means
    different things to different programmers. In the Node community, it’s more accurate
    to call most of these projects *modules*, but a more nuanced definition is useful
    when directly comparing this family of libraries.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的一些服务器端框架在技术上根本不是框架。术语 *框架* 很不幸地被过度使用，对不同程序员意味着不同的事情。在 Node 社区中，更准确地称这些项目为
    *模块*，但在直接比较这一系列库时，一个更细致的定义是有用的。
- en: 'The LoopBack project ([http://loopback.io/resources/#compare](http://loopback.io/resources/#compare))
    uses the following definitions:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: LoopBack 项目 ([http://loopback.io/resources/#compare](http://loopback.io/resources/#compare))
    使用以下定义：
- en: '***API framework—*** A library for building web APIs, backed by a framework
    that helps to structure the application. LoopBack itself is defined as this type
    of framework.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***API 框架—*** 用于构建 Web API 的库，由帮助结构化应用程序的框架支持。LoopBack 本身被定义为这种类型的框架。'
- en: '***HTTP server library—*** Anything based on Express falls into this category,
    including Koa and Kraken.js. These libraries help you build applications that
    are based around HTTP verbs and routes.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***HTTP 服务器库—*** 基于 Express 的任何东西都属于这一类别，包括 Koa 和 Kraken.js。这些库帮助您构建基于 HTTP
    动词和路由的应用程序。'
- en: '***HTTP server framework—*** A framework for building modular servers that
    speak HTTP. hapi is an example of this type of framework.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***HTTP 服务器框架—*** 用于构建使用 HTTP 通信的模块化服务器的框架。hapi 是这种类型框架的例子。'
- en: '***Web MVC framework—*** Model-View-Controller frameworks including Sails.js
    fall into this category.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Web MVC 框架—*** 包括 Sails.js 在内的模型-视图-控制器框架属于这一类别。'
- en: '***Full-stack framework—*** These frameworks use JavaScript on the server and
    browser, and are able to share code between both ends. This is known as *isomorphic
    code*. DerbyJS is a full-stack MVC framework.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***全栈框架—*** 这些框架在服务器和浏览器上使用 JavaScript，并且能够在两端之间共享代码。这被称为 *同构代码*。DerbyJS 是一个全栈
    MVC 框架。'
- en: 'Most Node developers understand *framework* to mean the second term: HTTP server
    library. The next section introduces Koa, a server library that uses the innovative
    ES2015 syntax known as *generators* to offer a unique way to handle HTTP middleware.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Node 开发者将 *框架* 理解为第二个术语：HTTP 服务器库。下一节将介绍 Koa，这是一个使用创新 ES2015 语法（称为 *生成器*）来提供独特方式处理
    HTTP 中间件的服务器库。
- en: 5.3\. Koa
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. Koa
- en: Koa ([http://koajs.com/)is](http://koajs.com/)is) based on Express, but uses
    the ES2015 generator syntax to define middleware. That means you can write middleware
    in an almost synchronous fashion. This partly solves the problem of middleware
    that depends highly on callbacks. With Koa, you can use the `yield` keyword to
    exit and then reenter middleware. [Table 5.1](#ch05table01) is an overview of
    Koa’s main features.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Koa ([http://koajs.com/)is](http://koajs.com/)is) 基于 Express，但使用 ES2015 生成器语法来定义中间件。这意味着你可以以几乎同步的方式编写中间件。这部分解决了高度依赖回调的中间件问题。在
    Koa 中，你可以使用 `yield` 关键字退出并重新进入中间件。[表 5.1](#ch05table01) 是 Koa 主要功能的概述。
- en: Table 5.1\. Koa’s main features
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.1\. Koa 的主要功能
- en: '| **Library type** | HTTP server library |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **库类型** | HTTP 服务器库 |'
- en: '| **Features** | Generator-based middleware, request/response model |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | 基于生成器的中间件，请求/响应模型 |'
- en: '| **Suggested uses** | Lightweight web apps, nonstrict HTTP APIs, serving single-page
    web app |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **建议用途** | 轻量级 Web 应用，非严格 HTTP API，服务单页 Web 应用 |'
- en: '| **Plugin architecture** | Middleware |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **插件架构** | 中间件 |'
- en: '| **Documentation** | [http://koajs.com/](http://koajs.com/) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **文档** | [http://koajs.com/](http://koajs.com/) |'
- en: '| **Popularity** | 10,000 GitHub stars |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| **流行度** | 10,000 GitHub 星标 |'
- en: '| **License** | MIT |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **许可证** | MIT |'
- en: The following listing shows how to use Koa to benchmark requests by yielding
    to the next middleware component and then continuing execution in the callee when
    it’s finished.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何使用 Koa 通过将执行权传递给下一个中间件组件并在完成时在调用者中继续执行来基准测试请求。
- en: Listing 5.1\. Koa’s middleware ordering
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. Koa 的中间件排序
- en: '![](Images/05lis01_alt.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05lis01_alt.jpg)'
- en: '[Listing 5.1](#ch05ex01) uses generators ![](Images/circ1.jpg) to switch context
    between two middleware components. Notice that we use the keyword `function*`—it’s
    not possible to use an arrow function here. By using the `yield` keyword ![](Images/circ2.jpg),
    execution steps down the middleware stack, then back again when the next middleware
    component returns ![](Images/circ3.jpg). An added benefit of using generator functions
    is you can just set `this.body`. In contrast, Express uses a function to send
    responses: `res.send(response)`. In Koa middleware, `this` is known as a *context*.
    A context is created for every request, and it’s used to encapsulate Node’s HTTP
    `request` and `response` objects ([https://nodejs.org/api/http.html](https://nodejs.org/api/http.html)).
    Whenever you need to access something from the request, such as the GET parameters
    or cookies, you can use the context. The same is true for the response: as you
    saw in [listing 5.1](#ch05ex01), you can control what gets sent to the browser
    by setting values on `this.body`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.1](#ch05ex01) 使用生成器 ![](Images/circ1.jpg) 在两个中间件组件之间切换上下文。请注意，我们使用关键字
    `function*`——在这里不能使用箭头函数。通过使用 `yield` 关键字 ![](Images/circ2.jpg)，执行步骤会下降到中间件堆栈，然后在下一个中间件组件返回时再次返回
    ![](Images/circ3.jpg)。使用生成器函数的一个额外好处是你可以直接设置 `this.body`。相比之下，Express 使用一个函数来发送响应：`res.send(response)`。在
    Koa 中间件中，`this` 被称为 *上下文*。为每个请求创建一个上下文，并用于封装 Node 的 HTTP `request` 和 `response`
    对象 ([https://nodejs.org/api/http.html](https://nodejs.org/api/http.html))。每次你需要从请求中访问某些内容时，例如
    GET 参数或 cookies，你都可以使用上下文。对于响应也是如此：正如你在 [列表 5.1](#ch05ex01) 中看到的，你可以通过在 `this.body`
    上设置值来控制发送到浏览器的数据。'
- en: If you’ve used both Express middleware and generator syntax before, Koa should
    be easy to learn. If either of these things is new to you, Koa might be hard to
    follow—or at least it might be hard to see why this style is beneficial. [Figure
    5.1](#ch05fig01) shows in more detail how `yield` hands off execution between
    middleware components.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过 Express 中间件和生成器语法，Koa 应该很容易学习。如果你对这两者中的任何一个都不熟悉，Koa 可能很难理解——或者至少可能很难看到这种风格的好处。![图
    5.1](#ch05fig01) 更详细地展示了 `yield` 如何在中间件组件之间传递执行。
- en: Figure 5.1\. Koa middleware execution order
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1\. Koa 中间件执行顺序
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: Each of the stages in [figure 5.1](#ch05fig01) corresponds to the numbers in
    [listing 5.1](#ch05ex01). First, the timer is set up in the first middleware component
    ![](Images/circ1.jpg), and then execution is yielded to the second middleware
    component that renders the body ![](Images/circ2.jpg). After the response has
    been sent, execution returns to the first middleware component, and the time is
    calculated ![](Images/circ3.jpg). This is displayed in the terminal with `console.log`,
    and the request is then finished ![](Images/circ4.jpg). Note that stage ![](Images/circ4.jpg)
    isn’t visible in [listing 5.1](#ch05ex01); it’s handled by Koa and Node’s HTTP
    server.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#ch05fig01) 中的每个阶段都对应于 [列表5.1](#ch05ex01) 中的数字。首先，计时器在第一个中间件组件中设置 ![](Images/circ1.jpg)，然后执行权传递给第二个中间件组件，该组件渲染主体
    ![](Images/circ2.jpg)。在发送响应后，执行权返回到第一个中间件组件，并计算时间 ![](Images/circ3.jpg)。这通过 `console.log`
    在终端中显示，然后请求完成 ![](Images/circ4.jpg)。请注意，阶段 ![](Images/circ4.jpg) 在 [列表5.1](#ch05ex01)
    中不可见；它由 Koa 和 Node 的 HTTP 服务器处理。'
- en: 5.3.1\. Setting up
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1. 设置
- en: Setting up a project with Koa requires installing the module and then defining
    middleware. If you want more functionality, such as a routing API that makes it
    easier to define and respond to various types of HTTP request, then you’ll need
    to install router middleware. That means a typical workflow requires planning
    the middleware your project will use beforehand, so you need to research popular
    modules first.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Koa 设置项目需要安装模块，然后定义中间件。如果你想要更多功能，例如一个路由 API，它可以使定义和响应各种类型的 HTTP 请求更容易，那么你需要安装路由中间件。这意味着典型的流程需要在事先规划项目将使用的中间件，因此你需要首先研究流行的模块。
- en: '|  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Persona thoughts**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**人物想法**'
- en: '*Alice*: “As a product developer, I like Koa’s minimal feature set—because
    our project has unique requirements, and we really want to shape the entire stack
    according to our needs.”'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*爱丽丝*：“作为一名产品开发者，我喜欢 Koa 的最小功能集——因为我们的项目有独特的要求，我们真的希望根据我们的需求塑造整个堆栈。”'
- en: '*Phil*: “As an agency developer, I find dealing with the middleware research
    stage too much trouble. I’d prefer this to be handled for me, because many of
    my projects have similar requirements, and I don’t want to keep installing the
    same modules to do basic things.”'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*菲利普*：“作为一名机构开发者，我发现处理中间件研究阶段太麻烦了。我宁愿有人帮我处理，因为我的许多项目有类似的要求，我不想反复安装相同的模块来做基本的事情。”'
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The next section demonstrates a third-party module that implements a powerful
    routing library for Koa.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分演示了一个第三方模块，它为 Koa 实现了一个强大的路由库。
- en: 5.3.2\. Defining routes
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2. 定义路由
- en: 'A popular router middleware component is koa-router ([https://www.npmjs.com/package/koa-router](https://www.npmjs.com/package/koa-router)).
    Like Express, it’s based on HTTP verbs, but unlike Express, it has a chainable
    API. The next snippet shows how groups of routes are defined:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的路由中间件组件是 koa-router ([https://www.npmjs.com/package/koa-router](https://www.npmjs.com/package/koa-router))。像
    Express 一样，它基于 HTTP 动词，但与 Express 不同，它有一个可链式调用的 API。下面的代码片段显示了如何定义路由组：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Routes can be named by using an additional argument. This is great because
    you can generate URLs, which not all Node web frameworks support. Here’s an example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用额外的参数来命名路由。这很好，因为你可以生成 URL，而并非所有 Node Web 框架都支持这一点。以下是一个示例：
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This module has a unique blend of features from Express and other web frameworks.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块结合了 Express 和其他 Web 框架的独特功能。
- en: '|  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Persona thoughts**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**人物想法**'
- en: '*Phil*: “This routing library reminds me of some of the things I liked about
    Ruby on Rails, so Koa could win me over after all!”'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*菲利普*：“这个路由库让我想起了我喜欢 Ruby on Rails 的一些东西，所以 Koa 最终可能会赢得我的青睐！”'
- en: '*Nadine*: “I can see opportunities for modularizing my existing projects with
    Koa, and then sharing this code with the community.”'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*纳丁*：“我可以看到使用 Koa 对现有项目进行模块化的机会，然后与社区分享这段代码。”'
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.3.3\. REST APIs
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.3. REST API
- en: Koa doesn’t come with the tools necessary to make RESTful APIs without implementing
    some kind of route-handling middleware. The previous example can be extended to
    implement a RESTful API in Koa.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Koa 不自带实现某种路由处理中间件所需的工具来制作 RESTful API。前面的示例可以扩展到在 Koa 中实现 RESTful API。
- en: 5.3.4\. Strengths
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.4. 优势
- en: It would be easy to say that Koa’s strengths come from its early adoption of
    generator syntax, but now that ES2015 is widespread in the Node community, this
    is no longer as unique as it once was. Currently, Koa’s main advantage is that
    it’s streamlined yet has some excellent third-party modules; check out the Koa
    wiki for more information ([https://github.com/koajs/koa/wiki#middleware](https://github.com/koajs/koa/wiki#middleware)).
    Product developers love it, because it has elegant syntax and can be tailored
    for projects with specific requirements.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易说Koa的优势来自于其对生成器语法的早期采用，但现在随着ES2015在Node社区中的普及，这已经不再像以前那样独特。目前，Koa的主要优势在于它既简洁又拥有一些优秀的第三方模块；查看Koa维基以获取更多信息
    ([https://github.com/koajs/koa/wiki#middleware](https://github.com/koajs/koa/wiki#middleware))。产品开发者喜欢它，因为它具有优雅的语法，并且可以根据特定要求进行定制。
- en: 5.3.5\. Weaknesses
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.5. 弱点
- en: Koa’s level of configurability alienates some developers. Creating many small
    projects with Koa can lead to low levels of code reuse, unless you already have
    code-sharing strategies in place.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Koa的可配置性程度让一些开发者感到困惑。使用Koa创建许多小型项目可能会导致代码重用率低，除非你已经实施了代码共享策略。
- en: 5.4\. Kraken
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 克隆龙
- en: Kraken is based on Express, but adds new functionality through custom modules
    developed by PayPal. One useful module in particular is Lusca ([https://github.com/krakenjs/lusca](https://github.com/krakenjs/lusca)),
    which provides an application security layer. Although it’s possible to use Lusca
    without Kraken, one of Kraken’s benefits is its predefined project structure.
    Express and Koa applications don’t require any specific project structure, so
    if you’re looking for help with starting new projects, Kraken can help get things
    going. [Table 5.2](#ch05table02) shows an overview of Kraken’s main features.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆龙基于Express，但通过PayPal开发的自定义模块增加了新功能。特别是有一个有用的模块是Lusca ([https://github.com/krakenjs/lusca](https://github.com/krakenjs/lusca))，它提供了一个应用安全层。尽管可以在没有克隆龙的情况下使用Lusca，但克隆龙的一个好处是它预定义了项目结构。Express和Koa应用不需要特定的项目结构，所以如果你需要帮助开始新项目，克隆龙可以帮助你开始。
    [表5.2](#ch05table02) 展示了克隆龙主要功能的概述。
- en: Table 5.2\. Kraken’s main features
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.2. 克隆龙的主要功能
- en: '| **Library type** | HTTP server library |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **库类型** | HTTP服务器库 |'
- en: '| **Features** | Strict project structure, models, templates (Dust), security
    hardening (Lusca), configuration management, internationalization |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | 严格的项目结构、模型、模板（Dust）、安全加固（Lusca）、配置管理、国际化 |'
- en: '| **Suggested uses** | Corporate web apps |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **推荐用途** | 企业级Web应用 |'
- en: '| **Plugin architecture** | Express middleware |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| **插件架构** | Express中间件 |'
- en: '| **Documentation** | [https://www.kraken.com/help/api](https://www.kraken.com/help/api)
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **文档** | [https://www.kraken.com/help/api](https://www.kraken.com/help/api)
    |'
- en: '| **Popularity** | 4,000 GitHub stars |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **流行度** | 4,000 GitHub星标 |'
- en: '| **License** | Apache 2.0 |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **许可** | Apache 2.0 |'
- en: 5.4.1\. Setting up
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1. 设置
- en: 'If you already have an Express project, you can add Kraken as a middleware
    component:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了一个Express项目，你可以将克隆龙作为中间件组件添加：
- en: '[PRE29]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But if you want to start a new project, you should try Kraken’s Yeoman generator.
    Yeoman is a tool that helps you to generate new projects. By using Yeoman generators,
    you can create bootstrapped projects for a variety of frameworks. Here are the
    steps to create a tailored Kraken project using Yeoman, with Kraken’s preferred
    filesystem layout:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你想开始一个新项目，你应该尝试克隆龙的Yeoman生成器。Yeoman是一个帮助你生成新项目的工具。通过使用Yeoman生成器，你可以为各种框架创建初始化的项目。以下是使用Yeoman创建定制克隆龙项目的步骤，以及克隆龙首选的文件系统布局：
- en: '[PRE30]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The generator creates a new directory, so you don’t need to do this yourself.
    After the generator finishes, you should be able to start a server and visit http://localhost:8000
    to try it out.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器会创建一个新的目录，因此你不需要自己这样做。生成器完成后，你应该能够启动服务器并访问http://localhost:8000来尝试它。
- en: 5.4.2\. Defining routes
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2. 定义路由
- en: 'In Kraken, routes are defined alongside the *controller*. Rather than separating
    out route definitions and route handlers as Express does, Kraken uses an MVC-inspired
    approach, which is lightweight thanks to the use of ES6 arrow functions:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在克隆龙中，路由定义与控制器并列。与Express将路由定义和路由处理程序分离不同，克隆龙采用了一种受MVC启发的轻量级方法，这得益于ES6箭头函数的使用：
- en: '[PRE31]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Routes can include parameters in the URL:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 路由可以在URL中包含参数：
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Kraken’s routing API is express-enrouten ([https://github.com/krakenjs/express-enrouten](https://github.com/krakenjs/express-enrouten)),
    and it partly infers the route from the directory the file is in. Say you have
    a file layout like this:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Kraken的路由API是express-enrouten ([https://github.com/krakenjs/express-enrouten](https://github.com/krakenjs/express-enrouten))，它部分从文件所在的目录推断路由。假设你有一个这样的文件布局：
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then Kraken will generate routes such as /user/create and /user/list.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Kraken将生成如/user/create和/user/list之类的路由。
- en: 5.4.3\. REST APIs
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.3\. REST API
- en: Kraken can be used to make REST APIs but doesn’t provide specific support for
    them. The capabilities of express-enrouten combined with middleware for parsing
    JSON means you can use Kraken to implement REST APIs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Kraken可以用来制作REST API，但不提供针对它们的特定支持。express-enrouten的功能与解析JSON的中间件结合意味着你可以使用Kraken来实现REST
    API。
- en: Kraken’s router has HTTP verbs for DELETE, GET, POST, PUT, and so on, which
    makes implementing REST similar to Express.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Kraken的路由器支持HTTP动词DELETE、GET、POST、PUT等，这使得实现REST与Express类似。
- en: 5.4.4\. Strengths
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.4\. 优点
- en: Because Kraken comes with a generator, Kraken projects look similar from a high
    level. Although Express projects can vary wildly in their layout, Kraken projects
    typically put files and directories in the same places.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kraken自带生成器，从高层次来看，Kraken项目看起来很相似。尽管Express项目的布局可能千差万别，但Kraken项目通常将文件和目录放在相同的位置。
- en: 'Because Kraken provides both a templating library (Dust) and internationalization
    (Makara), the two are seamlessly integrated. To write Dust templates with internationalization,
    you need to specify a key:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kraken提供了模板库（Dust）和国际化（Makara），这两个功能无缝集成。要编写具有国际化的Dust模板，你需要指定一个键：
- en: '[PRE34]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then add a .properties file to locales/language-code/view-name.properties. These
    properties files are simple key/value pairs, so if the previous example was in
    a view file called public/templates/profile.dust, the .profile file would be locales/US/en/profile.properties.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在locales/language-code/view-name.properties中添加一个.properties文件。这些属性文件是简单的键值对，所以如果前面的例子在一个名为public/templates/profile.dust的视图文件中，那么.profile文件将是locales/US/en/profile.properties。
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Persona thoughts**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色思考**'
- en: '*Phil*: “The fact that Kraken has a filesystem layout and uses controllers
    for routes appeals to me a lot. Some of my team know Django and Ruby on Rails,
    so this will be an easy transition for them. Kraken’s documentation also seems
    really good; there’s lots of useful stuff on the blog.”'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*Phil*: “Kraken具有文件系统布局并使用控制器进行路由的事实让我印象很深。我们团队中的一些人了解Django和Ruby on Rails，因此这对他们来说将是一个容易的过渡。Kraken的文档看起来也非常好；博客上有很多有用的内容。”'
- en: '*Alice*: “I like the idea of getting better application security with Lusca,
    but Kraken provides things I don’t really need. I’m going to try just using Lusca
    by itself.”'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alice*: “我喜欢通过Lusca获得更好的应用程序安全性的想法，但Kraken提供了一些我并不真正需要的东西。我将尝试仅使用Lusca。”'
- en: '|  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.4.5\. Weaknesses
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.5\. 缺点
- en: It takes more effort to learn Kraken than Koa or Express. Some tasks that are
    done programmatically in Express are done through JSON configuration files, and
    it’s sometimes hard to figure out exactly what JSON properties are needed to get
    things to work the desired way.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Kraken比学习Koa或Express需要更多的努力。在Express中通过编程完成的某些任务，在Kraken中是通过JSON配置文件完成的，有时很难确定需要哪些JSON属性才能按预期的方式工作。
- en: 5.5\. hapi
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. hapi
- en: hapi ([http://hapijs.com/](http://hapijs.com/)) is a server framework that focuses
    on web API development. It has its own hapi plugin API, and doesn’t come with
    any client-side support or database model layer. It comes with a routing API and
    has its own HTTP server wrapper. In hapi, you design APIs by thinking about the
    server as the main abstraction. The built-in server features for connections and
    logging make hapi good at scaling and management from a DevOps point of view.
    [Table 5.3](#ch05table03) contains an overview of hapi’s main features.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: hapi ([http://hapijs.com/](http://hapijs.com/))是一个专注于Web API开发的服务器框架。它有自己的hapi插件API，不提供任何客户端支持或数据库模型层。它包含一个路由API和自己的HTTP服务器包装器。在hapi中，你通过将服务器视为主要抽象来设计API。内置的连接和日志记录功能使hapi在DevOps方面具有良好的扩展性和管理能力。[表5.3](#ch05table03)包含hapi主要功能的概述。
- en: Table 5.3\. hapi’s main features
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.3\. hapi的主要功能
- en: '| **Library type** | HTTP server framework |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **库类型** | HTTP服务器框架 |'
- en: '| **Features** | High-level server container abstraction, security headers
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | 高级服务器容器抽象，安全头部 |'
- en: '| **Suggested uses** | Single-page web apps, HTTP APIs |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **建议用途** | 单页Web应用，HTTP API |'
- en: '| **Plugin architecture** | hapi plugins |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **插件架构** | hapi插件 |'
- en: '| **Documentation** | [http://hapijs.com/api](http://hapijs.com/api) |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **文档** | [http://hapijs.com/api](http://hapijs.com/api) |'
- en: '| **Popularity** | 6,000 GitHub stars |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **流行度** | 6,000 GitHub 星标 |'
- en: '| **License** | BSD 3 Clause |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| **许可** | BSD 3 条款 |'
- en: 5.5.1\. Setting up
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1\. 设置
- en: 'First, create a new Node project and install hapi:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的 Node 项目并安装 hapi：
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then create a new file called server.js. Add the code from the following listing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个名为 server.js 的新文件。添加以下列表中的代码。
- en: Listing 5.2\. Basic hapi server
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. 基本hapi服务器
- en: '[PRE36]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You could run this example as it is, but it won’t do much without any routes.
    Read on to learn about how hapi handles routes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接运行这个示例，但没有任何路由它不会做很多事情。继续阅读以了解 hapi 如何处理路由。
- en: 5.5.2\. Defining routes
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2\. 定义路由
- en: hapi has a built-in API for creating routes. You must provide an object that
    includes properties for the request method, a URL, and a callback to run, which
    is known as a *handler*. The next listing shows how to define a route with a handler
    method.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: hapi 内置了一个用于创建路由的 API。你必须提供一个包含请求方法、URL 和一个运行回调的对象，这个回调被称为 *handler*。下面的列表展示了如何使用处理方法定义一个路由。
- en: Listing 5.3\. hapi hello world server
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. hapi hello world 服务器
- en: '[PRE37]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add this code to the previous listing to define a route and handler that will
    respond with the text *hello world*. You can run this example by typing `npm start`.
    Open http://localhost:8000/hello to see the response.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到前面的列表中，以定义一个将响应文本 *hello world* 的路由和处理程序。你可以通过输入 `npm start` 来运行此示例。打开
    http://localhost:8000/hello 来查看响应。
- en: 'hapi doesn’t come with a predefined folder structure or any MVC features; it’s
    entirely based around servers. In this regard, it’s similar to Express. Notice,
    however, a key difference: the `request, reply` route handler signature is different
    from Express’s `req, res`. hapi’s request and reply objects are different from
    Express’s equivalents as well: you must call `reply` rather than manipulate Express’s
    `res` object. Express is more similar to Node’s built-in HTTP server.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: hapi 不包含预定义的文件夹结构或任何 MVC 功能；它完全基于服务器。在这方面，它与 Express 类似。然而，请注意一个关键的区别：`request,
    reply` 路由处理程序签名与 Express 的 `req, res` 不同。hapi 的请求和回复对象也与 Express 的等效对象不同：你必须调用
    `reply` 而不是操作 Express 的 `res` 对象。Express 更类似于 Node 内置的 HTTP 服务器。
- en: To go beyond this simple example and get more functionality, such as serving
    static files, you need plugins.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要超越这个简单的示例并获得更多功能，例如提供静态文件，你需要插件。
- en: 5.5.3\. Plugins
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3\. 插件
- en: hapi has its own plugin architecture, and most projects require several plugins
    to provide features such as authentication and user input validation. A simple
    plugin that most projects need is inert ([https://github.com/hapijs/inert](https://github.com/hapijs/inert)),
    which adds static file and directory handlers.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: hapi 有自己的插件架构，大多数项目需要几个插件来提供诸如身份验证和用户输入验证等功能。大多数项目都需要一个简单的插件 inert ([https://github.com/hapijs/inert](https://github.com/hapijs/inert))，它添加了静态文件和目录处理程序。
- en: To add inert to a hapi project, you need to first register the plugin with the
    `server.register` method. This adds the `reply.file` method for sending single
    files, and a built-in directory handler. Let’s look at the directory handler.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 inert 添加到 hapi 项目中，你需要首先使用 `server.register` 方法注册插件。这添加了 `reply.file` 方法用于发送单个文件，以及内置的目录处理程序。让我们看看目录处理程序。
- en: 'Make sure you have a project set up based on [listing 5.2](#ch05ex02). Next,
    install inert:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经基于 [列表 5.2](#ch05ex02) 设置了一个项目。接下来，安装 inert：
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now the plugin can be loaded and registered. Open the server.js file and add
    the following lines.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，插件可以被加载并注册。打开 server.js 文件并添加以下行。
- en: Listing 5.4\. Adding a plugin with hapi
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 使用 hapi 添加插件
- en: '[PRE39]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Instead of accepting only functions, hapi routes can also accept configuration
    objects for plugins. In this listing, the `directory` object includes the inert
    settings to serve files in the current path and show an index of the files in
    that directory. This is different from Express middleware, and shows how plugins
    extend the server’s behavior in hapi applications.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: hapi 路由不仅可以接受函数，还可以接受插件的配置对象。在这个列表中，`directory` 对象包含了惰性设置，用于在当前路径下提供文件服务并显示该目录中的文件索引。这与
    Express 中间件不同，展示了插件如何在 hapi 应用程序中扩展服务器的行为。
- en: 5.5.4\. REST APIs
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.4\. REST API
- en: 'hapi supports HTTP verbs and URL parameterization, allowing REST APIs to be
    implemented by using the standard hapi route API. The following snippet is the
    route required for a generalized delete method:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: hapi 支持 HTTP 动词和 URL 参数化，允许通过标准的 hapi 路由 API 实现 REST API。以下是一个用于通用删除方法的路由片段：
- en: '[PRE40]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In addition, plugins make creating RESTful APIs easier. For example, hapi-sequelize-crud
    ([https://www.npmjs.com/package/hapi-sequelize-crud](https://www.npmjs.com/package/hapi-sequelize-crud))
    automatically generates a RESTful API based on Sequelize models ([http://docs.sequelizejs.com/en/latest/](http://docs.sequelizejs.com/en/latest/)).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，插件使创建RESTful API变得更加容易。例如，hapi-sequelize-crud ([https://www.npmjs.com/package/hapi-sequelize-crud](https://www.npmjs.com/package/hapi-sequelize-crud))
    可以根据Sequelize模型 ([http://docs.sequelizejs.com/en/latest/](http://docs.sequelizejs.com/en/latest/))
    自动生成RESTful API。
- en: '|  |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Persona thoughts**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色思考**'
- en: '*Phil*: “I would definitely like to try hapi-sequelize-crud because we already
    have apps that use PostgreSQL and MySQL, so Sequelize might be a good fit. But,
    because hapi doesn’t come with features like this out of the box, I’m worried
    that this plugin might become unsupported, so I’m not sure if hapi will work well
    in an agency scenario.”'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*Phil*: “我肯定会尝试hapi-sequelize-crud，因为我们已经有使用PostgreSQL和MySQL的应用程序，所以Sequelize可能是一个不错的选择。但是，由于hapi本身不提供这类功能，我担心这个插件可能会失去支持，所以我不确定hapi是否能在代理场景中良好工作。”'
- en: '*Alice*: “As a product developer, I think hapi is interesting because like
    Express, it’s minimal, yet the plugin API is more formal and expressive.”'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alice*: “作为一名产品开发者，我认为hapi很有趣，因为它像Express一样简洁，但插件API更加正式和表达性强。”'
- en: '*Nadine*: “I can see several opportunities for making open source plugins for
    hapi, and the existing plugins mostly seem well written. hapi seems to have a
    technically competent audience, which appeals to me.”'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*Nadine*: “我可以看到为hapi制作开源插件的几个机会，并且现有的插件看起来都写得很好。hapi似乎有一个技术能力强的受众，这对我很有吸引力。”'
- en: '|  |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.5.5\. Strengths
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.5\. 优点
- en: hapi’s plugin API is one of the biggest advantages of using hapi. Plugins can
    extend hapi’s server but also add all kinds of other behavior, from data validation
    to templating. Also, because hapi is based around HTTP servers, it suits certain
    types of deployment scenarios. If you’re deploying many servers that need to be
    connected together or load balanced, you might prefer hapi’s server-based API
    to Express or Koa.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: hapi的插件API是使用hapi的最大优势之一。插件可以扩展hapi的服务器，也可以添加各种其他行为，从数据验证到模板化。此外，由于hapi基于HTTP服务器，它适合某些类型的部署场景。如果你需要部署许多需要连接在一起或负载均衡的服务器，你可能更喜欢hapi基于服务器的API而不是Express或Koa。
- en: 5.5.6\. Weaknesses
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.6\. 弱点
- en: 'hapi has similar weaknesses to Express: it’s minimal, so there’s no guidance
    on project structure. You can never be sure whether development on a plugin might
    cease, so relying on lots of plugins could cause maintenance issues in the future.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: hapi与Express有类似的弱点：它很简洁，因此没有关于项目结构的指导。你永远不能确定某个插件的开发是否会停止，所以过多地依赖插件可能会在未来造成维护问题。
- en: 5.6\. Sails.js
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6\. Sails.js
- en: 'The frameworks you’ve seen so far have been minimal server libraries. Sails
    ([http://sailsjs.org/](http://sailsjs.org/)) is a Model-View-Controller (MVC)
    framework, which is fundamentally different from a server library. It comes with
    an object-relational mapping (ORM) library for working with databases, and it
    can automatically generate REST APIs. It has modern features as well, including
    built-in WebSocket support. And if you’re a fan of React or Angular, you’ll be
    glad to know it’s front-end agnostic: it’s not a full-stack framework, so you
    can use it with practically any front-end library or framework. [Table 5.4](#ch05table04)
    shows the main features of Sails.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止看到的框架都是最小化的服务器库。Sails ([http://sailsjs.org/](http://sailsjs.org/)) 是一个模型-视图-控制器（MVC）框架，它与服务器库有根本的不同。它包含一个用于与数据库工作的对象关系映射（ORM）库，并且可以自动生成REST
    API。它还具有现代功能，包括内置的WebSocket支持。如果你是React或Angular的粉丝，你会很高兴知道它是前端无关的：它不是一个全栈框架，所以你可以与几乎任何前端库或框架一起使用。
    [表5.4](#ch05table04) 显示了Sails的主要功能。
- en: Table 5.4\. The main features of Sails
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.4\. Sails的主要功能
- en: '| **Library type** | MVC framework |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **库类型** | MVC框架 |'
- en: '| **Features** | Database support with an ORM, REST API generation, WebSocket
    |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | 带有ORM的数据库支持，REST API生成，WebSocket |'
- en: '| **Suggested uses** | Rails-style MVC apps |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| **建议用途** | Rails风格的MVC应用程序 |'
- en: '| **Plugin architecture** | Express middleware |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| **插件架构** | Express中间件 |'
- en: '| **Documentation** | [http://sailsjs.org/documentation/concepts/](http://sailsjs.org/documentation/concepts/)
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| **文档** | [http://sailsjs.org/documentation/concepts/](http://sailsjs.org/documentation/concepts/)
    |'
- en: '| **Popularity** | 6,000 GitHub stars |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| **流行度** | 6,000 GitHub星标 |'
- en: '| **License** | BSD 3 Clause |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **许可证** | BSD 3条款 |'
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Persona thoughts**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色思考**'
- en: '*Phil*: “This sounds exactly what I’m looking for—what’s the catch?!”'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*Phil*: “这听起来正是我想要的——有什么陷阱吗？！”'
- en: '*Alice*: “I thought this wouldn’t be for me because we’ve already invested
    development time in a React app, but because it’s focused on the server, it may
    work for our product.”'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alice*: “我原以为这不适合我，因为我们已经在React应用上投入了开发时间，但因为它专注于服务器，它可能适合我们的产品。”'
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.6.1\. Setting up
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.1\. 设置
- en: 'Sails comes with a project generator, so it’s best if you install it globally
    to make creating new projects easier. Install it with npm and then use `sails
    new` to make a project:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Sails自带项目生成器，所以最好将其全局安装以简化创建新项目的过程。使用npm安装它，然后使用`sails new`来创建项目：
- en: '[PRE41]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This creates a new directory with a package.json for the basic Sails dependencies.
    The new project includes Sails itself, EJS, and Grunt. You can run `npm start`
    to start the server, or type `sails lift`. When the server is running, you’ll
    be able to see the built-in Getting Started page by visiting http://localhost:1337.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的目录，其中包含一个用于基本Sails依赖项的package.json。新项目包括Sails本身、EJS和Grunt。你可以运行`npm
    start`来启动服务器，或者输入`sails lift`。当服务器运行时，你可以通过访问http://localhost:1337来查看内置的入门页面。
- en: 5.6.2\. Defining routes
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.2\. 定义路由
- en: 'To add routes, known as *custom routes* in Sails, open config/routes.js and
    add a property to the exported routes. This property is the HTTP verb and partial
    URL. For example, these are some valid Sails routes:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加路由，在Sails中称为*自定义路由*，请打开config/routes.js并为导出的路由添加一个属性。这个属性是HTTP动词和部分URL。例如，以下是一些有效的Sails路由：
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first route expects a file called views/example.ejs. The second route expects
    a file called api/controllers/ItemController with a method called `create`. You
    can generate this controller with a method called `create` by running `sails generate
    controller item create`. A similar command can be used to quickly create RESTful
    APIs.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个路由期望一个名为views/example.ejs的文件。第二个路由期望一个名为api/controllers/ItemController的文件，其中包含一个名为`create`的方法。你可以通过运行`sails
    generate controller item create`来生成这个控制器。类似的命令可以用来快速创建RESTful API。
- en: 5.6.3\. REST APIs
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.3\. REST API
- en: 'Sails combines database models and controllers into APIs, so to quickly stub
    RESTful APIs, use `sails generate api resource-name`. To use a database, you first
    need to install a database adapter. Adding MySQL involves finding the name of
    the Waterline MySQL package ([https://github.com/balderdashy/waterline](https://github.com/balderdashy/waterline))
    and then adding it to the project:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Sails将数据库模型和控制器组合成API，所以要快速创建RESTful API，请使用`sails generate api resource-name`。要使用数据库，你首先需要安装数据库适配器。添加MySQL涉及到找到Waterline
    MySQL包的名称([https://github.com/balderdashy/waterline](https://github.com/balderdashy/waterline))并将其添加到项目中：
- en: '[PRE43]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Next, open config/connections.js and fill out the connection details for your
    MySQL server. Sails model files allow you to specify the database connection,
    so you can use different models with different databases. That allows situations
    like a user session database in Redis and other, more permanent resources in a
    relational database such as MySQL.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开config/connections.js并填写你MySQL服务器的连接详情。Sails模型文件允许你指定数据库连接，因此你可以使用不同的模型与不同的数据库一起使用。这允许像Redis中的用户会话数据库和其他在关系型数据库（如MySQL）中的更永久资源这样的情况。
- en: 'Waterline is the database library for Sails, and it has its own documentation
    repository ([https://github.com/balderdashy/waterline-docs](https://github.com/balderdashy/waterline-docs)).
    Other than supporting multiple databases, Waterline has useful features: you can
    define table and column names to support legacy schemas, and the query API supports
    promises so queries look like modern JavaScript.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Waterline是Sails的数据库库，并且它有自己的文档仓库([https://github.com/balderdashy/waterline-docs](https://github.com/balderdashy/waterline-docs))。除了支持多种数据库外，Waterline还有一些有用的功能：你可以定义表和列名以支持旧版模式，并且查询API支持Promise，使得查询看起来像是现代JavaScript。
- en: '|  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Persona thoughts**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**人物想法**'
- en: '*Phil*: “The ease of creating APIs and the fact that Waterline models can support
    existing database schemas means Sails sounds ideal for us. We have clients that
    we want to slowly move from MySQL to PostgreSQL, so we may be able to do this
    with Waterline. Some of our developers and designers have already worked with
    Ruby on Rails, so I think they’ll pick up Sails with Node’s modern ES2015 syntax
    in no time.”'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '*Phil*: “创建API的便捷性以及Waterline模型能够支持现有的数据库模式意味着Sails对我们来说听起来非常理想。我们有一些客户，我们希望他们逐步从MySQL迁移到PostgreSQL，所以我们可能可以使用Waterline来实现这一点。我们的一些开发者和设计师已经使用过Ruby
    on Rails，所以我认为他们很快就能掌握使用Node的现代化ES2015语法的Sails。”'
- en: '*Alice*: “This framework provides things that I don’t need for our product.
    I feel like Koa or hapi would be a better fit.”'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alice*: “这个框架提供了一些我们产品不需要的功能。我觉得Koa或hapi可能更适合。”'
- en: '|  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 5.6.4\. Strengths
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.4\. 优点
- en: The built-in project creation and API generation means that setting up projects
    and adding typical REST APIs is fast. It works well for quickly creating new projects
    and collaborating, because Sails projects have the same filesystem layout. The
    creators of Sails, Mike McNeil and Irl Nathan, have written a book called *Sails.js
    in Action* (Manning Publications, 2017), which shows how Sails welcomes to Node
    beginners as well.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的项目创建和API生成意味着设置项目和添加典型的REST API非常快。这对于快速创建新项目和协作很有用，因为Sails项目具有相同的文件系统布局。Sails的创建者Mike
    McNeil和我rl Nathan写了一本名为《Sails.js in Action》（Manning Publications，2017）的书，展示了Sails如何欢迎Node初学者。
- en: 5.6.5\. Weaknesses
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.5\. 缺点
- en: 'Sails has some of the weaknesses shared by other server-side MVC frameworks:
    the routing API means you have to design your application with the Sails routing
    features in mind, and you may find it hard to adapt your schema to suit the Waterline
    way of handling things.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: Sails与其他服务器端MVC框架共享一些弱点：路由API意味着您必须考虑Sails的路由功能来设计应用程序，并且您可能会发现很难将您的模式适应Waterline处理事物的方式。
- en: 5.7\. DerbyJS
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7\. DerbyJS
- en: DerbyJS is a full-stack framework that supports data synchronization and server
    rendering of views. It depends on MongoDB and Redis. The data synchronization
    layer is provided by ShareJS, and it supports automatic conflict resolution. [Table
    5.5](#ch05table05) summarizes DerbyJS’ main features.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: DerbyJS是一个支持数据同步和视图服务器端渲染的全栈框架。它依赖于MongoDB和Redis。数据同步层由ShareJS提供，并支持自动冲突解决。[表5.5](#ch05table05)总结了DerbyJS的主要特性。
- en: Table 5.5\. DerbyJS features
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.5\. DerbyJS特性
- en: '| **Library type** | Full-stack framework |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| **库类型** | 全栈框架 |'
- en: '| **Features** | Database support with an ORM (Racer), isomorphic |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | 使用ORM（Racer）的数据库支持，同构 |'
- en: '| **Suggested uses** | Single-page web apps with server-side support |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| **推荐用途** | 具有服务器端支持的单一页面Web应用程序 |'
- en: '| **Plugin architecture** | DerbyJS plugins |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| **插件架构** | DerbyJS插件 |'
- en: '| **Documentation** | [http://derbyjs.com/docs/derby-0.6](http://derbyjs.com/docs/derby-0.6)
    |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| **文档** | [http://derbyjs.com/docs/derby-0.6](http://derbyjs.com/docs/derby-0.6)
    |'
- en: '| **Popularity** | 4,000 GitHub stars |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| **流行度** | 4,000 GitHub stars |'
- en: '| **License** | MIT |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| **许可证** | MIT |'
- en: 5.7.1\. Setting up
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.1\. 设置
- en: If you don’t have MongoDB or Redis, you need to install both of them to run
    the DerbyJS examples. The DerbyJS documentation explains how to do this for Mac
    OS, Linux, and Windows ([http://derbyjs.com/started#environment](http://derbyjs.com/started#environment)).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有MongoDB或Redis，您需要安装这两个来运行DerbyJS示例。DerbyJS文档解释了如何在Mac OS、Linux和Windows上完成此操作（[http://derbyjs.com/started#environment](http://derbyjs.com/started#environment)）。
- en: 'To create a new DerbyJS project quickly, install derby and derby-starter. The
    derby-starter package is used to bootstrap a Derby application:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速创建一个新的DerbyJS项目，安装derby和derby-starter。derby-starter包用于引导Derby应用程序：
- en: '[PRE44]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Derby applications are split into several smaller applications, so create a
    new app directory with three files: index.js, server.js, and index.html. The following
    listing shows a simple Derby app that renders a template.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Derby应用程序被分割成几个较小的应用程序，因此创建一个新的应用程序目录，包含三个文件：index.js、server.js和index.html。以下列表展示了一个简单的Derby应用程序，它渲染了一个模板。
- en: Listing 5.5\. Derby app/index.js file
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.5\. Derby应用程序的index.js文件
- en: '[PRE45]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The server file needs to load only the derby-starter module, as shown in the
    following snippet. Save this as app/server.js:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器文件只需要加载derby-starter模块，如下面的代码片段所示。将其保存为app/server.js：
- en: '[PRE46]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The app/index.html file renders an input field and the message that the user
    types:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: app/index.html文件渲染一个输入字段和用户输入的消息：
- en: '[PRE47]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You should be able to run the application from the example-derby-app directory
    by typing `node derby/server.js`. Once it’s running, editing the app/index.html
    file will cause the application to restart; you automatically get real-time updates
    when editing code and templates.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够通过在example-derby-app目录中输入`node derby/server.js`来运行应用程序。一旦它开始运行，编辑app/index.html文件将导致应用程序重新启动；在编辑代码和模板时，您将自动获得实时更新。
- en: 5.7.2\. Defining routes
  id: totrans-415
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.2\. 定义路由
- en: DerbyJS uses derby-router for routing. Because DerbyJS is powered by Express,
    the routing API is similar for server-side routes, and the same routing module
    is used in the browser. When clicking a link in a DerbyJS app, it’ll attempt to
    render the response in the client.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: DerbyJS使用derby-router进行路由。因为DerbyJS由Express驱动，所以服务器端路由的API相似，并且在浏览器中也使用相同的路由模块。当在DerbyJS应用程序中点击链接时，它将尝试在客户端渲染响应。
- en: 'DerbyJS is a full-stack framework, so adding routes isn’t quite the same as
    with the other libraries that you’ve looked at in this chapter. The most idiomatic
    way to add a basic route is by adding a view. Open apps/app/index.js and add a
    route by using `app.get`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: DerbyJS 是一个全栈框架，所以添加路由的方式与其他你在本章中查看的库略有不同。添加基本路由的最地道方式是通过添加视图。打开 apps/app/index.js
    并使用 `app.get` 添加路由：
- en: '[PRE48]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, open apps/app/views/hello.pug and add a simple Pug template:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 apps/app/views/hello.pug 并添加一个简单的 Pug 模板：
- en: '[PRE49]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now open apps/app/views/index.pug and import the template:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 apps/app/views/index.pug 并导入模板：
- en: '[PRE50]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The project should constantly update if you’ve run `npm start`, so opening http://localhost:3000/hello
    will now show the new view.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经运行了 `npm start`，项目应该会不断更新，所以现在打开 http://localhost:3000/hello 将会显示新的视图。
- en: The line that reads `index:` is the *namespace* for the view. In DerbyJS, view
    names have colon-separated namespaces, so you just created `hello:index`. The
    idea behind this is to encapsulate views so they don’t clash in larger projects.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 `index:` 的行是视图的 *命名空间*。在 DerbyJS 中，视图名称有冒号分隔的命名空间，所以你创建了 `hello:index`。背后的想法是将视图封装起来，以便在大型项目中不会发生冲突。
- en: 5.7.3\. REST APIs
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.3. REST API
- en: In DerbyJS projects, you need to create RESTful APIs by adding routes and route
    handlers with Express. Your DerbyJS project will have a server.js file that uses
    Express to create a server. If you open server/routes.js, you’ll find an example
    route, defined by using the standard Express routing API.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DerbyJS 项目中，你需要通过添加路由和路由处理程序来创建 RESTful API。你的 DerbyJS 项目将有一个使用 Express 创建服务器的
    server.js 文件。如果你打开 server/routes.js，你会找到一个使用标准 Express 路由 API 定义的示例路由。
- en: In the server routes file, you could use `app.use` to mount another Express
    application, so you could model a REST API as a completely separate Express app
    that the main DerbyJS app mounts.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器路由文件中，你可以使用 `app.use` 来挂载另一个 Express 应用程序，因此你可以将 REST API 模拟为一个完全独立的 Express
    应用程序，该应用程序由主 DerbyJS 应用程序挂载。
- en: 5.7.4\. Strengths
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.4. 优势
- en: DerbyJS has a database model API and a data synchronization API. You can use
    it to build single-page web apps, and modern real-time applications. Because it
    comes with WebSocket and synchronization built in, you don’t have to worry about
    which WebSocket library to use, or how to sync data between the client and server.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: DerbyJS 有数据库模型 API 和数据同步 API。你可以用它来构建单页 Web 应用程序和现代实时应用程序。因为它内置了 WebSocket 和同步功能，所以你不必担心使用哪个
    WebSocket 库，或者如何在客户端和服务器之间同步数据。
- en: '|  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Persona thoughts**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**角色思考**'
- en: '*Phil*: “We had a client asking about building a data visualization project
    based on real-time data, so I think DerbyJS could be good for that. But the learning
    curve seems steep, so I’m not sure I can convince our developers to use it.”'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*Phil*：“我们有一个客户询问基于实时数据构建数据可视化项目的事情，所以我认为 DerbyJS 对此可能很有用。但是学习曲线似乎很陡峭，所以我不确定我能否说服我们的开发者使用它。”'
- en: '*Alice*: “As a product developer, I find it hard to see how to fit our product’s
    needs to DerbyJS’ architecture, so I don’t think it’s a good fit for my project.”'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alice*：“作为一个产品开发者，我发现很难看到如何将我们产品的需求与 DerbyJS 的架构相匹配，所以我认为它不适合我的项目。”'
- en: '|  |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.7.5\. Weaknesses
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.7.5. 劣势
- en: It’s hard to convince people who are already experienced with either server-side
    or client-side libraries to use DerbyJS. Client-side developers who love React,
    for example, don’t typically want to use DerbyJS. Server-side developers who love
    making REST APIs or MVC projects and who are comfortable with WebSocket also fail
    to be motivated to learn DerbyJS.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 让已经熟悉服务器端或客户端库的人使用 DerbyJS 是一件困难的事情。例如，喜欢 React 的客户端开发者通常不想使用 DerbyJS。喜欢制作 REST
    API 或 MVC 项目并且对 WebSocket 感到舒适的服务器端开发者也未能被激励去学习 DerbyJS。
- en: 5.8\. Flatiron.js
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8. Flatiron.js
- en: Flatiron is a web framework that includes features for URL routing, data management,
    middleware, plugins, and logging. Unlike most web frameworks, Flatiron’s modules
    are designed to be decoupled, so you don’t have to use all of them. You could
    even use one or more in your own projects—if you like the logging module, for
    example, you could drop it into an Express project. Unlike many Node frameworks,
    Flatiron’s URL routing and middleware layers aren’t written using Express or Connect,
    although the middleware is backward-compatible with Connect. [Table 5.6](#ch05table06)
    summarizes Flatiron’s features.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: Flatiron是一个包含URL路由、数据管理、中间件、插件和日志功能的Web框架。与大多数Web框架不同，Flatiron的模块被设计为解耦的，因此你不必使用它们全部。你甚至可以在自己的项目中使用一个或多个——例如，如果你喜欢日志模块，你可以在Express项目中将其添加进去。与许多Node框架不同，Flatiron的URL路由和中间件层不是使用Express或Connect编写的，尽管中间件与Connect向后兼容。[表5.6](#ch05table06)总结了Flatiron的功能。
- en: Table 5.6\. Flatiron’s features
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.6\. Flatiron的功能
- en: '| **Library type** | Modular MVC framework |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| **库类型** | 模块化MVC框架 |'
- en: '| **Features** | Database management layer (Resourceful), decoupled reusable
    modules |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | 数据库管理层（资源丰富），解耦的可重用模块 |'
- en: '| **Suggested uses** | Lightweight MVC apps, use Flatiron modules in other
    frameworks |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| **建议用途** | 轻量级MVC应用，在其他框架中使用Flatiron模块 |'
- en: '| **Plugin architecture** | Broadway plugin API |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| **插件架构** | Broadway插件API |'
- en: '| **Documentation** | [https://github.com/flatiron](https://github.com/flatiron)
    |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| **文档** | [https://github.com/flatiron](https://github.com/flatiron) |'
- en: '| **Popularity** | 1,500 GitHub stars |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| **流行度** | 1,500 GitHub stars |'
- en: '| **License** | MIT |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| **许可证** | MIT |'
- en: 5.8.1\. Setting up
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.1\. 设置
- en: 'Installing Flatiron requires globally installing the command-line tool to create
    new Flatiron projects:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Flatiron需要全局安装命令行工具以创建新的Flatiron项目：
- en: '[PRE51]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After running these commands, you’ll find a new directory that contains a package.json
    file with the necessary dependencies. Run `npm install` to install the dependencies,
    and then `npm start` to run the app.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些命令后，你将找到一个包含带有必要依赖项的package.json文件的新目录。运行`npm install`来安装依赖项，然后运行`npm start`来启动应用。
- en: 'The main app.js file looks a lot like a typical Express app:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 主app.js文件看起来很像一个典型的Express应用：
- en: '[PRE52]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice, however, that the router is different from both Express and Koa. Responses
    are returned by using `this.res`, instead of an argument to the responder callback.
    Let’s look at Flatiron’s routes in more detail.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，路由器与Express和Koa都不同。响应是通过使用`this.res`返回的，而不是响应回调函数的参数。让我们更详细地看看Flatiron的路由。
- en: 5.8.2\. Defining routes
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.2\. 定义路由
- en: 'Flatiron’s routing library is called Director. Although it can be used for
    server routes, it also supports routes in browsers, so it can be used to make
    single-page apps as well. Director calls Express-style HTTP verb routes ad hoc:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Flatiron的路由库称为Director。尽管它可以用于服务器路由，但它也支持浏览器中的路由，因此可以用于制作单页应用。Director将Express风格的HTTP动词路由称为ad
    hoc：
- en: '[PRE53]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Routes can have parameters, and parameters can be defined with a regular expression:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 路由可以有参数，参数可以用正则表达式定义：
- en: '[PRE54]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To generate a response, use `res.writeHead` to send headers, and `res.end`
    to send the response body:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成响应，使用`res.writeHead`发送头部信息，并使用`res.end`发送响应体：
- en: '[PRE55]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The routing API can also be used as a class, with a routing table object. To
    use it, instantiate a new router and then use the dispatch method when HTTP requests
    arrive:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 路由API也可以作为一个类使用，带有路由表对象。要使用它，实例化一个新的路由器，然后在HTTP请求到达时使用dispatch方法：
- en: '[PRE56]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Using the routing API as a class also means you can hook into the streaming
    API. This makes dealing with large requests possible in a quick and easy way,
    which is good for doing things such as parsing uploaded data and exiting early:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由API作为类也意味着你可以挂钩到流式API。这使得以快速和简单的方式处理大型请求成为可能，这对于诸如解析上传数据并提前退出等操作是有益的：
- en: '[PRE57]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Director has a scoped routing API, which can be useful for creating REST APIs.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Director具有作用域路由API，这对于创建REST API很有用。
- en: 5.8.3\. REST APIs
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.3\. REST API
- en: 'REST APIs can be created with the standard Express HTTP verb style methods,
    or Director’s scoped routing feature. This allows routes to be grouped together
    based on URL fragments and URL parameters:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用标准的Express HTTP动词风格方法或Director的作用域路由功能创建REST API。这允许根据URL片段和URL参数将路由分组在一起：
- en: '[PRE58]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Flatiron also provides a high-level REST wrapper called Resourceful ([https://github.com/flatiron/resourceful](https://github.com/flatiron/resourceful)),
    which supports CouchDB, MongoDB, Socket.IO, and data validation.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: Flatiron 还提供了一个高级 REST 包装器，称为 Resourceful ([https://github.com/flatiron/resourceful](https://github.com/flatiron/resourceful))，它支持
    CouchDB、MongoDB、Socket.IO 和数据验证。
- en: 5.8.4\. Strengths
  id: totrans-470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.4\. 优势
- en: It’s hard for frameworks to gain traction, which is why Flatiron’s decoupled
    design is a major strength. You can use some of its modules without using the
    entire framework. For example, the Winston logging module ([https://github.com/winstonjs/winston](https://github.com/winstonjs/winston))
    is used by many projects that don’t use the rest of Flatiron. This means some
    parts of Flatiron receive a good level of open source contributions.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 框架要获得影响力是很困难的，这就是为什么 Flatiron 的解耦设计是一个主要优势。你可以使用其模块而不必使用整个框架。例如，Winston 日志模块
    ([https://github.com/winstonjs/winston](https://github.com/winstonjs/winston))
    被许多不使用 Flatiron 其他部分的项目所使用。这意味着 Flatiron 的某些部分收到了良好的开源贡献。
- en: 'The Director URL-routing API is isomorphic, so you can use it as a solution
    for both client- and server-side development. Director’s API differs from the
    Express-style routing APIs as well: Director has a simplified streaming API, and
    the routing object emits events before and after routes are executed.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 'The Director URL-routing API is isomorphic, so you can use it as a solution
    for both client- and server-side development. Director’s API differs from the
    Express-style routing APIs as well: Director has a simplified streaming API, and
    the routing object emits events before and after routes are executed.'
- en: Unlike most Node web frameworks, Flatiron has a plugin manager. Therefore, it's
    easier to extend Flatiron projects with community-supported plugins.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 Node 网络框架不同，Flatiron 有一个插件管理器。因此，使用社区支持的插件扩展 Flatiron 项目更容易。
- en: '|  |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Persona thoughts**'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**人物观点**'
- en: '*Nadine*: “I love Flatiron’s modular design, and the plugin manager is great.
    I can already think of some plugins that I’d like to make.”'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '*Nadine*: “我喜欢 Flatiron 的模块化设计，插件管理器也很棒。我已经能想到一些我想制作的插件。”'
- en: '*Alice*: “I don''t like the sound of all of Flatiron’s modules, so I’d like
    to try it with a different ORM and template library.”'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alice*: “我不喜欢 Flatiron 所有模块的声音，所以我想要尝试使用不同的 ORM 和模板库。”'
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.8.5\. Weaknesses
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.5\. 劣势
- en: Flatiron isn’t as easy to use for larger MVC-style projects as some other frameworks.
    For example, Sails is easier to set up. If you’re creating several medium-sized
    traditional web apps, Flatiron may work well. The ability to configure Flatiron
    is an added bonus, but make sure you evaluate it next to other options first.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于其他一些框架，Flatiron 对于大型 MVC 风格的项目来说并不那么容易使用。例如，Sails 更容易设置。如果你正在创建几个中等大小的传统
    Web 应用，Flatiron 可能会工作得很好。能够配置 Flatiron 是一个额外的优势，但请确保首先将其与其他选项进行比较评估。
- en: One strong competitor is LoopBack, which is the last framework that features
    in this chapter.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: LoopBack 是一个强大的竞争对手，它是本章中最后介绍的一个框架。
- en: 5.9\. LoopBack
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.9\. LoopBack
- en: LoopBack was created by StrongLoop, a company offering several commercial services
    that support the development of Node web apps. It’s billed as an API framework,
    but has features that make it work well with databases and for MVC apps. It even
    comes with a web interface for exploring and managing REST APIs. If you’re looking
    for something that will help create web APIs for mobile and desktop clients, LoopBack’s
    features are ideal. See [table 5.7](#ch05table07) for details about LoopBack.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: LoopBack 是由 StrongLoop 创建的，该公司提供多种支持 Node 网络应用开发的商业服务。它被定位为一个 API 框架，但它具有使它与数据库和
    MVC 应用很好地工作的功能。它甚至提供了一个用于探索和管理 REST API 的网络界面。如果你在寻找可以帮助为移动和桌面客户端创建 Web API 的东西，LoopBack
    的功能是理想的。见 [表 5.7](#ch05table07) 了解 LoopBack 的详细信息。
- en: Table 5.7\. LoopBack’s features
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.7\. LoopBack 的功能
- en: '| **Library type** | API framework |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| **库类型** | API 框架 |'
- en: '| **Features** | ORM, API user interface, WebSocket, client SDKs (including
    iOS) |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | ORM、API 用户界面、WebSocket、客户端 SDK（包括 iOS） |'
- en: '| **Suggested uses** | APIs that support multiple clients (mobile, desktop,
    web) |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| **推荐用途** | 支持多个客户端（移动、桌面、Web）的 API |'
- en: '| **Plugin architecture** | Express middleware |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| **插件架构** | Express 中间件 |'
- en: '| **Documentation** | [http://loopback.io/doc/](http://loopback.io/doc/) |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| **文档** | [http://loopback.io/doc/](http://loopback.io/doc/) |'
- en: '| **Popularity** | 6,500 GitHub stars |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| **流行度** | 6,500 GitHub 星标 |'
- en: '| **License** | Dual license: MIT and StrongLoop Subscription Agreement |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| **许可证** | 双重许可：MIT 和 StrongLoop 订阅协议 |'
- en: LoopBack is open source, and since StrongLoop’s acquisition by IBM, the framework
    now has major commercial endorsement. That makes it a unique offering in the Node
    community. It comes with Yeoman generators for quickly setting up application
    scaffolds. In the next section, you’ll see how to create a fresh LoopBack application.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: LoopBack是开源的，自从StrongLoop被IBM收购以来，该框架现在得到了主要商业认可。这使得它在Node社区中成为一个独特的提供物。它附带Yeoman生成器，可以快速设置应用程序骨架。在下一节中，您将看到如何创建新的LoopBack应用程序。
- en: 5.9.1\. Setting up
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.1\. 设置
- en: 'To set up a new LoopBack project, you need to use the StrongLoop command-line
    tools ([www.npmjs.com/package/strongloop](http://www.npmjs.com/package/strongloop)).
    Globally installing the strongloop package makes the command-line tools available
    through the `slc` command. This package includes features for process management,
    but what we’re interested in is the LoopBack project generator:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置新的LoopBack项目，您需要使用StrongLoop命令行工具([www.npmjs.com/package/strongloop](http://www.npmjs.com/package/strongloop))。全局安装strongloop包使得通过`slc`命令可用命令行工具。此包包括进程管理功能，但我们感兴趣的是LoopBack项目生成器：
- en: '[PRE59]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The StrongLoop command-line tool walks you through the steps necessary to set
    up a new project. Type in a name for the project and then select the api-server
    application skeleton. When the generator has finished installing the project’s
    dependencies, it will display some handy tips for working with the new project.
    [Figure 5.2](#ch05fig02) shows what this should look like.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: StrongLoop命令行工具会引导您完成设置新项目所需的步骤。输入项目名称，然后选择api-server应用程序骨架。当生成器完成安装项目的依赖项后，它将显示一些关于如何使用新项目的实用提示。[图5.2](#ch05fig02)显示了它应该看起来是什么样子。
- en: Figure 5.2\. LoopBack’s project generator
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. LoopBack的项目生成器
- en: '![](Images/05fig02_alt.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02_alt.jpg)'
- en: To run the project, type `node .`, and to create a model, use `slc loopback:model`.
    You’ll use the `slc` command regularly as you set up a new LoopBack project.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，请输入 `node .`，要创建模型，请使用 `slc loopback:model`。在设置新的LoopBack项目时，您将经常使用 `slc`
    命令。
- en: When the project is running, you should be able to access the API explorer at
    http://0.0.0.0:3000/explorer/. Click User to expand the User endpoint. You should
    see a large list of available API methods, including standard RESTful routes such
    as PUT /Users and DELETE /Users/{id}. [Figure 5.3](#ch05fig03) shows the API explorer.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目运行时，您应该能够访问API探索器，网址为http://0.0.0.0:3000/explorer/。点击User以展开User端点。您应该看到一个包含标准RESTful路由（如PUT
    /Users和DELETE /Users/{id}）在内的可用API方法的大列表。[图5.3](#ch05fig03)显示了API探索器。
- en: Figure 5.3\. The StrongLoop API explorer showing User routes
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 强Loop API探索器显示User路由
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03_alt.jpg)'
- en: 5.9.2\. Defining routes
  id: totrans-503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.2\. 定义路由
- en: 'In LoopBack, you can add routes at the Express level. Add a new file called
    server/boot/routes.js, and add a route by accessing the LoopBack Router instance:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在LoopBack中，您可以在Express级别添加路由。添加一个名为server/boot/routes.js的新文件，并通过访问LoopBack Router实例来添加路由：
- en: '[PRE60]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Visiting http://localhost:3000/hello will now respond with *Hello, world*. Adding
    routes this way, however, isn’t typical in a LoopBack project. It may be required
    for certain unusual API endpoints, but in general, routes are added automatically
    when models are generated.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 访问http://localhost:3000/hello现在将响应*Hello, world*。然而，以这种方式添加路由在LoopBack项目中并不典型。这可能对于某些不寻常的API端点来说是必需的，但通常，当生成模型时，路由会自动添加。
- en: 5.9.3\. REST APIs
  id: totrans-507
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.3\. REST API
- en: 'The easiest way to create REST APIs in a LoopBack project is by using the model
    generator. This is part of the `slc` command’s features. If you want to add a
    new model called *product*, for example, run `slc loopback:model`:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在LoopBack项目中创建REST API的最简单方法是使用模型生成器。这是`slc`命令功能的一部分。例如，如果您想添加一个名为*product*的新模型，请运行`slc
    loopback:model`：
- en: '[PRE61]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `slc` command walks you through the steps to create a model, allowing you
    to select whether the model is server-only, and set up some properties and validators.
    After you add a model, take a look at the corresponding JSON file—it should be
    in common/models/product.json. This JSON file is a lightweight way of defining
    how models behave, including all of the properties you specified in the previous
    step.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`slc`命令会引导您完成创建模型的步骤，允许您选择模型是否为服务器端专用，并设置一些属性和验证器。添加模型后，查看相应的JSON文件——它应该在common/models/product.json中。这个JSON文件是一种轻量级的方式来定义模型的行为，包括您在上一步中指定的所有属性。'
- en: If you want to add more properties, type `slc loopback:property`. You can add
    properties to models at any time.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想添加更多属性，请输入`slc loopback:property`。您可以在任何时候向模型添加属性。
- en: '|  |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Persona thoughts**'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '**人物想法**'
- en: '*Phil*: “Our teams love the sound of LoopBack, mainly because of the ability
    to quickly add RESTful resources and browse them with the API explorer. But I
    like it because it looks like it’s flexible enough to support our legacy MVC web
    apps. We could hook into the older database and move these projects over to Node.”'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '*Phil*：“我们的团队非常喜欢LoopBack，主要是因为它能够快速添加RESTful资源并通过API浏览器浏览它们。但我喜欢它，因为它看起来足够灵活，可以支持我们的遗留MVC
    Web应用。我们可以将其连接到旧数据库，并将这些项目迁移到Node。”'
- en: '*Alice*: “This is the only framework that really targets iOS and Android, as
    well as rich web clients. LoopBack has client libraries for iOS and Android, so
    this is a big deal for us as product developers who depend on mobile apps.”'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alice*：“这是唯一真正针对iOS、Android以及丰富Web客户端的框架。LoopBack为iOS和Android提供了客户端库，对我们这些依赖移动应用的产品开发者来说这是一个很大的优势。”'
- en: '|  |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.9.4\. Strengths
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.4\. 优点
- en: Even from this short introduction, it should be clear that one of the strengths
    of LoopBack is it removes the need to write boilerplate code. The command-line
    tool generates almost everything you need for lightweight RESTful web APIs, even
    database models and validation. At the same time, LoopBack doesn’t dictate too
    much about the front-end code. It also enables you to think about which models
    should be accessible to the browser and which are server-side only. Some frameworks
    get this wrong and push everything to the browser.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从这简短的介绍中，也应该清楚LoopBack的一个优点是它消除了编写样板代码的需要。命令行工具生成您需要的几乎所有轻量级RESTful Web API，甚至包括数据库模型和验证。同时，LoopBack对前端代码的限制也不多。它还使您能够考虑哪些模型应该对浏览器可访问，哪些仅限于服务器端。一些框架在这方面做得不对，将所有内容都推送到浏览器。
- en: If you have mobile apps that need to talk to your web APIs, take a look at LoopBack’s
    client SDKs ([http://loopback.io/doc/en/lb2/Client-SDKs.html](http://loopback.io/doc/en/lb2/Client-SDKs.html)).
    LoopBack supports API integration and push messages for both iOS and Android.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有需要与你的Web API通信的移动应用，请查看LoopBack的客户端SDKs ([http://loopback.io/doc/en/lb2/Client-SDKs.html](http://loopback.io/doc/en/lb2/Client-SDKs.html))。LoopBack支持iOS和Android的API集成和推送消息。
- en: 5.9.5\. Weaknesses
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.5\. 缺点
- en: LoopBack’s JSON-based model API is different from most JavaScript database APIs.
    It can take a while to learn how to map it to an existing project’s database schema.
    And because the HTTP layer is based on Express, it’s partly limited to what Express
    supports. Although Express is a solid HTTP server library, newer libraries are
    available for Node with more-modern APIs. LoopBack doesn’t have a specific plugin
    API. You can use Express middleware, but this isn’t as convenient as Flatiron
    or hapi’s plugin APIs.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: LoopBack基于JSON的模式API与大多数JavaScript数据库API不同。可能需要一段时间才能学会如何将其映射到现有项目的数据库模式。而且，由于HTTP层基于Express，它在一定程度上受到Express支持的限制。尽管Express是一个可靠的HTTP服务器库，但Node现在有更多现代API的库可用。LoopBack没有特定的插件API。您可以使用Express中间件，但这不如Flatiron或hapi的插件API方便。
- en: This concludes the frameworks that are covered in this chapter. Before moving
    on to the next chapter, let’s compare the frameworks to help you decide which
    is the right choice for your next project.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本章中涵盖的框架。在进入下一章之前，让我们比较这些框架，以帮助您决定哪个框架适合您的下一个项目。
- en: 5.10\. Comparison
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.10\. 比较
- en: If you’ve been following the persona thoughts throughout this chapter, you may
    already have decided which framework to use. If not, the rest of this chapter
    compares the benefits of each framework. And, if you’re still lost, [figure 5.4](#ch05fig04)
    will help you pick the right framework by answering some questions.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直关注本章中的人物想法，你可能已经决定使用哪个框架。如果没有，本章的其余部分将比较每个框架的优点。而且，如果你仍然感到困惑，[图5.4](#ch05fig04)将通过回答一些问题来帮助你选择正确的框架。
- en: Figure 5.4\. Choosing a Node framework
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4\. 选择Node框架
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: If you glance through Node’s popular server-side frameworks, they all sound
    similar. They offer lightweight HTTP APIs, and they use the server model instead
    of PHP’s page model. But the differences in their design have big implications
    for projects made with them, so to compare these frameworks, we’ll start at the
    HTTP level.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览一下Node流行的服务器端框架，它们听起来都很相似。它们提供轻量级的HTTP API，并且使用服务器模型而不是PHP的页面模型。但它们设计上的差异对使用它们的项目的意义很大，因此为了比较这些框架，我们将从HTTP级别开始。
- en: 5.10.1\. HTTP servers and routes
  id: totrans-528
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.10.1\. HTTP服务器和路由
- en: 'The majority of Node frameworks are based on Connect or Express. In this chapter,
    you’ve seen three that aren’t based on Express at all, and have their own solutions
    to HTTP APIs: Koa, hapi, and Flatiron.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Node框架都是基于Connect或Express构建的。在本章中，你已经看到了三个完全不基于Express的框架，它们有自己的HTTP API解决方案：Koa、hapi和Flatiron。
- en: Koa was created by the same author as Express, but offers a fresh approach by
    using more-modern JavaScript features. If you like Express but want to use ES2015
    generator syntax, Koa may work for you.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: Koa是由与Express相同的作者创建的，但通过使用更现代的JavaScript特性提供了新的方法。如果你喜欢Express但想使用ES2015生成器语法，Koa可能适合你。
- en: hapi’s server and routing APIs are highly modular and feel different from those
    of Express. If you find Express’s syntax awkward, you should give hapi a try.
    hapi makes it easier to reason about HTTP servers, so if you need to do things
    such as connect servers or cluster them, you may prefer hapi to Express descendants.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: hapi的服务器和路由API高度模块化，感觉与Express的不同。如果你觉得Express的语法不自然，你应该尝试一下hapi。hapi使得推理HTTP服务器变得更容易，所以如果你需要做诸如连接服务器或集群服务器的事情，你可能更喜欢hapi而不是Express的后代。
- en: Flatiron’s router is backward-compatible with Express but has extra features.
    The router emits events and uses a routing table. That’s different from the Express-style
    stack of middleware components. You can pass an object literal to Flatiron’s router.
    The router also works in browsers, so if you have server-side developers trying
    to tackle modern client-side development, they might be more at home with Flatiron
    than going all out with something like React Router.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: Flatiron的路由器与Express向后兼容，但具有额外功能。路由器会发出事件并使用路由表。这与Express风格的中间件组件堆栈不同。你可以向Flatiron的路由器传递一个对象字面量。路由器也可以在浏览器中工作，所以如果你有试图处理现代客户端开发的服务器端开发者，他们可能会觉得Flatiron比使用React
    Router等工具更自在。
- en: 5.11\. Writing modular code
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.11\. 编写模块化代码
- en: Not all of the frameworks covered here directly support plugins, but they’re
    all extensible in some way. The Express-based frameworks can use Connect middleware,
    but hapi and Flatiron have their own plugin APIs. Well-defined plugin APIs are
    useful because they make it easier for new users of a framework to extend it.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有在本章中讨论的框架都直接支持插件，但它们都以某种方式可扩展。基于Express的框架可以使用Connect中间件，但hapi和Flatiron有自己的插件API。定义良好的插件API很有用，因为它们使得框架的新用户更容易扩展它。
- en: If you’re using a larger MVC framework such as Sails.js or LoopBack, a plugin
    API makes it much easier to set up a new project. LoopBack partly sidesteps needing
    a plugin API by providing a highly capable project management tool. If you look
    at StrongLoop’s npm account ([www.npmjs.com/~strongloop](http://www.npmjs.com/~strongloop)),
    you’ll see lots of loopback-related projects that add support for things like
    Angular and several databases.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是像Sails.js或LoopBack这样的较大MVC框架，插件API使得设置新项目变得容易得多。LoopBack通过提供高度功能的项目管理工具部分避免了需要插件API。如果你查看StrongLoop的npm账户([www.npmjs.com/~strongloop](http://www.npmjs.com/~strongloop))，你会看到许多与loopback相关的项目，它们增加了对Angular和几个数据库的支持。
- en: 5.12\. Persona choices
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.12\. 角色选择
- en: 'The personas in this chapter now have enough background to make the right choice
    for their next project:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的人物角色现在已有足够的背景知识，可以为他们下一个项目做出正确的选择：
- en: 'Phil: “In the end I decided to go with LoopBack. It was a difficult choice
    because Sails and Kraken both have excellent features that my team liked, but
    we felt like LoopBack has stronger long-term support and reduces so much effort
    on server-side development.”'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 'Phil: “最终我决定选择LoopBack。这是一个艰难的选择，因为Sails和Kraken都拥有我们团队喜欢的出色功能，但我们感觉LoopBack有更强的长期支持，并且可以减少在服务器端开发上的大量努力。”'
- en: 'Nadine: “As an open source developer, I’ve opted for Flatiron. It’ll adapt
    to the various projects that I’m working on. For example, some projects will just
    use Winston and Director, but others will use the whole stack.”'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 'Nadine: “作为一个开源开发者，我选择了Flatiron。它将适应我正在工作的各种项目。例如，一些项目将仅使用Winston和Director，但其他项目将使用整个堆栈。”'
- en: 'Alice: “I’ve chosen hapi for my next project. It’s minimal, so I can adapt
    it to the project’s unique requirements. Most of the code will be Node and not
    rely on any specific framework, so I feel this works well with hapi.”'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 'Alice: “我已经为我的下一个项目选择了hapi。它很简洁，因此我可以根据项目的独特需求进行适配。大部分代码将是Node，并且不依赖于任何特定的框架，所以我感觉这与hapi很匹配。”'
- en: 5.13\. Summary
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.13\. 总结
- en: Koa is lightweight, minimal, and uses ES2015 generator syntax for middleware.
    It’s good for hosting single-page web apps that depend on external web APIs.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Koa轻量级、最小化，并使用ES2015生成器语法进行中间件。它适合托管依赖外部Web API的单页Web应用。
- en: hapi is focused on HTTP servers and routes. It’s good for lightweight back ends
    composed of lots of small services.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: hapi专注于HTTP服务器和路由。它适用于由许多小型服务组成的轻量级后端。
- en: Flatiron is a set of decoupled modules that can be used like either a web MVC
    framework or a more lightweight Express library. Flatiron is compatible with Connect
    middleware.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flatiron是一组解耦的模块，可以用作Web MVC框架或更轻量级的Express库。Flatiron与Connect中间件兼容。
- en: Kraken is based on Express, with added security features. It can be used for
    MVC.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kraken基于Express构建，并增加了安全特性。它可以用于MVC。
- en: Sails.js is a Rails/Django-inspired MVC framework. It has an ORM and a template
    system.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sails.js是一个受Rails/Django启发的MVC框架。它有一个ORM和一个模板系统。
- en: DerbyJS is an isomorphic framework that’s good for real-time applications.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DerbyJS是一个适用于实时应用程序的同构框架。
- en: LoopBack removes the need to write boilerplate code for quickly generating REST
    APIs complete with database support and an API explorer.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LoopBack消除了编写用于快速生成带有数据库支持和API浏览器的REST API的样板代码的需求。
- en: Chapter 6\. Connect and Express in depth
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 深入理解Connect和Express
- en: '*This chapter covers*'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding what Connect and Express are for
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Connect和Express的用途
- en: Using and creating middleware
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和创建中间件
- en: Creating and configuring an Express application
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和配置Express应用程序
- en: Using key Express techniques for error handling, rendering views, and forms
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用关键的Express技术进行错误处理、渲染视图和表单
- en: Using Express architectural techniques for routes, REST APIs, and authentication
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express架构技术进行路由、REST API和身份验证
- en: In [chapter 3](kindle_split_013.xhtml#ch03), you saw how to build a simple Express
    application. This chapter provides a more in-depth study of Express and Connect.
    These two popular Node modules are used by many web developers. This chapter shows
    you how to build web apps and REST APIs with the most commonly used patterns.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_013.xhtml#ch03)中，您看到了如何构建一个简单的Express应用程序。本章提供了对Express和Connect的更深入研究。这两个流行的Node模块被许多Web开发者使用。本章向您展示了如何使用最常用的模式构建Web应用程序和REST
    API。
- en: '|  |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Connect and Express**'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '**Connect和Express**'
- en: The concepts discussed in the following section are directly applicable to the
    higher-level framework Express because it extends and builds upon Connect with
    additional higher-level sugar. After reading this section, you’ll have a firm
    understanding of how Connect middleware works and how to compose components together
    to create an application. Other Node web frameworks work in a similar way, so
    learning Connect will give you a head start when learning new frameworks.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 下文中讨论的概念可以直接应用于高级框架Express，因为它通过添加额外的更高级的糖来扩展和构建在Connect之上。阅读本节后，您将深刻理解Connect中间件的工作原理以及如何组合组件来创建一个应用程序。其他Node网络框架以类似的方式工作，因此学习Connect将在学习新框架时给您带来先机。
- en: '|  |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To start, let’s see how to create a basic Connect application. Later in the
    chapter, you’ll see how to build a more complex Express application by using popular
    Express techniques.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何创建一个基本的Connect应用程序。在本章的后面部分，您将看到如何使用流行的Express技术构建一个更复杂的Express应用程序。
- en: 6.1\. Connect
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. Connect
- en: In this section, you’ll learn about *Connect*. You’ll see how its middleware
    can be used to build simple web applications, and how middleware ordering matters.
    This will help you to build more-modular Express applications later.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解*Connect*。您将看到如何使用其中间件来构建简单的Web应用程序，以及中间件排序的重要性。这将帮助您在以后构建更模块化的Express应用程序。
- en: 6.1.1\. Setting up a Connect application
  id: totrans-564
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 设置Connect应用程序
- en: 'Express is built with Connect, but do you know you can make a fully functionally
    web app with Connect alone? You can download and install Connect from the npm
    registry by using the command shown here:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: Express是用Connect构建的，但您知道您可以使用Connect单独创建一个功能齐全的Web应用程序吗？您可以通过以下命令从npm注册表中下载和安装Connect：
- en: '[PRE62]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here’s what a minimal Connect application looks like:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小化Connect应用程序的例子：
- en: '[PRE63]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This simple application (found under ch06-connect-and-express/hello-world in
    the sample code) will respond with *Hello, world!* The function passed to app.use
    is a middleware component that ends the request by sending back the *Hello, world!*
    text as a response. Middleware components form the basis of all Connect and Express
    apps. Let’s look at them in more detail.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的应用程序（在示例代码的ch06-connect-and-express/hello-world下找到）将响应*Hello, world!*传递给app.use的函数是一个中间件组件，通过发送*Hello,
    world!*文本作为响应来结束请求。中间件组件是所有Connect和Express应用程序的基础。让我们更详细地看看它们。
- en: 6.1.2\. Understanding how Connect middleware works
  id: totrans-570
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 理解Connect中间件的工作原理
- en: 'In Connect, a *middleware component* is a JavaScript function that by convention
    accepts three arguments: a request object, a response object, and an argument
    commonly named `next`, which is a callback function indicating that the component
    is done and the subsequent middleware component can be executed.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Connect 中，一个 *中间件组件* 是一个 JavaScript 函数，按照惯例接受三个参数：一个请求对象、一个响应对象，以及一个通常命名为
    `next` 的参数，它是一个回调函数，表示该组件已完成，可以执行后续的中间件组件。
- en: Before your middleware runs, Connect uses a dispatcher that takes in requests
    and then hands them off to the first middleware component that you’ve added to
    your application. [Figure 6.1](#ch06fig01) shows a typical Connect application,
    which is composed of the dispatcher as well as an arrangement of middleware including
    a logger, a body parser, a static file server, and custom middleware.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的中间件运行之前，Connect 使用一个调度器，它接收请求并将它们传递给第一个添加到应用程序中的中间件组件。[图 6.1](#ch06fig01)
    展示了一个典型的 Connect 应用程序，它由调度器以及包括日志记录器、体解析器、静态文件服务器和自定义中间件的中间件排列组成。
- en: Figure 6.1\. The life cycle of two HTTP requests making their way through a
    Connect server
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 两个 HTTP 请求通过 Connect 服务器的生命周期
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig01_alt.jpg)'
- en: As you can see, the design of the middleware API means that more-complex behavior
    can be composed of smaller building blocks. In the next section, you’ll see how
    to do this by combining components.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，中间件 API 的设计意味着更复杂的行为可以由更小的构建块组成。在下一节中，你将看到如何通过组合组件来实现这一点。
- en: 6.1.3\. Combining middleware
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 组合中间件
- en: Connect provides a method called `use` for combining middleware components.
    Let’s define two middleware functions and add them both to the application. One
    is the simple Hello World function from earlier, and the other is a logger.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 提供了一个名为 `use` 的方法来组合中间件组件。让我们定义两个中间件函数并将它们都添加到应用程序中。一个是之前简单的 Hello World
    函数，另一个是日志记录器。
- en: Listing 6.1\. Using multiple Connect middleware components
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 使用多个 Connect 中间件组件
- en: '![](Images/06lis01_alt.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis01_alt.jpg)'
- en: 'This middleware has two signatures: one with `next`, and one without. That’s
    because this component finishes the HTTP response and never needs to give control
    back to the dispatcher.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这个中间件有两个签名：一个带有 `next`，另一个不带。这是因为该组件完成 HTTP 响应，并且永远不需要将控制权交还给调度器。
- en: 'The `use()` function returns an instance of a Connect application to support
    method chaining, as shown previously. Note that chaining the `.use()` calls isn’t
    required, as shown in the following snippet:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '`use()` 函数返回一个 Connect 应用程序的实例以支持方法链式调用，如前所述。请注意，链式调用 `.use()` 调用不是必需的，如下面的代码片段所示：'
- en: '[PRE64]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now that you have a simple Hello World application working, we’ll look at why
    the ordering of middleware `.use()` calls is important, and how to strategically
    use that ordering to alter the way your application works.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个简单的 Hello World 应用程序运行起来，我们将探讨为什么中间件 `.use()` 调用的顺序很重要，以及如何战略性地使用这种顺序来改变应用程序的工作方式。
- en: 6.1.4\. Ordering middleware
  id: totrans-584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4\. 中间件排序
- en: The ordering of middleware in your application can dramatically affect the way
    it behaves. Execution can be stopped by omitting `next()`, and middleware can
    be combined to implement features such as authentication.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中中间件的顺序可以极大地影响其行为。可以通过省略 `next()` 来停止执行，并且可以将中间件组合起来实现如身份验证等功能。
- en: What happens when middleware components don’t call `next`? Consider the previous
    Hello World example, where the `logger` middleware component is used first, followed
    by the `hello` component. In that example, Connect logs to stdout and then responds
    to the HTTP request. But consider what would happen if the ordering were switched,
    as follows.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 当中间件组件没有调用 `next` 时会发生什么？考虑之前的 Hello World 示例，其中 `logger` 中间件组件首先使用，然后是 `hello`
    组件。在那个例子中，Connect 将日志记录到 stdout 并响应 HTTP 请求。但考虑如果顺序被切换，如下所示会发生什么。
- en: 'Listing 6.2\. Wrong: `hello` middleware component before `logger` component'
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 错误：`hello` 中间件组件在 `logger` 组件之前
- en: '![](Images/06lis02_alt.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis02_alt.jpg)'
- en: In this example, the `hello` middleware component is called first and responds
    to the HTTP request as expected. But `logger` is never called because `hello`
    never calls `next()`, so control is never passed back to the dispatcher to invoke
    the next middleware component. The moral here is that when a component doesn’t
    call `next()`, no remaining middleware in the chain of command will be invoked.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`hello`中间件组件首先被调用，并按预期响应HTTP请求。但是`logger`从未被调用，因为`hello`从未调用`next()`，所以控制权从未返回给调度器以调用下一个中间件组件。这里的教训是，当一个组件没有调用`next()`时，命令链中的任何剩余中间件都不会被调用。
- en: '[Figure 6.2](#ch06fig02) shows how this example would skip the logger, and
    how to correct it.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2](#ch06fig02)显示了此示例将跳过日志的情况以及如何纠正它。'
- en: Figure 6.2\. Middleware ordering is important.
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. 中间件的顺序很重要。
- en: '![](Images/06fig02_alt.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig02_alt.jpg)'
- en: As you can see, placing `hello` in front of `logger` is rather useless, but
    when used properly, ordering can be to your benefit.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将`hello`放在`logger`之前是相当无用的，但使用得当，顺序可以为你带来好处。
- en: 6.1.5\. Creating configurable middleware
  id: totrans-594
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.5\. 创建可配置的中间件
- en: You’ve learned some middleware basics; now we’ll go into detail and look at
    how to create more-generic and reusable middleware.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学了一些中间件的基础知识；现在我们将深入探讨如何创建更通用和可重用的中间件。
- en: 'Middleware commonly follows a simple convention in order to provide configuration
    capabilities to developers: using a function that returns another function (a
    closure). The basic structure for configurable middleware of this kind looks like
    this:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件通常遵循一个简单的约定，以便为开发者提供配置能力：使用一个返回另一个函数（闭包）的函数。这种类型的可配置中间件的基本结构看起来像这样：
- en: '![](Images/p0112_01.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/p0112_01.jpg)'
- en: 'This type of middleware is used as follows:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的中间件的使用方法如下：
- en: '[PRE65]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that the `setup` function is invoked in the `app.use` line, whereas in
    previous examples you were just passing a reference to the function.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`setup`函数在`app.use`行中被调用，而在之前的示例中，你只是传递了一个函数的引用。
- en: 'In this section, you’ll apply this technique to build three reusable, configurable
    middleware components:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将应用这种技术来构建三个可重用和可配置的中间件组件：
- en: A logger component with a configurable printing format
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有可配置打印格式的日志组件
- en: A router component that invokes functions based on the requested URL
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基于请求URL调用函数的路由组件
- en: A URL rewriter component that converts URL slugs to IDs
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将URL别名转换为ID的URL重写组件
- en: You’ll start by expanding your logger component to make it more configurable.
    The `logger` middleware component you created earlier in this chapter wasn’t configurable.
    It was hardcoded to print out the request’s `req.method` and `req.url` when invoked.
    But what if you want to change what the logger displays at some point in the future?
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从扩展你的日志组件开始，使其更具可配置性。本章前面创建的`logger`中间件组件不是可配置的。它在调用时硬编码为打印出请求的`req.method`和`req.url`。但如果你想在未来的某个时刻改变日志显示的内容呢？
- en: 'In practice, using configurable middleware is just like using any of the middleware
    you’ve created so far, except that you can pass additional arguments to the middleware
    component to alter its behavior. Using the configurable component in your application
    might look a little like the following example, where `logger` can accept a string
    that describes the format that it should print out:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，使用可配置的中间件就像使用你迄今为止创建的任何中间件一样，只是你可以向中间件组件传递额外的参数来改变其行为。在你的应用程序中使用可配置组件可能看起来像以下示例，其中`logger`可以接受一个字符串，描述它应该打印的格式：
- en: '[PRE66]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: To implement the configurable `logger` component, you first need to define a
    `setup` function that accepts a single string argument (in this example, you’ll
    name it `format`). When `setup` is invoked, a function is returned, and it’s the
    middleware component Connect will use. The returned component retains access to
    the `format` variable, even after the `setup` function has returned, because it’s
    defined within the same JavaScript closure. The `logger` then replaces the tokens
    in the `format` string with the associated request properties on the `req` object,
    logs to stdout, and calls `next()`, as shown in the following listing.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现可配置的`logger`组件，你首先需要定义一个`setup`函数，它接受一个字符串参数（在这个例子中，你将命名为`format`）。当`setup`被调用时，返回一个函数，这是Connect将使用的中间件组件。返回的组件保留了访问`format`变量的权限，即使在`setup`函数返回之后，因为它是在同一个JavaScript闭包中定义的。然后`logger`将`format`字符串中的占位符替换为`req`对象上关联的请求属性，记录到标准输出，并调用`next()`，如下面的列表所示。
- en: Listing 6.3\. A configurable `logger` middleware component for Connect
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. Connect的可配置`logger`中间件组件
- en: '![](Images/06lis03_alt.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis03_alt.jpg)'
- en: Because you’ve created this `logger` middleware component as configurable middleware,
    you can `.use()` the logger multiple times in a single application with different
    configurations or reuse this logger code in any number of future applications
    you might develop. This simple concept of configurable middleware is used throughout
    the Connect community, and it’s used for all core Connect middleware to maintain
    consistency.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你已经将这个`logger`中间件组件创建为可配置的中间件，所以你可以在单个应用程序中多次使用`.use()`来配置logger，或者在不同的应用程序中重用这个logger代码。这个简单的可配置中间件概念在整个Connect社区中被使用，并且用于所有核心Connect中间件以保持一致性。
- en: To use the logger middleware in [listing 6.3](#ch06ex03), you need to pass it
    a string that includes some of the properties found on the request object. For
    example, `.use(setup(':method :url'))` prints the HTTP method (`GET`, `POST`,
    and so forth) and URL of each request.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 要在[列表6.3](#ch06ex03)中使用logger中间件，你需要传递一个字符串，该字符串包含请求对象上的一些属性。例如，`.use(setup(':method
    :url'))`会打印出每个请求的HTTP方法（`GET`、`POST`等）和URL。
- en: Before moving on to Express, let’s look at how Connect supports error handling.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到Express之前，让我们看看Connect是如何支持错误处理的。
- en: 6.1.6\. Using error-handling middleware
  id: totrans-614
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.6\. 使用错误处理中间件
- en: All applications have errors, whether at the system level or the user level,
    and being well prepared for error situations—even ones you aren’t anticipating—is
    a smart thing to do. Connect implements an error-handling variant of middleware
    that follows the same rules as regular middleware but accepts an error object
    along with the request and response objects.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序都会出现错误，无论是在系统级别还是用户级别，为错误情况做好准备——即使是你没有预料到的——也是一件明智的事情。Connect实现了一个遵循与常规中间件相同规则的错误处理变体中间件，它接受一个错误对象以及请求和响应对象。
- en: Connect’s error handling is intentionally minimal, allowing the developer to
    specify the way errors should be handled. For example, you could pass only system
    and application errors through the middleware (for example, *foo is undefined*)
    or user errors (*password is invalid*) or a combination of both. Connect lets
    you choose which is best for your application.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: Connect的错误处理故意保持最小化，允许开发者指定错误处理的方式。例如，你可以只通过中间件传递系统错误和应用程序错误（例如，*foo未定义*）或用户错误（*密码无效*）或两者的组合。Connect让你选择最适合你应用程序的选项。
- en: 'In this section, you’ll use both types, and you’ll learn how error-handling
    middleware works. You’ll also learn some useful patterns that can be applied while
    we look at the following:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使用这两种类型，并学习错误处理中间件的工作方式。你还将学习一些有用的模式，这些模式可以在我们查看以下内容时应用：
- en: Using Connect’s default error handler
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Connect的默认错误处理器
- en: Handing application errors yourself
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自行处理应用程序错误
- en: Using multiple error-handling middleware components
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个错误处理中间件组件
- en: Let’s jump in with a look at how Connect handles errors without any configuration.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接看看Connect在没有任何配置的情况下是如何处理错误的。
- en: Using Connect’s default error handler
  id: totrans-622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Connect的默认错误处理器
- en: 'Consider the following middleware component, which will throw a `ReferenceError`
    error because the function `foo()` isn’t defined by the application:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下中间件组件，它将抛出一个`ReferenceError`错误，因为应用程序没有定义`foo()`函数：
- en: '[PRE67]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: By default, Connect will respond with a 500 status code, a response body containing
    the text *Internal Server Error*, and more information about the error itself.
    This is fine, but in any kind of real application, you’d probably want to do more-specialized
    things with those errors, such as send them off to a logging daemon.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Connect将以500状态码响应，包含文本*内部服务器错误*的响应体以及有关错误本身更多的信息。这很好，但在任何类型的实际应用程序中，你可能希望对那些错误进行更专业的处理，例如将它们发送到日志守护进程。
- en: Handling application errors yourself
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自行处理应用程序错误
- en: Connect also offers a way for you to handle application errors yourself, using
    error-handling middleware. For instance, in development you might want to respond
    to the client with a JSON representation of the error for quick and easy reporting,
    whereas in production you’d want to respond with a simple *Server error*, so as
    not to expose sensitive internal information (such as stack traces, filenames,
    and line numbers) to a potential attacker.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 还提供了一种方法，让您可以使用错误处理中间件自行处理应用程序错误。例如，在开发过程中，您可能希望向客户端返回错误的 JSON 表示形式，以便快速轻松地报告，而在生产环境中，您可能希望返回一个简单的
    *服务器错误*，以免向潜在的攻击者暴露敏感的内部信息（如堆栈跟踪、文件名和行号）。
- en: An error-handling middleware function must be defined to accept four arguments—`err`,
    `req`, `res`, and `next`—as shown in [listing 6.4](#ch06ex04), whereas regular
    middleware takes the arguments `req`, `res`, and `next`. The following listing
    shows an example error middleware. For a full example with a server, look at ch06-connect-and-express/listing6_4
    in the book’s source code.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理中间件函数必须定义以接受四个参数——`err`、`req`、`res` 和 `next`——如 [列表 6.4](#ch06ex04) 所示，而常规中间件则接受
    `req`、`res` 和 `next` 参数。以下列表显示了一个示例错误中间件。要查看带有服务器的完整示例，请参阅本书源代码中的 ch06-connect-and-express/listing6_4。
- en: Listing 6.4\. Error-handling middleware in Connect
  id: totrans-629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.4\. Connect 中的错误处理中间件
- en: '![](Images/06lis04_alt.jpg)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis04_alt.jpg)'
- en: '|  |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Use NODE_ENV to set the application’s mode
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 NODE_ENV 设置应用程序的模式
- en: A common Connect convention is to use the `NODE_ENV` environment variable (`process.env.NODE_ENV`)
    to toggle the behavior between server environments, such as production and development.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 的一个常见约定是使用 `NODE_ENV` 环境变量 (`process.env.NODE_ENV`) 在服务器环境之间切换行为，例如生产环境和开发环境。
- en: '|  |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When Connect encounters an error, it’ll switch to invoking only error-handling
    middleware, as you can see in [figure 6.3](#ch06fig03).
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Connect 遇到错误时，它将切换到仅调用错误处理中间件，正如您可以在 [图 6.3](#ch06fig03) 中看到的那样。
- en: Figure 6.3\. The life cycle of an HTTP request causing an error in a Connect
    server
  id: totrans-636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.3\. 在 Connect 服务器中引发错误的 HTTP 请求的生命周期
- en: '![](Images/06fig03_alt.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig03_alt.jpg)'
- en: 'Imagine you have an application that allows people to authenticate to an administration
    area for a blog. If the routing middleware component for the user routes causes
    an error, both the blog and admin middleware components will be skipped, because
    they don’t act as error-handling middleware—they only define three arguments.
    Connect will then see that `errorHandler` accepts the error argument and will
    invoke it. The middleware components could look something like this:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个允许人们登录博客管理区的应用程序。如果用户路由的中间件组件引发错误，则博客和 admin 中间件组件都将被跳过，因为它们不作为错误处理中间件——它们只定义了三个参数。然后
    Connect 将看到 `errorHandler` 接受错误参数，并将调用它。中间件组件可能看起来像这样：
- en: '[PRE68]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Short-circuiting functionality based on middleware execution is a fundamental
    concept used to organize Express applications. Now that you’ve learned the basics
    of Connect, it’s time to go into more detail about Express.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 基于中间件执行进行短路的功能是组织 Express 应用程序的基本概念。现在您已经了解了 Connect 的基础知识，是时候更详细地了解 Express
    了。
- en: 6.2\. Express
  id: totrans-641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 表达
- en: '*Express* is a popular web framework formerly built on Connect but still compatible
    with Connect middleware. Although Express comes with basic functionality, such
    as serving static files, URL routing, and application configuration, it’s still
    minimal. It provides enough structure so you can compose reusable chunks without
    being too restrictive of your development practices.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '*Express* 是一个流行的 Web 框架，最初建立在 Connect 之上，但仍然与 Connect 中间件兼容。尽管 Express 提供了基本功能，如静态文件服务、URL
    路由和应用配置，但它仍然非常简洁。它提供了足够的结构，以便您可以在不限制开发实践的情况下组合可重用的块。'
- en: Over the next few sections, you’ll implement a new Express application by using
    the Express skeleton app generator. This process is more detailed than the brief
    overview in [chapter 3](kindle_split_013.xhtml#ch03), so by the end of this chapter
    you should have enough knowledge of Express to build your own Express web apps
    and RESTful APIs. As the chapter continues, you’ll keep adding functionality to
    the skeleton to produce a full app by the end.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，您将通过使用 Express 骨干应用程序生成器来实现一个新的 Express 应用程序。这个过程比第 3 章中的简要概述更详细，因此到本章结束时，您应该对
    Express 有足够的了解，可以构建自己的 Express Web 应用程序和 RESTful API。随着本章的继续，您将不断向骨架添加功能，最终生成一个完整的应用程序。
- en: 6.2.1\. Generating the application skeleton
  id: totrans-644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 生成应用程序骨架
- en: Express doesn’t force application structure on the developer. You can place
    routes in as many files as you want, public assets in any directory you want,
    and so on. A minimal Express application can be as small as the following listing,
    which implements a fully functional HTTP server.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: Express不会强迫开发者使用特定的应用程序结构。你可以将路由放在你想要的任何文件中，将公共资产放在你想要的任何目录中，等等。一个最小的Express应用程序可以小到以下列表所示，它实现了一个完全功能的HTTP服务器。
- en: Listing 6.5\. A minimal Express application
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.5。一个最小的Express应用程序
- en: '![](Images/06lis05_alt.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06lis05_alt.jpg)'
- en: The `express(1)` command-line tool available in the express-generator package
    ([www.npmjs.com/package/express-generator](http://www.npmjs.com/package/express-generator))
    can set up an application skeleton for you. Using the generated application is
    a good way to get started if you’re new to Express, as it sets up an application
    complete with templates, public assets, configuration, and more.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: express-generator包中提供的`express(1)`命令行工具（[www.npmjs.com/package/express-generator](http://www.npmjs.com/package/express-generator)）可以为你设置应用程序骨架。如果你是Express的新手，使用生成的应用程序是一个很好的开始方式，因为它会设置一个包含模板、公共资产、配置等的应用程序。
- en: The default application skeleton that `express(1)` generates consists of only
    a few directories and files, as shown in [figure 6.4](#ch06fig04). This structure
    is designed to get developers up and running with Express in seconds, but the
    application’s structure is entirely up to you and your team to create.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`express(1)`生成的默认应用程序骨架仅包含几个目录和文件，如图6.4所示。这种结构旨在让开发者能在几秒钟内开始使用Express，但应用程序的结构完全由你和你的团队来创建。'
- en: Figure 6.4\. Default application skeleton structure using EJS templates
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4。使用EJS模板的默认应用程序骨架结构
- en: '![](Images/06fig04.jpg)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig04.jpg)'
- en: This chapter’s example uses Embedded JavaScript (EJS) templates, which are similar
    in structure to HTML. EJS is similar to PHP, JSP (for Java), and ERB (for Ruby),
    because server-side JavaScript is embedded in an HTML document and executed prior
    to being sent to the client. You’ll look at EJS more closely in [chapter 7](kindle_split_018.xhtml#ch07).
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例使用嵌入式JavaScript（EJS）模板，其结构与HTML相似。EJS类似于PHP、JSP（用于Java）和ERB（用于Ruby），因为服务器端JavaScript嵌入在HTML文档中并在发送到客户端之前执行。你将在第7章中更详细地了解EJS。
- en: 'In this section, you’ll do the following:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将执行以下操作：
- en: Install Express globally with npm
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用npm全局安装Express
- en: Generate the application
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成应用程序
- en: Explore the application and install dependencies
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索应用程序并安装依赖项
- en: Let’s get started.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Installing the Express executable
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安装Express可执行文件
- en: 'First, install express-generator globally with npm:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用npm全局安装express-generator：
- en: '[PRE69]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Next, you can use the `--help` flag to see the options available, as shown in
    [figure 6.5](#ch06fig05).
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用`--help`标志来查看可用的选项，如图6.5所示。
- en: Figure 6.5\. Express help
  id: totrans-662
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5。Express帮助
- en: '![](Images/06fig05.jpg)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig05.jpg)'
- en: Some of these options will generate small portions of the application for you.
    For example, you can specify a template engine to generate a dummy template file
    for the chosen template engine. Similarly, if you specify a CSS preprocessor by
    using the `--css` option, a dummy template file will be generated for it.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些选项会为你生成应用程序的小部分。例如，你可以指定一个模板引擎来为所选模板引擎生成一个占位符模板文件。同样，如果你使用`--css`选项指定了一个CSS预处理器，将为它生成一个占位符模板文件。
- en: Now that the executable is installed, let’s see how to generate what will become
    the photo application.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件安装完成后，让我们看看如何生成将成为照片应用程序的内容。
- en: Generating the application
  id: totrans-666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成应用程序
- en: For this application, you use the `-e` (or `--ejs`) flag to use the EJS templating
    engine. Execute `express -e shoutbox`. If you want to duplicate the code samples
    in our GitHub repository, use `express -e listing6_6`.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序，你使用`-e`（或`--ejs`）标志来使用EJS模板引擎。执行`express -e shoutbox`。如果你想复制我们GitHub仓库中的代码示例，使用`express
    -e listing6_6`。
- en: A fully functional application is created in the shoutbox directory. It contains
    a package.json file to describe the project and dependencies, the application
    file itself, the public file directories, and a directory for route handlers.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完全功能的应用程序在shoutbox目录中创建。它包含一个package.json文件来描述项目和依赖项，应用程序文件本身，公共文件目录，以及路由处理程序的目录。
- en: Exploring the application
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 探索应用程序
- en: 'Let’s take a closer look at what was generated. Open the package.json file
    in your editor to see the application’s dependencies, as shown in [figure 6.6](#ch06fig06).
    Express can’t guess which version of the dependencies you’ll want, so it’s good
    practice to supply the major, minor, and patch levels of the module so you don’t
    introduce any surprise bugs. For example, `"express": "~4.13.1"` is explicit and
    will provide you with identical code on each installation.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们更仔细地看看生成了什么。在您的编辑器中打开 package.json 文件，查看应用程序的依赖项，如图 [6.6](#ch06fig06) 所示。Express无法猜测你想要的依赖项版本，因此提供模块的主版本、次版本和补丁级别是良好的实践，这样你就不太可能引入任何意外错误。例如，`"express":
    "~4.13.1"` 是明确的，并且将在每次安装时提供相同的代码。'
- en: Figure 6.6\. Generated package.json contents
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6\. 生成的 package.json 内容
- en: '![](Images/06fig06.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig06.jpg)'
- en: Now look at the application file generated by `express(1)`, shown in the following
    listing. For now, you’ll leave this file as is. You should be familiar with these
    middleware components from the Connect sections earlier in this chapter, but it’s
    worth taking a look at how the default middleware configuration is set up.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看由 `express(1)` 生成的应用程序文件，如下所示。目前，你可以保持这个文件不变。你应该熟悉本章早期Connect部分中的这些中间件组件，但看看默认中间件配置是如何设置的也是值得的。
- en: Listing 6.6\. Generated Express application skeleton
  id: totrans-674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. 生成的Express应用程序骨架
- en: '![](Images/ch06ex06-0.jpg)'
  id: totrans-675
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex06-0.jpg)'
- en: '![](Images/ch06ex06-1.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex06-1.jpg)'
- en: You have the package.json and app.js files, but the application won’t run yet
    because the dependencies haven’t been installed. Whenever you generate a package.json
    file from `express(1)`, you need to install the dependencies. Execute `npm install`
    to do this, and then execute `npm start` to run the application.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 你有 package.json 和 app.js 文件，但应用程序还不能运行，因为依赖项尚未安装。每次你从 `express(1)` 生成 package.json
    文件时，都需要安装依赖项。执行 `npm install` 来完成此操作，然后执行 `npm start` 来运行应用程序。
- en: Check out the application by visiting http://localhost:3000 in your browser.
    The default application looks like the one in [figure 6.7](#ch06fig07).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在浏览器中访问 http://localhost:3000 来检查应用程序。默认应用程序看起来像 [图6.7](#ch06fig07) 中的那样。
- en: Figure 6.7\. Default Express application
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7\. 默认Express应用程序
- en: '![](Images/06fig07.jpg)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig07.jpg)'
- en: Now that you’ve seen the generated skeleton, you can start building a real Express
    application. The application will be a shoutbox that allows people to post messages.
    When building applications like this, most seasoned Express developers start by
    planning their API and hence the required routes and resources that will be required.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了生成的骨架，你可以开始构建一个真实的Express应用程序。该应用程序将是一个允许人们发布消息的 shoutbox。在构建此类应用程序时，大多数经验丰富的Express开发者会先规划他们的API，因此需要所需的路线和资源。
- en: Planning the shoutbox application
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 规划 shoutbox 应用程序
- en: 'Here are the requirements for the shoutbox application:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 shoutbox 应用程序的要求：
- en: It should allow users to register accounts, sign in, and sign out.
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它应该允许用户注册账户、登录和登出。
- en: Users should be able to post messages (entries).
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户应该能够发布消息（条目）。
- en: Site visitors should be able to paginate through entries.
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网站访客应该能够分页浏览条目。
- en: There should be a simple REST API that supports authentication.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该有一个简单的REST API来支持身份验证。
- en: 'You need to store data and handle authentication. You also need to validate
    user input. The necessary routes look something like this:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要存储数据并处理身份验证。你还需要验证用户输入。必要的路由看起来像这样：
- en: API routes
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 路由
- en: 'GET /api/entries: Get a list of entries'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GET /api/entries: 获取条目列表'
- en: 'GET /api/entries/page: Get a single page of entries'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GET /api/entries/page: 获取单个页面的条目'
- en: 'POST /api/entry: Create a new shoutbox entry'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'POST /api/entry: 创建新的 shoutbox 条目'
- en: Web UI routes
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web UI 路由
- en: 'GET /post: The form for a new entry'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GET /post: 新条目的表单'
- en: 'POST /post: Post a new entry'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'POST /post: 发布新条目'
- en: 'GET /register: Show the registration form'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GET /register: 显示注册表单'
- en: 'POST /register: Create a new account'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'POST /register: 创建新账户'
- en: 'GET /login: Show the sign-in form'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GET /login: 显示登录表单'
- en: 'POST /login: Sign in'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'POST /login: 登录'
- en: 'GET /logout: Sign out'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'GET /logout: 登出'
- en: This layout is similar to that of most web applications. Hopefully, you’ll be
    able to use the example from this chapter as a template for your own applications
    in the future.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 这种布局与大多数Web应用程序类似。希望你能将本章中的示例作为你未来应用程序的模板。
- en: 'In the previous listing, you may have noticed some calls to `app.set`:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，你可能注意到了对 `app.set` 的调用：
- en: '[PRE70]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is how Express applications are configured. The next section explains Express
    configuration in more detail.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Express应用程序的配置方式。下一节将更详细地解释Express的配置。
- en: 6.2.2\. Configuring Express and your application
  id: totrans-705
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 配置Express和你的应用程序
- en: Your application’s requirements will depend on the environment in which it’s
    running. For example, you may want verbose logging when your product is in development,
    but a leaner set of logs and gzip compression when it’s in production. In addition
    to configuring environment-specific functionality, you may want to define some
    application-level settings so Express knows what template engine you’re using
    and where it can find the templates. Express also lets you define custom configuration
    key/value pairs.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序需求将取决于其运行的环境。例如，当你的产品处于开发阶段时，你可能希望有详细的日志记录，而当它处于生产阶段时，你可能希望有一组更精简的日志和gzip压缩。除了配置特定于环境的功能外，你可能还想定义一些应用程序级别的设置，以便Express知道你正在使用哪个模板引擎以及它可以在哪里找到模板。Express还允许你定义自定义配置键/值对。
- en: '|  |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Setting environment variables**'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置环境变量**'
- en: 'To set an environment variable in UNIX systems, you can use this command:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 要在UNIX系统中设置环境变量，你可以使用以下命令：
- en: '[PRE71]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In Windows, you can use this code:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows系统中，你可以使用以下代码：
- en: '[PRE72]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: These environment variables will be available in your application on the `process.env`
    object.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 这些环境变量将在你的应用程序的`process.env`对象中可用。
- en: '|  |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Express has a minimal environment-driven configuration system, consisting of
    several methods, all driven by the `NODE_ENV` environment variable:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: Express有一个基于环境的最小配置系统，由几个方法组成，这些方法都由`NODE_ENV`环境变量驱动：
- en: '`app.set()`'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.set()`'
- en: '`app.get()`'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.get()`'
- en: '`app.enable()`'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.enable()`'
- en: '`app.disable()`'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.disable()`'
- en: '`app.enabled()`'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.enabled()`'
- en: '`app.disabled()`'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.disabled()`'
- en: In this section, you’ll see how to use the configuration system to customize
    the way Express behaves, as well as how to use this system for your own purposes
    throughout development.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解如何使用配置系统来自定义Express的行为方式，以及如何在开发过程中使用此系统满足自己的目的。
- en: Let’s take a closer look at what *environment-based configuration* means. Although
    the `NODE_ENV` environment variable originated in Express, many other Node frameworks
    have adopted it as a means to notify the Node application which environment it’s
    operating within, defaulting to development.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看基于环境的配置意味着什么。尽管`NODE_ENV`环境变量起源于Express，但许多其他Node框架都采用了它作为通知Node应用程序其操作环境的手段，默认为开发环境。
- en: 'The `app.configure()` method accepts optional strings representing the environment,
    and a function. When the environment matches the string passed, the callback is
    immediately invoked; when only a function is given, it’s invoked for all environments.
    These environment names are completely arbitrary. For example, you may have `development`,
    `stage`, `test`, and `production`, or `prod` for short:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.configure()`方法接受表示环境的可选字符串和一个函数。当环境与传递的字符串匹配时，回调函数立即被调用；当只提供一个函数时，它将在所有环境中被调用。这些环境名称完全是任意的。例如，你可能会有`development`、`stage`、`test`和`production`，或者简称为`prod`：'
- en: '[PRE73]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Express uses the configuration system internally, allowing you to customize
    the way Express behaves, but it’s also available for your own use.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: Express内部使用配置系统，允许你自定义Express的行为方式，但它也适用于你自己的使用。
- en: Express also provides Boolean variants of `app.set()` and `app.get()`. For example,
    `app.enable(setting)` is equivalent to `app.set(setting, true)`, and `app.enabled
    (setting)` can be used to check whether the value was enabled. The methods `app.disable
    (setting)` and `app.disabled(setting)` complement the truthful variants.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: Express还提供了`app.set()`和`app.get()`的布尔变体。例如，`app.enable(setting)`等同于`app.set(setting,
    true)`，而`app.enabled (setting)`可以用来检查值是否已启用。`app.disable (setting)`和`app.disabled(setting)`方法与真实变体互补。
- en: 'A useful setting for developing APIs with Express is the `json spaces` option.
    If you add it to your app.js file, your JSON will be printed in a more readable
    format:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Express开发API时，一个有用的设置是`json spaces`选项。如果你将其添加到你的app.js文件中，你的JSON将以更可读的格式打印出来：
- en: '[PRE74]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now that you’ve seen how to take advantage of the configuration system for your
    own use, let’s look at rendering views in Express.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何利用配置系统来满足自己的需求，让我们看看如何在Express中渲染视图。
- en: 6.2.3\. Rendering views
  id: totrans-731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. 渲染视图
- en: In this chapter’s application, you’ll use EJS templates, though as previously
    mentioned, almost any template engine in the Node community can be used. If you’re
    not familiar with EJS, don’t worry. It’s similar to templating languages found
    in other web development platforms (PHP, JSP, ERB). We cover some basics of EJS
    in this chapter, but we discuss EJS and several other template engines in greater
    detail in [chapter 7](kindle_split_018.xhtml#ch07).
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的应用中，你将使用EJS模板，尽管如前所述，Node社区中的几乎任何模板引擎都可以使用。如果你不熟悉EJS，不要担心。它与在其他Web开发平台（PHP、JSP、ERB）中找到的模板语言类似。我们在本章中介绍了EJS的一些基础知识，但在第7章中我们将更详细地讨论EJS和几个其他模板引擎。[第7章](kindle_split_018.xhtml#ch07)。
- en: 'Whether it’s rendering an entire HTML page, an HTML fragment, or an RSS feed,
    rendering views is crucial for nearly every application. The concept is simple:
    you pass data to a *view*, and that data is transformed, typically to HTML for
    web applications. You’re likely familiar with the idea of views, because most
    frameworks provide similar functionality; [figure 6.8](#ch06fig08) illustrates
    how a view forms a new representation for the data.'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在渲染整个HTML页面、HTML片段还是RSS源，对于几乎所有应用来说，渲染视图都是至关重要的。这个概念很简单：你将数据传递给一个 *视图*，然后这些数据被转换，通常是转换为HTML以供Web应用使用。你很可能熟悉视图的概念，因为大多数框架都提供了类似的功能；[图6.8](#ch06fig08)说明了视图如何为数据形成新的表示。
- en: Figure 6.8\. HTML template plus data = HTML view of data
  id: totrans-734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8\. HTML模板加数据 = 数据的HTML视图
- en: '![](Images/06fig08.jpg)'
  id: totrans-735
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig08.jpg)'
- en: 'The template that generates template 6.8 can be found in the following snippet:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 生成模板6.8的模板可以在以下片段中找到：
- en: '[PRE75]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Express provides two ways to render views: at the application level with `app.render()`,
    and at the response with `res.render()`, which uses the former internally. In
    this chapter, you’ll use only `res.render()`. If you look in ./routes/index.js,
    a function is defined that invokes `res.render(''index'')` in order to render
    the ./views/index.ejs template, as shown in the following code (found in listing6_8):'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: Express提供了两种渲染视图的方式：在应用级别使用 `app.render()`，以及在响应中使用 `res.render()`，后者内部使用前者。在本章中，你将只使用
    `res.render()`。如果你查看 ./routes/index.js，会发现定义了一个函数，它调用 `res.render('index')` 以渲染
    ./views/index.ejs 模板，如下面的代码（在列表6_8中找到）所示：
- en: '[PRE76]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Before looking at `res.render()` more closely, let’s see how to configure the
    view system.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细地查看 `res.render()` 之前，让我们看看如何配置视图系统。
- en: Configuring the view system
  id: totrans-741
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 配置视图系统
- en: 'Configuring the Express view system is simple. But even though `express(1)`
    generated the configuration for you, it’s still useful to know what’s going on
    behind the scenes so you can make changes. We’ll focus on three areas:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Express视图系统很简单。尽管 `express(1)` 为你生成了配置，但了解幕后发生的事情仍然很有用，这样你就可以进行更改。我们将重点关注三个区域：
- en: Adjusting the view lookup
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整视图查找
- en: Configuring the default template engine
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置默认模板引擎
- en: Enabling view caching to reduce file I/O
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用视图缓存以减少文件I/O
- en: First up is the `views` setting.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是 `views` 设置。
- en: Changing the lookup directory
  id: totrans-747
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更改查找目录
- en: 'The following snippet shows the `views` setting that the Express executable
    created:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了Express可执行文件创建的 `views` 设置：
- en: '[PRE77]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This specifies the directory that Express will use during view lookup. It’s
    a good idea to use `__dirname` so that your application isn’t dependent on the
    current working directory being the application’s root.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了Express在视图查找期间将使用的目录。使用 `__dirname` 是一个好主意，这样你的应用程序就不会依赖于当前工作目录是应用程序的根目录。
- en: '|  |'
  id: totrans-751
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**__dirname**'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '**__dirname**'
- en: '`__dirname` (with two leading underscores) is a global variable in Node that
    identifies the directory in which the currently running file *exists*. Often in
    development this directory will be the same as your current working directory
    (CWD), but in production the Node executable may run from another directory. Using
    `__dirname` helps keep paths consistent across environments.'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '`__dirname`（带有两个前置下划线）是Node中的一个全局变量，用于标识当前运行文件所在的目录。通常在开发中，这个目录将与你的当前工作目录（CWD）相同，但在生产中，Node可执行文件可能从另一个目录运行。使用
    `__dirname` 有助于在不同环境中保持路径的一致性。'
- en: '|  |'
  id: totrans-754
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next setting is `view engine`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个设置是 `view engine`。
- en: Using the default template engine
  id: totrans-756
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用默认模板引擎
- en: When `express(1)` generated the application, the `view engine` setting was assigned
    `ejs` because EJS was the template engine selected by the `-e` command-line option.
    This setting enables you to render `index` rather than index.ejs. Otherwise, Express
    requires the extension in order to determine which template engine is to be used.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 当`express(1)`生成应用程序时，`view engine`设置被分配为`ejs`，因为EJS是`-e`命令行选项选择的模板引擎。这个设置使你能够渲染`index`而不是index.ejs。否则，Express需要扩展名来确定要使用哪个模板引擎。
- en: You might be wondering why Express even considers extensions. The use of extensions
    allows you to use multiple template engines within a single Express application,
    while providing a clean API for common use cases, because most applications will
    use one template engine.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么Express甚至考虑扩展名。扩展名的使用允许你在单个Express应用程序中使用多个模板引擎，同时为常见用例提供干净的API，因为大多数应用程序将使用一个模板引擎。
- en: 'Suppose, for example, you find writing RSS feeds easier with another template
    engine, or perhaps you’re migrating from one template engine to another. You might
    use Pug as the default, and EJS for the /feed route, as indicated in the following
    code by the .ejs extension:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你发现使用另一个模板引擎编写RSS源更容易，或者你可能正在从一个模板引擎迁移到另一个模板引擎。你可能将Pug作为默认引擎，将EJS用于/feeds路由，如下面的代码所示，通过.ejs扩展名：
- en: '[PRE78]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '|  |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Keeping package.json in sync
  id: totrans-762
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保持package.json同步
- en: Keep in mind that any additional template engines you wish to use should be
    added to your package.json dependencies object. Try to remember to install packages
    with `npm install --save package-name`. Remove them with `npm uninstall --save
    package-name` to delete them from node_modules and package.json. This makes experimenting
    with different template engines easier when you’re still trying to figure out
    which one you want to use.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你希望使用的任何额外的模板引擎都应该添加到你的package.json依赖对象中。尽量记得使用`npm install --save package-name`来安装包。使用`npm
    uninstall --save package-name`来删除它们，从而从node_modules和package.json中移除。这使你在尝试确定要使用哪个模板引擎时，实验不同的模板引擎变得更加容易。
- en: '|  |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: View caching
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 视图缓存
- en: The `view cache` setting is enabled by default in the production environment
    and prevents subsequent `render()` calls from performing disk I/O. The contents
    of the templates are saved in memory, greatly improving performance. The side
    effect of enabling this setting is that you can no longer edit the template files
    without restarting the server, which is why it’s disabled in development. If you’re
    running a staging environment, you’ll likely want to enable this option.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，默认启用`view cache`设置，防止后续的`render()`调用执行磁盘I/O。模板的内容保存在内存中，大大提高了性能。启用此设置的副作用是，你将无法在不重新启动服务器的情况下编辑模板文件，这就是为什么它在开发中是禁用的。如果你正在运行预发布环境，你可能会想要启用此选项。
- en: As illustrated in [figure 6.9](#ch06fig09), when `view cache` is disabled, the
    template is read from disk on every request. This is what allows you to make changes
    to a template without restarting the application. When `view cache` is enabled,
    the disk is hit only once per template.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图6.9](#ch06fig09)所示，当禁用`view cache`时，每次请求都会从磁盘读取模板。这就是为什么你可以修改模板而无需重新启动应用程序的原因。当启用`view
    cache`时，每个模板只访问磁盘一次。
- en: Figure 6.9\. The view cache setting
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.9\. 视图缓存设置
- en: '![](Images/06fig09_alt.jpg)'
  id: totrans-769
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig09_alt.jpg)'
- en: You’ve seen how the view-caching mechanism helps improve performance in a nondevelopment
    environment. Now let’s see how Express locates views in order to render them.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了视图缓存机制如何帮助在非开发环境中提高性能。现在让我们看看Express是如何定位视图以便渲染的。
- en: View lookup
  id: totrans-771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 视图查找
- en: The process of looking up a view is similar to the way Node’s `require()` works.
    When `res.render()` or `app.render()` is invoked, Express first checks whether
    a file exists at an absolute path. Next, Express looks relative to the views directory.
    Finally, Express tries an index file. This process is represented as a flowchart
    in [figure 6.10](#ch06fig10).
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 查找视图的过程类似于Node的`require()`工作方式。当调用`res.render()`或`app.render()`时，Express首先检查在绝对路径下是否存在文件。接下来，Express在视图目录中查找。最后，Express尝试索引文件。这个过程在[图6.10](#ch06fig10)中用流程图表示。
- en: Figure 6.10\. Express view lookup process
  id: totrans-773
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10\. 表达视图查找过程
- en: '![](Images/06fig10.jpg)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig10.jpg)'
- en: Because `ejs` is set as the default engine, the render call omits the .ejs extension,
    and the template file will still be resolved correctly.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`ejs`被设置为默认引擎，所以渲染调用省略了.ejs扩展名，模板文件仍然可以正确解析。
- en: As the application evolves, you’ll need more views, and sometimes several for
    a single resource. Using `view lookup` can help with organization—for example,
    you can use subdirectories related to the resource and create views within them.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的发展，你可能需要更多的视图，有时甚至需要为单个资源创建多个视图。使用 `view lookup` 可以帮助组织——例如，你可以使用与资源相关的子目录，并在其中创建视图。
- en: Adding subdirectories allows you to eliminate redundant parts of names (such
    as edit-entry.ejs and show-entry.ejs). Express then adds the `view engine` extension
    and resolves `res.render('entries/edit')` to ./views/entries/edit.ejs.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 添加子目录允许你消除名称中的冗余部分（如 edit-entry.ejs 和 show-entry.ejs）。然后 Express 添加 `view engine`
    扩展，并将 `res.render('entries/edit')` 解析为 ./views/entries/edit.ejs。
- en: Express checks to see whether a file named *index* resides in subdirectories
    of the view directory. When files are named with a pluralized resource, such as
    *entries*, this typically implies a resource listing. This means you can use `res.render('entries')`
    to render the file in views/entries/index.ejs.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: Express 会检查视图目录的子目录中是否存在名为 *index* 的文件。当文件以复数资源命名，如 *entries* 时，这通常意味着资源列表。这意味着你可以使用
    `res.render('entries')` 来渲染 views/entries/index.ejs 中的文件。
- en: Methods of exposing data to views
  id: totrans-779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据展示给视图的方法
- en: You’ve seen how to pass local variables directly to `res.render()` calls, but
    you can also use a few other mechanisms for this. For example, you can use `app.locals`
    for application-level variables, and `res.locals` for request-level local variables
    that are typically set by middleware components prior to the final route-handling
    method where views are rendered.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '你已经看到了如何直接将局部变量传递给 `res.render()` 调用，但你也可以使用一些其他机制来完成这个任务。例如，你可以使用 `app.locals`
    来存储应用级别的变量，以及 `res.locals` 来存储请求级别的局部变量，这些变量通常由中间件组件在渲染视图的最终路由处理方法之前设置。 '
- en: The values passed directly to `res.render()` take precedence over values set
    in `res.locals` and `app.locals`, as [figure 6.11](#ch06fig11) shows.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 直接传递给 `res.render()` 的值优先于在 `res.locals` 和 `app.locals` 中设置的值，如 [图 6.11](#ch06fig11)
    所示。
- en: Figure 6.11\. Values passed directly to the `render` function take precedence
    when rendering a template.
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.11\. 在渲染模板时，直接传递给 `render` 函数的值具有优先级。
- en: '![](Images/06fig11.jpg)'
  id: totrans-783
  prefs: []
  type: TYPE_IMG
  zh: '![Images/06fig11.jpg]'
- en: 'By default, Express exposes only one application-level variable, `settings`,
    to views, which is the object containing all of the values set with `app.set()`.
    For example, using `app.set(''title'', ''My Application'')` would expose `settings.title`
    in the template, as shown in the following EJS snippet:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Express 只向视图暴露一个应用级别的变量 `settings`，它是一个包含所有使用 `app.set()` 设置的值的对象。例如，使用
    `app.set('title', 'My Application')` 会在模板中暴露 `settings.title`，如下面的 EJS 片段所示：
- en: '[PRE79]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Internally, Express exposes this object with the following JavaScript:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Express 使用以下 JavaScript 暴露此对象：
- en: '[PRE80]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: That’s all there is to it! Now that you’ve seen how to render views and send
    data to them, let’s look at how routes are defined and see how to write route
    handlers that can render views for the shoutbox application. You’ll also set up
    database models to persist data.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！现在你已经看到了如何渲染视图并将数据发送给它们，让我们看看如何定义路由，并了解如何编写可以为 shoutbox 应用程序渲染视图的路由处理程序。你还将设置数据库模型以持久化数据。
- en: 6.2.4\. Express routing 101
  id: totrans-789
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.4\. Express 路由 101
- en: The primary function of Express routes is to pair a URL pattern with response
    logic. But routes also can pair a URL pattern with middleware. This allows you
    to use middleware to provide reusable functionality to certain routes.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: Express 路由的主要功能是将 URL 模式与响应逻辑配对。但路由也可以将 URL 模式与中间件配对。这允许你使用中间件为某些路由提供可重用的功能。
- en: 'In this section, you’ll do the following:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将执行以下操作：
- en: Validate user-submitted content by using route-specific middleware
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由特定的中间件验证用户提交的内容
- en: Implement route-specific validation
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现路由特定的验证
- en: Implement pagination
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现分页
- en: Let’s explore some of the ways to use route-specific middleware.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些使用路由特定中间件的方法。
- en: Validating user content submission
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 验证用户内容提交
- en: 'To give you something to apply validation to, you’re going to finally add the
    ability to post to the shoutbox application. To add the ability to post, you need
    to do a few things:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你有东西可以应用验证，你最终将添加到 shoutbox 应用程序中发布的能力。为了添加发布的能力，你需要做几件事情：
- en: Create an entry model
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建条目模型
- en: Add entry-related routes
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加与条目相关的路由
- en: Create an entry form
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建条目表单
- en: Add logic to create entries using submitted form data
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加逻辑以使用提交的表单数据创建条目
- en: You’ll start by creating an entry model.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先创建一个条目模型。
- en: Creating an entry model
  id: totrans-803
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建条目模型
- en: Before moving on, you need to install the Node redis module into the project.
    Install it with `npm install --save redis`. If you don’t have Redis installed,
    go to [http://redis.io/](http://redis.io/) to learn how to install it; if you’re
    using macOS, you can easily install it with Homebrew ([http://brew.sh/](http://brew.sh/)),
    and Windows has a Redis Chocolatey package ([https://chocolatey.org/](https://chocolatey.org/)).
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要将 Node redis 模块安装到项目中。使用 `npm install --save redis` 安装它。如果你没有安装 Redis，请访问
    [http://redis.io/](http://redis.io/) 了解如何安装它；如果你使用 macOS，你可以很容易地使用 Homebrew ([http://brew.sh/](http://brew.sh/))
    安装它，Windows 有 Redis Chocolatey 软件包 ([https://chocolatey.org/](https://chocolatey.org/))。
- en: 'We’re using Redis to cheat a little bit: the features of Redis and ES6 make
    creating lightweight models without a complex database library easy. If you’re
    feeling ambitious, you could use another database library (see [chapter 8](kindle_split_019.xhtml#ch08)
    for more about databases in Node).'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Redis 来稍微作弊一下：Redis 的功能和 ES6 使得在没有复杂数据库库的情况下创建轻量级模型变得容易。如果你有雄心壮志，可以使用另一个数据库库（有关
    Node 中的数据库的更多信息，请参阅第 8 章）。
- en: Let’s see how to create a lightweight model to store your shoutbox entries.
    Create a file to contain the entry model definition at models/entry.js. Add the
    code contained in the following listing to this file. The entry model will be
    a simple ES6 class that saves data in a Redis list.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个轻量级模型来存储你的喊话条目。创建一个文件来包含条目模型定义，在 models/entry.js 中。将以下列表中的代码添加到此文件。条目模型将是一个简单的
    ES6 类，它将数据保存到 Redis 列表中。
- en: Listing 6.7\. A model for entries
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.7\. 条目模型
- en: '![](Images/06lis07_alt.jpg)'
  id: totrans-808
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis07_alt.jpg)'
- en: With the basic model fleshed out, you now need to add a function called `getRange`,
    using the contents of the following listing. This function will allow you to retrieve
    entries.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本模型完善之后，你现在需要添加一个名为 `getRange` 的函数，使用以下列表的内容。此函数将允许你检索条目。
- en: Listing 6.8\. Logic to retrieve a range of entries
  id: totrans-810
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.8\. 获取条目范围的逻辑
- en: '![](Images/06lis08_alt.jpg)'
  id: totrans-811
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis08_alt.jpg)'
- en: With a model created, you can now add routes to create and list entries.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了一个模型之后，你现在可以添加创建和列出条目的路由。
- en: Creating an entry form
  id: totrans-813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建条目表单
- en: 'The app has the ability to list entries, but no way to add them. You’ll add
    this capability next, starting by adding the following lines to the routing section
    of app.js:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序具有列出条目的能力，但没有添加条目的方法。你将在下一个步骤中添加此功能，首先在 app.js 的路由部分添加以下行：
- en: '[PRE81]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Next, add the following route to routes/entries.js. This route logic will render
    a template containing a form:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下路由添加到 routes/entries.js 中。此路由逻辑将渲染包含表单的模板：
- en: '[PRE82]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Next, use the EJS template in the following listing to create a template for
    the form and save it to views/post.ejs.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下列表中的 EJS 模板创建表单模板并将其保存到 views/post.ejs 中。
- en: Listing 6.9\. A form for entering post data
  id: totrans-819
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.9\. 输入帖子数据的表单
- en: '![](Images/06lis09_alt.jpg)'
  id: totrans-820
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis09_alt.jpg)'
- en: This form uses input names such as `entry[title]`, so extended body parsing
    is required. To change the body parser, open app.js, and move to the line that
    reads
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单使用如 `entry[title]` 这样的输入名称，因此需要扩展体解析。要更改体解析器，打开 app.js，并移动到读取
- en: '[PRE83]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Change this to use extended parsing:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 将此更改为使用扩展解析：
- en: '[PRE84]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: With form display taken care of, let’s move on to creating entries from the
    submitted form data.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理表单显示之后，让我们继续从提交的表单数据创建条目。
- en: Implementing entry creation
  id: totrans-826
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现条目创建
- en: To add the capability to create entries from submitted form data, add the logic
    in the next listing to the file routes/entries.js. This logic will add entries
    when form data is submitted.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加从提交的表单数据创建条目的功能，请将以下列表中的逻辑添加到文件 routes/entries.js 中。此逻辑将在表单数据提交时添加条目。
- en: Listing 6.10\. Add an entry using submitted form data
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.10\. 使用提交的表单数据添加条目
- en: '![](Images/06lis10_alt.jpg)'
  id: totrans-829
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis10_alt.jpg)'
- en: Now when you use a browser to access /post on your application, you’ll be able
    to add entries. You’ll take care of forcing the user to sign in first in [listing
    6.21](#ch06ex21).
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你使用浏览器访问应用程序上的 /post，你将能够添加条目。你将在 [列表 6.21](#ch06ex21) 中处理强制用户先登录。
- en: With posting content taken care of, it’s time to render lists of entries.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完帖子内容后，现在是时候渲染条目列表了。
- en: Adding front-page display of entries
  id: totrans-832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加条目的前页显示
- en: Start by creating the file routes/entries.js. Then add the code in the following
    listing to require the entry model and export a function for rendering a list
    of entries.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建文件 routes/entries.js。然后添加以下列表中的代码，以导入条目模型并导出一个用于渲染条目列表的函数。
- en: Listing 6.11\. Listing entries
  id: totrans-834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.11\. 列出条目
- en: '![](Images/06lis11_alt.jpg)'
  id: totrans-835
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis11_alt.jpg)'
- en: With route logic defined for listing entries, you now need to add an EJS template
    to display them. In the views directory, create a file named entries.ejs and put
    the following EJS in it.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在为列出条目定义路由逻辑后，您现在需要添加一个 EJS 模板来显示它们。在 views 目录中创建一个名为 entries.ejs 的文件，并将以下 EJS
    放入其中。
- en: Listing 6.12\. The entries.ejs view
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.12\. entries.ejs 视图
- en: '[PRE85]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Before running the application, run `touch views/menu.ejs` to create a temporary
    file that will hold the menu at a later stage. When the views and routes are ready,
    you need to tell the application where to find the routes.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，运行 `touch views/menu.ejs` 以创建一个临时文件，该文件将在稍后阶段保存菜单。当视图和路由准备就绪时，您需要告诉应用程序在哪里找到路由。
- en: Adding entry-related routes
  id: totrans-840
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加与条目相关的路由
- en: 'Before you add entry-related routes to the application, you need to make modifications
    to app.js. First, add the following `require` statement to the top of your app.js
    file:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在您将条目相关的路由添加到应用程序之前，您需要对 app.js 进行修改。首先，在您的 app.js 文件顶部添加以下 `require` 语句：
- en: '[PRE86]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Next, also in app.js, change the line containing the text `app.get(''/''` to
    the following to make any requests to the path `/` to return the entry listing:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，也在 app.js 中，将包含文本 `app.get('/')` 的行更改为以下内容，以便任何对路径 `/` 的请求都返回条目列表：
- en: '[PRE87]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: When you run the application, the front page will display a list of entries.
    Now that entries can be created and listed, let’s move on to using route-specific
    middleware to validate form data.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，主页将显示条目列表。现在，条目可以创建和列出，让我们继续使用特定路由的中间件来验证表单数据。
- en: Using route-specific middleware
  id: totrans-846
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用特定路由的中间件
- en: 'Suppose you want the entry text field in the post entry form to be required.
    The first way you might think of to address this problem is to add it straight
    in your route callback, as shown in the following snippet. This approach isn’t
    ideal, however, because it tightly ties the validation logic to this particular
    form. In many cases, validation logic can be abstracted into reusable components,
    making development easier, faster, and more declarative:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望帖子表单中的条目文本字段是必需的。您可能首先想到的解决这个问题的方法是在您的路由回调中直接添加它，如下面的代码片段所示。然而，这种方法并不理想，因为它将验证逻辑紧密地绑定到这个特定的表单上。在许多情况下，验证逻辑可以被抽象成可重用的组件，使开发更容易、更快、更声明性：
- en: '[PRE88]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Express routes can optionally accept middleware of their own, applied only when
    that route is matched, before the final route callback. The route callbacks themselves
    that you’ve been using throughout the chapter aren’t treated specially. These
    are the same as any other middleware, even the ones you’re about to create for
    validation!
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: Express 路由可以可选地接受自己的中间件，仅在匹配该路由时应用，在最终的路线回调之前。您在本章中使用的路线回调本身并没有被特别处理。它们与其他中间件相同，甚至包括您即将为验证创建的中间件！
- en: Let’s get started with route-specific middleware by looking at a simple, but
    inflexible, way to implement validation as route-specific middleware.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看一种简单但不够灵活的实现验证作为特定路由中间件的方法开始。
- en: Performing form validation with route-specific middleware
  id: totrans-851
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用特定路由的中间件进行表单验证
- en: 'The first possibility is to write a few simple, yet specific, middleware components
    to perform validation. Extending the `POST /post` route with this middleware might
    look something like the following:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种可能性是编写一些简单但具体的中间件组件来执行验证。通过扩展 `POST /post` 路由使用此中间件可能看起来像以下这样：
- en: '[PRE89]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that this route definition, which normally has only a path and routing
    logic as arguments, has two additional arguments specifying validation middleware.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个路由定义，通常只有路径和路由逻辑作为参数，有两个额外的参数指定验证中间件。
- en: The two example middleware components in the following listing illustrate how
    the original validations can be abstracted out. But they’re still not modular
    and work only for the single field `entry[title]`.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的两个示例中间件组件说明了如何抽象出原始验证。但它们仍然不是模块化的，并且只为单个字段 `entry[title]` 工作。
- en: Listing 6.13\. Two more potential, but imperfect, attempts at validation middleware
  id: totrans-856
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.13\. 两个更多潜在的但并不完美的验证中间件尝试
- en: '[PRE90]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: A more viable solution is to abstract the validators and pass the target field
    name. Let’s take a look at approaching it this way.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更可行的解决方案是抽象验证器并传递目标字段名。让我们看看如何以这种方式接近它。
- en: Building flexible validation middleware
  id: totrans-859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建灵活的验证中间件
- en: 'You can pass the field name, as shown in the following snippet. This allows
    you to reuse validation logic, lessening the amount of code you need to write:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以传递字段名，如下面的片段所示。这允许你重用验证逻辑，减少你需要编写的代码量：
- en: '[PRE91]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Swap the line `app.post('/post', entries.submit);` in the routing section of
    app.js with this snippet. It’s worth noting that the Express community has created
    many similar libraries for public consumption, but understanding how validation
    middleware works, and how to author your own, is invaluable.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 将app.js路由部分中的`app.post('/post', entries.submit);`行替换为以下片段。值得注意的是，Express社区已经为公众创建了众多类似的库，但了解验证中间件的工作原理以及如何编写自己的中间件是无价的。
- en: Let’s get on with it. Create a file named ./middleware/validate.js by using
    the program code in [listing 6.14](#ch06ex14). In validate.js, you’ll export several
    middleware components—in this case, `validate.required()` and `validate.lengthAbove()`.
    The implementation details aren’t important; the point of this example is that
    a small amount of effort can go a long way if the code is common within the application.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进。使用程序代码在[列表6.14](#ch06ex14)中创建一个名为./middleware/validate.js的文件。在validate.js中，你将导出几个中间件组件——在这种情况下，`validate.required()`和`validate.lengthAbove()`。实现细节并不重要；这个例子要说明的是，如果代码在应用程序中是通用的，那么一点小小的努力就能走得很远。
- en: Listing 6.14\. Validation middleware implementation
  id: totrans-864
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.14\. 验证中间件实现
- en: '![](Images/ch06ex14-0.jpg)'
  id: totrans-865
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex14-0.jpg)'
- en: '![](Images/ch06ex14-1.jpg)'
  id: totrans-866
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch06ex14-1.jpg)'
- en: 'To make this middleware available to your application, add the following line
    at the top of app.js:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此中间件对应用程序可用，请在app.js顶部添加以下行：
- en: '[PRE92]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If you try the application now, you’ll find that the validation will be in effect.
    This validation API could be made even more fluent, but we’ll leave that for you
    to investigate.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试应用程序，你会发现验证将生效。这个验证API可以变得更加流畅，但我们将其留给你去调查。
- en: 6.2.5\. Authenticating users
  id: totrans-870
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.5\. 验证用户
- en: 'In this section, you’ll create an authentication system for the application
    from scratch. You’ll go through the following steps:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将从零开始为应用程序创建一个身份验证系统。你将经历以下步骤：
- en: Implement logic to store and authenticate registered users
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现存储和验证已注册用户的逻辑
- en: Add account registration functionality
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加账户注册功能
- en: Allow people to sign in
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许人们登录
- en: Create and use middleware to load users
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并使用中间件来加载用户
- en: You’ll continue using Redis to implement user accounts. Now let’s see how to
    create a user model to make working with Redis easier in our Node code.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 你将继续使用Redis来实现用户账户。现在让我们看看如何创建一个用户模型，以便在Node代码中更轻松地使用Redis。
- en: Saving and loading user records
  id: totrans-877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保存和加载用户记录
- en: 'In this section, you’ll implement user loading, saving, and authentication.
    You’ll do the following:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将实现用户加载、保存和身份验证。你将执行以下操作：
- en: Define application dependencies by using a package.json file
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用package.json文件定义应用程序依赖项
- en: Create a user model
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户模型
- en: Add logic to load and save user data by using Redis
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Redis添加加载和保存用户数据的逻辑
- en: Secure user passwords by using bcrypt
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用bcrypt安全地存储用户密码
- en: Add logic to authenticate attempts to log in
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加验证登录尝试的逻辑
- en: '*Bcrypt* is a salted hashing function that’s available as a third-party module
    designed specifically for hashing passwords. Bcrypt is great for passwords because
    it incorporates an iteration count argument to make it slower over time.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bcrypt* 是一个加盐散列函数，作为一个专门为散列密码设计的第三方模块提供。Bcrypt非常适合密码，因为它包含一个迭代计数参数，使其随着时间的推移而变慢。'
- en: 'Before continuing, add bcrypt to your shoutbox project:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，将bcrypt添加到你的shoutbox项目中：
- en: '[PRE93]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Creating a user model
  id: totrans-887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建用户模型
- en: You now need to create a user model. Add a file named user.js to the models/
    directory.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在需要创建一个用户模型。在models/目录中添加一个名为user.js的文件。
- en: '[Listing 6.15](#ch06ex15) is the user model. In this code, the `redis` and
    `bcrypt` dependencies are required, and then a Redis connection is opened with
    `redis.createClient()`. The `User` function accepts an object and merges this
    object’s properties into its own. For example, `new User({ name: ''tobi'' })`
    creates an object and sets the object’s `name` property to `Tobi`.'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表6.15](#ch06ex15)是用户模型。在这段代码中，需要`redis`和`bcrypt`依赖项，然后使用`redis.createClient()`打开一个Redis连接。`User`函数接受一个对象，并将该对象的属性合并到其自身。例如，`new
    User({ name: ''tobi'' })`创建一个对象，并将对象的`name`属性设置为`Tobi`。'
- en: Listing 6.15\. Starting to create a user model
  id: totrans-890
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.15\. 开始创建用户模型
- en: '![](Images/06lis15_alt.jpg)'
  id: totrans-891
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06lis15_alt.jpg)'
- en: At the moment, the user mode is just a stub. You’ll need to add methods for
    creating and updating user records as well.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，用户模式只是一个占位符。你需要添加创建和更新用户记录的方法。
- en: Saving a user into Redis
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将用户保存到 Redis 中
- en: The next functionality you need is the ability to save a user, storing the user’s
    data with Redis. The `save` method shown in [listing 6.16](#ch06ex16) checks whether
    the user already has an ID, and if so, `save` invokes the `update` method, indexing
    the user ID by name, and populating a Redis hash with the object’s properties.
    Otherwise, a user who doesn’t have an ID is considered a new user; the `user:ids`
    value is then incremented, which gives the user a unique ID, and the password
    is hashed before saving into Redis with the same `update` method.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个你需要的功能是保存用户的能力，使用 Redis 存储用户数据。在 [列表 6.16](#ch06ex16) 中显示的 `save` 方法检查用户是否已经有了一个
    ID，如果有，则 `save` 调用 `update` 方法，按名称索引用户 ID，并用对象的属性填充 Redis 哈希。否则，没有 ID 的用户被视为新用户；然后
    `user:ids` 的值增加，给用户一个唯一的 ID，密码在保存到 Redis 之前使用相同的 `update` 方法进行哈希处理。
- en: Add the code in the following listing to models/user.js.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 models/user.js 中。
- en: Listing 6.16\. Updating user records
  id: totrans-896
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.16\. 更新用户记录
- en: '![](Images/06lis16_alt.jpg)'
  id: totrans-897
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis16_alt.jpg)'
- en: Securing user passwords
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 保护用户密码
- en: When the user is first created, you need to set a `.pass` property to the user’s
    password. The user-saving logic then replaces the `.pass` property with a hash
    generated by using the password.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户首次创建时，你需要将 `.pass` 属性设置为用户的密码。然后用户保存逻辑会将 `.pass` 属性替换为使用密码生成的哈希。
- en: 'The hash is *salted*. Per-user salting helps to protect against rainbow table
    attacks: the salt acts as a private key for the hashing mechanism. You can use
    bcrypt to generate a 12-character salt for the hash with `genSalt()`.'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是 *加盐的*。每个用户的加盐有助于防止雨彩虹表攻击：盐作为哈希机制的秘密密钥。你可以使用 bcrypt 的 `genSalt()` 生成一个 12
    位的盐。
- en: '|  |'
  id: totrans-901
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Rainbow table attacks
  id: totrans-902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 雨彩虹表攻击
- en: 'Rainbow table attacks use precomputed tables to break hashed passwords. You
    can read more about this topic in Wikipedia: [http://en.wikipedia.org/wiki/Rainbow_table](http://en.wikipedia.org/wiki/Rainbow_table).'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 雨彩虹表攻击使用预先计算的表来破解哈希密码。你可以在维基百科上了解更多关于这个主题的信息：[http://en.wikipedia.org/wiki/Rainbow_table](http://en.wikipedia.org/wiki/Rainbow_table)。
- en: '|  |'
  id: totrans-904
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: After the salt is generated, `bcrypt.hash()` is called, which hashes the`.pass`
    property and the salt. This final `hash` value then replaces the `.pass` property
    before `.update()` stores it in Redis, ensuring that plain-text passwords aren’t
    saved, only the hash.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 盐生成后，调用 `bcrypt.hash()`，它将 `.pass` 属性和盐进行哈希处理。这个最终的 `hash` 值然后替换 `.pass` 属性，在
    `.update()` 存储到 Redis 之前，确保不保存明文密码，只保存哈希。
- en: The following listing, which you’ll add to models/user.js, defines a function
    that creates the salted hash and stores it in the user’s `.pass` property.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表，你将添加到 models/user.js 中，定义了一个函数，该函数创建加盐的哈希并将其存储在用户的 `.pass` 属性中。
- en: Listing 6.17\. Adding bcrypt encryption to the user model
  id: totrans-907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.17\. 向用户模型添加 bcrypt 加密
- en: '![](Images/06lis17_alt.jpg)'
  id: totrans-908
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis17_alt.jpg)'
- en: That’s all there is to it.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。
- en: Testing the user-saving logic
  id: totrans-910
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试用户保存逻辑
- en: To try out saving users, start the Redis server by entering `redis-server` on
    the command line. Then add the code in the following listing, which creates an
    example user, to the bottom of models/user.js. You can then run `node models/user.js`
    on the command line to execute the creation of the example user.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试保存用户，通过命令行输入 `redis-server` 启动 Redis 服务器。然后，将以下列表中的代码添加到 models/user.js 的底部，该代码创建了一个示例用户。然后，你可以在命令行上运行
    `node models/user.js` 来执行示例用户的创建。
- en: Listing 6.18\. Testing the user model
  id: totrans-912
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.18\. 测试用户模型
- en: '![](Images/06lis18_alt.jpg)'
  id: totrans-913
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis18_alt.jpg)'
- en: 'You should see output indicating that the user has been created: `user id 1`,
    for example. After testing the user model, remove the code in [listing 6.18](#ch06ex18)
    from models/user.js.'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到表示用户已创建的输出：例如 `user id 1`。在测试用户模型后，从 models/user.js 中删除 [列表 6.18](#ch06ex18)
    中的代码。
- en: When you use the redis-cli tool that comes with Redis, you can use the `HGETALL`
    command to fetch each key and value of the hash, as the following command-line
    session demonstrates.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用随 Redis 一起提供的 redis-cli 工具时，你可以使用 `HGETALL` 命令来获取哈希中的每个键和值，如下面的命令行会话所示。
- en: Listing 6.19\. Querying with the Redis command-line tool
  id: totrans-916
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.19\. 使用 Redis 命令行工具进行查询
- en: '![](Images/06lis19_alt.jpg)'
  id: totrans-917
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis19_alt.jpg)'
- en: Having defined logic to save a user, you now need to add logic to retrieve user
    information.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了保存用户的逻辑后，你现在需要添加检索用户信息的逻辑。
- en: '|  |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Other Redis commands you can run in the redis-cli tool
  id: totrans-920
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 你可以在 redis-cli 工具中运行的 Redis 命令
- en: For more information about Redis commands, see the Redis command reference at
    [http://redis.io/commands](http://redis.io/commands).
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Redis 命令的更多信息，请参阅 Redis 命令参考 [http://redis.io/commands](http://redis.io/commands)。
- en: '|  |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Retrieving user data
  id: totrans-923
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取用户数据
- en: When a user attempts to log in to a web application, the user usually enters
    a username and password into a form, and this data is then submitted to the application
    for authentication. Once the login form is submitted, you need a method for fetching
    the user via name.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试登录到网络应用程序时，用户通常会在表单中输入用户名和密码，然后这些数据将被提交给应用程序进行认证。一旦提交登录表单，你需要一种方法通过名称获取用户。
- en: This logic is defined in the following listing as `User.getByName()`. The function
    first performs an ID lookup with `User.getId()` and then passes the ID that it
    finds to `User.get()`, which gets the Redis hash data for that user. Add the following
    methods to models/user.js.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 此逻辑在以下列表中定义为 `User.getByName()`。该函数首先使用 `User.getId()` 执行 ID 查找，然后将找到的 ID 传递给
    `User.get()`，该函数获取该用户的 Redis 哈希数据。将以下方法添加到 models/user.js 中。
- en: Listing 6.20\. Fetching a user from Redis
  id: totrans-926
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.20\. 从 Redis 获取用户
- en: '![](Images/06lis20_alt.jpg)'
  id: totrans-927
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06lis20_alt.jpg)'
- en: 'If you want to try fetching a user, you can try code like this:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试获取用户，你可以尝试以下代码：
- en: '[PRE94]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Having retrieved the hashed password, you can now proceed with authenticating
    the user.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取到散列密码后，你现在可以继续进行用户认证。
- en: Authenticating user logins
  id: totrans-931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 认证用户登录
- en: The final component needed for user authentication is a method, defined in the
    following listing, that takes advantage of the functions defined earlier for user
    data retrieval. Add this logic to models/user.js.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 用户认证所需的最后一个组件是以下列表中定义的方法，该方法利用了之前定义的用户数据检索函数。将此逻辑添加到 models/user.js 中。
- en: Listing 6.21\. Authenticating a user’s name and password
  id: totrans-933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.21\. 认证用户的用户名和密码
- en: '![](Images/06lis21_alt.jpg)'
  id: totrans-934
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06lis21_alt.jpg)'
- en: The authentication logic begins by fetching the user by name. If the user isn’t
    found, the callback function is immediately invoked. Otherwise, the user’s stored
    salt and the password submitted are hashed to produce what should be identical
    to the stored `user.pass` hash. If the submitted and stored hashes don’t match,
    the user has entered invalid credentials. When looking up a key that doesn’t exist,
    Redis will give you an empty hash, which is why the check for `!user.id` is used
    instead of `!user`.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 认证逻辑首先通过名称获取用户。如果找不到用户，回调函数将立即调用。否则，用户的存储盐和提交的密码将被散列以生成应与存储的 `user.pass` 散列相同的值。如果提交的散列和存储的散列不匹配，则用户输入了无效的凭据。当查找不存在的键时，Redis
    将返回一个空哈希，这就是为什么使用 `!user.id` 而不是 `!user` 进行检查的原因。
- en: Now that you’re able to authenticate users, you need a way for users to register.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你能够认证用户了，你需要一种让用户注册的方法。
- en: 6.2.6\. Registering new users
  id: totrans-937
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.6\. 注册新用户
- en: To allow users to create new accounts and then sign in, you need both registration
    and login capabilities.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户创建新账户并登录，你需要注册和登录功能。
- en: 'In this section, you’ll do the following to implement registration:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将执行以下操作以实现注册：
- en: Map registration and login routes to URL paths
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将注册和登录路由映射到 URL 路径
- en: Add route logic to display a registration form
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向路由逻辑中添加显示注册表单
- en: Add logic to store user data submitted from the form
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加逻辑以存储从表单提交的用户数据
- en: The form will look like [figure 6.12](#ch06fig12).
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 表单看起来像 [图 6.12](#ch06fig12)。
- en: Figure 6.12\. User registration form
  id: totrans-944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.12\. 用户注册表单
- en: '![](Images/06fig12.jpg)'
  id: totrans-945
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig12.jpg)'
- en: This form is displayed when a user visits /register with a web browser. Later
    you’ll create a similar form that allows users to log in.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用网络浏览器访问 /register 时，将显示此表单。稍后你将创建一个类似的表单，允许用户登录。
- en: Adding registration routes
  id: totrans-947
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加注册路由
- en: To get the registration form to show up, you first want to create a route to
    render the form and return it to the user’s browser for display.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让注册表单显示出来，你首先需要创建一个路由来渲染表单并将其返回给用户的浏览器进行显示。
- en: '[Listing 6.22](#ch06ex22) shows how you should alter app.js, using Node’s module
    system to import a module defining registration route behavior from the routes
    directory, and associating HTTP methods and URL paths to route functions. This
    forms a sort of “front controller.” As you can see, there are both `GET` and `POST`
    register routes.'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 6.22](#ch06ex22) 展示了如何使用 Node 的模块系统从 routes 目录导入定义注册路由行为的模块，并将 HTTP 方法与
    URL 路径关联到路由函数。这形成了一种“前端控制器”。正如你所见，既有 `GET` 和 `POST` 注册路由。'
- en: Listing 6.22\. Adding registration routes
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.22\. 添加注册路由
- en: '![](Images/06lis22_alt.jpg)'
  id: totrans-951
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06lis22_alt.jpg)'
- en: 'Next, to define the route logic, create an empty file in the routes directory
    called register.js. Start defining registration route behavior by exporting the
    following function from routes/register.js—a route that renders the registration
    template:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了定义路由逻辑，在路由目录中创建一个名为 register.js 的空文件。通过从 routes/register.js 导出以下函数来开始定义注册路由的行为——一个渲染注册模板的路由：
- en: '[PRE95]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This route uses an EJS template, which you’ll create next, to define the registration
    form’s HTML.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由使用你接下来将要创建的 EJS 模板来定义注册表单的 HTML。
- en: Creating a registration form
  id: totrans-955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建注册表单
- en: To define the registration form’s HTML, create a file in the views directory
    called register.ejs. You can define this form by using the HTML/EJS detailed in
    the following listing.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义注册表单的 HTML，在视图目录中创建一个名为 register.ejs 的文件。你可以使用以下列表中详细说明的 HTML/EJS 来定义此表单。
- en: Listing 6.23\. A view template that provides a registration form
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.23\. 提供注册表单的视图模板
- en: '![](Images/06lis23_alt.jpg)'
  id: totrans-958
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06lis23_alt.jpg)'
- en: 'Note the use of `include messages`, which includes another template: messages.ejs.
    This template, which you’ll define next, is used to communicate with the user.'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用了 `include messages`，这包括另一个模板：messages.ejs。这个模板，你接下来将定义，用于与用户通信。
- en: Relaying feedback to users
  id: totrans-960
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向用户传达反馈
- en: During user registration, and in many other parts of a typical application,
    it can be necessary to relay feedback to the user. A user, for example, may attempt
    to register with a username that someone else is already using. In this case,
    you need to tell the user to choose another name.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户注册过程中，以及在典型应用的许多其他部分，向用户传达反馈可能是必要的。例如，用户可能会尝试使用已被他人使用的用户名进行注册。在这种情况下，你需要告诉用户选择另一个名字。
- en: In your application, the messages.ejs template will be used to display errors.
    Numerous templates throughout the application will include the messages.ejs template.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用中，messages.ejs 模板将用于显示错误。应用中的许多模板都将包含 messages.ejs 模板。
- en: 'To create the messages template, create a file in the views directory called
    messages.ejs and put the logic in the following snippet into that file. The template
    logic checks whether the `locals.messages` variable is set. If so, the template
    cycles through the variable, displaying message objects. Each message object has
    a `type` property (allowing you to use messages for nonerror notifications if
    need be) and a `string` property (the message text). Application logic can queue
    an error for display by adding to the `res.locals.messages` array. After messages
    are displayed, `removeMessages` is called to empty the messages queue:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建消息模板，在视图目录中创建一个名为 messages.ejs 的文件，并将以下代码片段放入该文件中。模板逻辑检查 `locals.messages`
    变量是否已设置。如果是，模板将遍历该变量，显示消息对象。每个消息对象都有一个 `type` 属性（允许你在需要时使用消息进行非错误通知）和一个 `string`
    属性（消息文本）。应用逻辑可以通过向 `res.locals.messages` 数组中添加错误来排队显示错误。消息显示后，调用 `removeMessages`
    来清空消息队列：
- en: '[PRE96]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[Figure 6.13](#ch06fig13) shows the registration form when displaying an error
    message.'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.13](#ch06fig13) 展示了显示错误消息时的注册表单。'
- en: Figure 6.13\. Registration form error reporting
  id: totrans-966
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.13\. 注册表单错误报告
- en: '![](Images/06fig13.jpg)'
  id: totrans-967
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig13.jpg)'
- en: Adding a message to `res.locals.messages` is a simple way to communicate with
    the user, but because `res.locals` doesn’t persist across redirects, you need
    to make it more robust by using sessions to store messages between requests.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息添加到 `res.locals.messages` 是与用户通信的一种简单方式，但由于 `res.locals` 在重定向之间不持久，你需要通过使用会话在请求之间存储消息来使其更加健壮。
- en: Storing transient messages in sessions
  id: totrans-969
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在会话中存储临时消息
- en: A common web application design pattern is the Post/Redirect/Get (PRG) pattern.
    In this pattern, a user requests a form, the form data is submitted as an HTTP
    `POST` request, and the user is then redirected to another web page. Where the
    user is redirected to depends on whether the form data was considered valid by
    the application. If the form data isn’t considered valid, the application redirects
    the user back to the form page. If the form data is valid, the user is redirected
    to a new web page. The PRG pattern is primarily used to prevent duplicate form
    submissions.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的Web应用程序设计模式是Post/Redirect/Get（PRG）模式。在这个模式中，用户请求一个表单，表单数据作为HTTP `POST`请求提交，然后用户被重定向到另一个网页。用户被重定向到哪个网页取决于应用程序是否认为表单数据有效。如果表单数据被认为无效，应用程序将用户重定向回表单页面。如果表单数据有效，用户将被重定向到一个新网页。PRG模式主要用于防止重复提交表单。
- en: In Express, when a user is redirected, the content of `res.locals` is reset.
    If you’re storing messages to the user in `res.locals`, the messages are lost
    before they can be displayed. By storing messages in a session variable, however,
    you can work around this. Messages can then be displayed on the final redirect
    page.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中，当用户被重定向时，`res.locals`的内容会被重置。如果你在`res.locals`中存储消息给用户，消息在显示之前就会丢失。然而，通过将消息存储在会话变量中，你可以解决这个问题。然后可以在最终的跳转页面上显示消息。
- en: 'To accommodate the ability to queue messages to the user in a session variable,
    you need to add a module to your application. Create a file named ./middleware/messages.js,
    and add the following code:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应将消息队列到会话变量的能力，你需要在应用程序中添加一个模块。创建一个名为./middleware/messages.js的文件，并添加以下代码：
- en: '[PRE97]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `res.message` function provides a way to add messages to a session variable
    from any Express request. The `express.response` object is the prototype that
    Express uses for the response objects. Adding properties to this object means
    they’ll then be available to all middleware and routes alike. In the preceding
    snippet, `express.response` is assigned to a variable named `res` to make it easier
    to add properties on the object and to improve readability.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.message`函数提供了一种从任何Express请求向会话变量添加消息的方法。`express.response`对象是Express用于响应对象的原型。向此对象添加属性意味着它们将随后对所有中间件和路由可用。在前面的代码片段中，`express.response`被分配给一个名为`res`的变量，以便更容易在对象上添加属性并提高可读性。'
- en: 'This feature requires session support. To add support for sessions, you need
    an Express-compatible middleware module. There’s an officially supported package
    called express-session. Install it with `npm install --save express-session`,
    and then add the middleware to app.js, like this:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能需要会话支持。为了添加会话支持，你需要一个与Express兼容的中间件模块。有一个官方支持的包叫做express-session。使用`npm install
    --save express-session`安装它，然后将中间件添加到app.js中，如下所示：
- en: '[PRE98]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: It’s best to place the middleware after the cookie middleware is inserted (it
    should be around line 26).
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳做法是在将cookie中间件插入之后放置中间件（它应该在大约第26行附近）。
- en: 'To make it even easier to add messages, add the code in the following snippet.
    The `res.error` function allows you to easily add a message of type `error` to
    the message queue. Use the `res.message` function you previously defined in the
    module:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使添加消息更加容易，添加以下代码片段中的代码。`res.error`函数允许你轻松地将类型为`error`的消息添加到消息队列中。使用你在模块中先前定义的`res.message`函数：
- en: '[PRE99]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The last step is to expose these messages to the templates for output. If you
    don’t do this, you have to pass `req.session.messages` to every `res.render()`
    call in the application, which isn’t exactly ideal.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将这些消息暴露给模板以进行输出。如果你不这样做，你必须将`req.session.messages`传递到应用程序中的每个`res.render()`调用中，这并不完全理想。
- en: 'To address this, you’ll create middleware that populates `res.locals.messages`
    with the contents of `res.session.messages` on each request, effectively exposing
    the messages to any templates that are rendered. So far, ./middleware/messages.js
    extends the response prototype, but it doesn’t export anything. But adding the
    following snippet to this file exports the middleware you need:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你将创建一个中间件，在每个请求中将`res.locals.messages`填充为`res.session.messages`的内容，从而有效地将消息暴露给任何渲染的模板。到目前为止，./middleware/messages.js扩展了响应原型，但它没有导出任何内容。但是，向此文件添加以下代码片段可以导出所需的中间件：
- en: '[PRE100]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: First, a `messages` template variable is defined to store the session’s messages;
    it’s an array that may or may not exist from the previous request (remember that
    these are session-persisted messages). Next, you need a way to remove the messages
    from the session; otherwise, they’ll build up, because nothing is clearing them.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个 `messages` 模板变量来存储会话的消息；它是一个数组，可能存在于之前的请求中（记住这些是会话持久化的消息）。接下来，您需要一种方法从会话中删除消息；否则，它们会不断累积，因为没有清除它们。
- en: 'Now, all you need to do to integrate this new feature is to `require()` the
    file in app.js. You should mount this middleware below the session middleware
    because it depends on `req.session` being defined. Note that because this middleware
    was designed not to accept options and doesn’t return a second function, you can
    call `app.use(messages)` instead of `app.use(messages())`. For future-proofing,
    it’s typically best for third-party middleware to use `app.use(messages())`, regardless
    of whether it accepts options:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您要集成此新功能，只需在 app.js 中 `require()` 该文件即可。您应该在会话中间件下方挂载此中间件，因为它依赖于 `req.session`
    被定义。请注意，因为这个中间件被设计为不接受选项且不返回第二个函数，所以您可以使用 `app.use(messages)` 而不是 `app.use(messages())`。为了确保兼容性，通常最好让第三方中间件使用
    `app.use(messages())`，无论它是否接受选项：
- en: '[PRE101]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Now you’re able to access `messages` and `removeMessages()` within any view,
    so messages.ejs should work perfectly when included in any template.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在任何视图中访问 `messages` 和 `removeMessages()`，因此当 messages.ejs 包含在任何模板中时，应该可以完美工作。
- en: With the display of the registration form completed and a way to relay any necessary
    feedback to the user worked out, let’s move on to handling registration submissions.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 完成注册表单的显示并制定了一种向用户传达任何必要反馈的方法后，让我们继续处理注册提交。
- en: Implementing user registration
  id: totrans-988
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现用户注册
- en: You need to create the route function to handle HTTP `POST` requests to /register.
    This function is called `submit`.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建一个路由函数来处理对 /register 的 HTTP `POST` 请求。这个函数被称为 `submit`。
- en: When form data is submitted, the `bodyParser()` middleware populates `req.body`
    with the submitted data. The registration form uses the object notation `user[name]`,
    which translates to `req.body.user.name` after parsing by the body parser. Likewise,
    `req.body.user.pass` is used for the password field.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单数据提交时，`bodyParser()` 中间件将提交的数据填充到 `req.body` 中。注册表单使用对象表示法 `user[name]`，在经过
    body parser 解析后转换为 `req.body.user.name`。同样，`req.body.user.pass` 用于密码字段。
- en: You need only a small amount of code in the submission route to handle validation,
    such as ensuring that the username isn’t already taken, and to save the new user,
    as [listing 6.24](#ch06ex24) shows.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交路由中，您只需要少量代码来处理验证，例如确保用户名尚未被占用，并将新用户保存，如[列表 6.24](#ch06ex24)所示。
- en: Once registration is complete, the `user.id` is assigned to the user’s session,
    which you’ll later check to verify that the user is authenticated. If validation
    fails, a message is exposed to templates as the `messages` variable, via `res.locals.messages`,
    and the user is redirected back to the registration form.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 注册完成后，`user.id` 被分配给用户的会话，您稍后会检查以验证用户是否已认证。如果验证失败，则将消息暴露给模板作为 `messages` 变量，通过
    `res.locals.messages`，并将用户重定向回注册表单。
- en: To add this functionality, add the contents of the following listing to routes/register.js.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加此功能，请将以下列表的内容添加到 routes/register.js 中。
- en: Listing 6.24\. Creating a user with submitted data
  id: totrans-994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.24. 使用提交的数据创建用户
- en: '![](Images/06lis24_alt.jpg)'
  id: totrans-995
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06lis24_alt.jpg)'
- en: You can now fire up the application, visit /register, and register a user. The
    next thing you need is a way for returning registered users to authenticate, via
    the /login form.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以启动应用程序，访问 /register，并注册一个用户。接下来，您需要一种方式让已注册用户通过 /login 表单进行身份验证。
- en: 6.2.7\. Logging in registered users
  id: totrans-997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.7. 登录已注册用户
- en: 'Adding login functionality is even simpler than registration, because the bulk
    of the necessary logic is already in `User.authenticate()`, the general-purpose
    authentication method defined earlier. In this section, you’ll add the following:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 添加登录功能甚至比注册更简单，因为大部分必要的逻辑已经包含在之前定义的通用身份验证方法 `User.authenticate()` 中。在本节中，您将添加以下内容：
- en: Route logic to display a login form
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由逻辑以显示登录表单
- en: Logic to authenticate user data submitted from the form
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证从表单提交的用户数据的逻辑
- en: The form will look like [figure 6.14](#ch06fig14).
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 表单看起来像[图 6.14](#ch06fig14)。
- en: Figure 6.14\. User login form
  id: totrans-1002
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.14. 用户登录表单
- en: '![](Images/06fig14.jpg)'
  id: totrans-1003
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig14.jpg)'
- en: 'You’ll start by modifying app.js so login routes are required and the route
    paths are established:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先修改 app.js 以确保登录路由是必需的，并且建立了路由路径：
- en: '[PRE102]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Next, you’ll add functionality to display a login form.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将添加显示登录表单的功能。
- en: Displaying a login form
  id: totrans-1007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示登录表单
- en: 'The first step in implementing a login form is creating a file for login- and
    logout-related routes: routes/login.js. The route logic you need to add to display
    the login form is nearly identical to the logic used earlier to display the registration
    form; the only differences are the name of the template displayed and the page
    title:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 实现登录表单的第一步是创建一个用于登录和注销相关路由的文件：routes/login.js。你需要添加以显示登录表单的路由逻辑几乎与之前用于显示注册表单的逻辑相同；唯一的区别是显示的模板名称和页面标题：
- en: '[PRE103]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The EJS login form that you’ll define in ./views/login.ejs, shown in the following
    listing, is extremely similar to register.ejs as well; the only differences are
    the instruction text and the route that data is submitted to.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 ./views/login.ejs 中定义的 EJS 登录表单与 register.ejs 非常相似；唯一的区别是说明文本和数据提交到的路由：
- en: Listing 6.25\. A view template for a login form
  id: totrans-1011
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.25\. 登录表单的视图模板
- en: '![](Images/06lis25_alt.jpg)'
  id: totrans-1012
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis25_alt.jpg)'
- en: Now that you’ve added the route and template needed to display the login form,
    the next step is to add logic to handle login attempts.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经添加了显示登录表单所需的路由和模板，下一步是添加处理登录尝试的逻辑。
- en: Authenticating logins
  id: totrans-1014
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 验证登录
- en: To handle login attempts, you need to add route logic that will check the submitted
    username and password and, if they’re correct, set a session variable to the user’s
    ID and redirect the user to the home page. The following listing contains this
    logic, which you should add to routes/login.js.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理登录尝试，你需要添加路由逻辑来检查提交的用户名和密码，如果它们是正确的，则将一个会话变量设置为用户的ID，并将用户重定向到主页。以下列表包含此逻辑，你应该将其添加到
    routes/login.js 中。
- en: Listing 6.26\. A route to handle logins
  id: totrans-1016
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.26\. 处理登录的路由
- en: '![](Images/06lis26_alt.jpg)'
  id: totrans-1017
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis26_alt.jpg)'
- en: 'Here, if the user is authenticated by using `User.authenticate()`, `req.session.uid`
    is assigned in the same way as in the `POST` /register route: the session will
    persist this value, which you can use later to retrieve the `User` or other associated
    user data. If a match isn’t found, an error is set and the form is redisplayed.'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果用户通过 `User.authenticate()` 进行认证，`req.session.uid` 将以与 `POST` /register
    路由相同的方式分配：会话将持久化此值，你可以在以后使用它来检索 `User` 或其他相关用户数据。如果没有找到匹配项，将设置错误并重新显示表单。
- en: 'Users may also prefer to explicitly log out, so you should provide a link for
    this somewhere in the application. In app.js, set up the route with this:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 用户也可能更喜欢明确地注销，因此你应该在应用程序的某个位置提供一个链接。在 app.js 中，设置具有此功能的路由：
- en: '[PRE104]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then in ./routes/login.js, the following function will remove the session,
    which is detected by the `session()` middleware, causing the session to be assigned
    for subsequent requests:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 ./routes/login.js 中，以下函数将移除由 `session()` 中间件检测到的会话，导致会话被分配给后续请求：
- en: '[PRE105]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Now that the registration and login pages have been created, the next thing
    you need to add is a menu so users can reach them. Let’s see how to create one.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注册和登录页面已经创建，接下来你需要添加一个菜单，以便用户可以访问它们。让我们看看如何创建一个。
- en: Creating a menu for authenticated and anonymous users
  id: totrans-1024
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为认证用户和匿名用户创建菜单
- en: In this section, you’ll create a menu for both anonymous and authenticated users,
    allowing them to sign in, register, submit entries, and log out. [Figure 6.15](#ch06fig15)
    shows the menu for an anonymous user.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个用于匿名用户和认证用户的菜单，允许他们登录、注册、提交条目和注销。[图6.15](#ch06fig15)显示了匿名用户的菜单。
- en: Figure 6.15\. User login and registration menu used to access the forms you
    created
  id: totrans-1026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.15\. 用于访问你创建的表单的用户登录和注册菜单
- en: '![](Images/06fig15_alt.jpg)'
  id: totrans-1027
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig15_alt.jpg)'
- en: When the user is authenticated, you’ll display a different menu showing that
    user’s username, as well as a link to a page for posting messages to the shoutbox
    and a link allowing the user to log out. [Figure 6.16](#ch06fig16) shows this
    menu.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户认证时，你将显示一个不同的菜单，显示该用户的用户名，以及一个用于向喊盒发布消息的页面链接和一个允许用户注销的链接。[图6.16](#ch06fig16)显示了此菜单。
- en: Figure 6.16\. Menu when the user is authenticated
  id: totrans-1029
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.16\. 用户认证时的菜单
- en: '![](Images/06fig16_alt.jpg)'
  id: totrans-1030
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06fig16_alt.jpg)'
- en: Each EJS template you’ve created, representing an application page, has contained
    the code `<% include menu %>` after the `<body>` tag. This includes the ./views/menu.ejs
    template, which you’ll create next with the contents of the following listing.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的每个 EJS 模板，代表一个应用页面，都在 `<body>` 标签之后包含了 `<% include menu %>` 代码。这包括了 ./views/menu.ejs
    模板，你将在下一个列表中创建它。
- en: Listing 6.27\. Anonymous and authenticated user menu template
  id: totrans-1032
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.27\. 匿名和认证用户菜单模板
- en: '![](Images/06lis27_alt.jpg)'
  id: totrans-1033
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis27_alt.jpg)'
- en: In this application, you can assume that if a `user` variable is exposed to
    the template, a user is authenticated, because you won’t be exposing the variable
    otherwise; you’ll see this next. When this variable is present, you can display
    the username along with the entry submission and logout links. When an anonymous
    user is visiting, the site login and register links are displayed.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，你可以假设如果 `user` 变量被暴露给模板，则用户已认证，因为你不会在其他情况下暴露这个变量；你将在下面看到这一点。当这个变量存在时，你可以显示用户名以及提交条目和注销链接。当匿名用户访问时，显示网站登录和注册链接。
- en: You may be wondering where this `user` local variable comes from—you haven’t
    written it yet. Next you’ll write some code to load the logged-in user’s data
    for each request and make this data available to templates.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这个 `user` 本地变量是从哪里来的——你还没有编写它。接下来，你将编写一些代码来为每个请求加载已登录用户的数据，并使这些数据可用于模板。
- en: 6.2.8\. Working with user-loading middleware
  id: totrans-1036
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.8\. 与用户加载中间件协同工作
- en: A common task when you work with a web application is loading user information
    from a database, typically represented as a JavaScript object. Having this data
    readily available makes interacting with the user simpler. For this chapter’s
    application, you’ll load the user data on every request, using middleware.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与网络应用协同工作时，一个常见的任务是从数据库中加载用户信息，通常表示为一个 JavaScript 对象。拥有这些数据可以简化与用户的交互。对于本章的应用，你将使用中间件在每次请求时加载用户数据。
- en: You’ll place this middleware script in ./middleware/user.js, requiring the `User`
    model from the directory above (../models). The middleware function is first exported,
    and then it checks the session for the user ID. When the user ID is present, a
    user is authenticated, so it’s safe to fetch the user data from Redis.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把这个中间件脚本放在 ./middleware/user.js 中，从上面的目录（../models）中引入 `User` 模型。中间件函数首先被导出，然后它检查会话中的用户
    ID。当用户 ID 存在时，用户已认证，因此可以从 Redis 中安全地获取用户数据。
- en: Because Node is single-threaded, there’s no thread-local storage. In the case
    of an HTTP server, the request and response variables are the only contextual
    objects available. High-level frameworks could build upon Node to provide additional
    objects to store the authenticated user, but Express made the choice to stick
    with the original objects that Node provides. As a result, contextual data is
    typically stored on the request object, as shown in [listing 6.28](#ch06ex28),
    where the user is stored as `req.user`; subsequent middleware and routes can access
    the user object by using the same property.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node 是单线程的，所以没有线程局部存储。在 HTTP 服务器的案例中，请求和响应变量是唯一可用的上下文对象。高级框架可以在 Node 的基础上构建，以提供额外的对象来存储已认证的用户，但
    Express 选择坚持 Node 提供的原始对象。因此，上下文数据通常存储在请求对象上，如 [列表 6.28](#ch06ex28) 中所示，其中用户存储为
    `req.user`；后续的中间件和路由可以通过使用相同的属性来访问用户对象。
- en: You may wonder what the assignment to `res.locals.user` is for. `res.locals`
    is the request-level object that Express provides to expose data to templates,
    much like `app.locals`. It’s also a function that can be used to merge existing
    objects into itself.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道将 `res.locals.user` 赋值的目的是什么。`res.locals` 是 Express 提供的请求级别对象，用于将数据暴露给模板，类似于
    `app.locals`。它也是一个可以用来将现有对象合并到自身的函数。
- en: Listing 6.28\. Middleware that loads a logged-in user’s data
  id: totrans-1041
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.28\. 加载已登录用户数据的中间件
- en: '![](Images/06lis28_alt.jpg)'
  id: totrans-1042
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis28_alt.jpg)'
- en: To use this new middleware, first delete all lines in app.js containing the
    text `user`. You can then require the module as usual and pass it to `app.use()`.
    In this application, `user` is used above the router, so only the routes and middleware
    following `user` have access to `req.user`. If you’re using middleware that loads
    data, as this middleware does, you may want to move the `express.static` middleware
    above it; otherwise, each time a static file is served, a needless round-trip
    to the database takes place to fetch the user.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新的中间件，首先删除app.js中包含文本`user`的所有行。然后你可以像通常一样require模块，并将其传递给`app.use()`。在这个应用程序中，`user`在路由器之上使用，因此只有`user`之后的路由和中间件可以访问`req.user`。如果你使用的是像这个中间件一样加载数据的中间件，你可能希望将`express.static`中间件放在它之上；否则，每次服务静态文件时，都会进行不必要的数据库往返操作来获取用户。
- en: The following listing shows how to enable this middleware in app.js.
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何在app.js中启用此中间件。
- en: Listing 6.29\. Enabling user-loading middleware
  id: totrans-1045
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.29\. 启用用户加载中间件
- en: '![](Images/06lis29_alt.jpg)'
  id: totrans-1046
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis29_alt.jpg)'
- en: If you fire up the application again and visit either the /login or /register
    pages in your browser, you should see the menu. If you want to style the menu,
    add the following lines of CSS to public/stylesheets/style.css.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次启动应用程序并在浏览器中访问/login或/register页面，你应该能看到菜单。如果你想对菜单进行样式设计，请将以下CSS代码行添加到public/stylesheets/style.css中。
- en: Listing 6.30\. CSS that can be added to style.css to style application menus
  id: totrans-1048
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.30\. 可添加到style.css中以样式化应用程序菜单的CSS
- en: '[PRE106]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: With the menu in place, you should be able to register yourself as a user. Then
    you should see the authenticated user menu with the Post link.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单设置好后，你应该能够注册自己作为用户。然后你应该看到带有发布链接的已认证用户菜单。
- en: In the next section, you’ll learn how to create a public REST API for the application.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何为应用程序创建一个公共REST API。
- en: 6.2.9\. Creating a public REST API
  id: totrans-1052
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.9\. 创建公共REST API
- en: In this section, you’ll implement a RESTful public API for the shoutbox application,
    so that third-party applications can access and add to publication data. REST
    enables application data to be queried and changed using verbs and nouns, represented
    by HTTP methods and URLs, respectively. A REST request typically returns data
    in a machine-readable form, such as JSON or XML.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将实现一个针对shoutbox应用程序的RESTful公共API，以便第三方应用程序可以访问并添加发布数据。REST允许使用动词和名词（分别由HTTP方法和URL表示）查询和更改应用程序数据。REST请求通常以机器可读的格式（如JSON或XML）返回数据。
- en: 'To implement an API, you’ll do the following:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现API，你需要执行以下操作：
- en: Design an API that allows users to show, list, remove, and post entries
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个API，允许用户展示、列出、删除和发布条目
- en: Add Basic authentication
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加基本认证
- en: Implement routing
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现路由
- en: Provide JSON and XML responses
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供JSON和XML响应
- en: Various techniques can be used to authenticate and sign API requests, but implementing
    the more complex solutions are beyond the scope of this book. To illustrate how
    to integrate authentication, you’ll use the basic-auth package.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用各种技术来验证和签名API请求，但实现更复杂解决方案超出了本书的范围。为了说明如何集成认证，我们将使用basic-auth包。
- en: Designing the API
  id: totrans-1060
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设计API
- en: Before proceeding with the implementation, it’s a good idea to rough out the
    routes involved. For this application, you’ll prefix the RESTful API with the
    /api path, but this is a design choice you can alter. For example, you may wish
    to use a subdomain such as [http://api.myapplication.com](http://api.myapplication.com).
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实施之前，先大致规划一下涉及的路线是个好主意。对于这个应用，你将在RESTful API前加上/api路径，但这是一个你可以更改的设计选择。例如，你可能希望使用一个子域名，如[http://api.myapplication.com](http://api.myapplication.com)。
- en: 'The following snippet illustrates why it can be a good choice to move the callback
    functions into separate Node modules, versus defining them inline with the `app.VERB()`
    calls. A single list of routes gives you a clear picture of what you and the rest
    of your team have implemented, and where the implementation callback lives:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段说明了为什么将回调函数移动到单独的Node模块中，而不是与`app.VERB()`调用内联定义，可能是一个好的选择。一个清晰的路线列表可以让你和你的团队清楚地了解已经实现了什么，以及实现回调函数的位置：
- en: '[PRE107]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Adding Basic authentication
  id: totrans-1064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加基本认证
- en: As previously mentioned, there are many ways to approach API security and restrictions
    that fall outside the scope of this book. But it’s worth illustrating the process
    with Basic authentication.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有许多方法可以处理API安全性和限制，但这些方法超出了本书的范围。但用基本认证来展示这个过程是值得的。
- en: The `api.auth` middleware will abstract this process, because the implementation
    will live in the soon-to-be-created ./routes/api.js module. The `app.use()` method
    can be passed a pathname, which is known in Express as a *mount point*. With this
    mount point, pathnames beginning with /api and any HTTP verb will cause this middleware
    to be invoked.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '`api.auth` 中间件将抽象这个过程，因为实现将位于即将创建的 ./routes/api.js 模块中。`app.use()` 方法可以传递一个路径名，在Express中称为
    *挂载点*。使用这个挂载点，以 /api 开头的路径名和任何HTTP动词都会触发此中间件的调用。'
- en: 'The line `app.use(''/api'', api.auth)`, as shown in the following snippet,
    should be placed before the middleware that loads user data. This is so that you
    can later modify the user-loading middleware to load data for authenticated API
    users:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中显示的行 `app.use('/api', api.auth)` 应该放在加载用户数据的中间件之前。这样做是为了您可以在以后修改用户加载中间件以加载认证API用户的资料：
- en: '[PRE108]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'To perform Basic authentication, install the basic-auth module: `npm install
    --save basic-auth`. Next, create the ./routes/api.js file, and require both Express
    and the user model, as shown in the following snippet. The basic-auth package
    accepts a function to perform the authentication, taking the function signature
    `(username, password, callback)`. Your `User.authenticate` method is a perfect
    fit:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行基本认证，安装 basic-auth 模块：`npm install --save basic-auth`。接下来，创建 ./routes/api.js
    文件，并像以下代码片段所示，引入Express和用户模型。basic-auth 包接受一个函数来执行认证，该函数签名是 `(username, password,
    callback)`。您的 `User.authenticate` 方法是完美的选择：
- en: '[PRE109]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Authentication is ready to roll. Let’s move on to implementing the API routes.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 认证准备就绪。让我们继续实施API路由。
- en: Implementing routing
  id: totrans-1072
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实施路由
- en: 'The first route you’ll implement is `GET /api/user/:id`. The logic for this
    route has to first fetch the user by ID, responding with a *404 Not Found* code
    if the user doesn’t exist. If the user exists, the user data will be passed to
    `res.send()` to be serialized, and the application will respond with a JSON representation
    of this data. Add the logic in the following snippet to routes/api.js:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 您将实现的第一条路由是 `GET /api/user/:id`。此路由的逻辑必须首先通过ID获取用户，如果用户不存在，则响应 *404 Not Found*
    代码。如果用户存在，用户数据将被传递到 `res.send()` 进行序列化，应用程序将响应数据的JSON表示。在 routes/api.js 中添加以下代码片段的逻辑：
- en: '[PRE110]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Next, add the following route path to app.js:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下路由路径添加到 app.js 中：
- en: '[PRE111]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: You’re now ready to test it.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以开始测试了。
- en: Testing user data retrieval
  id: totrans-1078
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试用户数据检索
- en: 'Fire up the application and test it with the cURL command-line tool. The following
    snippet shows how to test the application’s REST authentication. Credentials are
    provided in the URL `tobi:ferret`, which cURL uses to produce the `Authorization`
    header field:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序，并使用cURL命令行工具进行测试。以下代码片段显示了如何测试应用程序的REST认证。凭据在URL `tobi:ferret` 中提供，cURL使用它来生成
    `Authorization` 头字段：
- en: '[PRE112]'
  id: totrans-1080
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The following listing shows the result of a successful test. To perform a similar
    test, you need to make sure you know the ID of a user. Try using redis-cli and
    `GET user:ids` if `1` doesn’t work and you’ve registered a user.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了成功测试的结果。要执行类似的测试，您需要确保您知道用户的ID。如果 `1` 不起作用并且您已注册用户，请尝试使用 redis-cli 和
    `GET user:ids`。
- en: Listing 6.31\. Test output
  id: totrans-1082
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.31\. 测试输出
- en: '![](Images/06lis31_alt.jpg)'
  id: totrans-1083
  prefs: []
  type: TYPE_IMG
  zh: '![Images/06lis31_alt.jpg]'
- en: Removing sensitive user data
  id: totrans-1084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 删除敏感用户数据
- en: 'As you can see by the JSON response, both the user’s password and salt are
    provided in the response. To alter this, you can implement`.toJSON()` on the `User`
    in models/user.js:'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从JSON响应中看到的，用户的密码和盐都包含在响应中。要更改此，您可以在 models/user.js 中的 `User` 上实现 `.toJSON()`：
- en: '[PRE113]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'If `.toJSON` exists on an object, it will be used by `JSON.stringify` calls
    to get the JSON format. If the cURL request shown earlier was to be issued again,
    you’d now receive only the ID and name properties:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象上存在 `.toJSON`，它将被 `JSON.stringify` 调用用于获取JSON格式。如果之前显示的cURL请求再次发出，您现在将只收到ID和名称属性：
- en: '[PRE114]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The next thing you’ll add to the API is the ability to create entries.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 您接下来要添加到API中的是创建条目的能力。
- en: Adding entries
  id: totrans-1090
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加条目
- en: The processes for adding an entry via the HTML form and through an API are nearly
    identical, so you’ll likely want to reuse the previously implemented `entries.submit()`
    route logic.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTML表单和通过API添加条目的过程几乎相同，因此您可能希望重用之前实现的 `entries.submit()` 路由逻辑。
- en: 'When adding entries, however, the route logic stores the name of the user,
    adding the entry in addition to the other details. For this reason, you need to
    modify the user-loading middleware to populate `res.locals.user` with the user
    data loaded by the `basic-auth` middleware. The `basic-auth` middleware returns
    this data, and you set it to `req.remoteUser`. Adding a check for this in the
    user-loading middleware is straightforward; change the `module.exports` definition
    in middleware/user.js as follows to make the user-loading middleware work with
    the API:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在添加条目时，路由逻辑会存储用户的名称，除了其他详细信息外，还会添加条目。因此，您需要修改用户加载中间件，以便使用`basic-auth`中间件加载的用户数据填充`res.locals.user`。`basic-auth`中间件返回这些数据，并将它们设置为`req.remoteUser`。在用户加载中间件中添加对此的检查很简单；按照以下方式更改中间件/user.js中的`module.exports`定义，以便用户加载中间件与API一起工作：
- en: '[PRE115]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: With this change made, you’re now able to add entries via the API.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此更改后，您现在可以通过API添加条目。
- en: 'One more change to implement, however, is an API-friendly response, rather
    than redirection to the application’s home page. To add this functionality, change
    the `entry.save` call in routes/entries.js to the following:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还需要进行的一项更改是提供API友好的响应，而不是重定向到应用程序的主页。为了添加此功能，将routes/entries.js中的`entry.save`调用更改为以下内容：
- en: '[PRE116]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Finally, to activate the entry-adding API in your application, add the contents
    of the following snippet to the routing section of app.js:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在您的应用程序中激活条目添加API，将以下片段的内容添加到app.js的路由部分：
- en: '[PRE117]'
  id: totrans-1098
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'By using the following cURL command, you can test adding an entry via the API.
    Here the title and body data is sent using the same field names that are in the
    HTML form:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下cURL命令，您可以测试通过API添加条目。在这里，标题和正文数据使用与HTML表单中相同的字段名称发送：
- en: '[PRE118]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Now that you’ve added the ability to create entries, you need to add the ability
    to retrieve entry data.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经添加了创建条目的能力，您还需要添加检索条目数据的能力。
- en: Adding entry listing support
  id: totrans-1102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加条目列表支持
- en: The next API route to implement is `GET /api/entries/:page?`. The route implementation
    is nearly identical to the existing entry list route in ./routes/entries.js. You
    also need to add pagination middleware, which is `page()` in the following snippets.
    You’ll add `page()` shortly.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要实现的API路由是`GET /api/entries/:page?`。路由实现几乎与./routes/entries.js中现有的条目列表路由相同。您还需要添加分页中间件，即以下片段中的`page()`。您很快就会添加`page()`。
- en: 'Because the routing logic will be accessing entries, you require the `Entry`
    model at the top of routes/api.js by using the following line:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 因为路由逻辑将访问条目，所以您需要在routes/api.js的顶部使用以下行来引入`Entry`模型：
- en: '[PRE119]'
  id: totrans-1105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Next, add the lines in the following snippet to app.js:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下片段中的行添加到app.js中：
- en: '[PRE120]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now add the routing logic in the following snippet to routes/api.js. The difference
    between this route logic and the similar logic in routes/entries.js reflects the
    fact that you’re no longer rendering a template, but JSON instead:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下片段中的路由逻辑添加到routes/api.js中。此路由逻辑与routes/entries.js中类似逻辑之间的区别反映了您不再渲染模板，而是渲染JSON的事实：
- en: '[PRE121]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Implementing pagination middleware
  id: totrans-1110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现分页中间件
- en: For pagination, you use the query-string `?page=N` value to determine the current
    page. Add the following middleware function to ./middleware/page.js.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分页，您使用查询字符串`?page=N`的值来确定当前页。将以下中间件函数添加到./middleware/page.js中。
- en: Listing 6.32\. Pagination middleware
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.32\. 分页中间件
- en: '![](Images/06lis32_alt.jpg)'
  id: totrans-1113
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis32_alt.jpg)'
- en: This middleware grabs the value assigned to `?page=N`; for example, `?page=1`.
    It then fetches the total number of results and exposes the `page` object with
    precomputed values to any views that may later be rendered. These values are computed
    outside the template to allow for a cleaner template containing less logic.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 此中间件获取分配给`?page=N`的值；例如，`?page=1`。然后它获取结果总数，并将预计算的`page`对象暴露给任何可能稍后渲染的视图。这些值在模板外进行计算，以允许模板更干净，包含更少的逻辑。
- en: Testing the entries route
  id: totrans-1115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试条目路由
- en: 'The following cURL command requests entry data from the API:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下cURL命令从API请求条目数据：
- en: '[PRE122]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This cURL command should result in output similar to the following JSON:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个cURL命令应该产生类似于以下JSON的输出：
- en: '[PRE123]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: With basic API implementation covered, let’s move on to how APIs can support
    multiple response formats.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本的API实现完成后，让我们继续探讨API如何支持多种响应格式。
- en: 6.2.10\. Enabling content negotiation
  id: totrans-1121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.10\. 启用内容协商
- en: '*Content negotiation* enables a client to specify the formats that it’s willing
    to accept, and which it prefers. In this section, you’ll provide JSON and XML
    representations of the API content so that the API consumers can decide what they
    want.'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '*内容协商*允许客户端指定它愿意接受的格式以及它偏好的格式。在本节中，您将提供 API 内容的 JSON 和 XML 表示，以便 API 消费者可以决定他们想要什么。'
- en: 'HTTP provides the content negotiation mechanism via the `Accept` header field.
    For example, a client who prefers HTML but is willing to accept plain text could
    set the following request header:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 通过 `Accept` 头字段提供内容协商机制。例如，一个偏好 HTML 但愿意接受纯文本的客户端可以设置以下请求头：
- en: '[PRE124]'
  id: totrans-1124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The *qvalue*, or *quality value* (`q=0.5` in this example), indicates that
    even though `text/html` is specified second, it’s favored by 50% over `text/plain`.
    Express parses this information and provides a normalized `req.accepted` array:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '*qvalue*，或 *质量值*（例如本例中的 `q=0.5`），表示尽管指定了 `text/html`，但它比 `text/plain` 更受青睐
    50%。Express 解析此信息并提供一个标准化的 `req.accepted` 数组：'
- en: '[PRE125]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Express also provides the `res.format()` method, which accepts an array of MIME
    types and callbacks. Express will determine what the client is willing to accept
    and what you’re willing to provide, and it’ll invoke the appropriate callback.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: Express 还提供了 `res.format()` 方法，它接受一个 MIME 类型数组和回调。Express 将确定客户端愿意接受什么以及您愿意提供什么，并将调用适当的回调。
- en: Implementing content negotiation
  id: totrans-1128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现内容协商
- en: Implementing content negotiation for the `GET /api/entries` route, in routes/api.js,
    might look something like [listing 6.33](#ch06ex33). JSON is supported as it was
    before—you serialize the entries as JSON with `res.send()`. The XML callback iterates
    the entries and writes to the socket as it does so. Note that there’s no need
    to set the `Content-Type` explicitly; `res.format()` sets it to the associated
    type automatically.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 routes/api.js 中实现 `GET /api/entries` 路径的内容协商可能看起来像 [列表 6.33](#ch06ex33)。JSON
    支持如之前一样——您使用 `res.send()` 将条目序列化为 JSON。XML 回调迭代条目并在这样做时写入套接字。请注意，无需显式设置 `Content-Type`；`res.format()`
    会自动将其设置为相关类型。
- en: Listing 6.33\. Implementing content negotiation
  id: totrans-1130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.33. 实现内容协商
- en: '![](Images/06lis33_alt.jpg)'
  id: totrans-1131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis33_alt.jpg)'
- en: If you set a default response format callback, this will execute if a user hasn’t
    requested a format you’ve explicitly handled.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设置了默认响应格式回调，则当用户未请求您明确处理过的格式时，将执行此操作。
- en: 'The `res.format()` method also accepts an extension name that maps to an associated
    MIME type. For example, `json` and `xml` can be used in place of `application/json`
    and `application/xml`, as the following snippet shows:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.format()` 方法还接受一个扩展名，该扩展名映射到相关 MIME 类型。例如，`json` 和 `xml` 可以用来代替 `application/json`
    和 `application/xml`，如下面的代码片段所示：'
- en: '[PRE126]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: <entry>
  id: totrans-1135
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <entry>
- en: <title>${entry.title}</title>
  id: totrans-1136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <title>${entry.title}</title>
- en: <body>${entry.body}</body>
  id: totrans-1137
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <body>${entry.body}</body>
- en: <username>${entry.username}</username>
  id: totrans-1138
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <username>${entry.username}</username>
- en: </entry>
  id: totrans-1139
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: </entry>
- en: '[PRE127]'
  id: totrans-1140
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Responding with XML
  id: totrans-1141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 以 XML 格式响应
- en: Writing a bunch of custom logic in the route in order to respond with XML may
    not be the cleanest way to go, so let’s see how to use the view system to clean
    this up.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由中编写大量自定义逻辑以响应 XML 可能不是最干净的方法，所以让我们看看如何使用视图系统来清理这个问题。
- en: Create a template named ./views/entries/xml.ejs with the following EJS iterating
    the entries to generate `<entry>` tags.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 ./views/entries/xml.ejs 的模板，该模板使用 EJS 迭代条目以生成 `<entry>` 标签。
- en: Listing 6.34\. Using an EJS template to generate XML
  id: totrans-1144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.34. 使用 EJS 模板生成 XML
- en: '![](Images/06lis34_alt.jpg)'
  id: totrans-1145
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06lis34_alt.jpg)'
- en: 'The XML callback can now be replaced with a single `res.render()` call, passing
    the `entries` array, as shown in the following code:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将 XML 回调替换为单个 `res.render()` 调用，传递 `entries` 数组，如下所示：
- en: '[PRE128]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'You’re now ready to test the XML version of the API. Enter the following in
    the command line to see the XML output:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好测试 API 的 XML 版本。在命令行中输入以下内容以查看 XML 输出：
- en: '[PRE129]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 6.3\. Summary
  id: totrans-1150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3. 摘要
- en: Connect is an HTTP framework that lets you stack middleware components before
    and after requests are processed.
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Connect 是一个 HTTP 框架，允许您在请求处理前后堆叠中间件组件。
- en: Connect middleware components are functions that accept Node’s request and response
    objects, as well as a function that calls the next middleware and an optional
    error object.
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Connect 中间件组件是接受 Node 的请求和响应对象、一个调用下一个中间件的函数以及一个可选的错误对象的函数。
- en: Express web applications are also built with middleware components.
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express 网络应用程序也是使用中间件组件构建的。
- en: You can build REST APIs with Express by using HTTP verbs to define routes.
  id: totrans-1154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用Express通过使用HTTP动词来定义路由来构建REST API。
- en: Express routes can respond with JSON, HTML, or other data formats.
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express路由可以响应JSON、HTML或其他数据格式。
- en: Express has a simple template engine API that supports many engines.
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express有一个简单的模板引擎API，支持许多引擎。
- en: Chapter 7\. Web application templating
  id: totrans-1157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. Web应用程序模板化
- en: '*This chapter covers*'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Organizing applications with templating
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板组织应用程序
- en: Creating templates by using Embedded JavaScript
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过嵌入式JavaScript创建模板
- en: Learning minimalist templating with Hogan
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hogan学习极简模板化
- en: Using Pug to create templates
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pug创建模板
- en: In [chapters 3](kindle_split_013.xhtml#ch03) and [6](kindle_split_017.xhtml#ch06),
    you learned some basics about templates in Express applications in order to create
    views. In this chapter, you’ll focus exclusively on templating, learning how to
    use three popular template engines, and how to use templating to keep any web
    application’s code clean by separating logic from presentation markup.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](kindle_split_013.xhtml#ch03)和[第6章](kindle_split_017.xhtml#ch06)中，你学习了在Express应用程序中使用模板的一些基础知识，以便创建视图。在本章中，你将专注于模板化，学习如何使用三个流行的模板引擎，以及如何通过将逻辑与表示标记分离来使用模板化使任何Web应用程序的代码保持整洁。
- en: If you’re familiar with templating and the Model-View-Controller (MVC) pattern,
    you can skim through to [section 7.2](#ch07lev1sec2), where you’ll start learning
    about the template engines detailed in this chapter, which include Embedded JavaScript,
    Hogan, and Pug. If you’re not familiar with templating, keep reading—you’ll explore
    it conceptually in the next few sections.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉模板化和模型-视图-控制器（MVC）模式，你可以快速浏览到[第7.2节](#ch07lev1sec2)，在那里你将开始学习本章详细介绍的模板引擎，包括嵌入式JavaScript、Hogan和Pug。如果你不熟悉模板化，请继续阅读——你将在接下来的几节中从概念上探索它。
- en: 7.1\. Using templating to keep code clean
  id: totrans-1165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 使用模板保持代码整洁
- en: You can use the MVC pattern to develop conventional web applications in Node
    as well as in nearly every other web technology. One of the key concepts in MVC
    is the separation of logic, data, and presentation. In MVC web applications, the
    user typically requests a resource from the server, which causes the *controller*
    to request application data from the *model* and then pass the data to the *view*,
    which finally formats the data for the end user. This view portion of the MVC
    pattern is often implemented by using one of various templating languages. When
    an application uses templating, the view relays selected values, returned by the
    model, to a *template engine*, and specifies the template file that defines how
    to display the provided values.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用MVC模式在Node中以及几乎所有的其他Web技术中开发传统Web应用程序。MVC中的一个关键概念是逻辑、数据和表示的分离。在MVC Web应用程序中，用户通常从服务器请求资源，这会导致*控制器*从*模型*请求应用程序数据，然后将数据传递给*视图*，最终为最终用户格式化数据。MVC模式中的这个视图部分通常通过使用各种模板语言之一来实现。当一个应用程序使用模板化时，视图将模型返回的选定值传递给*模板引擎*，并指定定义如何显示提供的值的模板文件。
- en: '[Figure 7.1](#ch07fig01) shows how templating logic fits into the overall architecture
    of an MVC application. Template files typically contain placeholders for application
    values as well as HTML, CSS, and sometimes small bits of client-side JavaScript
    to implement dynamic behavior, including displaying third-party widgets such as
    Facebook’s Like button, or to trigger interface behavior, such as hiding or revealing
    parts of the page. Because template files focus on presentation rather than logic,
    front-end developers and server-side developers can work on them, which can help
    with a project’s division of labor.'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.1](#ch07fig01)显示了模板逻辑如何适合MVC应用程序的整体架构。模板文件通常包含应用程序值的占位符以及HTML、CSS，有时还有一小部分客户端JavaScript来实现动态行为，包括显示第三方小部件，如Facebook的“赞”按钮，或触发界面行为，如隐藏或显示页面的一部分。因为模板文件侧重于表示而不是逻辑，所以前端开发人员和后端开发人员可以共同工作，这有助于项目的劳动分工。'
- en: Figure 7.1\. The flow of an MVC application and its interaction with the template
    layer
  id: totrans-1168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. MVC应用程序的流程及其与模板层的交互
- en: '![](Images/07fig01_alt.jpg)'
  id: totrans-1169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01_alt.jpg)'
- en: In this section, we’ll render HTML with, and without, a template to show you
    the difference. But first, let’s start with an example of templating in action.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示带有和没有模板的HTML渲染，以展示它们之间的差异。但首先，让我们从一个模板应用的实例开始。
- en: 7.1.1\. Templating in action
  id: totrans-1171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 模板应用实例
- en: As a quick illustration of applying templating, let’s look at the problem of
    elegantly outputting HTML from a simple blogging application. Each blog entry
    has a title, date of entry, and body text. The blog looks similar to [figure 7.2](#ch07fig02)
    in a web browser.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用模板的一个快速示例，让我们看看如何从简单的博客应用中优雅地输出HTML。每篇博客条目都有一个标题、条目日期和正文文本。在浏览器中，博客看起来类似于[图7.2](#ch07fig02)。
- en: Figure 7.2\. Example blog application browser output
  id: totrans-1173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 示例博客应用浏览器输出
- en: '![](Images/07fig02.jpg)'
  id: totrans-1174
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig02.jpg)'
- en: Blog entries are read from a text file formatted like the following snippet
    from entries.txt. The `---` in the following listing indicates where one entry
    stops and another begins.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 博客条目从格式类似于以下`entries.txt`片段的文本文件中读取。以下列表中的`---`表示一个条目的结束和另一个条目的开始。
- en: Listing 7.1\. Blog entries text file
  id: totrans-1176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1\. 博客条目文本文件
- en: '[PRE130]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The blog application code in blog.js starts by requiring necessary modules and
    reading in the blog entries, as shown in the following listing.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 博客应用代码在`blog.js`中开始时，通过以下列表展示了所需的模块导入和博客条目的读取操作。
- en: Listing 7.2\. Blog entry file-parsing logic for a simple blogging application
  id: totrans-1179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2\. 简单博客应用中的博客条目文件解析逻辑
- en: '![](Images/07lis02_alt.jpg)'
  id: totrans-1180
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07lis02_alt.jpg)'
- en: 'The following code, when added to the blog application, defines an HTTP server.
    When the server receives an HTTP request, it returns a page containing all blog
    entries. This page is rendered using a function called `blogPage`, which you’ll
    define next:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码，当添加到博客应用中时，定义了一个HTTP服务器。当服务器收到HTTP请求时，它返回一个包含所有博客条目的页面。这个页面是通过一个名为`blogPage`的函数渲染的，您将在下一个步骤中定义它：
- en: '[PRE131]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Now you need to define the `blogPage` function, which renders the blog entries
    into a page of HTML that can be sent to the user’s browser. You’ll implement this
    by trying two approaches:'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要定义`blogPage`函数，该函数将博客条目渲染成可以发送到用户浏览器的HTML页面。您将通过尝试两种方法来实现这一点：
- en: Rendering HTML without a template
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用模板渲染HTML
- en: Rendering HTML using a template
  id: totrans-1185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板渲染HTML
- en: Let’s look at rendering without a template first.
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看不使用模板的渲染。
- en: 7.1.2\. Rendering HTML without a template
  id: totrans-1187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. 不使用模板渲染HTML
- en: The blog application could output the HTML directly, but including the HTML
    with the application logic would result in clutter. In the following listing,
    the `blogPage` function illustrates a nontemplated approach to displaying blog
    entries.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 博客应用可以直接输出HTML，但将HTML包含在应用程序逻辑中会导致代码杂乱。在以下列表中，`blogPage`函数展示了显示博客条目的非模板方法。
- en: Listing 7.3\. Template engines separate presentation details from application
    logic
  id: totrans-1189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3\. 模板引擎将表示细节与应用逻辑分离
- en: '![](Images/07lis03_alt.jpg)'
  id: totrans-1190
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07lis03_alt.jpg)'
- en: Note that all of this presentation-related content, CSS definitions, and HTML
    adds many lines to the application.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些与表示相关的内容、CSS定义和HTML都为应用程序添加了许多行。
- en: Rendering HTML by using a template
  id: totrans-1192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用模板渲染HTML
- en: Rendering HTML by using templating allows you to remove the HTML from the application
    logic, cleaning up the code considerably.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板渲染HTML允许您将HTML从应用程序逻辑中移除，从而显著清理代码。
- en: 'To try the demos in this section, you need to install the Embedded JavaScript
    (EJS) module into your application directory. You can do this by entering the
    following on the command line:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试本节中的示例，您需要将嵌入式JavaScript (EJS) 模块安装到您的应用程序目录中。您可以在命令行中输入以下内容来完成此操作：
- en: '[PRE132]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The following snippet loads a template from a file and then defines a new version
    of the `blogPage` function, this time using the EJS template engine, which we’ll
    show you how to use in [section 7.2](#ch07lev1sec2):'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段从文件中加载一个模板，然后定义了一个新的`blogPage`函数版本，这次使用EJS模板引擎，我们将在[7.2节](#ch07lev1sec2)中向您展示如何使用它：
- en: '[PRE133]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The full listing can be found in this book’s listings under ch07-templates/listing7_4/.
    The EJS template file contains HTML markup (keeping it out of the application
    logic) and placeholders that indicate where data passed to the template engine
    should be put. The EJS template file that shows the blog entries contains the
    HTML and placeholders shown in the following listing.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的列表可以在本书的列表中找到，位于ch07-templates/listing7_4/。EJS模板文件包含HTML标记（将其保留在应用程序逻辑之外）和占位符，这些占位符指示数据传递到模板引擎时应放置的位置。以下列表展示了显示博客条目的HTML和占位符：
- en: Listing 7.4\. An EJS template for displaying blog entries
  id: totrans-1199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. 用于显示博客条目的EJS模板
- en: '![](Images/07lis04_alt.jpg)'
  id: totrans-1200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07lis04_alt.jpg)'
- en: Community-contributed Node modules also provide template engines, and a wide
    variety of them exist. If you consider HTML and/or CSS inelegant, because HTML
    requires closing tags and CSS requires opening and closing braces, take a closer
    look at template engines. They allow template files to use special languages (such
    as the Pug language, which we cover later in this chapter) that provide a shorthand
    way of specifying HTML, CSS, or both.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 社区贡献的Node模块也提供了模板引擎，并且存在各种各样的它们。如果你认为HTML和/或CSS不够优雅，因为HTML需要关闭标签，CSS需要开闭花括号，那么请更仔细地看看模板引擎。它们允许模板文件使用特殊语言（例如我们在本章后面将要介绍的Pug语言）来提供一种指定HTML、CSS或两者的简写方式。
- en: These template engines can make your templates cleaner, but you may not want
    to take the time to learn an alternative way of specifying HTML and CSS. Ultimately,
    what you decide to use comes down to a matter of personal preference.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模板引擎可以使你的模板更简洁，但你可能不想花时间去学习一种指定HTML和CSS的替代方法。最终，你决定使用什么取决于个人偏好。
- en: 'In the rest of this chapter, you’ll learn how to incorporate templating in
    your Node applications through the lens of three popular template engines:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将通过三个流行的模板引擎的视角学习如何在你的Node应用程序中集成模板：
- en: The Embedded JavaScript (EJS) engine
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式JavaScript (EJS) 引擎
- en: The minimalist Hogan engine
  id: totrans-1205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极简主义的Hogan引擎
- en: The Pug template engine
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pug模板引擎
- en: Each engine allows you to write HTML in an alternative way. Let’s start with
    EJS.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个引擎都允许你以不同的方式编写HTML。让我们从EJS开始。
- en: 7.2\. Templating with Embedded JavaScript
  id: totrans-1208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2. 使用嵌入式JavaScript进行模板化
- en: Embedded JavaScript ([https://github.com/visionmedia/ejs](https://github.com/visionmedia/ejs))
    takes a fairly straightforward approach to templating, and it will be familiar
    territory for folks who’ve used template engines in other languages, such as Java
    Server Pages (JSP), Smarty (PHP), Embedded Ruby (ERB), and so on. EJS allows you
    to embed EJS tags as placeholders for data within HTML. EJS also lets you execute
    raw JavaScript logic in your templates for tasks such as conditional branching
    and iteration, much as PHP does.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式JavaScript ([https://github.com/visionmedia/ejs](https://github.com/visionmedia/ejs))在模板方面采取了一种相当直接的方法，对于那些在其他语言中使用过模板引擎（如Java
    Server Pages (JSP)、Smarty (PHP)、嵌入式Ruby (ERB)等）的人来说，这将是一个熟悉的地方。EJS允许你在HTML中嵌入EJS标签作为数据占位符。EJS还允许你在模板中执行原始JavaScript逻辑，用于诸如条件分支和迭代等任务，就像PHP一样。
- en: 'In this section, you’ll learn how to do the following:'
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习以下内容：
- en: Create EJS templates
  id: totrans-1211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建EJS模板
- en: Use EJS filters to provide commonly needed, presentation-related functionality,
    such as text manipulation, sorting, and iteration
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EJS过滤器提供常用的、与展示相关的功能，例如文本操作、排序和迭代
- en: Integrate EJS with your Node applications
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将EJS集成到你的Node应用程序中
- en: Use EJS for client-side applications
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端应用程序中使用EJS
- en: Let’s dive deeper into the world of EJS templating.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探索EJS模板的世界。
- en: 7.2.1\. Creating a template
  id: totrans-1216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1. 创建模板
- en: 'In the world of templating, the data sent to the template engine for rendering
    is sometimes called the *context*. The following is a bare-bones example of Node
    using EJS to render a simple template in a context:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的世界里，发送给模板引擎进行渲染的数据有时被称为*上下文*。以下是一个使用Node和EJS在上下文中渲染简单模板的裸骨示例：
- en: '[PRE134]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Note the use of `locals` in the second argument sent to `render`. The second
    argument can include rendering options as well as context data, which means the
    use of `locals` ensures that individual bits of context data aren’t interpreted
    as EJS options. But it’s possible in most cases to pass the context itself as
    the second option, as the following `render` call illustrates:'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`render`函数的第二个参数中使用了`locals`。第二个参数可以包括渲染选项以及上下文数据，这意味着使用`locals`确保上下文数据的各个部分不会被解释为EJS选项。但在大多数情况下，可以将上下文本身作为第二个选项传递，如下面的`render`调用所示：
- en: '[PRE135]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'If you pass a context to EJS directly as the second argument to `render`, make
    sure you don’t name context values by using any of the following terms: `cache`,
    `client`, `close`, `compileDebug`, `debug`, `filename`, `open`, or `scope`. These
    values are reserved to allow the changing of template engine settings.'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接将上下文作为`render`函数的第二个参数传递给EJS，确保不要使用以下任何术语来命名上下文值：`cache`、`client`、`close`、`compileDebug`、`debug`、`filename`、`open`或`scope`。这些值被保留以允许更改模板引擎设置。
- en: Character escaping
  id: totrans-1222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符转义
- en: 'When rendering, EJS escapes any special characters in context values, replacing
    them with HTML entity codes. This is intended to prevent cross-site scripting
    (XSS) attacks, in which malicious web application users attempt to submit JavaScript
    as data in the hopes that when displayed, it’ll execute in some other user’s browser.
    The following code shows EJS’s escaping at work:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染时，EJS会转义上下文值中的任何特殊字符，并用HTML实体代码替换它们。这是为了防止跨站脚本（XSS）攻击，恶意网络应用程序用户试图将JavaScript作为数据提交，希望当显示时，它会在其他用户的浏览器中执行。以下代码显示了EJS的转义操作：
- en: '[PRE136]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The previous code displays the following output:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码显示了以下输出：
- en: '[PRE137]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'If you trust the data being used in your template and don’t want to escape
    a context value in an EJS template, you can use `<%-` instead of `<%=` in your
    template tag, as the following code demonstrates:'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您信任模板中使用的数据，并且不想在EJS模板中转义上下文值，您可以在模板标签中使用`<%-`而不是`<%=`，如下面的代码所示：
- en: '[PRE138]'
  id: totrans-1228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Note that if you don’t like the characters used by EJS to specify tags, you
    can customize them, like so:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您不喜欢EJS用于指定标签的字符，您可以自定义它们，如下所示：
- en: '[PRE139]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Now that you know the basics of EJS, let’s look at some more detailed examples.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了EJS的基础知识，让我们看看一些更详细的示例。
- en: 7.2.2\. Integrating EJS into your application
  id: totrans-1232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2。将EJS集成到您的应用程序中
- en: Because it’s awkward to store templates in files along with application code,
    and doing so clutters up your code, we’ll show you how to use Node’s filesystem
    API to read them from separate files.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将模板存储在与应用程序代码相同的文件中很不方便，这样做还会使你的代码变得杂乱，我们将向您展示如何使用Node的文件系统API从单独的文件中读取它们。
- en: Move to a working directory and create a file named app.js containing the code
    in the following listing.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到工作目录，创建一个名为app.js的文件，包含以下列表中的代码。
- en: Listing 7.5\. Storing template code in files
  id: totrans-1235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5。在文件中存储模板代码
- en: '![](Images/07lis05_alt.jpg)'
  id: totrans-1236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07lis05_alt.jpg)'
- en: Next, create a child directory called templates. You’ll keep your templates
    in this directory. Create a file named students.ejs in the templates directory.
    Enter the code in the following listing into templates/students.ejs.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为templates的子目录。您将在此目录中保存模板。在templates目录中创建一个名为students.ejs的文件。将以下列表中的代码输入到templates/students.ejs中。
- en: Listing 7.6\. EJS template that renders an array of students
  id: totrans-1238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6。渲染学生数组的EJS模板
- en: '[PRE140]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Caching EJS templates
  id: totrans-1240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 缓存EJS模板
- en: 'EJS supports optional, in-memory caching of template functions: after parsing
    your template file once, EJS will store the function that’s created by the parsing.
    Rendering a cached template will be faster because the parsing step can be skipped.'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: EJS支持可选的内存缓存模板函数：在解析您的模板文件一次后，EJS将存储由解析创建的函数。渲染缓存的模板将更快，因为可以跳过解析步骤。
- en: If you’re doing initial development of a Node web application, and you want
    to see any changes you make to your template files reflected immediately, don’t
    enable caching. But if you’re deploying an application to production, enabling
    caching is a quick, easy win. Caching is conditionally enabled via the `NODE_ENV`
    environment variable.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在进行Node网络应用程序的初始开发，并且希望立即看到您对模板文件所做的任何更改，请不要启用缓存。但如果是将应用程序部署到生产环境，启用缓存是一个快速、简单的方法。缓存是通过`NODE_ENV`环境变量条件性启用的。
- en: 'To try out caching, change the call to EJS’s `render` function in the previous
    example to the following:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试缓存，将上一个示例中对EJS的`render`函数的调用更改为以下内容：
- en: '[PRE141]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Note that the `filename` option doesn’t necessarily have to be a file; you can
    use a unique value that identifies whichever template you’re rendering.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`filename`选项不一定是文件；您可以使用一个唯一值来标识您正在渲染的任何模板。
- en: 'Now that you’ve learned how to integrate EJS with your Node applications, let’s
    look at how EJS can be used in a different way: in web browsers.'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学习了如何将EJS集成到Node应用程序中，让我们看看EJS可以以不同的方式使用：在网页浏览器中。
- en: 7.2.3\. Using EJS for client-side applications
  id: totrans-1247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3。在客户端应用程序中使用EJS
- en: 'To use EJS on the client side, you first need to download the EJS engine to
    your working directory, as shown by the following commands:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 要在客户端使用EJS，您首先需要将EJS引擎下载到工作目录，如下面的命令所示：
- en: '[PRE142]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: After you download the ejs.js file, you can use EJS in your client-side code.
    The following listing shows a simple client-side application of EJS. If you save
    this file as index.html, you should be able to open it in a browser to see the
    results.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 下载ejs.js文件后，您可以在客户端代码中使用EJS。以下列表显示了EJS的一个简单客户端应用程序。如果您将此文件保存为index.html，您应该能够在浏览器中打开它以查看结果。
- en: Listing 7.7\. Using EJS to add templating capabilities to the client side
  id: totrans-1251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 使用EJS向客户端添加模板功能
- en: '![](Images/07lis07_alt.jpg)'
  id: totrans-1252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07lis07_alt.jpg)'
- en: You’ve now learned how to use a fully featured Node template engine, so it’s
    time to look at the Hogan template engine, which deliberately limits the functionality
    available to templating code.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学会了如何使用功能齐全的Node模板引擎，现在是时候看看Hogan模板引擎了，它故意限制了模板代码可用的功能。
- en: 7.3\. Using the Mustache templating language with Hogan
  id: totrans-1254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 使用Hogan与Mustache模板语言
- en: Hogan.js ([https://github.com/twitter/hogan.js](https://github.com/twitter/hogan.js))
    is a template engine that was created by Twitter for its templating needs. Hogan
    is an implementation of the popular Mustache ([http://mustache.github.com/](http://mustache.github.com/))
    template language standard, which was created by GitHub’s Chris Wanstrath.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: Hogan.js ([https://github.com/twitter/hogan.js](https://github.com/twitter/hogan.js))
    是由Twitter为其模板需求创建的一个模板引擎。Hogan是流行的Mustache ([http://mustache.github.com/](http://mustache.github.com/))
    模板语言标准的实现，该标准由GitHub的Chris Wanstrath创建。
- en: Mustache takes a minimalist approach to templating. Unlike EJS, the Mustache
    standard deliberately doesn’t include conditional logic, or any built-in content-filtering
    capabilities other than escaping content to prevent XSS attacks. Mustache advocates
    that template code should be kept as simple as possible.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache对模板采用了一种极简主义的方法。与EJS不同，Mustache标准故意不包括条件逻辑，或除了转义内容以防止XSS攻击之外，没有其他内置的内容过滤功能。Mustache倡导模板代码应尽可能简单。
- en: In this section you’ll learn
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习
- en: How to create and implement Mustache templates in your application
  id: totrans-1258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在您的应用程序中创建和实现Mustache模板
- en: How to use the various template tags in the Mustache standard
  id: totrans-1259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Mustache标准中的各种模板标签
- en: How to organize your templates by using partials
  id: totrans-1260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用部分来组织模板
- en: How to fine-tune Hogan with your own delimiters and other options
  id: totrans-1261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用您自己的定界符和其他选项微调Hogan
- en: Let’s look at the alternative approach Hogan provides for templating.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Hogan提供的替代模板方法。
- en: 7.3.1\. Creating a template
  id: totrans-1263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1\. 创建模板
- en: 'To use Hogan in an application, or to try the demos in this section, you need
    to install Hogan in your application directory (ch07-templates/hogan-snippet).
    You can do this by entering the following command on the command line:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中使用Hogan，或尝试本节中的演示，您需要在应用程序目录（ch07-templates/hogan-snippet）中安装Hogan。您可以通过在命令行中输入以下命令来完成此操作：
- en: '[PRE143]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The following is a bare-bones example of Node using Hogan to render a simple
    template in a context. Running it outputs the text *Hello template!*
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用Hogan在上下文中渲染简单模板的Node的裸骨示例。运行它将输出文本*Hello template!*
- en: '[PRE144]'
  id: totrans-1267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Now that you know how to process Mustache templates with Hogan, let’s look at
    what tags Mustache supports.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了如何使用Hogan处理Mustache模板，让我们看看Mustache支持哪些标签。
- en: 7.3.2\. Using Mustache tags
  id: totrans-1269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 使用Mustache标签
- en: Mustache tags are conceptually similar to EJS’s tags. Mustache tags serve as
    placeholders for variable values, indicate where iteration is needed, and allow
    you to augment Mustache’s functionality and add comments to your templates.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: Mustache标签在概念上类似于EJS的标签。Mustache标签作为变量值的占位符，指示需要迭代的位置，并允许您增强Mustache的功能并在模板中添加注释。
- en: Displaying simple values
  id: totrans-1271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显示简单值
- en: To display a context value in a Mustache template, include the name of the value
    in double braces. Braces, in the Mustache community, are known as *mustaches*.
    If you want to display the value for context item `name`, for example, you use
    the Hogan tag `{{name}}`.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Mustache模板中显示上下文值，请将值的名称包含在双大括号中。在Mustache社区中，大括号被称为*胡子*。如果您想显示上下文项`name`的值，例如，您可以使用Hogan标签`{{name}}`。
- en: Like most template engines, Hogan escapes content by default to prevent XSS
    attacks. But to display an unescaped value in Hogan, you can either add a third
    mustache or prepend the name of the context item with an ampersand. Using the
    previous `name` example, you could display the context value unescaped by either
    using the `{{{name}}}` or `{{&name}}` tag formats.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数模板引擎一样，Hogan默认通过转义内容来防止XSS攻击。但要在Hogan中显示未转义值，您可以通过添加第三个胡子或在大括号前加上上下文项的名称来实现。使用之前的`name`示例，您可以通过使用`{{{name}}}`或`{{&name}}`标签格式来未转义地显示上下文值。
- en: 'If you want to add a comment in a Mustache template, you can use this format:
    `{{! This is a comment }}`.'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在Mustache模板中添加注释，可以使用此格式：`{{! This is a comment }}`。
- en: 'Sections: iterating through multiple values'
  id: totrans-1275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部分：遍历多个值
- en: 'Although Hogan doesn’t allow the inclusion of logic in templates, it does include
    an elegant way to iterate through multiple values in a context item by using Mustache
    *sections*. The following context, for example, contains an item with an array
    of values:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Hogan不允许在模板中包含逻辑，但它确实包含了一种优雅的方法，通过使用Mustache的*部分*来迭代上下文项中的多个值。例如，以下上下文包含一个包含值的数组：
- en: '[PRE145]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'If you want to create a template that displays each student in a separate HTML
    paragraph, with output similar to the following, it’s a straightforward task using
    a Hogan template:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个模板，该模板显示每个学生都在单独的HTML段落中，输出类似于以下内容，使用Hogan模板是一个简单直接的任务：
- en: '[PRE146]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The following template produces the desired HTML:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模板生成了所需的HTML：
- en: '[PRE147]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Inverted sections: default HTML when values don’t exist'
  id: totrans-1282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 倒置部分：不存在值时的默认HTML
- en: What if the value of the `students` item in the context data isn’t an array?
    If the value is a single object, for example, the template will display it. But
    sections won’t display if the corresponding item’s value is undefined or false,
    or is an empty array.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上下文数据中`students`项的值不是数组怎么办？如果值是一个单独的对象，例如，模板将显示它。但是，如果对应项的值是未定义的、false的，或者是一个空数组，则部分不会显示。
- en: 'If you want your template to output a message indicating that values don’t
    exist for a section, Hogan supports what Mustache calls *inverted sections*. The
    following template code, if added to the previous student display template, would
    display a message when no student data exists in the context:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望模板输出一个消息，指示某个部分不存在值，Hogan支持Mustache所说的*倒置部分*。以下模板代码，如果添加到之前的学生显示模板中，当上下文中不存在学生数据时将显示一条消息：
- en: '[PRE148]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Section lambdas: custom functionality in section blocks'
  id: totrans-1286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部分lambda：部分块中的自定义功能
- en: In order to allow developers to augment Mustache’s functionality, the Mustache
    standard lets you define section tags that process template content through a
    function call, rather than iterating through arrays. This is called a *section
    lambda*.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许开发者增强Mustache的功能，Mustache标准允许您定义处理模板内容的函数调用的部分标签，而不是迭代数组。这被称为*部分lambda*。
- en: '[Listing 7.8](#ch07ex08) shows an example of using a section lambda to add
    Markdown support when rendering a template. Note that the example uses the github-flavored-markdown
    module, which you install by entering `npm install github-flavored-markdown --dev`
    on your command line. If you’re using the book’s source code, run `npm install`
    from ch07-templates/listing7_8 to run the example.'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表7.8](#ch07ex08)展示了使用部分lambda在渲染模板时添加Markdown支持的一个示例。注意，该示例使用了github-flavored-markdown模块，您可以通过在命令行中输入`npm
    install github-flavored-markdown --dev`来安装它。如果您正在使用本书的源代码，请从`ch07-templates/listing7_8`运行`npm
    install`以运行示例。'
- en: In the following listing, the `**Name**` in the template gets rendered to `<strong>Name</strong>`
    when passing through the Markdown parser called by the section lambda logic.
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，模板中的`**Name**`在通过由部分lambda逻辑调用的Markdown解析器渲染时，会被转换为`<strong>Name</strong>`。
- en: Listing 7.8\. Using a lambda in Hogan
  id: totrans-1290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8. 在Hogan中使用lambda
- en: '![](Images/07lis08_alt.jpg)'
  id: totrans-1291
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07lis08_alt.jpg)'
- en: Section lambdas allow you to easily implement features such as caching and translation
    mechanisms in your templates.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 部分lambda允许您轻松实现诸如缓存和翻译机制等特性。
- en: 'Partials: reusing templates within other templates'
  id: totrans-1293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 部分模板：在其他模板中重用模板
- en: When writing templates, you want to avoid unnecessarily repeating the same code
    in multiple templates. One way to avoid this is to create partials. *Partials*
    are templates used as building blocks that are included in other templates. Another
    use of partials is to break up complicated templates into simpler templates.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写模板时，您希望避免在多个模板中不必要地重复相同的代码。避免这种情况的一种方法是通过创建部分模板。*部分模板*是作为构建块使用的模板，它们包含在其他模板中。部分模板的另一个用途是将复杂的模板分解成更简单的模板。
- en: The following listing, for example, uses a partial to separate the template
    code used to display student data from the main template.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下列表使用部分模板将用于显示学生数据的模板代码与主模板分开。
- en: Listing 7.9\. Using partials in Hogan
  id: totrans-1296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9. 在Hogan中使用部分模板
- en: '![](Images/07lis09_alt.jpg)'
  id: totrans-1297
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07lis09_alt.jpg)'
- en: 7.3.3\. Fine-tuning Hogan
  id: totrans-1298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3. 精调Hogan
- en: Hogan is fairly simple to use—after you’ve learned its vocabulary of tags, you
    should be off and running. You may need to tweak only a couple of options as you
    use it.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: Hogan相对简单易用——在您学会了其标签词汇后，您应该能够顺利使用。在使用过程中，您可能只需要调整几个选项。
- en: 'If you don’t like Mustache-style braces, you can change the delimiters Hogan
    uses by passing the `compile` method an option to override them. The following
    example shows compiling in Hogan using EJS-style delimiters:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢Mustache样式的花括号，你可以通过传递一个选项来覆盖Hogan使用的分隔符，将`compile`方法传递给选项。以下示例显示了使用EJS样式的分隔符在Hogan中进行编译：
- en: '[PRE149]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: In addition to Mustache, other template languages are available. One that attempts
    to eliminate as much of HTML’s noise as possible is Pug.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Mustache之外，还有其他模板语言可供选择。其中一种尝试尽可能消除HTML噪声的语言是Pug。
- en: 7.4\. Templating with Pug
  id: totrans-1303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4. 使用Pug进行模板化
- en: Pug ([http://pugjs.org](http://pugjs.org)), formerly known as Jade, offers an
    alternative way to specify HTML. It’s the default template engine in Express.
    The key difference between Pug and the majority of other templating systems is
    the use of meaningful whitespace. When creating a template in Pug, you use indentation
    to indicate HTML tag nesting. HTML tags also don’t have to be explicitly closed,
    which eliminates the problem of accidentally closing tags prematurely or not at
    all. Using indentation also results in templates that are less visually dense
    and easier to maintain.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: Pug（[http://pugjs.org](http://pugjs.org)），以前称为Jade，提供了一种指定HTML的替代方法。它是Express中的默认模板引擎。Pug与其他大多数模板系统的主要区别在于使用有意义的空白。在Pug中创建模板时，你使用缩进来表示HTML标签嵌套。HTML标签也不必显式关闭，这消除了意外提前关闭标签或根本不关闭标签的问题。使用缩进还可以使模板在视觉上不那么密集，更容易维护。
- en: 'For a quick example of this at work, let’s look at how you’d represent this
    snippet of HTML:'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速了解这个功能的工作原理，让我们看看如何表示以下HTML片段：
- en: '[PRE150]'
  id: totrans-1306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'This HTML could be represented using the following Pug template:'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Pug模板可以表示这个HTML：
- en: '[PRE151]'
  id: totrans-1308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Pug, like EJS, allows you to embed JavaScript, and you can use it on the server
    or client side. But Pug offers additional features, such as support for template
    inheritance and mixins. Mixins allow you to define easily reusable mini-templates
    to represent the HTML used for commonly occurring visual elements, such as item
    lists and boxes. Mixins are similar in concept to the Hogan.js partials, which
    you learned about in the previous section. Template inheritance makes it easy
    to organize the Pug templates needed to render a single HTML page into multiple
    files. You’ll learn about these features in detail later in this section.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 与EJS一样，Pug允许你在服务器或客户端嵌入JavaScript，但你还可以使用Pug提供的一些额外功能，例如支持模板继承和混入。混入允许你轻松定义可重用的迷你模板，以表示常用视觉元素（如项目列表和框）所使用的HTML。混入在概念上类似于你在上一节中学到的Hogan.js部分。模板继承使得将渲染单个HTML页面所需的Pug模板组织到多个文件中变得容易。你将在本节后面详细了解这些功能。
- en: 'To install Pug in a Node application directory, enter the following on the
    command line:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Node应用程序目录中安装Pug，请在命令行中输入以下内容：
- en: '[PRE152]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: In this section, you’ll learn
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习
- en: Pug basics, such as specifying class names, attributes, and block expansion
  id: totrans-1313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pug基础知识，例如指定类名、属性和块扩展
- en: How to add logic to your Pug templates by using built-in keywords
  id: totrans-1314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用内置关键字为你的Pug模板添加逻辑
- en: How to organize your templates by using inheritance, blocks, and mixins
  id: totrans-1315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过继承、块和混入来组织你的模板
- en: To get started, let’s look at the basics of Pug usage and syntax.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们看看Pug的使用基础和语法。
- en: 7.4.1\. Pug basics
  id: totrans-1317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1. Pug基础知识
- en: 'Pug uses the same tag names as HTML, but it lets you lose the opening and closing
    `<` and `>` characters and instead uses indentation to express tag nesting. A
    tag can have one or more CSS classes associated with it by adding `.<classname>`.
    A `div` element with the `content` and `sidebar` classes applied to it would be
    represented like this:'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: Pug使用与HTML相同的标签名，但它允许你省略开闭的`<`和`>`字符，而是使用缩进来表示标签嵌套。一个标签可以通过添加`.<classname>`与一个或多个CSS类相关联。一个应用了`content`和`sidebar`类的`div`元素将表示如下：
- en: '[PRE153]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'CSS IDs are assigned by adding `#<ID>` to the tag. You add a CSS ID of `featured_content`
    to the previous example by using the following Pug representation:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: CSS ID通过在标签中添加`#<ID>`来分配。你可以在上一个示例中使用以下Pug表示法添加`featured_content` CSS ID：
- en: '[PRE154]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Using div tag shorthand
  id: totrans-1322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用div标签简写
- en: 'Because the `div` tag is commonly used in HTML, Pug offers a shorthand way
    of specifying it. The following example renders to the same HTML as the previous
    example:'
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`div`标签在HTML中常用，Pug提供了一种简写的方式来指定它。以下示例渲染的HTML与上一个示例相同：
- en: '[PRE155]'
  id: totrans-1324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Now that you know how to specify HTML tags and their CSS classes and IDs, let’s
    look at how to specify HTML tag attributes.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何指定HTML标签及其CSS类和ID，让我们看看如何指定HTML标签属性。
- en: Specifying tag attributes
  id: totrans-1326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 指定标签属性
- en: 'You can specify tag attributes by enclosing the attributes in parentheses,
    separating the specification of each attribute from the next with a comma. You
    can specify a hyperlink that’ll open in a different tab by using the following
    Pug representation:'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将属性放在括号内来指定标签属性，用逗号分隔每个属性的指定。您可以使用以下Pug表示法指定一个将在新标签页中打开的超链接：
- en: '[PRE156]'
  id: totrans-1328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Because the specification of tag attributes can lead to long lines of Pug,
    the template engine provides you with some flexibility. The following Pug is valid
    and equivalent to the previous example:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标签属性的指定可能导致Pug中出现长行，模板引擎为您提供了某些灵活性。以下Pug是有效的，并且与上一个示例等价：
- en: '[PRE157]'
  id: totrans-1330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'You can also specify attributes that don’t require a value. The next Pug example
    shows the specification of an HTML form that includes a `select` element with
    an option preselected:'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定不需要值的属性。以下Pug示例显示了包含预选`select`元素的HTML表单的指定：
- en: '[PRE158]'
  id: totrans-1332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'In the previous code snippet, you can also see examples of tag content: `Select
    your favorite food:` after the `strong` tag; `Cheese` after the first `option`
    tag; and `Tofu` after the second `option` tag.'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您还可以看到标签内容的示例：`strong`标签后的`Select your favorite food:`；第一个`option`标签后的`Cheese`；以及第二个`option`标签后的`Tofu`。
- en: 'This is the normal way to specify tag content in Pug, but it’s not the only
    way. Although this style is great for short bits of content, it can result in
    Pug templates with overly long lines if a tag’s content is lengthy. Luckily, as
    the following example shows, Pug allows you to specify tag content by using the
    `|` character:'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指定Pug中标签内容的标准方式，但并非唯一方式。尽管这种风格非常适合短内容片段，但如果标签内容较长，可能会导致Pug模板中出现过长行。幸运的是，如下例所示，Pug允许您使用`|`字符指定标签内容：
- en: '[PRE159]'
  id: totrans-1335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'If the HTML tag, such as the `style` and `script` tags, accepts only text (meaning
    it doesn’t allow nested HTML elements), then the `|` characters can be left out
    entirely, as the following example shows:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTML标签，如`style`和`script`标签，只接受文本（意味着它不允许嵌套HTML元素），则可以完全省略`|`字符，如下例所示：
- en: '[PRE160]'
  id: totrans-1337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Having two separate ways to express long tag content and short tag content helps
    you keep your Pug templates looking elegant. Pug also supports an alternative
    way to express nesting, called *block expansion*.
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种单独的方式来表达长标签内容和短标签内容，这有助于您保持Pug模板的优雅。Pug还支持一种称为*块扩展*的替代嵌套表示方法。
- en: Keeping it organized with block expansion
  id: totrans-1339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用块扩展保持组织结构
- en: 'Pug normally expresses nesting through indentation, but sometimes indentation
    can lead to excess whitespace. For example, here’s a Pug template that uses indentation
    to define a simple list of links:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: Pug通常通过缩进来表示嵌套，但有时缩进会导致多余的空白。例如，以下是一个使用缩进来定义简单链接列表的Pug模板：
- en: '[PRE161]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'A more compact way to express the previous example is by using Pug block expansion.
    With block expansion, you add a colon after your tag to indicate nesting. The
    following code generates the same output as the previous listing, but in four
    lines instead of seven:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pug块扩展表达上一个示例的更紧凑方式。使用块扩展，您在标签后添加一个冒号来指示嵌套。以下代码生成的输出与上一个列表相同，但只有四行而不是七行：
- en: '[PRE162]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Now that you’ve had a good look at how to represent markup using Pug, let’s
    look at how to integrate Pug with your web application.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用Pug表示标记，让我们看看如何将Pug集成到您的Web应用程序中。
- en: Incorporating data in Pug templates
  id: totrans-1345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在Pug模板中嵌入数据
- en: 'Data is relayed to the Pug engine in the same basic way as in EJS. The template
    is first compiled into a function that’s then called with a context in order to
    render the HTML output. The following is an example of this:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以与EJS相同的基本方式传递给Pug引擎。模板首先编译成一个函数，然后通过上下文调用该函数以渲染HTML输出。以下是一个示例：
- en: '[PRE163]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Here, the `#{message}` in the template specifies a placeholder to be replaced
    by a context value.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模板中的`#{message}`指定了一个占位符，该占位符将由上下文值替换。
- en: 'Context values can also be used to supply values for attributes. The next example
    renders `<a href="http://google.com"></a>`:'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文值也可以用来为属性提供值。以下示例渲染了`<a href="http://google.com"></a>`：
- en: '[PRE164]'
  id: totrans-1350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Now that you’ve learned how HTML is represented using Pug, and how to provide
    Pug templates with application data, let’s look at how to incorporate logic in
    Pug.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用Pug表示HTML，以及如何向Pug模板提供应用程序数据，让我们看看如何在Pug中嵌入逻辑。
- en: 7.4.2\. Logic in Pug templates
  id: totrans-1352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2\. Pug模板中的逻辑
- en: 'After you supply Pug templates with application data, you need logic to deal
    with that data. Pug allows you to directly embed lines of JavaScript code into
    your templates, which is how you define logic in your templates. Code such as
    `if` statements, `for` loops, and `var` declarations are common. Before we dive
    into the details, here’s an example for template rendering a contact list, to
    give you a practical feel for how you might use Pug logic in an application:'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 在你为 Pug 模板提供应用程序数据后，你需要逻辑来处理这些数据。Pug 允许你直接将 JavaScript 代码行嵌入到模板中，这就是你在模板中定义逻辑的方式。如
    `if` 语句、`for` 循环和 `var` 声明等代码是常见的。在我们深入细节之前，这里有一个模板渲染联系名单的例子，以给你一个在实际应用中使用 Pug
    逻辑的感觉：
- en: '[PRE165]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Let’s first look at the various ways Pug handles output when embedding JavaScript
    code.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 Pug 在嵌入 JavaScript 代码时处理输出的各种方式。
- en: Using JavaScript in Pug templates
  id: totrans-1356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Pug 模板中使用 JavaScript
- en: Prefixing a line of JavaScript logic with `-` will execute the JavaScript without
    including any value returned from the code in the template’s output. Prefixing
    JavaScript logic with `=` will include a value returned from the code, escaped
    to prevent XSS attacks. But if your JavaScript generates code that shouldn’t be
    escaped, you can prefix it with `!=`. [Table 7.1](#ch07table01) summarizes the
    output resulting from these prefixes.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行 JavaScript 逻辑前加上 `-` 将会执行 JavaScript，但不会将代码返回的任何值包含在模板的输出中。在 JavaScript
    逻辑前加上 `=` 将会包含代码返回的值，并通过转义来防止 XSS 攻击。但如果你的 JavaScript 生成的代码不需要转义，你可以用 `!=` 前缀。表
    7.1（[Table 7.1](#ch07table01)）总结了这些前缀产生的输出。
- en: Table 7.1\. Prefixes used to embed JavaScript in Pug
  id: totrans-1358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1\. 用于在 Pug 中嵌入 JavaScript 的前缀
- en: '| Prefix | Output |'
  id: totrans-1359
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | 输出 |'
- en: '| --- | --- |'
  id: totrans-1360
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| = | Escaped output (for untrusted or unpredictable values, XSS safe) |'
  id: totrans-1361
  prefs: []
  type: TYPE_TB
  zh: '| = | 转义输出（用于不受信任或不预测的值，XSS 安全） |'
- en: '| != | Output without escaping (for trusted or predictable values) |'
  id: totrans-1362
  prefs: []
  type: TYPE_TB
  zh: '| != | 无转义输出（用于受信任或可预测的值） |'
- en: '| - | No output |'
  id: totrans-1363
  prefs: []
  type: TYPE_TB
  zh: '| - | 无输出 |'
- en: 'Pug includes commonly used conditional and iterative statements that can be
    written without prefixes: `if`, `else`, `case`, `when`, `default`, `until`, `while`,
    `each`, and `unless`.'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 包含了一些常用的条件性和迭代性语句，可以不使用前缀编写：`if`、`else`、`case`、`when`、`default`、`until`、`while`、`each`
    和 `unless`。
- en: 'Pug also allows you to define variables. The following shows two ways to assign
    values that are equivalent in Pug:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 还允许你定义变量。以下展示了在 Pug 中赋值两种等效的方式：
- en: '[PRE166]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The unprefixed statements have no output, just like the `-` prefix discussed
    previously.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 无前缀的语句没有输出，就像之前讨论的 `-` 前缀一样。
- en: Iterating through objects and arrays
  id: totrans-1368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 遍历对象和数组
- en: 'Values passed in a context are accessible to JavaScript in Pug. In the next
    example, you’ll read a Pug template from a file and pass the Pug template a context
    containing a couple of messages that you intend to display in an array:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文中传递的值在 Pug 中的 JavaScript 中是可访问的。在下一个例子中，你将从文件中读取一个 Pug 模板，并将包含一些你打算在数组中显示的消息的上下文传递给
    Pug 模板：
- en: '[PRE167]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The Pug template contains the following:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 模板包含以下内容：
- en: '[PRE168]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The final HTML output looks like this:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 HTML 输出如下所示：
- en: '[PRE169]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Pug also supports a non-JavaScript form of iteration: the `each` statement,
    which allows you to cycle through arrays and object properties with ease.'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 还支持一种非 JavaScript 形式的迭代：`each` 语句，它允许你轻松地遍历数组和对象属性。
- en: 'The following is equivalent to the previous example, but using `each` instead:'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下与上一个例子等效，但使用了 `each`：
- en: '[PRE170]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'You can cycle through object properties by using a slight variation, like this:'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过轻微的变化来遍历对象属性，如下所示：
- en: '[PRE171]'
  id: totrans-1379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Conditionally rendering template code
  id: totrans-1380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件渲染模板代码
- en: 'Sometimes templates need to make decisions about how data is displayed, depending
    on the value of the data. The next example illustrates a conditional in which,
    roughly half the time, the `script` tag is outputted as HTML:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 有时模板需要根据数据的值来决定如何显示数据。下一个例子演示了一个条件，大约一半的时间，`script` 标签会被输出为 HTML：
- en: '[PRE172]'
  id: totrans-1382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Conditionals can also be written in Pug by using a cleaner, alternative form:'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句也可以通过使用更简洁的替代形式在 Pug 中编写：
- en: '[PRE173]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'If you’re writing a negated conditional, such as `if (n != 1)`, you can use
    Pug’s `unless` keyword:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个否定条件，例如 `if (n != 1)`，你可以使用 Pug 的 `unless` 关键字：
- en: '[PRE174]'
  id: totrans-1386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Using case statements in Pug
  id: totrans-1387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 Pug 中使用 case 语句
- en: 'Pug also supports a non-JavaScript form of conditional similar to a `switch`:
    the `case` statement, which allows you to specify an outcome based on various
    template scenarios.'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 还支持类似于 `switch` 的非 JavaScript 形式的条件语句：`case` 语句，它允许你根据各种模板场景指定一个结果。
- en: 'The following example template shows how the `case` statement can be used to
    display results from the search of a blog in three ways. If the search finds nothing,
    a message is shown indicating that. If a single blog post is found, it’s displayed
    in detail. If multiple blog posts are found, an `each` statement is used to iterate
    through the posts, displaying their titles:'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例模板展示了如何使用 `case` 语句以三种方式显示博客搜索的结果。如果没有找到任何内容，会显示一条消息。如果找到一个博客帖子，会详细显示。如果找到多个博客帖子，会使用
    `each` 语句遍历帖子，显示它们的标题：
- en: '[PRE175]'
  id: totrans-1390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 7.4.3\. Organizing Pug templates
  id: totrans-1391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.3\. 组织 Pug 模板
- en: 'With your templates defined, you next need to know how to organize them. As
    with application logic, you don’t want to make your template files overly large.
    A single template file should correspond to a conceptual building block: a page,
    a sidebar, or blog post content, for example.'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了模板之后，接下来你需要了解如何组织它们。与应用程序逻辑一样，你不想让你的模板文件过大。单个模板文件应该对应一个概念性的构建块：一个页面、一个侧边栏或博客帖子内容等。
- en: 'In this section, you’ll learn a few mechanisms that allow template files to
    work together to render content:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解一些机制，这些机制允许模板文件协同工作以渲染内容：
- en: Structuring multiple templates with template inheritance
  id: totrans-1394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板继承结构化多个模板
- en: Implementing layouts by using block prepending/appending
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用块的前缀/后缀实现布局
- en: Template including
  id: totrans-1396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含模板
- en: Reusing template logic with mixins
  id: totrans-1397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混入重用模板逻辑
- en: Let’s begin by looking at template inheritance in Pug.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 Pug 中的模板继承开始。
- en: Structuring multiple templates with template inheritance
  id: totrans-1399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用模板继承结构化多个模板
- en: Template inheritance is one means of structuring multiple templates. The concept
    treats templates, conceptually, like classes in the object-oriented programming
    paradigm. One template can extend another, which can in turn extend another. You
    can use as many levels of inheritance as makes sense.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 模板继承是结构化多个模板的一种方法。从概念上讲，它将模板视为面向对象编程范式中的类。一个模板可以扩展另一个，而这个模板又可以扩展另一个。你可以使用任何有意义的继承级别。
- en: 'As a simple example, let’s look at using template inheritance to provide a
    basic HTML wrapper that you can use to wrap page content. In a working directory,
    create a folder called templates in which you’ll put the example’s Pug file. For
    a page template, you’ll create a file called layout.pug containing the following
    Pug:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的示例，让我们看看如何使用模板继承提供一个基本的 HTML 包装器，你可以用它来包装页面内容。在一个工作目录中，创建一个名为 templates
    的文件夹，你将在其中放置示例的 Pug 文件。对于页面模板，你将创建一个名为 layout.pug 的文件，包含以下 Pug 代码：
- en: '[PRE176]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The layout.pug template contains the bare-bones definition of an HTML page as
    well as two *blocks*. Blocks are used in template inheritance to define where
    a descendant template can provide content. In layout.pug, there’s a `title` block,
    allowing a descendent template to set the title, and a `content` block, allowing
    a descendant template to set what's to be displayed on the page.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: layout.pug 模板包含了 HTML 页面的基本定义以及两个 *块*。块在模板继承中用于定义子模板可以提供内容的位置。在 layout.pug 中，有一个
    `title` 块，允许子模板设置标题，还有一个 `content` 块，允许子模板设置要在页面上显示的内容。
- en: 'Next, in your working directory’s templates directory, create a file named
    page.pug. This template file will populate the `title` and `content` blocks:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的工作目录的模板目录中，创建一个名为 page.pug 的文件。这个模板文件将填充 `title` 和 `content` 块：
- en: '[PRE177]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Finally, add the logic in the following listing (a modification of an earlier
    example in this section), which will display the template results, showing inheritance
    in action.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加以下列表中的逻辑（本节中较早示例的修改），这将显示模板结果，展示继承的实际应用。
- en: Listing 7.10\. Template inheritance in action
  id: totrans-1407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 模板继承的实际应用
- en: '[PRE178]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Now let’s look at another template inheritance feature: block prepending and
    appending.'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个模板继承功能：块的前缀和后缀。
- en: Implementing layouts by using block prepending/appending
  id: totrans-1410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过使用块的前缀/后缀实现布局
- en: In the previous example, the blocks in layout.pug contain no content, which
    makes setting the content in the page.pug template straightforward. But if a block
    in an inherited template *does* contain content, this content can be built upon,
    rather than replaced, by descendant templates using block prepending and appending.
    This allows you to define common content and add to it, rather than replace it.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，layout.pug 中的块不包含任何内容，这使得在 page.pug 模板中设置内容变得简单。但如果继承模板中的块确实包含内容，则此内容可以通过子模板使用块前缀和后缀来构建，而不是替换。这允许你定义常见内容并添加到其中，而不是替换它。
- en: 'The following layout.pug template contains an additional block, `scripts`,
    which contains content—a `script` tag that loads the jQuery JavaScript library:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 layout.pug 模板包含一个额外的块，名为 `scripts`，其中包含内容——一个加载 jQuery JavaScript 库的 `script`
    标签：
- en: '[PRE179]'
  id: totrans-1413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: If you want the page.pug template to additionally load the jQuery UI library,
    you can do this by using the template in the following listing.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要 page.pug 模板额外加载 jQuery UI 库，你可以通过以下列表中的模板来实现。
- en: Listing 7.11\. Using `block append`ing to load an additional JavaScript file
  id: totrans-1415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 使用 `block append` 添加额外的 JavaScript 文件
- en: '![](Images/07lis11_alt.jpg)'
  id: totrans-1416
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07lis11_alt.jpg)'
- en: Template inheritance isn’t the only way to integrate multiple templates. You
    also can use the `include` Pug command.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 模板继承不是集成多个模板的唯一方法。你还可以使用 `include` Pug 命令。
- en: Template including
  id: totrans-1418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模板包含
- en: 'Another tool for organizing templates is Pug’s `include` command. This command
    incorporates the contents of another template. If you add the line `include footer`
    to the layout.pug template from the earlier example, you end up with the following
    template:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 组织模板的另一个工具是 Pug 的 `include` 命令。此命令结合了另一个模板的内容。如果你将 `include footer` 行添加到前面示例中的
    layout.pug 模板中，你最终会得到以下模板：
- en: '[PRE180]'
  id: totrans-1420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: This template includes the contents of a template named footer.pug in the rendered
    output of layout.pug, as illustrated in [figure 7.3](#ch07fig03).
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板在 layout.pug 的渲染输出中包含了名为 footer.pug 的模板的内容，如图 7.3 所示。[#ch07fig03]
- en: Figure 7.3\. Pug’s `include` mechanism provides a simple way to include the
    contents of one template in another template during rendering.
  id: totrans-1422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3\. Pug 的 `include` 机制提供了一个简单的方法，在渲染期间将一个模板的内容包含到另一个模板中。
- en: '![](Images/07fig03.jpg)'
  id: totrans-1423
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig03.jpg)'
- en: This can be used, for example, to add information about the site or design elements
    to layout.pug. You can also include non-Pug files by specifying the file extension
    (for example, `include twitter_widget.html`).
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来向 layout.pug 添加有关网站或设计元素的信息。你还可以通过指定文件扩展名（例如，`include twitter_widget.html`）来包含非
    Pug 文件。
- en: Reusing template logic with mixins
  id: totrans-1425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用混合重用模板逻辑
- en: Although Pug’s `include` command is useful for bringing in previously created
    chunks of code, it’s not ideal for creating a library of reusable functionality
    that you can share between pages and applications. For this, Pug provides the
    `mixin` command, which lets you define reusable Pug snippets.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Pug 的 `include` 命令对于引入先前创建的代码块很有用，但它并不是创建可在页面和应用程序之间共享的可重用功能库的理想选择。为此，Pug
    提供了 `mixin` 命令，它允许你定义可重用的 Pug 片段。
- en: A Pug mixin is analogous to a JavaScript function. A mixin can, like a function,
    take arguments, and these arguments can be used to generate Pug code.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: Pug 混合类似于 JavaScript 函数。混合可以像函数一样接受参数，并且可以使用这些参数生成 Pug 代码。
- en: 'Let’s say, for example, your application handles a data structure similar to
    the following:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你的应用程序处理类似于以下的数据结构：
- en: '[PRE181]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'If you want to define a way to output an HTML list derived from a given property
    of each object, you could define a mixin like the following one to accomplish
    this:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要定义一种方法来输出一个由每个对象的给定属性派生的 HTML 列表，你可以定义一个如以下所示的混合来完成此操作：
- en: '[PRE182]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'You could then use the mixin to display the data using this line of Pug:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下 Pug 代码行来使用混合显示数据：
- en: '[PRE183]'
  id: totrans-1433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: By using template inheritance, `include` statements, and mixins, you can easily
    reuse presentation markup and can prevent your template files from becoming larger
    than they need to be.
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模板继承、`include` 语句和混合，你可以轻松地重用表示标记，并防止你的模板文件变得比必要的还要大。
- en: 7.5\. Summary
  id: totrans-1435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 概述
- en: Templating engines help keep application logic and presentation organized.
  id: totrans-1436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板引擎有助于保持应用程序逻辑和表示的有序性。
- en: Node has several popular template engines, including EJS, Hogan.js, and Pug.
  id: totrans-1437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 有几个流行的模板引擎，包括 EJS、Hogan.js 和 Pug。
- en: EJS supports simple control flow and escape or unescaped interpolation.
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJS 支持简单的控制流和转义或未转义的插值。
- en: Hogan.js is a simple template engine that doesn't support control flow, but
    does support the Mustache standard.
  id: totrans-1439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hogan.js是一个简单的模板引擎，不支持控制流，但支持Mustache标准。
- en: Pug is a more complex template language that can output HTML, but doesn’t use
    angled brackets.
  id: totrans-1440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pug是一个更复杂的模板语言，可以输出HTML，但不使用尖括号。
- en: Pug relies on whitespace for embedding tags.
  id: totrans-1441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pug依赖于空白字符来嵌入标签。
- en: Chapter 8\. Storing application data
  id: totrans-1442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 存储应用程序数据
- en: '*This chapter covers*'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: 'Relational databases: PostgreSQL'
  id: totrans-1444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库：PostgreSQL
- en: 'NoSQL databases: MongoDB'
  id: totrans-1445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库：MongoDB
- en: ACID categories
  id: totrans-1446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACID类别
- en: Hosted cloud databases and storage services
  id: totrans-1447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管云数据库和存储服务
- en: Node.js serves an incredibly diverse set of developers with equally diverse
    needs. No single database or storage solution solves the number of use cases tackled
    by Node. This chapter provides a broad overview of the data storage possibilities,
    along with some important high-level concepts and terminology.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js为各种开发者提供了一系列极其多样化的需求。没有单一的数据库或存储解决方案能够解决Node处理的使用案例数量。本章提供了数据存储可能性的广泛概述，以及一些重要的高级概念和术语。
- en: 8.1\. Relational databases
  id: totrans-1449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 关系型数据库
- en: For most of the history of the web, relational databases have been the dominant
    choice for application data storage. This topic has been covered at length in
    many other texts and university programs, so we don’t spend too much time elaborating
    on this topic in this chapter.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络的大部分历史中，关系型数据库一直是应用程序数据存储的主导选择。这个主题在其他许多文本和大学课程中已经详细讨论过，所以我们本章不会在这个主题上花费太多时间进行阐述。
- en: 'Relational databases, built upon the mathematical ideas of relational algebra
    and set theory, have been around since the 1970s. A *schema* specifies the format
    of various data types and the relationships that exist among those types. For
    example, if you’re building a social network, you may have `User` and `Post` data
    types, and define a one-to-many relationship between `User` and `Post`. Then using
    Structured Query Language (SQL), you can issue queries on this data, such as,
    “Give me all posts belonging to a user with ID 123,” or in SQL: `SELECT * FROM
    post WHERE user_id=123`.'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在关系代数和集合理论数学思想之上的关系型数据库自20世纪70年代以来一直存在。*模式*指定了各种数据类型的格式以及这些类型之间的关系。例如，如果您正在构建一个社交网络，您可能有`User`和`Post`数据类型，并定义`User`和`Post`之间的一对多关系。然后使用结构化查询语言（SQL），您可以对此数据进行查询，例如，“给我所有属于ID为123的用户的所有帖子”，或者用SQL表示：`SELECT
    * FROM post WHERE user_id=123`。
- en: 8.2\. PostgreSQL
  id: totrans-1452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. PostgreSQL
- en: Both MySQL and PostgreSQL (Postgres) are popular relational database choices
    for Node applications. The differences between relational databases are mostly
    aesthetic, so for the most part, this section also applies to using other relational
    databases such as MySQL in Node. First, let’s look at how to install Postgres
    on your development machine.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL和PostgreSQL（Postgres）都是Node应用程序中流行的关系型数据库选择。关系型数据库之间的差异主要是美学上的，所以本节的大部分内容也适用于在Node中使用其他关系型数据库，如MySQL。首先，让我们看看如何在您的开发机上安装Postgres。
- en: 8.2.1\. Performing installation and setup
  id: totrans-1454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1. 执行安装和设置
- en: 'Postgres needs to be installed on your system. You can’t simply npm install
    it. Installation instructions vary from platform to platform. On macOS, installation
    is as simple as this:'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: Postgres需要在您的系统上安装。您不能简单地使用npm安装它。安装说明因平台而异。在macOS上，安装就像这样：
- en: '[PRE184]'
  id: totrans-1456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'You may run into upgrade issues if you already have a Postgres installation.
    Follow the instructions for your platform to migrate your existing databases,
    or wipe the database directory:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了Postgres，可能会遇到升级问题。按照您平台的说明迁移现有数据库，或者清除数据库目录：
- en: '[PRE185]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Then initialize and start Postgres:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 然后初始化并启动Postgres：
- en: '[PRE186]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This starts a Postgres daemon. This daemon needs to be started every time you
    boot your computer. You may want to automatically boot the Postgres daemon on
    startup, and many online guides detail this process for your particular operating
    system.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Postgres守护进程。每次您启动计算机时都需要启动此守护进程。您可能希望在启动时自动启动Postgres守护进程，许多在线指南详细说明了针对您特定操作系统的此过程。
- en: Similarly, most Linux systems have a package for installing Postgres. With Windows,
    you should download the installer from postgresql.org ([www.postgresql.org/download/windows/](http://www.postgresql.org/download/windows/)).
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，大多数Linux系统都有用于安装Postgres的软件包。对于Windows，您应从postgresql.org下载安装程序（[www.postgresql.org/download/windows/](http://www.postgresql.org/download/windows/))）。
- en: Several command-line administration utilities are installed with Postgres. You
    may want to familiarize yourself with some of them by reading their `man` pages.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: Postgres 随安装附带了一些命令行管理工具。你可能想通过阅读它们的 `man` 页面来熟悉其中的一些。
- en: 8.2.2\. Creating the database
  id: totrans-1464
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 创建数据库
- en: 'After the Postgres daemon is running, you need to create a database to use.
    This needs to be done only once. The simplest way is to use `createdb` from the
    command line. Here you create a database named *articles*:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Postgres 守护进程运行后，你需要创建一个数据库来使用。这只需要做一次。最简单的方法是使用命令行中的 `createdb`。在这里，你创建一个名为
    *articles* 的数据库：
- en: '[PRE187]'
  id: totrans-1466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: There is no output if this succeeds. If a database with this name already exists,
    this command does nothing and reports a failure.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，则没有输出。如果已存在具有此名称的数据库，则此命令不会执行任何操作并报告失败。
- en: 'Most applications connect to only a single database at a time, though multiple
    databases may be configured, depending on the *environment* the database is running
    in. Many applications have at least two environments: development and production.'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能配置了多个数据库，但大多数应用程序一次只连接到一个数据库，这取决于数据库运行的 *环境*。许多应用程序至少有两个环境：开发和生产。
- en: 'To drop all the data from an existing database, you can run the `dropdb` command
    from a terminal, passing the database name as an argument:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 要从现有数据库中删除所有数据，你可以从终端运行 `dropdb` 命令，并将数据库名称作为参数传递：
- en: '[PRE188]'
  id: totrans-1470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: You need to run `createdb` before using this database again.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次使用此数据库之前，你需要运行 `createdb`。
- en: 8.2.3\. Connecting to Postgres from Node
  id: totrans-1472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3\. 从 Node 连接到 Postgres
- en: 'The most popular package for interfacing with Postgres from node is `pg`. You
    can install `pg` by using `npm`:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Node 连接到 Postgres 最受欢迎的包是 `pg`。你可以使用 `npm` 安装 `pg`：
- en: '[PRE189]'
  id: totrans-1474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: With the Postgres server running, a database created, and the `pg` package installed,
    you’re ready to start using the database from Node. Before you can issue any commands
    against the server, you need to establish a connection to it, as shown in the
    next listing.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Postgres 服务器运行，数据库已创建，并且已安装 `pg` 包时，你就可以开始从 Node 使用数据库了。在你可以对服务器发出任何命令之前，你需要建立与它的连接，如下一列表所示。
- en: Listing 8.1\. Connecting to the database
  id: totrans-1476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1\. 连接到数据库
- en: '![](Images/08lis01_alt.jpg)'
  id: totrans-1477
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08lis01_alt.jpg)'
- en: 'Comprehensive documentation for `pg.Client` and other methods can be found
    on the `pg` package’s wiki page on GitHub: [https://github.com/brianc/node-postgres/wiki](https://github.com/brianc/node-postgres/wiki).'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: '`pg.Client` 和其他方法的全面文档可以在 GitHub 上 `pg` 包的 wiki 页面上找到：[https://github.com/brianc/node-postgres/wiki](https://github.com/brianc/node-postgres/wiki)。'
- en: 8.2.4\. Defining tables
  id: totrans-1479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.4\. 定义表
- en: In order to store data in PostgreSQL, you first need to define some tables and
    the shape of the data to be stored within them, as shown in the following listing
    (ch08-databases/listing8_3 in the book’s source code).
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 PostgreSQL 中存储数据，你首先需要定义一些表以及要存储的数据的形状，如以下列表所示（书中源代码的 ch08-databases/listing8_3）。
- en: Listing 8.2\. Defining a schema
  id: totrans-1481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2\. 定义模式
- en: '[PRE190]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 8.2.5\. Inserting data
  id: totrans-1483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.5\. 插入数据
- en: After your table is defined, you can insert data into it by using `INSERT` queries,
    as shown in the next listing. If you don’t specify the `id` value, PostgreSQL
    will select an ID for you. To learn which ID was chosen for a particular row,
    you append `RETURNING id` to your query, and it appears in the rows of the result
    passed to the callback.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的表定义完成后，你可以通过使用 `INSERT` 查询将其中的数据插入，如下一列表所示。如果你没有指定 `id` 值，PostgreSQL 将为你选择一个
    ID。要了解为特定行选择了哪个 ID，你可以在查询中附加 `RETURNING id`，它将出现在传递给回调函数的结果行的行中。
- en: Listing 8.3\. Inserting data
  id: totrans-1485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.3\. 插入数据
- en: '[PRE191]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 8.2.6\. Updating data
  id: totrans-1487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.6\. 更新数据
- en: After data is inserted, you can update the data by using an `UPDATE` query,
    as shown in the next listing. The number of affected rows will be available in
    the `rowCount` property of the query result. You can find the full example for
    this listing in ch08-databases/listing8_4.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 数据插入后，你可以通过使用 `UPDATE` 查询来更新数据，如下一列表所示。受影响行数将在查询结果的 `rowCount` 属性中可用。你可以在这个列表的完整示例中找到
    ch08-databases/listing8_4。
- en: Listing 8.4\. Updating data
  id: totrans-1489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 更新数据
- en: '[PRE192]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 8.2.7\. Querying data
  id: totrans-1491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.7\. 查询数据
- en: One of the most powerful features of a relational database is the ability to
    perform complex ad hoc queries on your data. Querying is performed by using `SELECT`
    statements, and the simplest example of this is shown in the following listing.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库最强大的功能之一是能够对你的数据进行复杂的即席查询。查询是通过使用 `SELECT` 语句来执行的，以下列表展示了这一点的最简单示例。
- en: Listing 8.5\. Querying data
  id: totrans-1493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.5\. 查询数据
- en: '[PRE193]'
  id: totrans-1494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 8.3\. Knex
  id: totrans-1495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. Knex
- en: Many developers prefer to not work with SQL statements directly in their applications,
    instead using an abstraction over the top. This is understandable, given that
    concatenating strings into SQL statements can be a clunky process and that queries
    can grow hard to understand and maintain. This has been particularly true for
    JavaScript, which didn’t have a syntax for representing multiline strings until
    ES2015 introduced template literals (see [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals)).
    [Figure 8.1](#ch08fig01) shows Knex’s statistics, including the number of downloads,
    which demonstrates its popularity.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者更喜欢不在他们的应用程序中直接处理SQL语句，而是使用抽象层。这是可以理解的，因为将字符串连接到SQL语句可能是一个笨拙的过程，而且查询可能会变得难以理解和维护。这对于JavaScript来说尤其如此，因为直到ES2015引入了模板字符串（请参阅
    [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals)），JavaScript都没有表示多行字符串的语法。[图
    8.1](#ch08fig01) 显示了 Knex 的统计数据，包括下载次数，这证明了它的流行。
- en: Figure 8.1\. Knex’s usage statistics
  id: totrans-1497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1\. Knex 的使用统计
- en: '![](Images/08fig01.jpg)'
  id: totrans-1498
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig01.jpg)'
- en: '*Knex* is a Node package implementing a type of lightweight abstraction over
    SQL, known as a *query builder*. A query builder constructs SQL strings though
    a declarative API that closely resembles the generated SQL. The Knex API is intuitive
    and unsurprising:'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: '*Knex* 是一个Node包，它实现了一种轻量级的SQL抽象，称为 *查询构建器*。查询构建器通过一个声明式API构建SQL字符串，该API与生成的SQL非常相似。Knex
    API直观且不出所料：'
- en: '[PRE194]'
  id: totrans-1500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'This produces a parameterized SQL query in the MySQL dialect of SQL:'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 这在MySQL方言的SQL中生成一个参数化SQL查询：
- en: '[PRE195]'
  id: totrans-1502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 8.3.1\. jQuery for databases
  id: totrans-1503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 数据库的 jQuery
- en: Despite ANSI and ISO SQL standards existing since the mid-1980s, most databases
    still speak their own SQL dialects. PostgreSQL is a notable exception; it prides
    itself on adhering to the SQL:2008 standard. A query builder can normalize differences
    across SQL dialects, providing a single, unified interface for SQL generation
    for multiple technologies. This has clear benefits for teams that regularly context-switch
    between various database technologies.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ANSI和ISO SQL标准自1980年代中期以来就已经存在，但大多数数据库仍然使用自己的SQL方言。PostgreSQL是一个值得注意的例外；它自豪地宣称自己遵循SQL:2008标准。查询构建器可以标准化不同SQL方言之间的差异，为多种技术提供统一的SQL生成接口。这对经常在多种数据库技术之间切换的团队来说具有明显的优势。
- en: 'Knex.js currently supports the following databases:'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: Knex.js 目前支持以下数据库：
- en: PostgreSQL
  id: totrans-1506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: MSSQL
  id: totrans-1507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSSQL
- en: MySQL
  id: totrans-1508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: MariaDB
  id: totrans-1509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MariaDB
- en: SQLite3
  id: totrans-1510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite3
- en: Oracle
  id: totrans-1511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle
- en: '[Table 8.1](#ch08table01) compares the ways Knex generates an insert statement,
    depending on which database is selected.'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8.1](#ch08table01) 比较了Knex根据所选数据库生成插入语句的方式。'
- en: Table 8.1\. Comparing Knex-generated SQL for various databases
  id: totrans-1513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 8.1\. 比较Knex生成的各种数据库的SQL
- en: '| Database | SQL |'
  id: totrans-1514
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | SQL |'
- en: '| --- | --- |'
  id: totrans-1515
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| PostgreSQL, SQLite, and Oracle | insert into "users" ("name", "age") values
    (?, ?) |'
  id: totrans-1516
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL、SQLite 和 Oracle | insert into "users" ("name", "age") values (?,
    ?) |'
- en: '| MySQL and MariaDB | insert into `users` (`name`, `age`) values (?, ?) |'
  id: totrans-1517
  prefs: []
  type: TYPE_TB
  zh: '| MySQL 和 MariaDB | insert into `users` (`name`, `age`) values (?, ?) |'
- en: '| Microsoft SQL Server | insert into [users] ([name], [age]) values (?, ?)
    |'
  id: totrans-1518
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft SQL Server | insert into [users] ([name], [age]) values (?, ?)
    |'
- en: Knex supports promises and Node-style callbacks.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: Knex 支持 promises 和 Node 风格的回调。
- en: 8.3.2\. Connecting and running queries with Knex
  id: totrans-1520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 使用 Knex 连接和运行查询
- en: 'Unlike many other query builders, Knex can also connect and execute queries
    for you against the selected database driver:'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他查询构建器不同，Knex 还可以为你选择的数据驱动程序连接和执行查询：
- en: '[PRE196]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Knex queries return promises by default, but can also support Node’s callback
    convention with `.asCallback`:'
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: Knex 查询默认返回承诺，但也可以通过 `.asCallback` 支持Node的回调约定：
- en: '[PRE197]'
  id: totrans-1524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'In [chapter 3](kindle_split_013.xhtml#ch03), you interacted with a SQLite database
    by using the sqlite3 package directly. This API can be rewritten using Knex. To
    run this example, first ensure that both the knex and sqlite3 packages are installed
    from npm:'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](kindle_split_013.xhtml#ch03) 中，你通过直接使用 sqlite3 包与SQLite数据库交互。可以使用
    Knex 重写此API。要运行此示例，首先确保已从 npm 安装了 knex 和 sqlite3 包：
- en: '[PRE198]'
  id: totrans-1526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The next listing uses sqlite3 to implement a simple `Article` model. Save this
    file as db.js; you’ll use it in [listing 8.7](#ch08ex07) to interact with the
    database.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表使用 sqlite3 实现了一个简单的 `Article` 模型。将此文件保存为 db.js；你将在 [列表 8.7](#ch08ex07)
    中使用它来与数据库交互。
- en: Listing 8.6\. Using Knex to connect and query sqlite3
  id: totrans-1528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. 使用 Knex 连接和查询 sqlite3
- en: '![](Images/ch08ex06-0.jpg)'
  id: totrans-1529
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch08ex06-0.jpg)'
- en: '![](Images/ch08ex06-1.jpg)'
  id: totrans-1530
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch08ex06-1.jpg)'
- en: Now `Article` entries can be added by using `db.Article`. The following listing
    can be used with the previous one to create articles and then print them. See
    ch08-databases/listing8_7/index.js for the full example.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以使用 `db.Article` 添加 `Article` 条目。以下列表可以与上一个列表一起使用来创建文章并打印它们。有关完整示例，请参阅 ch08-databases/listing8_7/index.js。
- en: Listing 8.7\. Interacting with the Knex-powered API
  id: totrans-1532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7\. 与 Knex 驱动的 API 交互
- en: '[PRE199]'
  id: totrans-1533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'SQLite requires minimal configuration: you don’t need to boot up a server daemon
    or create databases from outside the application. SQLite writes everything into
    a single file. If you run the preceding code, you’ll find an articles.sqlite file
    in your current directory. Wiping a SQLite database is as simple as deleting this
    one file:'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 需要最少的配置：您不需要启动服务器守护进程或从应用程序外部创建数据库。SQLite 将所有内容写入单个文件。如果您运行前面的代码，您将在当前目录中找到一个
    articles.sqlite 文件。擦除 SQLite 数据库就像删除这个文件一样简单：
- en: '[PRE200]'
  id: totrans-1535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'SQLite also has an in-memory mode, which avoids writing to disk entirely. This
    mode is commonly used to decrease the running time of automated tests. You can
    configure in-memory mode by using the special `:memory:` filename. Opening multiple
    connections to the `:memory:` file gives each connection its own private database:'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 也支持内存模式，这种模式可以完全避免写入磁盘。这种模式通常用于减少自动化测试的运行时间。您可以通过使用特殊的 `:memory:` 文件名来配置内存模式。打开多个连接到
    `:memory:` 文件会为每个连接提供其自己的私有数据库：
- en: '[PRE201]'
  id: totrans-1537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 8.3.3\. Swapping the database back end
  id: totrans-1538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 交换数据库后端
- en: 'Because you’re using Knex, it’s trivial to change [listings 8.6](#ch08ex06)
    and [8.7](#ch08ex07) to use PostgreSQL over sqlite3\. Knex needs the pg package
    installed to talk to the PostgreSQL server, which you’ll need to have installed
    and running. Install the pg package into the folder with [listing 8.7](#ch08ex07)
    (ch08-databases/listing8_7 in the book’s code) and remember to create the appropriate
    database by using PostgreSQL’s `createdb` command-line utility:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在使用 Knex，将 [列表 8.6](#ch08ex06) 和 [8.7](#ch08ex07) 更改为使用 PostgreSQL 而不是 sqlite3
    是非常简单的。Knex 需要安装 pg 包以与 PostgreSQL 服务器通信，您需要安装并运行它。将 pg 包安装到包含 [列表 8.7](#ch08ex07)
    的文件夹中（书中的代码为 ch08-databases/listing8_7），并记得使用 PostgreSQL 的 `createdb` 命令行工具创建适当的数据库：
- en: '[PRE202]'
  id: totrans-1540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The only code changes required to use this new database are in the Knex configuration;
    otherwise, the consumer API and usage are identical:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此新数据库所需进行的唯一代码更改是在 Knex 配置中；否则，消费者 API 和使用方式相同：
- en: '[PRE203]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Note that in a real-world scenario, you’d also need to migrate any existing
    data.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在实际场景中，您还需要迁移任何现有数据。
- en: 8.3.4\. Beware of leaky abstractions
  id: totrans-1544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 谨防抽象泄漏
- en: 'Query builders can normalize SQL syntax, but can do little to normalize behavior.
    Some features are supported in only particular databases, and some databases may
    exhibit entirely different behavior given identical queries. For example, the
    following are two methods of defining a primary key when using Knex:'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 查询构建器可以标准化 SQL 语法，但对标准化行为所能做的很少。某些功能仅在特定数据库中受支持，并且某些数据库可能会在相同的查询下表现出完全不同的行为。例如，以下是在使用
    Knex 定义主键时的两种方法：
- en: '`table.increments(''id'').primary();`'
  id: totrans-1546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table.increments(''id'').primary();`'
- en: '`table.integer(''id'').primary();`'
  id: totrans-1547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`table.integer(''id'').primary();`'
- en: 'Both options work as expected in SQLite3, but the second option will cause
    an error in PostgreSQL when inserting a new record:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite3 中，这两种选项都能按预期工作，但第二种选项在 PostgreSQL 中插入新记录时会导致错误：
- en: '[PRE204]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Values inserted into SQLite with a `null` primary key will be assigned an automatically
    incremented ID, regardless of whether the primary-key column was explicitly configured
    to autoincrement. PostgreSQL, on the other hand, requires autoincrement columns
    to be defined explicitly. Many such behavioral differences exist between databases,
    and some differences may be subtle without visible errors. Thorough testing needs
    to be applied if you do choose to transition to a different database.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `null` 作为主键插入 SQLite 的值将被分配一个自动递增的 ID，无论主键列是否明确配置为自动递增。另一方面，PostgreSQL 需要显式定义自动递增列。数据库之间存在许多这样的行为差异，并且一些差异可能很微妙，没有明显的错误。如果您确实选择过渡到不同的数据库，则需要彻底测试。
- en: 8.4\. MySQL vs. PostgreSQL
  id: totrans-1551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. MySQL 与 PostgreSQL
- en: Both MySQL and PostgreSQL are mature and powerful databases, and for many projects,
    there will be minimal differences when selecting one over the other. Many distinctions,
    which won’t be significant until the project needs to scale, exist below or at
    the edge of the interface exposed to the application developer.
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 和 PostgreSQL 都是成熟且强大的数据库，对于许多项目来说，在选择其中一个时与其他选择之间的差异可能很小。许多区别，直到项目需要扩展时才变得显著，存在于或位于面向应用程序开发者的接口边缘或下方。
- en: 'An exhaustive comparison between relational databases is mostly beyond the
    scope of this book, as the topic is complicated. Some notable distinctions are
    listed here:'
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 详尽的关系型数据库比较通常超出了本书的范围，因为该主题很复杂。这里列出了一些显著的差异：
- en: PostgreSQL supports more-expressive data types, including arrays, JSON, and
    user-defined types.
  id: totrans-1554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 支持更丰富的数据类型，包括数组、JSON 和用户定义的类型。
- en: PostgreSQL has built-in full-text search.
  id: totrans-1555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 内置全文搜索功能。
- en: PostgreSQL supports the full ANSI SQL:2008 standard.
  id: totrans-1556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 支持完整的 ANSI SQL:2008 标准。
- en: PostgreSQL’s replication support isn’t as powerful or battle-tested as MySQL’s.
  id: totrans-1557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL 的复制支持不如 MySQL 强大或经过实战检验。
- en: MySQL is older and has a bigger community. More compatible tools and resources
    are available for MySQL.
  id: totrans-1558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 更老，拥有更大的社区。MySQL 有更多兼容的工具和资源。
- en: The MySQL community has more fragmentation through subtly different forks (for
    example, MariaDB and WebScaleSQL from Facebook, Google, Twitter, and so forth).
  id: totrans-1559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 社区由于细微的分支（例如，来自 Facebook、Google、Twitter 等的 MariaDB 和 WebScaleSQL）而更加碎片化。
- en: MySQL’s pluggable storage engine can make it more complicated to understand,
    administer, and tune. On the other hand, this can be seen as an opportunity for
    more fine-grained control over performance.
  id: totrans-1560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 的可插拔存储引擎可能会使其理解、管理和调优变得更加复杂。另一方面，这也可以被视为对性能进行更精细控制的机会。
- en: MySQL and PostgreSQL express different performance characteristics at scale,
    depending on the type of workload. The subtleties of your workload may not become
    obvious until the project matures.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 和 PostgreSQL 在不同类型的工作负载下表现出不同的性能特征，你的工作负载的微妙之处可能直到项目成熟才变得明显。
- en: 'Many online resources provide far more in-depth comparisons between relational
    databases:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在线资源提供了关于关系型数据库之间更深入的比较：
- en: '[www.digitalocean.com/community/tutorials/sqlite-vs-mysql-vs-postgresql-a-comparison-of-relational-database-management-systems](http://www.digitalocean.com/community/tutorials/sqlite-vs-mysql-vs-postgresql-a-comparison-of-relational-database-management-systems)'
  id: totrans-1563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.digitalocean.com/community/tutorials/sqlite-vs-mysql-vs-postgresql-a-comparison-of-relational-database-management-systems](http://www.digitalocean.com/community/tutorials/sqlite-vs-mysql-vs-postgresql-a-comparison-of-relational-database-management-systems)'
- en: '[https://blog.udemy.com/mysql-vs-postgresql/](https://blog.udemy.com/mysql-vs-postgresql/)'
  id: totrans-1564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://blog.udemy.com/mysql-vs-postgresql/](https://blog.udemy.com/mysql-vs-postgresql/)'
- en: '[https://eng.uber.com/mysql-migration/](https://eng.uber.com/mysql-migration/)'
  id: totrans-1565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://eng.uber.com/mysql-migration/](https://eng.uber.com/mysql-migration/)'
- en: Which relational database you initially choose is unlikely to be a significant
    factor in the success of your project, so don’t worry about this decision too
    much. You can migrate to another database later, but Postgres should be powerful
    enough to provide most of the features and scalability that you’ll ever need.
    But if you’re in a position to evaluate several databases, you should familiarize
    yourself with the idea of ACID guarantees.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 你最初选择哪种关系型数据库不太可能是你项目成功的关键因素，所以不必过于担心这个决定。你可以稍后迁移到另一个数据库，但 Postgres 应该足够强大，能够提供你需要的几乎所有功能和可扩展性。但如果你有机会评估几个数据库，你应该熟悉
    ACID 保证的概念。
- en: 8.5\. ACID guarantees
  id: totrans-1567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5. ACID 保证
- en: '*ACID* describes a set of desirable properties for database transactions: atomicity,
    consistency, isolation, and durability. The exact definitions of these terms can
    vary. As a general rule, the more strictly a system guarantees ACID properties,
    the greater the performance compromise. This ACID categorization is a common way
    for developers to quickly communicate the trade-offs of a particular solution,
    such as those found in NoSQL systems.'
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '*ACID* 描述了数据库事务的一组理想属性：原子性、一致性、隔离性和持久性。这些术语的确切定义可能有所不同。一般来说，一个系统越严格地保证 ACID
    属性，其性能妥协就越大。这种 ACID 分类是开发者快速沟通特定解决方案（如 NoSQL 系统中发现的）权衡的常见方式。'
- en: '8.5.1\. Atomicity: transactions either succeed or fail in entirety'
  id: totrans-1569
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.1. 原子性：事务要么完全成功，要么完全失败
- en: 'An *atomic* transaction can’t be partially executed: either the entire operation
    completes, or the database is left unchanged. For example, if a transaction is
    to delete all comments by a particular user, either all comments will be deleted,
    or none of them will be deleted. There is no way to end up with some comments
    deleted and some not. Atomicity should apply even in the case of system error
    or power failure. *Atomic* is used here with its original meaning of *indivisible*.'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*原子*事务不能部分执行：要么整个操作完成，要么数据库保持不变。例如，如果事务是要删除特定用户的全部评论，要么所有评论都会被删除，要么一个评论都不会被删除。不可能出现一些评论被删除而另一些没有被删除的情况。原子性即使在系统错误或电源故障的情况下也应该适用。"原子"在这里使用其原始意义，即*不可分割*。
- en: '8.5.2\. Consistency: constraints are always enforced'
  id: totrans-1571
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.2\. 一致性：约束始终得到执行
- en: The completion of a successful transaction must maintain all data-integrity
    constraints defined in the system. Some example constraints are that primary keys
    must be unique, data conforms to a particular schema, or foreign keys must reference
    entities that exist. Transactions that would lead to inconsistent state typically
    result in transaction failures, though minor issues may be resolved automatically;
    for example, coercing data into the correct shape. This isn’t to be confused with
    the C of *consistency* in the CAP theorem, which refers to guaranteeing a single
    view of the data being presented to all readers of a distributed store.
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 成功事务的完成必须维护系统定义的所有数据完整性约束。一些示例约束包括主键必须是唯一的，数据符合特定的模式，或者外键必须引用存在的实体。可能导致不一致状态的事务通常会导致事务失败，尽管一些小问题可能会自动解决；例如，将数据强制转换为正确的形状。这不要与CAP定理中的*一致性*（C）混淆，它指的是保证分布式存储中所有读者看到的数据视图的一致性。
- en: '8.5.3\. Isolation: concurrent transactions don’t interfere'
  id: totrans-1573
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.3\. 隔离：并发事务不干扰
- en: 'Isolated transactions should produce the same result, whether the same transactions
    are executed concurrently or sequentially. The level of isolation a system provides
    directly affects its ability to perform concurrent operations. A naïve isolation
    scheme is the use of a *global lock*, whereby the entire database is locked for
    the duration of a transaction, thus effectively processing all transactions in
    series. This gives a strong isolation guarantee but it’s also pathologically inefficient:
    transactions operating on entirely disjointed datasets are needlessly blocked
    (for example, a user adding a comment ideally doesn’t block another user updating
    their profile). In practice, systems provide various levels of isolation using
    more fine-grained and selective locking schemes (for example, by table, row, or
    field). More-sophisticated systems may even optimistically attempt all transactions
    concurrently with minimal locking, only to retry transactions by using increasingly
    coarse-grained locks in cases where conflicts are detected.'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离事务应该产生相同的结果，无论是并发执行还是顺序执行相同的交易。系统提供的隔离级别直接影响到其执行并发操作的能力。一个简单的隔离方案是使用*全局锁*，在整个事务期间锁定整个数据库，从而有效地按顺序处理所有事务。这提供了强大的隔离保证，但同时也非常低效：操作完全不同数据集的事务会被无谓地阻塞（例如，一个用户添加评论理想情况下不应该阻止另一个用户更新他们的个人资料）。在实践中，系统通过使用更细粒度和选择性的锁定方案（例如，按表、行或字段）提供各种隔离级别。更复杂的系统甚至可能会乐观地尝试以最小锁定并发执行所有事务，只有在检测到冲突的情况下才会通过使用越来越粗粒度的锁来重试事务。
- en: '8.5.4\. Durability: transactions are permanent'
  id: totrans-1575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.4\. 持久性：事务是永久的
- en: The *durability* of a transaction is the degree to which its effects are guaranteed
    to persist, even after restarts, power failures, system errors, or even hardware
    failures. For example, an application using the SQLite in-memory mode has no transaction
    durability; all data is lost when the process exits. On the other hand, SQLite
    persisting to disk will have good transaction durability, because data persists
    even after the machine is restarted.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的*持久性*是指其效果在重启、电源故障、系统错误甚至硬件故障后仍保证持续的程度。例如，使用SQLite内存模式的应用程序没有事务持久性；当进程退出时，所有数据都会丢失。另一方面，SQLite将数据持久化到磁盘将具有良好的事务持久性，因为数据在机器重启后仍然持续存在。
- en: 'This may seem like a no-brainer: just write the data to disk—and voila, you
    have durable transactions. But disk I/O is one of the slowest operations your
    application can perform and can quickly become a significant bottleneck in your
    application, even at moderate levels of scale. Some databases offer different
    durability trade-offs that can be employed to maintain acceptable system performance.'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是个显而易见的事情：只需将数据写入磁盘——然后，你就有持久的交易了。但磁盘I/O是应用程序可以执行的最慢的操作之一，并且可能会迅速成为应用程序中的瓶颈，即使在中等规模下也是如此。一些数据库提供了不同的持久性权衡，可以用来维持可接受的系统性能。
- en: 8.6\. NoSQL
  id: totrans-1578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6\. NoSQL
- en: The umbrella term for data stores that don’t fit in the relational model is
    *NoSQL*. Today, because some NoSQL databases do speak SQL, the term NoSQL has
    a meaning closer to *nonrelational* or as the backronym *not only SQL*.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 不适合关系模型的数据库的统称是*NoSQL*。今天，由于一些NoSQL数据库确实支持SQL，因此NoSQL这个术语的含义更接近于*非关系型*或作为缩写词*不仅SQL*。
- en: 'Here’s a subset of paradigms and example databases that can be considered NoSQL:'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以被认为是NoSQL的范式和示例数据库的子集：
- en: '***Key-value/tuple—*** DynamoDB, LevelDB, Redis, etcd, Riak, Aerospike, Berkeley
    DB'
  id: totrans-1581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***键值/元组—*** DynamoDB, LevelDB, Redis, etcd, Riak, Aerospike, Berkeley DB'
- en: '***Graph—*** Neo4J, OrientDB'
  id: totrans-1582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***图—*** Neo4J, OrientDB'
- en: '***Document—*** CouchDB, MongoDB, Elastic (formerly Elasticsearch)'
  id: totrans-1583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***文档—*** CouchDB, MongoDB, Elastic（前身为Elasticsearch）'
- en: '***Column—*** Cassandra, HBase'
  id: totrans-1584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***列—*** Cassandra, HBase'
- en: '***Time series—*** Graphite, InfluxDB, RRDtool'
  id: totrans-1585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***时间序列—*** Graphite, InfluxDB, RRDtool'
- en: '***Multiparadigm—*** Couchbase (document database, key/value store, distributed
    cache)'
  id: totrans-1586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***多范式—*** Couchbase（文档数据库，键/值存储，分布式缓存）'
- en: For a more comprehensive list of NoSQL databases, see [http://nosql-database.org/](http://nosql-database.org/).
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 对于NoSQL数据库的更完整列表，请参阅[http://nosql-database.org/](http://nosql-database.org/)。
- en: 'NoSQL concepts can be difficult to digest if you’ve worked only with relational
    databases, because NoSQL usage often goes directly against well-established best
    practices: No defined schemas. Duplicate data. Loosely enforced constraints. NoSQL
    systems take responsibilities normally assigned to the database and place them
    in the realm of the application. It can all seem dirty.'
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只使用过关系型数据库，那么理解NoSQL概念可能会有些困难，因为NoSQL的使用往往直接违反了已经确立的最佳实践：没有定义的架构。数据重复。约束宽松。NoSQL系统承担了通常由数据库承担的责任，并将其置于应用领域。这一切可能看起来有些混乱。
- en: Usually, only a small set of access patterns create the bulk of the workload
    for the database, such as the queries that generate the landing screen of your
    application, where multiple domain objects need to be fetched. A common technique
    for improving read performance in a relational database is denormalization, whereby
    domain queries are preprocessed and shaped into a form that reduces the number
    of reads required for consumption by the client.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，只有一小部分访问模式会为数据库创建大部分工作负载，例如生成应用程序着陆页的查询，其中需要检索多个领域对象。提高关系型数据库读取性能的常见技术是反规范化，其中领域查询被预处理并塑造成减少客户端消费所需读取次数的形式。
- en: NoSQL data is more frequently denormalized by default. The domain modeling step
    may be entirely skipped. This can discourage overengineering of the data model,
    allow changes to be executed more quickly, and lead to an overall simpler, better-performing
    design.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，NoSQL数据更频繁地使用反规范化。领域建模步骤可能完全被跳过。这可以阻止对数据模型进行过度设计，允许更快地执行更改，并导致整体上更简单、性能更好的设计。
- en: 8.7\. Distributed databases
  id: totrans-1591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.7\. 分布式数据库
- en: An application can scale vertically by increasing the capacity of the machines
    running it, or horizontally by adding more machines. Vertical scaling is usually
    the less complicated option, but constraints borne by the hardware limit how far
    one machine can scale. Vertical scaling also tends to get expensive quickly. Horizontal
    scaling, on the other hand, has a far higher capacity for growth as you add capacity
    by adding more processes and more machines. This comes at the cost of complexity
    in orchestrating many more moving parts. All growing systems eventually reach
    a point where they must scale horizontally.
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过增加运行它的机器的容量来垂直扩展，或者通过添加更多机器来水平扩展。垂直扩展通常是更简单的选项，但硬件的限制决定了单台机器可以扩展的范围。垂直扩展也往往会迅速变得昂贵。另一方面，水平扩展通过添加更多进程和机器来增加容量，具有更高的增长能力。这以在编排更多移动部件中的复杂性为代价。所有增长系统最终都会达到一个必须水平扩展的点。
- en: Distributed databases are designed from the outset with horizontal scaling as
    the premise. Data stored across multiple machines improves the durability of the
    data by removing any single point of failure. Many relational systems have some
    capacity to perform horizontal scaling in the form of sharding, master/slave,
    master/master replication, though even with these capacities, relational systems
    aren’t designed to scale beyond a few hundred nodes. For example, the upper limit
    for a MySQL cluster is 255 nodes. Distributed databases, on the other hand, can
    scale into the thousands of nodes by design.
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式数据库从一开始就被设计为以横向扩展为基础。跨多台机器存储的数据通过消除任何单点故障来提高数据的持久性。许多关系型系统都有一些执行横向扩展的能力，形式为分片、主/从、主/主复制，尽管即使有这些能力，关系型系统也不是为了扩展到几百个节点以上而设计的。例如，MySQL集群的上限是255个节点。另一方面，分布式数据库通过设计可以扩展到数千个节点。
- en: 8.8\. MongoDB
  id: totrans-1594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.8\. MongoDB
- en: '*MongoDB* is a document-oriented, distributed database that’s hugely popular
    among Node developers. It’s the *M* in the fashionable MEAN stack (MongoDB, Express,
    Angular, Node) and is often one of the first databases people encounter when they
    start working with Node. [Figure 8.2](#ch08fig02) shows how popular the mongodb
    module is on npm.'
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: '*MongoDB* 是一种面向文档的、分布式数据库，在Node开发者中非常受欢迎。它是时尚的MEAN堆栈（MongoDB, Express, Angular,
    Node）中的 *M*，并且通常是人们开始使用Node时遇到的第一个数据库。[图8.2](#ch08fig02)显示了mongodb模块在npm上的流行程度。'
- en: Figure 8.2\. MongoDB’s usage statistics
  id: totrans-1596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. MongoDB的使用统计
- en: '![](Images/08fig02.jpg)'
  id: totrans-1597
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig02.jpg)'
- en: MongoDB attracts more than its fair share of criticism and controversy; despite
    this, it remains a staple data store for many developers. MongoDB has known deployments
    in prominent companies including Adobe, LinkedIn, and eBay and is even used in
    a component of the Large Hadron Collider at the European Organization for Nuclear
    Research (CERN).
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB吸引了比其应得的更多批评和争议；尽管如此，它仍然是许多开发者的主要数据存储。MongoDB在包括Adobe、LinkedIn和eBay在内的知名公司中有已知部署，甚至在欧洲核子研究组织（CERN）的大型强子对撞机的一个组件中也被使用。
- en: A MongoDB database stores documents in schemaless *collections*. Documents don’t
    need to have a predefined schema, and documents in a single collection needn’t
    share the same schema. This grants a lot of flexibility to MongoDB, though the
    burden is now upon the application to ensure that documents maintain a predictable
    structure (guaranteeing consistency—the *C* in ACID).
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB数据库以无模式的 *集合* 存储文档。文档不需要有预定义的模式，单个集合中的文档也不需要共享相同的模式。这赋予了MongoDB很大的灵活性，尽管现在应用程序需要确保文档保持可预测的结构（保证一致性——ACID中的
    *C*）。
- en: 8.8.1\. Performing installation and setup
  id: totrans-1600
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.8.1\. 执行安装和设置
- en: 'MongoDB needs to be installed on your system. Installation varies between platforms.
    On macOS, installation is as simple as this:'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB需要安装到您的系统上。安装方式因平台而异。在macOS上，安装过程就像这样：
- en: '[PRE205]'
  id: totrans-1602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'The MongoDB server is started by using the `mongod` executable:'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mongod`可执行文件启动MongoDB服务器：
- en: '[PRE206]'
  id: totrans-1604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The most popular MongoDB driver is the official mongodb package by Christian
    Amor Kvalheim:'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的MongoDB驱动程序是Christian Amor Kvalheim的官方mongodb包：
- en: '[PRE207]'
  id: totrans-1606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Windows users should note that driver installation requires msbuild.exe, which
    is installed by Microsoft Visual Studio.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户应注意的是，驱动程序安装需要msbuild.exe，该文件由Microsoft Visual Studio安装。
- en: 8.8.2\. Connecting to MongoDB
  id: totrans-1608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.8.2\. 连接到MongoDB
- en: After installing the mongodb package and starting the mongod server, you can
    connect as a client from Node, as shown in the following listing.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装mongodb包并启动mongod服务器后，您可以从Node作为客户端连接，如下所示。
- en: Listing 8.8\. Connecting to MongoDB
  id: totrans-1610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.8\. 连接到MongoDB
- en: '[PRE208]'
  id: totrans-1611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The connection’s success handler is passed a database client instance, from
    which all database commands are executed.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的成功处理程序会传递一个数据库客户端实例，所有数据库命令都从这个实例执行。
- en: 'Most interactions with the database are via the collection API:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库的大多数交互都是通过集合API进行的：
- en: '`collection.insert(doc)`—Insert one or more documents'
  id: totrans-1614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.insert(doc)`—插入一个或多个文档'
- en: '`collection.find(query)`—Find documents matching the query'
  id: totrans-1615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.find(query)`—查找匹配查询的文档'
- en: '`collection.remove(query)`—Remove documents matching the query'
  id: totrans-1616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.remove(query)`—删除匹配查询的文档'
- en: '`collection.drop()`—Remove the entire collection'
  id: totrans-1617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.drop()`—删除整个集合'
- en: '`collection.update(query)`—Update documents matching the query'
  id: totrans-1618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.update(query)`—更新匹配查询的文档'
- en: '`collection.count(query)`—Count documents matching the query'
  id: totrans-1619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.count(query)`—计算匹配查询的文档数量'
- en: 'Operations such as `find`, `insert`, and `delete` come in a few flavors, depending
    on whether you’re operating on one or many values. For example:'
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`, `insert`, 和 `delete` 等操作根据操作的是单个还是多个值，有多种形式。例如：'
- en: '`collection`.insertOne`(doc)`—Insert a single document'
  id: totrans-1621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.insertOne`(doc)`—插入单个文档'
- en: '`collection`.insertMany([doc1, doc2])—Insert many documents'
  id: totrans-1622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.insertMany([doc1, doc2])`—插入多个文档'
- en: '`collection`.findOne`(query)`—Find a single document matching the query'
  id: totrans-1623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.findOne`(query)`—查找匹配查询的单个文档'
- en: '`collection`.updateMany(query)—Update all documents matching the query'
  id: totrans-1624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection.updateMany(query)`—更新所有匹配查询的文档'
- en: 8.8.3\. Inserting documents
  id: totrans-1625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.8.3\. 插入文档
- en: '`collection.insertOne` places a single object into the collection as a document,
    as shown in the next listing. The success handler is passed an object containing
    metadata about the state of the operation.'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: '`collection.insertOne` 将单个对象作为一个文档插入到集合中，如下一列表所示。成功处理程序传递一个包含操作状态元数据的对象。'
- en: Listing 8.9\. Inserting a document
  id: totrans-1627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. 插入文档
- en: '![](Images/08lis09_alt.jpg)'
  id: totrans-1628
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08lis09_alt.jpg)'
- en: The `insertMany` call is similar, except it takes an array of multiple documents.
    The `insertMany` response will contain an array of `insertedIds,` in the order
    the documents were supplied, instead of a singular `insertedId.`
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertMany` 调用类似，但它接受多个文档的数组。`insertMany` 响应将包含一个 `insertedIds` 数组，按文档提供的顺序排列，而不是单个
    `insertedId`。'
- en: 8.8.4\. Querying
  id: totrans-1630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.8.4\. 查询
- en: 'Methods that read documents from the collection (such as `find`, `update`,
    and `remove`) take a query argument that’s used to match documents. The simplest
    form of a query is an object with which MongoDB will match documents with the
    same structure and same values. For example, this finds all articles with the
    title “I like cake”:'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合中读取文档的方法（如 `find`, `update`, 和 `remove`）接受一个查询参数，用于匹配文档。查询的最简单形式是一个对象，MongoDB
    将使用该对象匹配具有相同结构和相同值的文档。例如，以下查询找到所有标题为“我喜欢蛋糕”的文章：
- en: '![](Images/p0196_01.jpg)'
  id: totrans-1632
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0196_01.jpg)'
- en: 'Queries can be used to match objects by their unique `_id`:'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 查询可以用来通过其唯一 `_id` 匹配对象：
- en: '[PRE209]'
  id: totrans-1634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'Or match based on a *query operator*:'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 或者根据*查询运算符*进行匹配：
- en: '![](Images/p0196_02.jpg)'
  id: totrans-1636
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0196_02.jpg)'
- en: 'Many *query operators* exist in the MongoDB query language—for example:'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 查询语言中存在许多*查询运算符*——例如：
- en: '`$eq`—Equal to a particular value'
  id: totrans-1638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$eq`—等于特定值'
- en: '`$neq`—Not equal to a particular value'
  id: totrans-1639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$neq`—不等于特定值'
- en: '`$in`—In array'
  id: totrans-1640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$in`—在数组中'
- en: '`$nin`—Not in array'
  id: totrans-1641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$nin`—不在数组中'
- en: '`$lt`, `$lte`, `$gt`, `$gte`—Greater/less than or equal to comparison'
  id: totrans-1642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$lt`, `$lte`, `$gt`, `$gte`—大于/小于或等于比较'
- en: '`$near`—Geospatial value is near a certain coordinate'
  id: totrans-1643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$near`—地理值接近某个坐标'
- en: '`$not`, `$and`, `$or`, `$nor`—Logical operators'
  id: totrans-1644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$not`, `$and`, `$or`, `$nor`—逻辑运算符'
- en: These can be combined to match almost any condition and create a highly readable,
    sophisticated, and expressive query language. See [https://docs.mongodb.com/-manual/reference/operator/query/](https://docs.mongodb.com/-manual/reference/operator/query/)
    for more information on queries and query operators.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以组合起来匹配几乎任何条件，并创建一个高度可读、复杂和表达性的查询语言。有关查询和查询操作器的更多信息，请参阅[https://docs.mongodb.com/-manual/reference/operator/query/](https://docs.mongodb.com/-manual/reference/operator/query/)。
- en: The next listing shows an example that the previous Articles API implemented
    by using MongoDB, while maintaining a nearly identical external interface. Save
    this file as db.js (it’s listing8_10/db.js in the book’s sample code).
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 下一列表展示了之前通过 MongoDB 实现的 Articles API 的示例，同时保持了几乎相同的外部接口。将此文件保存为 db.js（在本书的示例代码中为
    listing8_10/db.js）。
- en: Listing 8.10\. Implementing the Article API with MongoDB
  id: totrans-1647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. 使用 MongoDB 实现文章 API
- en: '![](Images/ch08ex10-0.jpg)'
  id: totrans-1648
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch08ex10-0.jpg)'
- en: '![](Images/ch08ex10-1.jpg)'
  id: totrans-1649
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch08ex10-1.jpg)'
- en: 'The following snippet shows how to use [listing 8.10](#ch08ex10) (listing 8_10/index.js
    in the sample code):'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用[列表 8.10](#ch08ex10)（示例代码中的 listing8_10/index.js）：
- en: '[PRE210]'
  id: totrans-1651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: This uses a promise from [listing 8.10](#ch08ex10) to connect to the database,
    then creates an article using `Article`’s `create` method. After that, it loads
    all articles and logs them out.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用来自[列表 8.10](#ch08ex10) 的一个承诺连接到数据库，然后使用 `Article` 的 `create` 方法创建一个文章。之后，它加载所有文章并将它们记录下来。
- en: 8.8.5\. Using MongoDB identifiers
  id: totrans-1653
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.8.5\. 使用 MongoDB 标识符
- en: Identifiers from MongoDB are encoded in *Binary JSON* (BSON) format. The `_id`
    property on a document is a JavaScript Object that wraps a BSON-formatted `ObjectID`
    value. MongoDB uses BSON to represent documents internally and as a transmission
    format. BSON is more space-efficient than JSON and can be parsed more quickly,
    which means faster database interactions using less bandwidth.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB中的标识符以*二进制JSON*（BSON）格式编码。文档上的`_id`属性是一个JavaScript对象，它包装了一个BSON格式的`ObjectID`值。MongoDB使用BSON来表示内部文档和作为传输格式。BSON比JSON更节省空间，并且可以更快地解析，这意味着使用更少的带宽进行更快的数据库交互。
- en: 'A BSON `ObjectID` isn’t just a random sequence of bytes; it encodes metadata
    about where and when the ID was generated. For example, the first four bytes of
    an `ObjectID` are a timestamp. This removes the need to have to store a `createdAt`
    timestamp property in your documents:'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: BSON `ObjectID`不仅仅是一个随机的字节序列；它编码了关于ID在哪里以及何时生成的元数据。例如，`ObjectID`的前四个字节是一个时间戳。这消除了在文档中存储`createdAt`时间戳属性的需求：
- en: '![](Images/p0198_01_alt.jpg)'
  id: totrans-1656
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0198_01_alt.jpg)'
- en: See [https://docs.mongodb.com/manual/reference/method/ObjectId/](https://docs.mongodb.com/manual/reference/method/ObjectId/)
    for more information about the `ObjectID` format.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ObjectID`格式的更多信息，请参阅[https://docs.mongodb.com/manual/reference/method/ObjectId/](https://docs.mongodb.com/manual/reference/method/ObjectId/)。
- en: '`ObjectIDs` may superficially appear to be strings because of the way they’re
    printed in the terminal, but they’re objects. `ObjectIDs` suffer from classic
    object comparison gotchas: seemingly totally equivalent values are reported as
    inequivalent because they reference different objects.'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectIDs`可能看起来像是字符串，因为它们在终端中的打印方式，但它们是对象。`ObjectIDs`受到经典对象比较陷阱的影响：看似完全等效的值报告为不等效，因为它们引用了不同的对象。'
- en: 'In the following snippet, we extract the same value twice. Using the node’s
    built-in assert module, we try to assert that the objects or the IDs are equivalent,
    but both result in failure:'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们两次提取了相同的值。使用节点的内置assert模块，我们尝试断言对象或ID是等效的，但两者都失败了：
- en: '[PRE211]'
  id: totrans-1660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'These assertions produce error messages that at first seem confusing, as the
    actual values appear to match the expected values:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断言产生的错误消息最初看起来很令人困惑，因为实际值似乎与预期值匹配：
- en: '[PRE212]'
  id: totrans-1662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Equivalence can be detected correctly by using the `ObjectID`’s `equal` method
    that’s available on every `_id`. Alternatively, you can coerce the identifiers
    and compare them as strings, or use a `deepEquals` method such as that found on
    Node’s built-in assert module:'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用每个`_id`上可用的`ObjectID`的`equal`方法正确检测等效性，或者你可以强制转换标识符并将它们作为字符串比较，或者使用Node内置assert模块上的`deepEquals`方法：
- en: '![](Images/p0198_02_alt.jpg)'
  id: totrans-1664
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0198_02_alt.jpg)'
- en: 'Identifiers passed to the Node mongodb driver must be a BSON-formatted `ObjectID`.
    A string can be converted into an `ObjectID` by using the `ObjectID` constructor:'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给Node mongodb驱动程序的标识符必须是BSON格式的`ObjectID`。可以使用`ObjectID`构造函数将字符串转换为`ObjectID`：
- en: '[PRE213]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Where possible, the BSON form should be maintained; the cost of marshalling
    to and from strings works against the potential performance gains MongoDB hopes
    to achieve by serving client identifiers as BSON. See [http://bsonspec.org/](http://bsonspec.org/)
    for detailed information about the BSON format.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，应保持BSON形式；将字符串序列化和反序列化的成本与MongoDB通过将客户端标识符作为BSON提供所希望实现的性能提升相抵消。有关BSON格式的详细信息，请参阅[http://bsonspec.org/](http://bsonspec.org/)。
- en: 8.8.6\. Using replica sets
  id: totrans-1668
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.8.6\. 使用副本集
- en: The distributed features of MongoDB are mostly beyond the scope of this book,
    but in this section we quickly cover the basics of replica sets. Many `mongod`
    processes can be run as nodes/members of a replica set. A *replica set* consists
    of a single primary node and numerous secondary nodes. Each member of a replica
    set needs to be allocated a unique port and directory to store its data. Instances
    can’t share ports or directories, and the directories must already exist before
    startup.
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的分布式功能大多超出了本书的范围，但在这个部分中，我们快速介绍了副本集的基本知识。许多`mongod`进程可以作为副本集的节点/成员运行。一个*副本集*由一个主节点和多个次节点组成。副本集的每个成员都需要分配一个唯一的端口和目录来存储其数据。实例不能共享端口或目录，并且目录必须在启动之前存在。
- en: In the following listing, you create a unique directory for each member and
    start them on a sequential port number starting from 27017\. You may want to run
    each of the `mongod` commands in a new terminal tab without backgrounding them
    (without the trailing `&`).
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，您为每个成员创建一个唯一的目录，并从 27017 开始按顺序端口启动它们。您可能希望在新的终端标签中运行每个 `mongod` 命令，而不将其放入后台（不带尾随的
    `&`）。
- en: Listing 8.11\. Starting a replica set
  id: totrans-1671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. 启动副本集
- en: '![](Images/08lis11_alt.jpg)'
  id: totrans-1672
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08lis11_alt.jpg)'
- en: After the replica set is running, MongoDB needs to perform some initiation.
    You need to connect to the port of the instance that you want to become the first
    *primary* node (27017 by default) and call `rs.initiate()`, as shown in the following
    listing. Then you need to add each instance as a member of the replica set. Note
    that you need to supply the hostname of the machine you’re connecting to.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 副本集运行后，MongoDB 需要执行一些初始化操作。您需要连接到您希望成为第一个 *主节点* 的实例的端口（默认为 27017），并调用 `rs.initiate()`，如下所示。然后您需要将每个实例添加为副本集的成员。请注意，您需要提供您连接到的机器的主机名。
- en: Listing 8.12\. Initiating a replica set
  id: totrans-1674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. 初始化副本集
- en: '![](Images/08lis12_alt.jpg)'
  id: totrans-1675
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08lis12_alt.jpg)'
- en: MongoDB clients need to know about all the possible replica set members when
    they connect, though not all members need to currently be online. After connecting,
    you may use the MongoDB client as usual. [Listing 8.13](#ch08ex13) shows how to
    create a replica set with three members.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 当 MongoDB 客户端连接时，需要了解所有可能的副本集成员，尽管并非所有成员都需要当前在线。连接后，您可以像往常一样使用 MongoDB 客户端。[列表
    8.13](#ch08ex13) 展示了如何创建包含三个成员的副本集。
- en: Listing 8.13\. Connecting to a replica set
  id: totrans-1677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. 连接到副本集
- en: '![](Images/08lis13_alt.jpg)'
  id: totrans-1678
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08lis13_alt.jpg)'
- en: If any of the mongod nodes crash, the system will continue working, as long
    as at least two instances are running. If the primary node crashes, a secondary
    node will automatically be elected to be promoted into the primary.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何 mongod 节点崩溃，只要至少有两个实例正在运行，系统将继续工作。如果主节点崩溃，将自动选举一个次要节点提升为主节点。
- en: 8.8.7\. Understanding write concerns
  id: totrans-1680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.8.7\. 理解写关注点
- en: MongoDB gives the developer fine-grained control over which performance and
    safety trade-offs are acceptable for various areas of your application. It’s important
    to understand the concepts of both write and read concerns in order to use MongoDB
    without surprises, especially as the number of nodes in your replica set increases.
    In this section, we touch only on write concerns, as they’re the most important.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 允许开发者对应用程序各个区域可接受的性能和安全权衡进行细粒度控制。为了在不出现意外的情况下使用 MongoDB，特别是当副本集节点数量增加时，理解读写关注点的概念非常重要。在本节中，我们仅涉及写关注点，因为它们是最重要的。
- en: '*Write concerns* dictate the number of mongod instances that the data needs
    to be successfully written to before the overall operation responds with a success.
    If not explicitly specified, the default write concern is 1, which ensures that
    the data has been written to at least one node. It may not provide an adequate
    level of assurance for critical data; data may be lost if the node goes down before
    replicating to other nodes.'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: '*写关注点* 指定了在整体操作响应成功之前，数据需要成功写入多少个 mongod 实例。如果没有明确指定，默认写关注点是 1，这确保了数据至少已写入一个节点。它可能无法为关键数据提供足够的保证；如果节点在复制到其他节点之前崩溃，数据可能会丢失。'
- en: 'It’s possible and often desirable to set a zero write concern, whereby the
    application doesn’t wait for any response:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 设置零写关注点是可能的，并且通常是期望的，这样应用程序就不需要等待任何响应：
- en: '[PRE214]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: A zero write concern grants the highest performance but provides the least durability
    assurances, and is typically used for only temporary or unimportant data (such
    as the writing of logs or caches).
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 零写关注点提供了最高的性能，但提供的持久性保证最少，通常仅用于临时或不重要的数据（例如日志或缓存的写入）。
- en: 'If you’re connected to a replica set, you can indicate a write concern greater
    than 1\. Replicating to more nodes decreases the likelihood of data loss, at the
    expense of more latency when performing operations:'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您连接到副本集，您可以指定大于 1 的写关注点。将数据复制到更多节点可以降低数据丢失的可能性，但会以执行操作时增加延迟为代价：
- en: '[PRE215]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'You may want to scale the write concern as the number of nodes in the cluster
    changes. This can be done dynamically by MongoDB itself if you set the write concern
    to `majority`. This ensures that data is written to more than 50% of the available
    nodes:'
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望根据集群中节点数量的变化来扩展写入关注级别。如果将写入关注级别设置为“majority”，MongoDB本身可以动态地完成此操作。这确保数据被写入超过50%的可用节点：
- en: '[PRE216]'
  id: totrans-1689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: The default write concern of 1 may not provide an adequate level of assurance
    for critical data. Data may be lost if the node goes down before replicating to
    other nodes.
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的写入关注级别为1可能无法为关键数据提供足够的保证。如果节点在复制到其他节点之前崩溃，数据可能会丢失。
- en: Setting a write concern higher than 1 ensures that the data exists across multiple
    mongod instances before continuing. Running multiple instances on the same machine
    adds protection but doesn’t help in the case of systemwide failures such as running
    out of disk space or RAM. You can protect against machine failure by running instances
    across multiple machines and ensuring that writes propagate to these nodes, but
    this again will be slower and doesn’t protect against datacenter-wide failure.
    Running nodes across different datacenters protects against datacenter outage,
    but ensuring that data is replicated across datacenters will greatly impact performance.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 将写入关注级别设置为大于1确保在继续之前数据存在于多个mongod实例中。在同一台机器上运行多个实例可以提供保护，但无法帮助解决系统级故障，如磁盘空间或RAM耗尽。您可以通过在多台机器上运行实例并确保写入传播到这些节点来防止机器故障，但这又会使速度变慢，并且无法防止数据中心级故障。在不同数据中心运行节点可以防止数据中心中断，但确保数据在数据中心之间复制将大大影响性能。
- en: As always, the more assurances you add, the slower and more complicated the
    system becomes. This isn’t an issue specific to MongoDB; it’s an issue with any
    and all data storage. No perfect solution exists, and you’ll need to decide the
    acceptable level of risk for the various parts of your application.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，你添加的保证越多，系统就会变得越慢、越复杂。这不仅仅是一个特定于MongoDB的问题；它涉及到任何和所有数据存储的问题。没有完美的解决方案，你需要为应用程序的各个部分决定可接受的危险水平。
- en: 'For more information about how MongoDB replication works, see the following
    resources:'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MongoDB复制工作方式的更多信息，请参阅以下资源：
- en: '[https://docs.mongodb.com/manual/faq/replica-sets/](https://docs.mongodb.com/manual/faq/replica-sets/)'
  id: totrans-1694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/faq/replica-sets/](https://docs.mongodb.com/manual/faq/replica-sets/)'
- en: '[https://docs.mongodb.com/manual/faq/concurrency/](https://docs.mongodb.com/manual/faq/concurrency/)'
  id: totrans-1695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.mongodb.com/manual/faq/concurrency/](https://docs.mongodb.com/manual/faq/concurrency/)'
- en: 8.9\. Key/value stores
  id: totrans-1696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.9. 键值存储
- en: 'Each record in a key/value store comprises a single key and a single value.
    In many key/value systems, values can be of any data type, of any length or structure.
    From the perspective of the database, values are opaque atoms: the database doesn’t
    know or care about the type of the data and can’t be subdivided or accessed other
    than in its entirety. Contrast this with value storage in a relational database:
    data is stored in a series of tables, which contain rows of data separated into
    predefined columns. In a key/value store, the responsibility of managing the format
    of the data is handed to the application.'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储中的每条记录由一个键和一个值组成。在许多键值系统中，值可以是任何数据类型，任何长度或结构。从数据库的角度来看，值是不透明的原子：数据库不知道也不关心数据的类型，并且不能被细分或访问，除非作为整体。这与关系型数据库中的值存储形成对比：数据存储在一系列表中，这些表包含数据行，这些行被分隔到预定义的列中。在键值存储中，管理数据格式的责任交给了应用程序。
- en: Key/value stores can often be found in performance-critical paths of an application.
    Ideally, values are laid out in a manner such that the absolute minimum number
    of reads is required to fulfill a task. Key/value stores come with simpler querying
    capabilities than other database types. Ideally, complex queries are precalculated;
    otherwise, they need to be performed within the application rather than the database.
    This constraint can lead to easily understood and predictable performance characteristics.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 键值存储通常可以在应用程序的性能关键路径中找到。理想情况下，值以这种方式排列，即完成任务所需的读取次数绝对最少。与其它数据库类型相比，键值存储具有更简单的查询能力。理想情况下，复杂查询是预先计算的；否则，它们需要在应用程序内部而不是数据库中执行。这种限制可能导致易于理解和预测的性能特征。
- en: The most popular key/value stores, such as Redis and Memcached, are often used
    for volatile storage (if the process exits, the data is lost). Avoiding writing
    to disk is one of the best ways to improve performance. This can be an acceptable
    trade-off for features when data can be regenerated or loss is of little concern;
    for example, caches and user sessions.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的键/值存储，如 Redis 和 Memcached，通常用于易失性存储（如果进程退出，数据将丢失）。避免写入磁盘是提高性能的最佳方法之一。当数据可以重新生成或损失无关紧要时，这可以是一个可接受的权衡；例如，缓存和用户会话。
- en: Key/value stores may carry a stigma that they can’t be used for primary storage,
    but this isn’t always true. Many key/value stores provide just as much durability
    as a “real” database.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 键/值存储可能存在一种偏见，即它们不能用于主存储，但这并不总是正确的。许多键/值存储提供的持久性“与真实”数据库相当。
- en: 8.10\. Redis
  id: totrans-1701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.10\. Redis
- en: '*Redis* is a popular in-memory, data-structure store. Although many consider
    Redis to be a key/value store, keys and values represent only a subset of the
    features Redis supports across a variety of useful, basic data structures. [Figure
    8.3](#ch08fig03) shows the usage statistics for the redis package on npm.'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: '*Redis* 是一个流行的内存数据结构存储。尽管许多人认为 Redis 是一个键/值存储，但键和值仅代表 Redis 在各种有用、基本数据结构中支持的功能的一个子集。[图
    8.3](#ch08fig03) 显示了 npm 上 redis 包的使用统计。'
- en: Figure 8.3\. The redis package’s statistics on npm
  id: totrans-1703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3\. npm 上 redis 包的统计信息
- en: '![](Images/08fig03.jpg)'
  id: totrans-1704
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig03.jpg)'
- en: 'The data structures built into Redis include the following:'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 内置在 Redis 中的数据结构包括以下内容：
- en: Strings
  id: totrans-1706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Hashes
  id: totrans-1707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: List
  id: totrans-1708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Set
  id: totrans-1709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Sorted set
  id: totrans-1710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序集合
- en: 'Redis also comes with many other useful features out of the box:'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 还自带了许多其他有用的功能：
- en: '***Bitmap data—*** Direct bit manipulation in values.'
  id: totrans-1712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***位图数据—*** 在值中进行直接位操作。'
- en: '***Geospatial indexes—*** Storing geospatial data with radius queries.'
  id: totrans-1713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***地理空间索引—*** 使用半径查询存储地理空间数据。'
- en: '***Channels—*** A publish/subscribe data-delivery mechanism.'
  id: totrans-1714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***通道—*** 一种发布/订阅数据交付机制。'
- en: '***TTLs—*** Values can be configured with an expiry time, after which they’re
    automatically removed.'
  id: totrans-1715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***TTLs—*** 可以配置过期时间，在此之后它们将自动删除。'
- en: '***LRU eviction—*** Optionally removes values that haven’t been recently used
    in order to maintain maximum memory usage.'
  id: totrans-1716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***LRU 过期—*** 可选地移除最近未使用过的值，以保持最大内存使用。'
- en: '***HyperLogLog—*** High-performing approximation of set cardinality, while
    maintaining a low-memory footprint (doesn’t need to store every member).'
  id: totrans-1717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***HyperLogLog—*** 高性能的集合基数近似，同时保持低内存占用（不需要存储每个成员）。'
- en: '***Replication, clustering, and partitioning—*** Horizontal scaling and data
    durability.'
  id: totrans-1718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***复制、集群和分区—*** 水平扩展和数据持久性。'
- en: '***Lua scripting—*** Extend Redis with custom commands.'
  id: totrans-1719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Lua 脚本—*** 通过自定义命令扩展 Redis。'
- en: In this section, you’ll find several bulleted lists of Redis commands. They’re
    not intended to be a reference, but rather to give some insight into what’s possible
    with Redis. It’s an incredibly powerful and versatile tool. See [http://redis.io/commands](http://redis.io/commands)
    for more details.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你会找到几个 Redis 命令的列表。它们不是参考，而是为了让你了解 Redis 的可能性。这是一个功能强大且多才多艺的工具。有关更多详细信息，请参阅
    [http://redis.io/commands](http://redis.io/commands)。
- en: 8.10.1\. Performing installation and setup
  id: totrans-1721
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.1\. 执行安装和设置
- en: 'Redis can be installed through your system’s package management tool. On macOS,
    you can easily install it with Homebrew:'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过系统包管理工具安装 Redis。在 macOS 上，你可以使用 Homebrew 轻松安装它：
- en: '[PRE217]'
  id: totrans-1723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Starting the server is done using the `redis-server` executable:'
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `redis-server` 可执行文件启动服务器：
- en: '[PRE218]'
  id: totrans-1725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: The server listens on port 6379 by default.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器默认监听端口 6379。
- en: 8.10.2\. Performing initialization
  id: totrans-1727
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.2\. 执行初始化
- en: 'A Redis client instance is created with the `createClient` function from the
    redis npm package:'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 客户端实例是通过 redis npm 包的 `createClient` 函数创建的：
- en: '[PRE219]'
  id: totrans-1729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'This function takes the port and a host as arguments. But if you’re running
    the Redis server on the default port on your local machine, you don’t need to
    supply any arguments at all:'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受端口和主机作为参数。但如果你在本地机器上使用 Redis 服务器默认端口，你根本不需要提供任何参数：
- en: '[PRE220]'
  id: totrans-1731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: The Redis client instance is an `EventEmitter`, so you can attach listeners
    for various Redis status events, as shown in the next listing. You can immediately
    start issuing commands to the client, and they’ll be buffered until the connection
    is ready.
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 客户端实例是一个 `EventEmitter`，因此你可以为各种 Redis 状态事件附加监听器，如下一列表所示。你可以立即开始向客户端发送命令，它们将被缓冲，直到连接就绪。
- en: Listing 8.14\. Connecting to Redis and listening for status events
  id: totrans-1733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.14\. 连接到 Redis 并监听状态事件
- en: '[PRE221]'
  id: totrans-1734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: The error handler will fire if a connection or client problem occurs. If an
    `error` event is fired and no error handler is attached, the application process
    will throw the error and crash; this is a feature of all `EventEmitters` in Node.
    If the connection fails and an error handler is supplied, the Redis client will
    attempt to retry the connection.
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生连接或客户端问题，错误处理程序将触发。如果触发 `error` 事件但没有附加错误处理程序，应用程序进程将抛出错误并崩溃；这是 Node 中所有
    `EventEmitters` 的特性。如果连接失败并提供了错误处理程序，Redis 客户端将尝试重试连接。
- en: 8.10.3\. Working with key/value pairs
  id: totrans-1736
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.3\. 操作键/值对
- en: 'Redis can be used as a generic key/value store for strings and arbitrary binary
    data. Reading and writing a key/value pair can be done using the `set` and `get`
    methods, respectively:'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 可以用作字符串和任意二进制数据的通用键/值存储。可以使用 `set` 和 `get` 方法分别读取和写入键/值对：
- en: '[PRE222]'
  id: totrans-1738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: If you `set` an existing key, the value will be overwritten. If you try to `get`
    a key that doesn’t exist, the value will be `null`; it’s not considered an error.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您`set`一个现有的键，值将被覆盖。如果您尝试获取一个不存在的键，值将是`null`；这不被认为是错误。
- en: 'The following commands can be used to retrieve and manipulate values:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令来检索和操作值：
- en: '`append`'
  id: totrans-1741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append`'
- en: '`decr`'
  id: totrans-1742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decr`'
- en: '`decrby`'
  id: totrans-1743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decrby`'
- en: '`get`'
  id: totrans-1744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`'
- en: '`getrange`'
  id: totrans-1745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getrange`'
- en: '`getset`'
  id: totrans-1746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getset`'
- en: '`incr`'
  id: totrans-1747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`incr`'
- en: '`incrby`'
  id: totrans-1748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`incrby`'
- en: '`incrbyfloat`'
  id: totrans-1749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`incrbyfloat`'
- en: '`mget`'
  id: totrans-1750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mget`'
- en: '`mset`'
  id: totrans-1751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mset`'
- en: '`msetnx`'
  id: totrans-1752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msetnx`'
- en: '`psetex`'
  id: totrans-1753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psetex`'
- en: '`set`'
  id: totrans-1754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`'
- en: '`setex`'
  id: totrans-1755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setex`'
- en: '`setnx`'
  id: totrans-1756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setnx`'
- en: '`setrange`'
  id: totrans-1757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setrange`'
- en: '`strlen`'
  id: totrans-1758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strlen`'
- en: 8.10.4\. Working with keys
  id: totrans-1759
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.4\. 操作键
- en: 'You can check whether a key exists by using `exists`. This works with any data
    type:'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `exists` 检查键是否存在。这适用于任何数据类型：
- en: '[PRE223]'
  id: totrans-1761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'Along with `exists`, the following commands can all be used with any key, regardless
    of the type of the value (these commands work with strings, sets, lists, and so
    forth):'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `exists` 之外，以下所有命令都可以与任何键一起使用，无论值的类型如何（这些命令适用于字符串、集合、列表等）：
- en: '`del`'
  id: totrans-1763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`del`'
- en: '`exists`'
  id: totrans-1764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists`'
- en: '`rename`'
  id: totrans-1765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rename`'
- en: '`renamenx`'
  id: totrans-1766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renamenx`'
- en: '`sort`'
  id: totrans-1767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`'
- en: '`scan`'
  id: totrans-1768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan`'
- en: '`type`'
  id: totrans-1769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`'
- en: 8.10.5\. Encoding and data types
  id: totrans-1770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.5\. 编码和数据类型
- en: 'The Redis server stores keys and values as binary objects; it’s not dependent
    on the encoding of the value passed to the client. Any valid JavaScript string
    (UCS2/UTF16) can be used as a valid key or value:'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 服务器将键和值存储为二进制对象；它不依赖于传递给客户端的值的编码。任何有效的 JavaScript 字符串（UCS2/UTF16）都可以用作有效的键或值：
- en: '[PRE224]'
  id: totrans-1772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'By default, keys and values are coerced to strings as they’re written. For
    example, if you `set` a key with a number, it will be a string when you try to
    `get` that same key:'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，键和值在写入时会转换为字符串。例如，如果您使用数字`set`一个键，当您尝试获取相同的键时，它将是一个字符串：
- en: '![](Images/p0205_01_alt.jpg)'
  id: totrans-1774
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0205_01_alt.jpg)'
- en: 'The Redis client silently coerces numbers, Booleans, and dates into strings,
    and it also happily accepts buffer objects. Trying to set any other JavaScript
    type as a value (for example, Object, Array, RegExp) prints a warning that should
    be heeded:'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 客户端将数字、布尔值和日期无声地转换为字符串，并且它也乐意接受缓冲区对象。尝试将任何其他 JavaScript 类型（例如，Object、Array、RegExp）作为值设置，将打印出应予以注意的警告：
- en: '[PRE225]'
  id: totrans-1776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: In the future, this will be an error, so the calling application *must* be responsible
    for ensuring that the correct types are passed to the Redis client.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，这将是一个错误，因此调用应用程序*必须*负责确保向 Redis 客户端传递正确的类型。
- en: 'Gotcha: single vs. multiple value arrays'
  id: totrans-1778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意：单值与多值数组
- en: 'The client produces a cryptic error, “ReplyError: ERR syntax error,” if you
    try to set an array of values:'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您尝试设置一个值数组，客户端将产生一个神秘的错误，“ReplyError: ERR syntax error”。'
- en: '[PRE226]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'But note that no error occurs when the array contains only a single value:'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，当数组中只有一个值时，不会发生错误：
- en: '[PRE227]'
  id: totrans-1782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: This type of bug may show symptoms only when you’re running it in production,
    as it can easily elude detection if the test suite happens to produce only single-valued
    arrays, which is common for stripped-down test data. Be aware!
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的错误可能只有在您在生产环境中运行时才会显示症状，因为它可以轻易地逃避检测，如果测试套件恰好只产生单值数组，这在简化测试数据时很常见。请注意！
- en: Binary data with buffers
  id: totrans-1784
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 带缓冲区的二进制数据
- en: Redis is capable of storing arbitrary byte data, which means you can store any
    type of data in it. The Node client supports this feature with special handling
    for Node’s `Buffer` type. When a buffer is passed to the Redis client as a key
    or value, the bytes are sent unmodified to the Redis server. This avoids accidental
    data corruption and performance penalties of unnecessary marshalling between strings
    and buffers. For example, if you want to write data from disk or network directly
    into Redis, it’s more efficient to write the buffers directly to Redis than to
    convert them into strings first.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 能够存储任意字节数据，这意味着您可以在其中存储任何类型的数据。Node 客户端通过为 Node 的 `Buffer` 类型提供特殊处理来支持此功能。当缓冲区作为键或值传递给
    Redis 客户端时，字节将未修改地发送到 Redis 服务器。这避免了意外数据损坏和字符串与缓冲区之间不必要的 marshalling 之间的性能惩罚。例如，如果您想将磁盘或网络中的数据直接写入
    Redis，直接将缓冲区写入 Redis 比先将其转换为字符串更有效。
- en: '|  |'
  id: totrans-1786
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Buffers**'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓冲区**'
- en: '*Buffers* are what you receive from Node’s core file and network APIs by default.
    They’re a container around contiguous blocks of binary data, and were introduced
    in Node before JavaScript had its own native binary data types (`Uint8Array`,
    `Float32Array`, and so forth). Today, buffers are implemented in Node as a specialized
    subclass of `Uint8Array`. The Buffer API is available globally in Node; you don’t
    need to require anything to use it.'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓冲区* 是您从 Node 的核心文件和网络 API 默认接收的内容。它们是围绕连续的二进制数据块的容器，在 Node 在 JavaScript 还没有自己的原生二进制数据类型（`Uint8Array`、`Float32Array`
    等等）之前就已经被引入。今天，缓冲区在 Node 中作为 `Uint8Array` 的专用子类实现。Buffer API 在 Node 中全局可用；您不需要
    require 任何内容就可以使用它。'
- en: See [https://github.com/nodejs/node/blob/master/lib/buffer.js](https://github.com/nodejs/node/blob/master/lib/buffer.js)
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [https://github.com/nodejs/node/blob/master/lib/buffer.js](https://github.com/nodejs/node/blob/master/lib/buffer.js)
- en: '|  |'
  id: totrans-1790
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Redis has recently added commands for manipulating individual bits of string
    values, which can be of use when working with buffers:'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 最近添加了用于操作字符串值单个位的命令，这在处理缓冲区时可能很有用：
- en: '`bitcount`'
  id: totrans-1792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bitcount`'
- en: '`bitfield`'
  id: totrans-1793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bitfield`'
- en: '`bitop`'
  id: totrans-1794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bitop`'
- en: '`setbit`'
  id: totrans-1795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setbit`'
- en: '`bitpos`'
  id: totrans-1796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bitpos`'
- en: 8.10.6\. Using hashes
  id: totrans-1797
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.6\. 使用哈希
- en: A *hash* is a collection of key/value pairs. The `hmset` command takes a key
    and an object representing the key/value pairs of the hash. You can get the key/value
    pairs back as an object by using `hmget`, as shown in the next listing.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: '*哈希* 是键/值对的集合。`hmset` 命令接受一个键和一个表示哈希键/值对的对象。您可以通过使用 `hmget` 来获取键/值对，如下一列表所示。'
- en: Listing 8.15\. Storing data in elements of Redis hashes
  id: totrans-1799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. 在 Redis 哈希的元素中存储数据
- en: '![](Images/08lis15_alt.jpg)'
  id: totrans-1800
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08lis15_alt.jpg)'
- en: You can’t store nested objects in a Redis hash. It provides only a single level
    of keys and values.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能在 Redis 哈希中存储嵌套对象。它只提供单层键和值。
- en: 'The following commands operate on hashes:'
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令作用于哈希：
- en: '`hdel`'
  id: totrans-1803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hdel`'
- en: '`hexists`'
  id: totrans-1804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hexists`'
- en: '`hget`'
  id: totrans-1805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hget`'
- en: '`hgetall`'
  id: totrans-1806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hgetall`'
- en: '`hincrby`'
  id: totrans-1807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hincrby`'
- en: '`hincrbyfloat`'
  id: totrans-1808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hincrbyfloat`'
- en: '`hkeys`'
  id: totrans-1809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hkeys`'
- en: '`hlen`'
  id: totrans-1810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hlen`'
- en: '`hmget`'
  id: totrans-1811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hmget`'
- en: '`hmset`'
  id: totrans-1812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hmset`'
- en: '`hset`'
  id: totrans-1813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hset`'
- en: '`hsetnx`'
  id: totrans-1814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hsetnx`'
- en: '`hstrlen`'
  id: totrans-1815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hstrlen`'
- en: '`hvals`'
  id: totrans-1816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hvals`'
- en: '`hscan`'
  id: totrans-1817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hscan`'
- en: 8.10.7\. Using lists
  id: totrans-1818
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.7\. 使用列表
- en: 'A *list* is an ordered collection of string values. A list can contain multiple
    copies of the same value. Lists are conceptually similar to arrays. Lists are
    best used for their ability to behave as a stack (LIFO: last in, first out) or
    queue (FIFO: first in, first out) data structures.'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是字符串值的有序集合。列表可以包含相同值的多个副本。列表在概念上与数组相似。列表最适合用作栈（LIFO：后进先出）或队列（FIFO：先进先出）数据结构。'
- en: 'The following code shows the storage and retrieval of values in a list. The
    `lpush` command adds a value to a list. The `lrange` command retrieves a range
    of values, using start and end indices. The `-1` argument in the following code
    signifies the last item of the list, so this use of `lrange` retrieves all list
    items:'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了在列表中存储和检索值。`lpush` 命令向列表添加一个值。`lrange` 命令通过使用起始和结束索引检索值范围。以下代码中的 `-1`
    参数表示列表的最后一个项目，因此这种使用 `lrange` 的方式检索所有列表项：
- en: '[PRE228]'
  id: totrans-1821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Lists don’t contain any built-in means to determine whether a value is in the
    list, or any means of discovering the index of a particular value in the list.
    You can manually iterate over the list to obtain this information, but this is
    a highly inefficient approach that should be avoided. If you need these types
    of features, you should consider a different data structure, such as a set, perhaps
    even used in addition to a list. Duplicating data across multiple data structures
    is often desirable in order to take advantage of various performance characteristics.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 列表不包含任何内置方法来确定值是否在列表中，或者任何发现特定值在列表中索引的方法。您可以手动遍历列表以获取这些信息，但这是一种效率非常低的方法，应该避免。如果您需要这些类型的功能，您应该考虑不同的数据结构，例如集合，甚至可能是在列表之外使用。在多个数据结构之间复制数据通常是为了利用各种性能特性。
- en: 'The following commands operate on lists:'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在列表上操作：
- en: '`blpop`'
  id: totrans-1824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blpop`'
- en: '`brpop`'
  id: totrans-1825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brpop`'
- en: '`lindex`'
  id: totrans-1826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lindex`'
- en: '`linsert`'
  id: totrans-1827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linsert`'
- en: '`llen`'
  id: totrans-1828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llen`'
- en: '`lpop`'
  id: totrans-1829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lpop`'
- en: '`lpush`'
  id: totrans-1830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lpush`'
- en: '`lpushx`'
  id: totrans-1831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lpushx`'
- en: '`lrange`'
  id: totrans-1832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lrange`'
- en: '`lrem`'
  id: totrans-1833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lrem`'
- en: '`lset`'
  id: totrans-1834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lset`'
- en: '`ltrim`'
  id: totrans-1835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ltrim`'
- en: '`rpop`'
  id: totrans-1836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpop`'
- en: '`rpush`'
  id: totrans-1837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpush`'
- en: '`rpushx`'
  id: totrans-1838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpushx`'
- en: 8.10.8\. Using sets
  id: totrans-1839
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.8\. 使用集合
- en: 'A *set* is an unordered collection of unique values. Testing membership, and
    adding and removing items from a set can be performed in O(1) time, making it
    a high-performing structure suitable for many tasks:'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合* 是一个无序的唯一值集合。测试成员资格，以及从集合中添加和删除项目可以在 O(1) 时间内完成，使其成为一个高性能的结构，适用于许多任务：'
- en: '[PRE229]'
  id: totrans-1841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'The following commands operate on Redis sets:'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在 Redis 集合上操作：
- en: '`sadd`'
  id: totrans-1843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sadd`'
- en: '`scard`'
  id: totrans-1844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scard`'
- en: '`sdiff`'
  id: totrans-1845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sdiff`'
- en: '`sdiffstore`'
  id: totrans-1846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sdiffstore`'
- en: '`sinter`'
  id: totrans-1847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinter`'
- en: '`sinterstore`'
  id: totrans-1848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sinterstore`'
- en: '`sismember`'
  id: totrans-1849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sismember`'
- en: '`smembers`'
  id: totrans-1850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smembers`'
- en: '`spop`'
  id: totrans-1851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spop`'
- en: '`srandmember`'
  id: totrans-1852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srandmember`'
- en: '`srem`'
  id: totrans-1853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`srem`'
- en: '`sunion`'
  id: totrans-1854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sunion`'
- en: '`sunionstore`'
  id: totrans-1855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sunionstore`'
- en: '`sscan`'
  id: totrans-1856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sscan`'
- en: 8.10.9\. Providing pub/sub with channels
  id: totrans-1857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.9\. 使用频道提供 pub/sub
- en: Redis goes beyond the traditional role of a data store by providing channels.
    *Channels* are a data-delivery mechanism that provides publish/subscribe functionality,
    as shown conceptually in [figure 8.4](#ch08fig04). They can be useful for real-time
    applications such as chat and gaming.
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 通过提供频道超越了传统数据存储的角色。*频道* 是一种数据交付机制，它提供了发布/订阅功能，如图 8.4 所示的概念图。它们对于实时应用，如聊天和游戏，非常有用。
- en: Figure 8.4\. Redis channels provide an easy solution to a common data-delivery
    scenario.
  id: totrans-1859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4\. Redis 频道为常见的数据交付场景提供了一个简单的解决方案。
- en: '![](Images/08fig04.jpg)'
  id: totrans-1860
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig04.jpg)'
- en: A Redis client can subscribe or publish to a channel. A message published to
    a channel will be delivered to all subscribers. A publisher doesn’t need to know
    about the subscribers, nor the subscribers about the publishers. This decoupling
    of publishers and subscribers is what makes this a powerful and clean pattern.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 客户端可以订阅或发布到频道。发布到频道的消息将被发送到所有订阅者。发布者不需要了解订阅者，订阅者也不需要了解发布者。这种发布者和订阅者之间的解耦使得这种模式既强大又简洁。
- en: The following listing shows an example of how Redis’s publish/subscribe functionality
    can be used to implement a TCP/IP chat server.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了如何使用 Redis 的发布/订阅功能来实现 TCP/IP 聊天服务器的一个示例。
- en: Listing 8.16\. A simple chat server implemented with Redis pub/sub functionality
  id: totrans-1863
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16\. 使用 Redis pub/sub 功能实现的简单聊天服务器
- en: '![](Images/08lis16_alt.jpg)'
  id: totrans-1864
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08lis16_alt.jpg)'
- en: 8.10.10\. Improving Redis performance
  id: totrans-1865
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.10.10\. 提高Redis性能
- en: The hiredis npm package is a native binding from JavaScript to the protocol
    parser in the official Hiredis C library. Hiredis can significantly improve the
    performance of Node Redis applications, particularly if you’re using `sunion,
    sinter, lrange`, and `zrange` operations with large datasets.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: hiredis npm 包是从 JavaScript 到官方 Hiredis C 库中的协议解析器的本地绑定。Hiredis 可以显著提高 Node Redis
    应用程序的性能，尤其是如果您使用 `sunion, sinter, lrange`, 和 `zrange` 操作与大数据集。
- en: 'To use hiredis, simply install it alongside the redis package in your application,
    and the Node redis package will detect it and use it automatically the next time
    it starts:'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 hiredis，只需将其与应用程序中的 redis 包一起安装，Node redis 包将在下次启动时自动检测并使用它：
- en: '[PRE230]'
  id: totrans-1868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: There are few downsides to using hiredis, but because it’s compiled from C code,
    some complications or limitations may arise when building hiredis for some platforms.
    As with all native add-ons, you may need to rebuild hiredis with `npm rebuild`
    after updating Node.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 hiredis 几乎没有缺点，但由于它是从 C 代码编译的，因此在为某些平台构建 hiredis 时可能会出现一些复杂或限制。与所有原生插件一样，在更新
    Node 后，您可能需要使用 `npm rebuild` 重新构建 hiredis。
- en: 8.11\. Embedded databases
  id: totrans-1870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.11\. 嵌入式数据库
- en: An embedded database doesn’t require the installation or administration of an
    external server. It runs *embedded* within your application process itself. Communication
    with an embedded database usually occurs via direct procedure calls in your application,
    rather than across an interprocess communication (IPC) channel or a network.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式数据库不需要安装或管理外部服务器。它直接嵌入到你的应用程序进程中运行。与嵌入式数据库的通信通常通过应用程序中的直接过程调用进行，而不是通过进程间通信（IPC）通道或网络。
- en: In many situations, an application needs to be self-contained, so an embeddable
    database is the only option (for example, mobile or desktop applications). Embedded
    databases can also be used on web servers, often found powering high-throughput
    features such as user sessions or caching, and sometimes even as the primary storage.
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，应用程序需要自给自足，因此嵌入式数据库是唯一的选择（例如，移动或桌面应用程序）。嵌入式数据库也可以用于 Web 服务器，通常用于驱动高吞吐量功能，如用户会话或缓存，有时甚至作为主要存储。
- en: 'Some embeddable databases commonly used in Node and Electron apps are as follows:'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 和 Electron 应用程序中常用的一些嵌入式数据库如下：
- en: SQLite
  id: totrans-1874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite
- en: LevelDB
  id: totrans-1875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LevelDB
- en: RocksDB
  id: totrans-1876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RocksDB
- en: Aerospike
  id: totrans-1877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Aerospike
- en: EJDB
  id: totrans-1878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJDB
- en: NeDB
  id: totrans-1879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NeDB
- en: LokiJS
  id: totrans-1880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LokiJS
- en: Lowdb
  id: totrans-1881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lowdb
- en: NeDB, LokiJS, and Lowdb are all written in pure JavaScript, which by nature
    makes them embeddable into Node/Electron applications. Most embedded databases
    are simple key/value or document stores, though SQLite is a notable exception
    as an embeddable *relational* store.
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: NeDB、LokiJS 和 Lowdb 都是用纯 JavaScript 编写的，这使得它们可以嵌入到 Node/Electron 应用程序中。大多数嵌入式数据库都是简单的键/值或文档存储，尽管
    SQLite 是一个值得注意的例外，它是一个可嵌入的 *关系型* 存储。
- en: 8.12\. LevelDB
  id: totrans-1883
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.12\. LevelDB
- en: '*LevelDB* is an embeddable, persistent key/value store developed in early 2011
    by Google, initially for use as the backing store for the IndexedDB implementation
    in Chrome. LevelDB’s design is built on concepts from Google’s Bigtable database.
    LevelDB is comparable to databases such as Berkley DB, Tokyo/Kyoto Cabinet, and
    Aerospike, but in the context of this book, you can think of LevelDB as an embeddable
    Redis with only the bare minimum of features. Like many embedded databases, LevelDB
    isn’t multithreaded and doesn’t support multiple instances using the same underlying
    file storage, so it doesn’t work in a distributed setting without a wrapping application.'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: '*LevelDB* 是由 Google 在 2011 年初开发的一个可嵌入的、持久化的键/值存储，最初用于 Chrome 中 IndexedDB 实现的后端存储。LevelDB
    的设计基于 Google Bigtable 数据库的概念。LevelDB 可以与 Berkley DB、Tokyo/Kyoto Cabinet 和 Aerospike
    等数据库相媲美，但在本书的上下文中，你可以将 LevelDB 视为仅具有最基本功能的可嵌入 Redis。像许多嵌入式数据库一样，LevelDB 不是多线程的，也不支持使用相同底层文件存储的多个实例，因此在没有包装应用程序的情况下无法在分布式环境中工作。'
- en: LevelDB stores arbitrary byte arrays, sorted lexicographically by key. Values
    are compressed by using Google’s Snappy compression algorithm. Data is always
    persisted to disk; the total data capacity isn’t constrained by the amount of
    RAM on the machine, unlike an in-memory store such as Redis.
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB 以字典序对键进行排序存储任意字节数组。值通过使用 Google 的 Snappy 压缩算法进行压缩。数据始终持久化到磁盘；总数据容量不受机器上
    RAM 量的限制，与 Redis 这样的内存存储不同。
- en: 'Only a small set of self-explanatory operations are provided with LevelDB:
    `Get`, `Put`, `Del`, and `Batch`. LevelDB can also capture snapshots of the current
    database state and create bidirectional iterators for moving forward or backward
    through the dataset. Creating an iterator creates an implicit snapshot; the data
    an iterator can see can’t be changed by subsequent writes.'
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB 提供了一组非常简单的自解释操作：`Get`、`Put`、`Del` 和 `Batch`。LevelDB 还可以捕获当前数据库状态的快照，并创建双向迭代器以在数据集中向前或向后移动。创建迭代器会创建一个隐式快照；迭代器可以看到的数据不能通过后续写入进行更改。
- en: 'LevelDB forms the foundation for other databases, in the form of LevelDB forks.
    The number of significant LevelDB offshoots could be attributed to the simplicity
    of LevelDB itself:'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB 以 LevelDB 分支的形式构成了其他数据库的基础。LevelDB 的重要分支数量可以归因于 LevelDB 本身的简单性：
- en: RocksDB by Facebook
  id: totrans-1888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RocksDB by Facebook
- en: HyperLevelDB by Hyperdex
  id: totrans-1889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HyperLevelDB by Hyperdex
- en: Riak by Basho
  id: totrans-1890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Riak by Basho
- en: leveldb-mcpe by Mojang (creators of Minecraft)
  id: totrans-1891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: leveldb-mcpe by Mojang（Minecraft 的创造者）
- en: bitcoin/leveldb for the bitcoind project
  id: totrans-1892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bitcoin/leveldb for the bitcoind project
- en: For more information about LevelDB, see [http://leveldb.org/](http://leveldb.org/).
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 LevelDB 的更多信息，请参阅 [http://leveldb.org/](http://leveldb.org/)。
- en: 8.12.1\. LevelUP and LevelDOWN
  id: totrans-1894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.12.1\. LevelUP 和 LevelDOWN
- en: LevelDB support in Node is provided by the LevelUP and LevelDOWN packages written
    by Node foundation chair and prolific Australian developer Rod Vagg. LevelDOWN
    is a simple, sugar-free C++ binding to LevelDB for Node, and it’s unlikely you’ll
    interface with it directly. LevelUP wraps the LevelDOWN API with a more convenient,
    idiomatic node interface, adding support for key/value encodings, JSON, buffering
    writes until the database is open, and wrapping the LevelDB iterator interface
    in a Node stream. [Figure 8.5](#ch08fig05) shows levelup’s popularity on npm.
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的 LevelDB 支持由 Node 基金会主席和多产的澳大利亚开发者 Rod Vagg 编写的 LevelUP 和 LevelDOWN 包提供。LevelDOWN
    是 LevelDB 的一个简单、无糖的 C++ 绑定，用于 Node，你不太可能直接与之交互。LevelUP 使用更方便、更符合 Node 习惯的接口包装
    LevelDOWN API，增加了对键/值编码、JSON、缓冲写入直到数据库打开以及将 LevelDB 迭代器接口包装在 Node 流中的支持。[图 8.5](#ch08fig05)
    展示了 levelup 在 npm 上的流行度。
- en: Figure 8.5\. The levelup package’s statistics on npm
  id: totrans-1896
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. levelup 包在 npm 上的统计信息
- en: '![](Images/08fig05.jpg)'
  id: totrans-1897
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig05.jpg)'
- en: 8.12.2\. Installation
  id: totrans-1898
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.12.2\. 安装
- en: 'A major convenience of using LevelDB in your Node application is that it’s
    *embedded*: you can install everything you need solely with npm. You don’t need
    to install any additional software; just issue the following command and you’re
    ready to start using LevelDB:'
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 应用程序中使用 LevelDB 的一大便利是它**内嵌**：你可以仅使用 npm 安装所需的一切。你不需要安装任何额外的软件；只需执行以下命令，你就可以开始使用
    LevelDB：
- en: '[PRE231]'
  id: totrans-1900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'The level package is a simple convenience wrapper around the LevelUP and LevelDOWN
    packages, providing a LevelUP API preconfigured to use a LevelDown back end. Documentation
    for the LevelUP API exposed by the level package can be found on the LevelUP readme:'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: level 包是 LevelUP 和 LevelDOWN 包的简单便利包装，提供了一个预配置的 LevelUP API，用于使用 LevelDown 后端。可以在
    LevelUP 的 README 文件中找到 level 包暴露的 LevelUP API 的文档：
- en: '[www.npmjs.com/package/levelup](http://www.npmjs.com/package/levelup)'
  id: totrans-1902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.npmjs.com/package/levelup](http://www.npmjs.com/package/levelup)'
- en: '[www.npmjs.com/package/leveldown](http://www.npmjs.com/package/leveldown)'
  id: totrans-1903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.npmjs.com/package/leveldown](http://www.npmjs.com/package/leveldown)'
- en: 8.12.3\. API overview
  id: totrans-1904
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.12.3\. API 概述
- en: 'The LevelDB client’s main methods for storing and retrieving values are as
    follows:'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB 客户端存储和检索值的主要方法如下：
- en: '`db.put(key, value, callback`—Store a value under key'
  id: totrans-1906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.put(key, value, callback)`—在键下存储一个值'
- en: '`db.get(key, callback)`—Get the value under key'
  id: totrans-1907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.get(key, callback)`—获取键下的值'
- en: '`db.del(key, callback)`—Remove the value under key'
  id: totrans-1908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.del(key, callback)`—删除键下的值'
- en: '`db.batch().write()`—Perform batch operations'
  id: totrans-1909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.batch().write()`—执行批量操作'
- en: '`db.createKeyStream(options)`—Stream of keys in database'
  id: totrans-1910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.createKeyStream(options)`—数据库中的键流'
- en: '`db.createValueStream(options)`—Stream of values in database'
  id: totrans-1911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`db.createValueStream(options)`—数据库中的值流'
- en: 8.12.4\. Initialization
  id: totrans-1912
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.12.4\. 初始化
- en: When you initialize level, you need to provide a path to the directory that
    will store the data, as shown in the following listing; the directory will be
    created if it doesn’t already exist. There’s a loose community convention of giving
    this directory a .db extension (for example, ./app.db).
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 当你初始化 level 时，需要提供一个存储数据的目录路径，如下所示；如果目录不存在，则会创建该目录。有一个宽松的社区约定，即给这个目录添加一个 .db
    扩展名（例如，./app.db）。
- en: Listing 8.17\. Initializing a level database
  id: totrans-1914
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.17\. 初始化 level 数据库
- en: '[PRE232]'
  id: totrans-1915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: After `level()` is called, the returned LevelUP instance is immediately ready
    to start accepting commands, synchronously. Commands issued before the LevelDB
    store is open will be buffered until the store is open.
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `level()` 之后，返回的 LevelUP 实例立即准备好开始接受命令，同步地。在 LevelDB 存储打开之前发出的命令将被缓冲，直到存储打开。
- en: 8.12.5\. Key/value encodings
  id: totrans-1917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.12.5\. 键/值编码
- en: 'Because LevelDB can store arbitrary data of any type for both keys and values,
    it’s up to the calling application to handle data serialization and deserialization.
    LevelUp can be configured to encode keys and values by using the following data
    types out of the box:'
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 LevelDB 可以存储任意类型的数据，无论是键还是值，因此处理数据序列化和反序列化的任务就交给了调用应用程序。LevelUp 可以通过以下数据类型直接配置来编码键和值：
- en: '`utf8`'
  id: totrans-1919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`utf8`'
- en: '`json`'
  id: totrans-1920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json`'
- en: '`binary`'
  id: totrans-1921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binary`'
- en: '`id`'
  id: totrans-1922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`'
- en: '`hex`'
  id: totrans-1923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hex`'
- en: '`ascii`'
  id: totrans-1924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ascii`'
- en: '`base64`'
  id: totrans-1925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base64`'
- en: '`ucs2`'
  id: totrans-1926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ucs2`'
- en: '`utf16le`'
  id: totrans-1927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`utf16le`'
- en: By default, both keys and values are encoded as UTF-8 strings. In [listing 8.17](#ch08ex17),
    keys will remain as UTF-8 strings, but values are encoded/decoded as JSON. JSON
    encoding permits storage and retrieval of structured values such as objects or
    arrays in a somewhat similar fashion to that of a document store such as MongoDB.
    But note that unlike a real document store, there’s no way to access keys within
    values with vanilla LevelDB; values are opaque. Users can also supply their own
    custom encodings—for example, to support a different structured data format such
    as MessagePack.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，键和值都编码为 UTF-8 字符串。在[列表 8.17](#ch08ex17)中，键将保持为 UTF-8 字符串，但值将编码/解码为 JSON。JSON
    编码允许以类似于文档存储（如 MongoDB）的方式存储和检索结构化值，如对象或数组。但请注意，与真正的文档存储不同，使用 LevelDB 无法访问值内的键；值是透明的。用户还可以提供自己的自定义编码——例如，支持不同的结构化数据格式，如
    MessagePack。
- en: 8.12.6\. Reading and writing key/value pairs
  id: totrans-1929
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.12.6\. 读取和写入键/值对
- en: 'The core API is simple: use `put(key, value)` to write a value, `get(key)`
    to read a value, and `del(key)` to delete a value, as shown in the next listing.
    The code in [listing 8.18](#ch08ex18) should be appended to the code in [listing
    8.17](#ch08ex17); for a full example, see ch08-databases/listing8_18/index.js
    in the book’s sample code.'
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 核心API很简单：使用`put(key, value)`来写入值，`get(key)`来读取值，以及`del(key)`来删除值，如下一列表所示。下一列表中的代码应附加到[列表
    8.17](#ch08ex17)中的代码；要查看完整示例，请参阅书中示例代码的 ch08-databases/listing8_18/index.js。
- en: Listing 8.18\. Reading and writing values
  id: totrans-1931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.18\. 读取和写入值
- en: '[PRE233]'
  id: totrans-1932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: If you `put` a value on a key that already exists, the old value will be overwritten.
    Trying to `get` a key that doesn’t exist will result in an error. This error object
    will be of a particular type, `NotFoundError`, and has a special property, `err.notFound`,
    that can be used to differentiate it from other types of errors. This may seem
    unusual, but because LevelDB doesn’t have a built-in method to check for existence,
    LevelUp needs to be able to disambiguate nonexistent values and values that are
    `undefined`. Unlike with `get`, trying to `del` a nonexistent key will not cause
    an error.
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个已存在的键上`put`一个值，旧值将被覆盖。尝试获取一个不存在的键将导致错误。这个错误对象将是一个特定的类型，`NotFoundError`，并且有一个特殊属性`err.notFound`，可以用来区分它和其他类型的错误。这看起来可能有些不寻常，但因为在
    LevelDB 中没有内置的方法来检查存在性，LevelUp 需要能够区分不存在的值和`undefined`的值。与`get`不同，尝试删除一个不存在的键不会导致错误。
- en: Listing 8.19\. Getting keys that don’t exist
  id: totrans-1934
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.19\. 获取不存在的键
- en: '[PRE234]'
  id: totrans-1935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: All data reading and writing operations take an optional `options` argument
    for overriding the encoding options of the current operation, as shown in the
    next listing.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的数据读取和写入操作都接受一个可选的`options`参数，用于覆盖当前操作的编码选项，如下一列表所示。
- en: Listing 8.20\. Overriding encoding for specific operations
  id: totrans-1937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.20\. 覆盖特定操作的编码
- en: '[PRE235]'
  id: totrans-1938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 8.12.7\. Pluggable back ends
  id: totrans-1939
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.12.7\. 可插拔的后端
- en: A happy side effect of the separation of LevelUP/LevelDOWN is that LevelUP isn’t
    restricted to using LevelDB as the storage back end. Anything you can wrap with
    the MemDown API can be used as a storage back end for LevelUP, allowing you to
    use the exact same API to interface with many data stores.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: LevelUP/LevelDOWN 分离的一个令人高兴的副作用是 LevelUP 不受限于使用 LevelDB 作为存储后端。你可以使用 MemDown
    API 包装的任何内容作为 LevelUP 的存储后端，这允许你使用完全相同的API与许多数据存储进行接口。
- en: 'Some examples of alternative back ends are as follows:'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 一些替代后端的示例如下：
- en: MySQL
  id: totrans-1942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: Redis
  id: totrans-1943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis
- en: MongoDB
  id: totrans-1944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB
- en: JSON files
  id: totrans-1945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 文件
- en: Google spreadsheets
  id: totrans-1946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 电子表格
- en: AWS DynamoDB
  id: totrans-1947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS DynamoDB
- en: Windows Azure table storage
  id: totrans-1948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Azure 表存储
- en: Browser web storage (IndexedDB/localStorage)
  id: totrans-1949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器网页存储（IndexedDB/localStorage）
- en: This ability to easily swap out the storage medium or even write your own custom
    back end means you can use a single, consistent set of database APIs and tooling
    across many situations and environments. One database API to rule them all!
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 这种轻松更换存储介质或甚至编写自己的自定义后端的能力意味着你可以在许多情况和环境中使用单一、一致的数据库API和工具集。一个数据库API统治一切！
- en: A commonly used alternative back end is *memdown*, which stores values entirely
    in memory rather than disk, akin to using SQLite in-memory mode. This can be particularly
    useful in a test environment to reduce the cost of test setup and teardown.
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的替代后端是 *memdown*，它将值完全存储在内存中而不是磁盘上，类似于使用 SQLite 的内存模式。这在测试环境中可以特别有用，以减少测试设置和拆除的成本。
- en: 'To run the following listing, make sure you have the LevelUP and memdown packages
    installed:'
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行以下列表，请确保你已经安装了 LevelUP 和 memdown 包：
- en: '[PRE236]'
  id: totrans-1953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Listing 8.21\. Using memdown with LevelUP
  id: totrans-1954
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.21. 使用memdown与LevelUP
- en: '![](Images/08lis21_alt.jpg)'
  id: totrans-1955
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08lis21_alt.jpg)'
- en: In this sample, you could’ve used the same level package you used before, because
    it’s just a wrapper for LevelUP. But if you’re not using the LevelDB-backed LevelDOWN
    that comes bundled with level, you can just use LevelUP and avoid the binary dependency
    on LevelDB via LevelDOWN.
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你可以使用之前使用的相同级别的包，因为它只是LevelUP的包装器。但如果你没有使用level附带捆绑的LevelDB支持的LevelDOWN，你只需使用LevelUP，并通过LevelDOWN避免对LevelDB的二进制依赖。
- en: 8.12.8\. The modular database
  id: totrans-1957
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.12.8. 模块化数据库
- en: LevelDB’s performance and minimalism resonate with many Node developers, and
    it has fostered a modular database movement within the Node community. The concept
    is to be able to pick and choose exactly which features your application needs
    and tailor a database for your specific use case.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB的性能和简约风格与许多Node开发者产生共鸣，并在Node社区中催生了模块化数据库运动。概念是能够选择并选择应用程序需要的确切功能，并为特定的用例定制数据库。
- en: 'Here are just a few examples of modular LevelDB functionality available through
    npm packages:'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只是npm包中通过模块化LevelDB功能的一些示例：
- en: Atomic updates
  id: totrans-1960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子更新
- en: Autoincrementing keys
  id: totrans-1961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动递增键
- en: Geospatial queries
  id: totrans-1962
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理空间查询
- en: Live update streams
  id: totrans-1963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时更新流
- en: LRU eviction
  id: totrans-1964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LRU驱逐
- en: Map/reduce jobs
  id: totrans-1965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map/reduce作业
- en: Master/master replication
  id: totrans-1966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主/主复制
- en: Master/slave replication
  id: totrans-1967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主/从复制
- en: SQL queries
  id: totrans-1968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL查询
- en: Secondary indexes
  id: totrans-1969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二级索引
- en: Triggers
  id: totrans-1970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器
- en: Versioned data
  id: totrans-1971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本化数据
- en: 'The LevelUP wiki maintains a fairly comprehensive overview of the LevelDB ecosystem:
    [https://github.com/Level/levelup/wiki/Modules](https://github.com/Level/levelup/wiki/Modules),
    or you can search for *leveldb* on npm, for which there are 898 packages at the
    time of this writing. [Figure 8.6](#ch08fig06) shows how popular LevelDB is on
    npm.'
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: LevelUP维基百科维护了一个相当全面的LevelDB生态系统概述：[https://github.com/Level/levelup/wiki/Modules](https://github.com/Level/levelup/wiki/Modules)，或者你可以在npm上搜索*leveldb*，在撰写本文时，有898个包。[图8.6](#ch08fig06)显示了LevelDB在npm上的流行程度。
- en: Figure 8.6\. Examples of third-party LevelDB packages on npm
  id: totrans-1973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6. npm上第三方LevelDB包的示例
- en: '![](Images/08fig06_alt.jpg)'
  id: totrans-1974
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig06_alt.jpg)'
- en: 8.13\. Serialization and deserialization are expensive
  id: totrans-1975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.13. 序列化和反序列化成本高昂
- en: It’s important to remember that the built-in JSON operations are both expensive
    and blocking; your process can’t do anything else while it’s marshalling data
    to and from JSON. The same goes for most other serialization formats. It’s common
    for serialization to be a key bottleneck on a web server. The best way to reduce
    its impact is to minimize how often it’s performed and how much data it needs
    to handle.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，内置的JSON操作既昂贵又阻塞；在将数据从JSON序列化和反序列化时，你的进程无法执行其他任何操作。对于大多数其他序列化格式也是如此。在Web服务器上，序列化通常是一个关键瓶颈。减少其影响的最佳方法是尽量减少其执行频率和需要处理的数据量。
- en: You may experience some speed improvement by using a different serialization
    format (for example, MessagePack or Protocol Buffers), but alternative formats
    should be considered only after you've squeezed the possible gains out of reducing
    the payload sizes and unnecessary serialization/deserialization steps.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用不同的序列化格式（例如，MessagePack或Protocol Buffers），你可能会有一些速度提升，但在从减少有效载荷大小和不必要的序列化/反序列化步骤中挤出可能的收益之后，才应考虑替代格式。
- en: '`JSON.stringify` and `JSON.parse` are native functions and have been thoroughly
    optimized, but they can easily be overwhelmed when needing to handle megabytes
    of data. To demonstrate, the following listing benchmarks serializing and deserializing
    about 10 MB of data.'
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.stringify`和`JSON.parse`是原生函数，并且已经过充分优化，但当需要处理兆字节级的数据时，它们很容易被压垮。为了演示，以下列表对大约10
    MB的数据进行了序列化和反序列化的基准测试。'
- en: Listing 8.22\. Serialization benchmarking
  id: totrans-1979
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.22. 序列化基准测试
- en: '[PRE237]'
  id: totrans-1980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: On a 2015 3.1 GHz Intel Core i7 MacBook Pro running Node 6.2.2, it takes roughly
    140 ms to serialize, and 335 ms to deserialize, the approximately 10 MB of data.
    This would be a disaster if such a load were to occur on a web server, because
    these steps are totally blocking and have to be processed in series. Such a server
    would be able to handle only about a dismal seven requests a second when serializing,
    and about three requests a second when deserializing.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台2015年3.1 GHz Intel Core i7 MacBook Pro上运行Node 6.2.2，大约需要140毫秒来序列化，335毫秒来反序列化大约10
    MB的数据。如果这样的负载发生在Web服务器上，这将是一场灾难，因为这些步骤是完全阻塞的，并且必须按顺序处理。这样的服务器在序列化时只能处理大约每秒令人沮丧的七个请求，在反序列化时大约每秒三个请求。
- en: 8.14\. In-browser storage
  id: totrans-1982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.14. 浏览器存储
- en: The asynchronous programming model used in Node works well for many use cases
    because the assumption holds that I/O is the single biggest bottleneck for most
    web applications. The single most significant thing you can do to simultaneously
    reduce server workload and improve user experience is to take advantage of client-side
    data storage. A happy user is one who doesn’t have to wait for a full network
    round-trip to get results. Client-side storage can also facilitate improved application
    availability by allowing your application to remain at least semifunctional while
    the user or your service is offline.
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: Node中使用的异步编程模型适用于许多用例，因为假设I/O是大多数Web应用中最大的瓶颈。你可以同时减少服务器负载并提高用户体验的最重要的事情之一是利用客户端数据存储。一个快乐的用户是不需要等待完整的网络往返才能得到结果的。客户端存储还可以通过允许应用程序在用户或您的服务离线时至少保持半功能状态，从而促进应用程序可用性的提高。
- en: '8.14.1\. Web storage: localStorage and sessionStorage'
  id: totrans-1984
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.14.1\. Web存储：localStorage和sessionStorage
- en: Web storage defines a simple key/value store and has great support across both
    desktop and mobile browsers. Using web storage, a domain can persist a moderate
    amount of data in the browser and retrieve it at a later time, even after the
    website has been refreshed, the tab closed, or the browser shut down. Web storage
    is your first resort for client-side persistence. Its winning feature is its bare
    simplicity.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储定义了一个简单的键/值存储，并且在桌面和移动浏览器中都得到了很好的支持。使用Web存储，一个域可以在浏览器中持久化一定量的数据，并在稍后检索它，即使网站已被刷新，标签页已关闭或浏览器已关闭。Web存储是客户端持久化的首选方案。其获胜的特点是它的简单性。
- en: 'There are two web storage APIs: localStorage and sessionStorage. sessionStorage
    implements an identical API to localStorage, though it differs in its persistence
    behavior. Like localStorage, data stored in sessionStorage is persisted across
    page reloads, but unlike localStorage, all sessionStorage data expires when the
    page session ends (when the tab or browser is closed). sessionStorage data can’t
    be accessed from different browser windows.'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个Web存储API：localStorage和sessionStorage。sessionStorage实现了与localStorage相同的API，尽管它在持久化行为上有所不同。与localStorage一样，存储在sessionStorage中的数据在页面重新加载时保持持久，但与localStorage不同，当页面会话结束时（当标签页或浏览器关闭时），所有sessionStorage数据都会过期。sessionStorage数据不能从不同的浏览器窗口中访问。
- en: The web storage APIs were developed to overcome limitations with browser cookies.
    Specifically, cookies aren’t well suited for sharing data between multiple active
    tabs on the same domain. If a user is performing an activity across multiple tabs,
    sessionStorage can be used for sharing state between those tabs, without requiring
    the use of the network.
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储API的开发是为了克服浏览器Cookie的限制。具体来说，Cookie不适合在同一个域的多个活动标签页之间共享数据。如果用户在多个标签页中执行活动，可以使用sessionStorage在这些标签页之间共享状态，而无需使用网络。
- en: Cookies are also ill-suited for handling more long-term data that should live
    across multiple sessions, tabs, and windows; for example, user-authored documents
    or email. This is the use case that localStorage was designed to handle. Depending
    on the particular browser, varying upper limits exist for the amount of data that
    can be stored in web storage. Mobile browsers are limited to just 5 MB of storage.
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie不适用于处理需要在多个会话、标签页和窗口中持续存在的长期数据；例如，用户创建的文档或电子邮件。这正是localStorage被设计来处理的使用场景。根据特定浏览器的不同，可以存储在Web存储中的数据量上限也有所不同。移动浏览器仅限于5
    MB的存储空间。
- en: API overview
  id: totrans-1989
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API概述
- en: 'The localStorage API provides the following methods for working with keys and
    values:'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: localStorage API提供了以下方法来处理键和值：
- en: '`localStorage.setItem(key, value)`—Store a value under key'
  id: totrans-1991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage.setItem(key, value)`—在键下存储一个值'
- en: '`localStorage.getItem(key)`—Get the value under key'
  id: totrans-1992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage.getItem(key)`—获取键下的值'
- en: '`localStorage.removeItem(key)`—Remove the value under key'
  id: totrans-1993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage.removeItem(key)`—移除键下的值'
- en: '`localStorage.clear()`—Remove all keys and values'
  id: totrans-1994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage.clear()`—移除所有键和值'
- en: '`localStorage.key(index)`—Get value at index'
  id: totrans-1995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage.key(index)`—获取索引处的值'
- en: '`localStorage.length`—Total number of keys in localStorage'
  id: totrans-1996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localStorage.length`—localStorage中的键总数'
- en: 8.14.2\. Reading and writing values
  id: totrans-1997
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.14.2\. 读取和写入值
- en: Both keys and values must be strings. If you pass a value that isn’t a string,
    it’ll be coerced into a string for you. This conversion doesn’t produce JSON strings;
    instead, it’s a naïve conversion using `.toString`. Objects will end up serialized
    as the string `[object Object]`. The application must serialize values to and
    from strings in order to store more-complicated data types in web storage. The
    next listing shows how to store JSON in localStorage.
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 键和值都必须是字符串。如果你传递了一个非字符串的值，它将被自动转换为字符串。这种转换不会生成JSON字符串；相反，它使用`.toString`进行简单的转换。对象最终会被序列化为字符串`[object
    Object]`。应用程序必须将值序列化和反序列化成字符串，以便在Web存储中存储更复杂的数据类型。下面的列表展示了如何将JSON存储在localStorage中。
- en: Listing 8.23\. Storing JSON in web storage
  id: totrans-1999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.23\. 在Web存储中存储JSON
- en: '[PRE238]'
  id: totrans-2000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Access to web storage data is reasonably fast, though it’s also synchronous.
    Web storage blocks the UI thread while performing read and write operations. For
    small workloads, this overhead will be unnoticeable, but care should be taken
    to avoid excessive reads or writes, especially with large quantities of data.
    Unfortunately, web storage is also unavailable from web workers, so all reads
    and writes must happen on the main UI thread. For a detailed analysis of the performance
    impact of various client-side storage technologies, see this post by Nolan Lawson,
    author of PouchDB: [http://nolanlawson.com/2015/09/29/indexeddb-websql-localstorage-what-blocks-the-dom/](http://nolanlawson.com/2015/09/29/indexeddb-websql-localstorage-what-blocks-the-dom/).'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Web存储数据相对较快，尽管它也是同步的。Web存储在执行读写操作时会阻塞UI线程。对于小负载，这种开销可能不明显，但应避免过度读取或写入，尤其是大量数据时。不幸的是，Web存储在Web
    Worker中不可用，因此所有读取和写入都必须在主UI线程上执行。有关各种客户端存储技术性能影响的详细分析，请参阅PouchDB作者Nolan Lawson的这篇帖子：[http://nolanlawson.com/2015/09/29/indexeddb-websql-localstorage-what-blocks-the-dom/](http://nolanlawson.com/2015/09/29/indexeddb-websql-localstorage-what-blocks-the-dom/)。
- en: Web storage APIs provide no built-in facilities to perform queries, select keys
    by range, or search through values. You’re limited to accessing items key by key.
    To perform searches, you can set up and maintain your own indexes; or if your
    dataset is small enough, you can iterate over it in its entirety. The following
    listing iterates over all the keys in localStorage.
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储API没有提供内置的查询、按范围选择键或搜索值的工具。你只能通过键访问项目。要执行搜索，你可以设置和维护自己的索引；或者如果你的数据集足够小，你可以遍历整个数据集。以下列表遍历了localStorage中的所有键。
- en: Listing 8.24\. Iterating over entire dataset in localStorage
  id: totrans-2003
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.24\. 在localStorage中遍历整个数据集
- en: '[PRE239]'
  id: totrans-2004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: As in most key/value stores, there’s only a single namespace for keys. For example,
    if you have `posts` and `comments`, there’s no way to create separate stores for
    posts and comments. It’s easy enough to create your own “namespace” by using a
    prefix on each key to delineate namespaces, as shown in the next listing.
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数键/值存储类似，键只有一个命名空间。例如，如果你有`posts`和`comments`，就无法为帖子或评论创建单独的存储。通过在每个键前使用前缀来创建自己的“命名空间”很容易，如以下列表所示。
- en: Listing 8.25\. Namespacing keys
  id: totrans-2006
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.25\. 命名空间键
- en: '[PRE240]'
  id: totrans-2007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: To get all items within a namespace, you can filter through all items using
    the preceding `getAllKeys` function, as shown in the next listing.
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取命名空间内的所有项目，你可以使用前面的`getAllKeys`函数过滤所有项目，如以下列表所示。
- en: Listing 8.26\. Getting all items in a namespace
  id: totrans-2009
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.26\. 获取命名空间中的所有项目
- en: '[PRE241]'
  id: totrans-2010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Note that this loops over every single key in localStorage, so be wary of performance
    when iterating over many items.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个循环遍历localStorage中的每个键，所以在遍历大量项目时要当心性能。
- en: As a result of the localStorage API being synchronous, a few restrictions exist
    on when and where it can be used. For example, you could use localStorage to permanently
    memoize the result of any function that takes and returns JSON-serializable data,
    as shown in the following listing.
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: 由于localStorage API是同步的，因此在使用时存在一些限制。例如，你可以使用localStorage永久缓存任何接受并返回可序列化JSON数据的函数的结果，如以下列表所示。
- en: Listing 8.27\. Using localStorage for persistent memoization
  id: totrans-2013
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.27\. 使用localStorage进行持久化缓存
- en: '[PRE242]'
  id: totrans-2014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Note that an operation would need to be particularly slow in order for the memoization
    benefits to outweigh the overhead of the serialization/deserialization process
    (for example, a cryptographic algorithm). As such, localStorage works best when
    it’s saving time spent moving data across a network.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果操作特别慢，那么缓存的好处才能超过序列化/反序列化过程的开销（例如，加密算法）。因此，localStorage在节省跨网络移动数据的时间方面效果最佳。
- en: 'Web storage does have limitations, but for the right tasks, it can be a powerful
    and simple tool. Other in-browser storage topics to investigate are as follows:'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储确实存在限制，但对于合适的任务，它可以是一个强大且简单的工具。其他需要调查的浏览器内存储主题如下：
- en: IndexedDB
  id: totrans-2017
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IndexedDB
- en: Service workers
  id: totrans-2018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者
- en: Offline-first
  id: totrans-2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 离线优先
- en: 8.14.3\. localForage
  id: totrans-2020
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.14.3\. localForage
- en: Web storage’s main drawbacks are its blocking, synchronous API and limited storage
    capacity in some browsers. In addition to web storage, most modern browsers also
    support one or both of WebSQL and IndexedDB. Both data stores are nonblocking
    and can reliably hold far more data than web storage.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储的主要缺点是其阻塞的、同步的API以及在某些浏览器中有限的存储容量。除了Web存储之外，大多数现代浏览器还支持WebSQL和IndexedDB中的一个或两个。这两个数据存储都是非阻塞的，并且可以可靠地存储比Web存储多得多的数据。
- en: But using either of these databases directly, as we did with the web storage
    APIs, is inadvisable. WebSQL is deprecated, and its successor, IndexedDB, has
    a particularly unfriendly and verbose API, not to mention patchier browser support.
    To conveniently and reliably store data in the browser without blocking, we’re
    relegated to using a nonstandard tool to “normalize” the landscape. The localForage
    library from Mozilla ([http://mozilla.github.io/localForage/](http://mozilla.github.io/localForage/))
    is one such normalizing tool.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，像我们使用Web存储API那样直接使用这些数据库是不可取的。WebSQL已弃用，其继任者IndexedDB有一个特别不友好且冗长的API，更不用说浏览器支持的碎片化了。为了方便且可靠地在浏览器中存储数据而不阻塞，我们被迫使用非标准工具来“规范化”环境。来自Mozilla的localForage库（[http://mozilla.github.io/localForage/](http://mozilla.github.io/localForage/））就是这样一种规范化的工具。
- en: API overview
  id: totrans-2023
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API概述
- en: 'Conveniently, the localForage interface closely mirrors that of web storage,
    though in an asynchronous, nonblocking form:'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 便利的是，localForage接口紧密地模仿了Web存储，尽管是以异步、非阻塞的形式：
- en: '`localforage.setItem(key, value, callback)`—Store a value under key'
  id: totrans-2025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localforage.setItem(key, value, callback)`—在键下存储一个值'
- en: '`localforage.getItem(key, callback)`—Get the value under key'
  id: totrans-2026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localforage.getItem(key, callback)`—获取键下的值'
- en: '`localforage.removeItem(key, callback)`—Remove the value under key'
  id: totrans-2027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localforage.removeItem(key, callback)`—移除键下的值'
- en: '`localforage.clear(callback)`—Remove all keys and values'
  id: totrans-2028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localforage.clear(callback)`—移除所有键和值'
- en: '`localforage.key(index, callback)`—Get value at index'
  id: totrans-2029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localforage.key(index, callback)`—获取索引处的值'
- en: '`localforage.length(callback)`—Number of keys in localForage'
  id: totrans-2030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localforage.length(callback)`—localForage中的键的数量'
- en: 'The localForage API also includes useful additions with no web storage equivalent:'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: localForage API还包括一些没有Web存储等价的实用功能：
- en: '`localforage.keys(callback)`—Remove all keys and values'
  id: totrans-2032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localforage.keys(callback)`—移除所有键和值'
- en: '`localforage.iterate(iterator, callback)`—Iterate over keys and values'
  id: totrans-2033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localforage.iterate(iterator, callback)`—遍历键和值'
- en: 8.14.4\. Reading and writing
  id: totrans-2034
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.14.4\. 读取和写入
- en: The localForage API supports both promises and Node’s error-first callback convention.
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: localForage API支持promise和Node的错误优先回调约定。
- en: Listing 8.28\. Comparison of getting data with localStorage vs. localForage
  id: totrans-2036
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.28\. 使用localStorage与localForage获取数据的比较
- en: '![](Images/08lis28_alt.jpg)'
  id: totrans-2037
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08lis28_alt.jpg)'
- en: 'Under the hood, localForage utilizes the best storage mechanism available in
    the current browser environment. If IndexedDB is available, localForage will use
    that. Otherwise, it’ll try to fall back to WebSQL or even using web storage if
    required. You can configure the order in which the stores will be tried and even
    blacklist certain options:'
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，localForage利用当前浏览器环境中可用的最佳存储机制。如果IndexedDB可用，localForage将使用它。否则，它将尝试回退到WebSQL，甚至在需要时使用Web存储。您可以配置尝试存储的顺序，甚至可以黑名单某些选项：
- en: '![](Images/p0221_01_alt.jpg)'
  id: totrans-2039
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0221_01_alt.jpg)'
- en: 'Unlike localStorage, localForage isn’t limited to storing just strings. It
    supports most JavaScript primitives such as arrays and objects, as well as binary
    data types: `Typed-Arrays`, `ArrayBuffers`, and `Blobs`. Note that IndexedDB is
    the only back end that can store binary data natively: the WebSQL and localStorage
    back ends will incur marshalling overheads:'
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: 与localStorage不同，localForage不仅限于存储字符串。它支持大多数JavaScript原语，如数组和对象，以及二进制数据类型：`Typed-Arrays`、`ArrayBuffers`和`Blobs`。请注意，IndexedDB是唯一可以原生存储二进制数据的后端：WebSQL和localStorage后端将产生序列化开销：
- en: '[PRE243]'
  id: totrans-2041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Mirroring the web storage APIs makes localForage intuitive to use, while also
    overcoming many of the shortcomings and compatibility issues when trying to store
    data in the browser.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 通过镜像Web存储API，localForage的使用直观，同时也克服了在浏览器中存储数据时许多缺点和兼容性问题。
- en: 8.15\. Hosted storage
  id: totrans-2043
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.15\. 托管存储
- en: Hosted storage is another tactic you can use to avoid managing your own server-side
    storage. Hosted infrastructure services such as those provided by Amazon Web Services
    (AWS) are often considered as only a scaling and performance optimization, but
    smart usage of hosted services early on can save a lot of time implementing unnecessary
    infrastructure poorly.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: 托管存储是你可以用来避免管理自己的服务器端存储的另一种策略。由亚马逊网络服务（AWS）等提供的主机基础设施服务通常被认为只是扩展和性能优化，但早期智能地使用托管服务可以节省大量时间，避免实施不必要的糟糕基础设施。
- en: Many, if not all, of the databases listed in this chapter have a hosted offering.
    Hosted services allow you to try tools quickly and even deploy publicly accessible
    production applications without the hassles of setting up your own database hosting.
    But hosting your own is becoming increasingly easy. Many cloud services provide
    prebuilt server images, loaded with all the right software and configurations
    needed to run a machine hosting the database of your choosing.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中列出的许多数据库（如果不是所有数据库）都有托管服务。托管服务允许你快速尝试工具，甚至可以部署公开可访问的生产应用程序，而无需自己设置数据库托管。但自己托管正变得越来越容易。许多云服务提供预构建的服务器镜像，其中包含了运行数据库所需的所有正确软件和配置。
- en: 8.15.1\. Simple Storage Service
  id: totrans-2046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.15.1\. 简单存储服务
- en: Amazon Simple Storage Service (S3) is a remote file-hosting service provided
    as a part of the popular AWS suite. S3 is a cost-effective means of storing and
    hosting network-accessible files. It’s a filesystem in the cloud. Using RESTful
    HTTP calls, files can be uploaded into buckets, along with up to 2 KB of metadata.
    Bucket contents can then be accessed via HTTP `GET` or the BitTorrent protocol.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊简单存储服务（S3）是作为流行的AWS套件的一部分提供的远程文件托管服务。S3是一种经济高效的存储和托管网络可访问文件的方法。它是一个云端的文件系统。使用RESTful
    HTTP调用，可以将文件上传到存储桶，同时附带最多2 KB的元数据。然后可以通过HTTP `GET`或BitTorrent协议访问存储桶内容。
- en: Buckets and their contents can be configured with various permissions, including
    time-based access. You can also specify a time to live (TTL) on bucket contents
    themselves, after which they’ll become inaccessible and be removed from your bucket.
    It’s easy to promote your S3 data up to a content delivery network (CDN). AWS
    provides the CloudFront CDN, which can be easily connected to your files and will
    be accessible with low latency from around the world.
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: 存储桶及其内容可以通过各种权限进行配置，包括基于时间的访问权限。你还可以为存储桶内容本身指定一个生存时间（TTL），在此之后，它们将变得不可访问，并从你的存储桶中删除。将你的S3数据提升到内容分发网络（CDN）非常容易。AWS提供了CloudFront
    CDN，它可以轻松连接到你的文件，并且可以从世界各地以低延迟访问。
- en: Not all data needs to be or should be stored in a database. Are there components
    of your data that could be treated as files? After you’ve generated the results
    of an expensive calculation for a user, perhaps you can push those results up
    to S3 then forever step out of the way.
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有数据都需要或应该存储在数据库中。你的数据中是否有可以作为文件处理的组件？在你为用户完成一次昂贵的计算后，也许你可以将这些结果推送到S3，然后永远退出这个环节。
- en: A common and obvious use for S3 is the hosting of user-uploaded assets such
    as images. Uploaded assets live in a temporary directory on the application machine,
    processed by using a tool such as ImageMagick to reduce the file size, and then
    uploaded to S3 for hosting to web browsers. This process can be simplified even
    further by streaming uploads directly to S3, where they can trigger further processing.
    The client-side applications can also upload to S3 directly. Some more developer-centric
    services even opt for providing absolutely zero storage, requiring users to provide
    access tokens so the application can use their S3 buckets.
  id: totrans-2050
  prefs: []
  type: TYPE_NORMAL
  zh: S3的一个常见且明显的用途是托管用户上传的资产，如图像。上传的资产存储在应用程序机器上的临时目录中，通过使用ImageMagick等工具来减小文件大小，然后上传到S3以供浏览器托管。这个过程可以通过直接将上传流式传输到S3进一步简化，在那里它们可以触发进一步的加工。客户端应用程序也可以直接上传到S3。一些更面向开发者的服务甚至选择提供绝对零存储，要求用户提供访问令牌，以便应用程序可以使用他们的S3存储桶。
- en: S3 isn’t limited to the storage of images
  id: totrans-2051
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: S3不仅限于存储图像
- en: S3 can be used to store any type of file, up to 5 terabytes in size, of any
    format. S3 works best for large blobs of data that change infrequently and need
    to be accessed as a single atom.
  id: totrans-2052
  prefs: []
  type: TYPE_NORMAL
  zh: S3可以用来存储任何类型的文件，大小最高可达5太字节，格式不限。S3最适合存储不经常更改且需要作为单个原子访问的大量数据块。
- en: Storing data in S3 steps around the complications and complexity of setting
    up and maintaining a server for the hosting and storage of files. It’s great for
    instances where writes are infrequent, large chunks of data need to be accessed
    as a single atom, and there are many reads and potentially many read locations.
  id: totrans-2053
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据存储在 S3 中可以绕过设置和维护用于文件托管和存储的服务器的复杂性和复杂性。它非常适合写入不频繁、需要作为单个原子访问大量数据，并且有多个读取和潜在多个读取位置的情况。
- en: 8.16\. Which database?
  id: totrans-2054
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.16. 哪个数据库？
- en: In this chapter, we’ve covered just a few of the many databases commonly used
    in Node applications. Successful applications can be and have been built using
    any of these databases. Within a single application, there’s not always one ideal
    data storage solution; there’s no silver bullet. Each database presents its own
    unique set of trade-offs, and it’s up to the developer to evaluate which trade-offs
    make sense for the current state of the project. A hybrid of technologies is frequently
    the most appropriate.
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只介绍了 Node 应用程序中常用的一些数据库。成功的应用程序可以使用这些数据库中的任何一个来构建。在单个应用程序中，并不总是有一个理想的数据存储解决方案；没有一劳永逸的解决方案。每个数据库都提供其独特的权衡，开发者需要评估哪些权衡对当前项目状态是有意义的。技术的混合通常是最合适的。
- en: Rather than asking, “What database should I use?” you could be asking, “How
    far can I go without using a database at all?” How much of your project can you
    build with the fewest long-lasting decisions? It’s often best to defer decisions;
    you’ll always be able to make a better decision later, when you have more information.
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是问“我应该使用哪个数据库？”，你可能会问，“完全不使用数据库我能走多远？”你能用最少的长期决策构建你项目的多少部分？通常最好推迟决策；当你有更多信息时，你总是会做出更好的决策。
- en: 8.17\. Summary
  id: totrans-2057
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.17. 摘要
- en: Both relational and NoSQL databases can be used with Node.
  id: totrans-2058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是关系型数据库还是 NoSQL 数据库，都可以与 Node 一起使用。
- en: The simple pg Node module is great for working with the SQL language.
  id: totrans-2059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的 pg Node 模块非常适合与 SQL 语言一起工作。
- en: The Knex module allows you to use several databases with Node.
  id: totrans-2060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knex 模块允许您使用 Node 与多个数据库交互。
- en: ACID is a set of properties for database transactions and ensures safety.
  id: totrans-2061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACID 是数据库事务的一组属性，确保了安全性。
- en: MongoDB is a NoSQL database that uses JavaScript.
  id: totrans-2062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 是一种使用 JavaScript 的 NoSQL 数据库。
- en: Redis is a data-structure store that can be used as a database and cache.
  id: totrans-2063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis 是一种可以作为数据库和缓存使用的数据结构存储。
- en: LevelDB is a fast key/value store by Google that maps from strings to values.
  id: totrans-2064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LevelDB 是 Google 开发的一种快速键/值存储，它将字符串映射到值。
- en: LevelDB is a modular database.
  id: totrans-2065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LevelDB 是一个模块化数据库。
- en: Web-based storage, including localForage and localStorage, can be used to save
    data in browsers.
  id: totrans-2066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于网络的存储，包括 localForage 和 localStorage，可以用于在浏览器中保存数据。
- en: Storage services, such as Amazon S3, can be used to persist data to cloud providers.
  id: totrans-2067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储服务，如 Amazon S3，可以用于将数据持久化到云服务提供商。
- en: Chapter 9\. Testing Node applications
  id: totrans-2068
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章. 测试 Node 应用程序
- en: '*This chapter covers*'
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Testing logic with Node’s assert module
  id: totrans-2070
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node 的 assert 模块测试逻辑
- en: Using other assertion libraries
  id: totrans-2071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他断言库
- en: Using Node unit-testing frameworks
  id: totrans-2072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node 单元测试框架
- en: Simulating and controlling web browsers using Node
  id: totrans-2073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node 模拟和控制网络浏览器
- en: Getting more details when tests fail
  id: totrans-2074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当测试失败时获取更多详细信息
- en: As features are added to your application, the risk of introducing bugs is increased.
    An application isn’t complete if it’s not tested, and because manual testing is
    tedious and prone to human error, automated testing has become increasingly popular
    with developers. Automated testing involves writing logic to test your code, rather
    than running through application functionality by hand.
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您应用程序功能的增加，引入错误的风险也在增加。如果一个应用程序未经测试，那么它就不完整。由于手动测试既繁琐又容易出错，因此自动测试在开发者中越来越受欢迎。自动测试涉及编写逻辑来测试你的代码，而不是手动运行应用程序的功能。
- en: If the idea of automated testing is new to you, think of it as a robot doing
    all of the boring stuff while you focus on the interesting work. Every time you
    make a change to the code, the robot ensures that bugs haven’t crept in. Although
    you may not have completed or started your first Node application yet, it’s good
    to get a handle on how to implement automated testing because you’ll be able to
    write tests as you develop.
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自动测试的概念对你来说是新的，那么你可以将其想象成一个机器人做所有无聊的工作，而你则专注于有趣的工作。每次你对代码进行更改时，机器人都会确保没有错误悄悄地进入。尽管你可能还没有完成或开始你的第一个
    Node 应用程序，但了解如何实现自动测试是很好的，因为你在开发过程中将能够编写测试。
- en: 'In this chapter, you’ll look at two types of automated testing: unit testing
    and acceptance testing. *Unit testing* is used to verify logic, typically at a
    function or method level, and it’s applicable to all types of applications. Unit-testing
    methodologies can be divided into two major forms: test-driven development (TDD)
    and behavior-driven development (BDD). Practically speaking, TDD and BDD are largely
    the same thing, but they differ stylistically. This can be important, depending
    on who needs to read your tests. Other differences between TDD and BDD exist,
    but they’re beyond the scope of this book. *Acceptance testing* is an additional
    layer of testing most commonly used for web applications. Acceptance testing involves
    scripting control of a browser and attempting to trigger web application functionality
    with it.'
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解两种类型的自动化测试：单元测试和验收测试。*单元测试* 用于验证逻辑，通常在函数或方法级别，并且适用于所有类型的应用程序。单元测试方法可以分为两种主要形式：测试驱动开发（TDD）和行为驱动开发（BDD）。从实际的角度来看，TDD
    和 BDD 在很大程度上是同一件事，但它们在风格上有所不同。这很重要，取决于谁需要阅读你的测试。TDD 和 BDD 之间的其他差异存在，但它们超出了本书的范围。*验收测试*
    是一种常用的测试层，通常用于 Web 应用程序。验收测试涉及脚本控制浏览器，并尝试使用它触发 Web 应用程序的功能。
- en: This chapter covers established solutions for both unit and acceptance testing.
    For unit testing, we cover Node’s assert module; the Mocha, Vows, and Should.js
    frameworks; and Chai. For acceptance testing, we look at using Selenium with Node.
    [Figure 9.1](#ch09fig01) places the tools alongside their respective testing methodologies
    and flavors.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了单元测试和验收测试的既定解决方案。对于单元测试，我们涵盖了 Node 的 assert 模块；Mocha、Vows 和 Should.js 框架；以及
    Chai。对于验收测试，我们探讨了使用 Selenium 与 Node 的结合。[图 9.1](#ch09fig01) 将工具放置在其各自的测试方法和风味旁边。
- en: Figure 9.1\. Test framework overview
  id: totrans-2079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 测试框架概述
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-2080
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig01_alt.jpg)'
- en: Let’s start with unit testing.
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单元测试开始。
- en: 9.1\. Unit testing
  id: totrans-2082
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 单元测试
- en: '*Unit testing* is a type of automated testing in which you write logic to test
    discrete parts of your application. Writing tests helps you think more critically
    about your application design choices and helps you avoid pitfalls early on. The
    tests also give you confidence that your recent changes haven’t introduced errors.
    Although unit tests take a bit of work up front to write, they can save you time
    by lessening the need to manually retest every time you make a change to an application.'
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试* 是一种自动化测试类型，其中你编写逻辑来测试应用程序的离散部分。编写测试有助于你更批判性地思考应用程序的设计选择，并帮助你早期避免陷阱。测试还让你对自己的最近更改没有引入错误充满信心。尽管单元测试在编写时需要一些前期工作，但它们可以通过减少每次更改应用程序时手动重新测试的需要来节省你的时间。'
- en: Unit testing can be tricky, and testing asynchronous logic can present its own
    challenges. Asynchronous unit tests can run in parallel, so you have to be careful
    to ensure that tests don’t interfere with each other. For example, if your tests
    create temporary files on disk, you have to be careful that when you delete the
    files after a test, you don’t delete the working files of another test that hasn’t
    yet finished. For this reason, many unit-testing frameworks include flow control
    to sequence the running of tests.
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可能很棘手，测试异步逻辑可能也会带来自己的挑战。异步单元测试可以并行运行，因此你必须小心确保测试不会相互干扰。例如，如果你的测试在磁盘上创建临时文件，你必须小心，在测试后删除文件时，不要删除尚未完成的另一个测试的工作文件。因此，许多单元测试框架包括流程控制来序列化测试的运行。
- en: 'In this section, we show you how to use the following:'
  id: totrans-2085
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何使用以下内容：
- en: '***Node’s built-in assert module—*** A good building block for TDD-style automated
    testing'
  id: totrans-2086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Node 的内置 assert 模块—*** TDD 风格自动化测试的良好构建块'
- en: '***Mocha—*** A relatively new testing framework that can be used for TDD- or
    BDD-style testing'
  id: totrans-2087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Mocha—*** 一个相对较新的测试框架，可用于 TDD 或 BDD 风格的测试'
- en: '***Vows—*** A widely used BDD-style testing framework'
  id: totrans-2088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Vows—*** 一个广泛使用的 BDD 风格测试框架'
- en: '***Should.js—*** A module that builds on Node’s assert module to provide BDD-style
    assertions'
  id: totrans-2089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Should.js—*** 一个模块，它基于 Node 的 assert 模块来提供 BDD 风格的断言'
- en: The next section demonstrates how to test business logic with the assert module,
    which is included with Node.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将演示如何使用与 Node 一起提供的 assert 模块测试业务逻辑。
- en: 9.1.1\. The assert module
  id: totrans-2091
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. assert 模块
- en: The basis for most Node unit testing is the built-in assert module, which tests
    a condition and, if the condition isn’t met, throws an error. Node’s assert module
    is used by many third-party testing frameworks. Even without a testing framework,
    you can do useful testing with it. If you’re trying out a quick idea, you can
    use the assert module by itself to write a quick test.
  id: totrans-2092
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Node单元测试的基础是内置的assert模块，它测试一个条件，如果条件不满足，则抛出错误。Node的assert模块被许多第三方测试框架使用。即使没有测试框架，您也可以使用它进行有用的测试。如果您正在尝试快速的想法，您可以使用assert模块本身来编写快速测试。
- en: A simple example
  id: totrans-2093
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: Suppose you have a simple to-do application that stores items in memory, and
    you want to assert that it’s doing what you think it’s doing.
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个简单的待办事项应用，它将项目存储在内存中，并且您想断言它正在做您认为它正在做的事情。
- en: The following listing defines a module containing the core application functionality.
    Module logic supports creating, retrieving, and deleting to-do items. It also
    includes a simple `doAsync` method, so you can look at testing asynchronous methods
    too. Save this file as todo.js.
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表定义了一个包含核心应用功能的模块。模块逻辑支持创建、检索和删除待办事项。它还包括一个简单的`doAsync`方法，因此您还可以查看测试异步方法。将此文件保存为todo.js。
- en: Listing 9.1\. A model for a to-do list
  id: totrans-2096
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. 待办事项列表的模型
- en: '![](Images/09lis01_alt.jpg)'
  id: totrans-2097
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09lis01_alt.jpg)'
- en: Now you can use Node’s assert module to test the code. In a file called test.js,
    enter the following code to load the necessary modules, set up a new to-do list,
    and set a variable that tracks the number of completed tests.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用Node的assert模块来测试代码。在一个名为test.js的文件中，输入以下代码以加载必要的模块，设置一个新的待办事项列表，并设置一个跟踪完成测试数量的变量。
- en: Listing 9.2\. Set up necessary modules
  id: totrans-2099
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 设置必要的模块
- en: '[PRE244]'
  id: totrans-2100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Using equal to test the contents of a variable
  id: totrans-2101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用等于测试变量的内容
- en: Next, you can add a test of the to-do application’s delete functionality. Add
    the function in the following listing to the end of test.js.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以添加对待办事项应用删除功能的测试。将以下列表中的函数添加到test.js的末尾。
- en: Listing 9.3\. Test to make sure that no to-do items remain after deletion
  id: totrans-2103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3\. 确保删除后没有待办事项剩余
- en: '![](Images/09lis03_alt.jpg)'
  id: totrans-2104
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09lis03_alt.jpg)'
- en: This test adds a `todo` item and then deletes it. Because there should be no
    to-dos at the end of this test, the value of `todo.length` should be `0` if the
    application logic is working properly. If a problem occurs, an exception is thrown.
    If the value returned by `todo.length` isn’t set to `0`, the assertion will result
    in a stack trace showing an error message, “No items should exist,” outputted
    to the console. After the assertion, `testsCompleted` is incremented to note that
    a test has completed.
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试添加一个`todo`项然后删除它。因为在这个测试结束时应该没有待办事项，所以如果应用逻辑正常工作，`todo.length`的值应该是`0`。如果出现问题，将抛出异常。如果`todo.length`返回的值没有设置为`0`，断言将导致显示错误消息“不应该存在任何项”的堆栈跟踪输出到控制台。在断言之后，`testsCompleted`增加以记录一个测试已完成。
- en: Using notEqual to find problems in logic
  id: totrans-2106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用notEqual查找逻辑中的问题
- en: Next, add the code in the following listing to test.js. This code is a test
    of the to-do application’s add functionality.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下列表中的代码添加到test.js中。此代码是对待办事项应用添加功能的测试。
- en: Listing 9.4\. Test to make sure adding a to-do works
  id: totrans-2108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.4\. 确保添加待办事项的测试
- en: '![](Images/09lis04_alt.jpg)'
  id: totrans-2109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09lis04_alt.jpg)'
- en: The assert module also allows `notEqual` assertions. This type of assertion
    is useful when the generation of a certain value by application code indicates
    a problem in logic. [Listing 9.4](#ch09ex04) shows the use of a `notEqual` assertion.
    All to-do items are deleted, an item is added, and the application logic then
    gets all items. If the number of items is `0`, the assertion will fail and an
    exception will be thrown.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: assert模块还允许`notEqual`断言。这种断言在应用程序代码生成特定值时指示逻辑问题很有用。[列表9.4](#ch09ex04)显示了`notEqual`断言的使用。删除所有待办事项，添加一个项，然后应用逻辑获取所有项。如果项的数量是`0`，断言将失败并抛出异常。
- en: 'Using additional functionality: strictEqual, notStrictEqual, deep- pEqual,
    notDeepEqual'
  id: totrans-2111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用附加功能：strictEqual，notStrictEqual，deep- pEqual，notDeepEqual
- en: In addition to `equal` and `notEqual` functionality, the assert module offers
    strict versions of assertions called `strictEqual` and `notStrictEqual`. These
    use the strict equality operator (`===`) rather than the more permissive version
    (`==`).
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`equal`和`notEqual`功能外，assert模块还提供了称为`strictEqual`和`notStrictEqual`的严格断言版本。这些使用严格相等运算符(`===`)而不是更宽容的版本(`==`)。
- en: To compare objects, the assert module offers `deepEqual` and `notDeepEqual`.
    The *deep* in the names of these assertions indicates that they recursively compare
    two objects, comparing two object’s properties, and if the properties are themselves
    objects, comparing these as well.
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较对象，assert模块提供了`deepEqual`和`notDeepEqual`。这些断言名称中的`deep`表示它们会递归地比较两个对象，比较两个对象的属性，如果属性本身也是对象，则也会进行比较。
- en: Using ok to test for an asynchronous value being true
  id: totrans-2114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`ok`测试异步值是否为真
- en: Now it’s time to add a test of the to-do application’s `doAsync` method, as
    shown in [listing 9.5](#ch09ex05). Because this is an asynchronous test, you’re
    providing a callback function (`cb`) to signal to the test runner when the test
    has completed; you can’t rely on the function returning to tell you, as you can
    with synchronous tests. To see whether the result of `doAsync` is the value `true`,
    use the `ok` assertion. The `ok` assertion provides an easy way to test a value
    for being `true`.
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加对待办应用`doAsync`方法的测试了，如[列表9.5](#ch09ex05)所示。因为这是一个异步测试，你需要提供一个回调函数（`cb`）来通知测试运行器测试何时完成；你不能像同步测试那样依赖函数返回来告诉你，因为同步测试可以这样做。为了检查`doAsync`的结果是否为值`true`，使用`ok`断言。`ok`断言提供了一个简单的方式来测试一个值是否为`true`。
- en: Listing 9.5\. Test whether the `doAsync` callback is passed `true`
  id: totrans-2116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.5\. 测试`doAsync`回调是否传递了`true`
- en: '![](Images/09lis05_alt.jpg)'
  id: totrans-2117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09lis05_alt.jpg)'
- en: Testing that thrown errors are correct
  id: totrans-2118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试抛出的错误是否正确
- en: You can also use the assert module to check that thrown error messages are correct,
    as the following listing shows. The second argument in the `throws` call is a
    regular expression that looks for the text *requires* in the error message.
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用assert模块来检查抛出的错误消息是否正确，如下面的列表所示。`throws`调用中的第二个参数是一个正则表达式，用于在错误消息中查找文本`requires`。
- en: Listing 9.6\. Test whether `add` throws when missing a parameter
  id: totrans-2120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6\. 测试`add`在缺少参数时是否抛出异常
- en: '![](Images/09lis06_alt.jpg)'
  id: totrans-2121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09lis06_alt.jpg)'
- en: Adding logic to run your tests
  id: totrans-2122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加逻辑来运行你的测试
- en: Now that you’ve defined the tests, you can add logic to the file to run each
    of the tests. The logic in the following listing runs each test, and then prints
    the number of tests that were run and completed.
  id: totrans-2123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了测试，你可以在文件中添加逻辑来运行每个测试。以下列表中的逻辑运行每个测试，然后打印已运行和完成的测试数量。
- en: Listing 9.7\. Running the tests and reporting test completion
  id: totrans-2124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7\. 运行测试并报告测试完成
- en: '![](Images/09lis07_alt.jpg)'
  id: totrans-2125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09lis07_alt.jpg)'
- en: 'You can run the tests with the following command:'
  id: totrans-2126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令运行测试：
- en: '[PRE245]'
  id: totrans-2127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: If the tests don’t fail, the script informs you of the number of tests completed.
    It also can be smart to keep track of when tests start execution as well as when
    they complete, to protect against flaws in individual tests. For example, a test
    may execute without reaching the assertion.
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试没有失败，脚本会告诉你已完成的测试数量。它还可以智能地跟踪测试何时开始执行以及何时完成，以防止单个测试中的缺陷。例如，一个测试可能执行而没有达到断言。
- en: In order to use Node’s built-in functionality, each test case has to include
    a lot of boilerplate to set up the test (such as deleting all items) and to keep
    track of progress (the `completed` counter). All this boilerplate shifts the focus
    away from the primary concern of writing test cases, and it’s better left to a
    dedicated framework that can do the heavy lifting while you focus on testing business
    logic. Let’s look at making things easier by using Mocha, a third-party unit-testing
    framework.
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Node的内置功能，每个测试用例都必须包含大量的样板代码来设置测试（例如删除所有项目）以及跟踪进度（`completed`计数器）。所有这些样板代码都将注意力从编写测试用例的主要关注点转移开，最好留给一个专门的框架来做这些繁重的工作，而你则专注于测试业务逻辑。让我们看看如何通过使用第三方单元测试框架Mocha来简化事情。
- en: 9.1.2\. Mocha
  id: totrans-2130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. Mocha
- en: '*Mocha*, a popular testing framework, is easy to grasp. Although it defaults
    to a BDD style, you can also use it in a TDD style. Mocha has a wide variety of
    features, including global variable leak detection and client-side testing.'
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mocha**，一个流行的测试框架，易于掌握。尽管它默认使用BDD风格，但你也可以用它来使用TDD风格。Mocha具有许多功能，包括全局变量泄漏检测和客户端测试。'
- en: '|  |'
  id: totrans-2132
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Global variable leak detection**'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局变量泄漏检测**'
- en: You should have little need for global variables that are readable application-wide,
    and it’s considered a programming best practice to minimize your use of them.
    But in ES5, it’s easy to inadvertently create global variables by forgetting to
    include the `var` keyword when declaring a variable. Mocha helps detect accidental
    global variable leaks by throwing an error when you create a global variable during
    testing.
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少需要可读的全局变量，并且将它们的使用量最小化被认为是编程的最佳实践。但在 ES5 中，很容易忘记在声明变量时包含 `var` 关键字而意外创建全局变量。Mocha
    通过在测试期间创建全局变量时抛出错误来帮助检测意外的全局变量泄漏。
- en: If you want to disable global leak detection, run `mocha` with the `--ignored-leaks`
    command-line option. Alternatively, if you want to allow a select number of globals
    to be used, you can specify them by using the `--globals` command-line option
    followed by a comma-delimited list of allowable global variables.
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要禁用全局泄漏检测，请使用 `--ignored-leaks` 命令行选项运行 `mocha`。或者，如果你想允许使用选定数量的全局变量，你可以通过使用
    `--globals` 命令行选项后跟一个逗号分隔的允许的全局变量列表来指定它们。
- en: '|  |'
  id: totrans-2136
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: By default, Mocha tests are defined and their logic is set up by using BDD-flavored
    functions called `describe`, `it`, `before`, `after`, `beforeEach`, and `afterEach`.
    Alternatively, you can use Mocha’s TDD interface, which replaces the use of `describe`
    with `suite`, `it` with `test`, `before` with `setup`, and `after` with `teardown`.
    For our example, you’ll stick with the default BDD interface.
  id: totrans-2137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Mocha 测试是通过使用名为 `describe`、`it`、`before`、`after`、`beforeEach` 和 `afterEach`
    的 BDD 风格函数来定义和设置其逻辑的。或者，你也可以使用 Mocha 的 TDD 接口，它用 `suite` 替换 `describe`，用 `test`
    替换 `it`，用 `setup` 替换 `before`，用 `teardown` 替换 `after`。在我们的例子中，你将坚持使用默认的 BDD 接口。
- en: Testing Node applications with Mocha
  id: totrans-2138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Mocha 测试 Node 应用程序
- en: 'Let’s dive right in and see how to create a small project called *memdb*—a
    small in-memory database—and use Mocha to test it. First, you need to create the
    directories and files for the project:'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接深入探讨如何创建一个名为 *memdb* 的小型项目——一个内存数据库，并使用 Mocha 来测试它。首先，你需要为项目创建目录和文件：
- en: '[PRE246]'
  id: totrans-2140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Open package.json and add a `scripts` property that defines how the tests are
    run:'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 package.json 并添加一个 `scripts` 属性，该属性定义了如何运行测试：
- en: '[PRE247]'
  id: totrans-2142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: The *test* directory is where the tests will live. By default, Mocha uses the
    BDD interface. The following listing shows what it looks like (chapter09-testing/memdb
    in the book’s sample code).
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: '*test* 目录是测试将驻留的地方。默认情况下，Mocha 使用 BDD 接口。以下列表显示了它的样子（本书示例代码中的 chapter09-testing/memdb）。'
- en: Listing 9.8\. Basic structure for a Mocha test
  id: totrans-2144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8\. Mocha 测试的基本结构
- en: '[PRE248]'
  id: totrans-2145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'Mocha also supports TDD and qunit, and exports style interfaces, which are
    detailed on the project’s site ([https://mochajs.org/](https://mochajs.org/)).
    To illustrate the concept of interfaces, here’s the `exports` interface:'
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 还支持 TDD 和 qunit，并导出样式接口，这些接口在项目网站上详细说明（[https://mochajs.org/](https://mochajs.org/)）。为了说明接口的概念，这里有一个
    `exports` 接口：
- en: '[PRE249]'
  id: totrans-2147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: All of these interfaces provide the same functionality, but for now you’ll stick
    to the BDD interface and write the first test, shown in the following listing,
    in test/memdb.js. This test uses Node’s assert module to perform the assertions.
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些接口都提供相同的功能，但你现在将坚持使用 BDD 接口，并在 test/memdb.js 中编写第一个测试，如下所示。这个测试使用 Node 的
    assert 模块来执行断言。
- en: Listing 9.9\. Describing the memdb `.save` functionality
  id: totrans-2149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. 描述 memdb 的 `.save` 功能
- en: '![](Images/09lis09_alt.jpg)'
  id: totrans-2150
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9.09](Images/09lis09_alt.jpg)'
- en: To run the tests, all you need to do is execute `npm test`. Mocha looks in the
    ./test directory by default for JavaScript files to execute. Because you haven’t
    implemented the `.saveSync()` method yet, you’ll see that the single defined test
    fails, as shown in [figure 9.2](#ch09fig02).
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，你只需要执行 `npm test`。Mocha 默认在 ./test 目录中查找要执行的 JavaScript 文件。因为你还没有实现 `.saveSync()`
    方法，所以你会看到定义的单个测试失败，如图 9.2 所示。
- en: Figure 9.2\. Failing test in Mocha
  id: totrans-2152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.2\. Mocha 中的失败测试
- en: '![](Images/09fig02_alt.jpg)'
  id: totrans-2153
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9.2](Images/09fig02_alt.jpg)'
- en: Let’s make it pass! Add the code in the following listing to index.js.
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: 让它通过！将以下列表中的代码添加到 index.js 中。
- en: Listing 9.10\. Added save functionality
  id: totrans-2155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.10\. 添加了保存功能
- en: '![](Images/09lis10_alt.jpg)'
  id: totrans-2156
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9.10](Images/09lis10_alt.jpg)'
- en: Run the tests again with npm, and the results should be similar to [figure 9.3](#ch09fig03).
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 npm 运行测试，结果应该类似于 [图 9.3](#ch09fig03)。
- en: Figure 9.3\. Successful test in Mocha
  id: totrans-2158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3\. Mocha 中的成功测试
- en: '![](Images/09fig03_alt.jpg)'
  id: totrans-2159
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9.3](Images/09fig03_alt.jpg)'
- en: Defining setup and cleanup logic by using Mocha hooks
  id: totrans-2160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Mocha 钩子定义设置和清理逻辑
- en: The test case in [listing 9.10](#ch09ex10) makes the assumption that `memdb.first()`
    works correctly, so you’ll want to add a few test cases for that as well. The
    revised test file, [listing 9.11](#ch09ex11), includes a new concept—the concept
    of Mocha *hooks*. The BDD interface exposes `beforeEach()`, `afterEach()`, `before()`,
    and `after()`, which take callbacks for defining setup and cleanup logic.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.10](#ch09ex10) 中的测试用例假设 `memdb.first()` 正确工作，因此你也会想为它添加一些测试用例。修订后的测试文件，[列表
    9.11](#ch09ex11)，包括了一个新概念——Mocha 的 *钩子* 概念。BDD 接口暴露了 `beforeEach()`、`afterEach()`、`before()`
    和 `after()`，它们接受回调来定义设置和清理逻辑。'
- en: Listing 9.11\. Adding a `beforeEach` hook
  id: totrans-2162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.11\. 添加 `beforeEach` 钩子
- en: '![](Images/ch09ex11-0.jpg)'
  id: totrans-2163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch09ex11-0.jpg)'
- en: '![](Images/ch09ex11-1.jpg)'
  id: totrans-2164
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch09ex11-1.jpg)'
- en: 'Ideally, test cases share no state whatsoever. To achieve this with memdb,
    you need to remove all the documents by implementing the `.clear()` method in
    index.js:'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，测试用例没有任何共享状态。为了在 memdb 中实现这一点，你需要通过在 index.js 中实现 `.clear()` 方法来删除所有文档：
- en: '[PRE250]'
  id: totrans-2166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Running Mocha again should show you that three tests have passed.
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 Mocha 应该会显示有三个测试通过了。
- en: Testing asynchronous logic
  id: totrans-2168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试异步逻辑
- en: 'One thing we haven’t yet looked at in Mocha is testing asynchronous logic.
    To see how this is done, you’ll make a small change to one of the functions defined
    earlier in index.js. By changing the `save` function to the following, a callback
    can be optionally provided that will execute after a small delay (meant to simulate
    some sort of asynchronous operation):'
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Mocha 中还没有看到的是测试异步逻辑。为了了解这是如何完成的，你将对 index.js 中定义的其中一个函数进行小的修改。通过将 `save`
    函数更改为以下内容，可以可选地提供一个回调，该回调将在一小段时间后执行（用于模拟某种异步操作）：
- en: '[PRE251]'
  id: totrans-2170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Mocha test cases can be defined as asynchronous by adding an argument to a function
    defining testing logic. The argument is commonly named `done`. The following listing
    shows how to write a test for the asynchronous `save` method.
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 测试用例可以通过向定义测试逻辑的函数添加一个参数来定义为异步。该参数通常命名为 `done`。以下列表展示了如何编写异步 `save` 方法的测试。
- en: Listing 9.12\. Testing asynchronous logic
  id: totrans-2172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.12\. 测试异步逻辑
- en: '![](Images/09lis12_alt.jpg)'
  id: totrans-2173
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09lis12_alt.jpg)'
- en: 'This same rule applies to all of the hooks. For example, the `beforeEach()`
    hook to clear the database could add a callback, and Mocha could wait until it’s
    called in order to move on. If `done()` is invoked with an error as the first
    argument, Mocha will report the error and mark the hook or test case as a failure:'
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则适用于所有钩子。例如，用于清除数据库的 `beforeEach()` 钩子可以添加一个回调，Mocha 将等待它被调用，然后继续。如果 `done()`
    以错误作为第一个参数被调用，Mocha 将报告错误并将钩子或测试用例标记为失败：
- en: '[PRE252]'
  id: totrans-2175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'For more about Mocha, check out its full online documentation: [http://mochajs.org](http://mochajs.org).
    Mocha also works for client-side JavaScript.'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Mocha 的信息，请查看其完整的在线文档：[http://mochajs.org](http://mochajs.org)。Mocha 也可以用于客户端
    JavaScript。
- en: '|  |'
  id: totrans-2177
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Mocha’s use of nonparallel testing**'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mocha 的非并行测试使用**'
- en: Mocha executes tests one after another rather than in parallel, which makes
    test suites execute more slowly but makes writing tests easier. But Mocha won’t
    let any test run for an inordinately long time. Mocha, by default, allows any
    given test to run for only 2,000 milliseconds before failing it. If you have tests
    that take longer, you can run Mocha with the `--timeout` command-line option and
    then specify a larger number.
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha 按顺序执行测试，而不是并行执行，这使得测试套件执行得更慢，但编写测试更容易。但 Mocha 不会让任何测试运行过长时间。默认情况下，Mocha
    允许任何给定的测试运行最多 2,000 毫秒，然后将其标记为失败。如果你有运行时间较长的测试，你可以使用 `--timeout` 命令行选项运行 Mocha，然后指定一个更大的数字。
- en: For most testing, running tests serially is fine. If you find this problematic,
    other frameworks, such as Vows, execute in parallel, and are covered in the next
    section.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数测试，串行运行测试是可行的。如果你发现这有问题，其他框架，如 Vows，可以并行执行，这将在下一节中介绍。
- en: '|  |'
  id: totrans-2181
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.1.3\. Vows
  id: totrans-2182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. Vows
- en: The tests you can write using the Vows unit-testing framework are more structured
    than those of many other frameworks, with the structure intended to make the tests
    easy to read and maintain.
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vows 单元测试框架可以编写的测试用例比许多其他框架的结构更清晰，这种结构旨在使测试易于阅读和维护。
- en: Vows uses its own BDD-flavored terminology to define test structure. In the
    realm of Vows, a test suite contains one or more batches. A *batch* can be thought
    of as a group of related *contexts*, or conceptual areas of concern that you want
    to test. The batches and contexts run in parallel. A context may contain a *topic*,
    one or more *vows*, and/or one or more related contexts (inner contexts also run
    in parallel). A *topic* is testing logic that’s related to a context. A *vow*
    is a test of the result of a topic. [Figure 9.4](#ch09fig04) shows how Vows structures
    tests.
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: Vows使用自己的BDD风格的术语来定义测试结构。在Vows的领域里，一个测试套件包含一个或多个批次。一个*批次*可以被视为一组相关的*上下文*，或者您想要测试的概念性关注区域。批次和上下文并行运行。一个上下文可能包含一个*主题*、一个或多个*誓言*和/或一个或多个相关上下文（内部上下文也并行运行）。一个*主题*是与上下文相关的测试逻辑。一个*誓言*是对主题结果的测试。[图9.4](#ch09fig04)显示了Vows如何结构测试。
- en: Figure 9.4\. Vows can structure tests in a suite using batches, contexts, topics,
    and vows.
  id: totrans-2185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. Vows可以使用批次、上下文、主题和誓言来结构测试套件。
- en: '![](Images/09fig04.jpg)'
  id: totrans-2186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig04.jpg)'
- en: Vows, like Mocha, is geared toward automated application testing. The difference
    is primarily in flavor and parallelism, with Vows tests requiring a specific structure
    and terminology. In this section, we run through an example application test and
    explain how to use a Vows test to run multiple tests at the same time.
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: Vows，就像Mocha一样，旨在自动化应用程序测试。主要区别在于风味和并行性，Vows测试需要特定的结构和术语。在本节中，我们将通过一个示例应用程序测试来解释如何使用Vows测试同时运行多个测试。
- en: 'Add Vows to the to-do project by installing it using npm:'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用npm安装来将Vows添加到待办事项项目中：
- en: '[PRE253]'
  id: totrans-2189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'You need to add Vows to the test property in package.json so you can run the
    tests by typing `npm test`:'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将Vows添加到package.json中的测试属性，以便可以通过输入`npm test`来运行测试：
- en: '[PRE254]'
  id: totrans-2191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Testing application logic with Vows
  id: totrans-2192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Vows测试应用程序逻辑
- en: You can trigger testing in Vows either by running a script containing test logic
    or by using the `vows` command-line test runner. The following example of a standalone
    test script (which can be run like any other Node script) uses one of the tests
    of the to-do application’s core logic.
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行包含测试逻辑的脚本或使用`vows`命令行测试运行器来在Vows中触发测试。以下是一个独立测试脚本的示例（可以像其他任何Node脚本一样运行），它使用了待办事项应用程序核心逻辑的一个测试。
- en: '[Listing 9.13](#ch09ex13) creates a batch. Within the batch, you define a context.
    Within the context, you define a topic and a vow. Note how the code uses the callback
    to deal with asynchronous logic in the topic. If a topic isn’t asynchronous, a
    value can be returned rather than being sent via a callback. Save the file as
    test/todo-test.js.'
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.13](#ch09ex13) 创建了一个批次。在批次内，您定义一个上下文。在上下文中，您定义一个主题和一个誓言。注意代码如何使用回调来处理主题中的异步逻辑。如果一个主题不是异步的，则可以返回一个值，而不是通过回调发送。将文件保存为test/todo-test.js。'
- en: Listing 9.13\. Using Vows to test the to-do application
  id: totrans-2195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.13\. 使用Vows测试待办事项应用程序
- en: '![](Images/09lis13_alt.jpg)'
  id: totrans-2196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09lis13_alt.jpg)'
- en: 'You should be able to run this test by typing `npm test`. If you install Vows
    globally with `npm i -g vows`, you can also run all tests in a folder named *test*
    by entering the following command:'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够通过输入`npm test`来运行此测试。如果您使用`npm i -g vows`全局安装Vows，您还可以通过输入以下命令来运行名为*test*的文件夹中的所有测试：
- en: '[PRE255]'
  id: totrans-2198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: For more about Vows, check out the project’s online documentation ([http://vowsjs.org/](http://vowsjs.org/)),
    as shown in [figure 9.5](#ch09fig05).
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Vows的信息，请查看项目的在线文档([http://vowsjs.org/](http://vowsjs.org/))，如图9.5所示。
- en: Figure 9.5\. Vows combines full-featured BDD testing with macros and flow control.
  id: totrans-2200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5\. Vows结合了具有宏和流程控制的完整功能BDD测试。
- en: '![](Images/09fig05_alt.jpg)'
  id: totrans-2201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig05_alt.jpg)'
- en: Vows offers a comprehensive testing solution, but you can mix and match test
    library features by using a different assertion library. Perhaps you like Mocha
    but don’t like Node’s assertion library. The next section introduces Chai, an
    assertion library that you can use in place of Node’s assert module.
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: Vows提供了一套全面的测试解决方案，但您可以通过使用不同的断言库来混合和匹配测试库功能。也许你喜欢Mocha，但不喜欢Node的断言库。下一节介绍了Chai，这是一个可以替代Node
    assert模块的断言库。
- en: 9.1.4\. Chai
  id: totrans-2203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4\. 茶叶
- en: '*Chai* ([http://chaijs.com/](http://chaijs.com/)) is a popular assertion library
    that comes with three interfaces: *should*, *expect*, and *assert*. The `assert`
    interface, shown in the following listing, looks like Node’s built-in assertion
    module, but it comes with useful tools for comparing objects, arrays, and their
    properties. For example, `typeOf` can be used to compare types, and `property`
    checks that an object has the desired property.'
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: '*Chai* ([http://chaijs.com/](http://chaijs.com/)) 是一个流行的断言库，它提供了三个接口：*should*、*expect*
    和 *assert*。下面的列表中展示了 `assert` 接口，它看起来像 Node 的内置断言模块，但它提供了比较对象、数组和它们的属性的有用工具。例如，`typeOf`
    可以用来比较类型，而 `property` 检查对象是否具有所需的属性。'
- en: Listing 9.14\. Chai’s `assert` interface
  id: totrans-2205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.14\. Chai 的 `assert` 接口
- en: '![](Images/09lis14_alt.jpg)'
  id: totrans-2206
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09lis14_alt.jpg)'
- en: 'The main reason you might want to try Chai is the `should` and `expect` interfaces.
    They provide fluent APIs that are more like BDD-style libraries. Here’s the `expect`
    interface:'
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要尝试 Chai 的主要原因是 `should` 和 `expect` 接口。它们提供了流畅的 API，更像是 BDD 风格的库。以下是 `expect`
    接口：
- en: '[PRE256]'
  id: totrans-2208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'This API reads more like an English sentence—the declarative style is more
    verbose but easier to read aloud. The `should` interface switches this around:
    objects are decorated to have extra properties, so you don’t need to wrap assertions
    in a call as with `expect`:'
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 API 读起来更像一个英文句子——声明式风格更冗长，但更容易朗读。`should` 接口则相反：对象被装饰以具有额外的属性，因此你不需要像 `expect`
    那样在调用中包裹断言：
- en: '[PRE257]'
  id: totrans-2210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Deciding which interface to use depends on the project. If you’re writing tests
    first and using them to document the project, the verbose `expect` and `should`
    interfaces will work well. JavaScript purists prefer `expect` because it doesn’t
    change prototypes, but those with Ruby experience may be familiar with APIs such
    as `should`.
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用哪个接口取决于项目。如果你是先编写测试，然后使用它们来记录项目，那么详尽的 `expect` 和 `should` 接口将工作得很好。JavaScript
    纯粹主义者更喜欢 `expect`，因为它不会改变原型，但那些有 Ruby 经验的人可能熟悉 `should` 这样的 API。
- en: The main advantage of using Chai is the range of plugins. This includes handy
    things such as chai-as-promised ([http://chaijs.com/plugins/chai-as-promised/](http://chaijs.com/plugins/chai-as-promised/)),
    which helps test code that uses promises, and chai-stats ([http://chaijs.com/plugins/chai-stats/](http://chaijs.com/plugins/chai-stats/)),
    a library for comparing numbers according to statistical methods. Note that Chai
    is an assertion library, so you should use it alongside a test runner like Mocha.
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chai 的主要优势是插件的范围。这包括一些方便的工具，如 chai-as-promised ([http://chaijs.com/plugins/chai-as-promised/](http://chaijs.com/plugins/chai-as-promised/))，它有助于测试使用
    promises 的代码，以及 chai-stats ([http://chaijs.com/plugins/chai-stats/](http://chaijs.com/plugins/chai-stats/))，这是一个根据统计方法比较数字的库。请注意，Chai
    是一个断言库，因此你应该与像 Mocha 这样的测试运行器一起使用。
- en: Another BDD assertion library like Chai is Should.js. The next section introduces
    Should.js and demonstrates how to write tests with it.
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Chai 类似的另一个 BDD 断言库是 Should.js。下一节将介绍 Should.js 并演示如何使用它编写测试。
- en: 9.1.5\. Should.js
  id: totrans-2214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.5\. Should.js
- en: Should.js is an assertion library that can help make your tests easier to read
    by allowing you to express assertions in a BDD-like style. It’s designed to be
    used in conjunction with other testing frameworks, which lets you continue to
    use your own preferred framework. In this section, you’ll learn how to write assertions
    with Should.js and, as an example, you’ll write a test for a custom module.
  id: totrans-2215
  prefs: []
  type: TYPE_NORMAL
  zh: Should.js 是一个断言库，它允许你以 BDD（行为驱动开发）风格表达断言，从而使你的测试更容易阅读。它设计用于与其他测试框架一起使用，这样你就可以继续使用你自己的首选框架。在本节中，你将学习如何使用
    Should.js 编写断言，并以一个自定义模块的测试为例。
- en: 'Should.js is easy to use with other frameworks because it augments `Object.
    --proto-type` with a single property: `should`. This allows you to write expressive
    assertions such as `user.role.should.equal(''admin'')`, or `users.should.include
    (''rick'')`.'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: Should.js 与其他框架易于使用，因为它通过单个属性 `should` 增强了 `Object. --proto-type`。这允许你编写如 `user.role.should.equal('admin')`
    或 `users.should.include ('rick')` 这样的表达性断言。
- en: Let’s say you’re writing a Node command-line tip calculator that you want to
    use to figure out who should pay what amount when you split a bill with friends.
    You’d like to write tests for your calculation logic in a way that’s easily understood
    by your nonprogrammer friends, because then they won’t think you’re cheating them.
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个 Node 命令行小费计算器，你希望用它来确定当你和朋友分账时谁应该支付多少钱。你希望以易于你的非程序员朋友理解的方式编写你的计算逻辑的测试，因为这样他们就不会认为你在欺骗他们。
- en: 'To set up your tip calculator application, enter the following commands, which
    set up a folder for the application, and then install Should.js for testing:'
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置小费计算器应用程序，输入以下命令，这些命令设置应用程序的文件夹，然后安装Should.js进行测试：
- en: '[PRE258]'
  id: totrans-2219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'Now you can install Should.js by running the following commands:'
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过运行以下命令来安装Should.js：
- en: '[PRE259]'
  id: totrans-2221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Next, edit the index.js file, which will contain the logic defining the application’s
    core functionality. Specifically, the tip calculator logic includes four helper
    functions:'
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑index.js文件，该文件将包含定义应用程序核心功能的逻辑。具体来说，小费计算器的逻辑包括四个辅助函数：
- en: '`addPercentageToEach`—Increases each number in an array by a given percentage'
  id: totrans-2223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addPercentageToEach`—将给定百分比增加到数组中的每个数字'
- en: '`sum`—Calculates the sum of each element in an array'
  id: totrans-2224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum`—计算数组中每个元素的总和'
- en: '`percentFormat`—Formats a percentage for display'
  id: totrans-2225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percentFormat`—格式化用于显示的百分比'
- en: '`dollarFormat`—Formats a dollar value for display'
  id: totrans-2226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dollarFormat`—格式化用于显示的美元值'
- en: Add this logic by populating index.js with the contents of the following listing.
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在index.js中填充以下列表的内容来添加此逻辑。
- en: Listing 9.15\. Logic for calculating tips when splitting a bill
  id: totrans-2228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.15\. 分账时计算小费的逻辑
- en: '![](Images/09lis15_alt.jpg)'
  id: totrans-2229
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09lis15_alt.jpg)'
- en: Now edit the test script in test/tips.js, as shown in the following listing.
    The script loads the tip logic module; defines a tax, tip percentage, and the
    bill items to test; tests the addition of a percentage to each array element;
    and tests the bill total.
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编辑test/tips.js中的测试脚本，如下所示。该脚本加载小费逻辑模块；定义了税费、小费百分比和要测试的账单项目；测试了将百分比添加到每个数组元素；并测试了账单总额。
- en: Listing 9.16\. Logic that calculates tips when splitting a bill
  id: totrans-2231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.16\. 分账时计算小费的逻辑
- en: '![](Images/09lis16_alt.jpg)'
  id: totrans-2232
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09lis16_alt.jpg)'
- en: 'Run the script by using the following command. If all is well, the script should
    generate no output, because no assertions have been thrown, and your friends will
    be reassured of your honesty:'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行脚本。如果一切顺利，脚本应该不会生成任何输出，因为没有抛出断言，你的朋友们会放心你的诚实：
- en: '[PRE260]'
  id: totrans-2234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'To make this easier to run, add it as the test property under scripts in package.json:'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更容易运行，将其添加到package.json中scripts下的测试属性：
- en: '[PRE261]'
  id: totrans-2236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: Should.js supports many types of assertions—everything from assertions that
    use regular expressions to assertions that check object properties—allowing comprehensive
    testing of data and objects generated by your application. The project’s GitHub
    page ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js))
    provides comprehensive documentation of Should.js’s functionality.
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: Should.js支持许多类型的断言—从使用正则表达式的断言到检查对象属性的断言—允许全面测试应用程序生成的数据和对象。项目的GitHub页面 ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js))
    提供了Should.js功能的全面文档。
- en: Spies, stubs, and mocks are often used in addition to assertion libraries to
    control the way that code under tests is executed. The next section demonstrates
    how to do these with Sinon.JS.
  id: totrans-2238
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍、存根和模拟通常与断言库一起使用，以控制被测试代码的执行方式。下一节将演示如何使用Sinon.JS进行这些操作。
- en: 9.1.6\. Spies and stubs with Sinon.JS
  id: totrans-2239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.6\. 使用Sinon.JS的间谍和存根
- en: The final tool for your testing toolbox is a mock and stub library. The reason
    we write unit tests is to isolate parts of a system to test, but sometimes this
    is difficult. For example, imagine you’re testing code that resizes images. You
    don’t want to write to real image files, so how do you write tests? The code shouldn’t
    have special test branches that avoid touching the filesystem, because then you
    wouldn’t be truly testing the code. In cases like this, you need to *stub* the
    filesystem functionality. The practice of writing stubs also helps you do true
    TDD, because you can stub dependencies that aren’t ready yet.
  id: totrans-2240
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具箱中的最后一个工具是模拟和存根库。我们编写单元测试的原因是隔离系统的一部分进行测试，但有时这很困难。例如，想象你正在测试调整图像大小的代码。你不想写入真实的图像文件，那么你该如何编写测试？代码不应该有特殊的测试分支来避免接触文件系统，因为那样你就不会真正测试代码。在这种情况下，你需要*存根*文件系统功能。编写存根的实践也有助于你进行真正的TDD，因为你可以存根尚未准备好的依赖项。
- en: 'In this section, you’ll learn how to use Sinon.JS ([http://sinonjs.org/](http://sinonjs.org/))
    to write test spies, stubs, and mocks. Before you get started, create a new project
    and install Sinon:'
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用Sinon.JS ([http://sinonjs.org/](http://sinonjs.org/)) 来编写测试间谍、存根和模拟。在开始之前，创建一个新的项目并安装Sinon：
- en: '[PRE262]'
  id: totrans-2242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Next create a sample file to test. The example we use is a simple JSON key/value
    database. Our goal is to be able to stub the filesystem API so it doesn’t create
    real files on the filesystem. This will allow us to test only our database code
    rather than the file-handling code, as shown in the next listing.
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建一个用于测试的示例文件。我们使用的例子是一个简单的 JSON 键/值数据库。我们的目标是能够存根文件系统 API，使其不在文件系统中创建真实文件。这将允许我们只测试数据库代码，而不是文件处理代码，如下一个列表所示。
- en: Listing 9.17\. Database class
  id: totrans-2244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.17\. 数据库类
- en: '[PRE263]'
  id: totrans-2245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Save the listing as db.js. Now you’ll try testing it with Sinon’s spies.
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: 将列表保存为 db.js。现在你将尝试使用 Sinon 的间谍进行测试。
- en: Spies
  id: totrans-2247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 间谍
- en: 'Sometimes you just want to see whether a method has been called. Spies are
    perfect for this. The API lets you replace a method with something you can use
    to make assertions on. To mock the `fs.writeFile` call in db.js, use Sinon’s method
    replacement, `spy`:'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你只是想查看一个方法是否被调用。间谍非常适合这个用途。API 允许你用一个你可以用来进行断言的东西替换一个方法。为了模拟 db.js 中的 `fs.writeFile`
    调用，使用 Sinon 的方法替换方法 `spy`：
- en: '[PRE264]'
  id: totrans-2249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'When the test is finished, you can get the original method back with `restore`:'
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，你可以使用 `restore` 获取原始方法：
- en: '[PRE265]'
  id: totrans-2251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: In a test library like Mocha, you’d place these calls in the `beforeEach` and
    `afterEach` blocks. The following listing shows a full example of using spies.
    Save this file as spies.js.
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Mocha 这样的测试库中，你会在 `beforeEach` 和 `afterEach` 块中放置这些调用。以下列表展示了使用间谍的完整示例。将此文件保存为
    spies.js。
- en: Listing 9.18\. Using spies
  id: totrans-2253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.18\. 使用间谍
- en: '![](Images/09lis18_alt.jpg)'
  id: totrans-2254
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09lis18_alt.jpg)'
- en: After setting up the spy ![](Images/circ1.jpg), the code under test is run.
    Then you ensure that the expected method was called with `sinon.assert` ![](Images/circ2.jpg).
    The original method is then restored ![](Images/circ3.jpg). In this test, restoring
    it isn’t strictly necessary, but it’s best practice to always restore methods
    that you’ve changed.
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置间谍 ![](Images/circ1.jpg) 之后，运行待测试的代码。然后你确保预期的方法被 `sinon.assert` ![](Images/circ2.jpg)
    调用。然后恢复原始方法 ![](Images/circ3.jpg)。在这个测试中，恢复它并不是严格必要的，但始终恢复你更改的方法是最佳实践。
- en: Stubs
  id: totrans-2256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 存根
- en: Sometimes you need to control code flow. For example, you might want to force
    an error branch to be executed so you can test error handling in your code. The
    preceding example could be rewritten to use a stub instead of a spy to cause `writeFile`
    to execute its callback. Note that you still want to avoid calling the original
    method, but instead force the code under test to run the supplied callback. The
    next listing shows how to use stubs to replace functions. Save it as stub.js.
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要控制代码流程。例如，你可能想强制执行错误分支以测试你的代码中的错误处理。前面的例子可以重写为使用存根而不是间谍来执行 `writeFile`
    的回调。请注意，你仍然想避免调用原始方法，而是强制测试代码运行提供的回调。下一个列表展示了如何使用存根替换函数。将其保存为 stub.js。
- en: Listing 9.19\. Using stubs
  id: totrans-2258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.19\. 使用存根
- en: '![](Images/09lis19_alt.jpg)'
  id: totrans-2259
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09lis19_alt.jpg)'
- en: 'Using a combination of stubs and spies is ideal for testing Node code that
    makes heavy use of user-supplied functions, callbacks, and promises. Now that
    you’ve looked at tools designed for unit testing, let’s move on to an altogether
    different style of testing: functional testing.'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存根和间谍的组合是测试大量使用用户提供的函数、回调和承诺的 Node 代码的理想选择。既然你已经了解了为单元测试设计的工具，让我们继续探讨一种完全不同的测试风格：功能测试。
- en: 9.2\. Functional testing
  id: totrans-2261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 功能测试
- en: In most web development projects, *functional tests* work by driving the browser
    and then checking for various DOM transformations against a list of user-specific
    requirements. Imagine you’re building a content management system. A functional
    test for the image library upload feature would upload an image, check that it
    gets added, and then check that it’s added to a corresponding list of images.
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Web 开发项目中，*功能测试*通过驱动浏览器，然后检查各种 DOM 变化是否符合用户特定的要求列表。想象你正在构建一个内容管理系统。对于图像库上传功能的功能测试将上传一个图像，检查它是否被添加，然后检查它是否被添加到相应的图像列表中。
- en: 'The choice of tools to implement functional testing in Node is bewildering.
    From a high level, however, they fall into two broad groups: headless and browser-based
    tests. *Headless tests* typically use something like PhantomJS to provide a terminal-friendly
    browser environment, but lighter solutions use libraries such as Cheerio and JSDOM.
    *Browser-based tests* use a browser automation tool such as Selenium ([www.seleniumhq.org](http://www.seleniumhq.org))
    so you can write scripts that drive a real browser. Both approaches can use the
    same underlying Node test tools, so you could use Mocha, Jasmine, or even Cucumber
    to drive Selenium against your application. [Figure 9.6](#ch09fig06) shows an
    example test environment.'
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node中实现功能测试的工具选择令人眼花缭乱。然而，从高层次来看，它们可以分为两大类：无头测试和基于浏览器的测试。*无头测试*通常使用类似PhantomJS的工具来提供一个终端友好的浏览器环境，但更轻量级的解决方案则使用Cheerio和JSDOM等库。*基于浏览器的测试*使用Selenium等浏览器自动化工具([www.seleniumhq.org](http://www.seleniumhq.org))，这样你可以编写脚本驱动真实浏览器。两种方法都可以使用相同的底层Node测试工具，因此你可以使用Mocha、Jasmine，甚至Cucumber来驱动Selenium测试你的应用程序。[图9.6](#ch09fig06)展示了示例测试环境。
- en: Figure 9.6\. Testing with browser automation
  id: totrans-2264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6.使用浏览器自动化进行测试
- en: '![](Images/09fig06.jpg)'
  id: totrans-2265
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6](Images/09fig06.jpg)'
- en: In this section, you’ll learn about functional testing solutions for Node, so
    you can set up test environments based on your own requirements.
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解Node的功能测试解决方案，以便你可以根据你的要求设置测试环境。
- en: 9.2.1\. Selenium
  id: totrans-2267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. Selenium
- en: '*Selenium* is a popular Java-based browser automation library. With the aid
    of a language-specific driver, you can connect to a Selenium server and run tests
    against a real browser. In this section, you’ll learn how to use WebdriverIO ([http://webdriver.io/](http://webdriver.io/)),
    a Node Selenium driver.'
  id: totrans-2268
  prefs: []
  type: TYPE_NORMAL
  zh: '*Selenium*是一个流行的基于Java的浏览器自动化库。借助特定语言的驱动程序，你可以连接到Selenium服务器并针对真实浏览器运行测试。在本节中，你将学习如何使用WebdriverIO([http://webdriver.io/](http://webdriver.io/))，这是一个Node
    Selenium驱动程序。'
- en: 'Getting Selenium running is trickier than pure Node test libraries, because
    you need to install Java and download the Selenium JAR file. Download Java for
    your operating system, and then go to the Selenium download site ([http://docs.seleniumhq.org/download/](http://docs.seleniumhq.org/download/))
    to download the JAR file. You can then run a Selenium server like this:'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Selenium比纯Node测试库更复杂，因为你需要安装Java并下载Selenium JAR文件。为你的操作系统下载Java，然后转到Selenium下载网站([http://docs.seleniumhq.org/download/](http://docs.seleniumhq.org/download/))下载JAR文件。然后你可以这样运行Selenium服务器：
- en: '[PRE266]'
  id: totrans-2270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'Note that your exact Selenium version may be different. You may also have to
    supply a path to the browser binary. For example, in Windows 10 with Firefox set
    as the `browserName`, you can specify Firefox’s full path like this:'
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你的Selenium版本可能不同。你可能还需要提供一个浏览器二进制的路径。例如，在Windows 10上，将Firefox设置为`browserName`，你可以这样指定Firefox的完整路径：
- en: '[PRE267]'
  id: totrans-2272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: The exact path will depend on how Firefox is installed on your machine. For
    more about the Firefox driver, read the SeleniumHQ documentation ([https://github.com/SeleniumHQ/selenium/wiki/FirefoxDriver](https://github.com/SeleniumHQ/selenium/wiki/FirefoxDriver)).
    Drivers for Chrome and Microsoft Edge are configured in similar ways.
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: 完整路径将取决于Firefox在你的机器上的安装方式。有关Firefox驱动程序的更多信息，请参阅SeleniumHQ文档([https://github.com/SeleniumHQ/selenium/wiki/FirefoxDriver](https://github.com/SeleniumHQ/selenium/wiki/FirefoxDriver))。Chrome和Microsoft
    Edge的驱动程序配置方式类似。
- en: 'Now create a new Node project and install WebdriverIO:'
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的Node项目并安装WebdriverIO：
- en: '[PRE268]'
  id: totrans-2275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'WebdriverIO comes with a friendly config file generator. To run it, run `wdio
    config`:'
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: WebdriverIO附带一个友好的配置文件生成器。要运行它，请运行`wdio config`：
- en: '[PRE269]'
  id: totrans-2277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Follow the questions and accept the defaults. [Figure 9.7](#ch09fig07) shows
    my session.
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: 按照提示并接受默认设置。[图9.7](#ch09fig07)显示了我的会话。
- en: Figure 9.7\. Using `wdio` to configure Selenium tests
  id: totrans-2279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7.使用`wdio`配置Selenium测试
- en: '![](Images/09fig07.jpg)'
  id: totrans-2280
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7](Images/09fig07.jpg)'
- en: 'Update the package.json file with the `wdio` command so tests can be run with
    `npm test`:'
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 在package.json文件中更新`wdio`命令，以便可以使用`npm test`运行测试：
- en: '[PRE270]'
  id: totrans-2282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: Now add something to the test. A basic Express server will suffice. The example
    in the following listing will be used in the subsequent listing for testing. Save
    this listing as index.js (it’s c09-testing/selenium/index.js in the book’s sample
    code).
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在向测试中添加一些内容。一个基本的Express服务器就足够了。以下列表中的示例将在后续列表中用于测试。将此列表保存为index.js（在本书的示例代码中为c09-testing/selenium/index.js）。
- en: Listing 9.20\. Sample Express project
  id: totrans-2284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.20.示例Express项目
- en: '[PRE271]'
  id: totrans-2285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: The good thing about WebdriverIO is it provides a simple, fluent API for writing
    Selenium tests. The syntax is clear and easy to learn—you can even write tests
    with CSS selectors. The next listing (found in test/specs/todo-test.js in the
    book’s sample code) shows a simple test that sets up a WebdriverIO client and
    then checks the title on the page.
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: WebdriverIO 的好处是它提供了一个简单、流畅的 API 来编写 Selenium 测试。语法清晰，易于学习——你甚至可以使用 CSS 选择器编写测试。下一节（在本书示例代码的
    test/specs/todo-test.js 中找到）展示了设置 WebdriverIO 客户端并检查页面标题的简单测试。
- en: Listing 9.21\. A WebdriverIO test
  id: totrans-2287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.21. 一个 WebdriverIO 测试
- en: '![](Images/09lis21_alt.jpg)'
  id: totrans-2288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09lis21_alt.jpg)'
- en: After WebdriverIO is connected ![](Images/circ1.jpg), you can use an instance
    of the client to fetch pages from your app ![](Images/circ2.jpg). Then you can
    query the current state of the document in the browser—this example uses `getTitle`
    to get the `title` element from the document’s `head`. If you want to query the
    document for CSS elements, you can use `.elements` instead ([http://webdriver.io/api/protocol/elements.html](http://webdriver.io/api/protocol/elements.html)).
    There are all kinds of methods for manipulating the document, forms, and even
    cookies.
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WebdriverIO 连接 ![](Images/circ1.jpg) 之后，你可以使用客户端实例从你的应用程序中获取页面 ![](Images/circ2.jpg)。然后你可以查询浏览器中文档的当前状态——此示例使用
    `getTitle` 从文档的 `head` 中获取 `title` 元素。如果你要查询文档中的 CSS 元素，可以使用 `.elements` 代替 ([http://webdriver.io/api/protocol/elements.html](http://webdriver.io/api/protocol/elements.html))。有各种方法可以操作文档、表单，甚至是
    cookie。
- en: 'This test, which looks like the other Mocha tests in this chapter, is capable
    of running a real browser against a Node web app. To run it, start the server
    on port 4000:'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试，看起来像本章中的其他 Mocha 测试，能够在一个 Node Web 应用程序上运行真实的浏览器。要运行它，请在端口 4000 上启动服务器：
- en: '[PRE272]'
  id: totrans-2291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: Then type `npm test`. You should see Firefox open and the tests run in the command
    line. If you want to use Chrome, open wdio.conf.js and change the `browserName`
    property.
  id: totrans-2292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后输入 `npm test`。你应该看到 Firefox 打开，并在命令行中运行测试。如果你想使用 Chrome，打开 wdio.conf.js 并更改
    `browserName` 属性。
- en: '|  |'
  id: totrans-2293
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**More-advanced testing with Selenium**'
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Selenium 进行更高级的测试**'
- en: If you use WebdriverIO and Selenium to test a more complex web app that uses
    something like React or Angular, you’ll want to check out the `utility` methods.
    Some of the methods will pause the test until certain elements are available,
    which is great for React apps that may asynchronously render the document, updating
    it several times based on when remote data is available.
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 WebdriverIO 和 Selenium 测试一个更复杂的 Web 应用程序，该应用程序使用类似 React 或 Angular 这样的技术，你将想要查看
    `utility` 方法。其中一些方法会在某些元素可用之前暂停测试，这对于可能异步渲染文档、根据远程数据可用性更新多次的 React 应用程序来说非常好。
- en: Take a look at the `waitFor`* methods, such as `waitForVisible` ([http://webdriver.io/api/utility/waitForVisible.html](http://webdriver.io/api/utility/waitForVisible.html))
    to learn more.
  id: totrans-2296
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下 `waitFor`* 方法，例如 `waitForVisible` ([http://webdriver.io/api/utility/waitForVisible.html](http://webdriver.io/api/utility/waitForVisible.html))
    以了解更多信息。
- en: '|  |'
  id: totrans-2297
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.3\. Dealing with failing tests
  id: totrans-2298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 处理失败的测试
- en: When you’re working on an established project, there will come a point when
    tests begin to fail. Node provides several tools for getting more detail on failed
    tests, and in this section you’ll learn about how to enrich the output generated
    when debugging failing tests.
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在进行一个成熟的项目工作时，总会有测试开始失败的时候。Node 提供了几个工具来获取更多关于失败测试的详细信息，在本节中，你将了解如何丰富调试失败测试时生成的输出。
- en: The first thing to do when tests fail is to generate more-verbose logging output.
    The next section demonstrates how to do that with `NODE_DEBUG`.
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，首先要做的是生成更详细的日志输出。下一节将演示如何使用 `NODE_DEBUG` 来实现这一点。
- en: 9.3.1\. Getting more-detailed logs
  id: totrans-2301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1. 获取更详细的日志
- en: 'When tests fail, it’s useful to get information on what the program is doing.
    Node has two ways to do this: one for Node’s internals, and another for npm modules.
    To debug Node’s core modules, use `NODE_DEBUG`.'
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，了解程序正在做什么非常有用。Node 有两种方式来做这件事：一种用于 Node 的内部模块，另一种用于 npm 模块。要调试 Node 的核心模块，请使用
    `NODE_DEBUG`。
- en: Using NODE_DEBUG
  id: totrans-2303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 NODE_DEBUG
- en: 'To see how `NODE_DEBUG` works, imagine you have a deeply nested filesystem
    call where you’ve forgotten to use a callback. For example, the following example
    will throw an exception:'
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `NODE_DEBUG` 的工作原理，想象你有一个深层嵌套的文件系统调用，而你忘记使用回调函数。例如，以下示例将抛出异常：
- en: '[PRE273]'
  id: totrans-2305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'The stack trace shows only a limited amount of detail about the exception,
    and in particular doesn’t include full information on the call site where the
    exception originated:'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪只显示了关于异常的有限细节，特别是不包括异常起源的调用点的完整信息：
- en: '[PRE274]'
  id: totrans-2307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'Without the helpful comment, many programmers see a trace like this and blame
    Node for the unhelpful error. But, as the comment points out, `NODE_DEBUG=fs`
    can be used to get more information on the fs module. Run the script like this
    instead:'
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 没有有帮助的注释，许多程序员看到这样的跟踪并责怪 Node 的无帮助错误。但是，正如注释所指出的，可以使用 `NODE_DEBUG=fs` 来获取 fs
    模块更多的信息。用这种方式运行脚本：
- en: '[PRE275]'
  id: totrans-2309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'Now you’ll see a more detailed trace that helps debug the issue:'
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将看到一个更详细的跟踪，有助于调试问题：
- en: '[PRE276]'
  id: totrans-2311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: It’s clear from this trace that the problem lies in our file, inside a function
    on line 4 that was originally called from line 7\. This makes debugging any code
    that uses core modules much easier, and that includes not only the filesystem,
    but also network libraries such as Node’s HTTP client and server modules.
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个跟踪中可以清楚地看出，问题出在我们的文件中，在第四行的一个函数里，这个函数最初是从第七行调用的。这使得调试使用核心模块的任何代码都变得更容易，这不仅包括文件系统，还包括网络库，如
    Node 的 HTTP 客户端和服务器模块。
- en: Using DEBUG
  id: totrans-2313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 DEBUG
- en: The public alternative to `NODE_DEBUG` is `DEBUG`. Many packages on npm look
    for the `DEBUG` environment variable. It mimics the parameter style used by `NODE_DEBUG`,
    so you can specify a list of modules to debug or see all of them with `DEBUG='*'`.
    [Figure 9.8](#ch09fig08) shows the project from [chapter 4](kindle_split_015.xhtml#ch04)
    running with `DEBUG='*'`.
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: '`NODE_DEBUG` 的公共替代品是 `DEBUG`。npm 上的许多包都在寻找 `DEBUG` 环境变量。它模仿了 `NODE_DEBUG` 使用的参数样式，因此您可以指定要调试的模块列表或使用
    `DEBUG=''*''` 来查看所有模块。[图 9.8](#ch09fig08) 展示了使用 `DEBUG=''*''` 运行的来自 [第 4 章](kindle_split_015.xhtml#ch04)
    的项目。'
- en: Figure 9.8\. Running an Express application with `DEBUG='*'`
  id: totrans-2315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.8\. 使用 `DEBUG='*'` 运行 Express 应用程序
- en: '![](Images/09fig08_alt.jpg)'
  id: totrans-2316
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig08_alt.jpg)'
- en: 'If you want to incorporate the `NODE_DEBUG` functionality into your own projects,
    use the built-in `util.debuglog` method:'
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将 `NODE_DEBUG` 功能集成到自己的项目中，请使用内置的 `util.debuglog` 方法：
- en: '[PRE277]'
  id: totrans-2318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: To make custom debug loggers that are configured with `DEBUG`, you need to use
    the debug package from npm ([www.npmjs.com/package/debug](http://www.npmjs.com/package/debug)).
    You can create as many loggers as you want. Imagine you’re building an MVC web
    application. You could create separate loggers for models, views, and controllers.
    Then, when tests fail, you’ll be able to specify the debug logs that are necessary
    to debug the specific part of the application. The following listing (found in
    ch09-testing/debug-example/index.js) demonstrates how to use the debug module.
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建配置了 `DEBUG` 的自定义调试日志记录器，您需要使用 npm 中的调试包（[www.npmjs.com/package/debug](http://www.npmjs.com/package/debug)）。您可以创建任意数量的日志记录器。想象您正在构建一个
    MVC 网络应用程序。您可以分别为模型、视图和控制器创建单独的日志记录器。然后，当测试失败时，您将能够指定调试日志，以便调试应用程序的特定部分。以下列表（位于
    ch09-testing/debug-example/index.js 中）展示了如何使用调试模块。
- en: Listing 9.22\. Using the debug package
  id: totrans-2320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.22\. 使用 debug 包
- en: '[PRE278]'
  id: totrans-2321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'To run this example and see the view logs, set `DEBUG` to `debug-example:views`:'
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例并查看视图日志，请将 `DEBUG` 设置为 `debug-example:views`：
- en: '[PRE279]'
  id: totrans-2323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'One final feature of debug logging is that you can prefix a debug section with
    a hyphen to remove it from logs:'
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 调试日志的最后一个特性是，您可以在调试部分前加一个连字符来将其从日志中移除：
- en: '[PRE280]'
  id: totrans-2325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Hiding certain modules means you can still use the wildcard, but omit unneeded
    or noisy sections from the output.
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏某些模块意味着您仍然可以使用通配符，但可以从输出中省略不需要或嘈杂的部分。
- en: 9.3.2\. Getting better stack traces
  id: totrans-2327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 获取更好的堆栈跟踪
- en: 'If you’re using asynchronous operations, and that includes anything you’ve
    written using asynchronous callbacks or promises, then you may run into problems
    when stack traces aren’t detailed enough. Packages on npm can help you in such
    cases. For example, when callbacks run asynchronously, Node won’t keep the call
    stack from when the operation was queued. To test this, create two files, one
    called async.js that defines an asynchronous function, and another called index.js
    that requires async.js. This snippet is aync.js (found in ch09-testing/debug-stacktraces/async.js
    in the book’s sample code):'
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用异步操作，包括您使用异步回调或承诺编写的任何内容，那么当堆栈跟踪不够详细时，您可能会遇到问题。npm 上的包可以帮助您在这种情况下。例如，当回调异步运行时，Node
    不会保留操作排队时的调用栈。为了测试这一点，创建两个文件，一个名为 async.js，它定义了一个异步函数，另一个名为 index.js，它需要 async.js。以下片段是
    async.js（位于书籍示例代码 ch09-testing/debug-stacktraces/async.js 中）：
- en: '[PRE281]'
  id: totrans-2329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'And index.js just needs to require async.js:'
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 而 index.js 只需要引入 async.js：
- en: '[PRE282]'
  id: totrans-2331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'Now if you run index.js with `node index.js`, you’ll get a short stack trace
    that doesn’t show the caller of the failed function, only the location of the
    thrown exception:'
  id: totrans-2332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你使用`node index.js`运行index.js，你将得到一个简短的堆栈跟踪，它不会显示失败函数的调用者，只会显示抛出异常的位置：
- en: '[PRE283]'
  id: totrans-2333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: To improve this reporting, install the trace package ([www.npmjs.com/package/trace](http://www.npmjs.com/package/trace))
    and run it with `node -r trace index.js`. The `-r` flag tells Node to require
    the trace module before loading anything else.
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这种报告，安装trace包 ([www.npmjs.com/package/trace](http://www.npmjs.com/package/trace))
    并使用`node -r trace index.js`运行它。`-r`标志告诉Node在加载其他任何内容之前先require trace模块。
- en: 'Another problem with stack traces is they can be *too* detailed. This happens
    when the trace includes too much detail about Node’s internals. To clear up your
    stack traces, use `clarify` ([www.npmjs.com/package/clarify](http://www.npmjs.com/package/clarify)).
    Again, you can run it with the `-r` flag:'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪的另一个问题是它们可能过于详细。这发生在跟踪包括太多关于Node内部细节的情况下。为了清理你的堆栈跟踪，使用`clarify` ([www.npmjs.com/package/clarify](http://www.npmjs.com/package/clarify))。同样，你可以使用`-r`标志运行它：
- en: '[PRE284]'
  id: totrans-2336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '`clarify` is particularly useful if you want to include stack traces in error
    alert emails for a web application.'
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: '`clarify`特别有用，如果你想在Web应用的错误警报电子邮件中包含堆栈跟踪。'
- en: 'If you’re running code intended for browsers in Node, perhaps as part of an
    isomorphic web application, then you can get better stack traces by using source-map-support
    ([www.npmjs.com/package/source-map-support](http://www.npmjs.com/package/source-map-support)).
    This can be run with `-r`, but it also works with some test frameworks:'
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在Node中运行针对浏览器的代码，可能是作为同构Web应用的一部分，那么你可以通过使用source-map-support ([www.npmjs.com/package/source-map-support](http://www.npmjs.com/package/source-map-support))来获得更好的堆栈跟踪。这可以通过`-r`标志运行，但它也适用于一些测试框架：
- en: '[PRE285]'
  id: totrans-2339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: The next time you’re struggling with a stack trace generated by asynchronous
    code, look for tools such as `trace` and `clarify` to make sure you’re getting
    the best out of what V8 and Node can offer.
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 下次你遇到由异步代码生成的堆栈跟踪时，寻找像`trace`和`clarify`这样的工具，以确保你从V8和Node提供的最佳功能中获益。
- en: 9.4\. Summary
  id: totrans-2341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 摘要
- en: Writing unit tests requires a test runner such as Mocha.
  id: totrans-2342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试需要测试运行器，如Mocha。
- en: Node has a built-in assertion library called assert.
  id: totrans-2343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node有一个内置的断言库，称为assert。
- en: There are other assertion libraries, including Chai and Should.js.
  id: totrans-2344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他断言库，包括Chai和Should.js。
- en: If you don’t want to run certain code, such as network requests, you can use
    Sinon.JS.
  id: totrans-2345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不想运行某些代码，例如网络请求，你可以使用Sinon.JS。
- en: Sinon.JS also allows you to spy on code and verify that certain functions or
    methods were run.
  id: totrans-2346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sinon.JS还允许你监视代码并验证某些函数或方法是否已运行。
- en: Selenium can be used to write browser tests by scripting real browsers.
  id: totrans-2347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium可以通过脚本真实浏览器来编写浏览器测试。
- en: Chapter 10\. Deploying Node applications and maintaining uptime
  id: totrans-2348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章：部署Node应用程序和维护高可用性
- en: '*This chapter covers*'
  id: totrans-2349
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Choosing where to host your Node application
  id: totrans-2350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择托管Node应用程序的位置
- en: Deploying a typical application
  id: totrans-2351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署典型应用程序
- en: Maintaining uptime and maximizing performance
  id: totrans-2352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护高可用性和最大化性能
- en: Developing a web application is one thing, but putting it into production is
    another. For every web technology, tips and tricks are available that can increase
    stability and maximize performance, and Node is no different. In this chapter,
    you’ll get an overview of how to choose the right deployment environment for your
    application, and you’ll also learn about how to maintain uptime.
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: 开发Web应用是一回事，但将其投入生产是另一回事。对于每种Web技术，都有一些技巧和窍门可以提高稳定性和最大化性能，Node也不例外。在本章中，你将了解如何为你的应用程序选择正确的部署环境，你还将了解如何维护高可用性。
- en: The following section outlines the main types of environments you’ll deploy
    to. Then you’ll look at ways to maintain high uptimes.
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分概述了您将要部署的主要环境类型。然后您将了解如何保持高可用性。
- en: 10.1\. Hosting Node applications
  id: totrans-2355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 托管Node应用程序
- en: The web applications you’ve developed in this book use a Node-based HTTP server.
    A browser can talk to your application without a dedicated HTTP server such as
    Apache or Nginx. It’s possible to sit a server such as Nginx in front of your
    application, however, so Node can often be hosted anywhere you’ve previously been
    able to run a web server.
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这本书中开发的Web应用使用基于Node的HTTP服务器。浏览器可以与你的应用通信，而无需Apache或Nginx等专用HTTP服务器。然而，你可以在你的应用前面放置一个服务器，如Nginx，这样Node就可以在之前能够运行Web服务器的任何地方托管。
- en: 'Cloud providers, including Heroku and Amazon, also support Node. As a result,
    you have three ways to run your application in a reliable and scalable way:'
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商，包括 Heroku 和 Amazon，也支持 Node。因此，您有三种方式以可靠和可扩展的方式运行您的应用程序：
- en: '***Platform as a service—*** Run your application on Amazon, Azure, or Heroku'
  id: totrans-2358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***平台即服务—*** 在 Amazon、Azure 或 Heroku 上运行您的应用程序'
- en: '***Server or virtual machine—*** Run your application on a UNIX or Windows
    server in the cloud, a private hosting company, or internally at your place of
    business'
  id: totrans-2359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***服务器或虚拟机—*** 在云中的 UNIX 或 Windows 服务器、私人托管公司或您的工作场所内部运行您的应用程序'
- en: '***Container—*** Run your application and any other associated services by
    using a software container such as Docker'
  id: totrans-2360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***容器—*** 使用 Docker 等软件容器运行您的应用程序和任何其他相关服务'
- en: 'Choosing which of these three approaches to use can be difficult, particularly
    because trying them out first isn’t always easy. Note that each option isn’t tied
    to a particular vendor: Amazon and Azure are both capable of providing all of
    these deployment strategies, for example. To understand which option is right
    for you, this section explains their requirements as well as their advantages
    and disadvantages. Fortunately, every option has free or affordable options, so
    they should all be accessible to hobbyists and professionals alike.'
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用这三种方法中的哪一种可能会很困难，尤其是尝试它们并不总是容易。请注意，每个选项并不绑定到特定的供应商：例如，Amazon 和 Azure 都能够提供所有这些部署策略。为了了解哪种选项适合您，本节解释了它们的要求以及它们的优缺点。幸运的是，每个选项都有免费或负担得起的选项，因此它们都应该对业余爱好者和专业人士
    alike 都可访问。
- en: 10.1.1\. Platform as a service
  id: totrans-2362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 平台即服务
- en: With platform as a service (PaaS), you typically prepare an application for
    deployment by signing up for the service, creating a new app, and then adding
    a Git remote to your project. Pushing to that remote deploys your application.
    By default, it’ll run on a single container—the exact definition of container
    varies among vendors—and the service will attempt to restart the application if
    it crashes. You’ll get limited access to logs, and web and command-line interfaces
    for managing your app. To scale, you’ll run more instances of your application,
    which carries an additional fee. [Table 10.1](#ch10table01) contains an overview
    of the features of a typical PaaS offering.
  id: totrans-2363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用平台即服务（PaaS），您通常通过注册服务、创建新应用程序并将 Git 远程添加到项目中来准备应用程序的部署。将应用程序推送到该远程位置将部署您的应用程序。默认情况下，它将在单个容器上运行——容器确切的定义因供应商而异——如果应用程序崩溃，服务将尝试重新启动应用程序。您将获得对日志、Web
    和命令行界面的有限访问权限，用于管理您的应用程序。为了扩展，您将运行更多实例的应用程序，这会带来额外的费用。[表 10.1](#ch10table01) 包含了典型
    PaaS 提供的特性的概述。
- en: Table 10.1\. PaaS features
  id: totrans-2364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 10.1\. PaaS 特性
- en: '| **Ease of use** | High |'
  id: totrans-2365
  prefs: []
  type: TYPE_TB
  zh: '| **易用性** | 高 |'
- en: '| **Features** | Git push to deploy, simple horizontal scalability |'
  id: totrans-2366
  prefs: []
  type: TYPE_TB
  zh: '| **特性** | Git 推送部署，简单的水平扩展性 |'
- en: '| **Infrastructure** | Abstracted/black box |'
  id: totrans-2367
  prefs: []
  type: TYPE_TB
  zh: '| **基础设施** | 抽象/黑盒 |'
- en: '| **Commercial suitability** | Good: applications are typically network isolated
    |'
  id: totrans-2368
  prefs: []
  type: TYPE_TB
  zh: '| **商业适用性** | 好：应用程序通常是网络隔离的 |'
- en: '| **Pricing**^([[1](#ch10tn01)]) | Low traffic: $$; Popular site: $$$$ |'
  id: totrans-2369
  prefs: []
  type: TYPE_TB
  zh: '| **定价**^([[1](#ch10tn01)]) | 低流量：$$；热门网站：$$$$ |'
- en: '| **Vendors** | Heroku, Azure, AWS Elastic Beanstalk |'
  id: totrans-2370
  prefs: []
  type: TYPE_TB
  zh: '| **供应商** | Heroku、Azure、AWS Elastic Beanstalk |'
- en: ¹
  id: totrans-2371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-2372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '$: Cheap, $$$$$: Expensive'
  id: totrans-2373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '$: 价格便宜，$$$$: 价格昂贵'
- en: PaaS providers support their own preferred database and third-party databases.
    For Heroku, this is PostgreSQL; and for Azure, it’s SQL Database. The database
    connection details will be in environment variables, so you can connect without
    adding database credentials to your project’s source code. PaaS is great for hobbyists,
    because it can be cheap or even sometimes free to run small projects with low
    traffic.
  id: totrans-2374
  prefs: []
  type: TYPE_NORMAL
  zh: PaaS 提供商支持他们自己的首选数据库和第三方数据库。对于 Heroku，这是 PostgreSQL；对于 Azure，则是 SQL 数据库。数据库连接细节将在环境变量中，因此您可以在不将数据库凭据添加到项目源代码的情况下连接。PaaS
    对业余爱好者来说很棒，因为它可以以便宜或有时免费的方式运行流量低的小项目。
- en: 'Some vendors are easier to use than others: Heroku is extremely easy for programmers
    familiar with Git, even with little or no sysadmin or DevOps knowledge. PaaS systems
    typically know how to run projects made with popular tools such as Node, Rails,
    and Django, so they’re almost plug-and-play.'
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: 一些供应商比其他供应商更容易使用：对于熟悉 Git 的程序员来说，Heroku 非常容易使用，即使几乎没有系统管理员或 DevOps 知识。PaaS 系统通常知道如何运行使用
    Node、Rails 和 Django 等流行工具创建的项目，因此它们几乎是即插即用的。
- en: 'Example: Node on Heroku in 10 minutes'
  id: totrans-2376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例：10 分钟内在 Heroku 上运行 Node
- en: 'In this section, you''ll deploy an application to Heroku. Using Heroku’s default
    settings, you''ll deploy the application to a single lightweight Linux container-,
    known as a *dyno* in Heroku’s terminology, to serve your application. To deploy
    a basic Node app to Heroku, you need the following prerequisites:'
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将部署一个应用程序到Heroku。使用Heroku的默认设置，你将部署应用程序到一个轻量级的Linux容器，在Heroku术语中称为*dyno*，以服务你的应用程序。要将基本的Node应用程序部署到Heroku，你需要以下先决条件：
- en: An app to deploy
  id: totrans-2378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署的应用程序
- en: 'An account with Heroku: [https://signup.heroku.com/](https://signup.heroku.com/)'
  id: totrans-2379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku账户：[https://signup.heroku.com/](https://signup.heroku.com/)
- en: 'The Heroku CLI: [https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)'
  id: totrans-2380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku CLI：[https://devcenter.heroku.com/articles/heroku-cli](https://devcenter.heroku.com/articles/heroku-cli)
- en: 'After you have these elements, sign in to Heroku on the command-line:'
  id: totrans-2381
  prefs: []
  type: TYPE_NORMAL
  zh: 在你有了这些元素之后，在命令行中登录Heroku：
- en: '[PRE286]'
  id: totrans-2382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'Heroku then prompts you to enter your email address and Heroku password. Next,
    make a simple Express app:'
  id: totrans-2383
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku随后会提示你输入你的电子邮件地址和Heroku密码。接下来，创建一个简单的Express应用程序：
- en: '[PRE287]'
  id: totrans-2384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'You can run `npm start` and visit http://localhost:3000 to ensure that everything
    is running correctly. The next step is to make a Git repository and create a Heroku
    application:'
  id: totrans-2385
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行`npm start`并访问http://localhost:3000来确保一切运行正常。下一步是创建一个Git仓库并创建一个Heroku应用程序：
- en: '[PRE288]'
  id: totrans-2386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: This displays a randomly generated URL for your application, and a Git remote.
    Whenever you want to deploy, commit your changes with Git and push to `heroku
    master`. You can change the URL and the name of the application with `heroku rename`.
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了为你的应用程序生成的随机URL和一个Git远程仓库。无论何时你想部署，都可以使用Git提交你的更改并推送到`heroku master`。你可以使用`heroku
    rename`更改URL和应用程序的名称。
- en: Now visit the [herokuapp.com](http://herokuapp.com) URL from the previous step
    to see your basic Express app. To see the application logs, run `heroku logs`,
    and to get a shell in the application’s dyno, run `heroku run bash`.
  id: totrans-2388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问上一步骤中的[herokuapp.com](http://herokuapp.com) URL，查看你的基本Express应用程序。要查看应用程序日志，运行`heroku
    logs`，要进入应用程序的dyno的shell，运行`heroku run bash`。
- en: Heroku is a quick and easy way to run a Node application. Notice that you don’t
    have to do any Node-specific tailoring—Heroku runs basic Node apps out of the
    box without extra configuration. Sometimes you need more control over the environment,
    however, so in the next section we introduce using servers for hosting Node apps.
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是运行Node应用程序的一种快速简单的方式。请注意，你不需要进行任何Node特定的定制——Heroku默认运行基本的Node应用程序，无需额外配置。然而，有时你需要对环境有更多的控制，因此在下文中，我们将介绍使用服务器托管Node应用程序。
- en: 10.1.2\. Servers
  id: totrans-2390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 服务器
- en: 'Getting your own server has some advantages over PaaS. Instead of worrying
    about where to run the database, you can install PostgreSQL, MySQL, or even Redis
    on the same server if you want. You can install anything you like: custom logging
    software, HTTP servers, caching layers—it’s up to you. [Table 10.2](#ch10table02)
    summarizes the main characteristics of running your own servers.'
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有自己服务器相比PaaS有一些优势。你不必担心数据库的运行位置，如果你想的话，可以在同一服务器上安装PostgreSQL、MySQL甚至Redis。你可以安装任何你喜欢的软件：自定义日志软件、HTTP服务器、缓存层——这取决于你。[表10.2](#ch10table02)总结了运行自己服务器的主要特性。
- en: Table 10.2\. Server features
  id: totrans-2392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.2\. 服务器功能
- en: '| **Ease of use** | Low |'
  id: totrans-2393
  prefs: []
  type: TYPE_TB
  zh: '| **易用性** | 低 |'
- en: '| **Features** | Complete control over the whole stack, run your own database
    and caching layer |'
  id: totrans-2394
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | 对整个堆栈有完全控制权，运行自己的数据库和缓存层 |'
- en: '| **Infrastructure** | Open to the developer (or sysadmin/DevOps) |'
  id: totrans-2395
  prefs: []
  type: TYPE_TB
  zh: '| **基础设施** | 对开发者（或系统管理员/DevOps）开放 |'
- en: '| **Commercial suitability** | Good if you have staff capable of maintaining
    the server |'
  id: totrans-2396
  prefs: []
  type: TYPE_TB
  zh: '| **商业适用性** | 如果你有能够维护服务器的员工，则适用性良好 |'
- en: '| **Pricing** | Small VM: $; Large hosted server: $$$$$ |'
  id: totrans-2397
  prefs: []
  type: TYPE_TB
  zh: '| **定价** | 小型虚拟机：$；大型托管服务器：$$$$$ |'
- en: '| **Vendors** | Azure, Amazon, hosting companies |'
  id: totrans-2398
  prefs: []
  type: TYPE_TB
  zh: '| **供应商** | Azure、Amazon、托管公司 |'
- en: You can obtain and maintain a server in various ways. You can get a cheap virtual
    machine from a company such as Linode or Digital Ocean; this will be a full server
    that you can configure however you like, but it’ll share resources with other
    virtual machines on the same hardware. You can also buy your own hardware or rent
    a server. Some hosting companies offer managed hosting, whereby they’ll help maintain
    the server’s operating system.
  id: totrans-2399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式获取和维护服务器。你可以从Linode或Digital Ocean等公司获得便宜的虚拟机；这将是一个你可以按需配置的全服务器，但它将与同一硬件上的其他虚拟机共享资源。你也可以购买自己的硬件或租用服务器。一些托管公司提供托管服务，他们会帮助你维护服务器的操作系统。
- en: You have to decide which operating system you want to use. Debian has several
    flavors, and Node also works well in Windows and Solaris, so the choice is more
    difficult than it seems.
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须决定你想使用哪个操作系统。Debian有几个版本，Node在Windows和Solaris上也能很好地工作，所以选择比看起来更困难。
- en: 'Another critical decision is how to expose your app to the world: traffic can
    be redirected from port 80 and 443 to your app, but you could also sit Nginx in
    front of it to proxy requests and potentially handle static files.'
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键的决定是如何将你的应用程序暴露给世界：流量可以从80端口和443端口重定向到你的应用程序，但你也可以在它前面放置Nginx来代理请求并可能处理静态文件。
- en: You have various ways to move your code from your repository to the server as
    well. You can manually copy files with scp, sftp, or rsync, or you can use Chef
    to control multiple servers and manage releases. Some people set up a Heroku-like
    Git hook that will automatically update the app on the server, based on pushes
    to a certain Git branch.
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多种方式将你的代码从你的仓库移动到服务器。你可以使用scp、sftp或rsync手动复制文件，或者使用Chef来控制多个服务器并管理发布。有些人设置了一个类似Heroku的Git钩子，它将根据对某个Git分支的推送自动更新服务器上的应用程序。
- en: The important thing to realize is that managing your own server is difficult.
    Configuration takes a lot of work, and the server also has to be maintained with
    the latest OS bug fixes and security updates. If you’re a hobbyist, this may put
    you off—but you’ll learn a lot and may discover an interest in DevOps.
  id: totrans-2403
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到管理自己的服务器是困难的。配置需要大量工作，服务器还需要维护最新的操作系统错误修复和安全更新。如果你是爱好者，这可能会让你望而却步——但你将学到很多东西，也许会发现对DevOps的兴趣。
- en: Running Node apps on a virtual machine or full server doesn’t require anything
    special. If you want to see some of the techniques used to run a Node app on a
    server and keep it running for long periods of time, skip forward to [section
    10.2](#ch10lev1sec2), Understanding deployment basics. Otherwise, continue reading
    to learn about Node and Docker.
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机或完整服务器上运行Node应用程序不需要任何特殊的东西。如果你想看看在服务器上运行Node应用程序并长时间运行所使用的某些技术，请跳转到[第10.2节](#ch10lev1sec2)，了解部署基础知识。否则，继续阅读以了解Node和Docker。
- en: 10.1.3\. Containers
  id: totrans-2405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3\. 容器
- en: Using software containers is a kind of OS virtualization that automates the
    deployment of applications. The most well-known project is Docker, which is open
    source but also has commercial services that help you deploy production applications.
    [Table 10.3](#ch10table03) shows the main features of containers.
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用软件容器是一种操作系统虚拟化，它自动化了应用程序的部署。最著名的项目是Docker，它是开源的，但也提供商业服务，帮助你部署生产应用程序。[表10.3](#ch10table03)显示了容器的主要功能。
- en: Table 10.3\. Server features
  id: totrans-2407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.3\. 服务器功能
- en: '| **Ease of use** | Medium |'
  id: totrans-2408
  prefs: []
  type: TYPE_TB
  zh: '| **易用性** | 中等 |'
- en: '| **Features** | Complete control over the whole stack, run your own database
    and caching layer, redeploy to various providers and local machines |'
  id: totrans-2409
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | 对整个堆栈有完全控制权，运行自己的数据库和缓存层，可以重新部署到各种提供商和本地机器 |'
- en: '| **Infrastructure** | Open to the developer (or sysadmin/DevOps) |'
  id: totrans-2410
  prefs: []
  type: TYPE_TB
  zh: '| **基础设施** | 对开发者（或系统管理员/DevOps）开放 |'
- en: '| **Commercial suitability** | Great: deploy to a managed host, Docker host,
    or your own datacenter |'
  id: totrans-2411
  prefs: []
  type: TYPE_TB
  zh: '| **商业适用性** | 极佳：部署到托管主机、Docker主机或自己的数据中心 |'
- en: '| **Pricing** | $$$ |'
  id: totrans-2412
  prefs: []
  type: TYPE_TB
  zh: '| **定价** | $$$ |'
- en: '| **Vendors** | Azure, Amazon, Docker Cloud, Google Cloud Platform (with Kubernetes),
    hosting companies that allow you to run Docker containers |'
  id: totrans-2413
  prefs: []
  type: TYPE_TB
  zh: '| **供应商** | Azure、Amazon、Docker Cloud、Google Cloud Platform（带Kubernetes）、允许你运行Docker容器的托管公司
    |'
- en: 'Docker allows you to define your application in terms of images. If you’ve
    built a typical content management system that has a microservice for image processing,
    a main service for storing application data, and then a back-end database, you
    could deploy it with four separate Docker images:'
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许你以镜像的形式定义你的应用程序。如果你构建了一个典型的内容管理系统，它有一个用于图像处理的微服务、一个用于存储应用程序数据的主要服务，然后是一个后端数据库，你可以使用四个单独的Docker镜像来部署它：
- en: '***Image 1—*** Microservice for resizing images that are uploaded to the CMS'
  id: totrans-2415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***图1—*** 用于调整上传到CMS的图像的微服务'
- en: '***Image 2—*** PostgreSQL'
  id: totrans-2416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***图2—*** PostgreSQL'
- en: '***Image 3—*** Your main CMS web application with the administration interface'
  id: totrans-2417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***图3—*** 带有管理界面的主要CMS Web应用程序'
- en: '***Image 4—*** The public front-end web application'
  id: totrans-2418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***图4—*** 公共前端Web应用程序'
- en: Because Docker is open source, you’re not limited to a single vendor for deploying
    Dockerized applications. You can use Amazon’s Elastic Beanstalk to deploy your
    images, Docker Cloud, or even Microsoft’s Azure. Amazon also offers EC2 Container
    Service (ECS), and AWS CodeCommit for cloud Git repositories, which can be deployed
    to Elastic Beanstalk in a similar fashion to Heroku.
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker是开源的，您在部署Docker化应用程序时不受单一供应商的限制。您可以使用Amazon的Elastic Beanstalk来部署您的镜像，Docker
    Cloud，甚至Microsoft的Azure。Amazon还提供EC2容器服务（ECS），以及AWS CodeCommit用于云Git仓库，这些都可以以类似于Heroku的方式部署到Elastic
    Beanstalk。
- en: The amazing thing about using containers is that after you’ve containerized
    your app, you can bring up a fresh instance of it with a single command. If you
    get a new computer, you just need to check out your app’s repository, install
    Docker locally, and then run the script to start your app. Because your application
    has a well-defined recipe for deployment, it’s easier for you and your collaborators
    to understand how your application is supposed to run outside the local development
    environment.
  id: totrans-2420
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器的一个令人惊叹之处在于，在您将应用程序容器化之后，您只需一个命令就可以启动它的一个全新实例。如果您得到一台新电脑，您只需检出应用程序的仓库，在本地安装Docker，然后运行脚本以启动您的应用程序。因为您的应用程序有一个定义良好的部署配方，所以您和您的合作者更容易理解应用程序应该在本地开发环境之外如何运行。
- en: 'Example: Running Node apps with Docker'
  id: totrans-2421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例：使用Docker运行Node应用程序
- en: 'Example: [https://nodejs.org/en/docs/guides/nodejs-docker-webapp/](https://nodejs.org/en/docs/guides/nodejs-docker-webapp/)'
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：[https://nodejs.org/en/docs/guides/nodejs-docker-webapp/](https://nodejs.org/en/docs/guides/nodejs-docker-webapp/)
- en: 'To run a Node app with Docker, you need to do a few things first:'
  id: totrans-2423
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Docker运行Node应用程序，您首先需要做一些事情：
- en: 'Install Docker: [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).'
  id: totrans-2424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '安装Docker: [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).'
- en: Create a Node app. Refer to [section 10.1.1](#ch10lev2sec1), Platform as a service,
    for details on how to quickly make an example Express app.
  id: totrans-2425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Node应用程序。有关如何快速创建示例Express应用程序的详细信息，请参阅[第10.1.1节](#ch10lev2sec1)，平台即服务。
- en: Add a new file to the project called Dockerfile.
  id: totrans-2426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个名为Dockerfile的新文件。
- en: 'The Dockerfile tells Docker how to build your application’s image, and how
    to install the app and run it. You’ll use the official Node Docker image ([https://hub.docker.com/_/node/](https://hub.docker.com/_/node/))
    by specifying `FROM node:boron` in the Dockerfile, and then `run npm install`
    and `npm start` with the `RUN` and `CMD` instructions. The following snippet is
    a full Dockerfile that works for simple Node apps:'
  id: totrans-2427
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile告诉Docker如何构建您的应用程序镜像，以及如何安装和运行应用程序。您将通过在Dockerfile中指定`FROM node:boron`来使用官方Node
    Docker镜像 ([https://hub.docker.com/_/node/](https://hub.docker.com/_/node/))，然后使用`RUN`和`CMD`指令运行`npm
    install`和`npm start`。以下是一个适用于简单Node应用程序的完整Dockerfile示例：
- en: '[PRE289]'
  id: totrans-2428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: After you’ve created the Dockerfile, run the `docker build` ([https://docs.docker.com/engine/reference/commandline/build/](https://docs.docker.com/engine/reference/commandline/build/))
    command in the terminal to create an application image. You need to specify only
    the directory to build, so if you’re in the example Express app, you should be
    able to type `docker build .` to build the image and send it to the Docker daemon.
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Dockerfile后，在终端中运行`docker build` ([https://docs.docker.com/engine/reference/commandline/build/](https://docs.docker.com/engine/reference/commandline/build/))
    命令来创建应用程序镜像。您只需指定要构建的目录，因此如果您在示例Express应用程序中，应该能够键入`docker build .`来构建镜像并将其发送到Docker守护进程。
- en: Run `docker images` to see a list of images. Get the image ID, and then run
    `docker run -p 8080:3000 -d <image ID>` to run the app. We’ve bound the internal
    port (3000) to 8080 on localhost, so to access the app, we used http://localhost:8080
    in a browser.
  id: totrans-2430
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker images`以查看镜像列表。获取镜像ID，然后运行`docker run -p 8080:3000 -d <image ID>`来运行应用程序。我们已经将内部端口（3000）绑定到本地的8080端口，因此要访问应用程序，我们可以在浏览器中使用http://localhost:8080。
- en: 10.2\. Understanding deployment basics
  id: totrans-2431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 理解部署基础知识
- en: Suppose you’ve created a web application that you want to show off, or maybe
    you’ve created a commercial application and need to test it before putting it
    into full production. You’ll likely start with a simple deployment, and then do
    some work later to maximize uptime and performance. In this section, we walk you
    through a simple, temporary Git deployment, as well as details on how to keep
    the application up and running with Forever. Temporary deployments don’t persist
    beyond reboots, but they have the advantage of being quick to set up.
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您创建了一个您想要展示的Web应用程序，或者您可能创建了一个商业应用程序，在将其投入全面生产之前需要对其进行测试。您可能从简单的部署开始，然后在以后的工作中最大限度地提高正常运行时间和性能。在本节中，我们将向您介绍一个简单的、临时的Git部署，以及如何使用Forever保持应用程序运行和运行的详细信息。临时部署在重启后不会持久存在，但它们的优势是设置快速。
- en: 10.2.1\. Deploying from a Git repository
  id: totrans-2433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 从Git仓库部署
- en: 'Let’s quickly go through a basic deployment using a Git repository to give
    you a feel for the fundamental steps. Deployment is most commonly done by following
    these steps:'
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速通过使用Git仓库的基本部署步骤来让您了解基本步骤。部署通常是通过以下步骤完成的：
- en: Connect to a server by using SSH.
  id: totrans-2435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用SSH连接到服务器。
- en: Install Node and version-control tools (such as Git or Subversion) on the server
    if needed.
  id: totrans-2436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，在服务器上安装Node和版本控制工具（如Git或Subversion）。
- en: Download application files, including Node scripts, images, and CSS style sheets,
    from a version-control repository to the server.
  id: totrans-2437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从版本控制仓库将应用程序文件（包括Node脚本、图像和CSS样式表）下载到服务器上。
- en: Start the application.
  id: totrans-2438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序。
- en: 'Here’s an example of an application starting after downloading the application
    files using Git:'
  id: totrans-2439
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在使用Git下载应用程序文件后启动应用程序的一个示例：
- en: '[PRE290]'
  id: totrans-2440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Like PHP, Node doesn’t run as a background task. Because of this, the basic
    deployment we've outlined requires keeping the SSH connection open. As soon as
    the SSH connection closes, the application will terminate. Luckily, it’s fairly
    easy to keep your application running by using a simple tool.
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 与PHP一样，Node不会作为后台任务运行。因此，我们概述的基本部署需要保持SSH连接打开。一旦SSH连接关闭，应用程序将终止。幸运的是，通过使用简单的工具，保持应用程序运行相当容易。
- en: '|  |'
  id: totrans-2442
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Automating deployment**'
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化部署**'
- en: You can automate deployment of your Node application in various ways. One is
    to use a tool such as Fleet ([https://github.com/substack/fleet](https://github.com/substack/fleet)),
    which allows you to deploy to one or more servers by using `git push`. A more
    traditional approach is to use Capistrano, as detailed in the “Deploying node.js
    applications with Capistrano” post on Evan Tahler’s Bricolage blog ([https://blog.evantahler.com/deploying-node-js-applications-with-capistrano-af675cdaa7c6#.8r9v0kz3l](https://blog.evantahler.com/deploying-node-js-applications-with-capistrano-af675cdaa7c6#.8r9v0kz3l)).
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式自动化部署您的Node应用程序。其中一种方法是使用像Fleet（[https://github.com/substack/fleet](https://github.com/substack/fleet)）这样的工具，它允许您通过使用`git
    push`将应用程序部署到一台或多台服务器上。另一种更传统的方法是使用Capistrano，这在Evan Tahler的Bricolage博客上的“使用Capistrano部署node.js应用程序”文章中有详细说明（[https://blog.evantahler.com/deploying-node-js-applications-with-capistrano-af675cdaa7c6#.8r9v0kz3l](https://blog.evantahler.com/deploying-node-js-applications-with-capistrano-af675cdaa7c6#.8r9v0kz3l)）。
- en: '|  |'
  id: totrans-2445
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 10.2.2\. Keeping Node running
  id: totrans-2446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 保持Node运行
- en: Let’s say you’ve created a personal blog by using the Ghost blogging application
    ([https://ghost.org/](https://ghost.org/)), and you want to deploy it, making
    sure that it stays running even if you disconnect from SSH.
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您使用Ghost博客应用程序（[https://ghost.org/](https://ghost.org/)）创建了一个个人博客，并且您想要部署它，确保即使您断开SSH连接，它也能保持运行。
- en: The most popular tool in the Node community for dealing with this is Nodejitsu’s
    Forever ([https://github.com/foreverjs/forever](https://github.com/foreverjs/forever)).
    It keeps your application running after you disconnect from SSH and, additionally,
    restarts it if it crashes. [Figure 10.1](#ch10fig01) shows, conceptually, how
    Forever works.
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node社区中，处理此问题的最受欢迎的工具是Nodejitsu的Forever（[https://github.com/foreverjs/forever](https://github.com/foreverjs/forever)）。它可以在您断开SSH连接后保持应用程序运行，并在应用程序崩溃时重新启动它。[图10.1](#ch10fig01)从概念上展示了Forever是如何工作的。
- en: Figure 10.1\. The Forever tool helps you keep your application running, even
    if it crashes.
  id: totrans-2449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1\. Forever工具帮助您保持应用程序运行，即使它崩溃。
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-2450
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig01_alt.jpg)'
- en: You can install Forever globally by using the `sudo` command.
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`sudo`命令全局安装Forever。
- en: '|  |'
  id: totrans-2452
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The sudo command
  id: totrans-2453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: sudo命令
- en: Sometimes when installing an npm module *globally* (with the `-g` flag), you
    need to prefix the `npm` command with the `sudo` command ([www.sudo.ws](http://www.sudo.ws))
    in order to run npm with superuser privileges. The first time you use the `sudo`
    command, you’ll be prompted to enter your password. Then the command specified
    after it will be run.
  id: totrans-2454
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在全局安装npm模块（使用`-g`标志）时，你需要将`npm`命令前缀为`sudo`命令（[www.sudo.ws](http://www.sudo.ws)），以便以超级用户权限运行npm。第一次使用`sudo`命令时，你将被提示输入你的密码。然后运行它后面的指定命令。
- en: '|  |'
  id: totrans-2455
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you’re following along, install Forever now by using this command:'
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随，现在请使用以下命令安装Forever：
- en: '[PRE291]'
  id: totrans-2457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'After you’ve installed Forever, you can use it to start your blog and keep
    it running with the following command:'
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Forever后，你可以使用以下命令来启动你的博客并保持其运行：
- en: '[PRE292]'
  id: totrans-2459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'If you want to stop your blog for some reason, you can use Forever’s `stop`
    command:'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想出于某种原因停止你的博客，你可以使用Forever的`stop`命令：
- en: '[PRE293]'
  id: totrans-2461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'When using Forever, you can get a list of applications that the tool is managing
    by using its `list` command:'
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Forever时，你可以使用它的`list`命令来获取它正在管理的应用程序列表：
- en: '[PRE294]'
  id: totrans-2463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Another useful capability of Forever is that it can optionally restart your
    application when any source files have changed. This frees you from having to
    manually restart each time you add a feature or fix a bug.
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: Forever的另一个有用功能是它可以在任何源文件更改时可选地重新启动你的应用程序。这让你从每次添加功能或修复错误时都需要手动重新启动的麻烦中解脱出来。
- en: 'To start Forever in this mode, use the `-w` flag:'
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 要以这种方式启动Forever，请使用`-w`标志：
- en: '[PRE295]'
  id: totrans-2466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: Although Forever is an extremely useful tool for deploying applications, you
    may want to use something more full-featured for long-term deployments. In the
    next section, you’ll look at some industrial-strength monitoring solutions and
    see how to maximize application performance.
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Forever是一个部署应用程序的极其有用的工具，但你可能想要使用功能更全面的工具进行长期部署。在下一节中，你将了解一些工业级监控解决方案，并了解如何最大化应用程序性能。
- en: 10.3\. Maximizing uptime and performance
  id: totrans-2468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3. 最大化运行时间和性能
- en: When a Node application is release-worthy, you’ll want to make sure it starts
    and stops when the server starts and stops, and that it automatically restarts
    when the server crashes. It’s easy to forget to stop an application before a reboot
    or to forget to restart an application afterward.
  id: totrans-2469
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个Node应用程序值得发布时，你想要确保它在服务器启动和停止时启动和停止，并且在服务器崩溃时自动重新启动。很容易忘记在重启前停止应用程序，或者忘记在之后重新启动应用程序。
- en: You’ll also want to make sure you’re taking steps to maximize performance. For
    example, it makes sense when you’re running your application on a server with
    a quad-core CPU to not use only a single core. If you’re using only a single core
    and your web application’s traffic increases significantly, a single core may
    not have the processing capability to handle the traffic, and your web application
    won’t be able to consistently respond.
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 你还想要确保你正在采取步骤来最大化性能。例如，当你在一个拥有四核CPU的服务器上运行你的应用程序时，只使用单个核心是没有意义的。如果你只使用单个核心，并且你的Web应用程序的流量显著增加，单个核心可能没有足够的处理能力来处理流量，你的Web应用程序将无法持续响应。
- en: In addition to using all CPU cores, you’ll want to avoid using Node to host
    static files for high-volume production sites. Node is geared toward interactive
    applications, such as web applications and TCP/IP protocols, and it can’t serve
    static files as efficiently as software optimized to do only that. For serving
    static files, you should use technologies such as Nginx ([http://nginx.org/en/](http://nginx.org/en/)),
    which specializes in serving static files. Alternatively, you could upload all
    your static files to a content delivery network (CDN), such as Amazon S3 ([http://aws.amazon.com/s3/](http://aws.amazon.com/s3/)),
    and reference those files in your application.
  id: totrans-2471
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用所有CPU核心外，你还想避免使用Node为高流量生产站点托管静态文件。Node针对交互式应用程序，如Web应用程序和TCP/IP协议，它不能像专门为此优化的软件那样有效地服务静态文件。对于服务静态文件，你应该使用像Nginx（[http://nginx.org/en/](http://nginx.org/en/)）这样的技术，它专门用于服务静态文件。或者，你也可以将所有静态文件上传到内容分发网络（CDN），如Amazon
    S3（[http://aws.amazon.com/s3/](http://aws.amazon.com/s3/)），并在你的应用程序中引用这些文件。
- en: 'This section covers some server uptime and performance tips:'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了一些服务器运行时间和性能提示：
- en: Using Upstart to keep your application up and running through restarts and crashes
  id: totrans-2473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Upstart保持你的应用程序在重启和崩溃中持续运行
- en: Using Node’s cluster API for multicore processors
  id: totrans-2474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node的集群API进行多核处理器
- en: Serving Node application static files using Nginx
  id: totrans-2475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Nginx服务Node应用程序的静态文件
- en: 'Let’s start by looking at a powerful and easy-to-use tool for maintaining uptime:
    Upstart.'
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看一个强大且易于使用的工具，用于维护正常运行时间：Upstart。
- en: 10.3.1\. Maintaining uptime with Upstart
  id: totrans-2477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 使用 Upstart 维护正常运行时间
- en: Let’s say you’re happy with an application and want to market it to the world.
    You want to make dead sure that if you restart a server, you don’t then forget
    to restart your application. You also want to make sure that if your application
    crashes, it’s not only automatically restarted, but the crash is logged and you’re
    notified, which allows you to diagnose any underlying issues.
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你对一个应用程序感到满意，并希望将其推向全球市场。你想要确保，如果你重启服务器，不要忘记重启你的应用程序。你还想确保，如果你的应用程序崩溃，它不仅会自动重启，而且崩溃会被记录下来，你会收到通知，这样你可以诊断任何潜在的问题。
- en: Upstart ([http://upstart.ubuntu.com](http://upstart.ubuntu.com)) is a project
    that provides an elegant way to manage the starting and stopping of any Linux
    application, including Node applications. Modern versions of Ubuntu and CentOS
    support the use of Upstart. An alternative for macOS is to create launchd files
    (node-launchd on npm can do this), and the Windows equivalent is to use Windows
    Services, which is supported by the node-windows package on npm.
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: Upstart ([http://upstart.ubuntu.com](http://upstart.ubuntu.com)) 是一个项目，它提供了一种优雅的方式来管理任何
    Linux 应用程序的启动和停止，包括 Node 应用程序。现代版本的 Ubuntu 和 CentOS 支持使用 Upstart。对于 macOS 的替代方案是创建
    launchd 文件（npm 上的 node-launchd 可以做到这一点），而 Windows 的等效方案是使用 Windows 服务，这由 npm 上的
    node-windows 包支持。
- en: 'You can install Upstart on Ubuntu, if it’s not already installed, with this
    command:'
  id: totrans-2480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Upstart，可以使用以下命令在 Ubuntu 上安装：
- en: '[PRE296]'
  id: totrans-2481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'You can install Upstart on CentOS, if it’s not already installed, with this
    command:'
  id: totrans-2482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Upstart，可以使用以下命令在 CentOS 上安装：
- en: '[PRE297]'
  id: totrans-2483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: After you install Upstart, you need to add an Upstart configuration file for
    each of your applications. These files are created in the /etc/init directory
    and are named something like my_application_name.conf. The configuration files
    don't need to be marked as executable.
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Upstart 之后，你需要为你的每个应用程序添加一个 Upstart 配置文件。这些文件位于 /etc/init 目录中，命名类似于 my_application_name.conf。配置文件不需要标记为可执行。
- en: 'The following creates an empty Upstart configuration file for this chapter’s
    example application:'
  id: totrans-2485
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为本章示例应用程序创建一个空的 Upstart 配置文件：
- en: '[PRE298]'
  id: totrans-2486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: Now add the contents of the following listing to your config file. This setup
    will run the application when the server starts and will stop the application
    upon shutdown. The `exec` section gets executed by Upstart.
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下列表的内容添加到你的配置文件中。此设置将在服务器启动时运行应用程序，并在关闭时停止应用程序。`exec` 部分将由 Upstart 执行。
- en: Listing 10.1\. A typical Upstart configuration file
  id: totrans-2488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 一个典型的 Upstart 配置文件
- en: '![](Images/10lis01_alt.jpg)'
  id: totrans-2489
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10lis01_alt.jpg)'
- en: This configuration will keep your process up and running after the server restarts
    and even after it crashes unexpectedly. All the application-generated output will
    be sent to /var/log/upstart/hellonode.log, and Upstart will manage the log rotation
    for you.
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将在服务器重启后以及意外崩溃后保持进程运行。所有应用程序生成的输出都将发送到 /var/log/upstart/hellonode.log，Upstart
    将为你管理日志轮转。
- en: 'Now that you’ve created an Upstart configuration file, you can start your application
    by using the following command:'
  id: totrans-2491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个 Upstart 配置文件，你可以使用以下命令启动你的应用程序：
- en: '[PRE299]'
  id: totrans-2492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'If your application was started successfully, you’ll see a line like this:'
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序启动成功，你会看到类似以下的行：
- en: '[PRE300]'
  id: totrans-2494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: Upstart is highly configurable. Check out the online cookbook ([http://upstart.ubuntu.com/cookbook/](http://upstart.ubuntu.com/cookbook/))
    for all the available options.
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: Upstart 具有高度的可配置性。查看在线食谱（[http://upstart.ubuntu.com/cookbook/](http://upstart.ubuntu.com/cookbook/)），了解所有可用选项。
- en: Upstart and respawning
  id: totrans-2496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Upstart 和重启
- en: 'When the `respawn` option is used, Upstart will by default continually reload
    your application on crashes *unless* the application is restarted 10 times within
    5 seconds. You can change this limit by using the `respawn limit COUNT INTERVAL`
    option, where `COUNT` is the number of times within the `INTERVAL`, which is specified
    in seconds. For example, you set a limit of 20 times in 5 seconds like this:'
  id: totrans-2497
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `respawn` 选项时，Upstart 在默认情况下会在崩溃时不断重新加载你的应用程序，除非应用程序在 5 秒内重启了 10 次。你可以通过使用
    `respawn limit COUNT INTERVAL` 选项来更改此限制，其中 `COUNT` 是在 `INTERVAL`（以秒为单位指定）内的次数。例如，你可以这样设置
    5 秒内 20 次的限制：
- en: '[PRE301]'
  id: totrans-2498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: If your application is reloaded 10 times within 5 seconds (the default limit),
    typically there’s something wrong in the code or configuration, and it will never
    start successfully. Upstart won’t try to restart after reaching the limit, in
    order to save resources for other processes.
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序在5秒内（默认限制）重新加载10次，通常意味着代码或配置有问题，它将无法成功启动。Upstart达到限制后不会尝试重新启动，以节省其他进程的资源。
- en: It’s a good idea to do health checks outside Upstart that provide alerts to
    the development team through email or some other means of quick communication.
    A health check, for a web application, can simply involve hitting the website
    and seeing whether you get a valid response. You could roll your own methods or
    use tools such as Monit ([http://mmonit.com/monit/](http://mmonit.com/monit/))
    or Zabbix ([www.zabbix.com](http://www.zabbix.com)) for this.
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
  zh: 在Upstart之外进行健康检查是个好主意，它可以通过电子邮件或其他快速通信方式向开发团队提供警报。对于一个Web应用程序，健康检查可以简单地涉及访问网站并查看你是否得到了有效的响应。你可以自己编写方法或使用Monit
    ([http://mmonit.com/monit/](http://mmonit.com/monit/)) 或 Zabbix ([www.zabbix.com](http://www.zabbix.com))
    等工具来完成这项工作。
- en: Now that you know how to keep your application running regardless of crashes
    and server reboots, the next logical concern is performance. Node’s cluster API
    can help with this.
  id: totrans-2501
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何让你的应用程序在崩溃和服务器重启的情况下继续运行，接下来的一个合乎逻辑的担忧是性能。Node的集群API可以帮助解决这个问题。
- en: '10.3.2\. The cluster API: taking advantage of multiple cores'
  id: totrans-2502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2. 集群API：利用多个核心
- en: Most modern computer CPUs have multiple cores, but a Node process uses only
    one of them when running. If you're hosting a Node application on a server and
    want to maximize the server’s usage, you can manually start multiple instances
    of your application on different TCP/IP ports and use a load balancer to distribute
    web traffic to these instances, but that’s laborious to set up.
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机CPU都有多个核心，但Node进程在运行时只使用其中之一。如果你在服务器上托管Node应用程序并希望最大化服务器的使用，你可以手动在不同的TCP/IP端口上启动多个应用程序实例，并使用负载均衡器将这些Web流量分配到这些实例，但这需要繁琐的设置。
- en: To make it easier to use multiple cores for a single application, the cluster
    API was added to Node. This API makes it easy for your application to simultaneously
    run multiple workers on different cores that each do the same thing and respond
    to the same TCP/IP port. [Figure 10.2](#ch10fig02) shows how an application’s
    processing would be organized using the cluster API on a four-core processor.
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使单个应用程序更容易使用多个核心，Node中添加了集群API。这个API使得你的应用程序能够同时在不同的核心上运行多个工作者，每个工作者都执行相同的事情并响应相同的TCP/IP端口。[图10.2](#ch10fig02)展示了在四核处理器上使用集群API组织应用程序处理的方式。
- en: Figure 10.2\. A master spawning three workers on a four-core processor
  id: totrans-2505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2. 在四核处理器上主进程产生三个工作者
- en: '![](Images/10fig02.jpg)'
  id: totrans-2506
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig02.jpg)'
- en: The following listing automatically spawns a master process and a worker for
    each additional core.
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表会自动为每个额外的核心启动一个主进程和一个工作者。
- en: Listing 10.2\. A demonstration of Node’s cluster API
  id: totrans-2508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2. Node的集群API演示
- en: '![](Images/10lis02_alt.jpg)'
  id: totrans-2509
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10lis02_alt.jpg)'
- en: Because masters and workers run in separate operating system processes, which
    is necessary if they’re to run on separate cores, they can’t share state through
    global variables. But the cluster API does provide a means for the master and
    workers to communicate.
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主进程和工作者运行在独立的操作系统进程中，这是它们在单独的核心上运行所必需的，因此它们不能通过全局变量共享状态。但集群API确实为主进程和工作者提供了通信的途径。
- en: The following listing shows an example in which messages are passed between
    the master and the workers. A count of all requests is kept by the master, and
    whenever a worker reports handling a request, it’s relayed to each worker.
  id: totrans-2511
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了一个示例，其中消息在主进程和工作者之间传递。主进程维护所有请求的计数，每当工作者报告处理了一个请求，它就会被转发给每个工作者。
- en: Listing 10.3\. A demonstration of Node’s cluster API
  id: totrans-2512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3. Node的集群API演示
- en: '![](Images/ch10ex03-0.jpg)'
  id: totrans-2513
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch10ex03-0.jpg)'
- en: '![](Images/ch10ex03-1.jpg)'
  id: totrans-2514
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch10ex03-1.jpg)'
- en: Using Node’s cluster API is a simple way of creating applications that take
    advantage of modern hardware.
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node的集群API是创建利用现代硬件优势的应用程序的一种简单方法。
- en: 10.3.3\. Hosting static files and proxying
  id: totrans-2516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3. 托管静态文件和代理
- en: Although Node is an effective solution for serving dynamic web content, it’s
    not the most efficient way to serve static files such as images, CSS style sheets,
    or client-side JavaScript. Serving static files over HTTP is a specific task for
    which specific software projects are optimized, because they’ve focused primarily
    on this task for many years.
  id: totrans-2517
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Node 是提供动态 Web 内容的有效解决方案，但它不是提供静态文件（如图片、CSS 样式表或客户端 JavaScript）的最有效方式。在 HTTP
    上提供静态文件是一项特定的任务，特定的软件项目已经针对这项任务进行了优化，因为它们已经专注于这项任务多年。
- en: Fortunately, Nginx ([http://nginx.org/en/](http://nginx.org/en/)), an open source
    web server optimized for serving static files, is easy to set up alongside Node
    to serve those files. In a typical Nginx/Node configuration, Nginx initially handles
    each web request, relaying requests that aren’t for static files back to Node.
    [Figure 10.3](#ch10fig03) illustrates this configuration.
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Nginx ([http://nginx.org/en/](http://nginx.org/en/))，一个针对提供静态文件优化的开源 Web
    服务器，与 Node 一起设置起来非常简单，用于提供这些文件。在典型的 Nginx/Node 配置中，Nginx 最初处理每个 Web 请求，将不是静态文件的请求回传给
    Node。[图 10.3](#ch10fig03) 展示了这种配置。
- en: Figure 10.3\. You can use Nginx as a proxy to relay static assets quickly back
    to web clients.
  id: totrans-2519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3. 您可以使用 Nginx 作为代理快速将静态资源回传给 Web 客户端。
- en: '![](Images/10fig03.jpg)'
  id: totrans-2520
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig03.jpg)'
- en: The configuration in the following listing, which would be put in the Nginx
    configuration file’s `http` section, implements this setup. The configuration
    file is conventionally stored in a Unix server’s /etc directory at /etc/nginx/nginx.conf.
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的配置，将被放置在 Nginx 配置文件的 `http` 部分，实现了这种设置。配置文件通常存储在 Unix 服务器的 /etc 目录中的
    /etc/nginx/nginx.conf。
- en: Listing 10.4\. A configuration file that uses Nginx to proxy Node.js and serve
    static files
  id: totrans-2522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4. 使用 Nginx 代理 Node.js 和提供静态文件的配置文件
- en: '![](Images/ch10ex04-0.jpg)'
  id: totrans-2523
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch10ex04-0.jpg)'
- en: '![](Images/ch10ex04-1.jpg)'
  id: totrans-2524
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch10ex04-1.jpg)'
- en: By using Nginx to handle your static web assets, you ensure that Node is dedicated
    to doing what it does best.
  id: totrans-2525
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Nginx 处理您的静态网络资源，您确保 Node 专注于它最擅长的事情。
- en: 10.4\. Summary
  id: totrans-2526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 概述
- en: Node applications can be hosted by PaaS providers, dedicated services, virtual
    private servers, and cloud hosting.
  id: totrans-2527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 应用程序可以由 PaaS 提供商、专用服务、虚拟专用服务器和云托管来托管。
- en: You can quickly deploy Node applications to Linux servers by using Forever and
    Upstart.
  id: totrans-2528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Forever 和 Upstart 快速将 Node 应用程序部署到 Linux 服务器。
- en: To make your application perform better, Node’s cluster module lets you run
    multiple processes.
  id: totrans-2529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使您的应用程序性能更佳，Node 的集群模块允许您运行多个进程。
