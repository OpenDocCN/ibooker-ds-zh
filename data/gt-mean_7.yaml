- en: Appendix D. Reintroducing JavaScript
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录D. 重新介绍JavaScript
- en: '*This appendix covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本附录涵盖*'
- en: Applying best practices when writing JavaScript
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写JavaScript时应用最佳实践
- en: Using JSON effectively to pass data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用JSON传递数据
- en: Examining how to use callbacks and escaping callback hell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查如何使用回调以及如何逃离回调地狱
- en: Writing modular JavaScript with closures, patterns, and JavaScript classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闭包、模式和JavaScript类编写模块化JavaScript
- en: Adopting functional programming principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用函数式编程原则
- en: JavaScript is such a fundamental part of the MEAN stack (even if you’re writing
    the Angular part with TypeScript) that we’ll spend a little bit of time looking
    at it. We need to cover the bases because successful MEAN development depends
    on it. JavaScript is such a common language (uniquely, JavaScript has a runtime
    on almost every computer currently on the planet) that it seems that everybody
    knows some of it, partly because JavaScript is easy to start with and forgiving
    in the way it’s written. Unfortunately, this looseness and low barrier to entry
    can encourage bad habits, which can cause unexpected results.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是MEAN堆栈（即使您使用TypeScript编写Angular部分）的一个基本组成部分，因此我们将花一些时间来探讨它。我们需要打好基础，因为成功的MEAN开发依赖于它。JavaScript是一种如此常见的语言（独特的是，JavaScript几乎在地球上每台计算机上都有运行时），以至于似乎每个人都了解一些。部分原因是JavaScript易于入门，并且它的编写方式宽容。不幸的是，这种宽松性和低门槛可能会鼓励不良习惯，这可能导致意外结果。
- en: The aim of this appendix isn’t to teach JavaScript from scratch; you should
    already know the basics. If you don’t know JavaScript at all, you may struggle
    and find it hard going. Like all things, JavaScript has a learning curve. On the
    other hand, not everybody needs to read this appendix in detail, particularly
    experienced JavaScript developers. If you’re lucky enough to count yourself as
    part of the experienced camp, it still may be worthwhile to skim this appendix
    in case you find something new here.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录的目的是不是从头开始教授JavaScript；您应该已经掌握了基础知识。如果您对JavaScript一无所知，您可能会感到困难重重。像所有事物一样，JavaScript也有一个学习曲线。另一方面，并不是每个人都需要详细阅读这个附录，尤其是经验丰富的JavaScript开发者。如果您有幸认为自己属于经验丰富的行列，那么浏览这个附录以寻找新内容可能仍然是有价值的。
- en: We don’t cover TypeScript, though we hope that [chapters 8](kindle_split_020.xhtml#ch08)
    through [12](kindle_split_025.xhtml#ch12) cover it in enough detail for you to
    be comfortable with it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们并未涵盖TypeScript，但我们希望[第8章](kindle_split_020.xhtml#ch08)至[第12章](kindle_split_025.xhtml#ch12)的详细内容能够让您对它感到满意。
- en: One last thing before we get started in earnest. When you look around the internet
    for information around JavaScript, you’ll more than likely come across the appellations
    ES2015, ES2016, ES5, ES6, ES7, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们认真开始之前，还有最后一件事。当您在网上寻找JavaScript相关的信息时，您很可能会遇到ES2015、ES2016、ES5、ES6、ES7等称呼。
- en: ES5 is the version of JavaScript that has been available for the longest time,
    from the dim and distant past that includes the Firefox 4 web browser; the birth
    of Google Chrome; and the long, torturous death of the infamous Internet Explorer
    6. Luckily, those days are long gone, but the specification still stands, and
    most browsers (mostly) adhere to it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ES5是JavaScript的一个长期可用的版本，它始于遥远的过去，包括Firefox 4浏览器；Chrome浏览器的诞生；以及臭名昭著的Internet
    Explorer 6的漫长而痛苦的死亡。幸运的是，那些日子已经一去不复返，但该规范仍然存在，并且大多数浏览器（大多数）都遵循它。
- en: 'Officially, as of 2015, iterations of the JavaScript (or, if you prefer, ECMAScript
    [ES]) specification have been denoted by the year: ES2015, ES2016, and so on.
    Any reference to single-digit versioning post ES5, like ES6, is incorrect. Throughout
    this book, we’ve been careful to ensure that we named things correctly. Many authors
    across the internet haven’t been so diligent and continue to perpetuate the incorrect
    naming scheme.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，截至2015年，JavaScript（或者如果您愿意，ECMAScript [ES]）规范的版本已经通过年份来表示：ES2015、ES2016等等。对于ES5之后的单数字版本，如ES6，这种说法是不正确的。在这本书中，我们一直小心翼翼地确保我们正确地命名了事物。互联网上的许多作者并没有如此勤奋，他们继续传播错误的命名方案。
- en: As things stand today, most browsers adhere to most of the changes made in JavaScript
    as part of the ES2015 spec, with some browsers also providing some functionality
    for later iterations (2016, 2017, and so on). The pace of adoption and implementation
    is sometimes slower than we, as developers, would like, so transpilers such as
    Babel are available. JavaScript transpilers broadly take code written utilizing
    more modern ideas and convert it to a form that older browsers understand. They
    provide a bridge between old and new and between different languages. TypeScript,
    CoffeeScript, Elm, and ReasonML are all transpiled to JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的情况是，大多数浏览器都遵循了ES2015规范中JavaScript所做的大多数更改，一些浏览器还提供了一些后续迭代（2016年、2017年等）的功能。采用的步伐和实施速度有时比我们作为开发者所希望的慢，因此有了像Babel这样的转换器。JavaScript转换器广泛地将使用更现代思想编写的代码转换为旧浏览器能够理解的格式。它们在旧与新、不同语言之间架起了一座桥梁。TypeScript、CoffeeScript、Elm和ReasonML都是转换为JavaScript的。
- en: Everybody knows JavaScript, right?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个人都知道JavaScript，对吧？
- en: Not everybody knows JavaScript, but the vast majority of developers used it
    in one form or another at some point. Naturally, different levels of knowledge
    and experience exist. As a test, take a look at the following code listing. The
    listing contains a chunk of JavaScript code, the aim of which is to output messages
    to the console. If you understand the way the code is written, correctly determine
    what the output messages will be, and (more important) why they are what they
    are, you’re probably good for a skim read.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个人都了解JavaScript，但绝大多数开发者都在某个时候以某种形式使用过它。自然地，存在不同水平和经验。作为一个测试，看看下面的代码列表。该列表包含一段JavaScript代码，其目的是向控制台输出消息。如果你理解代码的编写方式，正确地确定输出消息将是什么，以及（更重要的是）为什么它们是这样的，你很可能适合快速阅读。
- en: Listing D.1\. Example JavaScript with intentional bugs
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.1\. 故意带有错误的示例JavaScript
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How did you get on with that? [Listing D.1](#app04ex01) has a couple of intentional
    bugs that JavaScript will let you make if you’re not careful. All this JavaScript
    is valid and legal, however, and it will run without throwing an error; you can
    test it by running it in a browser, if you like. The bugs highlight how easy it
    is to get unexpected results and also how difficult it can be to spot them if
    you don’t know what you’re looking for.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你对那件事的处理如何？[列表D.1](#app04ex01)有几个故意引入的错误，如果你不小心，JavaScript会允许你犯这些错误。然而，所有这些JavaScript都是有效和合法的，并且可以在不抛出错误的情况下运行；如果你喜欢，可以在浏览器中运行它来测试。这些错误突出了意外结果是多么容易发生，以及如果你不知道你在寻找什么，它们可能多么难以被发现。
- en: Want to know what the output of that code is? If you haven’t run it yourself,
    you can see the result in the following listing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道那段代码的输出结果是什么吗？如果你自己没有运行过，你可以在下面的列表中看到结果。
- en: Listing D.2\. Output of [listing D.1](#app04ex01)
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.2\. [列表D.1](#app04ex01)的输出
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Age is undefined due to scope clashes and variable hoisting.**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 年龄因作用域冲突和变量提升而未定义。**'
- en: '***2* Country hasn’t changed, but age has, due to variable scopes.**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 国家没有改变，但年龄因变量作用域而改变。**'
- en: '***3* Runs when called, not when defined; uses local variables over global**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用时运行，而不是定义时运行；使用局部变量而不是全局变量**'
- en: '***4* Runs later due to setTimeout; age is wrong due to a mistake in the for
    loop**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 由于setTimeout而稍后运行；由于for循环中的错误，年龄不正确**'
- en: Among other things, this code snippet shows a private closure exposing public
    methods, issues with variable scope and side effects, variables not being defined
    when expected, mixing of function and lexical scope, the effects of asynchronous
    code execution, and an easy mistake to make in a `for` loop. There’s quite a lot
    to take in when reading the code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这段代码片段展示了私有闭包暴露公共方法、变量作用域和副作用问题、在预期时未定义的变量、函数和词法作用域的混合、异步代码执行的影响，以及在`for`循环中容易犯的一个错误。阅读代码时有很多东西需要吸收。
- en: If you’re not sure what some of this means or didn’t get the outcome correct,
    read this appendix.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定其中的一些含义或者没有得到正确的结果，请阅读本附录。
- en: Good habits or bad habits
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好习惯或坏习惯
- en: JavaScript is an easy language to learn. You can grab a snippet from the internet
    and pop it into your HTML page, and you’ve started on your journey. One reason
    why it’s easy to learn is that in some respects, it’s not as strict as it should
    be. It lets you do things that it possibly shouldn’t, which leads to bad habits.
    In this section, we’ll take a look at some of these bad habits and show you how
    to turn them into good habits.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种易于学习的语言。你可以从互联网上抓取一段代码并将其放入你的 HTML 页面，然后你就可以开始你的旅程了。它易于学习的一个原因是，在某些方面，它并不像它应该的那样严格。它允许你做一些它可能不应该做的事情，这会导致坏习惯。在本节中，我们将探讨一些这些坏习惯，并展示如何将它们转变为好习惯。
- en: Variables, scope, and functions
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量、作用域和函数
- en: 'The first step is looking at *variables*, *scope*, and *functions*, which are
    all closely tied together. JavaScript has three types of scope: *global*, *function*
    (using the `var` keyword), and *lexical* (using `let` or `const` keywords). JavaScript
    also has *scope inheritance*. If you declare a variable in global scope, it’s
    accessible by everything; if you declare a variable with `var` inside a function,
    it’s accessible only to that function and everything inside it; if you declare
    a variable with `let` or `const` in a block, it’s accessible inside the braces
    and everything inside that block, but unlike `var`, access doesn’t bleed through
    to the surrounding function block.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是查看*变量*、*作用域*和*函数*，它们都是紧密相连的。JavaScript 有三种作用域类型：*全局*、*函数*（使用 `var` 关键字）和*词法*（使用
    `let` 或 `const` 关键字）。JavaScript 还具有*作用域继承*。如果你在全局作用域中声明一个变量，它对所有内容都是可访问的；如果你在函数内部使用
    `var` 声明一个变量，它只对该函数及其内部的内容可访问；如果你在代码块中使用 `let` 或 `const` 声明一个变量，它只在该花括号及其内部的内容中可访问，但与
    `var` 不同，访问不会渗透到周围的功能块。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The var keyword in ES2015 and later**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**ES2015 及以后的 `var` 关键字**'
- en: Modern practice tends to frown on using the `var` keyword, which will eventually
    be deprecated. `var` comes with a lot of baggage, and if you’re coming from other
    languages, its scoping can be difficult to work with and can trip up even the
    most experienced developer. We’ll discuss it here, though, because a lot of JavaScript
    has been built with `var`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现代实践往往不赞成使用 `var` 关键字，它最终将被弃用。`var` 带有大量的负担，如果你来自其他语言，其作用域可能难以处理，甚至可能让最有经验的开发者陷入困境。尽管如此，我们在这里讨论它，因为大量的
    JavaScript 都是用 `var` 编写的。
- en: With ES2015, the language specification introduced the `let` and `const` keywords,
    which are lexically (block) scoped. These keywords have greater similarity with
    other variable-definition schemes. The difference is explained in more detail
    in the following sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 ES2015 的推出，语言规范引入了 `let` 和 `const` 关键字，它们是词法（块）作用域的。这些关键字与其他变量定义方案有更大的相似性。差异将在以下章节中更详细地解释。
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Working with scope and scope inheritance
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理作用域和作用域继承
- en: Start with a simple example in which scope is used incorrectly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个简单的例子开始，其中作用域被错误地使用。
- en: Listing D.3\. Scope example
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.3\. 作用域示例
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Variable declared in global scope**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在全局作用域中声明的变量**'
- en: '***2* Variable declared in local lexical scope**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在局部词法作用域中声明的变量**'
- en: '***3* Outputs “Simon Holmes”**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 输出“Simon Holmes”**'
- en: '***4* Throws error because surname isn’t defined**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 抛出错误，因为 surname 未定义**'
- en: This piece of code throws an error because it’s trying to use the variable `surname`
    in the global scope, but it was defined in the local scope of the function `addSurname()`.
    A good way to visualize the concept of scope is to draw some nested circles. In
    [figure D.1](#app04fig01), the outer circle depicts the global scope; the middle
    circle depicts the function scope; and the inner circle depicts lexical scope.
    You can see that the global scope has access to the variable `firstname` and that
    the local scope of the function `addSurname()` has access to the global variable
    `firstname` and the local variable `surname`. In this case, lexical scope and
    function scope overlap.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会抛出错误，因为它试图在全局作用域中使用变量 `surname`，但它是在函数 `addSurname()` 的局部作用域中定义的。可视化作用域概念的一个好方法是画一些嵌套的圆圈。在[图
    D.1](#app04fig01)中，外圈表示全局作用域；中间圈表示函数作用域；内圈表示词法作用域。你可以看到全局作用域可以访问变量 `firstname`，而函数
    `addSurname()` 的局部作用域可以访问全局变量 `firstname` 和局部变量 `surname`。在这种情况下，词法作用域和函数作用域重叠。
- en: Figure D.1\. Scope circles depicting global scope versus local scope and scope
    inheritance
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 D.1\. 表示全局作用域与局部作用域以及作用域继承的圆圈图
- en: '![](Images/dfig01_alt.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig01_alt.jpg)'
- en: If you want the global scope to output the full name while keeping the surname
    private in the local scope, you need a way of pushing the value into the global
    scope. In terms of scope circles, you’re aiming for what you see in [figure D.2](#app04fig02).
    You want a new variable, `fullname`, that you can use in both global and local
    scopes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要全局作用域输出全名，同时在局部作用域中保持姓氏私有，你需要一种方法将值推送到全局作用域。从作用域圈的角度来看，你希望看到[图 D.2](#app04fig02)中的内容。你想要一个新的变量`fullname`，你可以在全局和局部作用域中使用它。
- en: Figure D.2\. Using an additional global variable to return data from the local
    scope
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 D.2\. 使用额外的全局变量从局部作用域返回数据
- en: '![](Images/dfig02_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig02_alt.jpg)'
- en: 'Pushing from local to global scope: The wrong way'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从局部作用域到全局作用域的推送：错误的方法
- en: One way you could do it—and we’ll warn you now that it’s bad practice—is to
    define a variable against the global scope from inside the local scope. In the
    browser, the global scope is the object `window`; in Node.js, it’s `global`. Sticking
    with browser examples for now, the following listing shows how this would look
    if you updated the code to use the `fullname` variable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样做的一种方式——现在我们就警告你，这是一种不好的做法——是在局部作用域内定义一个与全局作用域相关的变量。在浏览器中，全局作用域是`window`对象；在Node.js中，它是`global`。现在我们继续使用浏览器示例，以下列表显示了如果你更新代码以使用`fullname`变量，它会是什么样子。
- en: Listing D.4\. Global `fullname` variable
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.4\. 全局 `fullname` 变量
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* The fullname variable is defined in the window object.**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 全局对象中定义了`fullname`变量。**'
- en: '***2* Global scope can output the full name.**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 全局作用域可以输出全名。**'
- en: This approach allows you to add a variable to the global scope from inside a
    local scope, but it’s not ideal. The problems are twofold. First, if anything
    goes wrong with the `addSurname()` function and the variable isn’t defined, when
    the global scope tries to use it, you’ll get an error thrown. The second problem
    becomes obvious when your code grows. Suppose that you have dozens of functions
    adding things to different scopes. How do you keep track of them? How do you test
    them? How do you explain to someone else what’s going on? The answer to all these
    questions is *with great difficulty*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许你从局部作用域向全局作用域添加变量，但这并不是理想的。问题有两个。首先，如果`addSurname()`函数出现错误并且变量未定义，当全局作用域尝试使用它时，你会得到一个错误。第二个问题在你代码增长时变得明显。假设你有数十个函数向不同的作用域添加内容。你如何跟踪它们？你如何测试它们？你如何向别人解释正在发生的事情？所有这些问题的答案都是*非常困难*。
- en: 'Pushing from local to global scope: The right way'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从局部作用域到全局作用域的推送：正确的方法
- en: If declaring the global variable in the local scope is wrong, what’s the right
    way? The rule of thumb is *always declare variables in the scope in which they
    belong*. If you need a global variable, you should define it in the global scope,
    as in the following listing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在局部作用域中声明全局变量是错误的，那么正确的方法是什么？一般来说，*总是将变量声明在它们所属的作用域中*。如果你需要一个全局变量，你应该在全局作用域中定义它，如下面的列表所示。
- en: Listing D.5\. Declaring globally scoped variables
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.5\. 声明全局作用域变量
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Variable declared in global scope, even if a value isn’t assigned to
    it yet**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在全局作用域中声明的变量，即使尚未分配值**'
- en: Here, it’s obvious that the global scope now contains the variable `fullname`,
    which makes the code easier to read when you come back to it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，很明显全局作用域现在包含了`fullname`变量，这使得当你再次查看代码时更容易阅读。
- en: Referencing global variables from local scope
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从局部作用域引用全局变量
- en: You may have noticed that from within the function, the code still references
    the global variable by using the fully qualified `window.fullname`. It’s best
    practice to do this whenever you reference a global variable from a local scope.
    Again, this practice makes your code easier to come back to and debug, because
    you can explicitly see which variable is being referenced. The code should look
    like the following listing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在函数内部，代码仍然通过使用完全限定的`window.fullname`来引用全局变量。在从局部作用域引用全局变量时，这样做是一种最佳实践。再次强调，这种做法使得你的代码更容易回顾和调试，因为你可以明确地看到正在引用哪个变量。代码应该看起来像以下列表。
- en: Listing D.6\. Using global variables in local scope
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.6\. 在局部作用域中使用全局变量
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* When using global variables in local scope, always use the fully qualified
    reference.**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 当在局部作用域中使用全局变量时，始终使用完全限定的引用。**'
- en: This approach might add a few more characters to your code, but it makes it
    obvious which variable you’re referencing and where it came from. There’s another
    reason for this approach, particularly when assigning a value to a variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能会让你的代码增加一些字符，但它使得你引用的变量及其来源非常明显。还有另一个原因支持这种方法，尤其是在给变量赋值时。
- en: Implied global scope
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 隐含的全局作用域
- en: JavaScript lets you declare a variable without using `var`, which is a bad thing
    indeed. Worse, if you declare a variable without using `var`, JavaScript creates
    the variable in the global scope, as shown in the following listing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 允许你不用 `var` 就声明一个变量，这实际上是一个坏习惯。更糟糕的是，如果你不用 `var` 声明一个变量，JavaScript
    会将其创建在全局作用域中，如下面的列表所示。
- en: Listing D.7\. Declaring without `var`
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.7\. 不使用 `var` 声明
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* surname and fullname are both defined in the global scope by implication.**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* surname 和 fullname 都是通过隐含定义在全局作用域中的。**'
- en: '***2* They can be used in the global scope.**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 它们可以在全局作用域中使用。**'
- en: We hope that you can see how this could be confusing and is a bad practice.
    The takeaway is *always declare variables in the scope in which they belong, using
    the `var` statement*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你能看到这可能会造成混淆，并且是一个坏习惯。关键是要*始终在变量所属的作用域中声明变量，使用 `var` 语句*。
- en: The problem of variable hoisting
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量提升的问题
- en: You’ve probably heard that with JavaScript, you should always declare your variables
    at the top. That’s correct, and the reason is because of variable hoisting. With
    *variable hoisting*, JavaScript declares all variables at the top anyway without
    telling you, which can lead to some unexpected results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过，在使用 JavaScript 时，你应该始终在顶部声明你的变量。这是正确的，原因是因为变量提升。在 *变量提升* 中，JavaScript
    无论如何都会在顶部声明所有变量，而不会告诉你，这可能会导致一些意外的结果。
- en: The following code listing shows how variable hoisting might show itself. In
    the `addSurname()` function, you want to use the global value of `firstname` and
    later declare a local scope value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码列表显示了变量提升可能如何表现出来。在 `addSurname()` 函数中，你想要使用全局的 `firstname` 值，然后声明一个局部作用域的值。
- en: Listing D.8\. Shadowing example
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.8\. 遮蔽示例
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* You expect this to use a global variable.**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你期望这会使用一个全局变量。**'
- en: '***2* The output is actually “undefined Holmes.”**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 实际的输出是“undefined Holmes。”**'
- en: Why is the output wrong? JavaScript “hoists” all variable declarations to the
    top of their scope. You see the code in [listing D.8](#app04ex08), but JavaScript
    sees the code in [listing D.9](#app04ex09).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么输出是错误的？JavaScript “提升”了所有变量声明到它们作用域的顶部。你看到的是[列表 D.8](#app04ex08)中的代码，但 JavaScript
    看到的是[列表 D.9](#app04ex09)中的代码。
- en: Listing D.9\. Hoisting example
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.9\. 提升示例
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* JavaScript has moved all variable declarations to the top.**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* JavaScript 已经将所有变量声明移动到了顶部。**'
- en: '***2* No value is assigned before it’s used, so it’s undefined.**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在使用之前没有赋值，所以它是未定义的。**'
- en: When you see what JavaScript is doing, the bug is a little more obvious. JavaScript
    has declared the variable `firstname` at the top of the scope, but it doesn’t
    have a value to assign to it, so JavaScript leaves the variable undefined when
    you first try to use it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到 JavaScript 在做什么时，错误就更加明显了。JavaScript 在作用域的顶部声明了变量 `firstname`，但它没有值可以赋给它，所以当你第一次尝试使用它时，JavaScript
    将变量留为未定义。
- en: You should bear this fact in mind when writing your code. What JavaScript sees
    should be what you see. If you can see things from the same perspective, you have
    less room for error and unexpected problems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写代码时，你应该记住这个事实。JavaScript 看到的应该是你看到的。如果你能从相同的视角看待事物，你犯错误和意外问题的空间就会小很多。
- en: Lexical scope
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 词法作用域
- en: '*Lexical scope* is sometimes called *block scope*. Variables defined between
    a set of braces are limited to the scope of those braces. Therefore, scoping can
    be limited to looping and flow logic constructs.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*词法作用域*有时也称为*块作用域*。在一系列花括号之间定义的变量仅限于这些花括号的作用域。因此，作用域可以被限制在循环和流程逻辑结构中。'
- en: 'JavaScript defines two keywords that provide lexical scope: `let` and `const`.
    Why two? The functionality of the two is slightly different.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 定义了两个提供词法作用域的关键字：`let` 和 `const`。为什么是两个？这两个的功能略有不同。
- en: '`let` is a bit like `var`. It sets up a variable that can be changed in the
    scope in which it is defined. It differs from `var` in that its scope is limited
    as described earlier, and variables declared this way aren’t hoisted. As they’re
    not hoisted, they’re not tracked by the compiler the same way as `var`; the compiler
    leaves them where they are on the first pass, so if you try to reference them
    before they’re defined, the compiler complains with a `ReferenceError`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 有点像 `var`。它设置了一个可以在定义的作用域中更改的变量。它与 `var` 的不同之处在于，其作用域限制如前所述，并且以这种方式声明的变量不会被提升。由于它们不会被提升，它们不会被编译器以与
    `var` 相同的方式跟踪；编译器在第一次遍历时将它们留在原处，因此如果你在它们定义之前尝试引用它们，编译器会通过 `ReferenceError` 投诉。'
- en: Listing D.10\. `let` in action
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.10\. `let` 的作用
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Initially declares variable**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 首次声明变量**'
- en: '***2* Prints out value of 1**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印出值为 1**'
- en: '***3* Redefines value**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 重新定义值**'
- en: '***4* Prints out value of 2**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印出值为 2**'
- en: '***5* Tries to print out a value that’s not defined yet (ReferenceError)**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 尝试打印尚未定义的值（ReferenceError）**'
- en: '***6* Definition of variable that’s not hoisted**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 未提升的变量的定义**'
- en: '`const` has the same caveats as `let`. `const` differs from `let` in that variables
    declared in such a way aren’t allowed to change, either by reassignment or redeclaration;
    they’re declared to be immutable. `const` also prevents shadowing—redefining a
    previously defined outer scoped variable. Suppose you have a variable defined
    in global scope (with `var`), and you try to define a variable with `const` with
    the same name in an enclosed scope. The compiler will throw an `Error`. The type
    of the error returned depends on what you’re trying to do.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 与 `let` 有相同的注意事项。`const` 与 `let` 的不同之处在于，以这种方式声明的变量不允许通过重新赋值或重新声明来更改，它们被声明为不可变的。`const`
    还防止了覆盖——重新定义之前定义的外部作用域变量。假设你在全局作用域中定义了一个变量（使用 `var`），然后你尝试在封闭作用域中使用 `const` 定义一个同名的变量。编译器将抛出一个
    `Error`。返回的错误类型取决于你试图做什么。'
- en: Listing D.11\. Using `const`
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.11\. 使用 `const`
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Initially declares bar**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 首次声明 bar**'
- en: '***2* Initially declares foo variable**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 首次声明 foo 变量**'
- en: '***3* Prints out value of 1**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印出值为 1**'
- en: '***4* Tries to redefine foo (Error)**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 尝试重新定义 foo（错误）**'
- en: '***5* Tries to shadow bar variable**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 尝试覆盖 bar 变量**'
- en: Because of the clarity afforded by declaring variables with `let` and `const`,
    this method is now the preferred way. Issues of hoisting are no longer a concern,
    and variables behave in a more conventional way that programmers familiar with
    other mainstream languages are more comfortable with.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 `let` 和 `const` 声明变量带来的清晰性，这种方法现在已成为首选方式。提升问题不再成为关注点，变量以更传统的方式表现，这对于熟悉其他主流语言的程序员来说更加舒适。
- en: Functions are variables
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数是变量
- en: You may have noticed throughout the preceding code snippets that the `addSurname()`
    function has been declared as a variable. Again, this is a best practice. First,
    this is how JavaScript sees it anyway, and second, it makes it clear which scope
    the function is in.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在前面的代码片段中，`addSurname()` 函数被声明为一个变量。同样，这也是一种最佳实践。首先，JavaScript 本身就是这样看待的，其次，这清楚地表明了函数所在的作用域。
- en: Although you can declare a function in the format
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以按照以下格式声明一个函数
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'JavaScript interprets it as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 解释如下：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a result, it’s a best practice to define functions as variables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将函数定义为变量是一种最佳实践。
- en: Limiting use of the global scope
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制全局作用域的使用
- en: We’ve talked a lot about using the global scope, but in reality, you should
    try to limit your use of global variables. Your aim should be to keep the global
    scope as clean as possible, which becomes important as applications grow. Chances
    are that you’ll add various third-party libraries and modules. If all these libraries
    and modules use the same variable names in the global scope, your application
    will go into meltdown.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于使用全局作用域的内容，但现实中，你应该尽量限制全局变量的使用。你的目标应该是尽可能保持全局作用域的清洁，这对于应用程序的增长变得非常重要。很可能你会添加各种第三方库和模块。如果所有这些库和模块都在全局作用域中使用相同的变量名，你的应用程序将陷入崩溃。
- en: Global variables aren’t the “evil” that some people would have you believe,
    but you must be careful when using them. When you truly need global variables,
    a good approach is to create a container object in the global scope and put everything
    there. Do this with the ongoing name example to see how it looks by creating a
    `nameSetup` object in the global scope and use this to hold everything else.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量并不是一些人会让你相信的“邪恶”，但使用它们时必须小心。当你真正需要全局变量时，一个好的方法是在全局作用域中创建一个容器对象，并将所有内容放在那里。通过在全局作用域中创建一个
    `nameSetup` 对象并使用它来保存其他所有内容，你可以看到这样做是如何实现的。
- en: Listing D.12\. Using `const` to define functions globally
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.12\. 使用 `const` 在全局范围内定义函数
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Declares a global variable as an object**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将全局变量声明为一个对象**'
- en: '***2* Local variables are still okay inside functions.**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在函数内部仍然可以使用局部变量。**'
- en: '***3* Always access values of an object by using a fully qualified reference.**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 总是通过使用完全限定的引用来访问对象的值。**'
- en: When you code like this, all your variables are held together as properties
    of an object, keeping the global space nice and neat. Working like this also minimizes
    the risk of having conflicting global variables. You can add more properties to
    this object after declaration, and even add new functions. Adding to the preceding
    code listing, you could have the code shown next.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样编写代码时，所有变量都作为对象的属性一起存在，使得全局空间保持整洁。以这种方式工作还可以最大限度地减少全局变量冲突的风险。你可以在声明后向该对象添加更多属性，甚至添加新函数。在前面代码列表的基础上，你可以有下面的代码。
- en: Listing D.13\. Adding object properties
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.13\. 添加对象属性
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Defines a new function inside a global object**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在全局对象内部定义一个新函数**'
- en: '***2* Invokes a function and sends a parameter**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用一个函数并传递一个参数**'
- en: '***3* The output is “Simon D Holmes.”**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 输出结果为“Simon D Holmes。”**'
- en: Working in this way gives you control of your JavaScript and reduces the chances
    that your code will give you unpleasant surprises. Remember to declare variables
    in the appropriate scope and at the correct time, and group them into objects
    wherever possible.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式工作可以让你控制 JavaScript，并减少你的代码给你带来不愉快惊喜的机会。请记住，在适当的范围内并在正确的时间声明变量，并在可能的情况下将它们组合到对象中。
- en: Arrow functions
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 箭头函数
- en: So far, we’ve avoided discussing the JavaScript `this` variable. `this` is a
    fairly large topic and can be the source of much confusion. Simply put, the value
    of `this` changes depending on the context in which it’s used. For functions defined
    outside an `Object` context, `this` refers to the execution context where the
    function was defined when in strict mode; it defaults to the current execution
    context if not in strict mode, so it changes depending on when it’s used.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论 JavaScript 的 `this` 变量。`this` 是一个相当大的话题，可能会引起很多困惑。简单来说，`this`
    的值取决于其使用的上下文。对于在对象上下文外部定义的函数，`this` 在严格模式下指的是函数定义时的执行上下文；如果不处于严格模式，则默认为当前执行上下文，因此它的值会根据使用的时间而变化。
- en: Further, `this` can be bound to a different execution context if the prototype
    functions `call()` or `apply()` are used.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果使用了 `call()` 或 `apply()` 原型函数，`this` 可以绑定到不同的执行上下文。
- en: If a function is defined as an `Object` method, `this` refers to the surrounding
    object context. When used in an event handler, `this` refers to the DOM object
    that triggered the event.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数被定义为对象的方法，`this` 指的是周围的对象上下文。当在事件处理器中使用时，`this` 指的是触发事件的 DOM 对象。
- en: '*Arrow function expressions* (or arrow functions) cut through some of this
    confusion by not defining a `this` variable on creation, as happens with the `function`
    keyword. Some other context-related things are also not available, but `this`
    is by far the most important. Instead, it binds `this` to the surrounding lexical
    context and makes it ideal for nonmethod functions such as event handlers, callbacks,
    and global functions.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*箭头函数表达式*（或箭头函数）通过在创建时不定义 `this` 变量来消除一些这种困惑，这与 `function` 关键字发生的情况不同。还有一些其他与上下文相关的内容也不可用，但
    `this` 是最重要的。相反，它将 `this` 绑定到周围的词法上下文，使其非常适合非方法函数，如事件处理器、回调和全局函数。'
- en: The following listings provides the general form and some variations for arrow
    functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了箭头函数的一般形式和一些变体。
- en: Listing D.14\. Arrow function format
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.14\. 箭头函数格式
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* The most general form: arguments in parentheses (=>), function body (in
    braces)**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 最一般的形式：括号中的参数 (=>)，函数体（在大括号内）**'
- en: '***2* With a single expression, the braces can be omitted, but you get an implicit
    return equivalent to => { return expression; }.**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用单个表达式，可以省略花括号，但得到一个相当于 => { return expression; } 的隐式返回。**'
- en: '***3* If you have a single argument, you can omit the parentheses.**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果你有一个单个参数，你可以省略括号。**'
- en: '***4* Arrow functions with no arguments need the parentheses.**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 无参数的箭头函数需要括号。**'
- en: '***5* If you have a single argument and a single expression, omit the parentheses
    and the braces; remember that implicit return.**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 如果你有一个单个参数和一个单个表达式，可以省略括号和花括号；请记住隐式返回。**'
- en: Arrow functions provide a simpler, cleaner syntax, which in turn facilitates
    shorter, more compact, more expressive functions, especially combined with destructuring
    assignments. Plenty of examples throughout the book show how arrow functions can
    be used. For further information on `this`, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this);
    for more on arrow functions, see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数提供了一种更简单、更干净的语法，这反过来又促进了更短、更紧凑、更具有表现力的函数，尤其是在与解构赋值结合使用时。本书中提供了许多示例，展示了如何使用箭头函数。有关
    `this` 的更多信息，请参阅 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)；有关箭头函数的更多信息，请参阅
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).
- en: Destructuring
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解构
- en: Dimly reminiscent of the idea of pattern matching as used in some functional
    programming languages, destructuring allows for the unpacking of array values
    and object properties into distinct variables. If you’re passing objects into
    functions, destructuring means that you can explicitly state which properties
    from the argument object you want to use.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于在某些函数式编程语言中使用的模式匹配的概念，解构允许将数组值和对象属性解包到不同的变量中。如果你将对象传递给函数，解构意味着你可以明确指出你想要使用参数对象中的哪些属性。
- en: To use destructuring, on the LHS of the assignment operator (`=`) place square
    brackets for destructuring an array or braces for an object; then, add variable
    names for the values that you want. For arrays, variables get assigned values
    based on index order. For objects, you should use the keys from the object, but
    that’s not strictly necessary.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用解构，在赋值运算符（`=`）的左侧放置方括号以解构数组或花括号以解构对象；然后，添加你想要值的变量名。对于数组，变量根据索引顺序分配值。对于对象，你应该使用对象的键，但这不是严格必要的。
- en: The following listing details how to destructure an array.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表详细说明了如何解构数组。
- en: Listing D.15\. Destructuring an array
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.15\. 解构数组
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Assigns ‘first’ to fst and ‘second’ to snd and the remaining values to
    rest using the rest operator (...)**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用剩余操作符 (...) 将 ''first'' 赋给 fst，''second'' 赋给 snd，并将剩余的值赋给 rest**'
- en: '***2* Ignores the first value and pulls ‘second’ and ‘third’ into fst and snd
    respectively, not caring about anything else**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 忽略第一个值，将 ''second'' 和 ''third'' 分别拉入 fst 和 snd，而不关心其他任何东西**'
- en: '***3* Variables in destructuring can be assigned defaults if the assignment
    returns undefined. Here, snd will be 10.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在解构中，如果赋值返回 undefined，则变量可以分配默认值。这里，snd 将是 10。**'
- en: '***4* Swapping of variables; a becomes 4, and b becomes 3.**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 交换变量；a 变为 4，b 变为 3。**'
- en: Destructuring objects requires a little more care; you need to know what properties
    the object has so that they can be unpacked.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 解构对象需要更多的注意；你需要知道对象具有哪些属性，以便可以解包。
- en: See the following listing for examples of use.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下列表以获取使用示例。
- en: Listing D.16\. Destructuring objects
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.16\. 对象解构
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Unpacks properties a and c from the object**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从对象中解包属性 a 和 c**'
- en: '***2* Unpacks a and c, and assigns values to 10 and 100**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 解包 a 和 c，并将值赋给 10 和 100**'
- en: '***3* Unpacks a, and assigns default value to d if not in the provided object**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 解包 a，如果提供对象中没有 d，则将默认值赋给 d**'
- en: '***4* A new object with nested object structure**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 带有嵌套对象结构的新对象**'
- en: '***5* Arrow function that destructures the provided object; ultimately gets
    the value of width and uses that in the function**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 解构提供的对象的箭头函数；最终获取宽度值并在函数中使用它**'
- en: '***6* Uses the function; prints out 100**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用该函数；打印出 100**'
- en: Destructuring is an operation that can only be applied to the result of assignment,
    usually for function return values and regular expression matches, but can also
    be applied in function argument lists and in `for` ... `of` iteration. Further
    examples and information are available at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是一种只能应用于赋值结果的操作，通常用于函数返回值和正则表达式匹配，但也可以在函数参数列表和`for`...`of`迭代中使用。更多示例和信息可在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)找到。
- en: We use this technique in multiple places in the Loc8r codebase to cut down on
    the amount of data a function or callback is allowed to work with.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Loc8r代码库的多个地方使用这种技术，以减少函数或回调可以处理的数据量。
- en: Logic flow and looping
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑流程和循环
- en: Now we’ll take a quick look at best practices for the commonly used patterns
    of `if` statements and `for` loops. The text assumes that you’re familiar with
    these elements to some extent.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将快速查看常用`if`语句和`for`循环模式的最佳实践。本文假设你在某种程度上熟悉这些元素。
- en: 'Conditional statements: Working with if'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件语句：使用if
- en: JavaScript is helpful with `if` statements. If you have one expression within
    an `if` block, you don’t have to wrap it in curly braces `{}`. You can even follow
    it with an `else`. The code in the following listing is valid JavaScript.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在`if`语句中很有帮助。如果你在`if`块中只有一个表达式，你不需要用大括号`{}`包裹它。你甚至可以跟一个`else`。以下列表中的代码是有效的JavaScript。
- en: Listing D.17\. `if` without braces (bad practice)
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.17\. 无花括号的`if`（不良实践）
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Bad practice! Omitting { } around single-expression if blocks.**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不良实践！省略单表达式`if`块周围的{ }。**'
- en: Yes, you can do this in JavaScript, but no, you shouldn’t! Doing this relies
    on the layout of the code to be readable, which isn’t ideal. More important, what
    happens if you want to add some extra lines within the `if` blocks? Start by giving
    Sally a middle initial. See the following code listing for how you might logically
    try this.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以在JavaScript中这样做，但最好不要！这样做依赖于代码的布局易于阅读，这并不理想。更重要的是，如果你想在`if`块内添加一些额外的行，会发生什么？首先给Sally一个中间名。请参阅以下代码列表，了解你可能如何逻辑上尝试这样做。
- en: Listing D.18\. Demonstrating issue with no-brace `if`
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.18\. 展示无花括号的`if`问题
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Adds line into if block**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将行添加到if块中**'
- en: '***2* Output is “Simon Panayiotou.”**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输出是“Simon Panayiotou。”**'
- en: What went wrong here is that without the block braces, only the first expression
    is considered to be part of the block, and anything following is outside the block.
    So here, if `firstname` is Sally, `initial` becomes J, but `surname` always becomes
    Panayiotou.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里出问题的原因是，没有使用花括号，只有第一个表达式被认为是块的一部分，而任何跟在后面的都是块外部的。所以在这里，如果`firstname`是Sally，`initial`变为J，但`surname`总是变为Panayiotou。
- en: The following code listing shows the correct way of writing this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码列表显示了正确编写此代码的方式。
- en: Listing D.19\. Correctly formatted `if`
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.19\. 正确格式化的`if`
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Best practice! Always use { } to define if blocks.**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 最佳实践！始终使用{ }来定义if块。**'
- en: By being prescriptive, you see what the JavaScript interpreter sees and reduce
    the risk of unexpected errors. It’s a good aim to make your code as explicit as
    possible, and not leave anything open to interpretation. This practice helps both
    the quality of your code and your ability to understand it when you come back
    to it after a year of working on other things.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明确说明，你可以看到JavaScript解释器看到的内容，并减少意外错误的风险。让你的代码尽可能明确是一个好目标，不要留下任何可以解释的空间。这种做法有助于提高代码的质量，并有助于你在一年后回到它时理解它。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How many = symbols to use**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用多少个等号符号**'
- en: In the code snippets here, you’ll notice that in each of the `if` statements,
    `===` is used to check for a match. This is not only a best practice but also
    a great habit to get into.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提供的代码片段中，你会注意到在每个`if`语句中，都使用了`===`来检查匹配。这不仅是一种最佳实践，而且也是一种很好的习惯。
- en: The `===` (identity) operator is much stricter than `==` (equality). `===` provides
    a positive match only when the two operands are of the same type, such as number,
    string, and Boolean. `==` attempts type coercion to see whether the values are
    similar but a different type, which can lead to some interesting and unexpected
    results.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`===`（身份）运算符比 `==`（相等）运算符要严格得多。`===` 仅在两个操作数类型相同（如数字、字符串和布尔值）时提供正匹配。`==` 尝试类型强制转换以查看值是否相似但类型不同，这可能会导致一些有趣且意外的结果。'
- en: 'Look at the following code snippet for some interesting cases that could easily
    trip you up:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码片段中的一些可能让你陷入困境的有趣情况：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* True**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 正确**'
- en: '***2* False**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 错误**'
- en: 'In some situations, this might appear to be useful, but it’s far better to
    be clear and specific about what you consider to be a positive match as opposed
    to what JavaScript interprets as a positive match. If it doesn’t matter to your
    code whether `number` is a string or a number type, you can match one or the other:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这可能会显得很有用，但最好清楚地具体说明你认为是正匹配的内容，而不是 JavaScript 解释为正匹配的内容。如果你的代码不关心 `number`
    是字符串还是数字类型，你可以匹配其中一个：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The key is to *always use the exact operator* `===`. The same goes for the
    not equals operators: you should *always use the exact !==* instead of the loose
    `!=`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是始终使用精确运算符 `===`。对于不等于运算符也是如此：你应该始终使用精确的 `!==` 而不是松散的 `!=`。
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Running loops: Working with for'
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行循环：使用 `for`
- en: The most common method of looping through a collection of items is the `for`
    loop. JavaScript handles this task fairly well, but you should be aware of a couple
    of pitfalls and best practices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历项目集合的最常见方法是 `for` 循环。JavaScript 处理这个任务相当不错，但你应该注意一些陷阱和最佳实践。
- en: First, as with the `if` statement, JavaScript allows you to omit the curly braces
    `{}` around the block if you have only one expression in it. We hope that you
    know by now that this is a bad idea, as it is with the `if` statements. The following
    code listing shows some valid JavaScript that may not produce the results you
    expect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，与 `if` 语句一样，JavaScript 允许你在其中只有一个表达式时省略围绕块的括号 `{}`。我们希望你现在知道这是一个坏主意，就像在 `if`
    语句中一样。以下代码示例显示了一些可能不会产生你期望结果的合法 JavaScript 代码。
- en: Listing D.20\. `for` loop without braces (bad practice)
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.20\. 无花括号的 `for` 循环（不良实践）
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* The second statement is outside the loop, so it fires only once; and
    because i is defined in the for, it errors.**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 第二个语句在循环外部，所以它只运行一次；并且因为 i 在 `for` 中定义，所以它出错。**'
- en: From the way this is written and laid out, you might expect both `console.log()`
    statements to run on each iteration of the loop. For clarity, the preceding snippet
    should be written as in the following listing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从这种方式编写和布局来看，你可能会期望两个 `console.log()` 语句在循环的每次迭代中都会运行。为了清晰起见，前面的代码片段应该写成以下列表。
- en: Listing D.21\. Adding braces to a `for` loop
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.21\. 向 `for` 循环添加花括号
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We know that we keep going on about this, but making sure that your code reads
    the same way that JavaScript interprets it helps you! Bearing in mind this fact
    and the best practice for declaring variables, you should never see `let` inside
    a `for` conditional statement. Updating the preceding code snippet to meet this
    best practice gives you the following listing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们一直在谈论这个问题，但确保你的代码以与 JavaScript 解释相同的方式阅读对你有帮助！考虑到这个事实和声明变量的最佳实践，你永远不会在
    `for` 条件语句中看到 `let`。将前面的代码片段更新为符合这一最佳实践，你将得到以下列表。
- en: Listing D.22\. Extracting the variable declaration
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.22\. 提取变量声明
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Variables should be declared outside a for statement.**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 变量应在 `for` 语句外部声明。**'
- en: As the variable declaration should be at the top of the scope, there could be
    many lines of code between it and the variable’s first use in a loop. JavaScript
    interpreters act as though the variable has been defined there, so that’s where
    it should go.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变量声明应位于作用域的顶部，因此它和变量在循环中首次使用之间可能会有许多行代码。JavaScript 解释器会像变量已经在那里定义了一样行事，所以它应该放在那里。
- en: A common use for the `for` loop is to iterate through the contents of an array,
    so next, we’ll cover some best practices and issues to look out for.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环的常见用途是遍历数组的内容，因此接下来，我们将介绍一些最佳实践和需要注意的问题。'
- en: Using for loops with arrays
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用数组与循环
- en: 'The key to using `for` loops with arrays is remembering the arrays are zero-indexed:
    the first object in an array is in position 0\. The knock-on effect is that the
    position of the last item in the array is one less than the length. This sounds
    more complicated than it is. A simple array breaks down like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for` 循环遍历数组的要点是记住数组是零索引的：数组中的第一个对象位于位置 0。连锁反应是数组中最后一个项目的位置比长度少 1。这听起来比实际情况要复杂。一个简单的数组可以这样分解：
- en: '![](Images/p0429-01_alt.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0429-01_alt.jpg)'
- en: The typical code you might see for declaring an array like this and looping
    through it is in the following listing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 声明类似这样的数组并遍历它的典型代码如下所示。
- en: Listing D.23\. More `for` loop
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.23\. 更多的 `for` 循环
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Starts counting at 0; loops through while count is less than length.**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 0 开始计数；当计数小于长度时循环。**'
- en: This code works well and loops through the array correctly, starting at position
    0 and going through to the final position, 2\. Some people prefer to rule out
    the use of `i++` to autoincrement in their code because it can make code difficult
    to fathom. Personally, we think that `for` loops are the exception to this rule
    and in fact make the code easier to read, rather than adding a manual increment
    inside the loop itself.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行良好，正确地遍历了数组，从位置 0 开始，到最后的 2 位置。有些人更喜欢在他们的代码中排除使用 `i++` 自动递增，因为这可能会使代码难以理解。个人而言，我们认为
    `for` 循环是这一规则的例外，并且实际上使代码更容易阅读，而不是在循环内部手动递增。
- en: You can do one thing to improve the performance of this code. Each time the
    loop goes around, JavaScript checks the length of `myArray`. This process would
    be quicker if JavaScript checked against a variable, so a better practice is to
    declare a variable to hold the length of the array. You can see this solution
    in action in the following code listing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取一个方法来提高这段代码的性能。每次循环时，JavaScript 都会检查 `myArray` 的长度。如果 JavaScript 是检查一个变量，这个过程会更快，因此更好的做法是声明一个变量来保存数组的长度。你可以在下面的代码列表中看到这个解决方案的实际应用。
- en: Listing D.24\. Alternative `for` loop declaration
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.24\. 替代的 `for` 循环声明
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Declares arrayLength variable with other variables**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明 arrayLength 变量与其他变量一起**'
- en: '***2* Assigns length of array to arrayLength when setting up the loop**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在设置循环时将数组的长度赋给 arrayLength**'
- en: Now a new variable, `arrayLength`, is given the length of the array to be looped
    through when the loop is initiated. The script needs to check the length of the
    array only once, not on every loop.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个新变量 `arrayLength`，在循环开始时被赋予要遍历的数组的长度。脚本只需要检查一次数组的长度，而不是每次循环都检查。
- en: Getting to know JSON
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 JSON
- en: JavaScript Object Notation (JSON) is a JavaScript-based approach to data exchange.
    It’s much smaller than XML, more flexible, and easier to read. JSON is based on
    the structure of JavaScript objects but is language independent and can be used
    to transfer data among all manner of programming languages.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象表示法 (JSON) 是一种基于 JavaScript 的数据交换方法。它比 XML 小得多，更灵活，也更易于阅读。JSON
    基于JavaScript 对象的结构，但它是语言无关的，可以用于在所有类型的编程语言之间传输数据。
- en: We’ve used objects in our sample code in this book, and because JSON is based
    on JavaScript objects, we’ll discuss them here briefly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书的示例代码中使用了对象，因为 JSON 是基于 JavaScript 对象的，所以我们在这里简要讨论一下。
- en: JavaScript object literals
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JavaScript 对象字面量
- en: In JavaScript, everything other than the simplest data types—string, number,
    Boolean, null, and undefined—is an object, including arrays and functions. Object
    literals are what most people think of as JavaScript objects; they’re typically
    used to store data but can also contain functions, as you’ve already seen.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，除了最简单的数据类型（字符串、数字、布尔值、null 和 undefined）之外的所有内容都是对象，包括数组和函数。对象字面量是大多数人认为的
    JavaScript 对象；它们通常用于存储数据，但也可以包含函数，就像你之前看到的。
- en: Looking at the contents of a JavaScript object
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查看JavaScript 对象的内容
- en: A JavaScript object is a collection of key-value pairs, which are the properties
    of the object. Each key must have a value.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象是一系列键值对的集合，这些键值对是对象的属性。每个键都必须有一个值。
- en: 'The rules for a key are simple:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 键的规则很简单：
- en: The key must be a string.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键必须是一个字符串。
- en: The string must be wrapped in double quotes if it’s a JavaScript reserved word
    or an illegal JavaScript name.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符串是 JavaScript 保留字或非法 JavaScript 名称，则必须用双引号括起来。
- en: The value can be any JavaScript value, including functions, arrays, and nested
    objects. The following listing shows a valid JavaScript object literal based on
    these rules.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以是任何 JavaScript 值，包括函数、数组和嵌套对象。以下列表显示了基于这些规则的合法 JavaScript 对象字面量。
- en: Listing D.25\. An example of a JavaScript object literal
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.25\. 一个 JavaScript 对象字面量的示例
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* A simple key-value pair**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个简单的键值对**'
- en: '***2* A complex key surrounded by double quotes**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 被双引号包围的复杂键**'
- en: '***3* A function**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一个函数**'
- en: '***4* ‘this’ in the function points to the surrounding object due to the function
    keyword; an arrow function here would point to the global scope.**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 函数中的 `this` 指向周围的对象，因为函数关键字；在这里，箭头函数将指向全局作用域。**'
- en: '***5* Sets up an array as a value in the object**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在对象中将数组设置为值**'
- en: 'Here, all keys in the object are strings, but the values are a mixture of types:
    string, number, Boolean, null, function, and array.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对象中的所有键都是字符串，但值是多种类型的混合：字符串、数字、布尔值、null、函数和数组。
- en: Accessing the properties of an object literal
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 访问对象字面量的属性
- en: The preferred way to access properties is to use dot notation (`.`). Examples
    are
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 访问属性的推荐方式是使用点表示法 (`.`)。例如：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These examples can be used to get or set property values. If a property doesn’t
    exist when you try to *get* it, JavaScript returns `undefined`. If a property
    doesn’t exist when you try to *set* it, JavaScript adds it to the object and creates
    it for you.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例可以用来获取或设置属性值。如果你尝试 *获取* 不存在的属性，JavaScript 返回 `undefined`。如果你尝试 *设置* 不存在的属性，JavaScript
    会将其添加到对象中，并为你创建它。
- en: You can’t use dot notation when the key name is a reserved word or an illegal
    JavaScript name. To access these properties, you need to wrap the key string in
    square braces `[]`. A couple of examples are
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当键名是保留字或非法 JavaScript 名称时，不能使用点表示法。要访问这些属性，需要将键字符串用方括号 `[]` 括起来。以下是一些示例：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Again, these references can be used to get or set the values.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些引用可以用来获取或设置值。
- en: Next, we’ll take a look at how JSON is related.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看 JSON 是如何相关的。
- en: Differences with JSON
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与 JSON 的区别
- en: 'JSON is based on the notation of JavaScript object literals, but because it’s
    designed to be language independent, there are a couple of important differences:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 基于 JavaScript 对象字面量的表示法，但由于它被设计成语言无关，有一些重要的区别：
- en: All key names and strings must be wrapped in double quotes.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有键名和字符串都必须用双引号括起来。
- en: Functions aren’t a supported data type.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不是一个支持的数据类型。
- en: These two differences occur largely because you don’t know what will be interpreting
    it. Other programming languages won’t be able to process JavaScript functions
    and probably will have different sets of reserved names and restrictions on names.
    If you send all names as strings, you can bypass this issue.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个区别主要发生是因为你不知道什么会解释它。其他编程语言将无法处理 JavaScript 函数，并且可能有一组不同的保留名称和名称限制。如果你将所有名称作为字符串发送，你可以绕过这个问题。
- en: Allowable data types in JSON
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JSON 中允许的数据类型
- en: You can’t send functions with JSON, but as it’s a data exchange format, that’s
    not such a bad thing. The data types you can send are
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用 JSON 发送函数，但作为数据交换格式，这并不是一件坏事。你可以发送的数据类型是
- en: Strings
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Numbers
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: Objects
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Arrays
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Booleans
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: The value `null`
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值 `null`
- en: Looking at this list and comparing it with the JavaScript object in [listing
    D.25](#app04ex25), if you remove the `function` property, you should be able to
    convert it to JSON.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看此列表并将其与 [列表 D.25](#app04ex25) 中的 JavaScript 对象进行比较，如果你移除 `function` 属性，你应该能够将其转换为
    JSON。
- en: Formatting JSON data
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 格式化 JSON 数据
- en: Unlike with the JavaScript object, we’re not assigning the data to a variable;
    neither do we need a trailing semicolon. By wrapping all key names and strings
    in double quotes—and they do have to be double quotes—we can generate the following
    listing.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 对象不同，我们不是将数据赋给一个变量；我们也不需要尾随的分号。通过将所有键名和字符串用双引号括起来——它们确实必须是双引号——我们可以生成以下列表。
- en: Listing D.26\. An example of correctly formatted JSON
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.26\. 正确格式化的 JSON 示例
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* With JSON, you can send strings.**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 JSON 中，你可以发送字符串。**'
- en: '***2* Empty strings**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 空字符串**'
- en: '***3* Numbers**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 数字**'
- en: '***4* Boolean values**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 布尔值**'
- en: '***5* Null**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* Null**'
- en: '***6* Arrays of other JSON objects**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 其他 JSON 对象的数组**'
- en: This listing shows some valid JSON. This data can be exchanged between applications
    and programming languages without issue. It’s also easy for the human eye to read
    and understand.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了一些有效的 JSON。这些数据可以在应用程序和编程语言之间无问题地交换。它也易于人类眼睛阅读和理解。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Sending strings containing double quotes**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送包含双引号的字符串**'
- en: JSON specifies that all strings must be wrapped in double quotes. What if your
    string contains double quotes? The first double quote that an interpreter comes
    across will be seen as the end delimiter for the string, so it will most likely
    throw an error when the next item isn’t valid JSON.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 规定所有字符串必须用双引号括起来。如果你的字符串中包含双引号怎么办？解释器遇到的第一个双引号将被视为字符串的结束分隔符，因此当下一个项目不是有效的
    JSON 时，它很可能会抛出错误。
- en: 'The following code snippet shows an example. There are two double quotes inside
    the string, which isn’t valid JSON and will cause errors:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了示例。字符串中有两个双引号，这不是有效的 JSON，会导致错误：
- en: '[PRE32]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The answer to this problem is to escape nested double quotes with the backslash
    character (`\`). Applying this technique produces the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使用反斜杠字符（`\`）转义嵌套的双引号。应用这种技术会产生以下结果：
- en: '[PRE33]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This escape character tells JSON interpreters that the following character shouldn’t
    be considered to be part of the code; it’s part of the value and can be ignored.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此转义字符告诉 JSON 解释器，接下来的字符不应被视为代码的一部分；它是值的一部分，可以忽略。
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Shrinking JSON for transporting across the internet
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 缩小 JSON 以在网络中传输
- en: The spacing and indentation in [listing D.26](#app04ex26) are purely to aid
    human readability; programming languages don’t need them. You can reduce the amount
    of information being transmitted if you remove unnecessary whitespace before sending
    the code.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 D.26](#app04ex26) 中的间距和缩进纯粹是为了帮助人类可读性；编程语言不需要它们。在发送代码之前，如果你移除不必要的空白，可以减少传输的信息量。'
- en: 'The following code snippet shows a minimized version of [listing D.26](#app04ex26),
    which is more along the lines of what you’d expect to exchange between applications:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了 [列表 D.26](#app04ex26) 的最小化版本，这更符合你期望在应用程序之间交换的内容：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The content is exactly the same as that of [listing D.26](#app04ex26), but much
    more compact.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 内容与 [列表 D.26](#app04ex26) 完全相同，但更加紧凑。
- en: Why is JSON so good?
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么 JSON 如此之好？
- en: The popularity of JSON as a data exchange format predates the development of
    Node by quite some time. JSON began to flourish as the ability of browsers to
    run complex JavaScript increased. Having a data format that was (almost) natively
    supported was extremely helpful and made life considerably easier for front-end
    developers.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 作为数据交换格式的流行早于 Node 的开发。随着浏览器运行复杂 JavaScript 的能力增强，JSON 开始蓬勃发展。拥有一个（几乎）原生支持的数据格式非常有帮助，并且极大地简化了前端开发者的工作。
- en: The previous preferred data exchange format was XML. Compared with JSON, XML
    is harder to read at a glance, much more rigid, and considerably larger to send
    across networks. As you saw in the JSON examples, JSON doesn’t waste much space
    on syntax. JSON uses the minimum amount of characters required to accurately hold
    and structure the data, not a lot more.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 之前首选的数据交换格式是 XML。与 JSON 相比，XML 更难一眼看懂，结构更严格，发送到网络上的数据量也更大。正如你在 JSON 示例中看到的，JSON
    在语法上几乎不浪费空间。JSON 使用最少的字符来准确存储和结构化数据，而不是更多。
- en: When it comes to the MEAN stack, JSON is the ideal format for passing data through
    the layers of the stack. MongoDB stores data as binary JSON (BSON). Node and Express
    can interpret this natively and also push it out to Angular, which also uses JSON
    natively. Every part of the MEAN stack, including the database, uses the same
    data format, so you have no data transformations to worry about.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 MEAN 栈时，JSON 是在栈层之间传递数据的理想格式。MongoDB 将数据存储为二进制 JSON（BSON）。Node 和 Express
    可以原生地解释它，并将其推送到 Angular，Angular 也原生地使用 JSON。MEAN 栈的每个部分，包括数据库，都使用相同的数据格式，因此你无需担心数据转换。
- en: Formatting practices
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化实践
- en: The code samples in this book use some of our personal preferences for laying
    out code. Some of these practices are necessary best practices; others increase
    readability. If you have different preferences, as long as the code remains correct,
    that’s absolutely fine; the important thing is to be consistent.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码示例使用了一些我们个人的代码布局偏好。其中一些做法是必要的最佳实践；其他做法增加了可读性。如果你有不同的偏好，只要代码保持正确，那就绝对没问题；重要的是要保持一致性。
- en: The main reasons for being concerned about formatting are
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 人们对格式化感到担忧的主要原因是
- en: Ensuring syntactically correct JavaScript
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保JavaScript的语法正确
- en: Ensuring that your code functions correctly when minified
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保代码在压缩后仍能正确运行
- en: Improving readability for yourself and/or others on your team
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高自己和/或团队其他成员的代码可读性
- en: 'Start with an easy formatting practice: indentation.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单的格式化实践开始：缩进。
- en: Indenting code
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缩进代码
- en: The only real reason to indent your code is to make it considerably easier for
    mere humans to read. JavaScript interpreters don’t care about it and will happily
    run code without any indentation or line breaks.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正的原因是缩进你的代码是为了使它对普通人来说更容易阅读。JavaScript解释器并不关心它，并且会高兴地运行没有缩进或换行的代码。
- en: Best practice for indentation is to use spaces, not tabs, as there’s still no
    standard for the placement of tab stops. How many spaces you choose is up to you;
    we personally prefer two spaces. We find that using one space can make code difficult
    to follow at a glance, as the difference isn’t all that big. Four spaces can make
    your code unnecessarily wide (again, in our opinion). We like to balance the readability
    gains of indentation against the benefits of maximizing the amount of code you
    can see onscreen at any time—well, for that reason and a dislike of horizontal
    scrolling.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的缩进实践是使用空格而不是制表符，因为目前还没有关于制表符位置的标准。你选择多少空格由你决定；我们个人更喜欢两个空格。我们发现使用一个空格会使代码难以一目了然，因为差异并不大。四个空格会使你的代码显得过于宽（再次，这是我们的观点）。我们喜欢在缩进的易读性增益和最大化你能在屏幕上同时看到代码量的好处之间取得平衡——嗯，出于这个原因，以及不喜欢水平滚动。
- en: Position of braces for functions and blocks
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数和代码块的大括号位置
- en: A best practice you should get into is placing the opening bracket of a code
    block at the end of the statement that starts the block. What? All the code snippets
    so far have been written this way. The following code listing shows the right
    way and the wrong way of placing braces.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该养成的一个最佳实践是将代码块的开括号放在开始该块的语句的末尾。什么？到目前为止的所有代码片段都是这样写的。下面的代码列表显示了正确和错误放置大括号的方法。
- en: Listing D.27\. Brace placements
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.27\. 大括号放置
- en: '[PRE35]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Right way: opening bracket on the same line as the statement**'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 正确方法：括号与语句在同一行**'
- en: '***2* Wrong way: opening bracket on its own line**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 错误方法：括号单独一行**'
- en: At least 99% of the time, the second approach won’t cause you a problem. The
    first approach won’t cause you a problem 100% of the time. We’ll take that over
    wasting time debugging; how about you?
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 至少99%的时间，第二种方法不会给你带来问题。第一种方法100%的时间都不会给你带来问题。我们宁愿选择节省时间调试，你呢？
- en: 'What’s the 1% of the time when the wrong approach will cause you a problem?
    Consider a code snippet that uses the `return` statement:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 有1%的时间，错误的方法会导致问题？考虑一个使用`return`语句的代码片段：
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you put your opening bracket on a different line, JavaScript assumes that
    you’ve missed a semicolon after the `return` command itself and adds one for you.
    JavaScript evaluates it like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将你的开括号放在不同的行上，JavaScript会假设你遗漏了`return`命令后面的分号，并为你添加一个。JavaScript这样评估：
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* JavaScript inserts a semicolon after the return statement and so ignores
    the following code.**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* JavaScript在return语句后插入分号，因此忽略了后面的代码。**'
- en: Due to JavaScript’s semicolon insertion, it doesn’t return the object you intended;
    instead, JavaScript returns `undefined`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript的自动分号插入，它没有返回你打算返回的对象；相反，JavaScript返回`undefined`。
- en: Next, we’ll look at semicolon use and JavaScript semicolon insertion in more
    detail.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更详细地探讨分号的使用和JavaScript的分号插入。
- en: Using the semicolon correctly
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正确使用分号
- en: JavaScript uses the semicolon character to denote the end of statements. It
    tries to be helpful by making this character optional and injects its own semicolons
    at runtime if it deems it necessary to do so, which isn’t a good thing at all.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用分号字符表示语句的结束。它试图提供帮助，通过使这个字符可选，并在运行时认为有必要时注入它自己的分号，这根本不是一件好事。
- en: When using semicolons to delimit statements, you should return to the goal of
    seeing in the code what the JavaScript interpreter sees and not let it make any
    assumptions. We treat semicolons as not optional, and we’re now at a point where
    code looks wrong to us if they’re not there.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用分号分隔语句时，你应该回到在代码中看到JavaScript解释器看到的内容的目标，而不是让它做出任何假设。我们将分号视为非可选的，并且我们现在处于一个如果它们不存在，代码看起来就不正确的点。
- en: Most lines of your JavaScript have a semicolon at the end, but not all; that
    would be too easy! All the statements in the following listing should end with
    a semicolon.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你的大部分 JavaScript 代码行都以分号结尾，但并非所有；那会太简单了！以下列表中的所有语句都应该以分号结尾。
- en: Listing D.28\. Examples of semicolon use
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.28\. 分号使用示例
- en: '[PRE38]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Use a semicolon at the end of most statements.**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在大多数语句的末尾使用分号**。'
- en: But code blocks shouldn’t end with a semicolon. We’re talking about blocks of
    code associated with `if`, `switch`, `for`, `while`, `try`, `catch`, and `function`
    (when not being assigned to a variable). The following listing shows a few examples.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 但代码块不应该以分号结束。我们说的是与`if`、`switch`、`for`、`while`、`try`、`catch`和`function`（当不是赋值给变量时）相关的代码块。以下列表展示了几个例子。
- en: Listing D.29\. Using code blocks without semicolons
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.29\. 使用不带分号的代码块
- en: '[PRE39]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* No semicolon used at end of code block**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 代码块末尾没有使用分号**'
- en: The rule isn’t quite so straightforward as “don’t use a semicolon” after curly
    braces. When assigning a function or object to a variable, you *do* have a semicolon
    after the curly braces. You’ve seen a couple of examples, which we’ve been using
    throughout the book.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则并不像在花括号后“不要使用分号”那样简单明了。当将函数或对象赋值给变量时，你*确实*需要在花括号后使用分号。你已经看到了几个例子，这些例子我们在整本书中都在使用。
- en: Listing D.30\. Semicolon placement for assigned blocks
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.30\. 赋值块的分号放置
- en: '[PRE40]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Semicolons after curly braces when assigning to a variable**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在将值赋给变量时在花括号后使用分号**'
- en: Putting semicolons after blocks can take a little while to get used to, but
    it’s worth the effort and eventually becomes second nature.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块后放置分号可能需要一点时间来习惯，但这是值得的，最终会变得自然而然。
- en: Placing commas in a list
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在列表中放置逗号
- en: When you’re defining a long list of variables at the top of a scope, the most
    common approach is to write one variable name per line. This practice makes it
    easy to see at a glance what variables you’ve set up. The classic placement for
    the comma that separates variables is at the end of the line.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在作用域顶部定义一个长变量列表时，最常见的方法是每行写一个变量名。这种做法使得一眼就能看到你设置了哪些变量。分隔变量的逗号经典位置是在行尾。
- en: Listing D.31\. Comma-last placement
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.31\. 逗号后放置
- en: '[PRE41]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Uses a comma at the end of each line, separating it from the next variable
    declaration**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每行末尾使用逗号，将其与下一个变量声明分开**'
- en: This approach is Simon’s preferred approach, as he’s been using it for about
    15 years. Clive, on the other hand, advocates putting the comma at the front of
    each line.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法西蒙更喜欢，因为他已经使用了大约 15 年。另一方面，克莱夫主张将逗号放在每行的开头。
- en: Listing D.32\. Comma-first placement
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.32\. 逗号优先放置
- en: '[PRE42]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Uses a comma at start of each line, separating it from next variable
    declaration**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每行开头使用逗号，将其与下一个变量声明分开**'
- en: This JavaScript is perfectly valid and when minified to one line, reads exactly
    the same as the first code snippet. Simon has tried to get used to it, but he
    can’t; it looks wrong to him. Clive thinks that comma-first is a good idea, but
    he thinks Elm is great too.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 JavaScript 完全有效，当压缩成一行时，与第一个代码片段读取完全相同。西蒙试图习惯它，但他做不到；对他来说看起来不对。克莱夫认为逗号优先是一个好主意，但他也认为
    Elm 很棒。
- en: There are arguments for and against both approaches. Your choice comes down
    to personal preference. The critical thing is to have a standard and stick to
    it.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种方法都有赞成和反对的论点。你的选择取决于个人喜好。关键是要有一个标准并坚持它。
- en: Don’t be afraid of whitespace
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不要害怕空白
- en: Adding a bit of whitespace between sets of braces can help readability and won’t
    cause any problems for JavaScript. Again, you’ve seen this approach in all the
    code snippets so far. You can also add or remove whitespace from between a lot
    of JavaScript operators. Take a look at the following code snippet, showing the
    same piece of code with and without extra whitespace.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在花括号组之间添加一些空白可以帮助提高可读性，并且不会对 JavaScript 产生任何问题。同样，你已经在所有之前的代码片段中看到了这种方法。你还可以在许多
    JavaScript 运算符之间添加或删除空白。请看以下代码片段，展示了带有和没有额外空白的相同代码片段。
- en: Listing D.33\. Examples of whitespace formatting
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.33\. 空白格式化示例
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* JavaScript snippet using whitespace for readability**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用空白提高可读性的 JavaScript 片段**'
- en: '***2* Same snippet with whitespace removed (excluding indentation)**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 删除空白后的相同代码片段（不包括缩进）**'
- en: As humans, we read by using whitespace as the delimiters for words, and the
    way we read code is no different. Yes, you can figure out the second part of the
    code snippet here, as many syntactic pointers act as delimiters, but it’s quicker
    and easier to read and understand the first part. JavaScript interpreters don’t
    notice the whitespace in these places, and if you’re concerned about increasing
    the file size for browser-based code, you can always minimize it before pushing
    it live.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们通过使用空白作为单词的分隔符来阅读，我们阅读代码的方式也是如此。是的，你可以弄清楚这里代码片段的第二部分，因为许多语法指针充当分隔符，但阅读和理解第一部分更快、更容易。JavaScript
    解释器不会注意到这些地方的空白，如果你担心基于浏览器的代码文件大小增加，你可以在将其推送到生产环境之前将其最小化。
- en: Tools to help you write good JavaScript
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 帮助你编写良好 JavaScript 的工具
- en: A couple of online code-quality checkers called JSHint and ESLint check the
    quality and consistency of your code. Even better, most IDEs and good text editors
    have plugins or extensions for one or the other, so your code can be quality-checked
    as you go. These tools are useful for spotting the occasional missed semicolon
    or a comma in the wrong place.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 几个在线代码质量检查器，称为 JSHint 和 ESLint，检查你代码的质量和一致性。更好的是，大多数 IDE 和好的文本编辑器都有一个或多个插件或扩展，因此你的代码可以在编写过程中进行质量检查。这些工具对于发现偶尔遗漏的分号或位置错误的逗号非常有用。
- en: Of the two tools, ESLint is geared more toward linting ES2015 code. TypeScript
    has its own linter, TSLint, which Angular installs by default.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个工具中，ESLint 更侧重于检查 ES2015 代码。TypeScript 有自己的代码检查器，即 TSLint，Angular 默认安装。
- en: String formatting
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: ES2015 introduced an alternative way of formatting strings akin to string interpolation,
    as you’d find in many different languages. JavaScript calls this type of formatting
    *template literals*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 引入了一种类似于许多不同语言中的字符串插值的字符串格式化方法。JavaScript 将这种格式称为 *模板字符串*。
- en: A template literal is denoted with backticks where you’d ordinarily use single
    or double quotes to define a string. To perform the interpolation, the element
    (variable or function call result) that you wish inserted into the string needs
    to be wrapped by `'${}'`. The following listing shows how this works.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串用反引号表示，在通常使用单引号或双引号定义字符串的地方。要执行插值，你希望插入到字符串中的元素（变量或函数调用结果）需要被 `'${}'` 包裹。下面的列表显示了这是如何工作的。
- en: Listing D.34\. Using template literals
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.34\. 使用模板字符串
- en: '[PRE44]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Template literal**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 模板字符串**'
- en: '***2* Result of the interpolation**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 插值结果**'
- en: Understanding callbacks
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解回调
- en: The next aspect of JavaScript programming that we’ll look at is *callbacks*.
    Callbacks often seem to be confusing or complicated at first, but if you take
    a look under the hood, you’ll find that they’re fairly straightforward. Chances
    are that you’ve already used them.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要探讨的 JavaScript 编程的下一个方面是 *回调*。回调一开始可能看起来很复杂，但如果你深入了解，你会发现它们相当简单。很可能你已经使用过它们了。
- en: Callbacks are typically used to run a piece of code after a certain event has
    happened. Whether this event is a link being clicked, data being written to a
    database, or another piece of code finishing executing isn’t important, as the
    event could be almost anything. A callback function itself is typically an *anonymous
    function*—a function declared without a name—that’s passed directly to the receiving
    function as a parameter. Don’t worry if this seems like jargon right now; we’ll
    look at code examples soon, and you’ll see how easy it is.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 回调通常用于在某个事件发生后运行一段代码。无论这个事件是链接被点击、数据写入数据库还是其他代码执行完毕，这并不重要，因为事件可以是几乎任何东西。回调函数本身通常是一个
    *匿名函数*——一个没有名称的函数，它作为参数直接传递给接收函数。现在如果这听起来像是术语，请不要担心；我们很快就会看到代码示例，你会看到它是多么简单。
- en: Using setTimeout to run code later
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `setTimeout` 在稍后运行代码
- en: 'Most of the time, you use callbacks to run code after something happens. To
    get accustomed to the concept, you can use a function that’s built into JavaScript:
    `setTimeout()`. You may have already used it. In a nutshell, `setTimeout()` runs
    a callback function after the number of milliseconds that you declare. The basic
    construct for using it as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你使用回调在某个事件发生后运行代码。为了熟悉这个概念，你可以使用 JavaScript 中内置的函数：`setTimeout()`。你可能已经使用过它。简而言之，`setTimeout()`
    在你声明的毫秒数后运行回调函数。使用它的基本结构如下：
- en: '![](Images/p0439-01_alt.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/p0439-01_alt.jpg)'
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Canceling a setTimeout**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**取消 `setTimeout`**'
- en: 'If a `setTimeout` declaration has been assigned to a variable, you can use
    that variable to clear the timeout and stop it from completing, assuming that
    it hasn’t already completed. You use the `clearTimeout()` function, which works
    like so:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`setTimeout`声明已经被分配给一个变量，你可以使用这个变量来清除超时并停止它完成，前提是它还没有完成。你使用`clearTimeout()`函数，它的工作方式如下：
- en: '[PRE45]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This code snippet wouldn’t output anything to the log, as the `waitForIt` timer
    is cleared before it has the chance to complete.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段不会向日志输出任何内容，因为`waitForIt`计时器在它有机会完成之前就被清除了。
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: First, `setTimeout()` is declared inside a variable so that you can access it
    again to cancel it, should you want to. As we mentioned earlier, a callback is
    typically an unnamed anonymous function. If you wanted to log your name to the
    JavaScript console after 2 seconds, you could use this code snippet.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`setTimeout()`被声明在一个变量中，这样你就可以再次访问它来取消它，如果你想要的话。正如我们之前提到的，回调通常是一个未命名的匿名函数。如果你想在你名字在2秒后出现在JavaScript控制台，你可以使用这个代码片段。
- en: Listing D.35\. Capturing `setTimeout` reference
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.35\. 捕获`setTimeout`引用
- en: '[PRE46]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Callbacks are asynchronous. They run when they’re required, not necessarily
    in the order in which they appear in your code.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是异步的。它们在需要时运行，不一定是在你代码中出现的顺序。
- en: '|  |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Keeping in mind this asynchronous nature, what would you expect the output of
    the following code snippet to be?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这种异步特性，你预计以下代码片段的输出会是什么？
- en: '[PRE47]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you read the code from top to bottom, the console log statements appear
    to make sense. But because the `setTimeout()` callback is asynchronous, it doesn’t
    hold up the processing of code, so you end up with this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从上到下阅读代码，控制台日志语句看起来似乎是有意义的。但是，因为`setTimeout()`回调是异步的，它不会阻止代码的处理，所以你最终得到的是这样的结果：
- en: '[PRE48]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As a conversation, this result clearly doesn’t flow properly. In code, having
    the correct flow is essential; otherwise, your applications quickly fall apart.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一次对话，这个结果显然没有流畅地进行。在代码中，拥有正确的流程是至关重要的；否则，你的应用程序很快就会崩溃。
- en: Because this asynchronous approach is so fundamental to working with Node, we’ll
    look into it a little deeper.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种异步方法对于使用Node来说非常基础，所以我们将更深入地探讨它。
- en: Asynchronous code
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 异步代码
- en: Before you look at some more code, reminding yourself of the bank-teller analogy
    from [chapter 1](kindle_split_011.xhtml#ch01). [Figure D.3](#app04fig03) shows
    how a bank teller can deal with multiple requests by passing any time-consuming
    tasks to other people.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在你查看更多代码之前，提醒自己一下[第1章](kindle_split_011.xhtml#ch01)中的银行柜员类比。[图D.3](#app04fig03)展示了银行柜员如何通过将任何耗时任务转交给其他人来处理多个请求。
- en: Figure D.3\. Handling multiple requests
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图D.3\. 处理多个请求
- en: '![](Images/dfig03_alt.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig03_alt.jpg)'
- en: The bank teller is able to respond to Sally’s request because she passed responsibility
    for Simon’s request to the safe manager. The teller isn’t interested in how the
    safe manager does what he does or how long it takes. This approach is asynchronous.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 银行柜员能够响应萨莉的请求，因为她将西蒙的请求的责任转给了保险柜经理。柜员不关心保险柜经理是如何做他的工作或需要多长时间。这种方法是异步的。
- en: You can mimic this approach in JavaScript by using the `setTimeout()` function
    to demonstrate the asynchronous approach. All you need are some `console.log()`
    statements to demonstrate the bank teller’s activity and a couple of timeouts
    to represent the delegated tasks. You can see this approach in the following code
    listing, where it’s assumed that Simon’s request will take 3 seconds (3,000 ms),
    and Sally’s will take 1 second.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`setTimeout()`函数在JavaScript中模拟这种方法来演示异步方法。你所需要的只是一些`console.log()`语句来演示银行柜员的操作，以及几个超时来表示委托的任务。你可以在以下代码列表中看到这种方法，其中假设西蒙的请求需要3秒（3,000毫秒），而萨莉的请求需要1秒。
- en: Listing D.36\. Asynchronous flow
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.36\. 异步流程
- en: '[PRE49]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Takes first request**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 处理第一个请求**'
- en: '***2* Takes second request**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 处理第二个请求**'
- en: '***3* Ready for another request**'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 准备处理下一个请求**'
- en: '***4* Sally’s response appears after 1 second.**'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 萨莉的响应在1秒后出现。**'
- en: '***5* Simon’s response appears after another 2 seconds.**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 西蒙的响应在另外2秒后出现。**'
- en: 'This code has three distinct blocks: taking the first request from Simon and
    sending it away ***1***; taking the second request from Sally and sending it away
    ***2***; and ready to take another request ***3***. If this code were synchronous
    code like you’d see in PHP or .NET, you’d deal with Simon’s request in its entirety
    before taking Sally’s request 3 seconds later.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有三个不同的块：首先从西蒙那里接收请求并将其发送出去 ***1***；然后从萨利那里接收请求并将其发送出去 ***2***；以及准备好接受另一个请求
    ***3***。如果这段代码是像在 PHP 或 .NET 中看到的同步代码，你会在 3 秒后处理萨利的请求之前，先处理西蒙的请求的全部内容。
- en: With an asynchronous approach, the code doesn’t have to wait for one of the
    requests to complete before taking another one. You can run this code snippet
    in your browser to see how it works. Put it in an HTML page and run it, or enter
    it directly in the JavaScript console.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步方法，代码不需要等待一个请求完成后再处理另一个请求。你可以在浏览器中运行此代码片段以查看其工作方式。将其放入一个 HTML 页面并运行，或者直接在
    JavaScript 控制台中输入。
- en: We hope that you see how this code mimics the scenario we talked through as
    we kicked off this section. Simon’s request was first in, but as it took some
    time to complete, the response didn’t come back immediately. While somebody was
    dealing with Simon’s request, Sally’s request was taken. While Sally’s request
    was being dealt with, the bank teller became available again to take another request.
    As Sally’s request took less time to complete, she got her response first, whereas
    Simon had to wait a bit longer for his response. Neither Sally nor Simon got held
    up by the other.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你能看到这段代码如何模仿我们在本节开始时讨论的场景。西蒙的请求首先到来，但由于需要一些时间来完成，所以响应没有立即返回。当有人在处理西蒙的请求时，萨利的请求被接受。当萨利的请求正在被处理时，银行出纳员再次可用以接受另一个请求。由于萨利的请求完成得更快，她首先得到了响应，而西蒙则需要等待更长的时间才能得到他的响应。萨利和西蒙都没有因为对方而受阻。
- en: Now go one step further by looking at what might be happening *inside* the `setTimeout()`
    function.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进一步看看 `setTimeout()` 函数内部可能发生的情况。
- en: Running a callback function
  id: totrans-409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行回调函数
- en: We’re not going show you the source code of `setTimeout()` here, but a skeleton
    function that uses a callback. Declare a new function called `setTimeout()` that
    accepts the parameters `callback` and `delay`. The names aren’t important; they
    can be anything you want. The following code listing demonstrates this function.
    (Note that you won’t be able to run this function in a JavaScript console.)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里展示 `setTimeout()` 的源代码，但会展示一个使用回调的框架函数。声明一个新的函数名为 `setTimeout()`，它接受
    `callback` 和 `delay` 参数。名称并不重要；它们可以是任何你想要的。以下代码列表展示了这个函数。（注意，你无法在 JavaScript 控制台中运行此函数。）
- en: Listing D.37\. `setTimeout` skeleton
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.37\. `setTimeout` 框架
- en: '[PRE50]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Delays processing for specified number of ms**'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 处理指定毫秒数的延迟**'
- en: '***2* Runs callback function**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 运行回调函数**'
- en: '***3* Sends anonymous function and delays**'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 发送匿名函数并延迟**'
- en: The `callback` parameter is expected to be a function, which can be invoked
    at a specific point in the `setTimeout()` function ***1***. In this case, you’re
    passing it a simple anonymous function ***3*** that will write a message to the
    console log. When the `setTimeout()` function deems it appropriate to do so, it
    invokes the callback, and the message is logged to the console. That’s not so
    difficult, is it?
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback` 参数预期是一个函数，该函数可以在 `setTimeout()` 函数的特定点被调用 ***1***。在这种情况下，你传递给它一个简单的匿名函数
    ***3***，该函数将消息写入控制台日志。当 `setTimeout()` 函数认为适当的时候，它会调用回调函数，并将消息记录到控制台。这并不难，对吧？'
- en: If JavaScript is your first programming language, you’ll have no idea how weird
    this concept of passing anonymous functions around looks to those who are coming
    in from different backgrounds. But the ability to operate this way is one of JavaScript’s
    great strengths.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JavaScript 是你的第一门编程语言，你可能无法理解这种传递匿名函数的概念对那些来自不同背景的人来说是多么奇怪。但以这种方式操作的能力是 JavaScript
    的一个巨大优势。
- en: Typically, you won’t generally look inside the function running the callbacks,
    whether it’s `setTimeout()`, jQuery’s `ready()`, or Node’s `createServer()`. The
    documentation for these functions tells you what the expected parameters are and
    what parameters may be returned.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不会查看运行回调函数的函数内部，无论是 `setTimeout()`、jQuery 的 `ready()` 还是 Node 的 `createServer()`。这些函数的文档会告诉你预期的参数是什么以及可能返回的参数。
- en: '|  |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Why setTimeout() is unusual**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么 setTimeout() 是不寻常的**'
- en: The `setTimeout()` function is unusual in that you specify a delay after which
    the callback will fire. In a more typical use case, the function itself decides
    when the callback should be triggered. In jQuery’s `ready()` method, this is when
    jQuery says the DOM has loaded; in a `save()` operation in Node, this is when
    the data is saved to the database and a confirmation is returned.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`函数的独特之处在于你指定了一个延迟，之后回调将被触发。在更典型的用例中，函数本身决定何时触发回调。在jQuery的`ready()`方法中，这是jQuery说DOM已加载的时候；在Node的`save()`操作中，这是数据已保存到数据库并返回确认的时候。'
- en: '|  |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Callback scope
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 回调作用域
- en: Something to bear in mind when passing anonymous functions around this way is
    that the callback doesn’t inherit the scope of the function it’s passed into.
    The callback function isn’t declared inside the destination function, merely invoked
    from it. A *callback function inherits the scope in which it’s defined*.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在以这种方式传递匿名函数时需要注意的一点是，回调不会继承其传入函数的作用域。回调函数不是在目标函数内部声明的，而是从它那里调用的。*回调函数继承其定义的作用域*。
- en: '[Figure D.4](#app04fig04) depicts scope circles. Here, you see that the callback
    has its own local scope inside the global scope, which is where `requestB` is
    defined. This is all well and good if your callback needs access only to its inherited
    scope, but what if you want it to be smarter? What if you want to use data from
    your asynchronous function in your callback?'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[图D.4](#app04fig04)展示了作用域圆圈。在这里，你可以看到回调在其全局作用域内部有自己的局部作用域，这是`requestB`被定义的地方。如果你的回调只需要访问其继承的作用域，那么这很好。但是，如果你想让它更智能呢？如果你想在回调中使用异步函数中的数据呢？'
- en: Figure D.4\. A callback has its own local scope.
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图D.4\. 回调有自己的局部作用域。
- en: '![](Images/dfig04_alt.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/dfig04_alt.jpg)'
- en: Currently, the example callback function has a dollar amount hardcoded into
    it, but what if you want that value to be dynamic—to be a variable? Assuming that
    this value is set in the `setTimeout()` function, how do you get it into the callback?
    You could save it to the global scope, but as you know by now, doing so would
    be bad. You need to pass the value as a parameter into the callback function.
    You should get something like the scope circles shown in [figure D.5](#app04fig05).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，示例回调函数中有一个硬编码的金额，但如果你想让这个值是动态的——成为一个变量怎么办？假设这个值在`setTimeout()`函数中设置，你如何将其传递给回调？你可以将其保存到全局作用域，但正如你所知，这样做是错误的。你需要将这个值作为参数传递给回调函数。你应该得到类似于[图D.5](#app04fig05)中所示的作用域圆圈。
- en: The same thing in code would look like the following code listing.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，这看起来像以下代码列表。
- en: Listing D.38\. `setTimeout` with passing data
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.38\. `setTimeout`传递数据
- en: '[PRE51]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Declares a variable in the function scope**'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在函数作用域中声明一个变量**'
- en: '***2* Passes the variable as a parameter to the callback**'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将变量作为参数传递给回调**'
- en: '***3* Accepts the variable as a parameter in the callback and uses it**'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在回调中将变量作为参数接受并使用**'
- en: Figure D.5\. Setting a variable and passing it to the callback
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图D.5\. 设置变量并将其传递给回调
- en: '![](Images/dfig05_alt.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/dfig05_alt.jpg)'
- en: This code snippet outputs the same message to the console that you’ve already
    seen. The big difference now is that the value of dollars is being set in the
    `setTimeout()` function and being passed to the callback.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段输出到控制台的消息与您之前看到的相同。现在的主要区别是美元的价值是在`setTimeout()`函数中设置的，并被传递给回调。
- en: It’s important that you understand this approach, as the vast majority of Node
    code examples on the internet use asynchronous callbacks this way. But there are
    a couple of potential problems with this approach, particularly when your codebase
    gets larger and more complex. An overreliance on passing around anonymous callback
    functions can make the code hard to read and follow, especially when you find
    that you have multiple nested callbacks. It also makes running tests on the code
    difficult, as you can’t call any of these functions by name; they’re all anonymous.
    We don’t cover unit testing in this book, but in a nutshell, the idea is that
    every piece of code can be tested separately with repeatable and expected results.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种方法非常重要，因为互联网上绝大多数的Node代码示例都是使用这种方式进行异步回调。但是，这种方法存在一些潜在问题，尤其是在你的代码库变得更大、更复杂时。过度依赖传递匿名回调函数可能会使代码难以阅读和跟踪，尤其是当你发现你有多个嵌套回调时。这也会使对代码进行测试变得困难，因为你无法通过名称调用这些函数；它们都是匿名的。本书中不涵盖单元测试，但简而言之，其理念是每一块代码都可以单独进行测试，并得到可重复和预期的结果。
- en: Let’s look at a way that you can achieve this result with named callbacks.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用命名回调实现这个结果。
- en: Named callbacks
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命名回调
- en: '*Named callbacks* differ from inline callbacks in one fundamental way. Instead
    of putting the code you want to run directly into the callback, you put the code
    inside a defined function. Then, rather than passing the code directly as an anonymous
    function, you can pass the function name. Rather than passing the code, you’re
    passing a *reference* to the code to run.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名回调*与内联回调在本质上有一个区别。不是直接将您想要运行的代码放入回调中，而是将代码放在一个定义好的函数中。然后，而不是直接作为匿名函数传递代码，您可以传递函数名。而不是传递代码，您传递的是代码运行的*引用*。'
- en: Sticking with the ongoing example, add a new function called `onCompletion()`
    that will be the callback function. [Figure D.6](#app04fig06) shows how this function
    looks in the scope circles.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 持续使用当前的例子，添加一个名为`onCompletion()`的新函数，它将成为回调函数。[图D.6](#app04fig06)显示了该函数在作用域圆圈中的样子。
- en: Figure D.6\. Change in scope when using a named callback
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图D.6\. 使用命名回调时的作用域变化
- en: '![](Images/dfig06_alt.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig06_alt.jpg)'
- en: This figure looks like the preceding example, except that the callback scope
    has a name. As with an anonymous callback, a named callback can be invoked without
    any parameters, implied in [figure D.6](#app04fig06). The following code snippet
    shows how to declare and invoke a named callback, putting into code what you see
    in [figure D.6](#app04fig06).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图看起来和前面的例子类似，除了回调作用域有一个名字。和匿名回调一样，命名回调可以在没有任何参数的情况下被调用，如[图D.6](#app04fig06)所示。下面的代码片段展示了如何声明和调用一个命名回调，将[图D.6](#app04fig06)中的内容转化为代码。
- en: Listing D.39\. Named callbacks
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.39\. 命名回调
- en: '[PRE52]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Declares a named function in distinct scope**'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在不同的作用域中声明一个命名函数**'
- en: '***2* Sends the function name as a callback**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将函数名作为回调发送**'
- en: The named function ***1*** now exists as an entity in its own right, creating
    its own scope. Notice that there’s no longer an anonymous function, but the name
    of the function ***2*** is passed as a reference.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数***1***现在作为一个实体存在，创建了它自己的作用域。请注意，不再有匿名函数，但函数名***2***作为引用传递。
- en: Passing variables
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 传递变量
- en: '[Listing D.39](#app04ex39) uses a hardcoded dollar value in the console log
    again. As with anonymous callbacks, passing a variable from one scope to another
    is straightforward. You can pass the parameters you need into the named function.
    [Figure D.7](#app04fig07) shows how this looks in the scope circles.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表D.39](#app04ex39)再次在控制台日志中使用硬编码的美元值。和匿名回调一样，从一个作用域传递变量到另一个作用域是直接的。您可以将所需的参数传递到命名函数中。[图D.7](#app04fig07)显示了在作用域圆圈中的样子。'
- en: Figure D.7\. Passing the required parameter into the new function scope
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图D.7\. 将所需的参数传递到新的函数作用域
- en: '![](Images/dfig07_alt.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig07_alt.jpg)'
- en: You need to pass the variable `dollars` from `setTimeout()` to the `onCompletion()`
    callback function. You can do so without changing anything in your request, as
    the following code snippet shows.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将变量`dollars`从`setTimeout()`传递到`onCompletion()`回调函数中。您可以通过不更改请求中的任何内容来实现这一点，如下面的代码片段所示。
- en: Listing D.40\. `setTimeout` variable passing
  id: totrans-456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.40\. `setTimeout`变量传递
- en: '[PRE53]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Sends the dollars variable as a parameter to the callback**'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将美元变量作为参数发送到回调**'
- en: '***2* Named function accepts and uses the parameter**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 命名函数接受并使用参数**'
- en: '***3* No change is made when sending the callback.**'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 发送回调时没有进行任何更改。**'
- en: Here, the `setTimeout()` function sends the `dollars` variable to the `onCompletion()`
    function as a parameter. You’ll often have no control of the parameters sent to
    your callback, because asynchronous functions like `setTimeout()` are provided
    as is. But you’ll often want to use variables from other scopes inside your callback,
    not what your asynchronous function provides. Next, we’ll look at how to send
    the parameters you want to your callback.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`setTimeout()`函数将`dollars`变量作为参数发送到`onCompletion()`函数中。您通常无法控制发送到回调的参数，因为像`setTimeout()`这样的异步函数是按原样提供的。但您通常希望在回调中使用来自其他作用域的变量，而不是异步函数提供的变量。接下来，我们将看看如何将您想要的参数发送到回调。
- en: Using variables from a different scope
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用不同作用域中的变量
- en: 'Suppose that you want the name in the output to come through as a parameter.
    The updated function looks like the following:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望输出中的名字作为一个参数传递。更新后的函数看起来如下：
- en: '[PRE54]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The problem is that the `setTimeout()` function passes only a single parameter,
    `dollars`, to the callback. You can address this problem by using an anonymous
    function as a callback again, remembering that it inherits the scope in which
    it’s defined. To demonstrate this function outside the global scope, wrap the
    request in a new function, `getMoney()`, that accepts a single parameter, `name`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 `setTimeout()` 函数只传递了一个参数，`dollars`，到回调函数。你可以通过再次使用匿名函数作为回调来解决此问题，记住它继承了其定义的作用域。为了演示这个函数在全局作用域之外，将请求包裹在一个新的函数
    `getMoney()` 中，该函数接受一个参数，`name`。
- en: Listing D.41\. Variable scoping in `setTimeout`
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.41\. `setTimeout` 中的变量作用域
- en: '[PRE55]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Anonymous function accepts only the dollars parameter**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 匿名函数只接受美元参数**'
- en: '***2* Named callback accepts dollars from the anonymous function and name from
    the getMoney scope**'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 命名回调从匿名函数接收美元，从 `getMoney` 作用域接收名称**'
- en: In the scope circles, this code looks like [figure D.8](#app04fig08).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域圆圈中，此代码看起来像[图 D.8](#app04fig08)。
- en: The next listing puts all the code together for the sake of completeness.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表将所有代码放在一起，以保持完整性。
- en: Listing D.42\. Complete `setTimeout` example
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.42\. 完整的 `setTimeout` 示例
- en: '[PRE56]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* Sends a callback to the setTimeout function**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 向 `setTimeout` 函数发送回调**'
- en: '***2* Calls a callback function sending dollars variable**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 向回调函数发送包含美元变量的回调**'
- en: '***3* Calls a named function passing dollars and name parameters**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过命名函数调用传递美元和名称参数**'
- en: Figure D.8\. The process of sending variables from different scopes to a named
    callback function
  id: totrans-477
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 D.8\. 从不同作用域向命名回调函数发送变量的过程
- en: '![](Images/dfig08_alt.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/dfig08_alt.jpg)'
- en: The simple way to think of it is that calling the named function from inside
    the anonymous callback enables you to capture anything you need from the parent
    scope (`getMoney()`, in this case) and explicitly pass it to the named function
    (`onCompletion()`).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，从匿名回调内部调用命名函数使你能够从父作用域（在这种情况下是 `getMoney()`）捕获你需要的内容，并将其明确传递给命名函数（`onCompletion()`）。
- en: '|  |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Seeing the flow in action**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察流程的实际操作**'
- en: 'If you want to see this flow in action, you can add a debugger statement, run
    it in your browser, and step through the functions to see which variables and
    values are set where and when. Altogether, you have something like this:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看到这个流程的实际操作，你可以添加一个调试语句，在浏览器中运行它，并逐步执行函数以查看哪些变量和值在哪里以及何时被设置。总的来说，你会有如下所示的内容：
- en: '[PRE57]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that when adding a debugger statement, you’ll want to change the name of
    the `setTimeout()` function so that it doesn’t interfere with the native function.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当添加调试语句时，你可能需要更改 `setTimeout()` 函数的名称，以免干扰原生函数。
- en: '|  |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Remember that you normally won’t have access to the code inside the function
    that invokes the callback and that the callback is often invoked with a fixed
    set of parameters (or none, as with `setTimeout()`). Anything extra that you need
    to add must be added inside the anonymous callback.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你通常无法访问调用回调函数的函数内部的代码，并且回调通常使用一组固定的参数（或没有，如 `setTimeout()`）来调用。你需要添加的任何额外内容都必须添加在匿名回调内部。
- en: Better for reading and testing
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更适合阅读和测试
- en: Defining a named function in this way makes the scope and code of the function
    easier to comprehend at a glance, especially if you name your functions well.
    With a small, simple example like this one, you could think that the flow is harder
    to understand when you move the code into its own function, and you could well
    have a point. But when the code becomes more complex and you have multiple lines
    of code inside multiple nested callbacks, you’ll definitely see the advantage
    of doing it this way.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义一个命名函数使得函数的作用域和代码更容易一眼看懂，尤其是如果你给函数取了好的名字。在这样一个简单的小例子中，当你将代码移动到自己的函数中时，你可能会认为流程更难理解，你确实有这个观点。但是当代码变得更加复杂，你有多层嵌套的回调函数时，你肯定会看到这样做的好处。
- en: Another advantage of being able to easily see what the `onCompletion()` function
    should do and what parameters it expects and requires to work is that the function
    becomes easier to test. Now you can say, “When the function `onCompletion()` is
    passed a number of dollars and a name, it should output a message to the console,
    including this number and name.” This case is a simple one, but we hope that you
    can see its value.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 能够轻松地看到 `onCompletion()` 函数应该做什么，以及它期望和需要哪些参数，这使得函数更容易测试。现在你可以这样说：“当 `onCompletion()`
    函数传递一个金额和一个名字时，它应该向控制台输出一条消息，包括这个金额和名字。”这是一个简单的例子，但我们希望你能看到它的价值。
- en: That brings us to the end of discussing callbacks from a code perspective. Now
    that you’ve got a good idea of how callbacks are defined and used, look at Node
    to see why callbacks are so useful.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了从代码角度讨论回调的内容。现在你已经对回调的定义和使用有了很好的理解，那么看看 Node，了解为什么回调如此有用。
- en: Callbacks in Node
  id: totrans-491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Node 中的回调
- en: In the browser, many events are based on user interaction, waiting for things
    to happen outside what the code can control. The concept of waiting for external
    things to happen is similar on the server side. The difference on the server side
    is that the events focus more on other things happening on the server or indeed
    on a different server. In the browser, the code waits for events such as a mouse
    click or form submit, whereas the server-side code waits for events such as reading
    a file from the file system or saving data to a database.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，许多事件都是基于用户交互的，等待代码无法控制的事情发生。在服务器端，等待外部事情发生的概念是相似的。在服务器端的区别在于，事件更多地关注服务器上发生的事情，或者确实是在不同的服务器上发生的事情。在浏览器中，代码等待事件，如鼠标点击或表单提交，而服务器端代码等待事件，如从文件系统读取文件或将数据保存到数据库。
- en: The big difference is that in the browser, it’s generally an individual user
    who initiates the event, and it’s only that user who’s waiting for a response.
    On the server side, the central code generally initiates the event and waits for
    a response. As discussed in [chapter 1](kindle_split_011.xhtml#ch01), only a single
    thread is running in Node, so if the central code has to stop and wait for a response,
    every visitor to the site gets held up—not a good thing! This is why it’s important
    to understand callbacks, because Node uses callbacks to delegate the waiting to
    other processes, making it asynchronous.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的区别在于，在浏览器中，通常是由单个用户来启动事件，并且只有那个用户在等待响应。在服务器端，通常是中心代码启动事件并等待响应。正如在[第1章](kindle_split_011.xhtml#ch01)中讨论的那样，Node
    中只有一个线程在运行，所以如果中心代码需要停止并等待响应，那么每个访问者都会受到影响——这不是好事！这就是为什么理解回调很重要，因为 Node 使用回调将等待委托给其他进程，使其异步。
- en: Next, we’ll look at an example of using callbacks in Node.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个示例来了解在 Node 中使用回调函数。
- en: A Node callback
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Node 回调
- en: Using a callback in Node isn’t any different from using it in the browser. If
    you want to save some data, you don’t want the main Node process doing this, as
    you didn’t want the bank teller going with the safe manager and waiting for the
    response. You want to use an asynchronous function with a callback. All database
    drivers for Node provide this ability. We get into the specifics about how to
    create and save data in the book, so for now, we’ll use a simplified example.
    The following code snippet shows an example of asynchronously saving data using
    the `save()` method of the `mySafe` object and outputting a confirmation to the
    console when the database finishes and returns a response.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中使用回调与在浏览器中使用并没有什么不同。如果你想保存一些数据，你不想让主 Node 进程来做这件事，就像你不想让银行出纳员和保险库管理员一起去等待响应一样。你想要使用一个带有回调的异步函数。所有
    Node 的数据库驱动程序都提供了这种能力。关于如何创建和保存数据的具体细节将在书中介绍，所以现在我们用一个简化的例子来说明。下面的代码片段展示了使用 `mySafe`
    对象的 `save()` 方法异步保存数据，并在数据库完成并返回响应时向控制台输出确认信息。
- en: Listing D.43\. Basic Node callback
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.43\. 基本Node回调
- en: '[PRE58]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, the `save` function expects a callback function that can accept two parameters,
    an error object (`err`), and the data returned from the database following the
    save (`savedData`). There’s normally a bit more to functionality in the callback
    than this, but the basic construct is simple.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`save` 函数期望一个可以接受两个参数的回调函数，一个错误对象（`err`），以及保存后从数据库返回的数据（`savedData`）。在回调中通常还有更多功能，但基本结构很简单。
- en: Running callbacks one after another
  id: totrans-500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 依次运行回调
- en: You get the idea of running a callback, but what do you do if you want to run
    another asynchronous operation when the callback is finished? Returning to the
    banking metaphor, suppose that you want to get a total value from all of Simon’s
    accounts after the deposit is made to the safe. Simon doesn’t need to know that
    multiple steps and multiple people are involved, and the bank teller doesn’t need
    to know until everything is complete. You’re looking to create a flow like the
    one shown in [figure D.9](#app04fig09).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了运行回调的概念，但如果你想在回调完成后运行另一个异步操作怎么办？回到银行比喻，假设你在将存款存入保险箱后，想要从西蒙的所有账户中获取总价值。西蒙不需要知道涉及多个步骤和多人，银行出纳员也不需要知道直到一切完成。你希望创建一个如图
    D.9 所示的流程。
- en: Figure D.9\. Required flow when using two asynchronous operations, one after
    another
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 D.9\. 使用两个依次进行的异步操作所需的流程
- en: '![](Images/dfig09.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dfig09.jpg)'
- en: Clearly, two operations will be required, with another asynchronous call to
    the database. You know from what we’ve already discussed that you can’t put it
    in the code after the `save` function, as in the following code snippet.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，需要两个操作，还需要另一个对数据库的异步调用。根据我们之前讨论的内容，你知道不能在 `save` 函数之后将其放入代码中，如下代码片段所示。
- en: Listing D.44\. Node callback issues
  id: totrans-505
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.44\. 节点回调问题
- en: '[PRE59]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* The second function will fire before the save function has finished,
    so the returned accountsData will likely be incorrect.**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 第二个函数将在保存函数完成之前触发，因此返回的 accountsData 可能是不正确的。**'
- en: 'That’s not going to work, because the `myAccounts.findTotal()` function will
    run immediately rather than when the `mySafe.save()` function has finished. The
    return value is likely to be incorrect, because it won’t take into account the
    value being added to the safe. You need to ensure that the second operation runs
    when you know that the first one has finished. The solution is simple: invoke
    the second function from inside the first callback, a process known as *nesting*
    the callbacks.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不行的，因为 `myAccounts.findTotal()` 函数将立即运行，而不是在 `mySafe.save()` 函数完成后运行。返回值可能是不正确的，因为它不会考虑到被添加到保险箱的价值。你需要确保第二个操作在你知道第一个操作已经完成时运行。解决方案很简单：从第一个回调函数内部调用第二个函数，这个过程被称为
    *嵌套* 回调。
- en: Nested callbacks are used to run asynchronous functions one after another. Put
    the second function inside the callback from the first, as in the following listing.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套回调用于依次运行异步函数。将第二个函数放在第一个回调函数内部，如下所示。
- en: Listing D.45\. Nesting callbacks
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.45\. 嵌套回调
- en: '[PRE60]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Second asynchronous operation nested inside callback of first**'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 第二个异步操作嵌套在第一个回调函数内部**'
- en: Now you can be sure that the `myAccounts.findTotal()` function will run at the
    appropriate time, which in turn means that you can predict the response.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以确信 `myAccounts.findTotal()` 函数将在适当的时间运行，这反过来意味着你可以预测响应。
- en: This ability is important. Node is inherently asynchronous, jumping from request
    to request and from site visitor to site visitor. But sometimes, you need to do
    things in a sequential manner. Nesting callbacks gives you a good way of doing
    this by using native JavaScript.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力很重要。Node 本身是异步的，从一个请求跳转到另一个请求，从网站访客跳转到另一个访客。但有时，你需要按顺序做事。嵌套回调通过使用原生 JavaScript
    给你提供了一个很好的方法来实现这一点。
- en: The downside of nested callbacks is the complexity. You can probably see that
    with one level of nesting, the code is already a bit harder to read, and following
    the sequential flow takes a bit more mental effort. This problem is multiplied
    when the code gets more complex and you end up with multiple levels of nested
    callbacks. The problem is so great that it has become known as *callback hell*.
    Callback hell is why some people think that Node (and JavaScript) is particularly
    hard to learn and difficult to maintain, and they use it as an argument against
    the technology. In fairness, many code samples you can find online do suffer from
    this problem, which doesn’t do much to combat this opinion. It’s easy to end up
    in callback hell when you’re developing Node, but it’s also easy to avoid if you
    start in the right way.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套回调的缺点是复杂性。你可能已经注意到，在一级嵌套的情况下，代码已经有点难以阅读，而且跟随顺序流程需要更多的脑力。当代码变得更加复杂，并且你最终有多个级别的嵌套回调时，这个问题会成倍增加。这个问题如此严重，以至于它已经成为“回调地狱”的代名词。回调地狱是为什么有些人认为Node（和JavaScript）特别难以学习和维护，并且他们将其作为反对这项技术的论据。公平地说，你可以在网上找到的许多代码示例确实存在这个问题，这并没有多少帮助来反驳这种观点。在开发Node时，你很容易陷入回调地狱，但如果你从正确的方式开始，你也同样容易避免。
- en: 'We’ve already discussed the solution to callback hell: using named callbacks.
    Next, we’ll show you how named callbacks help with this problem.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了回调地狱的解决方案：使用命名回调。接下来，我们将向你展示命名回调如何帮助解决这个问题。
- en: Using named callbacks to avoid callback hell
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用命名回调避免回调地狱
- en: Named callbacks can help you avoid nested callback hell because you can use
    them to separate each step into a distinct piece of code or functionality. Humans
    tend to find this type of code easier to read and understand.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 命名回调可以帮助你避免嵌套回调地狱，因为你可以使用它们将每个步骤分离成独立的代码或功能。人类往往发现这种类型的代码更容易阅读和理解。
- en: 'To use a named callback, you need to take the content of a callback function
    and declare it as a separate function. The nested callback example has two callbacks,
    so you’re going to need two new functions: one for when the `mySafe.save()` operation
    has completed and one for when the `myAccounts.findTotal()` operation has completed.
    If these functions are called `onSave()` and `onFindTotal()`, respectively, you
    can create some code like the following listing.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命名回调，你需要将回调函数的内容提取出来，并声明为一个单独的函数。嵌套回调示例有两个回调，因此你需要两个新函数：一个用于`mySafe.save()`操作完成时，另一个用于`myAccounts.findTotal()`操作完成时。如果这些函数分别命名为`onSave()`和`onFindTotal()`，你可以创建一些如下所示的代码。
- en: Listing D.46\. Refactor of callback code
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.46\. 回调代码重构
- en: '[PRE61]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Invokes the first named function from mySafe.save operation**'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从mySafe.save操作中调用第一个命名函数**'
- en: '***2* Starts the second asynchronous operation from within the first named
    callback**'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在第一个命名回调内部启动第二个异步操作**'
- en: '***3* Invokes the second named function**'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用第二个命名函数**'
- en: Now that each piece of functionality is separated into a separate function,
    it’s easier to look at each part in isolation and understand what it’s doing.
    You can see what parameters it expects and what the outcomes should be. In reality,
    the outcomes are likely to be more complex than simple `console.log()` statements,
    but you get the idea. You can also follow the flow relatively easily and see the
    scope of each function.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将每个功能部分分离成独立的函数后，更容易单独查看每个部分并理解它在做什么。你可以看到它期望的参数和预期的结果。实际上，结果可能比简单的`console.log()`语句更复杂，但你可以理解这个概念。你还可以相对容易地跟踪流程，并看到每个函数的作用域。
- en: By using named callbacks, you can reduce the perceived complexity of Node and
    also make your code easier to read and maintain. An important second advantage
    is that individual functions are much better suited to unit testing. Each part
    has defined inputs and outputs, with expected and repeatable behavior.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用命名回调，你可以降低Node的感知复杂性，并使你的代码更容易阅读和维护。第二个重要优势是，单个函数更适合单元测试。每个部分都有定义的输入和输出，具有预期的可重复行为。
- en: Promises and async/await
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺和异步/await
- en: 'A Promise is like a contract: it states that a value will be available in the
    future when a long-running operation has completed. In essence, a Promise represents
    the result of an asynchronous operation. When that value has been determined,
    the Promise executes the given code or handles any error associated with not having
    received the expected value.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 就像一份合同：它声明当长时间运行的操作完成时，将会有一个值在未来可用。本质上，Promise 代表了异步操作的结果。当这个值被确定后，Promise
    将执行给定的代码或处理任何与未收到预期值相关的错误。
- en: 'Promises are first-class citizens of the JavaScript specification. They have
    three states:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: Promises 是 JavaScript 规范的一等公民。它们有三个状态：
- en: '***Pending*—** The initial state of the Promise'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Pending*—** Promise 的初始状态'
- en: '***Fulfilled*—** The asynchronous operation successfully resolved'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Fulfilled*—** 异步操作成功解析'
- en: '***Rejected*—** The asynchronous operation did not successfully resolve'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Rejected*—** 异步操作未成功解析'
- en: Promises
  id: totrans-533
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Promises
- en: When a Promise has been resolved, successfully or not, its value can’t change;
    it becomes immutable. We’ll discuss immutability in the section on functional
    programming later in this appendix.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Promise 被解析，无论是成功还是失败，其值都不能改变；它变成了不可变的。我们将在本附录后面的函数式编程部分讨论不可变性。
- en: 'To set up a Promise, you create a function that accepts two callback functions:
    one that executes on success and one that executes on failure. These callbacks
    fire when called by the Promise execution. Then, execution of the callbacks is
    transferred to `then()` functions (which are chainable) on success or a `catch()`
    function when not.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个 Promise，你创建一个接受两个回调函数的函数：一个在成功时执行，一个在失败时执行。这些回调函数在 Promise 执行时被调用。然后，回调函数的执行转移到成功时的
    `then()` 函数（可链式调用）或失败时的 `catch()` 函数。
- en: Listing D.47\. Setting up/using a Promise
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.47\. 设置/使用 Promise
- en: '[PRE62]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Creates a Promise, passing in the expected callback function**'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个 Promise，传入预期的回调函数**'
- en: '***2* On success, calls the resolve() function, optionally passing data forward**'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在成功时，调用 resolve() 函数，可选地传递数据**'
- en: '***3* On failure, calls the reject() function, optionally passing data or the
    Error object forward**'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在失败时，调用 reject() 函数，可选地传递数据或 Error 对象**'
- en: '***4* The then() function is called; it performs the desired operation, optionally
    returning a value to next then().**'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 调用 then() 函数；它执行所需的操作，可选地返回一个值给下一个 then()。**'
- en: '***5* The next then() function in the chain, which can be as long as necessary**'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 链中的下一个 then() 函数，其长度可以是必要的**'
- en: '***6* Catches the error. If this is at the end of a chain of then() functions,
    any error thrown is caught by this handler.**'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 捕获错误。如果这是 then() 函数链的末尾，任何抛出的错误都会被这个处理程序捕获。**'
- en: We use Promises in the Loc8r application, but not in a complicated way. The
    Promises API provides some static functions that help if you’re trying to execute
    multiple Promises.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Loc8r 应用程序中使用 Promises，但不是以复杂的方式。Promises API 提供了一些静态函数，这些函数有助于你尝试执行多个 Promises。
- en: '`Promise.all()` accepts an iterable of Promises and returns a Promise when
    all items in the array fulfill or reject. The `resolve()` callback receives an
    array of responses: a mixture of Promise-like objects and other objects in order
    of fulfillment. If one of the executed Promises rejects, the `reject()` callback
    receives a single value.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()` 接受一个 Promise 的可迭代对象，并在数组中的所有项目都满足或拒绝时返回一个 Promise。`resolve()`
    回调函数接收一个响应数组：按满足顺序排列的类似 Promise 对象和其他对象。如果执行中的任何一个 Promise 拒绝，`reject()` 回调函数接收一个单一值。'
- en: Listing D.48\. `Promise.all()`
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.48\. `Promise.all()`
- en: '[PRE63]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* Promise 3 rejects, so this is ignored (in this example).**'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Promise 3 拒绝了，所以在这个例子中会被忽略。**'
- en: '***2* The reject() call on Promise 3 ends up here, although all Promises are
    executed.**'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Promise 3 上的 reject() 调用最终会到这里，尽管所有 Promise 都被执行了。**'
- en: '`Promise.race()` also accepts an iterable, but the output of `Promise.race()`
    is different. `Promise.race()` executes all provided Promises and returns the
    first response value that it receives whether this value is a fulfillment or a
    rejection.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.race()` 也接受一个可迭代对象，但 `Promise.race()` 的输出是不同的。`Promise.race()` 执行所有提供的
    Promises，并返回它接收到的第一个响应值，无论这个值是满足还是拒绝。'
- en: Listing D.49\. `Promise.race()`
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.49\. `Promise.race()`
- en: '[PRE64]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* The expected response here is second, because the rejection happens before
    the resolve of promise1 resolves.**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这里预期的响应是第二个，因为拒绝发生在 promise1 解析之前。**'
- en: Because Promises rely on callbacks, due to their asynchronous nature, you can
    get into a muddle if several callbacks are nested. Finding yourself in a deeply
    nested callback structure is often referred to as callback hell. Promises somewhat
    mitigate this problem by providing a structure and making the asynchronicity explicit.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Promises 依赖于回调，由于它们的异步性质，如果嵌套多个回调，你可能会陷入混乱。发现自己处于深层嵌套的回调结构中通常被称为回调地狱。Promises
    通过提供结构和使异步性明确来在一定程度上缓解了这个问题。
- en: async/await
  id: totrans-555
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: async/await
- en: Promises have their drawbacks. They’re difficult to use in a synchronous manner,
    and you usually have to wade through a bunch of boilerplate code before getting
    to the good stuff.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: Promises 有其缺点。它们难以以同步方式使用，通常在到达好东西之前，你必须浏览一大堆样板代码。
- en: '`async/await` functions are there to simplify the behavior of using Promises
    synchronously. The `await` expression is valid only in an `async` function; if
    used outside an `async` function, the code throws a `SyntaxError`. When an `async`
    function is declared, the definition returns an `AsyncFunction` object. This object
    operates asynchronously via the JavaScript event loop and returns an implicit
    Promise as its result. The way the syntax is used and how it allows the code to
    be structured gives the impression that using `async` functions is much like using
    synchronous functions.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`async/await` 函数旨在简化同步使用 Promises 的行为。`await` 表达式仅在 `async` 函数中有效；如果在不属于 `async`
    函数的上下文中使用，代码会抛出 `SyntaxError`。当声明 `async` 函数时，其定义返回一个 `AsyncFunction` 对象。该对象通过
    JavaScript 事件循环异步操作，并返回一个隐式的 Promise 作为其结果。语法的使用方式和它允许代码的结构化方式给人一种使用 `async` 函数就像使用同步函数的印象。'
- en: '|  |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**await**'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**await**'
- en: The `await` expression causes the execution of the `async` function to pause
    and wait until the passed Promise resolves. Then, function execution resumes.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`await` 表达式会导致 `async` 函数的执行暂停，并等待传入的 Promise 解决。然后，函数执行继续。'
- en: One thing to point out is that `await` is not the same as `Promise.then()`.
    As `await` pauses the execution, causing code to execute synchronously, it isn’t
    chainable in the same way as `Promise.then()`.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要指出的是，`await` 与 `Promise.then()` 并不相同。因为 `await` 会暂停执行，使代码以同步方式执行，所以它不能像
    `Promise.then()` 那样进行链式调用。
- en: '|  |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next listing shows `async`/`await` in use.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了 `async`/`await` 的使用。
- en: Listing D.50\. `async`/`await`
  id: totrans-564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.50\. `async`/`await`
- en: '[PRE65]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Defines an async function**'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个 async 函数**'
- en: '***2* Pauses execution for 2 seconds while the Promise resolves**'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在 Promise 解决时暂停执行 2 秒**'
- en: '***3* result1 prints ‘done in 2s’**'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* result1 打印‘done in 2s’**'
- en: '***4* Pauses execution for 1 second while the Promise resolves**'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在 Promise 解决时暂停执行 1 秒**'
- en: '***5* result2 prints ‘done in 1s’**'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* result2 打印‘done in 1s’**'
- en: '***6* Calls the async function. This function pauses the execution for a total
    of 3 seconds.**'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 调用 async 函数。此函数总共暂停执行 3 秒。**'
- en: You can find more details on `async`/`await` at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
    找到更多关于 `async`/`await` 的详细信息。
- en: Writing modular JavaScript
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写模块化 JavaScript
- en: 'Someone anonymously tweeted a great quote:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 有人在匿名推文中分享了一句精彩的话：
- en: '*The secret to writing large apps in JavaScript is not to write large apps.
    Write many small apps that can talk to each other.*'
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在 JavaScript 中编写大型应用程序的秘诀不是编写大型应用程序。编写许多小型应用程序，这些应用程序可以相互通信。*'
- en: This quote makes great sense in a number of ways. Many applications share several
    features, such as user login and management, comments, reviews, and so on. The
    easier it is for you to take a feature from one application you’ve written and
    drop it into another, the more efficient you’ll be, particularly as you’ll already
    have (we hope) tested the feature in isolation, so you know it works.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话在许多方面都很有道理。许多应用程序共享一些功能，例如用户登录和管理、评论、评论等。你越容易将一个应用程序中的一个功能提取出来并放入另一个应用程序中，你的效率就越高，尤其是当你已经（我们希望）在隔离的情况下测试了该功能，因此你知道它有效。
- en: This is where modular JavaScript comes in. JavaScript applications don’t have
    to be in one never-ending file with functions, logic, and global variables flying
    loose all over the place. You can contain functionality within enclosed modules.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模块化 JavaScript 发挥作用的地方。JavaScript 应用程序不必是一个永无止境的文件，其中包含函数、逻辑和全局变量四处飞散。你可以在封装的模块中包含功能。
- en: Closures
  id: totrans-578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 闭包
- en: A *closure* essentially gives you access to the variables set in a function
    after the function has completed and returned. Then the closure offers you a way
    to avoid pushing variables into the global scope. It also offers a degree of protection
    to the variable and its value, because you can’t overwrite it, as you could a
    global variable.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '*闭包*基本上在你完成函数并返回后，让你访问函数中设置的变量。然后闭包为你提供了一种避免将变量推入全局作用域的方法。它还提供了一定程度的变量和其值的保护，因为你不能像全局变量那样覆盖它。'
- en: Sound a bit weird? Look at an example. The following listing demonstrates how
    you can send a value to a function and later retrieve it.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来有点奇怪？看看一个例子。以下列表展示了你如何向函数发送一个值，并在稍后检索它。
- en: Listing D.51\. Example closure
  id: totrans-581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.51\. 闭包示例
- en: '[PRE66]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* Returns a function that returns a parameter**'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回一个返回参数的函数**'
- en: '***2* Invokes the function, assigns a return value to the age property of user**'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用函数，将返回值赋给用户的年龄属性**'
- en: '***3* Outputs “Object {getAge: function}”**'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 输出“Object {getAge: function}”**'
- en: '***4* Retrieves a value using the getAge() method; outputs “30”**'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 getAge() 方法获取值；输出“30”**'
- en: Here’s what’s happening. The `getAge()` function is returned as a method of
    the `setAge()` function. The `getAge()` method has access to the scope in which
    it was created. So `getAge()`, and `getAge()` alone, has access to the `myAge()`
    parameter. As you saw earlier in this appendix, when a function is created, it
    also creates its own scope. Nothing outside this function has access to the scope.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情是，`getAge()` 函数作为 `setAge()` 函数的方法返回。`getAge()` 方法可以访问其创建的作用域。所以 `getAge()`，仅
    `getAge()`，可以访问 `myAge()` 参数。正如你在附录中较早看到的那样，当创建一个函数时，它也会创建自己的作用域。这个函数之外没有任何东西可以访问这个作用域。
- en: '`myAge()` isn’t a one-off shared variable. You can call the function again—creating
    a second new function scope—to set (and get) the age of a second user. You could
    happily run the following code snippet after the preceding one, creating a second
    user and giving them a different age.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '`myAge()` 并不是一个一次性共享变量。你可以再次调用该函数——创建第二个新的函数作用域——来设置（和获取）第二个用户的年龄。你可以在前一个代码片段之后愉快地运行以下代码片段，创建第二个用户并赋予他们不同的年龄。'
- en: Listing D.52\. Continuing the closure example
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.52\. 继续闭包示例
- en: '[PRE67]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* Assigns the setAge() function to a new user with a different age**'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 setAge() 函数赋给具有不同年龄的新用户**'
- en: '***2* Outputs “usertwo’s age: 35”**'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输出“usertwo’s age: 35”**'
- en: '***3* Outputs the original user’s age: 30**'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 输出原始用户的年龄：30**'
- en: Each user has a different age that isn’t aware of or affected by the other.
    The closure protects the value from outside interference. The important takeaway
    here is that *the returned method has access to the scope in which it was created*.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都有不同的年龄，他们不会意识到或受到其他用户年龄的影响。闭包保护了值免受外部干扰。这里的重要启示是*返回的方法可以访问其创建的作用域*。
- en: This closure approach is a great start, but it has evolved into more useful
    patterns. For example, take a look at the module pattern.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这种闭包方法是一个很好的开始，但它已经演变成更有用的模式。例如，看看模块模式。
- en: Module pattern
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块模式
- en: The *module pattern* extends the closure concept, typically wrapping a collection
    of code, functions, and functionality into a module. The idea is that the module
    is self-contained, uses only data that’s explicitly passed into it, and reveals
    only data that it’s asked for directly.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块模式*扩展了闭包概念，通常将一组代码、函数和功能封装到一个模块中。这个想法是模块是自包含的，只使用显式传递给它的数据，并且只暴露直接请求的数据。'
- en: '|  |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Immediately Invoked Function Expression**'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '**立即执行函数表达式**'
- en: The module pattern uses what is known as the Immediately Invoked Function Expression
    (IIFE). The functions we’ve been using in this book up until now have been function
    declarations, creating functions that you can call on later in the code. The IIFE
    creates a function expression and immediately invokes it, typically returning
    some values and/or methods.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式使用所谓的立即执行函数表达式（IIFE）。我们在这本书中直到现在所使用的函数都是函数声明，创建可以在代码的稍后部分调用的函数。IIFE 创建一个函数表达式并立即调用它，通常返回一些值和/或方法。
- en: 'The syntax for an IIFE wraps the function in parentheses and immediately invokes
    it by using another pair of parentheses (see the bold sections of this code snippet):'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 立即执行函数表达式（IIFE）的语法是将函数用括号括起来，并通过使用另一对括号立即调用它（参见此代码片段中的粗体部分）：
- en: '[PRE68]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* Assigns IIFE to a variable**'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 IIFE 赋值给变量**'
- en: '***2* Accesses the returned methods as properties of a variable**'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将返回的方法作为变量的属性访问**'
- en: This example is a typical use but not the only one. The IIFE has been assigned
    to a variable ***1***. When you do this, the returned methods from the function
    become properties of the variable ***2***.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是一个典型用法，但并非唯一。立即函数表达式（IIFE）已被分配给变量 ***1***。当你这样做时，函数返回的方法成为变量的属性 ***2***。
- en: '|  |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is made possible by using an IIFE. (See the sidebar in this section for
    a bit more information on IIFE.) Like the basic closure, the module pattern returns
    functions and variables as properties of the variable it’s assigned to. Unlike
    the basic closure, the module pattern doesn’t have to be manually initiated; the
    module immediately calls itself as soon as it has been defined.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用立即函数表达式（IIFE）实现的。（参见本节侧边栏，了解更多关于 IIFE 的信息。）与基本闭包类似，模块模式将函数和变量作为分配给变量的属性返回。与基本闭包不同，模块模式不需要手动启动；模块一旦定义，就会立即调用自己。
- en: The following listing shows a small but usable example of the module pattern.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了模块模式的一个小但实用的示例。
- en: Listing D.53\. Module pattern example
  id: totrans-609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.53\. 模块模式示例
- en: '[PRE69]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* Assigns a module to a variable**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将模块分配给变量**'
- en: '***2* Defines the variable in the module scope**'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在模块作用域中定义变量**'
- en: '***3* Defines a method to be returned that can take parameter and modify the
    module variable**'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义一个可以接受参数并修改模块变量的返回方法**'
- en: '***4* Defines a method to be returned that can access the module variable**'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 定义一个可以访问模块变量的返回方法**'
- en: '***5* Calls the methods set and get for the module variable**'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 调用模块变量的 set 和 get 方法**'
- en: '***6* Outputs “30”**'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 输出“30”**'
- en: In this example, the `myAge` variable exists within the scope of the module
    and is never directly exposed to the outside. You can interact with the `myAge`
    variable only in the ways defined by the exposed methods. In [listing D.53](#app04ex53),
    you get and set, but it’s possible to modify the age property directly. You can
    add a `happyBirthday()` method to the `userAge` module that will increase the
    value of `myAge` by 1 and return the new value. The following listing shows the
    new parts in bold.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`myAge` 变量存在于模块的作用域内，并且永远不会直接暴露给外部。你只能通过暴露的方法与 `myAge` 变量交互。在 [列表 D.53](#app04ex53)
    中，你可以获取和设置，但也可以直接修改年龄属性。你可以向 `userAge` 模块添加一个 `happyBirthday()` 方法，该方法将 `myAge`
    的值增加 1 并返回新值。下面的代码列表展示了新的部分，并用粗体标出。
- en: Listing D.54\. Adding the `happyBirthday` method to the module
  id: totrans-618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.54\. 向模块添加 `happyBirthday` 方法
- en: '[PRE70]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* New method to increment myAge by 1 and return a new value**'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 新方法，用于将 myAge 增加 1 并返回新值**'
- en: '***2* Calls the new method and assigns it to user.age**'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用新方法并将其分配给 user.age**'
- en: '***3* Outputs “31”**'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 输出“31”**'
- en: The new `happyBirthday()` method increments the `myAge` value by 1 and returns
    the new value. This result is possible because the `myAge` variable exists in
    the scope of the module function, as does the returned `happyBirthday()` function.
    The new value of `myAge` continues to persist inside the module scope.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `happyBirthday()` 方法将 `myAge` 的值增加 1 并返回新值。这是可能的，因为 `myAge` 变量存在于模块函数的作用域内，同样，返回的
    `happyBirthday()` 函数也是如此。`myAge` 的新值继续在模块作用域内保持。
- en: Revealing module pattern
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 揭示模块模式
- en: What we’ve looked at in the module pattern is heading close to the revealing
    module pattern. The *revealing module pattern* is essentially some syntax that
    sugarcoats the module pattern. The aim is to make obvious what is exposed as public
    and what remains private to the module.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模块模式中看到的内容正接近揭示模块模式。*揭示模块模式* 实质上是一些语法糖，它包装了模块模式。目的是使公开的部分和模块内部保持私有的部分一目了然。
- en: Taking declarations out of the return statement
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将声明从返回语句中移除
- en: Providing a return in the aforementioned way is also a stylistic convention
    but is again one that helps you and others understand your code when you come
    back to it after a break. When you use this approach, the `return` statement contains
    a list of the functions that you’re returning without any of the actual code.
    The code is declared in functions above the `return` statement, although within
    the same module. The following code listing shows an example.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 以上述方式提供返回值也是一种风格约定，但同样有助于你在休息后回来时理解你的代码。当你使用这种方法时，`return` 语句包含一个函数列表，你将返回这些函数，而不包含任何实际代码。代码在
    `return` 语句上方声明，尽管在同一个模块内。下面的代码列表展示了示例。
- en: Listing D.55\. Revealing module pattern, short example
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.55\. 揭示模块模式，简短示例
- en: '[PRE71]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* setAge function has been moved outside the return statement**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* `setAge`函数已被移出`return`语句**'
- en: '***2* return statement now references the setAge function and contains no code**'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 现在的`return`语句引用了`setAge`函数，且不包含任何代码**'
- en: You can’t see the benefit of this approach in such a small example. We’ll look
    at a longer example soon that will get you part of the way there, but you’ll see
    the benefits when you have a module that runs to several hundred lines of code.
    As gathering all the variables at the top of the scope makes it obvious which
    variables are being used, taking the code out of the `return` statement makes
    it obvious at a glance which functions are being exposed. If you had a dozen or
    so functions being returned, each with a dozen or more lines of code, chances
    are that you wouldn’t to be able to see the entire `return` statement on one screen
    of code without scrolling.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在如此小的示例中，你无法看到这种方法的益处。我们很快将看到一个更长的示例，这将帮助你走上一半的路，但当你有一个运行到几百行代码的模块时，你将看到其益处。由于在作用域顶部收集所有变量使得使用哪些变量变得明显，将代码从`return`语句中移除使得一眼就能看出哪些函数被公开。如果你有十几个或更多的函数被返回，每个函数有十行或更多的代码，那么你很可能无法在不滚动的情况下看到整个`return`语句。
- en: What’s important in the `return` statement, and what you’ll be looking for,
    is which methods are being exposed. In the context of the `return` statement,
    you aren’t interested in the inner workings of each method. Separating your code
    like this makes sense and sets you up to have great, maintainable, and understandable
    code.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 在`return`语句中重要的是什么，你将寻找的是什么，那就是哪些方法被公开。在`return`语句的上下文中，你对每个方法的内部工作不感兴趣。以这种方式分离你的代码是有意义的，并为你编写出色、可维护和可理解的代码奠定了基础。
- en: A full example of the pattern
  id: totrans-634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模式的完整示例
- en: In this section, we’ll take a look at a larger example of the pattern, using
    the `userAge` module. The following listing shows an example of the revealing
    module pattern and removing code from the `return` statement.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用`userAge`模块来查看该模式的更大示例。以下列表展示了揭示模块模式的一个示例，以及从`return`语句中移除代码。
- en: Listing D.56\. Revealing module pattern, full example
  id: totrans-636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表D.56\. 揭示模块模式，完整示例
- en: '[PRE72]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* Has an underscore, as it’s never directly exposed outside the module**'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 有下划线，因为它从未直接在模块外部公开**'
- en: '***2* Private function that isn’t exposed**'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 未公开的私有函数**'
- en: '***3* Can be called by a public function that’s exposed**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 可以通过一个公开的函数来调用**'
- en: '***4* The return statement acts as a reference for exposed methods.**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* `return`语句充当公开方法的参考。**'
- en: '***5* user.age and myAge are now 31.**'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* user.age和myAge现在是31。**'
- en: This demonstrates a few interesting things. First, notice that the variable
    `myAge` ***1*** itself is never exposed outside the module. The value of the variable
    is returned by various methods, but the variable itself remains private to the
    module.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了几个有趣的事情。首先，请注意变量`myAge` ***1*** 本身从未在模块外部公开。变量的值通过各种方法返回，但变量本身仍然保持模块的私有性。
- en: As well as private variables, you can have private functions such as `addYear()`
    ***2*** in the listing. Private functions can easily be called by public methods
    ***3***.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 除了私有变量外，你还可以在列表中有私有函数，如`addYear()` ***2***。私有函数可以很容易地通过公开方法 ***3*** 被调用。
- en: The `return` statement ***4*** is kept nice and simple and is now an at-a-glance
    reference to the methods being exposed by this module.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句 ***4*** 被保持得既简洁又简单，现在是对该模块公开的方法的直观参考。'
- en: Strictly speaking, the order of the functions inside the module isn’t important
    so long as they’re above the `return` statement. Anything below the `return` statement
    never runs. When writing large modules, you may find it easier to group related
    functions. If it suits what you’re doing, you could also create a nested module
    or even a separate module with a public method exposed to the first module so
    that they can talk to each other.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，模块内函数的顺序并不重要，只要它们位于`return`语句之上。位于`return`语句之下的任何内容都不会运行。在编写大型模块时，你可能发现将相关函数分组更容易。如果你觉得这样做合适，你也可以创建一个嵌套模块，甚至是一个独立的模块，该模块有一个公开的方法暴露给第一个模块，以便它们可以相互通信。
- en: 'Remember the quote from the beginning of this section:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 记住本节开头引用的引言：
- en: '*The secret to writing large apps in JavaScript is not to write large apps.
    Write many small apps that can talk to each other.*'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在JavaScript中编写大型应用程序的秘诀不是编写大型应用程序。编写许多可以相互通信的小应用程序。*'
- en: This quote applies not only to large-scale applications, but also to modules
    and functions. If you can keep your modules and functions small and to the point,
    you’re on your way to writing great code.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话不仅适用于大型应用程序，也适用于模块和函数。如果你能保持你的模块和函数小而精，你就朝着编写优秀代码的道路前进了。
- en: Classes
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: An extension to the modularity of JavaScript is the class syntax introduced
    with ES2015\. Classes are syntactic sugar over JavaScript’s prototypal inheritance
    model, but they work as you mostly expect classes to work, if you have object-oriented
    programming (OOP) experience.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的模块化扩展是ES2015引入的类语法。类是JavaScript原型继承模型的语法糖，但如果你有面向对象编程（OOP）经验，它们的工作方式就像你预期的那样。
- en: Note, though, that JavaScript classes, at least up until ES2017, have public
    properties and public and static methods. Private and protected class visibility
    are due to be added to the specification at some undetermined point. They do have
    an inheritance hierarchy that uses the `extends` keyword, but there are no interfaces.
    Accessing functions from a parent involves the `super` function, and initialization
    uses a constructor function.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，JavaScript类，至少在ES2017之前，有公共属性和公共和静态方法。私有和受保护的类可见性将在某个未确定的时间点添加到规范中。它们确实有一个使用`extends`关键字继承的继承层次结构，但没有接口。从父类访问函数涉及`super`函数，初始化使用构造函数。
- en: We’re not going to cover the whys and wherefores of OOP, which is an exercise
    best left to you. (See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)
    for starters.) Here, we’ll cover the basics of the syntax.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖面向对象编程（OOP）的来龙去脉，这是一个最好留给你自己练习的练习。（可以从[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)开始了解。）在这里，我们将介绍语法的基础。
- en: Listing D.57\. Class syntax examples
  id: totrans-654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.57\. 类语法示例
- en: '[PRE73]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: There’s plenty more to classes than this, and in this book, you’ll have used
    them mostly in Angular as TypeScript classes to build components.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 类的概念远不止这些，在这本书中，你将主要使用Angular中的TypeScript类来构建组件。
- en: Functional programming concepts
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程概念
- en: Functional programming as a concept has been around longer than object orientation.
    For a long time, the concept was relegated to academia, because some of the languages
    used have steep learning curves, which raised the barrier to entry artificially
    high. Who wants to spend time learning obscure concepts only to be confused by
    the syntax when all you want to do is get information from the users of your site
    and push it into a database?
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种概念，函数式编程比面向对象编程存在的时间更长。长期以来，这个概念被归入学术界，因为一些使用的语言学习曲线陡峭，人为地提高了入门的门槛。谁愿意花时间去学习那些晦涩难懂的概念，结果却因为语法而感到困惑，而你只想从你网站的访客那里获取信息并将其推入数据库呢？
- en: Recently, though, all mainstream object-oriented languages have been pulling
    in and integrating concepts of functional programming languages, because these
    concepts provide surety of data, reduce cognitive load, and allow for composition
    of functionality.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最近，所有主流的面向对象语言都在吸收并整合函数式编程语言的概念，因为这些概念提供了数据的安全性，减少了认知负担，并允许功能的组合。
- en: Concepts that you can apply to your JavaScript work include immutability, purity,
    declarative style, and function composition.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将以下概念应用到你的JavaScript工作中，包括不可变性、纯净性、声明式风格和函数组合。
- en: A bunch of other stuff may or may not be available, depending on which version
    of the language you’re using. We’ll cover these concepts one at a time.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的语言版本，可能有一些其他功能可用或不可用。我们将逐一介绍这些概念。
- en: Immutability
  id: totrans-662
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不可变性
- en: Although immutability isn’t strictly enforced at a language level, through a
    little bit of forward planning and some rigor, you can implement it simply and
    effectively. Be aware that npm packages are available to help, such as immutable.js
    from Facebook ([https://github.com/facebook/immutable-js](https://github.com/facebook/immutable-js)).
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不可变性在语言级别上并不是强制执行的，但通过一点前瞻性规划和一些严谨性，你可以简单而有效地实现它。请注意，有npm包可以帮助实现，例如Facebook的immutable.js
    ([https://github.com/facebook/immutable-js](https://github.com/facebook/immutable-js))。
- en: The point is that data/state that you’re operating on isn’t mutated. Mutation
    is an in-place operation and can be the cause of hard-to-track bugs.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是你在操作的数据/状态不会被修改。修改是在原地进行的操作，可能是难以追踪的bug的原因。
- en: The concept as it applies to JavaScript means that the state isn’t altered;
    it’s copied, transformed, and assigned to an alternative variable. This concept
    can also be applied to collections of data and objects; although slightly more
    rigor needs to be applied, the outcome should be the same.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念在 JavaScript 中的应用意味着状态没有被改变；它是被复制、转换并分配给一个替代变量。这个概念也可以应用于数据集合和对象；尽管需要稍微更严格的处理，但结果应该是相同的。
- en: 'For simple scalar-type variables, applying immutability is simple: declare
    it with `const`. That way, the JavaScript execution context can’t overwrite the
    variable, and it throws an exception if you try by mistake. We covered this topic
    earlier.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的标量类型变量，应用不可变性很简单：使用 `const` 声明。这样，JavaScript 执行上下文就不能覆盖变量，如果你不小心尝试这样做，它会抛出一个异常。我们之前已经讨论过这个话题。
- en: For object types (`Array`s, `Object`s, `Map`s, `Set`s), declaring with `const`
    isn’t massively helpful. The issue is that `const` creates a reference to the
    object being created. As it’s a reference, the data within the object can be altered.
    This is where the rigor comes in. Instead of using looping constructs like `for`
    to manipulate the collection directly, use the iterators provided by that type;
    they’re prototype methods and should be available in both the browser and in Node.js.
    For functionality you want that isn’t supplied, there are always libraries such
    as Lodash.js and Ramda.js.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象类型（`Array`s、`Object`s、`Map`s、`Set`s），使用 `const` 并没有太大帮助。问题是 `const` 创建了对创建的对象的引用。由于它是一个引用，对象内部的数据可以被修改。这就是严格性的所在。不要使用
    `for` 等循环结构直接操作集合，而应使用该类型提供的迭代器；它们是原型方法，应该在浏览器和 Node.js 中都可用。对于你想要的功能，如果库如 Lodash.js
    和 Ramda.js 没有提供，你总是可以找到。
- en: Listing D.58\. Examples of applying the concept of immutability
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.58\. 应用不可变概念的一些示例
- en: '[PRE74]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* A simple collection of four names assigned to const**'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将四个名称简单收集并分配给常量**'
- en: '***2* Uses the map function to iterate over the names in the collection and
    assign to a new variable**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用映射函数遍历集合中的名称并将其分配给新变量**'
- en: '***3* Uses the filter function to remove those items from the collection that
    fail the given criteria**'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用过滤器函数从集合中移除不符合给定条件的项**'
- en: '***4* A new array of integers**'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 一个整数数组**'
- en: '***5* Reduces the values to a single total value by summing them together**'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 通过将值相加将值归约为一个单一的总值**'
- en: '***6* Reduces from the right, creating a product of the values in the provided
    list**'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 从右向左进行归约，创建提供列表中值的乘积**'
- en: Purity
  id: totrans-676
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 纯度
- en: '*Pure functions* are functions that don’t exhibit side effects or use data
    that hasn’t been supplied. A side effect is a change to the program state that’s
    external to the function and differs from the return value of the function. Typical
    side effects include changing global variables’ values, sending text to the screen,
    and printing. Some of these side effects are unwanted and harmful, but some are
    unavoidable and necessary. As JavaScript programmers, we should strive to reduce
    side effects as much as possible. This way, program state is predictable and therefore
    easy to reason about if bugs occur.'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '*纯函数* 是不显示副作用或使用未提供的数据的函数。副作用是指对程序状态的改变，这种改变超出了函数的范围，并且与函数的返回值不同。典型的副作用包括改变全局变量的值、向屏幕发送文本和打印。其中一些副作用是不受欢迎的，是有害的，但其中一些是不可避免的，也是必要的。作为
    JavaScript 程序员，我们应该尽可能减少副作用。这样，程序状态是可预测的，因此如果出现错误，就更容易推理。'
- en: Functions should operate only on the data that they’ve been provided. External
    data, such as global window state, shouldn’t be changed unless absolutely necessary,
    and even then, only in a controlled manner by a dedicated function. If your code
    is reliant on global state, that’s a bad code smell that you should investigate.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该只操作它们被提供的那些数据。除非绝对必要，否则不应更改外部数据，例如全局窗口状态，并且即使在这种情况下，也只应由专门的函数以受控的方式进行更改。如果你的代码依赖于全局状态，那可能是一个你应该调查的坏代码信号。
- en: 'Pure functions are predictable, and more often than not, they exhibit a property
    called *idempotency*: given a set of inputs, the expected output of a function
    is always the same.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是可预测的，而且往往表现出一种称为 *幂等性* 的属性：给定一组输入，函数的预期输出总是相同的。
- en: 'A simple, somewhat contrived example is a function that adds two numbers together:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单、有些牵强的例子是一个将两个数字相加的函数：
- en: '[PRE75]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If you supply `1` and `2` to such a function, you always expect `3` to be returned.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向这样的函数提供 `1` 和 `2`，你总是期望返回 `3`。
- en: What if this function also relied on a value that was maintained outside the
    function—such as `const sumWithGlobal = (a, b) => a + b + window.c`—and that this
    value (`window.c`) was generally `0` but sometimes `1` or maybe something random
    like a string? What would you expect in that instance when you supplied `1` and
    `2` as function arguments? You couldn’t rely on the result to be `3`; it might
    be `4` or something wildly different or even an exception.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数还依赖于函数外部维护的值——例如 `const sumWithGlobal = (a, b) => a + b + window.c`——并且这个值（`window.c`）通常为
    `0`，但有时为 `1` 或可能是像字符串这样的随机值？当你提供 `1` 和 `2` 作为函数参数时，你期望在这个情况下会发生什么？你无法依赖结果为 `3`；它可能是
    `4` 或其他截然不同或甚至抛出异常的结果。
- en: This example is a simple one, but what if it involved thousands of lines of
    code? As you can see, this makes the size of the issue magnitudes larger. Try
    to keep functions pure; being able to predict outputs makes everyone’s lives easier.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，但如果它涉及到数千行代码呢？正如你所见，这会使问题的规模大得多。尽量保持函数的纯净；能够预测输出使每个人的生活都更容易。
- en: Declarative code style
  id: totrans-685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 声明式代码风格
- en: We don’t want to speak for everybody, but we guess that most code you write
    is imperative in style. You set out what you want the computer to do line by line,
    much like a recipe. You might overlay this code with notes of object orientation,
    but it’s still a recipe. There’s nothing wrong with this approach; it works and
    mostly works well.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想代表所有人发言，但我们可以猜测你写的代码大多数是命令式风格的。你一行一行地设定你想要计算机做什么，就像一个食谱。你可能会在这个代码上叠加面向对象的注释，但仍然是一个食谱。这种做法没有错；它有效，并且大多数情况下效果很好。
- en: With declarative programming, you state the logic of what you’re looking to
    achieve but leave the execution details up to the computer. In essence, you don’t
    care how the outcome of your program is achieved so long as it’s achieved.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式编程中，你声明你想要实现的逻辑，但将执行细节留给计算机。本质上，你不在乎你的程序的结果是如何实现的，只要它实现了。
- en: 'In this style of JavaScript, code should favor the following:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种 JavaScript 风格中，代码应该优先考虑以下内容：
- en: Array iterators over `for` loops
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组迭代器在 `for` 循环中
- en: Recursion
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Partially applicable and composable functions
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用和可组合的函数
- en: Ternary operators over `if` statements to ensure return values
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三元运算符代替 `if` 语句以确保返回值
- en: Avoiding changing state, mutating data, and side effects
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免改变状态、修改数据和副作用
- en: We stress “should” because JavaScript doesn’t support things like tail call
    recursion due to an internal stack frame limit. Also, partial application and
    function composition are things that you build into your code, not things that
    are natively supported.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调“应该”，因为 JavaScript 由于内部栈帧限制不支持像尾递归这样的功能。此外，部分应用和函数组合是你构建到代码中的东西，而不是原生支持的东西。
- en: Listing D.59\. Declarative programming example
  id: totrans-695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.59\. 声明式编程示例
- en: '[PRE76]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Creates a compose function**'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个组合函数**'
- en: '***2* Creates a list of items**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个项目列表**'
- en: '***3* Composes functions together**'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 组合函数**'
- en: '***4* Executes the composed functions by passing in data**'
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 通过传递数据执行组合函数**'
- en: In this code, the important part is the instruction to `getProcessableList()`.
    All the other elements are boilerplate required to present this contrived example.
    The point is that the intention is declared, but how it gets done isn’t.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，重要的是对 `getProcessableList()` 的指令。所有其他元素都是为展示这个虚构示例所需的样板代码。重点是意图是声明的，但实现方式没有声明。
- en: Partial application and function composition
  id: totrans-702
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部分应用和函数组合
- en: Pure functions provide predictable outcomes. If you can predict outcomes, you
    can combine your functions in innovate ways. Smaller functions can become parts
    of larger functions, and you don’t have to worry about intermediary results. To
    help you understand function composition, we’ll discuss partial application.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数提供可预测的结果。如果你可以预测结果，你可以以创新的方式组合你的函数。较小的函数可以成为较大函数的组成部分，你不必担心中间结果。为了帮助你理解函数组合，我们将讨论部分应用。
- en: '*Partial application*, or *currying*, means applying fewer arguments to a function
    than it requires, each time returning a new function and therefore holding off
    completing execution until all arguments are available.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '*部分应用*，或*柯里化*，意味着向函数传递的参数少于它所需的参数，每次返回一个新的函数，因此推迟执行直到所有参数都可用。'
- en: Unfortunately, JavaScript has no native support for currying, but through use
    of syntax, you can emulate this feature. The following listing shows how.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，JavaScript 没有原生的支持函数柯里化，但通过使用语法，你可以模拟这个功能。下面的列表展示了如何做到这一点。
- en: Listing D.60\. Currying example
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.60\. 柯里化示例
- en: '[PRE77]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Simple standard noncurried function**'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 简单的标准非柯里化函数**'
- en: '***2* Curried equivalent**'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 柯里化等价**'
- en: '***3* All arguments collected together and applied at once**'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 所有参数一起收集并一次性应用**'
- en: '***4* Currying requires multiple function calls.**'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 柯里化需要多次函数调用。**'
- en: '***5* Here, the intermediary call applies 2 to the x argument, returning a
    function that requires another argument to create a result (y => 2 + y).**'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在这里，中间调用将2应用于x参数，返回一个需要另一个参数来创建结果（y => 2 + y）的函数。**'
- en: '***6* Applies the last required argument to return the expected value of 5**'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 应用最后一个必需的参数以返回预期的5值**'
- en: Currying isn’t special. All you’re doing is taking a multiargument function
    and returning a new function after the application of a single argument.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化并不特殊。你所做的就是取一个多参数函数，并在应用一个参数后返回一个新的函数。
- en: With this knowledge in place, you can look at composition. *Composition* is
    combining multiple functions to create complex flows. This technique allows you
    to avoid code that uses looping code structures that read like streams of instructions.
    Instead, you abstract away the complexity of the processing by combining the operations
    into simple, descriptive functions.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 在具备这些知识的基础上，你可以看看组合。*组合*是将多个函数组合起来以创建复杂的流程。这种技术允许你避免使用类似指令流的结构化循环代码。相反，通过将操作组合成简单、描述性的函数，你可以抽象出处理的复杂性。
- en: To work properly, the functions need to be small and pure, free of side effects.
    The functions that are being composed need the inputs and outputs to match, so
    applying currying is helpful but not mandatory. Having the inputs and outputs
    match means that a function that takes an integer shouldn’t be composed with a
    function that takes a string. Although input mismatch is technically acceptable
    in JavaScript due to the language’s ability to implicitly typecast, it can be
    a source of bugs that may be difficult to track down.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正常工作，函数需要小而纯，没有副作用。正在组合的函数需要输入和输出匹配，因此应用柯里化是有帮助的，但不是必需的。输入和输出匹配意味着一个接受整数的函数不应该与一个接受字符串的函数组合。尽管由于语言能够隐式类型转换，输入不匹配在技术上是可以接受的，但它可能是一个难以追踪的错误的来源。
- en: A simple way to look at this is an example. The next listing takes the `curriedSum()`
    function from the preceding listing.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方式来观察这一点是举一个例子。接下来的列表从上一个列表中获取了 `curriedSum()` 函数。
- en: Listing D.61\. Simple composition
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.61\. 简单的组合
- en: '[PRE78]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1* Add function**'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加函数**'
- en: '***2* Simple curryable factor function**'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 简单的可柯里化因子函数**'
- en: '***3* Composes the functions to return a result of 100**'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 组合函数以返回100的结果**'
- en: This example is simple and contrived but illustrates the point.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，但说明了这个观点。
- en: Some libraries provide a function called `compose` that allows you to handle
    composition in a more elegant way, although this function isn’t difficult to build
    by hand. The basic principle is the simple application of the mathematical formula
    `g(f(x))`.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库提供了一个名为 `compose` 的函数，它允许你以更优雅的方式处理组合，尽管这个函数并不难手动构建。基本原理是简单应用数学公式 `g(f(x))`。
- en: Listing D.62\. `compose` function
  id: totrans-725
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.62\. `compose` 函数
- en: '[PRE79]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1* Simple compose function**'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 简单的组合函数**'
- en: '***2* Uses the composition function**'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用组合函数**'
- en: '***3* Obtains the result**'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取结果**'
- en: Beyond these small examples, composition is a tool that can make your code cleaner
    and easier to understand.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些小例子之外，组合是一种可以使你的代码更简洁、更容易理解的工具。
- en: Final thoughts
  id: totrans-731
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后的想法
- en: JavaScript is a forgiving language, which makes it easy to learn, but it’s also
    easy to pick up bad habits. If you make a little mistake in your code, JavaScript
    sometimes thinks, “Well, I think you meant to do this, so that’s what I’ll go
    with.” Sometimes it’s right, and sometimes it’s wrong. This isn’t acceptable for
    good code, so it’s important to be specific about what your code should do, and
    you should try to write your code in the way that the JavaScript interpreter sees
    it.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种宽容的语言，这使得它容易学习，但也容易养成坏习惯。如果你在代码中犯了一个小错误，JavaScript 有时会想，“嗯，我想你可能想这么做，所以我会这么做。”有时候它是正确的，有时候是错误的。这对好代码来说是不可以接受的，因此，明确你的代码应该做什么很重要，你应该尝试以
    JavaScript 解释器看到的方式编写你的代码。
- en: 'A key to understanding the power of JavaScript is understanding scope: global
    scope and function scope and lexical scope. There are no other types of scope
    in JavaScript. You want to avoid using the global scope as much as possible, and
    when you do use it, try to do it in a clean and contained way. Scope inheritance
    cascades down from the global scope, so it can be difficult to maintain if you’re
    not careful.'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 理解JavaScript的强大之处的一个关键在于理解作用域：全局作用域、函数作用域和词法作用域。JavaScript中没有其他类型的作用域。你应尽可能避免使用全局作用域，当你确实需要使用它时，尽量以干净和封装的方式使用。作用域继承自全局作用域向下级联，因此如果不小心，维护起来可能会很困难。
- en: JSON is born of JavaScript but isn’t JavaScript; it’s a language-independent
    data exchange format. JSON contains no JavaScript code and can quite happily be
    passed between a PHP server and a .NET server; JavaScript isn’t required to interpret
    JSON.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: JSON起源于JavaScript，但并非JavaScript；它是一种独立于语言的数据交换格式。JSON不包含JavaScript代码，可以非常愉快地在PHP服务器和.NET服务器之间传递；不需要JavaScript来解释JSON。
- en: Callbacks are vital to running successful Node applications, because they allow
    the central process to effectively delegate tasks that could hold it up. To put
    it another way, callbacks enable you to use sequential synchronous operations
    in an asynchronous environment. But callbacks aren’t without their problems. It’s
    easy to end up in callback hell, having multiple nested callbacks with overlapping
    inherited scopes making your code hard to read, test, debug, and maintain. Fortunately,
    you can use named callbacks to address this problem on all levels so long as you
    remember that named callbacks don’t inherit scope like their inline anonymous
    counterparts.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 回调对于运行成功的Node应用程序至关重要，因为它们允许中央进程有效地委托那些可能阻碍其运行的任务。换句话说，回调使你能够在异步环境中使用顺序同步操作。但回调并非没有问题。很容易陷入回调地狱，有多个嵌套的回调和重叠的继承作用域，使得代码难以阅读、测试、调试和维护。幸运的是，只要你记住命名回调不像它们的内联匿名回调那样继承作用域，你就可以在所有层面上使用命名回调来解决这个问题。
- en: Closures and module patterns provide ways to write code that’s self-contained
    and reusable between projects. A closure enables you to define a set of functions
    and variables within its own distinct scope, which you can come back to and interact
    with through the exposed methods. This leads to the revealing module pattern,
    which is convention-driven to draw specific lines between what’s private and what’s
    public. Modules are perfect for writing self-contained pieces of code that can
    interact well with other code, not tripping up over any scope clashes.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包和模块模式提供了在项目间编写自包含且可重用代码的方法。闭包允许你在其自身的独立作用域内定义一组函数和变量，你可以通过暴露的方法返回并与之交互。这导致了揭示性模块模式的出现，该模式遵循惯例来明确区分私有和公共部分。模块非常适合编写自包含的代码片段，这些代码片段可以与其他代码良好地交互，不会因为作用域冲突而出现问题。
- en: Recent changes to the JavaScript specification, such as the addition of class
    syntax and greater emphasis on functional programming, flesh out the available
    toolkit to suit whichever style of code you want to use.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript规范最近的变更，例如添加类语法和更加强调函数式编程，丰富了可用的工具集，以适应你想要使用的任何代码风格。
- en: 'A great many other additions to the JavaScript specification aren’t covered
    here: the rest operator, the spread operator, and generators, to name a few. It’s
    an exciting time to be working with the JavaScript language.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript规范中许多其他新增内容在此未涵盖：例如剩余操作符、展开操作符和生成器等。这是一个与JavaScript语言一起工作的激动人心的时刻。
