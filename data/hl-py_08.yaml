- en: Chapter 9\. Gaming with Pyglet
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章\. 使用 Pyglet 进行游戏
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容**'
- en: '*Display images and text on the screen*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在屏幕上显示图像和文本*'
- en: '*Using event loops and timers*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用事件循环和计时器*'
- en: '*Game design, and making your game fun*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*游戏设计和让你的游戏有趣*'
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this chapter, you’ll be writing your own arcade game using a library called
    Pyglet. Pyglet bills itself as a “cross-platform windowing and multimedia library
    for Python,” but you’ll be using it for its *real* purpose—writing games!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用名为 Pyglet 的库编写自己的街机游戏。Pyglet 自称为“跨平台的 Python 窗口和多媒体库”，但你将用它来实现其*真正*的目的——编写游戏！
- en: If you’re familiar with various arcade games, yours will be sort of a cross
    between Spacewar!, Asteroids, and Space Invaders—it will have a spaceship, evil
    aliens to shoot, and a planet to run into. To make the game more interesting,
    you’ll give the planet some gravity, so it draws in the ship gradually.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉各种街机游戏，你的游戏将类似于 Spacewar!、Asteroids 和 Space Invaders 的结合——它将有一个宇宙飞船、要射击的邪恶外星人，以及一个要撞到的星球。为了让游戏更有趣，你将给星球一些重力，这样它就会逐渐吸引飞船。
- en: But first, you’ll need to get Pyglet installed and working on your computer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，你需要将 Pyglet 安装并配置在你的电脑上。
- en: Installing Pyglet
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Pyglet
- en: 'The first thing you’ll need to do is to download and install Pyglet. A Windows
    installer and source code are available from [www.pyglet.org/download.html](http://www.pyglet.org/download.html),
    and Pyglet is available as a package for several Linux distributions. Pyglet installation
    is straightforward under Windows: download the installer program, and run it.
    Mac users can download a .dmg image with an installer on it, and there are packages
    for most Linux distributions. The next figure shows the Windows installer doing
    its thing.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是下载并安装 Pyglet。Windows 安装程序和源代码可以从 [www.pyglet.org/download.html](http://www.pyglet.org/download.html)
    获取，Pyglet 作为软件包在几个 Linux 发行版中可用。在 Windows 下安装 Pyglet 很简单：下载安装程序，然后运行它。Mac 用户可以下载带有安装程序的
    .dmg 图像，大多数 Linux 发行版都有软件包。下一张图显示了 Windows 安装程序正在运行。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Pyglet uses OpenGL under the hood, so you’ll need an OpenGL-capable graphics
    card. This normally isn’t a problem, unless you’re running an old computer—most
    cards released in the past five years or so support OpenGL automatically.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 在底层使用 OpenGL，所以你需要一块支持 OpenGL 的显卡。这通常不是问题，除非你正在运行一台旧电脑——过去五年左右发布的几乎所有显卡都自动支持
    OpenGL。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If none of those options work for you, you can always download the source package
    and run *python setup.py install*, though you’ll also need to install AVbin separately
    if you take this route.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述选项都不适合你，你可以始终下载源代码包并运行 *python setup.py install*，尽管如果你选择这条路，你还需要单独安装 AVbin。
- en: Figure 9.1\. Installing Pyglet
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 安装 Pyglet
- en: '![](09fig01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig01.jpg)'
- en: 'Let’s start with a simple Pyglet program, breaking it down line by line:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的 Pyglet 程序开始，逐行分析：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All the submodules of Pyglet are stored within the *pyglet* module. You can
    access the window module, for example, with *pyglet.window*. This saves you importing
    several modules at the top of your program, and makes your code easier to read.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 的所有子模块都存储在 *pyglet* 模块中。例如，你可以使用 *pyglet.window* 访问窗口模块。这可以节省你在程序顶部导入多个模块，并使你的代码更容易阅读。
- en: Pyglet’s *Window* object handles all the screen initialization and rendering.
    You’ll generally need one in every Pyglet application you write. You’re passing
    in *fullscreen=True* as an argument so the window takes up the whole screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 的 *Window* 对象处理所有屏幕初始化和渲染。你通常需要在每个 Pyglet 应用程序中有一个。你正在将 *fullscreen=True*
    作为参数传递，这样窗口就会占据整个屏幕。
- en: Pyglet is a framework, so after you’ve set everything up, you need to call its
    main application loop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 是一个框架，所以在你设置好一切之后，你需要调用其主应用程序循环。
- en: If you type this program in and run it, you should see a screen similar to [figure
    9.2](#ch09fig02).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入这个程序并运行它，你应该会看到一个类似于 [图 9.2](#ch09fig02) 的屏幕。
- en: Figure 9.2\. A black screen
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.2\. 一个黑色屏幕
- en: '![](09fig02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig02.jpg)'
- en: '![](f0290-01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](f0290-01.jpg)'
- en: 'That’s right—a big black screen. Not very impressive, but it’s *your* black
    screen: the blank canvas on which you’ll write your masterpiece. As an added bonus,
    you know Pyglet is working properly. To exit Pyglet, press the Escape key.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 没错——一个大大的黑色屏幕。并不怎么引人注目，但这是*你的*黑色屏幕：你将在这张空白画布上创作你的杰作。作为额外的奖励，你知道 Pyglet 正在正常工作。要退出
    Pyglet，请按 Escape 键。
- en: Next, we’ll figure out how to make that black screen more impressive.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将找出如何让那个黑色屏幕更加引人注目。
- en: First steps
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步
- en: Let’s get started! The first thing you’d like to do is display an image on the
    screen. Because you’re writing a space game, let’s make it a nice big planet.
    I’ve used an image of Mars that I downloaded from NASA’s website at [www.nasa.gov/multimedia/imagegallery/](http://www.nasa.gov/multimedia/imagegallery/),
    but feel free to create your own if you’re feeling artistic. The next listing
    will display your planet image on the screen.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！你首先想做的事情是在屏幕上显示一个图像。因为你正在编写一个太空游戏，让我们做一个大行星。我使用了一个从 NASA 网站下载的火星图像 [www.nasa.gov/multimedia/imagegallery/](http://www.nasa.gov/multimedia/imagegallery/)，但如果你有艺术感，你也可以自己创建。接下来的列表将显示你的行星图像。
- en: Listing 9.1\. Drawing on the screen
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 在屏幕上绘制
- en: '![](ch09list1-0.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09list1-0.jpg)'
- en: '![](ch09list1-1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](ch09list1-1.jpg)'
- en: Before you display images, you need to tell Pyglet where to find them. To do
    that, you append the path to an images folder onto Pyglet’s resource path ![](one.jpg)
    and ask it to reindex its resources. You’ll also need to create the folder manually
    and save your planet image in it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在你显示图像之前，你需要告诉 Pyglet 它们在哪里。为此，你将图像文件夹的路径追加到 Pyglet 的资源路径 ![](one.jpg)，并要求它重新索引其资源。你还需要手动创建文件夹，并将你的行星图像保存在其中。
- en: '![](f0292-01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](f0292-01.jpg)'
- en: Once you have your image source, all you need to do is call the *pyglet.resource.image*
    function, which will read the image from your resource directory ![](two.jpg).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了图像源，你所需要做的就是调用 *pyglet.resource.image* 函数，它将从你的资源目录中读取图像 ![](two.jpg)。
- en: By default, an image has an anchor at the lower-left corner; you’d prefer it
    in the center. I’ve created a function that will do that for you. Because you
    want the x and y coordinates to be integers, Python’s integer division operator
    (*//*) makes sure the result is an integer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，图像有一个在左下角的锚点；你更希望它在中心。我创建了一个函数，可以为你做到这一点。因为你希望 x 和 y 坐标是整数，Python 的整数除法运算符
    (*//*) 确保结果是整数。
- en: Pyglet is capable of drawing images directly to the screen, but a faster and
    cleaner way is to use a *Sprite* class ![](three.jpg). Sprites track their position
    and image and have their own optimized drawing routines, which make your program
    run faster. You’ll create one instance of your planet and stick it right in the
    middle of the screen. One thing to note is that you’re calling *super(Planet,
    self)* to get the parent class of your sprite—so you don’t have to worry about
    manually updating it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 能够直接在屏幕上绘制图像，但更快、更干净的方法是使用 *Sprite* 类 ![](three.jpg)。精灵跟踪其位置和图像，并拥有自己的优化绘制程序，这使得你的程序运行更快。你将创建一个你行星的实例，并将其直接放置在屏幕中央。需要注意的是，你调用
    *super(Planet, self)* 来获取你的精灵的父类——这样你就不必担心手动更新它。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Games are an area where a class-based design often makes a lot of sense, because
    there are usually a number of entities that behave similarly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏是一个基于类的设计通常很有意义的地方，因为通常有许多实体具有相似的行为。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once you’ve created the sprite, you need to tell Pyglet to draw it every frame.
    To do this, you create an *on_draw* event handler ![](four.jpg) for the window
    (we’ll cover event handlers in more detail in the next section). You’ll do more
    later, but for now you clear the screen and draw the planet.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了精灵，你需要告诉 Pyglet 在每一帧绘制它。为此，你为窗口创建一个 *on_draw* 事件处理器 ![](four.jpg)（我们将在下一节中更详细地介绍事件处理器）。你以后会做更多的事情，但现在你先清除屏幕并绘制行星。
- en: Figure 9.3\. Your planet. Ideal for running into with your spaceship! (Image
    courtesy of NASA/JPL/Malin Space Science Systems)
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.3\. 你的行星。非常适合你的宇宙飞船相撞！（图片由 NASA/JPL/Malin 空间科学系统提供）
- en: '![](09fig03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig03.jpg)'
- en: You should see a nice big planet in the middle of your screen.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在屏幕中央看到一个漂亮的行星。
- en: The planet will be a hazard for your spaceship, but first you need a spaceship.
    Let’s do that part next. In the process, we’ll introduce some important concepts
    when writing games or any event-based program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 行星将成为你的宇宙飞船的障碍，但首先你需要一艘飞船。让我们接下来做这部分。在这个过程中，我们将介绍在编写游戏或任何基于事件的程序时的一些重要概念。
- en: '![](f0293-01.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](f0293-01.jpg)'
- en: Starship piloting 101
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宇宙飞船驾驶 101
- en: 'Your ship follows much of the same process as the planet, with one main exception:
    it will move around the screen in response to the player pressing keys. If you’ve
    ever played Asteroids, you’ll be familiar with the control method you’ll use.
    The up arrow will fire your engines, and left and right will turn your ship. If
    you want to slow down or go backward, you need to turn your ship around completely
    and fire your engines in the opposite direction.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你的飞船遵循与行星几乎相同的流程，只有一个主要区别：它会在玩家按下按键时在屏幕上移动。如果你曾经玩过 Asteroids，你会熟悉你将使用的控制方法。上箭头会启动引擎，左右键会转向飞船。如果你想减速或后退，你需要完全转向飞船并朝相反方向启动引擎。
- en: The following listing shows the start of your *Ship* class. You’ll be adding
    features to it through the rest of this section. I’ve included this class in the
    same file as the planet, but feel free to create a new file and import it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了你的 *Ship* 类的开始。你将通过本节的其余部分添加功能。我已经将这个类包含在与行星相同的文件中，但你可以自由地创建一个新文件并导入它。
- en: Listing 9.2\. `Ship` class
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.2\. `Ship` 类
- en: '![](09list02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09list02.jpg)'
- en: 'First, you load the image for your ship ![](one.jpg), in the same way you did
    for the planet. Your *Ship* class looks similar to *Planet*, but you have some
    extra information ![](two.jpg): *.dx* and *.dy* are the ship’s speed in the x
    and y directions, and *.rotation* is how far left or right you’ve turned. You
    also put in *.thrust* and *.rot_spd* to determine how fast the ship should accelerate
    and turn. The higher these numbers are, the faster the ship will go.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你以与行星相同的方式加载你的飞船 ![图片](one.jpg) 的图像。你的 *Ship* 类看起来与 *Planet* 类似，但你有一些额外的信息
    ![图片](two.jpg)：*.dx* 和 *.dy* 是飞船在 x 和 y 方向上的速度，而 *.rotation* 是你向左或向右转的程度。你还加入了
    *.thrust* 和 *.rot_spd* 来确定飞船应该加速和转向的速度。这些数字越高，飞船的速度就越快。
- en: Now you can create an instance of your ship ![](three.jpg). You feed in the
    ship’s speed here as *dx* and *dy*, but it won’t have any effect until you start
    updating the ship’s position in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建你的飞船实例 ![图片](three.jpg)。你在这里输入飞船的速度作为 *dx* 和 *dy*，但直到你在下一节开始更新飞船的位置之前，它不会有任何效果。
- en: Once you have your ship, you can add *ship.draw()* to the *on_draw* event handler,
    and your ship will appear on the screen ![](four.jpg).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了飞船，你可以在 *on_draw* 事件处理器中添加 *ship.draw()*，你的飞船就会出现在屏幕上 ![图片](four.jpg)。
- en: Now you can see where your ship will start, and what it looks like.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到你的飞船将开始的位置，以及它的外观。
- en: '![](f0294-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0294-01.jpg)'
- en: Figure 9.4\. Your spaceship
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 你的宇宙飞船
- en: '![](09fig04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig04.jpg)'
- en: So far it’s no different than the planet you’re drawing, but now that you’ve
    set up your sprite, you can start making it do things.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，它与你在绘制的行星没有不同，但现在你已经设置了精灵，你可以开始让它做一些事情。
- en: Making things happen
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让事情发生
- en: In most games, you have control over some aspect—such as the main character—and
    can give input to tell them what to do next. Push the left arrow and move left;
    push the right arrow and move right. In this section, you’ll see how games accomplish
    this.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数游戏中，你控制某个方面——比如主要角色——并且可以输入指令来告诉他们下一步该做什么。按左箭头向左移动；按右箭头向右移动。在本节中，你将看到游戏是如何实现这一点的。
- en: Pyglet uses an *event-based* programming model, and it’s how most interactive
    programs like games and graphical user interfaces are written. Rather than checking
    or waiting for input at certain sections of your program, you instead register
    functions to be called when something interesting happens. Pyglet refers to these
    functions as *event handlers*. If you’re used to a standard imperative design
    (“do this, then this...”), an event-based structure can seem odd, but it’s a much
    cleaner way of writing some sorts of programs. The next listing introduces two
    event handlers—one for when keys are pressed, and another for when they’re released.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet 使用基于事件的编程模型，这也是大多数交互式程序（如游戏和图形用户界面）的编写方式。你不需要在程序的特定部分检查或等待输入，而是注册函数，以便在发生有趣的事情时调用。Pyglet
    将这些函数称为 *事件处理器*。如果你习惯于标准的命令式设计（“这样做，然后这样做...”），基于事件的架构可能会显得有些奇怪，但它是一种编写某些类型程序更干净的方法。接下来的列表介绍了两个事件处理器——一个用于按键按下时，另一个用于按键释放时。
- en: Listing 9.3\. Handling events
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.3\. 处理事件
- en: '![](09list03_alt.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09list03_alt.jpg)'
- en: 'To respond to keys, Pyglet defines two event handlers, *on_key_press* and *on_key_release*
    ![](one.jpg). They’re defined in much the same way the *on_draw* function is,
    but they have two arguments: the key that is pressed, and any extra keys that
    are held down, such as Shift or Ctrl.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应用户按键，Pyglet 定义了两个事件处理器，*on_key_press* 和 *on_key_release* ![图片](one.jpg)。它们与
    *on_draw* 函数的定义方式类似，但它们有两个参数：按下的键，以及任何额外按下的键，例如 Shift 或 Ctrl。
- en: '![](f0296-01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0296-01.jpg)'
- en: The symbol argument is an integer, but Pyglet defines a large number of keys
    you can use ![](two.jpg) without having to worry about how to represent non-printable
    keys, like left arrow or the Esc key. To use them, import *key* from *pyglet.window*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 符号参数是一个整数，但 Pyglet 定义了大量你可以使用的键，无需担心如何表示不可打印的键，例如左箭头键或 Esc 键 ![图片](two.jpg)。要使用它们，请从
    *pyglet.window* 导入 *key*。
- en: If arrow keys are pressed, you need to make some change to the game’s state.
    In this case, they correspond directly to the ship, so you’ll make a change to
    the ship’s state, and let the ship handle the changes during its *update* method
    ![](three.jpg).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下箭头键，你需要对游戏状态进行一些更改。在这种情况下，它们直接对应于飞船，因此你将对飞船的状态进行更改，并让飞船在其 *update* 方法中处理这些更改
    ![图片](three.jpg)。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Events are a powerful technique that make your programs simpler and easier to
    write. The alternative is to write one big loop that checks everything in your
    game. It has to run as quickly as possible, or your game will be slow and unplayable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一个强大的技术，可以使你的程序更简单、更容易编写。另一种方法是编写一个大的循环，检查游戏中的所有内容。它必须尽可能快地运行，否则你的游戏将会很慢，无法玩。
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once you’ve done that, pressing the arrow keys will trigger an *on_key_press*
    event and update your ship’s status—but you won’t see anything happen on the screen.
    That’s because you haven’t told the ship how to respond to changes in its status.
    For that, you’ll need to write an *update* method to change the rotation of the
    ship according to its status.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这些，按下箭头键将触发一个 *on_key_press* 事件并更新飞船的状态——但你不会在屏幕上看到任何变化。那是因为你没有告诉飞船如何对其状态的变化做出响应。为此，你需要编写一个
    *update* 方法来根据其状态更改飞船的旋转。
- en: Listing 9.4\. Updating the ship
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. 更新飞船
- en: '![](09list04_alt.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09list04_alt.jpg)'
- en: When the ship is first created, it won’t be turning left or right, or firing
    its engines. You set the ship’s state here ![](one.jpg) so your update function
    won’t throw an exception later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当飞船首次创建时，它不会向左或向右转动，也不会启动引擎。你在这里设置飞船的状态 ![图片](one.jpg)，这样你的更新函数就不会在以后抛出异常。
- en: By convention, most Pyglet classes will have an *update* method that gets called
    on each “tick” of the game engine ![](two.jpg). This is where your sprites change
    their position, create new objects in the game, and update their internal state.
    An *update* method takes one argument, *dt*, which tells you how much time has
    passed since the last time update was called.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，大多数 Pyglet 类将有一个在游戏引擎的每个“tick”上被调用的 *update* 方法 ![图片](two.jpg)。这是你的精灵改变位置、在游戏中创建新对象以及更新其内部状态的地方。一个
    *update* 方法接受一个参数，*dt*，它告诉你自上次调用更新以来过去了多少时间。
- en: You’re starting out simply, so you’re rotating the ship left and right for now
    ![](three.jpg). If you’re turning, then you update the *.rotation* attribute (a
    Pyglet built-in that rotates the sprite) by multiplying your rotation speed by
    *dt*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在开始得很简单，所以你现在只是左右旋转飞船 ![图片](three.jpg)。如果你在转动，那么你通过将旋转速度乘以 *dt* 来更新 *.rotation*
    属性（一个 Pyglet 内置的旋转精灵的属性）。
- en: Later, you’ll have other objects with *update* methods, so it’s a good idea
    to collect all of the method calls in one place ![](four.jpg).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将拥有具有 *update* 方法的其他对象，因此将所有方法调用收集在一个地方是一个好主意 ![图片](four.jpg)。
- en: '![](f0297-01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0297-01.jpg)'
- en: Figure 9.5\. Turning the ship
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.5\. 转动飞船
- en: '![](09fig05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig05.jpg)'
- en: Finally, you set Pyglet’s built-in scheduler to call your main update method
    60 times per second ![](five.jpg). This is the maximum speed at which Pyglet will
    run your game. If it’s slower, then you’ll get different values for *dt*, but
    your game will still run.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将 Pyglet 的内置调度器设置为每秒调用你的主要更新方法 60 次 ![图片](five.jpg)。这是 Pyglet 运行你的游戏的最大速度。如果它更慢，那么你将得到不同的
    *dt* 值，但你的游戏仍然会运行。
- en: Now your feedback loop is finished, and you can see the results of all your
    hard work. If you run the program, you should be able to rotate your ship left
    and right by pushing the left and right arrow keys.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的反馈循环已经完成，你可以看到你所有辛勤工作的结果。如果你运行程序，你应该能够通过按左右箭头键来左右旋转你的飞船。
- en: The next step is to make your ship move. To do that properly, though, you’ll
    need to learn a bit about how to specify directions and distances.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是让船只移动。不过，为了正确地做到这一点，你需要了解如何指定方向和距离。
- en: 'Back to school: Newton’s first law (and vectors)'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 回到学校：牛顿第一定律（以及向量）
- en: In order to make your ship move consistently, you’ll need to apply a little
    bit of theory. You may remember some of this from school, from math or physics
    courses. If not, don’t worry—we’ll be taking things one step at a time. The first
    thing to know is that x represents values that go left to right, and y represents
    values that go up and down, as illustrated here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的船只保持一致的运动，你需要应用一点理论。你可能记得一些从学校、数学或物理课程中学到的内容。如果不记得，不要担心——我们将一步一步地进行。首先要知道的是，x
    代表从左到右的值，y 代表从上到下的值，如图所示。
- en: Newton’s First Law
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 牛顿第一定律
- en: If you think back to your physics classes, you might remember Newton’s first
    law. Briefly, it states, “A body in motion will continue that motion unless acted
    on by an external force.” What this means is that your ship should move in a straight
    line unless you fire the engines. You already have a velocity—that’s the *.dx*
    and *.dy* attributes of your *Ship* class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想起你的物理课程，你可能会记得牛顿的第一定律。简而言之，它声明，“一个运动的物体将继续其运动，除非受到外部力的作用。”这意味着你的船只应该沿直线运动，除非你启动引擎。你已经有一个速度——这是你的
    *Ship* 类的 *.dx* 和 *.dy* 属性。
- en: Figure 9.6\. x and y coordinates. x represents values that go left to right,
    and y represents values that go up and down.
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.6\. x 和 y 坐标。x 代表从左到右的值，y 代表从上到下的值。
- en: '![](09fig06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![09fig06.jpg](09fig06.jpg)'
- en: Vectors
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 向量
- en: The second thing you need is a way to convert the angle of the ship and its
    acceleration into values you can add to the ship’s x and y velocities. Whenever
    your ship’s engines are firing, you’ll need to break up its angle like this to
    work out the effect on your velocity in the x and y directions. The direction
    in the next figure means that when the ship’s engines fire, you’ll need to add
    2 to your x velocity and 3 to your y velocity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要的是一种将船只的角度和加速度转换为可以添加到船只 x 和 y 速度中的值的方法。每当你的船只引擎启动时，你需要像这样分解其角度，以计算出对 x
    和 y 方向速度的影响。下一图中的方向意味着当船只引擎启动时，你需要将 2 添加到你的 x 速度，将 3 添加到你的 y 速度。
- en: 'You’ll need a few math modules to do this in Python, but the principle isn’t
    any different from [figure 9.7](#ch09fig07): figure out the x and y parts of the
    acceleration, and add those to your x and y velocities. During each update, add
    your velocity to your position.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要几个数学模块来在 Python 中完成这项工作，但原理与 [图 9.7](#ch09fig07) 并无不同：找出加速度的 x 和 y 部分，并将这些添加到你的
    x 和 y 速度中。在每次更新时，将你的速度添加到你的位置。
- en: '![](f0299-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![f0299-01.jpg](f0299-01.jpg)'
- en: Figure 9.7\. The ship’s angle can have x and y parts.
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.7\. 船只的角度可以分解为 x 和 y 部分。
- en: '![](09fig07.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![09fig07.jpg](09fig07.jpg)'
- en: Listing 9.5\. Moving the ship
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 移动船只
- en: '![](ch09list5-0.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![ch09list5-0.jpg](ch09list5-0.jpg)'
- en: '![](ch09list5-1.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![ch09list5-1.jpg](ch09list5-1.jpg)'
- en: All the trigonometric functions you need are stored in Python’s *math* module,
    so you start by importing it ![](one.jpg).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用 Python 的 *math* 模块存储所有所需的三角函数，因此你首先需要导入它 ![one.jpg](one.jpg)。
- en: '![](f0300-01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![f0300-01.jpg](f0300-01.jpg)'
- en: Thinking ahead a little, you’ll also want to be able to handle the case where
    the ship moves off the edge of the screen. You’ll take the easy option and wrap
    the game up and down and left to right ![](three.jpg). *wrap* is a function that
    does that—given the value and the amount you’d like it to be constrained to.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 事先稍微考虑一下，你可能还希望能够处理船只移动到屏幕边缘的情况。你将选择简单的方法，将游戏上下左右都包裹起来 ![three.jpg](three.jpg)。*wrap*
    是一个执行此操作的函数——给定值和您希望它约束到的数量。
- en: Next, you break your angle into x and y parts ![](four.jpg). Note that these
    might be negative if the angle points left or down. Also, Pyglet and the *.math*
    module use different representations of angles (degrees versus radians), so you
    need a function to convert from Pyglet’s version into something the *math* module
    can use. You also need to flip your rotation around to get the right values in
    the y direction.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将你的角度分解为 x 和 y 部分 ![four.jpg](four.jpg)。注意，如果角度指向左或下，这些值可能是负数。此外，Pyglet
    和 *.math* 模块使用不同的角度表示（度数与弧度），因此你需要一个函数将 Pyglet 的版本转换为 *math* 模块可以使用的版本。你还需要翻转你的旋转，以在
    y 方向获得正确的值。
- en: Figure 9.8\. Now you can drive your spaceship around. Brrm! Brrm!
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.8\. 现在，你可以驾驶你的宇宙飞船四处移动了。哔哔！哔哔！
- en: '![](09fig08.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![09fig08.jpg](09fig08.jpg)'
- en: '![](f0301-01.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f0301-01.jpg](f0301-01.jpg)'
- en: Once you have your two components, the rest is relatively straightforward. You
    multiply each part by the ship’s acceleration and how long it’s been since your
    last update, and add each 1 to your velocity ![](five.jpg).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了两个分量，剩下的就相对简单了。你将每个部分乘以飞船的加速度和自上次更新以来经过的时间，然后将每个 1 加到你的速度上 ![five.jpg]。
- en: The last step is to update your position on the screen ![](six.jpg). You also
    check to make sure you can’t go over the edge of the screen by wrapping your x
    and y positions based on the height and width of the window.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新你在屏幕上的位置 ![six.jpg]。你还需要检查确保你不会因为基于窗口的高度和宽度包裹你的 x 和 y 位置而超出屏幕边缘。
- en: Finally, it looks a bit odd for your ship to be flying around without any visual
    feedback, so I created an extra image with some flames shooting out of the back.
    You swap it over whenever the ship’s engines are on ![](three.jpg).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你的飞船在没有任何视觉反馈的情况下飞行，看起来有点奇怪，所以我创建了一个额外的图像，其中有一些火焰从后面喷出。当飞船的引擎开启时，你切换到这个图像
    ![three.jpg]。
- en: Now you can drive your ship around the screen, accelerate, and turn around to
    decelerate. Wheee! It’s fun for a while, but ultimately there’s not much to do,
    and the mechanics are easy to understand. What you’d like is to have something
    more complex, so you have more opportunities for different sorts of interaction
    with the game.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以驾驶你的飞船在屏幕上移动，加速，然后转弯减速。Wheee！这很有趣，但最终没有太多可做的事情，机制也容易理解。你想要的可能是更复杂的东西，这样你就有更多机会与游戏进行不同类型的互动。
- en: Gravity
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重力
- en: You’ll add to the game by making the planet have gravity, so it pulls on the
    ship. If the ship collides with the planet, then BOOM! No more ship! Fending off
    aliens while trying to keep clear of the planet should add enough difficulty to
    keep the player occupied and entertained.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过让行星具有重力来增加游戏的功能，这样它就会吸引飞船。如果飞船与行星相撞，那么 BOOM！飞船就没了！在抵御外星人的同时试图避开行星，这将增加足够的难度，以保持玩家忙碌和娱乐。
- en: Calculating gravity
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算重力
- en: How exactly do you go about adding that functionality? Well, the obvious place
    to put it is within the *Planet* class. It makes sense because it’s the planet
    that’s affecting the ship, and if you want anything else to be pulled by the planet’s
    gravity, it won’t be too hard to add. Essentially, you’re adding another force
    to the ship, just as you did when firing its engines.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何添加这个功能呢？显然，你应该在 *Planet* 类中放置它。这样做是有意义的，因为行星是影响飞船的，如果你想让其他任何东西被行星的引力吸引，这不会太难。本质上，你是在给飞船添加另一个力，就像你启动引擎时做的那样。
- en: '[Figure 9.9](#ch09fig09) shows you what the problem looks like. The long line
    is the vector from your ship to the planet. You’d like to find that, convert it
    into a force vector, and then split that vector into an x and y so you can easily
    add it to your ship’s velocity. Let’s deal with the easy bit first: splitting
    the force vector.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9.9](#ch09fig09) 展示了问题的样子。长线是从你的飞船到行星的矢量。你希望找到这个矢量，将其转换为力矢量，然后将其分解为 x 和
    y，这样你就可以轻松地将其添加到飞船的速度中。我们先处理容易的部分：分解力矢量。'
- en: Figure 9.9\. Gravity applies a force to your ship.
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.9\. 重力对飞船施加力。
- en: '![](09fig09.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![09fig09.jpg]'
- en: Listing 9.6\. Planet updates
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 行星更新
- en: '![](9list06.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![9list06.jpg]'
- en: First you need to find out how much gravitational force the planet will put
    on the ship. We’ll gloss over this part for now; all you need to know is that,
    in a minute, you’ll create a method that will tell you the magnitude and direction
    of the force ![](one.jpg). Other than this, it’s the same as when you updated
    the ship when its engines were firing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要找出行星将对飞船施加多少重力。我们现在暂时跳过这部分；你需要知道的是，在一分钟内，你将创建一个方法来告诉你力的强度和方向 ![one.jpg]。除此之外，这与你在引擎启动时更新飞船的情况相同。
- en: Don’t forget to include the *update* method ![](two.jpg) in the main *update*
    function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在主 *update* 函数中包含 *update* 方法 ![two.jpg]。
- en: 'Now you have a nice, well-defined problem to solve: find the distance and angle
    to the ship. This is the opposite problem to the one you solved earlier. Back
    then, you had an angle and distance and wanted the x and y parts; now you have
    the x and y parts and want to know the angle and distance.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个很好的、定义明确的问题要解决：找到飞船的距离和角度。这是与之前你解决的问题相反的问题。当时，你有一个角度和距离，想要 x 和 y 部分；现在你有
    x 和 y 部分，想要知道角度和距离。
- en: '![](f0303-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![f0303-01.jpg]'
- en: Listing 9.7\. Figuring out gravity
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.7\. 计算重力
- en: '![](09list07_alt.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![09list07_alt.jpg]'
- en: First, set your planet’s mass ![](one.jpg). The heavier your planet is, the
    more it will pull on your ship. This is one of the elements of your game you can
    tweak to make it easier or harder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置你的行星质量 ![一](one.jpg)。你的行星越重，它对船只的拉力就越大。这是你可以在游戏中调整以使其更容易或更难的一个元素。
- en: '![](f0304-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![f0304-01.jpg](f0304-01.jpg)'
- en: The core of your method is to find out how far away the ship is, and in which
    direction ![](two.jpg). Based on that, you can calculate everything else you need.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你的方法的核心是找出船只距离有多远，以及它在哪个方向 ![二](two.jpg)。基于这些信息，你可以计算出你需要的一切。
- en: Next, you find out the distance to the target (the ship) in the x and y directions
    ![](three.jpg). The distances might end up being negative if the ship is to the
    left or below—that’s normal.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你找出目标（船只）在x和y方向上的距离 ![三](three.jpg)。如果船只位于左侧或下方，距离可能会变成负数——这是正常的。
- en: 'Now you can find the first part of what you need, which is the distance to
    the ship ![](four.jpg). This is determined using the Pythagorean theorem: square
    the two smaller sides, and take the square root.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经找到了你需要的第一部分，即船只的距离 ![四](four.jpg)。这是通过勾股定理确定的：平方两个较小的边，然后取平方根。
- en: 'The angle is a little trickier ![](five.jpg). With a horizontal and vertical
    distance, you can use *math.acos* or *math.asin* to find the angle, but you need
    to take the complete 360-degree range into account. *math.acos* is only valid
    for the first half of the circle, so you need to reflect the angle by subtracting
    it from *2*math.pi* if it’s in the wrong half. [Figure 9.10](#ch09fig10) shows
    this in a little more detail: the two angles are different, even though the x
    distance and the direct distance are the same.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 角度计算稍微复杂一些 ![五](five.jpg)。在水平和垂直距离的情况下，你可以使用 *math.acos* 或 *math.asin* 来计算角度，但需要考虑完整的360度范围。*math.acos*
    只对圆的第一半部分有效，所以如果角度在错误的一半，你需要通过从 *2*math.pi* 减去它来反射角度。[图9.10](#ch09fig10) 更详细地展示了这一点：两个角度不同，尽管x距离和直接距离相同。
- en: Figure 9.10\. Two different angles, same x position and distance
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.10\. 两个不同的角度，相同的x位置和距离
- en: '![](09fig10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![09fig10.jpg](09fig10.jpg)'
- en: Once you have the distance and angle, you can return those vectors ![](six.jpg).
    I’ve chosen (distance, angle) as the way a vector is represented, to avoid accidental
    confusion later.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了距离和角度，你就可以返回这些向量 ![六](six.jpg)。我选择（距离，角度）作为向量的表示方式，以避免以后发生意外的混淆。
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If all this math seems a little complicated, don’t worry too much. You have
    easy-to-use methods for calculating vectors and forces that you can reuse in your
    next game.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些数学看起来有点复杂，不要过于担心。你有一些易于使用的计算向量和力的方法，你可以在你的下一个游戏中重复使用。
- en: '|  |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that you know the distance and direction to the ship, calculating the force
    due to gravity is easy ![](seven.jpg). It’s proportional to the mass of the planet
    and diminishes with the square of the distance. The closer the ship, the more
    force you apply to it. [Figure 9.11](#ch09fig11) shows a time lapse of the ship
    moving.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了船只的距离和方向，计算由于重力产生的力就很容易 ![七](seven.jpg)。它与行星的质量成正比，与距离的平方成反比。船只越近，你施加的力就越大。[图9.11](#ch09fig11)
    展示了船只移动的时间流逝。
- en: Figure 9.11\. Your ship in orbit around the planet
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.11\. 你的船在行星轨道上
- en: '![](09fig11.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![09fig11.jpg](09fig11.jpg)'
- en: '![](f0305-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![f0305-01.jpg](f0305-01.jpg)'
- en: When you run the program, you should see the ship being affected by gravity!
    Rather than moving in a straight line, it will have a force applied to it by the
    planet and will move in a graceful curve. If you’re careful, you can even put
    your ship into an orbit around the planet.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你应该看到船只受到重力的影响！它不会直线移动，而是会受到行星施加的力，并沿着优雅的曲线移动。如果你小心操作，甚至可以将你的船只送入行星轨道。
- en: Watch out for that planet!
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意那颗行星！
- en: For collision detection, we’re sticking with circles around the ship, planet,
    and alien. Circles like those in [figure 9.12](#ch09fig12) make the code simpler
    and more straightforward; but in trading accuracy for simplicity, you might notice
    a few collisions that should have been near misses. It’s possible to get pixel-perfect
    accuracy with Pyglet by comparing the overlap of the images themselves, but that’s
    outside the scope of this chapter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于碰撞检测，我们继续使用船只、行星和外星人的圆形。像[图9.12](#ch09fig12)中的圆形使代码更简单、更直接；但在以简单换取准确性的过程中，你可能会注意到一些本应只是擦肩而过的碰撞。使用Pyglet通过比较图像本身的重叠，可以得到像素级的精确度，但这超出了本章的范围。
- en: Figure 9.12\. The planet’s and ship’s collision circles
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.12\. 行星和船只的碰撞圆
- en: '![](09fig12.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![09fig12.jpg](09fig12.jpg)'
- en: In practice, though, you don’t need to draw circles—you can compare the distance
    between the ship and the planet, and then compare that to the radius of the planet
    and the ship.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不需要绘制圆形——你可以比较飞船和行星之间的距离，然后将其与行星和飞船的半径进行比较。
- en: Listing 9.8\. Crashing into the planet
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.8\. 碰撞到行星
- en: '![](ch09list8-0.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![ch09list8-0.jpg](https://example.org/ch09list8-0.jpg)'
- en: '![](ch09list8-1.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![ch09list8-1.jpg](https://example.org/ch09list8-1.jpg)'
- en: You’ll need a few attributes on your objects ![](one.jpg). One is to tell the
    game whether the ship is alive or not, and the others are the radius of the planet
    and the ship. To make life easier, you’ll calculate the radius of the ship and
    the planet from the size of their images. If you change the image later, you won’t
    need to update the object’s radius.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的对象上设置一些属性 ![one.jpg](https://example.org/one.jpg)。一个是告诉游戏飞船是否存活，其他的是行星和飞船的半径。为了简化生活，你会从它们图像的大小计算飞船和行星的半径。如果你稍后更改图像，你不需要更新对象的半径。
- en: '![](f0307-01.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![f0307-01.jpg](https://example.org/f0307-01.jpg)'
- en: With circles to detect collisions, all you need to do is compare the distance
    between the ship and the planet, and the sum of their radiuses ![](two.jpg). If
    the distance is shorter, then the circles intersect, and you have a collision.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用圆形来检测碰撞，你所需要做的就是比较飞船和行星之间的距离，以及它们半径的总和 ![two.jpg](https://example.org/two.jpg)。如果距离更短，那么圆形相交，你就发生了碰撞。
- en: Once your spaceship has crashed ![](three.jpg), you mark the ship as dead and
    reset the player’s position.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的宇宙飞船坠毁 ![three.jpg](https://example.org/three.jpg)，你将飞船标记为已损毁并重置玩家的位置。
- en: The ship’s .*reset()* method puts the ship back at the start ![](four.jpg) and
    sets its velocity to something reasonable. You’re also setting a “life timer”
    that determines the time until the ship restarts, giving the player a few seconds
    to think about what went wrong. You can use this to set the ship’s position at
    the start so you don’t need to feed in a position when you create your class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 船的 .*reset()* 方法将飞船放回起点 ![four.jpg](https://example.org/four.jpg) 并将其速度设置为合理的值。你还在设置一个“生命计时器”，它决定了飞船重新启动的时间，给玩家几秒钟的时间来思考发生了什么。你可以使用这个计时器来设置飞船的起始位置，这样你就不需要在创建类时输入位置。
- en: To delay the ship’s return, you check the *life_timer* attribute you set in
    the .*reset()* method ![](five.jpg). If you’re dead and the timer is greater than
    zero, then you still have some time left. If it’s less than 0, then you can mark
    the ship as alive and reset its position once more (because gravity still affects
    it), and you’re back to normal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了延迟飞船的返回，你检查在 .*reset()* 方法中设置的 *life_timer* 属性 ![five.jpg](https://example.org/five.jpg)。如果你已死且计时器大于零，那么你还有一些时间。如果它小于
    0，那么你可以将飞船标记为存活，并再次重置其位置（因为重力仍然影响它），然后你就可以恢复正常。
- en: The last thing you need to do is make sure the ship isn’t drawn when it’s dead
    ![](six.jpg). A simple *if* statement takes care of that.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是确保飞船在已损毁时不会被绘制 ![six.jpg](https://example.org/six.jpg)。一个简单的 *if*
    语句就可以解决这个问题。
- en: Now that your game is starting to take shape, you can see the general form a
    game takes. It has a certain state, effectively a simulation of a number of things
    like planets and ships, and you can have an effect on that simulation in certain
    ways. With some thought, a bit of luck, and some experimentation, your simulation
    will have aspects that are fun.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在随着你的游戏开始成形，你可以看到游戏的一般形式。它有一定的状态，实际上是对行星和飞船等许多事物的模拟，你可以以某种方式影响这个模拟。经过一些思考、一点运气和一些实验，你的模拟将具有一些有趣的方面。
- en: Next up, let’s add some excitement to your game.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们给你的游戏增加一些刺激。
- en: Guns, guns, guns!
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枪，枪，枪！
- en: 'What’s a space game without aliens to shoot? Even space trading games have
    guns of some sort, so if you don’t have any, you’ll look a bit odd. They’re easy
    to add, given the work you’ve already done on angles and timers: set the bullet
    travelling at high speed at the same angle as the ship, and update it in a similar
    way. You’ll also want to keep track of whether the bullet has run into anything,
    and after a certain amount of time, remove it from the game.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 没有外星人射击的空间游戏是什么？即使是太空贸易游戏也有某种枪械，所以如果你没有，你会显得有些奇怪。考虑到你已经对角度和计时器做了很多工作，添加枪械很容易：让子弹以与飞船相同的速度和角度飞行，并以类似的方式更新它。你还需要跟踪子弹是否撞到任何东西，并在一定时间后将其从游戏中移除。
- en: Listing 9.9\. Shooting
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.9\. 射击
- en: '![](ch09list9-0.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![ch09list9-0.jpg](https://example.org/ch09list9-0.jpg)'
- en: '![](ch09list9-1.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![ch09list9-1.jpg](https://example.org/ch09list9-1.jpg)'
- en: An easier way to manage key presses is to use Pyglet’s *KeyStateHandler* class
    ![](one.jpg). This class keeps track of which keys have been pressed and makes
    them available with a dictionary syntax, so you don’t need extra event handlers
    and state on your *Ship* class. If you push the left arrow key, then *self[key.LEFT]*
    will be set to *True*. The only tricky part to remember is that the ship instance
    is now a key handler, so you need to do a *window* *.push_handlers(ship)* so Pyglet
    knows to pass it events.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pyglet的 *KeyStateHandler* 类来管理按键更简单 ![one.jpg]。这个类跟踪哪些键被按下，并以字典语法使它们可用，所以你不需要在
    *Ship* 类上额外的事件处理程序和状态。如果你按下左箭头键，那么 *self[key.LEFT]* 将被设置为 *True*。唯一需要记住的棘手部分是，飞船实例现在是一个键处理程序，所以你需要做
    *window* *.push_handlers(ship)* 以让Pyglet知道要传递事件给它。
- en: '![](f0310-01.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0310-01.jpg)'
- en: 'If you only let the player fire when the spacebar is pressed, they’ll get a
    bullet per frame, or 60 shots per second! Even if your computer is fast enough
    to handle hundreds of bullets onscreen, it makes the game a bit easy: it means
    you can fill the screen with bullets until there’s nowhere for the alien to hide.
    You’ll limit the number of shots by setting a timer whenever the ship fires a
    bullet ![](two.jpg). Every update, you’ll subtract *dt* from the timer, until
    it’s 0 and the player is ready to fire again.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只允许玩家在按下空格键时射击，他们每帧就会得到一颗子弹，或者每秒60发子弹！即使你的电脑足够快可以处理屏幕上的数百颗子弹，这也让游戏变得有点简单：这意味着你可以用子弹填满屏幕，直到外星无处可藏。你可以通过在飞船发射子弹时设置计时器来限制射击次数
    ![two.jpg]。每次更新，你都会从计时器中减去 *dt*，直到它为0，玩家可以再次射击。
- en: Firing is straightforward—you create an instance of the *Bullet* class going
    in the right direction ![](four.jpg). You give the bullets a speed of 500, with
    the ship’s velocity added in (otherwise you get weird effects when you’re travelling
    fast or shooting while travelling sideways). You store the bullet instance in
    *ship.bullets*, because if you don’t have a reference to them somewhere, Python’s
    garbage collector will remove them, and you’ll wonder why your bullets aren’t
    appearing on the screen.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 射击很简单——你创建一个朝正确方向飞行的 *Bullet* 类实例 ![four.jpg]。你给子弹设置速度为500，加上飞船的速度（否则当你快速移动或侧向射击时会出现奇怪的效果）。你将子弹实例存储在
    *ship.bullets* 中，因为如果你没有在某个地方保留对它们的引用，Python的垃圾回收器会删除它们，你就会 wonder为什么你的子弹没有出现在屏幕上。
- en: '![](five.jpg) is the class you use whenever you fire a bullet. Bullet updates
    are easy, because they’re not affected by gravity and move in a straight line.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![five.jpg] 是你每次射击时使用的类。子弹更新很简单，因为它们不受重力影响，沿直线移动。'
- en: Figure 9.13\. Your ship firing—ready to take on the alien armada
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.13。你的飞船在射击——准备迎接外星舰队
- en: '![](09fig13.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](09fig13.jpg)'
- en: '![](f0311-01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0311-01.jpg)'
- en: You don’t want bullets hanging around forever, so they have their own timer.
    Once they’ve been around for 5 seconds, you delete them from *ship.bullets* and
    let Python handle the rest ![](three.jpg). You also check for collisions with
    the planet, the same way you did for the ship.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望子弹永远悬挂在那里，所以它们有自己的计时器。一旦它们存在了5秒钟，你就从 *ship.bullets* 中删除它们，让Python处理剩下的部分
    ![three.jpg]。你也会检查与行星的碰撞，就像你为飞船做的那样。
- en: Because there are potentially so many bullets, it makes sense to use Pyglet’s
    *Batch* class, which makes sprite rendering much faster if you have lots of sprites
    to draw. To use the *bullets* batch, you pass it in when creating the bullet sprite
    and then call *bullets.draw()* to draw all the bullets at once ![](six.jpg). You
    should see something like the next figure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因为可能有这么多子弹，所以使用Pyglet的 *Batch* 类是有意义的，如果你有很多精灵要绘制，它会大大加快精灵渲染的速度。要使用 *bullets*
    批次，你需要在创建子弹精灵时传递它，然后调用 *bullets.draw()* 来一次性绘制所有子弹 ![six.jpg]。你应该会看到类似下一张图的样子。
- en: Now you can fly around the galaxy, doing good deeds and destroying alien scum.
    Hang on—you don’t have any alien scum to shoot yet. Let’s fix that next.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以飞遍银河系，做好事并摧毁外星渣滓。Hang on——你还没有可以射击的外星渣滓。让我们在下一部分修复这个问题。
- en: Evil aliens
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶劣的外星人
- en: What good are bullets without aliens to try them out on? In this section, you’ll
    add an alien spaceship whose sole purpose in life is to destroy the evil Earthling
    intruder. To make life easier, you’ll assume the alien has advanced technology
    that isn’t influenced by gravity, and that they can enter and leave the planet’s
    atmosphere at will. You’re going to be a little lazy and not worry about all those
    vectors and collisions with the planet—only whether the alien has hit the player.
    The next listing gives you all the code you need to put an alien in your game.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 没有外星人来尝试，子弹有什么用？在本节中，你将添加一个外星飞船，它的唯一目的是摧毁邪恶的地球入侵者。为了简化问题，你假设外星人拥有不受重力影响的高级技术，并且他们可以随意进入和离开地球的大气层。你将稍微偷懒，不会担心所有那些向量和与地球的碰撞——只需关注外星人是否击中玩家。下一个列表提供了你将外星人放入游戏所需的所有代码。
- en: Listing 9.10\. A random alien
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.10\. 一个随机的外星人
- en: '![](ch09list10-0.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09list10-0.jpg)'
- en: '![](ch09list10-1.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09list10-1.jpg)'
- en: One thing I’ve done in this section of code is pull the vector functions out
    of the class and made them more standalone ![](three.jpg). I’ve left them as is
    here, but, ultimately, you’ll probably want to put them into their own module
    or find a vector library you can reuse.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码段中，我做了这样一件事：将向量函数从类中提取出来，使它们更加独立 ![图片](three.jpg)。我这里保留了它们，但最终，你可能希望将它们放入自己的模块或找到一个可以重用的向量库。
- en: '![](f0314-01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0314-01.jpg)'
- en: The *Alien* class ends up being similar to the *Ship* class, except for its
    *update* method ![](two.jpg), so there shouldn’t be any major surprises in this
    part. You have all the same concepts—speed, acceleration, wrapping the x and y
    position, death, and respawning after a countdown.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，*外星人*类与*飞船*类相似，除了它的*update*方法 ![图片](two.jpg)，所以在这个部分不应该有任何大的惊喜。你拥有所有相同的概念——速度、加速度、x和y位置的环绕、死亡以及倒计时后的重生。
- en: Your alien has a simple AI—every so often, it accelerates in a random direction
    ![](one.jpg). The frequency of the acceleration and the parameters set in *__init__*
    give the alien enough changes in direction that shooting it can be a bit of a
    challenge.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你的外星人有一个简单的AI——时不时地，它会向一个随机方向加速 ![图片](one.jpg)。加速的频率和在*__init__*中设置的参数使得外星人的方向变化足够多，以至于射击它可以构成一定的挑战。
- en: Finally, I noticed while play-testing that it’s possible for the alien to accelerate
    to ridiculous speeds ![](four.jpg), which makes it hard to shoot. To stop it from
    doing that, you check that the x and y speeds are within the alien’s maximum speeds
    and reduce them if they aren’t.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我在测试游戏时注意到，外星人可以加速到荒谬的速度 ![图片](four.jpg)，这使得射击变得困难。为了阻止它这样做，你需要检查x和y速度是否在外星人的最大速度范围内，如果不是，则降低它们。
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The alien is one thing in this game that you definitely want to experiment with.
    The rough rule of thumb is that an alien should be easy enough for the player
    to shoot some of the time, but hard enough to be a challenge. Without the right
    balance, your game won’t be fun.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，外星人是你绝对想要尝试的一个元素。粗略的规则是，外星人应该足够容易被玩家射击，但同时也足够困难，以构成挑战。如果没有达到适当的平衡，你的游戏将不会有趣。
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The last thing you need to do is make the alien interact with the other objects
    you have onscreen: it should be killed by bullets and should kill the player when
    it runs into the ship. You’d also like some sort of reward system for the player,
    so you’ll add a score. Every time the player does something wrong, like crash
    into the planet or the alien, you’ll subtract 100 points. If the player shoots
    the alien, then you’ll add 100 points.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的最后一件事是让外星人与其他屏幕上的对象交互：它应该被子弹杀死，当它撞到飞船时应该杀死玩家。你也许还想为玩家添加某种奖励系统，所以你会添加分数。每当玩家做错事，比如撞到星球或外星人，你会减去100分。如果玩家射击外星人，那么你会加上100分。
- en: Listing 9.11\. Making the alien interact
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.11\. 使外星人交互
- en: '![](ch09list11-0.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09list11-0.jpg)'
- en: '![](ch09list11-1.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch09list11-1.jpg)'
- en: You’d like the alien to be an extra hazard for the player to avoid, so you check
    the distance between the ship and the alien ![](one.jpg)—the same way you do for
    the ship and the planet. It’s up to you whether you want the alien to disappear
    when it collides with the player.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望外星人成为玩家需要避免的额外危险，所以你检查飞船和外星人之间的距离 ![图片](one.jpg)——就像你检查飞船和地球一样。是否希望外星人撞到玩家时消失，取决于你。
- en: A score ![](two.jpg) is how you let players know that they’ve done something
    right according to the rules of the game, so you give them 100 points for shooting
    the alien and subtract 100 points if they run into the alien or the planet.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 分数 ![](two.jpg) 是你让玩家知道他们根据游戏规则做了正确的事情的方式，所以你给他们射击外星人100分，如果他们撞到外星人或行星则减去100分。
- en: The bullets should have an effect on the alien ![](four.jpg). So, for each bullet,
    you check the range to the alien. If it’s within the alien’s radius, then you’ve
    shot the alien! Resetting the alien works in pretty much the same way it does
    for the player—only you draw the alien if it’s alive and have a short delay between
    the alien dying and its reappearance.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹应该对外星人产生效果 ![](four.jpg)。所以，对于每一颗子弹，你检查它到外星人的距离。如果它在外星人的半径内，那么你就击中了外星人！重置外星人的方式基本上与玩家相同——只是你在外星人存活时绘制它，并在外星人死亡和再次出现之间有一个短暂的延迟。
- en: Players need to be able to see their score on the screen ![](three.jpg), so
    you add a *Label* class in the bottom of the screen, 10 pixels from the lower-left
    corner. Setting the color looks a little odd, because you might be expecting three
    numbers for red, green, and blue. The fourth is the alpha value—255 is opaque
    and 0 is completely transparent—which is useful for fading text in and out.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家需要在屏幕上看到他们的分数 ![](three.jpg)，所以你在屏幕底部10像素处添加一个*标签*类。设置颜色看起来有点奇怪，因为你可能期望红色、绿色和蓝色三个数字。第四个是alpha值——255是不透明的，0是完全透明的——这对于淡入淡出文本很有用。
- en: You should see something like the next figure, complete with alien scum!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到下一个图示，包括外星渣滓！
- en: Now you have a full-blown space-alien-shooting-get-as-many-points-as-you-can-but-don’t-run-into-the-planet
    game (I’m sure you can think of a catchier title). You can send the game to your
    friends and even compete with each other.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个完整的太空外星人射击游戏，目标是尽可能多地得分，但不要撞到行星（我确信你能想到一个更吸引人的标题）。你可以把游戏发送给你的朋友，甚至可以互相竞争。
- en: '![](f0317-01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](f0317-01.jpg)'
- en: Figure 9.14\. Die, alien scum!
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.14\. 外星渣滓，去死吧！
- en: '![](09fig14.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](09fig14.jpg)'
- en: Where to from here?
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来该做什么？
- en: You can make a number of improvements or changes to the game, either to refine
    what’s already there, expand on the game play, or turn the game into something
    completely different. Here are some ideas.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对游戏进行许多改进或更改，无论是为了完善现有的内容，扩展游戏玩法，还是将游戏转变为完全不同的东西。这里有一些想法。
- en: Extending the game play
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展游戏玩法
- en: There are a number of other elements that would normally be in a game like this.
    A good idea might be to pick your favorite space-shooting game and see how many
    of its features you can add. You might want to make the alien shoot back, tweak
    its AI to make it nastier, or add more aliens. Adding extra, harder levels with
    each wave of aliens and limited lives for the player would be another feature.
    Sound effects are also good for setting an atmosphere.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这类游戏中通常会有许多其他元素。一个好主意可能是选择你最喜欢的太空射击游戏，看看你能添加多少它的功能。你可能想让外星人也能射击回来，调整它的AI让它变得更恶劣，或者添加更多外星人。随着外星波的每次到来添加额外的难度级别，以及限制玩家的生命值，这将是一个额外的功能。音效也有助于营造氛围。
- en: Altering the game play
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 改变游戏玩法
- en: Another option is to extend the game in a completely different direction—after
    all, perhaps you’re not a big fan of space-alien destruction. If you add a second
    player, and make your shots affected by gravity, you’ll have something pretty
    close to Spacewar!, the original space shooting game, written for the PDP-1 back
    in 1962.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是将游戏扩展到完全不同的方向——毕竟，也许你不是太空外星人破坏的大粉丝。如果你添加第二个玩家，并使你的射击受到重力的影响，你将拥有非常接近1962年为PDP-1编写的原始太空射击游戏Spacewar!。
- en: If shooting at stuff isn’t really your thing, you could add extra planets and
    turn the game into a space-trading game or a 3D version of Lunar Lander. Limited
    fuel and lighter or heavier gravity on different planets would add to the challenge
    of the game, in addition to trading well.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果射击并不是你的强项，你可以添加额外的行星，将游戏转变为太空贸易游戏或3D版本的月球着陆器。有限的燃料和不同行星上的轻重不同的重力将增加游戏的挑战性，除了交易之外。
- en: Pyglet comes with several examples you can use to add text input and other features.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Pyglet附带了一些示例，你可以使用这些示例来添加文本输入和其他功能。
- en: Refactoring
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重构
- en: Now that you understand the program, there are some areas where the code could
    be improved. For example, there’s quite a bit of duplication in terms of the objects
    and how their positions are updated—making them derive from a subclass could make
    your code clearer and easier to extend.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了这个程序，有一些地方代码可以进行改进。例如，在对象及其位置更新方面存在相当多的重复——使它们从子类派生可以使你的代码更清晰且更容易扩展。
- en: You could also use an external vector class within your objects, so you don’t
    have to look at (or debug) all that geometry code. It helps to know what’s behind
    the vector library before you start.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在你的对象内部使用外部矢量类，这样你就不必查看（或调试）所有那些几何代码。在开始之前了解矢量库背后的内容会有所帮助。
- en: Unit tests would be a big help in ensuring that your program is functioning
    properly when you make these changes. It’s difficult to test visual and game play
    aspects, but you can still check that collisions are detected properly by manually
    placing ship, bullet, and alien objects and checking whether they overlap. Other
    game data, such as forces and velocities, can be tested in the same way.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试将有助于确保你在进行这些更改时程序能够正常工作。测试视觉和游戏玩法方面可能很困难，但你仍然可以通过手动放置飞船、子弹和外星人对象并检查它们是否重叠来检查碰撞是否被正确检测。其他游戏数据，如力和速度，也可以以相同的方式进行测试。
- en: Get feedback
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取反馈
- en: Another thing to bear in mind is that you’re writing a game. You can write the
    most beautiful code, with all sorts of features, but all that will be for nothing
    if your game isn’t fun to play. One good way to design and develop games is to
    create a minimal version that includes the elements you think will be fun and
    test it out on a few people, tweaking the various parts as necessary.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要记住的是，你正在编写一个游戏。你可以编写出最漂亮的代码，包含各种特性，但如果你的游戏不好玩，所有这些都将毫无意义。设计和发展游戏的一个好方法就是创建一个包含你认为会有趣元素的最小版本，并在少数人身上测试它，根据需要调整各个部分。
- en: '![](f0318-01.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0318-01.jpg)'
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to write your own arcade game. You used Pyglet
    graphics classes to display images onscreen and move them around. To make your
    objects move realistically, you used some geometry and physics modeling to update
    their positions onscreen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写自己的街机游戏。你使用了Pyglet图形类在屏幕上显示图像并移动它们。为了使你的对象移动得更加逼真，你使用了一些几何和物理建模来更新它们在屏幕上的位置。
- en: You added several types of objects and learned how to make them interact with
    each other—your ship could run into a planet and fire bullets; then, finally,
    you added an alien that could run into the ship and be shot by bullets.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加了几种类型的对象，并学习了如何使它们相互交互——你的飞船可以撞上行星并发射子弹；然后，最终，你添加了一个可以撞上飞船并被子弹射中的外星人。
- en: Along the way, you learned about other game elements, such as collision detection
    and scheduling actions to take place over time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，你学习了其他游戏元素，例如碰撞检测和安排在一段时间内执行的动作。
- en: 'Finally, we covered some aspects of game design: your game needs to be fun
    and include some familiar elements to attract people. It’s important to get feedback
    from others: what’s fun for you might not be fun for anybody else.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了一些游戏设计方面的内容：你的游戏需要有趣，并包含一些熟悉元素以吸引人们。获取他人的反馈很重要：对你来说有趣的东西可能对其他人来说并不有趣。
- en: In the next chapter, you’ll learn more about Django and how you can make the
    web applications you write available on the internet for other people to use.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习更多关于Django的知识，以及你如何可以让其他人使用的你编写的网络应用程序在互联网上可用。
