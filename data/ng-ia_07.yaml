- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building custom directives and pipes
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自定义指令和管道
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: How to create your own directives
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建你自己的指令
- en: The difference between structural and attribute directives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构性指令和属性指令之间的区别
- en: How to use a directive to modify another component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用指令来修改另一个组件
- en: How to craft custom pipes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何制作自定义管道
- en: What pipe purity is and how to design stateful or stateless pipes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道纯度是什么以及如何设计有状态或无状态的管道
- en: Angular ships with a number of directives and pipes for the broadest use cases.
    Chapter 3 covered the defaults, so you can review what they are and how they’re
    used. This includes directives such as NgFor and NgIf for iterating over a list
    or conditionally displaying items, and pipes such as Currency and Number for formatting
    values for currency or number display.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Angular附带了许多指令和管道，以覆盖最广泛的使用场景。第三章介绍了默认设置，因此你可以回顾它们是什么以及如何使用。这包括NgFor和NgIf等指令，用于遍历列表或条件显示项目，以及Currency和Number等管道，用于格式化货币或数字显示。
- en: This chapter focuses on creating custom directives and pipes and talks about
    why you might create them. The built-in pipes and directives may fill many of
    the use cases, but sometimes your application requirements will benefit from a
    custom implementation to make things easier to use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍创建自定义指令和管道，并讨论为什么你可能需要创建它们。内置的管道和指令可能满足许多用例，但有时你的应用程序需求将受益于自定义实现，使使用更加方便。
- en: There are two types of custom directives, which have their own use cases and
    capabilities. We’ll create one that modifies some attributes of an element, one
    that modifies the default behaviors of a component, and one that changes the way
    the elements are added to the page.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种自定义指令，它们各自有自己的用例和能力。我们将创建一个修改元素某些属性的指令，一个修改组件默认行为的指令，以及一个改变元素添加到页面方式的指令。
- en: Likewise, we’ll also be building some custom pipes to demonstrate what value
    they can provide you. Just like directives, there are two types of pipes that
    you can build depending on your needs. We’ll create three different pipes to demonstrate
    the scenarios in which they’re useful and discuss best practices and design for
    performance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还将构建一些自定义管道来展示它们能为你提供什么价值。就像指令一样，根据你的需求，你可以构建两种类型的管道。我们将创建三个不同的管道来展示它们有用的场景，并讨论最佳实践和性能设计。
- en: The bundled directives and pipes cover a lot of the primary use cases, but often
    developers will need to craft their own. I find the early stages of building an
    application can often be accomplished without any, but once I start to notice
    places of duplication or unnecessary complexity, I start to create my own. Sometimes
    I don’t always see the best way to design a custom pipe or directive until I’ve
    already built something else that needs to be improved.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的指令和管道覆盖了大部分主要用例，但通常开发者需要自己制作。我发现构建应用程序的早期阶段往往可以不使用任何指令完成，但一旦我开始注意到重复或不必要的复杂性，我就开始创建自己的。有时我并不总是看到设计自定义管道或指令的最佳方式，直到我已经构建了一些需要改进的其他东西。
- en: That’s why in this chapter I’m tackling the perspective of adding custom pipes
    and directives to the chapter 2 example application that you should already be
    familiar with. I believe it’s easier to see the role and value of them in the
    context of an existing application rather than just building isolated examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我将探讨将自定义管道和指令添加到第二章示例应用程序中的视角，你应该已经熟悉这个应用程序。我相信在现有应用程序的上下文中，更容易看到它们的作用和价值，而不是仅仅构建孤立的示例。
- en: 'To be completely honest, it’s entirely possible to never create your own directives
    or pipes by just adding more logic into components—so why even bother? The main
    reasons apply to both directives and pipes:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完全诚实地说，仅通过在组件中添加更多逻辑，就完全有可能永远不创建自己的指令或管道——那么为什么还要费这个劲呢？主要原因适用于指令和管道：
- en: '*Reuse and reduce* —Instead of each component having to implement similar logic,
    it can be abstracted out and easily reused. This also reduces code footprint and
    helps standardize logic.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重用和减少*——而不是每个组件都必须实现类似的逻辑，它可以被抽象出来并轻松重用。这也减少了代码足迹并有助于标准化逻辑。'
- en: '*Maintainability and focused components* —Components sometimes become a dumping
    ground for code and logic that are tangential to the component itself. Removing
    that from the component makes it easier to maintain your components.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可维护性和专注的组件*——组件有时会成为与组件本身无关的代码和逻辑的垃圾场。将这些移除可以使维护组件变得更加容易。'
- en: '*Testability* —Moving everything into smaller blocks means you can create smaller
    test cases and limit permutations.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可测试性* — 将所有内容分解成更小的模块意味着你可以创建更小的测试用例并限制排列组合。'
- en: There are certainly a few scenarios where custom directives or pipes are required
    or the best solution. For example, custom directives are useful when we want to
    create some custom form validation, as we’ll investigate in the next chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，确实有一些场景下需要使用自定义指令或管道，或者这是最佳解决方案。例如，当我们需要创建一些自定义表单验证时，自定义指令是有用的，正如我们将在下一章中探讨的那样。
- en: The number of situations in which you’ll need to create your own will vary from
    project to project, and I’ve found that the ones I’ve created once are often useful
    for other projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建自己的情况的数量会因项目而异，我发现我创建过的一次通常对其他项目也很有用。
- en: 8.1 Setting up the chapter example
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 设置章节示例
- en: In this chapter, we’ll take the stock application example from chapter 2 and
    add some custom pipes and directives to it. Doing it that way will help us minimize
    the number of new things to review during this chapter while giving us some useful
    examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从第2章的股票应用程序示例中添加一些自定义管道和指令。这样做将帮助我们在此章节中减少需要审查的新事物的数量，同时给我们一些有用的示例。
- en: If you skipped chapter 2 or don’t recall the specifics of that example, the
    application is a basic stock tracking application. It displays a list of stocks
    and their current statuses and allows you to add or remove items from that list.
    It loads real data from a service as well. We won’t make any drastic changes to
    the way the application behaves, but we will simplify a few things with the use
    of custom pipes and directives. You can see what it will look like in [figure
    8.1](#figure8.1).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你跳过了第2章或者不记得那个例子中的具体内容，该应用程序是一个基本的股票跟踪应用程序。它显示股票列表及其当前状态，并允许你添加或从该列表中删除项目。它还会从服务中加载真实数据。我们不会对应用程序的行为方式做出任何重大改变，但我们将通过使用自定义管道和指令来简化一些事情。你可以在[图8.1](#figure8.1)中看到它将是什么样子。
- en: '![c08-1.png](image_fi/293313c08/c08-1.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![c08-1.png](image_fi/293313c08/c08-1.png)'
- en: '[**Figure 8.1**](#figureanchor8.1) What we’ll build in this chapter extends
    the example from chapter 2.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.1**](#figureanchor8.1) — 本章我们将构建的内容扩展了第2章的示例。'
- en: 'Regardless of whether you have the chapter 2 sample already or not, we’ll be
    starting from a new repository. To download with Git, clone the repo and check
    out the starting point using the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否已经有了第2章的样本，我们都会从一个新的仓库开始。要使用Git下载，克隆仓库并使用以下命令检查起始点：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Otherwise, you can download the archived files from [https://github.com/angular-in-action/stocks-enhanced/archive/start.zip](https://github.com/angular-in-action/stocks-enhanced/archive/start.zip)
    and unzip the files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以从[https://github.com/angular-in-action/stocks-enhanced/archive/start.zip](https://github.com/angular-in-action/stocks-enhanced/archive/start.zip)下载归档文件并解压文件。
- en: As usual, you’ll need to run `npm` `install` to download all the dependencies.
    Then run `ng serve` to start the local development server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，你需要运行 `npm install` 来下载所有依赖项。然后运行 `ng serve` 来启动本地开发服务器。
- en: 8.2 Crafting custom directives
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 创建自定义指令
- en: 'There are two types of directives: *structural* and *attribute*. The way they’re
    declared and used is essentially identical, but they have one key difference that
    you’ve seen in use in previous chapters. When we want to change a property of
    an element (such as the background color or height), we’ll need to use an attribute
    directive. But if we want to have control over how the element itself is rendered
    into the page, we’ll rely on the structural directive.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 指令有两种类型：*结构*和*属性*。它们的声明和使用方式基本上是相同的，但它们有一个关键的区别，你已经在之前的章节中看到过。当我们想要更改元素的一个属性（如背景颜色或高度）时，我们需要使用属性指令。但如果我们想要控制元素本身在页面上的渲染方式，我们将依赖于结构指令。
- en: We’ve had use cases where we wanted an element to appear on the page only when
    certain conditions were true, specifically a loading indicator. This is a great
    example of how we use a directive to change how the element is rendered. Likewise,
    we’ve needed to dynamically change the background color of an element, and we
    did that by modifying the classes on the element with a directive.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些用例，我们希望元素仅在特定条件为真时出现在页面上，特别是加载指示器。这是一个很好的例子，说明了我们如何使用指令来改变元素的渲染方式。同样，我们也需要动态地改变一个元素的背景颜色，我们通过使用指令修改元素上的类来实现这一点。
- en: 'More specifically, recall that you must prefix `ngIf` with `*`—for example,
    `*ngIf="loaded = true".` This means that NgIf is a structural directive and is
    able to control whether the DOM element is rendered or not. On the other hand,
    the `ngClass` directive is an attribute directive and doesn’t have the `*` when
    it’s used, such as `[ngClass]="{active: true}"`. NgClass simply modifies the properties
    of the element—in this case, the CSS class is applied—but doesn’t render DOM.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '更具体地说，回想一下，你必须用`*`前缀来修饰`ngIf`——例如，`*ngIf="loaded = true"`. 这意味着NgIf是一个结构指令，能够控制DOM元素是否渲染。另一方面，`ngClass`指令是一个属性指令，当使用时没有`*`，例如`[ngClass]="{active:
    true}"`。NgClass仅修改元素的属性——在这种情况下，应用了CSS类，但不会渲染DOM。'
- en: 'The difference is in the structural directive’s ability to add or remove DOM
    elements from the page. It’s similar to the idea of construction: You can remodel
    an existing building (attribute directive) or handle the creation of the building
    itself (structural directive). A structural directive can render DOM, but an attribute
    directive can only modify properties. The structural NgIf directive can determine
    if the DOM element is rendered based on the conditional value provided. The NgClass
    attribute directive doesn’t create elements, but rather changes the element’s
    class list.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于结构指令添加或删除DOM元素的能力。这类似于构建的概念：你可以重新设计现有的建筑（属性指令）或处理建筑本身的创建（结构指令）。结构指令可以渲染DOM，而属性指令只能修改属性。结构NgIf指令可以根据提供的条件值确定DOM元素是否渲染。NgClass属性指令不会创建元素，而是更改元素的类列表。
- en: In [figure 8.2](#figure8.2), you can see how attribute directives modify a component
    and how a structural directive creates (or destroys) components. In this chapter’s
    example, the NgFor structural directive creates multiple instances of the Summary
    component, whereas the NgClass attribute modifies the background color of those
    same instances.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图8.2](#figure8.2)中，你可以看到属性指令如何修改组件，以及结构指令如何创建（或销毁）组件。在本章的示例中，NgFor结构指令创建了Summary组件的多个实例，而NgClass属性则修改了这些相同实例的背景颜色。
- en: '![c08-2.png](image_fi/293313c08/c08-2.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![c08-2.png](image_fi/293313c08/c08-2.png)'
- en: '[**Figure 8.2**](#figureanchor8.2) How a structural or attribute directive
    modifies the DOM'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.2**](#figureanchor8.2)  结构或属性指令如何修改DOM'
- en: Therefore, the primary difference between structural and attribute directives
    is that a structural directive is designed to modify the DOM tree of an element,
    whereas an attribute directive is designed to only modify the properties or DOM
    of a single element. We’ll build an example of both types in this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结构指令和属性指令之间的主要区别在于，结构指令旨在修改元素的DOM树，而属性指令旨在仅修改单个元素的属性或DOM。在本章中，我们将构建这两种类型的示例。
- en: Remember, neither structural nor attribute directives have a template. Technically,
    *components* are a third type of directive, and the only type that has a template.
    If you ever need a template for your implementation, you should use a component.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，结构和属性指令都没有模板。技术上，*组件*是第三种类型的指令，并且是唯一具有模板的类型。如果你需要为你的实现使用模板，你应该使用组件。
- en: Directives can inject services just like a component, which gives you access
    to some interesting capabilities. If you have custom services, your directives
    could leverage them for use cases such as knowing whether the user is logged in
    and conditionally showing or hiding content.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可以像组件一样注入服务，这让你能够访问一些有趣的功能。如果你有自定义服务，你的指令可以利用它们来处理诸如判断用户是否登录以及有条件地显示或隐藏内容等用例。
- en: We’ll start by building an attribute directive, a second attribute directive
    to modify a component, and then a structural directive. Let’s get to it!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建一个属性指令，然后是一个用于修改组件的第二个属性指令，最后是一个结构指令。让我们开始吧！
- en: 8.2.1 Creating an attribute directive
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 创建属性指令
- en: Our first directive is going to help us manage the color of the Summary component,
    which is the card that displays the current stock information. The result won’t
    change the visual experience for the user but will abstract the capability so
    it can be reused. Right now, the Summary controller contains logic that’s used
    by the NgClass directive to change the background color to green or red based
    on the day’s change in value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个指令将帮助我们管理 Summary 组件的颜色，这是显示当前股票信息的卡片。结果不会改变用户的视觉体验，但会抽象出这种能力以便它可以被重用。目前，Summary
    控制器包含由 NgClass 指令使用的逻辑，根据当天的价值变化将背景颜色更改为绿色或红色。
- en: Although this isn’t necessarily a problem, we can abstract this into its own
    attribute directive in case we ever want to use it again. That’s a great use for
    attribute directives, because it’s simply managing the list of classes applied
    to an element, as shown in [figure 8.3](#figure8.3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不一定是一个问题，但我们可以将其抽象成它自己的属性指令，以防我们以后想再次使用它。这是属性指令的一个很好的用途，因为它只是管理应用于元素的类列表，如图
    8.3 所示。
- en: '![c08-3.png](image_fi/293313c08/c08-3.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![c08-3.png](image_fi/293313c08/c08-3.png)'
- en: '[**Figure 8.3**](#figureanchor8.3) A directive can modify the background property
    of an element, so the component doesn’t have to manage the logic.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 8.3** 指令可以修改元素的背景属性，因此组件不需要管理逻辑。'
- en: 'The Angular CLI allows us to generate the directive scaffolding quickly, so
    we’ll use the following command to generate the files we need—the files will be
    placed inside of the src/app/directives directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 允许我们快速生成指令框架，所以我们将使用以下命令来生成我们需要的文件——文件将被放置在 src/app/directives 目录中：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As with a component, it will also add the directive to the App module for you,
    saving a little bit of effort. We’ll implement this directive to also take an
    input that contains the stock data used by the component so we can detect the
    correct class to attach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与组件一样，它也会为你添加指令到 App 模块中，节省一点工作量。我们将实现这个指令，使其也接受一个包含组件使用的股票数据的输入，这样我们就可以检测到正确的类来附加。
- en: Let’s go ahead and create our directive. Open src/app/directives/card-type.directive.ts
    and replace its contents with what’s shown in the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建我们的指令。打开 src/app/directives/card-type.directive.ts 并将其内容替换为以下列表中所示的内容。
- en: '**Listing 8.1** Card type directive'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 8.1** 卡片类型指令'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing you should notice is how similar this looks to a component,
    because a component is really a special type of directive that has a template.
    Directives use the template of the element they are applied to instead of having
    their own template.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先应该注意到这与组件看起来多么相似，因为组件实际上是一种具有模板的特殊类型的指令。指令使用它们应用到的元素的模板，而不是拥有自己的模板。
- en: The directive starts by importing a few things that we’ll need, and then we
    have the `Directive` decorator. Here we only define the selector, `[cardType]`,
    which is the CSS form of making it work as an element attribute. This decorator
    is applied to the exported class `CardTypeDirective`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 指令首先导入我们需要的一些内容，然后我们有 `Directive` 装饰器。在这里，我们只定义了选择器 `[cardType]`，这是将其作为元素属性工作的
    CSS 形式。这个装饰器应用于导出的类 `CardTypeDirective`。
- en: Directives can take inputs, and we define some properties to accept input bindings.
    By defining one by the same name as the directive selector, we can then bind to
    the directive, like `<div [cardType]="stock"></div>`. The `cardType` property
    will accept a number, and, depending on whether the number is positive or negative,
    will apply the appropriate class. The other two inputs are to allow someone to
    change the class names applied, and they have defaults set in case we choose not
    to define them. This enables this directive to be flexible and more reusable than
    having everything hard-coded.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可以接受输入，我们定义了一些属性来接受输入绑定。通过定义一个与指令选择器同名的内容，我们就可以绑定到指令，例如 `<div [cardType]="stock"></div>`。`cardType`
    属性将接受一个数字，并且根据数字是正数还是负数，将应用适当的类。其他两个输入允许某人更改应用的类名，并且如果选择不定义它们，它们有默认值。这使得这个指令比所有内容都硬编码更灵活和可重用。
- en: The constructor is used to inject a property that contains a reference to the
    element that the directive is applied to. We then use that in the lifecycle hook
    to change the classes based on the `cardType` number being positive or negative.
    If the card is neither positive nor negative, it won’t apply any class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数用于注入一个包含对应用指令的元素的引用的属性。然后我们在生命周期钩子中使用它根据 `cardType` 数字是正数还是负数来更改类。如果卡片既不是正数也不是负数，则不会应用任何类。
- en: 'Now let’s put this directive to use and see how it works out. Open src/app/components/summary/summary.component.html
    and update the first line of the template to the following, which will remove
    the NgClass and add the fade-in animation that’s on the card:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个指令并看看它如何工作。打开 `src/app/components/summary/summary.component.html`
    并更新模板的第一行，如下所示，这将移除 NgClass 并添加卡片上的淡入动画：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also open the src/app/components/summary/summary.component.ts file and
    remove the `isNegative` and `isPositive` methods from the controller, as they’re
    no longer used. We didn’t end up using the `increaseClass` or `decreaseClass`
    input bindings, but you can try them out.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以打开 `src/app/components/summary/summary.component.ts` 文件，并将控制器中的 `isNegative`
    和 `isPositive` 方法移除，因为它们不再被使用。我们没有最终使用 `increaseClass` 或 `decreaseClass` 输入绑定，但你也可以尝试一下。
- en: When you run the code at this point, you should in fact see no change, except
    the animation of the cards while they fade in on load. We were able to refactor
    the logic into a separate directive and make it more flexible for reuse without
    breaking the current implementation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在这个时候运行代码时，你应该实际上看不到任何变化，除了卡片在加载时淡入的动画。我们能够将逻辑重构为一个单独的指令，使其更灵活且易于复用，同时不会破坏当前实现。
- en: A primary role of directives is to facilitate reuse. The `cardType` attribute
    directive allows this by decoupling the specific implementation of using NgClass
    into a more abstract directive that accepts a number to add the same classes.
    You might not initially build your application with these types of smaller directives,
    but keep an eye out for opportunities for reuse like this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的主要作用是促进复用。`cardType` 属性指令通过将使用 NgClass 的具体实现解耦为一个更抽象的指令，该指令接受一个数字以添加相同的类来实现这一点。你可能最初不会用这些类型的小指令来构建你的应用程序，但要注意这种复用机会。
- en: Another key aspect of this example is how it simplified the Summary component
    by removing logic that wasn’t essential to the component itself. Though there
    was nothing inherently bad about how it was before, it did require the Summary
    component to contain methods to manage how it adds classes. Again, look for opportunities
    to keep your components focused and simplify their roles by moving unnecessary
    capabilities outside.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的另一个关键方面是如何通过移除对组件本身不必要逻辑来简化 Summary 组件。尽管之前的方式本质上并没有什么不好，但它确实要求 Summary 组件包含管理添加类的方法。再次强调，寻找机会保持组件的专注性，并通过将不必要的功能移至外部来简化它们的角色。
- en: 8.2.2 Modifying a component with a directive with events
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 使用事件修改带有指令的组件
- en: The `cardType` directive was used to modify a `div` element, but we can also
    apply custom directives to components to modify them. Many times you’ll use an
    external library of components and wish it did something slightly differently.
    To some extent, you can modify those components without having to reimplement
    them yourself. This doesn’t require a different type of directive—it’s still an
    attribute directive—but it does show how you can modify components that you didn’t
    write yourself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`cardType` 指令被用来修改一个 `div` 元素，但我们也可以将自定义指令应用到组件上以修改它们。很多时候，你会使用外部组件库，并希望它们能以稍微不同的方式工作。在一定程度上，你可以修改这些组件而无需自己重新实现它们。这不需要不同类型的指令——它仍然是一个属性指令——但它确实展示了你可以如何修改自己没有编写的组件。'
- en: Let’s imagine that the Summary Card itself is a third-party component that we
    didn’t write ourselves. We don’t like the way it behaves out of the box, and we
    can craft a directive to let us change its default behavior or add new abilities.
    Fundamentally, this is no different from putting a directive on a normal HTML
    element, but people don’t often consider this approach instead of hacking the
    third-party library. In our particular example, we want to add a hover effect
    and shadow to the cards on hover to give it a unique feel.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设 Summary 卡本身是一个第三方组件，我们并没有自己编写。我们不喜欢它默认的行为方式，我们可以创建一个指令来让我们改变其默认行为或添加新功能。从根本上讲，这与在普通
    HTML 元素上放置指令没有区别，但人们很少考虑这种方法而不是直接修改第三方库。在我们的特定例子中，我们想在悬停时给卡片添加悬停效果和阴影，以使其具有独特的感受。
- en: The examples in [figure 8.4](#figure8.4) are useful for showing how to modify
    a component without changing it directly. We’ll add event listeners to handle
    mouse events and override the background color.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8.4](#figure8.4) 中的示例对于展示如何在不直接修改组件的情况下修改组件非常有用。我们将添加事件监听器来处理鼠标事件并覆盖背景颜色。'
- en: '![c08-4.png](image_fi/293313c08/c08-4.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![c08-4.png](image_fi/293313c08/c08-4.png)'
- en: '[**Figure 8.4**](#figureanchor8.4) Directive that handles hover events and
    modifies a component indirectly'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 8.4**](#figureanchor8.4)  处理悬停事件并间接修改组件的指令'
- en: 'To get started we need to generate another directive. Run the following in
    the terminal to create the CardHover directive:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要生成另一个指令。在终端中运行以下命令以创建 CardHover 指令：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now open the src/app/directives/card-hover.directive.ts file and replace its
    contents with the code from the following listing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 src/app/directives/card-hover.directive.ts 文件，并用以下列表中的代码替换其内容。
- en: '**Listing 8.2** CardHover directive'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 8.2**  CardHover 指令'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This directive is structured similarly to the previous one, with importing dependencies
    and defining a selector attribute. The focus for this directive is the three methods
    for `ngOnInit`, `onMouseOver`, and `onMouseOut`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令的结构与之前的类似，包括导入依赖项和定义选择器属性。这个指令的重点是 `ngOnInit`、`onMouseOver` 和 `onMouseOut`
    这三个方法。
- en: In the `ngOnInit` method, we start by getting a reference to the card by querying
    the element. Then we inspect the classes to determine whether the stock price
    is positive or negative, and change the background color property of the element
    to override the default provided by the component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ngOnInit` 方法中，我们首先通过查询元素来获取卡片引用。然后我们检查类以确定股价是正数还是负数，并将元素的背景颜色属性更改为覆盖组件提供的默认值。
- en: Then inside of the `onMouseOver` and `onMouseOut` methods, we change styles
    to give the cards a box shadow and move them slightly up to make them appear to
    hover slightly above the page. The event listener is triggered by using the `@HostListener`
    decorator, which takes a single argument for the event to listen to. This is an
    event binding, but done through the context of a directive. There are many cases
    where you will need a directive to listen for events to handle your logic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `onMouseOver` 和 `onMouseOut` 方法中，我们更改样式以给卡片添加阴影并将它们稍微向上移动，使它们看起来稍微悬停在页面之上。事件监听器是通过使用
    `@HostListener` 装饰器触发的，它接受一个参数用于监听的事件。这是一个事件绑定，但通过指令的上下文完成。有许多情况下你需要一个指令来监听事件以处理你的逻辑。
- en: 'To use this, we just need to update the use of the Summary component in the
    src/app/components/dashboard/dashboard.component.html file, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个指令，我们只需更新 src/app/components/dashboard/dashboard.component.html 文件中 Summary
    组件的使用，如下所示：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just by adding the attribute, the new behaviors will attach to the Summary component,
    and the new background colors should appear along with the hover affects. This
    directive is designed specifically to modify an existing element, which I find
    to be a good solution to the problem of components not doing everything exactly
    as we need.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只需添加属性，新的行为就会附加到 Summary 组件上，新的背景颜色应该会随着悬停效果一起出现。这个指令专门设计用来修改现有元素，我认为这是解决组件不完全按我们需求执行问题的良好解决方案。
- en: This example shows one way to modify a component, but you could also implement
    an `Input` that would capture data to help you do additional processing if you
    need more data than just the element itself.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了修改组件的一种方法，但你也可以实现一个 `Input` 来捕获数据，以便在需要比仅元素本身更多的数据时进行额外的处理。
- en: These two attribute directive examples describe a number of concepts that interplay
    as you think about how to craft your own directives for maximum impact. Sometimes
    they will need to be generic for maximum reuse, but it’s often useful to create
    them for specific use cases as we’ve done here.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性指令示例描述了在考虑如何为最大影响定制自己的指令时相互作用的多个概念。有时它们需要尽可能通用以实现最大重用，但像我们在这里所做的那样，为特定用例创建它们通常很有用。
- en: You may be wondering why we used JavaScript to change element styles. We certainly
    could have written some CSS to handle some of this logic, since appropriate class
    names were applied to use in selectors. But I wanted to demonstrate the use of
    element manipulation using JavaScript because you can do so much more with it
    than CSS. Keep your use cases and needs in mind, and if you can use CSS only,
    then that’s perfectly fine, but directives give you access to the entire element
    and DOM APIs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么我们使用 JavaScript 来更改元素样式。我们当然可以编写一些 CSS 来处理一些逻辑，因为已经应用了适当的类名以供选择器使用。但我想要展示使用
    JavaScript 进行元素操作的使用，因为您可以使用它比 CSS 做更多的事情。请记住您的用例和需求，如果您只能使用 CSS，那么这完全没问题，但指令为您提供了访问整个元素和
    DOM API 的权限。
- en: Let’s shift gears and talk about the other type of directives that allow us
    to manipulate the existence of the element itself.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转换话题，讨论另一种类型的指令，它允许我们操作元素本身的存在。
- en: 8.2.3 Creating a structural directive
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 创建结构性指令
- en: Structural directives allow you to modify the DOM tree of the element, not just
    the element itself. This includes being able to remove the element and replace
    it with something else, creating additional elements, and so forth.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结构性指令允许您修改元素的 DOM 树，而不仅仅是元素本身。这包括能够移除元素并用其他内容替换它，创建额外的元素等等。
- en: As discussed earlier in the chapter, the use cases for structural directives
    are more limited, and the built-in examples of NgIf, NgFor, and NgSwitch are likely
    to provide you with everything you need.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所讨论的，结构性指令的使用场景更为有限，而 NgIf、NgFor 和 NgSwitch 的内置示例可能已经提供了您所需的一切。
- en: But you still want to learn about it, right? Let’s create a directive that will
    delay the rendering of the element for a certain number of milliseconds. You can
    use this to fade elements into the page—in our case, we want each card to have
    a different delay so they appear to fade in sequentially, as shown in [figure
    8.5](#figure8.5).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但您仍然想了解它，对吧？让我们创建一个指令，该指令将延迟元素渲染一定数量的毫秒。您可以使用此功能使元素淡入页面——在我们的例子中，我们希望每张卡片有不同的延迟，以便它们按顺序淡入，如图
    8.5 所示。
- en: '![c08-5.png](image_fi/293313c08/c08-5.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![c08-5.png](image_fi/293313c08/c08-5.png)'
- en: '[**Figure 8.5**](#figureanchor8.5) Adding the Delay directive to have the cards
    fade in sequentially, one after another'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 8.5**](#figureanchor8.5) 添加延迟指令以使卡片依次淡入'
- en: We’ll build one and then come back to a key point about why they’re always preceded
    with a `*` symbol when they’re used. It’ll be easier to see why after we walk
    through the example.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个，然后回到一个关键点，即为什么它们在使用时总是以一个 `*` 符号开头。在我们通过示例了解之后，这会更容易理解。
- en: 'Start by generating a new directive by running the following command in the
    terminal:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在终端运行以下命令来创建一个新的指令：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Open src/app/directives/delay.directive.ts and replace its contents with the
    code you see in the following listing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/app/directives/delay.directive.ts 文件，并用以下列表中的代码替换其内容。
- en: '**Listing 8.3** Delay directive'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 8.3** 延迟指令'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this directive, we’re importing dependencies, of which `Input`, `TemplateRef`,
    and `ViewContainerRef` are required. `TemplateRef` and `ViewContainerRef` are
    references to the template of the element our directive is attached to and a reference
    to the view that contains it, respectively.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此指令中，我们正在导入依赖项，其中 `Input`、`TemplateRef` 和 `ViewContainerRef` 是必需的。`TemplateRef`
    和 `ViewContainerRef` 分别是引用我们指令附加到的元素的模板以及包含它的视图的引用。
- en: When the structural directive is rendered by Angular, it creates a placeholder
    space, called an *embedded view*, where the directive can decide what to insert
    inside of this new view container. Using the `ViewContainerRef`, we can access
    this view and create any number of views. The documentation for `ViewContainerRef`
    can be found at [https://angular.io/api/core/ViewContainerRef](https://angular.io/api/core/ViewContainerRef)
    and is a good place to go to learn more in-depth about how views work in Angular.
    But the primary point is that we end up with an empty container that we can add
    one or more views into.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular渲染结构指令时，它创建一个占位符空间，称为*嵌入式视图*，指令可以决定在这个新的视图容器中插入什么。使用`ViewContainerRef`，我们可以访问这个视图并创建任意数量的视图。`ViewContainerRef`的文档可以在[https://angular.io/api/core/ViewContainerRef](https://angular.io/api/core/ViewContainerRef)找到，这是一个深入了解Angular中视图工作方式的好地方。但主要点是，我们最终得到一个空容器，我们可以向其中添加一个或多个视图。
- en: After it renders the view container, it takes the template and extracts it into
    a template so that it’s removed from the page but still accessible and available
    via the `TemplateRef`. That means Angular won’t render out the template unless
    our directive explicitly calls the necessary methods to render it out. This is
    how you can handle the lower-level rendering of an element.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染视图容器后，它将模板提取出来，使其从页面上移除，但仍然可以通过`TemplateRef`访问和可用。这意味着Angular不会渲染模板，除非我们的指令明确调用必要的渲染方法。这就是如何处理元素的底层渲染。
- en: 'Now our constructor injects both of these references into our directive so
    we can use them in the setter method. The `Input` is defined as a setter (which
    is a feature of Java­Script) and uses the same name as the selector, so we can
    bind data into the directive easily. The `delay` property accepts a number, which
    is the number of milliseconds to delay the rendering of the element. This is immediately
    passed into a `setTimeout` function that calls the following line after the specified
    delay:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的构造函数中注入这两个引用，这样我们就可以在setter方法中使用它们。`Input`被定义为setter（这是JavaScript的一个特性），并使用与选择器相同的名称，因此我们可以轻松地将数据绑定到指令中。`delay`属性接受一个数字，表示延迟渲染元素的毫秒数。这个数字立即传递给一个`setTimeout`函数，该函数在指定的延迟后调用下一行：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This line is where we create a new view inside of the view container and then
    pass it the template reference to render. This is how NgIf works under the hood
    by checking the truthiness of the value passed into the NgIf and creating or clearing
    the view.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是我们创建视图容器中的新视图，并传递模板引用以进行渲染的地方。这就是NgIf在底层通过检查传递给NgIf的值的真伪性来创建或清除视图的方式。
- en: Now back to the business of the `*` in structural directives. We didn’t have
    a `TemplateRef` or `ViewContainerRef` in our attribute directives, and the `*`
    is the syntactic way to describe to Angular that this directive needs to capture
    the template and create a view container before the element is rendered. This
    directive is used like `*delay="1000",` to denote a delay of 1 second before it’s
    displayed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到结构指令中的`*`的问题。在我们的属性指令中，我们没有`TemplateRef`或`ViewContainerRef`，而`*`是描述给Angular的语法方式，表示这个指令需要在元素渲染之前捕获模板并创建视图容器。这个指令的使用方式是`*delay="1000"`，表示在显示之前延迟1秒。
- en: 'Let’s put this into use on the Summary components, so open src/app/components/dashboard/dashboard.component.html
    and update the template where it iterates over the cards:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Summary组件中使用这个功能，所以打开`src/app/components/dashboard/dashboard.component.html`并更新迭代卡的模板：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’ve extended the NgFor to also create a variable `i` that holds the current
    index in the loop, and then we multiply the index by 100 and pass it to the Delay
    directive. This will stagger the display of each card by 100 milliseconds sequentially,
    and, coupled with the animations on the Summary component, it will also animate
    in gracefully.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经扩展了NgFor，使其也能创建一个变量`i`，该变量在循环中持有当前索引，然后我们将索引乘以100并传递给Delay指令。这将按顺序延迟每个卡的显示100毫秒，并且，与Summary组件上的动画相结合，它也将优雅地动画化。
- en: Structural directives are a little trickier than attribute directives because
    you’re working with the Angular views instead of an already rendered element.
    Thankfully, the use cases for when a structural directive is appropriate are less
    common.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结构指令比属性指令稍微复杂一些，因为你是在处理Angular视图而不是已经渲染的元素。幸运的是，结构指令适用的用例相对较少。
- en: Most of the directives you’ll create are likely to be of the attribute type.
    I find this to be true in my work, but also generally because NgFor, NgIf, and
    NgSwitch provide functionality that covers most use cases for structural directives.
    Most examples of structural directives that I’ve seen accomplish the same basic
    tasks as these three built-in directives with some customized abilities. For example,
    many data table components have their own implementation of NgFor that’s better
    integrated with the data table and can help provide capabilities like pagination.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的大多数指令可能都是属性类型的。我在我的工作中发现这一点是正确的，而且一般来说，NgFor、NgIf 和 NgSwitch 提供的功能覆盖了大多数结构指令的使用场景。我所见到的许多结构指令的例子，与这三个内置指令一样，执行了相同的基本任务，并具有一些定制的能力。例如，许多数据表组件都有自己的
    NgFor 实现，与数据表更好地集成，并可以帮助提供分页等功能。
- en: As you work more with directives, you’ll likely need to also spend more time
    with the Angular APIs related to views and rendering elements. You’ll be able
    to implement more complex scenarios should your needs require them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你越来越多地使用指令，你可能还需要花更多时间熟悉与视图和渲染元素相关的 Angular API。如果你的需求需要，你将能够实现更复杂的场景。
- en: We’ve finished our custom directives, so let’s take a look at pipes and how
    we can craft custom ways to format our data before display.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了自定义指令，现在让我们看看管道，以及我们如何可以创建自定义的方式来格式化我们的数据，以便在显示之前。
- en: 8.3 Crafting custom pipes
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 创建自定义管道
- en: '*Pipes* are essentially a way to format data, and depending on the data you
    have you may find it useful to create your own set of pipes to simplify your templates.
    Pipes are generally simple and easy to implement, and if they can save you repeated
    formatting logic, then you should make your own.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*管道*基本上是一种格式化数据的方式，根据你拥有的数据，你可能发现创建自己的管道集来简化模板是有用的。管道通常简单且易于实现，如果它们可以节省你重复的格式化逻辑，那么你应该创建自己的。'
- en: Pipes are functions that data is passed through prior to being rendered into
    the page. Somewhat similar to how components have the OnInit lifecycle hook to
    handle logic before the component renders, pipes do the same thing for bindings.
    You can see how Angular processes bindings when pipes are present or not in [figure
    8.6](#figure8.6).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是在数据被渲染到页面之前传递数据的函数。这与组件有 OnInit 生命周期钩子来处理组件渲染前的逻辑类似，管道为绑定做同样的事情。你可以看到当存在或不存在管道时，Angular
    如何处理绑定。[图 8.6](#figure8.6)。
- en: '![c08-6.png](image_fi/293313c08/c08-6.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![c08-6.png](image_fi/293313c08/c08-6.png)'
- en: '[**Figure 8.6**](#figureanchor8.6) Data is passed through a pipe before being
    rendered in a template binding.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 8.6**](#figureanchor8.6)  数据在模板绑定渲染之前通过管道传递。'
- en: In the chapter example, there are several uses of the Currency and Percent pipes
    to format data. These are simple but great examples of how pipes can be invaluable.
    Imagine your application has to support different currencies—the Currency pipe
    can figure out how each currency is typically formatted.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，有几个使用货币和百分比管道来格式化数据的例子。这些都是管道如何变得非常有价值的简单但很好的例子。想象一下，如果你的应用程序需要支持不同的货币，货币管道可以找出每种货币通常是如何格式化的。
- en: 'There are fundamentally two types of pipes: pure and impure. *Pure* pipes maintain
    no state information, and *impure* pipes maintain state.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两种类型的管道：纯管道和不纯管道。*纯管道*不维护任何状态信息，而*不纯管道*维护状态。
- en: Pure and impure pipes are also rendered differently, as you can see in [figure
    8.7](#figure8.7). A pure pipe is only run if the input value passed into the pipe
    has changed, making it more efficient because it won’t run very often. On the
    other hand, an impure pipe will execute on every change detection run, because
    an impure pipe has state that might have changed, and that would render a different
    output regardless of whether the input has changed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 纯管道和不纯管道的渲染方式也不同，如图 8.7 所示。纯管道仅在传递到管道中的输入值发生变化时运行，这使得它更高效，因为它不会经常运行。另一方面，不纯管道会在每次变更检测运行时执行，因为不纯管道具有可能发生变化的状态，无论输入是否发生变化，都会渲染不同的输出。
- en: '![c08-7.png](image_fi/293313c08/c08-7.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![c08-7.png](image_fi/293313c08/c08-7.png)'
- en: '[**Figure 8.7**](#figureanchor8.7) How pure and impure pipes are handled by
    Angular'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 8.7**](#figureanchor8.7)  Angular 如何处理纯管道和不纯管道'
- en: This is very important to understand if you start to build pipes. Choosing to
    make a pipe pure or impure can have significant consequences in the way that pipe
    is executed and potentially on the performance of your application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始构建管道，理解这一点非常重要。选择使管道为纯管道或不纯管道可能会对管道的执行方式以及应用程序的性能产生重大影响。
- en: We’ll build examples of both pure and impure pipes, but you should always try
    to build a pure pipe. I’d bet that 98% of all custom pipes created are pure—or
    should be pure. We’ll look a little more closely at why this is when we build
    an impure pipe, but storing state in a pipe is tricky and makes its implementation
    more complex.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建纯管道和不纯管道的示例，但你应该始终尝试构建纯管道。我敢打赌，98%的所有自定义管道都是纯的——或者应该是纯的。当我们构建不纯管道时，我们将更详细地探讨为什么是这样，因为将状态存储在管道中很棘手，并且使其实现更加复杂。
- en: Let’s build a pipe that helps us display the change information for a stock,
    and we’ll be making it a pure pipe as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个帮助我们显示股票变动信息的管道，并且我们将使其成为一个纯管道。
- en: 8.3.1 Creating a pure pipe
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 创建纯管道
- en: Because almost every pipe you create will be a pure pipe, let’s start by looking
    at how to create one for our application. Pipes don’t have the same complexities
    as directives, because they’re a way to modify a value prior to it being rendered
    into the template. Pure pipes are so named because they implement a *pure function* —a
    function that doesn’t maintain any internal state and returns the same output
    given the same input.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因为几乎你创建的每个管道都将是一个纯管道，所以让我们先看看如何为我们的应用程序创建一个。管道不像指令那样复杂，因为它们是在值被渲染到模板之前修改值的一种方式。纯管道之所以被称为纯管道，是因为它们实现了一个*纯函数*——一个不维护任何内部状态，并且对于相同的输入返回相同输出的函数。
- en: Pure functions are important for performance, because Angular doesn’t need to
    run them with each change detection lifecycle unless the input value has changed.
    This can save a reasonable amount of overhead for performance reasons.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数对于性能很重要，因为Angular不需要在每次变化检测生命周期中运行它们，除非输入值已更改。这可以节省相当多的开销，出于性能原因。
- en: A pure pipe is implemented as a single function that accepts the value from
    the binding and any additional arguments that might be passed. This method is
    called `transform` because it takes the input value, does some type of transformation,
    and returns a result.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 纯管道实现为一个接受绑定值和可能传递的任何额外参数的单个函数。这个方法被称为`transform`，因为它接受输入值，执行某种类型的转换，并返回一个结果。
- en: 'We’re going to create a custom pipe that takes care of displaying the stock
    change price and percentage data. Right now, we have this inside of our Summary
    component template, and we’d like to replace the long line:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个自定义管道，用于处理显示股票价格变动和百分比数据。目前，我们已经在Summary组件模板中实现了这个功能，我们希望替换掉下面这个长行：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'with this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The original is quite long—imagine writing it in multiple places. We’d easily
    have issues where the output could be inconsistent, so we want to create a pipe
    that can make it reusable and cleaner.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 原文相当长——想象一下在多个地方写它。我们可能会遇到输出不一致的问题，所以我们要创建一个可以使其可重用和更干净的管道。
- en: 'Let’s make a new pipe called the Change pipe to simplify this snippet. As you’d
    expect, there’s a way to generate a new pipe with the CLI. Using the terminal,
    run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的管道，称为Change管道，以简化这个片段。正如你所期望的，有一个使用CLI生成新管道的方法。使用终端，运行以下命令：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The new files are generated inside of src/app/pipes. Let’s open src/app/pipes/change.pipe.ts
    and replace it with the code in the following listing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件生成在src/app/pipes目录下。让我们打开src/app/pipes/change.pipe.ts，并用以下列表中的代码替换它。
- en: '**Listing 8.4** Change pipe'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表8.4** Change管道'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This pipe uses the Currency and Percent pipes, and it begins by importing all
    the dependencies. The `@Pipe` decorator denotes that we’re creating a pipe, and
    we give it a `name` property to define the name of the pipe—this needs to be unique,
    so consider it carefully.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道使用了Currency和Percent管道，并且首先导入所有依赖项。`@Pipe`装饰器表示我们正在创建一个管道，我们给它一个`name`属性来定义管道的名称——这需要是唯一的，所以请仔细考虑。
- en: When the class is defined, it also implements the `PipeTransform` interface
    to help ensure that we construct the pipe properly. The constructor then injects
    the Currency and Percent pipes into the class so we can use them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当类被定义时，它还实现了`PipeTransform`接口，以帮助确保我们正确构建管道。构造函数随后将Currency和Percent管道注入到类中，这样我们就可以使用它们了。
- en: Finally, the real work happens in the `transform` method, where it accepts one
    or more arguments. The first is the value that’s passed into the pipe and that’s
    always provided by the binding, and it’s expected to be a `stock` object. The
    remaining arguments are optional parameters that might be passed as needed, and
    they’re optional because the interface doesn’t require them. In this case, we
    declare one parameter, `showPercent`, as a Boolean that declares whether we want
    to add the percentage value or not. The method then constructs a string using
    the desired formatting and returns it to be displayed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实际的工作发生在 `transform` 方法中，它接受一个或多个参数。第一个是传递给管道的值，它总是由绑定提供，并且预期是一个 `stock`
    对象。其余的参数是可能按需传递的可选参数，它们是可选的，因为接口不需要它们。在这种情况下，我们声明一个参数 `showPercent`，作为一个布尔值，表示我们是否想要添加百分比值。然后方法使用所需的格式构造一个字符串，并将其返回以供显示。
- en: We’ve implemented the `transform` method as a pure function. Every time you
    pass the same arguments to it, you’ll get the same output. If there’s a chance
    the value can change, it isn’t a pure function or a pure pipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `transform` 方法实现为一个纯函数。每次你向它传递相同的参数时，你都会得到相同的输出。如果值有可能会改变，它就不是纯函数或纯管道。
- en: 'Now we can put it to use in our Summary component. Open src/app/components/summary/summary.component.html
    and change the last line with `stock.change` to the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将其用于我们的 Summary 组件。打开 src/app/components/summary/summary.component.html
    并将最后一行中的 `stock.change` 改为以下内容：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We were able to simplify the long line with two interpolation bindings into
    a single one. Notice that we aren’t passing an argument into it, because by default
    it will show the change in percentage. You could disable this by changing the
    pipe call to pass the Boolean value like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够将带有两个插值绑定的长行简化为一个。注意，我们没有向它传递任何参数，因为默认情况下它将显示百分比变化。你可以通过将管道调用改为传递布尔值来禁用此功能，如下所示：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating any pure pipe will follow this basic outline, and the significant changes
    will be in how you transform the value. Be sure to return a value that’s either
    a string or that can be transformed into a string. You shouldn’t return an array
    or object, for example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任何纯管道都将遵循这个基本框架，显著的变化将在于你如何转换值。确保返回一个字符串或可以转换成字符串的值。你不应该返回数组或对象，例如。
- en: The value of pipe purity becomes more obvious when we create an impure pipe
    and see how it’s called by the application lifecycle. Let’s take a look at that
    now and create two examples to see in what situations they’re useful.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个不纯的管道并看到它是如何被应用程序生命周期调用的，管道纯度的价值就变得更加明显。现在让我们看看这个，并创建两个示例来了解它们在什么情况下是有用的。
- en: 8.3.2 Creating an impure pipe
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 创建不纯管道
- en: Sometimes the way you want to format a piece of data relies on the state of
    the pipe or the value itself—it implements the `transform` method in such a way
    that it doesn’t always provide the same result given the same inputs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你想要格式化数据的方式依赖于管道的状态或值本身——它以这种方式实现了 `transform` 方法，即它不总是提供相同的输出，即使输入相同。
- en: Due to this design, an impure pipe is executed with every change detection lifecycle
    regardless of whether the input itself has changed. This is the only way to know
    if the final binding result has changed (remember, it might be dependent on some
    additional state that changes the result) and whether Angular needs to update
    the rendered view.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种设计，不纯的管道会在每次变更检测生命周期中执行，无论输入本身是否已更改。这是唯一知道最终绑定结果是否已更改（记住，它可能依赖于某些会改变结果的其他状态）以及
    Angular 是否需要更新渲染视图的方法。
- en: The Async pipe is provided by Angular as an impure pipe and has a good use case.
    It allows you to pass in an observable or promise to the pipe, and when a value
    is returned asynchronously, the result will be evaluated. It essentially listens
    for the `async` event to fire (depending on the type) and then displays that value
    directly. You can use that to call an API that returns a promise, pass the promise
    into the binding with the Async pipe, and the value will appear after the API
    returns the value.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供的异步管道是一个不纯的管道，并且有一个很好的用例。它允许你将一个可观察对象或承诺传递给管道，当异步返回一个值时，结果将被评估。它本质上是在监听
    `async` 事件（取决于类型）触发后直接显示该值。你可以用它来调用返回承诺的 API，将承诺传递给与异步管道绑定的绑定，值将在 API 返回值后出现。
- en: To get a better sense of just how an Async pipe behaves, I find it helpful to
    implement one that logs how many times it’s been called to the console, and the
    resulting output is what you’ll see in [figure 8.8](#figure8.8). This tells you
    the number of times that change detection has run for the component that contains
    this pipe.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解异步管道的行为，我发现实现一个记录它被调用次数到控制台的管道很有帮助，并且最终输出就是你将在 [图8.8](#figure8.8) 中看到的。这告诉你包含此管道的组件进行了多少次变更检测。
- en: '![c08-8.png](image_fi/293313c08/c08-8.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![c08-8.png](image_fi/293313c08/c08-8.png)'
- en: '[**Figure 8.8**](#figureanchor8.8) Change Detector pipe that alerts to every
    time a component is checked for changes'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.8**](#figureanchor8.8)  变更检测管道，每次组件被检查变更时都会发出警报'
- en: 'Start by generating a new pipe using the terminal. We’ll create a new pipe
    called ChangeDetector:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用终端生成一个新的管道。我们将创建一个名为 ChangeDetector 的新管道：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Open the newly generated pipe at src/app/pipes/change-detector.pipe.ts. Replace
    it with the content found in the following listing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新创建的管道 src/app/pipes/change-detector.pipe.ts。将其替换为以下列表中的内容。
- en: '**Listing 8.5** ChangeDetector pipe'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表8.5**  变更检测管道'
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This pipe doesn’t transform any values by default. We first set the `pure` property
    to `false` in the decorator to tell Angular that this pipe is impure and must
    be always reevaluated. Then we store a property that contains a numeric value
    to hold the number of times it’s been called. Lastly, the `transform` method increments
    the count, logs out a message, and returns the value unchanged.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此管道默认不转换任何值。我们首先在装饰器中将 `pure` 属性设置为 `false`，以告诉 Angular 这个管道是不纯的，并且必须始终重新评估。然后我们存储一个包含数值的属性来保存它被调用的次数。最后，`transform`
    方法增加计数，输出一条消息，并返回未更改的值。
- en: If this were a pure pipe, it would only increment the count when the value of
    the binding changed, but this will run many more times. To see exactly how many,
    let’s put it on the App component.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个纯管道，它只会当绑定值改变时增加计数，但这将运行更多次。为了确切知道运行了多少次，让我们将它放在 App 组件上。
- en: 'Open src/app/app.component.html and update the line that contains the title
    to this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 src/app/app.component.html 并更新包含标题的行，如下所示：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This binds the string `'Stock Tracker'` into the ChangeDetector pipe, and if
    you open the console it should log out a lot of messages like `"Component change
    detection executed 32 times"`. The actual number might vary slightly if you’ve
    made customizations to your application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将字符串 `'Stock Tracker'` 绑定到 ChangeDetector 管道，如果你打开控制台，它应该会输出很多像 `"Component
    change detection executed 32 times"` 这样的消息。实际的数字可能会略有不同，如果你对你的应用程序进行了自定义。
- en: Now imagine that this transform method did some more difficult work. Perhaps
    you have a large array of items to scan to find how to map a key to a value, and
    that performance might be suboptimal. You might even have an asynchronous call
    to handle. These are examples of potential pitfalls when creating impure pipes,
    as you see in [figure 8.9](#figure8.9).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，这个转换方法做了更多困难的工作。也许你有一个大数组要扫描以找到如何将键映射到值，并且性能可能不是最优的。你可能甚至有一个异步调用来处理。这些都是创建不纯管道时可能遇到的潜在陷阱，就像你在
    [图8.9](#figure8.9) 中看到的那样。
- en: '![c08-9.png](image_fi/293313c08/c08-9.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![c08-9.png](image_fi/293313c08/c08-9.png)'
- en: '[**Figure 8.9**](#figureanchor8.9) Example of an impure pipe that loads news
    at the top of the page by maintaining state in the pipe itself'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图8.9**](#figureanchor8.9)  一个不纯管道的示例，通过在管道本身维护状态，在页面顶部加载新闻'
- en: I find this example provides a nice illustration of what happens, but what about
    an example of something that accomplishes a task? We can build another impure
    pipe that takes a value and then makes an HTTP request to load news, as you see
    in [figure 8.9](#figure8.9).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这个例子很好地说明了发生了什么，但关于完成任务的例子呢？我们可以构建另一个不纯管道，它接受一个值然后通过 HTTP 请求加载新闻，就像你在 [图8.9](#figure8.9)
    中看到的那样。
- en: 'Generate a new pipe with the following command and then replace the contents
    of src/app/pipes/news.pipe.ts with the code from the following listing:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令生成一个新的管道，然后替换 src/app/pipes/news.pipe.ts 中的内容为以下列表中的代码：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Listing 8.6** Impure News pipe'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表8.6**  不纯新闻管道'
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This pipe is declared again as an impure pipe, and it has two stateful properties
    to hold the source and the resulting news title.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个管道再次被声明为一个不纯管道，并且它有两个有状态的属性来保存源和结果新闻标题。
- en: The `transform` method is more complex. It’s run with every change detection
    run, so we create a barrier by first checking if the input source has changed
    or not, since we cache the last provided source. If the value changed (or is provided
    for the first time), we make an HTTP request to load the news data. As soon as
    that data has returned, we update the value of the `news` property with the `title`
    and it will get rendered out.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform`方法更为复杂。它在每次变更检测运行时都会执行，因此我们通过首先检查输入源是否已更改来创建一个屏障，因为我们缓存了最后提供的源。如果值已更改（或首次提供），我们将通过HTTP请求来加载新闻数据。一旦数据返回，我们就使用`title`更新`news`属性的值，并将其渲染出来。'
- en: You may wonder how Angular knows when the API request has completed. Well, because
    we’re using the Angular HttpClient service under the hood, Angular is aware of
    when that response has finished, and that triggers another round of change detection.
    Because this is an impure pipe, it’s run again, and the `news` value will be rendered.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道Angular是如何知道API请求何时完成的。好吧，因为我们底层使用了Angular HttpClient服务，Angular知道响应何时完成，这触发了另一轮变更检测。因为这是一个不纯的管道，它会再次运行，并将`news`值渲染出来。
- en: We need to put this into our template to have it run, so open src/app/app.component.html
    and add some extra lines to the header, as you see bolded in the following listing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将其放入模板中才能运行，所以打开`src/app/app.component.html`并添加一些额外的行到标题中，如下面的列表所示，其中加粗的部分。
- en: '**Listing 8.7** App header with News pipe'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表8.7**　带有新闻管道的应用程序标题'
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here we just add a place to render out the top news headline. There are several
    values you can pass if you’d rather get a different news source:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是添加了一个渲染顶级新闻标题的位置。如果你想要获取不同的新闻源，可以传递几个不同的值：
- en: '`the-wall-street-journal`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`the-wall-street-journal`'
- en: '`bloomberg`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bloomberg`'
- en: '`cnbc`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cnbc`'
- en: '`financial-times`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`financial-times`'
- en: '`the-new-york-times`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`the-new-york-times`'
- en: Now when you preview the application you should see the news headline appear
    at the top of the page with a link to the article. Every time the App component
    is rendered (which is once per load), it will request the news from the API. This
    could be dangerous to put onto another type of component that’s rendered more
    often or repeatedly in the same page.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你预览应用程序时，你应该看到新闻标题出现在页面顶部，并有一个链接到文章。每当应用程序组件被渲染（每次加载时只渲染一次），它都会从API请求新闻。如果将其放在渲染更频繁或重复渲染的同一页面的其他类型组件上可能会很危险。
- en: What’s important about this example is that it would have been much better to
    implement this as a component than inside of a pipe. There’s not a lot of reason
    to make it a pipe, in fact.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中重要的是，将其实现为一个组件而不是管道会更好。实际上，没有太多理由将其做成管道。
- en: Although impure pipes are interesting, I’m certainly of the mindset that you
    should avoid them if you can. Even the Async pipe is problematic to use in production
    because it makes error handling difficult. They were made to help in a small set
    of use cases and are perhaps mostly useful for development, but they make application
    logic more challenging and difficult to predict.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不纯管道很有趣，但我确实认为如果你能避免的话应该避免使用它们。即使是异步管道在生产环境中使用也有问题，因为它使得错误处理变得困难。它们是为了帮助解决一小部分用例而设计的，也许主要用于开发，但它们使得应用程序逻辑更加复杂和难以预测。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'You’ve successfully created several directives and pipes! These are useful
    skills to help with your code reuse and to keep your code focused on specific
    tasks. Here are the key takeaways from this chapter:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功创建了几个指令和管道！这些技能对于代码复用和使代码专注于特定任务非常有用。以下是本章的关键要点：
- en: 'Directives come in three flavors: attribute, structural, and components.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令有三种类型：属性、结构和组件。
- en: Attribute directives are the most common to create and are great for modifying
    an existing element.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性指令是最常见的创建方式，非常适合修改现有元素。
- en: Structural directives are less common and are meant to be used to modify the
    existence or structure of DOM elements.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构性指令不太常见，旨在用于修改DOM元素的存在或结构。
- en: Pure pipes are the most useful and allow you to transform a value before output
    using a pure function.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯管道非常有用，允许你使用纯函数在输出之前转换一个值。
- en: Impure pipes allow you to maintain state inside of a pipe, but they’re run with
    every change detection check and are to be avoided if possible.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不纯管道允许你在管道内部维护状态，但它们会在每次变更检测检查时运行，如果可能的话应避免使用。
