- en: 12 Optimizing a physical system
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 优化物理系统
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Building and visualizing a simulation for a projectile
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和可视化弹道模拟
- en: Finding maximal and minimal values for a function using derivatives
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用导数寻找函数的最大值和最小值
- en: Tuning simulations with parameters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数调整模拟
- en: Visualizing spaces of input parameters for simulations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化模拟的输入参数空间
- en: Implementing gradient ascent to maximize functions of several variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现梯度上升以最大化多个变量的函数
- en: For most of the last few chapters, we’ve focused on a physical simulation for
    a video game. This is a fun and simple example to work with, but there are far
    more important and lucrative applications. For any big feat of engineering like
    sending a rocket to Mars, building a bridge, or drilling an oil well, it’s important
    to know that it’s going to be safe, successful, and on budget before you attempt
    it. In each of these projects, there are quantities you want to optimize. For
    instance, you may want to minimize the travel time for your rocket, minimize the
    amount or cost of concrete in a bridge, or maximize the amount of oil produced
    by your well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几章的大部分时间里，我们一直专注于视频游戏的物理模拟。这是一个有趣且简单的例子，但还有更多重要且有利可图的用途。对于任何像向火星发射火箭、建造桥梁或钻油井这样的重大工程壮举，在尝试之前知道它将安全、成功且在预算范围内是非常重要的。在这些项目中的每一个，都有你想要优化的量。例如，你可能希望最小化火箭的旅行时间，最小化桥梁中混凝土的量或成本，或者最大化油井的产油量。
- en: To learn about optimization, we’ll focus on the simple example of a projectile−
    namely, a cannonball being fired from a cannon. Assuming the cannonball comes
    out of the barrel at the same speed every time, the launch angle will decide the
    trajectory (figure 12.1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解优化，我们将关注一个简单的例子，即弹道，即从大炮中发射的弹丸。假设弹丸每次从炮管中出来时的速度都相同，发射角度将决定轨迹（图12.1）。
- en: '![](../Images/CH12_F01_Orland.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F01_Orland.png)'
- en: Figure 12.1 Trajectories for a cannonball fired at four different launch angles
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 从四个不同发射角度发射弹道的轨迹
- en: As you can see in figure 12.1, four different launch angles produce four different
    trajectories. Among these, 45° is the launch angle that sends the cannonball the
    furthest, while 80° is the angle that sends it the highest. These are only a few
    angles of all of the possible values between 0 and 90°, so we can’t be sure they
    are the best. Our goal is to systematically explore the range of possible launch
    angles to be sure we’ve found the one that optimizes the range of the cannon.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图12.1中看到的，四个不同的发射角度产生了四个不同的轨迹。在这些轨迹中，45°是使弹道飞得最远的发射角度，而80°是使弹道飞得最高的角度。这些只是0到90°之间所有可能值中的一部分角度，所以我们不能确定它们是最好的。我们的目标是系统地探索可能的发射角度范围，以确保我们已经找到了优化射程的那个角度。
- en: To do this, we first build a simulator for the cannonball. This simulator will
    be a Python function that takes a launch angle as input, runs Euler’s method (as
    we did in chapter 9) to simulate the moment-by-moment motion of the cannonball
    until it hits the ground, and outputs a list of positions of the cannonball over
    time. From the result, we’ll extract the final horizontal position of the cannonball,
    which will be the landing position or range. Putting these steps together, we
    implement a function that takes a launch angle and returns the range of the cannonball
    at that angle (figure 12.2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先为弹道构建一个模拟器。这个模拟器将是一个 Python 函数，它接受发射角度作为输入，运行欧拉方法（正如我们在第9章所做的那样）来模拟弹道在击中地面之前的每一刻的运动，并输出弹道随时间变化的各个位置列表。从结果中，我们将提取弹道的最终水平位置，这将是着陆位置或射程。将这些步骤组合起来，我们实现了一个函数，该函数接受发射角度并返回该角度下弹道的射程（图12.2）。
- en: '![](../Images/CH12_F02_Orland.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F02_Orland.png)'
- en: Figure 12.2 Computing the range of a projectile using a simulator
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 使用模拟器计算弹道射程
- en: 'Once we have encapsulated all of this logic in a single Python function called
    `landing_position`, which computes the range of a cannonball as a function of
    its launch angle, we can think about the problem of finding the launch angle that
    maximizes the range. We can do this in two ways: first, we make a graph of the
    range versus the launch angle and look for the largest value (figure 12.3).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将所有这些逻辑封装在一个名为 `landing_position` 的单个 Python 函数中，该函数将弹道作为发射角度的函数来计算，我们就可以考虑寻找最大化射程的发射角度的问题。我们可以有两种方法来做这件事：首先，我们绘制射程与发射角度的图表，寻找最大的值（图12.3）。
- en: '![](../Images/CH12_F03_Orland.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F03_Orland.png)'
- en: Figure 12.3 Looking at a plot of range vs. launch angle, we can see the approximate
    value of the launch angle that produces the longest range.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 通过观察射程与发射角度的图表，我们可以看到产生最长射程的发射角度的大致值。
- en: The second way we can find the optimal launch angle is to set our simulator
    aside and find a formula for the range *r*(θ) of the projectile as a function
    of the launch angle θ. This should produce identical results as the simulation,
    but because it is a mathematical formula, we can take its derivative using the
    rules from chapter 10\. The derivative of the landing position with respect to
    the launch angle tells us how much increase in the range we’ll get for small increases
    in the launch angle. At some angle, we can see that we get diminishing returns−increasing
    the launch angle causes the range to *decrease* and we’ll have passed our optimal
    value. Before this, the derivative of *r*(θ) will instantaneously be zero, and
    the value of θ where the derivative is zero happens to be the maximum value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到最优发射角度的第二种方式是将我们的模拟器放在一边，找到一个公式来表示发射角度θ作为弹道射程*r*(θ)的函数。这应该会产生与模拟相同的结果，但由于它是一个数学公式，我们可以使用第10章中的规则对其求导。关于发射角度的着陆位置的导数告诉我们，对于发射角度的小幅度增加，我们将获得多少射程的增加。在某个角度，我们可以看到我们得到了递减的回报−增加发射角度会导致射程*减少*，我们将超过最优值。在此之前，*r*(θ)的导数将瞬间为零，导数为零的θ值恰好是最大值。
- en: Once we’ve warmed up using both of these optimization techniques on our 2D simulation,
    we can try a more challenging 3D simulation, where we can control the upward angle
    of the cannon as well as the lateral direction it is fired. If the elevation of
    the terrain varies around the cannon, the direction can have an impact on how
    far the cannonball flies before hitting the ground (figure 12.4).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用这两种优化技术在我们的二维模拟中进行了预热，我们就可以尝试一个更具挑战性的三维模拟，在这个模拟中，我们可以控制大炮的仰角以及发射的方向。如果地形在大炮周围变化，方向会影响炮弹在击中地面之前飞行的距离（图12.4）。
- en: 'For this example, let’s build a function *r*(θ, φ), taking two input angles
    θ and φ and outputting a landing position. The challenge is to find the pair (θ,
    φ) that maximizes the range of the cannon. This example lets us cover our third
    and most important optimization technique: *gradient ascent*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们构建一个函数*r*(θ, φ)，它接受两个输入角度θ和φ，并输出一个着陆位置。挑战在于找到一对(θ, φ)，以最大化大炮的射程。这个例子让我们涵盖了我们的第三种也是最重要的优化技术：*梯度上升*。
- en: '![](../Images/CH12_F04_Orland.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4](../Images/CH12_F04_Orland.png)'
- en: Figure 12.4 With uneven terrain, the direction we fire the cannon can affect
    the range of the cannonball as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 在不均匀的地形上，我们发射大炮的方向可以影响炮弹的射程。
- en: As we learned in the last chapter, the gradient of *r*(θ, φ) at a point (θ,
    φ) is a vector pointing in the direction that causes *r* to increase most rapidly.
    We’ll write a Python function called `gradient_ascent` that takes as input a function
    to optimize, along with a pair of starting inputs, and uses the gradient to find
    higher and higher values until it reaches the optimal value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所学，点(θ, φ)处函数*r*(θ, φ)的梯度是一个指向使*r*增加最快的方向的向量。我们将编写一个名为`gradient_ascent`的Python函数，它接受一个要优化的函数、一对起始输入，并使用梯度找到越来越高的值，直到达到最优值。
- en: The mathematical field of optimization is a broad one, and I hope to give you
    a sense of some basic techniques. All of the functions we’ll work with are smooth,
    so you will be able to make use of the many calculus tools you’ve learned so far.
    Also, the way we approach optimization in this chapter sets the stage for optimizing
    computer “intelligence” in machine learning algorithms, which we turn to in the
    final chapters of the book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 优化数学领域非常广泛，我希望能够让你对一些基本技术有一个大致的了解。我们将要使用的所有函数都是光滑的，因此你将能够利用你迄今为止学到的许多微积分工具。此外，我们在本章中处理优化的方式为在机器学习算法中优化计算机“智能”奠定了基础，这在本书的最后几章中会进行探讨。
- en: 12.1 Testing a projectile simulation
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 测试弹道模拟
- en: Our first task is to build a simulator that computes the flight path of the
    cannonball. The simulator will be a Python function called `trajectory`. It takes
    the launch angle, as well as a few other parameters that we may want to control,
    and returns the positions of the cannonball over time until it collides with Earth.
    To build this simulation, we turn to our old friend from chapter 9−Euler’s method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是构建一个计算炮弹飞行路径的模拟器。这个模拟器将是一个名为`trajectory`的Python函数，它接受发射角度以及我们可能想要控制的几个其他参数，并返回炮弹在撞击地球之前的各个时间点的位置。为了构建这个模拟，我们转向第9章的老朋友——欧拉方法。
- en: 'As a reminder, we can simulate motion with Euler’s method by advancing through
    time in small increments (we’ll use 0.01 seconds). At each moment, we’ll know
    the position of the cannonball, as well as its derivatives: velocity and acceleration.
    The velocity and acceleration let us approximate the change in position to the
    next moment, and we’ll repeat the process until the cannonball hits the ground.
    As we go, we can save the time, *x* and *y* positions of the cannonball, at each
    step and output them as the result of the `trajectory` function.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我们可以通过在时间上以小增量前进来使用欧拉方法模拟运动（我们将使用0.01秒）。在每一个时刻，我们将知道炮弹的位置，以及它的导数：速度和加速度。速度和加速度使我们能够近似下一个时刻的位置变化，我们将重复这个过程，直到炮弹击中地面。在这个过程中，我们可以保存炮弹在每个步骤的时间和*x*、*y*位置，并将它们作为`trajectory`函数的结果输出。
- en: Finally, we’ll write functions that take the results we get back from the `trajectory`
    function and measure one numerical property. The functions `landing _position`,
    `hang_time`, and `max_height` tell us the range, the time in the air, and the
    maximum height of the cannonball, respectively. Each of these will be a value
    we can subsequently optimize for.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编写函数，这些函数将测量从`trajectory`函数返回的结果的一个数值属性。函数`landing_position`、`hang_time`和`max_height`分别告诉我们炮弹的射程、空中时间和最大高度。这些都将是我们随后可以优化的值。
- en: 12.1.1 Building a simulation with Euler’s method
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 使用欧拉方法构建模拟
- en: In our first 2D simulation, we call the horizontal direction the *x* direction
    and the vertical direction the *z* direction. That way we won’t have to rename
    either of these when we add another horizontal direction. We call the angle that
    the cannonball is launched θ and the velocity of the cannonball ***v*** as shown
    in figure 12.5.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个2D模拟中，我们将水平方向称为*x*方向，将垂直方向称为*z*方向。这样，当我们添加另一个水平方向时，我们就不必重命名这两个方向中的任何一个。我们将炮弹发射的角度称为θ，将炮弹的速度称为***v***，如图12.5所示。
- en: '![](../Images/CH12_F05_Orland.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F05_Orland.png)'
- en: Figure 12.5 The variables in our projectile simulation
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 我们抛体模拟中的变量
- en: 'The *speed*, *v*, of a moving object is defined as the magnitude of its velocity
    vector, so *v* = |***v***|. Given the launch angle θ, the *x* and *z* components
    of the cannonball’s velocity are *v[x]* = |***v***| · cos(θ) and *v[z]* = |***v***|
    · sin(θ). I’ll assume that the cannonball leaves the barrel of the cannon at time
    *t* = 0 and with (*x*, *z*) coordinates (0, 0), but I’ll also include a configurable
    launch height. Here’s the basic simulation using Euler’s method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 移动物体的速度*v*定义为它的速度向量的模，因此*v* = |***v***|。给定发射角度θ，炮弹的*x*和*z*速度分量是*v[x]* = |***v***|
    · cos(θ)和*v[z]* = |***v***| · sin(θ)。我将假设炮弹在时间*t* = 0离开炮筒，其(*x*, *z*)坐标为(0, 0)，但我也会包括一个可配置的发射高度。以下是使用欧拉方法的基本模拟：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '❶ Additional inputs: the time step dt, gravitational field strength g, and
    angle theta (in degrees)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 额外输入：时间步长dt、重力场强度g和角度theta（以度为单位）
- en: ❷ Calculates the initial *x* and z components of velocity, converting the input
    angle from degrees to radians
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算初始*x*和*z*速度分量，将输入角度从度转换为弧度
- en: ❸ Initializes lists that hold all the values of time and the *x* and z positions
    over the course of the simulation
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 初始化列表，用于存储模拟过程中所有时间值和*x*、*z*位置值
- en: ❹ Runs the simulation only while the cannonball is above ground
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 仅在炮弹在地面以上时运行模拟
- en: ❺ Updates time, z velocity, and position. There are no forces acting in the
    *x* direction, so the *x* velocity is unchanged.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 更新时间、z速度和位置。在*x*方向上没有作用力，因此*x*速度保持不变。
- en: ❻ Returns the list of t, x, and z values, giving the motion of the cannonball
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回t、x和z值的列表，给出炮弹的运动轨迹
- en: 'You’ll find a `plot_trajectories` function in the source code for this book
    that takes the outputs of one or more results of the `trajectory` function and
    passes them to Matplotlib’s `plot` function, drawing curves that show the path
    of each cannonball. For instance, figure 12.6 shows plotting a 45° launch next
    to a 60° launch, which is done using the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的源代码中找到一个`plot_trajectories`函数，它接受一个或多个`trajectory`函数的结果，并将它们传递给Matplotlib的`plot`函数，绘制出显示每个炮弹路径的曲线。例如，图12.6显示了45°发射角度与60°发射角度的对比，这是通过以下代码实现的：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](../Images/CH12_F06_Orland.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F06_Orland.png)'
- en: Figure 12.6 An output of the `plot_trajectories` function showing the results
    of a 45° and 60° launch angle.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 `plot_trajectories`函数的输出，显示了45°和60°发射角度的结果。
- en: We can already see that the 45° launch angle produces a greater range and that
    the 60° launch angle produces a greater maximum height. To be able to optimize
    these properties, we need to measure them from the trajectories.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以看到，45°的发射角度产生了更远的射程，而60°的发射角度产生了更高的最大高度。为了能够优化这些属性，我们需要从轨迹中测量它们。
- en: 12.1.2 Measuring properties of the trajectory
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 测量轨迹的属性
- en: 'It’s useful to keep the raw output of the trajectory in case we want to plot
    it, but sometimes we’ll want to focus on one number that matters most. For instance,
    the range of the projectile is the last *x*-coordinate of the trajectory, which
    is the last *x* position before the cannonball hits the ground. Here’s a function
    that takes the result of the `trajectory` function (parallel lists with time and
    the *x* and *z* positions), and extracts the range or landing position. For the
    input trajectory, `traj`, `traj[1]` lists the *x*-coordinates, and `traj[1][−1]`
    is the last entry in the list:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 保留轨迹的原始输出是有用的，以防我们想要绘制它，但有时我们可能只想关注一个最重要的数字。例如，抛射体的射程是轨迹的最后一个*x*坐标，这是炮弹击中地面之前的最后一个*x*位置。以下是一个函数，它接受`trajectory`函数的结果（包含时间和*x*和*z*位置的并行列表），并提取射程或着陆位置。对于输入轨迹`traj`，`traj[1]`列出*x*坐标，而`traj[1][−1]`是该列表的最后一个条目：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the main metric of a projectile’s trajectory that interests us, but
    we can also measure some other ones. For instance, we might want to know the hang
    time (or how long the cannonball stays in the air) or its maximum height. We can
    easily create other Python functions that measure these properties from simulated
    trajectories; for example,
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对抛射体轨迹感兴趣的主要指标，但我们也可以测量其他一些指标。例如，我们可能想知道悬停时间（或炮弹在空中停留的时间）或其最大高度。我们可以轻松创建其他Python函数，从模拟轨迹中测量这些属性；例如，
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Total time in the air is equal to the last time value, the time on the clock
    when the projectile hits the ground.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 空中总时间是最后一个时间值，即当抛射体击中地面时的时钟时间。
- en: ❷ The maximum height is the maximum among the z positions, the third list in
    the trajectory output.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 最大高度是z位置中的最大值，轨迹输出中的第三个列表。
- en: To find an optimal value for any of these metrics, we need to explore how the
    parameters (namely, the launch angle) affect them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这些指标中的任何一个找到最佳值，我们需要探索参数（即发射角度）如何影响它们。
- en: 12.1.3 Exploring different launch angles
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 探索不同的发射角度
- en: The `trajectory` function takes a launch angle and produces the full time and
    position data for the cannonball over its flight. A function like `landing_position`
    takes this data and produces a single number. Composing these two together (figure
    12.7), we get a function for landing position in terms of the launch angle, where
    all other properties of the simulation are assumed constant.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`trajectory`函数接受一个发射角度，并生成炮弹在飞行过程中的完整时间和位置数据。像`landing_position`这样的函数接受这些数据并生成一个单一数字。将这两个函数组合起来（如图12.7所示），我们得到一个关于发射角度的着陆位置函数，其中假设模拟的所有其他属性都是恒定的。'
- en: '![](../Images/CH12_F07_Orland.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F07_Orland.png)'
- en: Figure 12.7 Landing position as a function of the launch angle
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 发射角度作为着陆位置函数
- en: 'One way to test the effect of the launch angle on a landing position is to
    make a plot of the resulting landing position for several different values of
    the launch angle (figure 12.8). To do this, we need to calculate the result of
    the composition `landing_position (trajectory(theta))` for several different values
    of `theta` and pass these to Matplotlib’s `scatter` function. Here, for example,
    I use `range(0,95,5)` as the launch angles. This is every angle from zero to 90
    in increments of 5:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 测试发射角度对着陆位置影响的一种方法是为几个不同的发射角度绘制着陆位置的图（图12.8）。为此，我们需要计算`theta`的几个不同值的结果，并将这些值传递给Matplotlib的`scatter`函数。例如，我使用`range(0,95,5)`作为发射角度。这是从0到90度，以5度为增量：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/CH12_F08_Orland.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F08_Orland.png)'
- en: Figure 12.8 A plot of the landing position vs. the launch angle for the cannon
    for several different values of the launch angle
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 对于几个不同的发射角度，抛射物的着陆位置与发射角度的图
- en: From this plot, we can guess what the optimal value is. At a launch angle of
    45°, the landing position is maximized at a little over 40 meters from the launch
    position. In this case, 45° turns out to be the *exact* value of the angle that
    maximizes the landing position. In the next section, we’ll use calculus to confirm
    this maximum value without having to do any simulation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张图中，我们可以猜测最佳值是多少。在发射角度为45°时，着陆位置在发射位置40米多一点处达到最大。在这种情况下，45°恰好是使着陆位置最大化的角度的*确切*值。在下一节中，我们将使用微积分来确认这个最大值，而无需进行任何模拟。
- en: 12.1.4 Exercises
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.4 练习
- en: '| **Exercise 12.1**: How far does the cannonball go when fired at an angle
    of 50° from an initial height of zero? How about if it is fired at an angle of
    130°?**Solution**: At 50°, the cannonball goes about 40.1 meters in the positive
    direction, while at 130°, it goes 40.1 meters in the negative direction:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习12.1**：当从初始高度为零的角度为50°发射时，炮弹能飞多远？如果从130°发射呢？**解决方案**：在50°时，炮弹在正方向上大约飞行40.1米，而在130°时，它在负方向上飞行40.1米：'
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is because 130° from the positive x-axis is the same as 50° from the negative
    x-axis. |
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为从正x轴130°与从负x轴50°是相同的。|
- en: '| **Exercise 12.2-Mini Project**: Enhance the `plot_trajectories` function
    to draw a large dot on the trajectory graph at each passing second so we can see
    the passing of time on the plot.**Solution**: Here are the updates to the function.
    It looks for the index of the nearest time after each whole second and makes a
    scatter plot of (*x*, *z*) values at each of these indices:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习12.2-迷你项目**：增强`plot_trajectories`函数，以便在轨迹图上每个经过的秒数处绘制一个大的点，这样我们就可以在图上看到时间的流逝。**解决方案**：以下是函数的更新。它寻找每个整秒之后最近的索引，并在这些索引处绘制(*x*,
    *z*)值的散点图：'
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As a result, you can picture the elapsed time for each of the trajectories you
    plot; for example,
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以想象出你绘制的每个轨迹所经过的时间；例如，
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/CH12_F08_Orland_UN01.png)Plots of four trajectories with dots
    showing their positions at each whole number of seconds. |'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/CH12_F08_Orland_UN01.png)显示每个整数秒位置的四条轨迹图。|'
- en: '| **Exercise 12.3**: Make a scatter plot of hang time versus angle for angles
    between 0 and 180°. Which launch angle produces the maximum hang time?**Solution**:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习12.3**：绘制0°到180°之间角度的悬挂时间与角度的散点图。哪个发射角度产生了最大的悬挂时间？**解决方案**：'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/CH12_F08_Orland_UN02.png)A plot of the hang time of the cannonball
    as a function of the launch angle |'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../Images/CH12_F08_Orland_UN02.png)抛射物悬挂时间作为发射角度的函数的图 |'
- en: '| It appears that a launch angle of roughly 90° yields the longest hang time
    of just about 4 seconds. This makes sense because θ = 90° yields the initial velocity
    with the largest vertical component. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 看起来大约90°的发射角度产生了大约4秒的最长悬挂时间。这很有道理，因为θ = 90°提供了最大的垂直分量初始速度。|'
- en: '| **Exercise 12.4−Mini Project**: Write a function `plot_trajectory_metric`
    that plots the result of any metric we want over a given set of theta (θ) values.
    For instance,'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习12.4-迷你项目**：编写一个函数`plot_trajectory_metric`，该函数可以绘制我们想要在给定的theta（θ）值集上的任何度量结果。例如，'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'makes a scatter plot of landing positions versus launch angle for the launch
    angles 10°, 20°, and 30°.As a bonus, pass the keyword arguments from `plot_trajectory_metric`
    to the internal calls of the `trajectory` function, so you can rerun the test
    with a different simulation parameter. For instance, this code makes the same
    plot but simulated with a 10-meter initial launch height:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为发射角度 10°、20° 和 30° 绘制了着陆位置与发射角度的散点图。作为额外奖励，将 `plot_trajectory_metric` 函数的键值参数传递给
    `trajectory` 函数的内部调用，这样你可以使用不同的模拟参数重新运行测试。例如，以下代码使用 10 米的初始发射高度进行相同的绘图：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Solution**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**:'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can make the plot from the previous exercise by running the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码来制作之前练习中的图表：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 12.5−Mini Project**: What is the approximate launch angle that
    yields the greatest range for the cannonball with a 10-meter initial launch height?**Solution**:
    Using the `plot_trajectory_metric` function from the preceding mini-project, we
    can simply runplot_trajectory_metric(landing_position,range(0,90,5), height=10)![](../Images/CH12_F08_Orland_UN03.png)A
    plot of range of the cannonball vs. launch angle with a 10 meter launch heightThe
    optimal launch angle from a height of 10 meters is about 40°. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **练习 12.5-迷你项目**：对于初始发射高度为 10 米的炮弹，产生最大射程的大约发射角度是多少？**解答**：使用前面迷你项目中提供的 `plot_trajectory_metric`
    函数，我们可以简单地运行 `plot_trajectory_metric(landing_position,range(0,90,5), height=10)`！[](../Images/CH12_F08_Orland_UN03.png)炮弹射程与发射角度的图表，发射高度为
    10 米最佳发射角度大约为 40°。 |'
- en: 12.2 Calculating the optimal range
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 计算最佳射程
- en: Using calculus, we can compute the maximum range for the cannon, as well as
    the launch angle that produces it. This actually takes two separate applications
    of calculus. First, we need to come up with an exact function that tells us the
    range *r* as a function of the launch angle θ. As a warning, this will take quite
    a bit of algebra. I’ll carefully walk you through all the steps, so don’t worry
    if you get lost; you’ll be able to jump ahead to the final form of the function
    *r*(θ) and continue reading.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微积分，我们可以计算出大炮的最大射程以及产生该射程的发射角度。这实际上需要应用微积分两次。首先，我们需要找到一个精确的函数，它告诉我们射程 *r*
    是发射角度 θ 的函数。作为警告，这需要相当多的代数运算。我会仔细地引导你通过所有步骤，所以如果你感到困惑，不要担心；你将能够跳到函数 *r*(θ) 的最终形式并继续阅读。
- en: Then I show you a trick using derivatives to find the maximum value of this
    function *r*(θ), and the angle θ that produces it. Namely, a value of θ that makes
    the derivative *r*'(θ) equal zero is also the value of θ that yields the maximum
    value of *r*(θ). It might not be immediately obvious why this works, but it will
    become clear once we examine the graph of *r*(θ) and study its changing slope.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我将向你展示一个使用导数来找到该函数 *r*(θ) 的最大值以及产生该最大值的发射角度 θ 的技巧。也就是说，使导数 *r*'(θ) 等于零的 θ
    值也是产生 *r*(θ) 最大值的 θ 值。这可能不是立即显而易见的，但一旦我们检查 *r*(θ) 的图形并研究其变化斜率，它就会变得清晰。
- en: 12.2.1 Finding the projectile range as a function of the launch angle
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 将射程作为发射角度的函数找到
- en: The horizontal distance traveled by the cannonball is actually pretty simple
    to calculate. The *x* component of the velocity *v[x]* is constant for its entire
    flight. For a flight of total time Δ*t*, the projectile travels a total distance
    of *r* = *v[x]* · Δ*t*. The challenge is finding the exact value of that elapsed
    time Δ*t*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 炮弹飞行的水平距离实际上相当简单计算。速度 *v[x]* 的 *x* 分量在其整个飞行过程中是恒定的。对于总飞行时间 Δ*t*，弹丸飞行总距离为 *r*
    = *v[x]* · Δ*t*。挑战在于找到那个经过时间 Δ*t* 的确切值。
- en: That time, in turn, depends on the *z* position of the projectile over time,
    which is a function *z*(*t*). Assuming the cannonball is launched from an initial
    height of zero, the first time that *z*(*t*) = 0 is when it’s launched at *t*
    = 0\. The second time is the elapsed time we’re looking for. Figure 12.9 shows
    the graph of *z*(*t*) from the simulation with θ = 45°. Note that its shape looks
    a lot like the trajectory, but the horizontal axis (*t*) now represents time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 那次，反过来，取决于弹丸随时间变化的 *z* 位置，这是一个函数 *z*(*t*)。假设炮弹是从初始高度为零发射的，那么 *z*(*t*) = 0 的第一次是它在
    *t* = 0 时发射。第二次是我们要找的经过时间。图 12.9 显示了 θ = 45° 的模拟中 *z*(*t*) 的图形。注意，它的形状看起来非常像轨迹，但现在水平轴
    (*t*) 代表时间。
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/CH12_F09_Orland.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F09_Orland.png)'
- en: Figure 12.9 A plot of z(*t*) for the projectile showing the launching and landing
    times where z = 0\. We can see from the graph that the elapsed time is about 2.9
    seconds.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 抛体z(*t*)的图像，显示了发射和着陆时间，其中z = 0。我们可以从图中看到经过的时间大约是2.9秒。
- en: 'We know *z* ''''(*t*) = *g* = −9.81, which is the acceleration due to gravity.
    We also know the initial *z* velocity, *z*''(0) = |***v***| · sin(θ), and the
    initial *z* position, *z*(0) = 0\. To recover the position function *z*(*t*),
    we need to integrate the acceleration *z* ''''(*t*) twice. The first integral
    gives us velocity:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道*z* ''(*t*) = *g* = −9.81，这是重力加速度。我们还知道初始*z*速度*z*'(0) = |***v***| · sin(θ)和初始*z*位置*z*(0)
    = 0。为了恢复位置函数*z*(*t*)，我们需要对加速度*z* ''(*t*)进行两次积分。第一次积分给出了速度：
- en: '![](../Images/CH12_F09_Orland_EQ01.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F09_Orland_EQ01.png)'
- en: 'The second integral gives us position:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个积分给出了位置：
- en: '![](../Images/CH12_F09_Orland_EQ02.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F09_Orland_EQ02.png)'
- en: We can confirm that this formula matches the simulation by plotting it (figure
    12.10). It is nearly indistinguishable from the simulation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过绘制它（图12.10）来确认这个公式与模拟相匹配。它与模拟几乎无法区分。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ A direct translation of the result of the integral, z(*t*), into Python code
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将积分结果z(*t*)直接转换为Python代码
- en: '![](../Images/CH12_F10_Orland.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F10_Orland.png)'
- en: Figure 12.10 Plotting the exact function z(*t*) on top of the simulated values
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 在模拟值上方绘制精确函数z(*t*)的图像
- en: 'For notational simplicity, let’s write the initial velocity |***v***| · sin(θ)
    as *v[z]* so that *z*(*t*) = *v[z]t* + *gt*²/2\. We want to find the value of
    *t* that makes *z*(*t*) = 0, which is the total hang time for the cannonball.
    You may remember how to find that value from high school algebra, but if not,
    let me remind you quickly. If you want to know what value of *t* solves an equation
    *at*² + *bt* + *c* = 0, all you have to do is plug the values *a*, *b*, and *c*
    into the *quadratic formula* :'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符号简单，让我们将初始速度|***v***| · sin(θ)写成*v[z]*，这样*z*(*t*) = *v[z]t* + *gt*²/2。我们想要找到使*z*(*t*)
    = 0的*t*值，这是炮弹的总悬挂时间。你可能记得如何从高中代数中找到这个值，但如果忘记了，让我快速提醒你。如果你想知道什么值的*t*可以解方程*at*²
    + *bt* + *c* = 0，你只需要将值*a*，*b*和*c*代入*二次公式*：
- en: '![](../Images/CH12_F10_Orland_EQ03.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F10_Orland_EQ03.png)'
- en: An equation like *at*² + *bt* + *c* = 0 can be satisfied twice; both times when
    our projectile hits *z* = 0\. The symbol ± is shorthand to let you know that using
    a + or − at this point in the equation gives you two different (but valid) answers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 方程*at*² + *bt* + *c* = 0可以满足两次；两次都是当我们的抛体击中*z* = 0时。符号±是简写，让你知道在这个方程的这个点使用+或−会得到两个不同的（但有效的）答案。
- en: In the case of solving *z*(*t*) = *v[z]t* + *gt*²/2 = 0, we have *a* = *g*/2,
    *b* = *v[z]* and *c* = 0\. Plugging into the formula, we find
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在解*z*(*t*) = *v[z]t* + *gt*²/2 = 0的情况下，我们有*a* = *g*/2，*b* = *v[z]*和*c* = 0。将它们代入公式，我们得到
- en: '![](../Images/CH12_F10_Orland_EQ04.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F10_Orland_EQ04.png)'
- en: Treating the ± symbol as a + (plus), the result is *t* = (− *v[z]* + *v[z]*)/*g*
    = 0\. This says that *z* = 0 when *t* = 0, which is a good sanity check; it confirms
    that the cannonball starts at *z* = 0\. The interesting solution is when we treat
    ± as a − (minus). In this case, the result is *t* = (− *v[z]* − *v[z]*)/*g* =
    −2*v[z]*/*g*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将±符号视为+（加号），结果是*t* = (− *v[z]* + *v[z]*)/*g* = 0。这意味着*z* = 0当*t* = 0时，这是一个很好的合理性检查；它证实了炮弹从*z*
    = 0开始。有趣的是，当我们把±视为−（减号）时。在这种情况下，结果是*t* = (− *v[z]* − *v[z]*)/*g* = −2*v[z]*/*g*。
- en: Let’s confirm the result makes sense. With an initial speed of 20 meters per
    second and a launch angle of 45° as we used in the simulation, the initial *z*
    velocity, *v[z]*, is −2 · (20 · sin(45°))/−9.81 ¼ 2.88\. This closely matches
    the result of 2.9 seconds that we read from the graph.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认结果是有意义的。以20米/秒的初始速度和45°的发射角度（我们在模拟中使用），初始*z*速度*v[z]*是−2 · (20 · sin(45°))/−9.81
    ¼ 2.88。这接近我们从图中读取的2.9秒的结果。
- en: This gives us confidence in calculating the hang time Δ*t* as Δ*t* = −2*v[z]*/*g*
    or Δ*t* = −2|***v***|sin(θ)/*g*. Because the range is *r* = *v[x]* · Δ*t* = |***v***|cos(θ)
    · Δ*t*, the full expression for the range *r* as a function of the launch angle
    θ is
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们相信计算悬挂时间Δ*t*为Δ*t* = −2*v[z]*/*g*或Δ*t* = −2|***v***|sin(θ)/*g*。因为射程*r* =
    *v[x]* · Δ*t* = |***v***|cos(θ) · Δ*t*，所以射程*r*作为发射角度θ的函数的完整表达式是
- en: '![](../Images/CH12_F10_Orland_EQ05.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F10_Orland_EQ05.png)'
- en: We can plot this side by side with the simulated landing positions at various
    angles as in figure 12.11 and see that it agrees.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其与图12.11中各种角度的模拟着陆位置并排绘制，并看到它们是一致的。
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../Images/CH12_F11_Orland.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F11_Orland.png)'
- en: Figure 12.11 Our calculation of projectile range as a function of the launch
    angle *r*(θ), which matches our simulated landing positions
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 我们将射程作为发射角度*r*(θ)的函数的计算，这与我们的模拟着陆位置相匹配
- en: Having a function *r*(θ) is a big advantage over repeatedly running the simulator.
    First of all, it tells us the range of the cannon at *every* launch angle, not
    just a handful of angles that we simulated. Second, it is much less computationally
    expensive to evaluate this one function than to run hundreds of iterations of
    Euler’s method. For more complicated simulations, this could make a big difference.
    Additionally, this function gives us the exact result rather than an approximation.
    The final benefit, which we’ll make use of next, is that the function *r*(θ) is
    smooth, so we can take its derivatives. This gives us an understanding of how
    the range of the projectile changes with respect to the launch angle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有*r*(θ)函数比反复运行模拟器有很大的优势。首先，它告诉我们大炮在*每个*发射角度的射程，而不仅仅是我们在模拟中模拟的一小部分角度。其次，评估这个函数比运行数百次欧拉方法的迭代要计算成本低得多。对于更复杂的模拟，这可能会产生很大的差异。此外，这个函数给出了确切的结果而不是近似值。下一个我们将利用的最终好处是，函数*r*(θ)是平滑的，因此我们可以求它的导数。这让我们了解了射程如何随着发射角度的变化而变化。
- en: 12.2.2 Solving for the maximum range
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 求最大射程
- en: Looking at the graph of *r*(θ) in figure 12.12, we can set our expectations
    for what the derivative *r*'(θ) will look like. As we increase the launch angle
    from zero, the range increases as well for a while but at a decreasing rate. Eventually,
    increasing the launch angle begins to decrease the range.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图12.12中*r*(θ)的图像，我们可以设定对导数*r*'(θ)的预期。随着发射角度从零增加，射程在一段时间内也会增加，但增加的速率在减小。最终，增加发射角度开始减少射程。
- en: The key observation to make is that while *r*'(θ) is positive, the range is
    increasing with respect to θ. Then the derivative *r*'(θ) crosses below zero,
    and the range decreases from there. It is precisely at this angle (where the derivative
    is zero) that the function *r*(θ) achieves its maximum value. You can visualize
    this by seeing that the graph of *r*(θ) in figure 12.12 hits its maximum when
    the slope of the graph is zero.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的观察是，当*r*'(θ)为正时，射程相对于θ是增加的。然后导数*r*'(θ)穿过零点，射程从那里开始减少。正是在这个角度（导数为零的地方），函数*r*(θ)达到了它的最大值。你可以通过观察图12.12中*r*(θ)的图像在斜率为零时达到最大值来可视化这一点。
- en: '![](../Images/CH12_F12_Orland.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F12_Orland.png)'
- en: Figure 12.12 The graph of *r*(θ) hits its maximum when the derivative is zero
    and, therefore, the slope of the graph is zero.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 *r*(θ)的图像在导数为零时达到最大值，因此图像的斜率为零。
- en: We should be able to take the derivative of *r*(θ) symbolically, find where
    it equals zero between 0° and 90°, and this should agree with the rough maximum
    value of 45°. Remember that the formula for *r* is
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够对*r*(θ)进行符号求导，找到它在0°到90°之间等于零的位置，并且这应该与45°的大致最大值一致。记住*r*的公式是
- en: '![](../Images/CH12_F12_Orland_EQ06.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F12_Orland_EQ06.png)'
- en: Because −2|***v***|²/*g* is constant with respect to θ, the only hard work is
    using the product rule on sin(θ)cos(θ). The result is
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为与θ无关的-2|***v***|²/*g*是常数，所以唯一困难的工作就是使用乘积法则对sin(θ)cos(θ)进行求导。结果是
- en: '![](../Images/CH12_F12_Orland_EQ07.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F12_Orland_EQ07.png)'
- en: Notice that I factored out the minus sign. If you haven’t seen this notation
    before, sin²(θ) means (sin(θ))². The value of the derivative *r*'(θ) is zero when
    the expression sin²(θ) − cos²(θ) is zero (in other words, we can ignore the constants).
    There are a few ways to figure out where this expression is zero, but a particularly
    nice one is to use the trigonometric identity, cos(2θ) = cos²(θ) − sin²(θ), which
    reduces our problem even further. Now we need to figure out where cos(2θ) = 0.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我已经提取了负号。如果你以前没有见过这种符号，sin²(θ)意味着(sin(θ))²。当表达式sin²(θ) − cos²(θ)为零时（换句话说，我们可以忽略常数），导数*r*'(θ)的值为零。有几种方法可以找出这个表达式在哪里为零，但特别好的一个方法是使用三角恒等式，cos(2θ)
    = cos²(θ) − sin²(θ)，这进一步简化了我们的问题。现在我们需要找出cos(2θ) = 0的位置。
- en: 'The cosine function is zero at *π*/2 plus any multiple of *π*, or 90° plus
    any multiple of 180° (that is, 90°, 270°, 430°, and so on). If 2θ is equal to
    these values, θ could be half of any of these values: 45°, 135°, 215°, and so
    on.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 余弦函数在*π*/2加上任何*π*的倍数时为零，或者90°加上任何180°的倍数（即90°，270°，430°等等）。如果2θ等于这些值，θ可以是这些值的一半：45°，135°，215°等等。
- en: Of these, there are two interesting results. First, θ = 45° is the solution
    between θ = 0 and θ = 90°, so it is both the solution we expected and the solution
    we’re looking for! The second interesting solution is 135° because this is the
    same as shooting the cannonball at 45° in the opposite direction (figure 12.13).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些结果中，有两个有趣的结果。首先，θ = 45° 是 θ = 0 和 θ = 90° 之间的解，因此它既是我们所期望的解，也是我们正在寻找的解！第二个有趣解是
    135°，因为这与以 45° 的角度向相反方向射击炮弹相同（图12.13）。
- en: '![](../Images/CH12_F13_Orland.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F13_Orland.png)'
- en: Figure 12.13 In our model, shooting the cannonball at 135° is like shooting
    at 45° in the opposite direction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 在我们的模型中，以 135° 的角度射击炮弹就像以 45° 的角度向相反方向射击。
- en: At angles of 45° and 135°, the resulting ranges are
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 45° 和 135° 的角度下，得到的射程是
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It turns out that these are the extremes of where the cannonball can end up,
    with all other parameters equal. A launch angle of 45° produces the maximum landing
    position, while a launch angle of 135° produces the minimum landing position.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，这些是炮弹可能到达的极限位置，其他参数都相等。以 45° 的发射角度产生最大的着陆位置，而以 135° 的发射角度产生最小的着陆位置。
- en: 12.2.3 Identifying maxima and minima
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 识别极大值和极小值
- en: To see the difference between the maximum range at 45° and the minimum range
    at 135°, we can extend the plot of *r*(θ). Remember, we found both of these angles
    because they were at places where the derivative *r*'(θ) was zero (figure 12.14).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分 45° 的最大射程和 135° 的最小射程，我们可以扩展 *r*(θ) 的图。记住，我们找到这两个角度是因为它们是在导数 *r*'(θ) 为零的地方（图12.14）。
- en: '![](../Images/CH12_F14_Orland.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F14_Orland.png)'
- en: Figure 12.14 The angles θ = 45° and θ = 135° are the two values between 0 and
    180 where r'(θ) = 0.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 θ = 45° 和 θ = 135° 是在 0 和 180 之间，r'(θ) = 0 的两个值。
- en: While *maxima*(the plural of “maximum”) of smooth functions occur where the
    derivative is zero, the converse is not always true; not every place where the
    derivative is zero yields a maximum value. As we see in figure 12.14 at θ = 135°,
    it can also yield a *minimum* value of a function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然平滑函数的极大值出现在导数为零的地方，但反过来不一定成立；导数为零的每个地方不一定产生最大值。正如我们在图12.14中看到的那样，在 θ = 135°
    处，它也可以产生函数的 *最小* 值。
- en: 'You need to be cautious of the global behavior of functions as well, because
    the derivative can be zero at what’s called a *local* maximum or minimum, where
    the function briefly obtains a maximum or minimum value, but it’s real, *global*
    maximum or minimum values lie elsewhere. Figure 12.15 shows a classic example:
    *y* = *x*³ − *x*. Zooming in on the region where −1 < *x* < 1, there are two places
    where the derivative is zero, which look like a maximum and minimum, respectively.
    When you zoom out, you see that neither of these is the maximum or minimum value
    for the whole function because it goes off to infinity in both directions.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要注意函数的全局行为，因为导数可以在所谓的 *局部* 极大值或极小值处为零，函数在短时间内获得最大值或最小值，但它的真实，*全局* 最大值或最小值可能位于其他地方。图12.15显示了一个经典例子：*y*
    = *x*³ − *x*。在 −1 < *x* < 1 的区域内放大，有两个导数为零的地方，分别看起来像最大值和最小值。当你放大时，你会看到这两个都不是整个函数的最大值或最小值，因为它在两个方向上都趋向于无穷大。
- en: '![](../Images/CH12_F15_Orland.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F15_Orland.png)'
- en: Figure 12.15 Two points that are a local minimum and local maximum, but neither
    is the minimum or maximum value for the function
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 两个局部最小值和局部最大值，但都不是函数的最小值或最大值
- en: As another confounding possibility, a point where the derivative is zero may
    not even be a local minimum or maximum. For instance, the function *y* = *x*³
    has a derivative of zero at *x* = 0 (figure 12.16). This point just happens to
    be a place where the function *x*³ stops increasing momentarily.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一种令人困惑的可能性，导数为零的点甚至可能不是局部最小值或最大值。例如，函数 *y* = *x*³ 在 *x* = 0 处导数为零（图12.16）。这个点恰好是函数
    *x*³ 短暂停止增加的地方。
- en: '![](../Images/CH12_F16_Orland.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F16_Orland.png)'
- en: Figure 12.16 For *y* = *x*³, the derivative is zero at *x* = 0, but this is
    not a minimum or maximum value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 对于 *y* = *x*³，导数在 *x* = 0 处为零，但这不是最小值或最大值。
- en: I won’t go into the technicalities of telling whether a point with a zero derivative
    is a minimum, maximum, or neither, or how to distinguish local minima and maxima
    from global ones. The key idea is that you need to fully understand the behavior
    of a function before you can confidently say you’ve found an optimal value. With
    this in mind, let’s move on to some more complicated functions to optimize and
    some new techniques for optimizing them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入讲解如何判断一个导数为零的点是最小值、最大值还是都不是，或者如何区分局部最小值和最大值与全局最小值和最大值。关键思想是，在自信地说你已经找到了最优值之前，你需要完全理解函数的行为。有了这个想法，让我们继续探讨一些更复杂的函数优化以及一些新的优化技术。
- en: 12.2.4 Exercises
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 练习
- en: '| **Exercise 12.6**: Use the formula for elapsed time, Δ*t*, in terms of the
    launch angle θ to find the angle that maximizes the hang time of the cannonball.**Solution**:
    The time in the air is *t* = 2*v[z]*/*g* = 2*v* sin(θ)/*g* where the initial speed
    of the cannonball is *v* = &#124;***v***&#124;. This is maximized when sin(θ)
    is maximized. We don’t need calculus for this; the maximum value of sin(θ) for
    0 ≤ θ ≤ 180° occurs at θ = 90°. In other words, with all other parameters constant,
    the cannonball stays in the air longest when fired directly upward. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **练习 12.6**：使用关于发射角度θ的经过时间Δ*t*公式，找出使炮弹悬停时间最大的角度。**解答**：在空中的时间是 *t* = 2*v[z]*/*g*
    = 2*v* sin(θ)/*g*，其中炮弹的初始速度是 *v* = &#124;***v***&#124;。当sin(θ)最大时，这个值达到最大。我们不需要微积分来做这个；对于0
    ≤ θ ≤ 180°，sin(θ)的最大值发生在θ = 90°。换句话说，当所有其他参数保持不变时，炮弹直接向上发射时悬停时间最长。|'
- en: '| **Exercise 12.7**: Confirm that the derivative of sin(*x*) is zero at *x*
    = 11*π*/2\. Is this a maximum or minimum value of sin(*x*)?**Solution**: The derivative
    of sin(*x*) is cos(*x*), and![](../Images/CH12_F16_Orland_EQ08.png)so the derivative
    of sin(*x*) is indeed zero at *x* = 11*π*/2\. Because sin(11*π*/2) = sin(3*π*/2)
    = −1 and the sine function ranges between −1 and 1, we can be sure this is a local
    maximum. Here’s a plot of sin(*x*) to confirm that:![](../Images/CH12_F16_Orland_UN04.png)
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **练习 12.7**：确认sin(*x*)在*x* = 11*π*/2处的导数为零。这是sin(*x*)的最大值还是最小值？**解答**：sin(*x*)的导数是cos(*x*)，因此sin(*x*)在*x*
    = 11*π*/2处的导数确实是零。因为sin(11*π*/2) = sin(3*π*/2) = −1，且正弦函数的范围在−1和1之间，我们可以确定这是一个局部最大值。以下是sin(*x*)的图像，以确认这一点：![](../Images/CH12_F16_Orland_EQ08.png)
    |'
- en: '| **Exercise 12.8**: Where does *f*(*x*) = *x*³ − *x* have its local maximum
    and minimum values? What are the values?**Solution**: You can see from plotting
    the function that *f*(*x*) hits a local minimum value at some *x* > 0 and a local
    maximum value at some *x* < 0\. Let’s find these two points.The derivative is
    *f*''(*x*) = 3*x*² − 1, so we want to find where 3*x*² − 1 = 0\. We could use
    the quadratic formula to solve for *x*, but it’s simple enough to eyeball a solution.
    If 3*x*² − 1 = 0 then *x*² = 1/3, so *x* = −1/ or *x* = 1/. These are the *x*
    values where *f*(*x*) hits its local minimum and maximum values.The local maximum
    value is![](../Images/CH12_F16_Orland_UN04_EQ09.png)and the local minimum value
    is![](../Images/CH12_F16_Orland_UN04_EQ10.png) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **练习 12.8**：函数*f*(*x*) = *x*³ − *x*的局部最大值和最小值在哪里？这些值是多少？**解答**：从函数的图像中可以看出，*f*(*x*)在某个*x*
    > 0处达到局部最小值，在某个*x* < 0处达到局部最大值。让我们找到这两个点。导数是*f*''(*x*) = 3*x*² − 1，因此我们想要找到3*x*²
    − 1 = 0的地方。我们可以使用二次公式来解*x*，但这足够简单，可以直观地找到解。如果3*x*² − 1 = 0，那么*x*² = 1/3，所以*x*
    = −1/ 或 *x* = 1/。这些是*f*(*x*)达到局部最小值和最大值的*x*值。局部最大值是![](../Images/CH12_F16_Orland_UN04_EQ09.png)，局部最小值是![](../Images/CH12_F16_Orland_UN04_EQ10.png)。|'
- en: '| **Exercise 12.9−Mini Project**: The graph of a quadratic function *q*(*x*)
    = *ax*² + *bx* + *c* with *a* ≠ 0 is a *parabola*, an arch shape that either has
    a single maximum value or a single minimum value. Based on the numbers *a*, *b*,
    and *c*, what is the *x* value where *q*(*x*) is maximized or minimized? How can
    you tell if this point is a minimum or maximum?**Solution**: The derivative *q*''(*x*)
    is given by 2*ax* + *b*. This is zero when *x* =- *b*/2*a*.If *a* is positive,
    the derivative starts negative at some low *x* value, then hits zero at *x* =
    − *b*/2*a* and is positive from then on. That means *q* is decreasing before *x*
    = − *b*/2*a* and increasing thereafter; this describes a *minimum* value of *q*(*x*).You
    can tell the opposite story if *a* is negative. Therefore, *x* = − *b*/2*a* is
    a minimum value of *q*(*x*) if *a* is positive and a maximum value if *a* is negative.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **练习12.9-迷你项目**：二次函数*q*(*x*) = *ax*² + *bx* + *c*（*a* ≠ 0）的图像是一个*抛物线*，一个具有单一最大值或单一最小值的拱形。根据数字*a*、*b*和*c*，*q*(*x*)在何处达到最大值或最小值？如何判断这个点是最大值还是最小值？**解答**：导数*q*''(*x*)由2*ax*
    + *b*给出。当*x* = - *b*/2*a*时，导数为零。如果*a*是正的，导数在某个低的*x*值开始为负，然后在*x* = - *b*/2*a*时达到零，之后为正。这意味着*q*在*x*
    = - *b*/2*a*之前是递减的，之后是递增的；这描述了*q*(*x*)的*最小值*。如果*a*是负的，你可以讲述相反的故事。因此，如果*a*是正的，*x*
    = - *b*/2*a*是*q*(*x*)的*最小值*；如果*a*是负的，它是*最大值*。|'
- en: 12.3 Enhancing our simulation
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 增强我们的模拟
- en: 'As your simulator becomes more complicated, there can be multiple parameters
    governing its behavior. For our original cannon, the launch angle θ was the only
    parameter we were playing with. To optimize the range of the cannon, we worked
    with a function of one variable: *r*(θ). In this section, we’ll make our cannon
    fire in 3D, meaning that we need to vary two launch angles as parameters to optimize
    the range of the cannonball.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的模拟器变得越来越复杂，可能会有多个参数控制其行为。对于我们的原始大炮，发射角度θ是我们唯一操作的参数。为了优化大炮的射程，我们与一个一元函数*r*(θ)一起工作。在本节中，我们将使大炮在3D中发射，这意味着我们需要改变两个发射角度作为参数来优化炮弹的射程。
- en: 12.3.1 Adding another dimension
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 添加另一个维度
- en: The first thing is to add a *y* dimension to our simulation. We can now picture
    the cannon sitting at the origin of the *x*,*y* plane, shooting the cannonball
    up into the *z* direction at some angle θ. In this version of the simulator, you
    can control the angle θ as well as a second angle, which we’ll call φ (the Greek
    letter phi). This measures how far the cannon is rotated laterally from the +*x*
    direction (figure 12.17).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是为我们的模拟添加一个*y*维度。现在我们可以想象大炮坐在*x*、*y*平面的原点，以某个角度θ将炮弹射向*z*方向。在这个版本的模拟器中，你可以控制角度θ以及第二个角度，我们将称之为φ（希腊字母phi）。这衡量了大炮从+*x*方向横向旋转的距离（图12.17）。
- en: '![](../Images/CH12_F17_Orland.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F17_Orland.png)'
- en: Figure 12.17 Picturing the cannon firing in 3D. Two angles θ and ϕ determine
    the direction the cannon is fired.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 3D展示大炮发射。两个角度θ和ϕ决定了大炮发射的方向。
- en: 'To simulate the cannon in 3D, we need to add motion in the *y* direction. The
    physics in the *z* direction remains exactly the same, but the horizontal velocity
    is split between the *x* and *y* direction, depending on the value of the angle
    φ. Whereas the previous *x* component of the initial velocity was *v[x]* = |***v***|cos(θ),
    it’s now scaled by a factor of cos(φ) to give *v[x]* = |***v***|cos(θ)cos(φ).
    The *y* component of initial velocity is *v[y]* = |***v***|cos(θ)sin(φ). Because
    gravity doesn’t act in the *y* direction, we don’t have to update *v[y]* over
    the course of the simulation. Here’s the updated trajectory function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在3D中模拟大炮，我们需要在*y*方向上添加运动。在*z*方向上的物理保持完全相同，但水平速度在*x*和*y*方向上根据角度φ的值进行分配。而之前初始速度的*x*分量是*v[x]*
    = |***v***|cos(θ)，现在它乘以一个因子cos(φ)，给出*v[x]* = |***v***|cos(θ)cos(φ)。初始速度的*y*分量是*v[y]*
    = |***v***|cos(θ)sin(φ)。因为重力在*y*方向上不起作用，我们不需要在模拟过程中更新*v[y]*。以下是更新的轨迹函数：
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ The lateral angle ϕ is the input parameter of the simulation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 横向角度ϕ是模拟的输入参数。
- en: ❷ Calculates the initial y velocity
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算初始y速度
- en: ❸ Stores the values of time and the x, y, and z positions throughout the simulation
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在整个模拟过程中存储时间以及x、y和z位置值
- en: ❹ Updates the y position in each iteration
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在每次迭代中更新y位置
- en: If this simulation is successful, we don’t expect it to change the angle θ that
    yields the maximum range. Whether you fire a projectile at 45° above the horizontal
    in the +*x* direction, the − *x* direction, or any other direction in the plane,
    the projectile should go the same distance. That is to say that φ doesn’t affect
    the distance traveled. Next, we add the terrain with a variable elevation around
    the launch point so the distance traveled changes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个模拟成功，我们预计它不会改变产生最大射程的角度 θ。无论你在 +*x* 方向上方 45° 水平发射弹丸，还是在 − *x* 方向上方 45° 水平发射，或者在任何其他平面上方发射，弹丸应该飞行相同的距离。也就是说，φ
    不影响飞行的距离。接下来，我们在发射点周围添加具有可变高度的地形，这样飞行的距离就会改变。
- en: 12.3.2 Modeling terrain around the cannon
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 建模大炮周围的地形
- en: Hills and valleys around the cannon mean that its shots can stay in the air
    for different durations depending on where they’re aimed. We can model the elevation
    above or below the plane *z* = 0 by a function that returns a number for every
    (*x*,*y*) point. For instance,
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 大炮周围的山丘和山谷意味着其射击的持续时间会根据射击方向的不同而不同。我们可以通过一个函数来模拟 *z* = 0 平面以上或以下的高度，该函数为每个 (*x*,*y*)
    点返回一个数字。例如，
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'represents flat ground, where the elevation at every (*x*,*y*) point is zero.
    Another function we’ll use is a ridge between two valleys:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表示平坦地面，其中每个 (*x*,*y*) 点的高度为零。我们将使用的另一个函数是两个山谷之间的山脊：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On this ridge, the ground slopes upward from the origin in the positive and
    negative *x* directions, and it slopes downward in the positive and negative *y*
    directions. (You can plot the cross sections of this function at *x* = 0 and *y*
    = 0 to confirm this.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个山脊上，地面从原点向正负 *x* 方向上升，向正负 *y* 方向下降。 (您可以在 *x* = 0 和 *y* = 0 处绘制该函数的横截面来确认这一点。)
- en: 'Whether we want to simulate the projectile on flat ground or on the ridge,
    we have to adapt the `trajectory3d` function to terminate when the projectile
    hits the ground, not just when its altitude is zero. To do this, we can pass the
    elevation function defining the terrain as a keyword argument, defaulting to flat
    ground, and revise the test for whether the projectile is above ground. Here are
    the changed lines in the function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们是要模拟平坦地面上的弹丸还是山脊上的弹丸，我们都必须调整 `trajectory3d` 函数，使其在弹丸击中地面时终止，而不仅仅是当其高度为零时。为此，我们可以传递定义地形的
    elevation 函数作为关键字参数，默认为平坦地面，并修改测试弹丸是否在地面以上的条件。以下是函数中更改的行：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the source code, I also provide a function called `plot_trajectories_3d,`
    which plots the result of `trajectory3D` as well as the specified terrain. To
    confirm our simulation works, we see the trajectory end below *z* = 0 when the
    cannonball is fired downhill and above *z* = 0 when it is fired uphill (figure
    12.18):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，我还提供了一个名为 `plot_trajectories_3d` 的函数，它绘制了 `trajectory3D` 的结果以及指定的地形。为了确认我们的模拟工作正常，我们看到当炮弹从下山发射时，轨迹在
    *z* = 0 以下结束，而当它从上山发射时，轨迹在 *z* = 0 以上结束（图 12.18）：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](../Images/CH12_F18_Orland.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F18_Orland.png)'
- en: Figure 12.18 A projectile fired downhill lands below z = 0 and a projectile
    fired uphill lands above z = 0.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18 向下发射的弹丸在 z = 0 以下着陆，向上发射的弹丸在 z = 0 以上着陆。
- en: If you had to guess, it seems reasonable that the maximum range for the cannon
    is attained in the downhill direction rather than the uphill direction. On its
    way down, the cannonball has further to fall, taking more time and allowing it
    to travel further. It’s not clear if the vertical angle θ will yield the optimal
    range because our calculation of 45° made the assumption that the ground was flat.
    To answer this question, we need to write the range *r* of the projectile as a
    function of θ and φ.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须猜测，大炮的最大射程似乎是在下山方向而不是上山方向达到的。在下山的过程中，炮弹有更长的下落距离，需要更多的时间，这允许它飞得更远。由于我们的
    45° 计算假设地面是平坦的，所以不清楚垂直角度 θ 是否会产生最佳射程。为了回答这个问题，我们需要将弹丸的射程 *r* 写成 θ 和 φ 的函数。
- en: 12.3.3 Solving for the range of the projectile in 3D
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.3 在 3D 中求解弹丸的射程
- en: Even though the cannonball is fired in 3D space in our latest simulation, its
    trajectory lies in a vertical plane. As such, given an angle φ, we only need to
    work with the slice of the terrain in the direction the cannonball is fired. For
    instance, if the cannonball is fired at an angle φ = 240°, we only need to think
    about terrain values when (*x*, *y*) lies along a line at 240° from the origin.
    This is like thinking about the elevation of the terrain only at the points in
    the shadow cast by the trajectory (figure 12.19).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们的最新模拟中炮弹是在三维空间中发射的，但其轨迹位于一个垂直平面内。因此，给定一个角度 φ，我们只需要处理炮弹发射方向的地形切片。例如，如果炮弹以角度
    φ = 240° 发射，我们只需要考虑当 (*x*, *y*) 沿着从原点出发的 240° 线时地形值。这就像只考虑轨迹投射下的地形高程点（图 12.19）。
- en: '![](../Images/CH12_F19_Orland.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH12_F19_Orland.png)'
- en: Figure 12.19 We only need to think about the elevation of the terrain in the
    plane where the projectile is fired. This is where the shadow of the trajectory
    is cast.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19 我们只需要考虑投体发射平面上的地形高程。这就是轨迹阴影投射的地方。
- en: Our goal is to do all of our calculations in the plane of the shadow’s trajectory,
    working with the distance *d* from the origin in the *x*,*y* plane as our coordinate,
    rather than *x* and *y* themselves. At some distance, the trajectory of the cannonball
    and the elevation of the terrain will have the same *z* value, which is where
    the cannonball stops. This distance is the range that we want to find an expression
    for.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在阴影轨迹的平面内进行所有计算，以从原点到 *x*, *y* 平面的距离 *d* 作为我们的坐标，而不是 *x* 和 *y* 本身。在某个距离处，炮弹的轨迹和地面的高程将具有相同的
    *z* 值，这就是炮弹停止的地方。这个距离是我们想要找到一个表达式的射程。
- en: Let’s keep calling the height of the projectile *z*. As a function of time,
    the height is exactly the same as in our 2D example
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续称投体的高度为 *z*。作为时间的函数，高度与我们的二维示例完全相同
- en: '![](../Images/CH12_F19_Orland_EQ11.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH12_F19_Orland_EQ11.png)'
- en: where *v[z]* is the *z* component of the initial velocity. The *x* and *y* positions
    are also given as simple functions of time *x*(*t*) = *v[x]t* and *y*(*t*) = *v[y]t*
    because no forces act in the *x* or *y* direction.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *v[z]* 是初始速度的 *z* 分量。*x* 和 *y* 位置也作为时间 *t* 的简单函数给出，*x*(*t*) = *v[x]t* 和 *y*(*t*)
    = *v[y]t*，因为 *x* 或 *y* 方向上没有作用力。
- en: On the ridge, the elevation is given as a function of the *x*, *y* position
    by (*x*² − 5*y*²)/2500\. We can write this elevation as *h*(*x*, *y*) = *B[x]*²
    − *C[y]*² where *B* = 1/2500 = 0.0004 and *C* = 5/2500 = 0.002\. It’s useful to
    know the elevation of the terrain directly under the projectile at a given time
    *t*, which we can call *h*(*t*). We can calculate the value of *h* under the projectile
    at any point in time *t* because the projectile’s *x* and *y* positions are given
    by *v[x]t* and *v[y]t*, and the elevation at the same (*x*, *y*) point will be
    *h*(*v[x]t*, *v[y]t*) = *Bv[x]*² *t*² − *Cv[y]*² *t*².
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在脊上，高程是作为 *x*, *y* 位置的函数给出的，公式为 (*x*² − 5*y*²)/2500。我们可以将这个高程写成 *h*(*x*, *y*)
    = *B[x]*² − *C[y]*²，其中 *B* = 1/2500 = 0.0004 和 *C* = 5/2500 = 0.002。知道在给定时间 *t*
    投体正下方的地形高程是有用的，我们可以称之为 *h*(*t*)。我们可以在任何时间 *t* 计算投体下方的 *h* 值，因为投体的 *x* 和 *y* 位置由
    *v[x]t* 和 *v[y]t* 给出，并且在相同的 (*x*, *y*) 点上的高程将是 *h*(*v[x]t*, *v[y]t*) = *Bv[x]*²
    *t*² − *Cv[y]*² *t*²。
- en: 'The altitude of the projectile above the ground at a time *t* is the difference
    between *z*(*t*) and *h*(*t*). The time of impact is the time when this difference
    is zero, that is *z*(*t*) − *h*(*t*) = 0\. We can expand that condition in terms
    of the definitions of *z*(*t*) and *h*(*t*):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 投体在时间 *t* 的高度相对于地面的高度是 *z*(*t*) 和 *h*(*t*) 的差值。碰撞时间是指这个差值为零的时间，即 *z*(*t*) −
    *h*(*t*) = 0。我们可以用 *z*(*t*) 和 *h*(*t*) 的定义来展开这个条件：
- en: '![](../Images/CH12_F19_Orland_EQ12.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH12_F19_Orland_EQ12.png)'
- en: 'Once again, we can reshape this into the form *at*² + *bt* + *c* = 0:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以将其重塑为形式 *at*² + *bt* + *c* = 0：
- en: '![](../Images/CH12_F19_Orland_EQ13.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH12_F19_Orland_EQ13.png)'
- en: 'Specifically, *a* = *g*/2 − *Bv[x]*² + *Cv[y]*², *b* = *v[z]* and *c* = 0\.
    To find the time *t* that satisfies this equation, we can use the quadratic formula:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，*a* = *g*/2 − *Bv[x]*² + *Cv[y]*²，*b* = *v[z]*，*c* = 0。为了找到满足这个方程的时间 *t*，我们可以使用二次公式：
- en: '![](../Images/CH12_F19_Orland_EQ14.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH12_F19_Orland_EQ14.png)'
- en: 'Because *c* = 0, the form is even simpler:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *c* = 0，所以形式更加简单：
- en: '![](../Images/CH12_F19_Orland_EQ15.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH12_F19_Orland_EQ15.png)'
- en: 'When we use the + operator, we find *t* = 0, confirming that the cannonball
    is at ground level at the moment it is launched. The interesting solution is obtained
    using the − operator, which is the time the projectile lands. This time is *t*
    = (− *b* − *b*)/2*a* = − *b*/*a*. Plugging in the expressions for *a* and *b*,
    we get an expression for landing time in terms of quantities we know how to calculate:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用+运算符时，我们找到*t* = 0，确认炮弹在发射的瞬间处于地面水平。有趣的是，使用-运算符得到的解，这是投射物落地的时间。这个时间是*t*
    = (− *b* − *b*)/2*a* = − *b*/*a*。将*a*和*b*的表达式代入，我们得到一个关于我们已知如何计算的数量落地时间的表达式：
- en: '![](../Images/CH12_F19_Orland_EQ16.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F19_Orland_EQ16.png)'
- en: The distance in the (*x*,*y*) plane that the projectile lands is![](../Images/CH12_F19_Orland_EQ16a.png)
    for this time *t*. That expands to ![](../Images/CH12_F19_Orland_EQ16b.png). You
    can think of ![](../Images/CH12_F19_Orland_EQ16c.png) as the component of the
    initial velocity parallel to the *x*,*y* plane, so I’ll call this number *vxy*.
    The distance at landing is
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 投射物在(*x*,*y*)平面上的落点距离为![](../Images/CH12_F19_Orland_EQ16a.png)对于这个时间*t*。这扩展到![](../Images/CH12_F19_Orland_EQ16b.png)。你可以把![](../Images/CH12_F19_Orland_EQ16c.png)看作是初始速度平行于*x*,*y*平面的分量，所以我将这个数字称为*vxy*。落点距离是
- en: '![](../Images/CH12_F19_Orland_EQ17.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F19_Orland_EQ17.png)'
- en: 'All of these numbers in the expression are either constants that I specified
    or are computed in terms of the initial speed *v* = |***v***| and the launch angles
    θ and φ. It’s straightforward (albeit a bit tedious) to translate this to Python,
    where it becomes clear exactly how we can view the distance as a function of θ
    and φ:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中的所有这些数字要么是我指定的常数，要么是关于初始速度*v* = |***v***|和发射角度θ和φ的计算值。将这个表达式翻译成Python（尽管有点繁琐）是直接的，这样我们可以清楚地看到我们如何将距离视为θ和φ的函数：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Constants for the shape of the ridge, launch speed, and acceleration due to
    gravity
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 山脊形状、发射速度和重力加速度的常数
- en: ❷ A helper function that finds the x, y, and z components of the initial velocity
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个辅助函数，用于找到初始速度的x, y和z分量
- en: ❸ The horizontal component of initial velocity (parallel to the x,y plane)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 初始速度的水平分量（平行于x,y平面）
- en: ❹ The constants a and b
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 常数a和b
- en: ❺ Solves the quadratic equation for landing time, which is -b/a
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 解落点时间的二次方程，即-b/a
- en: ❻ The horizontal distance traveled
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 水平距离
- en: The horizontal distance traveled is the horizontal velocity times the elapsed
    time. Plotting this point alongside the simulated trajectory, we can verify that
    our calculated value for the landing position matches the simulation with Euler’s
    method (figure 12.20).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 水平距离是水平速度乘以经过的时间。将这个点与模拟轨迹一起绘制，我们可以验证我们计算出的落点位置与使用欧拉方法进行的模拟（图12.20）相匹配。
- en: '![](../Images/CH12_F20_Orland.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F20_Orland.png)'
- en: Figure 12.20 Comparing the calculated landing point with the result of the simulation
    for θ = 30° and ϕ = 240°
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 比较计算出的落点与θ = 30°和ϕ = 240°的模拟结果
- en: Now that we have a function *r*(θ, φ) for the range of the cannon in terms of
    the launch angles θ and φ, we can turn our attention to finding the angles that
    optimize the range.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了关于发射角度θ和φ的函数*r*(θ, φ)来表示大炮的射程，我们可以将注意力转向寻找优化射程的角度。
- en: 12.3.4 Exercises
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.4 练习
- en: '| **Exercise 12.10**: If &#124;***v***&#124; = *v* is the initial speed of
    the cannonball, verify that the initial velocity vector has a magnitude equal
    to *v*. In other words, show that the vector (*v* cos θ cos φ, *v cos* θ sin φ,
    *v* sin θ) has length *v*.**Hint**: By the definitions of sine and cosine and
    the Pythagorean theorem, sin² *x* + cos² *x* = 0 for any value of *x*.**Solution**:
    The magnitude of (*v* cos θ cos φ, *v cos* θ sin φ, *v* sin θ) is given by![](../Images/CH12_F20_Orland_EQ18.png)
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| **练习12.10**：如果|***v***| = *v*是炮弹的初始速度，验证初始速度向量的大小等于*v*。换句话说，证明向量(*v* cos
    θ cos φ, *v cos* θ sin φ, *v* sin θ)的长度是*v*。**提示**：根据正弦和余弦的定义以及勾股定理，sin² *x* +
    cos² *x* = 0对于任何*x*的值都成立。**解答**：向量(*v* cos θ cos φ, *v cos* θ sin φ, *v* sin θ)的大小由![](../Images/CH12_F20_Orland_EQ18.png)给出
    |'
- en: '| **Exercise 12.11**: Explicitly write out the formula for the range of the
    cannonball on the ridge with elevation *Bx*² − *Cy*² as a function of θ and φ.
    The constants that appear are *B* and *C*, as well as the initial launch speed
    *v* and the acceleration due to gravity *g*.**Solution**: Starting with the formula![](../Images/CH12_F20_Orland_EQ19.png)we
    can plug in *v[z]* = *v* sin θ, *vxy* = *v* cos θ, *v[y]* = *v* cos θ sin φ, and
    *v[x]* = *v* cos θ cos φ to get![](../Images/CH12_F20_Orland_EQ20.png)With a little
    simplification in the denominator, this becomes![](../Images/CH12_F20_Orland_EQ21.png)
    |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **练习 12.11**：明确写出在脊地形上，以 *Bx*² − *Cy*² 为函数的炮弹射程公式，其中 θ 和 φ 为变量。出现的常数包括 *B*
    和 *C*，以及初始发射速度 *v* 和重力加速度 *g*。**解答**：从公式![](../Images/CH12_F20_Orland_EQ19.png)开始，我们可以将
    *v[z]* = *v* sin θ，*vxy* = *v* cos θ，*v[y]* = *v* cos θ sin φ，和 *v[x]* = *v* cos
    θ cos φ 代入，得到![](../Images/CH12_F20_Orland_EQ20.png)。通过在分母中进行一些简化，这变成![](../Images/CH12_F20_Orland_EQ21.png)
    |'
- en: '| **Exercise 12.12-Mini Project**: When an object like a cannonball moves quickly
    through the air, it experiences frictional force from the air, called *drag*,
    which pushes it in the opposite direction it’s moving. The drag force depends
    on a lot of factors, including the size and shape of the cannonball and the density
    of the air, but for simplicity, let’s assume it works as follows. If *v* is the
    cannonball’s velocity vector at any point, the drag force, **F**[*d*], is**F**[*d*]
    = −α**v**whereα (the Greek letter alpha) is a number giving the magnitude of drag
    felt by a particular object in the air. The fact that the drag force is proportional
    to the velocity means that as an object speeds up, it feels more and more drag.
    Figure out how to add a drag parameter to the cannonball simulation and show that
    drag causes the cannonball to slow down.**Solution**: We want to add to our simulation
    is an acceleration based on drag. The force will be -α*v*, so the acceleration
    it causes is -α*v*/*m*. Because we’re not varying the mass of the cannonball,
    we can use a single drag constant, which isα/ *m*. The components of the acceleration
    due to drag is *v[x]*α/ *m*, *v[y]*α/ *m* and *v[z]*α/ *m*. Here’s the updated
    section of the code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 12.12-迷你项目**：当一个物体如炮弹快速通过空气时，它会受到空气的摩擦力，称为 *drag*，这会将其推向相反的方向。阻力取决于许多因素，包括炮弹的大小和形状以及空气的密度，但为了简化，让我们假设它如下工作。如果
    *v* 是炮弹在任何点的速度向量，那么阻力，**F**[*d*]，是**F**[*d*] = −α**v**其中α（希腊字母 alpha）是一个数字，表示特定物体在空气中感受到的阻力大小。阻力与速度成正比的事实意味着，随着物体速度的增加，它感受到的阻力越来越大。找出如何向炮弹模拟中添加阻力参数，并展示阻力会导致炮弹减速。**解答**：我们想在模拟中添加基于阻力的加速度。力将是
    -α*v*，因此它引起的加速度是 -α*v*/*m*。由于我们没有改变炮弹的质量，我们可以使用一个单一的阻力常数，即α/ *m*。阻力引起的加速度分量是 *v[x]*α/
    *m*，*v[y]*α/ *m* 和 *v[z]*α/ *m*。以下是代码更新的部分：'
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Reduces both vx and vy in proportion to the drag force❷ Changes the z velocity
    (vz) by the effects of gravity and dragYou can see that a small drag constant
    of 0.1 slows down the cannonball noticeably, causing it to fall short of the trajectory
    without drag.![](../Images/CH12_F20_Orland_UN05.png)Trajectories of the cannonball
    with `drag` `=` `0` and `drag` `=` `0.1` |
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 按照阻力大小成比例地减少 vx 和 vy❷ 通过重力和阻力的影响改变 z 速度 (vz) 你可以看到，一个小的阻力常数 0.1 明显地减慢了炮弹的速度，导致它没有阻力的情况下无法达到轨迹！[](../Images/CH12_F20_Orland_UN05.png)阻力分别为
    `drag` `=` `0` 和 `drag` `=` `0.1` 的炮弹轨迹 |
- en: 12.4 Optimizing range using gradient ascent
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 使用梯度上升优化射程
- en: Let’s continue to assume that we’re firing the cannon on the ridge terrain with
    some launch angles θ and φ, and all other launch parameters set to their defaults.
    In this case, the function *r*(θ, φ) tells us what the range of the cannon is
    at these launch angles. To get a qualitative sense of how the angles affect the
    range, we can plot the function *r* .
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续假设我们在脊地形上以某些发射角度 θ 和 φ 发射大炮，并将所有其他发射参数设置为默认值。在这种情况下，函数 *r*(θ, φ) 告诉我们大炮在这些发射角度下的射程。为了定性了解角度如何影响射程，我们可以绘制函数
    *r* 。
- en: 12.4.1 Plotting range versus launch parameters
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.1 绘制射程与发射参数的关系图
- en: I showed you a few different ways to plot a function of two variables in the
    last chapter. My preference for plotting *r*(θ, φ) is to use a heatmap. On a 2D
    canvas, we can vary θ in one direction and vary φ in the other and then use color
    to indicate the corresponding range of the projectile (figure 12.21).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我向你展示了多种绘制二维变量函数的方法。我偏好使用热图来绘制 *r*(θ, φ)。在一个二维画布上，我们可以在一个方向上改变 θ，在另一个方向上改变
    φ，然后使用颜色来表示相应弹道物体的射程（图 12.21）。
- en: '![](../Images/CH12_F21_Orland.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F21_Orland.png)'
- en: Figure 12.21 A heatmap of the range of the cannon as a function of the launch
    angles θ and ϕ
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21 大炮射程作为发射角度 θ 和 ϕ 的函数的热图
- en: This 2D space is an abstract one, having coordinates θ and φ. That is to say
    that this rectangle isn’t a drawing of a 2D slice of the 3D world we’ve modelled.
    Rather, it’s just a convenient way to show how the range *r* varies as the two
    parameters change.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个二维空间是一个抽象的空间，具有 θ 和 φ 坐标。也就是说，这个矩形并不是我们建模的 3D 世界二维切片的绘制。相反，它只是显示范围 *r* 随两个参数变化而变化的一种方便方式。
- en: On the graph in figure 12.22, brighter values indicate higher ranges, and there
    appear to be two brightest points. These are possible maximum values of the range
    of the cannon.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在图12.22的图表中，亮度值表示更高的范围，并且似乎有两个最亮的点。这些是大炮射程的可能最大值。
- en: '![](../Images/CH12_F22_Orland.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F22_Orland.png)'
- en: Figure 12.22 The brightest spots occur when the range of the projectile is maximized.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22 最亮的点出现在弹道范围最大化的时刻。
- en: These spots occur at around θ = 40, φ = 90, and φ = 270\. The φ values make
    sense because they are the downhill directions in the ridge. Our next goal is
    to find the exact values of θ and φ to maximize the range.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点出现在大约 θ = 40, φ = 90 和 φ = 270 的位置。φ 值是有意义的，因为它们是脊的下坡方向。我们的下一个目标是找到 θ 和 φ
    的确切值以最大化范围。
- en: 12.4.2 The gradient of the range function
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.2 射程函数的梯度
- en: Just as we used the derivative of a function of one variable to find its maximum,
    we’ll use the gradient ∇*r*(θ, φ) of the function *r*(θ, φ) to find its maximum
    values. For a smooth function of one variable, *f*(*x*), we saw that *f*'(*x*)
    = 0 when *f* attained its maximum value. This is when the graph of *f*(*x*) was
    momentarily flat, meaning the slope of *f*(*x*) was zero, or more precisely, that
    the slope of the line of best approximation at the given point was zero. Similarly,
    if we make a 3D plot of *r*(θ, φ), we can see that it is flat at its maximum points
    (figure 12.23).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们使用一元函数的导数来找到它的最大值一样，我们将使用函数 *r*(θ, φ) 的梯度 ∇*r*(θ, φ) 来找到它的最大值。对于一个一元变量的光滑函数
    *f*(*x*)，我们看到了当 *f* 达到最大值时 *f*'(*x*) = 0。这是当 *f*(*x*) 的图表暂时平直时，意味着 *f*(*x*) 的斜率为零，或者更精确地说，给定点的最佳近似线的斜率为零。同样，如果我们绘制
    *r*(θ, φ) 的三维图，我们可以看到它在最大点处是平的（图12.23）。
- en: '![](../Images/CH12_F23_Orland.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F23_Orland.png)'
- en: Figure 12.23 The graph of *r*(θ, ϕ) is flat at its maximum points.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23 *r*(θ, ϕ) 的图表在其最大点处是平的。
- en: Let’s be precise about what this means. Because *r*(θ, φ) is smooth, there is
    a plane of best approximation. The slopes of this plane in the θ and φ directions
    are given by the partial derivatives ∂*r*/∂θ and ∂*r*/∂φ, respectively. Only when
    both of these are zero is the plane flat, meaning the graph of *r*(θ, φ) is flat.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们精确地说明这意味着什么。因为 *r*(θ, φ) 是光滑的，所以存在一个最佳近似平面。这个平面在 θ 和 φ 方向上的斜率分别由偏导数 ∂*r*/∂θ
    和 ∂*r*/∂φ 给出。只有当这两个都为零时，平面才是平的，这意味着 *r*(θ, φ) 的图表是平的。
- en: Because the partial derivatives of *r* are defined to be the components of the
    gradient of *r* , this condition of flatness is equivalent to saying that ∇*r*(θ,
    φ) = 0\. To find such points, we have to take the gradient of the full formula
    for *r*(θ, φ) and then solve for values of θ and φ that cause it to be zero. Taking
    these derivatives and solving them is a lot of work and not that enlightening,
    so I’ll leave it as an exercise for you. Next, I’ll show you a way to follow an
    *approximate* gradient up the slope of the graph toward the maximum point, which
    won’t require any algebra.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *r* 的偏导数被定义为 *r* 梯度的分量，这个平直的条件等同于说 ∇*r*(θ, φ) = 0。为了找到这样的点，我们必须对 *r*(θ, φ)
    的完整公式求梯度，然后求解 θ 和 φ 的值，使得它为零。求这些导数并求解它们是很多工作，而且并不那么启发人心，所以我把这个作为你的练习。接下来，我将向你展示一种沿着图表斜坡向上追踪近似梯度到最大点的方法，这不会要求任何代数。
- en: Before I move on, I want to reiterate a point from the previous section. Just
    because you’ve found a point on the graph where the gradient is zero doesn’t mean
    that it’s a maximum value. For instance, on the graph of *r*(θ, φ), there’s a
    point in between the two maxima where the graph is flat and the gradient is zero
    (figure 12.24).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我继续之前，我想重申一下前一部分的一个观点。仅仅因为你在图表上找到一个梯度为零的点，并不意味着它是一个最大值。例如，在 *r*(θ, φ) 的图表中，在两个最大值之间有一个点，图表是平的，梯度为零（图12.24）。
- en: '![](../Images/CH12_F24_Orland.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F24_Orland.png)'
- en: Figure 12.24 A point (θ, ϕ) where the graph of *r*(θ, ϕ) is flat. The gradient
    is zero, but the function does not attain a maximum value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24 *r*(θ, ϕ) 的图形平坦的点 (θ, ϕ)。梯度为零，但函数没有达到最大值。
- en: This point isn’t meaningless, it happens to tell you the best angle θ when you’re
    shooting the projectile at φ = 180°, which is the worst possible direction because
    it is the steepest uphill direction. A point like this is called a *saddle point*,
    where the function simultaneously hits a maximum with respect to one variable
    and a minimum with respect to another. The name comes from the fact that the graph
    kind of looks like a saddle.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个点并非没有意义，它恰好告诉你当你在 φ = 180° 射击抛体时最佳的角度 θ，这是最糟糕的方向，因为它是最陡的上升方向。这样的点被称为 *鞍点*，函数在某一变量上达到最大值，而在另一变量上达到最小值。这个名字来源于图表看起来有点像马鞍。
- en: 'Again, I won’t go into the details of how to identify maxima, minima, saddle
    points, or other kinds of places where the gradient is zero, but be warned: with
    more dimensions, there are weirder ways that a graph can be flat.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我不会深入讲解如何识别极大值、极小值、鞍点或其他梯度为零的位置，但请注意：随着维度的增加，图形平坦的方式也会变得更为奇特。
- en: 12.4.3 Finding the uphill direction with the gradient
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.3 使用梯度找到上升方向
- en: Rather than take the partial derivatives of the complicated function *r*(θ,
    φ) symbolically, we can find approximate values for the partial derivatives. The
    direction of the gradient that they give us tells us, for any given point, which
    direction the function increases the most quickly. If we jump to a new point in
    this direction, we should move uphill and towards a maximum value. This procedure
    is called *gradient ascent*, and we’ll implement it in Python.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必对复杂的函数 *r*(θ, φ) 进行符号求偏导数，我们可以找到偏导数的近似值。它们给出的梯度方向告诉我们，对于任何给定的点，函数增加最快的方向。如果我们沿着这个方向跳到新的点，我们应该向上移动并朝向最大值。这个过程被称为
    *梯度上升*，我们将在Python中实现它。
- en: 'The first step is to be able to approximate the gradient at any point. To do
    that, we use the approach I introduced in chapter 9: taking the slopes of small
    secant lines. Here are the functions as a reminder:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是能够近似任何点的梯度。为了做到这一点，我们使用我在第9章中介绍的方法：取小割线的斜率。以下是作为提醒的函数：
- en: '[PRE24]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Finds the slope of a secant line, *f*(*x*), between *x* values of xmin and
    xmax
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 找到介于 xmin 和 xmax 之间的割线，*f*(*x*) 的斜率
- en: ❷ The approximate derivative is a secant line between *x* − 10 − 6 and *x* +
    10 − 6.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 近似导数是介于 *x* − 10 − 6 和 *x* + 10 − 6 之间的割线。
- en: 'To find the approximate partial derivative of a function *f*(*x*, *y*) at a
    point (*x*[0], *y*[0]), we want to fix *x* = *x*[0] and take the derivative with
    respect to *y*, or fix *y* = *y*[0] and take the derivative with respect to *x*.
    In other words, the partial derivative ∂*f*/∂*x* at (*x*[0], *y*[0]) is the ordinary
    derivative of *f*(*x*, *y*[0]) with respect to *x* at *x* = *x*[0]. Likewise,
    the partial derivative ∂*f*/∂*y* is the ordinary derivative of *f*(*x*[0], *y*)
    with respect to *y* at *y* = *y*[0]. The gradient is a vector (tuple) of these
    partial derivatives:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到函数 *f*(*x*, *y*) 在点 (*x*[0], *y*[0]) 处的近似偏导数，我们想要固定 *x* = *x*[0] 并对 *y* 求导，或者固定
    *y* = *y*[0] 并对 *x* 求导。换句话说，(*x*[0], *y*[0]) 处的偏导数 ∂*f*/∂*x* 是 *f*(*x*, *y*[0])
    在 *x* = *x*[0] 时关于 *x* 的普通导数。同样，偏导数 ∂*f*/∂*y* 是 *f*(*x*[0], *y*) 在 *y* = *y*[0]
    时关于 *y* 的普通导数。梯度是这些偏导数的矢量（元组）：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In Python, the function *r*(θ, φ) is encoded as the `landing_distance` function,
    and we can store a special function, `approx_gradient`, representing its gradient:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数 *r*(θ, φ) 被编码为 `landing_distance` 函数，我们可以存储一个特殊函数，`approx_gradient`，代表其梯度：
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This, like all gradients, defines a vector field: an assignment of a vector
    to every point in space. In this case, it tells us the vector of steepest increase
    in *r* at any point (θ, φ). Figure 12.25 shows the plot of the `landing_distance_gradient`
    on top of the heatmap for *r*(θ, φ).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这，就像所有梯度一样，定义了一个矢量场：为空间中的每个点分配一个矢量。在这种情况下，它告诉我们任何一点上 *r* 的最大增加矢量。图12.25显示了在
    *r*(θ, φ) 的热图上 `landing_distance_gradient` 的绘图。
- en: '![](../Images/CH12_F25_Orland.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F25_Orland.png)'
- en: Figure 12.25 A plot of the gradient vector field ∇r(θ, ϕ) on top of the heatmap
    of the function *r*(θ, ϕ). The arrows point in the direction of increase in r,
    toward brighter spots on the heatmap.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25 在函数 *r*(θ, ϕ) 的热图上显示的梯度矢量场 ∇r(θ, ϕ) 的绘图。箭头指向 r 增加的方向，指向热图上更亮的点。
- en: It’s even clearer that the gradient arrows converge on maximum points for the
    function if you zoom in (figure 12.26).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果放大查看（图12.26），梯度箭头会汇聚到函数的最大点。
- en: '![](../Images/CH12_F26_Orland.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F26_Orland.png)'
- en: Figure 12.26 The same plot as in figure 12.25 near (θ, ϕ) = (37.5°, 90°), which
    is the approximate location of one of the maxima
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26 与图12.25相同的图表，在（θ, ϕ）=（37.5°, 90°）附近，这是最大值之一的近似位置
- en: The next step is to implement the *gradient ascent* algorithm, where we start
    at an arbitrarily chosen point (θ, φ) and follow the gradient field until we arrive
    at *a* maximum.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现 *梯度上升* 算法，我们从任意选择的点（θ, φ）开始，沿着梯度场移动，直到我们到达 *一个* 最大值。
- en: 12.4.4 Implementing gradient ascent
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.4 实现梯度上升
- en: The gradient ascent algorithm takes as inputs the function we’re trying to maximize,
    as well as a starting point where we’ll begin our exploration. Our simple implementation
    calculates the gradient at the starting point and adds it to the starting point,
    giving us a new point some distance away from the original in the direction of
    the gradient. Repeating this process, we can move to points closer and closer
    to a maximum value.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度上升算法将我们要最大化的函数以及一个起始点作为输入，我们将从这里开始我们的探索。我们的简单实现计算起始点的梯度并将其加到起始点上，从而得到一个新的点，该点在原点附近，沿着梯度的方向有一定距离。重复此过程，我们可以移动到越来越接近最大值的点。
- en: 'Eventually, as we approach a maximum, the gradient will get close to zero as
    the graph reaches a plateau. When the gradient is near zero, we have nowhere further
    uphill to go, and the algorithm should terminate. To make this happen, we can
    pass in a *tolerance*, which is the smallest value of the gradient that we should
    follow. If the gradient is smaller, we can be assured the graph is flat, and we’ve
    arrived at a maximum for the function. Here’s the implementation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当我们接近最大值时，梯度将接近零，因为图表达到一个平台期。当梯度接近零时，我们就没有更多的上坡路可走了，算法应该终止。为了实现这一点，我们可以传递一个
    *tolerance*，这是我们应跟随的最小梯度值。如果梯度更小，我们可以确信图表是平的，我们已经到达了函数的最大值。以下是实现方式：
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Sets the initial values of (*x, y*) to the input values
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 (*x, y*) 的初始值设置为输入值
- en: ❷ Tells us how to move uphill from the current (*x, y*) value
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 告诉我们如何从当前的 (*x, y*) 值向上移动
- en: ❸ Only steps to a new point if the gradient is longer than the minimum length
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 只有当梯度大于最小长度时才向新点移动
- en: ❹ Updates (*x, y*) to (*x, y*) + ∇*f*(*x, y*)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将 (*x, y*) 更新为 (*x, y*) + ∇*f*(*x, y*)
- en: ❺ Updates the gradient at this new point
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 更新此新点的梯度
- en: ❻ When there’s nowhere further uphill to go, returns the values of *x* and *y*
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 当没有更多的上坡路可走时，返回 *x* 和 *y* 的值
- en: 'Let’s test this, starting at the value of (θ, φ) = (36°, 83°), which appears
    to be fairly close to the maximum:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下，从（θ, φ）=（36°, 83°）的值开始，这个值看起来相当接近最大值：
- en: '[PRE28]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a promising result! On our heatmap in figure 12.27, we can see the movement
    from the initial point of (θ, φ) = (36°, 83°) to a new location of roughly (θ,
    φ) = (37.58, 90.00), which looks like it has the maximum brightness.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很有希望的结果！在我们的热图（图12.27）中，我们可以看到从初始点（θ, φ）=（36°, 83°）移动到一个新的位置大约为（θ, φ）=（37.58,
    90.00），看起来它具有最大的亮度。
- en: '![](../Images/CH12_F27_Orland.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F27_Orland.png)'
- en: Figure 12.27 The starting and ending points for the gradient ascent
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27 梯度上升的起始点和结束点
- en: 'To get a better sense of how the algorithm works, we can track the trajectory
    of the gradient ascent through the θ, φ plane. This is similar to how we tracked
    the time and position values as we iterated through Euler’s method:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解算法的工作原理，我们可以追踪梯度上升在 θ, φ 平面上的轨迹。这与我们迭代欧拉方法时跟踪时间和位置值的方式类似：
- en: '[PRE29]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this implemented, we can run
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了这一点后，我们可以运行
- en: '[PRE30]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: and we get back two lists, consisting of the θ values and the φ values at each
    step of the ascent. These lists both have 855 numbers, meaning that this gradient
    ascent took 855 steps to complete. When we plot the θ and φ points on the heatmap
    (figure 12.28), we can see the path that our algorithm took to ascend the graph.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了两个列表，包含上升过程中的每个步骤的 θ 值和 φ 值。这两个列表都有 855 个数字，这意味着这个梯度上升需要 855 步才能完成。当我们把
    θ 和 φ 点绘制在热图（图12.28）上时，我们可以看到我们的算法上升图所采取的路径。
- en: '![](../Images/CH12_F28_Orland.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH12_F28_Orland.png)'
- en: Figure 12.28 The path that the gradient ascent algorithm takes to reach the
    maximum value of the range function
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28 梯度上升算法达到范围函数最大值所采取的路径
- en: Note that because there are two maximum values, the path *and* the destination
    depend on our choice of the initial point. If we start close to φ = 90°, we’re
    likely to hit that maximum, but if we’re closer to φ = 270°, our algorithm finds
    that one instead (figure 12.29).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于有两个最大值，路径和目的地都取决于我们选择的初始点。如果我们从 φ = 90° 附近开始，我们很可能会达到那个最大值，但如果我们更接近 φ =
    270°，我们的算法会找到那个最大值（图 12.29）。
- en: '![](../Images/CH12_F29_Orland.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F29_Orland.png)'
- en: Figure 12.29 Starting at different points, the gradient ascent algorithm can
    find different maximum values.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.29 从不同的点开始，梯度上升算法可以找到不同的最大值。
- en: The launch angles (37.58°, 90°) and (37.58°, 270°) *both* maximize the function
    *r*(θ, φ) and are, therefore, the launch angles that yield the greatest range
    for the cannon. That range is about 53 meters
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 发射角度 (37.58°, 90°) 和 (37.58°, 270°) *都* 最大化了函数 *r*(θ, φ)，因此它们是产生大炮最大射程的发射角度。这个射程大约是
    53 米
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: and we can plot the associated trajectories as shown in figure 12.30.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将相关的轨迹绘制如图 12.30 所示。
- en: '![](../Images/CH12_F30_Orland.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH12_F30_Orland.png)'
- en: Figure 12.30 The trajectories for the cannon having maximum range
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.30 具有最大射程的大炮轨迹
- en: As we explore some machine learning applications, we’ll continue to rely on
    the gradient to figure out how to optimize functions. Specifically, we’ll use
    the counterpart to gradient ascent, called *gradient descent*. This finds the
    minimum values for functions by exploring the parameter space in the direction
    *opposite* the gradient, thereby moving downhill instead of uphill. Because gradient
    ascent and descent can be performed automatically, we’ll see they give a way for
    machines to learn optimal solutions to problems on their own.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索一些机器学习应用，我们将继续依赖梯度来找出如何优化函数。具体来说，我们将使用梯度上升的对立面，称为*梯度下降*。通过在梯度相反的方向探索参数空间，它找到函数的最小值，从而向下而不是向上移动。因为梯度上升和下降可以自动执行，我们将看到它们为机器提供了一种自主学习问题最优解的方法。
- en: 12.4.5 Exercises
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.5 练习
- en: '| **Exercise 12.13**: On the heatmap, simultaneously plot the paths of gradient
    ascent from 20 randomly chosen points. All of the paths should end up at one of
    the two maxima.**Solution**: With a heatmap already plotted, we can run the following
    to execute and plot 20 random gradient ascents:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 12.13**：在热图中，同时绘制从 20 个随机选择点开始的梯度上升路径。所有路径都应该结束在两个最大值之一。**解答**：在已经绘制了热图的情况下，我们可以运行以下代码来执行并绘制
    20 次随机的梯度上升：'
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The result shows that all of the paths lead to the same places.![](../Images/CH12_F30_Orland_UN06.png)The
    paths of gradient ascents from 20 random initial points |
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，所有路径都导向了同一个地方！![图片](../Images/CH12_F30_Orland_UN06.png)从 20 个随机初始点开始的梯度上升路径
- en: '| **Exercise 12.14-Mini Project**: Find the partial derivatives ∂*r*/∂θ and
    ∂*r*/∂φ symbolically and write a formula for the gradient ∇*r*(θ, φ). |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **练习 12.14-迷你项目**：符号地找到 ∂r/∂θ 和 ∂r/∂φ 的偏导数，并写出梯度 ∇r(θ, φ) 的公式。|'
- en: '| **Exercise 12.15**: Find the point on *r*(θ, φ) where the gradient is zero,
    but the function is not maximized.**Solution**: We can trick the gradient ascent
    by starting it with φ = 180°. By the symmetry of the setup, we can see that ∂*r*/∂φ
    = 0 wherever φ = 180°, so the gradient ascent never has a reason to leave the
    line where φ = 0:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 12.15**：找到 *r*(θ, φ) 上梯度为零但函数不是最大化的点。**解答**：我们可以通过将 φ 初始化为 180° 来欺骗梯度上升。由于设置的对称性，我们可以看到当
    φ = 180° 时，∂r/∂φ = 0，因此梯度上升没有理由离开 φ = 0 的线：'
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| This is the optimal launch angle if you fix φ = 0 or φ = 180°, which is the
    worst angle because you’re firing uphill.![](../Images/CH12_F30_Orland_UN07.png)Tricking
    gradient ascent by initializing it on a cross section where ∂r/∂ϕ = 0 |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 如果你将 φ 固定为 0 或 180°，这就是最佳发射角度，因为你是向上发射的！![图片](../Images/CH12_F30_Orland_UN07.png)通过在
    ∂r/∂ϕ = 0 的横截面上初始化梯度上升来欺骗梯度上升。|'
- en: '| **Exercise 12.16**: How many steps does it take for gradient ascent to reach
    the origin from (36, 83)? Instead of jumping one gradient, jump 1.5 gradients.
    Show that you get there in fewer steps. What happens if you jump even further
    in each step?**Solution**: Let’s introduce a parameter `rate` to the gradient
    ascent calculation, which indicates how fast the ascent tries to go. The higher
    the rate, the more we trust the current calculated gradient and jump in that direction:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习12.16**: 梯度上升从 (36, 83) 到达原点需要多少步？而不是跳过一个梯度，跳 1.5 个梯度。证明你可以用更少的步骤到达那里。如果你在每一步中跳得更远会发生什么？**解答**：让我们向梯度上升计算中引入一个参数
    `rate`，它表示上升尝试的速度。速率越高，我们越信任当前计算的梯度，并朝那个方向跳跃：'
- en: '[PRE34]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here’s a function that counts the number of steps that a gradient ascent process
    takes to converge:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，它计算梯度上升过程收敛所需的步数：
- en: '[PRE35]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It takes 855 steps to perform our original ascent, with the `rate` parameter
    equal to 1:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rate` 参数等于 1 进行原始上升需要 855 步：
- en: '[PRE36]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With `rate=1.5`, we jump one and a half gradients in each step. Not surprisingly,
    we get to the maximum faster, in only 568 steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `rate=1.5` 时，我们每步跳一个半梯度。不出所料，我们更快地到达最大值，只需 568 步：
- en: '[PRE37]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Trying some more values, we see that increasing the rate gets us to the solution
    in even fewer steps:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更多的值，我们发现增加速率可以使我们在更少的步骤中达到解：
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Don’t get too greedy though! When we use a rate of 20, we get the answer in
    fewer steps, but some steps appear to overshoot the answer and the next step doubles
    back. If you set the rate too high, the algorithm can get further and further
    from the solution; in which case, it is said to diverge rather than converge.![](../Images/CH12_F30_Orland_UN08.png)A
    gradient ascent with a rate of 20\. The algorithm initially overshoots the maximum
    θ value and has to double back. |
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 但不要过于贪婪！当我们使用速率为 20 时，我们可以在更少的步骤中得到答案，但一些步骤似乎超出了答案，并且下一步会加倍回退。如果你将速率设置得太高，算法可能会越来越远离解；在这种情况下，我们说它发散而不是收敛！![](../Images/CH12_F30_Orland_UN08.png)速率为
    20 的梯度上升。算法最初超出了最大 θ 值，并不得不回退。|
- en: '| If you up the rate to 40, your gradient ascent won’t converge. Each jump
    overshoots further than the last, and the exploration of the parameter space runs
    off into infinity. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 如果你将速率提高到 40，你的梯度上升将不会收敛。每次跳跃都比上一次跳得更远，参数空间的探索会跑到无限远处。|'
- en: '| **Exercise 12.17**: What happens when you try to run `gradient_ascent` directly
    using simulated results for *r* as a function of θ and φ instead of calculated
    results?**Solution**: The result is not pretty. This is because the simulated
    results depend on numerical estimations (like deciding when the projectile hits
    the ground), so these fluctuate rapidly for small changes in the launch angles.
    Here’s a plot of the cross section *r*(θ, 270°) that our derivative approximator
    would consider when calculating the partial derivative ∂*r*/∂θ:![](../Images/CH12_F30_Orland_UN09.png)A
    cross section of simulated trajectories shows that our simulator doesn’t produce
    a smooth function *r*(θ, ϕ).The value of the derivative fluctuates wildly, so
    the gradient ascent moves in random directions. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **练习12.17**: 当你尝试直接使用模拟结果（将 *r* 作为 θ 和 φ 的函数）而不是计算结果来运行 `gradient_ascent`
    时会发生什么？**解答**：结果并不理想。这是因为模拟结果依赖于数值估计（例如决定弹丸何时击中地面），因此当发射角度发生微小变化时，这些估计会迅速波动。以下是我们导数近似器在计算偏导数
    ∂*r*/∂θ 时会考虑的横截面 *r*(θ, 270°) 的图像：![](../Images/CH12_F30_Orland_UN09.png)模拟轨迹的横截面显示，我们的模拟器没有产生一个平滑的函数
    *r*(θ, ϕ)。导数的值波动很大，因此梯度上升会在随机方向上移动。|'
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We can simulate a moving object’s trajectory by using Euler’s method and recording
    all of the times and positions along the way. We can compute facts about the trajectory,
    like final position or elapsed time.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用欧拉方法并记录所有的时间和位置来模拟移动物体的轨迹。我们可以计算关于轨迹的事实，如最终位置或经过的时间。
- en: Varying a parameter of our simulation, like the launch angle of the cannon,
    can lead to different results−for instance, a different range for the cannonball.
    If we want to find the angle that maximizes range, it helps to write range as
    a function of the angle *r*(θ).
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变我们模拟的一个参数，如大炮的发射角度，可能会导致不同的结果——例如，弹丸的射程不同。如果我们想找到最大化射程的角度，将射程写成角度 *r*(θ) 的函数会有所帮助。
- en: Maximum values of a smooth function *f*(*x*) occur where the derivative *f*'(*x*)
    is zero. You need to be careful, though, because when *f*'(*x*) = 0, the function
    *f* might be at a maximum value, or it could also be a minimum value or a point
    where function *f* has temporarily stopped changing.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光滑函数 *f*(*x*) 的最大值出现在其导数 *f*'(*x*) 为零的地方。不过，你需要小心，因为当 *f*'(*x*) = 0 时，函数 *f*
    可能处于最大值，也可能是最小值，或者是一个函数 *f* 临时停止变化的点。
- en: To optimize a function of two variables, like the range *r* as a function of
    the vertical launch angle θ and the lateral launch angle φ, you need to explore
    the 2D space of all possible inputs (θ, φ) and figure out which pair produces
    the optimal value.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要优化两个变量的函数，例如将射程 *r* 作为垂直发射角 θ 和水平发射角 φ 的函数进行优化，你需要探索所有可能的输入 (θ, φ) 的二维空间，并找出哪一对产生最优值。
- en: Maximum and minimum values of a smooth function of two variables *f*(*x*, *y*)
    occur when *both* partial derivatives are zero; that is, ∂*f*/∂*x* = 0 and ∂*f*/∂*y*
    = 0, so ∇*f*(*x*, *y*) = 0 as well (by definition). If the partial derivatives
    are zero, it might also be a *saddle point*, which minimizes the function with
    respect to one variable while maximizing it with respect to the other.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两个变量的光滑函数 *f*(*x*, *y*) 的最大值和最小值，发生在两个偏导数都为零的情况下；也就是说，∂*f*/∂*x* = 0 和 ∂*f*/∂*y*
    = 0，因此 ∇*f*(*x*, *y*) = 0（根据定义）。如果偏导数为零，它也可能是一个鞍点，相对于一个变量最小化函数，相对于另一个变量最大化函数。
- en: The gradient ascent algorithm finds an approximate maximum value for a function
    *f*(*x*,*y*) by starting at an arbitrarily chosen point in 2D and moving in the
    direction of the gradient ∇*f*(*x*, *y*). Because the gradient points in the direction
    of most rapid increase in the function *f* , this algorithm finds (*x*, *y*) points
    with increasing *f* values. The algorithm terminates when the gradient is near
    zero.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 梯度上升算法通过从二维空间中任意选择一个点开始，沿着梯度 ∇*f*(*x*, *y*) 的方向移动，来寻找函数 *f*(*x*, *y*) 的近似最大值。由于梯度指向函数
    *f* 增加最快的方向，因此该算法找到的 (*x*, *y*) 点具有增加的 *f* 值。当梯度接近零时，算法终止。
