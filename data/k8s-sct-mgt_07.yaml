- en: 5 HashiCorp Vault and Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 HashiCorp Vault 和 Kubernetes
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Enabling HashiCorp Vault for use by end user applications deployed to Kubernetes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 HashiCorp Vault 以供部署到 Kubernetes 的最终用户应用程序使用
- en: Integrating Kubernetes authentication to simplify access to Vault resources
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Kubernetes 认证以简化对 Vault 资源的访问
- en: Accessing secrets stored in HashiCorp Vault by applications deployed to Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过部署到 Kubernetes 的应用程序访问存储在 HashiCorp Vault 中的秘密
- en: Chapter 4 introduced HashiCorp Vault as a KMS that could be used to provide
    encryption for secrets and other resources stored in `etcd`—the key/value datastore
    for Kubernetes—so these values could not be readily accessed because they were
    stored at rest.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第四章介绍了 HashiCorp Vault 作为一种 KMS，可用于为存储在 `etcd`（Kubernetes 的键/值存储）中的秘密和其他资源提供加密，因此这些值不能轻易访问，因为它们是静态存储的。
- en: This chapter focuses on the importance of using a secrets management tool, like
    HashiCorp Vault, to securely store and manage sensitive assets for applications
    deployed to Kubernetes as well as demonstrating how both applications and Vault
    can be configured to provide seamless integration with one another. By using a
    tool like Vault, application teams can offload some of the responsibilities involved
    in managing sensitive resources to a purpose-built tool, while still being able
    to integrate with their applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了使用像 HashiCorp Vault 这样的秘密管理工具的重要性，以安全地存储和管理部署到 Kubernetes 的应用程序的敏感资产，并展示了如何配置应用程序和
    Vault 以实现彼此的无缝集成。通过使用 Vault 这样的工具，应用团队可以将管理敏感资源的一些责任转移到专门构建的工具上，同时仍然能够与他们的应用程序集成。
- en: 5.1 Managing application secrets using HashiCorp Vault
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 使用 HashiCorp Vault 管理应用程序秘密
- en: As you’ve seen thus far, sensitive assets can be used by either the core infrastructure
    components of Kubernetes or by applications deployed to the platform. Chapter
    4 focused primarily on the infrastructure portion and how to properly secure the
    primary database of Kubernetes, `etcd`, by encrypting the values using HashiCorp
    Vault. While Vault can aid in keeping the platform secure, it is more commonly
    used to store and protect properties for use in applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如您迄今为止所看到的，敏感资产可以被 Kubernetes 的核心基础设施组件或部署到平台上的应用程序使用。第四章主要关注基础设施部分，以及如何通过使用
    HashiCorp Vault 加密值来正确保护 Kubernetes 的主要数据库 `etcd`。虽然 Vault 可以帮助保持平台的安全，但它更常用于存储和保护用于应用程序的属性。
- en: When securing the values for storage within `etcd`, as described in chapter
    4, Vault was used as an intermediary to perform the cryptographic functions needed
    to encrypt and decrypt data in transit using Vault’s transit secrets. For applications
    deployed to Kubernetes, they themselves are not designed to act as a secrets store
    and would look to another tool that is better designed for this purpose. This
    is where Vault can be used as a solution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当像第四章中描述的那样在 `etcd` 中保护存储的值时，Vault 被用作中介来执行使用 Vault 的传输秘密加密和解密数据所需的加密功能。对于部署到
    Kubernetes 的应用程序，它们自身并不是设计为作为秘密存储的，它们会寻找另一个更适合此目的的工具。这就是 Vault 可以作为解决方案的地方。
- en: Imagine you wanted to use Vault to store the secret locations where field agents
    are deployed around the world. While a database could be used in this scenario,
    we will demonstrate how to store arbitrary data in a secure fashion using a Vault
    instance deployed to Kubernetes and access the values within an application deployed
    to Kubernetes (figure 5.1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想使用 Vault 存储全球各地部署的字节代理的秘密位置。虽然在这种情况下可以使用数据库，但我们将演示如何使用部署到 Kubernetes 的 Vault
    实例以安全的方式存储任意数据，并在部署到 Kubernetes 的应用程序中访问这些值（图 5.1）。
- en: '![](../Images/CH05_F01_Sotobueno3.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F01_Sotobueno3.png)'
- en: Figure 5.1 Secrets storage within Vault and an application requesting access
    to retrieve the stored values
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 Vault 中的秘密存储以及请求访问以检索存储值的应用程序
- en: 5.1.1 Deploying Vault to Kubernetes
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 在 Kubernetes 上部署 Vault
- en: In chapter 4, you installed HashiCorp Vault within the minikube VM to provide
    a clear separation between the Kubernetes infrastructure components (particularly
    `etcd`) and the KMS. Since `etcd` is so crucial to the functionality of the Kubernetes
    cluster, you should ensure there are no dependencies upon one another for proper
    operation (aka the *chicken or the egg* dilemma).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四章中，您在 minikube VM 中安装了 HashiCorp Vault，以在 Kubernetes 基础设施组件（尤其是 `etcd`）和
    KMS 之间提供清晰的分离。由于 `etcd` 对 Kubernetes 集群的功能至关重要，您应确保它们之间没有相互依赖，以确保正常操作（即所谓的“先有鸡还是先有蛋”的困境）。
- en: Since there is less of a hard dependency between applications and the KMS (and
    vice versa), and to be able to take advantage of many of the benefits of Kubernetes
    itself (e.g., scheduling and application health monitoring), Vault will be deployed
    to Kubernetes for the purpose of acting as a KMS for applications. There are several
    methods you can use to deploy Vault to Kubernetes, but the most straightforward
    method is using Helm. A chart available from HashiCorp ([https://github.com/hashicorp/vault-helm](https://github.com/hashicorp/vault-helm))
    supports the majority of deployment options needed for either a development instance
    or to support a production-ready cluster.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序和 KMS（反之亦然）之间的硬依赖性较小，并且为了能够利用 Kubernetes 本身的大多数好处（例如，调度和应用程序健康监控），Vault
    将部署到 Kubernetes 以充当应用程序的 KMS。您可以使用几种方法将 Vault 部署到 Kubernetes，但最直接的方法是使用 Helm。从
    HashiCorp 可用的图表（[https://github.com/hashicorp/vault-helm](https://github.com/hashicorp/vault-helm)）支持大多数部署选项，无论是用于开发实例还是支持生产就绪集群。
- en: 'To get started, use the terminal from any directory to first add the Hashicorp
    repository to Helm containing the Vault chart:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，请从任何目录使用终端首先将 Hashicorp 仓库添加到 Helm，其中包含 Vault 图表：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then retrieve the latest updates from the remote repositories, which will pull
    down the content to your machine:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从远程仓库检索最新更新，这将把内容拉到您的机器上：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Vault HA storage using integrated RaftHA (high availability) storage
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 使用集成 RaftHA（高可用性）存储进行高可用性存储
- en: The next consideration whenever Vault is deployed is how you will handle the
    storage of its metadata. When Vault was deployed outside of Kubernetes within
    the minikube VM, the file system storage type was used. This configuration will
    persist to the local filesystem and is an easy way to get Vault running. However,
    when using a production-style deployment, the file system storage type is not
    desirable, as it only supports a single instance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每次部署 Vault 时，下一个考虑因素是您将如何处理其元数据的存储。当 Vault 在 Kubernetes 之外的 minikube VM 中部署时，使用了文件系统存储类型。此配置将持久化到本地文件系统，并且是让
    Vault 运行起来的简单方法。然而，当使用生产式部署时，文件系统存储类型是不理想的，因为它只支持单个实例。
- en: Another benefit of deploying Vault on Kubernetes, aside from the aforementioned
    benefits and to align with the desire for a more production style deployment,
    is the ability to achieve high availability (HA) easily. However, going beyond
    a single instance requires the use of a different storage type other than file
    system. While Vault supports a number of external storage backends, ranging from
    relational and NoSQL databases to cloud object storage, a simple option that is
    highly available and does not have any external dependency is integrated storage
    using Raft (figure 5.2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上部署 Vault 的另一个好处，除了上述好处以及与更生产式部署的愿望相一致之外，是能够轻松实现高可用性（HA）。然而，要超越单个实例，需要使用除文件系统之外的不同存储类型。虽然
    Vault 支持多种外部存储后端，从关系型数据库和 NoSQL 数据库到云对象存储，但一个简单且高可用且没有外部依赖的选项是使用 Raft 的集成存储（图
    5.2）。
- en: '![](../Images/CH05_F02_Sotobueno3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2](../Images/CH05_F02_Sotobueno3.png)'
- en: Figure 5.2 Leader election and the replication of data using Raft storage
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 领导者选举和 Raft 存储的数据复制
- en: Raft is a distributed *consensus algorithm*, in which multiple members form
    a cluster after an election occurs. A leader is determined based on the outcome
    of the election, when they have the responsibility of determining the the shared
    state of the cluster and replicating the state to each of the followers. The minimum
    number in any cluster is 3 (*N*/2+1, where *N* is the number of total nodes) to
    ensure there is a minimum number of nodes if a failure occurs. Raft is a common
    protocol and is used by other solutions in the cloud-native space, including `etcd`,
    when it operates in a highly available configuration.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Raft 是一种分布式 **一致性算法**，在发生选举后，多个成员形成一个集群。根据选举结果确定领导者，当他们在确定集群的共享状态并将状态复制到每个跟随者方面承担责任时。任何集群的最小数量是
    3（*N*/2+1，其中 *N* 是总节点数）以确保在发生故障时有最小数量的节点。Raft 是一种常见协议，当它在高可用配置下运行时，被云原生空间中的其他解决方案使用，包括
    `etcd`。
- en: With an understanding of the storage requirement’s needed to support a highly
    available deployment of Vault, install the Vault Helm chart by setting the `server.ha.enabled=true`
    and `server.ha.raft.enabled=true` values, which will enable HA along with enabling
    Raft. In addition, since you are attempting to deploy a highly available deployment
    to a single minikube node, set the `server.affinity` value to `""`; this will
    skip the default Pod affinity configurations, which would attempt to schedule
    each Vault Pod to a separate node and, thus, result in a scheduling failure. Execute
    the command in the following listing to install the chart.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解支持 Vault 高可用性部署所需的存储需求后，通过设置 `server.ha.enabled=true` 和 `server.ha.raft.enabled=true`
    的值来安装 Vault Helm 图表，这将启用高可用性并启用 Raft。此外，由于您正在尝试将高可用性部署部署到单个 minikube 节点，请将 `server.affinity`
    的值设置为 `""`；这将跳过默认的 Pod 亲和性配置，该配置会尝试将每个 Vault Pod 调度到不同的节点，从而导致调度失败。执行以下列表中的命令来安装图表。
- en: Listing 5.1 Deploying vault using Helm
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 使用 Helm 部署 vault
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Specify the name of the release and the chart to install.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ① 指定发布名称和要安装的图表名称。
- en: ② Enable Vault in high availability mode.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在高可用性模式下启用 Vault。
- en: ③ Enable Raft in high availability mode.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在高可用性模式下启用 Raft。
- en: ④ Disable Pod affinity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 禁用 Pod 亲和性。
- en: ⑤ Create a namespace called vault if it does not already exist.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果尚不存在，创建一个名为 vault 的命名空间。
- en: 'Confirm that three instances of Vault are deployed to the `vault` namespace:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确认已将三个 Vault 实例部署到 `vault` 命名空间：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In addition to the three expected Vault instances, another Pod prefixed with
    `vault-agent-injector` is also deployed and serves the purpose of dynamically
    injecting secrets into Pods. The Vault Agent Injector will be covered in detail
    later in the chapter. If any of the Vault or Vault Injector Pods are not currently
    in a `Running` state or none of the Pods appear, use the `kubectl` `get` `events`
    `-n` `vault` command to investigate the cause of such issues.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了预期的三个 Vault 实例外，还有一个以 `vault-agent-injector` 为前缀的 Pod 也已部署，其目的是动态地将机密注入到 Pod
    中。Vault Agent Injector 将在本章的后面详细讨论。如果 Vault 或 Vault Injector Pod 中任何一个当前不在 `Running`
    状态，或者没有任何 Pod 出现，请使用 `kubectl get events -n vault` 命令来调查此类问题的原因。
- en: With Vault deployed, the first step is to initialize Vault. Since there are
    multiple instances of Vault, one of them should be designated as the initial leader—`vault-0`
    in this instance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 部署后，第一步是初始化 Vault。由于存在多个 Vault 实例，其中一个实例应被指定为初始领导者——在本例中为 `vault-0`。
- en: 'First check the status of Vault, which should denote it has yet to be initialized:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查 Vault 的状态，它应该表明尚未初始化：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now initialize the Vault, so you can begin interacting with it, as follows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初始化 Vault，以便您可以开始与之交互，操作如下。
- en: Listing 5.2 Initializing the vault
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 初始化 vault
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① The output will display each of the keys that can be used to unseal the Vault
    along with the initial root token.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ① 输出将显示可用于解密 Vault 的每个密钥以及初始根令牌。
- en: When Vault is initialized, it will be put into *sealed* mode, meaning it knows
    how to access the storage layer but cannot decrypt any of the content. When Vault
    is in a sealed state, it is akin to a bank vault, where the assets are secure,
    but no actions can take place. To be able to interact with Vault, it must be unsealed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Vault 初始化时，它将被置于 *密封* 模式，这意味着它知道如何访问存储层，但不能解密任何内容。当 Vault 处于密封状态时，它类似于银行保险库，资产安全，但无法进行任何操作。要能够与
    Vault 交互，必须将其解密。
- en: '*Unsealing* is the process of obtaining access to the master key. However,
    this key is only one portion of how data in Vault is encrypted. When data is stored
    in Vault, it is encrypted using an *encryption key*. This key is stored along
    with the data in Vault and encrypted using another key, known as the *master key*.
    However, it does not stop there. The master key is also stored with the data in
    Vault and encrypted one more time by the *unseal key*. The unseal key is then
    distributed into multiple shards using an algorithm known as Shamir’s Secret Sharing.
    To reconstruct the *seal key*, a certain number of shards must be provided individually,
    which will enable access to the combined key and, ultimately, to the data stored
    within Vault (figure 5.3).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*解封*是获取访问主密钥的过程。然而，这个密钥只是Vault中数据加密的一部分。当数据存储在Vault中时，它使用一个*加密密钥*进行加密。这个密钥与数据一起存储在Vault中，并使用另一个密钥加密，称为*主密钥*。然而，这还没有结束。主密钥也存储在Vault中的数据中，并再次使用*解封密钥*进行加密。解封密钥随后使用称为Shamir的密钥共享算法分布到多个碎片中。为了重建*封印密钥*，必须提供一定数量的碎片，这将允许访问组合密钥，最终访问Vault中存储的数据（图5.3）。'
- en: '![](../Images/CH05_F03_Sotobueno3.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F03_Sotobueno3.png)'
- en: Figure 5.3 The steps involved in unsealing Vault
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 解封Vault的步骤
- en: When Vault was initialized, five unsealed keys were provided, representing the
    shards that will be used to construct the combined key. By default, three keys
    are needed to reconstruct the combined key. Begin the process of unsealing the
    vault for the `vault-0` instance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当Vault初始化时，提供了五个解封密钥，代表将用于构建组合密钥的碎片。默认情况下，需要三个密钥来重建组合密钥。开始为`vault-0`实例解封Vault的过程。
- en: Execute the following command to begin the unsealing process. When prompted,
    enter the value of the key next to Unseal Key 1 at the prompt from the `vault`
    `operator` `init` command executed in the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以开始解封过程。当提示时，输入在以下列表中执行的`vault` `operator` `init`命令旁边`Unseal Key 1`的值。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 5.3 Progression of unsealing the vault
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 解封Vault的进度
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① Unseal progress
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ① 解封进度
- en: The unsealing process is underway, as the `Unseal` `Progress` row shown in listing
    5.3 indicates one of the keys has been entered. Execute the same `kubectl` `-n`
    `vault exec` `-it` `vault-0—vault` `operator` `unseal` two more times, providing
    the values next to Unseal Key 2, Unseal Key 3, and so on when prompted.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 解封过程正在进行中，如列表5.3中所示的`Unseal` `Progress`行表明已输入了一个密钥。执行相同的`kubectl` `-n` `vault
    exec` `-it` `vault-0—vault` `operator` `unseal`命令两次，当提示时提供`Unseal Key 2`、`Unseal
    Key 3`等旁边的值。
- en: Keep providing keys until you see an output similar to that in the following
    listing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 继续提供密钥，直到您看到以下列表中的输出类似结果。
- en: Listing 5.4 An unsealed Vault instance
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 一个解封的Vault实例
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Sealed status
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ① 封存状态
- en: ② Cluster name
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ② 集群名称
- en: ③ HA Mode status
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 高可用模式状态
- en: The `vault-0` instance is now unsealed. However, since Vault is running in HA
    mode, the other two members must be joined to the newly created cluster and undergo
    the unsealing process.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`vault-0`实例现在已解封。然而，由于Vault正在运行在HA模式，其他两个成员必须加入新创建的集群并经历解封过程。'
- en: First join the `vault-1` instance to the Raft cluster, as follows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将`vault-1`实例加入Raft集群，如下所示。
- en: Listing 5.5 Joining a new node to the Raft cluster
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 将新节点加入Raft集群
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① Address of the Raft leader
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ① Raft领导者的地址
- en: 'Next execute the following command three times, providing a different unseal
    key, as accomplished with `vault-0`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来执行以下命令三次，提供不同的解封密钥，就像在`vault-0`中完成的那样：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once these steps have been completed on the `vault-1` instance, perform the
    `vault operator` `join` and `vault` `operator` `unseal` commands on the `vault-2`
    instance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vault-1`实例上完成这些步骤后，在`vault-2`实例上执行`vault operator` `join`和`vault` `operator`
    `unseal`命令。
- en: 'To confirm that the highly available Vault cluster is ready, log in to the
    `vault-0` instance using the `Initial` `Root` `Token` provided by the `vault operator`
    `init` command as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认高可用Vault集群已就绪，请使用`vault operator` `init`命令提供的`Initial` `Root` `Token`登录到`vault-0`实例，如下所示：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that you have logged in with the root token, confirm all members have successfully
    joined to the Vault cluster by listing all Raft members:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已使用root令牌登录，通过列出所有Raft成员来确认所有成员是否已成功加入Vault集群：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice how `vault-0` is listed as the `leader` with the other two members being
    `followers`, as indicated by the `State` column. If three Raft instances do not
    appear, confirm that each member was successfully joined in listing 5.5\. At this
    point, the highly available Vault has been deployed to the minikube instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `vault-0` 被列为 `leader`，其他两个成员是 `followers`，如 `State` 列所示。如果出现三个 Raft 实例，请确认每个成员在列表
    5.5 中都成功加入。此时，高可用性的 Vault 已部署到 minikube 实例。
- en: Secrets engines
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥管理引擎
- en: We spoke earlier about the types of storage backends that can be used as durable
    storage for Vault information. The actual storage, generation, and encryption
    of data within Vault itself is facilitated by one of the supported secrets engines.
    Secrets engines can perform simple operations, like storing or reading data. However,
    more complex secrets engines may call out to external resources to generate assets
    on demand. The transit secrets engine, as described in chapter 4, aided in the
    encryption and decryption of values stored in `etcd`, but for applications looking
    to retrieve values stored in Vault, like the one you are looking to implement
    in this chapter, the Key/Value, or `kv`, secrets engine can be used.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过可以作为 Vault 信息持久化存储使用的存储后端类型。Vault 内部数据的实际存储、生成和加密由支持的密钥管理引擎之一提供便利。密钥管理引擎可以执行简单的操作，如存储或读取数据。然而，更复杂的密钥管理引擎可能会调用外部资源按需生成资产。第
    4 章中描述的传输密钥管理引擎有助于加密和解密存储在 `etcd` 中的值，但对于需要从 Vault 中检索值的程序，例如本章中你打算实现的程序，可以使用键/值或
    `kv` 密钥管理引擎。
- en: 'The `kv` engine does exactly what it sounds like it would: it enables the storage
    of key–value pairs within Vault. This secrets engine has evolved over time, and
    there are, as of this writing, two versions that can be used.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`kv` 引擎确实如其名称所示：它允许在 Vault 中存储键值对。这个密钥管理引擎随着时间的推移而发展，截至本文撰写时，有两个版本可以使用。'
- en: '`kv`*version 1*—Nonversioned storage of key–value pairs. Updated values overwrite
    existing values. There is a smaller storage footprint, since there is no requirement
    to store additional metadata that supports versioning.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kv`*版本 1*—非版本化的键值对存储。更新值会覆盖现有值。由于没有存储支持版本化的额外元数据的要求，存储占用空间较小。'
- en: '`kv`*version 2*—Support for versioned key–value pairs. It provides enhanced
    support for avoiding unintentionally overwriting data. There is an additional
    storage requirement for the metadata used to track versioning.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kv`*版本 2*—支持版本化的键值对。它提供了增强的数据避免意外覆盖的支持。需要额外的存储空间来存储用于跟踪版本化的元数据。'
- en: Either `kv` version could be used in this case, but given that most implementations
    make use of version 2, it is the one that will be used. Secrets engines are enabled
    on a given *path*, or location within Vault. For your application, you will use
    the `agents` path.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以使用任意的 `kv` 版本，但鉴于大多数实现都使用版本 2，因此将使用该版本。密钥管理引擎在 Vault 的特定 *路径* 或位置上启用。对于你的应用程序，你将使用
    `agents` 路径。
- en: 'Before enabling the `kv` engine, list all of the enabled secrets engines:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用 `kv` 引擎之前，列出所有启用的密钥管理引擎：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now enable the `kv-v2` secrets engine on the `agents` path to enable the storing
    of key–value pair secrets, as follows.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `agents` 路径上启用 `kv-v2` 密钥管理引擎以启用存储键值对密钥，如下所示。
- en: Listing 5.6 Enabling the `kv` secrets engine
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 启用 `kv` 密钥管理引擎
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Location of the kv secrets engine in Vault
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ① Vault 中 kv 密钥管理引擎的位置
- en: ② Version of the secrets engine
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ② 密钥管理引擎的版本
- en: ③ Name of the engine to enable
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 要启用的引擎名称
- en: 'With the engine enabled on the `agents` path, you can now store a few values.
    Each agent will have several attributes associated with their key:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `agents` 路径上启用了引擎后，你现在可以存储一些值。每个代理将与它们的键相关联几个属性：
- en: '`name`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`'
- en: '`email`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`电子邮件`'
- en: '`location`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位置`'
- en: 'Create a new entry for agent `bill`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为代理 `bill` 创建一个新的条目：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Retrieving the value stored in Vault is just as simple:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Vault 中检索存储的值同样简单：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that you have confirmed you were able to add and retrieve a secret successfully,
    add a few more agents:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经确认能够成功添加和检索密钥，添加几个更多代理：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, there should be four secrets stored in Vault.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Vault 中应该存储了四个密钥。
- en: Application access and security
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序访问和安全
- en: The root token currently being used to interact with Vault has unrestricted
    access to all of Vault’s capabilities and is not recommended to be used within
    applications interacting with the Vault server. Instead, applying the principle
    of least privilege, a separate method for the application to authenticate against
    Vault should be used. Vault supports multiple auth methods for a consumer to identify
    itself, including username and password, TLS certificates, and the aforementioned
    token, just to name a few.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当前用于与Vault交互的根令牌具有对Vault所有能力的无限制访问权限，不建议在与应用程序交互的Vault服务器中使用。相反，应用最小权限原则，应使用单独的方法让应用程序对Vault进行认证。Vault支持多种认证方法，供消费者识别自身，包括用户名和密码、TLS证书以及前面提到的令牌，仅举几例。
- en: An auth method can be associated with one or more *policies*, which define the
    privileges against different paths in Vault. Each policy is associated with *capabilities*,
    which provide fine-grained control against a particular path (figure 5.4).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将一种或多种*策略*与认证方法关联，这些策略定义了在Vault中对不同路径的权限。每个策略都与*能力*相关联，这些能力提供了对特定路径的细粒度控制（图5.4）。
- en: '![](../Images/CH05_F04_Sotobueno3.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F04_Sotobueno3.png)'
- en: Figure 5.4 The relationships between capabilities, policies, and auth methods
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 能力、策略和认证方法之间的关系
- en: 'The following is the set of capabilities available in Vault:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Vault中可用的能力集：
- en: '`create`—Allows the creation of data against a given path'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`—允许在给定路径上创建数据'
- en: '`read`—Allows the reading of data at a given path'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`—允许在给定路径上读取数据'
- en: '`delete`—Allows the deletion of data against a given path'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`—允许在给定路径上删除数据'
- en: '`list`—Allows the listing of values against a given path'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`—允许在给定路径上列出值'
- en: Policies are written either in JSON or HashiCorp Configuration Language (HCL
    [compatible with JSON]) format and are submitted to the Vault server using the
    CLI at creation time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 策略可以以JSON或HashiCorp配置语言（HCL [兼容JSON]）格式编写，并在创建时通过CLI提交给Vault服务器。
- en: Create a new file called `agents-policy.hcl`, which will define the policy that
    provides access to `read` and `list` the values within the `agents` path, as follows.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`agents-policy.hcl`的新文件，该文件将定义提供对`agents`路径中的`read`和`list`值访问权限的策略，如下所示。
- en: Listing 5.7 Creating a policy to govern access to Vault content
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 创建策略以管理对Vault内容的访问
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① List of capabilities associated at a given path
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ① 与给定路径关联的能力列表
- en: ImportanT Versioned content, as in `kv` version 2, stores content prefixed with
    `data/`, which was omitted in `kv` version 1 and must be accounted for when designing
    policies.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要版本化的内容，如`kv`版本2，存储以`data/`为前缀的内容，这在`kv`版本1中被省略，在设计策略时必须考虑。
- en: 'Create a new policy called `agents_reader` by copying the .hcl policy file
    created in listing 5.7 to the Vault Pod and creating the policy:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将列表5.7中创建的.hcl策略文件复制到Vault Pod并创建策略，创建一个名为`agents_reader`的新策略：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now create a new token that can be used by the Agents application and only provides
    access to the `agents` path, and assign it to a variable called `AGENTS_APP_TOKEN`,
    as shown.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的令牌，该令牌可用于代理应用程序，并且仅提供对`agents`路径的访问权限，并将其分配给名为`AGENTS_APP_TOKEN`的变量，如下所示。
- en: Listing 5.8 Creating a token for the Agents application
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8 为代理应用程序创建令牌
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Creating the token and printing the output in yaml format
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建令牌并以yaml格式打印输出
- en: ② Extracting the token from the response
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从响应中提取令牌
- en: 'You can view information about the token by looking up its details:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查找其详细信息来查看有关令牌的信息：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ① The id of the token that can be used to interact with the agents path
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ① 可以用于与代理路径交互的令牌的ID
- en: If the command returned an error or no values at all, confirm the value of the
    `$AGENTS_APP_TOKEN` value that was assigned in listing 5.8.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令返回了错误或没有任何值，请确认列表5.8中分配的`$AGENTS_APP_TOKEN`值的正确性。
- en: By default, the *time to live* (TTL), or the period of time in which the token
    is valid, is set for 32 days. In many enterprise organizations, limiting the length
    in time for which a token is valid increases the security posture and reduces
    the threat vector in the event a token becomes compromised. To explicitly set
    the TTL of a token, the `-ttl` flag can be added to the `vault token create` command
    to customize the duration a token is valid.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*有效期限*（TTL），或令牌有效的时长，设置为32天。在许多企业组织中，限制令牌有效的时间长度可以增加安全性，并在令牌被泄露的情况下减少威胁向量。要显式设置令牌的有效期限，可以将`-ttl`标志添加到`vault
    token create`命令中，以自定义令牌的有效时长。
- en: 'Confirm the token can only view resources in the `agents` path, as described
    by the `agents_reader` policy. First, back up the current root token to another
    location within the Vault Pod, so you can restore access later on:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 确认令牌只能查看 `agents` 路径中的资源，如 `agents_reader` 策略所述。首先，将当前根令牌备份到 Vault Pod 中的另一个位置，以便稍后可以恢复访问：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now log in with the new token created in listing 5.8:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用列表 5.8 中创建的新令牌登录：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Logging in displays key information about traits associated with the token,
    including the time it is valid and the permissions that it contains. Confirm the
    keys within the `agents` path can be listed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 登录会显示与令牌关联的键信息，包括其有效时间和包含的权限。确认 `agents` 路径中的密钥可以被列出：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If an error occurs, confirm the policy was created properly, starting with listing
    5.7.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，请确认策略已正确创建，从列表 5.7 开始。
- en: 'If the keys were listed properly, attempt to access a resource, such as listing
    enabled secrets engines for which the token should not have access:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密钥被正确列出，尝试访问资源，例如列出令牌不应具有访问权限的已启用密钥管理引擎：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the restricted level of permissions confirmed, restore the root token
    by copying the backup token to the default location Vault expects, so you can
    once again execute elevated permissions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 确认权限级别受限后，通过将备份令牌复制到 Vault 期望的默认位置来恢复根令牌，以便您可以再次执行提升权限：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Confirm an elevated request can be executed, so subsequent steps can be implemented:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 确认可以执行提升请求，以便后续步骤可以实施：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 5.1.2 Deploying an application to access Vault
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 将应用程序部署到访问 Vault
- en: Using a token that can be used to access the `agents` path within Vault, deploy
    an application that demonstrates accessing values within Vault. The source code
    is available on GitHub ([http://mng.bz/WMXa](http://mng.bz/WMXa)), but we will
    not cover the application itself from a programming perspective in this chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可以访问 Vault 中 `agents` 路径的令牌，部署一个演示在 Vault 中访问值的应用程序。源代码可在 GitHub 上找到（[http://mng.bz/WMXa](http://mng.bz/WMXa)），但本章不会从编程角度介绍该应用程序本身。
- en: 'The first step is creating a Kubernetes Secret called `agents-vault-token`,
    which will contain our token that will be injected as an environment variable
    within the application, so it can communicate with Vault:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个名为 `agents-vault-token` 的 Kubernetes Secret，它将包含我们的令牌，该令牌将被注入为应用程序中的环境变量，以便它可以与
    Vault 进行通信：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Create a file called `serviceaccount.yml` to define a Kubernetes service account
    called `agents` to associate with the application, as shown in the following listing.
    It is always recommended for each workload to be executed under a separate Service
    Account to delegate only the necessary permissions required. This will be demonstrated
    in further detail in listing 5.14.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `serviceaccount.yml` 的文件，以定义一个名为 `agents` 的 Kubernetes 服务账户，将其与应用程序关联，如下所示。始终建议每个工作负载在单独的服务账户下执行，以便仅委派所需的必要权限。这将在列表
    5.14 中进一步详细说明。
- en: Listing 5.9 serviceaccount.yml
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 serviceaccount.yml
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create the `agents` service account referencing the manifest created in the
    following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建引用以下清单的 `agents` 服务账户：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a file called `deployment_token_auth.yml` containing the manifest for
    the application that will use token-based authentication with the token defined
    within the `agents-vault-token` secret created earlier, as follows.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `deployment_token_auth.yml` 的文件，包含使用之前在 `agents-vault-token` secret 中定义的令牌进行基于令牌认证的应用程序清单，如下所示。
- en: Listing 5.10 deployment_token_auth.yml
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 deployment_token_auth.yml
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① Token stored within a Kubernetes secret injected as an environment variable
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ① 存储在 Kubernetes secret 中并作为环境变量注入的令牌
- en: 'Apply the Deployment to the cluster to create the application:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将部署应用到集群以创建应用程序：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With the deployment created, confirm the application is running:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 部署创建后，确认应用程序正在运行：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Vault token is exposed to the application via the `QUARKUS_VAULT_AUTHENTICATION_
    CLIENT_TOKEN` environment variable. The application framework then facilitates
    the backend communication to the Vault server.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 令牌通过 `QUARKUS_VAULT_AUTHENTICATION_CLIENT_TOKEN` 环境变量暴露给应用程序。然后应用程序框架促进与
    Vault 服务器的后端通信。
- en: Now test out the application to confirm values can be received. The application
    exposes a restful service at the /agents endpoint on port 8080 that can be used
    to query for agents stored in Vault.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试应用程序以确认可以接收值。应用程序在端口 8080 上通过 /agents 端点公开一个 restful 服务，可以用于查询 Vault 中存储的代理。
- en: Attempt to locate the record for the agent `bill` by first locating the name
    of the running `agents` Pod and then invoking the service at the `/agents/bill`
    endpoint.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过定位正在运行的`agents` Pod的名称，然后调用`/agents/bill`端点来尝试定位代理`bill`的记录。
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since you were able to retrieve a valid result, now attempt to retrieve a nonexistent
    value, which should return an empty result:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您能够检索到一个有效的结果，现在尝试检索一个不存在的值，应该返回一个空的结果：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Feel free to query for the other agents that were stored in Vault to fully exercise
    the application. In the next section, you will explore how to avoid using Vault
    tokens to authenticate to Vault.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 随意查询存储在Vault中的其他代理，以全面测试应用程序。在下一节中，您将探索如何避免使用Vault令牌来认证访问Vault。
- en: 5.2 Kubernetes auth method
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 Kubernetes认证方法
- en: Section 5.1.2 explored how an application can make use of Vault tokens, using
    the token auth method to interact with the Vault server to access stored values.
    While using tokens to access Vault is fairly straightforward, it requires the
    additional step of managing the life cycle of the token, which can, in the end,
    result in a reduction of the overall security posture.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 5.1.2节探讨了应用程序如何使用Vault令牌，使用令牌认证方法与Vault服务器交互以访问存储的值。虽然使用令牌访问Vault相对简单，但它需要额外的步骤来管理令牌的生命周期，这最终可能导致整体安全态势的降低。
- en: Vault, as described in 5.1, supports a diverse set of auth methods. Since you
    are operating within a Kubernetes environment, you can take advantage of a different
    method—the *Kubernetes auth method*—to simplify how applications interact with
    Vault. Using this method will prevent you from needing to oversee the additional
    task of managing tokens to access Vault.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如5.1节所述，Vault支持多种认证方法。由于您在Kubernetes环境中操作，您可以利用不同的方法——*Kubernetes认证方法*——来简化应用程序与Vault的交互。使用此方法将防止您需要管理访问Vault的令牌的额外任务。
- en: The Kubernetes auth method does not do away with the concept of tokens (quite
    the opposite), but instead of managing separate tokens that originate in Vault,
    it makes use of the JSON Web Tokens (JWTs) associated with Kubernetes Service
    Accounts. Running applications on Kubernetes interact with Vault using the Service
    Account token mounted within the Pod (`/var/run/secrets/kubernetes.io/serviceaccount/token`).
    *Roles* are then created within Vault, which map Kubernetes service accounts and
    Vault policies that define the level of access granted. A diagram of the components
    involved in the Kubernetes Auth Method is shown in figure 5.5.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes认证方法并没有消除令牌的概念（恰恰相反），但它不是管理源自Vault的单独令牌，而是使用与Kubernetes服务账户关联的JSON
    Web Tokens (JWTs)。在Kubernetes上运行的应用程序通过Pod内挂载的服务账户令牌（`/var/run/secrets/kubernetes.io/serviceaccount/token`）与Vault交互。然后在Vault中创建*角色*，这些角色将Kubernetes服务账户与定义了授予访问级别的Vault策略映射。Kubernetes认证方法中涉及的组件图示在图5.5中。
- en: '![](../Images/CH05_F05_Sotobueno3.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F05_Sotobueno3.png)'
- en: Figure 5.5 An overview of the components involved in the Kubernetes auth method
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 Kubernetes认证方法中涉及的组件概述
- en: 5.2.1 Configuring Kubernetes auth
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 配置Kubernetes认证
- en: 'Your first step is enabling the Kubernetes auth method within Vault:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一步是在Vault中启用Kubernetes认证方法：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since Vault will be interacting with the Kubernetes Service Account, it must
    be able to verify who the submitted token is associated with and if it is still
    valid. Fortunately, Kubernetes exposes the TokenReview API for just this purpose
    and essentially performs a reverse lookup of JWT tokens. By authenticating against
    the TokenReview API with a given JWT token of a ServiceAccount, details about
    the account will be returned, including, but not limited to, the username.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Vault将与Kubernetes服务账户交互，它必须能够验证提交的令牌与谁关联，以及它是否仍然有效。幸运的是，Kubernetes提供了TokenReview
    API，正是为了这个目的，并且本质上执行JWT令牌的反向查找。通过使用给定服务账户的JWT令牌对TokenReview API进行认证，将返回有关账户的详细信息，包括但不限于用户名。
- en: For Vault to interact with the Kubernetes TokenReview API to inspect tokens
    provided by applications, it must be given permissions to make such requests.
    Create a new service account called `vault-tokenreview` in a file called `vault-tokenreview-serviceaccount.yml`
    that will be used to by the Kubernetes auth method, as shown in the following
    listing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Vault能够与Kubernetes TokenReview API交互以检查应用程序提供的令牌，它必须被授予执行此类请求的权限。在名为`vault-tokenreview-serviceaccount.yml`的文件中创建一个新的服务账户`vault-tokenreview`，该账户将被Kubernetes认证方法使用，如下所示。
- en: Listing 5.11 vault-tokenreview-serviceaccount.yml
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.11 vault-tokenreview-serviceaccount.yml
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ① Name of the service account that will be used by the Kubernetes auth method
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将由 Kubernetes 认证方法使用的服务账户的名称
- en: 'Now create the `vault-tokenreview` service account using the manifest created
    in listing 5.11:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建 `vault-tokenreview` 服务账户，使用列表 5.11 中创建的清单：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With the `vault-tokenreview` service account now created, it must be granted
    permissions to make requests against the Token Review API. There is an included
    Kubernetes `ClusterRole` that provides this level of access, called `system:auth-delegator`.
    Create a new `ClusterRoleBinding` called `vault-tokenreview-binding` in a file
    called `vault-tokenreview-binding.yml`, containing the following.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经创建了 `vault-tokenreview` 服务账户，必须授予其对 Token Review API 进行请求的权限。有一个内置的 Kubernetes
    `ClusterRole` 提供这种级别的访问权限，称为 `system:auth-delegator`。在名为 `vault-tokenreview-binding.yml`
    的文件中创建一个新的 `ClusterRoleBinding`，名为 `vault-tokenreview-binding`，包含以下内容。
- en: Listing 5.12 vault-tokenreview-binding.yml
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 vault-tokenreview-binding.yml
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create the `ClusterRoleBinding` from the manifest contained in the `vault-tokenreview-binding.yml`
    file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `vault-tokenreview-binding.yml` 文件中的清单创建 `ClusterRoleBinding`：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Since the JWT of the `vault-tokenreview` service account is needed by Vault
    to communicate to Kubernetes, execute the following set of commands to first find
    the name of the Kubernetes secret that contains the JWT token and then the Base64
    decoded token value stored within the secret.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Vault 需要使用 `vault-tokenreview` 服务账户的 JWT 来与 Kubernetes 通信，请执行以下命令组，首先找到包含
    JWT 令牌的 Kubernetes 机密名称，然后是存储在机密中的 Base64 解码的令牌值。
- en: Listing 5.13 Setting Vault `TokenReview` variables
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 设置 Vault `TokenReview` 变量
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ① Locates the name of the secret associated with the vault-tokenreview ServiceAccount
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定位与 vault-tokenreview 服务账户关联的机密名称
- en: ② Obtains the JWT token for the vault-tokenreview ServiceAccount
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取 vault-tokenreview 服务账户的 JWT 令牌
- en: 'Next specify the configuration of the Kubernetes cluster by providing the location
    of the Kubernetes API, the certificate of the certificate authority, and the JWT
    of the service account obtained in listing 5.13:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过提供 Kubernetes API 的位置、证书颁发机构的证书以及列表 5.13 中获取的服务账户的 JWT，指定 Kubernetes 集群的配置：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that Vault is capable of authenticating requests, applications that want
    to obtain resources from within Vault must have a role associated with them to
    gain access to values stored within Vault. A *role* consists of the name and namespace
    of the Service Account submitting the request along with a set of Vault policies.
    Recall from listing 5.10, the Agents application is running using a Service Account
    called `agents`. While there was little distinction between which Service Account
    was used to run the application previously, it is needed at this point to facilitate
    the integration with Vault using the Kubernetes auth method. Execute the following
    to create a new role within Vault called `agents`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Vault 能够进行身份验证请求后，想要从 Vault 内部获取资源的应用程序必须与它们关联一个角色，以获取 Vault 中存储的值。一个 *角色*
    包括提交请求的服务账户的名称和命名空间，以及一组 Vault 策略。回想列表 5.10，Agents 应用程序正在使用名为 `agents` 的服务账户运行。虽然之前在运行应用程序时使用的服务账户之间几乎没有区别，但在此处需要它以方便使用
    Kubernetes 认证方法与 Vault 集成。执行以下操作以在 Vault 中创建一个名为 `agents` 的新角色：
- en: Listing 5.14 Creating a Vault role
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 创建 Vault 角色
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① Path to create a new role called agents
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建名为 agents 的新角色的路径
- en: ② Name of the service account to associate with the role
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ② 要与角色关联的服务账户的名称
- en: ③ Namespace containing the service account associated with the role
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 包含与角色关联的服务账户的命名空间
- en: ④ Policies to apply to the role
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 应用到角色的策略
- en: The creation of the role within Vault allows the Agents application to make
    use of the Kubernetes auth method to retrieve values from Vault.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vault 中创建角色的操作允许 Agents 应用程序使用 Kubernetes 认证方法从 Vault 获取值。
- en: 5.2.2 Testing and validating Kubernetes auth
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 测试和验证 Kubernetes 认证
- en: 'To test and validate the integration of Kubernetes auth within the Agents application,
    first remove any existing artifacts that may still exist from the prior token-auth-method-based
    approach, as they will no longer be needed:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试和验证 Agents 应用程序中 Kubernetes 认证的集成，首先删除任何可能仍然存在的先前基于令牌认证方法的现有工件，因为它们将不再需要：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: NOTE Feel free to ignore any errors related to resources not being found. This
    step ensures you have a fresh environment that implements the Kubernetes auth
    method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请忽略任何与资源未找到相关的错误。此步骤确保您有一个实现 Kubernetes 认证方法的全新环境。
- en: In the prior deployment of the Agents application, the `QUARKUS_VAULT_ AUTHENTICATION_CLIENT_TOKEN`
    contained the value of the token used to authenticate against Vault. When migrating
    to the Kubernetes auth method, the `QUARKUS_VAULT_ AUTHENTICATION_KUBERNETES_ROLE`
    will be used instead and reference the `agents` role created in Vault in listing
    5.14.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前部署的 Agents 应用程序中，`QUARKUS_VAULT_AUTHENTICATION_CLIENT_TOKEN` 包含了用于对 Vault
    进行认证的令牌值。当迁移到 Kubernetes 认证方法时，将使用 `QUARKUS_VAULT_AUTHENTICATION_KUBERNETES_ROLE`
    代替，并引用 Vault 中在列表 5.14 中创建的 `agents` 角色。
- en: Create a file called `deployment_kubernetes_auth.yml` containing the following
    Deployment definition.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `deployment_kubernetes_auth.yml` 的文件，包含以下 Deployment 定义。
- en: Listing 5.15 deployment_kubernetes_auth.yml
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.15 deployment_kubernetes_auth.yml
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now create the deployment from the manifest created in listing 5.15:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在根据列表 5.15 中创建的清单创建部署：
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once the application has started, query for agent `maria` to confirm the value
    stored in Vault can be successfully retrieved, thus validating the Kubernetes
    auth method has been successfully integrated.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序启动，查询代理 `maria` 以确认存储在 Vault 中的值可以成功检索，从而验证 Kubernetes 认证方法已成功集成。
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A successful response demonstrates how the Kubernetes auth method can be used
    to retrieve secrets from Vault, without explicitly providing the application a
    Vault token to authenticate. If a successful result was not returned, confirm
    the steps described in this section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的响应展示了如何使用 Kubernetes 认证方法从 Vault 中检索机密，而不需要明确地为应用程序提供一个 Vault 令牌进行认证。如果没有返回成功的结果，请确认本节中描述的步骤。
- en: 5.3 The Vault Agent Injector
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 Vault 代理注入器
- en: The Kubernetes Auth Method simplified how applications deployed on Kubernetes
    can access values stored within Vault. One of the challenges presented by using
    either the token or Kubernetes auth methods, as described in section 5.2.1, is
    that the application needs to be Vault aware. In many cases, especially in legacy
    applications or those provided by third-party vendors, it may not be possible
    to modify the source code to configure this type of integration.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 认证方法简化了在 Kubernetes 上部署的应用程序访问 Vault 中存储的值的方式。使用令牌或 Kubernetes 认证方法（如
    5.2.1 节所述）所面临的挑战之一是，应用程序需要了解 Vault。在许多情况下，尤其是在遗留应用程序或第三方供应商提供的应用程序中，可能无法修改源代码来配置此类集成。
- en: To overcome these challenges, several approaches emerged, using patterns in
    the Kubernetes ecosystem to address how values stored within Vault are made available
    to applications. Each leaned on a key characteristic of a Pod in Kubernetes, through
    which volumes could be shared between containers using an `emptyDir` volume type.
    A separate container could then be packaged within the Pod with the responsibility
    of facilitating the interaction with Vault and providing the secret values to
    the application through the shared volume.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些挑战，出现了几种方法，利用 Kubernetes 生态系统中的模式来解决如何使存储在 Vault 中的值可供应用程序使用。每种方法都依赖于
    Kubernetes 中 Pod 的一个关键特性，通过该特性可以使用 `emptyDir` 卷类型在容器之间共享卷。然后可以在 Pod 中打包一个单独的容器，其责任是促进与
    Vault 的交互并通过共享卷向应用程序提供机密值。
- en: 'Two patterns in Kubernetes were adopted to support this approach:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中采用了两种模式来支持这种方法：
- en: '*init container*—A container, or set of containers, that executes before the
    application containers are started. In the context of Vault, assets are retrieved
    from Vault and placed in a shared volume that is pre-populated for the application
    to consume.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*init container*—在应用程序容器启动之前执行的一个容器或一组容器。在 Vault 的上下文中，从 Vault 中检索资产并将其放置在为应用程序预先填充的共享卷中，以便应用程序可以消费。'
- en: '*sidecar*–Containers that run alongside the application container. In the context
    of Vault, they continue to interact with Vault and refresh the content of the
    shared volume with assets from Vault.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*sidecar*–与应用程序容器一起运行的容器。在 Vault 的上下文中，它们继续与 Vault 交互并使用 Vault 的资产刷新共享卷的内容。'
- en: To avoid the burden of requiring end users to develop and maintain their own
    set of containers for interacting with Vault as well as providing a mechanism
    for automatically injecting Vault-aware containers into Pods, the Vault Agent
    Injector from HashiCorp was created. The *Vault Agent Injector* runs as a Pod
    in Kubernetes and monitors for applications seeking to becoming Vault aware, based
    on annotations declared within their Pod. Once the injector has been installed
    to a cluster, when any other Pod is created, an admission webhook is sent to the
    Vault Agent Injector with the details of the Pod. If specific annotations and,
    in particular, `vault.hashicorp.com/agent-inject:` `true` are present within the
    Pod, the definition of Pod itself is modified to automatically inject an `initContainer`
    and/or `sidecar` container. This process leverages the Kubernetes `MutatingWebhookConfiguration`
    feature, which allows the modification of Kubernetes resources before they are
    persisted to `etcd` (figure 5.6).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免要求最终用户开发和维护他们自己的容器集以与Vault交互，并提供一种机制以自动将具有Vault意识的容器注入Pod，HashiCorp创建了Vault
    Agent Injector。*Vault Agent Injector* 在Kubernetes中以Pod的形式运行，并监视声明在其Pod中的注解以寻求成为Vault意识的应用程序。一旦将注入器安装到集群中，当创建任何其他Pod时，就会向Vault
    Agent Injector发送一个准入webhook，其中包含Pod的详细信息。如果Pod中存在特定的注解，特别是 `vault.hashicorp.com/agent-inject:`
    `true`，则修改Pod本身的定义以自动注入 `initContainer` 和/或 `sidecar` 容器。此过程利用了Kubernetes的 `MutatingWebhookConfiguration`
    功能，该功能允许在资源持久化到 `etcd` 之前修改Kubernetes资源（图 5.6）。
- en: '![](../Images/CH05_F06_Sotobueno3.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH05_F06_Sotobueno3.png)'
- en: Figure 5.6 A Pod being modified by the `MutatingWebhookConfiguration` to inject
    the Vault Agent Injector at admission time
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 通过 `MutatingWebhookConfiguration` 在准入时间修改Pod以注入Vault Agent Injector
- en: 5.3.1 Configurations to support Kubernetes Vault Agent injection
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 支持Kubernetes Vault Agent注入的配置
- en: To demonstrate how an application can have values stored in Vault injected with
    minimal changes to the application itself, you’ll once again use the Agents application
    as the target. First define a new secret within Vault called `config`, containing
    properties related to the application. Through the Vault Agent Injector, the values
    provided within the secret will be added to a file within the application Pod.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示应用程序如何通过最小化对应用程序本身的更改将存储在Vault中的值注入，你将再次使用代理应用程序作为目标。首先在Vault中定义一个新的名为 `config`
    的密钥，包含与应用程序相关的属性。通过Vault Agent Injector，密钥中的值将被添加到应用程序Pod内的一个文件中。
- en: First define the `config` secret in Vault by executing the command as follows.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过以下命令在Vault中定义 `config` 密钥。
- en: Listing 5.16 Creating a key–value secret
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16 创建键值密钥
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ① Writing data to the specified path
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将数据写入指定的路径
- en: ② Writing multiple key–value pairs to the secret
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将多个键值对写入密钥
- en: With the new value added, the next step is modifying the Deployment for the
    Agents application by defining several annotations needed to not only support
    automatic container injection but also to customize how the values presented in
    the Pod.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新值之后，下一步是修改代理应用程序的Deployment，通过定义几个必要的注解，不仅支持自动容器注入，还可以自定义Pod中呈现的值。
- en: Create a new file called `deployment_vault_agent.yml`, as shown.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `deployment_vault_agent.yml` 的新文件，如下所示。
- en: Listing 5.17 deployment_vault_agent.yml
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.17 deployment_vault_agent.yml
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ① Enables Vault Agent injection
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ① 启用Vault Agent注入
- en: ② The name of the role associated with the Kubernetes auth method
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ② 与Kubernetes认证方法关联的角色名称
- en: ③ The name of the Vault secret as the value and the resulting filename within
    the application Pod
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ③ Vault密钥的名称作为值以及应用程序Pod中的结果文件名
- en: ④ A template to describe how the secret content will be rendered
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 描述密钥内容如何呈现的模板
- en: The Vault Agent Injector builds upon the Kubernetes auth method, so a portion
    of the configurations applied in section 5.1 will be reused.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Vault Agent Injector建立在Kubernetes认证方法之上，因此将重用第5.1节中应用的部分配置。
- en: The `vault.hashicorp.com/role` denotes the name of the role associated with
    the service account running the Pod as well as the policies for granting access
    to content within Vault. The code line beginning with `vault.hashicorp.com/agent-inject-secret-`
    is used to define the file that will ultimately be created within the application
    Pod. The value of this annotation refers to the name of the secret within Vault.
    The secret `config` within the `agents` path was created in listing 5.16\. The
    remainder of the annotation key refers to the name of the file that will be created
    in the Pod. So an annotation with the key `vault.hashicorp.com/agent-inject-secret-config.properties`
    results in a file named `config.properties` within the Pod.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`vault.hashicorp.com/role` 表示与运行 Pod 的服务账户相关联的角色以及授予访问 Vault 内容的策略。以 `vault.hashicorp.com/agent-inject-secret-`
    开头的代码行用于定义最终将在应用 Pod 中创建的文件。此注释的值引用了 Vault 中的密钥名称。在列表 5.16 中创建的 `agents` 路径中的
    `config` 密钥。注释键的其余部分引用了将在 Pod 中创建的文件名。因此，具有键 `vault.hashicorp.com/agent-inject-secret-config.properties`
    的注释会在 Pod 中创建一个名为 `config.properties` 的文件。'
- en: Finally, the code line beginning with `vault.hashicorp.com/agent-inject-template-`
    refers to a template in the Consul language and defines how the content of the
    secret is rendered. Like the line beginning with `vault.hashicorp.com/agent-inject-secret-`,
    the remaining portion references the name of the file that will be created. The
    template defined here merely loops through all the keys and values contained within
    the secret.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以 `vault.hashicorp.com/agent-inject-template-` 开头的代码行指的是 Consul 语言中的模板，并定义了密钥内容的渲染方式。与以
    `vault.hashicorp.com/agent-inject-secret-` 开头的行类似，其余部分引用了将要创建的文件名。这里定义的模板只是遍历密钥中包含的所有键和值。
- en: 'If an existing agents deployment is present in the cluster, delete it to ensure
    any of the existing integrations with Vault, as described in sections 5.1.2 and
    5.2, are not used moving forward:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集群中存在现有的代理部署，请将其删除以确保不会使用 5.1.2 和 5.2 节中描述的与 Vault 的任何现有集成：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now execute the following command to create the agents deployment, which will
    make use of the Kubernetes Vault Agent Injector:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下命令以创建代理部署，该部署将使用 Kubernetes Vault Agent Injector：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If you observe the state of the `agents` Pod, you will notice several differences
    with this deployment.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察 `agents` Pod 的状态，您将注意到与这次部署有几种不同的情况。
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: First notice, under the `READY` column, there are now two containers. The additional
    container is the sidecar responsible for keeping the contents of the secrets sourced
    from Vault up to date. In addition, before either the sidecar or agents container
    started, an init container called `vault-agent-init` also present in the Pod preseeded
    the an `emptyDir` volume mounted at `/vault/secrets` with the contents of the
    Vault secret. (This path can be modified via an annotation.) Since the init container
    must successfully complete before starting the primary containers, and since both
    containers within the Pod are currently running, you can rest assured the secret
    values have been retrieved from Vault. Let’s verify by viewing the contents of
    the file located at `/vault/secrets/config.properties` within the `agents` container.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意，在 `READY` 列下，现在有两个容器。额外的容器是负责保持从 Vault 获取的密钥内容更新的边车容器。此外，在边车容器或代理容器启动之前，Pod
    中还包含一个名为 `vault-agent-init` 的初始化容器，该初始化容器在 `/vault/secrets` 挂载点处预填充了 Vault 密钥的内容。（此路径可以通过注释进行修改。）由于初始化容器必须在启动主容器之前成功完成，并且由于
    Pod 中的两个容器目前都在运行，您可以放心地认为密钥值已从 Vault 中检索出来。让我们通过查看位于 `agents` 容器中 `/vault/secrets/config.properties`
    文件的内容来验证这一点。
- en: Listing 5.18 Viewing the file created by the vault secrets injector
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.18 查看由 vault secrets injector 创建的文件
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ① Obtaining the name of the running agents Pod
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ① 获取正在运行的代理 Pod 的名称
- en: ② Printing the contents of the file created by the Vault Agent Injector
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ② 打印由 Vault Agent Injector 创建的文件的内容
- en: Feel free to update the contents of the `config` secret within Vault. The sidecar
    container bundled within the Pod will routinely check the status of the secret
    and update the contents of the file within the application container. By using
    the Kubernetes Vault Agent Injector, Vault secrets can be provided automatically
    to application without any changes to the application, abstracting the use of
    Vault entirely, while providing the benefits of referencing sensitive values stored
    in HashiCorp Vault.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随意更新 Vault 中 `config` 机密的内容。Pod 内捆绑的边车容器将定期检查机密的状态，并更新应用程序容器内文件的内容。通过使用 Kubernetes
    Vault Agent Injector，可以在不修改应用程序的情况下自动提供 Vault 机密，完全抽象化 Vault 的使用，同时提供引用存储在 HashiCorp
    Vault 中的敏感值的优点。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: HashiCorp Vault can be installed quickly and easily to a Kubernetes environment
    using a Helm chart.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Helm 图表，可以快速轻松地将 HashiCorp Vault 安装到 Kubernetes 环境中。
- en: Unsealing a HashiCorp Vault instance is the process of obtaining the plain text
    root key to enable access to the underlying data.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解密 HashiCorp Vault 实例是获取纯文本根密钥的过程，以启用对底层数据的访问。
- en: The Kubernetes auth method uses a Kubernetes service account to authenticate
    with HashiCorp Vault.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 认证方法使用 Kubernetes 服务帐户与 HashiCorp Vault 进行身份验证。
- en: The Kubernetes TokenReview API provides a method for extracting user details
    from a JWT token.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes TokenReview API 提供了一种从 JWT 令牌中提取用户详情的方法。
- en: The HashiCorp Vault Agent Injector mutates the definition of a Pod, allowing
    it to obtain secrets stored in Vault.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Vault Agent Injector 修改了 Pod 的定义，使其能够获取存储在 Vault 中的机密。
