- en: Part 4\. C# 7 and beyond
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4部分\. C# 7及以后
- en: 'C# 7 is the first release since C# 1 to have multiple minor releases.^([[1](#part04fn1)])
    There have been four releases:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7是自C# 1以来的第一个发布版本，它有多个小版本发布.^([[1](#part04fn1)]) 共有四个版本：
- en: ¹
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Visual Studio 2002 included C# 1.0, and Visual Studio 2003 included C# 1.2\.
    I’ve no idea why the version number skipped 1.1, and it’s not clear what the differences
    were between the two versions.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Visual Studio 2002包含了C# 1.0，而Visual Studio 2003包含了C# 1.2。我不知道为什么版本号跳过了1.1，而且两个版本之间的差异也不清楚。
- en: C# 7.0 in March 2017 with Visual Studio 2017 version 15.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2017年3月发布的C# 7.0与Visual Studio 2017版本15.0
- en: C# 7.1 in August 2017 with Visual Studio 2017 version 15.3
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2017年8月发布的C# 7.1与Visual Studio 2017版本15.3
- en: C# 7.2 in December 2017 with Visual Studio 2017 version 15.5
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2017年12月发布的C# 7.2与Visual Studio 2017版本15.5
- en: C# 7.3 in May 2018 with Visual Studio 2017 version 15.7
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2018年5月发布的C# 7.3与Visual Studio 2017版本15.7
- en: Most of the minor releases have expanded on new features introduced in earlier
    C# 7.x releases rather than introducing entirely new areas, although the ref-related
    features covered in [chapter 13](kindle_split_030_split_000.html#ch13) were greatly
    expanded in C# 7.2.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数的小版本发布都是基于之前C# 7.x版本中引入的新特性进行扩展，而不是引入全新的领域，尽管在第13章中涵盖的与ref相关的特性在C# 7.2中得到了极大的扩展。
- en: As far as I’m aware, no plans exist for a C# 7.4 release, although I wouldn’t
    completely rule it out. Having multiple versions seems to have worked reasonably
    well, and I expect the same sort of release cycle for C# 8.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 据我所知，目前没有C# 7.4发布的计划，尽管我不会完全排除它。多个版本似乎已经工作得相当好，我预计C# 8也将有类似的发布周期。
- en: There’s more to talk about in C# 7 than in C# 6, because the features are more
    complex. Tuples have an interesting separation between the types as the compiler
    considers them and the types that the CLR uses. Local methods fascinate me in
    terms of comparing their implementation with that of lambda expressions. Pattern
    matching is reasonably simple to understand but requires a certain amount of thought
    in terms of using it to its best advantage. The ref-related features are inherently
    complicated even when they sound simple. (I’m looking at you, `in` parameters.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7中要讨论的内容比C# 6要多，因为特性更加复杂。元组在编译器视为的类型和CLR使用的类型之间有一个有趣的分离。局部方法在比较它们的实现与lambda表达式时让我着迷。模式匹配相对简单易懂，但要在最佳优势下使用它，需要一定的思考。与ref相关的特性即使听起来简单，本质上也是复杂的。（我指的是`in`参数。）
- en: Although I expect most developers to find most C# 6 features useful every day,
    you may find some of the C# 7 features aren’t useful to you at all. I rarely use
    tuples in my code, because I usually target platforms where they’re not available.
    I don’t use the ref-related features much, as I’m not coding in a context where
    they’re particularly useful. This doesn’t stop them from being good features;
    they’re just not universally applicable. Other C# 7 features, such as pattern
    matching, `throw` expressions, and numeric literal improvements, are more likely
    to be useful to all developers but perhaps with less impact than the more targeted
    features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我预计大多数开发者会发现C# 6的特性在日常使用中非常有用，但你可能会发现一些C# 7的特性对你来说一点用处都没有。我很少在我的代码中使用元组，因为我通常针对的平台不支持它们。由于我编写的代码环境不特别需要这些特性，所以我很少使用与ref相关的特性。这并不妨碍它们成为好的特性；它们只是不是普遍适用的。其他C#
    7特性，如模式匹配、`throw`表达式和数字字面量改进，更有可能对所有开发者都有用，但可能影响不如更针对性的特性大。
- en: I mention all of this merely to set expectations. As always, when you read about
    a feature, consider how you might apply it in your own code. Don’t feel forced
    to apply it; there are no points for using the most language features in the shortest
    amount of code. If you find you don’t have a use for that feature right now, that’s
    fine. Just remember it’s there so if you’re in a different context later, you
    know what’s available.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是提到这些，只是为了设定预期。就像往常一样，当你阅读关于某个特性的内容时，考虑一下你如何在你的代码中应用它。不要感到被迫去应用它；使用最多的语言特性在最短的代码中并不会得到任何分数。如果你发现你现在没有用到那个特性，那也没关系。只需记住它在那里，这样如果你在未来的不同环境中，你就知道有哪些可用。
- en: It’s also important for me to set expectations about [chapter 15](kindle_split_032_split_000.html#ch15),
    which looks at the future of C#. Most of the chapter demonstrates features already
    available in C# 8 preview builds, but there’s no guarantee that all of those features
    will ship in the final build, and there may well be other features I haven’t mentioned
    at all. I hope you will find the features I’ve written about as exciting as I
    do and will keep watch for new previews and blog posts by the C# team. This is
    an exciting time to be a C# developer, both in terms of what we have today and
    the promise of a bright future.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我来说，设定对[第15章](kindle_split_032_split_000.html#ch15)的期望也很重要，该章节探讨了C#的未来。本章的大部分内容演示了已在C#
    8预览版本中可用的功能，但并不能保证所有这些功能都将包含在最终版本中，而且可能还有我没有提到的其他功能。我希望你会发现我写的功能和我一样令人兴奋，并关注C#团队的新预览和博客文章。对于C#开发者来说，这是一个激动人心的时刻，无论是从我们今天拥有的东西，还是从光明的未来前景来看。
- en: Chapter 11\. Composition using tuples
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章\. 使用元组进行组合
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Using tuples to compose data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组组合数据
- en: 'Tuple syntax: literals and types'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组语法：字面量和类型
- en: Converting tuples
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换元组
- en: How tuples are represented in the CLR
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组在CLR中的表示
- en: Alternatives to tuples and guidelines for their use
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组的替代方案及其使用指南
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Back in C# 3, LINQ revolutionized how we write code to handle collections of
    data. One of the ways it did that was to allow us to express many operations in
    terms of how we want to handle each individual item: how to transform an item
    from one representation to another, or how to filter items out of the result,
    or how to sort the collection based on a particular aspect of each item. For all
    that, LINQ didn’t give us many new tools for working with noncollections.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 回到C# 3，LINQ革命性地改变了我们编写代码来处理数据集合的方式。它实现这一目标的方式之一是允许我们以我们想要处理每个单独项目的方式表达许多操作：如何将一个项目从一种表示形式转换为另一种表示形式，或者如何从结果中过滤掉项目，或者如何根据每个项目的特定方面对集合进行排序。对于所有这些，LINQ并没有为我们提供许多用于处理非集合的新工具。
- en: Anonymous types provide one kind of composition but with the huge restriction
    of being useful only within a block of code. You can’t declare that a method returns
    an anonymous type precisely because the return type can’t be named.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型提供了一种组合方式，但有一个巨大的限制，即仅在代码块内有效。你不能声明一个方法返回匿名类型，正是因为返回类型无法命名。
- en: C# 7 introduces support for tuples to make data composition simple along with
    deconstruction from a composite type into its individual components. If you’re
    now thinking to yourself that C# already has tuples in the form of the `System.Tuple`
    types, you’re right to an extent; those types already exist in the framework but
    don’t have any language support. To add to the confusion, C# 7 doesn’t use those
    tuple types for its language-supported tuples. It uses a new set of `System.ValueTuple`
    types, which you’ll explore in [section 11.4](kindle_split_028_split_000.html#ch11lev1sec4).
    There’s a comparison with `System.Tuple` in [section 11.5.1](kindle_split_028_split_000.html#ch11lev2sec19).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7引入了对元组的支持，以便简化数据的组合以及从复合类型到其单个组件的解构。如果你现在正在想，C#已经以`System.Tuple`类型的形式有了元组，你是对的，在某种程度上；这些类型已经在框架中存在，但没有任何语言支持。为了增加混乱，C#
    7并没有使用这些元组类型来支持其语言支持的元组。它使用了一组新的`System.ValueTuple`类型，你将在[第11.4节](kindle_split_028_split_000.html#ch11lev1sec4)中了解它们。在[第11.5.1节](kindle_split_028_split_000.html#ch11lev2sec19)中有与`System.Tuple`的比较。
- en: 11.1\. Introduction to tuples
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. 元组简介
- en: Tuples allow you to create a single composite value from multiple individual
    values. They’re shorthand for composition with no extra encapsulation for situations
    where values are related to each other but you don’t want the work of creating
    a new type. C# 7 introduces new syntax to make working with tuples simple.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 元组允许你从多个单个值创建一个单一的复合值。它们是用于值之间相关联但不需要创建新类型的组合的简写。C# 7引入了新的语法，使处理元组变得简单。
- en: 'As an example, suppose you have a sequence of integers and you want to find
    both the minimum and the maximum in one pass. This sounds like you should be able
    to put that code into a single method, but what would you make the return type?
    You could return the minimum value and use an `out` parameter for the maximum
    value or use two `out` parameters, but both of those feel fairly clunky. You could
    create a separate named type, but that’s a lot of work for just one example. You
    could return a `Tuple<int, int>` using the `Tuple<,>` class introduced in .NET
    4, but then you couldn’t easily tell which was the minimum value and which was
    the maximum (and you’d end up allocating an object just to return the two values).
    Or you could use C# 7’s tuples. You could declare the method like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一系列整数，并且你想要在一次遍历中找到最小值和最大值。这听起来你应该能够将这段代码放入一个单独的方法中，但你应该将返回类型设为什么？你可以返回最小值并使用`out`参数来获取最大值，或者使用两个`out`参数，但这些都感觉相当笨拙。你可以创建一个单独的命名类型，但这对于仅仅一个例子来说工作量很大。你可以使用.NET
    4中引入的`Tuple<,>`类返回`Tuple<int, int>`，但这样你就不容易区分哪个是最小值，哪个是最大值（你最终会分配一个对象来返回这两个值）。或者你可以使用C#
    7的元组。你可以这样声明方法：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then you could call it like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以这样调用它：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Calls the method to compute the min and max and returns them as a tuple**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用方法计算最小值和最大值，并以元组的形式返回**'
- en: '***2* Prints out the minimum value (-5)**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印出最小值（-5）**'
- en: '***3* Prints out the maximum value (10)**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印出最大值（10）**'
- en: You’ll look at a couple of implementations of `MinMax` shortly, but this example
    should give you enough of an idea about the purpose of the feature to make it
    worth reading all the fairly detailed descriptions over the course of the chapter.
    For a feature that sounds simple, there’s quite a lot to say about tuples, and
    it’s all interrelated, which makes it hard to describe in a logical order. If
    you find yourself asking “But what about...?” while reading, I urge you to mentally
    put a pin in the question until the end of the section. Nothing here is complex,
    but there’s a lot to get through, especially because I’m aiming to be comprehensive.
    Hopefully, by the time you reach the end of the chapter, all your questions will
    be answered.^([[1](kindle_split_028_split_000.html#ch11fn1)])
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会看到`MinMax`的几个实现，但这个例子应该足以让你了解该特性的目的，使得阅读本章中相当详细的所有描述都值得。对于一个听起来简单的特性，元组有很多东西可以讨论，而且它们都是相互关联的，这使得很难按逻辑顺序描述。如果你在阅读时发现自己想“但是……怎么办？”的话，我强烈建议你在本节结束时再思考这个问题。这里没有什么复杂的，但有很多东西需要理解，尤其是因为我旨在全面。希望在你读到本章末尾时，所有的问题都会得到解答.^([[1](kindle_split_028_split_000.html#ch11fn1)])
- en: ¹
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If they’re not, you should ask for more information on the Author Online forum
    or Stack Overflow, of course.
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它们不是，你当然应该在作者在线论坛或Stack Overflow上请求更多信息。
- en: 11.2\. Tuple literals and tuple types
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2. 元组字面量和元组类型
- en: You can think of tuples as the introduction of some types into the CLR and some
    syntactic sugar to make those types easy to use, both in terms of specifying them
    (for variables and so on) and constructing values. I’m going to start off explaining
    everything from the perspective of the C# language without worrying too much about
    how it maps onto the CLR; then I’ll loop back to explain everything the compiler
    is doing for you behind the scenes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将元组视为将一些类型引入CLR以及一些语法糖，以便于使用这些类型，无论是指定它们（对于变量等）还是构造值。我将从C#语言的角度开始解释一切，而不太关心它如何映射到CLR；然后我会回过头来解释编译器为你幕后所做的一切。
- en: 11.2.1\. Syntax
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1. 语法
- en: 'C# 7 introduces two new pieces of syntax: tuple literals and tuple types. They
    look similar: they’re both comma-separated sequences of two or more elements in
    parentheses. In a *tuple literal*, each element has a value and an optional name.
    In a *tuple type*, each element has a type and an optional name. [Figure 11.1](kindle_split_028_split_000.html#ch11fig01)
    shows an example of a tuple literal; [figure 11.2](kindle_split_028_split_000.html#ch11fig02)
    shows an example of a tuple type. Each has one named element and one unnamed element.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 引入了两种新的语法：元组字面量和元组类型。它们看起来很相似：它们都是用逗号分隔的括号中两个或更多元素的序列。在元组字面量中，每个元素都有一个值和一个可选的名称。在元组类型中，每个元素都有一个类型和一个可选的名称。[图11.1](kindle_split_028_split_000.html#ch11fig01)
    展示了一个元组字面量的例子；[图11.2](kindle_split_028_split_000.html#ch11fig02) 展示了一个元组类型的例子。每个都有一个命名元素和一个未命名元素。
- en: Figure 11.1\. A tuple literal with element values `5` and `"text"`. The second
    element is named `title`.
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.1\. 元组字面量，元素值为 `5` 和 `"text"`。第二个元素被命名为 `title`。
- en: '![](../Images/11fig01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig01.jpg)'
- en: Figure 11.2\. A tuple type with element types `int` and `Guid`. The first element
    is named `x`.
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.2\. 元组类型，元素类型为 `int` 和 `Guid`。第一个元素被命名为 `x`。
- en: '![](../Images/11fig02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig02.jpg)'
- en: 'In practice, it’s more common for either all the elements to be named or none
    of them to be named. For example, you might have tuple types of `(int, int)` or
    `(int x, int y, int z)`, and you might have tuple literals of `(x: 1, y: 2)` or
    `(1, 2, 3)`. But this is a coincidence; nothing is tying the elements together
    in terms of whether they have names. There are two restrictions on names to be
    aware of, though:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，所有元素都有名称或没有任何名称的情况更为常见。例如，你可能会有 `(int, int)` 或 `(int x, int y, int z)`
    这样的元组类型，以及 `(x: 1, y: 2)` 或 `(1, 2, 3)` 这样的元组字面量。但这只是一个巧合；没有任何东西将元素绑定在一起，关于它们是否有名称。不过，有两个关于名称的限制需要注意：'
- en: 'The names have to be unique within the type or literal. A tuple literal of
    `(x: 1, x: 2)` isn’t allowed and wouldn’t make any sense.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '名称必须在类型或字面量内是唯一的。不允许有 `(x: 1, x: 2)` 这样的元组字面量，并且这也没有任何意义。'
- en: 'Names of the form `ItemN`, where `N` is an integer, are allowed only where
    the value of `N` matches the position in the literal or type, starting at 1\.
    So `(Item1: 0, Item2: 0)` is fine, but `(Item2: 0, Item1: 0)` is prohibited. You’ll
    see why this is the case in the next section.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '形如 `ItemN` 的名称，其中 `N` 是一个整数，只有在 `N` 的值与字面量或类型中的位置相匹配时才允许，从 1 开始。所以 `(Item1:
    0, Item2: 0)` 是可以的，但 `(Item2: 0, Item1: 0)` 是禁止的。你将在下一节中看到为什么这是这种情况。'
- en: 'Tuple types are used to specify types in the same places other type names are
    used: variable declarations, method return types, and so on. Tuple literals are
    used like any other expression specifying a value; they simply compose those elements
    into a tuple value.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 元组类型用于在与其他类型名称相同的位置指定类型：变量声明、方法返回类型等。元组字面量像任何其他指定值的表达式一样使用；它们只是将这些元素组合成一个元组值。
- en: 'The element values in a tuple literal can be any value other than a pointer.
    Most of the examples in this chapter use constants (primarily integers and strings)
    for convenience, but you’ll often use variables as the element values in a literal.
    Similarly, the element types in a tuple can be any nonpointer type: arrays, type
    parameters, even other tuple types.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 元组字面量中的元素值可以是任何非指针值。本章中的大多数示例为了方便起见使用了常量（主要是整数和字符串），但你通常会在字面量中使用变量作为元素值。同样，元组中的元素类型可以是任何非指针类型：数组、类型参数，甚至是其他元组类型。
- en: 'Now that you know what a tuple type looks like, you can understand the return
    type `(int min, int max)` for our `MinMax` method:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了元组类型的样子，你可以理解我们的 `MinMax` 方法的返回类型 `(int min, int max)`：
- en: It’s a tuple type with two elements.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个包含两个元素的元组类型。
- en: The first element is an `int` named `min`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个元素是一个名为 `min` 的 `int`。
- en: The second element is an `int` named `max`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个元素是一个名为 `max` 的 `int`。
- en: You also know how to create a tuple by using a tuple literal, so you can implement
    our method completely, as shown in the following listing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你也知道如何通过使用元组字面量来创建元组，因此你可以完全实现我们的方法，如下所示。
- en: Listing 11.1\. Representing the minimum and maximum values of a sequence as
    a tuple
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.1\. 将序列的最小和最大值表示为元组
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Return type is a tuple with named elements.**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回类型是一个具有命名元素的元组。**'
- en: '***2* Prohibits empty sequences**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 禁止空序列**'
- en: '***3* Uses regular int variables to keep track of min/max**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用常规的 int 变量来跟踪 min/max**'
- en: '***4* Updates the variables with the new min/max**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 更新变量以获取新的 min/max**'
- en: '***5* Constructs a tuple from min and max**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从 min 和 max 构造元组**'
- en: 'The only parts of [listing 11.1](kindle_split_028_split_000.html#ch11ex01)
    that involve new features are the return type that I’ve already explained and
    the `return` statement, which uses a tuple literal:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.1](kindle_split_028_split_000.html#ch11ex01) 中涉及新特性的只有我已经解释过的返回类型和使用了元组字面量的
    `return` 语句：'
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So far, I haven’t talked about the type of a tuple literal. I’ve only said that
    they’re used to create tuple values, but I’m going to deliberately leave that
    somewhat vague at the moment. I’ll note that our tuple literal doesn’t have any
    element names at the moment, at least not in C# 7.0\. The `min` and `max` parts
    provide the values for the elements using the local variables in the method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我还没有谈论元组字面量的类型。我只说过，它们用于创建元组值，但我会故意暂时对此保持模糊。我将指出，我们的元组字面量目前没有任何元素名称，至少在
    C# 7.0 中是这样。`min`和`max`部分使用方法中的局部变量为元素提供值。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Good tuple element names match good variable names**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**好的元组元素名称与好的变量名称相匹配**'
- en: 'Is it a coincidence that the variable names used in the literal match the names
    used in method’s return type? As far as the compiler is concerned, absolutely.
    The compiler wouldn’t care if you declared the method to return `(waffle: int,
    iceCream : int)`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '使用字面量中的变量名称与方法返回类型中使用的名称匹配是巧合吗？就编译器而言，绝对是。编译器不会关心你是否声明方法返回`(waffle: int, iceCream
    : int)`。'
- en: For a human reader, it’s far from a coincidence; the names indicate that the
    values have the same meaning in the returned tuple as they do within the method.
    If you find yourself providing very different names, you might want to check whether
    you have a bug or whether perhaps some of the names could be chosen better.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类读者来说，这绝对不是巧合；名称表明返回的元组中的值与在方法中的含义相同。如果你发现自己提供了非常不同的名称，你可能想检查是否有错误，或者是否可能某些名称的选择更好。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: While we’re defining terms, let’s define the *arity* of a tuple type or literal
    as the number of elements it has. For example, `(int, long)` has an arity of 2,
    and (`"a", "b", "c")` has an arity of 3\. The element types themselves are irrelevant
    to the arity.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在定义术语时，让我们定义元组类型或字面量的*元数*为其拥有的元素数量。例如，`(int, long)`的元数为2，而(`"a", "b", "c")`的元数为3。元素类型本身与元数无关。
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This isn’t new terminology, really. The concept of arity already exists in generics,
    where the arity is the number of type parameters. The `List<T>` type has an arity
    of 1, whereas `Dictionary<TKey, TValue>` has an arity of 2.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是新术语。arity 的概念已经在泛型中存在，arity 是类型参数的数量。`List<T>`类型具有1个arity，而`Dictionary<TKey,
    TValue>`具有2个arity。
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The tip around good element names matching good variable names really gives
    a hint as to an aspect of tuple literals that was improved in C# 7.1.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于好的元素名称与好的变量名称的建议实际上为元组字面量改进的一个方面提供了线索。
- en: 11.2.2\. Inferred element names for tuple literals (C# 7.1)
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2. 元组字面量的推断元素名称（C# 7.1）
- en: 'In C# 7.0, tuple element names had to be explicitly stated in code. This would
    often lead to code that looked redundant: the names specified in the tuple literal
    would match the property or local variable names used to provide the values. In
    the simplest form, this might be something like the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7.0 中，元组元素名称必须在代码中显式声明。这通常会导出看起来冗余的代码：元组字面量中指定的名称将与提供值的属性或局部变量名称匹配。在最简单的情况下，这可能类似于以下内容：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The inference doesn’t just apply when your code uses simple variables, though;
    tuples are often initialized from properties, too. This is particularly prevalent
    in LINQ with projections.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 推断不仅适用于你的代码使用简单变量时；元组通常也初始化自属性。这在 LINQ 中的投影尤其普遍。
- en: 'In C# 7.1, tuple element names are inferred when the value comes from a variable
    or property in exactly the same way as names are inferred in anonymous types.
    To see how useful this is, let’s consider three ways of writing a query in LINQ
    to Objects that joins two collections to obtain the names, job titles, and departments
    of employees. First, here’s traditional LINQ using anonymous types:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7.1 中，当值来自变量或属性时，元组元素名称的推断方式与匿名类型中名称的推断方式完全相同。为了了解这有多有用，让我们考虑三种在 LINQ to
    Objects 中编写查询的方法，该方法将两个集合连接起来以获取员工的姓名、职位和部门。首先，这是使用匿名类型的传统 LINQ：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we’ll use tuples with explicit element names:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用具有显式元素名称的元组：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we’ll use inferred element names with C# 7.1:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用 C# 7.1 的推断元素名称：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This changes the case of the tuple elements compared with the previous example
    but still achieves the goal of creating tuples with useful names using concise
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例相比，这改变了元组元素的名称，但仍然达到了使用简洁代码创建具有有用名称的元组的目标。
- en: 'Although I’ve demonstrated the feature within a LINQ query, it applies anywhere
    you use tuple literals. For example, given a list of elements, you could create
    a tuple with the count, min, and max by using element name inference for the count:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我已经在LINQ查询中演示了该功能，但它适用于你使用元组字面量的任何地方。例如，给定一个元素列表，你可以通过使用计数元素的名称推断来创建一个包含计数、最小值和最大值的元组：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that you still need to specify element names for `Min` and `Max`, because
    those values are obtained using method invocations. Method invocations don’t provide
    inferred names for either tuple elements or anonymous type properties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你仍然需要为`Min`和`Max`指定元素名称，因为这些值是通过方法调用获得的。方法调用既不提供元组元素的推断名称，也不提供匿名类型属性的推断名称。
- en: As one slight wrinkle, if two names would both be inferred to be the same, neither
    is inferred. If there’s a collision between an inferred name and an explicit name,
    the explicit name takes priority and the other element remains unnamed. Now that
    you know how to specify tuple types and tuple literals, what can you do with them?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小小的细节，如果两个名称都会被推断为相同，则都不会被推断。如果推断的名称与显式名称发生冲突，则显式名称具有优先级，其他元素保持未命名。现在你已经知道了如何指定元组类型和元组字面量，那么你可以用它们做什么呢？
- en: 11.2.3\. Tuples as bags of variables
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.3\. 将元组视为变量的袋子
- en: 'The next sentence may come as a shock to you, so please prepare yourself: tuple
    types are value types with public, read/write fields. Surely not! I usually recommend
    against mutable value types in the strongest possible terms, and likewise I always
    suggest that fields should be private. In general, I stand by those recommendations,
    but tuples are slightly different.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个句子可能会让你感到震惊，所以请做好准备：元组类型是具有公共、可读写字段的值类型。当然不是！我通常强烈反对使用可变值类型，同样我也总是建议字段应该是私有的。一般来说，我坚持这些建议，但元组略有不同。
- en: Most types aren’t just raw data; they attach meaning to that data. Sometimes
    there’s validation for the data. Sometimes there’s an enforced relationship between
    multiple pieces of data. Usually, there are operations that make sense only because
    of the meaning attached to the data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类型不仅仅是原始数据；它们给数据附加了意义。有时会有数据验证。有时会在多个数据项之间强制执行关系。通常，只有当数据附加了意义时，某些操作才有意义。
- en: Tuples don’t do that at all. They just act as if they were bags of variables.
    If you have two variables, you can change them independently; there’s no inherent
    connection between them, and there’s no enforced relationship between them. Tuples
    allow you to do exactly the same thing, but with the extra feature that you can
    pass that whole bag of variables around in one value. This is particularly important
    when it comes to methods, which can return only a single value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 元组根本不做这样的事情。它们只是表现得像是一袋变量。如果你有两个变量，你可以独立地改变它们；它们之间没有固有的联系，也没有强制的关系。元组允许你做完全相同的事情，但额外的好处是你可以将整个变量袋作为一个值传递。这在方法方面尤为重要，因为方法只能返回一个值。
- en: '[Figure 11.3](kindle_split_028_split_000.html#ch11fig03) shows this graphically.
    The left side shows code and a mental model for declaring three independent local
    variables, and the right side shows similar code, but two of those variables are
    in a tuple (the oval). On the right side, the name and score are grouped together
    as a tuple in the `player` variable. When you want to treat them as separate variables,
    you can still do so (for example, printing out `player.score`), but you can also
    treat them as a group (for example, assigning a new value to `player`).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.3](kindle_split_028_split_000.html#ch11fig03) 以图形方式展示了这一点。左侧显示了声明三个独立局部变量的代码和心智模型，右侧显示了类似的代码，但其中两个变量在一个元组（椭圆形）中。在右侧，名称和分数作为元组组合在`player`变量中。当你想要将它们作为单独的变量处理时，你仍然可以这样做（例如，打印出`player.score`），但你也可以将它们作为一个组处理（例如，为`player`分配一个新的值）。'
- en: Figure 11.3\. Three separate variables on the left; two variables, one of which
    is a tuple, on the right
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.3\. 左侧有三个单独的变量；右侧有两个变量，其中一个变量是元组
- en: '![](../Images/11fig03_alt.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig03_alt.jpg)'
- en: Once you get into the mentality of thinking of a tuple as a bag of variables,
    a lot of things start to make more sense. But what are those variables? You’ve
    already seen that when you have named elements in a tuple you can refer to them
    by name, but what if an element doesn’t have a name?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始将元组视为变量的袋子，许多事情开始变得更有意义。但这些变量是什么？你已经看到，当你在一个元组中有命名元素时，你可以通过名称来引用它们，但如果没有名称的元素怎么办？
- en: Accessing elements by name and position
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过名称和位置访问元素
- en: You may recall that there’s a restriction on element names of the form `ItemN`,
    where `N` is a number. Well, that’s because every variable in a tuple can be referred
    to by its position as well as by any name it was given. There’s still only one
    variable per element; it’s just that there may be two ways of referring to that
    variable. It’s easiest to show this with an example as in the following listing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，对形式为 `ItemN` 的元素名称有限制，其中 `N` 是一个数字。嗯，那是因为元组中的每个变量都可以通过其位置以及它被赋予的任何名称来引用。每个元素仍然只有一个变量；只是可能有两种方式来引用该变量。以下示例中最容易展示这一点。
- en: Listing 11.2\. Reading and writing tuple elements by name and position
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.2\. 通过名称和位置读取和写入元组元素
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Displays the first element by name and position**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过名称和位置显示第一个元素**'
- en: '***2* The second element has no name; can use only position.**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第二个元素没有名称；只能使用位置。**'
- en: '***3* Modifies the first element by name**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过名称修改第一个元素**'
- en: '***4* Displays the first element by position (prints 100**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 通过位置显示第一个元素（打印 100**）'
- en: 'At this point, you can probably see why `(Item1: 10, 20)` is okay but `(Item2:
    10, 20)` isn’t allowed. In the first case, you’re redundantly naming the element,
    but in the second case, you’re causing ambiguity as to whether `Item2` refers
    to the first element (by name) or the second element (by position). You could
    argue that `(Item5: 10, 20)` should be allowed because there are only two elements;
    `Item5` doesn’t exist because the tuple has only two elements. This is one of
    those cases where even though something wouldn’t technically cause an ambiguity,
    it’d certainly be confusing, so it’s still prohibited.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，你可能已经明白为什么 `(Item1: 10, 20)` 是允许的，但 `(Item2: 10, 20)` 不被允许。在前一种情况下，你是在重复命名元素，但在第二种情况下，你造成了歧义，即
    `Item2` 是指第一个元素（按名称）还是第二个元素（按位置）。你可以争论 `(Item5: 10, 20)` 应该被允许，因为只有两个元素；`Item5`
    不存在，因为元组只有两个元素。这是那种即使技术上不会造成歧义，但肯定会引起混淆的情况，所以仍然被禁止。'
- en: Now that you know you can modify a tuple value after creating it, you can rewrite
    your `MinMax` method to use a single tuple local variable for the “result so far”
    instead of your separate `min` and `max` variables, as shown in the next listing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道可以在创建元组后修改其值，你可以重写你的 `MinMax` 方法，使用单个元组局部变量来表示“到目前为止的结果”，而不是使用你分开的 `min`
    和 `max` 变量，如以下列表所示。
- en: Listing 11.3\. Using a tuple instead of two local variables in `MinMax`
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. 在 `MinMax` 中使用元组代替两个局部变量
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Constructs a tuple with the first value as both min and max**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用第一个值作为最小值和最大值构建元组**'
- en: '***2* Modifies each field of the tuple separately**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 分别修改元组的每个字段**'
- en: '***3* Returns the tuple directly**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 直接返回元组**'
- en: '[Listing 11.3](kindle_split_028_split_000.html#ch11ex03) is very, very close
    to [listing 11.1](kindle_split_028_split_000.html#ch11ex01) in terms of how it
    works. You’ve just grouped two of your four local variables together; instead
    of `source`, `iterator`, `min`, and `max`, you have `source`, `iterator`, and
    `result`, where `result` has `min` and `max` elements inside it. The memory usage
    will be the same and the performance will be the same; it’s just a different way
    of writing it. Is it a better way of writing the code? That’s fairly subjective,
    but at least it’s a localized decision; it’s purely an implementation detail.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.3](kindle_split_028_split_000.html#ch11ex03) 在工作方式上与 [列表 11.1](kindle_split_028_split_000.html#ch11ex01)
    非常非常接近。你只是将四个局部变量中的两个组合在一起；而不是 `source`、`iterator`、`min` 和 `max`，你有 `source`、`iterator`
    和 `result`，其中 `result` 包含 `min` 和 `max` 元素。内存使用量和性能将相同；这只是不同的编写方式。这是否是更好的编写代码的方式？这是一个相当主观的问题，但至少它是一个局部决策；这是一个纯粹的实施细节。'
- en: Treating a tuple as a single value
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将元组视为单个值
- en: 'While you’re thinking about alternative implementations for your method, let’s
    consider another one. You can take this code that first assigns a new value to
    `result.min` and then a new value to `result.max`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在考虑方法的替代实现时，让我们考虑另一个。你可以取这个首先将新值赋给 `result.min` 然后将新值赋给 `result.max` 的代码：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you assign directly to `result` instead, you can replace the whole bag in
    a single assignment, as shown in the following listing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接赋值给 `result`，你可以用一个单一的赋值来替换整个集合，如以下列表所示。
- en: Listing 11.4\. Reassigning the result tuple in one statement in `MinMax`
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. 在 `MinMax` 中用一条语句重新赋值结果元组
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Assigns a new value to the whole of result**'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将整个结果赋予新的值**'
- en: Again, there’s not an awful lot to choose between implementations, and that’s
    because in [listing 11.3](kindle_split_028_split_000.html#ch11ex03) the two elements
    of the tuple were being updated individually, referring only to the previous value
    of the same element. A more compelling example is to write a method that returns
    the Fibonacci sequence^([[2](kindle_split_028_split_000.html#ch11fn2)]) as an
    `IEnumerable<int>`. C# already helps you do that by providing iterators with yield,
    but it can be a bit fiddly. The following listing shows a perfectly reasonable
    C# 6 implementation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在 [列表 11.3](kindle_split_028_split_000.html#ch11ex03) 中，元组的两个元素是分别更新的，只引用了相同元素的先前值。一个更有说服力的例子是编写一个方法，返回斐波那契数列^([[2](kindle_split_028_split_000.html#ch11fn2)])
    作为 `IEnumerable<int>`。C# 已经通过提供带有 yield 的迭代器来帮助你这样做，但这可能有点麻烦。下面的列表展示了完全合理的 C#
    6 实现。
- en: ²
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first two elements are 0 and 1; after that, any element of the sequence
    is the sum of the previous two elements.
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 前两个元素是 0 和 1；之后，序列中的任何元素都是前两个元素的和。
- en: Listing 11.5\. Implementing the Fibonacci sequence without tuples
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 不使用元组实现斐波那契数列
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you iterate, you keep track of the current element and the next element of
    the sequence. In each iteration, you shift from the pair representing “current
    and next” to “next and next-next.” To do that, you need a temporary variable;
    you can’t simply assign new values directly to `current` and `next` one after
    the other, because the first assignment would lose information you need for the
    second assignment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在迭代过程中，你跟踪序列的当前元素和下一个元素。在每次迭代中，你从代表“当前和下一个”的元组转换到“下一个和下一个下一个”。要做到这一点，你需要一个临时变量；你不能简单地依次直接给
    `current` 和 `next` 赋新值，因为第一个赋值会丢失第二个赋值所需的信息。
- en: Tuples let you perform a single assignment that changes both elements. The temporary
    variable is still present in the IL, but the resulting source code shown in the
    following listing ends up being beautiful, in my view.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 元组允许你执行一个改变两个元素的单一赋值。临时变量仍然存在于 IL 中，但以下列表中显示的源代码在我看来是美丽的。
- en: Listing 11.6\. Implementing the Fibonacci sequence with tuples
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.6\. 使用元组实现斐波那契数列
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After you’ve gone that far, it’s hard to resist generalizing this further to
    generate arbitrary sequences, extracting all of the Fibonacci code out to just
    arguments in a method call. The following listing introduces a generalized `GenerateSequence`
    method suitable for generating all kinds of sequences based on its arguments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在你走到这一步之后，很难抗拒将其进一步泛化以生成任意序列，将所有斐波那契数列代码提取到方法调用中的参数。下面的列表介绍了一个通用的 `GenerateSequence`
    方法，它可以根据其参数生成各种序列。
- en: Listing 11.7\. Separating concerns of sequence generation for Fibonacci
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.7\. 分离斐波那契数列生成关注点
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Method to allow the generation of arbitrary sequences based on previous
    state**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 允许根据先前状态生成任意序列的方法**'
- en: '***2* Use of sequence generator specifically for the Fibonacci sequence**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 特定于斐波那契数列的序列生成器使用**'
- en: This could certainly be achieved using anonymous or even named types, but it
    wouldn’t be as elegant. Readers with experience in other programming languages
    may not be overly impressed by this—it’s not as if C# 7 has brought a brand-new
    paradigm to the world—but it’s exciting to be able to write code as beautiful
    as this in C#.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然可以使用匿名类型甚至命名类型来实现，但这不会那么优雅。有其他编程语言经验的读者可能不会特别印象深刻——C# 7 并没有为世界带来全新的范式——但能够在
    C# 中写出这样美丽的代码是令人兴奋的。
- en: Now that you’ve seen the basics of how tuples work, let’s dive a bit deeper.
    In the next section, we’ll mostly be considering conversions, but we’ll also look
    at where element names are important and where they’re not.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了元组的基本工作原理，让我们更深入地探讨一下。在下一节中，我们将主要考虑转换，但也会看看元素名称何时重要，何时不重要。
- en: 11.3\. Tuple types and conversions
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 元组类型和转换
- en: Until now, I’ve carefully avoided going into the details of the type of a tuple
    literal. By staying somewhat vague, I’ve been able to show quite a lot of code
    so you can get a feeling for how tuples can be used. Now’s the time to justify
    the *In Depth* part of the book’s title. First, think about all the declarations
    you’ve seen using `var` and tuple literals.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我小心地避免深入探讨元组字面量的类型细节。通过保持一定的模糊性，我能够展示大量的代码，以便你可以感受到元组的使用方式。现在是时候证明这本书标题中的“深入”部分了。首先，想想你看到的所有使用
    `var` 和元组字面量的声明。
- en: 11.3.1\. Types of tuple literals
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1\. 元组字面量的类型
- en: 'Some tuple literals have a type, but some don’t. It’s a simple rule: a tuple
    literal has a type when every element expression within it has a type. The idea
    of an expression without a type is nothing new in C#; lambda expressions, method
    groups, and the `null` literal are also expressions with no type. Just as in those
    examples, you can’t use tuple literals without a type to assign a value to an
    implicitly typed local variable. For example, this is valid, because both 10 and
    20 are expressions with a type:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一些元组字面量有类型，但一些没有。这是一个简单的规则：当元组字面量中的每个元素表达式都有类型时，它就有类型。在 C# 中，没有类型的表达式的概念并不新鲜；lambda
    表达式、方法组和 `null` 字面量也是没有类型的表达式。就像那些例子一样，你不能使用没有类型的元组字面量来给隐式类型的局部变量赋值。例如，这是有效的，因为
    10 和 20 都是具有类型的表达式：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But this is invalid because the null literal doesn’t have a type:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是无效的，因为 `null` 字面量没有类型：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Just like the `null` literal, a tuple literal without a type can still be convertible
    to a type. When a tuple has a type, any element names are also part of the type.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `null` 字面量一样，没有类型的元组字面量仍然可以转换为类型。当一个元组有类型时，任何元素名称也是类型的一部分。
- en: 'For example, in each of these cases, the left side is equivalent to the right
    side:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这些情况中，左边等同于右边：
- en: '|'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The first example demonstrates how element names propagate from tuple literals
    to tuple types. The last example shows how the type inference still works in complex
    ways: the type of `input` allows the type of `x` in the lambda expression to be
    fixed to `string`, which then allows the expression `x.Length` to be bound appropriately.
    This leaves a tuple literal with element types `string` and `int`, so the return
    type of the lambda expression is inferred to be `(string, int)`. You saw a similar
    kind of inference in [listing 11.7](kindle_split_028_split_000.html#ch11ex07)
    with our Fibonacci implementation using the sequence generator method, but you
    weren’t focusing on the types involved at the time.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例演示了元素名称是如何从元组字面量传播到元组类型的。最后一个示例显示了类型推断在复杂情况下的工作方式：`input` 的类型允许 lambda
    表达式中的 `x` 类型被固定为 `string`，这然后允许表达式 `x.Length` 被适当地绑定。这留下了一个具有 `string` 和 `int`
    元素类型的元组字面量，因此 lambda 表达式的返回类型被推断为 `(string, int)`。你曾在 [列表 11.7](kindle_split_028_split_000.html#ch11ex07)
    中看到过类似类型的推断，当时我们使用序列生成方法实现了斐波那契数列，但你当时并没有关注涉及到的类型。
- en: That’s fine for tuple literals that have types. But what can you do with tuple
    literals that don’t have types? How can you convert from a tuple literal without
    names to a tuple type with names? To answer these questions, you need to look
    at tuple conversions in general.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有类型的元组字面量来说，这是可以的。但对于没有类型的元组字面量，你能做什么呢？如何将没有名称的元组字面量转换为有名称的元组类型？为了回答这些问题，你需要查看元组转换的一般情况。
- en: 'You need to think about two kinds of conversions: conversions from tuple literals
    to tuple types and conversions from one tuple type to another. You’ve already
    seen this kind of difference in [chapter 8](kindle_split_024_split_000.html#ch08):
    there’s a conversion from an interpolated string literal expression to `FormattableString`
    but no conversion from the `string` type to `FormattableString`. The same idea
    is at work here. You’ll look first at the literal conversions.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑两种类型的转换：从元组字面量到元组类型的转换，以及从一个元组类型到另一个元组类型的转换。你已经在 [第 8 章](kindle_split_024_split_000.html#ch08)
    中看到过这种差异：存在从字符串字面量表达式到 `FormattableString` 的转换，但没有从 `string` 类型到 `FormattableString`
    的转换。这里的工作原理是相同的。你首先将查看字面量转换。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Lambda expression parameters can look like tuples**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lambda 表达式参数看起来像元组**'
- en: 'Lambda expressions with a single parameter aren’t confusing, but if you use
    two parameters, they can look like tuples. As an example, let’s look at a useful
    method that just uses the LINQ `Select` overload that provides the projection
    with the index of the element as well as the value. It’s often useful to propagate
    the index through the other operations, so it makes sense to put the two pieces
    of data in a tuple. That means you end up with this method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 单参数的 lambda 表达式并不令人困惑，但如果你使用两个参数，它们看起来可能像元组。作为一个例子，让我们看看一个只使用 LINQ `Select`
    重载的有用方法，它提供了带有元素索引和值的投影。在操作中传播索引通常很有用，所以将这两部分数据放在一个元组中是有意义的。这意味着你最终得到这个方法：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Concentrate on the lambda expression:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于 lambda 表达式：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here the first occurrence of `(value, index)` isn’t a tuple literal; it’s the
    sequence of parameters for the lambda expression. The second occurrence *is* a
    tuple literal, the result of the lambda expression.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `(value, index)` 的第一次出现不是一个元组字面量；它是 lambda 表达式的参数序列。第二次出现 *是* 一个元组字面量，lambda
    表达式的结果。
- en: There’s nothing wrong here. I just don’t want it to take you by surprise when
    you see something similar.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有问题。我只是不希望当你看到类似的情况时感到惊讶。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.3.2\. Conversions from tuple literals to tuple types
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 从元组字面量到元组类型的转换
- en: Just as in many other parts of C#, there are implicit conversions from tuple
    literals and explicit conversions. I expect the use of explicit conversions to
    be rare for reasons I’ll show in a moment. But after you understand how implicit
    conversions work, the explicit conversions pretty much fall out anyway.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 C# 的许多其他部分一样，存在从元组字面量到元组类型的隐式转换和显式转换。我预计显式转换的使用将很少，原因我将在稍后展示。但一旦你理解了隐式转换的工作原理，显式转换基本上就自然而然地出现了。
- en: Implicit conversions
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 隐式转换
- en: 'A tuple literal can be implicitly converted to a tuple type if both of the
    following are true:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下两个条件都成立，元组字面量可以隐式转换为元组类型：
- en: The literal and the type have the same arity.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面量和类型具有相同的秩。
- en: Each expression in the literal can be implicitly converted to its corresponding
    element type.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面量中的每个表达式都可以隐式转换为相应的元素类型。
- en: 'The first bullet is simple. It’d be odd to be able to convert `(5, 5)` to `(int,
    int, int)`, for example. Where would the last value come from? The second bullet
    is a little more complex, but I’ll clarify it with examples. First, let’s try
    this conversion:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条要点很简单。能够将 `(5, 5)` 转换为 `(int, int, int)`，例如，这会显得有些奇怪。最后一个值从哪里来呢？第二条要点稍微复杂一些，但我会通过例子来澄清。首先，让我们尝试这个转换：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As per the preceding description, you need to look at each element expression
    in the source tuple literal `(5, "text")` and check whether there’s an implicit
    conversion to the corresponding element type in the target tuple type `(byte,
    object)`. If every element can be converted, the conversion is valid:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的描述，你需要查看源元组字面量 `(5, "text")` 中的每个元素表达式，并检查是否存在到目标元组类型 `(byte, object)`
    中相应元素类型的隐式转换。如果每个元素都可以转换，则转换是有效的：
- en: '![](../Images/f0331-01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0331-01.jpg)'
- en: 'Even though there’s no implicit conversion from `int` to `byte`, there’s an
    implicit conversion from the integer constant 5 to `byte` (because 5 is in the
    range of valid `byte` values). There’s also an implicit conversion from a string
    literal to `object`. All the conversions are valid, so the whole conversion is
    valid. Hooray! Now let’s try a different conversion:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有从 `int` 到 `byte` 的隐式转换，但整数常量 5 到 `byte` 的隐式转换是存在的（因为 5 在有效的 `byte` 值范围内）。还有一个从字符串字面量到
    `object` 的隐式转换。所有转换都是有效的，因此整个转换是有效的。太好了！现在让我们尝试不同的转换：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Again, you try to apply implicit conversions element-wise:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你尝试逐元素应用隐式转换：
- en: '![](../Images/f0332-01.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0332-01.jpg)'
- en: 'In this case, you’re trying to convert the integer constant `300` to `byte`.
    That’s outside the range of valid values, so there’s no implicit conversion. There’s
    an explicit conversion, but that doesn’t help when you’re trying to achieve an
    overall implicit conversion of the tuple literal. There’s an implicit conversion
    from the string literal to the `string` type, but because not all the conversions
    are valid, the whole conversion is invalid. If you try to compile this code, you’ll
    get an error pointing to the 300 within the tuple literal:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你试图将整数常量 `300` 转换为 `byte`。这超出了有效值的范围，因此没有隐式转换。存在显式转换，但这在你试图实现元组字面量整体隐式转换时并没有帮助。从字符串字面量到
    `string` 类型的隐式转换是存在的，但由于并非所有转换都是有效的，整个转换是无效的。如果你尝试编译此代码，你将得到一个错误，指向元组字面量中的 `300`：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This error message is a little misleading. It suggests that our previous example
    shouldn’t be valid either. The compiler isn’t really trying to convert the type
    `int` to `byte`; it’s trying to convert the expression `300` to `byte`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息有些误导。它暗示我们的前一个例子也可能不合法。编译器实际上并不是试图将类型 `int` 转换为 `byte`；它试图将表达式 `300` 转换为
    `byte`。
- en: Explicit conversions
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 显式转换
- en: Explicit conversions for tuple literals follow the same rules as implicit conversions,
    but they require an explicit conversion to be present for each element expression
    to the corresponding type. If that condition is met, there’s an explicit conversion
    from the tuple literal to the tuple type, so you can cast in the normal way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 元组字面量的显式转换遵循与隐式转换相同的规则，但每个元素表达式到对应类型的转换都需要显式转换。如果满足这个条件，则从元组字面量到元组类型的转换是显式的，因此你可以按正常方式进行类型转换。
- en: '|  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Every implicit conversion in C# also counts as an explicit conversion, which
    is somewhat confusing. You can think of the condition as “there has to be a conversion,
    either explicit or implicit, available for each element” if you find that clearer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的每个隐式转换也计为显式转换，这有点令人困惑。如果你觉得这样更清晰，你可以将条件视为“每个元素必须有可用的转换，无论是显式还是隐式”。
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To go back to our conversion of `(300, "text")`, there’s an explicit conversion
    to the tuple type `(byte, string)`. But converting that exact expression requires
    an unchecked context for the conversion to work, because the compiler knows that
    the constant value `300` is outside the normal range of `byte`. A more realistic
    example would use an `int` variable from elsewhere:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们转换`(300, "text")`的情况，有一个显式转换到元组类型`(byte, string)`。但将这个确切的表达式转换为需要未检查的上下文才能工作，因为编译器知道常量值`300`超出了`byte`的正常范围。一个更现实的例子将使用来自其他地方的`int`变量：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The casting part—`((byte, string))`—looks like it has more parentheses than
    it needs, but they’re all required. The inner ones are specifying the tuple type,
    and the outer ones are signifying the cast. [Figure 11.4](kindle_split_028_split_000.html#ch11fig04)
    shows this graphically.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 转换部分——`((byte, string))`——看起来比需要的括号多，但它们都是必需的。内层的括号指定了元组类型，外层的括号表示了类型转换。[图11.4](kindle_split_028_split_000.html#ch11fig04)以图形方式展示了这一点。
- en: Figure 11.4\. Explaining the parentheses in an explicit tuple conversion
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.4. 解释显式元组转换中的括号
- en: '![](../Images/11fig04.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig04.jpg)'
- en: 'It looks ugly to me, but it’s nice that it’s at least available. A simpler
    alternative in many cases is to write the appropriate cast in each element expression
    in the tuple literal, at which point not only would the tuple conversion be valid,
    but the inferred type of the literal becomes what you want anyway. For example,
    I’d probably write the preceding example as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来这看起来很丑，但至少它可用。在许多情况下，一个更简单的替代方案是在元组字面量中的每个元素表达式中写出适当的类型转换，这样不仅元组转换将是有效的，而且字面量的推断类型也会变成你想要的。例如，我可能会把前面的例子写成如下：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The two options are equivalent; when the conversion is applied to the whole
    tuple literal, the compiler still emits an explicit conversion for each element
    expression. But I find the latter much more readable. Aside from anything else,
    it shows clearer intent: you know an explicit conversion is required from `int`
    to `byte`, but you’re happy for the string to stay as it is. If you were trying
    to convert several values to a specific tuple type (rather than using the inferred
    type), this would help to make it clear which conversions are explicit and therefore
    potentially lossy instead of accidentally losing data due to a whole-tuple explicit
    conversion.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项是等价的；当转换应用于整个元组字面量时，编译器仍然会对每个元素表达式发出显式转换。但我发现后者更易读。除此之外，它还清楚地表明了意图：你知道从`int`到`byte`需要显式转换，但你希望字符串保持原样。如果你试图将多个值转换为特定的元组类型（而不是使用推断的类型），这将有助于清楚地表明哪些转换是显式的，因此可能是损失性的，而不是由于整个元组显式转换而意外丢失数据。
- en: The role of element names in tuple literal conversions
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 元组字面量转换中元素名称的作用
- en: 'You may have noticed that this section hasn’t mentioned names at all. They’re
    almost entirely irrelevant within tuple literal conversions. Most important, it’s
    fine to convert from an element expression without a name to a type element with
    a name. You’ve been doing that a lot in this chapter without me raising it as
    an issue. You did it right from the start with our first `MinMax` method implementation.
    As a reminder, the method was declared as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，本节根本没有提到名称。在元组字面量转换中，它们几乎完全无关紧要。最重要的是，从没有名称的元素表达式转换为有名称的类型元素是可以的。你在这个章节中已经做了很多次，而我并没有把它当作问题提出。你从我们的第一个`MinMax`方法实现开始就做对了。作为提醒，该方法声明如下：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And then our return statement was this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的返回语句是这样的：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You’re trying to convert a tuple literal with no element names^([[3](kindle_split_028_split_000.html#ch11fn3)])
    to `(int min, int max)`. Of course, it’s valid; otherwise, I wouldn’t have shown
    it to you. It’s also convenient. Element names aren’t completely irrelevant in
    tuple literal conversions, though. When an element name is explicitly specified
    in the tuple literal, the compiler will warn you if either there’s no corresponding
    element name in the type you’re converting it to or the two names are different.
    Here’s an example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在尝试将没有元素名称的元组字面量^([[3](kindle_split_028_split_000.html#ch11fn3)])转换为`(int
    min, int max)`。当然，这是有效的；否则，我就不会向你展示了。尽管元素名称在元组字面量转换中并不完全无关紧要。当在元组字面量中显式指定元素名称时，如果转换到的类型中没有相应的元素名称，或者两个名称不同，编译器会警告你。以下是一个例子：
- en: ³
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In C# 7.0, at least. As noted in [section 11.2.2](kindle_split_028_split_000.html#ch11lev2sec2),
    in C# 7.1 the names are inferred.
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在C# 7.0中至少是这样。如[11.2.2节](kindle_split_028_split_000.html#ch11lev2sec2)所述，在C#
    7.1中，名称是推断出来的。
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This shows all the possible combinations for element names in this order:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了元素名称的所有可能组合，顺序如下：
- en: Both the target type and the tuple literal specify the same element name.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标类型和元组字面量指定了相同的元素名称。
- en: Both the target type and the tuple literal specify a name for the element, but
    the names are different.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标类型和元组字面量为元素指定了名称，但名称不同。
- en: The target type specifies an element name, but the tuple literal doesn’t.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标类型指定了元素名称，但元组字面量没有。
- en: The target type doesn’t specify an element name, but the tuple literal does.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标类型没有指定元素名称，但元组字面量指定了。
- en: Neither the target type nor the tuple literal specifies an element name.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标类型和元组字面量都没有指定元素名称。
- en: 'Of these, the second and the fourth result in compile-time warnings. The result
    of compiling that code is shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，第二个和第四个结果会在编译时产生警告。编译该代码的结果如下：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The second warning message isn’t as helpful as it might be, because the target
    type isn’t specifying a name at all for the corresponding element. Hopefully,
    you could still work out what’s wrong.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个警告信息并不像可能的那样有帮助，因为目标类型根本未指定对应元素的名称。希望你能弄清楚出了什么问题。
- en: 'Is this useful? Absolutely. Not when you’re declaring a variable and constructing
    a value in one statement, but when the declaration and the construction are separated.
    For example, suppose our `MinMax` method in [listing 11.1](kindle_split_028_split_000.html#ch11ex01)
    had been really long in a way that was hard to refactor. Should you return `(min,
    max)` or `(max, min)`? Yes, in this case just the name of the method makes the
    order pretty obvious, but in some cases, it might not be as clear. At that point,
    adding element names to the `return` statement can be used as validation. This
    compiles warning free:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这有用吗？当然有用。当你在一行语句中声明变量并构造值时没有用，但当声明和构造被分开时就有用了。例如，假设我们的`MinMax`方法在[列表11.1](kindle_split_028_split_000.html#ch11ex01)中真的很长，难以重构。你应该返回`(min,
    max)`还是`(max, min)`？是的，在这种情况下，方法名本身就能使顺序非常明显，但在某些情况下可能并不那么清晰。在这种情况下，在`return`语句中添加元素名称可以用作验证。这样编译不会产生警告：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But if you reverse the elements, you get a warning for each element:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你反转元素，每个元素都会产生警告：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Warning CS8123, twice**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 警告 CS8123，两次**'
- en: Note that this applies only to explicitly specified names. Even in C# 7.1, when
    element names are inferred from a tuple literal of `(max, min)`, that doesn’t
    generate a warning when you convert it to a tuple type of `(int min, int max)`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这仅适用于显式指定的名称。即使在C# 7.1中，当元素名称从`(max, min)`的元组字面量中推断出来时，将其转换为`(int min, int
    max)`的元组类型也不会产生警告。
- en: I always prefer to structure the code to make this so clear that you don’t need
    this extra checking. But it’s good to know that it’s available when you need it,
    perhaps as a first step before you refactor the method to be shorter, for example.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是更喜欢将代码结构化，使其如此清晰，以至于你不需要进行额外的检查。但了解它在需要时可用是很好的，例如，在重构方法以使其更短之前，这可能是一个第一步。
- en: 11.3.3\. Conversions between tuple types
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3\. 元组类型之间的转换
- en: 'After you have the hang of tuple literal conversions, implicit and explicit
    tuple type conversions are reasonably simple, because they work in a similar way.
    Here, you have no expressions to worry about, just the types. There’s an implicit
    conversion from a source tuple type to a target tuple type of the same arity if
    there’s an implicit conversion from each source element type to the corresponding
    target element type. Similarly, there’s an explicit conversion from a source tuple
    type to a target tuple type of the same arity if there’s an explicit conversion
    from each source element type to the corresponding target element type. Here’s
    an example showing multiple conversions all from a source type of `(int, string)`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了元组字面量转换之后，隐式和显式元组类型转换相对简单，因为它们以类似的方式工作。在这里，你不需要担心任何表达式，只需要类型。如果每个源元素类型到相应目标元素类型都存在隐式转换，则从源元组类型到相同秩的目标元组类型存在隐式转换。同样，如果每个源元素类型到相应目标元素类型都存在显式转换，则从源元组类型到相同秩的目标元组类型存在显式转换。以下是一个示例，展示了从源类型
    `(int, string)` 进行多个转换：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* The type of t1 is inferred as (int, string).**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* t1 的类型被推断为 (int, string)。**'
- en: '***2* Valid implicit conversion from (int, string) to (long, string)**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 (int, string) 到 (long, string) 的有效隐式转换**'
- en: '***3* Invalid: no implicit conversion from int to byte**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 无效：无法从 int 转换到 byte**'
- en: '***4* Valid explicit conversion from (int, string) to (byte, string)**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从 (int, string) 到 (byte, string) 的有效显式转换**'
- en: '***5* Valid implicit conversion from (int, string) to (object, object)**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从 (int, string) 到 (object, object) 的有效隐式转换**'
- en: '***6* Invalid: no conversion at all from int to string**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 无效：从 int 到 string 无法进行转换**'
- en: In this case, the explicit conversion from `(int, string)` to `(byte, string)`
    in the fourth line will result in the value of `t4.Item1` being `44`, because
    that’s the result of the explicit conversion of the `int` value 300 to `byte`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第四行中从 `(int, string)` 到 `(byte, string)` 的显式转换将导致 `t4.Item1` 的值为 `44`，因为这是将
    `int` 值 300 显式转换为 `byte` 的结果。
- en: 'Unlike with tuple literal conversions, there’s no warning if element names
    don’t match up. I can show this with an example that’s similar to our arity-5
    conversion with tuple literals. All you need to do is store the tuple value in
    a variable first so that you perform a type-to-type conversion instead of a literal-to-type
    conversion:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组字面量转换不同，如果元素名称不匹配，则不会有警告。我可以用一个与我们的秩为 5 的元组字面量转换类似的例子来展示这一点。你所需要做的只是首先将元组值存储在一个变量中，这样你执行的是类型到类型的转换，而不是字面量到类型的转换：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This compiles with no warnings at all. One aspect of tuple type conversion is
    important in a way that isn’t applicable for literal conversions, however, and
    that’s when the conversion isn’t just an implicit conversion but is an identity
    conversion.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有任何警告就能编译。元组类型转换的一个方面很重要，但在字面量转换中不适用，那就是转换不仅仅是隐式转换，而是身份转换。
- en: Tuple type identity conversions
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 元组类型身份转换
- en: 'The concept of identity conversions has been present in C# since the beginning,
    although it’s been expanded over time. Before C# 7, the rules worked like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 身份转换的概念自 C# 诞生以来就存在，尽管随着时间的推移它得到了扩展。在 C# 7 之前，规则是这样的：
- en: An identity conversion exists from each type to itself.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类型都可以与其自身进行身份转换。
- en: An identity conversion exists between `object` and `dynamic`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object` 和 `dynamic` 之间存在身份转换。'
- en: An identity conversion exists between two array types if an identity conversion
    exists between their element types. For example, an identity conversion exists
    between `object[]` and `dynamic[]`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个数组类型的元素类型之间存在身份转换，则这两个数组类型之间存在身份转换。例如，`object[]` 和 `dynamic[]` 之间存在身份转换。
- en: Identity conversions extend to constructed generic types when identity conversions
    exist between corresponding type arguments. For example, an identity conversion
    exists between `List<object>` and `List<dynamic>`.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对应类型参数之间存在身份转换时，身份转换扩展到构造的泛型类型。例如，`List<object>` 和 `List<dynamic>` 之间存在身份转换。
- en: 'Tuples introduce another kind of identity conversion: between tuple types of
    the same arity when an identity conversion exists between each corresponding pair
    of element types, regardless of name. In other words, identity conversions exist
    (in both directions; identity conversions are always symmetric) between the following
    types:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 元组引入了另一种身份转换：当每个对应元素类型之间存在身份转换时，无论名称如何，相同秩的元组类型之间也存在身份转换。换句话说，以下类型之间存在身份转换（双向；身份转换总是对称的）：
- en: '`(int x, object` `y)`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(int x, object y)`'
- en: '`(int a, dynamic` `d)`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(int a, dynamic d)`'
- en: '`(int,` `object)`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(int, object)`'
- en: 'Again, this can be applied to constructed types, and the tuple element types
    can be constructed, too, so long as an identity conversion is still available.
    So, for example, identity conversions exist between these two types:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这可以应用于构造类型，元组元素类型也可以构造，只要仍然存在身份转换。例如，身份转换存在于以下两种类型之间：
- en: '`Dictionary<string, (int,` `List<object>)>`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<string, (int, List<object>)>`'
- en: '`Dictionary<string, (int index, List<dynamic>` `values)>`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dictionary<string, (int index, List<dynamic values)>>`'
- en: Identity conversions are mostly important for tuples when it comes to constructed
    types. It’d be annoying if you could easily convert from `(int, int)` to `(int
    x, int y)` but not from `IEnumerable<(int, int)>` to `IEnumerable<(int x, int
    y)>,` or vice versa.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构造类型时，标识符转换对于元组来说尤为重要。如果你可以轻松地从`(int, int)`转换为`(int x, int y)`，但不能从`IEnumerable<(int,
    int)>`转换为`IEnumerable<(int x, int y)>`，或者相反，这将会很烦人。
- en: 'The identity conversions are important for overloads as well. In the same way
    two overloads can’t vary just by return type, they can’t vary only by parameter
    types with identity conversions between them. You can’t write two methods in the
    same class like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 身份转换对于重载也同样重要。与两个重载不能仅通过返回类型而不同一样，它们也不能仅通过参数类型以及它们之间的身份转换而不同。你不能在同一个类中编写如下两个方法：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you do so, you’ll receive a compile-time error like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这样做，你将收到如下编译时错误：
- en: '[PRE36]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From a C# language perspective, the parameter types aren’t exactly the same,
    but making the error message absolutely precise in terms of identity conversions
    would make it a lot harder to understand.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 从C#语言的角度来看，参数类型并不完全相同，但要在身份转换方面使错误信息绝对精确，这将使理解变得更加困难。
- en: 'If you find the official definitions of identity conversions confusing, one
    simple (though rather less official) way of thinking about them is this: two types
    are identical if you can’t tell the difference between them at execution time.
    We’ll go into a lot more detail about that in [section 11.4](kindle_split_028_split_000.html#ch11lev1sec4).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现官方对身份转换的定义令人困惑，一个简单（尽管不那么官方）的思考方式是这样的：如果执行时无法区分两种类型，则这两种类型是相同的。我们将在[第11.4节](kindle_split_028_split_000.html#ch11lev1sec4)中详细介绍这一点。
- en: Lack of generic variance conversions
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 缺乏泛型方差转换
- en: 'With the identity conversions in mind, you might be hopeful that you could
    use tuple types with generic variance for interface and delegate types. Sadly,
    this isn’t the case. Variance applies only to reference types, and tuple types
    are always value types. As an example, it feels like this should compile:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到身份转换，你可能会希望可以使用具有泛型方差界面的元组类型和委托类型。遗憾的是，情况并非如此。方差仅适用于引用类型，而元组类型始终是值类型。例如，感觉这个应该可以编译：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But it doesn’t. Sorry about that. I can’t see it coming up terribly often as
    a practical issue, but I wanted to remove the disappointment you might feel if
    you ever wanted this and expected it to work.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 但它并不这样做。对此表示歉意。我不认为这会经常作为一个实际问题出现，但我希望在你期望它工作但最终没有时，能减少你的失望感。
- en: 11.3.4\. Uses of conversions
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.4\. 转换的使用
- en: Now that you know what’s available, you may be wondering when you’d want to
    use these tuple conversions. This will largely depend on how you use tuples in
    a broader sense. Tuples used within a single method or returned from private methods
    to be used in the same class are rarely going to require conversions. You’ll just
    pick the right type to start with, possibly casting within a tuple literal when
    constructing an initial value.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了这些可用的功能，你可能想知道何时会想要使用这些元组转换。这主要取决于你更广泛地使用元组的方式。在单个方法内使用或在同一类中返回以供使用的私有方法中使用的元组很少需要转换。你只需从正确的类型开始，在构造初始值时，可能需要在元组字面量中进行类型转换。
- en: It’s more likely that you’ll need to convert from one tuple type to another
    when you’re using internal or public methods accepting or returning tuples, because
    you’ll have less control over the element types. The more broadly a tuple type
    is used, the less likely it is to be *exactly* the desired type in every single
    use.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 更可能的情况是，当你使用接受或返回元组的内部或公共方法时，你需要从一种元组类型转换为另一种类型，因为你对元素类型的控制会更少。元组类型的使用范围越广，它在每次使用中都恰好是所需类型的可能性就越小。
- en: 11.3.5\. Element name checking in inheritance
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.5\. 继承中的元素名称检查
- en: Although element names aren’t important in conversions, the compiler is picky
    about their use in inheritance. When a tuple type appears in a member you’re either
    overriding from a base class or implementing from an interface, the element names
    you specify must match those in the original definition. Not only must any names
    that are specified in the original definition be matched, but if there isn’t a
    name in the original definition, you can’t put one in the implementation. The
    element types in the implementation have to be identity convertible to the element
    types in the original definition.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在转换中元素名称并不重要，但编译器在继承中使用时对它们的挑剔。当一个元组类型出现在你正在从基类重写或从接口实现成员时，你指定的元素名称必须与原始定义中的名称匹配。不仅必须匹配原始定义中指定的任何名称，而且如果原始定义中没有名称，你也不能在实现中添加一个。实现中的元素类型必须与原始定义中的元素类型进行身份转换。
- en: 'As an example, consider this `ISample` interface and some methods trying to
    implement `ISample.Method` (each of which would be in a separate implementation
    class, of course):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个`ISample`接口和一些尝试实现`ISample.Method`的方法（当然，每个方法都会在单独的实现类中）：
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Wrong type elements**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误类型元素**'
- en: '***2* First element is missing its name.**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第一个元素缺少名称。**'
- en: '***3* Second element has a name; it doesn’t in the original definition.**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 第二个元素有名称；在原始定义中并没有。**'
- en: '***4* First element has the wrong name.**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 第一个元素名称错误。**'
- en: '***5* Wrong tuple type arity**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 错误元组类型数量**'
- en: '***6* Valid**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 有效**'
- en: That example deals only with an interface implementation, but the same restrictions
    hold when overriding a base class member. Likewise, that example uses only a parameter,
    but the restrictions apply to return types, too. Note that this means that adding,
    removing, or changing a tuple element name in an interface member or a virtual/abstract
    class member is a breaking change. Think carefully before doing this in a public
    API!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 那个例子只处理接口实现，但在重写基类成员时，相同的限制也适用。同样，那个例子只使用参数，但限制也适用于返回类型。请注意，这意味着在接口成员或虚拟/抽象类成员中添加、删除或更改元组元素名称是一个破坏性更改。在公共API中这样做之前请仔细思考！
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In some senses, this is a slightly inconsistent step, in that the compiler has
    never worried before about the author of a class changing method parameter names
    when overriding a method or implementing an interface. The ability to specify
    argument names means that this can cause problems if a caller changes their code
    in terms of whether they refer to the interface or the implementation. My suspicion
    is that if the C# language designers were starting again from scratch, this would
    be prohibited, too.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，这是一个稍微不一致的步骤，因为编译器以前从未担心过类作者在重写方法或实现接口时更改方法参数名称。指定参数名称的能力意味着如果调用者根据他们是否引用接口或实现更改代码，这可能会引起问题。我的怀疑是，如果C#语言设计者从头开始，这也会被禁止。
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'C# 7.3 has added one more language feature to tuples: the ability to compare
    them with `==` and `!=` operators.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.3为元组添加了一个新的语言特性：使用`==`和`!=`运算符比较它们的能力。
- en: 11.3.6\. Equality and inequality operators (C# 7.3)
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.6\. 相等性和不等性运算符（C# 7.3）
- en: As you’ll see in [section 11.4.5](kindle_split_028_split_000.html#ch11lev2sec14),
    the CLR representation of value tuples has supported equality via the `Equals`
    method from the start. But it doesn’t overload the `==` or `!=` operators. As
    of C# 7.3, however, the compiler provides `==` and `!=` implementations between
    tuples where there’s an identity conversion between the tuple types of the two
    operands. (Aside from other aspects of identity conversions, that means the element
    names aren’t important.)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第11.4.5节](kindle_split_028_split_000.html#ch11lev2sec14)中看到的，从开始起，值元组的CLR表示就通过`Equals`方法支持了相等性。但它没有重载`==`或`!=`运算符。然而，截至C#
    7.3，编译器提供了在元组之间进行身份转换时`==`和`!=`的实现。（除了其他身份转换的方面，这意味着元素名称并不重要。）
- en: The compiler expands the `==` operator into element-wise comparisons with the
    `==` operators of each corresponding pair of values and the `!=` operator into
    element-wise comparisons with the `!=` operators of each corresponding pair of
    values. That’s probably easiest to show with the following example.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将`==`运算符扩展为使用每个对应值对的`==`运算符进行逐元素比较，将`!=`运算符扩展为使用每个对应值对的`!=`运算符进行逐元素比较。以下示例可能更容易说明这一点。
- en: Listing 11.8\. Equality and inequality operators
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.8\. 相等性和不等性运算符
- en: '[PRE39]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* Equality operator**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 等价运算符**'
- en: '***2* Equivalent code generated by compiler**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 编译器生成的等效代码**'
- en: '***3* Inequality operator**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 不等价运算符**'
- en: '***4* Equivalent code generated by compiler**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 编译器生成的等效代码**'
- en: '[Listing 11.8](kindle_split_028_split_000.html#ch11ex08) shows two tuples (one
    with element names and one without) and compares them for equality and inequality.
    In each case, I’ve then shown what the compiler generates for that operator. The
    important point to note here is that the generated code uses any overloaded operators
    provided by the element types. It’d be impossible for the CLR type to provide
    the same functionality without using reflection. This is a task better handled
    by the compiler.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表11.8](kindle_split_028_split_000.html#ch11ex08)显示了两个元组（一个带有元素名称，一个没有）并比较了它们的等价性和不等价性。在每种情况下，我都展示了编译器为该运算符生成的代码。这里需要注意的重要点是，生成的代码使用了元素类型提供的任何重载运算符。没有使用反射，CLR类型无法提供相同的功能。这是一个最好由编译器处理的任务。'
- en: We’ve now gone as far into the language rules of tuples as we need to. The precise
    details of how element names are propagated in type inference and the like are
    best handled by the language specification. Even this book has limits in terms
    of how deep it needs to go. Although you could use all of the preceding information
    and ignore what the CLR does with tuples, you’ll be able to do more with tuples
    and better understand the behavior if you dig a bit deeper and find out how the
    compiler translates all of these rules into IL.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入探讨了元组的语言规则，这是我们需要的。元素名称在类型推断等中的精确传播细节最好由语言规范来处理。即使这本书在深度上也有一定的限制。尽管你可以使用所有前面的信息并忽略CLR对元组所做的处理，但如果你稍微深入一点，了解编译器如何将这些规则转换为IL，你将能够用元组做更多的事情，并更好地理解其行为。
- en: We’ve covered an awful lot of ground already. If you haven’t tried writing code
    using tuples yet, now is a good time to do so. Take a break from the book and
    see if you can get a feel for tuples before learning how they’re implemented.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了大量的内容。如果你还没有尝试使用元组编写代码，现在是时候这样做。从书中休息一下，看看你能否在学习它们是如何实现之前对元组有一个感觉。
- en: 11.4\. Tuples in the CLR
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. CLR中的元组
- en: Although in theory the C# language isn’t tied to .NET, the reality is that every
    implementation I’ve seen at least attempts to look like the regular .NET Framework
    to some extent, even if it’s compiled ahead of time and runs on a non-PC-desktop
    device. The C# language specification makes certain requirements of the final
    environment, including that certain types are available. At the time of this writing,
    there isn’t a C# 7 specification, but I envision that when it’s introduced, it’ll
    require the types described in this section in order to use tuples.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在理论上C#语言与.NET没有绑定，但现实是，我所看到的每个实现至少在某种程度上都试图看起来像常规.NET Framework，即使它是预编译的，并在非PC桌面设备上运行。C#语言规范对最终环境提出了一些要求，包括某些类型是可用的。在撰写本文时，还没有C#
    7规范，但我设想当它被引入时，它将需要本节中描述的类型来使用元组。
- en: Unlike anonymous types, in which each unique sequence of property names within
    an assembly causes the compiler to generate a new type, tuples don’t require any
    extra types to be generated by the compiler. Instead, it uses a new set of types
    from the framework. Let’s meet them now.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 与匿名类型不同，匿名类型中每个组件内的唯一属性名称序列都会导致编译器生成一个新的类型，元组不需要编译器生成任何额外的类型。相反，它使用框架中的一组新类型。现在让我们来认识它们。
- en: 11.4.1\. Introducing System.ValueTuple<...>
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.1\. 介绍 System.ValueTuple<...>
- en: Tuples in C# 7 are implemented using the `System.ValueTuple` family of types.
    These types live in the `System.ValueTuple.dll` assembly, which is part of .NET
    Standard 2.0 but not part of any older .NET Framework releases. You can use it
    when targeting older frameworks by adding a dependency to the `System.ValueTuple`
    NuGet package.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7中的元组是通过`System.ValueTuple`类型系列实现的。这些类型位于`System.ValueTuple.dll`程序集中，它是.NET
    Standard 2.0的一部分，但不是任何旧版.NET Framework版本的一部分。你可以通过添加对`System.ValueTuple` NuGet包的依赖项来在针对旧框架时使用它。
- en: 'There are nine `ValueTuple` structs with generic arities of 0 through 8:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有九个`ValueTuple`结构体，具有0到8的泛型参数：
- en: '`System.ValueTuple` (nongeneric)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple` (非泛型)'
- en: '`System.ValueTuple<T1>`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple<T1>`'
- en: '`System.ValueTuple<T1, T2>`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple<T1, T2>`'
- en: '`System.ValueTuple<T1, T2, T3>`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple<T1, T2, T3>`'
- en: '`System.ValueTuple<T1, T2, T3, T4>`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple<T1, T2, T3, T4>`'
- en: '`System.ValueTuple<T1, T2, T3, T4, T5>`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple<T1, T2, T3, T4, T5>`'
- en: '`System.ValueTuple<T1, T2, T3, T4, T5, T6>`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple<T1, T2, T3, T4, T5, T6>`'
- en: '`System.ValueTuple<T1, T2, T3, T4, T5, T6, T7>`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple<T1, T2, T3, T4, T5, T6, T7>`'
- en: '`System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>`'
- en: For the moment, we’re going to ignore the first two and the last one, although
    I talk about the latter in [sections 11.4.7](kindle_split_028_split_000.html#ch11lev2sec16)
    and [11.4.8](kindle_split_028_split_000.html#ch11lev2sec17). That leaves us with
    the types with generic arities between 2 and 7 inclusive. (Realistically, those
    are the ones you’re most likely to use anyway.)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将忽略前两个和最后一个，尽管我在[11.4.7](kindle_split_028_split_000.html#ch11lev2sec16)和[11.4.8](kindle_split_028_split_000.html#ch11lev2sec17)部分提到了后者。这让我们只剩下具有2到7个泛型参数的类型的处理。
    (实际上，这些是您最可能使用的类型。)
- en: 'A description of any particular `ValueTuple<...>` type is very much like the
    description of tuple types from earlier: it’s a value type with public fields.
    The fields are called `Item1`, `Item2`, and so on, as far as `Item7`. The arity-8
    tuple’s final field is called `Rest`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 任何特定的`ValueTuple<...>`类型的描述非常类似于早期元组类型的描述：它是一个具有公共字段的值类型。字段被称为`Item1`、`Item2`等，直到`Item7`。具有8个元素的元组的最后一个字段称为`Rest`。
- en: Anytime you use a C# tuple type, it’s mapped onto a `ValueTuple<...>` type.
    That mapping is pretty obvious when the C# tuple type doesn’t have any element
    names; `(int, string, byte)` is mapped to `ValueTuple<int, string, byte>`, for
    example. But what about the optional element names in C# tuple types? Generic
    types are generic only in their type parameters; you can’t magically give two
    constructed types different field names. How does the compiler handle this?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用C#元组类型的时候，它都会映射到一个`ValueTuple<...>`类型。当C#元组类型没有元素名称时，这种映射是非常明显的；例如`(int,
    string, byte)`映射到`ValueTuple<int, string, byte>`。但是，C#元组类型中的可选元素名称怎么办？泛型类型仅在它们的类型参数上是泛型的；你不能神奇地给两个构造类型不同的字段名称。编译器是如何处理这种情况的呢？
- en: 11.4.2\. Element name handling
  id: totrans-311
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.2\. 元素名称处理
- en: Effectively, the C# compiler ignores the names for the purposes of mapping C#
    tuple types to CLR `ValueTuple<...>` types. Although `(int, int)` and `(int x,
    int y)` are distinct types from a C# language perspective, they both map onto
    `ValueTuple <int, int>`. The compiler then maps any uses of element names to the
    relevant `ItemN` name. [Figure 11.5](kindle_split_028_split_000.html#ch11fig05)
    shows the effective translation of C# with a tuple literal into C#, which refers
    only to the CLR types.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，C#编译器在将C#元组类型映射到CLR `ValueTuple<...>`类型时忽略了名称。尽管`(int, int)`和`(int x, int
    y)`从C#语言的角度来看是不同的类型，但它们都映射到`ValueTuple<int, int>`。然后编译器将任何使用元素名称的用法映射到相关的`ItemN`名称。[图11.5](kindle_split_028_split_000.html#ch11fig05)显示了将C#元组字面量转换为C#的有效翻译，它仅引用CLR类型。
- en: Figure 11.5\. Compiler translation of tuple type handling into use of ValueTuple
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.5\. 编译器将元组类型处理转换为使用ValueTuple
- en: '![](../Images/11fig05_alt.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11fig05_alt.jpg)'
- en: Notice that the lower half of [figure 11.5](kindle_split_028_split_000.html#ch11fig05)
    has lost the names. For local variables like this, they’re used only at compile
    time. The only trace of them at execution time would be in the PDB file created
    to give the debugger more information. What about element names that are visible
    outside the relatively small context of a method?
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到[图11.5](kindle_split_028_split_000.html#ch11fig05)的下半部分已经失去了名称。对于这样的局部变量，它们仅在编译时使用。在执行时，它们唯一的痕迹将是在为调试器提供更多信息而创建的PDB文件中。那么，对于在方法相对较小的上下文之外可见的元素名称怎么办？
- en: Element names in metadata
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 元素名称在元数据中
- en: Think back to the `MinMax` method you’ve used several times in this chapter.
    Suppose you make that method public as part of a whole package of aggregating
    methods to complement LINQ to Objects. It’d be a real shame to lose the readability
    afforded by the tuple element names, but you now know that the CLR return type
    of the method can’t propagate them. Fortunately, the compiler can use the same
    technique that’s already in place for other features that aren’t directly supported
    by the CLR, such as `out` parameters and default parameter values; attributes
    to the rescue!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在本章中你已经多次使用的`MinMax`方法。假设你将这个方法公开作为整个聚合方法包的一部分，以补充LINQ to Objects。失去由元组元素名称提供的可读性将是一件非常遗憾的事情，但你现在知道该方法的CLR返回类型无法传播它们。幸运的是，编译器可以使用已经在其他不受CLR直接支持的功能中实施的技术，例如`out`参数和默认参数值；属性来拯救！
- en: 'In this case, the compiler uses an attribute called `TupleElementNamesAttribute`
    (in the same namespace as many similar attributes: `System.Runtime.CompilerServices`)
    to encode the element names in the assembly. For example, a public `MinMax` method
    declaration could be represented in C# 6 as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器使用一个名为 `TupleElementNamesAttribute` 的属性（与许多类似属性位于同一命名空间中：`System.Runtime.CompilerServices`）来在程序集中对元素名称进行编码。例如，一个公共的
    `MinMax` 方法声明可以用 C# 6 表示如下：
- en: '[PRE40]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The C# 7 compiler won’t let you compile that code. The compiler gives an error
    telling you to use tuple syntax directly. But compiling the same code with the
    C# 6 compiler results in an assembly you can use from C# 7, and the elements of
    the returned tuple will be available by name.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 编译器不会让你编译这段代码。编译器会给出一个错误，告诉你直接使用元组语法。但是，使用 C# 6 编译器编译相同的代码会得到一个可以在 C# 7
    中使用的程序集，并且返回的元组的元素可以通过名称访问。
- en: The attribute gets a bit more complicated when nested tuple types are involved,
    but it’s unlikely that you’ll ever need to interpret the attribute directly. It’s
    just worth being aware that it exists and that’s how the element names are communicated
    outside local variables. The attributes are emitted by the C# compiler even for
    private members, even though it could probably make do without them. I suspect
    it’s considerably simpler to treat all members the same way regardless of their
    access modifiers.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到嵌套元组类型时，属性会变得稍微复杂一些，但你几乎不需要直接解释这个属性。只需知道它存在，以及元素名称是如何在局部变量之外进行通信的。即使没有它们，编译器也可以处理私有成员，因此值得知道这一点。我怀疑无论成员的访问修饰符如何，以相同的方式处理所有成员都会简单得多。
- en: No element names at execution time
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行时间没有元素名称
- en: In case it isn’t obvious from everything that’s gone before, a tuple value has
    no concept of element names at execution time. If you call `GetType()` on a tuple
    value, you’ll get a `ValueTuple<...>` type with the appropriate element types,
    but any element names you have in your source code will be nowhere in sight. If
    you step through code and the debugger displays element names, that’s because
    it’s used extra information to work out the original element names; it’s not something
    the CLR knows about directly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的所有内容都没有让你明白，元组值在执行时间没有元素名称的概念。如果你对一个元组值调用 `GetType()`，你会得到一个带有适当元素类型的 `ValueTuple<...>`
    类型，但你在源代码中设置的任何元素名称都不会出现在任何地方。如果你在代码中单步执行，并且调试器显示元素名称，那是因为它使用了额外的信息来推断原始元素名称；这不是
    CLR 直接知道的东西。
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This approach may feel familiar to Java developers. It’s similar to the way
    Java handles generics with type information that isn’t present at execution time.
    In Java, there’s no such thing as an `ArrayList<Integer>` object or an `ArrayList<String>`
    object; they’re just `ArrayList` objects. That’s proved painful in Java, but the
    element names for tuples are less fundamentally important than type arguments
    in generics, so hopefully it won’t end up causing the same kind of problems.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能对 Java 开发者来说很熟悉。它类似于 Java 处理在执行时间没有类型信息的泛型的方式。在 Java 中，没有 `ArrayList<Integer>`
    对象或 `ArrayList<String>` 对象这样的东西；它们只是 `ArrayList` 对象。这在 Java 中证明是痛苦的，但元组的元素名称在泛型类型参数中不如基本重要，所以希望它不会导致同样的问题。
- en: '|  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Element names exist for tuples within the C# language, but not in the CLR. What
    about conversions?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 语言中，元组存在元素名称，但在 CLR 中并不存在。那么转换呢？
- en: 11.4.3\. Tuple conversion implementations
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.3. 元组转换实现
- en: 'The types in the `ValueTuple` family don’t provide *any* conversions as far
    as the CLR is concerned. They wouldn’t be able to; the conversions that the C#
    language provides couldn’t be expressed in the type information. Instead, the
    C# compiler creates a new value when it needs to, performing appropriate conversions
    on each element. Here are two examples of conversions, one implicit (using the
    implicit conversion from `int` to `long`) and one explicit (using the explicit
    conversion from `int` to `byte`):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueTuple` 家族的类型在 CLR 方面不提供任何转换。它们无法做到；C# 语言提供的转换无法在类型信息中表达。相反，当需要时，C# 编译器会为每个元素创建一个新的值，并执行适当的转换。以下有两个转换示例，一个是隐式转换（使用从
    `int` 到 `long` 的隐式转换）和一个显式转换（使用从 `int` 到 `byte` 的显式转换）：'
- en: '[PRE41]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The compiler generates code as if you’d written this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的代码就像你这样写：
- en: '[PRE42]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'That example deals only with the conversions between tuple types that you’ve
    already seen, but the conversions for tuple literals to tuple types work in exactly
    the same way: any conversion required from an element expression to the target
    element type is just performed as part of calling the appropriate `ValueTuple<...>`
    constructor.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 那个例子只处理了你已经看到的元组类型之间的转换，但元组字面量到元组类型的转换以完全相同的方式进行：从元素表达式到目标元素类型的任何所需转换都只是作为调用适当的`ValueTuple<...>`构造函数的一部分来执行。
- en: You’ve now learned about everything the compiler needs in order to provide tuple
    syntax, but the `ValueTuple<...>` types provide more functionality to make them
    easy to work with. Given how general they are, they can’t do much, but the `ToString()`
    method has a readable output, and there are multiple options for comparing them.
    Let’s see what’s available.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经了解了编译器为了提供元组语法所需的所有内容，但`ValueTuple<...>`类型提供了更多功能，使它们易于使用。鉴于它们的通用性，它们不能做很多事情，但`ToString()`方法提供了可读的输出，并且有多个选项用于比较它们。让我们看看有哪些可用功能。
- en: 11.4.4\. String representations of tuples
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.4\. 元组的字符串表示
- en: 'The string representation of a tuple is like a tuple literal in C# source code:
    a sequence of values that is separated by commas and enclosed in parentheses.
    There’s no fine-tuned control of this output; if you use a `(DateTime, DateTime)`
    tuple to represent a date interval, for example, you can’t pass in a format string
    to indicate that you want the elements to be formatted just as dates. The `ToString()`
    method calls `ToString()` on each non-null element and uses an empty string for
    each null element.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的字符串表示形式类似于C#源代码中的元组字面量：由逗号分隔的值序列，用括号括起来。对此输出没有精细的控制；例如，如果你使用`(DateTime, DateTime)`元组来表示日期间隔，你不能传递一个格式字符串来指示你希望元素格式化为日期。`ToString()`方法对每个非空元素调用`ToString()`，对每个空元素使用空字符串。
- en: 'As a reminder, none of the names you’ve provided to the tuple elements are
    known at execution time, so they can’t appear in the results of calling `ToString()`.
    That can make it slightly less useful than the string representation of anonymous
    types, although if you’re printing a lot of tuples of the same type, you’ll be
    grateful for the lack of repetition. One brief example is sufficient to demonstrate
    all of the preceding information:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，你提供给元组元素的名称在执行时是未知的，因此它们不能出现在调用`ToString()`的结果中。这可能会使其比匿名类型的字符串表示形式稍微不那么有用，尽管如果你打印大量相同类型的元组，你会对缺乏重复而感到感激。一个简短的例子就足以展示所有前面的信息：
- en: '[PRE43]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Cast null to string so you can infer the tuple type**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将null转换为字符串以便推断元组类型**'
- en: '***2* Writes the tuple value to the console**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将元组值写入控制台**'
- en: 'The output of this snippet is as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段的输出如下：
- en: '[PRE44]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: I’ve called `ToString()` explicitly here just to prove there’s nothing else
    going on. You’d get the same output by calling `Console.WriteLine(tuple)`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里明确地调用了`ToString()`方法，只是为了证明没有其他操作在进行。调用`Console.WriteLine(tuple)`也会得到相同的结果。
- en: The string representation of tuples is certainly useful for diagnostic purposes,
    but it’d rarely be appropriate to display it directly in an end-user-facing application.
    You’re likely to want to provide more context, specify format information for
    some types, and possibly handle null values more clearly.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的字符串表示对于诊断目的肯定是有用的，但在直接面向最终用户的应用程序中很少适合直接显示。你可能会想要提供更多上下文，指定某些类型的格式信息，并可能更清晰地处理空值。
- en: 11.4.5\. Regular equality and ordering comparisons
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.5\. 常规相等性和排序比较
- en: Each `ValueTuple<...>` type implements `IEquatable<T>` and `IComparable<T>`,
    where `T` is the same as the type itself. For example, `ValueTuple<T1, T2>` implements
    `IEquatable<ValueTuple<T1, T2>>` and `IComparable<ValueTuple<T1, T2>>`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`ValueTuple<...>`类型实现了`IEquatable<T>`和`IComparable<T>`，其中`T`与类型本身相同。例如，`ValueTuple<T1,
    T2>`实现了`IEquatable<ValueTuple<T1, T2>>`和`IComparable<ValueTuple<T1, T2>>`。
- en: 'Each type also implements the nongeneric `IComparable` interface and overrides
    the `object.Equals(object)` method in the natural way: `Equals(object)` will return
    `false` if it’s passed an instance of a different type, and `CompareTo(object)`
    will throw an `ArgumentException` if it’s passed an instance of a different type.
    Otherwise, each method delegates to its counterpart from `IEquatable<T>` or `IComparable<T>`.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型也实现了非泛型的`IComparable`接口，并以自然的方式重写了`object.Equals(object)`方法：如果传入的是不同类型的实例，`Equals(object)`将返回`false`，如果传入的是不同类型的实例，`CompareTo(object)`将抛出`ArgumentException`。否则，每个方法都会委托给`IEquatable<T>`或`IComparable<T>`中的对应方法。
- en: Equality tests are performed element-wise using the default equality comparer
    for each element type. Similarly, element hash codes are computed using the default
    equality comparers, and then those hash codes are combined in an implementation-specific
    way to provide an overall hash code for the tuple. Ordering comparisons between
    tuples are performed element-wise too, with earlier elements being deemed more
    important in the comparisons than later ones, so `(1, 5)` compares as less than
    `(3, 2)`, for example.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 相等性测试是使用每个元素类型的默认相等性比较器逐元素执行的。同样，元素哈希码是使用默认相等性比较器计算的，然后以特定实现的方式将这些哈希码组合起来，为元组提供一个整体的哈希码。元组之间的排序比较也是逐元素执行的，较早的元素在比较中被认为比较晚的元素更重要，例如，`(1,
    5)` 被认为小于 `(3, 2)`。
- en: These comparisons make tuples easy to work with in LINQ. Suppose you have a
    collection of `(int, int)` tuples representing `(x, y)` coordinates. You can use
    familiar LINQ operations to find distinct points in the list and order them. This
    is shown in the following listing.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比较使得元组在 LINQ 中易于处理。假设你有一个表示 `(x, y)` 坐标的 `(int, int)` 元组集合。你可以使用熟悉的 LINQ 操作来查找列表中的不同点并对它们进行排序。这在下述列表中展示。
- en: Listing 11.9\. Finding and ordering distinct points
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.9. 查找和排序不同点
- en: '[PRE45]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `Distinct()` call means that you see (2, 1) only once in the output. But
    the fact that equality is checked element-wise means that (2, 1) isn’t equal to
    (1, 2).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`Distinct()` 调用意味着你只会在输出中看到一次 (2, 1)。但是，由于相等性是逐元素检查的，所以 (2, 1) 并不等于 (1, 2)。'
- en: 'Because the first element in the tuple is considered the most important in
    ordering, our points will be sorted by their `x` coordinates; if multiple points
    have the same `x` coordinate, those will be sorted by their `y` coordinates. The
    output is therefore as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因为元组中的第一个元素在排序中被认为是最重要的，所以我们的点将按照它们的 `x` 坐标进行排序；如果多个点的 `x` 坐标相同，则将按照它们的 `y`
    坐标进行排序。因此，输出如下：
- en: '[PRE46]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The regular comparisons provide no way of specifying how to compare each particular
    element. You can reasonably easily create your own custom implementations of `IEqualityComparer<T>`
    or `IComparer<T>` for specific tuple types, of course, but at that point you might
    want to consider whether it’s worth implementing a fully custom type for the data
    you’re trying to represent and avoid tuples entirely. Alternatively, in some cases
    it may be simpler to use structural comparisons.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的比较无法指定如何比较每个特定的元素。当然，你可以很容易地创建自己的 `IEqualityComparer<T>` 或 `IComparer<T>`
    的自定义实现，用于特定的元组类型，但在这个时候，你可能想要考虑是否值得为你要表示的数据实现一个完全自定义的类型，并完全避免使用元组。或者，在某些情况下，使用结构比较可能更简单。
- en: 11.4.6\. Structural equality and ordering comparisons
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.6. 结构相等性和排序比较
- en: 'In addition to the regular `IEquatable` and `IComparable` interfaces, each
    `ValueTuple` struct explicitly implements `IStructuralEquatable` and `IStructuralComparable`.
    These interfaces have existed since .NET 4.0 and are implemented by arrays and
    the `Tuple` family of immutable classes. I can’t say I’ve ever used the interfaces
    myself, but that’s not to claim they can’t be used and used well. They mirror
    the regular APIs for equality and ordering, but each method takes a comparer that’s
    intended to be used for the individual elements:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的 `IEquatable` 和 `IComparable` 接口之外，每个 `ValueTuple` 结构体还明确实现了 `IStructuralEquatable`
    和 `IStructuralComparable` 接口。这些接口自 .NET 4.0 以来就存在了，并由数组以及不可变的 `Tuple` 类家族实现。我无法说我曾经自己使用过这些接口，但这并不意味着它们不能被使用并且用得好。它们反映了常规的相等性和排序
    API，但每个方法都接受一个比较器，该比较器旨在用于单个元素：
- en: '[PRE47]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The idea behind the interface is to allow composite objects to be compared for
    equality or ordering by performing pairwise comparisons with the given comparer.
    The regular generic comparisons implemented by `ValueTuple` types are statically
    type safe but relatively inflexible, as they always use default comparisons for
    the elements, whereas the structural comparisons are less type safe but provide
    extra flexibility. The following listing demonstrates this using strings and passing
    in a case-insensitive comparer.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接口背后的思想是允许通过使用给定的比较器进行成对比较来比较复合对象以进行相等性或排序。`ValueTuple` 类型实现的常规泛型比较是静态类型安全的，但相对不灵活，因为它们总是使用元素的默认比较。而结构比较则相对不安全，但提供了额外的灵活性。以下列表通过使用字符串并传递不区分大小写的比较器来演示这一点。
- en: Listing 11.10\. Structural comparisons with a case-insensitive comparer
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.10. 使用不区分大小写的比较器进行结构比较
- en: '[PRE48]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Unconventional variable names that reflect the values**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1. 反映值的非常规变量名***'
- en: '***2* Performs a selection of interesting comparisons**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 执行有趣的比较选择**'
- en: '***3* Performs ordering and equality comparisons case insensitively**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 以不区分大小写的方式执行排序和相等比较**'
- en: 'The output of [listing 11.10](kindle_split_028_split_000.html#ch11ex10) demonstrates
    that the comparisons are indeed performed pairwise in a case-insensitive way:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表11.10](kindle_split_028_split_000.html#ch11ex10)的输出表明，比较确实是以不区分大小写的方式成对进行的：'
- en: '[PRE49]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The benefit of this kind of comparison is that it’s all down to composition:
    the comparer knows how to perform comparisons of only individual elements, and
    the tuple implementation delegates each comparison to the comparer. This is a
    little like LINQ, in which you express operations on individual elements but then
    ask them to be performed on collections.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这种比较的好处在于它完全是组合的结果：比较器知道如何仅对单个元素执行比较，而元组实现将每个比较委托给比较器。这有点像LINQ，你在其中表达对单个元素的操作，但随后要求它们在集合上执行。
- en: This is all very well if you have tuples with elements that are all of the same
    type. If you want to perform structural comparisons on tuples with elements of
    different kinds, such as comparing `(string, int, double)` values, then you need
    to make sure your comparer can handle comparing strings, comparing integers, and
    comparing doubles. It’d only need to compare two values of the same type in each
    comparison, however. The `ValueTuple` implementations still allow only tuples
    with the same type arguments to be compared; if you compare a `(string, int)`
    with an `(int, string)`, for example, an exception will be thrown immediately
    and before any elements are compared. An example of such a comparer is beyond
    the scope of this book, but the sample code contains a sketch (`CompoundEqualityComparer`)
    that should be a good starting point if you need to implement something similar
    for production code.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的元组元素都是同一类型，这一切都很完美。如果你想在具有不同类型元素的元组上执行结构比较，例如比较`(string, int, double)`值，那么你需要确保你的比较器可以处理比较字符串、比较整数和比较双精度浮点数。然而，每个比较只需要比较相同类型的两个值。`ValueTuple`实现仍然只允许比较具有相同类型参数的元组；例如，如果你比较`(string,
    int)`和`(int, string)`，则会立即抛出异常，在比较任何元素之前。
- en: That concludes our coverage of the arity-2 to arity-7 `ValueTuple<...>` types,
    but I did mention that I’d come back to the other three types you saw in [section
    11.4.1](kindle_split_028_split_000.html#ch11lev2sec10). First, let’s look at `ValueTuple<T1>`
    and `ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>`, which are more closely related
    than you might expect.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对arity-2到arity-7的`ValueTuple<...>`类型的介绍，但我确实提到我会回到你在[第11.4.1节](kindle_split_028_split_000.html#ch11lev2sec10)中看到的另外三种类型。首先，让我们看看`ValueTuple<T1>`和`ValueTuple<T1,
    T2, T3, T4, T5, T6, T7, TRest>`，它们比你想象的更紧密相关。
- en: 11.4.7\. Womples and large tuples
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.7. Womples和大型元组
- en: 'A single-value tuple (`ValueTuple<T1>`), affectionately known as a *womple*
    by the C# team, can’t be constructed on its own using tuple syntax, but it can
    be part of another tuple. As described earlier, generic `ValueTuple` structs exist
    with only up to eight type parameters. What should the C# compiler do if it’s
    presented with a tuple literal with more than eight elements? It uses the `ValueTuple<...>`
    with arity 8 with the first seven type arguments corresponding to the first seven
    types from the tuple literal and the final element being a nested tuple type for
    the remaining elements. If you have a tuple literal with exactly eight `int` elements,
    the type involved will be as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 单值元组（`ValueTuple<T1>`），被C#团队亲切地称为*womple*，不能单独使用元组语法构建，但它可以是另一个元组的一部分。如前所述，存在具有最多八个类型参数的泛型`ValueTuple`结构。如果C#编译器遇到一个包含超过八个元素的元组字面量，它应该怎么做？它使用具有8个参数的`ValueTuple<...>`，前七个类型参数对应于元组字面量中的前七个类型，最后一个元素是剩余元素的嵌套元组类型。如果你有一个包含正好八个`int`元素的元组字面量，涉及的类型如下：
- en: '[PRE50]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There’s the womple, highlighted in bold. The `ValueTuple<...>` with arity 8
    is especially designed for this usage; the final type argument (`TRest`) is constrained
    to be a value type, and, as I mentioned at the start of [section 11.4.1](kindle_split_028_split_000.html#ch11lev2sec10),
    there’s no `Item8` field. Instead, there’s a `Rest` field.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有**womple**，用粗体突出显示。`ValueTuple<...>`具有8个参数，专门为此用途设计；最后的类型参数（`TRest`）被限制为必须是值类型，并且，正如我在[第11.4.1节](kindle_split_028_split_000.html#ch11lev2sec10)开头提到的，没有`Item8`字段。相反，有一个`Rest`字段。
- en: It’s important that the last element of an arity-8 `ValueTuple<...>` is always
    expected to be a tuple with more elements rather than a final individual element
    to avoid ambiguity. For example, a tuple type like this
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个参数为8的`ValueTuple<...>`中，最后一个元素始终预期是一个包含更多元素的元组，而不是一个最终的单独元素，以避免歧义。例如，这样的元组类型
- en: '[PRE51]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: could be treated as a C#-syntax type `(A, B, C, D, E, F, G, H, I)` with arity
    9 or a type `(A, B, C, D, E, F, G, (H, I))` with arity 8 and the final element
    being a tuple type.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被视为具有9个参数的C#-语法类型`(A, B, C, D, E, F, G, H, I)`或具有8个参数的类型`(A, B, C, D, E, F,
    G, (H, I))`，其中最后一个元素是元组类型。
- en: 'As a developer, you don’t need to worry about all of this, because the C# compiler
    allows you to use `ItemX` names for *all* the elements in a tuple regardless of
    the number of elements and whether you’ve used the tuple syntax or explicitly
    referred to `ValueTuple`. For example, consider a rather long tuple:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，你不需要担心所有这些，因为C#编译器允许你使用`ItemX`名称来表示元组中的所有元素，无论元素数量多少，以及你是否使用了元组语法或显式引用了`ValueTuple`。例如，考虑一个相当长的元组：
- en: '[PRE52]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: That’s perfectly valid code, but the `tuple.Item16` expression is converted
    by the compiler into `tuple.Rest.Rest.Item2`. If you want to use the real field
    names, you can certainly do so; I just wouldn’t advise it. Now from huge tuples
    to the exact opposite.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码完全有效，但编译器会将`tuple.Item16`表达式转换为`tuple.Rest.Rest.Item2`。如果你想使用真正的字段名，当然可以这样做；我只是不建议这样做。现在从巨大的元组到完全相反的情况。
- en: 11.4.8\. The nongeneric ValueTuple struct
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.8\. 非泛型ValueTuple结构
- en: If the womple sounded slightly silly to start with, the *nuple*—a nongeneric
    tuple, one without any elements at all—sounds even more pointless. You might have
    expected the nongeneric `ValueTuple` to be a static class, like the nongeneric
    `Nullable` class, but it’s a struct and looks for all the world like the other
    tuple structs, other than not having any data. It implements all the interfaces
    described earlier in this section, but every nuple value is equal (in both plain
    equality and ordering senses) to every other nuple value, which makes sense, as
    there’s nothing to differentiate them from each other.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一开始womple听起来有点愚蠢，那么*nuple*——一个非泛型元组，一个没有任何元素的元组——听起来更是毫无意义。你可能预期非泛型的`ValueTuple`会是一个静态类，就像非泛型的`Nullable`类一样，但它是一个结构体，看起来和其他元组结构体一样，除了没有任何数据。它实现了本节前面描述的所有接口，但每个nuple值（在普通相等和排序意义上）都等于其他每个nuple值，这是有道理的，因为没有什么可以区分它们。
- en: 'It does have static methods that would be useful for creating `ValueTuple<...>`
    values if we didn’t have tuple literals. Those methods will primarily be useful
    if you want to use tuple types from C# 6 or from another language that doesn’t
    have built-in support, and you want to use type inference for the element types.
    (Remember, when you call a constructor, you always have to specify all the type
    arguments, which can be annoying.) For example, to construct an `(int, int)` value
    tuple in C# 6 using type inference, you could use this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实有静态方法，如果没有元组字面量，这些方法将非常有用，用于创建`ValueTuple<...>`值。这些方法主要在你想要从C# 6或没有内置支持的另一种语言中使用元组类型，并且想要使用元素类型的类型推断时有用。（记住，当你调用构造函数时，你总是必须指定所有类型参数，这可能会很烦人。）例如，要在C#
    6中使用类型推断构造一个`(int, int)`值元组，你可以使用这个：
- en: '[PRE53]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The C# team has hinted that there may be future places where nuples will be
    useful with pattern matching and decomposition, but it’s more of a placeholder
    than anything else at the moment.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: C#团队暗示，未来可能会有一些地方nuples在模式匹配和分解中很有用，但目前这更多的是一个占位符。
- en: 11.4.9\. Extension methods
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.9\. 扩展方法
- en: 'The `System.TupleExtensions` static class is provided in the same assembly
    as the `System.ValueTuple` types. It contains extension methods on the `System.Tuple`
    and `System.ValueTuple` types. There are three kinds of methods:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.TupleExtensions`静态类与`System.ValueTuple`类型位于同一程序集。它包含对`System.Tuple`和`System.ValueTuple`类型的扩展方法。有三种类型的方法：'
- en: '`Deconstruct`, which extends the `Tuple` types'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Deconstruct`，它扩展了`Tuple`类型'
- en: '`ToValueTuple`, which extends the `Tuple` types'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToValueTuple`，它扩展了`Tuple`类型'
- en: '`ToTuple`, which extends the `ValueTuple` types'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToTuple`，它扩展了`ValueTuple`类型'
- en: 'Each kind of method is overloaded 21 times by generic arity using the same
    pattern you saw previously to handle arities of 8 or more. You’ll look at `Deconstruct`
    in [chapter 12](kindle_split_029_split_000.html#ch12), but `ToValueTuple` and
    `ToTuple` do exactly what you’d expect them to: they convert between the .NET
    4.0 era immutable reference type tuples and the new mutable value type tuples.
    I expect these to be useful primarily when working with legacy code using `Tuple`.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都通过使用你之前看到的相同模式，通过泛型参数数量进行 21 次重载，以处理 8 个或更多的参数数量。你将在第 12 章（kindle_split_029_split_000.html#ch12）中查看
    `Deconstruct`，但 `ToValueTuple` 和 `ToTuple` 完全按照你的预期执行：它们在 .NET 4.0 时代的不可变引用类型元组和新的可变值类型元组之间进行转换。我预计这些主要用于与使用
    `Tuple` 的遗留代码一起工作。
- en: 'Phew! That’s just about everything I think is worth knowing about the types
    involved in implementing tuples on the CLR. Next, we’re going to consider your
    other options: if you’re thinking about using a tuple, you should be aware that’s
    only one of the tools in your box, and it isn’t always the most appropriate one
    to reach for.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这就是我想知道的关于在 CLR 上实现元组所涉及类型的一切了。接下来，我们将考虑你的其他选项：如果你在考虑使用元组，你应该知道这仅仅是你的工具箱中的一个工具，而且并不总是最合适的选择。
- en: 11.5\. Alternatives to tuples
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5\. 元组的替代方案
- en: It may seem trite to remind you of this, but every option you’ve ever used in
    the past for a bag of variables is still valid. You don’t *have* to use the C#
    7 tuples anywhere. This section briefly looks at the pros and cons of the other
    options.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这听起来可能有些陈词滥调，但你在过去用于变量集合的每个选项仍然有效。你并不*必须*在任何地方使用 C# 7 的元组。本节简要探讨了其他选项的优缺点。
- en: 11.5.1\. System.Tuple<...>
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.1\. System.Tuple<...>
- en: The .NET 4 `System.Tuple<...>` types are immutable reference types, although
    the element types within them may be mutable. You can think of it as being immutable
    in a shallow fashion, just like `readonly` fields.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 4 的 `System.Tuple<...>` 类型是不可变的引用类型，尽管它们内部的元素类型可能是可变的。你可以将其视为在浅层上不可变，就像
    `readonly` 字段一样。
- en: The biggest downside here is the lack of any kind of language integration. Old-school
    tuples are harder to create, the types are more long-winded to specify, the conversions
    I describe in [section 11.3](kindle_split_028_split_000.html#ch11lev1sec3) simply
    aren’t present, and most important, you can use only the `ItemX` naming style.
    Even though the names attached to C# 7 tuples are compile-time only, they still
    make a huge difference in usability.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最大的缺点是缺乏任何语言集成。传统的元组更难创建，类型指定更冗长，我在第 11.3 节（kindle_split_028_split_000.html#ch11lev1sec3）中描述的转换根本不存在，最重要的是，你只能使用
    `ItemX` 命名风格。尽管附加到 C# 7 元组上的名称仅在编译时有效，但它们在可用性上仍然有巨大的差异。
- en: 'Beyond this, reference type tuples feel like fully fledged objects instead
    of bags of values, which can be good or bad depending on the context. They’re
    usually less convenient to work with, but it’s certainly more efficient to copy
    a single reference to a large `Tuple<...>` object than it is to copy a `ValueTuple<...>,`
    which involves copying all the element values. This also has implications on safe
    multithreading: copying a reference is atomic, whereas copying a value tuple isn’t.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，引用类型元组感觉像是完整的对象，而不是值的集合，这取决于上下文，可能是好是坏。它们通常不太方便使用，但复制一个大型 `Tuple<...>` 对象的单个引用肯定比复制一个
    `ValueTuple<...>` 更有效率，后者涉及到复制所有元素值。这也对安全的多线程有影响：复制引用是原子的，而复制值元组则不是。
- en: 11.5.2\. Anonymous types
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.2\. 匿名类型
- en: Anonymous types were introduced as part of LINQ, and that remains their primary
    use case in my experience. You could use them for regular variables within a method,
    but I can’t remember ever seeing that usage in production code.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型作为 LINQ 的一部分被引入，在我的经验中，这仍然是它们的主要用途。你可以在方法内的常规变量中使用它们，但我记不起在生产代码中看到过这种用法。
- en: 'Most of the nice features of anonymous types are also present in C# 7 tuples:
    named elements, natural equality, and a clear string representation. The main
    problem with anonymous types is precisely that they’re anonymous; you can’t return
    them from methods or properties without losing all the type safety. (You basically
    have to use `object` or `dynamic`. The information is still there at execution
    time, but the compiler doesn’t know about it.) C# 7 tuples don’t have that problem.
    It’s fine to return a tuple from a method, as you’ve seen.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型的许多优点也存在于C# 7元组中：命名元素、自然相等性和清晰的字符串表示。匿名类型的主要问题正是它们是匿名的；你不能从方法或属性中返回它们而不会丢失所有类型安全。你基本上必须使用`object`或`dynamic`。在执行时信息仍然存在，但编译器不知道这一点。C#
    7元组没有这个问题。从方法中返回元组是完全可以的，就像你看到的。
- en: 'I can see four advantages of anonymous types over tuples:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以看到匿名类型相对于元组的四个优点：
- en: 'In C# 7.0, projection initializers that provide both a name and a value in
    a single identifier are simpler than tuples; compare `new { p.Name, p.Age }` and
    `(name: p.Name, age: p.Age)`, for example. This is addressed in C# 7.1, as the
    tuple element names can be inferred, leading to compact representations such as
    `(p.Name, p.Age)`.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在C# 7.0中，提供单个标识符中名称和值的投影初始化器比元组简单；例如，比较`new { p.Name, p.Age }`和`(name: p.Name,
    age: p.Age)`。这在C# 7.1中得到解决，因为元组元素名称可以被推断，从而产生如`(p.Name, p.Age)`这样的紧凑表示。'
- en: The use of names within the string representation of anonymous types can be
    handy for diagnostic purposes.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在匿名类型的字符串表示中使用名称对于诊断目的来说可能很有用。
- en: Anonymous types are supported by out-of-process LINQ providers (to databases
    and so on). Tuple literals can’t currently be used within expression trees, making
    the value proposition significantly weaker.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名类型由进程外LINQ提供程序（数据库等）支持。元组字面量目前不能在表达式树中使用，这使得其价值主张显著减弱。
- en: Anonymous types can be more efficient in some contexts due to a single reference
    being passed through a pipeline. In most cases, I wouldn’t expect this to be a
    problem at all, and the fact that tuples don’t create any objects for the garbage
    collector to clean up is an efficiency benefit in the other direction, of course.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在管道中传递单个引用，匿名类型在某些情况下可能更有效率。在大多数情况下，我不期望这会成为一个问题，而且元组不会为垃圾收集器创建任何需要清理的对象，这在其他方面是一个效率优势，当然。
- en: Within LINQ to Objects, I expect to use tuples extensively, particularly when
    using C# 7.1 and its inferred tuple element names.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在LINQ to Objects中，我预计会广泛使用元组，尤其是在使用C# 7.1及其推断的元组元素名称时。
- en: 11.5.3\. Named types
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.3. 命名类型
- en: Tuples are just bags of variables. There’s no encapsulation; no meaning is attached
    to them other than what you decide to do with them. Sometimes that’s exactly what
    you want, but be careful of taking this too far. Consider a `(double, double)`.
    That could be used as
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 元组只是变量的集合。它们没有封装；除了你决定如何使用它们之外，它们没有其他含义。有时这正是你想要的，但要注意不要走得太远。考虑一个`(double, double)`。它可以用来表示
- en: 2D Cartesian coordinates (x, y)
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D笛卡尔坐标（x, y）
- en: 2D polar coordinates (radius, angle)
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D极坐标（半径，角度）
- en: 1D start/end pair
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1D起始/结束对
- en: Any number of other things
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他数量的事物
- en: Each of these use cases would have different operations on it when modeled as
    a first-class type. You wouldn’t need to worry about names not being propagated
    or accidentally using Cartesian coordinates as polar coordinates, for example.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为一等类型建模时，这些用例中的每一个都会对其执行不同的操作。你不需要担心名称没有传播或者不小心使用了笛卡尔坐标而不是极坐标，例如。
- en: If you need the grouping of values only temporarily, or if you’re prototyping
    and you’re not sure what you’ll need, tuples are great. But if you find you’re
    using the same tuple shape in several places in your code, I’d recommend replacing
    it with a named type.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要临时分组值，或者如果你正在原型设计且不确定你需要什么，元组是个不错的选择。但如果你发现你在代码的几个地方使用了相同的元组结构，我建议你用命名类型来替换它。
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A Roslyn code analyzer to automate most of this, using tuple element names to
    detect different usages, could be wonderful. I don’t know of any such tool at
    the moment, unfortunately.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Roslyn代码分析器可以自动化大部分这些操作，使用元组元素名称来检测不同的用法，这将是非常棒的。不幸的是，目前我不知道有这样的工具。
- en: '|  |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: With that background of alternative options, let’s round off this chapter with
    some more detailed recommendations about where tuples might be useful.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个替代选项的背景下，让我们以一些更详细的建议来结束这一章，关于元组可能有用的情况。
- en: 11.6\. Uses and recommendations
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6. 使用和建议
- en: First, it’s important to remember that language support for tuples is new within
    C# 7\. Any suggestions here are the result of *thinking* about tuples rather than
    extensive *use* of tuples. Reason can get you so far, but it doesn’t give much
    insight into the actual experience. My expectations about when I’d use new language
    features have proved somewhat incorrect in the past, so take everything here with
    a grain of salt. That said, hopefully it at least provides some food for thought.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要记住，在C# 7中，对元组的语言支持是新的。这里提出的任何建议都是基于对元组的思考，而不是对元组的广泛使用。理性可以带你走得很远，但它并不能给你太多关于实际经验的洞察。我过去对何时使用新语言特性的预期证明是有些错误的，所以请带着一颗宽容的心来看待这里的一切。话虽如此，但希望至少能提供一些思考的食物。
- en: 11.6.1\. Nonpublic APIs and easily changed code
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.1\. 非公共API和易于更改的代码
- en: Until the community in general has more experience with tuples and best practices
    have been established through hard-won battle scars, I’d avoid using tuples in
    public APIs, including protected members for types that can be derived from in
    other assemblies. If you’re in the lucky situation where you control (and can
    modify arbitrarily) all the code that interacts with yours, you can be more speculative.
    But you don’t want to put yourself in a situation where you return a tuple from
    a public method just because it’s easy to do, only to discover later that you
    really wanted to encapsulate those values more thoroughly. A named type takes
    more design and implementation work, but the result is unlikely to be harder for
    the caller to use. Tuples are mostly convenient for the implementer rather than
    the caller.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在社区普遍对元组有更多经验并且最佳实践通过艰苦的战斗经验确立之前，我会避免在公共API中使用元组，包括在其他程序集可以派生的类型中的受保护成员。如果你处于幸运的情况，可以控制（并且可以任意修改）与你的代码交互的所有代码，你可以更加推测。但你不希望处于这样的情况：仅仅因为从公共方法返回元组很容易，后来却发现你实际上更希望更彻底地封装这些值。命名类型需要更多设计和实现工作，但结果可能不会比调用者使用起来更难。元组主要方便的是实现者而不是调用者。
- en: My current preference is to go even further and use tuples only as an implementation
    detail within a type. I’m comfortable returning a tuple from a private method,
    but I’d shy away from doing so from an internal method in production code. In
    general, the more localized the decision, the easier it is to change your mind
    and the less you have to think about it.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我目前的偏好是更进一步，只在类型内部将元组用作实现细节。我可以在私有方法中返回元组，但我会避免在生产代码中的内部方法中这样做。一般来说，决策越局部化，改变主意就越容易，你也不必过多地思考。
- en: 11.6.2\. Local variables
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.2\. 本地变量
- en: Tuples are primarily designed to allow multiple values to be returned from a
    method without using `out` parameters or a dedicated return type. That doesn’t
    mean that’s the only place you can use them, though.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 元组主要是为了允许在不需要使用`out`参数或专用返回类型的情况下从方法中返回多个值而设计的。但这并不意味着你只能在这些地方使用它们。
- en: It’s not unusual within a method to have natural groups of variables. You can
    often tell this when you look at the variables if they have a common prefix. For
    example, [listing 11.11](kindle_split_028_split_000.html#ch11ex11) shows a method
    that might occur in a game to display the highest-scoring player for a particular
    date. Although LINQ to Objects has a `Max` method that’ll return the highest value
    for a projection, there’s nothing that will return the original sequence element
    associated with that value.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中，自然地分组变量并不罕见。当你查看变量时，如果它们有一个共同的词缀，你通常可以判断出来。例如，[列表11.11](kindle_split_028_split_000.html#ch11ex11)显示了一个可能在游戏中出现的方法，用于显示特定日期的最高得分玩家。尽管LINQ
    to Objects有一个`Max`方法可以返回投影的最高值，但没有东西可以返回与该值关联的原始序列元素。
- en: '|  |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative is to use `OrderByDescending(...).FirstOrDefault()`, but that’s
    introducing sorting when you need to find only a single value. The MoreLinq package
    has the `MaxBy` method, which addresses this deficiency. Another alternative to
    keeping two variables is to keep a single `highestGame` variable and use the `Score`
    property of that in the comparison. In more complex cases, that may not be as
    feasible.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`OrderByDescending(...).FirstOrDefault()`，但这会在你需要找到单个值时引入排序。MoreLinq包有`MaxBy`方法，可以解决这个问题。另一种保持两个变量的替代方法是保持一个单一的`highestGame`变量，并在比较中使用该变量的`Score`属性。在更复杂的情况下，这可能不太可行。
- en: '|  |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 11.11\. Displaying the highest-scoring player for a date
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.11\. 显示特定日期的最高得分玩家
- en: '[PRE54]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here you have four local variables, including the parameter:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你有四个局部变量，包括参数：
- en: '`date`'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`'
- en: '`filteredGames`'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filteredGames`'
- en: '`highestPlayer`'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`highestPlayer`'
- en: '`highestScore`'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`highestScore`'
- en: The last two of these are tightly related to each other; they’re initialized
    at the same time and changed together. This suggests you could *consider* using
    a tuple variable instead, as in the following listing.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个问题紧密相关；它们同时初始化并一起更改。这表明你可以 *考虑* 使用元组变量，如下面的列表所示。
- en: Listing 11.12\. A refactoring to use a tuple local variable
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.12\. 使用元组局部变量的重构
- en: '[PRE55]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The changes are shown in bold. Is this better? Maybe. Philosophically, it’s
    exactly the same code, when you think about a tuple as just a collection of variables.
    It feels slightly cleaner to me, because it reduces the number of concepts the
    method is considering at the top level. Obviously, in the kind of simplistic examples
    that are applicable to books, differences in clarity are likely to be small. But
    if you have a complicated method that’s resistant to refactoring into multiple
    smaller methods, tuple local variables could make a more significant difference.
    The same kind of consideration makes sense for fields, too.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 改变的内容以粗体显示。这是否更好？也许吧。从元组被视为变量集合的角度来看，从哲学上讲，代码是完全相同的。对我来说，它感觉稍微干净一些，因为它减少了方法在顶层考虑的概念数量。显然，在适用于书籍的简单示例中，清晰度的差异可能很小。但是，如果你有一个难以重构为多个较小方法的方法，元组局部变量可能会产生更显著的影响。对于字段，这种考虑也是合理的。
- en: 11.6.3\. Fields
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.3\. 字段
- en: 'Just as local variables sometimes cluster together naturally, so do fields.
    Here’s an example from Noda Time in `PrecalculatedDateTimeZone`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 正如局部变量有时会自然地聚集在一起一样，字段也是如此。以下是从 Noda Time 的 `PrecalculatedDateTimeZone` 中的一个示例：
- en: '[PRE56]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'I’m not going to explain the meaning of all these fields, but hopefully it’s
    reasonably obvious that the last three of them relate to a tail zone. We could
    consider changing this to use two fields instead, one of which is a tuple:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会解释所有这些字段的意义，但希望可以合理明显地看出最后三个字段与尾区相关。我们可以考虑将它们改为使用两个字段，其中一个字段是元组：
- en: '[PRE57]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The rest of the code can then refer to `tailZone.start`, `tailZone.intervalMap`,
    and so forth. Note that because the `tailZone` variable is declared to be `readonly`,
    assignments to the individual elements are invalid except in the constructor.
    A few limitations and caveats exist:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 之后的代码可以引用 `tailZone.start`、`tailZone.intervalMap` 等等。请注意，因为 `tailZone` 变量被声明为
    `readonly`，除了在构造函数中之外，对单个元素的赋值都是无效的。存在一些限制和注意事项：
- en: The elements of the tuple can still be assigned individually in the constructor,
    but there’s no warning if you initialize some elements but not all of them. For
    example, if you forgot to initialize `tailZoneStart` in the original code, you’d
    see a warning, but there’s no equivalent warning if you forget to initialize `tailZone.start`.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组的元素仍然可以在构造函数中单独赋值，但如果你初始化了某些元素但没有全部初始化，则不会有警告。例如，如果你在原始代码中忘记了初始化 `tailZoneStart`，你会看到一个警告，但如果你忘记了初始化
    `tailZone.start`，则没有等效的警告。
- en: Either the whole tuple field is read-only or none of it is. If you have a group
    of related fields, some of which are read-only and some of which aren’t, you either
    have to forego the read-only aspect or not use this technique. At that point,
    I’d usually just not use tuples.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么整个元组字段是只读的，要么都不是。如果你有一组相关的字段，其中一些是只读的，而另一些不是，你或者必须放弃只读的特性，或者不使用这种技术。在那个点上，我通常会直接不使用元组。
- en: If some of the fields are automatically generated fields backing automatically
    implemented properties, you’d have to write full properties to use the tuple.
    Again, at that point I’d skip the tuple.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果某些字段是自动生成的字段，作为自动实现属性的支撑，你必须编写完整的属性来使用元组。再次，在那个点上，我会跳过元组。
- en: Finally, one aspect of tuples that may not be obvious is their interaction with
    dynamic typing.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，元组的一个可能不明显方面是它与动态类型的交互。
- en: 11.6.4\. Tuples and dynamic don’t play together nicely
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.6.4\. 元组与动态类型并不总是相处融洽
- en: I don’t use `dynamic` much myself anyway, and I suspect that good uses of dynamic
    typing and good uses of tuples won’t have much of an intersection. It’s worth
    being aware of two issues around element access, however.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我自己并不经常使用 `dynamic`，而且我怀疑动态类型和元组的良好用途交集不会很大。然而，值得注意的是关于元素访问的两个问题。
- en: The dynamic binder doesn’t know about element names
  id: totrans-456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态绑定器不知道元素名称
- en: 'Remember that element names are mostly a compile-time concern. Mix that with
    the way dynamic binding happens only at execution times, and I suspect you can
    see what’s coming. As a simple example, consider the following code:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，元素名称主要是在编译时考虑的问题。再结合动态绑定仅在执行时发生的特性，我猜你大概能预见接下来会发生什么。作为一个简单的例子，考虑以下代码：
- en: '[PRE58]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At first glance, it sounds reasonable to expect this to print 10, but an exception
    is thrown:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎应该输出10，但会抛出异常：
- en: '[PRE59]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Although this is unfortunate, it’d require significant gymnastics for element
    name information to be preserved for the dynamic binder to make this work. I’m
    not expecting this to change. If you modify the code to print `tuple.Item1` instead,
    that’s fine. At least, it’s fine for the first seven elements.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很不幸，但要保留元素名称信息以便动态绑定器工作，需要做大量的调整。我不期望这种情况会改变。如果你修改代码以打印`tuple.Item1`而不是`tuple.Item9`，那没问题。至少，对于前七个元素来说，这是可以的。
- en: The dynamic binder doesn’t (currently) know about high element numbers
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 动态绑定器（目前）不知道高元素编号
- en: In section 11.5.4, you saw how the compiler handles tuples with more than seven
    elements. The compiler uses the arity-8 `ValueTuple<...>` with a final element
    that contains another tuple accessed via the `Rest` field instead of an `Item8`
    field. In addition to transforming the type itself, the compiler transforms numbered
    element access; source code referring to `tuple.Item9` refers to `tuple.Rest.Item2`
    in the generated IL, for example.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在11.5.4节中，你看到了编译器如何处理包含超过七个元素的元组。编译器使用具有8个参数的`ValueTuple<...>`，其最后一个元素包含另一个通过`Rest`字段访问的元组，而不是`Item8`字段。除了转换类型本身之外，编译器还会转换编号元素访问；例如，源代码中引用`tuple.Item9`在生成的IL中会引用`tuple.Rest.Item2`。
- en: 'At the time of this writing, the dynamic binder isn’t aware of this, so again
    you’ll see an exception where the same code would be fine with compile-time binding.
    As an example, you can easily test and play with this yourself:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，动态绑定器对此并不知情，因此你将再次看到在编译时绑定中相同的代码会抛出异常。例如，你可以轻松地测试和尝试以下操作：
- en: '[PRE60]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Works, referring to tuple.Rest.Item2**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 成功，引用tuple.Rest.Item2**'
- en: '***2* Fails at execution time**'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在执行时失败**'
- en: Unlike the previous issue, this could be fixed by making the dynamic binder
    smarter. But the execution-time behavior will then depend on which version of
    the dynamic binder your application ends up using. Usually, a reasonably clean
    separation exists between which version of the compiler you use and which assembly
    and framework versions you use. Requiring a particular version of the dynamic
    binder would certainly muddy the waters somewhat.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个问题不同，可以通过使动态绑定器更智能来修复这个问题。但这样执行时的行为将取决于你的应用程序最终使用哪个版本的动态绑定器。通常，编译器版本、程序集和框架版本之间存在合理的分离。要求特定的动态绑定器版本无疑会使得问题更加复杂。
- en: Summary
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Tuples act as bags of elements with no encapsulation.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组作为没有封装的元素集合。
- en: Tuples in C# 7 have distinct language and CLR representations.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7中的元组具有独特的语言和CLR表示。
- en: Tuples are value types with public, mutable fields.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组是具有公共、可变字段的值类型。
- en: C# tuples support flexible element names.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#元组支持灵活的元素名称。
- en: The CLR `ValueTuple<...>` structs always use element names of `Item1`, `Item2`,
    and so forth.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR `ValueTuple<...>` 结构体始终使用`Item1`、`Item2`等元素名称。
- en: C# provides conversions for tuple types and tuple literals.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#为元组类型和元组文字提供了转换。
- en: Chapter 12\. Deconstruction and pattern matching
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章。解构和模式匹配
- en: '|  |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Deconstructing tuples into multiple variables
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元组解构到多个变量中
- en: Deconstructing nontuple types
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非元组类型的解构
- en: Applying pattern matching in C# 7
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C# 7中应用模式匹配
- en: Using the three kinds of patterns introduced in C# 7
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C# 7中引入的三种模式
- en: '|  |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In [chapter 11](kindle_split_028_split_000.html#ch11), you learned that tuples
    allow you to compose data simply without having to create new types and allowing
    one variable to act as a bag of other variables. When you used the tuples—for
    example, to print out the minimum value from a sequence of integers and then print
    out the maximum—you extracted the values from the tuple one at a time.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](kindle_split_028_split_000.html#ch11)中，你了解到元组允许你简单地组合数据，而不必创建新类型，并允许一个变量充当其他变量的集合。当你使用元组时——例如，从整数序列中打印最小值然后打印最大值——你会逐个从元组中提取值。
- en: That certainly works, and in many cases it’s all you need. But in plenty of
    cases, you’ll want to break a composite value into separate variables. This operation
    is called *deconstruction*. That composite value may be a tuple, or it could be
    of another type—`KeyValuePair`, for example. C# 7 provides simple syntax to allow
    multiple variables to be declared or initialized in a single statement.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然有效，在许多情况下，这已经足够了。但在很多情况下，你可能希望将复合值分解为单独的变量。这种操作称为 *分解*。这个复合值可能是一个元组，也可能是其他类型——例如
    `KeyValuePair`。C# 7 提供了简单的语法，允许在单个语句中声明或初始化多个变量。
- en: Deconstruction occurs in an unconditional way just like a sequence of assignments.
    Pattern matching is similar, but in a more dynamic context; the input value has
    to match the pattern in order to execute the code that follows it. C# 7 introduces
    pattern matching in a couple of contexts and a few kinds of patterns, and there
    will likely be more in future releases. We’ll start building on [chapter 11](kindle_split_028_split_000.html#ch11)
    by deconstructing the tuples you’ve just created.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 分解以无条件的方式进行，就像一系列赋值操作。模式匹配与此类似，但处于更动态的环境中；输入值必须匹配模式才能执行其后的代码。C# 7 在几个上下文中引入了模式匹配，以及几种模式，未来版本可能还会更多。我们将从分解你刚刚创建的元组开始，构建[第
    11 章](kindle_split_028_split_000.html#ch11)。
- en: 12.1\. Deconstruction of tuples
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. 元组的分解
- en: 'C# 7 provides two flavors of deconstruction: one for tuples and one for everything
    else. They follow the same syntax and have the same general features, but talking
    about them in the abstract can be confusing. We’ll look at tuples first, and I’ll
    call out anything that’s tuple specific. In [section 12.2](kindle_split_029_split_000.html#ch12lev1sec2),
    you’ll see how the same ideas are applied to other types. Just to give you an
    idea of what’s coming, the following listing shows several features of deconstruction,
    each of which you’ll examine in more detail.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 提供了两种分解方式：一种用于元组，另一种用于其他所有类型。它们的语法相同，具有相同的一般特性，但在抽象层面上谈论它们可能会造成混淆。我们首先来看元组，我会指出任何特定于元组的内容。在[第
    12.2 节](kindle_split_029_split_000.html#ch12lev1sec2)中，你将看到相同的概念如何应用于其他类型。为了给你一个大致的概念，下面的列表展示了分解的几个特性，你将在接下来的内容中更详细地研究它们。
- en: Listing 12.1\. Overview of deconstruction using tuples
  id: totrans-489
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1\. 使用元组的分解概述
- en: '[PRE61]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Creates a tuple of type (int, string)**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个类型为 (int, string) 的元组**'
- en: '***2* Deconstructs to new variables a, b implicitly**'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 隐式分解为新的变量 a, b**'
- en: '***3* Deconstructs to new variables c, d explicitly**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 明确分解为新的变量 c, d**'
- en: '***4* Deconstructs to existing variables**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 分解为现有变量**'
- en: '***5* Proves that deconstruction works**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 证明分解是有效的**'
- en: 'I suspect that if you were shown that code and told that it would compile,
    you’d already be able to guess the output, even if you hadn’t read anything about
    tuples or deconstruction before:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑，如果你看到那段代码并被告知它将编译，即使你之前没有阅读过有关元组或分解的内容，你也已经能够猜出输出结果：
- en: '[PRE62]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: All you’ve done is declared and initialized the six variables `a`, `b`, `c`,
    `d`, `e`, and `f` in a new way that takes less code than it would’ve before. This
    isn’t to diminish the usefulness of the feature, but this time there’s relatively
    little subtlety to go into. In all cases, the operation is as simple as copying
    a value out of the tuple into a variable. It doesn’t associate the variable with
    the tuple; changing the variable later won’t change the tuple, or vice versa.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你所做的一切只是以比以前更少代码的方式声明和初始化了六个变量 `a`、`b`、`c`、`d`、`e` 和 `f`。这并不是要贬低该特性的有用性，但这次相对没有太多细微之处需要探讨。在所有情况下，操作都像是从元组中复制一个值到变量中一样简单。它不会将变量与元组关联；稍后更改变量不会更改元组，反之亦然。
- en: '|  |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Tuple declaration and deconstruction syntax**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**元组声明和分解语法**'
- en: 'The language specification regards deconstruction as closely related to other
    tuple features. Deconstruction syntax is described in terms of a *tuple expression*
    even when you’re not deconstructing tuples (which you’ll see in [section 12.2](kindle_split_029_split_000.html#ch12lev1sec2)).
    You probably don’t need to worry too much about that, but you should be aware
    of potential causes for confusion. Consider these two statements:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 语言规范将分解视为与其他元组特性密切相关。即使你不在分解元组时，分解语法也是以 *元组表达式* 的形式描述的（你将在[第 12.2 节](kindle_split_029_split_000.html#ch12lev1sec2)中看到）。你可能不需要过于担心这一点，但你应该意识到潜在的混淆原因。考虑以下两个语句：
- en: '[PRE63]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first uses deconstruction to declare two variables (`c` and `d`); the second
    is a declaration of a single variable (`x`) of tuple type `(int c, string d)`.
    I don’t think this similarity was a design mistake, but it can take a little getting
    used to just like expression-bodied members looking like lambda expressions.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个使用解构来声明两个变量（`c`和`d`）；第二个是声明一个元组类型的单个变量（`x`），类型为`(int c, string d)`。我认为这种相似性并不是设计错误，但就像表达式成员看起来像lambda表达式一样，这需要一点时间来习惯。
- en: '|  |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s start by looking in more detail at the first two parts of the example,
    where you declare and initialize in one statement.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先更详细地看看示例的前两部分，其中你在一条语句中声明和初始化。
- en: 12.1.1\. Deconstruction to new variables
  id: totrans-506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1\. 解构到新变量
- en: It’s always been feasible to declare multiple variables in a single statement,
    but only if they were of the same type. I’ve typically stuck to a single declaration
    per statement for the sake of readability. But when you can declare and initialize
    multiple variables in a single statement, and the initial values all have the
    same source, that’s neat. In particular, if that source is the result of a function
    call, you can avoid declaring an extra variable just to avoid making multiple
    calls.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 始终可以在一条语句中声明多个变量，但前提是它们必须是同一类型。我通常坚持每条语句一个声明，以保持可读性。但是，当你可以在一条语句中声明和初始化多个变量，并且初始值都来自同一来源时，那就很方便了。特别是，如果这个来源是函数调用，你可以避免声明一个额外的变量来避免多次调用。
- en: The syntax that’s probably simplest to understand is the one in which each variable
    is explicitly typed—the same syntax as for a parameter list or tuple type. To
    clarify my preceding point about the extra variable, the following listing shows
    a tuple as a result of a method call being deconstructed into three new variables.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易理解的语法可能是每个变量都显式类型化的那种——与参数列表或元组类型相同的语法。为了阐明我前面关于额外变量的观点，以下列表显示了方法调用结果解构为三个新变量后的元组。
- en: Listing 12.2\. Calling a method and deconstructing the result into three variables
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.2\. 调用一个方法并将结果解构到三个变量中
- en: '[PRE64]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The benefit isn’t as obvious until you consider the equivalent code without
    using deconstruction. This is what the compiler is transforming the preceding
    code into:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 优点并不那么明显，直到你考虑不使用解构的等效代码。这就是编译器将前面的代码转换成的内容：
- en: '[PRE65]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The three declaration statements don’t bother me too much, although I do appreciate
    the brevity of the original code, but the `tmp` variable really niggles. As its
    name suggests, it’s there only temporarily; its sole purpose is to remember the
    result of the method call so it can be used to initialize the three variables
    you really want: `a`, `b`, and `name`. Even though you want `tmp` only for that
    bit of code, it has the same scope as the other variables, which feels messy to
    me. If you want to use implicit typing for some variables but explicit typing
    for others, that’s fine too, as shown in [figure 12.1](kindle_split_029_split_000.html#ch12fig01).'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个声明语句并没有让我太烦恼，尽管我确实欣赏原始代码的简洁性，但`tmp`变量真的很让人烦恼。正如其名称所暗示的，它只是临时存在的；它的唯一目的是记住方法调用的结果，以便可以用来初始化你真正想要的三个变量：`a`、`b`和`name`。即使你只想在那一小段代码中使用`tmp`，但它与其他变量的作用域相同，这让我感觉有些混乱。如果你想要对某些变量使用隐式类型，而对其他变量使用显式类型，那也是可以的，如[图12.1](kindle_split_029_split_000.html#ch12fig01)所示。
- en: Figure 12.1\. Mixing implicit and explicit typing in deconstruction
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1\. 解构中混合隐式和显式类型
- en: '![](../Images/12fig01_alt.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12fig01_alt.jpg)'
- en: This is particularly useful if you want to specify a different type than the
    element type in the original tuple using an implicit conversion for elements where
    required; see [figure 12.2](kindle_split_029_split_000.html#ch12fig02).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用隐式转换来指定与原始元组元素类型不同的类型，这在需要时特别有用；请参见[图12.2](kindle_split_029_split_000.html#ch12fig02)。
- en: Figure 12.2\. Deconstruction involving implicit conversions
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.2\. 涉及隐式转换的解构
- en: '![](../Images/12fig02_alt.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12fig02_alt.jpg)'
- en: 'If you’re happy to use implicit typing for all the variables, C# 7 has shorthand
    to make it simple; just use `var` before the list of names:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意为所有变量使用隐式类型，C# 7 提供了简写来简化操作；只需在名称列表之前使用 `var`：
- en: '[PRE66]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is equivalent to using `var` for each variable inside the parameter list,
    and that in turn is equivalent to explicitly specifying the inferred type based
    on the type of the value being assigned. Just as with regular implicitly typed
    variable declarations, using `var` doesn’t make your code dynamically typed; it
    just makes the compiler infer the type.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于在参数列表内部为每个变量使用 `var`，而这又等价于根据被分配的值的类型显式指定推断类型。就像常规隐式类型变量声明一样，使用 `var` 并不会使你的代码变为动态类型；它只是让编译器推断类型。
- en: 'Although you can mix and match between implicit typing and explicit typing
    in terms of the types specified within the brackets, you can’t use `var` before
    the variable list and then provide types for some variables:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以在括号内指定的类型方面在隐式类型和显式类型之间混合使用，但你不能在变量列表之前使用 `var` 然后为一些变量提供类型：
- en: '[PRE67]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1* Invalid: mixture of “inside and outside” declarations**'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效：混合“内部和外部”声明**'
- en: 'A special identifier: _ discards'
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个特殊的标识符：_ 被丢弃
- en: 'C# 7 has three features that allow new places to introduce local variables:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 有三个特性允许在新的地方引入局部变量：
- en: Deconstruction (this section and 12.2)
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构（本节和 12.2）
- en: Patterns ([sections 12.3](kindle_split_029_split_000.html#ch12lev1sec3) to [12.7](kindle_split_029_split_000.html#ch12lev1sec7))
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式 ([第 12.3 节](kindle_split_029_split_000.html#ch12lev1sec3) 到 [第 12.7 节](kindle_split_029_split_000.html#ch12lev1sec7))
- en: Out variables ([section 14.2](kindle_split_031_split_000.html#ch14lev1sec2))
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出变量 ([第 14.2 节](kindle_split_031_split_000.html#ch14lev1sec2))
- en: In all these cases, specifying a variable name of `_` (a single underscore)
    has a special meaning. It’s a *discard*, which means “I don’t care about the result.
    I don’t even want it as a variable at all—just get rid of it.” When a discard
    is used, it doesn’t introduce a new variable into scope. You can use multiple
    discards instead of specifying different variable names for multiple variables
    you don’t care about.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，指定变量名为 `_`（单个下划线）具有特殊含义。它是一个 *丢弃*，意味着“我不关心结果。我甚至不希望它作为一个变量——只是去掉它。”当使用丢弃时，它不会引入新的变量到作用域中。你可以使用多个丢弃而不是为多个你不在乎的变量指定不同的变量名。
- en: 'Here’s an example of discards in tuple deconstruction:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在元组解构中使用丢弃的示例：
- en: '[PRE68]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* Tuple with four elements**'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 四个元素的元组**'
- en: '***2* Deconstructs the tuple but keeps only the first two elements**'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 解构元组但只保留前两个元素**'
- en: '***3* Error CS0103: The name ’_’ doesn’t exist in the current context**'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 错误 CS0103：名称 '' _ '' 在当前上下文中不存在**'
- en: If you already have a variable called `_` in scope (declared with a regular
    variable declaration), you can still use discards in deconstruction to an otherwise
    new set of variables, and the existing variable will remain untouched.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个名为 `_` 的变量在作用域内（使用常规变量声明），你仍然可以在解构中使用丢弃来赋值给其他新的变量集，而现有的变量将保持不变。
- en: As you saw in our original overview, you don’t have to declare new variables
    to use deconstruction. Deconstruction can act as a sequence of assignments instead.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在我们的原始概述中看到的那样，你不必声明新变量来使用解构。解构可以作为一个赋值序列来执行。
- en: 12.1.2\. Deconstruction assignments to existing variables and properties
  id: totrans-538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.2\. 解构赋值给现有变量和属性
- en: 'The previous section explained most of our original overview example. In this
    section, we’ll look at this part of the code instead:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节解释了我们的原始概述示例的大部分内容。在本节中，我们将查看代码的这一部分：
- en: '[PRE69]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this case, the compiler isn’t treating the deconstruction as a sequence of
    declarations with corresponding initialization expressions; instead, it’s just
    a sequence of assignments. This has the same benefit in terms of avoiding temporary
    variables that you saw in the previous section. The following listing gives an
    example using the same `MethodReturningTuple()` that you used before.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器并不是将解构视为一系列具有相应初始化表达式的声明，而是一系列赋值。这和之前章节中看到的避免临时变量的好处相同。以下列表提供了一个使用之前使用的相同
    `MethodReturningTuple()` 的示例。
- en: Listing 12.3\. Assignments to existing variables using deconstruction
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. 使用解构赋值给现有变量
- en: '[PRE70]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* Declares, initializes, and uses three variables**'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明、初始化和使用三个变量**'
- en: '***2* Assigns to all three variables using deconstruction**'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用解构赋值给所有三个变量**'
- en: '***3* Displays the new values**'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示新值**'
- en: So far, so good, but the feature doesn’t stop with the ability to assign to
    local variables. Any assignment that would be valid as a separate statement is
    also valid using deconstruction. That can be an assignment to a field, a property,
    or an indexer, including working on arrays and other objects.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，但这个特性不仅仅局限于对局部变量的赋值能力。任何可以作为单独语句有效执行的赋值操作，都可以使用解构来实现。这可以是对字段、属性或索引器的赋值，包括对数组和其它对象的操作。
- en: '|  |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Declarations or assignments: Not a mixture**'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明或赋值：不要混合**'
- en: 'Deconstruction allows you to either declare and initialize variables or execute
    a sequence of assignments. You can’t mix the two. For example, this is invalid:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 解构允许你声明和初始化变量，或者执行一系列赋值。你不能混合使用这两种方式。例如，以下是不合法的：
- en: '[PRE71]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'It’s fine for the assignments to use a variety of targets, however: some existing
    local variables, some fields, some properties, and so on.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值可以使用各种目标，这是可以的：一些现有的局部变量，一些字段，一些属性，等等。
- en: '|  |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In addition to regular assignments, you can assign to a discard (the `_` identifier),
    thereby effectively throwing away the value if there’s nothing called `_` in scope.
    If you do have a variable named `_` in scope, deconstruction assigns to it as
    normal.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规赋值外，你还可以将值赋给一个丢弃（即 `_` 标识符），如果作用域中没有名为 `_` 的变量，这实际上会丢弃该值。如果你在作用域中有一个名为 `_`
    的变量，解构会像平常一样将其赋值。
- en: '|  |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using _ in deconstruction: Assign or discard?**'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**在解构中使用 _：赋值还是丢弃？**'
- en: 'This looks a little confusing at first: sometimes deconstruction to _ when
    there’s an existing variable with that name changes the value, and sometimes it
    discards it. You can avoid this confusion in two ways. The first is to look at
    the rest of the deconstruction to see whether it’s introducing new variables (in
    which case `_` is a discard) or assigning values to existing variables (in which
    case `_` is assigned a new value like the other variables).'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 起初这看起来有点令人困惑：有时当存在同名的现有变量时，将 _ 用于解构会改变其值，有时则会丢弃它。你可以通过两种方式避免这种困惑。第一种是查看解构的其余部分，以确定它是否引入了新的变量（在这种情况下
    `_` 是一个丢弃），或者是否将值赋给现有变量（在这种情况下 `_` 被赋予一个新值，就像其他变量一样）。
- en: The second way to avoid confusion is to not use `_` as a local variable name.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 避免混淆的第二种方法是不要使用 `_` 作为局部变量名。
- en: '|  |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In practice, I expect almost all uses of assignment deconstruction to target
    either local variables or fields and properties of `this`. In fact, there’s a
    neat little technique you can use in constructors that makes the expression-bodied
    constructors introduced in C# 7 even more useful. Many constructors assign values
    to properties or fields based on the constructor parameters. You can perform all
    those assignments in a single expression if you collect the parameters into a
    tuple literal first, as shown in the next listing.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我预计几乎所有的赋值解构都会针对局部变量或 `this` 的字段和属性。事实上，有一种巧妙的小技巧可以在构造函数中使用，这使得C# 7中引入的表达式主体构造函数变得更加有用。许多构造函数根据构造函数参数将值赋给属性或字段。如果你首先将参数收集到一个元组字面量中，就可以在一个表达式中完成所有这些赋值，如下一列表所示。
- en: Listing 12.4\. Simple constructor assignments using deconstruction and a tuple
    literal
  id: totrans-561
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.4\. 使用解构和元组字面量进行简单的构造函数赋值
- en: '[PRE72]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: I really like the brevity of this. I love the clarity of the mapping from constructor
    parameter to property. The C# compiler even recognizes it as a pattern and avoids
    constructing a `ValueTuple<double, double>`. Unfortunately, it still requires
    a dependency on `System.ValueTuple.dll` to build, which is enough to put me off
    using it unless I’m also using tuples somewhere else in the project or targeting
    a framework that already includes `System.ValueTuple`.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢这种简洁性。我喜欢从构造函数参数到属性的映射的清晰性。C# 编译器甚至将其识别为一种模式，并避免构造 `ValueTuple<double,
    double>`。不幸的是，它仍然需要依赖 `System.ValueTuple.dll` 来构建，这足以让我在项目其他地方也使用元组或目标框架已经包含 `System.ValueTuple`
    的情况下才使用它。
- en: '|  |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Is this idiomatic C#?**'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是不是地道的C#语法？**'
- en: As I’ve described, this trick has pros and cons. It’s a pure implementation
    detail of the constructor; it doesn’t even affect the rest of the class body.
    If you decide to embrace this style and then decide you don’t like it, removing
    it should be trivial. It’s too early to say whether this will catch on, but I
    hope so. I’d be wary as soon as the tuple literal needs to be more than just the
    exact parameter values, though. Even adding a single precondition tips the balance
    in favor of a regular sequence of assignments, in my subjective opinion.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我描述的，这个技巧有优点也有缺点。这是构造函数的纯实现细节；它甚至不影响类的其余部分。如果你决定接受这种风格，然后又决定不喜欢它，移除它应该是微不足道的。现在还太早说这会不会流行起来，但我希望如此。不过，一旦元组字面量需要不仅仅是精确的参数值，我就要小心了。即使添加一个前置条件，在我看来，也会使常规的赋值序列更有优势。
- en: '|  |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Assignment deconstruction has an extra wrinkle compared with declaration deconstruction
    in terms of ordering. Deconstruction that uses assignment has three distinct stages:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 与声明解构相比，赋值解构在排序方面有一个额外的复杂性。使用赋值的解构有三个不同的阶段：
- en: Evaluating the targets of the assignments
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估赋值的目标
- en: Evaluating the right-hand side of the assignment operator
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估赋值运算符右侧的表达式
- en: Performing the assignments
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行赋值操作
- en: Those three stages are performed in exactly that order. Within each stage, evaluation
    occurs in left-to-right source order, as normal. It’s rare that this can make
    a difference, but it’s possible.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个阶段将严格按照这个顺序执行。在每个阶段内，评估按照正常的从左到右的源顺序进行。这种情况很少能产生影响，但有可能。
- en: '|  |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have to worry about this section in order to understand code in front
    of you, that’s a strong code smell. When you *do* understand it, I urge you to
    refactor it. Deconstruction has all the same caveats of using side effects within
    an expression but amplified because you have multiple evaluations to perform in
    each stage.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须担心这个部分才能理解你面前的代码，那是一个强烈的代码气味。当你 *确实* 理解它时，我强烈建议你重构它。解构具有在表达式内部使用副作用的所有相同注意事项，但由于你需要在每个阶段执行多个评估，所以这些注意事项被放大了。
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: I’m not going to linger on this topic for long; a single example is enough to
    show the kind of problem you might see. This is by no means the worst example
    you might find, however. There are all kinds of things you could do in order to
    make this more convoluted. The following listing deconstructs a `(StringBuilder,
    int)` tuple into an existing `StringBuilder` variable and the `Length` property
    associated with that variable.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这个问题上停留太久；一个例子就足以展示你可能会遇到的问题。但这绝对不是你可能会找到的最糟糕的例子。你可以做很多事来使这个问题更加复杂。下面的列表将一个
    `(StringBuilder, int)` 元组解构到一个现有的 `StringBuilder` 变量和与该变量关联的 `Length` 属性。
- en: Listing 12.5\. Deconstruction in which evaluation order matters
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.5\. 评估顺序重要的解构
- en: '[PRE73]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1* Keeps a reference to original builder for diagnostic reasons**'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为了诊断原因保留原始 builder 的引用**'
- en: '***2* Performs the deconstruction assignments**'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 执行解构赋值**'
- en: '***3* Displays the contents of the old and new builders**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示旧的和新的 builder 的内容**'
- en: 'The middle line is the tricky one here. The key question to consider is which
    `StringBuilder` has its `Length` property set: the one that `builder` refers to
    originally or the new value assigned in the first part of the deconstruction?
    As I described earlier, all the targets for the assignments are evaluated first,
    before any assignments are performed. The following listing demonstrates this
    in a sort of exploded version of the same code in which the deconstruction is
    performed manually.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的中间行是有点棘手的。需要考虑的关键问题是哪个 `StringBuilder` 的 `Length` 属性被设置：是 `builder` 原先引用的那个，还是解构第一部分中分配的新值？正如我之前描述的，所有赋值的靶点都会先被评估，然后再执行任何赋值操作。下面的列表以某种爆炸版本的形式展示了相同的代码，其中手动执行了解构操作。
- en: Listing 12.6\. Slow-motion deconstruction to show evaluation order
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.6\. 缓慢动作解构以显示评估顺序
- en: '[PRE74]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* Evaluates assignment targets**'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 评估赋值目标**'
- en: '***2* Evaluates the tuple literal**'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 评估元组字面量**'
- en: '***3* Performs the assignments on the targets**'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在目标上执行赋值操作**'
- en: No extra evaluation is required when the target is just a local variable; you
    can assign directly to it. But assigning to a property of a variable requires
    evaluating that variable value as part of the first phase; that’s why you have
    the `targetForLength` variable.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标是局部变量时，不需要额外的评估；你可以直接将其赋值。但是，将属性赋给变量需要将变量值作为第一阶段的组成部分进行评估；这就是为什么你有`targetForLength`变量。
- en: 'After the tuple has been constructed from the literal, you can assign the different
    items to your targets, making sure you use `targetForLength` rather than builder
    when assigning the `Length` property. The Length property is set on the original
    `StringBuilder` with content 12345 rather than the new one with content 67890\.
    That means the output of [listings 12.5](kindle_split_029_split_000.html#ch12ex05)
    and [12.6](kindle_split_029_split_000.html#ch12ex06) is as follows:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在从字面量构造元组之后，你可以将不同的项赋值给你的目标，确保在赋值`Length`属性时使用`targetForLength`而不是builder。`Length`属性是在内容为12345的原始`StringBuilder`上设置的，而不是内容为67890的新一个。这意味着[列表12.5](kindle_split_029_split_000.html#ch12ex05)和[12.6](kindle_split_029_split_000.html#ch12ex06)的输出如下：
- en: '[PRE75]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: With that out of the way, there’s one final—and rather more pleasant—wrinkle
    of tuple construction to talk about before moving on to nontuple deconstruction.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完这些之后，在继续讨论非元组解构之前，还有最后一个——相当令人愉快——的元组构造细节需要讨论。
- en: 12.1.3\. Details of tuple literal deconstruction
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.3. 元组字面量解构的细节
- en: As I described in [section 11.3.1](kindle_split_028_split_000.html#ch11lev2sec4),
    not all tuple literals have a type. For example, the tuple literal `(null, x =>
    x * 2)` doesn’t have a type because neither of its element expressions has a type.
    But you know it can be converted to type `(string, Func<int, int>)` because each
    expression has a conversion to the corresponding type.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在[第11.3.1节](kindle_split_028_split_000.html#ch11lev2sec4)中所述，并非所有元组字面量都有类型。例如，元组字面量`(null,
    x => x * 2)`没有类型，因为它的元素表达式都没有类型。但你知道它可以转换为类型`(string, Func<int, int>)`，因为每个表达式都有一个转换为对应类型的转换。
- en: 'The good news is that tuple deconstruction has exactly the same sort of “per
    element assignment compatibility” as well. This works for both declaration deconstructions
    and assignment deconstructions. Here’s a brief example:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是元组解构正好具有与声明解构和赋值解构相同的“按元素赋值兼容性”。这适用于声明解构和赋值解构。以下是一个简短的例子：
- en: '[PRE76]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Deconstruction declaring text and func**'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明解构文本和func**'
- en: '***2* Deconstruction assigning to text and func**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将解构赋值给文本和func**'
- en: 'This also works with deconstruction that requires an implicit conversion from
    an expression to the target type. For example, using our favorite “`int` constant
    within range of `byte`” example, the following is valid:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于需要从表达式到目标类型的隐式转换的解构。例如，使用我们最喜欢的“`int`常量在`byte`范围内”的例子，以下是有效的：
- en: '[PRE77]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Like many good language features, this is probably something you might have
    implicitly expected, but the language needs to be carefully designed and specified
    to allow it. Now that you’ve looked at tuple deconstruction fairly extensively,
    deconstruction of nontuples is relatively straightforward.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多优秀的语言特性一样，这可能是你可能隐含期望的，但语言需要精心设计和指定才能允许它。现在你已经相当广泛地研究了元组解构，非元组解构相对简单。
- en: 12.2\. Deconstruction of nontuple types
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2. 非元组类型的解构
- en: Deconstruction for nontuple types uses a pattern-based^([[1](kindle_split_029_split_000.html#ch12fn1)])
    approach in the same way async/await does and `foreach` can. Just as any type
    with a suitable `GetAwaiter` method or extension method can be awaited, any type
    with a suitable `Deconstruct` method or extension method can be deconstructed
    using the same syntax as tuples. Let’s start with deconstruction using regular
    instance methods.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 非元组类型的解构使用与async/await和`foreach`相同的方式基于模式的策略。就像任何具有合适的`GetAwaiter`方法或扩展方法的类型都可以被等待一样，任何具有合适的`Deconstruct`方法或扩展方法的类型都可以使用与元组相同的语法进行解构。让我们从使用常规实例方法进行解构开始。
- en: ¹
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is entirely distinct from the patterns coming up in [section 12.3](kindle_split_029_split_000.html#ch12lev1sec3).
    Apologies for the terminology collision.
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这与[第12.3节](kindle_split_029_split_000.html#ch12lev1sec3)中出现的模式完全不同。对于术语冲突，我表示歉意。
- en: 12.2.1\. Instance deconstruction methods
  id: totrans-607
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1. 实例解构方法
- en: 'It’s simplest to demonstrate deconstruction with the `Point` class used in
    several examples now. You can add a `Deconstruct` method to it like this:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现在在多个示例中使用的`Point`类来演示解构是最简单的。你可以像这样向它添加一个`Deconstruct`方法：
- en: '[PRE78]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Then you can deconstruct any `Point` to two double variables as in the following
    listing.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以像以下列表中那样将任何 `Point` 解构为两个 `double` 变量。
- en: Listing 12.7\. Deconstructing a `Point` to two variables
  id: totrans-611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.7\. 将 `Point` 解构为两个变量
- en: '[PRE79]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1* Constructs an instance of point**'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 构造点实例**'
- en: '***2* Deconstructs it to two variables of type double**'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将其解构为两个 `double` 类型的变量**'
- en: '***3* Displays the two variable values**'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显示两个变量的值**'
- en: The `Deconstruct` method’s job is to populate the `out` parameters with the
    result of the deconstruction. In this case, you’re just deconstructing to two
    `double` values. It’s like a constructor in reverse, as the name suggests.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deconstruct` 方法的任务是使用解构的结果填充 `out` 参数。在这种情况下，你只是将解构为两个 `double` 值。正如其名称所暗示的，就像一个构造函数的反向操作。'
- en: 'But wait; you used a neat trick with tuples to assign parameter values to properties
    in the constructor in a single statement. Can you do that here? Yes, you can,
    and personally, I love it. Here are both the constructor and the `Deconstruct`
    method so you can see the similarities:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等；你使用了一个巧妙的技巧，用元组在构造函数中一次性将参数值赋给属性。你能在这里做到吗？是的，你可以，而且我个人非常喜欢它。以下是构造函数和 `Deconstruct`
    方法，以便你可以看到它们的相似之处：
- en: '[PRE80]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The simplicity of this is beautiful, at least after you’ve gotten used to it.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单性很美，至少在你习惯了之后。
- en: 'The rules of `Deconstruct` instance methods used for deconstruction are pretty
    simple:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解构的 `Deconstruct` 实例方法的规则相当简单：
- en: The method must be accessible to the code doing the deconstruction. (For example,
    if everything is in the same assembly, it’s fine for `Deconstruct` to be an internal
    method.)
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法必须对执行解构的代码是可访问的。（例如，如果所有内容都在同一个程序集内，`Deconstruct` 是一个内部方法就很好。）
- en: It must be a `void` method.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是一个 `void` 方法。
- en: There must be at least two parameters. (You can’t deconstruct to a single value.)
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须至少有两个参数。（你不能解构为单个值。）
- en: It must be nongeneric.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是非泛型的。
- en: You may be wondering why the design uses `out` parameters instead of requiring
    that `Deconstruct` is parameterless but has a tuple return type. The answer is
    that it’s useful to be able to deconstruct to multiple sets of values, which is
    feasible with multiple methods, but you can’t overload methods just on return
    type. To make this clearer, I’ll use an example deconstructing `DateTime`, but
    of course, you can’t add your own instance methods to `DateTime`. It’s time to
    introduce extension deconstruction methods.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么设计使用 `out` 参数而不是要求 `Deconstruct` 无参数但有元组返回类型。答案是，能够解构到多组值是有用的，这可以通过多个方法实现，但你不能仅基于返回类型来重载方法。为了使这一点更清晰，我将使用一个解构
    `DateTime` 的例子，但当然，你不能向 `DateTime` 添加你自己的实例方法。是时候介绍扩展解构方法了。
- en: 12.2.2\. Extension deconstruction methods and overloading
  id: totrans-626
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2\. 扩展解构方法和重载
- en: As I briefly stated in the introduction, the compiler finds any `Deconstruct`
    methods that follow the relevant pattern, including extension methods. You can
    probably imagine what an extension method for deconstruction looks like, but the
    following listing gives a concrete example, using `DateTime`.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在介绍中简要提到的，编译器会找到任何遵循相关模式的 `Deconstruct` 方法，包括扩展方法。你可能可以想象解构扩展方法的样子，但以下列表提供了一个具体的例子，使用了
    `DateTime`。
- en: Listing 12.8\. Using an extension method to deconstruct `DateTime`
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.8\. 使用扩展方法解构 `DateTime`
- en: '[PRE81]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* Extension method to deconstruct DateTime**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 扩展方法用于解构 `DateTime**`'
- en: '***2* Deconstructs the current date to year/month/day**'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将当前日期解构为年/月/日**'
- en: '***3* Displays the date using the three variables**'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用三个变量显示日期**'
- en: As it happens, this is a private extension method declared in the same (static)
    class that you’re using it from, but it’d more commonly be public or internal,
    just like most extension methods are.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这是一个在同一个（静态）类中声明的私有扩展方法，你从那里使用它，但更常见的是它是公共或内部的，就像大多数扩展方法一样。
- en: What if you want to deconstruct a `DateTime` to more than just a date? This
    is where overloading is useful. You can have two methods with different parameter
    lists, and the compiler will work out which to use based on the number of parameters.
    Let’s add another extension method to deconstruct a `DateTime` in terms of time
    as well as date and then use both our methods to deconstruct different values.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将 `DateTime` 解构为不仅仅是日期呢？这正是重载有用的地方。你可以有两个具有不同参数列表的方法，编译器将根据参数数量确定使用哪个。让我们添加另一个扩展方法，以日期和时间的形式解构
    `DateTime`，然后使用这两个方法解构不同的值。
- en: Listing 12.9\. Using `Deconstruct` overloads
  id: totrans-635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.9\. 使用 `Deconstruct` 重载
- en: '[PRE82]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* Deconstructs a date to year/month/day**'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将日期解构为年/月/日**'
- en: '***2* Deconstructs a date to year/month/day/hour/minute/second**'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将日期解构为年/月/日/小时/分钟/秒**'
- en: '***3* Uses the six-value deconstructor**'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用六值解构器**'
- en: '***4* Uses the three-value deconstructor**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用三值解构器**'
- en: You can use extension `Deconstruct` methods for types that already have instance
    `Deconstruct` methods, and they’ll be used if the instance methods aren’t applicable
    when deconstructing, just as for normal method calls.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用扩展 `Deconstruct` 方法为已经具有实例 `Deconstruct` 方法的类型，如果实例方法在解构时不适用，它们将被使用，就像在正常方法调用中一样。
- en: 'The restrictions for an extension `Deconstruct` method follow naturally from
    those of an instance method:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `Deconstruct` 方法的限制自然地来源于实例方法的限制：
- en: It has to be accessible to the calling code.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须对调用代码是可访问的。
- en: Other than the first parameter (the target of the extension method), all parameters
    must be `out` parameters.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了第一个参数（扩展方法的调用目标）之外，所有参数都必须是 `out` 参数。
- en: There must be at least two such `out` parameters.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少必须有两个这样的 `out` 参数。
- en: The method may be generic, but only the receiver of the call (the first parameter)
    can participate in type inference.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可能是泛型的，但只有调用接收者（第一个参数）可以参与类型推断。
- en: The rules indicating when a method can and can’t be generic deserve closer scrutiny,
    particularly because they also shed light on why you need to use a different number
    of parameters when overloading `Deconstruct`. The key lies in how the compiler
    treats the `Deconstruct` method.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 指示方法何时可以是泛型或不能是泛型的规则值得更仔细的审查，尤其是因为它们还揭示了为什么在重载 `Deconstruct` 时需要使用不同数量的参数。关键在于编译器如何处理
    `Deconstruct` 方法。
- en: 12.2.3\. Compiler handling of Deconstruct calls
  id: totrans-648
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.3\. 编译器对解构调用的处理
- en: When everything’s working as expected, you can get away without thinking too
    much about how the compiler decides which `Deconstruct` method to use. If you
    run into problems, however, it can be useful to try to put yourself in the place
    of the compiler.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切按预期工作的时候，你可以不必过多地思考编译器是如何决定使用哪个 `Deconstruct` 方法的。然而，如果你遇到问题，尝试将自己置于编译器的位置可能会有所帮助。
- en: 'The timing you’ve already seen for tuple decomposition still applies when deconstructing
    with methods, so I’ll focus on the method call itself. Let’s take a somewhat concrete
    example, working out what the compiler does when faced with a deconstruction like
    this:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用方法进行解构时，元组分解的时机仍然适用，因此我将专注于方法调用本身。让我们来看一个相对具体的例子，看看编译器在遇到这种解构时会如何处理：
- en: '[PRE83]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'I say this is a *somewhat* concrete example because I haven’t shown what the
    type of `target` is. That’s deliberate, because all you need to know is that it
    isn’t a tuple type. The compiler expands this into something like this:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我说这是一个 *相对* 具体的例子，因为我没有展示 `target` 的类型。这是故意的，因为你所需要知道的是它不是一个元组类型。编译器将其扩展为类似以下的内容：
- en: '[PRE84]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: It then uses all the normal rules of method invocation to try to find the right
    method to call. I realize that the use of `out var` is something you haven’t seen
    before. You’ll look at it more closely in [section 14.2](kindle_split_031_split_000.html#ch14lev1sec2),
    but all you need to know for now is that it’s declaring an implicitly typed variable
    using the type of the `out` parameter to infer the type.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它使用所有正常的方法调用规则来尝试找到要调用的正确方法。我意识到 `out var` 的使用是你之前没有见过的。你将在 [第 14.2 节](kindle_split_031_split_000.html#ch14lev1sec2)
    中更详细地了解它，但你现在需要知道的是，它使用 `out` 参数的类型来推断隐式类型的变量。
- en: 'The important thing to notice is that the types of the variables you’ve declared
    in the original code aren’t used as part of the `Deconstruct` call. That means
    they can’t participate in type inference. This explains three things:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，你在原始代码中声明的变量的类型并不作为 `Deconstruct` 调用的一部分使用。这意味着它们不能参与类型推断。这解释了三件事：
- en: Instance `Deconstruct` methods can’t be generic, because there’s no information
    for type inference to use.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例 `Deconstruct` 方法不能是泛型的，因为没有信息供类型推断使用。
- en: Extension `Deconstruct` methods can be generic, because the compiler may be
    able to infer type arguments using `target`, but that’s the only parameter that’s
    going to be useful in terms of type inference.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 `Deconstruct` 方法可以是泛型的，因为编译器可能能够使用 `target` 推断类型参数，但那将是唯一有用的参数，从类型推断的角度来看。
- en: When overloading `Deconstruct` methods, it’s the number of `out` parameters
    that’s important, not their type. If you introduce multiple `Deconstruct` methods
    with the same number of `out` parameters, that’s just going to stop the compiler
    from using any of them, because the calling code won’t be able to tell which one
    you mean.
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当重载`Deconstruct`方法时，重要的是`out`参数的数量，而不是它们的类型。如果你引入多个具有相同数量`out`参数的`Deconstruct`方法，这将会阻止编译器使用任何一个，因为调用代码将无法确定你指的是哪一个。
- en: I’ll leave it at that, because I don’t want to make more of this than needed.
    If you run into problems that you can’t understand, try performing the transformation
    shown previously, and it may well make things clearer.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 我就说到这里，因为我不想做得比必要的更多。如果你遇到无法理解的问题，尝试执行之前展示的转换，这可能会使事情更加清晰。
- en: That’s everything you need to know about deconstruction. The rest of the chapter
    focuses on pattern matching, a feature that’s theoretically entirely separate
    from deconstruction but has a similar feeling to it in terms of the tools available
    for using existing data in new ways.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要了解的所有关于解构的内容。本章的其余部分专注于模式匹配，这是一个理论上完全独立于解构的功能，但在可用工具方面与解构有相似的感觉，这些工具可以用于以新的方式使用现有数据。
- en: 12.3\. Introduction to pattern matching
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3\. 模式匹配简介
- en: Like many other features, pattern matching is new to C# but not new to programming
    languages in general. In particular, functional languages often make heavy use
    of patterns. The patterns in C# 7.0 satisfy many of the same use cases but in
    a manner that fits in with the rest of the syntax of the language.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多其他特性一样，模式匹配对于C#来说是新的，但对于编程语言总体来说并不是新的。特别是，函数式语言通常大量使用模式。C# 7.0中的模式满足了许多相同的用例，但以一种与语言其余语法相匹配的方式。
- en: The basic idea of a pattern is to test a certain aspect of a value and use the
    result of that test to perform another action. Yes, that sounds just like an `if`
    statement, but patterns are typically used either to give more context for the
    condition or to provide more context within the action itself based on the pattern.
    Yet again, this feature doesn’t allow you to do anything you couldn’t do before;
    it just lets you express the same intention more clearly.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的基本思想是测试一个值的某个方面，并使用该测试的结果执行另一个操作。是的，这听起来就像一个`if`语句，但模式通常用于提供更多上下文，或者根据模式在动作本身中提供更多上下文。再次强调，这个特性并不允许你做之前不能做的事情；它只是让你更清晰地表达相同的目的。
- en: I don’t want to go too far without giving an example. Don’t worry if it seems
    a little odd right now; the aim is to give you a flavor. Suppose you have an abstract
    class `Shape` that defines an abstract `Area` property and derived classes `Rectangle`,
    `Circle`, and `Triangle`. Unfortunately, for your current application, you don’t
    need the area of a shape; you need its perimeter. You may not be able to modify
    `Shape` to add a `Perimeter` property (you may not have any control over its source
    at all), but you know how to compute it for all the classes you’re interested
    in. Before C# 7, a `Perimeter` method might look something like the following
    listing.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想在没有给出例子的情况下走得太远。如果你现在觉得它有点奇怪，不用担心；目的是给你一个感觉。假设你有一个定义了抽象`Area`属性和派生类`Rectangle`、`Circle`和`Triangle`的抽象类`Shape`。不幸的是，对于你当前的应用程序，你不需要形状的面积；你需要它的周长。你可能无法修改`Shape`来添加`Perimeter`属性（你可能根本无法控制其源代码），但你知道如何计算你感兴趣的类中的周长。在C#
    7之前，一个`Perimeter`方法可能看起来像以下列表。
- en: Listing 12.10\. Computing a perimeter without patterns
  id: totrans-665
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.10\. 不使用模式计算周长
- en: '[PRE85]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '|  |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If the lack of curly braces inside offends you, I apologize. I normally use
    them for all loops, if statements, and so forth, but in this case, they ended
    up dwarfing the useful code here and in some other later pattern examples. I’ve
    removed them for brevity.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内部缺少花括号让你感到不适，我为此道歉。我通常会在所有循环、if语句等地方使用它们，但在这个例子中，它们最终使有用的代码在这里以及一些后续的模式示例显得微不足道。为了简洁，我已经将它们移除了。
- en: '|  |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That’s ugly. It’s repetitive and long-winded; the same pattern of “check whether
    the shape is a particular type, and then use that type’s properties” occurs three
    times. Urgh. Importantly, even though there are multiple `if` statements here,
    the body of each of them returns a value, so you’re always picking only one of
    them to execute. The following listing shows how the same code can be written
    in C# 7 using patterns in a `switch` statement.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很糟糕。它重复且冗长；相同的模式“检查形状是否是特定类型，然后使用该类型的属性”出现了三次。呃。重要的是，尽管这里有几个 `if` 语句，但每个语句的主体都返回一个值，所以你总是只选择其中一个来执行。以下列表显示了如何使用
    C# 7 中的模式在 `switch` 语句中编写相同的代码。
- en: Listing 12.11\. Computing a perimeter with patterns
  id: totrans-672
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.11\. 使用模式计算周长
- en: '[PRE86]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* Handles a null value**'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 处理空值**'
- en: '***2* Handles each type you know about**'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 处理您所知道的每种类型**'
- en: '***3* If you don’t know what to do, throw an exception.**'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果不知道该做什么，就抛出一个异常。**'
- en: This is quite a departure from the `switch` statement from previous versions
    of C#, in which case labels were all just constant values. Here you’re sometimes
    interested in just value matching (for the `null` case) and sometimes interested
    in the type of the value (the rectangle, circle, and triangle cases). When you
    match by type, that match also introduces a new variable of that type that you
    use to calculate the perimeter.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 C# 早期版本中的 `switch` 语句有很大的不同，在早期版本中，case 标签都是常量值。在这里，你有时只对值匹配（对于 `null` 的情况）感兴趣，有时对值的类型（矩形、圆形和三角形的情况）感兴趣。当你按类型匹配时，这个匹配也会引入一个新的变量，你可以使用这个变量来计算周长。
- en: 'The topic of patterns within C# has two distinct aspects:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中模式的话题有两个不同的方面：
- en: The syntax for patterns
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式的语法
- en: The contexts in which you can use patterns
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用模式的环境
- en: 'At first, it may feel like everything’s new, and differentiating between these
    two aspects may seem pointless. But the patterns you can use in C# 7.0 are just
    the start: the C# design team has been clear that the syntax has been designed
    for new patterns to become available over time. When you know the places in the
    language where patterns are allowed, you can pick up new patterns easily. It’s
    a little bit chicken and egg—it’s hard to demonstrate one part without showing
    the other—but we’ll start by looking at the kinds of patterns available in C#
    7.0.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，可能会觉得一切都是新的，区分这两个方面可能似乎没有意义。但 C# 7.0 中可用的模式只是开始：C# 设计团队已经明确表示，语法已经被设计为随着时间的推移使新的模式可用。当你知道语言中允许模式的位置时，你可以轻松地掌握新的模式。这有点像鸡生蛋的问题——很难在不展示另一个的情况下展示一个部分——但我们将从查看
    C# 7.0 中可用的模式类型开始。
- en: 12.4\. Patterns available in C# 7.0
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4\. C# 7.0 中可用的模式
- en: 'C# 7.0 introduces three kinds of patterns: constant patterns, type patterns,
    and the `var` pattern. I’m going to demonstrate each with the `is` operator, which
    is one of the contexts for using patterns.'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0 引入了三种类型的模式：常量模式、类型模式和 `var` 模式。我将通过 `is` 操作符来演示每种模式，`is` 操作符是使用模式的一个上下文。
- en: Every pattern tries to match an input. This can be any nonpointer expression.
    For the sake of simplicity, I’ll refer to this as `input` in the pattern descriptions,
    as if it were a variable, but it doesn’t have to be.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模式都试图匹配一个输入。这可以是任何非指针表达式。为了简单起见，我在模式描述中将其称为 `input`，就像它是一个变量一样，但它不必是。
- en: 12.4.1\. Constant patterns
  id: totrans-685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1\. 常量模式
- en: 'A *consta**nt pattern* is just what it sounds like: the pattern consists entirely
    of a compile-time constant expression, which is then checked for equality with
    `input`. If both `input` and the constant are integer expressions, they’re compared
    using `==`. Otherwise, the static `object.Equals` method is called. It’s important
    that it’s the static method that’s called, because that enables you to safely
    check for a null value. The following listing shows an example that serves even
    less real-world purpose than most of the other examples in the book, but it does
    demonstrate a couple of interesting points.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *常量模式* 正如其名：该模式完全由编译时常量表达式组成，然后检查它与 `input` 是否相等。如果 `input` 和常量都是整数表达式，它们将使用
    `==` 进行比较。否则，将调用静态的 `object.Equals` 方法。重要的是调用的是静态方法，因为这使你可以安全地检查空值。以下列表显示了一个示例，它甚至比书中大多数其他示例的实际用途还要少，但它确实演示了几个有趣的观点。
- en: Listing 12.12\. Simple constant matches
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.12\. 简单常量匹配
- en: '[PRE87]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output is mostly straightforward, but you may be surprised by the penultimate
    line:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 输出大部分都很直接，但你可能会对倒数第二行感到惊讶：
- en: '[PRE88]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If integers are compared using `==`, why didn’t the last call of `Match(10L)`
    match? The answer is that the compile-time type of `input` isn’t an integral type,
    it’s just `object`, so the compiler generates code equivalent to calling `object.Equals(x,
    10)`. That returns `false` when the value of `x` is a boxed `Int64` instead of
    a boxed `Int32`, as is the case in our last call to `Match`. For an example using
    `==`, you’d need something like this:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `==` 比较整数，为什么最后的 `Match(10L)` 调用没有匹配成功？答案是 `input` 的编译时类型不是一个整型，它只是 `object`，因此编译器生成的代码相当于调用
    `object.Equals(x, 10)`。当 `x` 的值是一个装箱的 `Int64` 而不是一个装箱的 `Int32` 时，它会返回 `false`，正如我们在最后的
    `Match` 调用中所遇到的情况。要使用 `==` 的例子，你需要像这样：
- en: '[PRE89]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This isn’t useful in `is` expressions like this; it’d be more likely to be used
    in `switch`, where you might have some integer constants (like a pre-pattern-matching
    `switch` statement) along with other patterns. A more obviously useful kind of
    pattern is the type pattern.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的`is`表达式中，这并不实用；它更可能用于`switch`，其中你可能有一些整数常量（比如一个预模式匹配的`switch`语句）以及其他模式。一种更明显有用的模式类型是类型模式。
- en: 12.4.2\. Type patterns
  id: totrans-694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2\. 类型模式
- en: A *type pattern* consists of a type and an identifier—a bit like a variable
    declaration. The pattern matches if `input` is a value of that type, just like
    the regular `is` operator. The benefit of using a pattern for this is that it
    also introduces a new *pattern variable* of that type initialized with the value
    if the pattern matches. If the pattern doesn’t match, the variable still exists;
    it’s just not definitely assigned. If `input` is null, it won’t match any type.
    As described in [section 12.1.1](kindle_split_029_split_000.html#ch12lev2sec1),
    the underscore identifier `_` can be used, in which case it’s a *discard* and
    no variable is introduced. The following listing is a conversion of our earlier
    set of `as`-followed-by-`if` statements ([listing 12.10](kindle_split_029_split_000.html#ch12ex10))
    to use pattern matching without taking the more extreme step of using a `switch`
    statement.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *类型模式* 由一个类型和一个标识符组成——有点像变量声明。如果 `input` 是该类型的值，则模式匹配，就像常规的 `is` 操作符一样。使用模式的好处是，它还引入了一个新的
    *模式变量*，该变量以匹配的值初始化。如果模式不匹配，变量仍然存在；它只是没有被明确赋值。如果 `input` 为空，则不会匹配任何类型。如 [12.1.1
    节](kindle_split_029_split_000.html#ch12lev2sec1) 所述，可以使用下划线标识符 `_`，在这种情况下，它是一个
    *丢弃*，不会引入任何变量。以下列表是将我们之前的一组 `as` 后跟 `if` 语句 ([列表 12.10](kindle_split_029_split_000.html#ch12ex10))
    转换为使用模式匹配，而不采取使用 `switch` 语句的更极端步骤。
- en: Listing 12.13\. Using type patterns instead of `as/if`
  id: totrans-696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.13\. 使用类型模式代替 `as/if`
- en: '[PRE90]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In this case, I definitely prefer the `switch` statement option instead, but
    that would be overkill if you had only one `as`/`if` to replace. A type pattern
    is generally used to replace either an `as`/`if` combination or `if` with `is`
    followed by a cast. The latter is required when the type you’re testing is a non-nullable
    value type.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我确实更喜欢 `switch` 语句选项，但如果只有一个 `as`/`if` 需要替换，那就太过分了。类型模式通常用于替换一个 `as`/`if`
    组合或 `if` 后跟一个类型转换。后者在你要测试的类型是非可空值类型时是必需的。
- en: The type specified in a type pattern can’t be a nullable value type, but it
    can be a type parameter, and that type parameter may end up being a nullable value
    type at execution time. In that case, the pattern will match only when the value
    is non-null. The following listing shows this using `int?` as a type argument
    for a method that uses the type parameter in a type pattern, even though the expression
    `value is int? t` wouldn’t have compiled.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 类型模式中指定的类型不能是可空值类型，但它可以是类型参数，并且该类型参数在执行时最终可能成为可空值类型。在这种情况下，只有当值非空时，模式才会匹配。以下列表展示了这一点，使用
    `int?` 作为使用类型参数的类型模式的方法的类型参数，即使表达式 `value is int? t` 不会编译。
- en: Listing 12.14\. Behavior of nullable value types in type patterns
  id: totrans-700
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.14\. 类型模式中可空值类型的行为
- en: '[PRE91]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output is as follows:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE92]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: To wrap up this section on type patterns, there’s one issue in C# 7.0 that’s
    addressed by C# 7.1\. It’s one of those cases where if your project is already
    set to use C# 7.1 or higher, you may not even notice. I’ve included this mostly
    so that you don’t get confused if you copy code from a C# 7.1 project to a C#
    7.0 project and find it breaks.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节关于类型模式的内容，C# 7.0 中有一个问题在 C# 7.1 中得到了解决。这是那些如果你已经将项目设置为使用 C# 7.1 或更高版本，你可能甚至都没有注意到的情况之一。我包括这个主要是为了避免你从
    C# 7.1 项目复制代码到 C# 7.0 项目时发现它无法工作而感到困惑。
- en: In C# 7.0, type patterns like this
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7.0 中，像这样的类型模式
- en: '[PRE93]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: required that the compile-time type of `x` could be cast to `SomeType`. That
    sounds entirely reasonable until you start using generics. Consider the following
    generic method that displays details of the shapes provided using pattern matching.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 需要 `x` 的编译时类型可以被转换为 `SomeType`。这听起来完全合理，直到你开始使用泛型。考虑以下使用模式匹配显示提供的形状详细信息的泛型方法。
- en: Listing 12.15\. Generic method using type patterns
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.15\. 使用类型模式的泛型方法
- en: '[PRE94]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1* Variable type is a type parameter (T)**'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 变量类型是类型参数 (T)**'
- en: '***2* Switches on that variable**'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在该变量上切换**'
- en: '***3* Tries to use type case to convert to concrete shape type**'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 尝试使用类型匹配转换为具体形状类型**'
- en: 'In C# 7.0, this listing won’t compile, because this wouldn’t compile either:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7.0 中，这个列表无法编译，因为以下代码也无法编译：
- en: '[PRE95]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The use of the `is` operator is valid, but the cast isn’t. The inability to
    cast type parameters directly has been an annoyance for a long time in C#, with
    the usual workaround being to first cast to `object`:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `is` 操作符是有效的，但转换不是。在 C# 中直接转换类型参数的能力一直是一个烦恼，通常的解决方案是首先将其转换为 `object`：
- en: '[PRE96]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This is clumsy enough in a normal cast, but it’s worse when you’re trying to
    use an elegant type pattern.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常的转换中，这已经足够笨拙，但在尝试使用优雅的类型模式时，情况更糟。
- en: In [listing 12.15](kindle_split_029_split_000.html#ch12ex15), this can be worked
    around by either accepting an `IEnumerable<Shape>` (taking advantage of generic
    covariance to allow a conversion of `List<Circle>` to `IEnumerable<Shape>`, for
    example) or by specifying the type of `shape` as `Shape` instead of `T`. In other
    cases, the workarounds aren’t as simple. C# 7.1 addresses this by permitting a
    type pattern for any type that would be valid using the `as` operator, which makes
    [listing 12.15](kindle_split_029_split_000.html#ch12ex15) valid.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 12.15](kindle_split_029_split_000.html#ch12ex15)中，可以通过接受 `IEnumerable<Shape>`（利用泛型协变允许将
    `List<Circle>` 转换为 `IEnumerable<Shape>`，例如）或指定 `shape` 的类型为 `Shape` 而不是 `T` 来解决这个问题。在其他情况下，解决方案并不那么简单。C#
    7.1 通过允许任何可以使用 `as` 操作符的有效类型的类型模式来解决这个问题，这使得[列表 12.15](kindle_split_029_split_000.html#ch12ex15)有效。
- en: I expect the type pattern to be the most commonly used pattern out of the three
    patterns introduced in C# 7.0\. Our final pattern almost doesn’t sound like a
    pattern at all.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计类型模式将是 C# 7.0 中引入的三个模式中最常用的模式。我们的最后一个模式几乎听起来根本不像一个模式。
- en: 12.4.3\. The var pattern
  id: totrans-720
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3\. 变量模式
- en: 'The `var` pattern looks like a type pattern but using `var` as the type, so
    it’s just `var` followed by an identifier:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 模式看起来像是一个类型模式，但使用 `var` 作为类型，所以它只是 `var` 后跟一个标识符：'
- en: '[PRE97]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Like type patterns, it introduces a new variable. But unlike type patterns,
    it doesn’t test anything. It always matches, resulting in a new variable with
    the same compile-time type as `input`, with the same value as `input`. Unlike
    type patterns, the `var` pattern still matches even if `input` is a null reference.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型模式一样，它引入了一个新变量。但与类型模式不同，它不测试任何内容。它总是匹配，结果是一个具有与 `input` 相同的编译时类型和相同值的新的变量。与类型模式不同，即使
    `input` 是一个空引用，`var` 模式仍然匹配。
- en: Because it always matches, using the `var` pattern with the `is` operator in
    an `if` statement in the way that I’ve demonstrated for the other patterns is
    reasonably pointless. It’s most useful with `switch` statements in conjunction
    with a *guard clause* (described in [section 12.6.1](kindle_split_029_split_000.html#ch12lev2sec10)),
    although it could also occasionally be useful if you want to switch on a more
    complex expression without assigning it to a variable.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它总是匹配，所以在 `if` 语句中使用 `var` 模式与 `is` 操作符，就像我在其他模式中演示的那样，是相当没有意义的。它最常与 `switch`
    语句结合使用，并与 *保护子句*（在[第 12.6.1 节](kindle_split_029_split_000.html#ch12lev2sec10)中描述）一起使用，尽管如果你想在没有将其分配给变量的情况下对更复杂的表达式进行切换，偶尔也可能有用。
- en: Just for the sake of presenting an example of `var` without using guard clauses,
    [listing 12.16](kindle_split_029_split_000.html#ch12ex16) shows a `Perimeter`
    method similar to the one in [listing 12.11](kindle_split_029_split_000.html#ch12ex11).
    But this time, if the `shape` parameter has a null value, a random shape is created
    instead. You use a `var` pattern to report the type of the shape if you then can’t
    compute the perimeter. You don’t need the constant pattern with the value `null`
    now, as you’re ensuring that you never switch on a null reference.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了展示一个不使用守卫子句的`var`模式的例子，[列表12.16](kindle_split_029_split_000.html#ch12ex16)显示了一个类似于[列表12.11](kindle_split_029_split_000.html#ch12ex11)中的`Perimeter`方法。但这次，如果`shape`参数有一个null值，就会创建一个随机的形状。如果你不能计算周长，你可以使用`var`模式来报告形状的类型。现在你不需要带有`null`值的常量模式，因为你在确保你永远不会在null引用上切换。
- en: Listing 12.16\. Using the `var` pattern to introduce a variable on error
  id: totrans-726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.16\. 使用`var`模式在错误中引入变量
- en: '[PRE98]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In this case, an alternative would’ve been to introduce the `actualShape` variable
    before the `switch` statement, switch on that, and then use the `default` case
    as before.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个替代方案是在`switch`语句之前引入`actualShape`变量，然后根据它进行切换，然后像以前一样使用`default`情况。
- en: Those are all the patterns available in C# 7.0\. You’ve already seen both of
    the contexts in which they can be used—with the `is` operator and in `switch`
    statements—but there’s a little more to say in each case.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是C# 7.0中可用的所有模式。你已经看到了它们可以使用的两种上下文——与`is`运算符和`switch`语句一起使用——但在每种情况下都有更多要说的话。
- en: 12.5\. Using patterns with the is operator
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5\. 使用`is`运算符的模式
- en: The `is` operator can be used anywhere as part of a normal expression. It’s
    almost always used with `if` statements, but it certainly doesn’t have to be.
    Until C# 7, the right-hand side of an `is` operator had to be just a type, but
    now it can be any pattern. Although this does allow you to use the constant or
    `var` patterns, realistically you’ll almost always use type patterns instead.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符可以在任何地方作为正常表达式的一部分使用。它几乎总是与`if`语句一起使用，但绝对不必如此。在C# 7之前，`is`运算符的右侧必须只是一个类型，但现在它可以是一个任何模式。尽管这确实允许你使用常量或`var`模式，但现实情况下你几乎总是使用类型模式。'
- en: 'Both the `var` pattern and type patterns introduce a new variable. Prior to
    C# 7.3, this came with an extra restriction: you can’t use them in field, property,
    or constructor initializers or query expressions. For example, this would be invalid:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`模式和类型模式都引入了一个新的变量。在C# 7.3之前，这带来了一个额外的限制：你无法在字段、属性或构造函数初始化器或查询表达式中使用它们。例如，这将是不合法的：'
- en: '[PRE99]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: I haven’t found this to be an issue, but the restriction is lifted in C# 7.3
    anyway.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有发现这成为一个问题，但限制在C# 7.3中已经被取消了。
- en: 'That leaves us with patterns introducing local variables, which leads to an
    obvious question: what’s the scope of the newly introduced variable? I understand
    that this was the cause of a lot of discussion within the C# language team and
    the community, but the final result is that the scope of the introduced variable
    is the enclosing block.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了引入局部变量的模式，这引发了一个明显的问题：新引入的变量的作用域是什么？我明白这曾在C#语言团队和社区中引发了大量讨论，但最终结果是引入的变量的作用域是包含的代码块。
- en: As you might expect from a hotly debated topic, there are pros and cons to this.
    One of the things I’ve never liked about the `as`/`if` pattern shown in [listing
    12.10](kindle_split_029_split_000.html#ch12ex10) is that you end up with a lot
    of variables in scope even though you typically don’t want to use them outside
    the condition where the value matched the type you were testing. Unfortunately,
    this is still the case when using type patterns. It’s not quite the same situation,
    as the variable won’t be definitely assigned in branches where the pattern wasn’t
    matched.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个激烈争论的话题，所以它既有优点也有缺点。我从未喜欢过的`as`/`if`模式[列表12.10](kindle_split_029_split_000.html#ch12ex10)之一是，即使你通常不想在值匹配你测试的类型之外的条件中使用它们，你最终会在作用域中拥有很多变量。不幸的是，在使用类型模式时，这种情况仍然存在。这并不是完全相同的情况，因为当模式不匹配时，变量在分支中不会被肯定赋值。
- en: To compare, after this code
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，在这段代码之后
- en: '[PRE100]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'the `text` variable is in scope and definitely assigned. The roughly equivalent
    type pattern code looks like this:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '`text`变量在作用域内，并且肯定被赋值了。大致等价的类型模式代码如下：'
- en: '[PRE101]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'After this, the `text` variable is in scope, but not definitely assigned. Although
    this does pollute the declaration space, it can be useful if you’re trying to
    provide an alternative way of obtaining a value. For example:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，`text` 变量在作用域内，但不是确定赋值。尽管这确实会污染声明空间，但如果您试图提供获取值的一种替代方式，这可能是有用的。例如：
- en: '[PRE102]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Here you really want the `text` variable to stay in scope, because you want
    to use it; you assign to it in one of two ways. You don’t really want `builder`
    in scope after the middle block, but you can’t have it both ways.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您确实希望 `text` 变量保持作用域，因为您想使用它；您可以通过两种方式之一对其赋值。您真的不希望在中间块之后还有 `builder` 的作用域，但您不能两者兼得。
- en: 'To be a little more technical about the definite assignment, after an `is`
    expression with a pattern that introduces a pattern variable, the variable is
    (in language specification terminology) “definitely assigned after true expression.”
    That can be important if you want an `if` condition to do more than just test
    the type. For example, suppose you want to check whether the value provided is
    a large integer. This is fine:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 要更技术性地讨论确定赋值，在具有引入模式变量的模式表达式的 `is` 表达式之后，该变量（在语言规范术语中）是“在真表达式之后确定赋值”。如果您想使 `if`
    条件做更多的事情，而不仅仅是测试类型，这可能很重要。例如，假设您想检查提供的值是否是大型整数。这是可以的：
- en: '[PRE103]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You can use `x` after the `&&` because you’ll evaluate that operand only if
    the first operand evaluates to `true`. You can also use `x` inside the `if` statement
    because you’ll execute the body of the `if` statement only if both `&&` operands
    evaluate to `true`. But what if you want to handle both `int` or `long` values?
    You can test the value, but then you can’t tell which condition matched:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `&&` 之后使用 `x`，因为只有当第一个操作数评估为 `true` 时，您才会评估该操作数。您也可以在 `if` 语句中使用 `x`，因为只有当两个
    `&&` 操作数都评估为 `true` 时，您才会执行 `if` 语句的主体。但如果您想同时处理 `int` 或 `long` 值怎么办？您可以测试该值，但这样您就无法知道哪个条件匹配了：
- en: '[PRE104]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Here, both `x` and `y` are in scope both inside and after the `if` statement,
    even though the part declaring `y` looks as if it may not execute. But the variables
    are definitely assigned only within the very small piece of code where you’re
    checking how large the values are.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x` 和 `y` 都在 `if` 语句内部及其之后的作用域内，即使看起来声明 `y` 的部分可能不会执行。但变量仅在检查值大小的小块代码中确定赋值。
- en: 'All of this makes logical sense, but it can be a little surprising the first
    time you see it. The two takeaways of this section are as follows:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都符合逻辑，但第一次看到时可能会有些惊讶。本节的两点收获如下：
- en: Expect the scope of a pattern variable declared in an `is` expression to be
    the enclosing block.
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期在 `is` 表达式中声明的模式变量的作用域是包含的块。
- en: If the compiler prevents you from using a pattern variable, that means the language
    rules can’t prove that the variable will have been assigned a value at that point.
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编译器阻止您使用模式变量，这意味着语言规则无法证明在该点变量将被赋值。
- en: In the final part of this chapter, we’ll look at patterns used in `switch` statements.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探讨在 `switch` 语句中使用的模式。
- en: 12.6\. Using patterns with switch statements
  id: totrans-753
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6. 使用 switch 语句的模式
- en: 'Specifications are often written not in terms of algorithms as such but in
    terms of cases. The following are examples far removed from computing:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 规范通常不是用算法本身来编写的，而是用情况来编写的。以下是一些与计算相去甚远的例子：
- en: '*Taxes and benefits*—Your tax bracket probably depends on your income and some
    other factors.'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*税费和福利*—您的税率可能取决于您的收入和其他一些因素。'
- en: '*Travel tickets*—There may be group discounts as well as separate prices for
    children, adults, and the elderly.'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旅行票务*—可能会有团体折扣，以及针对儿童、成人和老年人的单独价格。'
- en: '*Takeout food ordering*—There can be deals if your order meets certain criteria.'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*外卖订餐*—如果您的订单符合某些标准，可能会有优惠。'
- en: 'In the past, we’ve had two ways of detecting which case applies to a particular
    input: `switch` statements and `if` statements, where `switch` statements were
    limited to simple constants. We still have just those two approaches, but `if`
    statements are already cleaner using patterns as you’ve seen, and `switch` statements
    are much more powerful.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们有两种检测特定输入适用哪种情况的方法：`switch` 语句和 `if` 语句，其中 `switch` 语句仅限于简单的常量。我们仍然只有这两种方法，但
    `if` 语句已经更简洁，如您所见，而 `switch` 语句则更强大。
- en: '|  |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Pattern-based `switch` statements feel quite different from the constant-value-only
    `switch` statements of the past. Unless you’ve had experience with other languages
    that have similar functionality, you should expect it to take a little while to
    get used to the change.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 基于模式的 `switch` 语句与过去只允许常量值的 `switch` 语句感觉相当不同。除非你有过使用具有类似功能的其他语言的经验，否则你应该预计需要一段时间才能习惯这种变化。
- en: '|  |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`switch` statements with patterns are largely equivalent to a sequence of `if`/`else`
    statements, but they encourage you to think more in terms of “this kind of input
    leads to this kind of output” instead of steps.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 带有模式的 `switch` 语句在很大程度上等同于一系列的 `if`/`else` 语句，但它们鼓励你更多地从“这种输入导致这种输出”的角度去思考，而不是步骤。
- en: '|  |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**All switch statements can be considered pattern based**'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '**所有 `switch` 语句都可以被视为基于模式的**'
- en: Throughout this section, I talk about constant-based `switch` statements and
    pattern-based `switch` statements as if they’re different. Because constant patterns
    *are* patterns, every valid `switch` statement can be considered a pattern-based
    `switch` statement, and it will still behave in exactly the same way. The differences
    you’ll see later in terms of execution order and new variables being introduced
    don’t apply to constant patterns anyway.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我谈论基于常量的 `switch` 语句和基于模式的 `switch` 语句，好像它们是不同的。因为常量模式 *确实是* 模式，所以每个有效的
    `switch` 语句都可以被视为基于模式的 `switch` 语句，并且它们的行为将完全相同。关于执行顺序和引入新变量的差异，在常量模式中并不适用。
- en: I find it quite helpful, at least at the moment, to consider these as if they
    were two separate constructs that happen to use the same syntax. You may feel
    more comfortable not to make that distinction. It’s safe to use either mental
    model; they’ll both predict the code’s behavior correctly.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现至少在目前，将这些视为两个独立的构造，它们恰好使用了相同的语法，是非常有帮助的。你可能觉得不区分它们会更舒服。使用任何心理模型都是安全的；它们都会正确预测代码的行为。
- en: '|  |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ve already seen an example of patterns in `switch` statements in [section
    12.3](kindle_split_029_split_000.html#ch12lev1sec3), where you used a constant
    pattern to match `null` and type patterns to match different kinds of shapes.
    In addition to simply putting a pattern in the case label, there’s one new piece
    of syntax to introduce.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 [12.3 节](kindle_split_029_split_000.html#ch12lev1sec3) 中看到了 `switch` 语句中模式的例子，其中你使用常量模式来匹配
    `null` 和类型模式来匹配不同类型的形状。除了在 case 标签中简单地放置一个模式之外，还有一个新的语法元素需要介绍。
- en: 12.6.1\. Guard clauses
  id: totrans-770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.6.1\. 守卫子句
- en: 'Each case label can also have a guard clause, which consists of an expression:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 每个case标签也可以有一个守卫子句，它由一个表达式组成：
- en: '[PRE105]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The expression has to evaluate to a Boolean value^([[2](kindle_split_029_split_000.html#ch12fn2)])
    just like an `if` statement’s condition. The body of the case will be executed
    only if the expression evaluates to `true`. The expression can use more patterns,
    thereby introducing extra pattern variables.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式必须评估为布尔值^([[2](kindle_split_029_split_000.html#ch12fn2)))，就像 `if` 语句的条件一样。只有当表达式评估为
    `true` 时，才会执行 case 的主体。表达式可以使用更多的模式，从而引入额外的模式变量。
- en: ²
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It can also be a value that can be implicitly converted to a Boolean value or
    a value of a type that provides a `true` operator. These are the same requirements
    as the condition in an `if` statement.
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它也可以是一个可以隐式转换为布尔值或提供 `true` 操作符的类型的值。这些要求与 `if` 语句中的条件相同。
- en: 'Let’s look at a concrete example that’ll also illustrate my point about specifications.
    Consider the following definition of the Fibonacci sequence:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具体的例子，这个例子也将说明我关于规范的观点。考虑以下斐波那契数列的定义：
- en: '`fib(0) = 0`'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib(0) = 0`'
- en: '`fib(1) = 1`'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib(1) = 1`'
- en: '`fib(n) = fib(n-2) + fib(n-1)` for all `n > 1`'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fib(n) = fib(n-2) + fib(n-1)` 对于所有 `n > 1`'
- en: 'In [chapter 11](kindle_split_028_split_000.html#ch11), you saw how to generate
    the Fibonacci sequence by using tuples, which is a clean approach when considering
    it as a sequence. If you consider it only as a function, however, the preceding
    definition leads to the following listing: a simple `switch` statement using patterns
    and a guard clause.'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 11 章](kindle_split_028_split_000.html#ch11) 中，你看到了如何使用元组生成斐波那契数列，当将其视为序列时，这是一种干净的方法。然而，如果你只将其视为函数，前面的定义会导致以下列表：一个简单的使用模式和守卫子句的
    `switch` 语句。
- en: Listing 12.17\. Implementing the Fibonacci sequence recursively with patterns
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.17\. 使用模式递归实现斐波那契数列
- en: '[PRE106]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '***1* Base cases handled with constant patterns**'
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用常量模式处理基本案例**'
- en: '***2* Recursive case handled with var pattern and guard clause**'
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用var模式和守卫子句处理递归情况**'
- en: '***3* If you don’t match any patterns, the input was invalid.**'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果没有匹配任何模式，输入是无效的。**'
- en: This is a horribly inefficient implementation that I’d never use in real life,
    but it clearly demonstrates how a specification can be directly translated into
    code.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个效率极低且我永远不会在实际生活中使用的实现，但它清楚地展示了如何将规范直接转换为代码。
- en: In this example, the guard clause doesn’t need to use the pattern variable,
    so I used a discard with the `_` identifier. In many cases, if the pattern introduces
    a new variable, it *will* be used in the guard clause or at least in the case
    body.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，保护子句不需要使用模式变量，所以我使用了带有`_`标识符的丢弃操作。在许多情况下，如果模式引入了新的变量，它*将会*在保护子句或至少在case体中使用。
- en: 'When you use guard clauses, it makes perfect sense for the same pattern to
    appear multiple times, because the first time the pattern matches, the guard clause
    may evaluate to `false`. Here’s an example from Noda Time in a tool used to build
    documentation:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用保护子句时，同一个模式出现多次是完全合理的，因为第一次模式匹配时，保护子句可能评估为`false`。以下是从用于构建文档的工具中的Noda Time的一个示例：
- en: '[PRE107]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'I have four patterns that handle generic parameters based on the `useTypeArgumentNames`
    method parameter and then whether the generic type parameter was introduced in
    a method or a type. The case that throws an exception is almost a `default` case
    for generic parameters, indicating that it’s come across a situation I haven’t
    thought about yet. The fact that I’m using the same pattern variable name (`gp`)
    for multiple cases raises another natural question: what’s the scope of a pattern
    variable introduced in a `case` label?'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 我有四个模式，根据`useTypeArgumentNames`方法参数以及泛型类型参数是在方法还是类型中引入来处理泛型参数。抛出异常的情况几乎是一个泛型参数的`default`情况，表明它遇到了我还没有考虑过的情况。我使用相同的模式变量名（`gp`）为多个情况命名的事实又提出了另一个自然的问题：在`case`标签中引入的模式变量的作用域是什么？
- en: 12.6.2\. Pattern variable scope for case labels
  id: totrans-792
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.6.2\. `case`标签的模式变量作用域
- en: If you declare a local variable directly within a `case` body, the scope of
    that variable is the whole `switch` statement, including other `case` bodies.
    That’s still true (and unfortunate, in my opinion), but it doesn’t include variables
    declared within case labels. The scope of those variables is just the body associated
    with that case label. That applies to pattern variables declared by the pattern,
    pattern variables declared within the guard clause, and any `out` variables (see
    [section 14.2](kindle_split_031_split_000.html#ch14lev1sec2)) declared in the
    guard clause.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接在`case`体内部声明局部变量，该变量的作用域是整个`switch`语句，包括其他`case`体。这一点依然成立（并且在我看来，这是不幸的），但它不包括在case标签内声明的变量。这些变量的作用域仅仅是与该case标签关联的体。这适用于由模式声明的模式变量、在保护子句内声明的模式变量以及在任何保护子句中声明的任何`out`变量（参见[第14.2节](kindle_split_031_split_000.html#ch14lev1sec2)）。
- en: 'That’s almost certainly what you want, and it’s useful in terms of allowing
    you to use the same pattern variables for multiple cases handling similar situations,
    as demonstrated in the Noda Time tool code. There’s one quirk here: just as with
    normal `switch` statements, it’s valid to have multiple `case` labels with the
    same body. At that point, the variables declared within all the `case` labels
    for that body are required to have different names (because they’re contributing
    to the same declaration space). But within the `case` body, none of those variables
    will be definitely assigned, because the compiler can’t tell which label matched.
    It can still be useful to introduce those variables, but mostly for the sake of
    using them in guard clauses.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎肯定是你想要的，并且它在允许你为处理类似情况的不同情况使用相同的模式变量方面很有用，正如在Noda Time工具代码中所示。这里有一个怪癖：就像正常的`switch`语句一样，可以有多个具有相同体的`case`标签。在这种情况下，所有这些`case`标签内声明的变量都需要有不同的名字（因为它们正在贡献同一个声明空间）。但在`case`体内部，这些变量中没有一个会被明确赋值，因为编译器无法确定哪个标签匹配。尽管如此，引入这些变量仍然可能是有用的，但主要是为了在保护子句中使用它们。
- en: For example, suppose you’re matching an `object` input, and you want to make
    sure that if it’s numeric, it’s within a particular range, and that range may
    vary by type. You could use one type pattern per numeric type with a corresponding
    guard clause. The following listing shows this for `int` and `long`, but you could
    expand it for other types.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在匹配一个`object`输入，并确保如果它是数值类型，它处于特定的范围内，而这个范围可能因类型而异。你可以为每种数值类型使用一个类型模式，并相应地使用保护子句。以下列表显示了`int`和`long`的情况，但你也可以将其扩展到其他类型。
- en: Listing 12.18\. Using multiple `case` labels with patterns for a single `case`
    body
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.18\. 使用模式为单个case体提供多个`case`标签
- en: '[PRE108]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The pattern variables are definitely assigned within the guard clauses, because
    execution will reach the guard clause only if the pattern has matched to start
    with, and they’re still in scope within the body, but they’re not definitely assigned.
    You could assign new values to them and use them after that, but I feel that won’t
    often be useful.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 模式变量肯定在保护子句中被赋值，因为只有当模式最初匹配时，执行才会到达保护子句，并且它们在主体中仍然有效，但它们不是肯定被赋值的。你可以给它们赋新值并在之后使用它们，但我感觉这不会经常有用。
- en: 'In addition to the basic premise of pattern matching being new and different,
    there’s one huge difference between the constant-based `switch` statements of
    the past and new pattern-based `switch` statements: the order of cases matters
    in a way that it didn’t before.'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模式匹配的基本前提是新颖和不同之外，过去基于常量的`switch`语句和新的基于模式的`switch`语句之间还有一个巨大的区别：case的顺序现在比以前更重要。
- en: 12.6.3\. Evaluation order of pattern-based switch statements
  id: totrans-800
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.6.3\. 基于模式的switch语句的评估顺序
- en: In almost all situations, `case` labels for constant-based `switch` statements
    can be reordered freely with no change in behavior.^([[3](kindle_split_029_split_000.html#ch12fn3)])
    This is because each `case` label matches a single constant value, and the constants
    used for any `switch` statement all have to be different, so any input can match
    at most only one `case` label. With patterns, that’s no longer true.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，基于常量的`switch`语句的`case`标签可以自由地重新排序，而不会改变行为。[3](kindle_split_029_split_000.html#ch12fn3)
    这是因为每个`case`标签都匹配一个单一的常量值，并且任何`switch`语句中使用的所有常量都必须是不同的，所以任何输入最多只能匹配一个`case`标签。但是，对于模式来说，情况就不再是这样了。
- en: ³
  id: totrans-802
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The only time this isn’t true is when you use a variable in one case body that
    was declared in an earlier case body. That’s almost always a bad idea anyway,
    and it’s a problem only because of the shared scope of such variables.
  id: totrans-804
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 唯一不成立的情况是，当你在某个case体中使用在早期case体中声明的变量时。这几乎总是个坏主意，而且这只是一个问题，因为这样的变量具有共享的作用域。
- en: 'The logical evaluation order of a pattern-based `switch` statement can be summarized
    simply:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 基于模式的`switch`语句的逻辑评估顺序可以简单地总结如下：
- en: Each `case` label is evaluated in source-code order.
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个case标签按源代码顺序进行评估。
- en: The code body of the `default` label is executed only when all the `case` labels
    have been evaluated, regardless of where the `default` label is within the `switch`
    statement.
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当所有`case`标签都已评估时，才会执行`default`标签的代码体，无论`default`标签在`switch`语句中的位置如何。
- en: '|  |'
  id: totrans-808
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-809
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Although you now know that the code associated with the `default` label is executed
    only if none of the case labels matches, regardless of where it appears, it’s
    possible that some people reading your code might not. (Indeed, you might have
    forgotten it by the time you next come to read your own code.) If you put the
    `default` label as the final part of the `switch` statement, the behavior is always
    clear.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你现在知道与`default`标签关联的代码仅在没有任何case标签匹配的情况下执行，无论它出现在哪里，但阅读你代码的一些人可能并不了解这一点。（实际上，当你下次再次阅读自己的代码时，你可能已经忘记了这一点。）如果你将`default`标签放在`switch`语句的最后部分，其行为总是清晰的。
- en: '|  |'
  id: totrans-811
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Sometimes it won’t matter. In our Fibonacci-computing method, for example,
    the cases were only 0, 1, and more than 1, so they could be freely reordered.
    Our Noda Time tool code, however, had four cases that definitely need to be checked
    in order:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候这并不重要。例如，在我们的斐波那契计算方法中，case只有0、1和大于1，因此它们可以自由地重新排序。然而，我们的Noda Time工具代码有四个必须按顺序检查的case：
- en: '[PRE109]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Here you want to use the generic type parameter name whenever `useTypeArgumentNames`
    is true (the first case), regardless of the other cases. The second and third
    cases are mutually exclusive (in a way that you know but the compiler wouldn’t),
    so their order doesn’t matter. The last case must be last within these four because
    you want the exception to be thrown only if the input is a `GenericParameter`
    that isn’t otherwise handled.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当`useTypeArgumentNames`为真（即第一个案例）时，你应始终使用泛型类型参数名称。第二个和第三个案例是互斥的（以你知道的方式，但编译器不知道），所以它们的顺序无关紧要。最后一个案例必须是这四个中的最后一个，因为你希望只有当输入是一个未处理的`GenericParameter`时才抛出异常。
- en: 'The compiler is helpful here: the final case doesn’t have a guard clause, so
    it’ll always be valid if the type pattern matches. The compiler is aware of this;
    if you put that case earlier than the other case labels with the same pattern,
    it knows that’s effectively hiding them and reports an error.'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里编译器很有帮助：最后的案例没有守卫子句，所以如果类型模式匹配，它总是有效的。编译器知道这一点；如果你将这个案例放在具有相同模式的其它案例标签之前，它知道这实际上是在隐藏它们，并报告错误。
- en: Multiple case bodies can be executed in only one way, and that’s with the rarely
    used `goto` statement. That’s still valid within pattern-based `switch` statements,
    but you can `goto` only a constant value, and a `case` label must be associated
    with that value without a guard clause. For example, you can’t `goto` a type pattern,
    and you can’t `goto` a value on the condition that an associated guard clause
    also evaluates to `true`. In reality, I’ve seen so few `goto` statements in `switch`
    statements that I can’t see this being much of a restriction.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 多个案例体只能以一种方式执行，那就是使用很少使用的`goto`语句。这在基于模式的`switch`语句中仍然有效，但你只能跳转到常量值，并且必须有一个没有守卫子句的`case`标签与该值关联。例如，你不能跳转到类型模式，也不能在关联的守卫子句也评估为`true`的条件下跳转到值。实际上，我在`switch`语句中看到这么少的`goto`语句，以至于我认为这并不是一个很大的限制。
- en: I deliberately referred to the *logical* evaluation order earlier. Although
    the C# compiler could effectively translate every `switch` statement into a sequence
    of `if`/`else` statements, it can act more efficiently than that. For example,
    if there are multiple type patterns for the same type but with different guard
    clauses, it can evaluate the type pattern part once and then check each guard
    clause in turn instead. Similarly, for constant values without guard patterns
    (which still have to be distinct, just as in previous versions of C#), the compiler
    can use the IL `switch` instruction, potentially after performing an implicit
    type check. Exactly which optimizations the compiler performs is beyond the scope
    of this book, but if you ever happen to look at the IL associated with a `switch`
    statement and it bears little resemblance to the source code, this may well be
    the cause.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前故意提到了*逻辑*评估顺序。尽管C#编译器可以将每个`switch`语句有效地转换成一系列的`if`/`else`语句，但它可以比这更高效地执行。例如，如果有多个类型模式对应同一类型但具有不同的守卫子句，它可以一次评估类型模式部分，然后依次检查每个守卫子句。同样，对于没有守卫模式的常量值（它们仍然必须像C#的早期版本一样是唯一的），编译器可以使用IL
    `switch`指令，这可能在执行隐式类型检查之后。编译器执行的确切优化超出了本书的范围，但如果你偶然查看与`switch`语句关联的IL，并且它与源代码几乎没有相似之处，这可能是原因。
- en: 12.7\. Thoughts on usage
  id: totrans-818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7\. 使用思考
- en: This section provides preliminary thoughts on how the features described in
    this chapter are best used. Both features are likely to evolve further and possibly
    even be combined with a deconstruction pattern. Other related potential features,
    such as syntax to write an expression-bodied method for which the result is based
    on a pattern-based `switch`, may well affect where these features are used. You’ll
    see some potential C# 8 features like this in [chapter 15](kindle_split_032_split_000.html#ch15).
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了关于本章描述的特性如何最佳使用的初步思考。这两个特性很可能会进一步发展，甚至可能结合解构模式。其他相关的潜在特性，例如用于编写基于模式的`switch`表达式的语法，可能会影响这些特性的使用位置。你将在第15章（[chapter
    15](kindle_split_032_split_000.html#ch15)）中看到一些这样的C# 8特性。
- en: Pattern matching is an implementation concern, which means that you don’t need
    to worry if you find later that you’ve overused it. You can revert to an older
    style of coding if you find patterns don’t give you the readability benefit you’d
    expected. The same is true of deconstruction to some extent. But if you’ve added
    public `Deconstruct` methods all over your API, removing them would be a breaking
    change.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一个实现问题，这意味着如果你后来发现你过度使用了它，你不需要担心。如果你发现模式没有给你预期的可读性好处，你可以回退到更老的编码风格。这在某种程度上也适用于解构。但是，如果你在你的API中到处添加了公共的`Deconstruct`方法，移除它们将是一个破坏性的变更。
- en: More than that, I suggest that most types aren’t naturally deconstructable anyway,
    just as most types don’t have a natural `IComparable<T>` implementation. I suggest
    adding a `Deconstruct` method only if the order of the components is obvious and
    unambiguous. That’s fine for coordinates, anything with a hierarchical nature
    such as date/time values, or even where there’s a common convention, such as colors
    being thought of as RGB with optional alpha. Most business-related entities probably
    don’t fall into this category, though; for example, an item in an online shopping
    basket has various aspects, but there’s no obvious order to them.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我建议大多数类型本身并不是自然可解构的，就像大多数类型没有自然的`IComparable<T>`实现一样。我建议只有在组件的顺序明显且无歧义的情况下才添加`Deconstruct`方法。这对于坐标、具有层次性质的东西（如日期/时间值）或甚至有共同约定的地方（如将颜色视为带有可选alpha的RGB）都是可以的。然而，大多数与业务相关的实体可能不属于这一类别；例如，在线购物车中的商品有各种方面，但它们之间没有明显的顺序。
- en: 12.7.1\. Spotting deconstruction opportunities
  id: totrans-822
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.7.1. 发现解构机会
- en: 'The simplest kind of deconstruction to use is likely to be related to tuples.
    If you’re calling a method that returns a tuple and you don’t need to keep the
    values together, consider deconstructing them instead. For example, with our `MinMax`
    method from [chapter 11](kindle_split_028_split_000.html#ch11), I’d almost always
    deconstruct immediately instead of keeping the return value as a tuple:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的最简单的解构类型可能与你想要解构的元组有关。如果你调用一个返回元组的方法，而你不需要保留这些值在一起，考虑解构它们。例如，在我们的第11章中的`MinMax`方法[kindle_split_028_split_000.html#ch11]，我几乎总是立即解构，而不是将返回值作为一个元组保留：
- en: '[PRE110]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: I suspect the use of nontuple deconstruction will be rarer, but if you’re dealing
    with points, colors, date/time values, or something similar, you may find that
    it’s worth deconstructing the value early on if you’d otherwise refer to the components
    via properties multiple times. You could’ve done this before C# 7, but the ease
    of declaring multiple local variables via deconstruction could easily swing the
    balance between not worth doing and worth doing.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑非元组解构的使用会更少，但如果你处理的是点、颜色、日期/时间值或类似的东西，你可能会发现，如果你在其他情况下多次通过属性引用组件，那么在早期解构值可能是值得的。你可以在C#
    7之前这样做，但通过解构声明多个局部变量的便利性可以轻易地改变是否值得做的平衡。
- en: 12.7.2\. Spotting pattern matching opportunities
  id: totrans-826
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.7.2. 发现模式匹配机会
- en: 'You should consider pattern matching in two obvious places:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在两个明显的地方考虑使用模式匹配：
- en: Anywhere you’re using the `is` or `as` operators and conditionally executing
    code by using the more specifically typed value.
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何你使用`is`或`as`运算符，并通过使用更具体类型的值来有条件地执行代码的地方。
- en: Anywhere you have an `if/else-if/else-if/else` sequence using the same value
    for all the conditions, and you can use a `switch` statement instead.
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何你有一个使用相同值的所有条件的`if/else-if/else-if/else`序列的地方，你可以使用`switch`语句代替。
- en: If you find yourself using a pattern of the form `var ... when` multiple times
    (in other words, when the only condition occurs in a guard clause), you may want
    to ask yourself whether this is really pattern matching. I’ve certainly come across
    scenarios like that, and so far I’ve erred on the side of using pattern matching
    anyway. Even if it feels slightly abusive, it conveys the intent of matching a
    single condition and taking a single action more clearly than the `if/else` sequence
    does, in my view.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己多次使用形式为`var ... when`的模式（换句话说，当唯一条件出现在守卫子句中时），你可能想问自己这真的是模式匹配吗。我确实遇到过这样的场景，到目前为止，我仍然倾向于使用模式匹配。即使这感觉有点滥用，在我看来，它比`if/else`序列更清楚地传达了匹配单个条件并执行单个动作的意图。
- en: Both of these are transformations of an existing code structure with changes
    only to the implementation details. They’re not changing the way you think about
    and organize your logic. That grander style of change—which could still be refactoring
    within the visible API of a single type, or perhaps within the public API of an
    assembly, by changing internal details—is harder to spot. Sometimes it may be
    a move away from using inheritance; the logic for a calculation may be more clearly
    expressed in a single place that considers all the different cases than as part
    of the type representing each of those cases. The perimeter of a shape case in
    [section 12.3](kindle_split_029_split_000.html#ch12lev1sec3) is one example of
    this, but you could easily apply the same ideas to many business cases. This is
    where disjoint union types are likely to become more widespread within C#.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种都是对现有代码结构的转换，只是对实现细节进行了修改。它们并没有改变你对逻辑思考和组织的思考方式。那种更大的改变风格——可能仍然是在单个类型的可见API内进行重构，或者可能是在程序集的公共API内通过改变内部细节来实现——更难以察觉。有时，它可能意味着从使用继承转向其他方式；一个计算的逻辑可能在一个考虑了所有不同情况的单一位置中表达得更加清晰，而不是作为代表每个情况的类型的组成部分。[第12.3节](kindle_split_029_split_000.html#ch12lev1sec3)中形状案例的边界就是一个例子，但你很容易将这些相同的想法应用到许多业务案例中。这就是为什么在C#中，非元组类型可能会变得更加普遍。
- en: 'As I said, these are preliminary thoughts. As always, I encourage you to experiment
    with deliberate introspection: consider opportunities as you code, and if you
    try something new, reflect on its pros and cons after you’ve done so.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说的，这些只是初步的想法。一如既往，我鼓励你通过有意识的内省进行实验：在编码时考虑机会，如果你尝试了新的东西，在你完成之后反思其优缺点。
- en: Summary
  id: totrans-833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Deconstruction allows you to break values into multiple variables with syntax
    that’s consistent between tuples and nontuples.
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构允许你使用与元组和非元组一致的语法将值分解成多个变量。
- en: Nontuple types are deconstructed using a `Deconstruct` method with `out` parameters.
    This can be an extension method or an instance method.
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非元组类型使用具有`out`参数的`Deconstruct`方法进行解构。这可以是一个扩展方法或实例方法。
- en: Multiple variables can be declared with a single `var` deconstruction if all
    the types can be inferred by the compiler.
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果编译器可以推断出所有类型，则可以使用单个`var`解构声明多个变量。
- en: Pattern matching allows you to test the type and content of a value, and some
    patterns allow you to declare a new variable.
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配允许你测试值的类型和内容，并且一些模式允许你声明新的变量。
- en: Pattern matching can be used with the `is` operator or in `switch` statements.
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配可以使用`is`运算符或`switch`语句。
- en: A pattern within a `switch` statement can have an additional guard clause introduced
    by the `when` contextual keyword.
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`switch`语句中的模式可以引入一个额外的保护子句，由`when`上下文关键字引入。
- en: When a `switch` statement contains patterns, the order of the `case` labels
    can change the behavior.
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`switch`语句包含模式时，`case`标签的顺序可能会改变行为。
- en: Chapter 13\. Improving efficiency with more pass by reference
  id: totrans-841
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章. 通过更多按引用传递提高效率
- en: '|  |'
  id: totrans-842
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章内容涵盖**'
- en: Aliasing variables with the `ref` keyword
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ref`关键字别名变量
- en: Returning variables by reference with ref returns
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ref返回值按引用返回变量
- en: Efficient argument passing with `in` parameters
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`in`参数进行高效的参数传递
- en: Preventing data changes with read-only ref returns, read-only ref locals, and
    read-only struct declarations
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用只读ref返回值、只读ref局部变量和只读结构声明来防止数据更改
- en: Extension methods with `in` or `ref` targets
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`in`或`ref`目标的扩展方法
- en: Ref-like structs and `Span<T>`
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于ref的结构和`Span<T>`
- en: '|  |'
  id: totrans-850
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'When C# 7.0 came out, it had a couple of features that struck me as slightly
    odd: ref local variables and ref returns. I was slightly skeptical about how many
    developers would need them, as they seemed to be targeted situations involving
    large value types, which are rare. My expectation was that only near-real-time
    services and games would find these useful.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 当C# 7.0发布时，它有几个我觉得有点奇怪的功能：只读局部变量和只读返回值。我对有多少开发者需要它们有些怀疑，因为它们似乎针对的是涉及大型值类型的情况，这种情况很少见。我的预期是，只有接近实时服务和游戏会发现这些功能有用。
- en: 'C# 7.2 brought another raft of ref-related features: `in` parameters, read-only
    ref locals and returns, read-only structs, and ref-like structs. These were complementary
    to the 7.0 features but still appeared to be making the language more complicated
    for the benefit of a small set of users.'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.2 带来了另一批与引用相关的特性：`in` 参数、只读引用局部变量和返回值、只读结构体和类似引用的结构体。这些特性与 7.0 版本的特性相辅相成，但似乎仍然是为了一小部分用户的利益而使语言变得更加复杂。
- en: I’m now convinced that although many developers may not directly see more ref-based
    code in their projects, they’ll reap the benefits of the features existing because
    more-efficient facilities are being made available in the framework. At the time
    of writing, it’s too early to say for sure how revolutionary this will prove,
    but I think it’s likely to be significant.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在确信，尽管许多开发者可能不会直接在他们项目中看到更多基于引用的代码，但他们将从框架中提供的更高效功能中受益。在撰写本文时，还太早确定这将证明有多么革命性，但我认为它很可能会是重大的。
- en: Often performance comes at the expense of readability. I still believe that’s
    the case with many of the features described in this chapter; I’m expecting them
    to be used sparingly in cases where performance is known to be important enough
    to justify the cost. The framework changes enabled by all of this are a different
    matter, though. They should make it reasonably easy to reduce object allocations
    and save both memory and garbage collector work without making your code harder
    to read.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，性能是以可读性为代价的。我仍然认为，本章中描述的许多特性也是这样；我预计它们将在已知性能足够重要以证明其成本的情况下被少量使用。然而，所有这些带来的框架变化是另一回事。它们应该使减少对象分配、节省内存和垃圾收集器的工作量变得相对容易，而不会使你的代码更难以阅读。
- en: I bring all of this up because you may have similar reactions. While reading
    this chapter, it’s entirely reasonable to decide that you’ll try to avoid most
    of the language features here. I urge you to plow on to the end, though, to see
    the framework-related benefits. The final section, on ref-like structs, introduces
    `Span<T>`. Far more can be said about spans than I have room to write in this
    book, but I expect spans and related types to be important parts of the developer
    toolbox in the future.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到这些，是因为你可能会有类似的反应。在阅读本章时，决定尽量避免这里的大多数语言特性是完全合理的。尽管如此，我敦促你继续读到最后一部分，以了解框架相关的益处。关于类似引用的结构体的最后一部分介绍了
    `Span<T>`。关于跨度可以说的内容远不止这本书能写的，但我预计跨度和相关类型将成为未来开发者工具箱中的重要部分。
- en: 'Throughout this chapter, I’ll mention when a feature is available only in a
    point release of C# 7\. As with other point release features, that means if you’re
    using a C# 7 compiler, you’ll be able to take advantage of those features only
    with appropriate project settings to specify the language version. I suggest you
    take an all-or-nothing approach to ref-related features: either use them all,
    with appropriate settings to allow this, or use none of them. Using only the features
    in C# 7.0 is likely to be less satisfying. With all of that said, let’s start
    by revisiting the use of the `ref` keyword in earlier versions of C#.'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我会提到何时一个特性仅在 C# 7 的某个点版本中可用。与其他点版本特性一样，这意味着如果你使用的是 C# 7 编译器，你只能通过适当的设置来指定语言版本，才能利用这些特性。我建议你对引用相关特性采取全有或全无的方法：要么全部使用，并设置适当的选项来允许这样做；要么一个都不用。仅使用
    C# 7.0 中的特性可能不会令人满意。尽管如此，让我们首先回顾一下在 C# 早期版本中使用 `ref` 关键字的情况。
- en: '13.1\. Recap: What do you know about ref?'
  id: totrans-857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1\. 回顾：你对引用了解多少？
- en: You need a firm grasp of how ref parameters work in C# 6 and earlier in order
    to understand the ref-related features in C# 7\. This, in turn, requires a firm
    grasp of the difference between a variable and its value.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 C# 7 中的引用相关特性，你需要牢固掌握 C# 6 及更早版本中引用参数的工作方式。这反过来又需要你牢固掌握变量与其值之间的区别。
- en: 'Different developers have different ways of thinking about variables, but my
    mental model is always that of a piece of paper, as shown in [figure 13.1](kindle_split_030_split_000.html#ch13fig01).
    The piece of paper has three items of information:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的开发者对变量的思考方式不同，但我的心理模型始终是一张纸，如图 [13.1](kindle_split_030_split_000.html#ch13fig01)
    所示。这张纸上有三项信息：
- en: Figure 13.1\. Representing a variable as a piece of paper
  id: totrans-860
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.1\. 将变量表示为一张纸
- en: '![](../Images/13fig01.jpg)'
  id: totrans-861
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1](../Images/13fig01.jpg)'
- en: The name of the variable
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的名称
- en: The compile-time type
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译时类型
- en: The current value
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前值
- en: Assigning a new value to the variable is just a matter of erasing the current
    value and writing a new one instead. When the type of the variable is a reference
    type, the value written on the piece of paper is never an object; it’s always
    an object reference. An object reference is just a way of navigating to an object
    in the same way that a street address is a way of navigating to a building. Two
    pieces of paper with the same address written on them refer to the same building,
    just as two variables with the same reference value refer to the same object.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 将新值赋给变量只是删除当前值并写入新值的问题。当变量的类型是引用类型时，纸上的值永远不是一个对象；它始终是一个对象引用。对象引用只是导航到对象的一种方式，就像街道地址是导航到建筑的方式一样。两张写有相同地址的纸指向同一栋建筑，就像两个具有相同引用值的变量指向同一个对象一样。
- en: '|  |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-867
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The `ref` keyword and object references are different concepts. Similarities
    certainly exist, but you need to distinguish between them. Passing an object reference
    by value isn’t the same thing as passing a variable by reference, for example.
    In this section, I’ve emphasized the difference by using *object reference* instead
    of just *reference*.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`关键字和对象引用是不同的概念。当然，它们之间有相似之处，但你需要区分它们。例如，通过值传递对象引用与通过引用传递变量不是一回事。在本节中，我通过使用*对象引用*而不是仅仅*引用*来强调它们之间的区别。'
- en: '|  |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Importantly, when an assignment copies one variable’s value into another variable,
    it really is just the value that’s copied; the two pieces of paper remain independent,
    and a later change to either variable doesn’t change the other. [Figure 13.2](kindle_split_030_split_000.html#ch13fig02)
    illustrates this concept.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，当一个赋值操作将一个变量的值复制到另一个变量时，实际上复制的是值；两张纸保持独立，对任一变量的后续更改都不会影响另一个。图13.2[展示了这一概念](kindle_split_030_split_000.html#ch13fig02)。
- en: Figure 13.2\. Assignment copying a value into a new variable
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.2\. 将值赋值到新变量中
- en: '![](../Images/13fig02.jpg)'
  id: totrans-872
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2](../Images/13fig02.jpg)'
- en: This sort of value copying is exactly what happens with a value parameter when
    you call a method; the *value* of the method argument is copied onto a fresh piece
    of paper—the parameter—as shown in [figure 13.3](kindle_split_030_split_000.html#ch13fig03).
    The argument doesn’t have to be a variable; it can be any expression of an appropriate
    type.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这种值复制正是当你调用方法时值参数所发生的情况；方法参数的*值*被复制到一张新的纸上——参数，如图13.3[所示](kindle_split_030_split_000.html#ch13fig03)。参数不必是变量；它可以是一个适当类型的任何表达式。
- en: 'Figure 13.3\. Calling a method with value parameters: the parameters are new
    variables that start with the values of the arguments.'
  id: totrans-874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.3\. 使用值参数调用方法：参数是新的变量，它们从参数的值开始。
- en: '![](../Images/13fig03_alt.jpg)'
  id: totrans-875
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3](../Images/13fig03_alt.jpg)'
- en: 'A ref parameter behaves differently, as shown in [figure 13.4](kindle_split_030_split_000.html#ch13fig04).
    Instead of acting as a new piece of paper, a reference parameter requires the
    caller to provide an existing piece of paper, not just an initial value. You can
    think of it as a piece of paper with two names written on it: the one the calling
    code uses to identify it and the parameter name.'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: ref参数的行为不同，如图13.4[所示](kindle_split_030_split_000.html#ch13fig04)。它不是作为一张新纸来使用，而是要求调用者提供一个现有的纸张，而不仅仅是初始值。你可以把它想象成一张写有两个名字的纸：一个是调用代码用来识别它的名字，另一个是参数的名字。
- en: Figure 13.4\. A ref parameter uses the same piece of paper rather than creating
    a new one with a copy of the value.
  id: totrans-877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.4\. ref参数使用相同的纸张，而不是用值的副本创建新的纸张。
- en: '![](../Images/13fig04_alt.jpg)'
  id: totrans-878
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4](../Images/13fig04_alt.jpg)'
- en: If the method modifies the value of the ref parameter, thereby changing what’s
    written on the paper, then when the method returns, that change is visible to
    the caller because it’s on the original piece of paper.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该方法修改了ref参数的值，从而改变了纸上写的内容，那么当方法返回时，这种变化对调用者来说是可见的，因为它是在原始的纸张上。
- en: '|  |'
  id: totrans-880
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-881
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are different ways of thinking about ref parameters and variables. You
    may read other authors who treat ref parameters as entirely separate variables
    that just have an automatic layer of indirection so that any access to the ref
    parameter follows the indirection first. That’s closer to what the IL represents,
    but I find it less helpful.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ref参数和变量的思考方式有很多种。你可能读过其他作者将ref参数视为完全独立的变量，这些变量只是有一个自动的间接层，以便任何对ref参数的访问都首先遵循间接层。这更接近于IL所表示的内容，但我发现它不太有帮助。
- en: '|  |'
  id: totrans-883
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: There’s no requirement that each ref parameter uses a different piece of paper.
    The following listing provides a somewhat extreme example, but it’s good for checking
    your understanding before moving on to ref locals.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 没有要求每个ref参数使用不同的纸。下面的列表提供了一个相当极端的例子，但在你继续学习ref局部变量之前检查你的理解是很好的。
- en: Listing 13.1\. Using the same variable for multiple ref parameters
  id: totrans-885
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1\. 使用相同的变量作为多个ref参数
- en: '[PRE111]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The output here is 12: `x`, `p1`, `p2` all represent the same piece of paper.
    It starts with a value of 5; `p1++` increments it to 6, and `p2 *= 2` doubles
    it to 12\. [Figure 13.5](kindle_split_030_split_000.html#ch13fig05) shows a graphical
    representation of the variables involved.'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出是 12：`x`、`p1`、`p2`都代表同一张纸。它从值 5 开始；`p1++`将其递增到 6，而`p2 *= 2`将其加倍到 12。图 13.5
    [Figure 13.5](kindle_split_030_split_000.html#ch13fig05) 展示了涉及的变量的图形表示。
- en: Figure 13.5\. Two ref parameters referring to the same piece of paper
  id: totrans-888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.5\. 两个ref参数指向同一张纸
- en: '![](../Images/13fig05.jpg)'
  id: totrans-889
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/13fig05.jpg)'
- en: 'A common way of talking about this is *aliasing*: in the preceding example,
    the variables `x`, `p1`, and `p2` are all *aliases* for the same storage location.
    They’re different ways of getting to the same piece of memory.'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个话题的一种常见说法是*别名*：在上面的例子中，变量`x`、`p1`和`p2`都是同一存储位置的*别名*。它们是到达同一内存的不同方式。
- en: Apologies if this seems long-winded and old hat. You’re now ready to move on
    to the genuinely new features of C# 7\. With the mental model of variables as
    pieces of paper, understanding the new features will be much easier.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来冗长且陈旧，那么你现在可以继续学习C# 7的真正新特性了。有了将变量视为纸张的心理模型，理解新特性将会容易得多。
- en: 13.2\. Ref locals and ref returns
  id: totrans-892
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. Ref局部变量和ref返回值
- en: Many of the ref-related C# 7 features are interconnected, which makes it harder
    to understand the benefits when you see them one at a time. While I’m describing
    the features, the examples will be even more contrived than normal, as they try
    to demonstrate just a single point at a time. The first two features you’ll look
    at are the ones introduced in C# 7.0, although even they were enhanced in C# 7.2\.
    First up, ref locals.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 许多与ref相关的C# 7特性是相互关联的，这使得当你一次看到它们时，理解它们的优点变得更加困难。当我在描述这些特性时，示例将比正常情况下更加牵强，因为它们试图一次只证明一个点。你将首先查看的是在C#
    7.0中引入的特性，尽管它们在C# 7.2中得到了增强。首先是ref局部变量。
- en: 13.2.1\. Ref locals
  id: totrans-894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1\. Ref局部变量
- en: 'Let’s continue our earlier analogy: ref parameters allow a piece of paper to
    be shared between variables in two methods. The same piece of paper used by the
    caller is the one that the method uses for the parameter. Ref locals take that
    idea one step further by allowing you declare a new local variable that shares
    the same piece of paper as an existing variable.'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续之前的类比：ref参数允许在两个方法之间共享一张纸。调用者使用的同一张纸就是方法使用的参数。ref局部变量通过允许你声明一个新的局部变量，该变量与现有变量共享同一张纸，将这个想法进一步发展。
- en: The following listing shows a trivial example of this, incrementing twice via
    different variables and then showing the result. Note that you have to use the
    `ref` keyword in both the declaration and in the initializer.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了这样一个简单的例子，通过不同的变量进行两次递增，然后显示结果。请注意，你必须在声明和初始化时都使用`ref`关键字。
- en: Listing 13.2\. Incrementing twice via two variables
  id: totrans-897
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2\. 通过两个变量进行两次递增
- en: '[PRE112]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This prints 12, just as if you’d incremented `x` twice.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 这会输出 12，就像你两次递增`x`一样。
- en: Any expression of the appropriate type that’s classified as a variable can be
    used to initialize a ref local, including array elements. If you have an array
    of large mutable value types, this can avoid unnecessary copy operations in order
    to make multiple changes. The following listing creates an array of tuples and
    then modifies both items within each array element without copying.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 任何被分类为变量的适当类型的表达式都可以用来初始化一个ref局部变量，包括数组元素。如果你有一个包含大可变值类型的数组，这可以避免不必要的复制操作，以便进行多次更改。下面的列表创建了一个元组数组，然后修改了每个数组元素中的两个项目，而不进行复制。
- en: Listing 13.3\. Modifying array elements using ref local
  id: totrans-901
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3\. 使用ref局部变量修改数组元素
- en: '[PRE113]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '***1* Initializes the array with (0, 0), (1, 1), and so on**'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 初始化数组为 (0, 0), (1, 1)，依此类推**'
- en: '***2* For each element of the array, increments x and doubles y**'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对于数组的每个元素，递增x并加倍y**'
- en: 'Before ref locals, there would’ve been two alternatives to modify the array.
    You could use either multiple array access expressions such as the following:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ref locals 之前，修改数组有两种选择。你可以使用多个数组访问表达式，如下所示：
- en: '[PRE114]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Or you could copy the whole tuple out of the array, modify it, and then copy
    it back:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将整个元组从数组中复制出来，修改它，然后再复制回去：
- en: '[PRE115]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Neither of these is particularly appealing. The ref local approach expresses
    our aim of working with an array element as a normal variable for the body of
    the loop.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都不太吸引人。ref local 方法表达了我们的目标，即在工作循环体中将数组元素作为普通变量处理。
- en: Ref locals can also be used with fields. The behavior for a static field is
    predictable, but the behavior for instance fields may surprise you. Consider the
    following listing, which creates a ref local to alias a field in one instance
    via a variable (`obj`) and then changes the value of `obj` to refer to a different
    instance.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: Ref locals 也可以与字段一起使用。静态字段的行怍是可预测的，但实例字段的行怍可能会让你感到惊讶。考虑以下列表，它创建一个 ref local
    来通过变量 (`obj`) 别名一个实例的字段，然后更改 `obj` 的值以指向不同的实例。
- en: Listing 13.4\. Aliasing the field of a specific object by using ref local
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.4\. 通过 ref local 修改特定对象的字段别名
- en: '[PRE116]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '***1* Creates an instance of RefLocalField**'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建 RefLocalField 的实例**'
- en: '***2* Declares a ref local variable referring to the field of the first instance**'
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明一个 ref local 变量，它引用第一个实例的字段**'
- en: '***3* Assigns a new value to ref local**'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将新值赋给 ref local**'
- en: '***4* Demonstrates that this has modified the field**'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 证明了这已经修改了字段**'
- en: '***5* Reassigns the obj variable to refer to a second instance of RefLocalField**'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将 obj 变量重新赋值以指向 RefLocalField 的第二个实例**'
- en: '***6* Demonstrates that tmp still uses the field in the first instance**'
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 证明了 tmp 仍然使用第一个实例的字段**'
- en: '***7* Demonstrates that the value of the field in the second instance really
    is 0**'
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 证明了第二个实例的字段值确实是 0**'
- en: 'The output is shown here:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE117]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The possibly surprising line is the middle one. It demonstrates that using `tmp`
    isn’t the same as using `obj.value` each time. Instead, `tmp` acts as an alias
    for the field expressed as `obj.value` at the point of initialization. [Figure
    13.6](kindle_split_030_split_000.html#ch13fig06) shows a snapshot of the variables
    and objects involved at the end of the `Main` method.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 可能令人惊讶的行是中间的那一行。它表明使用 `tmp` 并不等于每次都使用 `obj.value`。相反，`tmp` 在初始化点充当 `obj.value`
    表达的字段的别名。[图 13.6](kindle_split_030_split_000.html#ch13fig06) 显示了在 `Main` 方法末尾涉及的变量和对象快照。
- en: Figure 13.6\. At the end of [listing 13.4](kindle_split_030_split_000.html#ch13ex04),
    the tmp variable refers to a field in the first instance created, whereas the
    value of obj refers to a different instance.
  id: totrans-923
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.6\. 在 [列表 13.4](kindle_split_030_split_000.html#ch13ex04) 的末尾，tmp 变量指向第一个创建的实例中的字段，而
    obj 的值指向不同的实例。
- en: '![](../Images/13fig06_alt.jpg)'
  id: totrans-924
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13fig06_alt.jpg)'
- en: As a corollary of this, the `tmp` variable will prevent the first instance from
    being garbage collected until after the last use of `tmp` in the method. Similarly,
    using a ref local for an array element stops the array containing that element
    from being garbage collected.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此的推论，`tmp` 变量将防止第一个实例在方法中 `tmp` 的最后使用之后被垃圾收集。同样，使用 ref local 对数组元素会阻止包含该元素的数组被垃圾收集。
- en: '|  |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A ref variable that refers to a field within an object or an array element makes
    life harder for the garbage collector. It has to work out which object the variable
    is part of and keep that object alive. Regular object references are simpler because
    they directly identify the object involved. Each ref variable that refers to a
    field in an object introduces an *interior pointer* into a data structure maintained
    by the garbage collector. It’d be expensive to have a lot of these present concurrently,
    but ref variables can occur only on the stack, which makes it less likely that
    there’ll be enough to cause performance issues.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 指向对象内部字段或数组元素的 ref 变量会让垃圾收集器的工作变得更困难。它必须确定变量属于哪个对象，并保持该对象存活。常规对象引用更简单，因为它们直接标识了涉及的对象。每个指向对象中字段的
    ref 变量都会在垃圾收集器维护的数据结构中引入一个 *内部指针*。同时存在大量这些指针会非常昂贵，但 ref 变量只能出现在栈上，这使得不太可能出现足够的
    ref 变量导致性能问题。
- en: '|  |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Ref locals do have a few restrictions around their use. Most of them are obvious
    and won’t get in your way, but it’s worth knowing them just so you don’t experiment
    to try to work around them.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 引用局部变量在其使用上确实有一些限制。其中大部分都很明显，不会妨碍你，但了解它们仍然值得，这样你就不会尝试去规避它们。
- en: 'Initialization: Once, only once, and at declaration (before C# 7.3)'
  id: totrans-931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始化：一旦，仅一次，且在声明时（在C# 7.3之前）
- en: 'Ref locals always have to be initialized at the point of declaration. For example,
    the following code is invalid:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 引用局部变量必须在声明点进行初始化。例如，以下代码是无效的：
- en: '[PRE118]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Likewise, there’s no way to change a ref local to alias a different variable.
    (In our model terms, you can’t rub the name off and then write it on a different
    piece of paper.) Of course, the same variable can effectively be declared several
    times; for example, in [listing 13.3](kindle_split_030_split_000.html#ch13ex03),
    you declared the element variable in a loop:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，没有方法可以将引用局部变量更改为别名不同的变量。（在我们的模型术语中，你不能擦掉名字然后写在另一张纸上。）当然，同一个变量可以有效地声明多次；例如，在[列表13.3](kindle_split_030_split_000.html#ch13ex03)中，你在循环中声明了`element`变量：
- en: '[PRE119]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: On each iteration of the loop, `element` will alias a different array element.
    But that’s okay, because it’s effectively a new variable on each iteration.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的每次迭代中，`element`将别名不同的数组元素。但这没关系，因为它在每次迭代中实际上是一个新变量。
- en: 'The variable used to initialize the ref local has to be definitely assigned,
    too. You might expect the variables to share definite assignment status, but rather
    than making the definite assignment rules even more complicated, the language
    designers ensured that ref locals are always definitely assigned. Here’s an example:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 用于初始化引用局部变量的变量也必须是已确定的。你可能期望这些变量共享确定的赋值状态，但为了不使确定的赋值规则更加复杂，语言设计者确保引用局部变量始终是已确定的。以下是一个例子：
- en: '[PRE120]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '***1* Invalid, as x isn’t definitely assigned**'
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效，因为x没有确定的赋值**'
- en: This code doesn’t try to read from any variable until everything is definitely
    assigned, but it’s still invalid.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在尝试从任何变量读取之前不会尝试读取，但它仍然无效。
- en: 'C# 7.3 lifts the restriction on reassignment, but ref locals still have to
    be initialized at the point of declaration using a definitely assigned variable.
    For example:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.3取消了重新赋值的限制，但引用局部变量仍然必须在声明点使用已确定的变量进行初始化。例如：
- en: '[PRE121]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '***1* Valid only in C# 7.3**'
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 仅在C# 7.3中有效**'
- en: '***2* Prints x = 11, y = 21**'
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印 x = 11, y = 21**'
- en: I urge a degree of caution around using this feature anyway. If you need the
    same ref variable to refer to different variables over the course of a method,
    I suggest at least trying to refactor the method to be simpler.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 我敦促在使用此功能时要谨慎。如果你需要在方法执行过程中让同一个引用变量指向不同的变量，我建议至少尝试重构方法以使其更简单。
- en: No ref fields, or local variables that would live beyond the method call
  id: totrans-946
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 没有引用字段，或会在方法调用后继续存在的局部变量
- en: Although a ref local can be initialized using a field, you can’t declare a field
    using `ref`. This is one aspect of protecting against having a ref variable that
    acts like an alias for another variable with a shorter lifetime. It’d be problematic
    if you could create an object with a field that aliased a local variable in a
    method; what would happen to that field after the method had returned?
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用字段来初始化引用局部变量，但你不能使用`ref`来声明字段。这是防止引用变量像别名一样指向具有更短生命周期的另一个变量的一个方面。如果你可以创建一个具有别名方法中局部变量的字段的对象，那么在方法返回后该字段会发生什么？
- en: 'The same concern around lifetimes extends to local variables in three cases:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 与生命周期相关的相同问题也适用于三种情况下的局部变量：
- en: Iterator blocks can’t contain ref locals.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代块不能包含引用局部变量。
- en: Async methods can’t contain ref locals.
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步方法不能包含引用局部变量。
- en: Ref locals can’t be captured by anonymous methods or local methods. (Local methods
    are described in [chapter 14](kindle_split_031_split_000.html#ch14).)
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用局部变量不能被匿名方法或局部方法捕获。（局部方法在[第14章](kindle_split_031_split_000.html#ch14)中描述。）
- en: These are all cases where local variables can live beyond the original method
    call. At times, the compiler could potentially prove that it wouldn’t cause a
    problem, but the language rules have been chosen for simplicity. (One simple example
    of this is a local method that’s only called by the containing method rather than
    being used in a method group conversion.)
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是局部变量可以超出原始方法调用范围的情况。有时，编译器可能会证明这不会引起问题，但语言规则被选择为了简单性。（一个简单的例子是，一个仅由包含方法调用的局部方法，而不是在方法组转换中使用的方法。）
- en: No references to read-only variables
  id: totrans-953
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不可引用只读变量
- en: 'Any ref local variable introduced in C# 7.0 is writable; you can write a new
    value on the piece of paper. That causes a problem if you try to initialize the
    ref local by using a piece of paper that isn’t writable. Consider this attempt
    to violate the `readonly` modifier:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0中引入的任何ref局部变量都是可写的；你可以在纸上写一个新的值。如果你尝试使用不可写的纸来初始化ref局部变量，这就会引起问题。考虑以下违反`readonly`修饰符的尝试：
- en: '[PRE122]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '***1* Aliases a writable field**'
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将可写字段重命名**'
- en: '***2* Attempts to alias a readonly field**'
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 尝试重命名只读字段**'
- en: '***3* Increments both variables**'
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 同时增加两个变量**'
- en: If this were valid, all the reasoning we’ve built up over the years about read-only
    fields would be lost. Fortunately, that isn’t the case; the compiler prevents
    the assignment to `y` just as it would prevent any direct modification of `readonlyField`.
    But this code would be valid in the constructor for the `MixedVariables` class,
    because in that situation you’d be able to write directly to `readonlyField` as
    well. In short, you can initialize a ref local only in a way that aliases a variable
    you’d be able to write to in other situations. This matches the behavior from
    C# 1.0 onward for using fields as arguments for ref parameters.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是有效的，那么我们多年来关于只读字段的推理都将丢失。幸运的是，情况并非如此；编译器会阻止对`y`的赋值，就像它会阻止对`readonlyField`的任何直接修改一样。但这段代码在`MixedVariables`类的构造函数中是有效的，因为在那种情况下，你也能直接写入`readonlyField`。简而言之，你只能以其他情况下可以写入变量的方式初始化ref局部变量。这与从C#
    1.0开始的将字段用作ref参数的参数的行为相匹配。
- en: This restriction can be frustrating if you want to take advantage of the sharing
    aspect of ref locals without the writable aspect. In C# 7.0, that’s a problem;
    but you’ll see in [section 13.2.4](kindle_split_030_split_000.html#ch13lev2sec4)
    that C# 7.2 offers a solution.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想利用ref局部变量的共享特性而不需要可写特性，这种限制可能会让你感到沮丧。在C# 7.0中，这是一个问题；但你在[第13.2.4节](kindle_split_030_split_000.html#ch13lev2sec4)中会看到C#
    7.2提供了一个解决方案。
- en: 'Types: Only identity conversions are permitted'
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型：仅允许身份转换
- en: The type of the ref local either has to be the same as the type of the variable
    it’s being initialized with or there has to be an identity conversion between
    the two types. Any other conversion—even reference conversions that are allowed
    in many other scenarios—aren’t enough. The following listing shows an example
    of a ref local declaration using a tuple-based identity conversion that you learned
    about in [chapter 11](kindle_split_028_split_000.html#ch11).
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: ref局部变量的类型必须与其初始化时使用的变量的类型相同，或者两者之间必须有身份转换。任何其他转换——甚至是在许多其他场景中允许的引用转换——都不够。以下列表展示了使用基于元组的身份转换的ref局部变量声明示例，这是你在[第11章](kindle_split_028_split_000.html#ch11)中学到的。
- en: '|  |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: See [section 11.3.3](kindle_split_028_split_000.html#ch11lev2sec6) for a reminder
    on identity conversions.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 有关身份转换的提醒，请参阅[第11.3.3节](kindle_split_028_split_000.html#ch11lev2sec6)。
- en: '|  |'
  id: totrans-966
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 13.5\. Identity conversion in ref local declaration
  id: totrans-967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.5\. ref局部变量声明中的身份转换
- en: '[PRE123]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This prints 30, as `tuple1` and `tuple2` share the same storage location; `tuple1.x`
    and `tuple2.a` are equivalent to each other, as are `tuple1.y` and `tuple2.b`.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出30，因为`tuple1`和`tuple2`共享相同的存储位置；`tuple1.x`和`tuple2.a`彼此等价，同样`tuple1.y`和`tuple2.b`也彼此等价。
- en: 'In this section, you’ve looked at initializing ref locals from local variables,
    fields, and array elements. A new kind of expression is categorized as a variable
    in C# 7: the variable returned by a ref return method.'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经看到了从局部变量、字段和数组元素初始化ref局部变量的方法。在C# 7中，一种新的表达式类型被归类为变量：由ref返回方法返回的变量。
- en: 13.2.2\. Ref returns
  id: totrans-971
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2\. Ref返回
- en: In some ways, it should be easy to understand ref returns. Using our previous
    model, it’s the idea that a method can return a piece of paper instead of a value.
    You need to add the `ref` keyword to the return type and to any return statement.
    The calling code will often declare a ref local to receive the return value, too.
    This means you have to sprinkle the `ref` keyword pretty liberally in your code
    to make it very clear what you’re trying to do. The following listing shows about
    the simplest possible use of ref return; the `RefReturn` method returns whatever
    variable was passed into it.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，理解ref返回应该很容易。使用我们之前的模型，这是一个方法可以返回一张纸而不是一个值的概念。你需要将`ref`关键字添加到返回类型和任何返回语句中。调用代码通常会声明一个局部ref来接收返回值。这意味着你必须在代码中广泛地使用`ref`关键字，以使其非常清楚你试图做什么。以下列表显示了关于最简单的ref返回使用；`RefReturn`方法返回传递给它的任何变量。
- en: Listing 13.6\. Simplest possible ref return demonstration
  id: totrans-973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.6\. 最简单的ref返回演示
- en: '[PRE124]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This prints 11, because `x` and `y` are on the same piece of paper, just as
    if you’d written
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印11，因为`x`和`y`在同一张纸上，就像你写了
- en: '[PRE125]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The method is essentially an identity function just to show the syntax. It could’ve
    been written as an expression-bodied method, but I wanted to make the return part
    clear.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法本质上是一个恒等函数，只是为了展示语法。它也可以写成表达式主体方法，但我想要使返回部分清晰。
- en: So far, so simple, but a lot of details get in the way, mostly because the compiler
    makes sure that any piece of paper that’s returned is still going to exist when
    the method has finished returning. It can’t be a piece of paper that was created
    in the method.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很简单，但很多细节都被阻碍了，主要是因为编译器确保任何返回的纸张在方法返回完成后仍然存在。它不能是方法中创建的纸张。
- en: To put this in implementation terms, a method can’t return a storage location
    that it’s just created on the stack, because when the stack is popped, the storage
    location won’t be valid anymore. When describing how the C# language works, Eric
    Lippert is fond of saying that the stack is an implementation detail (see [http://mng.bz/oVvZ](http://mng.bz/oVvZ)).
    In this case, it’s an implementation detail that leaks into the language. The
    restrictions are for the same reasons that ref fields are prohibited, so if you
    feel you understand one of these, you can apply the same logic to the other.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 用实现术语来说，一个方法不能返回它刚刚在栈上创建的存储位置，因为当栈弹出时，该存储位置将不再有效。在描述C#语言的工作方式时，埃里克·利普特喜欢说栈是一个实现细节（见[http://mng.bz/oVvZ](http://mng.bz/oVvZ)）。在这种情况下，这是一个泄漏到语言中的实现细节。这些限制的原因与为什么不允许ref字段相同，所以如果你觉得你理解了其中之一，你可以将相同的逻辑应用到另一个上。
- en: 'I won’t go into an exhaustive list of every kind of variable that can and can’t
    be returned using ref return, but here are the most common examples:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详尽无遗地列出可以使用ref返回返回和不能返回的每种类型的变量，但这里有一些最常见的例子：
- en: Valid
  id: totrans-981
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 有效
- en: '`ref` or `out` parameters'
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`或`out`参数'
- en: Fields of reference types
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型字段
- en: Fields of structs where the struct variable is a `ref` or `out` parameter
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构变量字段，其中结构变量是`ref`或`out`参数
- en: Array elements
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组元素
- en: Invalid
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无效
- en: Local variables declared in the method (including value parameters)
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法中声明的局部变量（包括值参数）
- en: Fields of struct variables declared in the method
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法中声明的结构变量字段
- en: In addition to these restrictions on what can and can’t be returned, ref return
    is entirely invalid in async methods and iterator blocks. Similar to pointer types,
    you can’t use the `ref` modifier in a type argument, although it can appear in
    interface and delegate declarations. For example, this is entirely valid
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些关于可以和不能返回的限制之外，ref返回在异步方法和迭代块中完全无效。与指针类型类似，你无法在类型参数中使用`ref`修饰符，尽管它可以出现在接口和委托声明中。例如，这是完全有效的
- en: '[PRE126]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: But you couldn’t get the same result by trying to refer to `Func<ref int>`.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 但通过尝试引用`Func<ref int>`，你无法得到相同的结果。
- en: Ref return doesn’t have to be used with a ref local. If you want to perform
    a single operation on the result, you can do that directly. The following listing
    shows this using the same code as [listing 13.6](kindle_split_030_split_000.html#ch13ex06)
    but without the ref local.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: Ref返回不必与ref局部一起使用。如果你想对结果执行单个操作，你可以直接这样做。以下列表显示了这一点，使用与[列表13.6](kindle_split_030_split_000.html#ch13ex06)相同的代码，但没有ref局部。
- en: Listing 13.7\. Incrementing the result of a ref return directly
  id: totrans-993
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.7\. 直接增加ref返回的结果
- en: '[PRE127]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '***1* Increments the returned variable directly**'
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 直接增加返回变量的值**'
- en: 'Again, this is equivalent to incrementing `x`, so the output is 11\. In addition
    to modifying the resulting variable, you can use it as a `ref` argument to another
    method. To make our already purely demonstrative example even sillier, you could
    call `RefReturn` with the result of itself (twice):'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这相当于递增 `x`，所以输出是 11。除了修改结果变量外，您还可以将其用作另一个方法的 `ref` 参数。为了使我们的纯粹演示性示例更加荒谬，您甚至可以调用
    `RefReturn` 并使用其结果（两次）：
- en: '[PRE128]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Ref returns are valid for indexers as well as methods. This is most commonly
    useful to return an array element by reference, as shown in the following listing.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: Ref 返回对索引器和方法都有效。这通常最有用，如以下列表所示，通过引用返回数组元素。
- en: Listing 13.8\. A ref return indexer exposing array elements
  id: totrans-999
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.8\. 通过引用返回数组元素的 ref 返回索引器
- en: '[PRE129]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '***1* Indexer returns an array element by reference**'
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 索引器通过引用返回数组元素**'
- en: '***2* Declares two ref locals referring to the same array element**'
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明两个 ref 本地变量，它们引用相同的数组元素**'
- en: '***3* Changes the array element value via x**'
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过 x 改变数组元素的值**'
- en: '***4* Observes the change via y**'
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 通过 y 观察变化**'
- en: 'You’ve now covered all the new features in C# 7.0, but later point releases
    expanded the set of ref-related features. The first feature was one I was quite
    frustrated by when writing my initial draft of this chapter: lack of conditional
    `?:` operator support.'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经涵盖了 C# 7.0 中所有的新特性，但后续的版本发布扩展了与 ref 相关的特性集。第一个特性是我最初撰写本章初稿时相当沮丧的一个：缺乏条件
    `?:` 运算符的支持。
- en: '13.2.3\. The conditional ?: operator and ref values (C# 7.2)'
  id: totrans-1006
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '13.2.3\. 条件运算符 ?: 和 ref 值（C# 7.2）'
- en: 'The conditional `?:` operator has been present since C# 1.0 and is familiar
    from other languages:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符 `?:` 自 C# 1.0 版本以来就存在，并且在其他语言中也很常见：
- en: '[PRE130]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: It evaluates its first operand (the condition), and then evaluates either the
    second or third operand to provide the overall result. It feels natural to want
    to achieve the same thing with ref values, picking one or another variable based
    on a condition.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 它评估其第一个操作数（条件），然后评估第二个或第三个操作数以提供整体结果。使用 ref 值来实现相同的事情感觉很自然，根据条件选择一个或另一个变量。
- en: With C# 7.0, this wasn’t feasible, but it is in C# 7.2\. A conditional operator
    can use ref values for the second and third operands, at which point the result
    of the conditional operator is also a variable that can be used with the `ref`
    modifier. As an example, the following listing shows a method that counts the
    even and odd values in a sequence, returning the result as a tuple.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 7.0，这是不可行的，但在 C# 7.2 中可以。条件运算符可以使用 ref 值作为第二个和第三个操作数，此时条件运算符的结果也是一个可以用作
    `ref` 修饰符的变量。以下列表显示了一个方法，它计算序列中的偶数和奇数值，并将结果作为元组返回。
- en: Listing 13.9\. Counting even and odd elements in a sequence
  id: totrans-1011
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.9\. 在序列中计算偶数和奇数元素
- en: '[PRE131]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '***1* Picks the appropriate variable to increment**'
  id: totrans-1013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 选择合适的变量进行递增**'
- en: '***2* Increments it**'
  id: totrans-1014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 递增它**'
- en: 'The use of a tuple here is somewhat coincidental, although it serves to demonstrate
    how useful it is for tuples to be mutable. This addition makes the language feel
    much more consistent. The result of the conditional operator can be used as an
    argument to a ref parameter, assigned to a ref local, or used in a ref return.
    It all just drops out nicely. The next C# 7.2 feature addresses an issue you looked
    at in [section 13.2.1](kindle_split_030_split_000.html#ch13lev2sec1) when discussing
    the restrictions on ref locals: how do you take a reference to a read-only variable?'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用元组有些偶然，尽管它有助于展示元组可变性的有用性。这一添加使语言感觉更加一致。条件运算符的结果可以用作 ref 参数的参数，分配给 ref 本地变量，或用于
    ref 返回。这一切都自然而然地发生了。下一个 C# 7.2 特性解决了一个您在 [第 13.2.1 节](kindle_split_030_split_000.html#ch13lev2sec1)
    中讨论 ref 本地变量限制时考虑的问题：如何获取只读变量的引用？
- en: 13.2.4\. Ref readonly (C# 7.2)
  id: totrans-1016
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.4\. Ref readonly（C# 7.2）
- en: 'So far, all the variables you’ve been aliasing have been writable. In C# 7.0,
    that’s all that’s available. But that’s insufficient in two parallel scenarios:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您所别名的所有变量都是可写的。在 C# 7.0 中，这仅是可用的。但在两个并行场景中，这还不够：
- en: You may want to alias a read-only field for the sake of efficiency to avoid
    copying.
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提高效率，您可能希望将只读字段别名为 ref，以避免复制。
- en: You may want to allow only read-only access via the ref variable.
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能希望仅通过 ref 变量允许只读访问。
- en: The introduction of `ref readonly` in C# 7.2 addresses both scenarios. Both
    ref locals and ref returns can be declared with the `readonly` modifier, and the
    result is read-only, just like a read-only field. You can’t assign a new value
    to the variable, and if it’s a struct type, you can’t modify any fields or call
    property setters.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref readonly` 在 C# 7.2 中的引入解决了这两个场景。ref 局部和 ref 返回都可以用 `readonly` 修饰符声明，结果是只读的，就像只读字段一样。你不能给变量赋新值，如果它是结构体类型，你不能修改任何字段或调用属性设置器。'
- en: '|  |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-1022
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Given that one of the reasons for using `ref readonly` is to avoid copying,
    you could be surprised to hear that sometimes it has the opposite effect. You’ll
    look at this in detail in [section 13.4](kindle_split_030_split_000.html#ch13lev1sec4).
    Don’t start using `ref readonly` in your production code without reading that
    section!
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 `ref readonly` 的一个原因是为了避免复制，你可能会惊讶地听到有时它会产生相反的效果。你将在 [第 13.4 节](kindle_split_030_split_000.html#ch13lev1sec4)
    中详细了解这一点。在没有阅读该部分的情况下，不要在生产代码中使用 `ref readonly`！
- en: '|  |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The two places you can put the modifier work together: if you call a method
    or indexer with a `ref readonly` return and want to store the result in a local
    variable, it has to be a `ref readonly` local variable, too. The following listing
    shows how the read-only aspects chain together.'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以放置修饰符的两个地方协同工作：如果你用一个 `ref readonly` 返回值调用一个方法或索引器，并且想在局部变量中存储结果，那么这个局部变量也必须是
    `ref readonly` 的。以下列表展示了只读方面是如何连锁在一起的。
- en: Listing 13.10\. `ref readonly` return and local
  id: totrans-1026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.10\. `ref readonly` 返回和局部变量
- en: '[PRE132]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '***1* Initializes a read-only field with an arbitrary value**'
  id: totrans-1028
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用任意值初始化只读字段**'
- en: '***2* Returns a read-only alias to the field**'
  id: totrans-1029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回字段的只读别名**'
- en: '***3* Initializes a read-only ref local using the method**'
  id: totrans-1030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用方法初始化只读引用局部变量**'
- en: This works with indexers, too, and it allows immutable collections to expose
    their data directly without any copying but without any risk of the memory being
    mutated. Note that you can return a `ref readonly` without the underlying variable
    being read-only, which provides a read-only view over an array, much like `ReadOnlyCollection`
    does for arbitrary collections but with copy-free read access. The following listing
    shows a simple implementation of this idea.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于索引器，并且它允许不可变集合直接暴露其数据，没有任何复制，也没有任何内存被突变的风险。请注意，你可以返回一个 `ref readonly`，即使底层变量不是只读的，这提供了一个对数组的只读视图，就像
    `ReadOnlyCollection` 对任意集合所做的那样，但具有无复制读取访问。以下列表展示了这个想法的简单实现。
- en: Listing 13.11\. A read-only view over an array with copy-free reads
  id: totrans-1032
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.11\. 对数组的只读视图，无复制读取
- en: '[PRE133]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '***1* Copies the array reference without cloning contents**'
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 复制数组引用而不克隆内容**'
- en: '***2* Returns a read-only alias to the array element**'
  id: totrans-1035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回数组元素的只读别名**'
- en: '***3* Modification to the array is visible via the local.**'
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过局部变量可见对数组的修改。**'
- en: This example isn’t compelling in terms of efficiency gains because `int` is
    already a small type, but in scenarios using larger structs to avoid excessive
    heap allocation and garbage collection, the benefits can be significant.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子在效率提升方面并不令人信服，因为 `int` 已经是一个小类型，但在使用较大的结构体以避免过多的堆分配和垃圾回收的场景中，好处可能是显著的。
- en: '|  |'
  id: totrans-1038
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Implementation details**'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现细节**'
- en: 'In IL, a `ref readonly` method is implemented as a regular ref-returning method
    (the return type is a by-ref type) but with `[InAttribute]` from the `System.Runtime.InteropServices`
    namespace applied to it. This attribute is, in turn, specified with the `modreq`
    modifier in IL: if a compiler isn’t aware of `InAttribute`, it should reject any
    call to the method. This is a safety mechanism to prevent misuse of the method’s
    return value. Imagine a C# 7.0 compiler (one that’s aware of `ref` returns but
    not `ref readonly` returns) trying to call a `ref readonly` returning method from
    another assembly. It could allow the caller to store the result in a writable
    ref local and then modify it, thereby violating the intention of the `ref readonly`
    return.'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IL 中，`ref readonly` 方法被实现为一个常规的返回引用的方法（返回类型是一个按引用类型），但应用了来自 `System.Runtime.InteropServices`
    命名空间的 `[InAttribute]` 属性。这个属性反过来在 IL 中用 `modreq` 修饰符指定：如果编译器不知道 `InAttribute`，它应该拒绝对该方法的任何调用。这是一个安全机制，以防止方法返回值的误用。想象一下，一个
    C# 7.0 编译器（一个知道 `ref` 返回但不了解 `ref readonly` 返回的编译器）尝试从一个其他程序集调用 `ref readonly`
    返回的方法。它可能允许调用者将结果存储在可写的引用局部变量中，然后修改它，从而违反了 `ref readonly` 返回的意图。
- en: You can’t declare `ref readonly` returning methods unless `InAttribute` is available
    to the compiler. That’s rarely an issue, because it’s been in the desktop framework
    since .NET 1.1 and in .NET Standard 1.1\. If you absolutely have to, you can declare
    your own attribute in the right namespace, and the compiler will use that.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能声明 `ref readonly` 返回方法，除非编译器可以使用 `InAttribute`。这很少是问题，因为它自从 .NET 1.1 以来就在桌面框架中，并且在
    .NET Standard 1.1 中。如果你绝对需要，你可以在正确的命名空间中声明自己的属性，编译器将使用它。
- en: '|  |'
  id: totrans-1042
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `readonly` modifier can be applied to local variables and return types as
    you’ve seen, but what about parameters? If you have a `ref readonly` local and
    want to pass it into a method without just copying the value, what are your options?
    You might expect the answer to be the `readonly` modifier again, just applied
    to parameters, but reality is slightly different, as you’ll see in the next section.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly` 修饰符可以应用于局部变量和返回类型，正如你所见，但对于参数呢？如果你有一个 `ref readonly` 局部变量，并且想要将其传递给一个方法而不只是复制其值，你有什么选择？你可能期望答案是再次使用
    `readonly` 修饰符，只是应用于参数，但现实略有不同，正如你将在下一节中看到的。'
- en: 13.3\. in parameters (C# 7.2)
  id: totrans-1044
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. `in` 参数（C# 7.2）
- en: C# 7.2 adds `in` as a new modifier for parameters in the same style as `ref`
    or `out` but with a different intention. When a parameter has the `in` modifier,
    the intention is that the method won’t change the parameter value, so a variable
    can be passed by reference to avoid copying. Within the method, an `in` parameter
    acts like a `ref readonly` local variable. It’s still an alias for a storage location
    passed by the caller, so it’s important that the method doesn’t modify the value;
    the caller would see that change, which goes against the point of it being an
    `in` parameter.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.2 添加了 `in` 作为参数的新修饰符，其风格与 `ref` 或 `out` 相同，但目的不同。当一个参数有 `in` 修饰符时，其意图是方法不会更改参数值，因此可以通过引用传递变量以避免复制。在方法内部，`in`
    参数的行为类似于 `ref readonly` 局部变量。它仍然是调用者传递的存储位置的别名，因此方法不修改值是很重要的；调用者会看到这种变化，这与 `in`
    参数的目的相悖。
- en: 'There’s a big difference between an `in` parameter and a `ref` or `out` parameter:
    the caller doesn’t have to specify the `in` modifier for the argument. If the
    `in` modifier is missing, the compiler will pass the argument by reference if
    the argument is a variable but take a copy of the value as a hidden local variable
    and pass that by reference if necessary. If the caller specifies the `in` modifier
    explicitly, the call is valid only if the argument can be passed by reference
    directly. The following listing shows all the possibilities.'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 参数与 `ref` 或 `out` 参数之间有很大的区别：调用者不需要为参数指定 `in` 修饰符。如果缺少 `in` 修饰符，编译器将根据参数是变量还是值来决定是否通过引用传递参数；如果参数是变量，则通过引用传递；如果需要，则将值作为隐藏的局部变量复制并传递。如果调用者明确指定
    `in` 修饰符，则调用有效仅当参数可以直接通过引用传递时。以下列表显示了所有可能性。'
- en: Listing 13.12\. Valid and invalid possibilities for passing arguments for `in`
    parameters
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.12\. 传递 `in` 参数时的有效和无效可能性
- en: '[PRE134]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '***1* Declares method with in parameter**'
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明具有 in 参数的方法**'
- en: '***2* Variable is passed by reference implicitly.**'
  id: totrans-1050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 变量隐式通过引用传递。**'
- en: '***3* Variable is passed by reference explicitly (due to in modifier).**'
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 显式通过引用传递变量（由于 in 修饰符）。**'
- en: '***4* Result is copied to hidden local variable, which is passed by reference.**'
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 结果被复制到隐藏的局部变量中，该变量通过引用传递。**'
- en: '***5* Compile-time error: argument can’t be passed by reference.**'
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 编译时错误：参数不能通过引用传递。**'
- en: In the generated IL, the parameter is equivalent to a ref parameter decorated
    with `[IsReadOnlyAttribute]` from the `System.Runtime.CompilerServices` name-space.
    This attribute was introduced much more recently than `InAttribute`; it’s in .NET
    4.7.1, but it’s not even in .NET Standard 2.0\. It’d be annoying to have to either
    add a dependency or declare the attribute yourself, so the compiler generates
    the attribute in your assembly automatically if it’s not otherwise available.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的 IL 中，该参数相当于一个带有 `[IsReadOnlyAttribute]` 的 `ref` 参数，该属性来自 `System.Runtime.CompilerServices`
    命名空间。这个属性比 `InAttribute` 更晚引入；它在 .NET 4.7.1 中，但甚至不在 .NET Standard 2.0 中。如果必须这样做，可以在正确的命名空间中声明自己的属性，编译器将使用该属性。
- en: The attribute doesn’t have the `modreq` modifier in IL; any C# compiler that
    doesn’t understand `IsReadOnlyAttribute` will treat it as a regular `ref` parameter.
    (The CLR doesn’t need to know about the attribute either.) Any callers recompiled
    with a later version of a compiler will suddenly fail to compile, because they’ll
    now require the `in` modifier instead of the `ref` modifier. That leads us to
    a bigger topic of backward compatibility.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性在 IL 中没有 `modreq` 修饰符；任何不理解 `IsReadOnlyAttribute` 的 C# 编译器都会将其视为常规的 `ref`
    参数。（CLR 也不需要了解该属性。）任何使用编译器后续版本重新编译的调用者将突然无法编译，因为他们现在需要 `in` 修饰符而不是 `ref` 修饰符。这引出了向后兼容性的一个更大话题。
- en: 13.3.1\. Compatibility considerations
  id: totrans-1056
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1\. 兼容性考虑
- en: 'The way that the `in` modifier is optional at the call site leads to an interesting
    backward-compatibility situation. Changing a method parameter from being a value
    parameter (the default, with no modifiers) to an `in` parameter is always *source*
    compatible (you should always be able to recompile without changing calling code)
    but is never *binary* compatible (any existing compiled assemblies calling the
    method will fail at execution time). Exactly what that means will depend on your
    situation. Suppose you want to change a method parameter to be an `in` parameter
    for an assembly that has already been released:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 修饰符在调用站点是可选的，这导致了一个有趣的向后兼容性问题。将方法参数从值参数（默认值，没有修饰符）更改为 `in` 参数始终是 *源* 兼容的（你应该总是能够在不更改调用代码的情况下重新编译）但永远不会
    *二进制* 兼容的（任何现有已编译的调用该方法的程序集将在执行时失败）。这具体意味着什么将取决于你的情况。假设你想要将一个方法参数更改为 `in` 参数，而这个程序集已经发布：'
- en: If your method is accessible to callers outside your control (if you’re publishing
    a library to NuGet, for example), this is a breaking change and should be treated
    like any other breaking change.
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的方法可以被你无法控制的调用者访问（例如，如果你正在将库发布到 NuGet），这是一个破坏性变更，应该像对待任何其他破坏性变更一样处理。
- en: If your code is accessible only to callers that will definitely be recompiled
    when they use the new version of your assembly (even if you can’t change that
    calling code), then this won’t break those callers.
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的代码只能被那些在使用你程序集的新版本时一定会重新编译的调用者访问（即使你无法更改调用代码），那么这不会破坏这些调用者。
- en: If your method is only internal to your assembly,^([[1](kindle_split_030_split_000.html#ch13fn1)])
    you don’t need to worry about binary compatibility because all the callers will
    be recompiled anyway.
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的方法仅限于你的程序集内部，^([[1](kindle_split_030_split_000.html#ch13fn1))) 你不需要担心二进制兼容性，因为所有调用者都会重新编译。
- en: ¹
  id: totrans-1061
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1062
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: If your assembly uses `InternalsVisibleTo`, the situation is more nuanced; that
    level of detail is beyond the scope of this book.
  id: totrans-1063
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你的程序集使用了 `InternalsVisibleTo`，情况会更加复杂；这种详细程度超出了本书的范围。
- en: 'Another slightly less likely scenario exists: if you have a method with a `ref`
    parameter purely for the sake of avoiding copying (you never modify the parameter
    in the method), changing that to an `in` parameter is always *binary* compatible,
    but never *source* compatible. That’s the exact opposite of changing a value parameter
    to an `in` parameter.'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个稍微不太可能的情况是：如果你有一个仅为了避免复制（你永远不会在方法中修改参数）而具有 `ref` 参数的方法，将其更改为 `in` 参数始终是 *二进制*
    兼容的，但永远不会 *源* 兼容的。这与将值参数更改为 `in` 参数正好相反。
- en: All of this assumes that the act of using an `in` parameter doesn’t break the
    semantics of the method itself. That’s not always a valid assumption; let’s see
    why.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都假设使用 `in` 参数的行为不会破坏方法本身的语义。这并不总是有效的假设；让我们看看原因。
- en: '13.3.2\. The surprising mutability of in parameters: External changes'
  id: totrans-1066
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2\. `in` 参数的意外可变性：外部更改
- en: So far, it sounds like if you don’t modify a parameter within a method, it’s
    safe to make it an `in` parameter. That’s not the case, and it’s a dangerous expectation.
    The compiler stops the *method* from modifying the parameter, but it can’t do
    anything about other code modifying it. You need to remember that an `in` parameter
    is an alias for a storage location that other code may be able to modify. Let’s
    look at a simple example first, which may seem utterly obvious.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，听起来如果你不修改方法内的参数，将其更改为 `in` 参数是安全的。但这并不是情况，而且这是一个危险预期。编译器阻止 *方法* 修改参数，但它无法阻止其他代码修改它。你需要记住，`in`
    参数是其他代码可能能够修改的存储位置的别名。让我们先看一个简单的例子，这可能会显得非常明显。
- en: Listing 13.13\. `in` parameter and value parameter differences in the face of
    side effects
  id: totrans-1068
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.13\. 面对副作用时 `in` 参数和值参数的差异
- en: '[PRE135]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The first two methods are identical except for the log message displayed and
    the nature of the parameter. In the `Main` method, you call the two methods in
    the same way, passing in a local variable with an initial value of 10 as the argument
    and an action that increments the variable. The output shows the difference in
    semantics:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个方法除了显示的日志消息和参数的性质外，都是相同的。在`Main`方法中，你以相同的方式调用这两个方法，传递一个初始值为10的局部变量作为参数和一个增加变量的操作。输出显示了语义上的差异：
- en: '[PRE136]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: As you can see, the `InParameter` method is able to observe the change caused
    by calling `action()`; the `ValueParameter` method isn’t. This isn’t surprising;
    `in` parameters are intended to share a storage location, whereas value parameters
    are intended to take a copy.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`InParameter`方法能够观察到调用`action()`引起的更改；`ValueParameter`方法则不能。这并不奇怪；`in`参数旨在共享存储位置，而值参数旨在获取副本。
- en: The problem is that although it’s obvious in this particular case because there’s
    so little code, in other examples it might not be. For example, the `in` parameter
    could happen to be an alias for a field in the same class. In that case, any modifications
    to the field, either directly in the method or by other code that the method calls,
    will be visible via the parameter. That isn’t obvious either in the calling code
    or the method itself. It gets even harder to predict what will happen when multiple
    threads are involved.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，尽管在这个特定情况下由于代码很少，所以很明显，但在其他例子中可能不是。例如，`in`参数可能恰好是同一类中字段的别名。在这种情况下，对字段的任何修改，无论是直接在方法中还是在方法调用的其他代码中，都将通过参数可见。这在调用代码或方法本身中也不明显。当涉及多个线程时，预测会发生什么变得更加困难。
- en: I’m deliberately being somewhat alarmist here, but I think this is a real problem.
    We’re used to highlighting the possibility of this sort of behavior^([[2](kindle_split_030_split_000.html#ch13fn2)])
    with ref parameters by specifying the modifier on the parameter and the argument.
    Additionally, the `ref` modifier feels like it’s implicitly concerned with how
    changes in a parameter are visible, whereas the `in` modifier is about *not* changing
    the parameter. In [section 13.3.4](kindle_split_030_split_000.html#ch13lev2sec8),
    I’ll give more guidance on using `in` parameters, but for the moment you should
    just be aware of the potential risk of the parameter changing its value unexpectedly.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里故意有些夸张，但我认为这是一个真正的问题。我们习惯于通过指定参数上的修饰符和参数来突出显示这种行为的可能性^([[2](kindle_split_030_split_000.html#ch13fn2)])。此外，`ref`修饰符感觉上与参数变化如何可见有关，而`in`修饰符则是关于*不*改变参数。在第[13.3.4节](kindle_split_030_split_000.html#ch13lev2sec8)中，我将提供更多关于使用`in`参数的指导，但在此期间，你应该只是意识到参数意外改变其值的潜在风险。
- en: ²
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I like to think of it as being similar to the quantum entanglement phenomenon
    known as “spooky action at a distance.”
  id: totrans-1077
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我喜欢把它想象成类似于量子纠缠现象中所谓的“遥远距离的神秘作用”。
- en: 13.3.3\. Overloading with in parameters
  id: totrans-1078
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.3\. 使用输入参数进行重载
- en: 'One aspect I haven’t touched on yet is method overloading: what happens if
    you want two methods with the same name and the same parameter type, but in one
    case the parameter is an `in` parameter and in the second method it’s not?'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有涉及到的一个方面是方法重载：如果你想要两个具有相同名称和相同参数类型的方法，但在一种情况下参数是`in`参数，而在第二种情况下不是，会发生什么？
- en: 'Remember that as far as the CLR is concerned, this is just another `ref` parameter.
    You can’t overload the method by just changing between `ref`, `out`, and `in`
    modifiers; they all look the same to the CLR. But you can overload an `in` parameter
    with a regular value parameter:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，就CLR而言，这只是一个另一个`ref`参数。你不能仅仅通过在`ref`、`out`和`in`修饰符之间切换来重载方法；它们对CLR来说看起来都一样。但你可以用常规值参数重载`in`参数：
- en: '[PRE137]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'New tiebreaker rules in overload resolution make the method with the value
    parameter better with respect to an argument that doesn’t have an `in` modifier:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 在重载解析中的新规则使具有值参数的方法在具有没有`in`修饰符的参数方面表现得更好：
- en: '[PRE138]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '***1* Call to first method**'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用第一个方法**'
- en: '***2* Call to first method**'
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用第一个方法**'
- en: '***3* Call to second method because of in modifier**'
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 由于输入修饰符调用第二个方法**'
- en: These rules allow you to add overloads for existing method names without too
    many compatibility concerns if the existing methods have value parameters and
    the new methods have in parameters.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则允许你在现有方法名称上添加重载，而无需过多考虑兼容性问题，如果现有方法具有值参数，而新方法具有输入参数。
- en: 13.3.4\. Guidance for in parameters
  id: totrans-1088
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.4\. 关于输入参数的指导
- en: 'Full disclosure: I haven’t used `in` parameters in real code yet. The guidance
    here is speculative.'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 完全坦白：我还没有在实际代码中使用过`in`参数。这里提供的指导是推测性的。
- en: The first thing to note is that `in` parameters are intended to improve performance.
    As a general principle, I wouldn’t start making any changes to your code to improve
    performance before you’ve *measured* performance in a meaningful and repeatable
    way and set goals for it. If you’re not careful, you can complicate your code
    in the name of optimization, only to find out that even if you massively improved
    the performance of one or two methods, those methods weren’t on a critical path
    for the application anyway. The exact goals you have will depend on the kind of
    code you’re writing (games, web applications, libraries, IoT applications, or
    something else), but careful measurement is important. For microbenchmarks, I
    recommend the BenchmarkDotNet project.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，`in`参数旨在提高性能。作为一个一般原则，在你以有意义和可重复的方式测量性能并为其设定目标之前，我不会开始对你的代码进行任何更改以改善性能。如果你不小心，你可能会以优化的名义使你的代码复杂化，结果发现即使你大幅提高了一个或两个方法的性能，但这些方法根本不是应用程序的关键路径。你具体的目标将取决于你正在编写的代码类型（游戏、Web应用程序、库、物联网应用程序或其他），但仔细的测量是非常重要的。对于微基准测试，我推荐BenchmarkDotNet项目。
- en: 'The benefit of `in` parameters lies in reducing the amount of data that needs
    to be copied. If you’re using only reference types or small structs, no improvement
    may occur at all; logically, the storage location still needs to be passed to
    the method, even if the value at that storage location isn’t being copied. I won’t
    make too many claims here because of the black box of JIT compilation and optimization.
    Reasoning about performance without testing it is a bad idea: enough complex factors
    are involved to turn that reasoning into an educated guess at best. I’d expect
    the benefits of `in` parameters to increase as the size of the structs involved
    increases, however.'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`参数的好处在于减少需要复制的数量。如果你只使用引用类型或小的结构体，可能根本不会发生任何改进；从逻辑上讲，存储位置仍然需要传递给方法，即使该存储位置中的值没有被复制。由于JIT编译和优化的黑盒性质，我不会在这里做出过多的断言。不测试就推理性能是一个坏主意：涉及到的复杂因素足够多，以至于这种推理最多只能是一个有根据的猜测。然而，我预计随着涉及的结构体大小的增加，`in`参数的好处也会增加。'
- en: My main concern about `in` parameters is that they can make reasoning about
    your code much harder. You can read the value of the same parameter twice and
    get different results, despite your method not changing anything, as you saw in
    [section 13.3.2](kindle_split_030_split_000.html#ch13lev2sec6). That makes it
    harder to write correct code and easy to write code that appears to be correct
    but isn’t.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 我对`in`参数的主要担忧是它们可以使你对代码的推理变得更加困难。你可以读取相同参数的值两次并得到不同的结果，尽管你的方法没有做任何改变，就像你在[第13.3.2节](kindle_split_030_split_000.html#ch13lev2sec6)中看到的那样。这使得编写正确的代码变得更加困难，并且容易编写看似正确但实际上不正确的代码。
- en: 'There’s a way to avoid this while still getting many of the benefits of `in`
    parameters, though: by carefully reducing or removing the possibilities of them
    changing. If you have a public API that’s implemented via a deep stack of private
    method calls, you can use a value parameter for that public API and then use `in`
    parameters in the private methods. The following listing provides an example,
    although it’s not doing any meaningful computations.'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以在避免这种情况的同时，仍然获得`in`参数的许多好处：通过仔细减少或去除它们改变的可能性。如果你有一个通过私有方法调用深层堆栈实现的公共API，你可以为那个公共API使用值参数，然后在私有方法中使用`in`参数。以下列表提供了一个示例，尽管它并没有进行任何有意义的计算。
- en: Listing 13.14\. Using `in` parameters safely
  id: totrans-1094
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.14\. 安全使用`in`参数
- en: '[PRE139]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '***1* Public method using value parameters**'
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用值参数的公共方法**'
- en: '***2* Private method using an in parameter**'
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用`in`参数的私有方法**'
- en: '***3* Another method with an in parameter**'
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 另一个带有`in`参数的方法**'
- en: With this approach, you can guard against unexpected change; because all the
    methods are private, you can inspect all the callers to make sure they won’t be
    passing in values that could change while your method is executing. A single copy
    of each struct will be made when `PublicMethod` is called, but those copies are
    then aliased for use in the private methods, isolating your code from any changes
    the caller may be making in other threads or as side effects of the other methods.
    In some cases, you may *want* the parameter to be changeable, but in a way that
    you carefully document and control.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你可以防止意外的变化；因为所有的方法都是私有的，你可以检查所有调用者，确保他们不会传递在方法执行期间可能发生变化的值。当调用`PublicMethod`时，将创建每个结构的单个副本，但这些副本随后被别名用于私有方法，从而将你的代码与调用者在其他线程中或作为其他方法副作用所做的任何更改隔离开。在某些情况下，你可能*希望*参数可变，但以一种你仔细记录和控制的方式。
- en: Applying the same logic to internal calls is also reasonable but requires more
    discipline because there’s more code that can call the method. As a matter of
    personal preference, I’ve explicitly used the `in` modifier at the call site as
    well as in the parameter declaration to make it obvious what’s going on when reading
    the code.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的逻辑应用于内部调用也是合理的，但需要更多的自律，因为可以调用该方法的方法代码更多。出于个人偏好，我在调用点以及参数声明中明确使用了`in`修饰符，以便在阅读代码时可以清楚地了解正在发生什么。
- en: 'I’ve summed all of this up in a short list of recommendations:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这些总结成了一小份推荐列表：
- en: Use `in` parameters only when there’s a measurable and significant performance
    benefit. This is most likely to be true when large structs are involved.
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在有可测量和显著性能提升的情况下才使用`in`参数。这很可能涉及到大型结构体。
- en: Avoid using `in` parameters in public APIs unless your method can function correctly
    even if the parameter values change arbitrarily during the method.
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非你的方法可以在参数值在方法执行期间任意变化的情况下正确运行，否则请避免在公共API中使用`in`参数。
- en: Consider using a public method as a barrier against change and then using `in`
    parameters within the private implementation to avoid copying.
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑将公共方法用作防止变化的屏障，然后在私有实现中使用`in`参数来避免复制。
- en: Consider explicitly using the `in` modifier when calling a method that takes
    an `in` parameter unless you’re deliberately using the compiler’s ability to pass
    a hidden local variable by reference.
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在调用接受`in`参数的方法时显式使用`in`修饰符，除非你故意使用编译器的功能通过引用传递隐藏的局部变量。
- en: Many of these guidelines could be easily checked by a Roslyn analyzer. Although
    I don’t know of such an analyzer at the time of this writing, I wouldn’t be surprised
    to see a NuGet package become available.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些指南都可以很容易地通过Roslyn分析器进行检查。虽然我在写作时不知道有这样的分析器，但我不会对出现一个NuGet包感到惊讶。
- en: '|  |'
  id: totrans-1107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you detect an implicit challenge here, you’re right. If you let me know about
    an analyzer like this, I’ll add a note on the website.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这里发现了隐式的挑战，你是正确的。如果你能告诉我这样的分析器，我会在网站上添加一个注释。
- en: '|  |'
  id: totrans-1110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: All of this depends on the amount of copying genuinely being reduced, and that’s
    not as straightforward as it sounds. I alluded to this earlier, but now it’s time
    to look much more closely at when the compiler implicitly copies structs and how
    you can avoid that.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都取决于复制量的真正减少，这并不像听起来那么简单。我之前提到了这一点，但现在我们需要更仔细地看看编译器在什么情况下隐式复制结构体，以及你如何避免这种情况。
- en: 13.4\. Declaring structs as readonly (C# 7.2)
  id: totrans-1112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4\. 将结构体声明为只读（C# 7.2）
- en: The point of `in` parameters is to improve performance by reducing copying for
    structs. That sounds great, but an obscure aspect of C# gets in our way unless
    we’re careful. We’ll look at the problem first and then at how C# 7.2 solves it.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`参数的目的是通过减少结构体的复制来提高性能。这听起来很棒，但除非我们小心，否则C#的一个不为人知的方面会阻碍我们。我们将首先探讨这个问题，然后看看C#
    7.2是如何解决这个问题的。'
- en: '13.4.1\. Background: Implicit copying with read-only variables'
  id: totrans-1114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.1\. 背景：使用只读变量的隐式复制
- en: C# has been implicitly copying structs for a long time. It’s all documented
    in the specification, but I wasn’t aware of it until I spotted a mysterious performance
    boost in Noda Time when I’d accidentally forgotten to make a field read-only.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: C#已经隐式复制结构体很长时间了。这都在规范中有详细说明，但直到我在Noda Time中意外忘记将字段设置为只读时发现了神秘的性能提升，我才意识到这一点。
- en: 'Let’s take a look at a simple example. You’re going to declare a `YearMonthDay`
    struct with three read-only properties: `Year`, `Month`, and `Day`. You’re not
    using the built-in `DateTime` type for reasons that will become clear later. The
    following listing shows the code for `YearMonthDay`; it’s really simple. (There’s
    no validation; it’s purely for demonstration in this section.)'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的例子。你将声明一个具有三个只读属性：`Year`、`Month`和`Day`的`YearMonthDay`结构体。你不会使用内置的`DateTime`类型，原因将在稍后变得清晰。下面的列表显示了`YearMonthDay`的代码；它真的很简单。（这里没有验证；这部分只是为了演示。）
- en: Listing 13.15\. A trivial year/month/day struct
  id: totrans-1117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.15\. 一个简单的年/月/日结构体
- en: '[PRE140]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Now let’s create a class with two `YearMonthDay` fields: one read-only and
    one read-write. You’ll then access the `Year` property in both fields.'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个具有两个`YearMonthDay`字段的类：一个只读和一个可读写。然后你将在这两个字段中访问`Year`属性。
- en: Listing 13.16\. Accessing properties via a read-only or read-write field
  id: totrans-1120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.16\. 通过只读或可读写字段访问属性
- en: '[PRE141]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The IL generated for the two property accesses is different in a subtle but
    important way. Here’s the IL for the read-only field; I’ve removed the namespaces
    from the IL for simplicity:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 为这两个属性访问生成的IL在微妙但重要的方式上有所不同。以下是只读字段的IL；为了简单起见，我已经从IL中删除了命名空间：
- en: '[PRE142]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'It loads the value of the field, thereby copying it to the stack. Only then
    can it call the `get_Year()` member, which is the getter for the `Year` property.
    Compare that with the code using the read-write field:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 它加载字段的值，从而将其复制到堆栈上。只有在这种情况下，它才能调用`get_Year()`成员，这是`Year`属性的getter。与使用可读写字段的代码进行比较：
- en: '[PRE143]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: This uses the `ldflda` instruction to load the address of the field onto the
    stack rather than `ldfld`, which loads the value of the field. This is only IL,
    which isn’t what your computer executes directly. It’s entirely possible that
    in some cases the JIT compiler is able to optimize this away, but in Noda Time
    I found that making fields read-write (with an attribute purely to explain why
    they weren’t read-only) made a significant difference in performance.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`ldflda`指令将字段的地址加载到堆栈上，而不是`ldfld`，后者加载字段的值。这完全是IL，这不是你的计算机直接执行的内容。在某些情况下，JIT编译器可能能够优化这一点，但在Noda
    Time中我发现，将字段设置为可读写（仅用属性来解释为什么它们不是只读的）对性能产生了显著影响。
- en: The reason the compiler takes this copy is to avoid a read-only field being
    mutated by the code within the property (or method, if you’re calling one). The
    intention of a read-only field is that nothing can change its value. It’d be odd
    if `readOnlyField.SomeMethod()` was able to modify the field. C# is designed to
    expect that any property setters will mutate the data, so they’re prohibited entirely
    for read-only fields. But even a property getter could try to mutate the value.
    Taking a copy is a safety measure, effectively.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器采取这种复制的原因是为了避免只读字段在属性（或如果你调用了一个方法）内部的代码中被修改。只读字段的意图是没有任何东西可以改变它的值。如果`readOnlyField.SomeMethod()`能够修改字段，那就很奇怪了。C#设计为期望任何属性设置器都会修改数据，因此它们被完全禁止用于只读字段。但即使是属性getter也可能尝试修改值。采取复制是一个安全措施。
- en: '|  |'
  id: totrans-1128
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This affects only value types**'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '**这仅影响值类型**'
- en: Just as a reminder, it’s fine to have a read-only field that’s a reference type
    and for methods to mutate the data in the objects they refer to. For example,
    you could have a read-only `StringBuilder` field, and you’d still be able to append
    to that `StringBuilder`. The value of the field is only the reference, and that’s
    what can’t change.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 就作为一个提醒，有一个只读的字段是引用类型，并且方法可以修改它们所引用的对象中的数据是可以的。例如，你可以有一个只读的`StringBuilder`字段，你仍然可以向那个`StringBuilder`中追加内容。字段的值只是一个引用，这就是不能改变的东西。
- en: In this section, we’re focusing on the field type being a value type like `decimal`
    or `DateTime`. It doesn’t matter whether the type that contains the field is a
    class or a struct.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们关注的是字段类型是一个值类型，如`decimal`或`DateTime`。字段包含的类型是类还是结构体无关紧要。
- en: '|  |'
  id: totrans-1132
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Until C# 7.2, only fields could be read-only. Now we have `ref readonly` local
    variables and `in` parameters to worry about. Let’s write a method that prints
    out the year, month, and day from a value parameter:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 直到C# 7.2，只有字段可以是只读的。现在我们有`ref readonly`局部变量和`in`参数需要担心。让我们编写一个方法，该方法从值参数中打印出年、月和日：
- en: '[PRE144]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The IL for this uses the address of the value that’s already on the stack.
    Each property access looks as simple as this:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个IL使用的是已经位于堆栈上的值的地址。每个属性访问看起来都像这样：
- en: '[PRE145]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'This doesn’t create any additional copies. The assumption is that if the property
    mutates the value, it’s okay for your `input` variable to be changed; it’s just
    a read-write variable, after all. But if you decide to change input to an `in`
    parameter like this, things change:'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会创建任何额外的副本。假设如果属性改变了值，那么你的 `input` 变量被改变是可以接受的；毕竟，它只是一个读写变量。但如果你决定将输入改为像这样的
    `in` 参数，事情就会改变：
- en: '[PRE146]'
  id: totrans-1138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Now in the IL for the method, each property access has code like this:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在方法的 IL 中，每个属性访问都有如下代码：
- en: '[PRE147]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The `ldobj` instruction copies the value from the address (the parameter) onto
    the stack. You were trying to avoid one copy being made by the caller, but in
    doing so you’ve introduced three copies within the method. You’d see the exact
    same behavior with `readonly ref` local variables, too. That’s not good! As you’ve
    probably guessed, C# 7.2 has a solution to this: read-only structs to the rescue!'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldobj` 指令将值从地址（参数）复制到堆栈上。你试图避免调用者进行一次复制，但在这样做的同时，你在方法内部引入了三个复制。你也会看到 `readonly
    ref` 本地变量有完全相同的行为。这可不是什么好事！正如你可能猜到的，C# 7.2 有一个解决方案：只读结构来拯救！'
- en: 13.4.2\. The readonly modifier for structs
  id: totrans-1142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.2\. 结构的只读修饰符
- en: To recap, the reason the C# compiler needs to make copies for read-only value
    type variables is to avoid code within those types changing the value of the variable.
    What if the struct could promise that it didn’t do that? After all, most structs
    are designed to be immutable. In C# 7.2, you can apply the `readonly` modifier
    to a struct declaration to do exactly that.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，C# 编译器需要为只读值类型变量创建副本的原因是为了避免那些类型内部的代码改变变量的值。如果结构能承诺它不会这样做会怎样？毕竟，大多数结构都是设计为不可变的。在
    C# 7.2 中，你可以将 `readonly` 修饰符应用于结构声明来做到这一点。
- en: 'Let’s modify our year/month/day struct to be read-only. It’s already obeying
    the semantics within the implementation, so you just need to add the `readonly`
    modifier:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的年/月/日结构以使其成为只读。它已经遵守了实现中的语义，所以你只需要添加 `readonly` 修饰符：
- en: '[PRE148]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'After that simple change to the declaration, and without any changes to the
    code using the struct, the IL generated for `PrintYearMonthDay(in YearMonthDay
    input)` becomes more efficient. Each property access now looks like this:'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明进行简单更改之后，并且没有对使用该结构的代码进行任何更改，为 `PrintYearMonthDay(in YearMonthDay input)`
    生成的 IL 变得更高效。每个属性访问现在看起来像这样：
- en: '[PRE149]'
  id: totrans-1147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Finally, you’ve managed to avoid copying the whole struct even once.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你成功避免了整个结构被复制哪怕一次。
- en: 'If you look in the downloadable source code that accompanies the book, you’ll
    see this in a separate struct declaration: `ReadOnlyYearMonthDay`. That was necessary
    so I could have samples with before and after, but in your own code you can just
    make an existing struct read-only without breaking source or binary compatibility.
    Going in the opposite direction is an insidious breaking change, however; if you
    decide to remove the modifier and modify an existing member to mutate the state
    of the value, code that was previously compiled expecting the struct to be read-only
    could end up mutating read-only variables in an alarming way.'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看书中附带的可下载源代码，你会在一个单独的结构声明中看到这个：`ReadOnlyYearMonthDay`。这是必要的，这样我才能有带有前后对比的样本，但在你自己的代码中，你只需将现有的结构设置为只读，而不会破坏源代码或二进制兼容性。然而，向相反方向进行是一个隐秘的破坏性变更；如果你决定移除修饰符并修改现有的成员以改变值的状态，之前编译的期望结构为只读的代码可能会以令人不安的方式修改只读变量。
- en: 'You can apply the modifier only if your struct is genuinely read-only and therefore
    meets the following conditions:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在你结构真正是只读的情况下应用修饰符，并且因此满足以下条件：
- en: Every instance field and automatically implemented instance property must be
    read-only. Static fields and properties can still be read-write.
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个实例字段和自动实现的实例属性必须是只读的。静态字段和属性仍然可以是读写。
- en: You can assign to `this` only within constructors. In specification terms, `this`
    is treated as an `out` parameter in constructors, a `ref` parameter in members
    of regular structs, and an `in` parameter in members of read-only structs.
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能在构造函数中向 `this` 赋值。在规范术语中，`this` 在构造函数中被视为一个 `out` 参数，在常规结构的成员中是一个 `ref` 参数，在只读结构的成员中是一个
    `in` 参数。
- en: Assuming you already intended your structs to be read-only, adding the `readonly`
    modifier allows the compiler to help you by checking that you aren’t violating
    that. I’d expect most user-defined structs to work right away. Unfortunately,
    there’s a slight wrinkle when it comes to Noda Time, which may affect you, too.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你原本打算你的结构体应该是只读的，添加`readonly`修饰符可以让编译器帮助你检查你是否违反了这一规定。我预计大多数用户定义的结构体会立即工作。不幸的是，当涉及到Noda
    Time时，这里有一个小问题，这也可能影响到你。
- en: 13.4.3\. XML serialization is implicitly read-write
  id: totrans-1154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.3\. XML序列化默认是读写模式
- en: 'Currently, most of the structs in Noda Time implement `IXmlSerializable`. Unfortunately,
    XML serialization is defined in a way that’s actively hostile to writing read-only
    structs. My implementation in Noda Time typically looks like this:'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Noda Time中的大多数结构体实现了`IXmlSerializable`。不幸的是，XML序列化是以一种对只读结构体有敌意的方式定义的。我在Noda
    Time中的实现通常如下所示：
- en: '[PRE150]'
  id: totrans-1156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Can you see the problem? It assigns to `this` in the last line. That prevents
    me from declaring these structs with the `readonly` modifier, which saddens me.
    I have three options at the moment:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出问题吗？它在最后一行对`this`进行了赋值。这阻止了我使用`readonly`修饰符来声明这些结构体，这让我感到很沮丧。目前我有三个选择：
- en: Leave the structs as they are, which means `in` parameters and `ref readonly`
    locals are inefficient.
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持结构体不变，这意味着`in`参数和`ref readonly`局部变量是低效的。
- en: Remove XML serialization from the next major version of Noda Time.
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Noda Time的下一个主要版本中移除XML序列化。
- en: Use unsafe code in `ReadXml` to violate the `readonly` modifier. The `System
    .Runtime.CompilerServices.Unsafe` package makes this simpler.
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ReadXml`中使用不安全代码来违反`readonly`修饰符。`System.Runtime.CompilerServices.Unsafe`包使这变得简单。
- en: None of these options is pleasant, and there’s no twist as I reveal a cunning
    way of satisfying all the concerns. At the moment, I believe that structs implementing
    `IXmlSerializable` can’t be genuinely read-only. No doubt there are other interfaces
    that are implicitly mutable in the same way that you might want to implement in
    a struct, but I suspect that `IXmlSerializable` will be the most common one.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中没有一个令人愉快，而且在我揭示一个巧妙的方法来满足所有这些担忧之前，没有转折。目前，我相信实现`IXmlSerializable`的结构体不能真正是只读的。毫无疑问，还有其他接口可能是隐式可变的，就像你可能在结构体中实现的那样，但我怀疑`IXmlSerializable`将是其中最常见的一个。
- en: 'The good news is that most readers probably aren’t facing this issue. Where
    you can make your user-defined structs read-only, I encourage you to do so. Just
    bear in mind that it’s a one-way change for public code; you can safely remove
    the modifier later only if you’re in the privileged position of being able to
    recompile all the code that uses the struct. Our next feature is effectively tidying
    up consistency: providing the same functionality to extension methods that’s already
    present in struct instance methods.'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，大多数读者可能不会遇到这个问题。在你能够使你的用户定义结构体只读的情况下，我鼓励你这样做。但请记住，这是一个单向的改变，对于公共代码来说；只有在你能够重新编译使用该结构体的所有代码的特权位置，你才能安全地移除修饰符。我们下一个特性实际上是整理一致性：为扩展方法提供已经在结构体实例方法中存在的相同功能。
- en: 13.5\. Extension methods with ref or in parameters (C# 7.2)
  id: totrans-1163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5\. 带有ref或in参数的扩展方法（C# 7.2）
- en: Prior to C# 7.2, the first parameter in any extension method had to be a value
    parameter. This restriction is partially lifted in C# 7.2 to embrace the new ref-like
    semantics more thoroughly.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.2之前，任何扩展方法中的第一个参数都必须是值参数。在C# 7.2中，这一限制部分被放宽，以更彻底地拥抱新的类似ref的语义。
- en: 13.5.1\. Using ref/in parameters in extension methods to avoid copying
  id: totrans-1165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.1\. 在扩展方法中使用ref/in参数以避免复制
- en: Suppose you have a large struct that you’d like to avoid copying around and
    a method that computes a result based on the values of properties in that struct—the
    magnitude of a 3D vector, for example. If the struct provides the method (or property)
    itself, you’re fine, particularly if the struct is declared with the `readonly`
    modifier. You can avoid copying with no problems. But maybe you’re doing something
    more complex that the authors of the struct hadn’t considered. The samples in
    this section use a trivial read-only `Vector3D` struct introduced in the following
    listing. The struct just exposes `X`, `Y`, and `Z` properties.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个大的结构体，你希望避免复制，并且有一个基于该结构体属性值计算结果的方法——例如3D向量的模。如果结构体提供了这个方法（或属性），那么你没问题，尤其是如果结构体声明了`readonly`修饰符。你可以无问题地避免复制。但也许你正在做一些结构体作者没有考虑到的更复杂的事情。本节中的示例使用了一个简单的只读`Vector3D`结构体，该结构体在下面的列表中引入。这个结构体仅公开了`X`、`Y`和`Z`属性。
- en: Listing 13.17\. A trivial `Vector3D` struct
  id: totrans-1167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.17\. 一个简单的 `Vector3D` 结构体
- en: '[PRE151]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'If you write your own method accepting the struct with an `in` parameter, you’re
    fine. You can avoid copying, but it may be slightly awkward to call. For example,
    you might end up having to write something like this:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写自己的接受具有 `in` 参数的结构体的方法，那就没问题。你可以避免复制，但调用可能有些尴尬。例如，你可能不得不写点像这样的事情：
- en: '[PRE152]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'That would be ugly. You have extension methods, but a regular extension method
    like this would copy the vector on each call:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 那会很难看。你有扩展方法，但像这样的常规扩展方法会在每次调用时复制向量：
- en: '[PRE153]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'It’s unpleasant to have to choose between performance and readability. C# 7.2
    comes to the rescue in a reasonably predictable way: you can write extension methods
    with a `ref` or `in` modifier on the first parameter. The modifier can appear
    before or after the `this` modifier. If you’re only computing a value, you should
    use an `in` parameter, but you can also use `ref` if you want to be able to modify
    the value in the original storage location without having to create a new value
    and copy it in. The following listing provides two sample extension methods on
    a `Vector3D`.'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能和可读性之间做出选择并不愉快。C# 7.2 以一种合理可预测的方式提供了帮助：你可以在第一个参数上使用 `ref` 或 `in` 修饰符来编写扩展方法。修饰符可以出现在
    `this` 修饰符之前或之后。如果你只是计算一个值，你应该使用 `in` 参数，但如果你想能够在原始存储位置修改值而不必创建一个新值并复制它，你也可以使用
    `ref`。以下列表提供了两个在 `Vector3D` 上的示例扩展方法。
- en: Listing 13.18\. Extension methods using `ref` and `in`
  id: totrans-1174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.18\. 使用 `ref` 和 `in` 的扩展方法
- en: '[PRE154]'
  id: totrans-1175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The parameter names are abbreviated more than I’m normally comfortable with
    to avoid long-winded formatting in the book. Note that the second parameter in
    the `OffsetBy` method is an `in` parameter; you’re trying to avoid copying to
    as great an extent as you can.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称的缩写比我通常感到舒适的程度要高，以避免在书中出现冗长的格式化。请注意，`OffsetBy` 方法中的第二个参数是一个 `in` 参数；你试图尽可能避免复制。
- en: It’s simple to use the extension methods. The only possibly surprising aspect
    is that unlike regular `ref` parameters, there’s no sign of the `ref` modifier
    when calling ref extension methods. The following listing uses both of the extension
    methods I’ve shown to create two vectors, offset the first vector by the second
    vector, and then display the resulting vector and its magnitude.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展方法很简单。唯一可能令人惊讶的方面是，与常规 `ref` 参数不同，调用 ref 扩展方法时没有 `ref` 修饰符的迹象。以下列表使用我展示的两个扩展方法创建两个向量，将第一个向量偏移第二个向量，然后显示结果向量和其大小。
- en: Listing 13.19\. Calling `ref` and `in` extension methods
  id: totrans-1178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.19\. 调用 `ref` 和 `in` 扩展方法
- en: '[PRE155]'
  id: totrans-1179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The output is as follows:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE156]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This shows that the call to `OffsetBy` modified the `vector` variable as you
    intended it to.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `OffsetBy` 的调用按预期修改了 `vector` 变量。
- en: '|  |'
  id: totrans-1183
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `OffsetBy` method makes our immutable `Vector3D` struct feel somewhat mutable.
    This feature is still in its early days, but I suspect I’ll feel much more comfortable
    writing extension methods with initial `in` parameters than with `ref` parameters.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '`OffsetBy` 方法使我们的不可变 `Vector3D` 结构体感觉有些可变。这个特性还处于早期阶段，但我怀疑我会在使用初始 `in` 参数的扩展方法上比使用
    `ref` 参数上感到更加自在。'
- en: '|  |'
  id: totrans-1186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'An extension method with an initial `in` parameter can be called on a read-write
    variable (as you’ve seen by calling `vector.Magnitude()`), but an extension method
    with an initial `ref` parameter can’t be called on a read-only variable. For example,
    if you create a read-only alias for `vector`, you can’t call `OffsetBy`:'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 具有初始 `in` 参数的扩展方法可以在可读写变量上调用（正如你在调用 `vector.Magnitude()` 时所看到的），但具有初始 `ref`
    参数的扩展方法不能在只读变量上调用。例如，如果你为 `vector` 创建了一个只读别名，你就不能调用 `OffsetBy`：
- en: '[PRE157]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '***1* Error: trying to use a read-only variable as ref**'
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误：尝试将只读变量用作 ref**'
- en: Unlike regular extension methods, restrictions exist about the extended type
    (the type of the first parameter) for initial `ref` and `in` parameters.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规扩展方法不同，对于初始的 `ref` 和 `in` 参数，对扩展类型（第一个参数的类型）存在一些限制。
- en: 13.5.2\. Restrictions on ref and in extension methods
  id: totrans-1191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.5.2\. 对 `ref` 和 `in` 扩展方法的限制
- en: 'Normal extension methods can be declared to extend any type. They can use either
    a regular type or a type parameter with or without constraints:'
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的扩展方法可以声明为扩展任何类型。它们可以使用常规类型或带有或不带有约束的类型参数：
- en: '[PRE158]'
  id: totrans-1193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'In contrast, `ref` and `in` extension methods always have to extend value types.
    In the case of `in` extension methods, that value type can’t be a type parameter
    either. These are valid:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`ref`和`in`扩展方法始终必须扩展值类型。在`in`扩展方法的情况下，该值类型也不能是类型参数。以下内容是有效的：
- en: '[PRE159]'
  id: totrans-1195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'But these are invalid:'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下内容是无效的：
- en: '[PRE160]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '***1* Reference type target for ref parameter**'
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* ref参数的引用类型目标**'
- en: '***2* Type parameter target for ref parameter without struct constraint**'
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 没有结构约束的ref参数的类型参数目标**'
- en: '***3* Reference type target for in parameter**'
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* in参数的引用类型目标**'
- en: '***4* Type parameter target for in parameter**'
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4* in参数的类型参数目标**'
- en: Note the difference between `in` and `ref`, where a `ref` parameter can be a
    type parameter so long as it has the `struct` constraint. An `in` extension method
    can still be generic (as per the final valid example), but the extended type can’t
    be a type parameter. At the moment, there’s no constraint that can require that
    `T` is a `readonly struct`, which would be required for a generic `in` parameter
    to be useful. That may change in future versions of C#.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`in`和`ref`之间的区别，其中`ref`参数只要具有`struct`约束就可以是类型参数。`in`扩展方法仍然可以是泛型的（如最后一个有效示例所示），但扩展类型不能是类型参数。目前，没有约束可以要求`T`是`readonly
    struct`，这对于泛型`in`参数是有用的。这可能在C#的将来版本中发生变化。
- en: 'You may wonder why the extended type is constrained to be a value type at all.
    There are two primary reasons for this:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么扩展类型必须约束为值类型。有两个主要原因：
- en: The feature is designed to avoid expensive copying of value types, so there’s
    no benefit for reference types.
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个功能旨在避免值类型的昂贵复制，因此引用类型没有好处。
- en: 'If a `ref` parameter could be a reference type, it could be set to a null reference
    within the method. That would disrupt an assumption C# developers and tooling
    can always make at the moment: that calling `x.Method()` (where `x` is a variable
    of some reference type) can never make `x` null.'
  id: totrans-1205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ref`参数可以是引用类型，它可以在方法内部设置为null引用。这将破坏C#开发者和工具目前可以做出的一个假设：调用`x.Method()`（其中`x`是某种引用类型的变量）永远不会使`x`为null。
- en: I don’t expect to use `ref` and `in` extension methods very much, but they do
    provide a pleasant consistency to the language.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 我不期望会非常频繁地使用`ref`和`in`扩展方法，但它们确实为语言提供了一致性。
- en: 'The features in the remainder of the chapter are somewhat different from the
    ones you’ve examined so far. Just to recap, so far you’ve looked at these:'
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分的功能与您迄今为止所考察的功能有所不同。为了回顾，到目前为止，您已经看过以下内容：
- en: Ref locals
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ref局部变量
- en: Ref returns
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ref返回值
- en: Read-only versions of ref locals and ref returns
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ref局部变量和ref返回值的只读版本
- en: '`in` parameters: read-only versions of `ref` parameters'
  id: totrans-1211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`参数：`ref`参数的只读版本'
- en: Read-only structs, which allow `in` parameters and read-only ref locals and
    returns to avoid copying
  id: totrans-1212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读结构体，允许`in`参数和只读ref局部变量和返回值以避免复制
- en: Extension methods targeting `ref` or `in` parameters
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`ref`或`in`参数为目标扩展方法
- en: If you started with ref parameters and wondered how to extend the concept further,
    you might have come up with something similar to this list. We’re now going to
    move on to ref-like structs, which are related to all of these but also feel like
    a whole new kind of type.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从ref参数开始，想知道如何进一步扩展这个概念，您可能会想到这个列表中的类似内容。我们现在将转向类似ref的结构体，这些结构与上述所有内容相关，但感觉像是一种全新的类型。
- en: 13.6\. Ref-like structs (C# 7.2)
  id: totrans-1215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6\. 类似ref的结构体（C# 7.2）
- en: 'C# 7.2 introduces the notion of a *ref-like* struct: one that’s intended to
    exist only on the stack. Just as with custom task types, it’s likely that you’ll
    never need to declare your own ref-like struct, but I expect C# code written against
    up-to-date frameworks in the next few years to use the ones built into the framework
    quite a lot.'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.2引入了*类似ref*的结构体的概念：这种结构体仅存在于栈上。就像自定义任务类型一样，您可能永远不需要声明自己的类似ref结构体，但我预计在未来几年内，针对最新框架编写的C#代码将大量使用框架内构建的类似ref结构体。
- en: 'First, you’ll look at the basic rules for ref-like structs and then see how
    they’re used and the framework support for them. I should note that these are
    a simplified form of the rules; consult the language specification for the gory
    details. I suspect that relatively few developers will need to know exactly how
    the compiler enforces the stack safety of ref-like structs, but it’s important
    to understand the principle of what it’s trying to achieve:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将查看类似引用结构的规则，然后了解它们的使用方式和框架对这些规则的支持。我应该指出，这些都是规则的简化形式；有关详细信息，请参阅语言规范。我怀疑相对较少的开发者需要确切知道编译器如何强制执行类似引用结构的栈安全性，但了解它试图实现的原则是很重要的：
- en: '*A ref-like struct value must stay on the stack, always.*'
  id: totrans-1218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*类似引用的结构值必须始终保持在栈上，总是如此。*'
- en: 'Let’s start by creating a ref-like struct. The declaration is the same as a
    normal struct declaration with the addition of the `ref` modifier:'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个类似引用的结构体开始。声明与普通结构体声明相同，只是增加了`ref`修饰符：
- en: '[PRE161]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '***1* Struct members as normal**'
  id: totrans-1221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 结构成员作为正常**'
- en: 13.6.1\. Rules for ref-like structs
  id: totrans-1222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.6.1\. 类似引用结构的规则
- en: 'Rather than say what you *can* do with it, here are some of the things you
    *can’t* do with `RefLikeStruct` and a brief explanation:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是说明你可以用它做什么，这里有一些你不能用`RefLikeStruct`做的事情以及简要的解释：
- en: You can’t include a `RefLikeStruct` as a field of any type that isn’t also a
    ref-like struct. Even a regular struct can easily end up on the heap either via
    boxing or by being a field in a class. Even within another ref-like struct, you
    can use `RefLikeStruct` only as the type of an instance field—never a static field.
  id: totrans-1224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将`RefLikeStruct`包含在任何不是类似引用结构的类型的字段中。即使是普通的结构体也可能会通过装箱或作为类的一个字段而轻易地结束在堆上。即使在另一个类似引用结构中，你也只能将`RefLikeStruct`用作实例字段的类型——永远不能用作静态字段。
- en: You can’t box a `RefLikeStruct`. Boxing is precisely designed to create an object
    on the heap, which is exactly what you don’t want.
  id: totrans-1225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能装箱`RefLikeStruct`。装箱正是设计用来在堆上创建对象，这正是你不想看到的。
- en: You can’t use `RefLikeStruct` as a type argument (either explicitly or by type
    inference) for any generic method or type, including as a type argument for a
    generic ref-like struct type. Generic code can use generic type arguments in all
    kinds of ways that put values on the heap, such as creating a `List<T>`.
  id: totrans-1226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将`RefLikeStruct`用作任何泛型方法或类型的类型参数（无论是显式还是通过类型推断），包括用作泛型类似引用结构类型类型参数。泛型代码可以使用泛型类型参数以各种方式在堆上放置值，例如创建`List<T>`。
- en: You can’t use `RefLikeStruct[]` or any similar array type as the operand for
    the `typeof` operator.
  id: totrans-1227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将`RefLikeStruct[]`或任何类似的数组类型用作`typeof`运算符的操作数。
- en: 'Local variables of type `RefLikeStruct` can’t be used anywhere the compiler
    might need to capture them on the heap in a special generated type. That includes
    the following:'
  id: totrans-1228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为`RefLikeStruct`的局部变量不能在任何编译器可能需要将其捕获到特殊生成的类型中的堆上的地方使用。这包括以下内容：
- en: Async methods, although this could potentially be relaxed so a variable could
    be declared and used between await expressions, so long as it was never used across
    an await expression (with a declaration before the await and a usage after it).
    Parameters for async methods can’t be ref-like struct types.
  id: totrans-1229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步方法，尽管这可能会被放宽，以便变量可以在await表达式之间声明和使用，只要它从未跨越await表达式（在await之前声明，在await之后使用）。异步方法的参数不能是类似引用结构类型。
- en: Iterator blocks, which already appear to have the “only using `RefLikeStruct`
    between two yield expressions is okay” rules. Parameters for iterator blocks can’t
    be ref-like struct types.
  id: totrans-1230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器块已经遵循了“只在两个yield表达式之间使用`RefLikeStruct`是允许的”规则。迭代器块的参数不能是类似引用的结构类型。
- en: Any local variable captured by a local method, LINQ query expression, anonymous
    method, or lambda expression.
  id: totrans-1231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何被局部方法、LINQ查询表达式、匿名方法或lambda表达式捕获的局部变量。
- en: 'Additionally, complicated rules^([[3](kindle_split_030_split_000.html#ch13fn3)])
    indicate how ref local variables of ref-like types can be used. I suggest trusting
    the compiler here; if your code fails to compile because of ref-like structs,
    you’re likely trying to make something available at a point where it will no longer
    be alive on the stack. With this set of rules keeping values on the stack, you
    can finally look at using the poster child for ref-like structs: `Span<T>`.'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，复杂的规则^([[3](kindle_split_030_split_000.html#ch13fn3)])说明了类似引用类型的局部引用变量如何使用。我建议在这里信任编译器；如果你的代码因为类似引用结构而无法编译，你很可能是试图在它不再存在于栈上的位置使其可用。有了这组规则来保持值在栈上，你最终可以查看使用类似引用结构的“宠儿”：`Span<T>`。
- en: ³
  id: totrans-1233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Translation: I’m finding them hard to understand. I understand the general
    purpose, but the complexity required to prevent bad things from happening is beyond
    my current level of interest in going over the rules line by line.'
  id: totrans-1235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 翻译：我发现它们很难理解。我理解了其一般用途，但防止发生不良事件所需的复杂性超出了我对逐行审查规则的兴趣水平。
- en: 13.6.2\. Span<T> and stackalloc
  id: totrans-1236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.6.2\. Span<T>和stackalloc
- en: 'There are several ways of accessing chunks of memory in .NET. Arrays are the
    most common, but `ArraySegment<T>` and pointers are also used. One large downside
    of using arrays directly is that the array effectively owns all its memory; an
    array is never just part of a larger piece of memory. That doesn’t sound too bad
    until you think of how many method signatures you’ve seen like this:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中访问内存块有几种方式。数组是最常见的，但`ArraySegment<T>`和指针也被使用。直接使用数组的一个大缺点是数组实际上拥有所有其内存；数组永远不会是更大内存块的一部分。这听起来并不太糟糕，直到你想到你看到过多少这样的方法签名：
- en: '[PRE162]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: This “buffer, offset, length” set of parameters occurs all over the place in
    .NET, and it’s effectively a code smell suggesting that we haven’t had the right
    abstraction in place. `Span<T>` and the related types aim to fix this.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: “缓冲区、偏移量、长度”这一组参数在.NET中到处都是，它实际上是一个代码异味，表明我们没有放置正确的抽象。`Span<T>`和相关类型旨在解决这个问题。
- en: '|  |'
  id: totrans-1240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Some uses of `Span<T>` will work just by adding a reference to the `System.Memory`
    NuGet package. Others require framework support. The code presented in this section
    has been built against .NET Core 2.1\. Some listings will build against earlier
    versions of the framework as well.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Span<T>`的一些用法只需添加对`System.Memory` NuGet包的引用即可工作。其他则需要框架支持。本节中展示的代码是针对.NET
    Core 2.1构建的。一些列表也将针对框架的早期版本构建。'
- en: '|  |'
  id: totrans-1243
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`Span<T>` is a ref-like struct that provides read/write, indexed access to
    a section of memory just like an array but without any concept of owning that
    memory. A span is always created from something else (maybe a pointer, maybe an
    array, even data created directly on the stack). When you use a `Span<T>`, you
    don’t need to care where the memory has been allocated. Spans can be *sliced*:
    you can create one span as a subsection of another without copying any data. In
    new versions of the framework, the JIT compiler will be aware of `Span<T>` and
    handle it in a heavily optimized manner.'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Span<T>`是一个类似于ref的结构体，它提供了对内存部分的读写、索引访问，就像数组一样，但没有拥有该内存的概念。span总是从其他东西（可能是指针，可能是数组，甚至是直接在栈上创建的数据）创建而来。当你使用`Span<T>`时，你不需要关心内存的分配位置。span可以被**切片**：你可以创建一个span作为另一个span的子部分，而不需要复制任何数据。在新版本的框架中，JIT编译器将了解`Span<T>`并以高度优化的方式处理它。'
- en: 'The ref-like nature of `Span<T>` sounds irrelevant, but it has two significant
    benefits:'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Span<T>`的ref-like特性听起来无关紧要，但它有两个显著的好处：'
- en: It allows a span to refer to memory with a tightly controlled lifecycle, as
    the span can’t escape from the stack. The code that allocates the memory can pass
    a span to other code and then free the memory afterward with confidence that there
    won’t be any spans left to refer to that now-deallocated memory.
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许span引用具有紧密控制生命周期的内存，因为span不能从栈中逃逸。分配内存的代码可以将span传递给其他代码，然后在之后有信心地释放内存，因为不会有任何span引用现在已分配的内存。
- en: It allows custom one-time initialization of data in a span without any copying
    and without the risk of code being able to change the data afterward.
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许在span中自定义一次性初始化数据，而不需要任何复制，也不存在代码在之后改变数据的风险。
- en: Let’s demonstrate both of these points in a simple way by writing a method to
    generate a random string. Although `Guid.NewGuid` often can be used for this purpose,
    sometimes you may want a more customized approach using a different set of characters
    and length. The following listing shows the traditional code you might have used
    in the past.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个生成随机字符串的方法来简单演示这两个点。尽管`Guid.NewGuid`经常可以用于此目的，但有时你可能想使用不同的字符集和长度来采取更定制的方法。以下列表显示了你可能过去使用的传统代码。
- en: Listing 13.20\. Generating a random string by using a `char[]`
  id: totrans-1249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.20\. 使用`char[]`生成随机字符串
- en: '[PRE163]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Here’s an example of calling the method to generate a string of 10 lowercase
    letters:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个调用方法生成10个小写字母字符串的例子：
- en: '[PRE164]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[Listing 13.20](kindle_split_030_split_000.html#ch13ex20) performs two heap
    allocations: one for the char array and one for the string. The data needs to
    be copied from one place to the other when constructing the string. You can improve
    this slightly if you know you’ll always be generating reasonably small strings,
    and if you’re in a position to use unsafe code. In that situation, you can use
    `stackalloc`, as shown in the following listing.'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13.20](kindle_split_030_split_000.html#ch13ex20) 执行了两次堆分配：一次用于字符数组，一次用于字符串。在构建字符串时，需要将数据从一处复制到另一处。如果你知道你将始终生成合理的小字符串，并且你处于可以使用不安全代码的位置，你可以稍微改进这一点。在这种情况下，你可以使用
    `stackalloc`，如下面的列表所示。'
- en: Listing 13.21\. Generating a random string by using `stackalloc` and a pointer
  id: totrans-1254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.21\. 使用 `stackalloc` 和指针生成随机字符串
- en: '[PRE165]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'This performs only one heap allocation: the string. The temporary buffer is
    stack allocated, but you need to use the `unsafe` modifier because you’re using
    a pointer. Unsafe code takes me out of my comfort zone; although I’m reasonably
    confident that this code is okay, I wouldn’t want to do anything much more complicated
    with pointers. There’s still the copy from the stack allocated buffer to the string,
    too.'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 这只进行了一次堆分配：字符串。临时缓冲区是堆栈分配的，但你需要使用 `unsafe` 修饰符，因为你正在使用指针。不安全代码让我感到不舒服；尽管我对这段代码相当有信心，但我不想用指针做任何更复杂的事情。从堆栈分配的缓冲区到字符串的复制仍然存在。
- en: The good news is that `Span<T>` also supports `stackalloc` without any need
    for the `unsafe` modifier, as shown in the following listing. You don’t need the
    `unsafe` modifier because you’re relying on the rules for ref-like structs to
    keep everything safe.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是 `Span<T>` 也支持 `stackalloc`，无需任何 `unsafe` 修饰符，如下面的列表所示。你不需要 `unsafe` 修饰符，因为你依赖于类似
    ref 结构的规则来确保一切安全。
- en: Listing 13.22\. Generating a random string by using `stackalloc` and a `Span<char>`
  id: totrans-1258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.22\. 使用 `stackalloc` 和 `Span<char>` 生成随机字符串
- en: '[PRE166]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'That makes me more confident, but it’s no more efficient; you’re still copying
    data in a way that feels redundant. You can do better. All you need is this factory
    method in `System.String`:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我更有信心，但效率并没有提高；你仍然以感觉重复的方式复制数据。你可以做得更好。你所需要的就是 `System.String` 中的这个工厂方法：
- en: '[PRE167]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'That uses `SpanAction<T, TArg>`, which is a new delegate with this signature:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了 `SpanAction<T, TArg>`，这是一个具有以下签名的新的委托：
- en: '[PRE168]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'These two signatures may look a little odd to start with, so let’s unpack what
    the implementation of `Create` does. It takes the following steps:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个签名一开始可能看起来有点奇怪，所以让我们来分析一下 `Create` 方法的实现。它执行以下步骤：
- en: Allocates a string with the requested length
  id: totrans-1265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配具有所需长度的字符串
- en: Creates a span that refers to the memory inside the string
  id: totrans-1266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个指向字符串内部内存的范围
- en: Calls the `action` delegate, passing in whatever state the method was given
    and the span
  id: totrans-1267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `action` 委托，传入方法所接收的任何状态和范围
- en: Returns the string
  id: totrans-1268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回字符串
- en: The first thing to note is that our delegate is able to write to the content
    of a string. That sounds like it defies everything you know about the immutability
    of strings, but the `Create` method is in control here. Yes, you can write whatever
    you like to the string, just as you can create a new string with whatever content
    you want. But by the time the string is returned, the content is effectively baked
    into the string. You can’t try to cheat by holding onto the `Span<char>` that’s
    passed to the delegate, because the compiler makes sure it doesn’t escape the
    stack.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们的委托能够写入字符串的内容。这听起来好像违背了你所知道的所有关于字符串不可变性的知识，但 `Create` 方法在这里是掌控者。是的，你可以将任何内容写入字符串，就像你可以创建一个包含任何内容的新的字符串一样。但是，当字符串返回时，内容实际上已经嵌入到字符串中。你不能通过保留传递给委托的
    `Span<char>` 来试图作弊，因为编译器确保它不会逃离堆栈。
- en: That still leaves the odd part about the state. Why do you need to pass in state
    that’s then passed back to our delegate? It’s easiest to show you an example;
    the following listing uses the `Create` method to implement our random string
    generator.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然留下了关于状态的奇怪部分。为什么你需要传入随后传递回我们的委托的状态？最容易的方式是给你一个例子；下面的列表使用 `Create` 方法来实现我们的随机字符串生成器。
- en: Listing 13.23\. Generating a random string with `string.Create`
  id: totrans-1271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.23\. 使用 `string.Create` 生成随机字符串
- en: '[PRE169]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'At first, it looks like a lot of pointless repetition occurs. The second argument
    to `string.Create` is `(alphabet, random)`, which puts the `alphabet` and `random`
    parameters into a tuple to act as the state. You then unpack these values from
    the tuple again in the lambda expression:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看起来好像有很多无意义的重复。`string.Create`的第二个参数是`(alphabet, random)`，这把`alphabet`和`random`参数放入一个元组中，作为状态。然后你再次在lambda表达式中从元组中解包这些值：
- en: '[PRE170]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Why not just capture the parameters in the lambda expression? Using `alphabet`
    and `random` within the lambda expression would compile and behave correctly,
    so why bother using the extra `state` parameter?
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在lambda表达式中捕获参数呢？在lambda表达式中使用`alphabet`和`random`可以编译并正确运行，那么为什么还要使用额外的`state`参数呢？
- en: 'Remember the point of using spans: you’re trying to reduce heap allocations
    as well as copying. When a lambda expression captures a parameter or local variable,
    it has to create an instance of a generated class so that the delegate has access
    to those variables. The lambda expression in [listing 13.23](kindle_split_030_split_000.html#ch13ex23)
    doesn’t need to capture anything, so the compiler can generate a static method
    and cache a single delegate instance to use every time `Generate` is called. All
    the state is passed via the parameters to `string.Create`, and because C# 7 tuples
    are value types, there’s no allocation for that state.'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 记住使用span的目的：你试图减少堆分配以及复制。当一个lambda表达式捕获一个参数或局部变量时，它必须创建一个生成类的实例，以便委托可以访问这些变量。在[列表13.23](kindle_split_030_split_000.html#ch13ex23)中的lambda表达式不需要捕获任何东西，因此编译器可以生成一个静态方法并缓存一个单独的委托实例，每次调用`Generate`时都使用。所有状态都是通过`string.Create`的参数传递的，因为C#
    7的元组是值类型，所以没有为该状态分配。
- en: 'At this point, your simple string generation method is as good as it’s going
    to get: it requires a single heap allocation and no extra data copying. Your code
    just writes straight into the string data.'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的简单字符串生成方法已经达到了极限：它只需要一次堆分配，没有额外的数据复制。你的代码直接写入字符串数据。
- en: This is just one example of the kind of thing that `Span<T>` makes possible.
    Related types exist; `ReadOnlySpan<T>`, `Memory<T>`, and `ReadOnlyMemory<T>` are
    the most important ones. A full deep-dive into them is beyond the scope of this
    book.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是`Span<T>`使可能的一种类型的事例。相关的类型也存在；`ReadOnlySpan<T>`、`Memory<T>`和`ReadOnlyMemory<T>`是最重要的。对这些类型的全面深入探讨超出了本书的范围。
- en: Importantly, our optimization of the `Generate` method didn’t need to change
    its signature at all. It was a pure implementation change isolated from anything
    else, and that’s what makes me excited. Although passing large structs by reference
    throughout your codebase would help avoid excessive copying, that’s an invasive
    optimization. I far prefer optimizations that I can perform in a piecemeal, targeted
    fashion.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们对`Generate`方法的优化根本不需要改变它的签名。这是一个纯实现变更，与任何其他东西都隔离，这正是让我兴奋的原因。虽然在整个代码库中通过引用传递大型结构体可以帮助避免过度复制，但这是一种侵入式优化。我更喜欢可以分阶段、有针对性地进行的优化。
- en: Just as string gains extra methods to make use of spans, so will many other
    types. We now take it for granted that any I/O-based operation will have an async
    option available in the framework, and I expect the same to be true for spans
    over time; wherever they’d be useful, they’ll be available. I expect third-party
    libraries will offer overloads accepting spans, too.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 正如字符串通过额外的方法来利用span一样，许多其他类型也将如此。我们现在认为，任何基于I/O的操作都将在框架中有一个异步选项可用，我预计随着时间的推移，span也将如此；在任何它们有用的地方，它们都将可用。我也预计第三方库将提供接受span的重载。
- en: Stackalloc with initializers (C# 7.3)
  id: totrans-1281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 带初始化器的`stackalloc`（C# 7.3）
- en: 'While we’re on the subject of stack allocation, C# 7.3 adds one extra twist:
    initializers. Whereas with previous versions you could use `stackalloc` only with
    a size you wanted to allocate, with C# 7.3 you can specify the content of the
    allocated space as well. This is valid for both pointers and spans:'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论堆分配时，C# 7.3增加了一个额外的转折：初始化器。与之前的版本不同，你只能使用`stackalloc`来分配你想要的大小，而C# 7.3允许你指定分配空间的内
    容。这对于指针和span都有效：
- en: '[PRE171]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: I don’t believe this has any significant efficiency gains over allocating and
    then manually populating the space, but it’s certainly simpler code to read.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这并没有比手动分配和填充空间有显著的效率提升，但代码确实更容易阅读。
- en: Pattern-based fixed statements (C# 7.3)
  id: totrans-1285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基于模式的固定语句（C# 7.3）
- en: 'As a reminder, the `fixed` statement is used to obtain a pointer to memory,
    temporarily preventing the garbage collector from moving that data. Before C#
    7.3, this could be used only with arrays, strings, and taking the address of a
    variable. C# 7.3 allows it to be used with any type that has an accessible method
    called `GetPinnableReference` that returns a reference to an unmanaged type. For
    example, if you have a method returning a `ref int`, you can use that in a fixed
    statement like this:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，`fixed` 语句用于获取内存的指针，暂时阻止垃圾回收器移动该数据。在 C# 7.3 之前，这只能与数组、字符串以及获取变量的地址一起使用。C#
    7.3 允许它与任何具有可访问方法 `GetPinnableReference` 并返回指向非托管类型的引用的类型一起使用。例如，如果你有一个返回 `ref
    int` 的方法，你可以在类似这样的 `fixed` 语句中使用它：
- en: '[PRE172]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '***1* Calls value.GetPinnableReference**'
  id: totrans-1288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用 value.GetPinnableReference**'
- en: '***2* Code using the pointer**'
  id: totrans-1289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用指针的代码**'
- en: This isn’t something most developers would normally implement themselves, even
    within the small proportion of developers who use unsafe code on a regular basis.
    As you might expect, the types you’re most likely to use this with are `Span<T>`
    and `ReadOnlySpan<T>`, allowing them to interoperate with code that already uses
    pointers.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是大多数开发者通常会自己实现的事情，即使在那些经常使用不安全代码的小比例开发者中也是如此。正如你所预期的，你最可能使用这个功能的是 `Span<T>`
    和 `ReadOnlySpan<T>`，这允许它们与已经使用指针的代码进行交互。
- en: 13.6.3\. IL representation of ref-like structs
  id: totrans-1291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.6.3\. ref-like 结构的 IL 表示
- en: Ref-like structs are decorated with an `[IsRefLikeAttribute]` attribute that
    is again from the `System.Runtime.CompilerServices` namespace. If you’re targeting
    a version of the framework that doesn’t have the attribute available, it’ll be
    generated in your assembly.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: ref-like 结构被装饰了一个 `[IsRefLikeAttribute]` 属性，这个属性同样来自 `System.Runtime.CompilerServices`
    命名空间。如果你针对的框架版本没有提供该属性，它将在你的程序集中生成。
- en: Unlike `in` parameters, the compiler doesn’t use the `modreq` modifier to require
    any tools consuming the type to be aware of it; instead, it also adds an `[ObsoleteAttribute]`
    to the type with a fixed message. Any compiler that understands `[IsRefLikeAttribute]`
    can ignore the `[ObsoleteAttribute]` if it has the right text. If the type author
    wants to make the type obsolete, they just use `[ObsoleteAttribute]` as normal,
    and the compiler will treat it as any other obsolete type.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `in` 参数不同，编译器不会使用 `modreq` 修饰符来要求任何消耗该类型的工具了解它；相反，它还会向该类型添加一个带有固定信息的 `[ObsoleteAttribute]`。任何理解
    `[IsRefLikeAttribute]` 的编译器都可以忽略 `[ObsoleteAttribute]`，如果它有正确的文本。如果类型作者想要使类型过时，他们只需像平常一样使用
    `[ObsoleteAttribute]`，编译器就会将其视为任何其他过时类型。
- en: Summary
  id: totrans-1294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: C# 7 adds support for pass-by-reference semantics in many areas of the language.
  id: totrans-1295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7 在语言的许多方面增加了对按引用语义的支持。
- en: C# 7.0 included only the first few features; use C# 7.3 for the full range.
  id: totrans-1296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7.0 仅包含了一些基本功能；请使用 C# 7.3 以获取完整的功能范围。
- en: The primary aim of the ref-related features is for performance. If you’re not
    writing performance-critical code, you may not need to use many of these features.
  id: totrans-1297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ref 相关功能的主要目的是性能。如果你不是在编写性能关键代码，你可能不需要使用这些功能中的许多。
- en: Ref-like structs allow the introduction of new abstractions in the framework,
    starting with `Span<T>`. These abstractions aren’t just for high-performance scenarios;
    they’re likely to affect a large proportion of .NET developers over time.
  id: totrans-1298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ref-like 结构允许在框架中引入新的抽象，从 `Span<T>` 开始。这些抽象不仅适用于高性能场景；随着时间的推移，它们可能会影响大量 .NET
    开发者。
- en: Chapter 14\. Concise code in C# 7
  id: totrans-1299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 14 章\. C# 7 的简洁代码
- en: '|  |'
  id: totrans-1300
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Declaring methods within methods
  id: totrans-1302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法内声明方法
- en: Simplifying calls by using `out` parameters
  id: totrans-1303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `out` 参数简化调用
- en: Writing numeric literals more readably
  id: totrans-1304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更易于阅读的数字字面量
- en: Using `throw` as an expression
  id: totrans-1305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `throw` 用作表达式
- en: Using default literals
  id: totrans-1306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认字面量
- en: '|  |'
  id: totrans-1307
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'C# 7 comes with large features that change the way we approach code: tuples,
    deconstruction, and patterns. It comes with complex but effective features that
    are squarely aimed at high-performance scenarios. It also comes with a set of
    small features that just make life a little bit more pleasant. There’s no single
    feature in this chapter that’s earth-shattering; each makes a small difference,
    and the combination of all of them can lead to beautifully concise, clear code.'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 带来了大量改变我们编写代码方式的功能：元组、解构和模式。它带来了复杂但有效的功能，这些功能直接针对高性能场景。它还带来了一组小功能，这些功能只是让生活更加愉快。本章没有哪个功能是震撼性的；每个都带来了一点点改变，所有这些功能的组合可以导致代码简洁、清晰。
- en: 14.1\. Local methods
  id: totrans-1309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1\. 局部方法
- en: If this weren’t *C# in Depth*, this section would be short indeed; you can write
    methods within methods. There’s more to it than that, of course, but let’s start
    with a simple example. The following listing shows a simple local method within
    a regular `Main` method. The local method prints and then increments a local variable
    declared within `Main`, demonstrating that variable capture works with local methods.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不是“C# 深入”，这一节确实会很简短；你可以在方法内部编写方法。当然，这不仅仅是那样，但让我们从一个简单的例子开始。以下列表显示了一个在常规 `Main`
    方法内的简单局部方法。局部方法打印并增加在 `Main` 内声明的局部变量，这证明了变量捕获与局部方法一起工作。
- en: Listing 14.1\. A simple local method that accesses a local variable
  id: totrans-1311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.1\. 访问局部变量的简单局部方法
- en: '[PRE173]'
  id: totrans-1312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '***1* Declares local variable used within method**'
  id: totrans-1313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明在方法中使用中的局部变量**'
- en: '***2* Calls local method twice**'
  id: totrans-1314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用局部方法两次**'
- en: '***3* Local method**'
  id: totrans-1315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 局部方法**'
- en: 'This looks a bit odd when you see it for the first time, but you soon get used
    to it. Local methods can appear anywhere you have a block of statements: methods,
    constructors, properties, indexers, event accessors, finalizers, and even within
    anonymous functions or nested within another local method.'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次看到它时，这看起来有点奇怪，但很快你就会习惯。局部方法可以出现在你拥有语句块的地方：方法、构造函数、属性、索引器、事件访问器、终结器，甚至匿名函数或嵌套在其他局部方法内。
- en: 'A local method declaration is like a normal method declaration but with the
    following restrictions:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法声明类似于正常的方法声明，但有以下限制：
- en: It can’t have any access modifiers (`public` and so on).
  id: totrans-1318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能有任何访问修饰符（如 `public` 等）。
- en: It can’t have the `extern`, `virtual`, `new`, `override`, `static`, or `abstract`
    modifiers.
  id: totrans-1319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能有 `extern`、`virtual`、`new`、`override`、`static` 或 `abstract` 修饰符。
- en: It can’t have any attributes (such as `[MethodImpl])` applied to it.
  id: totrans-1320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能有任何属性（如 `[MethodImpl]`）应用于它。
- en: It can’t have the same name as another local method within the same parent;
    there’s no way to overload local methods.
  id: totrans-1321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能与同一父级内的另一个局部方法有相同的名称；没有方法可以重载局部方法。
- en: 'On the other hand, a local method acts like standard methods in other ways,
    such as the following:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，局部方法在其他方面表现得像标准方法，例如以下情况：
- en: It can be `void` or return a value.
  id: totrans-1323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以是 `void` 或返回值。
- en: It can have the `async` modifier.
  id: totrans-1324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以有 `async` 修饰符。
- en: It can have the `unsafe` modifier.
  id: totrans-1325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以有 `unsafe` 修饰符。
- en: It can be implemented via an iterator block.
  id: totrans-1326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过迭代器块实现。
- en: It can have parameters, including optional ones.
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以有参数，包括可选的。
- en: It can be generic.
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以是泛型的。
- en: It can refer to any enclosing type parameters.
  id: totrans-1329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以引用任何封装的类型参数。
- en: It can be the target of a method group conversion to a delegate type.
  id: totrans-1330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以是方法组转换为委托类型的目标。
- en: 'As shown in the [listing 14.1](kindle_split_031_split_000.html#ch14ex01), it’s
    fine to declare the method after it’s used. Local methods can call themselves
    or other local methods that are in scope. Positioning can still be important,
    though, largely in terms of how the local methods refer to *captured variables*:
    local variables declared in the enclosing code but used in the local method.'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 14.1](kindle_split_031_split_000.html#ch14ex01)所示，在方法使用后声明方法是完全可以的。局部方法可以调用自身或作用域内的其他局部方法。然而，位置仍然很重要，这主要是指局部方法如何引用*捕获的变量*：在封装代码中声明的局部变量，但在局部方法中使用。
- en: Indeed, much of the complexity around local methods, both in language rules
    and implementation, revolves around the ability for them to read and write captured
    variables. Let’s start off by talking about the rules that the language imposes.
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，关于局部方法的复杂性问题，无论是语言规则还是实现，都围绕着它们读取和写入捕获变量的能力。让我们从讨论语言强加的规则开始。
- en: 14.1.1\. Variable access within local methods
  id: totrans-1333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.1\. 局部方法中的变量访问
- en: You’ve already seen that local variables in the enclosing block can be read
    and written, but there’s more nuance to it than that. There are a lot of small
    rules here, but you don’t need to worry about learning them exhaustively. Most
    of the time you won’t even notice them, and you can refer back to this section
    if the compiler complains about code that you expect to be valid.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，封装块中的局部变量可以被读取和写入，但这比这更微妙。这里有很多小的规则，但你不需要担心彻底学习它们。大多数时候你甚至不会注意到它们，如果编译器对预期有效的代码提出抱怨，你可以参考这一节。
- en: A local method can capture only variables that are in scope
  id: totrans-1335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 局部方法只能捕获作用域内的变量。
- en: 'You can’t refer to a local variable outside its scope, which is, broadly speaking,
    the block in which it’s declared. For example, suppose you want your local method
    to use an iteration variable declared in a loop; the local method itself has to
    be declared in the loop, too. As a trivial example, this isn’t valid:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在变量的作用域外引用局部变量，这通常是指它声明的代码块。例如，假设你希望你的局部方法使用在循环中声明的迭代变量；局部方法本身也必须在循环中声明。作为一个简单的例子，这是无效的：
- en: '[PRE174]'
  id: totrans-1337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '***1* Unable to access i; it’s not in scope.**'
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无法访问 i；它不在作用域内。**'
- en: But with the local method inside the loop, it’s valid:^([[1](kindle_split_031_split_000.html#ch14fn1)])
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 但在循环内的局部方法中，这是有效的:^([[1](kindle_split_031_split_000.html#ch14fn1)])
- en: ¹
  id: totrans-1340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It may be a little strange to read, but it’s valid.
  id: totrans-1342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 读起来可能有点奇怪，但它是有效的。
- en: '[PRE175]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '***1* Local method declared within loop; i is in scope.**'
  id: totrans-1344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在循环内声明的局部方法；i 在作用域内。**'
- en: A local method must be declared after the declaration of any vari- iables it
    captures
  id: totrans-1345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 局部方法必须在捕获任何变量的声明之后声明
- en: 'Just as you can’t use a variable earlier than its declaration in regular code,
    you can’t use a captured variable in a local method until after its declaration,
    either. This rule is more for consistency than out of necessity; it would’ve been
    feasible to specify the language to require that any calls to the method occur
    after the variable’s declaration, for example, but it’s simpler to require all
    access to occur after declaration. Here’s another trivial example of invalid code:'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在常规代码中你不能在变量声明之前使用变量一样，你也不能在局部方法中在声明之后使用捕获的变量。这个规则更多的是为了保持一致性，而不是出于必要性；例如，指定语言要求任何对方法的调用都在变量声明之后进行是可行的，但要求所有访问都在声明之后进行要简单得多。这里还有一个无效代码的简单例子：
- en: '[PRE176]'
  id: totrans-1347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '***1* CS0841: Can’t use local variable i before it’s declared**'
  id: totrans-1348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* CS0841: 在声明之前不能使用局部变量 i**'
- en: Just moving the local method declaration to after the variable declaration (whether
    before or after the `PrintI()` call) fixes the error.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将局部方法声明移动到变量声明之后（无论是在 `PrintI()` 调用之前还是之后）就可以修复错误。
- en: A Local method can’t capture ref parameters of the enclosing method
  id: totrans-1350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 局部方法不能捕获封装方法的 ref 参数
- en: 'Just like anonymous functions, local methods aren’t permitted to use reference
    parameters of their enclosing method. For example, this is invalid:'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 就像匿名函数一样，局部方法不允许使用封装方法的引用参数。例如，这是无效的：
- en: '[PRE177]'
  id: totrans-1352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '***1* Invalid access to reference parameter**'
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效访问引用参数**'
- en: 'The reason for this prohibition for anonymous functions is that the created
    delegate might outlive the variable being captured. In most cases, this reason
    wouldn’t apply to local methods, but as you’ll see later, it’s possible for local
    methods to have the same kind of issue. In most cases, you can work around this
    by declaring an extra parameter in the local method and passing the reference
    parameter by reference again:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于匿名函数禁止此操作的原因是创建的委托可能会比捕获的变量存在的时间更长。在大多数情况下，这个原因不适用于局部方法，但正如你稍后将会看到的，局部方法也可能出现同样的问题。在大多数情况下，你可以通过在局部方法中声明一个额外的参数并通过引用再次传递引用参数来解决这个问题：
- en: '[PRE178]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: If you don’t need to modify the parameter within the local method, you can make
    it a value parameter instead.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要在局部方法中修改参数，你可以将其改为值参数。
- en: As a corollary of this restriction (again, mirroring a restriction for anonymous
    functions), local methods declared within structs can’t access `this`. Imagine
    that `this` is an implicit extra parameter at the start of every instance method’s
    parameter list. For class methods, it’s a value parameter; for struct methods,
    it’s a reference parameter. Therefore, you can capture `this` in local methods
    in classes but not in structs. The same workaround applies as for other reference
    parameters.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个限制的推论（再次，与匿名函数的限制相呼应），在结构体内部声明的局部方法不能访问 `this`。想象一下，`this` 是每个实例方法参数列表开头的隐式额外参数。对于类方法，它是一个值参数；对于结构体方法，它是一个引用参数。因此，你可以在类中的局部方法中捕获
    `this`，但不能在结构体中。对于其他引用参数，同样的解决方案也适用。
- en: '|  |'
  id: totrans-1358
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I’ve provided an example in the source code accompanying the book in LocalMethodUsingThisInStruct.cs.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 我在书中提供的源代码示例中提供了 LocalMethodUsingThisInStruct.cs。
- en: '|  |'
  id: totrans-1361
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Local methods interact with definite assignment
  id: totrans-1362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 局部方法与确定赋值交互
- en: The rules of definite assignment in C# are complicated, and local methods complicate
    them further. The simplest way to think about it is as if the method were inlined
    at any point where it’s called. That impacts assignment in two ways.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: C#中明确赋值的规则很复杂，局部方法使它们更加复杂。最简单的方式来思考它就是，方法在任何被调用的地方都被内联。这会影响赋值，有两个方面的影响。
- en: 'First, if a method that reads a captured variable is called before it’s definitely
    assigned, that causes a compile-time error. Here’s an example that tries to print
    the value of a captured variable in two places: once before it’s been assigned
    a value and once afterward:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果一个读取捕获变量的方法在它被明确赋值之前被调用，这将导致编译时错误。以下是一个尝试在两个地方打印捕获变量值的示例：一次是在它被赋值之前，一次是在之后：
- en: '[PRE179]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '***1* CS0165: Use of unassigned local variable ‘i’**'
  id: totrans-1366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* CS0165: 使用未分配的局部变量‘i’**'
- en: '***2* No error: i is definitely assigned here.**'
  id: totrans-1367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 没有错误：在这里i被明确赋值。**'
- en: Notice that it’s the location of the call to `PrintI` that causes the error
    here; the location of the method declaration itself is fine. If you move the assignment
    to `i` before any calls to `PrintI()`, that’s fine, even if it’s still after the
    declaration of `PrintI()`.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里导致错误的是调用`PrintI`的位置；方法声明的位置本身是没问题的。如果你在调用`PrintI()`之前将`i`的赋值移动到任何位置，那也是可以的，即使它仍然在`PrintI()`声明之后。
- en: 'Second, if a local method writes to a captured variable in all possible execution
    flows, the variable will be definitely assigned at the end of any call to that
    method. Here’s an example that assigns a value within a local method but then
    reads it within the containing method:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果局部方法在所有可能的执行流程中都向捕获变量写入，那么在调用该方法的任何地方，变量将在方法调用的末尾被明确赋值。以下是一个在局部方法中分配值但然后在包含方法中读取它的示例：
- en: '[PRE180]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '***1* Call to the method makes i definitely assigned.**'
  id: totrans-1371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用方法使i被明确赋值。**'
- en: '***2* So it’s fine to print it out.**'
  id: totrans-1372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 因此打印出来是没问题的。**'
- en: '***3* Method performs the assignment.**'
  id: totrans-1373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 方法执行了赋值。**'
- en: There are a couple of final points to make about local methods and variables,
    but this time the variables under discussion are not captured variables but fields.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 关于局部方法和变量，还有一些最终要说明的点，但这次讨论的变量不是捕获变量，而是字段。
- en: Local methods can’t assign read-only fields
  id: totrans-1375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 局部方法不能分配只读字段
- en: 'Read-only fields can be assigned values only in field initializers or constructors.
    That rule doesn’t change with local methods, but it’s made a little stricter:
    even if a local method is declared within a constructor, it doesn’t count as being
    inside the constructor in terms of field initialization. This code is invalid:'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 只读字段只能在字段初始化器或构造函数中分配值。这个规则在局部方法中不会改变，但它变得更加严格：即使一个局部方法是在构造函数中声明的，它也不算作在构造函数内部进行字段初始化。以下代码是无效的：
- en: '[PRE181]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '***1* Invalid assignment to read-only field**'
  id: totrans-1378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效地分配到只读字段**'
- en: This restriction isn’t likely to be a significant problem, but it’s worth being
    aware of. It stems from the fact that the CLR hasn’t had to change in order to
    support local methods. They’re just a compiler transformation. This leads us to
    considering exactly how the compiler *does* implement local methods, particularly
    with respect to captured variables.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制可能不会成为一个重大问题，但值得注意。这源于CLR不需要改变以支持局部方法。它们只是编译器转换。这让我们考虑编译器是如何实现局部方法的，特别是关于捕获变量的方面。
- en: 14.1.2\. Local method implementations
  id: totrans-1380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.2\. 局部方法实现
- en: Local methods don’t exist at the CLR level.^([[2](kindle_split_031_split_000.html#ch14fn2)])
    The C# compiler converts local methods into regular methods by performing whatever
    transformations are required to make the final code behave according to the language
    rules. This section provides examples of the transformations implemented by Roslyn
    (the Microsoft C# compiler) and focuses on how captured variables are treated,
    as that’s the most complex aspect of the transformation.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLR级别上不存在局部方法.^([[2](kindle_split_031_split_000.html#ch14fn2)]) C#编译器通过执行所需的任何转换，将局部方法转换为常规方法，以使最终代码的行为符合语言规则。本节提供了Roslyn（Microsoft
    C#编译器）实现的转换示例，并重点介绍了如何处理捕获的变量，因为这是转换中最复杂的部分。
- en: ²
  id: totrans-1382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a C# compiler were to target an environment where local methods did exist,
    all of the information in this section would probably be irrelevant for that compiler.
  id: totrans-1384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果C#编译器要针对一个存在局部方法的运行环境，本节中的所有信息可能对该编译器都无关紧要。
- en: '|  |'
  id: totrans-1385
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Implementation details: Nothing guaranteed here**'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现细节：这里没有保证**'
- en: This section really is about how the C# 7.0 version of Roslyn implements local
    methods. This implementation could change in future versions of Roslyn, and other
    C# compilers may use a different implementation. It also means there’s quite a
    lot of detail here that you may not be interested in.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分实际上是在讲述 Roslyn 7.0 版本的 C# 如何实现局部方法。这种实现可能会在 Roslyn 的未来版本中发生变化，其他 C# 编译器可能使用不同的实现。这也意味着这里有很多细节，你可能并不感兴趣。
- en: The implementation does have performance implications that may affect how comfortable
    you are with using local methods in performance-sensitive code. But as with all
    performance matters, you should be basing your decisions more on careful measurement
    than on theory.
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 实现确实有性能影响，可能会影响你在性能敏感的代码中使用局部方法的舒适度。但与所有性能问题一样，你应该更多地基于仔细的测量而不是理论来做出决定。
- en: '|  |'
  id: totrans-1389
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Local methods feel like anonymous functions in the way they can capture local
    variables from their surrounding code. But significant differences in the implementation
    can make local methods rather more efficient in many cases. At the root of this
    difference is the lifetime of the local variables involved. If an anonymous function
    is converted into a delegate instance, that delegate could be invoked long after
    the method has returned, so the compiler has to perform tricks, hoisting the captured
    variables into a class and making the delegate refer to a method in that class.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法在捕获周围代码中的局部变量方面类似于匿名函数。但在实现上的显著差异使得局部方法在许多情况下更加高效。这种差异的根源在于涉及的局部变量的生命周期。如果一个匿名函数被转换为委托实例，那么这个委托可以在方法返回很长时间后调用，因此编译器必须进行一些技巧，将捕获的变量提升到类中，并使委托引用该类中的方法。
- en: 'Compare that with local methods: in most cases, the local method can be invoked
    only during the call of the enclosing method; you don’t need to worry about it
    referring to captured variables after that call has completed. That allows for
    a more efficient, stack-based implementation with no heap allocations. Let’s start
    reasonably simply with a local method that increments a captured variable by an
    amount specified as an argument to the local method.'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 与局部方法相比：在大多数情况下，局部方法只能在封装方法的调用期间调用；你不必担心在调用完成后它引用捕获的变量。这允许实现一个更高效、基于堆栈的实现，没有堆分配。让我们从一个简单的局部方法开始，该局部方法通过作为局部方法参数指定的数量来增加捕获的变量。
- en: Listing 14.2\. Local method modifying a local variable
  id: totrans-1392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.2\. 修改局部变量的局部方法
- en: '[PRE182]'
  id: totrans-1393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: What does Roslyn do with this method? It creates a private mutable struct with
    public fields to represent all the local variables in the same scope that are
    captured by any local method. In this case, that’s just the `i` variable. It creates
    a local variable within the `Main` method of that struct type and passes the variable
    by reference to the regular method created from `AddToI` along with the declared
    `amount` parameter, of course. You end up with something like the following listing.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: Roslyn 对这个方法做了什么？它创建了一个具有公共字段的私有可变结构体来表示同一作用域中所有被任何局部方法捕获的局部变量。在这种情况下，那就是 `i`
    变量。它在该结构体的 `Main` 方法中创建一个局部变量，并将变量通过引用传递给从 `AddToI` 创建的常规方法，当然还有声明的 `amount` 参数。你最终得到如下所示的内容。
- en: Listing 14.3\. What Roslyn does with [listing 14.2](kindle_split_031_split_000.html#ch14ex02)
  id: totrans-1395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.3\. Roslyn 对 [列表 14.2](kindle_split_031_split_000.html#ch14ex02) 的处理
- en: '[PRE183]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '***1* Generated mutable struct to store the local variables from Main**'
  id: totrans-1397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 生成可变结构体以存储 Main 中的局部变量**'
- en: '***2* Creates and uses a value of the struct within the method**'
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在方法内创建和使用结构体值**'
- en: '***3* Passes the struct by reference to the generated method**'
  id: totrans-1399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将结构体通过引用传递给生成的局部方法**'
- en: '***4* Generated method to represent the original local method**'
  id: totrans-1400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 生成方法来表示原始局部方法**'
- en: As usual, the compiler generates unspeakable names for the method and the struct.
    Note that in this example, the generated method is static. That’s the case when
    either the local method is originally contained in a static member or when it’s
    contained in an instance member but the local method doesn’t capture `this` (explicitly
    or implicitly by using instance members within the local method).
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，编译器为方法和结构体生成难以言喻的名字。注意，在这个例子中，生成的局部方法是静态的。这是当局部方法最初包含在静态成员中，或者当它包含在实例成员中但局部方法没有捕获
    `this`（显式或隐式地通过在局部方法中使用实例成员）时的情况。
- en: 'The important point about generating this struct is that the transformation
    is almost free in terms of performance: all the local variables that would’ve
    been on the stack before are still on the stack; they are just bunched together
    in a struct so that they can be passed by reference to the generated method. Passing
    the struct by reference has two benefits:'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此结构体的重要之处在于，从性能角度来看，这种转换几乎是免费的：所有原本应该在栈上的局部变量现在仍然在栈上；它们只是被组合在一个结构体中，以便可以将它们通过引用传递给生成的函数。通过引用传递结构体有两个好处：
- en: It allows the local method to modify the local variables.
  id: totrans-1403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许局部方法修改局部变量。
- en: However many local variables are captured, calling the local method is cheap.
    (Compare that with passing them all by value, which would mean creating a second
    copy of each captured local variable.)
  id: totrans-1404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论捕获了多少局部变量，调用局部方法都是低成本的。（与之相比，如果通过值传递它们，则意味着每个捕获的局部变量都需要创建第二个副本。）
- en: All of this without any garbage being generated on the heap. Hooray! Now let’s
    make things a little more complex.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都不会在堆上生成任何垃圾。太好了！现在让我们使事情变得稍微复杂一些。
- en: Capturing variables in multiple scopes
  id: totrans-1406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在多个作用域中捕获变量
- en: In an anonymous function, if local variables are captured from multiple scopes,
    multiple classes are generated with a field in each class representing the inner
    scope holding a reference to an instance of the class representing the outer scope.
    That wouldn’t work with the struct approach for local methods that you just saw
    because of the copying involved. Instead, the compiler generates one struct for
    each scope containing a captured variable and uses a separate parameter for each
    scope. The following listing deliberately creates two scopes, so we can see how
    the compiler handles it.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 在匿名函数中，如果从多个作用域捕获局部变量，则会生成多个类，每个类都有一个字段，表示内部作用域，该字段包含对表示外部作用域的类的实例的引用。由于涉及复制，这不会适用于你刚才看到的局部方法的结构体方法。相反，编译器为每个包含捕获变量的作用域生成一个结构体，并为每个作用域使用一个单独的参数。以下列表故意创建了两个作用域，这样我们就可以看到编译器是如何处理的。
- en: Listing 14.4\. Capturing variables from multiple scopes
  id: totrans-1408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.4\. 从多个作用域捕获变量
- en: '[PRE184]'
  id: totrans-1409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: I used a simple `if` statement to introduce a new scope rather than a `for`
    or `foreach` loop, because this made the translation simpler to represent reasonably
    accurately. The following listing shows the compiler how the compiler translates
    the local methods into regular ones.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个简单的 `if` 语句来引入一个新的作用域，而不是 `for` 或 `foreach` 循环，因为这使得翻译更容易合理准确地表示。以下列表显示了编译器如何将局部方法转换为常规方法。
- en: Listing 14.5\. What Roslyn does with [listing 14.4](kindle_split_031_split_000.html#ch14ex04)
  id: totrans-1411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.5\. Roslyn 对 [列表 14.4](kindle_split_031_split_000.html#ch14ex04) 的处理
- en: '[PRE185]'
  id: totrans-1412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '***1* Generated struct for outer scope**'
  id: totrans-1413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为外部作用域生成的结构体**'
- en: '***2* Generated struct for inner scope**'
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为内部作用域生成的结构体**'
- en: '***3* Uncaptured local variable**'
  id: totrans-1415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 未捕获的局部变量**'
- en: '***4* Creates and uses struct for outer scope variable hour**'
  id: totrans-1416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为外部作用域变量 hour 创建并使用结构体**'
- en: '***5* Creates and uses struct for inner scope variable minute**'
  id: totrans-1417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 为内部作用域变量 minute 创建并使用结构体**'
- en: '***6* Passes both structs by reference to generated method**'
  id: totrans-1418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 通过引用将两个结构体传递给生成的方法**'
- en: '***7* Generated method to represent the original local method**'
  id: totrans-1419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 生成的表示原始局部方法的函数**'
- en: In addition to demonstrating how multiple scopes are handled, this listing shows
    that uncaptured local variables aren’t included in the generated structs.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 除了演示如何处理多个作用域之外，此列表还显示未捕获的局部变量不包括在生成的结构体中。
- en: So far, we’ve looked at cases where the local method can execute only while
    the containing method is executing, which makes it safe for the local variables
    to be captured in this efficient way. In my experience, this covers most of the
    cases where I’ve wanted to use local methods. There are occasional exceptions
    to that safe situation, though.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已查看的情况是，局部方法只能在包含方法执行时执行，这使得局部变量以这种方式被捕获是安全的。在我的经验中，这涵盖了我想使用局部方法的绝大多数情况。尽管如此，偶尔也会出现一些例外情况。
- en: Prison break! How local methods can escape their containing code
  id: totrans-1422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 监狱越狱！本地方法如何逃离其包含的代码
- en: 'Local methods behave like regular methods in four ways that can stop the compiler
    from performing the “keep everything on the stack” optimization we’ve discussed
    so far:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法以四种方式表现得像常规方法，这可以阻止编译器执行我们之前讨论的“将所有内容保持在栈上”的优化：
- en: They can be asynchronous, so a call that returns a task almost immediately won’t
    necessarily have finished executing the logical operation.
  id: totrans-1424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以是异步的，因此一个几乎立即返回任务的调用不一定会完成逻辑操作。
- en: They can be implemented with iterators, so a call that creates a sequence will
    need to continue executing the method when the next value in the sequence is requested.
  id: totrans-1425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用迭代器实现，因此创建序列的调用在请求序列中的下一个值时需要继续执行方法。
- en: They can be called from anonymous functions, which could in turn be called (as
    delegates) long after the original method has finished.
  id: totrans-1426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以从匿名函数中调用，而这些匿名函数又可以（作为委托）在原始方法完成很久之后被调用。
- en: They can be the targets of method group conversions, again creating delegates
    that can outlive the original method call.
  id: totrans-1427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以是方法组转换的目标，再次创建可以超出原始方法调用生命周期的委托。
- en: The following listing shows a simple example of the last bullet point. A local
    `Count` method captures a local variable in its enclosing `CreateCounter` method.
    The `Count` method is used to create an `Action` delegate, which is then invoked
    after the `CreateCounter` method has returned.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了最后一个要点的一个简单示例。一个局部 `Count` 方法在其封装的 `CreateCounter` 方法中捕获一个局部变量。`Count`
    方法用于创建一个 `Action` 委托，然后在 `CreateCounter` 方法返回后调用该委托。
- en: Listing 14.6\. Method group conversion of a local method
  id: totrans-1429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.6\. 局部方法的方法组转换
- en: '[PRE186]'
  id: totrans-1430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '***1* Invokes the delegate after CreateCounter has finished**'
  id: totrans-1431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 CreateCounter 完成后调用委托**'
- en: '***2* Local variable captured by Count**'
  id: totrans-1432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Count 捕获的局部变量**'
- en: '***3* Method group conversion of Count to an Action delegate**'
  id: totrans-1433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 Count 转换为 Action 委托的方法组转换**'
- en: '***4* Local method**'
  id: totrans-1434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 局部方法**'
- en: 'You can’t use a struct on the stack for `count` anymore. The stack for `CreateCounter`
    won’t exist by the time the delegate is invoked. But this feels very much like
    an anonymous function now; you could’ve implemented `CreateCounter` by using a
    lambda expression instead:'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能再在栈上使用结构体作为 `count`。当委托被调用时，`CreateCounter` 的栈将不存在。但现在这非常像匿名函数；你本可以用 lambda
    表达式来实现 `CreateCounter`：
- en: '[PRE187]'
  id: totrans-1436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '***1* Alternative implementation using a lambda expression**'
  id: totrans-1437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 lambda 表达式实现的替代实现**'
- en: 'That gives you a clue as to how the compiler can implement the local method:
    it can apply a similar transformation for the local method as it would for the
    lambda expression, as shown in the following listing.'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 这为你提供了关于编译器如何实现局部方法的线索：它可以为局部方法应用与 lambda 表达式类似的转换，如下面的列表所示。
- en: Listing 14.7\. What Roslyn does with [listing 14.6](kindle_split_031_split_000.html#ch14ex06)
  id: totrans-1439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.7\. Roslyn 对 [列表 14.6](kindle_split_031_split_000.html#ch14ex06) 的处理
- en: '[PRE188]'
  id: totrans-1440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '***1* Creates and initializes object holding captured variables**'
  id: totrans-1441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建并初始化包含捕获变量的对象**'
- en: '***2* Method group conversion of instance method from holder**'
  id: totrans-1442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从持有者转换实例方法的方法组转换**'
- en: '***3* Private class with captured variables and local method**'
  id: totrans-1443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含捕获变量和局部方法的私有类**'
- en: '***4* Captured variable**'
  id: totrans-1444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 捕获的变量**'
- en: '***5* Local method is now an instance method in generated class**'
  id: totrans-1445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 局部方法现在是生成类中的实例方法**'
- en: The same kind of transformation is performed if the local method is used within
    an anonymous function if it’s an async method or if it’s an iterator (with `yield`
    statements). The performance-minded may wish to be aware that async methods and
    iterators can end up generating multiple objects; if you’re working hard to prevent
    allocations and you’re using local methods, you may wish to pass parameters explicitly
    to those local methods instead of capturing local variables. An example of this
    is shown in the next section.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果局部方法在匿名函数中使用（如果是异步方法或迭代器（带有 `yield` 语句）），则会执行类似的转换。注重性能的人可能希望知道，异步方法和迭代器最终可能会生成多个对象；如果你正在努力防止分配，并且使用局部方法，你可能希望明确将这些参数传递给这些局部方法，而不是捕获局部变量。下一个部分将展示一个这样的例子。
- en: Of course, the set of possible scenarios is pretty huge; one local method could
    use a method conversion for another local method, or you could use a local method
    within an async method, and so on. I’m certainly not going to try to cover every
    possible case here. This section is intended to give you a good idea of the two
    kinds of transformation the compiler can use when dealing with captured variables.
    To see what it’s doing with *your* code, use a decompiler or ildasm, remembering
    to disable any “optimizations” the decompiler might do for you. (Otherwise, it
    could easily just show the local method, which doesn’t help you at all.) Now that
    you’ve seen what you can do with local methods and how the compiler handles them,
    let’s consider when it’s appropriate to use them.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可能的场景集相当庞大；一个局部方法可能使用方法转换来调用另一个局部方法，或者你可以在异步方法中使用局部方法，等等。我当然不会试图在这里涵盖所有可能的案例。本节旨在给你一个很好的概念，了解编译器在处理捕获变量时可以使用的两种转换类型。要查看编译器对你的代码做了什么，请使用反编译器或
    ildasm，同时记得禁用反编译器可能为你做的任何“优化”。（否则，它可能只会显示局部方法，这对您没有任何帮助。）现在你已经看到了你可以用局部方法做什么以及编译器如何处理它们，让我们考虑何时使用它们是合适的。
- en: 14.1.3\. Usage guidelines
  id: totrans-1448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.3\. 使用指南
- en: 'There are two primary patterns to spot where local methods might be applicable:'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要模式可以用来发现局部方法可能适用的场景：
- en: You have the same logic repeated multiple times in a method.
  id: totrans-1450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在方法中重复多次相同的逻辑。
- en: You have a private method that’s used from only one other method.
  id: totrans-1451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个仅从另一个方法中使用的私有方法。
- en: The second case is a special case of the first in which you’ve taken the time
    to refactor the common code already. But the first case can occur when there’s
    enough local state to make that refactoring ugly. Local methods can make the extraction
    significantly more appealing because of the ability to capture local variables.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是第一种情况的特殊情况，其中你已经花时间重构了通用代码。但是，当有足够的局部状态使重构变得丑陋时，第一种情况可能会发生。局部方法可以通过捕获局部变量的能力使提取变得更具吸引力。
- en: 'When refactoring an existing method to become a local method, I advise consciously
    taking a two-stage approach. First, move the single-use method into the code that
    uses it without changing its signature.^([[3](kindle_split_031_split_000.html#ch14fn3)])
    Second, look at the method parameters: are all the calls to the method using the
    same local variables as arguments? If so, those are good candidates for using
    captured variables instead, removing the parameter from the local method. Sometimes
    you may even be able to remove the parameters entirely.'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 当将现有方法重构为局部方法时，我建议有意识地采取两阶段的方法。首先，将单次使用的方法移动到使用它的代码中，而不改变其签名.^([[3](kindle_split_031_split_000.html#ch14fn3)])
    第二，查看方法参数：所有调用该方法的是否都使用相同的局部变量作为参数？如果是，那么这些就是使用捕获变量代替参数的好候选，从而从局部方法中移除参数。有时你甚至可能完全移除参数。
- en: ³
  id: totrans-1454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sometimes this requires changes to the type parameters in the signature. Often
    if you have one generic method calling another, when you move the second method
    into the first, it can just use the type parameters of the first. [Listing 14.9](kindle_split_031_split_000.html#ch14ex09)
    demonstrates this.
  id: totrans-1456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时这需要更改签名中的类型参数。通常，如果你有一个泛型方法调用另一个方法，当你将第二个方法移动到第一个方法中时，它可以直接使用第一个方法的类型参数。[列表
    14.9](kindle_split_031_split_000.html#ch14ex09) 展示了这一点。
- en: Depending on the number and size of the parameters, this second step could even
    have a performance impact. If you were previously passing large value types by
    value, those were being copied on each call. Using captured variables instead
    can eliminate that copy, which could be significant if the method is being called
    a lot.
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 根据参数的数量和大小，这一步甚至可能对性能产生影响。如果你之前是通过值传递大值类型，那么这些类型在每次调用时都会被复制。使用捕获变量代替可以消除这种复制，如果方法被频繁调用，这可能非常显著。
- en: The important point about local methods is that it becomes clear that they’re
    an implementation detail of a method rather than of a type. If you have a private
    method that makes sense as an operation in its own right but happens to be used
    in only one place at the moment, you may be better off leaving it where it is.
    The payoff—in terms of logical type structure—is much bigger when a private method
    is tightly bound to a single operation and you can’t easily imagine any other
    circumstances where you’d use it.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 关于局部方法的重要点是，它们清楚地表明它们是方法的一个实现细节，而不是类型的一个实现细节。如果你有一个作为独立操作有意义的私有方法，但碰巧目前只在一个地方使用，你最好让它保持原样。当私有方法紧密绑定到单个操作，并且你无法轻易想象任何其他使用它的环境时，这种收益——从逻辑类型结构的角度来看——要大得多。
- en: Iterator/async argument validation and local method optimization
  id: totrans-1459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 迭代器/异步参数验证和局部方法优化
- en: One common example of this is when you have iterator or async methods and want
    to eagerly perform argument validation. For example, the [Listing 14.8](kindle_split_031_split_000.html#ch14ex08)
    provides a sample implementation of one overload of `Select` in LINQ to Objects.
    The argument validation isn’t in an iterator block, so it’s performed as soon
    as the method is called, whereas the `foreach` loop doesn’t execute at all until
    the caller starts iterating over the returned sequence.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个常见例子是当你有迭代器或异步方法，并希望立即执行参数验证。例如，[列表14.8](kindle_split_031_split_000.html#ch14ex08)提供了LINQ
    to Objects中`Select`的一个重载的示例实现。参数验证不在迭代器块中，因此它在方法被调用时立即执行，而`foreach`循环则根本不会执行，直到调用者开始遍历返回的序列。
- en: Listing 14.8\. Implementing `Select` without local methods
  id: totrans-1461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.8\. 不使用局部方法实现`Select`
- en: '[PRE189]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '***1* Eagerly checks arguments**'
  id: totrans-1463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 主动检查参数**'
- en: '***2* Delegates to the implementation**'
  id: totrans-1464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 委派给实现**'
- en: '***3* Implementation executes lazily**'
  id: totrans-1465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实现延迟执行**'
- en: Now, with local methods available, you can move the implementation into the
    `Select` method, as shown in the following listing.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了局部方法可用，你可以将实现移动到`Select`方法中，如下所示。
- en: Listing 14.9\. Implementing `Select` with a local method
  id: totrans-1467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.9\. 使用局部方法实现`Select`
- en: '[PRE190]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'I’ve highlighted one interesting aspect of the implementation: you still pass
    the (now-validated) parameters into the local method. This isn’t required; you
    could make the local method parameterless and just use the captured `source` and
    `selector` variables, but it’s a performance tweak—it reduces the number of allocations
    required. Is this performance difference important? Would the version using variable
    capture be significantly more readable? Answers to both questions depend on the
    context and are likely to be somewhat subjective.'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 我突出显示了一个有趣的实现方面：你仍然将（现在已验证的）参数传递给局部方法。这不是必需的；你可以使局部方法无参数，并仅使用捕获的`source`和`selector`变量，但这是一种性能调整——减少了所需的分配数量。这种性能差异重要吗？使用变量捕获的版本会显著提高可读性吗？这两个问题的答案都取决于上下文，并且可能相当主观。
- en: Readability suggestions
  id: totrans-1470
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 读写建议
- en: 'Local methods are still new enough to me that I’m slightly wary of them. I’m
    erring on the side of leaving code as it is rather than refactoring toward local
    methods at the moment. In particular, I’m avoiding using the following two features:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 局部方法对我来说仍然很新，所以我对此有些谨慎。目前，我更倾向于保持代码原样，而不是重构为局部方法。特别是，我避免使用以下两个特性：
- en: Even though you can declare a local method within the scope of a loop or other
    block, I find that odd to read. I prefer to use local methods only when I can
    declare them right at the bottom of the enclosing method. I can’t capture any
    variables declared within loops, but I’m okay with that.
  id: totrans-1472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使你可以在循环或其他块的范围内声明局部方法，但我发现这很难阅读。我更喜欢只在可以立即在封装方法的底部声明局部方法时使用局部方法。我无法捕获在循环中声明的任何变量，但我对此可以接受。
- en: You can declare local methods within other local methods, but that feels like
    a rabbit hole I’d rather not go down.
  id: totrans-1473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在其他局部方法中声明局部方法，但这感觉像是一个我不愿意陷入的兔子洞。
- en: Your tastes may vary, of course, but as always, I caution against using a new
    feature just because you can. (Experiment with it for the sake of experimentation,
    certainly, but don’t let the new shiny things lure you into sacrificing readability.)
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你的品味可能各不相同，但就像往常一样，我警告你，不要仅仅因为可以就使用新特性。（当然，为了实验而实验，但不要让新玩意儿诱使你牺牲可读性。）
- en: 'Time for some good news: the first feature of this chapter was the big one.
    The remaining features are much simpler.'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息时间：本章的第一个特性是最大的一个。其余的特性要简单得多。
- en: 14.2\. Out variables
  id: totrans-1476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2\. `out` 变量
- en: Before C# 7, `out` parameters were slightly painful to work with. An `out` parameter
    required a variable to already be declared before you could use it as an argument
    for the parameter. Because declarations are separate statements, this meant that
    in some places where you wanted a single expression—initializing a variable, for
    example—you had to reorganize your code to have multiple statements.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7 之前，`out` 参数的使用有些痛苦。`out` 参数需要在将其用作参数的参数之前已经声明一个变量。因为声明是独立的语句，这意味着在某些你想要单个表达式的地方——例如初始化一个变量——你必须重新组织你的代码以包含多个语句。
- en: 14.2.1\. Inline variable declarations for out parameters
  id: totrans-1478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1\. 为 `out` 参数的行内变量声明
- en: 'C# 7 removes this pain point by allowing new variables to be declared within
    the method invocation itself. As a trivial example, consider a method that takes
    textual input, attempts to parse it as an integer using `int.TryParse`, and then
    returns either the parsed value as a nullable integer (if it parsed successfully)
    or null (if it didn’t). In C# 6, this would have to be implemented using at least
    two statements: one to declare the variable and a second to call `int.TryParse`
    passing the newly declared variable for the `out` parameter:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7 通过允许在方法调用本身内部声明新变量来消除这个痛点。作为一个简单的例子，考虑一个接受文本输入的方法，尝试使用 `int.TryParse` 将其解析为整数，然后返回解析成功的解析值作为可空整数（如果解析成功）或
    null（如果未解析）。在 C# 6 中，这至少需要两个语句来实现：一个用于声明变量，另一个用于调用 `int.TryParse` 并将新声明的变量作为 `out`
    参数传递：
- en: '[PRE191]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'In C# 7, the `value` variable can be declared within the method call itself,
    which means you can implement the method with an expression body:'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7 中，`value` 变量可以在方法调用本身内部声明，这意味着你可以使用表达式体实现方法：
- en: '[PRE192]'
  id: totrans-1482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'In several ways, `out` variable arguments behave similarly to variables introduced
    by pattern matches:'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 在几种方式上，`out` 变量参数的行为类似于由模式匹配引入的变量：
- en: If you don’t care about the value, you can use a single underscore as the name
    to create a discard.
  id: totrans-1484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不在乎值，你可以使用单个下划线作为名称来创建一个丢弃项。
- en: You can use `var` to declare an implicitly typed variable (the type is inferred
    from the type of the parameter).
  id: totrans-1485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `var` 来声明一个隐式类型的变量（类型是从参数的类型推断出来的）。
- en: You can’t use an `out` variable argument in an expression tree.
  id: totrans-1486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在表达式树中使用 `out` 变量参数。
- en: The scope of the variable is the surrounding block.
  id: totrans-1487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的作用域是周围的块。
- en: You can’t use `out` variables in field, property, or constructor initializers
    or in query expressions before C# 7.3\. You’ll look at an example of this shortly.
  id: totrans-1488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 7.3 之前，你无法在字段、属性或构造函数初始化器或查询表达式中使用 `out` 变量。你很快就会看到一个例子。
- en: The variable will be definitely assigned if (and only if) the method is definitely
    invoked.
  id: totrans-1489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果（并且仅当）方法被明确调用时，变量将被明确赋值。
- en: 'To demonstrate the last point, consider the following code, which tries to
    parse two strings and sum the results:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明最后一点，考虑以下代码，它尝试解析两个字符串并将结果相加：
- en: '[PRE193]'
  id: totrans-1491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: In the third operand of the conditional operator, `value1` is definitely assigned
    (so you could return that if you like), but `value2` isn’t definitely assigned;
    if the first call to `int.TryParse` returned `false`, you wouldn’t call `int.TryParse`
    the second time because of the short-circuiting nature of the `&&` operator.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件运算符的第三个操作数中，`value1` 被明确赋值（所以如果你愿意，你可以返回它），但 `value2` 没有被明确赋值；如果第一次调用 `int.TryParse`
    返回 `false`，由于 `&&` 运算符的短路性质，你不会第二次调用 `int.TryParse`。
- en: 14.2.2\. Restrictions lifted in C# 7.3 for out variables and pattern variables
  id: totrans-1493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2\. C# 7.3 为 `out` 变量和模式变量取消的限制
- en: As I mentioned in [section 12.5](kindle_split_029_split_000.html#ch12lev1sec5),
    pattern variables can’t be used when initializing fields or properties, in construction
    initializers (`this(...)` and `base(...)`), or in query expressions. The same
    restriction applies to `out` variables until C# 7.3, which lifts all those restrictions.
    The following listing demonstrates this and shows that the result of the `out`
    variable is also available within the constructor body.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第 12.5 节](kindle_split_029_split_000.html#ch12lev1sec5)中提到的，模式变量不能用于初始化字段或属性，在构造初始化器（`this(...)`
    和 `base(...)`）或查询表达式中。相同的限制也适用于 `out` 变量，直到 C# 7.3，那时所有这些限制都被取消。以下列表演示了这一点，并显示
    `out` 变量的结果也可以在构造函数体内部使用。
- en: Listing 14.10\. Using an `out` variable in a constructor initializer
  id: totrans-1495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.10\. 在构造函数初始化器中使用`out`变量
- en: '[PRE194]'
  id: totrans-1496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Although the restrictions prior to C# 7.3 never bothered me, it’s nice that
    they’ve now been removed. In the rare cases that you needed to use patterns or
    `out` variables for initializers, the alternatives were relatively annoying and
    usually involved creating a new method just for this purpose.
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在C# 7.3之前的规定从未让我烦恼，但现在它们已经被移除，这真是个好事。在那些你需要使用模式或`out`变量进行初始化的罕见情况下，替代方案相对令人烦恼，通常需要为这个目的创建一个新的方法。
- en: That’s about it for `out` variable arguments. They’re just a useful little shorthand
    to avoid otherwise-annoying variable declaration statements.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`out`变量参数就这么多。它们只是避免其他可能令人烦恼的变量声明语句的一个有用的简写。
- en: 14.3\. Improvements to numeric literals
  id: totrans-1499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3\. 数值字面量的改进
- en: 'Literals haven’t changed much in the course of C#’s history. No changes at
    all occurred from C# 1 until C# 6, when interpolated string literals were introduced,
    but that didn’t change numbers at all. In C# 7, two features are aimed at number
    literals, both for the sake of improving readability: binary integer literals
    and underscore separators.'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#的历史过程中，字面量并没有发生太大的变化。从C# 1到C# 6，没有任何变化发生，直到引入了插值字符串字面量，但这并没有改变数字。在C# 7中，有两个特性针对数值字面量，都是为了提高可读性：二进制整数字面量和下划线分隔符。
- en: 14.3.1\. Binary integer literals
  id: totrans-1501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.1\. 二进制整数字面量
- en: 'Unlike floating-point literals (for `float`, `double`, and `decimal`), integer
    literals have always had two options for the base of the literal: you could use
    decimal (no prefix) or hex (a prefix of `0x` or `0X`).^([[4](kindle_split_031_split_000.html#ch14fn4)])
    C# 7 extends this to binary literals, which use a prefix of `0b` or `0B`. This
    is particularly useful if you’re implementing a protocol with specific bit patterns
    for certain values. It doesn’t affect the execution-time behavior at all, but
    it can make the code a lot easier to read. For example, which of these three lines
    initializes a byte with the top bit and the bottom three bits set and the other
    bits unset?'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 与浮点字面量（对于`float`、`double`和`decimal`）不同，整数字面量始终有两个选项用于字面量的基数：你可以使用十进制（没有前缀）或十六进制（前缀为`0x`或`0X`）。^([[4](kindle_split_031_split_000.html#ch14fn4)])
    C# 7扩展了这一点到二进制字面量，它使用前缀`0b`或`0B`。这对于实现具有特定位模式的特定值的协议特别有用。它根本不影响执行时的行为，但它可以使代码更容易阅读。例如，以下哪一行初始化了一个字节，其中最高位和最低三位被设置，其他位未被设置？
- en: ⁴
  id: totrans-1503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-1504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The C# designers wisely eschewed the ghastly octal literals that Java inherited
    from C. What’s the value of 011? Why, 9, “of course.”
  id: totrans-1505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C#的设计者明智地避免了Java从C继承的可怕的八进制字面量。011的值是多少？当然，是9。
- en: '[PRE195]'
  id: totrans-1506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: They all do. But you can tell that easily in the third line, whereas the other
    two take slightly longer to check (at least for me). Even that last one takes
    longer than it might, because you still have to check that you have the right
    number of bits in total. If only there were a way of clarifying it even more.
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 他们都这样做。但你可以很容易地在第三行中看出这一点，而其他两行则需要稍微长一点的时间来检查（至少对我来说是这样）。即使最后一行也花的时间比预期的要长，因为你仍然需要检查你是否有正确数量的总位数。如果有一种方法可以进一步澄清那就更好了。
- en: 14.3.2\. Underscore separators
  id: totrans-1508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2\. 下划线分隔符
- en: 'Let’s jump straight into underscore separators by improving the previous example.
    If you want to specify all the bits of a byte and do so in binary, it’s easier
    to spot that you have two nibbles than to count all eight bits. Here’s the same
    code with a fourth line that uses an underscore to separate the nibbles:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过改进之前的示例直接跳到下划线分隔符。如果你想指定字节的全部位并在二进制中这样做，发现你有两个四分位比数所有八个位要容易得多。以下是相同的代码，第四行使用下划线来分隔四分位：
- en: '[PRE196]'
  id: totrans-1510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Love it! I can really check that at a glance. Underscore separators aren’t
    restricted to binary literals, though, or even to integer literals. You can use
    them in any numeric literal and put them (almost) anywhere within the literal.
    In decimal literals, you’re most likely to use them every three digits like thousands
    separators (at least in Western cultures). In hex literals, they’re generally
    most useful every two, four, or eight digits to separate 8-, 16-, or 32-bit parts
    within the literal. For example:'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 真喜欢这个！我确实可以一目了然地检查它。不过，下划线分隔符不仅限于二进制字面量，甚至也不限于整数字面量。你可以在任何数值字面量中使用它们，并将它们（几乎）放在字面量中的任何位置。在十进制字面量中，你很可能会每三位使用一次，就像千位分隔符一样（至少在西方文化中是这样）。在十六进制字面量中，它们通常每两个、四个或八个数字最有用，用于在字面量中分隔8位、16位或32位部分。例如：
- en: '[PRE197]'
  id: totrans-1512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'This flexibility comes at a price: the compiler doesn’t check that you’re putting
    the underscores in sensible places. You can even put multiple underscores together.
    Valid but unfortunate examples include the following:'
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性是有代价的：编译器不会检查你放置下划线是否合理。你甚至可以将多个下划线连在一起。以下是一些有效但不太合适的例子：
- en: '[PRE198]'
  id: totrans-1514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'You also should be aware of a few restrictions:'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意一些限制：
- en: You can’t put an underscore at the start of the literal.
  id: totrans-1516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在字面量的开头放置下划线。
- en: You can’t put an underscore at the end of the literal (including just before
    the suffix).
  id: totrans-1517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在字面量的末尾放置下划线（包括在后缀之前）。
- en: You can’t put an underscore directly before or after the period in a floating-point
    literal.
  id: totrans-1518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在浮点字面量的点号前后直接放置下划线。
- en: In C# 7.0 and 7.1, you can’t put an underscore after the base specifier (`0x`
    or `0b`) of an integer literal.
  id: totrans-1519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C# 7.0 和 7.1 中，你不能在整数字面量的基数指定符（`0x` 或 `0b`）之后放置下划线。
- en: 'The final restriction has been lifted in C# 7.2\. Although readability is subjective,
    I definitely prefer to use an underscore after the base specifier when there are
    underscores elsewhere, as in the following examples:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.2 中已经取消了最后一个限制。虽然可读性是主观的，但我确实更喜欢在其他地方使用下划线时，在基数指定符之后使用下划线，如下面的例子所示：
- en: '`0b_1000_0111` versus `0b1000_0111`'
  id: totrans-1521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0b_1000_0111` 与 `0b1000_0111`'
- en: '`0x_ffff_0000` versus `0xffff_0000`'
  id: totrans-1522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x_ffff_0000` 与 `0xffff_0000`'
- en: That’s it! A nice simple feature with very little nuance. The next feature is
    similarly straightforward and permits a simplification in some cases where you
    need to throw an exception conditionally.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！这是一个简单而实用的功能，几乎没有细微差别。下一个功能同样简单直接，允许在某些需要条件抛出异常的情况下简化操作。
- en: 14.4\. Throw expressions
  id: totrans-1524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4\. 抛出表达式
- en: 'Earlier versions of C# always included the `throw` statement, but you couldn’t
    use `throw` as an expression. Presumably, the reasoning was that you wouldn’t
    want to, because it would always throw an exception. It turns out that as more
    language features were added that needed expressions, this classification became
    increasingly more irritating. In C# 7, you can use *throw expressions* in a limited
    set of contexts:'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 早期版本的 C# 总是包含 `throw` 语句，但你不能将 `throw` 用作表达式。据推测，原因是你可能不想这样做，因为它总是会抛出异常。结果证明，随着更多需要表达式的语言特性的添加，这种分类变得越来越令人烦恼。在
    C# 7 中，你可以在有限的环境中使用 *throw 表达式*：
- en: As the body of a lambda expression
  id: totrans-1526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 lambda 表达式的主体
- en: As the body of an expression-bodied member
  id: totrans-1527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为表达式主体成员的主体
- en: As the second operand of the `??` operator
  id: totrans-1528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 `??` 运算符的第二个操作数
- en: As the second or third operand of the conditional `?:` operator (but not both
    in the same expression)
  id: totrans-1529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为条件运算符 `?:` 的第二个或第三个操作数（但不是在同一表达式中同时使用）
- en: 'All of these are valid:'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是有效的：
- en: '[PRE199]'
  id: totrans-1531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '***1* Expression-bodied method**'
  id: totrans-1532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 表达式主体方法**'
- en: '***2* Lambda expression**'
  id: totrans-1533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Lambda 表达式**'
- en: '***3* ?? operator (in expression-bodied method)**'
  id: totrans-1534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在表达式主体方法中使用 `??` 运算符**'
- en: '***4* ?: operator (in expression-bodied property)**'
  id: totrans-1535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在表达式主体属性中使用 `?:` 运算符**'
- en: 'You can’t use `throw` expressions everywhere, though; that just wouldn’t make
    sense. For example, you can’t use them unconditionally in assignments or as method
    arguments:'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在任何地方使用 `throw` 表达式，但这并不合理。例如，你不能在赋值或方法参数中无条件地使用它们：
- en: '[PRE200]'
  id: totrans-1537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The C# team has given us flexibility where it’s useful (typically, where it
    allows you to express the exact same concepts as before, but in a more concise
    fashion) but prevented us from shooting ourselves in the foot with `throw` expressions
    that would be ludicrous in context.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: C# 团队在我们认为有用的地方给予了我们灵活性（通常，这允许你以前相同的方式表达概念，但更加简洁）但阻止了我们使用在上下文中荒谬的 `throw` 表达式。
- en: Our next feature continues the theme of allowing us to express the same logic
    but with less fluff by simplifying the `default` operator with default literals.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个特性继续了允许我们以更简洁的方式表达相同逻辑的主题，通过使用默认字面量简化 `default` 运算符。
- en: 14.5\. Default literals (C# 7.1)
  id: totrans-1540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5\. 默认字面量（C# 7.1）
- en: 'The `default(T)` operator was introduced in C# 2.0 primarily for use with generic
    types. For example, to retrieve a value from a list if the index was in bounds
    or the default for the type instead, you could write a method like this:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: '`default(T)` 运算符是在 C# 2.0 中引入的，主要用于泛型类型。例如，要从列表中检索值，如果索引在范围内或为类型的默认值，你可以编写如下方法：'
- en: '[PRE201]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'The result of the `default` operator is the same default value for a type that
    you observe when you leave a field uninitialized: a null reference for reference
    types, an appropriately typed zero for all numeric types, U+0000 for `char`, `false`
    for `bool`, and a value with all fields set to the corresponding default for other
    value types.'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: '`default` 操作符的结果与你在字段未初始化时观察到的类型的默认值相同：对于引用类型是空引用，对于所有数值类型是相应类型的零，对于 `char`
    是 U+0000，对于 `bool` 是 `false`，对于其他值类型是所有字段都设置为相应的默认值。'
- en: 'When C# 4 introduced optional parameters, one way of specifying the default
    value for a parameter was to use the `default` operator. This can be unwieldy
    if the type name is long, because you end up with the type name in both the parameter
    type and its default value. One of the worst offenders for this is `CancellationToken`,
    particularly because the conventional name for a parameter of that type is `cancellationToken`.
    A common async method signature might be something like this:'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 当 C# 4 引入可选参数时，指定参数默认值的一种方法就是使用 `default` 操作符。如果类型名称很长，这可能会变得难以管理，因为类型名称会同时出现在参数类型及其默认值中。在这方面最糟糕的违规者之一是
    `CancellationToken`，尤其是因为该类型参数的传统名称是 `cancellationToken`。一个常见的异步方法签名可能如下所示：
- en: '[PRE202]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: The second parameter declaration is so long it needs a whole line to itself
    for book formatting; it’s 64 characters.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数声明非常长，需要整行来排版书籍格式；它有 64 个字符。
- en: 'In C# 7.1, in certain contexts, you can use `default` instead of `default(T)`
    and let the compiler figure out which type you intended. Although there are definitely
    benefits beyond the preceding example, I suspect it was one of the main motivating
    factors. The preceding example can become this:'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7.1 中，在特定上下文中，你可以使用 `default` 而不是 `default(T)`，让编译器确定你打算使用哪种类型。尽管确实有超出前面示例的好处，但我怀疑这是主要推动因素之一。前面的示例可以变成这样：
- en: '[PRE203]'
  id: totrans-1548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'That’s much cleaner. Without the type after it, `default` is a *literal* rather
    than an *operator*, and it works similarly to the `null` literal, except that
    it works for all types. The literal itself has no type, just like the `null` literal
    has no type, but it can be converted to any type. That type might be inferred
    from elsewhere, such as an implicitly typed array:'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 这要干净得多。没有类型跟随它，`default` 是一个 *字面量* 而不是一个 *操作符*，并且它的工作方式与 `null` 字面量类似，除了它可以适用于所有类型。这个字面量本身没有类型，就像
    `null` 字面量没有类型一样，但它可以被转换为任何类型。这种类型可能从其他地方推断出来，例如隐式类型的数组：
- en: '[PRE204]'
  id: totrans-1550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'That code snippet doesn’t list any type names explicitly, but `intArray` is
    implicitly an `int[]` (with the `default` literal being converted to 0), and `stringArray`
    is implicitly a `string[]` (with the `default` literal being converted to a null
    reference). Just like the `null` literal, there does have to be some type involved
    to convert it to; you can’t just ask the compiler to infer a type with no information:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 那段代码没有明确列出任何类型名称，但 `intArray` 是隐式地 `int[]`（`default` 字面量被转换为 0），而 `stringArray`
    是隐式地 `string[]`（`default` 字面量被转换为空引用）。就像 `null` 字面量一样，确实需要涉及某种类型来转换它；你不能只是要求编译器在没有信息的情况下推断类型：
- en: '[PRE205]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: The `default` literal is classified as a constant expression if the type it’s
    converted to is a reference type or a primitive type. This allows you to use it
    in attributes if you want to.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果转换后的类型是引用类型或原始类型，则 `default` 字面量被分类为常量表达式。这允许你在需要时在属性中使用它。
- en: One quirk to be aware of is that the term *default* has multiple meanings. It
    can mean the default value of a type or the default value of an optional parameter.
    The default literal always refers to the default value of the appropriate type.
    That could lead to some confusion if you use it as an argument for an optional
    parameter that has a different default value. Consider the following listing.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个怪癖是，术语 *default* 有多种含义。它可以指类型的默认值或可选参数的默认值。默认字面量始终指适当的类型的默认值。如果你将其用作具有不同默认值的可选参数的参数，这可能会导致一些混淆。考虑以下列表。
- en: Listing 14.11\. Specifying a default literal as a method argument
  id: totrans-1555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.11\. 将默认字面量作为方法参数指定
- en: '[PRE206]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '***1* Parameter’s default value is 10.**'
  id: totrans-1557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 参数的默认值是 10。**'
- en: '***2* Method argument is default for int.**'
  id: totrans-1558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 方法参数对 int 是默认值。**'
- en: This prints 0, because that’s the default value for `int`. The language is entirely
    consistent, but this code could cause confusion because of the different possible
    meanings of default. I’d try to avoid using the default literal in situations
    like this.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出0，因为这是`int`类型的默认值。语言本身是完全一致的，但这段代码可能会因为默认值的多种可能含义而引起混淆。我会尽量避免在这种情况下使用默认字面量。
- en: 14.6\. Nontrailing named arguments (C# 7.2)
  id: totrans-1560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6. 非尾部命名参数（C# 7.2）
- en: 'Optional parameters and named arguments were introduced as complementary features
    in C# 4, and both had ordering requirements: optional parameters had to come after
    all required parameters (other than parameter arrays), and named arguments had
    to come after all positional arguments. Optional parameters haven’t changed, but
    the C# team has noticed that often named arguments can be useful as tools for
    increasing clarity, even for arguments in the middle of an argument list. This
    is particularly true when the argument is a literal (typically, a number, Boolean,
    literal, or null) where the context doesn’t clarify the purpose of the value.'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数和命名参数在C# 4中被引入作为互补特性，并且两者都有顺序要求：可选参数必须位于所有必需参数（除了参数数组）之后，而命名参数必须位于所有位置参数之后。可选参数没有变化，但C#团队注意到，命名参数经常可以作为提高清晰度的工具，即使对于参数列表中间的参数也是如此。这尤其适用于参数是一个字面量（通常是数字、布尔值、字面量或`null`）且上下文没有明确说明值的目的时。
- en: 'As an example, I’ve been writing samples for the BigQuery client library recently.
    When you upload a CSV file to BigQuery, you can specify a schema, let the server
    determine the schema, or fetch it from the table if that already exists. When
    writing the samples for the autodetection, I wanted to make it clear that you
    can pass a null reference for the `schema` parameter. Written in the simplest—but
    not clearest—form, it’s not at all obvious what the `null` argument means:'
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我最近一直在编写BigQuery客户端库的示例。当你将CSV文件上传到BigQuery时，你可以指定一个模式，让服务器确定模式，或者如果该模式已经存在，则从表中获取它。在编写自动检测的示例时，我想清楚地说明你可以为`schema`参数传递一个`null`引用。以最简单但不是最清晰的形式编写，`null`参数的含义根本不明显：
- en: '[PRE207]'
  id: totrans-1563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Before C# 7.2, my options for making this clearer were to either use named
    arguments for the last three parameters, which ended up looking a little awkward,
    or use an explanatory local variable:'
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.2之前，我使这段代码更清晰的选择是使用命名参数来表示最后三个参数，这最终看起来有点尴尬，或者使用一个解释性的局部变量：
- en: '[PRE208]'
  id: totrans-1565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'That’s clearer, but it’s still not great. C# 7.2 allows named arguments anywhere
    in the argument list, so I can make it clear what the second argument means without
    any extra statements:'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 这更清晰了，但仍然不是很好。C# 7.2允许在参数列表中的任何位置使用命名参数，因此我可以清楚地说明第二个参数的含义，而无需任何额外的语句：
- en: '[PRE209]'
  id: totrans-1567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: This can also help differentiate between overloads in some cases in which the
    argument (typically `null`) could be converted to the same parameter position
    in multiple overloads.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以帮助在某些情况下区分重载，在这些情况下，参数（通常是`null`）可以转换为多个重载中的相同参数位置。
- en: 'The rules for nontrailing named arguments have been designed carefully to avoid
    any subsequent positional arguments from becoming ambiguous: if there are any
    *unnamed* arguments after a named one, the named argument has to correspond to
    the same parameter as it would if it were a simple positional argument. For example,
    consider this method declaration and three calls to it:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '非尾部命名参数的规则被精心设计，以避免任何后续的位置参数变得模糊：如果有一个或多个**未命名的**参数在命名参数之后，则命名参数必须对应于如果它是简单的位置参数时的参数。例如，考虑这个方法声明及其三个调用： '
- en: '[PRE210]'
  id: totrans-1570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '***1* Valid: trailing named arguments out of order**'
  id: totrans-1571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 有效：尾部命名参数顺序错误**'
- en: '***2* Valid: nontrailing named argument in order**'
  id: totrans-1572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 有效：非尾部命名参数顺序正确**'
- en: '***3* Invalid: nontrailing named argument out of order**'
  id: totrans-1573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 无效：非尾部命名参数顺序错误**'
- en: The first call is valid because it consists of one positional argument followed
    by two named arguments; it’s obvious that the positional argument corresponds
    to the parameter `x`, and the other two are named. No ambiguity.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用是有效的，因为它由一个位置参数后跟两个命名参数组成；很明显，位置参数对应于参数`x`，其他两个是命名的。没有歧义。
- en: The second call is valid because although there’s a named argument with a later
    positional argument, the named argument corresponds to the same parameter as it
    would if it were positional (`y`). Again, it’s clear what value each parameter
    should take.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用是有效的，因为尽管有一个带名称的参数后面跟着一个位置参数，但带名称的参数与如果它是位置参数（`y`）时对应的参数相同。再次强调，每个参数应该取什么值是清晰的。
- en: 'The third call is invalid: the first argument is named but corresponds to the
    second parameter (`y`). Should the second argument correspond to the first parameter
    (`x`) on the grounds that it’s the first non-named argument? Although the rules
    could work this way, it all becomes a bit confusing; it’s even worse when optional
    parameters get involved. It’s simpler to prohibit it, so that’s what the language
    team decided to do. Next is a feature that has been in the CLR forever but was
    exposed only in C# 7.2.'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次调用是无效的：第一个参数被命名但对应于第二个参数（`y`）。第二个参数是否应该对应于第一个参数（`x`），因为它是最先的非命名参数？尽管规则可以按这种方式工作，但这会变得有些混乱；当涉及到可选参数时，情况会更糟。禁止它会更简单，因此语言团队决定这样做。接下来是一个CLR中一直存在但仅在C#
    7.2中公开的特性。
- en: 14.7\. Private protected access (C# 7.2)
  id: totrans-1577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.7. 私有受保护访问（C# 7.2）
- en: A few years ago, `private protected` was going to be part of C# 6 (and perhaps
    they planned to introduce it even earlier than this). The problem was coming up
    with a name. By the time the team had reached 7.2, they decided they weren’t going
    to find a better name than `private protected`. This combination of access modifiers
    is more restrictive than either `protected` or `internal`. You have access to
    a private protected member only from code that’s in the same assembly *and* is
    within a subclass of the member declaration (or is in the same type).
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，`private protected`本应成为C# 6的一部分（也许他们计划比这更早引入它）。问题是给这个特性起一个名字。当团队达到7.2版本时，他们决定找不到比`private
    protected`更好的名字。这种访问修饰符的组合比`protected`或`internal`都更具有限制性。只有从位于同一程序集且在成员声明子类中的代码才能访问`private
    protected`成员（或位于同一类型中）。
- en: Compare this with `protected internal`, which is less restrictive than either
    `protected` or `internal`. You have access to a protected internal member from
    code that’s in the same assembly *or* is within a subclass of the member declaration
    (or is in the same type).
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 与`protected internal`相比，它比`protected`或`internal`都更不具限制性。你可以从位于同一程序集或成员声明子类中的代码访问受保护的内部成员（或位于同一类型中）。
- en: That’s all there is to say about it; it doesn’t even merit an example. It’s
    nice to have from a completeness perspective, as it was odd for there to be an
    access level that could be expressed in the CLR but not in C#. I’ve used it only
    once so far in my own code, and I don’t expect it to be something I find much
    more useful in the future. We’ll finish this chapter with a few odds and ends
    that don’t fit in neatly anywhere else.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，没有太多可说的；它甚至不值得举一个例子。从完整性的角度来看，这是件好事，因为在CLR中可以表达但C#中不能表达访问级别确实很奇怪。到目前为止，我仅在自己的代码中使用过一次，并且我不期望它在未来会变得更有用。我们将以一些不适合放在其他地方的零散内容结束本章。
- en: 14.8\. Minor improvements in C# 7.3
  id: totrans-1581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.8. C# 7.3的微小改进
- en: As you’ve already seen in this chapter and earlier in the book, the C# design
    team didn’t stop work on C# 7 after releasing C# 7.0\. Small tweaks were made,
    mostly to enhance the features released in C# 7.0\. Where possible, I’ve included
    those details along with the general feature description. A few of the features
    in C# 7.3 don’t fit in that way, and they don’t really fit in with this chapter’s
    theme of concise code, either. But it wouldn’t feel right to leave them out.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章以及本书前面的内容中已经看到的，C#设计团队在发布C# 7.0后并没有停止对C# 7的工作。进行了一些小的调整，主要是为了增强C# 7.0中发布的功能。在可能的情况下，我已经将这些细节与一般功能描述一起包含。C#
    7.3中的某些功能不适合这种方式，它们也不太符合本章关于简洁代码的主题。但把它们留在外面又感觉不合适。
- en: 14.8.1\. Generic type constraints
  id: totrans-1583
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.8.1. 泛型类型约束
- en: 'When I briefly described type constraints in [section 2.1.5](kindle_split_017_split_000.html#ch02lev2sec5),
    I left out a few restrictions. Prior to C# 7.3, a type constraint couldn’t specify
    that the type argument must derive from `Enum` or `Delegate`. This restriction
    has been lifted, and a new kind of constraint has been added: a constraint of
    `unmanaged`. The following listing gives examples of how these constraints are
    specified and used.'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在[第2.1.5节](kindle_split_017_split_000.html#ch02lev2sec5)简要描述类型约束时，遗漏了一些限制。在C#
    7.3之前，类型约束不能指定类型参数必须派生自`Enum`或`Delegate`。这个限制已经被取消，并增加了一种新的约束类型：`unmanaged`约束。以下列表展示了这些约束是如何指定和使用的。
- en: Listing 14.12\. New constraints in C# 7.3
  id: totrans-1585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.12. C# 7.3中的新约束
- en: '[PRE211]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '***1* Valid: enum value type**'
  id: totrans-1587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 有效：枚举值类型**'
- en: '***2* Invalid: doesn’t meet struct constraint**'
  id: totrans-1588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 无效：不满足结构约束**'
- en: '***3* All valid (unfortunately)**'
  id: totrans-1589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 所有都有效（遗憾的是**）'
- en: '***4* Valid: System.Int32 is an unmanaged type.**'
  id: totrans-1590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 有效：System.Int32 是一个非托管类型。**'
- en: '***5* Invalid: System.String is a managed type.**'
  id: totrans-1591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 无效：System.String 是一个托管类型。**'
- en: 'I’ve shown a constraint of `where T : struct, Enum` for the enum constraint,
    because that’s how you almost always want to use it. That constrains `T` to be
    a real enum type: a value type derived from `Enum`. The `struct` constraint excludes
    the `Enum` type itself. If you’re trying to write a method that works with any
    enum type, you usually wouldn’t want to handle `Enum`, which isn’t really an enum
    type in itself. Unfortunately, it’s far too late to add these constraints onto
    the various enum parsing methods in the framework.'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: '我已经展示了 `where T : struct, Enum` 的约束，因为几乎总是这样使用它。这限制了 `T` 必须是一个真正的枚举类型：一个从 `Enum`
    派生的值类型。`struct` 约束排除了 `Enum` 类型本身。如果你试图编写一个可以与任何枚举类型一起工作的方法，你通常不希望处理 `Enum`，因为
    `Enum` 本身并不是一个真正的枚举类型。不幸的是，为框架中各种枚举解析方法添加这些约束已经太晚了。'
- en: 'The delegate constraint doesn’t have an equivalent, unfortunately. There’s
    no way of expressing a constraint of “only the types declared with a delegate
    declaration.” You could use a constraint of `where T : MulticastDelegate` instead,
    but then you’d still be able to use `MulticastDelegate` itself as a type argument.'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '很遗憾，没有与委托约束等效的约束。没有方法可以表达“只有使用委托声明声明的类型”的约束。你可以使用 `where T : MulticastDelegate`
    的约束代替，但那样你仍然可以使用 `MulticastDelegate` 本身作为类型参数。'
- en: The final constraint is for *unmanaged* types. I’ve mentioned these in passing
    before, but an unmanaged type is a non-nullable, nongeneric value type whose fields
    aren’t reference types, recursively. Most of the value types in the framework
    (`Int32`, `Double`, `Decimal`, `Guid`) are unmanaged types. As an example of a
    value type that isn’t, a `ZonedDateTime` in Noda Time wouldn’t be an unmanaged
    type because it contains a reference to a `DateTimeZone` instance.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个约束是针对 *非托管* 类型。我之前已经提到过这些，但非托管类型是一个非可空、非泛型的值类型，其字段不是引用类型，递归地。框架中的大多数值类型（`Int32`、`Double`、`Decimal`、`Guid`）都是非托管类型。作为一个不是值类型的例子，Noda
    Time 中的 `ZonedDateTime` 不会是非托管类型，因为它包含对 `DateTimeZone` 实例的引用。
- en: 14.8.2\. Overload resolution improvements
  id: totrans-1595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.8.2\. 重载解析改进
- en: 'The rules around overload resolution have been tweaked over and over again,
    usually in hard-to-explain ways, but the change in C# 7.3 is welcome and reasonably
    simple. A few conditions that used to be checked after overload resolution had
    finished are now checked earlier. Some calls that would have been considered to
    be ambiguous or invalid in an earlier version of C# are now fine. The checks are
    as follows:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 重载解析的规则已经被反复调整，通常以难以解释的方式，但 C# 7.3 的变化是受欢迎的，并且相对简单。一些在重载解析完成后曾经被认为是模糊或无效的调用现在被认为是有效的。检查如下：
- en: Generic type arguments must meet any constraints on the type parameters.
  id: totrans-1597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型参数必须满足类型参数上的任何约束。
- en: Static methods can’t be called as if they were instance methods.
  id: totrans-1598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法不能像实例方法那样调用。
- en: Instance methods can’t be called as if they were static methods.
  id: totrans-1599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法不能像静态方法那样调用。
- en: 'As an example of the first scenario, consider these overloads:'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一种场景的例子，考虑以下重载：
- en: '[PRE212]'
  id: totrans-1601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '***1* Method with a struct constraint**'
  id: totrans-1602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 具有结构约束的方法**'
- en: '***2* Method with a class constraint**'
  id: totrans-1603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 具有类约束的方法**'
- en: In previous versions of C#, overload resolution would’ve ignored the type parameter
    constraints to start with. It would’ve picked the second overload, because `string`
    is a more specific regular parameter type than `object`, and then discovered that
    the supplied type argument (`int`) violated the type constraint.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 的早期版本中，重载解析会首先忽略类型参数约束。它会选择第二个重载，因为 `string` 是比 `object` 更具体的常规参数类型，然后发现提供的类型参数（`int`）违反了类型约束。
- en: With C# 7.3, the code compiles with no error or ambiguity because the type constraint
    is checked as part of finding applicable methods. The other checks are similar;
    the compiler discards methods that would be invalid for the call earlier than
    it used to. Examples of all three scenarios are in the downloadable source code.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 7.3，代码编译时没有错误或歧义，因为类型约束是在查找适用方法时检查的。其他检查类似；编译器会丢弃对于调用无效的方法，比以前更早地被丢弃。所有三种场景的例子都在可下载的源代码中。
- en: 14.8.3\. Attributes for fields backing automatically implemented properties
  id: totrans-1606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.8.3\. 自动实现属性的字段属性
- en: 'Suppose you want a trivial property backed by a field, but you need to apply
    an attribute to the field to enable other infrastructure. Prior to C# 7.3, you’d
    have to declare the field separately and then write a simple property with boilerplate
    code. For example, suppose you wanted to apply a `DemoAttribute` (just an attribute
    I’ve made up) to a field backing a string property. You’d have needed code like
    this:'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个由字段支持的简单属性，但你需要将属性应用于字段以启用其他基础设施。在C# 7.3之前，你必须单独声明字段，然后编写一个带有样板代码的简单属性。例如，假设你想要将`DemoAttribute`（我只是编造的一个属性）应用于支持字符串属性的字段。你可能需要像这样的代码：
- en: '[PRE213]'
  id: totrans-1608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'That’s annoying when automatically implemented properties do almost everything
    you want. In C# 7.3, you can specify a field attribute directly to an automatically
    implemented property:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动实现属性几乎可以做你想要的所有事情时，这会让人感到烦恼。在C# 7.3中，你可以直接将字段属性指定给自动实现的属性：
- en: '[PRE214]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: This isn’t a new modifier for attributes, but previously it wasn’t available
    in this context. (At least not officially and not in the Microsoft compiler. The
    Mono compiler has allowed it for some time.) It’s just another rough edge of the
    specification where the language wasn’t consistent that has been smoothed out
    for C# 7.3.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是属性的新修饰符，但之前在这个上下文中不可用。（至少不是官方的，也不是在微软编译器中。Mono编译器已经允许这样做一段时间。）这只是规范中另一个语言不一致的粗糙边缘，在C#
    7.3中已经被平滑处理。
- en: Summary
  id: totrans-1612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Local methods allow you to clearly express that a particular piece of code is
    an implementation detail of a single operation rather than being of general use
    within the type itself.
  id: totrans-1613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地方法允许你清楚地表达特定的代码片段是单个操作的实现细节，而不是在类型本身内具有通用用途。
- en: '`out` variables are pure ceremony reduction that allow some cases that involved
    multiple statements (declaring a variable and then using it) to be reduced to
    a single expression.'
  id: totrans-1614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out` 变量是纯粹的形式简化，它允许一些涉及多个语句（声明一个变量然后使用它）的情况简化为一个单一的表达式。'
- en: Binary literals allow more clarity when you need to express an integer value,
    but the bit pattern is more important than the magnitude.
  id: totrans-1615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制字面量在需要表达整数值且位模式比大小更重要时提供了更多的清晰度。
- en: Literals with many digits that could easily become confusing to the reader are
    clearer when digit separators are inserted.
  id: totrans-1616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可能容易让读者感到困惑的许多数字，插入数字分隔符会使它们更清晰。
- en: Like `out` variables, `throw` expressions often allow logic that previously
    had to be expressed in multiple statements to be represented in a single expression.
  id: totrans-1617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`out`变量类似，`throw`表达式通常允许将之前必须用多个语句表达的逻辑表示为一个单一的表达式。
- en: Default literals remove redundancy. They also stop you from having to say the
    same thing twice.^([[5](kindle_split_031_split_000.html#ch14fn5)])
  id: totrans-1618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认字面量消除了冗余。它们还阻止你不得不两次说同样的话.^([[5](kindle_split_031_split_000.html#ch14fn5)])
- en: ⁵
  id: totrans-1619
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵
- en: ''
  id: totrans-1620
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: See how annoying redundancy is? Sorry, I couldn’t resist.
  id: totrans-1621
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 看看冗余有多烦人？抱歉，我忍不住了。
- en: Unlike the other features, using nontrailing named arguments may increase the
    size of your source code, but all in the name of clarity. Or, if you were previously
    specifying lots of named arguments when you wanted to name only one in the middle,
    you’ll be able to remove some names without losing readability.
  id: totrans-1622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他特性不同，使用非尾随命名参数可能会增加你的源代码大小，但一切都是为了清晰。或者，如果你之前在只想命名中间的一个参数时指定了很多命名参数，你现在将能够删除一些名称而不会影响可读性。
- en: Chapter 15\. C# 8 and beyond
  id: totrans-1623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章\. C# 8及以后版本
- en: '|  |'
  id: totrans-1624
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Expressing null and non-null expectations for reference types
  id: totrans-1626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达对引用类型的null和非null期望
- en: Using switch expressions with pattern matching
  id: totrans-1627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模式匹配的switch表达式
- en: Matching patterns recursively against properties
  id: totrans-1628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归地对属性进行匹配模式
- en: Using index and range syntax for concise and consistent code
  id: totrans-1629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用索引和范围语法以简洁和一致的方式编写代码
- en: Using asynchronous versions of the `using`, `foreach`, and `yield` statements
  id: totrans-1630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`using`、`foreach`和`yield`语句的异步版本
- en: '|  |'
  id: totrans-1631
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: At the time of this writing, C# 8 is still being designed. The GitHub repository
    shows a lot of potential features, but only a few have reached the stage of publicly
    available preview builds of the compiler. This chapter is educated guesswork;
    nothing here is set in stone. It’s almost inconceivable that all the features
    being considered would be included in C# 8, and I’ve restricted myself to the
    ones I consider reasonably likely to make the cut. I’ve provided the most detail
    about the features available in preview at the time of writing, but even so, that
    doesn’t mean further changes won’t occur.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，C# 8仍在设计中。GitHub存储库显示了大量的潜在功能，但只有少数已经达到公开可用的编译器预览版本阶段。本章是基于推测的；这里的内容都不是确定的。几乎无法想象正在考虑的所有功能都会包含在C#
    8中，我已经限制了自己只考虑那些我认为有合理可能被采纳的功能。我已经提供了在撰写本文时预览中可用的功能的最大细节，但即使如此，这也并不意味着不会发生进一步的更改。
- en: '|  |'
  id: totrans-1633
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of this writing, only a few C# 8 features are available in preview
    builds, and there are different builds with different features. The preview for
    nullable reference types supports only full .NET projects (rather than .NET Core
    SDK style projects), which makes it harder to experiment with them on real code
    if all your projects use the new project format. I expect these limitations to
    be overcome in later builds, possibly by the time you read this.
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，只有少数C# 8功能在预览版本中可用，并且有不同的构建版本具有不同的功能。可空引用类型的预览只支持完整的.NET项目（而不是.NET Core
    SDK风格的项目），这使得如果所有项目都使用新的项目格式，则在真实代码中实验它们变得更加困难。我预计这些限制将在以后的构建中克服，可能在你阅读本文时已经实现。
- en: '|  |'
  id: totrans-1636
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’ll start with nullable reference types.
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从可空引用类型开始。
- en: 15.1\. Nullable reference types
  id: totrans-1638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1\. 可空引用类型
- en: Ah, null references. The so-called billion-dollar mistake that Tony Hoare apologized
    for in 2009 after introducing them in the 1960s. It’s hard to find an experienced
    C# developer who hasn’t been bitten by a `NullReferenceException` at least a few
    times. The C# team has a plan to tame null references, making it clearer where
    we should expect to find them.
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，空引用。所谓的十亿美元的错误，托尼·霍尔在1960年代引入它们后于2009年道歉。很难找到一个经验丰富的C#开发者没有至少被`NullReferenceException`咬过几次。C#团队有一个计划来驯服空引用，使我们可以更清楚地知道它们在哪里。
- en: 15.1.1\. What problem do nullable reference types solve?
  id: totrans-1640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.1\. 可空引用类型解决了什么问题？
- en: As an example that I’ll expand on over the course of this section, let’s consider
    the classes in the following listing. If you’re following along in the downloadable
    source code, you’ll see that I’ve declared them as separate nested classes within
    each example, as the code changes over time.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节中我将进一步展开的例子，让我们考虑以下列表中的类。如果你在下载的源代码中跟随，你会看到我将它们声明为每个示例中的独立嵌套类，因为代码会随着时间的推移而变化。
- en: Listing 15.1\. Initial model before C# 8
  id: totrans-1642
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.1\. C# 8之前的初始模型
- en: '[PRE215]'
  id: totrans-1643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: An address would usually contain far more information than a country, but a
    single property is enough for the examples in this chapter. With those classes
    in place, how safe is this code?
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 一个地址通常包含比一个国家更多的信息，但在这个章节的示例中，一个属性就足够了。有了这些类，这段代码有多安全？
- en: '[PRE216]'
  id: totrans-1645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: If you know (somehow) that `customer` is non-null and that a customer always
    has an associated address, that may be fine. But how can you know that? If you
    know that only because you’ve looked at documentation, what has to change to make
    the code safer?
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你（以某种方式）知道`customer`是非空的，并且客户总是有一个相关的地址，那可能没问题。但你如何知道这一点？如果你只是因为查看过文档而知道这一点，代码需要做出什么改变才能更安全？
- en: Since C# 2, we’ve had nullable value types, non-nullable value types, and implicitly
    nullable reference types. A grid of nullable/non-nullable against value/reference
    types has had three of the four cells filled in, but the fourth has been elusive,
    as shown in [table 15.1](kindle_split_032_split_000.html#ch15table01).
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 自从C# 2以来，我们就有了可空值类型、非可空值类型和隐式可空引用类型。在可空/非可空与值/引用类型的网格中，已经有三个单元格被填满，但第四个单元格仍然难以捉摸，如[表15.1](kindle_split_032_split_000.html#ch15table01)所示。
- en: Table 15.1\. Support for nullability and non-nullability for reference and value
    types in C# 7
  id: totrans-1648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表15.1\. C# 7中对引用类型和值类型的可空性和非可空性支持
- en: '|   | Nullable | Non-nullable |'
  id: totrans-1649
  prefs: []
  type: TYPE_TB
  zh: '|   | 可空 | 非可空 |'
- en: '| --- | --- | --- |'
  id: totrans-1650
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Reference types | Implicit | Not supported |'
  id: totrans-1651
  prefs: []
  type: TYPE_TB
  zh: '| 引用类型 | 隐式 | 不支持 |'
- en: '| Value types | Nullable<T> or ? suffix | Default |'
  id: totrans-1652
  prefs: []
  type: TYPE_TB
  zh: '| 值类型 | Nullable<T>或?后缀 | 默认 |'
- en: The fact that there’s only one supported cell in the top row means we have no
    way of expressing an intention that some reference values may be null and others
    should never be null. When you run into a problem with an unexpected null value,
    it can be hard to determine where the fault lies unless the code has been carefully
    documented with null checks implemented consistently.^([[1](kindle_split_032_split_000.html#ch15fn1)])
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有顶部行支持一个单元格，我们无法表达某些引用值可能为null而其他值则永远不应为null的意图。当你遇到意外null值的问题时，除非代码已经被仔细记录并一致地实现了null检查，否则很难确定错误所在.^([[1](kindle_split_032_split_000.html#ch15fn1)])
- en: ¹
  id: totrans-1654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-1655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The day before I wrote this paragraph, most of my time was spent trying to track
    down a problem of exactly this kind. The issue is very real.
  id: totrans-1656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我写这个段落的前一天，我大部分时间都在试图追踪一个与此完全相同的问题。这个问题非常真实。
- en: Given the huge body of .NET code that now exists with no machine-readable discrimination
    between references that can reasonably be null and those that must always be non-null,
    any attempt to rectify this situation can only be a cautious one. What can we
    do?
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在存在大量没有机器可读区分的.NET代码，其中一些引用可以合理地设置为null，而另一些则必须始终非null，因此任何试图纠正这种情况的尝试都只能是非常谨慎的。我们能做什么呢？
- en: 15.1.2\. Changing the meaning when using reference types
  id: totrans-1658
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.2\. 使用引用类型时改变含义
- en: 'The broad idea of the null safety feature is to assume that when a developer
    is intentionally discriminating between non-null and nullable reference types,
    the default is to be non-nullable. New syntax is introduced for nullable reference
    types: `string` is a non-nullable reference type, and `string?` is a nullable
    reference type. The grid then evolves, as shown in [table 15.2](kindle_split_032_split_000.html#ch15table02).'
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: null安全特性的广泛思想是假设当开发者在有意区分非null和可空引用类型时，默认值应该是非可空的。为可空引用类型引入了新的语法：`string`是非可空引用类型，而`string?`是可空引用类型。然后，网格会像[表15.2](kindle_split_032_split_000.html#ch15table02)中所示那样演变。
- en: Table 15.2\. Support for nullability and non-nullability for reference and value
    types in C# 8
  id: totrans-1660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表15.2\. C# 8中引用和值类型的null性和非null性支持
- en: '|   | Nullable | Non-nullable |'
  id: totrans-1661
  prefs: []
  type: TYPE_TB
  zh: '|   | 可空 | 非可空 |'
- en: '| --- | --- | --- |'
  id: totrans-1662
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Reference types | No CLR type representation, but the ? suffix as an annotation
    | Default when nullable reference type support is enabled |'
  id: totrans-1663
  prefs: []
  type: TYPE_TB
  zh: '| 引用类型 | 没有CLR类型表示，但有?后缀作为注释 | 启用可空引用类型支持时的默认值 |'
- en: '| Value types | Nullable<T> or ? suffix | Default |'
  id: totrans-1664
  prefs: []
  type: TYPE_TB
  zh: '| 值类型 | Nullable<T>或?后缀 | 默认值 |'
- en: That sounds like the opposite of caution; it’s changing the meaning of all C#
    code that deals with reference types! Turning on the feature changes the default
    from nullable to non-nullable. The expectation is that there are far fewer places
    where a null reference is intended to be valid than places where it should never
    occur.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是谨慎的反面；它改变了所有处理引用类型的C#代码的含义！启用此功能将默认值从可空更改为非可空。预期的情况是，意图使null引用有效的位置远少于不应出现null引用的位置。
- en: Let’s go back to our customer and address example. Without any changes to the
    code, the compiler warns us that our `Customer` and `Address` classes are allowing
    non-nullable properties to be uninitialized. That can be fixed by adding constructors
    with non-nullable parameters, as shown in the following listing.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的客户和地址示例。在不修改代码的情况下，编译器会警告我们`Customer`和`Address`类允许非可空属性未初始化。这可以通过添加具有非可空参数的构造函数来修复，如下面的列表所示。
- en: Listing 15.2\. Model with non-nullable properties everywhere
  id: totrans-1667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.2\. 遍处使用非可空属性的模型
- en: '[PRE217]'
  id: totrans-1668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: At this point, you “can’t” construct a `Customer` without providing a non-null
    name and address, and you “can’t” construct an `Address` without providing a non-null
    country. I’ve deliberately put *can’t* in scare-quotes for reasons you’ll see
    in [section 15.1.4](kindle_split_032_split_000.html#ch15lev2sec4).
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你“不能”不提供非null的名称和地址就构造一个`Customer`，你“不能”不提供非null的国家就构造一个`Address`。我故意用引号标注了*can’t*，原因你将在[第15.1.4节](kindle_split_032_split_000.html#ch15lev2sec4)中看到。
- en: 'But now consider our console output code again:'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在再次考虑我们的控制台输出代码：
- en: '[PRE218]'
  id: totrans-1671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: This is safe, assuming everyone is obeying the contracts properly. Not only
    will it not throw an exception, but you won’t be passing a null value to `Console.WriteLine`,
    because the country in the address won’t be null.
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每个人都正确遵守了契约，这是安全的。这不仅不会抛出异常，而且你也不会将null值传递给`Console.WriteLine`，因为地址中的国家不会是null。
- en: Okay, so the compiler can check that things aren’t null. But what about when
    you want to allow null values? It’s time to explore the new syntax I mentioned
    before.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以编译器可以检查事物是否为 null。但是，当你想要允许 null 值时怎么办？是时候探索我之前提到的新的语法了。
- en: 15.1.3\. Enter nullable reference types
  id: totrans-1674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.3\. 引入可空引用类型
- en: 'The syntax used to indicate a reference type that can be null is designed to
    be immediately familiar. It’s the same as the syntax for nullable value types:
    adding a question mark after the type name. This can be used in most places that
    a reference type can appear. For example, consider this method:'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示可空引用类型的语法设计得立即熟悉。它与可空值类型的语法相同：在类型名称后添加一个问号。这可以在引用类型可以出现的大多数地方使用。例如，考虑以下方法：
- en: '[PRE219]'
  id: totrans-1676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The signature of the method shows the following:'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的签名显示如下：
- en: The type of `first` is nullable string.
  id: totrans-1678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first` 的类型是可空字符串。'
- en: The type of `second` is non-nullable string.
  id: totrans-1679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`second` 的类型是非可空字符串。'
- en: The return type is non-nullable string.
  id: totrans-1680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型是非可空字符串。
- en: 'The compiler then uses that information to warn you if you try to misuse a
    value that might be null. For example, it can warn you if you do the following:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器随后使用这些信息来警告你，如果你尝试误用可能为 null 的值。例如，它可以警告你以下操作：
- en: Assign a possibly null value to a non-nullable variable or property.
  id: totrans-1682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可能为 null 的值赋给非可空变量或属性。
- en: Pass a possibly null value as an argument for a non-nullable parameter.
  id: totrans-1683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可能为 null 的值作为非可空参数的参数传递。
- en: Dereference a possibly null value.
  id: totrans-1684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消对可能为 null 的值的引用。
- en: 'Let’s build this into our customer model. Let’s suppose the customer address
    could be null. You need to modify the `Customer` class as follows:'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其构建到我们的客户模型中。假设客户地址可能是 null。你需要按以下方式修改 `Customer` 类：
- en: Change the property type.
  id: totrans-1686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改属性类型。
- en: Either remove the constructor parameter for the address, make it nullable, or
    overload it.
  id: totrans-1687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么移除地址的构造函数参数，要么使其可空，或者对其进行重载。
- en: The `Address` type itself doesn’t change, only how it’s used. The following
    listing shows the new `Customer` class. I’ve chosen to remove the constructor
    parameter for the address.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address` 类型本身并没有改变，只是它的使用方式发生了变化。以下列表展示了新的 `Customer` 类。我选择移除了地址的构造函数参数。'
- en: Listing 15.3\. Making the customer `Address` property nullable
  id: totrans-1689
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.3\. 使客户 `Address` 属性可空
- en: '[PRE220]'
  id: totrans-1690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '***1* The address is now optional information.**'
  id: totrans-1691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 地址现在是可选信息。**'
- en: '***2* Removes the address parameter from the constructor**'
  id: totrans-1692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从构造函数中移除了地址参数**'
- en: 'Great, you’ve now made your intent clear: the `Name` property won’t be null,
    but the `Address` property might be. The compiler now gives you a different warning
    when you try to display the country of the user’s address:'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，你现在已经清楚地表达了你的意图：`Name` 属性不会为 null，但 `Address` 属性可能会。现在当你尝试显示用户地址的国家时，编译器会给出不同的警告：
- en: '[PRE221]'
  id: totrans-1694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Great! It’s now identifying the problem you originally faced, which caused a
    `NullReferenceException`. How do you fix the problem? It’s time to look at the
    *behavior* of nullable reference types rather than just the syntax.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在它正在识别你最初面临的问题，这导致了 `NullReferenceException`。如何解决这个问题？现在是时候查看可空引用类型的 *行为*
    而不仅仅是语法了。
- en: 15.1.4\. Nullable reference types at compile time and execution time
  id: totrans-1696
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.4\. 编译时和执行时可空引用类型
- en: 'One golden rule of the new feature is that no behavior is changed implicitly.
    Even though the meaning of your code has changed to assume an intent of non-nullable
    types, the behavior hasn’t. The only difference is at compile time in terms of
    the warnings generated. No new real types are involved; the CLR has no notion
    of a nullable versus non-nullable reference type. Attributes are used to propagate
    nullability information, but that’s all. This is similar to the extra information
    about tuple element names, which are not part of the type at execution time. This
    has two important consequences:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 新特性的一个黄金法则是没有行为会隐式地改变。即使你代码的含义已经改变，假设了非可空类型的意图，但行为并没有改变。唯一的区别是在编译时产生的警告。没有引入新的真实类型；CLR
    没有可空与非可空引用类型的概念。使用属性来传播可空性信息，但仅此而已。这类似于元组元素名称的额外信息，这些名称在执行时不是类型的一部分。这有两个重要的后果：
- en: Defensive programming remains a best practice. With the code you’ve written
    so far, it’s possible for `Name` to be null, because a user could be ignoring
    warnings or using code from another project that uses only C# 7\. Argument validation
    is still important.
  id: totrans-1698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御性编程仍然是一个最佳实践。根据你迄今为止编写的代码，`Name` 可能为 null，因为用户可能会忽略警告或使用来自另一个项目且仅使用 C# 7 的代码。参数验证仍然很重要。
- en: To understand the feature fully, you need to understand the compiler warnings.
    You definitely shouldn’t just ignore them; they’re present to provide value.
  id: totrans-1699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要完全理解这个特性，你需要理解编译器警告。你绝对不应该只是忽略它们；它们的存在是为了提供价值。
- en: 'Let’s look at the warning you’re currently facing and consider all the ways
    you could avoid it. You currently have this:'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你目前面临的警告，并考虑所有可以避免它的方法。你现在有这个：
- en: '[PRE222]'
  id: totrans-1701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: The compiler is correctly telling you this is dangerous because `customer.Address`
    could be null. You’ll look at three ways you can make the code safer. First, you
    can use the null conditional and null coalescing operators in tandem, as shown
    in the next listing.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器正确地告诉你这是危险的，因为 `customer.Address` 可能是 null。你将看到三种可以使代码更安全的方法。首先，你可以同时使用空条件运算符和空合并运算符，如下一个列表所示。
- en: Listing 15.4\. Safe dereferencing using the null conditional operator
  id: totrans-1703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.4\. 使用空条件运算符进行安全的取消引用
- en: '[PRE223]'
  id: totrans-1704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: If `customer.Address` is null, the expression `customer.Address?.Country` won’t
    try to evaluate the `Country` property, and the result of the expression will
    be null. The null coalescing operator then provides a default value to print.
    The compiler understands that you’re no longer trying to dereference anything
    that might be null, and the warning goes away.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `customer.Address` 是 null，表达式 `customer.Address?.Country` 不会尝试评估 `Country`
    属性，并且表达式的结果将是 null。空合并运算符随后提供一个默认值以打印。编译器理解你不再尝试取消引用任何可能为 null 的东西，警告就会消失。
- en: You may be a little uneasy with this at the moment. It’s easy to get lost in
    a sea of question marks if you’re not careful. I believe that C# developers will
    become more comfortable with this over time, but it’s not the only solution available.
    You could take a more verbose approach that’s simple to follow, as shown in the
    following listing.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能对此感到有些不自在。如果不小心，很容易在问号的大海中迷失方向。我相信随着时间的推移，C# 开发者会越来越习惯这种方式，但这并不是唯一的解决方案。你可以采取更冗长的但易于遵循的方法，如下面的列表所示。
- en: Listing 15.5\. Checking a reference with a local variable
  id: totrans-1707
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.5\. 通过局部变量检查引用
- en: '[PRE224]'
  id: totrans-1708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '***1* Extracts address to a new local variable**'
  id: totrans-1709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从地址提取到新的局部变量**'
- en: '***2* Checks for nullity and dereferences only if non-null**'
  id: totrans-1710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查空值，仅在非空时取消引用**'
- en: 'There’s an interesting point to note here: the compiler needs to keep track
    of more than just the type of the variable. If the rule were as simple as “dereferencing
    a value of a nullable reference type causes a warning,” this code would still
    generate a warning, despite being safe. Instead, the compiler keeps track of whether
    a variable’s value can be null at each place in the code in a similar manner to
    the way it keeps track of definite assignment. By the time you reach the body
    of the `if` statement, the compiler knows that the value of `address` can’t be
    null, so it doesn’t warn when you dereference it. Our third approach, shown in
    the following listing, is similar to the second one, but without the local variable.'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的观点需要注意：编译器需要跟踪的不仅仅是变量的类型。如果规则像“取消引用可空引用类型的值会引发警告”这么简单，那么即使这段代码是安全的，它仍然会生成警告。相反，编译器以类似于跟踪确定赋值的方式，在代码的每个位置跟踪变量的值是否可以为
    null。在你到达 `if` 语句的主体时，编译器知道 `address` 的值不能为 null，因此在你取消引用它时不会发出警告。我们下面展示的第三种方法与第二种类似，但没有使用局部变量。
- en: Listing 15.6\. Checking a reference with repeated property access
  id: totrans-1712
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.6\. 通过重复属性访问检查引用
- en: '[PRE225]'
  id: totrans-1713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Even when you understand how the second example compiles without a warning,
    [listing 15.6](kindle_split_032_split_000.html#ch15ex06) can be a little surprising.
    The compiler doesn’t just keep track of whether a variable value can be null;
    it does that for properties, too. It assumes that if you access the same property
    on the same value twice, the result will be the same both times.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你理解了第二个示例如何编译而不产生警告，[列表 15.6](kindle_split_032_split_000.html#ch15ex06) 可能仍然会让你感到有些惊讶。编译器不仅跟踪变量值是否可以为
    null，它也跟踪属性。它假设如果你在相同的值上两次访问相同的属性，两次的结果将是相同的。
- en: This may worry you. It means the feature isn’t guaranteed to stop your code
    from dereferencing null values. Another thread could modify the `Address` property
    between the two calls you’ve seen, or the `Address` property itself could be written
    to randomly return a null value sometimes. There are other ways you can fool the
    compiler into believing your code is fine when it’s not absolutely safe. This
    is known and accepted by the C# design team, because it’s a pragmatic balance
    between safety and awkwardness. Code using the C# 8 features will be much more
    null-safe than code written before, but making it 100% safe would almost certainly
    require more-invasive changes that would put a lot of developers off. So long
    as you understand the limits of what it’s trying to achieve, you’ll be fine.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让你担心。这意味着该特性并不能保证阻止你的代码解除对null值的引用。另一个线程可能在你看过的两次调用之间修改`Address`属性，或者`Address`属性本身可能会随机返回一个null值。还有其他方法可以欺骗编译器相信你的代码是安全的，尽管实际上并不绝对安全。这是C#设计团队所知道并接受的，因为它是在安全性和尴尬性之间的一种实用平衡。使用C#
    8特性的代码将比之前编写的代码更加null安全，但使其100%安全几乎肯定需要更侵入性的更改，这会让许多开发者望而却步。只要你能理解它试图达到的极限，你就可以安心了。
- en: You’ve seen that the compiler works hard to understand what might or might not
    be null. What can you do when it doesn’t have as much context as you do?
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到编译器努力理解可能或可能不是null的东西。当你没有那么多上下文时，你能做什么？
- en: 15.1.5\. The damn it or bang operator
  id: totrans-1717
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.5\. 该鬼玩意儿或砰操作符
- en: 'There’s one additional piece of syntax you haven’t looked at yet: the *dammit*,
    or *damn it*, or *bang operator*.^([[2](kindle_split_032_split_000.html#ch15fn2)])
    This is an exclamation mark at the end of an expression, and it’s a way of telling
    the compiler to ignore whatever it thinks it knows about that expression and just
    treat it as non-null.'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有看到的一个额外的语法元素：*鬼玩意儿*、*该死*或*叹号操作符*。^([[2](kindle_split_032_split_000.html#ch15fn2)])
    这是一个在表达式末尾的感叹号，它是一种告诉编译器忽略它认为关于该表达式的任何知识，并将其视为非null的方式。
- en: ²
  id: totrans-1719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-1720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I doubt that it’ll ever officially be called the damn it operator, but I suspect
    the name will live on in the community, just like everyone calls the Microsoft
    .NET Compiler Platform by its original name of Roslyn.
  id: totrans-1721
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我怀疑它永远不会正式被称为鬼玩意儿操作符，但我怀疑这个名字将在社区中流传，就像每个人都用Roslyn的原名来称呼Microsoft .NET编译平台一样。
- en: 'This is useful in two opposite situations:'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 这在两种相反的情况下很有用：
- en: Sometimes you have more information than the compiler does, so you know a value
    won’t be null, even though the compiler thinks it might be.
  id: totrans-1723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，你拥有的信息比编译器多，所以你知道一个值不会是null，即使编译器认为它可能是。
- en: Sometimes you want to deliberately pass in a null value to check your argument
    validation.
  id: totrans-1724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，你可能会故意传递一个null值来检查你的参数验证。
- en: Brief examples of the first situation are somewhat contrived, because you’d
    typically try to reorganize the code to avoid getting into that situation. In
    small examples, that’s almost always feasible, but it’s harder in real applications.
    The following listing shows a method to print the length of a string with input
    that can be null.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况的一些简短示例有些牵强，因为你通常会尝试重新组织代码以避免陷入那种情况。在小示例中，这几乎总是可行的，但在实际应用中则更困难。以下列表显示了一种打印字符串长度的方法，其中输入可以是null。
- en: Listing 15.7\. Using the bang operator to satisfy the compiler
  id: totrans-1726
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.7\. 使用叹号操作符来满足编译器
- en: '[PRE226]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '***1* Input can be null**'
  id: totrans-1728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 输入可以是null**'
- en: '***2* If IsNullOrEmpty returns false, it’s not null.**'
  id: totrans-1729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果IsNullOrEmpty返回false，则它不是null。**'
- en: '***3* Use the bang operator to convince the compiler.**'
  id: totrans-1730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用叹号操作符来说服编译器。**'
- en: In this example, you know something the compiler doesn’t in terms of the relationship
    between the input to `string.IsNullOrEmpty` and the return value. If `string.IsNullOrEmpty`
    returns `false`, the input can’t be null, so it’s fine to dereference that value
    to get the length of the string. If you just try to use `text.Length`, the compiler
    issues a warning. With `text!.Length`, you’re telling the compiler that you know
    better, effectively taking responsibility for reasoning about the value.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你知道编译器不知道的东西，即`string.IsNullOrEmpty`的输入与返回值之间的关系。如果`string.IsNullOrEmpty`返回`false`，则输入不能为null，因此可以安全地解除引用该值以获取字符串的长度。如果你只是尝试使用`text.Length`，编译器会发出警告。使用`text!.Length`，你是在告诉编译器你更了解情况，实际上是在承担对值的推理责任。
- en: Now it’d be nice if the compiler did understand that input/result relationship
    for `string.IsNullOrEmpty` method. We’ll come back to that idea in [section 15.1.7](kindle_split_032_split_000.html#ch15lev2sec7).
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果编译器能理解`string.IsNullOrEmpty`方法的输入/输出关系那就太好了。我们将在[15.1.7节](kindle_split_032_split_000.html#ch15lev2sec7)中回到这个想法。
- en: The second use of the bang operator is far easier to demonstrate with a realistic
    example. I mentioned earlier that you should still validate parameters for null,
    because it’s still entirely possible for you to receive null values. You may then
    want to add a unit test for that validation, but then the compiler warns you because
    you’re providing a null value when you’ve said it shouldn’t be null. The following
    listing shows how the bang operator fixes this.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 感叹号运算符的第二次使用可以通过一个现实生活中的例子更容易地演示。我之前提到，你应该仍然验证参数是否为null，因为仍然完全有可能你收到null值。然后你可能想为这个验证添加一个单元测试，但然后编译器会警告你，因为你提供了null值，而你说过它不应该为null。以下列表显示了感叹号运算符是如何解决这个问题。
- en: Listing 15.8\. Using the bang operator in unit tests
  id: totrans-1734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.8\. 在单元测试中使用感叹号运算符
- en: '[PRE227]'
  id: totrans-1735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '***1* Deliberately passes in a null value for the non-nullable parameter**'
  id: totrans-1736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 故意传递一个null值给不可空参数**'
- en: 'I’ve made the `Customer` and `Address` types immutable in [listing 15.8](kindle_split_032_split_000.html#ch15ex08)
    for simplicity. It’s interesting to note that the compiler doesn’t raise any kind
    of warning on the validation itself. Even though it knows the value shouldn’t
    be null, it doesn’t complain that the code checks whether it is null. But it does
    try to enforce that when you call the constructor in the test, the first argument
    is non-null. In an earlier version of C#, the lambda expression in the test would
    look like this:'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 我为了简化，在[列表15.8](kindle_split_032_split_000.html#ch15ex08)中将`Customer`和`Address`类型设置为不可变。值得注意的是，编译器在验证本身并没有发出任何警告。尽管它知道值不应该为null，但它不会抱怨代码检查它是否为null。但是，它确实试图强制当你测试中调用构造函数时，第一个参数不能为null。在C#的早期版本中，测试中的lambda表达式看起来是这样的：
- en: '[PRE228]'
  id: totrans-1738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: That code generates a warning, as you’d want it to in almost all cases. Changing
    the argument to `null!` satisfies the compiler, and the test does what you want.
    This raises the question of what it’s like working with nullable reference types
    in practice, and, in particular, how to migrate existing code to use the feature.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会生成警告，这在几乎所有情况下都是你想要的。将参数更改为`null!`可以让编译器满意，并且测试会按照你的意愿执行。这引发了一个问题，即在实际中使用可空引用类型是什么样的，特别是如何将现有代码迁移到使用该功能。
- en: 15.1.6\. Experiences of nullable reference type migration
  id: totrans-1740
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.6\. 可空引用类型迁移的经验
- en: There’s no better way to get a feel for how a feature works than to try it.
    I used the C# 8 preview build with Noda Time to see how much work would be required
    to make it warning free and to see whether it found any bugs. This section describes
    this experience and some guidelines I found myself following. Your code may face
    different challenges, but I suspect there’ll be plenty of commonality.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比尝试它更好的方式来了解一个功能是如何工作的了。我使用C# 8预览版和Noda Time来查看使其无警告需要多少工作量，以及它是否发现了任何错误。本节描述了这一经历以及我发现自己遵循的一些指南。你的代码可能会面临不同的挑战，但我怀疑会有很多共同点。
- en: Using attributes to express nullable intent before C# 8
  id: totrans-1742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在C# 8之前使用属性表达可空意图
- en: 'For a long time, Noda Time has used attributes (at least for all public methods)
    to indicate whether reference type parameters can be null and likewise whether
    return values may return null. For example, here’s the signature for a method
    in `IDateTimeZoneProvider`:'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，Noda Time使用属性（至少对于所有公共方法）来指示引用类型参数是否可以为null，以及返回值是否可能返回null。例如，以下是`IDateTimeZoneProvider`中一个方法的签名：
- en: '[PRE229]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: This shows that the argument for the `id` parameter must not be null, but the
    method may return a null reference. I’ve already expressed the intent around nullity,
    just not in a way that the C# compiler understood. That meant my first pass was
    just to go to all the places in the code where I’d said that null values were
    allowed and change them to use nullable reference types.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`id`参数的参数不能为null，但该方法可能返回null引用。我已经表达了关于null性的意图，只是没有用C#编译器理解的方式。这意味着我的第一次遍历只是去到代码中所有我说过允许null值的地方，并将它们更改为使用可空引用类型。
- en: I happened to use the JetBrains annotations provided with ReSharper. This allows
    ReSharper to perform the same kind of inspection that C# 8 does in the language.
    I won’t go into the details of these annotations other than to note that they’re
    available. You don’t have to use a third-party set of annotations at all, however.
    You can easily create your own attributes and apply them right now. Even without
    any tooling support, this can make your code easier to maintain, and you’ll be
    in a better position to move to the C# 8 nullable reference types in the future.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 我偶然使用了与ReSharper一起提供的JetBrains注解。这使得ReSharper能够执行与C# 8在语言中执行的同种类型的检查。我不会深入这些注解的细节，只是指出它们是可用的。然而，你根本不需要使用第三方注解集。你可以轻松创建自己的属性并将其立即应用。即使没有任何工具支持，这也可以使你的代码更容易维护，并且你将处于更好的位置，以便将来迁移到C#
    8的可空引用类型。
- en: Iteration is natural
  id: totrans-1747
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 迭代是自然的
- en: After this first pass, I had about 100 warnings. I went through and fixed most
    of those and then rebuilt. After the second pass, I had about 110 warnings—more
    than before! I went through and fixed most of those and then rebuilt. After the
    third pass, I still had about 100 warnings. I went through and fixed most of those
    and then rebuilt.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次第一次遍历后，我大约有100个警告。我逐一修复了这些警告，然后重新构建。在第二次遍历后，我大约有110个警告——比之前还多！我逐一修复了这些警告，然后重新构建。在第三次遍历后，我仍然大约有100个警告。我逐一修复了这些警告，然后重新构建。
- en: 'I don’t remember how many iterations this took, but it’s not a sign of anything
    being wrong. The process of making a codebase nullable-reference-type compliant
    is like playing whack-a-mole: you decide to change the nullability in one place,
    and then that can cause warnings everywhere that value is used. You change those,
    and the problem moves again. Decisions about nullability propagate through the
    code and need careful checking. This is fine and is what you should expect to
    happen.'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 我不记得这需要多少次迭代，但这并不是表明有任何错误发生的迹象。使代码库符合可空引用类型的过程就像玩打地鼠：你决定改变某个地方的可空性，然后这会导致该值被使用的地方出现警告。你更改这些警告，问题又转移了。关于可空性的决策会在代码中传播，需要仔细检查。这是正常的，也是你应该预料到的情况。
- en: But when part of the code needs a value to be nullable and another part needs
    it to be non-nullable, you’ve discovered a problem. This isn’t a problem that
    C# 8 has introduced; it’s a problem that the feature has revealed. How you handle
    it will be context specific.
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当代码的一部分需要值是可空的，而另一部分需要它不可空时，你就发现了一个问题。这不是C# 8引入的问题；这是该特性揭示的问题。你如何处理它将取决于具体情境。
- en: Best practices for using the bang operator
  id: totrans-1751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用感叹号运算符的最佳实践
- en: If you have to use the bang operator in production code, add a comment to explain
    why you did so. If you use a nicely searchable format (for example, including
    `NULLABLEREF` in the comment), you’ll be able to find them later. You may be able
    to remove the operator later through further tooling improvements. It’s not that
    using the operator is wrong, but it’s an assertion that you know better than the
    compiler, and I prefer not to trust myself that much.
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须在生产代码中使用感叹号运算符，请添加注释解释你这样做的原因。如果你使用一个易于搜索的格式（例如，在注释中包含`NULLABLEREF`），你将能够在以后找到它们。你可能能够通过进一步的工具改进来删除该运算符。使用该运算符本身并没有错，但它是一种断言，表明你知道比编译器更多，而我更喜欢不这么信任自己。
- en: I used the operator more often in test code and mostly for performing the sort
    of validation tests you saw in the previous section. Beyond that, if I expect
    a value to be non-null because of the way I’ve set up the test, I’m usually happy
    forcing the compiler to be happy with it, particularly if I know that it’ll be
    validated by the code I’m calling afterward anyway. If I’m wrong, the result should
    be the test failing with either an `ArgumentNullException` or `NullReferenceException`,
    which is fine, as I’d still know that my assumptions were invalid. Arguably, test
    code should be less defensive than production code in general; instead of trying
    to handle unexpected situations in a graceful way, it’s fine for them to fail.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 我在测试代码中使用该运算符的频率更高，主要用于执行之前章节中看到的验证测试。除此之外，如果因为我设置的测试方式，我期望一个值是非空的，我通常很高兴强迫编译器接受它，尤其是如果我知道它将被我随后调用的代码验证。如果我是错的，结果应该是测试失败，要么是`ArgumentNullException`，要么是`NullReferenceException`，这是可以接受的，因为我会知道我的假设是无效的。可以说，测试代码在一般情况下应该比生产代码更少防御性；而不是试图优雅地处理意外情况，它们失败是可以的。
- en: Null-inconsistent generics
  id: totrans-1754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可空不一致的泛型
- en: 'I found it odd to implement `IEqualityComparer<T>` for reference types in Noda
    Time, because it was defined long before nullable reference types were considered.
    Both `Equals` and `GetHashCode` are defined in terms of parameters of type `T`,
    but they’re inconsistent in terms of null handling: `Equals` is meant to handle
    null values, but `GetHashCode` is meant to throw an `ArgumentNullException`.'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 在Noda Time中为引用类型实现`IEqualityComparer<T>`我觉得很奇怪，因为它是在考虑可空引用类型之前定义的。`Equals`和`GetHashCode`都是根据类型为`T`的参数定义的，但在处理null方面不一致：`Equals`旨在处理null值，但`GetHashCode`旨在抛出`ArgumentNullException`。
- en: It’s unclear how this should be expressed in implementations. If I have an equality
    comparer for the `Period` class, should I implement `IEqualityComparer <Period?>`
    to allow null arguments or `IEqualityComparer<Period>` to prohibit them? Either
    way, callers could be surprised either at compile time or execution time.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中如何表达这一点尚不清楚。如果我有一个`Period`类的等价比较器，我应该实现`IEqualityComparer<Period?>`以允许null参数，还是实现`IEqualityComparer<Period>`以禁止它们？无论哪种方式，调用者都可能在编译时或执行时感到惊讶。
- en: Beyond just an implementation issue, it’s unclear to me how this could be expressed
    more clearly in the interface itself. More language design work may be required
    here in order to express how generic type parameters should be handled. Just using
    `T?` in the interface would feel wrong, as you wouldn’t want to accept `Nullable<T>`
    when `T` is a value type.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是实现问题，我在接口本身中如何更清楚地表达这一点也不清楚。可能需要更多的语言设计工作，以表达如何处理泛型类型参数。在接口中使用`T?`会感觉不正确，因为你不希望接受`Nullable<T>`当`T`是值类型时。
- en: Although I happened to encounter this with `IEqualityComparer<T>`, I anticipate
    the same issue cropping up in other interfaces and even in generic classes. I’m
    mostly mentioning it here so that you don’t think you’ve done anything wrong when
    you come across it.
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我偶然遇到了`IEqualityComparer<T>`，但我预计同样的问题也会出现在其他接口甚至泛型类中。我主要在这里提到这一点，以免你在遇到它时认为你做错了什么。
- en: The end result
  id: totrans-1759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 最终结果
- en: The Noda Time codebase isn’t huge, but it’s not tiny either. The whole process
    took me about five hours, including time diagnosing a bug in the preview build
    of Roslyn. In the end, I found a bug (now fixed) in Noda Time around inconsistent
    handling of an odd situation where `TimeZoneInfo.Local` returns null in some environments
    on Mono. I also found some missing annotations and had to clarify the intent for
    some internal members.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: Noda Time的代码库并不庞大，但也不小。整个过程花费了我大约五小时，包括诊断Roslyn预览构建中的错误的时间。最后，我在Noda Time中找到了一个错误（现已修复），这个错误与在某些环境中Mono上`TimeZoneInfo.Local`返回null的不一致处理有关。我还发现了一些缺失的注释，并不得不澄清一些内部成员的意图。
- en: I was pleased with the result; knowing the compiler was checking the consistency
    of the code improves my confidence in it. Additionally, after I’ve published a
    version of Noda Time built with C# 8, anyone using the library from C# 8 will
    benefit from the extra information. This will help move more errors from execution
    time to compile time, giving users more confidence in how they’re using Noda Time.
    It’s a win-win situation.
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 我对结果感到满意；知道编译器正在检查代码的一致性，这增加了我对它的信心。此外，在我发布使用C# 8构建的Noda Time版本之后，任何使用C# 8的库的用户都将从额外的信息中受益。这将有助于将更多错误从执行时间移至编译时间，使用户对如何使用Noda
    Time更有信心。这是一个双赢的局面。
- en: All of this experience was with the preview from the first half of 2018\. This
    isn’t the end state of the language design or the implementation, however. Let’s
    take a speculative look at the future.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些经验都是基于2018年上半年预览版的。然而，这并不是语言设计或实现的最终状态。让我们来推测一下未来。
- en: 15.1.7\. Future improvements
  id: totrans-1763
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.7\. 未来改进
- en: In June 2018, I spent time in conferences and user groups with Mads Torgersen,
    the lead of the C# language design team. I traveled with a laundry list of feature
    requests and issues based on my experience with Noda Time, and his responses reassured
    me about the future of the features.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年6月，我与C#语言设计团队的负责人Mads Torgersen一起参加了会议和用户组活动。我带着基于我在Noda Time使用经验的一系列功能请求和问题清单，他的回应让我对功能的未来充满信心。
- en: The C# team is aware that the preview that’s available already isn’t quite ready
    for mainstream adoption. A few things need a bit more work, but the preview allows
    the team to gather early feedback. The changes listed here won’t be the only ones,
    but they’re the ones I was most interested in.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: C# 团队已经意识到目前可用的预览版还不是主流采用的准备状态。有几件事情需要更多的工作，但预览版允许团队收集早期反馈。这里列出的更改不会是唯一的，但它们是我最感兴趣的。
- en: Providing the compiler with more semantic information
  id: totrans-1766
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为编译器提供更多语义信息
- en: 'When I introduced the bang operator in [section 15.1.5](kindle_split_032_split_000.html#ch15lev2sec5),
    I showed that the compiler didn’t understand the semantics of `string.IsNullOrEmpty`.
    (The compiler doesn’t infer that if the method returns `false`, the input couldn’t
    have been null.) This isn’t the only situation in which a relationship between
    input and output should be able to help the compiler. Here are three examples
    that feel like they should compile without warnings (including `string.IsNullOrEmpty`
    again for completeness):'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 [第 15.1.5 节](kindle_split_032_split_000.html#ch15lev2sec5) 介绍叹号操作符时，我展示了编译器并不理解
    `string.IsNullOrEmpty` 的语义。（编译器不会推断如果方法返回 `false`，则输入不可能是 null。）这不是唯一一个输入和输出之间关系应该能够帮助编译器的情况。以下有三个感觉上应该没有警告（包括
    `string.IsNullOrEmpty` 以确保完整性）的例子：
- en: '[PRE230]'
  id: totrans-1768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'In each case, the semantics of the code you’re calling are important. For these
    examples, the compiler would need to know the following:'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，你调用的代码的语义都很重要。对于这些示例，编译器需要了解以下内容：
- en: If the result of `string.IsNullOrEmpty` is false, the input can’t be null.
  id: totrans-1770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `string.IsNullOrEmpty` 的结果是 `false`，则输入不能为空。
- en: If the result of `ReferenceEquals` is false and one of the inputs is known to
    be a null reference, the other input can’t be null.
  id: totrans-1771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `ReferenceEquals` 的结果是 `false`，并且其中一个输入已知是空引用，则另一个输入不能为空。
- en: If the input to the `XElement` to `string` conversion operator is non-null,
    the output is also non-null.
  id: totrans-1772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `XElement` 到 `string` 转换操作符的输入非空，输出也将非空。
- en: These are all examples of relationships between inputs and outputs, and those
    relationships can’t be expressed at the moment. I suspect that most uses of the
    bang operator in the preview build could be avoided if the compiler understood
    these relationships. How can the compiler get that extra information?
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是输入和输出之间关系的事例，而这些关系目前无法表达。我怀疑如果编译器理解了这些关系，那么预览构建中大多数使用叹号操作符的情况都可以避免。编译器如何获取这些额外信息？
- en: One approach that could work for these specific examples would be for the compiler
    to have the information hardcoded. That would be easy for the C# design team but
    unsatisfactory in other ways. It’d put the framework libraries on a different
    footing to third-party libraries, which would be annoying. I may want to express
    relationships like this in Noda Time, for example, which would make it more pleasant
    to use.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些特定示例，一个可能的工作方法是让编译器将信息硬编码。这对 C# 设计团队来说很容易，但在其他方面可能不太令人满意。这会让框架库与第三方库处于不同的地位，这会让人感到烦恼。例如，我可能想在
    Noda Time 中表达这种关系，这将使其使用起来更加愉快。
- en: It’s likely that the C# team will instead design a whole new mini-language that
    can be expressed in attributes to give the compiler the extra semantic information
    it needs to be smarter about determining whether a particular value should be
    considered “definitely not null.” This will require a lot of work to design and
    implement but will provide a much more complete solution.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，C# 团队将设计一种全新的迷你语言，可以通过属性来表示，从而为编译器提供额外的语义信息，使其能够更智能地确定某个特定值是否应该被认为是“肯定不是
    null”。这将需要大量的设计和实施工作，但将提供一个更加完整的解决方案。
- en: Deeper thinking about generics
  id: totrans-1776
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 对泛型的深入思考
- en: 'Generics present interesting challenges for nullability design. I mentioned
    one example when implementing `IEqualityComparer<T>`, but the issue goes well
    beyond that. Consider the following simple class that’s already valid in C# 7:'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型在可空性设计上提出了有趣的挑战。我在实现 `IEqualityComparer<T>` 时提到了一个例子，但这个问题远远超出了那个范围。考虑以下在
    C# 7 中已经有效的简单类：
- en: '[PRE231]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Should that be valid, and what does it mean? In particular, what’s the result
    of constructing an instance of it without setting the `Value` property?
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是有效的，那它意味着什么？特别是，如果没有设置 `Value` 属性，构造该实例的结果是什么？
- en: For `Wrapper<int>`, the value of `Value` will be 0 by default.
  id: totrans-1780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Wrapper<int>`，`Value` 的默认值将是 0。
- en: For `Wrapper<int?>`, the value of `Value` will be the null value for `int?`
    by default.
  id: totrans-1781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Wrapper<int?>`，`Value` 的默认值将是 `int?` 的空值。
- en: For `Wrapper<string>`, the value of `Value` will be a null reference by default.
    That’s bad, as it goes against the type of `Value` being the non-nullable string
    type.
  id: totrans-1782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Wrapper<string>`，`Value` 的值默认将是一个空引用。这很糟糕，因为它与 `Value` 的非空字符串类型相矛盾。
- en: For `Wrapper<string?>`, the value of `Value` will be a null reference by default.
    That’s okay, as the type of `Value` is the nullable string type.
  id: totrans-1783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `Wrapper<string?>`，`Value` 的值默认将是一个空引用。这是可以接受的，因为 `Value` 的类型是可空字符串类型。
- en: It gets even more confusing when you consider that at execution time, `Wrapper
    <int>` and `Wrapper<int?>` will be different CLR types, but `Wrapper<string>`
    and `Wrapper<string?>` will be the same CLR type.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑到在执行时，`Wrapper<int>` 和 `Wrapper<int?>` 将是不同的 CLR 类型，但 `Wrapper<string>`
    和 `Wrapper<string?>` 将是相同的 CLR 类型时，事情会变得更加混乱。
- en: I don’t know how this confusion will be resolved in C# 8, but the team is aware
    of it. I’m glad it’s their job rather than mine to make sense of it, as it makes
    my head hurt just thinking about it.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道 C# 8 中这种混淆将如何解决，但团队已经注意到了这个问题。我很高兴是他们而不是我来弄清楚这个问题，因为这仅仅想到它就让我头疼。
- en: That example uses only syntax that’s valid in C# 7 and doesn’t explicitly refer
    to nullable types at all. What if you try to use `T?` within a generic type or
    method?
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 那个例子只使用了在 C# 7 中有效的语法，并且根本没有明确提到可空类型。如果你尝试在泛型类型或方法中使用 `T?` 会怎样？
- en: In C# 7, if you have a type parameter `T`, the type `T?` can be used only when
    `T` is constrained to be a non-nullable value type, at which point it means `Nullable<T>`.
    That’s reasonably simple, but what can you do for nullable reference types? It
    seems likely that you’ll need a new generic constraint of non-nullable reference
    type, at which point `T?` could be used when `T` is either constrained to be a
    non-nullable value type or is constrained to be a non-nullable reference type.
    I wouldn’t expect a single constraint to indicate “some non-nullable type,” because
    the representation of the corresponding nullable type is very different between
    value types and reference types.
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 7 中，如果你有一个类型参数 `T`，只有当 `T` 被约束为非可空值类型时，才能使用 `T?`，此时它意味着 `Nullable<T>`。这相当简单，但对于可空引用类型你能做什么呢？看起来你将需要一个非可空引用类型的新泛型约束，此时
    `T?` 可以在 `T` 被约束为非可空值类型或被约束为非可空引用类型时使用。我不期望一个单一的约束来表示“某些非可空类型”，因为相应的可空类型在值类型和引用类型之间的表示方式非常不同。
- en: Opt-in parameter validation
  id: totrans-1788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自愿参数验证
- en: The only changes implemented so far have been at compile time. The IL generated
    by the compiler doesn’t change, and you still need to perform parameter validation
    to protect against code that ignores compiler warnings, uses the bang operator,
    or is compiled against an earlier version of C#.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 目前实施的所有更改都是在编译时进行的。编译器生成的 IL 代码没有变化，你仍然需要执行参数验证来保护代码不受忽略编译器警告、使用感叹号运算符或针对 C#
    的早期版本编译的影响。
- en: That makes sense, but the validation feels like boilerplate code. The null-coalescing
    operator, `nameof` operator, and `throw` expressions are all features that have
    helped improve the code required for validation in some cases, but it’s still
    annoying and easy to forget.
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意义的，但验证感觉像是样板代码。空合并运算符、`nameof` 运算符和 `throw` 表达式都是有助于在某些情况下改进验证所需代码的功能，但它们仍然令人烦恼且容易忘记。
- en: 'One feature under discussion is to allow an exclamation mark after a parameter
    name to indicate that the compiler should generate a null validation at the start
    of a method. Consider a method that might currently be written like this:'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 正在讨论的一个特性是允许在参数名后跟一个感叹号，以指示编译器在方法开始时生成空值验证。考虑一个可能目前这样编写的方法：
- en: '[PRE232]'
  id: totrans-1792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'You could instead write this:'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以改写为：
- en: '[PRE233]'
  id: totrans-1794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '***1* Automatic null validation**'
  id: totrans-1795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 自动空值验证**'
- en: It’s possible that properties could have automatic validation in the same way.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 可能属性也可以以相同的方式自动验证。
- en: Enabling nullability checking
  id: totrans-1797
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 启用空值检查
- en: In the preview build I’ve used, nullability checking is turned on by default.
    Although you can suppress warnings in the normal way, it’s likely that the C#
    8 compiler will have more nuanced settings before it launches. There are lots
    of different scenarios to consider.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 在我使用的预览构建中，空值检查默认是开启的。虽然你可以像往常一样抑制警告，但 C# 8 编译器在发布之前可能会提供更细致的设置。有许多不同的场景需要考虑。
- en: When developers upgrade to the C# 8 compiler, they’re likely to want to do this
    without seeing any new warnings. This is particularly important if the project
    settings treat warnings as errors. I suspect this means nullability checking will
    be turned off by default, at least for existing projects.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者升级到C# 8编译器时，他们很可能会希望在看不到任何新警告的情况下进行此操作。如果项目设置将警告视为错误，这一点尤为重要。我怀疑这意味着nullability检查默认情况下会被关闭，至少对于现有项目来说是这样。
- en: Not all class libraries will embrace C# 8 at the same time. It’ll be important
    for code that uses C# 8 with nullability checking turned on to be able to consume
    libraries that haven’t migrated yet. This is likely to be geared toward reporting
    as few errors as possible. For example, the compiler could treat all inputs to
    the library as nullable but all outputs from the library as non-nullable. Additionally,
    there’ll need to be a way for a library to indicate when it has migrated.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类库都会同时拥抱C# 8。对于使用C# 8且已开启nullability检查的代码来说，能够消费尚未迁移的库非常重要。这很可能是为了尽可能减少错误报告。例如，编译器可能会将库的所有输入视为可空，但所有输出视为不可空。此外，还需要有一种方式让库能够表明它已经迁移。
- en: When developers decide to migrate a project to use nullable reference types,
    they may want to do so over the course of several changes. It’s possible that
    their project may contain generated code that can’t be easily modified to express
    nullability. This suggests it’d be useful to be able to express the concept of
    “this code expresses nullability” on a per type basis.
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发者决定将项目迁移到使用可空引用类型时，他们可能会在几个更改的过程中这样做。他们的项目可能包含无法轻易修改以表达nullability的生成代码。这表明能够在每个类型的基础上表达“此代码表达nullability”的概念是有用的。
- en: These considerations are new for C#. We’ve never had a language feature with
    such a broad impact on compatibility. I expect the team to iterate on this aspect
    several times before the final launch on C# 8.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑对于C#来说是新的。我们从未有过一个对兼容性影响如此广泛的语言特性。我预计团队在C# 8最终发布之前会在此方面迭代多次。
- en: Nullable reference types likely will be the biggest feature in C# 8, but others
    are also available in preview builds already. One of my favorites is switch expressions.
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 可空引用类型很可能会成为C# 8中最大的特性，但其他特性也已经在预览版本中可用。我最喜欢的是switch表达式。
- en: 15.2\. Switch expressions
  id: totrans-1804
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2. Switch表达式
- en: 'The switch statement has been available in C# right from the start, and the
    only way it has changed in all that time is to permit pattern matching in C# 7\.
    It remains an imperative control structure: if this case matches, do this; if
    that case matches, do that. A lot of the uses of switch statements are more functional,
    though, with each case computing a result: if this case matches, the result is
    X; if that case matches, the result is Y. This is a common construct in functional
    programming languages in which many functions are expressed purely in terms of
    pattern matching.'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: switch语句从C#一开始就可用，在这段时间里，它唯一的变化是允许在C# 7中实现模式匹配。它仍然是一个命令式控制结构：如果这个情况匹配，就做这个；如果那个情况匹配，就做那个。尽管如此，switch语句的许多用法都是函数式的，每个情况都计算一个结果：如果这个情况匹配，结果是X；如果那个情况匹配，结果是Y。这在许多函数式编程语言中是一个常见的结构，其中许多函数完全用模式匹配来表示。
- en: The introduction of expression-bodied members has made this stick out like a
    sore thumb. Many methods can be implemented with a single expression, but if you
    want to use a switch/case structure, you have to use a block body. This is usually
    just an inconvenience, but it’s still a point of friction.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式成员的引入使得这一点显得格外突出。许多方法可以用单个表达式实现，但如果你想使用switch/case结构，就必须使用块体。这通常只是不方便，但仍然是一个摩擦点。
- en: 'C# 8 introduces *switch expressions* as an alternative to switch statements.
    This uses somewhat different syntax from switch statements, so it’s worth comparing
    the two. In [chapter 12](kindle_split_029_split_000.html#ch12), when I introduced
    pattern matching, you looked at an example of a switch statement to compute the
    perimeter of different shapes. Here’s the code used in [chapter 12](kindle_split_029_split_000.html#ch12):'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8引入了*switch表达式*作为switch语句的替代方案。它与switch语句的语法略有不同，因此值得比较。在[第12章](kindle_split_029_split_000.html#ch12)中，当我介绍模式匹配时，你看到了一个用于计算不同形状周长的switch语句示例。以下是[第12章](kindle_split_029_split_000.html#ch12)中使用的代码：
- en: '[PRE234]'
  id: totrans-1808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: The following listing shows the equivalent code using a switch expression instead
    but still using a regular block-bodied method.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了使用switch表达式代替的等效代码，但仍然使用常规的块体方法。
- en: Listing 15.9\. Converting a switch statement into a switch expression
  id: totrans-1810
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.9\. 将switch语句转换为switch表达式
- en: '[PRE235]'
  id: totrans-1811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'There are a lot of things to point out here, so I haven’t tried to cram them
    all into the code as annotations. Here are all the differences between a switch
    statement and a switch expression:'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多需要注意的地方，所以我并没有试图将它们全部作为注释放入代码中。以下是`switch`语句和`switch`表达式之间的所有差异：
- en: Instead of `switch (value)`, the introductory syntax for switch expressions
    is `value switch`.
  id: totrans-1813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch (value)`的引入语法是`value switch`。'
- en: A fat arrow `=>` comes between the pattern and the result to return if that
    pattern is matched. (In a `switch` statement, a colon is used instead.)
  id: totrans-1814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果匹配到模式，则模式与返回结果之间使用一个粗箭头`=>`。在`switch`语句中，则使用冒号代替。
- en: The `case` keyword isn’t used at all in switch expressions. The left side of
    the => is just a pattern with an optional guard clause with the `when` keyword.
  id: totrans-1815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`switch`表达式中根本不使用`case`关键字。`=>`的左侧只是一个带有可选的`when`关键字保护子句的模式。
- en: The right side of the `=>` is just an expression. The `return` keyword isn’t
    used, because every pattern results in a value or throws. Likewise, there’s never
    a `break` statement.
  id: totrans-1816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=>`的右侧只是一个表达式。不需要使用`return`关键字，因为每个模式都会产生一个值或抛出异常。同样，也永远不会出现`break`语句。'
- en: The patterns are comma separated. If you’re converting a switch statement into
    a switch expression, this usually means changing semicolons into commas.
  id: totrans-1817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式是逗号分隔的。如果您正在将`switch`语句转换为`switch`表达式，这通常意味着将分号改为逗号。
- en: There’s no `default` case. Instead, the discard `_` (underscore) is used to
    match anything that hasn’t already been matched.
  id: totrans-1818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有使用`default`情况。相反，使用丢弃的`_`（下划线）来匹配任何尚未匹配的内容。
- en: 'My experience has mostly been writing methods that return a switch expression
    result directly, but you can also use it like any other expression. For example,
    you could write this:'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 我的经验主要是编写直接返回`switch`表达式结果的方法，但您也可以像使用任何其他表达式一样使用它。例如，您可以编写如下：
- en: '[PRE236]'
  id: totrans-1820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '***1* Body of switch expression as before**'
  id: totrans-1821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* switch表达式的主体与之前相同**'
- en: This is fine, but as I mentioned before, one of the nicest aspects of switch
    expressions is to use them for expression-bodied methods. The following listing
    shows the evolution of [listing 15.9](kindle_split_032_split_000.html#ch15ex09)
    into an expression-bodied method.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但如我之前提到的，switch表达式最令人愉快的一个方面是用于表达式主体方法。以下列表显示了[列表15.9](kindle_split_032_split_000.html#ch15ex09)演变成表达式主体方法的过程。
- en: Listing 15.10\. Using a switch expression to implement an expression-bodied
    method
  id: totrans-1823
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.10\. 使用switch表达式实现表达式主体方法
- en: '[PRE237]'
  id: totrans-1824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: You can format this however you like, perhaps moving the `shape switch` onto
    the first line, or maybe outdenting the braces to the same level as the method
    declaration.
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按自己的喜好格式化，比如将`形状切换`移到第一行，或者将花括号缩进到与方法声明相同的级别。
- en: One important difference between switch statements and switch expressions is
    that there must always be some result (which could be an exception) from a switch
    expression. A switch expression isn’t allowed to do nothing and produce no value.
    You can use the `_` discard to make sure of that, but it’s possible to write a
    switch expression that isn’t *exhaustive*—in other words, an expression that may
    not always match. With the preview build I’ve been working with, this produces
    a compiler warning, and then the compiler emits invalid IL. This might become
    a compile-time error instead, or the compiler may inject code to throw an exception
    (possibly `InvalidOperationException`) to indicate that the code encountered a
    situation it didn’t expect.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句和`switch`表达式之间的重要区别是，`switch`表达式必须始终有一个结果（可能是异常）。不允许`switch`表达式什么都不做并产生没有值。您可以使用`_`丢弃来确保这一点，但可能编写一个不是*详尽无遗*的`switch`表达式——换句话说，一个可能不会总是匹配的表达式。在我使用的预览构建中，这会产生编译器警告，然后编译器生成无效的IL。这可能会成为编译时错误，或者编译器可能会注入代码来抛出异常（可能是`InvalidOperationException`），以表明代码遇到了它没有预料到的情况。'
- en: The one issue I have with switch expressions at the moment is that there’s no
    way of expressing multiple patterns that should evaluate to the same result. In
    a switch statement, you can specify multiple case labels, but there’s no equivalent
    in switch expressions yet. The C# team is aware of the desire for this, so hopefully
    it will be included before C# 8 is released.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我对switch表达式有一个问题，那就是没有方法来表达多个应该评估为相同结果的模式。在`switch`语句中，您可以指定多个case标签，但在switch表达式中还没有等效的选项。C#团队已经注意到了这种需求，所以希望它能在C#
    8发布之前被包含进去。
- en: The use of patterns in C# 8 isn’t just improved via switch expressions. The
    patterns themselves are growing in scope.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 8中，模式的使用不仅仅是通过switch表达式得到改进。模式本身也在扩展其范围。
- en: 15.3\. Recursive pattern matching
  id: totrans-1829
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.递归模式匹配
- en: 'As a reminder, the patterns introduced in C# 7 were as follows:'
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，C# 7中引入的模式如下：
- en: Type patterns (`expression is Type t`)
  id: totrans-1831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型模式（`expression is Type t`）
- en: Constant patterns (`expression is 10`, `expression is null`, and so on)
  id: totrans-1832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量模式（`expression is 10`、`expression is null`等）
- en: The `var` pattern (`expression is var v`)
  id: totrans-1833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`模式（`expression is var v`）'
- en: C# 8 will introduce recursive patterns (patterns can be nested within bigger
    patterns) as well as deconstruction patterns. The simplest way of explaining recursive
    patterns is to show them in action. We’ll come back to deconstruction patterns.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8将引入递归模式（模式可以嵌套在更大的模式中）以及解构模式。解释递归模式的最简单方法就是展示它们的作用。我们将回到解构模式。
- en: 15.3.1\. Matching properties in patterns
  id: totrans-1835
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.1.在模式中匹配属性
- en: 'To match properties with additional patterns inside an overall pattern, you
    use braces containing a comma-separated list of patterns against properties. The
    property patterns match the property value against the nested pattern using any
    of the normal pattern types. As an example, let’s have another look at the three
    patterns we’re using to work out the areas of rectangles, circles, and triangles
    taken from [listing 15.10](kindle_split_032_split_000.html#ch15ex10):'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 要在整体模式内匹配具有附加模式的属性，你使用包含逗号分隔的模式列表的括号来匹配属性。属性模式使用任何正常的模式类型将属性值与嵌套模式匹配。作为一个例子，让我们再次看看我们用来计算矩形、圆形和三角形面积的三个模式，这些模式取自[列表15.10](kindle_split_032_split_000.html#ch15ex10)：
- en: '[PRE238]'
  id: totrans-1837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: In each case, you don’t need the shape itself; you just need properties from
    it. You can use nested `var` patterns to match those properties against any value
    and extract pattern variables for each of the properties you need. The following
    listing shows the full method with the nested patterns.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，你不需要形状本身；你只需要它的属性。你可以使用嵌套`var`模式来匹配这些属性与任何值，并为每个你需要属性的属性提取模式变量。以下列表显示了包含嵌套模式的完整方法。
- en: Listing 15.11\. Matching nested patterns
  id: totrans-1839
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.11.匹配嵌套模式
- en: '[PRE239]'
  id: totrans-1840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Is this clearer than the previous code? I’m not sure. I’ve used it as an example
    that follows neatly from the previous one, but I might easily stick with the code
    in [listing 15.10](kindle_split_032_split_000.html#ch15ex10). You’ll look at a
    more complicated example later, in which the feature becomes more compelling but
    would be harder to immediately understand.
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
  zh: 这比之前的代码更清晰吗？我不确定。我已经用它作为从上一个例子中顺利跟随的例子，但我可能很容易地坚持使用[列表15.10](kindle_split_032_split_000.html#ch15ex10)中的代码。你将在稍后的一个更复杂的例子中看到，这个特性将变得更加引人注目，但可能更难立即理解。
- en: 'Note that although here you’ve stopped capturing the `Rectangle`, `Circle`,
    or `Triangle` in their own pattern variables (`rect`, `circle`, and `triangle`
    before), that’s only because you don’t need them for anything. It’s still valid
    to introduce a pattern variable that way. For example, if you were describing
    shapes, you might have a pattern to describe a flat rectangle with zero height:'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管在这里你已经停止使用它们各自的模式变量（在`rect`、`circle`和`triangle`之前）来捕获`Rectangle`、`Circle`或`Triangle`，但这仅仅是因为你不需要它们用于任何事情。以这种方式引入模式变量仍然是有效的。例如，如果你在描述形状，你可能有一个模式来描述一个高度为零的平面矩形：
- en: '[PRE240]'
  id: totrans-1843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: This is useful when you have a lot of properties but you’re just testing patterns
    against a few of them. Next up, we’ll look at *deconstruction patterns*.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有很多属性但只是对其中几个进行模式测试时，这很有用。接下来，我们将探讨*解构模式*。
- en: 15.3.2\. Deconstruction patterns
  id: totrans-1845
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.2.解构模式
- en: 'You saw deconstruction of tuples in [section 12.1](kindle_split_029_split_000.html#ch12lev1sec1)
    and deconstruction via the `Deconstruct` method in [section 12.2](kindle_split_029_split_000.html#ch12lev1sec2).
    Patterns in C# 8 will be extended to allow deconstruction with nested patterns
    inside. As a somewhat contrived example, you might decide that it’s natural to
    deconstruct a `Triangle` to all three of its sides:'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第12.1节](kindle_split_029_split_000.html#ch12lev1sec1)中看到了元组的解构，在[第12.2节](kindle_split_029_split_000.html#ch12lev1sec2)中通过`Deconstruct`方法进行了解构。C#
    8中的模式将被扩展，以允许使用嵌套模式进行解构。作为一个有点牵强的例子，你可能会决定将`Triangle`解构为其所有三个边是自然的：
- en: '[PRE241]'
  id: totrans-1847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: You could then simplify our perimeter computation to deconstruct to three variables
    instead of specifying each property name. So instead of this case in our switch
    expression
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以简化我们的周长计算，将其解构为三个变量而不是指定每个属性名称。所以，在我们的switch表达式中，而不是这个情况
- en: '[PRE242]'
  id: totrans-1849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'you could have this:'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样：
- en: '[PRE243]'
  id: totrans-1851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Again, is that more readable than just matching against the type? Maybe. Over
    time, I suspect each developer will work out their own preferences around pattern
    matching and ideally come to a convention within the codebases they’re working
    in, too.
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这比仅匹配类型更易读吗？也许吧。随着时间的推移，我怀疑每个开发者都会在自己的偏好中找到关于模式匹配的方法，并且理想情况下，也会在他们的代码库中形成一种约定。
- en: 15.3.3\. Omitting types from patterns
  id: totrans-1853
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.3\. 从模式中省略类型
- en: 'The ability to look inside objects makes patterns useful even when you’re not
    testing the value’s type. At that point, it feels redundant to specify the type
    as part of the pattern. For this example, let’s go back to the customer and address
    example used for nullable reference types. You’ll go back to the first data model:
    all mutable, all nullable:'
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 查看对象内部的能力使得模式在您不测试值类型时仍然有用。在那个点上，将类型作为模式的一部分指定似乎显得多余。对于这个例子，让我们回到之前用于可空引用类型的客户和地址示例。您将回到第一个数据模型：所有可变的，所有可空的：
- en: '[PRE244]'
  id: totrans-1855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Now suppose you want to greet customers in different ways depending on the country
    in their address. Your input could be of type `Customer`, so you don’t want to
    have to repeat that within the pattern. When you match the `Address` of a customer
    within a pattern, that will always be of type `Address`, so you don’t need to
    specify that type either.
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设您想根据地址中的国家以不同的方式问候客户。您的输入可能是 `Customer` 类型，因此您不想在模式中重复它。当您在模式中匹配客户的 `Address`
    时，它始终是 `Address` 类型，因此您也不需要指定该类型。
- en: The following listing shows multiple patterns matching different kinds of customers.
    It also demonstrates the `{ }` pattern, which is a special case of a property
    pattern that doesn’t have any properties to match. That pattern matches any non-null
    value.
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了匹配不同类型客户的多个模式。它还演示了 `{ }` 模式，这是没有属性要匹配的属性模式的特例。该模式匹配任何非空值。
- en: Listing 15.12\. Matching customers against multiple patterns concisely
  id: totrans-1858
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.12\. 简洁地匹配多个模式以匹配客户
- en: '[PRE245]'
  id: totrans-1859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '***1* Matches a country of UK**'
  id: totrans-1860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 匹配国家为 UK**'
- en: '***2* Matches a country of USA**'
  id: totrans-1861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 匹配国家为 USA**'
- en: '***3* Matches any country, but it must be present**'
  id: totrans-1862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 匹配任何国家，但必须存在**'
- en: '***4* Matches any address**'
  id: totrans-1863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 匹配任何地址**'
- en: '***5* Matches any customer, even with a null address**'
  id: totrans-1864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 匹配任何客户，即使地址为空**'
- en: '***6* Matches anything, even a null customer reference**'
  id: totrans-1865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 匹配任何内容，即使客户引用为空**'
- en: The ordering is important here. For example, a customer with an address with
    a country of USA could match every pattern except the first one. You could make
    the patterns more selective instead (using the constant null pattern to match
    customers with a null `Address` property value, for example), but it’s simpler
    to rely on the ordering.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的顺序很重要。例如，一个地址国家为美国的客户可能除了第一个模式外，都匹配。您可以使模式更具有选择性（例如，使用常量空模式来匹配具有空 `Address`
    属性值的客户），但依赖顺序会更简单。
- en: The enhancements to pattern matching in C# 8 will allow them to be used in more
    cases where currently you need `if` statements. Switch expressions add to this
    flexibility, too. I expect more and more code to be written with patterns. As
    always, it’s important to avoid going over the top; not all code will be simpler
    when written with patterns than with the control structures we had before. Still,
    this area of C#’s evolution definitely has a lot of potential. Our next feature
    is really a pair of features enabled by two new framework types.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8 中对模式匹配的增强将允许它们在更多需要 `if` 语句的情况下使用。切换表达式也增加了这种灵活性。我预计越来越多的代码将使用模式编写。一如既往，避免过度使用很重要；并非所有代码使用模式编写都比我们之前使用的控制结构更简单。然而，C#
    进化的这个领域确实有很大的潜力。我们的下一个特性实际上是由两种新的框架类型启用的两个特性。
- en: 15.4\. Indexes and ranges
  id: totrans-1868
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4\. 索引和范围
- en: Compared with nullable reference types and improved pattern handling, indexes
    and ranges feel like a small feature, even combined. But I suspect over time we’ll
    come to wonder why it took so long to have them. The following listing provides
    a tiny taste before you look at the details.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 与可空引用类型和改进的模式处理相比，索引和范围感觉像是一个小特性，即使结合起来也是如此。但我怀疑随着时间的推移，我们会 wonder 为什么它们出现得这么晚。下面的列表在您查看详细信息之前提供了一个小小的预览。
- en: Listing 15.13\. Trimming the first and last character from a string with a range
  id: totrans-1870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.13\. 使用范围从字符串中裁剪第一个和最后一个字符
- en: '[PRE246]'
  id: totrans-1871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '***1* Takes a substring of the string with a range literal**'
  id: totrans-1872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用范围文字从字符串中提取子字符串**'
- en: 'The output is as follows:'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE247]'
  id: totrans-1874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: The highlighted expression of `1..^1` is the interesting part here. To understand
    this code, you need to learn about two new types.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 这里高亮的`1..^1`表达式是这里有趣的部分。要理解这段代码，你需要了解两种新的类型。
- en: 15.4.1\. Index and Range types and literals
  id: totrans-1876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.4.1\. 索引和范围类型和字面量
- en: 'The idea is simple. `Index` and `Range` are two structs that will be provided
    in the framework but currently need to be defined in your own code:'
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单。`Index`和`Range`是框架中将提供的两个结构体，但目前需要在你的代码中定义：
- en: '`Index` is an integer from either the start or end of something indexable.
    The value of the index is never negative.'
  id: totrans-1878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Index`是从可索引事物的开始或结束的一个整数。索引的值永远不会是负数。'
- en: '`Range` is a pair of indexes: one for the start of the range and one for the
    end.'
  id: totrans-1879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range`是一对索引：一个用于范围的开始，一个用于范围的结束。'
- en: 'There are then three pieces of important syntax:'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 然后有三个重要的语法元素：
- en: A regular implicit conversion from `int` to create a “from the start” `Index`.
  id: totrans-1881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`int`到创建“从开始”`Index`的常规隐式转换。
- en: A new unary operator (`^`) that can be used with `int` to create a “from the
    end” `Index`. Here a value of 0 means the element just past the end, and a value
    of 1 means the last element.^([[3](kindle_split_032_split_000.html#ch15fn3)])
  id: totrans-1882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的单目运算符（`^`），可以与`int`一起使用来创建“从末尾”的`Index`。在这里，0的值表示刚好在末尾的元素，而1的值表示最后一个元素.^([[3](kindle_split_032_split_000.html#ch15fn3)])
- en: ³
  id: totrans-1883
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-1884
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is slightly counterintuitive when using an `Index` with an indexer, but
    it makes a lot more sense with ranges, which have exclusive upper bounds. A range
    with an upper bound of ^0 is effectively “to the end of the sequence,” which is
    probably what you’d expect.
  id: totrans-1885
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用带有索引器的`Index`时，这有点反直觉，但与具有排他性上界的范围相比，它更有意义。一个上界为`^0`的范围实际上是指“到序列的末尾”，这可能是你预期的。
- en: A new binary-ish operator (`..`) with optional operands for the start and end
    to create a `Range`.
  id: totrans-1886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的类似二元的运算符（`..`），具有可选的起始和结束操作数来创建`Range`。
- en: The `..` operator is binary-ish because there can be zero, one, or two operands.
    The following listing shows examples of all of these. You’re not applying the
    indexes or ranges to anything; you’re just creating the values.
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: '`..`运算符是类似二元的，因为可以有零个、一个或两个操作数。以下列表显示了所有这些示例。你并不是将索引或范围应用于任何东西；你只是在创建值。'
- en: Listing 15.14\. Index and range literals
  id: totrans-1888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.14\. 索引和范围字面量
- en: '[PRE248]'
  id: totrans-1889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: One point to note is that the start and end points of a range can be any index.
    For example, you could have a range of `^5..10` representing the fifth element
    from the end to the tenth element from the start. This would be unusual, but valid.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，范围的起始点和结束点可以是任何索引。例如，你可以有一个`^5..10`的范围，表示从末尾第五个元素到从开始第十个元素。这可能是非典型的，但却是有效的。
- en: This is the sum total of the direct language support for indexes and ranges.
    It’s when they also have framework support that they become useful.
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是索引和范围直接语言支持的总量。当它们也有框架支持时，它们才变得有用。
- en: 15.4.2\. Applying indexes and ranges
  id: totrans-1892
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.4.2\. 应用索引和范围
- en: All the examples in this section require extension methods and extension operators
    supported by the C# 8 preview build. The exact APIs may change, and the extensions
    provided in the preview work with only a limited set of types; this is just enough
    to demonstrate the benefits. In [listing 15.13](kindle_split_032_split_000.html#ch15ex13),
    I showed how the `Substring` method can be used with a `Range`. Both indexes and
    ranges will be applied and most often to types that represent sequences of some
    form, such as
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有示例都需要C# 8预览版支持的扩展方法和扩展运算符。确切的API可能会更改，预览版中提供的扩展只与有限的一组类型一起工作；这足以展示其优势。在[列表
    15.13](kindle_split_032_split_000.html#ch15ex13)中，我展示了如何使用`Range`与`Substring`方法一起使用。索引和范围都将应用，并且通常应用于表示某种形式的序列的类型，例如
- en: Arrays
  id: totrans-1894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Spans
  id: totrans-1895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: Strings (as sequences of UTF-16 code units)
  id: totrans-1896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串（作为UTF-16代码单元的序列）
- en: 'These all support two operations:'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都支持两种操作：
- en: Retrieving a single element
  id: totrans-1898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取单个元素
- en: Creating a slice to represent part of the sequence
  id: totrans-1899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个切片来表示序列的一部分
- en: The single-element-retrieval operation already has a common representation using
    an indexer accepting an `int` parameter, but this makes it hard to retrieve the
    last element in a uniform way. The `Index` type solves this with its from the
    start or from the end aspect. The slice operation has previously taken different
    forms depending on the type involved. For example, `Span<T>` has a `Slice` method,
    whereas `String` has a `Substring` method.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 单元素检索操作已经有一个使用接受 `int` 参数的索引器的常见表示，但这使得以统一的方式检索最后一个元素变得困难。`Index` 类型通过其从起始或从末尾的特性解决了这个问题。切片操作以前根据涉及类型的不同而采取不同的形式。例如，`Span<T>`
    有一个 `Slice` 方法，而 `String` 有一个 `Substring` 方法。
- en: By adding indexer overloads accepting `Index` and `Range` values, you can use
    a consistent and convenient syntax to perform both operations on all of the relevant
    types. The following listing shows similar calls working for a string and a `Span<int>`.
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加接受 `Index` 和 `Range` 值的索引重载，你可以使用一致且方便的语法在所有相关类型上执行这两种操作。以下列表显示了类似调用在字符串和
    `Span<int>` 上工作。
- en: Listing 15.15\. Using indexer overloads for index and range in a string and
    a span
  id: totrans-1902
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.15\. 在字符串和 span 中使用索引重载来访问索引和范围
- en: '[PRE249]'
  id: totrans-1903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '***1* Accesses a single character by index from start**'
  id: totrans-1904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从起始索引访问单个字符**'
- en: '***2* Accesses a single character by index from end**'
  id: totrans-1905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从末尾索引访问单个字符**'
- en: '***3* Takes a substring using a range**'
  id: totrans-1906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用范围获取子字符串**'
- en: '***4* Accesses a single element by index from start**'
  id: totrans-1907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从起始索引访问单个元素**'
- en: '***5* Accesses a single element by index from end**'
  id: totrans-1908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从末尾索引访问单个元素**'
- en: '***6* Creates a slice using a range**'
  id: totrans-1909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用范围创建切片**'
- en: 'The output is as follows:'
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE250]'
  id: totrans-1911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Both the string and span indexers accepting a `Range` treat the upper bound
    of the range as exclusive: the range `[2..7]` returns the elements with indexes
    2, 3, 4, 5, and 6.'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: 接受 `Range` 的字符串和 span 索引器都将范围的上界视为排他性：范围 `[2..7]` 返回索引为 2、3、4、5 和 6 的元素。
- en: In [listing 15.15](kindle_split_032_split_000.html#ch15ex15), the ranges included
    both start and end indexes, and both index values were computed from the start.
    You can use any range with the indexers so long as the indexes are valid for the
    sequence they’re applied to. For example, using `text[^5..]` with the code in
    [listing 15.15](kindle_split_032_split_000.html#ch15ex15) would return `world`
    as the last five characters of `text`.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 15.15](kindle_split_032_split_000.html#ch15ex15) 中，包含的范围包括起始和结束索引，并且这两个索引值都是从起始计算的。只要索引对它们应用的序列有效，你就可以使用任何范围与索引器一起使用。例如，使用
    `text[^5..]` 与 [列表 15.15](kindle_split_032_split_000.html#ch15ex15) 中的代码将返回 `text`
    的最后五个字符 `world`。
- en: Likewise, you could write `text[^10..5]`, which would return `ello`. In the
    context of a string of length 11 (`hello world`), an index of ^10 is equivalent
    to an index of 1, so `text[^10..5]` is equivalent (in this case, it does depend
    on the length of `text`) to `text[1..5]`, returning the four characters after
    the first. Next, we’ll look at increased language support for asynchrony.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以写 `text[^10..5]`，这将返回 `ello`。在长度为 11 的字符串（`hello world`）的上下文中，索引 ^10 等同于索引
    1，因此 `text[^10..5]` 在这个情况下（这确实取决于 `text` 的长度）等同于 `text[1..5]`，返回第一个字符之后的四个字符。接下来，我们将探讨对异步性的语言支持增强。
- en: 15.5\. More async integration
  id: totrans-1915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5\. 更多的异步集成
- en: 'When async/await was introduced in C# 5, it revolutionized asynchrony for many
    C# developers. But a few language features have so far stayed synchronous, making
    it hard to go all in on asynchrony. In this section, we’ll look at the following:'
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 C# 5 中引入 async/await 时，它彻底改变了许多 C# 开发者的异步性。但到目前为止，一些语言特性仍然保持同步，这使得全面采用异步性变得困难。在本节中，我们将探讨以下内容：
- en: Async disposal
  id: totrans-1917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处置
- en: Async iteration (`foreach`)
  id: totrans-1918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步迭代 (`foreach`)
- en: Async iterators (`yield return`)
  id: totrans-1919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步迭代器 (`yield return`)
- en: These require framework support as well as language support. It wouldn’t be
    appropriate for the compiler to approximate asynchrony by executing the synchronous
    code on a different thread, for example. Let’s start with async disposal, which
    is the simplest of the three features.
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 这些需要框架支持和语言支持。编译器通过在另一个线程上执行同步代码来近似异步性是不合适的。让我们从异步处置开始，这是三个特性中最简单的。
- en: 15.5.1\. Asynchronous resource disposal with using await
  id: totrans-1921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.1\. 使用 using await 进行异步资源处置
- en: The `IDisposable` interface with its single `Dispose` method is naturally synchronous.
    If that method needs to perform I/O, such as to flush a stream, then it can block
    with all the normal issues that causes.
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 带有单个 `Dispose` 方法的 `IDisposable` 接口自然是同步的。如果该方法需要执行 I/O，例如刷新流，那么它可能会因为所有正常原因而阻塞。
- en: 'A new interface will be introduced for classes that support asynchronous disposal:'
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: 将引入一个新的接口，用于支持异步释放的类：
- en: '[PRE251]'
  id: totrans-1924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: There’s no requirement that a type that implements `IAsyncDisposable` also implements
    `IDisposable`, although I suspect many types will do so.
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `IAsyncDisposable` 的类型不需要也实现 `IDisposable`，尽管我怀疑许多类型会这样做。
- en: There’s then corresponding language support in the form of the `using await`
    statement, which works as you’d expect it to, calling `DisposeAsync` automatically
    and awaiting the resulting task. The following listing shows an example of implementing
    the interface and then using it.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: 然后以 `using await` 语句的形式提供相应的语言支持，它按预期工作，自动调用 `DisposeAsync` 并等待结果任务。以下列表显示了实现接口并使用它的示例。
- en: Listing 15.16\. Implementing `IAsyncDisposal` and calling it with `using await`
  id: totrans-1927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.16\. 实现 `IAsyncDisposal` 并使用 `using await` 调用它
- en: '[PRE252]'
  id: totrans-1928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'The output shows the resource disposal:'
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了资源释放：
- en: '[PRE253]'
  id: totrans-1930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'This is simple, but it hides two aspects of complexity that need to be addressed:'
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但它隐藏了需要解决的两个复杂性的方面：
- en: Libraries typically await tasks with `ConfigureAwait(false)`. Applications typically
    await tasks without this. If the compiler is doing the awaiting automatically,
    how can the user configure this?
  id: totrans-1932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库通常使用 `ConfigureAwait(false)` 等待任务。应用程序通常在没有这个的情况下等待任务。如果编译器正在自动等待，用户如何配置这个？
- en: It’d be natural to have cancellation available for disposal. Where does that
    fit into the interface and the call site?
  id: totrans-1933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于释放来说，自然应该有取消操作。这在该接口和调用点中如何定位？
- en: 'The C# team is aware of both points, and I expect them to be addressed in some
    form before release. The same problems occur for the other async features in C#
    8, and I hope they’ll all be solved in a similar way. Let’s look at the next feature
    now: asynchronous iteration with `foreach`.'
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: C# 团队已经注意到了这两个问题，我期望它们在发布前以某种形式得到解决。C# 8 中其他异步特性也存在相同的问题，我希望它们都能以类似的方式得到解决。现在让我们看看下一个特性：使用
    `foreach` 的异步迭代。
- en: 15.5.2\. Asynchronous iteration with foreach await
  id: totrans-1935
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.2\. 使用 `foreach await` 的异步迭代
- en: 'Spoiler alert: there’s quite a lot of text before we reach the language feature
    in this section. That’s necessary in order to explain it properly, but the upshot
    is that code like this will be valid, where `asyncSequence` requires asynchronous
    work to retrieve the items:'
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在我们达到本节中的语言特性之前，这里有很多文本。这是为了正确解释它所必需的，但结果是，像这样的代码将是有效的，其中 `asyncSequence`
    需要异步操作来检索项目：
- en: '[PRE254]'
  id: totrans-1937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '***1* Uses item**'
  id: totrans-1938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用项目**'
- en: 'The interfaces introduced for asynchronous iteration aren’t quite as straightforward
    as the one for disposal. There are two interfaces, mirroring `IEnumerable<T>`
    and `IEnumerator<T>` to some extent, but not quite so obviously:'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: 引入的异步迭代接口并不像释放接口那样简单直接。有两个接口，在一定程度上反映了 `IEnumerable<T>` 和 `IEnumerator<T>`，但并不那么明显：
- en: '[PRE255]'
  id: totrans-1940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '`IAsyncEnumerable<T>` may be closer to `IEnumerable<T>` than you expect; there’s
    nothing asynchronous in it. Instead of `GetEnumerator()`, it has `GetAsyncEnumerator()`,
    and that returns an `IAsyncEnumerator<T>`, but it does so synchronously. It’s
    possible that for some implementations this will be problematic, but I expect
    it to be the natural approach for most asynchronous sequences. Any implementation
    that wants to perform asynchronous operations as part of setup will probably need
    to defer that work until the caller starts iterating over the result.'
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAsyncEnumerable<T>` 可能比您预期的更接近 `IEnumerable<T>`；它里面没有异步操作。它不是 `GetEnumerator()`，而是
    `GetAsyncEnumerator()`，它返回一个 `IAsyncEnumerator<T>`，但它是以同步方式完成的。对于某些实现，这可能会成为问题，但我预计对于大多数异步序列来说，这将是自然的方法。任何希望在设置过程中执行异步操作的实现可能都需要将这项工作推迟到调用者开始迭代结果时。'
- en: The `IAsyncEnumerator<T>` interface is much further from `IEnumerator<T>` and
    reflects a common pattern in real-world implementations. Asynchrony is often used
    when I/O is involved, such as retrieving results over a network. That often naturally
    results in sequences being retrieved in chunks; you may perform a query and retrieve
    the first 10 results together, then the next 7, and then be told that’s the complete
    result set.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAsyncEnumerator<T>` 接口与 `IEnumerator<T>` 相差甚远，反映了现实世界实现中的常见模式。当涉及 I/O 时，如通过网络检索结果，通常使用异步操作。这通常自然地导致序列以块的形式检索；您可能执行一个查询并一次性检索前
    10 个结果，然后是下一个 7 个，然后被告知这是完整的结果集。'
- en: While you’re iterating within a set of results that has been buffered, there’s
    no need for asynchrony. Although asynchrony is quite efficient, it’s not completely
    free, so it’s worth avoiding if you can. Instead, you can iterate synchronously,
    so long as you have a way of determining when you’ve reached the end of the current
    result set. At that point, you can asynchronously fetch the next one and iterate
    through that synchronously again.
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在缓冲的结果集中迭代时，不需要异步操作。尽管异步操作相当高效，但它并不完全免费，所以如果你能避免，那就值得避免。相反，你可以同步迭代，只要你有一种方法来确定你是否已经到达了当前结果集的末尾。在那个点上，你可以异步获取下一个结果，并再次同步迭代。
- en: 'The `IAsyncEnumerator<T>` interface exposes this pattern through its two methods:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAsyncEnumerator<T>` 接口通过其两个方法公开此模式：'
- en: '`WaitForNextAsync` is asynchronous, returning a task that indicates whether
    any more results were retrieved or whether you’ve reached the end of the sequence.'
  id: totrans-1945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitForNextAsync` 是异步的，返回一个任务，指示是否检索到更多结果或是否已到达序列的末尾。'
- en: '`TryGetNext` is synchronous, returning the next item. The `out` parameter is
    used to indicate whether there *was* a next item to return.^([[4](kindle_split_032_split_000.html#ch15fn4)])
    When this is `false`, that doesn’t mean you’ve necessarily reached the end of
    sequence; it just means you need to call `WaitForNextAsync` again.'
  id: totrans-1946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TryGetNext` 是同步的，返回下一个项目。`out` 参数用于指示是否返回了下一个项目。[^4](kindle_split_032_split_000.html#ch15fn4)
    当这是 `false` 时，这并不意味着你必然到达了序列的末尾；它只是意味着你需要再次调用 `WaitForNextAsync`。'
- en: ⁴
  id: totrans-1947
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-1948
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is oddly inconsistent with most `TryXyz` methods, which return `bool` and
    use an `out` parameter for the value. This could change before release.
  id: totrans-1949
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这与大多数 `TryXyz` 方法不一致，这些方法返回 `bool` 并使用 `out` 参数作为值。这可能在发布前改变。
- en: That may all sound complicated, but the good news is that you’re unlikely to
    need to do any of this yourself; the new `foreach await` statement handles it
    all for you.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来很复杂，但好消息是，你不太可能需要自己执行任何这些操作；新的 `foreach await` 语句为你处理了一切。
- en: 'Let’s look at an example, which draws heavily from my experience working with
    Google Cloud Platform APIs. Many APIs have list operations, such as listing contacts
    in an address book or virtual machines in a cluster. There may be too many results
    to return in a single RPC response, so we have a page-based pattern: each response
    contains a “next page token” that the client supplies on a subsequent request
    to retrieve more data. For the first request, the client doesn’t supply a page
    token, and the final response doesn’t contain a page token. A simplified view
    of the API might look like the following listing.'
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，这个例子大量借鉴了我与 Google Cloud Platform API 一起工作的经验。许多 API 都有列表操作，例如在地址簿中列出联系人或在集群中列出虚拟机。返回的结果可能太多，无法在一个
    RPC 响应中返回，所以我们有一个基于页面的模式：每个响应都包含一个“下一页令牌”，客户端在后续请求中提供该令牌以检索更多数据。对于第一个请求，客户端不提供页码，最后的响应也不包含页码。API
    的简化视图可能如下所示。
- en: Listing 15.17\. Simplified RPC-based service for listing cities
  id: totrans-1952
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.17\. 列出城市的简化 RPC 服务
- en: '[PRE256]'
  id: totrans-1953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: That’s unwieldy to use directly, but it can easily be wrapped in a client that
    exposes this API instead, as shown in the next listing.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接使用起来不方便，但它可以很容易地被包装在一个客户端中，该客户端公开此 API，如下一个列表所示。
- en: Listing 15.18\. Wrapper around the RPC service to provide a simpler API
  id: totrans-1955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.18\. RPC 服务的包装，以提供更简单的 API
- en: '[PRE257]'
  id: totrans-1956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '***1* Constructs a GeoClient with an RPC service**'
  id: totrans-1957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 构建带有 RPC 服务的 `GeoClient`**'
- en: '***2* Provides a simple async sequence of cities**'
  id: totrans-1958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 提供一个简单的城市异步序列**'
- en: With `GeoClient` in place, you can finally use `foreach await`, as in the following
    listing.
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GeoClient` 就位后，你最终可以使用 `foreach await`，如下所示。
- en: Listing 15.19\. Using `foreach await` with a `GeoClient`
  id: totrans-1960
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.19\. 使用 `foreach await` 与 `GeoClient`
- en: '[PRE258]'
  id: totrans-1961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: The final code here is a lot simpler than all the code I had to show you to
    set up the example, and that’s without even looking at the implementation of `GeoClient`.
    But that’s a good thing; it shows the benefit of the feature. You’ve taken relatively
    complex definitions in both `IGeoService` and `IAsyncEnumerable<T>` and consumed
    them in a simple and efficient manner with `foreach await`.
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最终的代码比之前向你展示的设置示例的代码要简单得多，甚至没有查看 `GeoClient` 的实现。但这是一件好事；它显示了该功能的好处。你以相对简单和高效的方式使用
    `foreach await` 消费了 `IGeoService` 和 `IAsyncEnumerable<T>` 中的相对复杂的定义。
- en: '|  |'
  id: totrans-1963
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The downloadable source code contains a complete example with an in-memory fake
    service implementation.
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 可下载的源代码包含一个完整的示例，其中包含内存中的模拟服务实现。
- en: '|  |'
  id: totrans-1966
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: One thing you may be surprised about is that `IAsyncEnumerator<T>` doesn’t implement
    `IAsyncDisposable`. That could change before release, but even if it doesn’t,
    I expect the compiler to dispose of an enumerator if it turns out to implement
    `IAsyncDisposable` at execution time.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶的一件事是 `IAsyncEnumerator<T>` 并没有实现 `IAsyncDisposable`。这可能在发布前改变，但即使它没有改变，我也预计编译器会在执行时销毁一个枚举器，如果它实现了
    `IAsyncDisposable`。
- en: Just like the synchronous `foreach` statement, `foreach await` won’t require
    the `IAsyncEnumerable<T>` and `IAsyncEnumerator<T>` interfaces to be implemented.
    It’ll be pattern based, so any type providing a `GetAsyncEnumerator()` method
    that returns a type that in turn provides the appropriate `WaitForNextAsync` and
    `TryGetNext` methods will be supported. This could allow some optimizations, but
    I expect the interfaces to be used most of the time.
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 就像同步的 `foreach` 语句一样，`foreach await` 不会要求实现 `IAsyncEnumerable<T>` 和 `IAsyncEnumerator<T>`
    接口。它将基于模式，因此任何提供 `GetAsyncEnumerator()` 方法且返回的类型又提供了适当的 `WaitForNextAsync` 和 `TryGetNext`
    方法的类型都将得到支持。这可能会允许一些优化，但我预计接口将在大多数情况下被使用。
- en: So far, you’ve seen how to consume asynchronous sequences. What about producing
    them?
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何消费异步序列。那么，如何产生它们呢？
- en: 15.5.3\. Asynchronous iterators
  id: totrans-1970
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.5.3. 异步迭代器
- en: C# 2 introduced iterators with `yield return` and `yield break` statements to
    make it easy to write methods returning `IEnumerable<T>` or `IEnumerator<T>`.
    C# 8 will have the same feature for asynchronous sequences. The feature isn’t
    available in the preview, but the following listing shows how I expect it to work.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 引入了 `yield return` 和 `yield break` 语句，使得编写返回 `IEnumerable<T>` 或 `IEnumerator<T>`
    的方法变得容易。C# 8 将为异步序列提供相同的功能。这个功能在预览版中不可用，但下面的列表显示了我是如何期望它工作的。
- en: Listing 15.20\. Implementing `ListCitiesAsync` with an iterator
  id: totrans-1972
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.20. 使用迭代器实现 `ListCitiesAsync`
- en: '[PRE259]'
  id: totrans-1973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'The mapping between the async iterator method and the `IAsyncEnumerator<T>`
    interface, with its mixture of asynchronous and synchronous parts, will be complex
    to implement. Whenever you continue executing code in the async method, it can
    complete that specific call in several ways:'
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代器方法与 `IAsyncEnumerator<T>` 接口之间的映射，其中包含异步和同步部分的混合，将非常复杂来实现。每次你在异步方法中继续执行代码时，它可以通过几种方式完成那个特定的调用：
- en: It could await an incomplete asynchronous operation.
  id: totrans-1975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能等待一个不完整的异步操作。
- en: It could reach a `yield return` statement.
  id: totrans-1976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能达到一个 `yield return` 语句。
- en: It could reach a `yield break` statement.
  id: totrans-1977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能达到一个 `yield break` 语句。
- en: It could reach the end of the method.
  id: totrans-1978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能达到方法的末尾。
- en: It could throw an exception.
  id: totrans-1979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能抛出一个异常。
- en: How those are handled will depend on whether the caller is executing `WaitForNextAsync()`
    or `TryGetNext()`. To make this efficient, the generated code should effectively
    switch between synchronous mode (if you’re yielding values with no intervening
    awaits) and asynchronous mode (if you’re awaiting an asynchronous operation).
    I can broadly picture how this might be achieved, but I’m glad I’m not the one
    having to implement it.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能的处理方式将取决于调用者是否正在执行 `WaitForNextAsync()` 或 `TryGetNext()`。为了提高效率，生成的代码应该能够有效地在同步模式（如果你在无中间等待的情况下产生值）和异步模式（如果你正在等待异步操作）之间切换。我可以大致想象出这可能如何实现，但我很高兴我不是那个需要实现它的人。
- en: There are other features not available in the C# 8 preview yet. We’ll look at
    these more briefly.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些功能在 C# 8 预览版中尚未提供。我们将简要地探讨这些功能。
- en: 15.6\. Features not yet in preview
  id: totrans-1982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.6. 尚未在预览中提供的功能
- en: If C# 8 turns out to have only the features I’ve listed so far, it’ll still
    be a big deal. In some ways, I wish we could have a release with just nullable
    reference types, wait a year or so for most codebases to be updated to it, and
    then continue with more features. But C# 8 likely will ship with more features
    than I’ve shown so far.
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 C# 8 只包含我之前列出的功能，它仍然是一个大事件。在某些方面，我希望我们能够发布一个只包含可空引用类型的版本，等待一年左右，让大多数代码库更新到它，然后继续添加更多功能。但
    C# 8 很可能将包含比我之前展示的更多功能。
- en: This section discusses the features I think are the most likely to be included
    in C# 8\. Even more features have been proposed either by members of the C# team
    or by external developers. The C# team uses GitHub to keep track of language proposals,
    which makes it easy to see what’s going on and contribute yourself; see [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang).
    We’ll start with a feature inspired by Java.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了我认为最有可能包含在C# 8中的特性。还有更多特性被C#团队或外部开发者提出。C#团队使用GitHub来跟踪语言提案，这使得查看正在进行的事情并自行贡献变得容易；请参阅[https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)。我们将从一个受Java启发的特性开始。
- en: 15.6.1\. Default interface methods
  id: totrans-1985
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.6.1. 默认接口方法
- en: 'Whereas C# introduced extension methods for LINQ, Java took a different approach
    to enable its support for *streams*, which covers many of the same use cases as
    LINQ. In Java 8, Oracle introduced *default methods* in Java interfaces: an interface
    could declare a method and a default implementation for it, which could then be
    overridden within a concrete implementation. The default implementation can’t
    declare any state in terms of fields; it has to be expressed in terms of the other
    members of the interface.'
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C#为LINQ引入了扩展方法，但Java采取了不同的方法来支持其*流*功能，这涵盖了与LINQ相同的大量用例。在Java 8中，Oracle在Java接口中引入了*默认方法*：接口可以声明一个方法及其默认实现，然后可以在具体实现中覆盖它。默认实现不能声明任何以字段形式存在的状态；它必须以接口的其他成员的形式表达。
- en: 'The two features are similar in some ways: they both allow logic to be expressed
    so the consumer of an interface can call a method without every interface implementation
    having to directly know about it or implement it. There are pros and cons with
    each approach:'
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特性在某些方面是相似的：它们都允许逻辑以这样的方式表达，即接口的消费者可以在不需要每个接口实现直接了解或实现它的情况下调用方法。每种方法都有其优缺点：
- en: Extension methods can be introduced by anyone, not just the author of the interface.
    You can’t add a default method to an interface you can’t control. (Extension methods
    can also be applied to classes and structs, of course.)
  id: totrans-1988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法可以由任何人引入，而不仅仅是接口的作者。你不能向一个你无法控制的接口添加默认方法。（当然，扩展方法也可以应用于类和结构体。）
- en: Default methods can be overridden by implementing classes, often for the sake
    of optimization. Extension methods can’t be overridden; they’re just static methods
    with syntactic sugar to make calling them look more like they’re regular instance
    methods.
  id: totrans-1989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认方法可以通过实现类来覆盖，通常是为了优化。扩展方法不能被覆盖；它们只是带有语法糖的静态方法，使得调用它们看起来更像常规实例方法。
- en: The second point can be easily appreciated using LINQ’s `Enumerable.Count()`
    method as an example. By default, it counts the elements in a sequence by calling
    `GetEnumerator()` and then counting how many calls to `MoveNext()` on that enumerator
    return `true`.
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点可以通过使用LINQ的`Enumerable.Count()`方法作为例子来轻松理解。默认情况下，它通过调用`GetEnumerator()`来计算序列中的元素数量，然后统计该枚举器上`MoveNext()`方法返回`true`的调用次数。
- en: Many implementations of `IEnumerable<T>` have far more efficient ways of determining
    the number of elements. `Enumerable.Count()` is specifically optimized for some
    of those, such as `ICollection` and `ICollection<T>` implementations. But what
    about a collection that doesn’t want to implement either of those interfaces but
    still wants to provide the `Count` cheaply? It’s stuck; it has no way of communicating
    to `Enumerable.Count()` that it can implement that part of LINQ itself more efficiently.
    If `Count()` had been a method in `IEnumerable<T>` with a default implementation,
    however, our new collection could just override that method.
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: 许多`IEnumerable<T>`的实现有更有效的方法来确定元素的数量。`Enumerable.Count()`特别针对某些实现进行了优化，例如`ICollection`和`ICollection<T>`实现。但对于不想实现这些接口但仍想以低成本提供`Count`功能的集合怎么办？它就陷入了困境；它没有方法将信息传达给`Enumerable.Count()`，表明它可以更高效地实现LINQ的这一部分。然而，如果`Count()`是`IEnumerable<T>`中的一个具有默认实现的方法，那么我们的新集合只需覆盖该方法即可。
- en: 'Here’s an example of how `IEnumerable<T>` could’ve been declared using C# 8
    default interface methods:'
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用C# 8默认接口方法声明`IEnumerable<T>`的例子：
- en: '[PRE260]'
  id: totrans-1993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: Default interface methods also allow interfaces to be expanded over time in
    a rather more version-friendly way. New methods can be added with a default implementation
    that either implements the new functionality using the existing members or potentially
    throws a `NotSupportedException`. That way, old implementations will still build,
    even if the new method can’t be called reliably. Versioning is a tricky subject,
    to say the least, but having another option in our toolbox is welcome. In numerous
    situations, this would’ve made things simpler in code that I maintain.
  id: totrans-1994
  prefs: []
  type: TYPE_NORMAL
  zh: 默认接口方法还允许接口以更版本友好的方式随着时间的推移进行扩展。可以通过默认实现添加新方法，该实现要么使用现有成员实现新功能，要么可能抛出`NotSupportedException`。这样，旧实现仍然可以构建，即使新方法无法可靠地调用。版本控制至少是一个棘手的话题，但拥有另一个工具箱选项是受欢迎的。在许多情况下，这会使我维护的代码更简单。
- en: Default interface methods are proving to be a controversial feature. They require
    CLR support, which makes the feature harder to experiment with before committing
    to it wholeheartedly. If the feature is included, it’ll be interesting to see
    its adoption rate. It may remain rarely used until the runtime versions that support
    it are widely adopted, too. Next, we’ll look at a feature that has been talked
    about and even prototyped for a long time.
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 默认接口方法正在证明是一个有争议的功能。它们需要CLR支持，这使得在完全承诺之前进行实验更困难。如果该功能被包含在内，将很有趣地看到其采用率。它可能直到支持它的运行时版本被广泛采用之前都很少使用。接下来，我们将探讨一个被讨论了很长时间甚至已经原型化的功能。
- en: 15.6.2\. Record types
  id: totrans-1996
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.6.2. 记录类型
- en: The forerunner of record types was a feature called *primary constructors*,
    which was originally intended to be present in C# 6\. The language team wasn’t
    happy with some of the rough edges in the original design, so they decided to
    delay its introduction until it could be improved.
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型的先驱是一个名为*主构造函数*的功能，最初旨在C# 6中存在。语言团队对原始设计中的某些粗糙边缘不满意，因此他们决定推迟其引入，直到可以改进。
- en: 'Record types are designed to make it easy to create immutable classes or structs
    with a given set of properties. I tend to think of them in terms of starting with
    anonymous types but adding all kinds of features. They can be declared incredibly
    simply. For example, here’s a complete class declaration:'
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型旨在使创建具有给定属性集的不可变类或结构体变得容易。我倾向于从匿名类型开始，但添加所有种类的功能。它们可以声明得非常简单。例如，以下是一个完整的类声明：
- en: '[PRE261]'
  id: totrans-1999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'That generates a bunch of members for you, although you can still introduce
    your own behavior as well. The generated members are a constructor, properties,
    equality methods, a `Deconstruct` method for deconstruction, and a `With` method
    like this:'
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 这会为你生成一些成员，尽管你仍然可以引入自己的行为。生成的成员包括构造函数、属性、相等方法、一个用于解构的`Deconstruct`方法，以及一个类似这样的`With`方法：
- en: '[PRE262]'
  id: totrans-2001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: That isn’t valid syntax for optional parameter default values at the moment,
    and it’s not clear whether it’ll be valid to write that code explicitly, but it
    at least shows the intention of the method’s behavior.
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这不是可选参数默认值的有效语法，而且不清楚是否可以明确地写出这样的代码，但至少显示了该方法行为意图。
- en: 'The `With` method is designed to interoperate with new syntax in the form of
    *with expressions*. The idea is that both the method and the syntax make it easy
    to create a new instance of the immutable type that’s the same as an existing
    one but with one or more properties changed. `WithFoo` methods are common in immutable
    types already (where `Foo` is the name of a property in the type), but they typically
    work on one property at a time. For example, with an immutable Point class with
    `X`, `Y`, and `Z` properties, you might use the following code to create a new
    point that has the same `Z` value as a previous point, but new `X` and `Y` values:'
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: '`With`方法旨在与以*with表达式*形式出现的新语法进行互操作。想法是方法和语法都使得创建一个与现有实例相同但一个或多个属性已更改的新不可变类型变得容易。在不可变类型中已经常见`WithFoo`方法（其中`Foo`是该类型中属性的名称），但它们通常一次只处理一个属性。例如，对于具有`X`、`Y`和`Z`属性的不可变Point类，你可能使用以下代码创建一个新的点，它具有与先前点相同的`Z`值，但新的`X`和`Y`值：'
- en: '[PRE263]'
  id: totrans-2004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Each `WithFoo` method calls a constructor, passing in all the existing properties
    other than the one named in the method, where the new value specified in the parameter
    is used. These methods become tedious to write and have a performance implication,
    too: to “change” N properties, you need to make N method calls, each one of which
    creates a new object.'
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `WithFoo` 方法都会调用一个构造函数，传递除了方法中命名的属性之外的所有现有属性，其中参数中指定的新值被用来使用。这些方法编写起来很繁琐，并且也有性能影响：要“更改”N
    个属性，你需要进行 N 次方法调用，每次调用都会创建一个新的对象。
- en: 'The `With` method for record types is different: it has one parameter for each
    property of the type, with new syntax for a default parameter value if that parameter
    isn’t specified, indicating that the value should be taken from the current object.
    For example, consider the `With` method in our `Point` type. You could either
    call that directly'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型的 `With` 方法不同：它为类型的每个属性有一个参数，如果未指定该参数，则具有用于默认参数值的语法，表示应从当前对象中获取该值。例如，考虑我们
    `Point` 类型的 `With` 方法。你可以直接调用它
- en: '[PRE264]'
  id: totrans-2007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'or use the new *with expression* syntax, which looks more like an object initializer:'
  id: totrans-2008
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用新的 *with 表达式* 语法，它看起来更像是一个对象初始化器：
- en: '[PRE265]'
  id: totrans-2009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: The two would compile to the same IL. This way, only a single new object is
    constructed.
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个会编译成相同的 IL。这样，就只构造了一个新的对象。
- en: This is only a simple example. It becomes trickier when you have a complex type
    and you want to modify just one leaf node. For example, if you have a `Contact`
    type with an `Address` property, you may want to create a new contact that’s the
    same as the old one but with one part of the `Address` property different. It’s
    possible that’ll still be tricky in C# 8 but that *with expression* syntax may
    be enhanced to make that simpler over time, just as the syntax for pattern matching
    has grown.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子。当你有一个复杂类型并且只想修改一个叶节点时，事情会变得复杂。例如，如果你有一个具有`Address`属性的`Contact`类型，你可能想创建一个新的联系信息，它与旧的联系信息相同，但`Address`属性的一部分不同。在
    C# 8 中，这仍然可能很棘手，但*with 表达式*语法可能会随着时间的推移得到增强，使其变得更简单，就像模式匹配的语法一样。
- en: I’m excited about the possibilities here. Immutable types have been a pain to
    create and work with in C# for a long time. Whereas C# 7 tuples filled one gap
    left by anonymous types, record types fill another. I’ve always loved anonymous
    types for the work the compiler does for you in terms of equality, constructor,
    and property code. It’s just a shame we couldn’t name them or add more functionality
    later. Record types fix all of this and more. Finally, I want to highlight a few
    features that involve a little more thinking outside the box.
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这里的可能性感到兴奋。在 C# 中，不可变类型长期以来一直难以创建和使用。虽然 C# 7 的元组填补了匿名类型留下的一个空缺，但记录类型填补了另一个空缺。我一直喜欢匿名类型，因为编译器为你做了很多工作，包括等价性、构造函数和属性代码。只是遗憾的是，我们无法给它们命名或稍后添加更多功能。记录类型解决了所有这些问题，还有更多。最后，我想强调一些需要更多创新思维的功能。
- en: 15.6.3\. Even more features in brief
  id: totrans-2013
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.6.3\. 简要介绍更多功能
- en: Although some minor features are more likely to make it into C# 8, they’re not
    as interesting as the ones I discuss here. Remember, you can always check GitHub
    to learn more about what might be included and its up-to-date status.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些小功能更有可能被纳入 C# 8，但它们不如我这里讨论的有趣。记住，你总是可以检查 GitHub 来了解可能包含的内容及其最新状态。
- en: Type classes (aka concepts, shapes, or structural generic constraints)
  id: totrans-2015
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型类（也称为概念、形状或结构化泛型约束）
- en: Although generics are great for many situations, they have limitations. There
    are “shapes” of data types that can’t be expressed with generics, such as operators
    and constructors. Although you can require that a type argument has a parameterless
    constructor, you can’t require that it has a constructor with a specific parameter
    list. Additionally, at times types can have the same shape in some useful way
    but not implement any common interfaces or have any common base classes other
    than `System .Object`. *Type classes* would be a new kind of type to address these
    concerns. They’d be a little like interfaces, but the implementing class wouldn’t
    need to know about them. You would be able to constrain a generic type parameter
    by the type class instead.
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然泛型在许多情况下都很出色，但它们也有局限性。有些数据类型“形状”无法用泛型表达，例如运算符和构造函数。虽然你可以要求类型参数有一个无参构造函数，但你不能要求它有一个具有特定参数列表的构造函数。此外，有时类型可以在某些有用的方式下具有相同的形状，但除了
    `System.Object` 之外，没有实现任何公共接口或具有任何公共基类。*类型类* 将是一种新的类型，用于解决这些问题。它们会有一点像接口，但实现类不需要了解它们。你将能够通过类型类来约束泛型类型参数。
- en: 'This has the potential to be powerful but somewhat confusing; I’m of two minds
    about it myself. It’s likely to require runtime changes in order to execute efficiently.
    It may take C# developers (or me, at least) a while to work out when it’s useful
    and when it’s just confusing. Adding a whole new kind of type at this stage in
    the language’s evolution feels like a giant step. For all these caveats, this
    feature definitely fills a gap: where you need this functionality, the current
    tools don’t offer any clean solutions.'
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 这有可能非常强大但有些令人困惑；我自己对此也有两种看法。它可能需要运行时更改才能高效执行。它可能需要 C# 开发者（至少是我）一段时间才能弄清楚何时有用，何时只是令人困惑。在语言发展的这个阶段添加整个新的类型感觉像是一个巨大的步骤。尽管有所有这些警告，这个特性确实填补了一个空白：当你需要这种功能时，当前的工具没有提供任何干净的解决方案。
- en: Extension everything
  id: totrans-2018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展一切
- en: 'At the time of this writing, this has a milestone of X.0 in GitHub, but I wouldn’t
    be overly surprised to see it move up the priority list. The name does a good
    job of explaining the feature: the concept of extension methods would be applied
    to other member types, such as properties, constructors, and operators. It may
    also allow static extension members to be introduced—ones that look like they’re
    static methods on the extended type. (For example, you could write a method in
    `StringExtensions` that could be called as `string.IsNullOrTabs` as a more specific
    version of `string.IsNullOrWhiteSpace`.)'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，这在 GitHub 上的里程碑为 X.0，但我不会对它被提升到优先级列表感到过分惊讶。这个名字很好地解释了该特性：扩展方法的概念将被应用于其他成员类型，例如属性、构造函数和运算符。它还可能允许引入静态扩展成员——它们看起来像是扩展类型上的静态方法。（例如，你可以在
    `StringExtensions` 中编写一个方法，可以像 `string.IsNullOrTabs` 一样调用，作为 `string.IsNullOrWhiteSpace`
    的更具体版本。）
- en: The syntax used for extension methods doesn’t lend itself to other member types,
    so it’s probable that a whole new syntax would be used instead. This might be
    an extension type that’s purely present to create multiple extension members all
    on one specific extended type.
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: 用于扩展方法的语法不适合其他成员类型，因此很可能将使用全新的语法。这可能是纯粹为了创建多个扩展成员而存在于一个特定扩展类型上的扩展类型。
- en: Extension types still wouldn’t be able to introduce new state. Any extension
    properties would be likely to present a different view of existing properties.
    For example, you could have an extension property on `DateTime` called `FinancialQuarter`
    that knew your company’s financial reporting dates and used the existing `Year`/`Month`/`Day`
    properties to compute the appropriate quarter.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展类型仍然无法引入新的状态。任何扩展属性都可能呈现现有属性的不同视图。例如，你可以在 `DateTime` 上有一个扩展属性名为 `FinancialQuarter`，它了解你公司的财务报告日期，并使用现有的
    `Year`/`Month`/`Day` 属性来计算适当的季度。
- en: Target-typed new
  id: totrans-2022
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 目标类型新
- en: 'Implicit typing with `var` can be useful for reducing clutter when long type
    names are involved. It doesn’t help for fields, though, because they can’t be
    implicitly typed. We still end up with code like this:'
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 的隐式类型可以用于在涉及长类型名时减少混乱。然而，对于字段来说，它并没有帮助，因为它们不能隐式类型化。我们最终还是得到了这样的代码：
- en: '[PRE266]'
  id: totrans-2024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'The *target-typed new* feature wouldn’t affect where you could use `var`. Instead,
    it would shorten the right-hand side of the declaration:'
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标类型的新特性* 不会影响你可以在哪里使用 `var`。相反，它会缩短声明右侧的部分：'
- en: '[PRE267]'
  id: totrans-2026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Anytime the compiler can tell which type you probably mean when calling a constructor,
    you’d be able to leave out the type name entirely. This introduces interesting
    complexity with member invocations. For example, `Method(new())` would take the
    target type from the method parameter, which is fine until `Method` is generic
    or overloaded.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候编译器可以告诉你调用构造函数时你很可能指的是哪种类型，你就可以完全省略类型名。这给成员调用引入了有趣的复杂性。例如，`Method(new())`
    会从方法参数中获取目标类型，这在 `Method` 不是泛型或重载的情况下是可以的。
- en: I love and hate this feature proposal, in roughly equal measure. It could certainly
    make code unreadable if used excessively, but almost any feature can be misused.
    On the other hand, I relish the possibility of removing the duplication of long
    field initialization.
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个特性提案又爱又恨，大约是相等的程度。如果过度使用，它确实可能会使代码难以阅读，但几乎任何特性都可能被误用。另一方面，我喜欢去除长字段初始化重复的可能性。
- en: I expect this to be even more controversial than default interface methods.
    We’ll see what happens, and you can be part of the conversation.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 我预计这会比默认接口方法更具争议性。我们将看看会发生什么，你也可以成为对话的一部分。
- en: 15.7\. Getting involved
  id: totrans-2030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.7. 参与其中
- en: 'The C# design process is more open than ever before. Although a lot of work
    goes on in the background with Language Design Meetings (LDMs) in Microsoft offices,
    there’s plenty of room for community involvement, too. The GitHub repository at
    [https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang) is
    the place to start. It contains notes from LDMs, proposals, discussions, and specifications.
    You’re welcome to engage at any of the following levels:'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的设计流程比以往任何时候都更加开放。尽管在微软办公室的编程语言设计会议（LDMs）背后有很多工作，但社区参与的空间也很大。[https://github.com/dotnet/csharplang](https://github.com/dotnet/csharplang)
    的 GitHub 仓库是开始的地方。它包含 LDMs 的笔记、提案、讨论和规范。你可以在以下任何级别参与：
- en: Trying out preview builds to see how well new features fit with your existing
    code
  id: totrans-2032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试预览版构建以查看新功能与现有代码的兼容性
- en: Discussing currently proposed features
  id: totrans-2033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论当前提出的特性
- en: Proposing new features
  id: totrans-2034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出新特性
- en: Prototyping new features in Roslyn
  id: totrans-2035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Roslyn 中原型设计新功能
- en: Helping draft language in the specification for new features
  id: totrans-2036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助起草新功能的规范
- en: Spotting mistakes in the existing specification (it happens!)
  id: totrans-2037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现有规范中找出错误（这种情况是会发生的！）
- en: You may feel it’s a better use of your time to wait for full releases with complete
    documentation and a polished implementation. That’s perfectly fine, too. It’s
    easy enough to dip your toe in the water at any time, if only to look at the set
    of proposed features for a given milestone.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得等待带有完整文档和精炼实现的完整发布版本是更好的时间利用方式。这也是完全可以接受的。任何时候都可以轻松地尝试一下，即使只是为了查看特定里程碑的提案功能集。
- en: This open design process is relatively new, and I expect it to be fine-tuned
    over time. I’d be surprised if the team ever went back to a more closed process.
    Although community engagement like this is expensive in terms of time, there are
    huge benefits in making sure the new features are ones developers really need.
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开放的设计流程相对较新，我预计它会在未来得到进一步的优化。如果团队真的回到了更加封闭的流程，我会感到惊讶。尽管这种社区参与在时间上可能很昂贵，但确保新功能是开发者真正需要的功能所带来的巨大好处是值得的。
- en: Conclusion
  id: totrans-2040
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: There’s been a lot more text than code in this chapter, mostly because I don’t
    want to present too much code that’ll be wrong by the time C# 8 ships. I doubt
    that all the features I’ve described will be present in C# 8, but I think it’s
    at least likely that some of them will be. I’d be surprised if nullable reference
    types or the pattern-related features didn’t make it into C# 8.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中文字比代码多得多，主要是因为我不想展示太多在 C# 8 发布时可能已经错误的代码。我怀疑我描述的所有功能都不会出现在 C# 8 中，但我认为至少有一些功能可能会出现。如果可空引用类型或与模式相关的功能没有进入
    C# 8，我会感到惊讶。
- en: What comes beyond that? Well, minor releases in the C# 8 line, presumably, and
    then on to C# 9\. Some of the features of C# 9 are probably already on GitHub
    as proposals, but I suspect there’ll be some that haven’t been talked about at
    all yet. I expect C# to continue to evolve to meet the needs of developers as
    the computing landscape changes.
  id: totrans-2042
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来会是什么？嗯，C# 8 线的次要版本，然后是 C# 9。C# 9 的一些特性可能已经在 GitHub 上作为提案出现，但我怀疑还有一些尚未讨论过。我预计随着计算环境的改变，C#
    将继续进化以满足开发者的需求。
