- en: Chapter 4\. Pathfinding and Graph Search Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 路径查找和图搜索算法
- en: Graph search algorithms explore a graph either for general discovery or explicit
    search. These algorithms carve paths through the graph, but there is no expectation
    that those paths are computationally optimal. We will cover Breadth First Search
    and Depth First Search because they are fundamental for traversing a graph and
    are often a required first step for many other types of analysis.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图搜索算法可以探索图的通用发现或显式搜索。这些算法通过图中开辟路径，但不期望这些路径在计算上是最优的。我们将介绍广度优先搜索和深度优先搜索，因为它们是遍历图的基础，通常是许多其他类型分析的必要第一步。
- en: Pathfinding algorithms build on top of graph search algorithms and explore routes
    between nodes, starting at one node and traversing through relationships until
    the destination has been reached. These algorithms are used to identify optimal
    routes through a graph for uses such as logistics planning, least cost call or
    IP routing, and gaming simulation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 路径查找算法基于图搜索算法构建，并通过从一个节点开始并沿着关系遍历直到达到目的地来探索节点之间的最优路线。这些算法用于识别通过图的最佳路径，例如物流规划、最少成本呼叫或IP路由以及游戏仿真。
- en: 'Specifically, the pathfinding algorithms we’ll cover are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将讨论的路径查找算法有：
- en: 'Shortest Path, with two useful variations (A* and Yen’s): finding the shortest
    path or paths between two chosen nodes'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短路径，带有两个有用的变体（A*和Yen’s）：查找两个选择节点之间的最短路径或路径
- en: 'All Pairs Shortest Path and Single Source Shortest Path: for finding the shortest
    paths between all pairs or from a chosen node to all others'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全对最短路径和单源最短路径：用于查找所有节点对之间的最短路径或从选定节点到所有其他节点的路径
- en: 'Minimum Spanning Tree: for finding a connected tree structure with the smallest
    cost for visiting all nodes from a chosen node'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小生成树：用于查找具有最小访问成本的连接树结构，从选定节点访问所有节点
- en: 'Random Walk: because it’s a useful preprocessing/sampling step for machine
    learning workflows and other graph algorithms'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机漫步：因为它是机器学习工作流程和其他图算法的有用预处理/抽样步骤
- en: In this chapter we’ll explain how these algorithms work and show examples in
    Spark and Neo4j. In cases where an algorithm is only available in one platform,
    we’ll provide just that one example or illustrate how you can customize our implementation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释这些算法的工作原理，并展示Spark和Neo4j中的示例。对于仅在一个平台上可用的算法，我们将提供一个示例或说明如何定制我们的实现。
- en: '[Figure 4-1](#pathfinding-overview-image) shows the key differences between
    these types of algorithms, and [Table 4-1](#pathfinding-overview-table) is a quick
    reference to what each algorithm computes with an example use.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-1](#pathfinding-overview-image)展示了这些算法类型之间的主要差异，而[表 4-1](#pathfinding-overview-table)则是每种算法计算内容及示例用途的快速参考。'
- en: '![gral 0401](Images/gral_0401.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0401](Images/gral_0401.png)'
- en: Figure 4-1\. Pathfinding and search algorithms
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1\. 路径查找和搜索算法
- en: Table 4-1\. Overview of pathfinding and graph search algorithms
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1\. 路径查找和图搜索算法概述
- en: '| Algorithm type | What it does | Example use | Spark example | Neo4j example
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 算法类型 | 功能 | 示例用途 | Spark示例 | Neo4j示例 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '|'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Breadth First Search](#bfs)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[广度优先搜索](#bfs)'
- en: '|'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Traverses a tree structure by fanning out to explore the nearest neighbors and
    then their sublevel neighbors
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扇形扩展以探索最近的邻居及其下一级邻居来遍历树结构
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Locating neighbor nodes in GPS systems to identify nearby places of interest
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在GPS系统中定位邻居节点，以识别附近的地点
- en: '|'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: '|'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'No'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: '|'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Depth First Search](#dfs)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[深度优先搜索](#dfs)'
- en: '|'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Traverses a tree structure by exploring as far as possible down each branch
    before backtracking
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尽可能远地探索每个分支来遍历树结构，然后回溯
- en: '|'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Discovering an optimal solution path in gaming simulations with hierarchical
    choices
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有层次选择的游戏仿真中发现最优解路径
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'No'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'No'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Shortest Path](#shortest_path)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[最短路径](#shortest_path)'
- en: 'Variations: [A*](#astar), [Yen’s](#yens)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 变体：[A*](#astar)，[Yen’s](#yens)
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Calculates the shortest path between a pair of nodes
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 计算节点对之间的最短路径
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Finding driving directions between two locations
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个位置之间寻找驾驶方向
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: '|'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[All Pairs Shortest Path](#all_pairs_shortest_paths)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[所有对最短路径](#all_pairs_shortest_paths)'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Calculates the shortest path between *all pairs of nodes* in the graph
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 计算图中*所有节点对*之间的最短路径
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Evaluating alternate routes around a traffic jam
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在交通堵塞中评估替代路径
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Single Source Shortest Path](#single_source_shortest_path)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[单源最短路径](#single_source_shortest_path)'
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Calculates the shorest path between a *single root* node and *all* other nodes
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 计算从*单个根*节点到*所有*其他节点的最短路径
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Least cost routing of phone calls
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 电话呼叫的最低成本路由
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Minimum Spanning Tree](#minimum_weight_spanning_tree)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[最小生成树](#minimum_weight_spanning_tree)'
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Calculates the path in a connected tree structure with the smallest cost for
    visiting all nodes
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 计算在连接树结构中访问所有节点的最小成本路径
- en: '|'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Optimizing connected routing, such as laying cable or garbage collection
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 优化连接路由，如布置电缆或垃圾收集
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'No'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Random Walk](#random_walk)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[随机游走](#random_walk)'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Returns a list of nodes along a path of specified size by randomly choosing
    relationships to traverse.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一条指定大小路径上的节点列表，通过随机选择关系来遍历。
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Augmenting training for machine learning or data for graph algorithms.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为机器学习或图算法的数据增强训练。
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'No'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 否
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: First we’ll take a look at the dataset for our examples and walk through how
    to import the data into Apache Spark and Neo4j. For each algorithm, we’ll start
    with a short description of the algorithm and any pertinent information on how
    it operates. Most sections also include guidance on when to use related algorithms.
    Finally, we provide working sample code using the sample dataset at the end of
    each algorithm section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看我们示例的数据集，并介绍如何将数据导入Apache Spark和Neo4j。对于每个算法，我们将从算法的简要描述和其操作方式的任何相关信息开始。大多数部分还包括何时使用相关算法的指导。最后，我们提供使用每个算法部分末尾的示例数据集的工作示例代码。
- en: Let’s get started!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'Example Data: The Transport Graph'
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例数据：运输图
- en: All connected data contains paths between nodes, which is why search and pathfinding
    are the starting points for graph analytics. Transportation datasets illustrate
    these relationships in an intuitive and accessible way. The examples in this chapter
    run against a [graph containing a subset of the European road network](http://www.elbruz.org/e-roads/).
    You can download the nodes and relationships files from the [book’s GitHub repository](https://bit.ly/2FPgGVV).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有连接的数据包含节点之间的路径，这就是为什么搜索和路径查找是图分析的起点。交通数据集以直观和易于访问的方式展示这些关系。本章的示例针对包含[欧洲道路网络子集的图](http://www.elbruz.org/e-roads/)。您可以从[书籍的GitHub仓库](https://bit.ly/2FPgGVV)下载节点和关系文件。
- en: Table 4-2\. *transport-nodes.csv*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2\. *transport-nodes.csv*
- en: '| id | latitude | longitude | population |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| id | 纬度 | 经度 | 人口 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Amsterdam | 52.379189 | 4.899431 | 821752 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | 52.379189 | 4.899431 | 821752 |'
- en: '| Utrecht | 52.092876 | 5.104480 | 334176 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 乌得勒支 | 52.092876 | 5.104480 | 334176 |'
- en: '| Den Haag | 52.078663 | 4.288788 | 514861 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 海牙 | 52.078663 | 4.288788 | 514861 |'
- en: '| Immingham | 53.61239 | -0.22219 | 9642 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 伊明厄姆 | 53.61239 | -0.22219 | 9642 |'
- en: '| Doncaster | 53.52285 | -1.13116 | 302400 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 | 53.52285 | -1.13116 | 302400 |'
- en: '| Hoek van Holland | 51.9775 | 4.13333 | 9382 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 霍克范霍兰 | 51.9775 | 4.13333 | 9382 |'
- en: '| Felixstowe | 51.96375 | 1.3511 | 23689 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 费利克斯托 | 51.96375 | 1.3511 | 23689 |'
- en: '| Ipswich | 52.05917 | 1.15545 | 133384 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 52.05917 | 1.15545 | 133384 |'
- en: '| Colchester | 51.88921 | 0.90421 | 104390 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 51.88921 | 0.90421 | 104390 |'
- en: '| London | 51.509865 | -0.118092 | 8787892 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 51.509865 | -0.118092 | 8787892 |'
- en: '| Rotterdam | 51.9225 | 4.47917 | 623652 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 鹿特丹 | 51.9225 | 4.47917 | 623652 |'
- en: '| Gouda | 52.01667 | 4.70833 | 70939 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 古达 | 52.01667 | 4.70833 | 70939 |'
- en: Table 4-3\. *transport-relationships.csv*
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-3\. *transport-relationships.csv*
- en: '| src | dst | relationship | cost |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| src | dst | relationship | cost |'
- en: '| --- | --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Amsterdam | Utrecht | EROAD | 46 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | 乌得勒支 | EROAD | 46 |'
- en: '| Amsterdam | Den Haag | EROAD | 59 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | 海牙 | EROAD | 59 |'
- en: '| Den Haag | Rotterdam | EROAD | 26 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 海牙 | 鹿特丹 | EROAD | 26 |'
- en: '| Amsterdam | Immingham | EROAD | 369 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | 伊明厄姆 | EROAD | 369 |'
- en: '| Immingham | Doncaster | EROAD | 74 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 伊明厄姆 | 唐卡斯特 | EROAD | 74 |'
- en: '| Doncaster | London | EROAD | 277 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 | 伦敦 | EROAD | 277 |'
- en: '| Hoek van Holland | Den Haag | EROAD | 27 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 霍克范霍兰 | 海牙 | EROAD | 27 |'
- en: '| Felixstowe | Hoek van Holland | EROAD | 207 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 费利克斯托 | 霍克范霍兰 | EROAD | 207 |'
- en: '| Ipswich | Felixstowe | EROAD | 22 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 费利克斯托 | EROAD | 22 |'
- en: '| Colchester | Ipswich | EROAD | 32 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 伊普斯维奇 | EROAD | 32 |'
- en: '| London | Colchester | EROAD | 106 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 科尔切斯特 | EROAD | 106 |'
- en: '| Gouda | Rotterdam | EROAD | 25 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 古达 | 鹿特丹 | EROAD | 25 |'
- en: '| Gouda | Utrecht | EROAD | 35 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 古达 | 乌得勒支 | EROAD | 35 |'
- en: '| Den Haag | Gouda | EROAD | 32 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 海牙 | 古达 | EROAD | 32 |'
- en: '| Hoek van Holland | Rotterdam | EROAD | 33 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 霍克范霍兰 | 鹿特丹 | EROAD | 33 |'
- en: '[Figure 4-2](#transport-graph-image) shows the target graph that we want to
    construct.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](#transport-graph-image)显示了我们想要构建的目标图。'
- en: '![gral 0402](Images/gral_0402.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 0402](Images/gral_0402.png)'
- en: Figure 4-2\. The transport graph
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 运输图
- en: 'For simplicity we consider the graph in [Figure 4-2](#transport-graph-image)
    to be undirected because most roads between cities are bidirectional. We’d get
    slightly different results if we evaluated the graph as directed because of the
    small number of one-way streets, but the overall approach remains similar. However,
    both Spark and Neo4j operate on directed graphs. In cases like this where we want
    to work with undirected graphs (e.g., bidirectional roads), there is an easy way
    to accomplish that:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们考虑[图 4-2](#transport-graph-image)中的图为无向图，因为大多数城市之间的道路都是双向的。如果我们将图视为有向图，由于少量单向街道的存在，结果会略有不同，但总体方法保持相似。然而，Spark和Neo4j都是基于有向图操作的。在像这样希望处理无向图（例如双向道路）的情况下，有一种简单的方法可以实现：
- en: For Spark, we’ll create two relationships for each row in *transport-relationships.csv*—one
    going from `dst` to `src` and one from `src` to `dst`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Spark，我们将为*transport-relationships.csv*中的每一行创建两个关系——一个从`dst`到`src`，另一个从`src`到`dst`。
- en: For Neo4j, we’ll create a single relationship and then ignore the relationship
    direction when we run the algorithms.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Neo4j，我们将创建单个关系，然后在运行算法时忽略关系的方向。
- en: Having understood those little modeling workarounds, we can now get on with
    loading graphs into Spark and Neo4j from the example CSV files.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了这些小建模技巧后，我们现在可以从示例CSV文件中加载图到Spark和Neo4j中。
- en: Importing the Data into Apache Spark
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据导入Apache Spark
- en: 'Starting with Spark, we’ll first import the packages we need from Spark and
    the GraphFrames package:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spark开始，我们首先从Spark和GraphFrames包中导入我们需要的包：
- en: '[PRE0]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following function creates a GraphFrame from the example CSV files:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数从示例CSV文件创建一个GraphFrame：
- en: '[PRE1]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Loading the nodes is easy, but for the relationships we need to do a little
    preprocessing so that we can create each relationship twice.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 加载节点很简单，但是对于关系，我们需要进行一些预处理，以便能够创建每个关系两次。
- en: 'Now let’s call that function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用那个函数：
- en: '[PRE2]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Importing the Data into Neo4j
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据导入Neo4j
- en: 'Now for Neo4j. We’ll start by loading the nodes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是Neo4j的时候了。我们将首先加载节点：
- en: '[PRE3]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now the relationships:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是关系的时候了：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although we’re storing directed relationships, we’ll ignore the direction when
    we execute algorithms later in the chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们存储了有向关系，但是在本章后续执行算法时，我们会忽略方向。
- en: Breadth First Search
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: Breadth First Search (BFS) is one of the fundamental graph traversal algorithms.
    It starts from a chosen node and explores all of its neighbors at one hop away
    before visiting all the neighbors at two hops away, and so on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）是基础图遍历算法之一。它从选择的节点开始，先探索所有一跳可达的邻居节点，然后再访问所有两跳可达的邻居节点，以此类推。
- en: The algorithm was first published in 1959 by Edward F. Moore, who used it to
    find the shortest path out of a maze. It was then developed into a wire routing
    algorithm by C. Y. Lee in 1961, as described in [“An Algorithm for Path Connections
    and Its Applications”](https://bit.ly/2U1jucF).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法最早由Edward F. Moore在1959年发表，他用它来找出迷宫中的最短路径。后来，C. Y. Lee将其发展为一种电路布线算法，如[“路径连接算法及其应用”](https://bit.ly/2U1jucF)中描述的那样。
- en: BFS is most commonly used as the basis for other more goal-oriented algorithms.
    For example, [Shortest Path](#shortest_path), [Connected Components](ch06.xhtml#weakly_connected_components),
    and [Closeness Centrality](ch05.xhtml#closeness_centrality) all use the BFS algorithm.
    It can also be used to find the shortest path between nodes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: BFS最常用作其他更目标导向算法的基础。例如，[最短路径](#shortest_path)，[连通分量](ch06.xhtml#weakly_connected_components)，以及[接近中心性](ch05.xhtml#closeness_centrality)都使用BFS算法。它还可以用于查找节点之间的最短路径。
- en: '[Figure 4-3](#den-haag-breadth-first-image) shows the order in which we would
    visit the nodes of our transport graph if we were performing a breadth first search
    that started from the Dutch city, Den Haag (in English, The Hague). The numbers
    next to the city name indicate the order in which each node is visited.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](#den-haag-breadth-first-image)显示了如果从荷兰城市海牙（英文名为The Hague）开始执行广度优先搜索，我们将访问我们的运输图节点的顺序。城市名称旁边的数字表示每个节点访问的顺序。'
- en: '![gral 0403](Images/gral_0403.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 0403](Images/gral_0403.png)'
- en: Figure 4-3\. Breadth First Search starting from Den Haag. Node numbers indicate
    the order traversed.
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 从海牙开始的广度优先搜索。节点数字表示访问顺序。
- en: We first visit all of Den Haag’s direct neighbors, before visiting their neighbors,
    and their neighbors’ neighbors, until we’ve run out of relationships to traverse.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先访问所有海牙的直接邻居，然后访问它们的邻居及其邻居的邻居，直到我们没有关系可遍历为止。
- en: Breadth First Search with Apache Spark
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apache Spark的广度优先搜索
- en: Spark’s implementation of the Breadth First Search algorithm finds the shortest
    path between two nodes by the number of relationships (i.e., hops) between them.
    You can explicitly name your target node or add criteria to be met.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Spark的广度优先搜索算法实现通过它们之间的关系数（即跳数）找到两个节点之间的最短路径。您可以明确命名目标节点或添加要满足的条件。
- en: 'For example, we can use the `bfs` function to find the first medium-sized (by
    European standards) city that has a population of between 100,000 and 300,000
    people. Let’s first check which places have a population matching those criteria:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`bfs`函数找到第一个中等规模（按欧洲标准）的城市，其人口介于10万到30万之间。让我们首先检查哪些地方的人口符合这些标准：
- en: '[PRE5]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the output we’ll see:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将看到的输出：
- en: '| id | latitude | longitude | population |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| id | 纬度 | 经度 | 人口 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Colchester | 51.88921 | 0.90421 | 104390 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 51.88921 | 0.90421 | 104390 |'
- en: '| Ipswich | 52.05917 | 1.15545 | 133384 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 52.05917 | 1.15545 | 133384 |'
- en: There are only two places matching our criteria, and we’d expect to reach Ipswich
    first based on a breadth first search.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据广度优先搜索，只有两个符合我们条件的地方，我们预计首先到达伊普斯维奇（Ipswich）。
- en: 'The following code finds the shortest path from Den Haag to a medium-sized
    city:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码找到从海牙到一个中等规模城市的最短路径：
- en: '[PRE6]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`result` contains columns that describe the nodes and relationships between
    the two cities. We can run the following code to see the list of columns returned:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`result`包含描述两个城市之间节点和关系的列。我们可以运行以下代码来查看返回的列列表：'
- en: '[PRE7]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is the output we’ll see:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将看到的输出：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Columns beginning with `e` represent relationships (edges) and columns beginning
    with `v` represent nodes (vertices). We’re only interested in the nodes, so let’s
    filter out any columns that begin with `e` from the resulting DataFrame:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以`e`开头的列代表关系（边），以`v`开头的列代表节点（顶点）。我们只对节点感兴趣，所以让我们从结果DataFrame中过滤掉任何以`e`开头的列：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we run the code in pyspark we’ll see this output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在pyspark中运行此代码，我们将看到以下输出：
- en: '| from | v1 | v2 | to |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| from | v1 | v2 | to |'
- en: '| --- | --- | --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| [Den Haag, 52.078… | [Hoek van Holland… | [Felixstowe, 51.9… | [Ipswich,
    52.0591… |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| [海牙, 52.078… | [荷克·范·荷兰… | [费利克斯托… | [伊普斯维奇… |'
- en: As expected, the `bfs` algorithm returns Ipswich! Remember that this function
    is satisfied when it finds the first match, and as you can see in [Figure 4-3](#den-haag-breadth-first-image),
    Ipswich is evaluated before Colchester.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`bfs`算法返回了伊普斯维奇！请记住，此函数在找到第一个匹配时满足条件，正如您在[图 4-3](#den-haag-breadth-first-image)中所看到的，伊普斯维奇在科尔切斯特之前评估。
- en: Depth First Search
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: Depth First Search (DFS) is the other fundamental graph traversal algorithm.
    It starts from a chosen node, picks one of its neighbors, and then traverses as
    far as it can along that path before backtracking.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索（DFS）是另一种基本的图遍历算法。它从一个选择的节点开始，选择其邻居之一，然后沿着该路径尽可能远地遍历，然后回溯。
- en: DFS was originally invented by French mathematician Charles Pierre Trémaux as
    a strategy for solving mazes. It provides a useful tool to simulate possible paths
    for scenario modeling.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: DFS最初是由法国数学家查尔斯·皮埃尔·特雷莫发明的，作为解决迷宫的一种策略。它为情景建模提供了一个有用的工具，用来模拟可能的路径。
- en: '[Figure 4-4](#den-haag-depth-first-image) shows the order in which we would
    visit the nodes of our transport graph if we were performing a DFS that started
    from Den Haag.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-4](#den-haag-depth-first-image)显示了如果从海牙开始执行DFS，我们将访问传输图的节点的顺序。'
- en: '![gral 0404](Images/gral_0404.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0404](Images/gral_0404.png)'
- en: Figure 4-4\. Depth First Search starting from Den Haag. Node numbers indicate
    the order traversed.
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 从海牙开始的深度优先搜索。节点编号指示遍历顺序。
- en: Notice how different the node order is compared to BFS. For this DFS, we start
    by traversing from Den Haag to Amsterdam, and are then able to get to every other
    node in the graph without needing to backtrack at all!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意相比于BFS，节点顺序有多不同。对于DFS，我们从海牙（Den Haag）开始遍历，然后能够到达图中的每个其他节点，而无需回溯！
- en: We can see how search algorithms lay the groundwork for moving through graphs.
    Now let’s look at the pathfinding algorithms that find the cheapest path in terms
    of the number of hops or weight. Weights can be anything measured, such as time,
    distance, capacity, or cost.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到搜索算法为在图中移动奠定了基础。现在让我们看看路径查找算法，它们以跳数或权重的角度找到最便宜的路径。权重可以是任何度量，例如时间、距离、容量或成本。
- en: Shortest Path
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最短路径
- en: The Shortest Path algorithm calculates the shortest (weighted) path between
    a pair of nodes. It’s useful for user interactions and dynamic workflows because
    it works in real time.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径算法计算一对节点之间的最短（加权）路径。它对用户交互和动态工作流程很有用，因为它实时工作。
- en: Pathfinding has a history dating back to the 19th century and is considered
    to be a classic graph problem. It gained prominence in the early 1950s in the
    context of alternate routing; that is, finding the second-shortest route if the
    shortest route is blocked. In 1956, Edsger Dijkstra created the best-known of
    these algorithms.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 路径查找的历史可以追溯到19世纪，并被认为是一个经典的图问题。在早期的1950年代，它在备用路由的背景下开始引起关注；即，如果最短路径被阻塞，找到次短路径。在1956年，Edsger
    Dijkstra创建了这些算法中最著名的算法。
- en: Dijkstra’s Shortest Path algorithm operates by first finding the lowest-weight
    relationship from the start node to directly connected nodes. It keeps track of
    those weights and moves to the “closest” node. It then performs the same calculation,
    but now as a cumulative total from the start node. The algorithm continues to
    do this, evaluating a “wave” of cumulative weights and always choosing the lowest
    weighted cumulative path to advance along, until it reaches the destination node.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra的最短路径算法首先通过找到从起始节点到直接相连节点的最低权重关系来运行。它跟踪这些权重，并移动到“最近”的节点。然后它执行相同的计算，但现在作为从起始节点到目前节点的累积总和。该算法继续这样做，评估一系列累积权重，并始终选择最低加权累积路径前进，直到到达目标节点。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll notice in graph analytics the use of the terms *weight*, *cost*, *distance*,
    and *hop* when describing relationships and paths. “Weight” is the numeric value
    of a particular property of a relationship. “Cost” is used similarly, but we’ll
    see it more often when considering the total weight of a path.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在图分析中，当描述关系和路径时会使用诸如*权重*、*成本*、*距离*和*跳*这样的术语。 “权重”是关系特性的数值值。“成本”类似地使用，但在考虑路径的总权重时我们会更频繁地看到它。
- en: “Distance” is often used within an algorithm as the name of the relationship
    property that indicates the cost of traversing between a pair of nodes. It’s not
    required that this be an actual physical measure of distance. “Hop” is commonly
    used to express the number of relationships between two nodes. You may see some
    of these terms combined, as in “It’s a five-hop distance to London” or “That’s
    the lowest cost for the distance.”
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: “距离”经常在算法中用作指示横越一对节点的成本的关系属性的名称。这并不要求这是实际的物理距离度量。“跳”通常用来表示两个节点之间的关系数量。你可能会看到这些术语组合在一起，比如“到伦敦的距离是五跳”或“那是距离的最低成本”。
- en: When Should I Use Shortest Path?
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用最短路径？
- en: Use Shortest Path to find optimal routes between a pair of nodes, based on either
    the number of hops or any weighted relationship value. For example, it can provide
    real-time answers about degrees of separation, the shortest distance between points,
    or the least expensive route. You can also use this algorithm to simply explore
    the connections between particular nodes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最短路径来在一对节点之间找到基于跳数或任何加权关系值的最佳路径。例如，它可以提供与度数分离有关的实时答案、点之间的最短距离或最便宜路径。你也可以使用这种算法来简单地探索特定节点之间的连接。
- en: 'Example use cases include:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例子的使用情况包括：
- en: Finding directions between locations. Web-mapping tools such as Google Maps
    use the Shortest Path algorithm, or a close variant, to provide driving directions.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地点之间找到方向。Web地图工具如Google地图使用最短路径算法或类似算法来提供驾驶方向。
- en: Finding the degrees of separation between people in social networks. For example,
    when you view someone’s profile on LinkedIn, it will indicate how many people
    separate you in the graph, as well as listing your mutual connections.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在社交网络中查找人与人之间的联系度。例如，当你在LinkedIn上查看某人的个人资料时，它会指示您在图表中与该人相隔多少人，并列出您共同的连接。
- en: Finding the number of degrees of separation between an actor and Kevin Bacon
    based on the movies they’ve appeared in (the *Bacon Number*). An example of this
    can be seen on the [Oracle of Bacon website](https://oracleofbacon.org). [The
    Erdös Number Project](https://www.oakland.edu/enp) provides a similar graph analysis
    based on collaboration with Paul Erdös, one of the most prolific mathematicians
    of the twentieth century.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据演员和凯文·培根出演电影的情况找到两者之间的分离度（*培根数*）。可以在[培根数网站](https://oracleofbacon.org)上看到一个例子。[厄尔德什数项目](https://www.oakland.edu/enp)基于与保罗·厄尔德什合作的合作关系提供了类似的图分析，他是二十世纪最多产的数学家之一。
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Dijkstra’s algorithm does not support negative weights. The algorithm assumes
    that adding a relationship to a path can never make a path shorter—an invariant
    that would be violated with negative weights.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法不支持负权重。该算法假定向路径添加关系永远不会使路径变短——这是一个不变量，如果出现负权重将会违反这一假设。
- en: Shortest Path with Neo4j
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Neo4j中的最短路径
- en: The Neo4j Graph Algorithms library has a built-in procedure that we can use
    to compute both unweighted and weighted shortest paths. Let’s first learn how
    to compute unweighted shortest paths.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j图算法库中有一个内置过程，我们可以用来计算无权和加权最短路径。让我们首先学习如何计算无权最短路径。
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'All of Neo4j’s Shortest Path algorithms assume that the underlying graph is
    undirected. You can override this by passing in the parameter `direction: "OUTGOING"`
    or `direction: "INCOMING"`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '所有Neo4j的最短路径算法都假定底层图是无向的。您可以通过传递参数 `direction: "OUTGOING"` 或 `direction: "INCOMING"`
    来覆盖此设置。'
- en: 'To have Neo4j’s Shortest Path algorithm ignore weights we need to pass `null`
    as the third parameter to the procedure, which indicates that we don’t want to
    consider a weight property when executing the algorithm. The algorithm will then
    assume a default weight of `1.0` for each relationship:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要使Neo4j的最短路径算法忽略权重，我们需要将`null`作为该过程的第三个参数传递，这表示我们在执行算法时不考虑权重属性。算法将假定每个关系的默认权重为`1.0`：
- en: '[PRE10]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This query returns the following output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询返回以下输出：
- en: '| place | cost |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 地点 | 费用 |'
- en: '| --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Amsterdam | 0.0 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | 0.0 |'
- en: '| Immingham | 1.0 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 伊明厄姆 | 1.0 |'
- en: '| Doncaster | 2.0 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 | 2.0 |'
- en: '| London | 3.0 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 3.0 |'
- en: Here the cost is the cumulative total for relationships (or hops). This is the
    same path as we see using Breadth First Search in Spark.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的成本是关系（或跳数）的累计总数。这与在Spark中使用广度优先搜索看到的路径相同。
- en: 'We could even work out the total distance of following this path by writing
    a bit of postprocessing Cypher. The following procedure calculates the shortest
    unweighted path and then works out what the actual cost of that path would be:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写一些后处理Cypher代码，我们甚至可以计算沿着这条路径的总距离。以下过程计算最短无权路径，然后计算该路径的实际成本：
- en: '[PRE11]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the previous code feels a bit unwieldy, notice that the tricky part is figuring
    out how to massage the data to include the cost over the whole journey. This is
    helpful to keep in mind when we need the cumulative path cost.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的代码感觉有点笨拙，请注意，最棘手的部分是如何调整数据以包括整个旅程的成本。当我们需要累积路径成本时，这是有帮助的思路。
- en: 'The query returns the following result:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回以下结果：
- en: '| place | cost |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 地点 | 费用 |'
- en: '| --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Amsterdam | 0.0 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | 0.0 |'
- en: '| Immingham | 369.0 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 伊明厄姆 | 369.0 |'
- en: '| Doncaster | 443.0 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 | 443.0 |'
- en: '| London | 720.0 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 720.0 |'
- en: '[Figure 4-6](#amsterdam-london-image) shows the unweighted shortest path from
    Amsterdam to London, routing us through the fewest number of cities. It has a
    total cost of 720 km.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-6](#amsterdam-london-image)显示了从阿姆斯特丹到伦敦的无权最短路径，通过尽可能少的城市进行路由。总距离为720公里。'
- en: '![gral 0406](Images/gral_0406.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0406](Images/gral_0406.png)'
- en: Figure 4-6\. The unweighted shortest path between Amsterdam and London
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-6\. 阿姆斯特丹到伦敦之间的无权最短路径
- en: Choosing a route with the fewest number of nodes visited might be very useful
    in situations such as subway systems, where less stops are highly desirable. However,
    in a driving scenario, we’re probably more interested in the total cost using
    the shortest weighted path.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择节点访问最少的路径时可能非常有用，比如地铁系统中，尽量减少停靠站点是非常理想的。然而，在驾驶场景中，我们可能更关心使用最短加权路径的总成本。
- en: Shortest Path (Weighted) with Neo4j
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带权最短路径与Neo4j
- en: 'We can execute the Weighted Shortest Path algorithm to find the shortest path
    between Amsterdam and London like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行带权最短路径算法来找到阿姆斯特丹和伦敦之间的最短路径，如下所示：
- en: '[PRE12]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The parameters passed to this algorithm are:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给该算法的参数是：
- en: '`source`'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`'
- en: The node where our shortest path search begins
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最短路径搜索起始节点
- en: '`destination`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`destination`'
- en: The node where our shortest path ends
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最短路径终止节点
- en: '`distance`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance`'
- en: The name of the relationship property that indicates the cost of traversing
    between a pair of nodes
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表示两个节点之间遍历成本的关系属性名称
- en: 'The cost is the number of kilometers between two locations. The query returns
    the following result:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 成本是两个位置之间的公里数。查询返回以下结果：
- en: '| place | cost |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 地点 | 成本 |'
- en: '| --- | --- |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Amsterdam | 0.0 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| Amsterdam | 0.0 |'
- en: '| Den Haag | 59.0 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| Den Haag | 59.0 |'
- en: '| Hoek van Holland | 86.0 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| Hoek van Holland | 86.0 |'
- en: '| Felixstowe | 293.0 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| Felixstowe | 293.0 |'
- en: '| Ipswich | 315.0 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| Ipswich | 315.0 |'
- en: '| Colchester | 347.0 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| Colchester | 347.0 |'
- en: '| London | 453.0 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| London | 453.0 |'
- en: The quickest route takes us via Den Haag, Hoek van Holland, Felixstowe, Ipswich,
    and Colchester! The cost shown is the cumulative total as we progress through
    the cities. First we go from Amsterdam to Den Haag, at a cost of 59. Then we go
    from Den Haag to Hoek van Holland, at a cumulative cost of 86—and so on. Finally,
    we arrive in London, from Colchester, for a total cost of 453 km.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最快的路线经过 Den Haag、Hoek van Holland、Felixstowe、Ipswich 和 Colchester！所示成本是随着我们通过城市的进展而累积的总成本。首先，我们从
    Amsterdam 到 Den Haag，成本为 59。然后，我们从 Den Haag 到 Hoek van Holland，累积成本为 86，依此类推。最后，我们从
    Colchester 到 London，总成本为 453 公里。
- en: Remember that the unweighted shortest path had a total cost of 720 km, so we’ve
    been able to save 267 km by taking weights into account when computing the shortest
    path.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，无权重最短路径的总成本为 720 公里，因此在计算最短路径时考虑权重后，我们已经节省了 267 公里。
- en: Shortest Path (Weighted) with Apache Spark
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Apache Spark 进行加权最短路径
- en: In the [Breadth First Search with Apache Spark](#bfs-spark) section we learned
    how to find the shortest path between two nodes. That shortest path was based
    on hops and therefore isn’t the same as the shortest *weighted* path, which would
    tell us the shortest total distance between cities.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用 Apache Spark 进行广度优先搜索](#bfs-spark) 部分，我们学习了如何找到两个节点之间的最短路径。那个最短路径基于跳数，因此不同于最短*加权*路径，后者告诉我们城市之间的最短总距离。
- en: If we want to find the shortest weighted path (in this case, distance) we need
    to use the `cost` property, which is used for various types of weighting. This
    option is not available out of the box with GraphFrames, so we need to write our
    own version of Weighted Shortest Path using its [`aggregateMessages` framework](https://bit.ly/2JCFBRJ).
    Most of our algorithm examples for Spark use the simpler process of calling on
    algorithms from the library, but we have the option of writing our own functions.
    More information on `aggregateMessages` can be found in the [“Message passing
    via AggregateMessages”](http://bit.ly/2Wo6Hxg) section of the GraphFrames user
    guide.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要找到最短加权路径（在本例中为距离），我们需要使用 `cost` 属性，该属性用于各种加权类型。GraphFrames 并没有直接提供此选项，因此我们需要编写自己版本的加权最短路径，利用其
    [`aggregateMessages` 框架](https://bit.ly/2JCFBRJ)。我们大多数的 Spark 算法示例使用库中的简单过程调用，但我们可以选择编写自己的函数。有关
    `aggregateMessages` 的更多信息，请参见 GraphFrames 用户指南中的 [“通过 AggregateMessages 进行消息传递”](http://bit.ly/2Wo6Hxg)
    部分。
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When available, we recommend leveraging preexisting, tested libraries. Writing
    our own functions, especially for more complicated algorithms, requires a deeper
    understanding of our data and calculations.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在可用时，我们建议利用现有的、经过测试的库。编写自己的函数，尤其是更复杂的算法，需要对数据和计算有更深入的理解。
- en: The following example should be treated as a reference implementation, and would
    need to be optimized before running on a larger dataset. Those that aren’t interested
    in writing their own functions can skip this example.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例应视为参考实现，运行在更大数据集上之前需要进行优化。对于不希望编写自己函数的人可以跳过此示例。
- en: 'Before we create our function, we’ll import some libraries that we’ll use:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数之前，我们将导入一些将要使用的库：
- en: '[PRE13]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Aggregate_Messages` module is part of the GraphFrames library and contains
    some useful helper functions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregate_Messages` 模块是 GraphFrames 库的一部分，包含一些有用的辅助函数。'
- en: 'Now let’s write our function. We first create a user-defined function that
    we’ll use to build the paths between our source and destination:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写我们的函数。首先，我们创建一个用户定义的函数，用于构建源和目标之间的路径：
- en: '[PRE14]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And now for the main function, which calculates the shortest path starting
    from an origin and returns as soon as the destination has been visited:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是主要函数，它从起始点开始计算最短路径，并在访问目的地后返回：
- en: '[PRE15]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Warning
  id: totrans-268
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If we store references to any DataFrames in our functions, we need to cache
    them using the `AM.getCachedDataFrame` function or we’ll encounter a memory leak
    during execution. In the `shortest_path` function we use this function to cache
    the `vertices` and `new_vertices` DataFrames.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在函数中存储任何DataFrame的引用，我们需要使用`AM.getCachedDataFrame`函数对其进行缓存，否则在执行过程中可能会遇到内存泄漏问题。在`shortest_path`函数中，我们使用这个函数来缓存`vertices`和`new_vertices`的DataFrames。
- en: 'If we wanted to find the shortest path between Amsterdam and Colchester we
    could call that function like so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想找到阿姆斯特丹和科尔切斯特之间的最短路径，我们可以这样调用该函数：
- en: '[PRE16]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'which would return the following result:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下结果：
- en: '| id | distance | path |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| id | distance | path |'
- en: '| --- | --- | --- |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Colchester | 347.0 | [Amsterdam, Den Haag, Hoek van Holland, Felixstowe,
    Ipswich, Colchester] |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 347.0 | [阿姆斯特丹，海牙，胡克范荷兰，费利克斯托，伊普斯维奇，科尔切斯特] |'
- en: The total distance of the shortest path between Amsterdam and Colchester is
    347 km and takes us via Den Haag, Hoek van Holland, Felixstowe, and Ipswich. By
    contrast, the shortest path in terms of number of relationships between the locations,
    which we worked out with the [Breadth First Search algorithm](#bfs) (refer back
    to [Figure 4-4](#den-haag-depth-first-image)), would take us via Immingham, Doncaster,
    and London.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 从阿姆斯特丹到科尔切斯特的最短路径总距离为347公里，经过海牙，胡克范荷兰，费利克斯托和伊普斯维奇。相比之下，根据地点之间关系数量计算的最短路径，我们使用了[Breadth
    First Search算法](#bfs)（参见[图 4-4](#den-haag-depth-first-image)），会经过英格兰的伊明厄姆，唐卡斯特和伦敦。
- en: 'Shortest Path Variation: A*'
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最短路径变体：A*
- en: The A* Shortest Path algorithm improves on Dijkstra’s by finding shortest paths
    more quickly. It does this by allowing the inclusion of extra information that
    the algorithm can use, as part of a heuristic function, when determining which
    paths to explore next.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: A*最短路径算法通过允许包含额外信息，作为启发式函数的一部分，更快地找到最短路径，改进了Dijkstra算法。
- en: The algorithm was invented by Peter Hart, Nils Nilsson, and Bertram Raphael
    and described in their 1968 paper [“A Formal Basis for the Heuristic Determination
    of Minimum Cost Paths”](https://bit.ly/2JAaV3s).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法由彼得·哈特，尼尔斯·尼尔森和伯特拉姆·拉斐尔发明，并在他们1968年的论文[“启发式确定最小成本路径的形式基础”](https://bit.ly/2JAaV3s)中描述。
- en: The A* algorithm operates by determining which of its partial paths to expand
    at each iteration of its main loop. It does so based on an estimate of the cost
    (heuristic) still left to reach the goal node.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: A*算法通过在其主循环的每次迭代中确定要扩展的部分路径来操作。它基于到达目标节点仍然需要的成本估计（启发式）。
- en: Warning
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be thoughtful in the heuristic employed to estimate path costs. Underestimating
    path costs may unnecessarily include some paths that could have been eliminated,
    but the results will still be accurate. However, if the heuristic overestimates
    path costs, it may skip over actual shorter paths (incorrectly estimated to be
    longer) that should have been evaluated, which can lead to inaccurate results.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑估算路径成本的启发式函数。低估路径成本可能会不必要地包含一些本可以被排除的路径，但结果仍然准确。然而，如果启发式函数高估路径成本，则可能会跳过实际上更短的路径（错误地估计为更长的路径），这会导致不准确的结果。
- en: 'A* selects the path that minimizes the following function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: A*选择最小化以下函数的路径：
- en: '[PRE17]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'where:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'where:'
- en: '`g(n)` is the cost of the path from the starting point to node `n`.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g(n)`是从起点到节点`n`的路径成本。'
- en: '`h(n)` is the estimated cost of the path from node `n` to the destination node,
    as computed by a heuristic.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h(n)`是从节点`n`到目标节点的路径的预估成本，由启发式函数计算。'
- en: Note
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Neo4j’s implementation, geospatial distance is used as the heuristic. In
    our example transportation dataset we use the latitude and longitude of each location
    as part of the heuristic function.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在Neo4j的实现中，地理空间距离被用作启发式函数的一部分。在我们的示例运输数据集中，我们使用每个位置的纬度和经度作为启发式函数的一部分。
- en: A* with Neo4j
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Neo4j的A*
- en: 'The following query executes the A* algorithm to find the shortest path between
    Den Haag and London:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询执行A*算法以找到阿姆斯特丹和伦敦之间的最短路径：
- en: '[PRE18]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The parameters passed to this algorithm are:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此算法的参数是：
- en: '`source`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`'
- en: The node where our shortest path search begins.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最短路径搜索开始的节点。
- en: '`destination`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`destination`'
- en: The node where our shortest path search ends.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最短路径搜索结束的节点。
- en: '`distance`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance`'
- en: The name of the relationship property that indicates the cost of traversing
    between a pair of nodes. The cost is the number of kilometers between two locations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 指示两个节点之间遍历成本的关系属性名称。成本是两个位置之间的公里数。
- en: '`latitude`'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`纬度`'
- en: The name of the node property used to represent the latitude of each node as
    part of the geospatial heuristic calculation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示每个节点纬度的节点属性名称，作为地理空间启发式计算的一部分。
- en: '`longitude`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`经度`'
- en: The name of the node property used to represent the longitude of each node as
    part of the geospatial heuristic calculation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示每个节点经度的节点属性名称，作为地理空间启发式计算的一部分。
- en: 'Running this procedure gives the following result:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此过程将得到以下结果：
- en: '| place | cost |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 地点 | 成本 |'
- en: '| --- | --- |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Den Haag | 0.0 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 海牙 | 0.0 |'
- en: '| Hoek van Holland | 27.0 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 霍克范荷兰 | 27.0 |'
- en: '| Felixstowe | 234.0 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 费利克斯托 | 234.0 |'
- en: '| Ipswich | 256.0 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 256.0 |'
- en: '| Colchester | 288.0 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 288.0 |'
- en: '| London | 394.0 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 394.0 |'
- en: We’d get the same result using the Shortest Path algorithm, but on more complex
    datasets the A* algorithm will be faster as it evaluates fewer paths.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的数据集上，A* 算法会比最短路径算法更快，因为它评估的路径更少。
- en: 'Shortest Path Variation: Yen’s k-Shortest Paths'
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最短路径变体：Yen 的 k 最短路径
- en: Yen’s *k*-Shortest Paths algorithm is similar to the Shortest Path algorithm,
    but rather than finding just the shortest path between two pairs of nodes, it
    also calculates the second shortest path, third shortest path, and so on up to
    *k*-1 deviations of shortest paths.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Yen 的 *k* 最短路径算法类似于最短路径算法，但不仅仅是找到两个节点之间的最短路径，还计算第二短路径、第三短路径等，直到第 *k*-1 短路径。
- en: Jin Y. Yen invented the algorithm in 1971 and described it in [“Finding the
    *K* Shortest Loopless Paths in a Network”](https://bit.ly/2HS0eXB). This algorithm
    is useful for getting alternative paths when finding the absolute shortest path
    isn’t our only goal. It can be particularly helpful when we need more than one
    backup plan!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 金·Y·延于 1971 年发明了该算法，并在[“在网络中找到 *K* 个最短非循环路径”](https://bit.ly/2HS0eXB)中描述了它。当我们不仅仅需要找到绝对最短路径时，此算法非常有用，特别是当我们需要多个备用方案时！
- en: Yen’s with Neo4j
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 Neo4j 的 Yen 算法
- en: 'The following query executes Yen’s algorithm to find the shortest paths between
    Gouda and Felixstowe:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询执行 Yen 算法来找到古达和费利克斯托之间的最短路径：
- en: '[PRE19]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The parameters passed to this algorithm are:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给此算法的参数包括：
- en: '`start`'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`'
- en: The node where our shortest path search begins.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最短路径搜索开始的节点。
- en: '`end`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`end`'
- en: The node where our shortest path search ends.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最短路径搜索结束的节点。
- en: '`5`'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`5`'
- en: The maximum number of shortest paths to find.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到的最大最短路径数量。
- en: '`distance`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`距离`'
- en: The name of the relationship property that indicates the cost of traversing
    between a pair of nodes. The cost is the number of kilometers between two locations.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 表示两个位置之间遍历成本的关系属性名称。成本是两个位置之间的公里数。
- en: After we get back the shortest paths we look up the associated node for each
    node ID, and then we filter out the start and end nodes from the collection.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们获得最短路径后，我们查找每个节点 ID 的关联节点，然后从集合中过滤出起点和终点节点。
- en: 'Running this procedure gives the following result:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此过程将得到以下结果：
- en: '| index | via | totalCost |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 经由 | 总成本 |'
- en: '| --- | --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | [Rotterdam, Hoek van Holland] | 265.0 |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 0 | [鹿特丹, 霍克范荷兰] | 265.0 |'
- en: '| 1 | [Den Haag, Hoek van Holland] | 266.0 |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 1 | [海牙, 霍克范荷兰] | 266.0 |'
- en: '| 2 | [Rotterdam, Den Haag, Hoek van Holland] | 285.0 |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 2 | [鹿特丹, 海牙, 霍克范荷兰] | 285.0 |'
- en: '| 3 | [Den Haag, Rotterdam, Hoek van Holland] | 298.0 |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 3 | [海牙, 鹿特丹, 霍克范荷兰] | 298.0 |'
- en: '| 4 | [Utrecht, Amsterdam, Den Haag, Hoek van Holland] | 374.0 |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 4 | [乌得勒支, 阿姆斯特丹, 海牙, 霍克范荷兰] | 374.0 |'
- en: '[Figure 4-7](#yens-gouda-felixstowe-image) shows the shortest path between
    Gouda and Felixstowe.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](#yens-gouda-felixstowe-image) 展示了从古达到费利克斯托的最短路径。'
- en: '![gral 0407](Images/gral_0407.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0407](Images/gral_0407.png)'
- en: Figure 4-7\. The shortest path between Gouda and Felixstowe
  id: totrans-340
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-7\. 古达和费利克斯托之间的最短路径
- en: The shortest path in [Figure 4-7](#yens-gouda-felixstowe-image) is interesting
    in comparison to the results ordered by total cost. It illustrates that sometimes
    you may want to consider several shortest paths or other parameters. In this example,
    the second-shortest route is only 1 km longer than the shortest one. If we prefer
    the scenery, we might choose the slightly longer route.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-7](#yens-gouda-felixstowe-image) 中的最短路径与按总成本排序的结果比较有趣。它说明有时您可能需要考虑多条最短路径或其他参数。在这个例子中，第二短路径仅比最短路径长
    1 公里。如果我们更喜欢风景，我们可能会选择稍长的路线。'
- en: All Pairs Shortest Path
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全对最短路径
- en: The All Pairs Shortest Path (APSP) algorithm calculates the shortest (weighted)
    path between all pairs of nodes. It’s more efficient than running the Single Source
    Shortest Path algorithm for every pair of nodes in the graph.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 全对最短路径（APSP）算法计算所有节点对之间的最短（加权）路径。它比在图中每对节点运行单源最短路径算法更有效。
- en: APSP optimizes operations by keeping track of the distances calculated so far
    and running on nodes in parallel. Those known distances can then be reused when
    calculating the shortest path to an unseen node. You can follow the example in
    the next section to get a better understanding of how the algorithm works.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: APSP 通过跟踪到目前为止计算的距离并在节点上并行运行来优化操作。在计算到未见节点的最短路径时，可以重复使用这些已知的距离。你可以在接下来的部分中参考示例，更好地理解算法的工作原理。
- en: Note
  id: totrans-345
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some pairs of nodes might not be reachable from each other, which means that
    there is no shortest path between these nodes. The algorithm doesn’t return distances
    for these pairs of nodes.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有些节点对可能彼此不可达，这意味着这些节点之间没有最短路径。算法不返回这些节点对的距离。
- en: A Closer Look at All Pairs Shortest Path
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更详细地查看全对最短路径
- en: The calculation for APSP is easiest to understand when you follow a sequence
    of operations. The diagram in [Figure 4-8](#all-pairs-example-image) walks through
    the steps for node A.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按照操作序列进行时，全对最短路径的计算最容易理解。图 [Figure 4-8](#all-pairs-example-image) 中的图示展示了节点
    A 的步骤。
- en: '![gral 0408](Images/gral_0408.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0408](Images/gral_0408.png)'
- en: Figure 4-8\. The steps to calculate the shortest path from node A to all other
    nodes, with updates shaded.
  id: totrans-350
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-8\. 计算从节点 A 到所有其他节点的最短路径的步骤，已进行阴影更新。
- en: 'Initially the algorithm assumes an infinite distance to all nodes. When a start
    node is selected, then the distance to that node is set to 0\. The calculation
    then proceeds as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，算法假设到所有节点的距离是无限的。当选择了一个起始节点时，到该节点的距离被设置为 0。然后计算继续进行如下：
- en: From start node A we evaluate the cost of moving to the nodes we can reach and
    update those values. Looking for the smallest value, we have a choice of B (cost
    of 3) or C (cost of 1). C is selected for the next phase of traversal.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从起始节点 A 开始，我们评估移动到可以到达的节点的成本并更新这些值。在寻找最小值时，我们可以选择 B（成本为 3）或 C（成本为 1）。C 被选为下一个遍历阶段的节点。
- en: 'Now from node C, the algorithm updates the cumulative distances from A to nodes
    that can be reached directly from C. Values are only updated when a lower cost
    has been found:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在从节点 C 开始，算法更新从 A 直接到达节点的累积距离。只有在找到更低成本时才会更新值：
- en: '[PRE20]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then B is selected as the next closest node that hasn’t already been visited.
    It has relationships to nodes A, D, and E. The algorithm works out the distance
    to those nodes by summing the distance from A to B with the distance from B to
    each of those nodes. Note that the lowest cost from the start node A to the current
    node is always preserved as a sunk cost. The distance (d) calculation results:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择 B 作为下一个最接近的尚未访问的节点。它与节点 A、D 和 E 有关系。算法通过将从 A 到 B 的距离与从 B 到这些节点的距离相加来计算到这些节点的距离。请注意，从起始节点
    A 到当前节点的最低成本始终保留为固定成本。距离（d）计算结果：
- en: '[PRE21]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this step the distance from node A to B and back to A, shown as d(A,A) =
    6, is greater than the shortest distance already computed (0), so its value is
    not updated.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这一步中，从节点 A 到 B，然后返回 A 的距离，表示为 d(A,A) = 6，大于已计算的最短距离（0），因此其值不会更新。
- en: The distances for nodes D (6) and E (4) are less than the previously calculated
    distances, so their values are updated.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点 D（6）和 E（4）的距离小于先前计算的距离，因此它们的值被更新。
- en: E is selected next. Only the cumulative total for reaching D (5) is now lower,
    and therefore it is the only one updated.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来选择 E。现在只有到达 D 的累积总数（5）更低，因此只更新它。
- en: When D is finally evaluated, there are no new minimum path weights; nothing
    is updated, and the algorithm terminates.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当最终评估 D 时，没有新的最小路径权重；没有更新，算法终止。
- en: Tip
  id: totrans-361
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Even though the All Pairs Shortest Path algorithm is optimized to run calculations
    in parallel for each node, this can still add up for a very large graph. Consider
    using a subgraph if you only need to evaluate paths between a subcategory of nodes.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 即使全对最短路径算法已经优化为对每个节点并行运行计算，但对于非常大的图表，这仍可能增加。如果只需要评估子类节点之间的路径，请考虑使用子图。
- en: When Should I Use All Pairs Shortest Path?
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时应该使用全对最短路径？
- en: All Pairs Shortest Path is commonly used for understanding alternate routing
    when the shortest route is blocked or becomes suboptimal. For example, this algorithm
    is used in logical route planning to ensure the best multiple paths for diversity
    routing. Use All Pairs Shortest Path when you need to consider all possible routes
    between all or most of your nodes.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 全对最短路径通常用于了解当最短路径被阻塞或变得次优时的备用路由。例如，该算法用于逻辑路由规划，以确保多样化路由的最佳多条路径。在需要考虑所有节点之间所有可能路径时，请使用全对最短路径。
- en: 'Example use cases include:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: Optimizing the location of urban facilities and the distribution of goods. One
    example of this is determining the traffic load expected on different segments
    of a transportation grid. For more information, see R. C. Larson and A. R. Odoni’s
    book, *Urban Operations Research* (Prentice-Hall).
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化城市设施的位置和货物的分布。其中一个例子是确定预期在交通网格不同部分的交通负载。有关更多信息，请参阅R. C. Larson和A. R. Odoni的书籍*Urban
    Operations Research*（Prentice-Hall）。
- en: 'Finding a network with maximum bandwidth and minimal latency as part of a data
    center design algorithm. There are more details about this approach in the paper
    [“REWIRE: An Optimization-Based Framework for Data Center Network Design”](https://bit.ly/2HTbhzY),
    by A. R. Curtis et al.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在数据中心设计算法的一部分中找到带宽最大且延迟最小的网络。有关此方法的更多详细信息，请参阅A. R. Curtis等人的论文 [“REWIRE: An
    Optimization-Based Framework for Data Center Network Design”](https://bit.ly/2HTbhzY)。'
- en: All Pairs Shortest Path with Apache Spark
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Apache Spark进行全对最短路径
- en: 'Spark’s `shortestPaths` function is designed for finding the shortest paths
    from all nodes to a set of nodes called *landmarks*. If we wanted to find the
    shortest path from every location to Colchester, Immingham, and Hoek van Holland,
    we would write the following query:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Spark的`shortestPaths`函数旨在查找从所有节点到一组称为*地标*的节点的最短路径。如果我们想找到每个位置到Colchester、Immingham和Hoek
    van Holland的最短路径，我们将编写以下查询：
- en: '[PRE22]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we run that code in pyspark we’ll see this output:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在pyspark中运行该代码，我们将看到以下输出：
- en: '| id | distances |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| id | distances |'
- en: '| --- | --- |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Amsterdam | [Immingham → 1, Hoek van Holland → 2, Colchester → 4] |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | [Immingham → 1, Hoek van Holland → 2, Colchester → 4] |'
- en: '| Colchester | [Colchester → 0, Hoek van Holland → 3, Immingham → 3] |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| Colchester | [Colchester → 0, Hoek van Holland → 3, Immingham → 3] |'
- en: '| Den Haag | [Hoek van Holland → 1, Immingham → 2, Colchester → 4] |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 海牙 | [Hoek van Holland → 1, Immingham → 2, Colchester → 4] |'
- en: '| Doncaster | [Immingham → 1, Colchester → 2, Hoek van Holland → 4] |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 | [Immingham → 1, Colchester → 2, Hoek van Holland → 4] |'
- en: '| Felixstowe | [Hoek van Holland → 1, Colchester → 2, Immingham → 4] |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 费利克斯托 | [Hoek van Holland → 1, Colchester → 2, Immingham → 4] |'
- en: '| Gouda | [Hoek van Holland → 2, Immingham → 3, Colchester → 5] |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| Gouda | [Hoek van Holland → 2, Immingham → 3, Colchester → 5] |'
- en: '| Hoek van Holland | [Hoek van Holland → 0, Immingham → 3, Colchester → 3]
    |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| 霍克港 | [Hoek van Holland → 0, Immingham → 3, Colchester → 3] |'
- en: '| Immingham | [Immingham → 0, Colchester → 3, Hoek van Holland → 3] |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 伊明厄姆 | [Immingham → 0, Colchester → 3, Hoek van Holland → 3] |'
- en: '| Ipswich | [Colchester → 1, Hoek van Holland → 2, Immingham → 4] |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | [Colchester → 1, Hoek van Holland → 2, Immingham → 4] |'
- en: '| London | [Colchester → 1, Immingham → 2, Hoek van Holland → 4] |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | [Colchester → 1, Immingham → 2, Hoek van Holland → 4] |'
- en: '| Rotterdam | [Hoek van Holland → 1, Immingham → 3, Colchester → 4] |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 鹿特丹 | [Hoek van Holland → 1, Immingham → 3, Colchester → 4] |'
- en: '| Utrecht | [Immingham → 2, Hoek van Holland → 3, Colchester → 5] |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 乌特勒支 | [Immingham → 2, Hoek van Holland → 3, Colchester → 5] |'
- en: The number next to each location in the `distances` column is the number of
    relationships (roads) between cities we need to traverse to get there from the
    source node. In our example, Colchester is one of our destination cities and you
    can see it has 0 nodes to traverse to get to itself but 3 hops to make from Immingham
    and Hoek van Holland. If we were planning a trip, we could use this information
    to help maximize our time at our chosen destinations.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`distances`列中每个位置旁边的数字是我们需要从源节点穿越的城市之间关系（道路）的数量。在我们的示例中，Colchester是我们的目标城市之一，您可以看到它到自身的距离为0，但从Immingham和Hoek
    van Holland出发需要3跳。如果我们计划旅行，我们可以使用这些信息来帮助最大化在我们选择的目的地停留的时间。'
- en: All Pairs Shortest Path with Neo4j
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Neo4j的全对最短路径
- en: Neo4j has a parallel implementation of the All Pairs Shortest Path algorithm,
    which returns the distance between every pair of nodes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j具有全对最短路径算法的并行实现，可以返回每对节点之间的距离。
- en: The first parameter to this procedure is the property to use to work out the
    shortest weighted path. If we set this to `null` then the algorithm will calculate
    the unweighted shortest paths between all pairs of nodes.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程的第一个参数是要用于计算最短加权路径的属性。如果我们将其设置为 `null`，则算法将计算所有节点对之间的非加权最短路径。
- en: 'The following query does this:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询执行此操作：
- en: '[PRE23]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This algorithm returns the shortest path between every pair of nodes twice—once
    with each of the nodes as the source node. This would be helpful if you were evaluating
    a directed graph of one-way streets. However, we don’t need to see each path twice,
    so we filter the results to only keep one of them by using the `sourceNodeId <
    targetNodeId` predicate.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法返回每对节点之间的最短路径两次——每次以其中一个节点作为源节点。如果您正在评估单向街道的有向图，这将非常有用。然而，我们不需要看到每条路径两次，因此我们通过使用
    `sourceNodeId < targetNodeId` 谓词来过滤结果，仅保留其中一条路径。
- en: 'The query returns the following results:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回以下结果：
- en: '| source | target | distance |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 源 | 目标 | 距离 |'
- en: '| --- | --- | --- |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Colchester | Utrecht | 5.0 |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 乌得勒支 | 5.0 |'
- en: '| London | Rotterdam | 5.0 |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 鹿特丹 | 5.0 |'
- en: '| London | Gouda | 5.0 |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 古达 | 5.0 |'
- en: '| Ipswich | Utrecht | 5.0 |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 乌得勒支 | 5.0 |'
- en: '| Colchester | Gouda | 5.0 |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 古达 | 5.0 |'
- en: '| Colchester | Den Haag | 4.0 |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 海牙 | 4.0 |'
- en: '| London | Utrecht | 4.0 |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 乌得勒支 | 4.0 |'
- en: '| London | Den Haag | 4.0 |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 海牙 | 4.0 |'
- en: '| Colchester | Amsterdam | 4.0 |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 阿姆斯特丹 | 4.0 |'
- en: '| Ipswich | Gouda | 4.0 |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 古达 | 4.0 |'
- en: This output shows the 10 pairs of locations that have the most relationships
    between them because we asked for results in descending order (`DESC`).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示了具有最多关系的 10 对地点，因为我们要求按降序（`DESC`）显示结果。
- en: If we want to calculate the shortest weighted paths, rather than passing in
    `null` as the first parameter, we can pass in the property name that contains
    the `cost` to be used in the shortest path calculation. This property will then
    be evaluated to work out the shortest weighted path between each pair of nodes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想计算最短加权路径，而不是将第一个参数设置为 `null`，我们可以传递包含在最短路径计算中要使用的 `cost` 的属性名称。然后将评估此属性以计算每对节点之间的最短加权路径。
- en: 'The following query does this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询执行此操作：
- en: '[PRE24]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The query returns the following result:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回以下结果：
- en: '| source | target | distance |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 源 | 目标 | 距离 |'
- en: '| --- | --- | --- |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Doncaster | Hoek van Holland | 529.0 |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 | 霍克范霍兰 | 529.0 |'
- en: '| Rotterdam | Doncaster | 528.0 |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| 鹿特丹 | 唐卡斯特 | 528.0 |'
- en: '| Gouda | Doncaster | 524.0 |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 古达 | 唐卡斯特 | 524.0 |'
- en: '| Felixstowe | Immingham | 511.0 |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 费利克斯托 | 伊明厄姆 | 511.0 |'
- en: '| Den Haag | Doncaster | 502.0 |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 海牙 | 唐卡斯特 | 502.0 |'
- en: '| Ipswich | Immingham | 489.0 |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 伊明厄姆 | 489.0 |'
- en: '| Utrecht | Doncaster | 489.0 |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| 乌得勒支 | 唐卡斯特 | 489.0 |'
- en: '| London | Utrecht | 460.0 |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 乌得勒支 | 460.0 |'
- en: '| Colchester | Immingham | 457.0 |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 伊明厄姆 | 457.0 |'
- en: '| Immingham | Hoek van Holland | 455.0 |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 伊明厄姆 | 霍克范霍兰 | 455.0 |'
- en: Now we’re seeing the 10 pairs of locations furthest from each other in terms
    of the total distance between them. Notice that Doncaster shows up frequently
    along with several cities in the Netherlands. It looks like it would be a long
    drive if we wanted to take a road trip between those areas.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了距离最远的 10 对地点，其总距离最长。注意到唐卡斯特经常出现，还有荷兰的几个城市。如果我们想在这些地区之间进行一次公路旅行，看起来会是一段漫长的车程。
- en: Single Source Shortest Path
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单源最短路径
- en: The Single Source Shortest Path (SSSP) algorithm, which came into prominence
    at around the same time as Dijkstra’s Shortest Path algorithm, acts as an implementation
    for both problems.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 单源最短路径（SSSP）算法与迪杰斯特拉最短路径算法几乎同时兴起，是这两个问题的实现。
- en: The SSSP algorithm calculates the shortest (weighted) path from a root node
    to all other nodes in the graph, as demonstrated in [Figure 4-9](#sssp-steps-image).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: SSSP 算法计算图中从根节点到所有其他节点的最短（加权）路径，如 [图 4-9](#sssp-steps-image) 所示。
- en: '![gral 0409](Images/gral_0409.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0409](Images/gral_0409.png)'
- en: Figure 4-9\. The steps of the Single Source Shortest Path algorithm
  id: totrans-428
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-9\. 单源最短路径算法的步骤
- en: 'It proceeds as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 过程如下：
- en: It begins with a root node from which all paths will be measured. In [Figure 4-9](#sssp-steps-image)
    we’ve selected node A as the root.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从一个根节点开始，所有路径将从此节点开始测量。在 [图 4-9](#sssp-steps-image) 中，我们选择节点 A 作为根节点。
- en: The relationship with the smallest weight coming from that root node is selected
    and added to the tree, along with its connected node. In this case, that’s d(A,D)=1.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择从根节点到该根节点的最小权重关系，并将其与连接的节点一起添加到树中。在这种情况下，这是 d(A,D)=1。
- en: The next relationship with the smallest cumulative weight from our root node
    to any unvisited node is selected and added to the tree in the same way. Our choices
    in [Figure 4-9](#sssp-steps-image) are d(A,B)=8, d(A,C)=5 directly or 4 via A-D-C,
    and d(A,E)=5\. So, the route via A-D-C is chosen and C is added to our tree.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来选择与从我们的根节点到任何未访问节点的累积权重最小的关系，并以相同的方式将其添加到树中。我们在[图 4-9](#sssp-steps-image)中的选择是
    d(A,B)=8, d(A,C)=5 直接或经过 A-D-C 的4，以及 d(A,E)=5。因此，选择经过 A-D-C 的路径，将 C 添加到我们的树中。
- en: The process continues until there are no more nodes to add and we have our single
    source shortest path.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程一直持续到没有更多的节点可添加，我们就得到了我们的单源最短路径。
- en: When Should I Use Single Source Shortest Path?
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时应该使用单源最短路径？
- en: Use Single Source Shortest Path when you need to evaluate the optimal route
    from a fixed start point to all other individual nodes. Because the route is chosen
    based on the total path weight from the root, it’s useful for finding the best
    path to each node, but not necessarily when all nodes need to be visited in a
    single trip.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要评估从固定起点到所有其他各个节点的最优路径时，请使用单源最短路径。由于路由是基于从根节点到目标节点的总路径权重选择的，因此它对于找到到每个节点的最佳路径很有用，但不一定适用于需要在单次行程中访问所有节点的情况。
- en: For example, SSSP is helpful for identifying the main routes to use for emergency
    services where you don’t visit every location on each incident, but not for finding
    a single route for garbage collection where you need to visit each house in one
    trip. (In the latter case, you’d use the Minimum Spanning Tree algorithm, covered
    later.)
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，单源最短路径对于确定紧急服务的主要路线很有帮助，其中您不会在每次事件中访问每个位置，但对于找到垃圾收集的单一路线就不适用，因为您需要在一次旅行中访问每个房子。（在后一种情况下，您会使用稍后介绍的最小生成树算法。）
- en: 'Example use cases include:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: Detecting changes in topology, such as link failures, and [suggesting a new
    routing structure in seconds](https://bit.ly/2HL7ndd)
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测拓扑结构的变化，如链路故障，并且在几秒钟内[建议新的路由结构](https://bit.ly/2HL7ndd)。
- en: Using Dijkstra as an IP routing protocol for use in autonomous systems such
    as a [local area network (LAN)](https://bit.ly/2HUsAAr)
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为IP路由协议使用迪杰斯特拉，用于自治系统，例如[局域网（LAN）](https://bit.ly/2HUsAAr)。
- en: Single Source Shortest Path with Apache Spark
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apache Spark进行单源最短路径
- en: We can adapt the `shortest_path` function that we wrote to [calculate the shortest
    path between two locations](#shortest-weighted-path-spark) to instead return us
    the shortest path from one location to all others. Note that we’re using Spark’s
    `aggregateMessages` framework again to customize our function.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改我们编写的`shortest_path`函数，以便从一个位置到所有其他位置返回最短路径，而不是计算两个位置之间的最短加权路径。请注意，我们再次使用Spark的`aggregateMessages`框架来定制我们的函数。
- en: 'We’ll first import the same libraries as before:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入与之前相同的库：
- en: '[PRE25]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And we’ll use the same user-defined function to construct paths:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用同样的用户定义函数来构建路径：
- en: '[PRE26]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now for the main function, which calculates the shortest path starting from
    an origin:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是主要函数，它从一个起始点开始计算最短路径：
- en: '[PRE27]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we want to find the shortest path from Amsterdam to all other locations
    we can call the function like this:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要找到从阿姆斯特丹到所有其他位置的最短路径，我们可以像这样调用函数：
- en: '[PRE28]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We define another user-defined function to filter out the start and end nodes
    from the resulting path. If we run that code we’ll see the following output:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义另一个用户定义的函数，用于从结果路径中过滤出起点和终点节点。如果我们运行该代码，将会看到以下输出：
- en: '| id | distance | via |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| id | distance | via |'
- en: '| --- | --- | --- |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Amsterdam | 0.0 | [] |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | 0.0 | [] |'
- en: '| Utrecht | 46.0 | [] |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 乌特勒支 | 46.0 | [] |'
- en: '| Den Haag | 59.0 | [] |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| 海牙 | 59.0 | [] |'
- en: '| Gouda | 81.0 | [Utrecht] |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| 古达 | 81.0 | [乌特勒支] |'
- en: '| Rotterdam | 85.0 | [Den Haag] |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 鹿特丹 | 85.0 | [海牙] |'
- en: '| Hoek van Holland | 86.0 | [Den Haag] |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| 胡克港 | 86.0 | [海牙] |'
- en: '| Felixstowe | 293.0 | [Den Haag, Hoek van Holland] |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| 费利克斯托 | 293.0 | [海牙，胡克港] |'
- en: '| Ipswich | 315.0 | [Den Haag, Hoek van Holland, Felixstowe] |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 315.0 | [海牙，胡克港，费利克斯托] |'
- en: '| Colchester | 347.0 | [Den Haag, Hoek van Holland, Felixstowe, Ipswich] |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 347.0 | [海牙，胡克港，费利克斯托，伊普斯维奇] |'
- en: '| Immingham | 369.0 | [] |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| 伊明厄姆 | 369.0 | [] |'
- en: '| Doncaster | 443.0 | [Immingham] |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 | 443.0 | [伊明厄姆] |'
- en: '| London | 453.0 | [Den Haag, Hoek van Holland, Felixstowe, Ipswich, Colchester]
    |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 453.0 | [海牙，胡克港，费利克斯托，伊普斯维奇，科尔切斯特] |'
- en: In these results we see the physical distances in kilometers from the root node,
    Amsterdam, to all other cities in the graph, ordered by shortest distance.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些结果中，我们看到从根节点阿姆斯特丹到图中所有其他城市的物理距离，按最短距离排序。
- en: Single Source Shortest Path with Neo4j
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Neo4j 单源最短路径
- en: Neo4j implements a variation of SSSP, called the [Delta-Stepping algorithm](https://bit.ly/2UaCHrw)
    that divides Dijkstra’s algorithm into a number of phases that can be executed
    in parallel.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 实现了 SSSP 的一种变体，称为[Delta-Stepping 算法](https://bit.ly/2UaCHrw)，将迪杰斯特拉算法分成多个可以并行执行的阶段。
- en: 'The following query executes the Delta-Stepping algorithm:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的查询执行 Delta-Stepping 算法：
- en: '[PRE30]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The query returns the following output:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回以下输出：
- en: '| destination | distance |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| 目的地 | 距离 |'
- en: '| --- | --- |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| London | 0.0 |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 0.0 |'
- en: '| Colchester | 106.0 |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 106.0 |'
- en: '| Ipswich | 138.0 |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 138.0 |'
- en: '| Felixstowe | 160.0 |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| 费利克斯托 | 160.0 |'
- en: '| Doncaster | 277.0 |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 | 277.0 |'
- en: '| Immingham | 351.0 |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| 伊明汉姆 | 351.0 |'
- en: '| Hoek van Holland | 367.0 |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| 霍克范霍兰 | 367.0 |'
- en: '| Den Haag | 394.0 |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| 海牙 | 394.0 |'
- en: '| Rotterdam | 400.0 |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| 鹿特丹 | 400.0 |'
- en: '| Gouda | 425.0 |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| 根达 | 425.0 |'
- en: '| Amsterdam | 453.0 |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | 453.0 |'
- en: '| Utrecht | 460.0 |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| 乌得勒支 | 460.0 |'
- en: In these results we see the physical distances in kilometers from the root node,
    London, to all other cities in the graph, ordered by shortest distance.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些结果中，我们看到从根节点伦敦到图中所有其他城市的物理距离，按最短距离排序。
- en: Minimum Spanning Tree
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小生成树
- en: The Minimum (Weight) Spanning Tree algorithm starts from a given node and finds
    all its reachable nodes and the set of relationships that connect the nodes together
    with the minimum possible weight. It traverses to the next unvisited node with
    the lowest weight from any visited node, avoiding cycles.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 最小（权重）生成树算法从给定节点开始，找到所有可达节点及将节点以最小可能权重连接的关系集合。它从任何访问过的节点到下一个未访问节点以最低权重遍历，避免循环。
- en: The first known Minimum Weight Spanning Tree algorithm was developed by the
    Czech scientist Otakar Borůvka in 1926. Prim’s algorithm, invented in 1957, is
    the simplest and best known.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个已知的最小权重生成树算法由捷克科学家奥塔卡尔·博鲁沃卡（Otakar Borůvka）于1926年开发。普里姆算法，于1957年发明，是最简单和最著名的。
- en: Prim’s algorithm is similar to Dijkstra’s Shortest Path algorithm, but rather
    than minimizing the total length of a path ending at each relationship, it minimizes
    the length of each relationship individually. Unlike Dijkstra’s algorithm, it
    tolerates negative-weight relationships.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 普里姆算法类似于迪杰斯特拉最短路径算法，但它不是最小化到达每个关系的路径总长度，而是最小化每个关系的长度。与迪杰斯特拉算法不同的是，它能容忍负权重关系。
- en: The Minimum Spanning Tree algorithm operates as demonstrated in [Figure 4-10](#mst-steps-image).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树算法的操作如[图 4-10](#mst-steps-image)所示。
- en: '![gral 0410](Images/gral_0410.png)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0410](Images/gral_0410.png)'
- en: Figure 4-10\. The steps of the Minimum Spanning Tree algorithm
  id: totrans-493
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-10\. 最小生成树算法的步骤
- en: 'The steps are as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤如下：
- en: It begins with a tree containing only one node. In [Figure 4-10](#mst-steps-image)
    we start with node A.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它始于一个仅包含一个节点的树。在[图 4-10](#mst-steps-image)中，我们从节点 A 开始。
- en: The relationship with smallest weight coming from that node is selected and
    added to the tree (along with its connected node). In this case, A-D.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择从该节点出发的具有最小权重的关系，并将其添加到树中（以及其连接的节点）。在这种情况下，A-D。
- en: This process is repeated, always choosing the minimal-weight relationship that
    joins any node not already in the tree.
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程重复进行，始终选择连接到树中尚未存在的节点的最小权重关系。
- en: If you compare our example here to the SSSP example in [Figure 4-9](#sssp-steps-image)
    you’ll notice that in the fourth graph the paths become different. This is because
    SSSP evaluates the shortest path based on cumulative totals from the root, whereas
    Minimum Spanning Tree only looks at the cost of the next step.
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你比较我们这里的例子与[图 4-9](#sssp-steps-image)中的单源最短路径例子，你会注意到在第四个图中路径变得不同。这是因为单源最短路径基于从根节点累积总和评估最短路径，而最小生成树仅查看下一步的成本。
- en: When there are no more nodes to add, the tree is a minimum spanning tree.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当没有更多节点可添加时，树就是最小生成树。
- en: There are also variants of this algorithm that find the maximum-weight spanning
    tree (highest-cost tree) and the *k*-spanning tree (tree size limited.)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法也有找到最大权重生成树（最高成本树）和*k*-生成树（限制树大小）的变体。
- en: When Should I Use Minimum Spanning Tree?
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用最小生成树？
- en: Use Minimum Spanning Tree when you need the best route to visit all nodes. Because
    the route is chosen based on the cost of each next step, it’s useful when you
    must visit all nodes in a single walk. (Review the previous section on [“Single
    Source Shortest Path”](#single_source_shortest_path) if you don’t need a path
    for a single trip.)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要最佳路线访问所有节点时，请使用最小生成树。因为路线是基于每个下一步的成本选择的，所以当您必须在一次行走中访问所有节点时非常有用。（如果您不需要一条单程路线，请查看之前关于[“单源最短路径”](#single_source_shortest_path)的部分。）
- en: You can use this algorithm for optimizing paths for connected systems like water
    pipes and circuit design. It’s also employed to approximate some problems with
    unknown compute times, such as the Traveling Salesman Problem and certain types
    of rounding problems. Although it may not always find the absolute optimal solution,
    this algorithm makes potentially complicated and compute-intensive analysis much
    more approachable.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此算法用于优化连接系统的路径，如水管和电路设计。它还用于近似某些具有未知计算时间的问题，例如旅行推销员问题和某些类型的舍入问题。尽管它可能并不总是找到绝对最佳解决方案，但此算法使潜在复杂且计算密集的分析变得更易接近。
- en: 'Example use cases include:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: Minimizing the travel cost of exploring a country. [“An Application of Minimum
    Spanning Trees to Travel Planning”](https://bit.ly/2CQBs6Q) describes how the
    algorithm analyzed airline and sea connections to do this.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化探索一个国家的旅行成本。 [“最小生成树在旅行规划中的应用”](https://bit.ly/2CQBs6Q) 描述了该算法分析航空和海上连接来实现这一目的。
- en: Visualizing correlations between currency returns. This is described in [“Minimum
    Spanning Tree Application in the Currency Market”](https://bit.ly/2HFbGGG).
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化货币回报之间的相关性。这在[“货币市场中最小生成树应用”](https://bit.ly/2HFbGGG)中有描述。
- en: Tracing the history of infection transmission in an outbreak. For more information,
    see [“Use of the Minimum Spanning Tree Model for Molecular Epidemiological Investigation
    of a Nosocomial Outbreak of Hepatitis C Virus Infection”](https://bit.ly/2U7SR4Y).
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪爆发中传染传播的历史。有关更多信息，请参阅[“使用最小生成树模型进行医院暴发的丙型肝炎病毒感染分子流行病学调查”](https://bit.ly/2U7SR4Y)。
- en: Warning
  id: totrans-508
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The Minimum Spanning Tree algorithm only gives meaningful results when run on
    a graph where the relationships have different weights. If the graph has no weights,
    or all relationships have the same weight, then any spanning tree is a minimum
    spanning tree.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当在具有不同权重的关系的图上运行时，最小生成树算法仅在求得有意义的结果时才有效。如果图中没有权重，或所有关系具有相同的权重，则任何生成树都是最小生成树。
- en: Minimum Spanning Tree with Neo4j
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Neo4j中的最小生成树
- en: 'Let’s see the Minimum Spanning Tree algorithm in action. The following query
    finds a spanning tree starting from Amsterdam:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最小生成树算法的实际运作。以下查询从阿姆斯特丹开始查找一个生成树：
- en: '[PRE31]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The parameters passed to this algorithm are:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给该算法的参数包括：
- en: '`Place`'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`Place`'
- en: The node labels to consider when computing the spanning tree
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 计算生成树时要考虑的节点标签
- en: '`EROAD`'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`EROAD`'
- en: The relationship types to consider when computing the spanning tree
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 计算生成树时要考虑的关系类型
- en: '`distance`'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance`'
- en: The name of the relationship property that indicates the cost of traversing
    between a pair of nodes
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 指示穿越一对节点之间的成本的关系属性的名称
- en: '`id(n)`'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`id(n)`'
- en: The internal node id of the node from which the spanning tree should begin
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 应该从哪个节点开始生成树的内部节点ID
- en: 'This query stores its results in the graph. If we want to return the minimum
    weight spanning tree we can run the following query:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将结果存储在图中。如果我们想返回最小权重生成树，则可以运行以下查询：
- en: '[PRE32]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And this is the output of the query:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查询的输出：
- en: '| source | destination | cost |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| 起点 | 终点 | 成本 |'
- en: '| --- | --- | --- |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Amsterdam | Utrecht | 46.0 |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 | 乌得勒支 | 46.0 |'
- en: '| Utrecht | Gouda | 35.0 |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| 乌得勒支 | 古达 | 35.0 |'
- en: '| Gouda | Rotterdam | 25.0 |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| 古达 | 鹿特丹 | 25.0 |'
- en: '| Rotterdam | Den Haag | 26.0 |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| 鹿特丹 | 海牙 | 26.0 |'
- en: '| Den Haag | Hoek van Holland | 27.0 |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| 海牙 | 霍克范荷兰 | 27.0 |'
- en: '| Hoek van Holland | Felixstowe | 207.0 |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| 霍克范荷兰 | 费利克斯托 | 207.0 |'
- en: '| Felixstowe | Ipswich | 22.0 |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| 费利克斯托 | 伊普斯维奇 | 22.0 |'
- en: '| Ipswich | Colchester | 32.0 |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| 伊普斯维奇 | 科尔切斯特 | 32.0 |'
- en: '| Colchester | London | 106.0 |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| 科尔切斯特 | 伦敦 | 106.0 |'
- en: '| London | Doncaster | 277.0 |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 | 唐卡斯特 | 277.0 |'
- en: '| Doncaster | Immingham | 74.0 |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 | 伊明厄姆 | 74.0 |'
- en: '![gral 0411](Images/gral_0411.png)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0411](Images/gral_0411.png)'
- en: Figure 4-11\. A minimum weight spanning tree from Amsterdam
  id: totrans-539
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-11\. 来自阿姆斯特丹的最小权重生成树
- en: If we were in Amsterdam and wanted to visit every other place in our dataset
    during the same trip, [Figure 4-11](#mst-image) demonstrates the shortest continuous
    route to do so.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在阿姆斯特丹，并希望在同一次旅行中访问数据集中的每个其他地方，[图 4-11](#mst-image) 展示了实现最短连续路径的方法。
- en: Random Walk
  id: totrans-541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机游走
- en: The Random Walk algorithm provides a set of nodes on a random path in a graph.
    The term was first mentioned by Karl Pearson in 1905 in a letter to *Nature* magazine
    titled [“The Problem of the Random Walk”](https://go.nature.com/2Fy15em). Although
    the concept goes back even further, it’s only more recently that random walks
    have been applied to network science.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 随机游走算法在图中提供了一组节点上的随机路径。这个术语最早由卡尔·皮尔逊在 1905 年写给《自然》杂志的一封信中提到，题为 [“随机游走问题”](https://go.nature.com/2Fy15em)。尽管这个概念更早存在，但直到近年来，随机游走才被应用于网络科学。
- en: A random walk, in general, is sometimes described as being similar to how a
    drunk person traverses a city. They know what direction or end point they want
    to reach but may take a very circuitous route to get there.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，随机游走有时被描述为类似于醉酒者如何穿越城市。他们知道他们想要到达的方向或终点，但可能会采取非常迂回的路线来到达那里。
- en: The algorithm starts at one node and somewhat randomly follows one of the relationships
    forward or backward to a neighbor node. It then does the same from that node and
    so on, until it reaches the set path length. (We say somewhat randomly because
    the number of relationships a node has, and its neighbors have, influences the
    probability a node will be walked through.)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 算法从一个节点开始，有点随机地沿着一个关系向前或向后到一个相邻节点。然后它从那个节点继续，以此类推，直到达到设定的路径长度。（我们说有点随机是因为节点的关系数以及其邻居的关系数会影响节点被遍历的概率。）
- en: When Should I Use Random Walk?
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们何时应该使用随机游走？
- en: Use the Random Walk algorithm as part of other algorithms or data pipelines
    when you need to generate a mostly random set of connected nodes.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要生成一个大部分随机连接节点的集合时，作为其他算法或数据流水线的一部分使用随机游走算法。
- en: 'Example use cases include:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: As part of the node2vec and graph2vec algorithms, that create node embeddings.
    These node embeddings could then be used as the input to a neural network.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 node2vec 和 graph2vec 算法的一部分，创建节点嵌入。然后这些节点嵌入可以作为神经网络的输入。
- en: As part of the Walktrap and Infomap community detection. If a random walk returns
    a small set of nodes repeatedly, then it indicates that node set may have a community
    structure.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Walktrap 和 Infomap 社区检测的一部分。如果随机游走重复返回一小组节点，则表明该节点集可能具有社区结构。
- en: As part of the training process of machine learning models. This is described
    further in David Mack’s article [“Review Prediction with Neo4j and TensorFlow”](https://bit.ly/2Cx14ph).
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为机器学习模型训练的一部分。这在 David Mack 的文章 [“使用 Neo4j 和 TensorFlow 进行评论预测”](https://bit.ly/2Cx14ph)
    中有进一步描述。
- en: You can read about more use cases in a paper by N. Masuda, M. A. Porter, and
    R. Lambiotte, [“Random Walks and Diffusion on Networks”](https://bit.ly/2JDvlJ0).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 N. Masuda、M. A. Porter 和 R. Lambiotte 的论文 [“网络上的随机游走和扩散”](https://bit.ly/2JDvlJ0)
    中阅读更多用例。
- en: Random Walk with Neo4j
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Neo4j 的随机游走
- en: 'Neo4j has an implementation of the Random Walk algorithm. It supports two modes
    for choosing the next relationship to follow at each stage of the algorithm:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 实现了随机游走算法。在算法的每个阶段，它支持两种模式来选择下一个要遵循的关系：
- en: '`random`'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`random`'
- en: Randomly chooses a relationship to follow
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择要遵循的关系
- en: '`node2vec`'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`node2vec`'
- en: Chooses relationship to follow based on computing a probability distribution
    of the previous neighbors
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 基于计算上一个邻居的概率分布选择要遵循的关系
- en: 'The following query does this:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的查询执行此操作：
- en: '[PRE33]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The parameters passed to this algorithm are:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给该算法的参数包括：
- en: '`id(source)`'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`id(source)`'
- en: The internal node id of the starting point for our random walk
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随机游走起始点的内部节点 ID
- en: '`5`'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`5`'
- en: The number of hops our random walk should take
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的随机游走应该采取的跳数
- en: '`1`'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`1`'
- en: The number of random walks we want to compute
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要计算的随机游走数量
- en: 'It returns the following result:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回以下结果：
- en: '| place |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| 地点 |'
- en: '| --- |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| London |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| 伦敦 |'
- en: '| Doncaster |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| 唐卡斯特 |'
- en: '| Immingham |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| 伊明厄姆 |'
- en: '| Amsterdam |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 |'
- en: '| Utrecht |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| 乌得勒支 |'
- en: '| Amsterdam |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| 阿姆斯特丹 |'
- en: At each stage of the random walk the next relationship is chosen randomly. This
    means that if we rerun the algorithm, even with the same parameters, we likely
    won’t get the same result. It’s also possible for a walk to go back on itself,
    as we can see in [Figure 4-12](#randomwalk-image) where we go from Amsterdam to
    Den Haag and back.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机游走的每个阶段，下一个关系都是随机选择的。这意味着，即使我们使用相同的参数重新运行算法，我们也可能得不到相同的结果。随机游走也可能会沿原路返回，正如我们在[图 4-12](#randomwalk-image)中看到的，从阿姆斯特丹到海牙再返回。
- en: '![gral 0412](Images/gral_0412.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0412](Images/gral_0412.png)'
- en: Figure 4-12\. A random walk starting from London
  id: totrans-578
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-12\. 从伦敦开始的随机游走
- en: Summary
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Pathfinding algorithms are useful for understanding the way that our data is
    connected. In this chapter we started out with the fundamental Breadth and Depth
    First algorithms, before moving onto Dijkstra and other shortest path algorithms.
    We also looked at variants of the shortest path algorithms optimized for finding
    the shortest path from one node to all other nodes or between all pairs of nodes
    in a graph. We finished with the Random Walk algorithm, which can be used to find
    arbitrary sets of paths.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 寻路算法有助于理解我们的数据连接方式。在本章中，我们从基本的广度优先和深度优先算法开始，然后进入迪杰斯特拉和其他最短路径算法。我们还研究了优化后的最短路径算法的变体，用于在图中找到一个节点到所有其他节点或所有节点对之间的最短路径。最后，我们介绍了随机游走算法，该算法可用于查找任意路径集合。
- en: Next we’ll learn about Centrality algorithms that can be used to find influential
    nodes in a graph.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将学习关于中心性算法，该算法可用于在图中找到具有影响力的节点。
