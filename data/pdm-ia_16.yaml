- en: Appendix A. Podman-related container tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. Podman相关的容器工具
- en: 'This appendix describes the three tools that use containers/storage and containers/image
    libraries. These tools address the following functionalities:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录描述了使用 containers/storage 和 containers/image 库的三个工具。这些工具解决了以下功能：
- en: Moving container images between different container registries and storage
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的容器注册表和存储之间移动容器镜像
- en: Building container images
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Testing, developing, and running containers in production on a single node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单个节点上测试、开发和在生产环境中运行容器
- en: Running containers in production at scale
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产环境中大规模运行容器
- en: As the original creator of Podman, I recognized the need for specialized tools,
    each performing specific functionality rather than a one-size-fits-all monolithic
    solution.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Podman的原始创建者，我认识到需要专门的工具，每个工具都执行特定的功能，而不是一刀切的单体解决方案。
- en: From a security perspective, each of these four categories requires different
    security constraints. Containers running in production need to be run in a more
    secure environment than ones running in development and testing. Moving container
    images between registries requires no privileged access to the host you are running
    the command on—only remote access to the registries. You will have the least secure
    system with a monolithic daemon. If my containers need more access during builds,
    then in production, they get the same access as during builds.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，这四个类别需要不同的安全约束。在生产环境中运行的容器需要在一个比开发和测试环境中运行得更安全的环境中运行。在注册表中移动容器镜像不需要对您运行命令的主机具有特权访问权限——只需要对注册表的远程访问。如果您在构建过程中需要更多访问权限，那么在生产环境中，它们将获得与构建过程中相同的访问权限。
- en: Another critical problem with a monolithic daemon is that it prevents experimentation
    with the tools and doesn’t allow them to go their own way. One example of this
    is when we proposed a change to the Docker daemon to allow users to pull different
    types of OCI content off of container registries. This change was denied, as it
    had little to do with Docker containers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 单体守护进程的另一个关键问题是它阻止了对工具的实验，并且不允许它们独立发展。一个例子是我们提出更改Docker守护进程，允许用户从容器注册表中拉取不同类型的OCI内容。这个更改被拒绝了，因为它与Docker容器几乎没有关系。
- en: Similarly, when the monolithic daemon is modified for one product, it can negatively
    affect features of another one using that daemon. It could cause performance degradation
    or complete breakage. This happened when Kubernetes was being developed, since
    it relied on the Docker daemon as the container engine. But since Docker is monolithic
    and being developed for many other projects, many of its changes affected Kubernetes,
    leading to instability. It was obvious that Kubernetes needed a dedicated container
    engine for its workloads, and in December 2020 it was announced that Kubernetes
    will eventually use the newly developed standard, the Container Runtime Interface
    (CRI; see [http://mng.bz/yaDq](http://mng.bz/yaDq)) to improve interaction between
    orchestrators and different container runtimes. I wrote a coloring book, *The
    Container Commandos* (figure A.1; [https://red.ht/3gfVlHF](https://red.ht/3gfVlHF)),
    illustrated by Máirín Duffy (@marin), describing the container tools talked about
    in this appendix, based on superheroes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当单体守护进程为某个产品修改时，它可能会对使用该守护进程的另一个产品的功能产生负面影响。它可能导致性能下降或完全损坏。这发生在Kubernetes开发期间，因为它依赖于Docker守护进程作为容器引擎。但由于Docker是单体的，并且为许多其他项目开发，其中许多更改影响了Kubernetes，导致不稳定。很明显，Kubernetes需要为其工作负载提供一个专门的容器引擎，2020年12月宣布Kubernetes最终将使用新开发的标准化接口，即容器运行时接口（CRI；见[http://mng.bz/yaDq](http://mng.bz/yaDq)），以改善编排程序与不同容器运行时之间的交互。我编写了一本彩色书，《容器指挥官》（图A.1；[https://red.ht/3gfVlHF](https://red.ht/3gfVlHF)），由Máirín
    Duffy (@marin) 插图，描述了本附录中讨论的容器工具，基于超级英雄。
- en: '![](../../OEBPS/Images/A-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/A-01.png)'
- en: Figure A.1 The Container Coloring Book ([https://red.ht/3gfVlHF](https://red.ht/3gfVlHF))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图A.1 容器彩色书 ([https://red.ht/3gfVlHF](https://red.ht/3gfVlHF))
- en: Finally, sometimes there are conflicting interests or release schedules in play.
    Having separate, independent tools allows releases to be deployed independently
    from all the others at their own pace to guarantee new features to their customers.
    Four projects were created for the distinct functions described in table A.1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有时存在相互冲突的利益或发布计划。拥有独立的独立工具允许以它们自己的速度独立部署，从而确保向客户保证新功能。为表A.1中描述的独立功能创建了四个项目。
- en: Table A.1 Primary container tools based on containers/storage and containers/image.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.1 基于 containers/storage 和 containers/image 的主要容器工具。
- en: '| Tool | Description |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 描述 |'
- en: '| Skopeo | Performs various operations on container images and image repositories
    ([https://github.com/containers/skopeo](https://github.com/containers/skopeo))
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Skopeo | 对容器镜像和镜像仓库执行各种操作 ([https://github.com/containers/skopeo](https://github.com/containers/skopeo))
    |'
- en: '| Buildah | Facilitates a wide range of operations on container images ([https://github.com/containers/buildah](https://github.com/containers/buildah))
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Buildah | 促进对容器镜像执行广泛的操作 ([https://github.com/containers/buildah](https://github.com/containers/buildah))
    |'
- en: '| Podman | All-in-one management tool for pods, containers, and images ([https://github.com/containers/podman](https://github.com/containers/podman))
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Podman | Pod、容器和镜像的全能管理工具 ([https://github.com/containers/podman](https://github.com/containers/podman))
    |'
- en: '| CRI-O | OCI-based implementation of the Kubernetes Container Runtime Interface
    ([https://github.com/cri-o/cri-o](https://github.com/cri-o/cri-o)) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| CRI-O | 基于 OCI 的 Kubernetes 容器运行时接口实现 ([https://github.com/cri-o/cri-o](https://github.com/cri-o/cri-o))
    |'
- en: As you have already learned a great deal about Podman, you know now why it is
    included in this list. Podman is an excellent tool for understanding and developing
    containers as well as pods and images. It encapsulates everything Docker CLI does
    but without locking everything under one central daemon. Because Podman works
    without a daemon and uses the operating system for sharing data, other tools can
    work with the same data stores and libraries. The rest of this appendix describes
    the rest of the tools, starting with Skopeo (figure A.2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经学到了很多关于 Podman 的知识，你现在知道为什么它被包含在这个列表中。Podman 是一个理解和发展容器、Pod 和镜像的优秀工具。它封装了
    Docker CLI 所做的所有事情，但不需要将所有内容锁定在一个中央守护进程下。因为 Podman 无守护进程工作并使用操作系统共享数据，其他工具可以与相同的数据存储和库一起工作。本附录的其余部分描述了其余的工具，从
    Skopeo（图 A.2）开始。
- en: '![](../../OEBPS/Images/A-02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片 A-02](../../OEBPS/Images/A-02.png)'
- en: Figure A.2 Skopeo, Buildah, and Podman work together by sharing the same containers/storage
    images and containers/image library for pulling and pushing images.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.2 Skopeo、Buildah 和 Podman 通过共享相同的容器/存储镜像和容器/镜像库来协同工作，以拉取和推送镜像。
- en: A.1 Skopeo
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 Skopeo
- en: While using container engines like Docker or Podman, if you want to inspect
    a container image in a registry, you are required to pull this image from the
    registry to your local storage. Only then can you examine it. The problem is that
    this image can be huge, and after inspecting it, you might realize it wasn’t what
    you expected, and you wasted time pulling it. Because the protocol used to pull
    the image and inspect it is just a web protocol, a simple tool, Skopeo, was created
    to pull the image’s detailed information and display it on the screen. *Skopeo*
    is the Greek word for *remote viewing*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Docker 或 Podman 等容器引擎时，如果你想检查注册表中的容器镜像，你必须从注册表将其拉取到本地存储。只有在这种情况下，你才能检查它。问题是这个镜像可能非常大，在检查后，你可能会意识到它不是你预期的，你浪费了时间拉取它。因为用于拉取和检查镜像的协议只是一个网络协议，所以创建了一个简单的工具
    Skopeo 来拉取镜像的详细信息并在屏幕上显示。*Skopeo* 是希腊语中 *远程查看* 的意思。
- en: '![](../../OEBPS/Images/A-UN01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片 A-UN01.png]'
- en: 'Execute the following `skopeo` `inspect` command to examine an image’s detailed
    information in JSON form:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下 `skopeo` `inspect` 命令以以 JSON 格式检查镜像的详细信息：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Skopeo was extended to also copy images off of registries. Eventually, Skopeo
    became the tool for copying images between different types of storage (transports).
    These types of storage became the transports defined in table A.2.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Skopeo 被扩展以也能从注册表中复制镜像。最终，Skopeo 成为了在不同类型存储（传输）之间复制镜像的工具。这些存储类型成为了表 A.2 中定义的传输。
- en: Table A.2 Podman-supported transports
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.2 Podman 支持的传输方式
- en: '| Transport | Description |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 传输 | 描述 |'
- en: '| Container registry (`docker`) | This is the default transport. It references
    a container image stored in a remote container image registry website. Registries
    store and share container images (e.g., docker.io and quay.io). |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 容器注册表 (`docker`) | 这是默认的传输方式。它引用存储在远程容器镜像注册网站中的容器镜像。注册表存储和共享容器镜像（例如，docker.io
    和 quay.io）。 |'
- en: '| `oci` | References a container image; compliant with the Open Container Initiative
    Format specification. The manifest and layer tarballs are located in the local
    directory as individual files. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `oci` | 引用容器镜像；符合 Open Container Initiative 格式规范。清单和层 tarball 位于本地目录中作为单独的文件。
    |'
- en: '| `dir` | References a container image; compliant with the Docker image layout.
    It is very similar to the `oci` transport but stores the files using the legacy
    Docker format. As a non-standardized format, it is primarily useful for debugging
    or noninvasive container inspection. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `dir` | 引用符合 Docker 图像布局的容器图像。它与 `oci` 传输方式非常相似，但使用传统的 Docker 格式存储文件。作为一个非标准化格式，它主要用于调试或非侵入式容器检查。|'
- en: '| `docker-archive` | References a container image in a Docker image layout,
    which is packed into a TAR archive. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `docker-archive` | 引用打包在 TAR 归档中的 Docker 图像布局中的容器图像。|'
- en: '| `oci-archive` | References an image compliant with the Open Container Initiative
    Format specification, which is packed into a TAR archive. It is very similar to
    the `docker-archive` transport but stores an image in OCI format. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `oci-archive` | 引用符合 Open Container Initiative 格式规范的图像，该图像打包在 TAR 归档中。它与
    `docker-archive` 传输方式非常相似，但以 OCI 格式存储图像。|'
- en: '| `docker-daemon` | References an image stored in the Docker daemon’s internal
    storage. Since the Docker daemon requires root privileges, Podman has to be run
    by the root user. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `docker-daemon` | 引用存储在 Docker 守护进程内部存储中的图像。由于 Docker 守护进程需要 root 权限，Podman
    必须由 root 用户运行。|'
- en: '| `container-storage` | References an image located in a local container storage.
    It is not a transport but more of a mechanism for storing images. It can be used
    to convert other transports into `container-storage`. Podman defaults to using
    `container-storage` for local images. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `container-storage` | 引用位于本地容器存储中的图像。它不是一个传输方式，而是一种存储图像的机制。它可以用来将其他传输方式转换为
    `container-storage`。Podman 默认使用 `container-storage` 来存储本地图像。|'
- en: 'Other container engines and tools wanted to use the functionality developed
    in Skopeo to copy images, so Skopeo was split in two: the command line, Skopeo,
    and the underlying library, containers/image. Splitting functionality into a separate
    library made it possible to build other container tools, including Podman.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其他容器引擎和工具希望使用 Skopeo 中开发的复制图像的功能，因此 Skopeo 被拆分为两部分：命令行 Skopeo 和底层库 containers/image。将功能拆分为单独的库使得构建其他容器工具成为可能，包括
    Podman。
- en: 'The `skopeo` `copy` command is very popular for copying images between different
    types of container storage. One difference compared to Podman and Buildah, as
    you’ll see in section A.2, is that Skopeo forces users to specify the transport
    for the source and destination. Podman and Buildah default to using the `docker`
    or `containers-storage` transport, depending on the context and command. In the
    following example, you will copy an image from a container registry using the
    `docker` transport and store the image locally using the `container-storage` transport:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`skopeo` `copy` 命令在在不同类型的容器存储之间复制图像时非常受欢迎。与 Podman 和 Buildah 相比，一个不同之处在于，正如你在
    A.2 节中看到的，Skopeo 强制用户指定源和目的地的传输方式。Podman 和 Buildah 默认根据上下文和命令使用 `docker` 或 `containers-storage`
    传输方式。在以下示例中，你将使用 `docker` 传输方式从一个容器注册库复制图像，并使用 `container-storage` 传输方式将图像本地存储：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Another command many Skopeo users use is `skopeo` `sync`, which lets you synchronize
    images between container registries and local storage.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个许多 Skopeo 用户使用的命令是 `skopeo` `sync`，它允许你在容器注册库和本地存储之间同步图像。
- en: Skopeo is mainly used for infrastructure projects to help provision multiple
    container registries—for example, copying images from a public registry to a private
    one. Table A.3 describes the most popular commands used with Skopeo. One of the
    first tools to take advantage of the containers/image library was Buildah.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Skopeo 主要用于基础设施项目，以帮助配置多个容器注册库——例如，将公共注册库中的图像复制到私有注册库中。表 A.3 描述了与 Skopeo 一起使用的最常用命令。第一个利用
    containers/image 库的工具是 Buildah。
- en: Table A.3 Primary Skopeo commands and their description
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.3 Skopeo 主要命令及其描述
- en: '| Command | Description |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| `skopeo copy` | Copy an image (manifest, filesystem layers, or signatures)
    from one location to another. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `skopeo` `copy` | 从一个位置复制图像（清单、文件系统层或签名）到另一个位置。|'
- en: '| `skopeo` `delete` | Mark the image name for later deletion by the registry’s
    garbage collector. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `skopeo` `delete` | 标记图像名称，以便由注册库的垃圾收集器稍后删除。|'
- en: '| `skopeo` `inspect` | Return low-level information about an image name in
    a registry. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `skopeo` `inspect` | 返回关于注册库中图像名称的低级信息。|'
- en: '| `skopeo` `list-tags` | List tags in the transport-specific image repository.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `skopeo` `list-tags` | 列出特定传输图像存储库中的标签。|'
- en: '| `skopeo` `login` | Log in to a container registry (the same as `podman` `login`).
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `skopeo` `login` | 登录到容器注册库（与 `podman` `login` 相同）。|'
- en: '| `skopeo` `logout` | Log out of a container registry (the same as `podman`
    `logout`). |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `skopeo` `logout` | 从容器注册库登出（与 `podman logout` 相同）。 |'
- en: '| `skopeo` `manifest` `digest` | Compute a manifest digest for a manifest file,
    and write it to standard output. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `skopeo` `manifest` `digest` | 计算一个清单文件的清单摘要，并将其写入标准输出。 |'
- en: '| `skopeo` `sync` | Synchronize images between container registries and local
    directories. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `skopeo` `sync` | 在容器注册库和本地目录之间同步镜像。 |'
- en: A.2 Buildah
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 Buildah
- en: As you learned in section 1.1.2, creating a container image means creating a
    directory on disk and adding content to it to make it look like the root, `/`,
    directory on a Linux machine, called a rootfs. Originally, the only way to do
    this was with `docker` `build`, using a Dockerfile. While Dockerfiles and Containerfiles
    are excellent ways of creating recipes for your container images, a low-level
    building block tool that allowed other ways to build container images was needed—one
    that allowed breaking the image-build process into individual commands, letting
    you use other more powerful scripting tools and languages than Containerfile to
    build images. We created a tool called Buildah ([https://buildah.io](https://buildah.io))
    to serve this purpose.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 1.1.2 节中学到的，创建容器镜像意味着在磁盘上创建一个目录并向其中添加内容，使其看起来像 Linux 机器上的根目录 `/`，称为 rootfs。最初，完成这一点的唯一方法是通过
    `docker build` 使用 Dockerfile。虽然 Dockerfile 和 Containerfile 是创建容器镜像配方的好方法，但还需要一个低级别的构建块工具，允许以其他方式构建容器镜像——允许将镜像构建过程分解成单独的命令，让你可以使用比
    Containerfile 更强大的脚本工具和语言来构建镜像。我们创建了一个名为 Buildah 的工具 ([https://buildah.io](https://buildah.io))
    来满足这个目的。
- en: '![](../../OEBPS/Images/A-UN02.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/A-UN02.png)'
- en: Buildah was designed to be that simple tool for building container images. It’s
    built on top of the container/storage and container/image libraries, just like
    Podman and Skopeo. It has a lot of functionality similar to Podman. You can pull
    images, push images, commit images, and even run containers on images. What mainly
    differentiates Podman from Buildah is the underlying concept of a *container*.
    A Podman container is a long-lived one, a *running* container, while a Buildah
    container is just a temporary one, a *working* container, which will be used to
    create an OCI image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah 被设计成构建容器镜像的简单工具。它建立在容器存储和容器图像库之上，就像 Podman 和 Skopeo 一样。它具有许多与 Podman
    相似的功能。你可以拉取镜像、推送镜像、提交镜像，甚至可以在镜像上运行容器。Podman 与 Buildah 主要的区别在于其底层的 *容器* 概念。Podman
    容器是一个长期运行的容器，一个 *运行* 的容器，而 Buildah 容器只是一个临时的容器，一个 *工作* 的容器，它将被用来创建一个 OCI 镜像。
- en: Note Buildah is a Linux-only tool, not available on Mac or Windows. However,
    Podman embeds Buildah in the `podman` `build` command. Podman on Mac and Windows
    uses the Buildah code on the server side, allowing those platforms to build using
    Containerfiles and Dockerfiles. See appendixes E and F for more information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Buildah 是一个仅适用于 Linux 的工具，在 Mac 或 Windows 上不可用。然而，Podman 在 `podman build`
    命令中集成了 Buildah。Mac 和 Windows 上的 Podman 使用服务器端的 Buildah 代码，允许这些平台使用 Containerfiles
    和 Dockerfiles 进行构建。有关更多信息，请参阅附录 E 和 F。
- en: Buildah was designed to take the steps defined in a Dockerfile and make them
    available at the command line. Buildah wanted to simplify building a container
    image by allowing you to use all of the tools available within the OS to populate
    the image. You can add data to this directory via standard Linux tools, like `cp`,
    `make`, `yum` `install`, and so on. Then commit the rootfs into a tarball, add
    some JSON to describe what the creator of the image wanted the image to do, and
    finally, push this to a container registry. Basically, Buildah breaks down the
    steps you learned about in a Containerfile into individual commands you can execute
    from a shell.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah 是为了将 Dockerfile 中定义的步骤在命令行中可用而设计的。Buildah 希望通过允许你使用操作系统内所有可用的工具来填充镜像，从而简化容器镜像的构建过程。你可以通过标准
    Linux 工具，如 `cp`、`make`、`yum install` 等将数据添加到这个目录中。然后提交 rootfs 到一个 tarball 中，添加一些
    JSON 来描述镜像创建者希望镜像执行的操作，最后将这个 tarball 推送到容器注册库。基本上，Buildah 将你在 Containerfile 中学到的步骤分解成可以在
    shell 中执行的单独命令。
- en: Note The name *Buildah* is a play on the way I pronounce *builder*. If you ever
    heard me speak, you’d notice I have a strong Boston accent. When the core team
    asked what I wanted to call the tool, I said, “I don’t care, just call it *builder*.”
    And they heard *Buildah*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：名称 *Buildah* 是我对 *builder* 这个词发音的戏谑。如果你曾经听过我说话，你会注意到我有一个强烈的波士顿口音。当核心团队问我想要给这个工具起什么名字时，我说：“我不在乎，就叫它
    *builder* 吧。” 他们听成了 *Buildah*。
- en: The first step when building a new container image is pulling a base image.
    In a Containerfile, this is done with the `FROM` instruction.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构建新的容器镜像的第一步是拉取基础镜像。在 Containerfile 中，这是通过 `FROM` 指令完成的。
- en: A.2.1 Creating a working container from a base image
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 从基础镜像创建工作容器
- en: The first command to look at is `buildah` `from`. It is equivalent to the Containerfile’s
    `FROM` instruction. When executing `buildah` `from` `IMAGE`, it pulls the specified
    image from the container registry, saves it in a local container storage, and
    creates a working container based on this image. As mentioned previously, this
    container is similar to a Podman container, except it exists temporarily only
    to become a container image. In the following example, a working container is
    created based on an ubi8-init image.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要查看的命令是 `buildah from`。它等同于 Containerfile 的 `FROM` 指令。当执行 `buildah from IMAGE`
    时，它会从容器注册库中拉取指定的镜像，将其保存在本地容器存储中，并基于此镜像创建一个工作容器。如前所述，这个容器类似于 Podman 容器，但它只临时存在，以成为容器镜像。在以下示例中，基于
    ubi8-init 镜像创建了一个工作容器。
- en: Listing A.1 Buildah pulling an image and creating a Buildah container
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 附录 A.1 Buildah 拉取镜像并创建 Buildah 容器
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Pulls the image from the container registry
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从容器注册库拉取镜像
- en: ❷ Outputs a new container name
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出新的容器名称
- en: 'Notice that the `buildah` `from` output looks the same as the `podman` `pull`
    output, except for the last line, which outputs the container name: `ubi8-init-working-container`.
    If you run the `buildah` `from` command again, you get a second container name:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `buildah from` 的输出看起来与 `podman pull` 的输出相同，除了最后一行，它输出了容器名称：`ubi8-init-working-container`。如果您再次运行
    `buildah from` 命令，您将得到第二个容器名称：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Buildah keeps track of its containers and generates each one by incrementing
    a counter. Of course you can override the container name with the `--name` option.
    Next, you will add content to this container image.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah 会跟踪其容器，并通过递增计数器来生成每个容器。当然，您可以使用 `--name` 选项覆盖容器名称。接下来，您将向这个容器镜像添加内容。
- en: A.2.2 Adding data to a working container
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.2 向工作容器添加数据
- en: Buildah has two commands, `buildah` `copy` and `buildah` `add`, for copying
    the contents of a file, URL, or directory into the container’s working directory.
    They map to the same functionality as the Containerfile’s `COPY` and `ADD` instructions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah 有两个命令，`buildah copy` 和 `buildah add`，用于将文件、URL 或目录的内容复制到容器的当前工作目录。它们映射到
    Containerfile 的 `COPY` 和 `ADD` 指令的功能。
- en: Note It is somewhat confusing to have two commands that do almost the same thing.
    In most cases, I recommend you just use `buildah` `copy` and `COPY` inside a Containerfile.
    The main difference between the two is that `COPY` only copies local files and
    directories off of the host into the container image. The `add` command supports
    the use of URLs to pull remote content and insert it into your container. The
    `ADD` command also supports taking TAR and ZIP files and expanding them when copied
    into the container image.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有两个命令几乎做同样的事情，这可能会有些令人困惑。在大多数情况下，我建议您只使用 Containerfile 中的 `buildah copy`
    和 `COPY` 命令。这两个命令的主要区别在于 `COPY` 命令只将主机上的本地文件和目录复制到容器镜像中。`add` 命令支持使用 URL 拉取远程内容并将其插入到您的容器中。`ADD`
    命令还支持将 TAR 和 ZIP 文件复制到容器镜像中并展开它们。
- en: The syntax of the `buildah` `copy` command requires you to specify the name
    of the container previously created by the `buildah` `from` command, followed
    by the source and, optionally, destination. If the destination is not provided,
    source data will be copied into the container’s working directory. The destination
    directory will be created if it doesn’t exist yet.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildah copy` 命令的语法要求您指定由 `buildah from` 命令先前创建的容器名称，然后是源和（可选的）目标。如果没有提供目标，源数据将被复制到容器的当前工作目录。如果目标目录不存在，将会创建它。'
- en: 'The following example copies the local html/index.xhtml file (created previously
    in section 3.1) into the /var/lib/www/html directory in the container:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将本地 html/index.xhtml 文件（在 3.1 节中创建）复制到容器中的 /var/lib/www/html 目录：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you would like to use more advanced tools like package managers to add content
    to your containers, Buildah supports running commands inside the containers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用更高级的工具，如包管理器，向容器添加内容，Buildah 支持在容器内运行命令。
- en: A.2.3 Running commands in a working container
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.3 在工作容器中运行命令
- en: 'To run a command inside the working container, you need to execute `buildah`
    `run`. Under the hood, this command works exactly the same as the `RUN` instruction;
    it starts a new container on top of the current one, executes a specified command,
    and commits the result back to the working container. The syntax of `buildah`
    `run` requires you to specify the name of the working container followed by the
    command. In the following example, you install the `httpd` service within the
    container:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行中的容器内运行命令，你需要执行`buildah` `run`。在底层，这个命令与`RUN`指令的工作方式完全相同；它会在当前容器之上启动一个新的容器，执行指定的命令，并将结果提交回运行中的容器。`buildah`
    `run`的语法要求你指定运行中的容器名称，然后跟随着命令。在下面的示例中，你将在容器内安装`httpd`服务：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make sure you will have a running web server once the running container
    is created, the next command enables the Apache HTTP Server service:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在创建运行中的容器后，你将有一个正在运行的Web服务器，下一个命令将启用Apache HTTP服务器服务：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Table A.4 shows the relationship between Containerfile instructions and Buildah
    commands.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.4展示了Containerfile指令与Buildah命令之间的关系。
- en: Table A.4 Containerfile instructions mapped to Buildah commands
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表A.4 将Containerfile指令映射到Buildah命令
- en: '| Instruction | Command | Description |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 命令 | 描述 |'
- en: '| `ADD` | `buildah` `add` | Add the contents of a file, URL, or directory to
    the container. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `ADD` | `buildah` `add` | 将文件、URL或目录的内容添加到容器中。|'
- en: '| `COPY` | `buildah` `copy` | Copies the contents of a file, URL, or directory
    into a container’s working directory. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `COPY` | `buildah` `copy` | 将文件、URL或目录的内容复制到容器的运行目录中。|'
- en: '| `FROM` | `buildah` `from` | Creates a new working container, either from
    scratch or using a specified image as a starting point. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `FROM` | `buildah` `from` | 创建一个新的运行中的容器，要么从头开始，要么使用指定的镜像作为起点。|'
- en: '| `RUN` | `buildah` `run` | Runs a command inside the container. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `RUN` | `buildah` `run` | 在容器内运行命令。|'
- en: A.2.4 Adding content to a working container directly from the host
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.4 直接从宿主机向运行中的容器添加内容
- en: Up until now, you’ve seen how Buildah can perform the same commands you execute
    within a Containerfile, but one of Buildah’s goals is exposing the container image
    rootfs directly to the host. This allows you to use commands available on your
    host machine to add content to the container image, without requiring the commands
    to be present inside the container image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了Buildah如何执行与你在Containerfile中执行的相同命令，但Buildah的一个目标是将容器镜像的rootfs直接暴露给宿主机。这允许你使用宿主机上可用的命令向容器镜像添加内容，而无需在容器镜像内部存在这些命令。
- en: The `buildah` `mount` command allows you to mount a working container’s root
    filesystem directly on your system and then use tools like `cp`, `make`, `dnf`,
    or even an editor to manipulate the contents of the container’s rootfs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildah` `mount`命令允许你将运行中容器的根文件系统直接挂载到你的系统上，然后使用`cp`、`make`、`dnf`或甚至是一个编辑器来操作容器根文件系统的内容。'
- en: 'If you run Buildah as root, you can simply execute the `buildah` `mount` command.
    But in rootless mode, this isn’t allowed. Recall from section 2.2.10, where you
    learned about the `podman` `mount` command, that you must first enter the user
    namespace. Similarly, the `buildah` `unshare` command creates a shell running
    in the user namespace. Once you are in the user namespace, you can mount the container.
    In the following example, using what you have learned so far, you will use commands
    from your host’s operating system `grep` to add content to the container:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以root用户运行Buildah，你可以简单地执行`buildah` `mount`命令。但在无root模式下，这是不允许的。回想一下第2.2.10节，你学习了`podman`
    `mount`命令，你必须首先进入用户命名空间。同样，`buildah` `unshare`命令创建一个在用户命名空间中运行的shell。一旦你进入用户命名空间，你就可以挂载容器。在下面的示例中，使用你迄今为止所学的内容，你将使用宿主机的操作系统`grep`命令向容器添加内容：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you can check if your changes were actually applied inside a working container:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以检查你的更改是否实际上已应用于运行中的容器内部：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After you are done populating the content of the working container, it’s time
    to specify other instructions from the Containerfile. These will describe your
    intentions as the container image creator.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充运行中容器的内容完成后，现在是时候指定Containerfile中的其他指令了。这些指令将描述你作为容器镜像创建者的意图。
- en: A.2.5 Configuring a working container
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.5 配置运行中的容器
- en: You probably noticed in table A.3 that there are a lot of missing Containerfile
    instructions. Containerfile instructions like `LABEL`, `EXPOSE`, `WORKDIR`, `CMD`,
    and `ENTRYPOINT` are used to populate the OCI image specification.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能在表 A.3 中注意到有很多 Containerfile 指令缺失。`LABEL`、`EXPOSE`、`WORKDIR`、`CMD` 和 `ENTRYPOINT`
    等Containerfile指令用于填充 OCI 镜像规范。
- en: 'Now, using the `buildah` `config` command, you can add a port to expose (`EXPOSE`)
    and mark a location inside the container rootfs as a volume (`VOLUME`), which
    will be used as the website root directory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 `buildah config` 命令，您可以添加一个端口以暴露（`EXPOSE`）并标记容器根文件系统内的一个位置作为卷（`VOLUME`），该卷将用作网站根目录：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can inspect the corresponding OCI image specification fields using the
    `buildah` `inspect` command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `buildah inspect` 命令检查相应的 OCI 镜像规范字段：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Table A.4 shows the relationship between Containerfile instructions and Buildah
    config options. You can also refer to table A.5 for additional information on
    these instructions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.4 显示了 Containerfile 指令与 Buildah 配置选项之间的关系。您还可以参考表 A.5 以获取有关这些指令的更多信息。
- en: Table A.5 Containerfile instructions mapped to Buildah config options
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A.5 将 Containerfile 指令映射到 Buildah 配置选项
- en: '| Instruction | Option | Description |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 选项 | 描述 |'
- en: '| `MAINTAINER` | `--author` | Sets contact information of the image author
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `MAINTAINER` | `--author` | 设置镜像作者的联系方式 |'
- en: '| `CMD` | `--cmd` | Sets a default command to run within a container |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `CMD` | `--cmd` | 设置在容器内运行的默认命令 |'
- en: '| `ENTRYPOINT` | `--entrypoint` | Sets a command for a container that will
    run as an executable |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `ENTRYPOINT` | `--entrypoint` | 为将在容器中运行的可执行文件设置命令 |'
- en: '| `ENV` | `--env` | Sets the environment variable for all subsequent instructions
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `ENV` | `--env` | 为所有后续指令设置环境变量 |'
- en: '| `HEALTHCHECK` | `--healthcheck` | Specifies a command to check if a container
    is still running |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `HEALTHCHECK` | `--healthcheck` | 指定一个命令以检查容器是否仍在运行 |'
- en: '| `LABEL` | `--label` | Adds key-value metadata |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `LABEL` | `--label` | 添加键值元数据 |'
- en: '| `ONBUILD` | `--onbuild` | Sets a command to be run when the image is used
    as the base for another image |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `ONBUILD` | `--onbuild` | 设置当镜像用作其他镜像的基础时运行的命令 |'
- en: '| `EXPOSE` | `--port` | Specifies a port that the container will listen on
    at run time |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `EXPOSE` | `--port` | 指定容器在运行时将监听的端口 |'
- en: '| `STOPSIGNAL` | `--stop-signal` | Sets the stop signal to be sent when the
    container is stopped |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `STOPSIGNAL` | `--stop-signal` | 设置在容器停止时发送的停止信号 |'
- en: '| `USER` | `--user` | Sets the user to be used when running the container and
    for all subsequent `RUN`, `CMD`, and `ENTRYPOINT` instructions |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `USER` | `--user` | 设置运行容器时以及所有后续的 `RUN`、`CMD` 和 `ENTRYPOINT` 指令所使用的用户 |'
- en: '| `VOLUME` | `--volume` | Adds a mount point and marks it as a volume for external
    data |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `VOLUME` | `--volume` | 为外部数据添加挂载点并将其标记为卷 |'
- en: '| `WORKDIR` | `--workingdir` | Sets the working directory for all subsequent
    `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` instructions |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `WORKDIR` | `--workingdir` | 为所有后续的 `RUN`、`CMD`、`ENTRYPOINT`、`COPY` 和 `ADD`
    指令设置工作目录 |'
- en: Once you have finished adding content to the Buildah container image and adding
    configuration to the OCI image specification, you need to create an image from
    the working container.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完成向 Buildah 容器镜像添加内容以及向 OCI 镜像规范添加配置后，您需要从工作容器创建镜像。
- en: A.2.6 Creating an image from a working container
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.6 从工作容器创建镜像
- en: 'The working container you’ve been building so far can be used to create the
    OCI-compliant image using the `buildah` `commit` command. This command works in
    the same way as the `podman` `commit` command you learned about in section 2.1.9\.
    Inputs for this command are the working container name and an optional image tag;
    if a tag is not specified, the image will have no name:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您到目前为止一直在构建的工作容器可以使用 `buildah commit` 命令创建符合 OCI 规范的镜像。此命令与您在 2.1.9 节中学习的 `podman
    commit` 命令的工作方式相同。此命令的输入是工作容器名称和一个可选的镜像标签；如果没有指定标签，则镜像将没有名称：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see the image using `buildah` `images`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `buildah images` 查看镜像：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because Podman and Buildah share the same container image storage, you can
    see the same images with `podman` `images`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Podman 和 Buildah 共享相同的容器镜像存储，您可以使用 `podman images` 看到相同的镜像：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can even run a Podman container on the image:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以在镜像上运行 Podman 容器：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A.2.7 Pushing an image to a container registry
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.7 将镜像推送到容器注册库
- en: 'Similarly to Podman, Buildah has the `buildah` `login` and `buildah` `push`
    commands, which allow you to push images to container registries, as shown in
    the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Podman 类似，Buildah 有 `buildah` `login` 和 `buildah` `push` 命令，这些命令允许您将镜像推送到容器注册库，如下面的示例所示：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note You can also use `podman` `login` and `podman` `push` or even `skopeo`
    `login` and `skopeo` `copy` to accomplish the same task.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您也可以使用 `podman` `login` 和 `podman` `push` 或甚至 `skopeo` `login` 和 `skopeo`
    `copy` 来完成相同任务。
- en: Congratulations! You have successfully built an OCI-compliant container image
    manually by using simple shell commands rather than using a Containerfile. Additionally,
    if you want to create an image using an existing Containerfile or Dockerfile,
    you can use the `buildah` `build` command.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功手动构建了一个符合 OCI 标准的容器镜像，而不是使用 Containerfile。此外，如果您想使用现有的 Containerfile
    或 Dockerfile 创建镜像，可以使用 `buildah` `build` 命令。
- en: A.2.8 Building an image from Containerfiles
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.8 从 Containerfiles 构建镜像
- en: 'You can use the `buildah` `build` command to build an OCI-compliant image from
    a Containerfile or a Dockerfile. Buildah includes a parser that understands the
    Containerfile format and can perform all tasks using previously described commands
    automatically. In the next example, use the Containerfile from section 2.3.2:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `buildah` `build` 命令从 Containerfile 或 Dockerfile 构建一个符合 OCI 标准的镜像。Buildah
    包含一个解析器，它理解 Containerfile 格式，并可以使用之前描述的命令自动执行所有任务。在下一个示例中，使用第 2.3.2 节中的 Containerfile：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can build your container image using this Containerfile by executing the
    following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令使用此 Containerfile 构建您的容器镜像：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You’ve probably noticed that this output matches precisely the output of the
    `podman` `build` command. This is because the `podman` `build` command uses Buildah.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，这个输出与 `podman` `build` 命令的输出完全匹配。这是因为 `podman` `build` 命令使用了 Buildah。
- en: A.2.9 Buildah as a library
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.9 Buildah 作为库
- en: Buildah was designed to not only be used as a command-line tool but also to
    be a Golang-based library. Buildah is being used in a few different tools, such
    as Podman and the OpenShift image builder. Buildah allows these tools to internally
    build OCI images. Every time you do a `podman` `build`, you are executing the
    Buildah library code. Having learned how to build container images using Buildah,
    copy images between container storages using Skopeo, and manage and run containers
    on the host using Podman, let’s talk about how all these tools are used in the
    Kubernetes ecosystem.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah 被设计成不仅可以用作命令行工具，还可以用作基于 Golang 的库。Buildah 被用于几个不同的工具中，例如 Podman 和 OpenShift
    镜像构建器。Buildah 允许这些工具内部构建 OCI 镜像。每次您执行 `podman` `build` 时，您都在执行 Buildah 库代码。在学会了如何使用
    Buildah 构建容器镜像、使用 Skopeo 在容器存储之间复制镜像以及使用 Podman 在主机上管理和运行容器之后，让我们来谈谈这些工具如何在 Kubernetes
    生态系统中使用。
- en: 'A.3 CRI-O: Container Runtime Interface for OCI containers'
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 CRI-O：OCI 容器的容器运行时接口
- en: When Kubernetes was being developed, it used the Docker API internally to run
    containers. Kubernetes relied on features of Docker that changed from release
    to release, sometimes breaking Kubernetes. At the same time, CoreOS wanted their
    alternative container engine, called RKT ([https://github.com/rkt/rkt](https://github.com/rkt/rkt)),
    to work with Kubernetes. Kubernetes developers decided, then, to split out the
    Docker functionality and use a new API called the Container Runtime Interface
    (CRI; [http://mng.bz/yaDq](http://mng.bz/yaDq)). This interface allows Kubernetes
    to use other container engines in addition to Docker.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Kubernetes 正在开发时，它使用 Docker API 内部运行容器。Kubernetes 依赖于 Docker 从一个版本到另一个版本变化的特性，有时会破坏
    Kubernetes。同时，CoreOS 想要他们的替代容器引擎，称为 RKT ([https://github.com/rkt/rkt](https://github.com/rkt/rkt))，与
    Kubernetes 一起工作。Kubernetes 开发者决定，然后，将 Docker 功能拆分出来并使用一个新的 API，称为容器运行时接口 (CRI；[http://mng.bz/yaDq](http://mng.bz/yaDq))。此接口允许
    Kubernetes 使用除了 Docker 之外的其他容器引擎。
- en: When Kubernetes wants to pull a container image, it calls out to a remote socket
    via the CRI and asks the listener to pull an OCI image for it. When it wants to
    launch a Pod/Container, it calls out to the socket and asks it to launch the container.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Kubernetes 想要拉取一个容器镜像时，它会通过 CRI 调用一个远程套接字，并要求监听器为它拉取一个 OCI 镜像。当它想要启动一个 Pod/容器时，它会调用套接字并要求启动容器。
- en: Note CoreOS was eventually acquired by Red Hat, and the RKT project has ended.
    Kubernetes has deprecated Docker as a container runtime.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：CoreOS 最终被 Red Hat 收购，RKT 项目已结束。Kubernetes 已弃用 Docker 作为容器运行时。
- en: Red Hat saw the CRI as an opportunity to develop a new container engine, which
    they ended up calling the Container Runtime Interface for OCI containers (CRI-O;
    [https://cri-o.io/](https://cri-o.io/)). CRI-O is based on the same containers/storage
    and containers/image libraries as Skopeo, Buildah, and Podman and can be used
    in conjunction with these tools. CRI-O’s primary objective is replacing the Docker
    service as the container engine for Kubernetes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat将CRI视为开发新容器引擎的机会，他们最终将其称为OCI容器容器运行时接口（CRI-O；[https://cri-o.io/](https://cri-o.io/)）。CRI-O基于与Skopeo、Buildah和Podman相同的容器/storage和容器/image库，可以与这些工具一起使用。CRI-O的主要目标是取代Docker服务作为Kubernetes的容器引擎。
- en: '![](../../OEBPS/Images/A-UN03.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/A-UN03.png)'
- en: CRI-O is tied to Kubernetes releases. When a new version of Kubernetes is released,
    the version numbers are synchronized. CRI-O is optimized for Kubernetes workloads;
    the engineers working on it understand what Kubernetes is trying to do and are
    making sure CRI-O does it in the most efficient way possible. Since CRI-O has
    no other users, Kubernetes doesn’t have to worry about breaking changes in CRI-O.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: CRI-O与Kubernetes版本绑定。当发布新的Kubernetes版本时，版本号会同步。CRI-O针对Kubernetes工作负载进行了优化；从事该工作的工程师了解Kubernetes试图做什么，并确保CRI-O以最有效的方式完成。由于CRI-O没有其他用户，Kubernetes不必担心CRI-O中的破坏性更改。
- en: Note CRI-O is the core technology used with Red Hat’s OpenShift Kubernetes-based
    product. OpenShift uses Podman to install and configure CRI-O before Kubernetes
    starts running. The OpenShift image builder embeds Buildah functionality to allow
    users to build images within their OpenShift clusters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CRI-O是Red Hat的基于OpenShift Kubernetes产品的核心技术。OpenShift在Kubernetes开始运行之前使用Podman来安装和配置CRI-O。OpenShift镜像构建器集成了Buildah功能，使用户能够在他们的OpenShift集群内构建镜像。
