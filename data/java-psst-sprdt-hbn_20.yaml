- en: 16 Working with Spring Data REST
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 使用 Spring Data REST 工作环境
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing REST applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 REST 应用程序
- en: Creating a Spring Data REST application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Spring Data REST 应用程序
- en: Using ETags for conditional requests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ETags 进行条件请求
- en: Limiting access to repositories, methods, and fields
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制对存储库、方法和字段的访问
- en: Working with REST events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 REST 事件进行工作
- en: Using projections and excerpts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用投影和摘录
- en: '*Representational state transfer* (REST) is a software architectural style
    for creating web services; it also provides a set of constraints. The American
    computer scientist Roy Fielding, who is also one of the authors of the HTTP specification,
    first defined REST, presenting the REST principles in his PhD dissertation (Fielding,
    2000). Web services following this REST architectural style are called *RESTful
    web services*, and they allow interoperability between the internet and computer
    systems. Requesting systems can access and manipulate web resources represented
    as text using a well-known set of stateless operations (`GET`, `POST`, `PUT`,
    `PATCH`, `DELETE`). A stateless operation does not depend on any other prior operation;
    it must contain all the information needed to be understood by the server.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*表征状态转移*（REST）是创建网络服务的软件架构风格；它还提供了一套约束。美国计算机科学家罗伊·菲尔丁（Roy Fielding），也是HTTP规范的作者之一，首先定义了REST，在他的博士论文中提出了REST原则（Fielding，2000）。遵循此REST架构风格的服务称为*RESTful网络服务*，它们允许互联网和计算机系统之间的互操作性。请求系统可以使用一组众所周知的无状态操作（`GET`、`POST`、`PUT`、`PATCH`、`DELETE`）来访问和操作表示为文本的网络资源。无状态操作不依赖于任何其他先前操作；它必须包含所有必要的信息，以便服务器理解。'
- en: 16.1 Introducing REST applications
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 介绍 REST 应用程序
- en: We will first define the terms *client* and *resource* to describe what makes
    an API RESTful. A *client* is a person or software using the RESTful API. For
    example, a programmer using a RESTful API to execute actions against the LinkedIn
    website is a client, but the client can also be a web browser. When we go to the
    LinkedIn website, our browser is the client that calls the website API and that
    displays the obtained information on the screen. A *resource* can be any object
    about which the API can obtain information. In the LinkedIn API, a resource can
    be a message, a photo, or a user. Each resource has a unique identifier.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义术语*客户端*和*资源*来描述使API成为RESTful的因素。*客户端*是使用RESTful API的人或软件。例如，使用RESTful
    API对领英网站执行操作的程序员是客户端，但客户端也可以是网页浏览器。当我们访问领英网站时，我们的浏览器是调用网站API并在屏幕上显示获取信息的客户端。*资源*可以是API可以获取信息的任何对象。在领英API中，资源可以是消息、照片或用户。每个资源都有一个唯一的标识符。
- en: 'The REST architecture style defines six constraints ([https://restfulapi.net/rest-architectural-constraints/](https://restfulapi.net/rest-architectural-constraints/)):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 'REST架构风格定义了六个约束（[https://restfulapi.net/rest-architectural-constraints/](https://restfulapi.net/rest-architectural-constraints/））:'
- en: '*Client-server—*Clients are separated from servers, and each has its own concerns.
    Most frequently, a client is concerned with the representation of the user, and
    a server is concerned with data storage and domain model logic—the conceptual
    model of a domain including data and behavior.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端-服务器—*客户端与服务器分离，各自有其关注点。最常见的是，客户端关注用户表示，而服务器关注数据存储和领域模型逻辑——包括数据和行为的领域概念模型。'
- en: '*Stateless—*The server does not keep any information about the client between
    requests. Each request from a client contains all of the information necessary
    to respond to that request. The client keeps the state on its side.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无状态—*服务器在请求之间不保留任何关于客户端的信息。每个客户端的请求都包含响应该请求所需的所有信息。客户端在其一侧保持状态。'
- en: '*Uniform interface—*The client and the server may evolve independently of each
    other. The uniform interface between them makes them loosely coupled.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*统一接口—*客户端和服务器可以独立于彼此进行演化。它们之间的统一接口使得它们松散耦合。'
- en: '*Layered systems—*The client does not have any way to determine if it is interacting
    directly with the server or with an intermediary. Layers can be dynamically added
    and removed. They can provide security, load balancing, or shared caching.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分层系统—*客户端没有方法来确定它是否直接与服务器或中介交互。层可以动态添加和移除。它们可以提供安全性、负载均衡或共享缓存。'
- en: '*Cacheable—*Clients are able to cache responses. Responses define themselves
    as cacheable or not.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可缓存—*客户端能够缓存响应。响应定义自己是否可缓存。'
- en: '*Code on demand (optional)—*Servers are able to temporarily customize or extend
    the functionality of a client. The server can transfer some logic to the client
    that the client can execute, such as JavaScript client-side scripts.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码按需（可选）—*服务器能够暂时自定义或扩展客户端的功能。服务器可以将一些逻辑传输到客户端，客户端可以执行这些逻辑，例如 JavaScript 客户端脚本。'
- en: A RESTful web application provides information about its resources, which are
    identified with the help of URLs. The client can execute actions against such
    a resource; it can create, read, update, or delete a resource.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful 网络应用程序提供有关其资源的信息，这些资源通过 URL 进行标识。客户端可以针对此类资源执行操作；它可以创建、读取、更新或删除资源。
- en: The REST architectural style is not protocol-specific, but the most widely used
    protocol is REST over HTTP. HTTP is a synchronous application network protocol
    based on requests and responses.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: REST 架构风格不是特定于协议的，但最广泛使用的协议是 HTTP 上的 REST。HTTP 是基于请求和响应的同步应用程序网络协议。
- en: To make our API RESTful, we have to follow a set of rules while developing it.
    A RESTful API will transfer information to the client, which uses that information
    as a representation of the state of the accessed resource. For example, when we
    call the LinkedIn API to access a specific user, the API will return the state
    of that user (name, biography, professional experience, posts). The REST rules
    make the API easier to understand and simpler for new programmers to use when
    they join a team.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的 API 成为 RESTful，我们必须在开发时遵循一系列规则。RESTful API 将将信息传输到客户端，客户端使用这些信息作为访问资源的状态的表示。例如，当我们调用
    LinkedIn API 来访问特定用户时，API 将返回该用户的状态（姓名、传记、职业经验、帖子）。REST 规则使 API 更易于理解，对于新加入团队的程序员来说更简单易用。
- en: 'The representation of the state can be in JSON, XML, or HTML format. The client
    uses the API to send the following information to the server:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的表示可以是 JSON、XML 或 HTML 格式。客户端使用 API 向服务器发送以下信息：
- en: The identifier (URL) of the resource we want to access.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要访问的资源标识符（URL）。
- en: The operation we want the server to perform on that resource. This is an HTTP
    method, the most common of which are `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要服务器对该资源执行的操作。这是一个 HTTP 方法，其中最常见的是 `GET`、`POST`、`PUT`、`PATCH` 和 `DELETE`。
- en: For example, using the LinkedIn RESTful API to fetch a specific LinkedIn user
    requires that we have a URL that identifies the user and that we use the HTTP
    method `GET`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 LinkedIn RESTful API 获取特定 LinkedIn 用户需要我们有一个标识用户的 URL，并使用 HTTP 方法 `GET`。
- en: 16.2 Creating a Spring Data REST application
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 创建 Spring Data REST 应用程序
- en: 'Our first goal is to create a Spring Data REST application that will provide
    a browser interface to interact with the database and to manage and persist CaveatEmptor
    users. To do this, we’ll access the Spring Initializr website ([https://start.spring.io/](https://start.spring.io/))
    and create a new Spring Boot project (figure 16.1), having the following characteristics:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要目标是创建一个 Spring Data REST 应用程序，该程序将提供一个浏览器界面来与数据库交互，并管理持久化 CaveatEmptor
    用户。为此，我们将访问 Spring Initializr 网站 ([https://start.spring.io/](https://start.spring.io/))
    并创建一个新的 Spring Boot 项目（图 16.1），具有以下特性：
- en: 'Group: com.manning.javapersistence'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：com.manning.javapersistence
- en: 'Artifact: spring-data-rest'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件包：spring-data-rest
- en: 'Description: Spring Data REST'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：Spring Data REST
- en: '![](../../OEBPS/Images/CH16_F01_Tudose2.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH16_F01_Tudose2.png)'
- en: Figure 16.1 Creating a new Spring Boot project using Spring Data REST and MySQL
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 使用 Spring Data REST 和 MySQL 创建新的 Spring Boot 项目
- en: 'We’ll also add the following dependencies:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加以下依赖项：
- en: Spring Web (this will add `spring-boot-starter-web` in the Maven pom.xml file)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Web (这将在 Maven pom.xml 文件中添加 `spring-boot-starter-web`)
- en: Spring Data JPA (this will add `spring-boot-starter-data-jpa` in the Maven pom.xml
    file)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JPA (这将在 Maven pom.xml 文件中添加 `spring-boot-starter-data-jpa`)
- en: REST Repositories (this will add `spring-boot-starter-data-rest` in the Maven
    pom.xml file)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 仓库（这将在 Maven pom.xml 文件中添加 `spring-boot-starter-data-rest`)
- en: MySQL Driver (this will add `mysql-connector-java` in the Maven pom.xml file)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 驱动程序（这将在 Maven pom.xml 文件中添加 `mysql-connector-java`)
- en: Note To execute the examples from the source code, you’ll first need to run
    the Ch16.sql script.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要执行源代码中的示例，您首先需要运行 Ch16.sql 脚本。
- en: The pom.xml file in the following listing includes the dependencies we added
    to start the Spring Data REST project. This Spring Data REST application will
    access a MySQL database, so we need the driver.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的 pom.xml 文件包括了启动 Spring Data REST 项目时我们添加的依赖项。这个 Spring Data REST 应用程序将访问一个
    MySQL 数据库，因此我们需要驱动程序。
- en: Listing 16.1 The pom.xml Maven file
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.1 `pom.xml` Maven 文件
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ⓐ `spring-boot-starter-web` is the starter dependency used by Spring Boot to
    build web applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `spring-boot-starter-web` 是 Spring Boot 用于构建 Web 应用程序的启动依赖项。
- en: Ⓑ `spring-boot-starter-data-jpa` is the starter dependency used by Spring Boot
    to connect to a relational database through Spring Data JPA.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `spring-boot-starter-data-jpa` 是 Spring Boot 用于通过 Spring Data JPA 连接到关系型数据库的启动依赖项。
- en: Ⓒ `spring-boot-starter-data-rest` is the starter dependency used by Spring Boot
    for Spring Data REST applications.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `spring-boot-starter-data-rest` 是 Spring Boot 用于 Spring Data REST 应用程序的启动依赖项。
- en: Ⓓ `mysql-connector-java` is the JDBC driver for MySQL. It is a runtime dependency,
    so it is needed in the classpath only at runtime.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `mysql-connector-java` 是 MySQL 的 JDBC 驱动程序。它是一个运行时依赖项，因此仅在运行时需要在类路径中。
- en: The next step is to fill in the Spring Boot application.properties file, which
    can include various properties to be used by the application. Spring Boot will
    automatically find and load the application.properties file from the classpath—the
    src/main/ resources folder is added by Maven to the classpath.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是填写 Spring Boot 的 `application.properties` 文件，该文件可以包含应用程序将使用的各种属性。Spring
    Boot 将自动从类路径中查找并加载 `application.properties` 文件——Maven 将 `src/main/resources` 文件夹添加到类路径中。
- en: There are several ways to provide parameters in a Spring Boot application, and
    the .properties file is just one of them. Parameters can also come from the source
    code or as command-line arguments—see the Spring Boot documentation for details.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spring Boot 应用程序中提供参数有几种方式，.properties 文件只是其中之一。参数也可以来自源代码或作为命令行参数——有关详细信息，请参阅
    Spring Boot 文档。
- en: For our application, the application.properties configuration file will look
    like the following listing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，`application.properties` 配置文件将如下所示。
- en: Listing 16.2 The application.properties file
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.2 `application.properties` 文件
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ The application will start on port 8081.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 应用程序将在端口 8081 上启动。
- en: Ⓑ The URL of the database.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 数据库的 URL。
- en: Ⓒ The credentials to access the database. Replace them with the credentials
    on your machine, and use a password in real life.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 访问数据库的凭证。将它们替换为您的机器上的凭证，并在实际生活中使用密码。
- en: Ⓓ The dialect of the database, MySQL.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 数据库的方言是 MySQL。
- en: Ⓔ Show the SQL queries when they are executed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 在它们执行时显示 SQL 查询。
- en: Ⓕ Recreate the tables for each execution of the application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 在每次应用程序执行时重新创建表。
- en: The `User` class will now contain a `@Version` annotated field. As discussed
    in section 11.2.2, the field value is incremented whenever a modified `User` instance
    has been persisted. Section 16.3 will demonstrate how this field can be used for
    conditional REST requests using ETags.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 类现在将包含一个由 `@Version` 注解的字段。如第 11.2.2 节所述，每当修改后的 `User` 实例被持久化时，字段值都会递增。第
    16.3 节将演示如何使用此字段通过 ETags 进行条件 REST 请求。'
- en: Listing 16.3 The modified `User` class
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.3 修改后的 `User` 类
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Users will participate in an auction that is represented by the `Auction` class.
    An auction is described by the `auctionNumber`, the number of `seats`, and the
    set of `users`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将参与由 `Auction` 类表示的拍卖。拍卖由 `auctionNumber`、`seats` 的数量和 `users` 集合来描述。
- en: Listing 16.4 The `Auction` class
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.4 `Auction` 类
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The users participating in the auction will be read from a CSV file, in the
    `CsvDataLoader` class. We’ll use the `@Bean` annotation to create a bean that
    will be managed and injected into the application by Spring.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 参与拍卖的用户将从 CSV 文件中读取，在 `CsvDataLoader` 类中。我们将使用 `@Bean` 注解创建一个 Bean，该 Bean 将由
    Spring 管理并注入到应用程序中。
- en: Listing 16.5 The `CsvDataLoader` class
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.5 `CsvDataLoader` 类
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ⓐ The result of the method will be a bean managed by Spring.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 方法的结果将是一个由 Spring 管理的 Bean。
- en: Ⓑ Create the `Auction` object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 创建 `Auction` 对象。
- en: Ⓒ Use the information from the CSV file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 使用 CSV 文件中的信息。
- en: Ⓓ Read line by line.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 逐行读取。
- en: Ⓔ Create the user from the read information, configure it, and add it to the
    auction.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 从读取的信息中创建用户，配置它，并将其添加到拍卖中。
- en: Ⓕ Return the `Auction` bean.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 返回 `Auction` Bean。
- en: The `UserRepository` interface extends `JpaRepository<User, Long>`, inheriting
    the JPA-related methods and managing the `User` entity, having IDs of type `Long`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRepository` 接口扩展了 `JpaRepository<User, Long>`，继承了 JPA 相关的方法，并管理 `User`
    实体，具有 `Long` 类型的 ID。'
- en: Listing 16.6 The `UserRepository` interface
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.6 `UserRepository` 接口
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Spring Boot application will import the bean created in the `CsvDataLoader`
    class and autowire it. It will also create a bean of type `ApplicationRunner`.
    This is a Spring Boot functional interface (an interface with a single abstract
    method) that gives access to application arguments. This `ApplicationRunner` interface
    is created, and its single method is executed, just before the `run()` method
    from `SpringApplication` completes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot应用程序将导入在`CsvDataLoader`类中创建的bean，并自动装配它。它还将创建一个类型为`ApplicationRunner`的bean。这是一个Spring
    Boot功能接口（一个只有一个抽象方法的接口），它提供了访问应用程序参数的权限。这个`ApplicationRunner`接口被创建，并且它的单个方法将在`SpringApplication`的`run()`方法完成之前执行。
- en: Listing 16.7 The `Application` class
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.7 `Application`类
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ⓐ Import the `CsvDataLoader` class and the `Auction` bean it creates.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 导入`CsvDataLoader`类及其创建的`Auction` bean。
- en: Ⓑ Autowire the imported `Auction` bean.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 自动装配导入的`Auction` bean。
- en: Ⓒ Browse all users from the auction, and save them in the repository.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 浏览拍卖中的所有用户，并将它们保存到仓库中。
- en: We can access the Spring Data REST application in the browser (http://localhost:8081/
    users) as shown in figure 16.2\. We get the information about users and the option
    to easily navigate between the records. Spring Data REST will expose information
    about the API to be accessed, providing links to each record.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在浏览器中访问Spring Data REST应用程序（http://localhost:8081/users），如图16.2所示。我们可以获取用户信息，并轻松地在记录之间导航。Spring
    Data REST将公开要访问的API信息，并为每个记录提供链接。
- en: '![](../../OEBPS/Images/CH16_F02_Tudose2.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH16_F02_Tudose2.png)'
- en: Figure 16.2 Accessing the Spring Data REST application from the browser
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 从浏览器访问Spring Data REST应用程序
- en: 'We can test this REST API endpoint using a REST client. IntelliJ IDEA Ultimate
    edition provides such a REST client, but you can use a different client (such
    as cURL or Postman). We can execute commands like the following (see figure 16.3):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用REST客户端测试这个REST API端点。IntelliJ IDEA Ultimate版提供了一个这样的REST客户端，但您也可以使用不同的客户端（如cURL或Postman）。我们可以执行以下命令（见图16.3）：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../../OEBPS/Images/CH16_F03_Tudose2.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH16_F03_Tudose2.png)'
- en: Figure 16.3 The result of executing the `GET` `http://localhost:8081/users/1`
    command in the IntelliJ IDEA Ultimate edition REST client
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 在IntelliJ IDEA Ultimate版REST客户端中执行`GET http://localhost:8081/users/1`命令的结果
- en: 16.3 Using ETags for conditional requests
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 使用ETags进行条件请求
- en: Any exchange of information across the network requires time. The smaller the
    information is, the quicker our program will work. But when and how can we reduce
    the amount of information retrieved from the server and transferred across the
    network?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的任何信息交换都需要时间。信息越小，我们的程序运行得越快。但何时以及如何减少从服务器检索和通过网络传输的信息量呢？
- en: 'Suppose we need to execute a command such as the following one multiple times:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要多次执行如下命令：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll access the server each time, and the same information will be sent across
    the network. This is inefficient, and we’d like to limit the amount of data exchanged
    between the client and server.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每次访问服务器，并将相同的信息发送到网络。这是低效的，我们希望限制客户端和服务器之间交换的数据量。
- en: We can use ETags to make conditional requests and avoid sending information
    that has not changed. An ETag is an HTTP response header returned by a web server.
    It will help us determine if the content at a given URL has been modified, and
    consequently allow us to make a conditional request.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用ETags进行条件请求，避免发送未更改的信息。ETag是Web服务器返回的HTTP响应头。它将帮助我们确定给定URL的内容是否已修改，从而允许我们进行条件请求。
- en: 'In the `User` class, there is a field annotated with the `@Version` annotation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`User`类中，有一个被`@Version`注解的字段：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This field will also be used as an ETag. When we execute this request to the
    server,
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段也将用作ETag。当我们向服务器执行此请求时，
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'the answer will include, on the header, the version of the record (0), as an
    ETag (see figure 16.4):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 答案将在头部包含记录的版本（0），作为ETag（见图16.4）：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../../OEBPS/Images/CH16_F04_Tudose2.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH16_F04_Tudose2.png)'
- en: Figure 16.4 The server’s answer, including the ETag on the header, representing
    the entity version
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 服务器的回答，包括头部上的ETag，表示实体版本
- en: Using this information, we can now execute a conditional request and get the
    information about the user with ID 1 only if the ETag is different than 0.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，我们现在可以执行一个条件请求，并且只有当ETag与0不同时，才能获取ID为1的用户信息。
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The answer from the server will be the 304 (Not Modified) response code, together
    with an empty body (see figure 16.5):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应将是304（未修改）响应代码，以及一个空正文（见图16.5）：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../../OEBPS/Images/CH16_F05_Tudose2.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH16_F05_Tudose2.png)'
- en: Figure 16.5 The server’s answer for a record matching the existing ETag does
    not have a body.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 对于匹配现有ETag的记录，服务器响应没有正文。
- en: We can now modify the content from the user with ID 1, executing a `PATCH` command.
    We use a `PATCH` instead of a `PUT`, as `PATCH` will update only the fields that
    are included in the request, whereas `PUT` will replace an entire entity with
    a new one.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以修改ID为1的用户的内 容，执行一个`PATCH`命令。我们使用`PATCH`而不是`PUT`，因为`PATCH`只会更新请求中包含的字段，而`PUT`将用新的实体替换整个实体。
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The answer from the server will be 204 (No Content) success response code,
    and the ETag will be the increased version of the record (1) (see figure 16.6):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应将是204（无内容）成功响应代码，ETag将是记录增加的版本（1）（见图16.6）：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../../OEBPS/Images/CH16_F06_Tudose2.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH16_F06_Tudose2.png)'
- en: Figure 16.6 The server’s answer after patching a user increases the ETag to
    1.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 修复用户后，服务器响应将ETag增加到1。
- en: 'We can now re-execute the conditional request, to get the information about
    user with ID 1 only if the ETag is different from 0:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新执行条件请求，以获取ID为1的用户的详细信息，前提是ETag与0不同：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As the version of the record was changed from 0 to 1, the conditional request
    will get an answer with the 200 (Success) response code and the full information
    about the user (see figure 16.7):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于记录的版本已从0更改为1，条件请求将获得带有200（成功）响应代码和用户全部信息的响应（见图16.7）：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../../OEBPS/Images/CH16_F07_Tudose2.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH16_F07_Tudose2.png)'
- en: Figure 16.7 The server’s answer includes the full information about the user,
    with the ETag changed from 0 to 1.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 服务器响应包括关于用户的全部信息，ETag从0变为1。
- en: 16.4 Limiting access to repositories, methods, and fields
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 限制对存储库、方法和字段的访问
- en: Spring Data REST will export all public top-level repository interfaces by default.
    But real-world use cases will frequently require limiting access to particular
    methods, fields, or even whole repositories. We can use the `@RepositoryRestResource`
    annotation to block an *interface* from being exported or to customize access
    to an endpoint.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data REST默认将所有公共顶级存储库接口导出。但实际用例通常需要限制对特定方法、字段甚至整个存储库的访问。我们可以使用`@RepositoryRestResource`注解来阻止导出*接口*或自定义端点的访问。
- en: 'For example, if the managed entity is `User`, Spring Data REST will export
    it to the `/users` path. We can block the export of the entire repository by using
    the `exported = false` option of the `@RepositoryRestResource` annotation. The
    repository will look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果管理实体是`User`，Spring Data REST将默认将其导出到`/users`路径。我们可以通过使用`@RepositoryRestResource`注解的`exported
    = false`选项来阻止整个存储库的导出。存储库将看起来像这样：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Any command executed against this repository will result in an error. For example,
    executing
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对此存储库执行的任何命令都将导致错误。例如，执行
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'will generate the 404 (Not Found) response code from the server (see figure
    16.8):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将从服务器生成404（未找到）响应代码（见图16.8）：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](../../OEBPS/Images/CH16_F08_Tudose2.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH16_F08_Tudose2.png)'
- en: Figure 16.8 Blocking the export of the repository will prevent any interaction
    from the REST interface.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 阻止导出存储库将阻止REST接口的任何交互。
- en: For convenience, we’ll use the `@RepositoryRestResource` annotation with its
    default options for the `UserRepository` interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，我们将使用带有默认选项的`@RepositoryRestResource`注解来处理`UserRepository`接口。
- en: By default, Spring Data REST will also export all methods from a repository
    interface, but we can block access to these *methods* with the `@RestResource(exported
    = false)` annotation. For the `UserRepository` interface, we won’t export the
    deletion methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring Data REST还将导出存储库接口的所有方法，但我们可以使用`@RestResource(exported = false)`注解来阻止对这些*方法*的访问。对于`UserRepository`接口，我们不会导出删除方法。
- en: Listing 16.8 The `UserRepository` interface
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.8 `UserRepository`接口
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ⓐ Use the `@RepositoryRestResource` annotation to export the repository to the
    `/users` path. This is the default option.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用`@RepositoryRestResource`注解将存储库导出到`/users`路径。这是默认选项。
- en: Ⓑ Use the `@RestResource(exported = false)` annotation to not export the delete
    methods of the repositories.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@RestResource(exported = false)`注解来阻止导出存储库的删除方法。
- en: If we now execute the `DELETE` command,
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在执行`DELETE`命令，
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'the server will respond with the 405 (Method Not Allowed) response code, because
    the delete method was not exported (see figure 16.9). The allowed methods are
    `GET`, `HEAD`, `PUT`, `PATCH`, and `OPTIONS`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将响应405（方法不允许）的响应代码，因为删除方法没有被导出（见图16.9）。允许的方法有`GET`、`HEAD`、`PUT`、`PATCH`和`OPTIONS`：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](../../OEBPS/Images/CH16_F09_Tudose2.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH16_F09_Tudose2.png)'
- en: Figure 16.9 The delete method is no longer exported by Spring Data REST and
    is not allowed by the server.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 删除方法不再由Spring Data REST导出，服务器也不允许。
- en: 'We can limit access to particular fields and not expose them in the REST interface
    by using the `@JsonIgnore` annotation. For example, we can use this annotation
    inside the `User` class, on the `isRegistered` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`@JsonIgnore`注解来限制对特定字段的访问，并在REST接口中不暴露它们。例如，我们可以在`User`类中，在`isRegistered`方法上使用此注解：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Accessing the repository through the browser will no longer provide the `isRegistered`
    field information. You can see this in figure 16.10 and compare it to figure 16.2.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览器访问存储库将不再提供`isRegistered`字段信息。您可以在图16.10中看到这一点，并与图16.2进行比较。
- en: '![](../../OEBPS/Images/CH16_F10_Tudose2.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH16_F10_Tudose2.png)'
- en: Figure 16.10 The REST client no longer gets the `isRegistered` information.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 REST客户端不再获取`isRegistered`信息。
- en: 16.5 Working with REST events
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 使用REST事件
- en: 'In some situations, we may need to add side effects to the behavior of the
    application when a particular event occurs. The REST application can emit 10 different
    types of events when working with an entity. All of them extend the `org.springframework.data
    .rest.core.event.RepositoryEvent` class and belong to the same `org.springframework.data.rest.core.event`
    package:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要在特定事件发生时向应用程序的行为添加副作用。当与实体一起工作时，REST应用程序可以发出10种不同类型的事件。所有这些都扩展了`org.springframework.data
    .rest.core.event.RepositoryEvent`类，并属于同一个`org.springframework.data.rest.core.event`包：
- en: '`BeforeCreateEvent`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeforeCreateEvent`'
- en: '`AfterCreateEvent`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterCreateEvent`'
- en: '`BeforeSaveEvent`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeforeSaveEvent`'
- en: '`AfterSaveEvent`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterSaveEvent`'
- en: '`BeforeLinkSaveEvent`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeforeLinkSaveEvent`'
- en: '`AfterLinkSaveEvent`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterLinkSaveEvent`'
- en: '`BeforeDeleteEvent`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeforeDeleteEvent`'
- en: '`AfterDeleteEvent`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterDeleteEvent`'
- en: '`BeforeLinkDelete`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BeforeLinkDelete`'
- en: '`AfterLinkDelete`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AfterLinkDelete`'
- en: 'These events can be treated in two ways:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件可以有两种处理方式：
- en: Write an annotated handler
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写注解处理程序
- en: Write an `ApplicationListener`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写`ApplicationListener`
- en: Let’s look at these two options.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两种选项。
- en: 16.5.1 Writing an AnnotatedHandler
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5.1 编写注解处理程序
- en: To add side effects by writing an `AnnotatedHandler`, we can create a POJO class
    with the `@RepositoryEventHandler` annotation on it. This annotation tells the
    `BeanPostProcessor` managed by Spring that this class must be inspected for handler
    methods. The `BeanPostProcessor` will browse the methods of the class carrying
    this annotation and detect annotations that correspond to different events.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过编写`AnnotatedHandler`来添加副作用，我们可以创建一个带有`@RepositoryEventHandler`注解的POJO类。这个注解告诉Spring管理的`BeanPostProcessor`，这个类必须检查其处理方法。`BeanPostProcessor`将浏览带有此注解的类的所有方法，并检测与不同事件对应的注解。
- en: The event handler bean must be under the control of the container. We can annotate
    the class as a `@Service` (which is a `@Component` stereotype), so it will be
    considered by `@ComponentScan` or `@SpringBootApplication`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序bean必须在容器控制之下。我们可以将类注解为`@Service`（这是一个`@Component`的子类型），这样它就会被`@ComponentScan`或`@SpringBootApplication`考虑。
- en: The entity whose events we are following is provided by the type of the first
    parameter of the annotated methods. In the following examples, the methods of
    the handler will have a `User` entity as a parameter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跟踪的事件的实体由注解方法的第一个参数的类型提供。在以下示例中，处理程序的方法将有一个`User`实体作为参数。
- en: The association between the annotated methods and the events is summarized in
    table 16.1.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注解方法和事件之间的关系总结在表16.1中。
- en: Table 16.1 `AnnotatedHandler` annotations and corresponding events
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.1 `AnnotatedHandler`注解及其对应的事件
- en: '| Annotations | Events |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 注解 | 事件 |'
- en: '| `@HandleBeforeCreate``@HandleAfterCreate` | `POST` event |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `@HandleBeforeCreate` `@HandleAfterCreate` | `POST`事件 |'
- en: '| `@HandleBeforeSave``@HandleAfterSave` | `PUT` and `PATCH` events |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `@HandleBeforeSave` `@HandleAfterSave` | `PUT`和`PATCH`事件 |'
- en: '| `@HandleBeforeDelete``@HandleAfterDelete` | `DELETE` events |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `@HandleBeforeDelete` `@HandleAfterDelete` | `DELETE`事件 |'
- en: '| `@HandleBeforeLinkSave``@HandleAfterLinkSave` | A linked object is saved
    to the repository |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `@HandleBeforeLinkSave` `@HandleAfterLinkSave` | 将链接对象保存到存储库 |'
- en: '| `@HandleBeforeLinkDelete``@HandleAfterLinkDelete` | A linked object is deleted
    from the repository |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `@HandleBeforeLinkDelete` | `@HandleAfterLinkDelete` | 从存储库中删除链接对象 |'
- en: The `UserRepositoryEventHandler` class, a POJO class with the `@RepositoryEventHandler`
    annotation on it, is shown in the following listing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中展示了带有`@RepositoryEventHandler`注解的POJO类`UserRepositoryEventHandler`。
- en: Listing 16.9 The `UserRepositoryEventHandler` class
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.9 `UserRepositoryEventHandler`类
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ⓐ Annotate the class with the `@RepositoryEventHandler` annotation to tell the
    Spring `BeanPostProcessor` to inspect it for handler methods.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用`@RepositoryEventHandler`注解注解类，以告知Spring `BeanPostProcessor`检查其处理方法。
- en: Ⓑ Annotate the class with the `@Service` annotation to bring it under the control
    of the container.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用`@Service`注解注解类，使其处于容器的控制之下。
- en: Ⓒ Annotate the method with `@HandleBeforeCreate` to associate it with the `POST`
    event.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 使用`@HandleBeforeCreate`注解方法，将其与`POST`事件关联。
- en: Ⓓ The method has an entity `User` as a first parameter, indicating the type
    whose events we are following.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 该方法以实体`User`作为第一个参数，表示我们正在跟踪的事件的类型。
- en: 16.5.2 Writing an ApplicationListener
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5.2 编写ApplicationListener
- en: To add side effects by writing an `ApplicationListener`, we’ll extend the `AbstractRepositoryEventListener`
    abstract class. This class is generified by the type of entity on which the events
    happen. It will listen for the events and call the corresponding methods. We’ll
    annotate the custom listener as a `@Service` (which is a `@Component` stereotype),
    so it will be considered by `@ComponentScan` or `@SpringBootApplication`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过编写一个`ApplicationListener`来添加副作用，我们将扩展`AbstractRepositoryEventListener`抽象类。这个类通过事件发生的实体类型进行了泛化。它将监听事件并调用相应的方法。我们将自定义监听器注解为`@Service`（这是一个`@Component`的子类型），这样它就会被`@ComponentScan`或`@SpringBootApplication`考虑。
- en: The `AbstractRepositoryEventListener` abstract class already contains a series
    of empty protected methods to address events. We’ll need to override and make
    public only the ones we are interested in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractRepositoryEventListener`抽象类已经包含了一系列空的受保护方法来处理事件。我们需要覆盖并仅将我们感兴趣的公开。'
- en: The association between the methods and events is summarized in table 16.2.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 方法与事件之间的关系总结在表16.2中。
- en: Table 16.2 `ApplicationListener` methods and corresponding events
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.2 `ApplicationListener`方法和相应的事件
- en: '| Methods | Events |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 事件 |'
- en: '| `onBeforeCreate``onAfterCreate` | `POST` event |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `onBeforeCreate` | `onAfterCreate` | `POST`事件 |'
- en: '| `onBeforeSave``onAfterSave` | `PUT` and `PATCH` events |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `onBeforeSave` | `onAfterSave` | `PUT`和`PATCH`事件 |'
- en: '| `onBeforeDelete``onAfterDelete` | `DELETE` events |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `onBeforeDelete` | `onAfterDelete` | `DELETE`事件 |'
- en: '| `onBeforeLinkSave``onAfterLinkSave` | A linked object is saved to the repository
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `onBeforeLinkSave` | `onAfterLinkSave` | 将链接对象保存到存储库 |'
- en: '| `onBeforeLinkDelete``onAfterLinkDelete` | A linked object is deleted from
    the repository |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `onBeforeLinkDelete` | `onAfterLinkDelete` | 从存储库中删除链接对象 |'
- en: The `RepositoryEventListener` class, extending the `AbstractRepositoryEventListener`
    abstract class, contains the methods that react to the events. It’s shown in the
    following listing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展了`AbstractRepositoryEventListener`抽象类的`RepositoryEventListener`类包含了响应事件的函数。它将在以下列表中展示。
- en: Listing 16.10 The `RepositoryEventListener` class
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.10 `RepositoryEventListener`类
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Ⓐ Annotate the class with the `@Service` annotation to bring it under the control
    of the container.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用`@Service`注解注解类，使其处于容器的控制之下。
- en: Ⓑ Extend the `AbstractRepositoryEventListener`, generified by the `User` entity—the
    entity on which the events happen.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 通过`User`实体扩展`AbstractRepositoryEventListener`，这是事件发生的实体。
- en: Ⓒ The method has a `User` entity as the first parameter, indicating the type
    whose events we are following.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 该方法以`User`实体作为第一个参数，表示我们正在跟踪的事件的类型。
- en: 'Now we can run the application and execute a REST command as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行应用程序并执行以下REST命令：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The handler and the listener will react to the events and generate additional
    behavior as a side effect, as shown in figure 16.11.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器和监听器将对事件做出反应，并作为副作用生成额外的行为，如图16.11所示。
- en: '![](../../OEBPS/Images/CH16_F11_Tudose2.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH16_F11_Tudose2.png)'
- en: Figure 16.11 Additional behavior (side effects) from the handler and listener
    reacting to a REST event
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11 处理器和监听器对REST事件做出反应产生的额外行为（副作用）
- en: The two approaches of addressing events (with handlers and with listeners) provide
    similar behavior and they treat the same types of events. All other things being
    equal, handlers provide the advantage of working only at a declarative level (annotations
    on classes and methods), while listeners require us to extend an existing abstract
    class, so they hang in an existing hierarchy, which means less freedom of hierarchy
    design.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 处理事件（使用处理器和使用监听器）的两种方法提供类似的行为，并且它们处理相同类型的事件。在其他条件相同的情况下，处理器提供仅在声明性级别（类和方法上的注解）工作的优势，而监听器要求我们扩展一个现有的抽象类，这意味着它们挂在一个现有的层次结构中，这意味着层次结构设计的自由度较低。
- en: 16.6 Using projections and excerpts
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.6 使用投影和摘录
- en: Spring Data REST provides a default view of the domain model you are working
    with, but real-world use cases may require it to be changed or adapted to particular
    needs. You can do this using projections and excerpts, providing specific views
    of the information that is exported.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data REST提供了您正在处理的域模型的默认视图，但现实世界的用例可能需要对其进行更改或适应特定需求。您可以使用投影和摘录来实现这一点，提供导出信息的特定视图。
- en: We’ll add the new `Address` class to the project. It will contain a few fields,
    and we’d like to display the information inside it with the `toString` method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加新的`Address`类到项目中。它将包含一些字段，我们希望使用`toString`方法显示其中的信息。
- en: Listing 16.11 The `Address` class
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.11 `Address`类
- en: '[PRE28]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is a one-to-one relationship between `User` and `Address`, as we introduced
    a new field in the `User` entity:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`和`Address`之间存在一对一的关系，因为我们已经在`User`实体中引入了一个新字段：'
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `CascadeType.ALL` option will cause the persistence operations to be cascaded
    to the related entities. The `orphanRemoval=true` argument specifies that we want
    to permanently remove an `Address` when it is no longer referenced by the `User`.
    You can revisit chapter 8 for more details about these options.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`CascadeType.ALL`选项将导致持久化操作级联到相关实体。`orphanRemoval=true`参数指定我们希望在`Address`不再被`User`引用时永久删除它。您可以回顾第8章以获取有关这些选项的更多详细信息。'
- en: If we access the http://localhost:8081/users/1 URL, we’ll get the default view
    of the user with ID 1, displaying all its fields and the fields from the address,
    as shown in figure 16.12.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问 http://localhost:8081/users/1 URL，我们将获得ID为1的用户的默认视图，显示所有字段以及地址字段，如图16.12所示。
- en: '![](../../OEBPS/Images/CH16_F12_Tudose2.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH16_F12_Tudose2.png)'
- en: Figure 16.12 The default view of a user with an address
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12 带有地址的用户默认视图
- en: We’ll now add the new `UserProjection` interface to the project (listing 16.12).
    With the help of the `@Projection` annotation, we can create the `summary` projection
    on the `User` entity, which will export only the name of the user and the address
    according to how it is displayed by the `toString` method. We’ll do this using
    Spring Expression Language (SpEL).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加新的`UserProjection`接口到项目中（列表16.12）。借助`@Projection`注解，我们可以在`User`实体上创建`summary`投影，这将仅导出用户名称和地址，根据`toString`方法显示的方式。我们将使用Spring表达式语言（SpEL）来完成此操作。
- en: Listing 16.12 The `UserProjection` interface
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.12 `UserProjection`接口
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ⓐ The projection is named `summary`, and it applies to the `User` entities.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 投影名为`summary`，并应用于`User`实体。
- en: Ⓑ As the field is called `name`, we need to write a `getName` method to export
    it, following the getter names convention.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 由于字段名为`name`，我们需要编写一个`getName`方法来导出它，遵循getter名称约定。
- en: Ⓒ Export the `address` according to how it is displayed by the `toString` method.
    We use the `@Value` annotation, containing a SpEL expression. We also need to
    follow the getter names convention, so the method is called `getAddress`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 根据由`toString`方法显示的方式导出`address`。我们使用`@Value`注解，包含一个SpEL表达式。我们还需要遵循getter名称约定，因此该方法被命名为`getAddress`。
- en: If we access the http://localhost:8081/users/1?projection=summary URL (with
    the projection name included as a parameter), we’ll get a view of the user with
    ID 1, displaying the `name` field and the address provided by the `toString` method.
    This is shown in figure 16.13.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问http://localhost:8081/users/1?projection=summary URL（包含作为参数的投影名称），我们将获得ID为1的用户的视图，显示`name`字段和由`toString`方法提供的地址。这如图16.13所示。
- en: '![](../../OEBPS/Images/CH16_F13_Tudose2.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH16_F13_Tudose2.png)'
- en: Figure 16.13 The view of a user with an address provided by the `summary` projection
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13 由`summary`投影提供的带有地址的用户视图
- en: We may want to apply the default view of a projection at the level of a whole
    collection. In this case, we’ll have to go to the already defined repository and
    use the `excerptProjection = UserProjection.class` option of the `@RepositoryRestResource`
    annotation, as shown in listing 16.13.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望在集合的整体级别应用投影的默认视图。在这种情况下，我们需要前往已经定义的仓库，并使用`@RepositoryRestResource`注解的`excerptProjection
    = UserProjection.class`选项，如列表16.13所示。
- en: Listing 16.13 The modified `UserRepository` interface
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.13 修改后的`UserRepository`接口
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we access the http://localhost:8081/users/ URL, we’ll get a view of all users,
    displayed according to the projection definition, as shown in figure 16.14.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问http://localhost:8081/users/ URL，我们将获得所有用户的视图，根据投影定义显示，如图16.14所示。
- en: '![](../../OEBPS/Images/CH16_F14_Tudose2.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH16_F14_Tudose2.png)'
- en: Figure 16.14 The view of the whole `users` collection, displayed according to
    the `summary` projection
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14 根据`summary`投影显示的整个`users`集合视图
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Using Spring Boot, you can create and configure a Spring Data REST project to
    provide an interface to interact with the database and to manage and persist information.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot，您可以创建和配置一个Spring Data REST项目，以提供与数据库交互的接口，以及管理和持久化信息。
- en: You can use ETags to make efficient requests that get data from the server,
    avoiding transferring information that the client already has.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用ETags来执行高效请求，从服务器获取数据，避免传输客户端已经拥有的信息。
- en: You can limit access to repositories, methods, and fields, and export only the
    information and actions that you would like to allow.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以限制对仓库、方法和字段的访问，并仅导出您希望允许的信息和操作。
- en: You can work with REST events and manage them through handlers and listeners.
    They can work through meta-information or by extending an existing class.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以与REST事件一起工作，并通过处理程序和监听器来管理它们。它们可以通过元信息或通过扩展现有类来工作。
- en: You can use projections and excerpts to provide customized views of the information
    exported by the repository, according to the needs of different users.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用投影和摘录来提供根据不同用户需求定制的仓库信息视图。
