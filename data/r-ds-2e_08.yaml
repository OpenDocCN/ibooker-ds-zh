- en: Chapter 7\. Data Import
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 数据导入
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Working with data provided by R packages is a great way to learn data science
    tools, but you want to apply what you’ve learned to your own data at some point.
    In this chapter, you’ll learn the basics of reading data files into R.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用R包提供的数据是学习数据科学工具的好方法，但您想要将所学应用于自己的数据。在本章中，您将学习将数据文件读入R的基础知识。
- en: Specifically, this chapter will focus on reading plain-text rectangular files.
    We’ll start with practical advice for handling features such as column names,
    types, and missing data. You will then learn about reading data from multiple
    files at once and writing data from R to a file. Finally, you’ll learn how to
    handcraft data frames in R.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将重点介绍读取纯文本矩形文件。我们将从处理列名、类型和缺失数据的实用建议开始。然后，您将了解如何一次从多个文件读取数据，并将数据从R写入文件。最后，您将学习如何在R中手工制作数据框架。
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'In this chapter, you’ll learn how to load flat files in R with the readr package,
    which is part of the core tidyverse:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用readr包在R中加载平面文件，该包是核心tidyverse的一部分：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Reading Data from a File
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取数据
- en: 'To begin, we’ll focus on the most common rectangular data file type: CSV, which
    is short for “comma-separated values.” Here is what a simple CSV file looks like.
    The first row, commonly called the *header row*, gives the column names, and the
    following six rows provide the data. The columns are separated, aka *delimited*,
    by commas.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重点放在最常见的矩形数据文件类型上：CSV，即“逗号分隔值”。这是一个简单的CSV文件的示例。第一行，通常称为*标题行*，给出列名，接下来的六行提供数据。列由逗号分隔。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Table 7-1](#tbl-students-table) represents of the same data as a table.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-1](#tbl-students-table) 表示相同的数据作为表格。'
- en: Table 7-1\. Data from the students.csv file as a table
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. students.csv文件中的数据表
- en: '| Student ID | Full Name | favourite.food | mealPlan | AGE |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 学生ID | 全名 | 最喜欢的食物 | 餐饮计划 | 年龄 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 1 | Sunil Huffmann | Strawberry yoghurt | Lunch only | 4 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Sunil Huffmann | Strawberry yoghurt | 仅午餐 | 4 |'
- en: '| 2 | Barclay Lynn | French fries | Lunch only | 5 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Barclay Lynn | French fries | 仅午餐 | 5 |'
- en: '| 3 | Jayendra Lyne | N/A | Breakfast and lunch | 7 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 3 | Jayendra Lyne | N/A | 早餐和午餐 | 7 |'
- en: '| 4 | Leon Rossini | Anchovies | Lunch only | NA |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 4 | Leon Rossini | Anchovies | 仅午餐 | NA |'
- en: '| 5 | Chidiegwu Dunkel | Pizza | Breakfast and lunch | five |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 5 | Chidiegwu Dunkel | Pizza | 早餐和午餐 | five |'
- en: '| 6 | Güvenç Attila | Ice cream | Lunch only | 6 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 6 | Güvenç Attila | Ice cream | 仅午餐 | 6 |'
- en: 'We can read this file into R using [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml).
    The first argument is the most important: the path to the file. You can think
    about the path as the address of the file: the file is called `students.csv`,
    and it lives in the `data` folder.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)将这个文件读入R。第一个参数是最重要的：文件的路径。你可以把路径看作是文件的地址：文件名为`students.csv`，存放在`data`文件夹中。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The previous code will work if you have the `students.csv` file in a `data`
    folder in your project. You can download the [`students.csv` file](https://oreil.ly/GDubb)
    or you can read it directly from that URL with this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在项目的`data`文件夹中有`students.csv`文件，前面的代码将起作用。您可以下载[`students.csv`文件](https://oreil.ly/GDubb)，或者直接从该URL读取它：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you run [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml),
    it prints out a message telling you the number of rows and columns of data, the
    delimiter that was used, and the column specifications (names of columns organized
    by the type of data the column contains). It also prints out some information
    about retrieving the full column specification and how to quiet this message.
    This message is an integral part of readr, and we’ll return to it in [“Controlling
    Column Types”](#sec-col-types).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行[`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)时，它会输出一条消息，告诉您数据的行数和列数，使用的分隔符以及列规格（按列包含的数据类型命名的列名）。它还打印出一些有关检索完整列规格及如何静音此消息的信息。这条消息是readr的一个重要部分，我们将在[“控制列类型”](#sec-col-types)中返回它。
- en: Practical Advice
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用建议
- en: 'Once you read data in, the first step usually involves transforming it in some
    way to make it easier to work with in the rest of your analysis. Let’s take another
    look at the `students` data with that in mind:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据后，通常的第一步是以某种方式转换数据，以便在后续分析中更容易处理。让我们再次查看`students`数据：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `favourite.food` column, there are a bunch of food items, and then the
    character string `N/A`, which should have been a real `NA` that R will recognize
    as “not available.” This is something we can address using the `na` argument.
    By default [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    recognizes only empty strings (`""`) in this dataset as `NA`s; we want it to also
    recognize the character string `"N/A"`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`favourite.food`列中，有一堆食物项目，以及字符字符串`N/A`，本应是R识别的真正`NA`，表示“不可用”。我们可以使用`na`参数来解决这个问题。默认情况下，[`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)仅识别此数据集中的空字符串（`""`）为`NA`；我们希望它也能识别字符字符串`"N/A"`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You might also notice that the `Student ID` and `Full Name` columns are surrounded
    by backticks. That’s because they contain spaces, breaking R’s usual rules for
    variable names; they’re *nonsyntactic* names. To refer to these variables, you
    need to surround them with backticks, `` ` ``:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到`Student ID`和`Full Name`列被反引号包围。这是因为它们包含空格，违反了R变量名称的常规规则；它们是*nonsyntactic*名称。要引用这些变量，您需要使用反引号
    `` ` `` 包围它们：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An alternative approach is to use [`janitor::clean_names()`](https://rdrr.io/pkg/janitor/man/clean_names.xhtml)
    to use some heuristics to turn them all into snake case at once:^([1](ch07.xhtml#idm44771312718064))
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用[`janitor::clean_names()`](https://rdrr.io/pkg/janitor/man/clean_names.xhtml)一次性使用一些启发式方法将它们全部转换为蛇形命名:^([1](ch07.xhtml#idm44771312718064))
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another common task after reading in data is to consider variable types. For
    example, `meal_plan` is a categorical variable with a known set of possible values,
    which in R should be represented as a factor:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据后的另一个常见任务是考虑变量类型。例如，`meal_plan`是一个具有已知可能值集合的分类变量，在R中应表示为因子：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the values in the `meal_plan` variable have stayed the same, but the
    type of variable denoted underneath the variable name has changed from character
    (`<chr>`) to factor (`<fct>`). You’ll learn more about factors in [Chapter 16](ch16.xhtml#chp-factors).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`meal_plan` 变量中的值保持不变，但是在变量名下标有所不同，从字符（`<chr>`）变为因子（`<fct>`）。有关因子的详细信息请参见[第16章](ch16.xhtml#chp-factors)。
- en: Before you analyze these data, you’ll probably want to fix the `age` and `id`
    columns. Currently, `age` is a character variable because one of the observations
    is typed out as `five` instead of a numeric `5`. We discuss the details of fixing
    this issue in [Chapter 20](ch20.xhtml#chp-spreadsheets).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析这些数据之前，您可能希望修复`age`和`id`列。当前，`age`是一个字符变量，因为其中一条观察结果被输入为`five`而不是数字`5`。我们将在[第20章](ch20.xhtml#chp-spreadsheets)讨论解决此问题的详细信息。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A new function here is [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml),
    which has three arguments. The first argument `test` should be a logical vector.
    The result will contain the value of the second argument, `yes`, when `test` is
    `TRUE`, and the value of the third argument, `no`, when it is `FALSE`. Here we’re
    saying if `age` is the character string `"five"`, make it `"5"`, and if not, leave
    it as `age`. You will learn more about [`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)
    and logical vectors in [Chapter 12](ch12.xhtml#chp-logicals).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 新的函数是[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)，它有三个参数。第一个参数`test`应该是一个逻辑向量。当`test`为`TRUE`时，结果将包含第二个参数`yes`的值；当`test`为`FALSE`时，结果将包含第三个参数`no`的值。在这里我们说，如果`age`是字符字符串`"five"`，则将其变为`"5"`，否则保持为`age`。有关[`if_else()`](https://dplyr.tidyverse.org/reference/if_else.xhtml)和逻辑向量的更多信息，请参见[第12章](ch12.xhtml#chp-logicals)。
- en: Other Arguments
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他参数
- en: 'There are a couple of other important arguments that we need to mention, and
    they’ll be easier to demonstrate if we first show you a handy trick: [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    can read text strings that you’ve created and formatted like a CSV file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个重要的参数需要提到，如果我们首先向您展示一个方便的技巧将更容易演示：[`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)可以读取您创建并格式化为CSV文件样式的文本字符串：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Usually, [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    uses the first line of the data for the column names, which is a common convention.
    But it’s not uncommon for a few lines of metadata to be included at the top of
    the file. You can use `skip = n` to skip the first `n` lines or use `comment =
    "#"` to drop all lines that start with, for example, `#`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，[`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)使用数据的第一行作为列名，这是一种常见的约定。但是在文件顶部可能包含几行元数据并不罕见。您可以使用`skip
    = n`跳过前`n`行，或使用`comment = "#"`删除以`#`开头的所有行，例如：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In other cases, the data might not have column names. You can use `col_names
    = FALSE` to tell [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    not to treat the first row as headings and instead label them sequentially from
    `X1` to `Xn`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，数据可能没有列名。您可以使用 `col_names = FALSE` 来告诉 [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    不将第一行视为标题，而是按顺序从 `X1` 到 `Xn` 进行标记：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you can pass `col_names` a character vector, which will be used
    as the column names:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将 `col_names` 传递为字符向量，用作列名：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These arguments are all you need to know to read the majority of CSV files that
    you’ll encounter in practice. (For the rest, you’ll need to carefully inspect
    your `.csv` file and read the documentation for [`read_csv()`’s](https://readr.tidyverse.org/reference/read_delim.xhtml)
    many other arguments.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数是你在实践中大部分会遇到的 CSV 文件所需知道的全部内容。（对于其余部分，你需要仔细检查你的 `.csv` 文件并阅读 [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    的文档中的许多其他参数。）
- en: Other File Types
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他文件类型
- en: 'Once you’ve mastered [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml),
    using readr’s other functions is straightforward; it’s just a matter of knowing
    which function to reach for:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦掌握了 [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)，使用
    readr 的其他函数就很简单了；关键是知道要使用哪个函数：
- en: '[`read_csv2()`](https://readr.tidyverse.org/reference/read_delim.xhtml)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[`read_csv2()`](https://readr.tidyverse.org/reference/read_delim.xhtml)'
- en: Reads semicolon-separated files. These use `;` instead of `,` to separate fields
    and are common in countries that use `,` as the decimal marker.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 读取以分号分隔的文件。这些文件使用 `;` 而不是 `,` 来分隔字段，是在使用 `,` 作为小数点分隔符的国家中很常见的。
- en: '[`read_tsv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[`read_tsv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)'
- en: Reads tab-delimited files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 读取制表符分隔的文件。
- en: '[`read_delim()`](https://readr.tidyverse.org/reference/read_delim.xhtml)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[`read_delim()`](https://readr.tidyverse.org/reference/read_delim.xhtml)'
- en: Reads in files with any delimiter, attempting to automatically guess the delimiter
    if you don’t specify it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 读取具有任何分隔符的文件，如果不指定分隔符，则尝试自动猜测分隔符。
- en: '[`read_fwf()`](https://readr.tidyverse.org/reference/read_fwf.xhtml)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[`read_fwf()`](https://readr.tidyverse.org/reference/read_fwf.xhtml)'
- en: Reads fixed-width files. You can specify fields by their widths with [`fwf_widths()`](https://readr.tidyverse.org/reference/read_fwf.xhtml)
    or by their positions with [`fwf_positions()`](https://readr.tidyverse.org/reference/read_fwf.xhtml).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 读取固定宽度文件。您可以使用 [`fwf_widths()`](https://readr.tidyverse.org/reference/read_fwf.xhtml)
    指定字段的宽度，或者使用 [`fwf_positions()`](https://readr.tidyverse.org/reference/read_fwf.xhtml)
    指定字段的位置。
- en: '[`read_table()`](https://readr.tidyverse.org/reference/read_table.xhtml)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[`read_table()`](https://readr.tidyverse.org/reference/read_table.xhtml)'
- en: Reads a common variation of fixed-width files where columns are separated by
    whitespace.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 读取常见的固定宽度文件变体，其中列由空格分隔。
- en: '[`read_log()`](https://readr.tidyverse.org/reference/read_log.xhtml)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[`read_log()`](https://readr.tidyverse.org/reference/read_log.xhtml)'
- en: Reads Apache-style log files.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 Apache 风格的日志文件。
- en: Exercises
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: What function would you use to read a file where fields were separated with
    |?
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用什么函数可以读取以 | 分隔字段的文件？
- en: Apart from `file`, `skip`, and `comment`, what other arguments do [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    and [`read_tsv()`](https://readr.tidyverse.org/reference/read_delim.xhtml) have
    in common?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了 `file`、`skip` 和 `comment` 外，[`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    和 [`read_tsv()`](https://readr.tidyverse.org/reference/read_delim.xhtml) 还有哪些共同的参数？
- en: What are the most important arguments to [`read_fwf()`](https://readr.tidyverse.org/reference/read_fwf.xhtml)?
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是 [`read_fwf()`](https://readr.tidyverse.org/reference/read_fwf.xhtml) 最重要的参数是什么？
- en: Sometimes strings in a CSV file contain commas. To prevent them from causing
    problems, they need to be surrounded by a quoting character, like `"` or `'`.
    By default, [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    assumes that the quoting character will be `"`. To read the following text into
    a data frame, what argument to [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    do you need to specify?
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时 CSV 文件中的字符串包含逗号。为了防止它们引起问题，它们需要用引号字符（如 `"` 或 `'`）括起来。默认情况下，[`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    假定引号字符是 `"`. 要将以下文本读入数据框，您需要指定 [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    的哪个参数？
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Identify what is wrong with each of the following inline CSV files. What happens
    when you run the code?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定以下内联 CSV 文件中的问题。运行代码时会发生什么？
- en: '[PRE15]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Practice referring to nonsyntactic names in the following data frame by:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下数据框中，通过练习引用非语法名称：
- en: Extracting the variable called `1`.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取名为 `1` 的变量。
- en: Plotting a scatterplot of `1` versus `2`.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制 `1` 对 `2` 的散点图。
- en: Creating a new column called `3`, which is `2` divided by `1`.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `3` 的新列，它是 `2` 除以 `1`。
- en: 'Renaming the columns to `one`, `two`, and `three`:'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列重命名为 `one`，`two` 和 `three`：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Controlling Column Types
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制列类型
- en: A CSV file doesn’t contain any information about the type of each variable (i.e., whether
    it’s a logical, number, string, etc.), so readr will try to guess the type. This
    section describes how the guessing process works, how to resolve some common problems
    that cause it to fail, and, if needed, how to supply the column types yourself.
    Finally, we’ll mention a few general strategies that are useful if readr is failing
    catastrophically and you need to get more insight into the structure of your file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 文件不包含每个变量的类型信息（即它是逻辑值、数字、字符串等），因此 readr 将尝试猜测类型。本节描述了猜测过程的工作方式，如何解决一些导致猜测失败的常见问题，以及如果需要的话如何自己提供列类型。最后，我们将提及一些一般策略，如果
    readr 失败严重，您需要获取有关文件结构的更多信息时可以使用。
- en: Guessing Types
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 猜测类型
- en: 'readr uses a heuristic to figure out the column types. For each column, it
    pulls the values of 1,000^([2](ch07.xhtml#idm44771312159040)) rows spaced evenly
    from the first row to the last, ignoring missing values. It then works through
    the following questions:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: readr 使用一种启发式方法来确定列类型。对于每一列，它从第一行到最后一行均匀地抽取 1,000^([2](ch07.xhtml#idm44771312159040))
    个值，忽略缺失值。然后它按以下问题逐步进行：
- en: Does it contain only `F`, `T`, `FALSE`, or `TRUE` (ignoring case)? If so, it’s
    a logical.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只包含 `F`，`T`，`FALSE` 或 `TRUE`（忽略大小写）吗？如果是，那么它是逻辑值。
- en: Does it contain only numbers (e.g., `1`, `-4.5`, `5e6`, `Inf`)? If so, it’s
    a number.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只包含数字（例如，`1`，`-4.5`，`5e6`，`Inf`）吗？如果是，那么它是一个数字。
- en: Does it match the ISO8601 standard? If so, it’s a date or date-time. (We’ll
    return to date-times in more detail in [“Creating Date/Times”](ch17.xhtml#sec-creating-datetimes).)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否符合 ISO8601 标准？如果是，那么它是日期或日期时间（我们将在[“创建日期/时间”](ch17.xhtml#sec-creating-datetimes)中详细讨论日期时间）。
- en: Otherwise, it must be a string.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它必须是一个字符串。
- en: 'You can see that behavior in action in this simple example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这个简单的例子中看到这种行为：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This heuristic works well if you have a clean dataset, but in real life, you’ll
    encounter a selection of weird and beautiful failures.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个干净的数据集，这种启发式方法效果很好，但是在实际生活中，您会遇到各种奇怪而美丽的失败。
- en: Missing Values, Column Types, and Problems
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺失值、列类型和问题
- en: The most common way column detection fails is that a column contains unexpected
    values, and you get a character column instead of a more specific type. One of
    the most common causes for this is a missing value, recorded using something other
    than the `NA` that readr expects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列检测最常见的失败方式是，一列包含意外值，导致您得到一个字符列而不是更具体的类型。其中最常见的原因之一是缺失值，使用的不是 readr 期望的 `NA`。
- en: 'Take this simple one-column CSV file as an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个简单的单列 CSV 文件为例：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we read it without any additional arguments, `x` becomes a character column:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有添加任何额外的参数读取它，`x` 将成为一个字符列：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this small case, you can easily see the missing value `.`. But what happens
    if you have thousands of rows with only a few missing values represented by `.`s
    sprinkled among them? One approach is to tell readr that `x` is a numeric column
    and then see where it fails. You can do that with the `col_types` argument, which
    takes a named list where the names match the column names in the CSV file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小例子中，您可以轻松看到缺失值 `.`。但是，如果您有成千上万行中间夹杂着几个 `.` 表示的缺失值会发生什么？一种方法是告诉 readr `x`
    是一个数字列，然后查看它失败的地方。您可以使用 `col_types` 参数来做到这一点，该参数接受一个命名列表，其中名称与 CSV 文件中的列名匹配：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    reports that there was a problem and tells us we can find out more with [`problems()`](https://readr.tidyverse.org/reference/problems.xhtml):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在[`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml) 报告了问题，并告诉我们可以通过[`problems()`](https://readr.tidyverse.org/reference/problems.xhtml)了解更多信息：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This tells us that there was a problem in row 3, column 1 where readr expected
    a double but got a `.`. That suggests this dataset uses `.` for missing values.
    So then we set `na = "."`, and the automatic guessing succeeds, giving us the
    numeric column that we want:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，在第 3 行第 1 列出现了问题，readr 期望是一个 double，但得到了一个 `.`。这表明该数据集使用 `.` 表示缺失值。因此，我们设置
    `na = "."`，自动猜测成功，给我们了我们想要的数字列：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Column Types
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列类型
- en: 'readr provides a total of nine column types for you to use:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: readr 提供了总共九种列类型供您使用：
- en: '[`col_logical()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    and [`col_double()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    read logicals and real numbers. They’re relatively rarely needed (except as shown
    previously), since readr will usually guess them for you.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`col_logical()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    和 [`col_double()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml) 分别读取逻辑值和实数。它们相对较少使用（除非像前面展示的那样），因为
    readr 通常会为你猜测这些类型。'
- en: '[`col_integer()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    reads integers. We seldom distinguish integers and doubles in this book because
    they’re functionally equivalent, but reading integers explicitly can occasionally
    be useful because they occupy half the memory of doubles.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`col_integer()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    读取整数。在这本书中我们很少区分整数和双精度浮点数，因为它们在功能上是等效的，但明确读取整数有时也很有用，因为它们只占双精度浮点数内存的一半。'
- en: '[`col_character()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    reads strings. This can be useful to specify explicitly when you have a column
    that is a numeric identifier, i.e., long series of digits that identifies an object
    but doesn’t make sense to apply mathematical operations to. Examples include phone
    numbers, Social Security numbers, credit card numbers, and so on.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`col_character()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    读取字符串。当你有一个列是数字标识符，即长序列的数字，用来标识一个对象但不适合进行数学运算时，这将会很有用。例如电话号码、社会保险号、信用卡号等。'
- en: '[`col_factor()`](https://readr.tidyverse.org/reference/parse_factor.xhtml),
    [`col_date()`](https://readr.tidyverse.org/reference/parse_datetime.xhtml), and
    [`col_datetime()`](https://readr.tidyverse.org/reference/parse_datetime.xhtml)
    create factors, dates, and date-times, respectively; you’ll learn more about those
    when we get to those data types in [Chapter 16](ch16.xhtml#chp-factors) and [Chapter 17](ch17.xhtml#chp-datetimes).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`col_factor()`](https://readr.tidyverse.org/reference/parse_factor.xhtml),
    [`col_date()`](https://readr.tidyverse.org/reference/parse_datetime.xhtml), 和
    [`col_datetime()`](https://readr.tidyverse.org/reference/parse_datetime.xhtml)
    分别创建因子、日期和日期时间；当我们讨论到这些数据类型时（请见[第 16 章](ch16.xhtml#chp-factors) 和 [第 17 章](ch17.xhtml#chp-datetimes)），你会进一步学习这些内容。'
- en: '[`col_number()`](https://readr.tidyverse.org/reference/parse_number.xhtml)
    is a permissive numeric parser that will ignore non-numeric components and is
    particularly useful for currencies. You’ll learn more about it in [Chapter 13](ch13.xhtml#chp-numbers).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`col_number()`](https://readr.tidyverse.org/reference/parse_number.xhtml)
    是一种宽松的数值解析器，它会忽略非数值组件，特别适用于货币。你将在[第 13 章](ch13.xhtml#chp-numbers)中进一步了解它。'
- en: '[`col_skip()`](https://readr.tidyverse.org/reference/col_skip.xhtml) skips
    a column so it’s not included in the result, which can be useful for speeding
    up reading the data if you have a large CSV file and you want to use only some
    of the columns.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`col_skip()`](https://readr.tidyverse.org/reference/col_skip.xhtml) 跳过一个列，使其不包含在结果中，如果你有一个大的
    CSV 文件，并且只想使用部分列，这将会很有用。'
- en: 'It’s also possible to override the default column by switching from [`list()`](https://rdrr.io/r/base/list.xhtml)
    to [`cols()`](https://readr.tidyverse.org/reference/cols.xhtml) and specifying
    `.default`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过从 [`list()`](https://rdrr.io/r/base/list.xhtml) 切换到 [`cols()`](https://readr.tidyverse.org/reference/cols.xhtml)
    并指定 `.default` 来覆盖默认列。
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another useful helper is [`cols_only()`](https://readr.tidyverse.org/reference/cols.xhtml),
    which will read in only the columns you specify:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的辅助函数是 [`cols_only()`](https://readr.tidyverse.org/reference/cols.xhtml)，它将只读取你指定的列：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Reading Data from Multiple Files
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从多个文件读取数据
- en: 'Sometimes your data is split across multiple files instead of being contained
    in a single file. For example, you might have sales data for multiple months,
    with each month’s data in a separate file: `01-sales.csv` for January, `02-sales.csv`
    for February, and `03-sales.csv` for March. With [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    you can read these data in at once and stack them on top of each other in a single
    data frame.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你的数据分布在多个文件中，而不是单个文件。例如，你可能有多个月份的销售数据，每个月份的数据保存在单独的文件中：`01-sales.csv` 表示一月，`02-sales.csv`
    表示二月，`03-sales.csv` 表示三月。使用 [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)，你可以一次性读取这些数据，并将它们堆叠在一个单一的数据框中。
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once again, the previous code will work if you have the CSV files in a `data`
    folder in your project. You can download these files from [*https://oreil.ly/jVd8o*](https://oreil.ly/jVd8o),
    [*https://oreil.ly/RYsgM*](https://oreil.ly/RYsgM), and [*https://oreil.ly/4uZOm*](https://oreil.ly/4uZOm)
    or you can read them directly with:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 CSV 文件位于项目的 `data` 文件夹中，前面的代码将再次起作用。您可以从 [*https://oreil.ly/jVd8o*](https://oreil.ly/jVd8o)、[*https://oreil.ly/RYsgM*](https://oreil.ly/RYsgM)
    和 [*https://oreil.ly/4uZOm*](https://oreil.ly/4uZOm) 下载这些文件，或直接读取它们：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `id` argument adds a new column called `file` to the resulting data frame
    that identifies the file the data come from. This is especially helpful in circumstances
    where the files you’re reading in do not have an identifying column that can help
    you trace the observations back to their original sources.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 参数会向结果数据框中添加一个名为 `file` 的新列，用于标识数据来自哪个文件。在文件没有可帮助您追溯观察结果到原始来源的标识列的情况下，这尤为有用。'
- en: If you have many files you want to read in, it can get cumbersome to write out
    their names as a list. Instead, you can use the base [`list.files()`](https://rdrr.io/r/base/list.files.xhtml)
    function to find the files for you by matching a pattern in the filenames. You’ll
    learn more about these patterns in [Chapter 15](ch15.xhtml#chp-regexps).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要读取许多文件，逐个写出它们的名称作为列表可能会很麻烦。相反，您可以使用基础函数 [`list.files()`](https://rdrr.io/r/base/list.files.xhtml)
    通过匹配文件名中的模式来查找文件。您将在 [第 15 章](ch15.xhtml#chp-regexps) 中更多了解这些模式。
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Writing to a File
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件
- en: 'readr also comes with two useful functions for writing data to disk: [`write_csv()`](https://readr.tidyverse.org/reference/write_delim.xhtml)
    and [`write_tsv()`](https://readr.tidyverse.org/reference/write_delim.xhtml).
    The most important arguments to these functions are `x` (the data frame to save)
    and `file` (the location to save it). You can also specify how missing values
    are written with `na`, as well as whether you want to `append` to an existing
    file.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: readr 还提供了两个将数据写入磁盘的实用函数：[`write_csv()`](https://readr.tidyverse.org/reference/write_delim.xhtml)
    和 [`write_tsv()`](https://readr.tidyverse.org/reference/write_delim.xhtml)。这些函数的最重要参数是
    `x`（要保存的数据框）和 `file`（保存位置）。您还可以使用 `na` 指定如何写入缺失值，以及是否要 `append` 到现有文件中。
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let’s read that CSV file back in. Note that the variable type information
    that you just set up is lost when you save to CSV because you’re starting over
    with reading from a plain-text file again:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次读取该 CSV 文件。请注意，由于从普通文本文件重新开始读取，您刚刚设置的变量类型信息将丢失：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This makes CSVs a little unreliable for caching interim results—you need to
    re-create the column specification every time you load in. There are two main
    alternatives:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 CSV 在缓存中间结果时略显不可靠 — 每次加载时都需要重新创建列规范。有两种主要替代方法：
- en: '[`write_rds()`](https://readr.tidyverse.org/reference/read_rds.xhtml) and [`read_rds()`](https://readr.tidyverse.org/reference/read_rds.xhtml)
    are uniform wrappers around the base functions [`readRDS()`](https://rdrr.io/r/base/readRDS.xhtml)
    and [`saveRDS()`](https://rdrr.io/r/base/readRDS.xhtml). These store data in R’s
    custom binary format called RDS. This means that when you reload the object, you
    are loading the *exact same* R object that you stored.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`write_rds()`](https://readr.tidyverse.org/reference/read_rds.xhtml) 和 [`read_rds()`](https://readr.tidyverse.org/reference/read_rds.xhtml)
    是围绕基础函数 [`readRDS()`](https://rdrr.io/r/base/readRDS.xhtml) 和 [`saveRDS()`](https://rdrr.io/r/base/readRDS.xhtml)
    的统一包装器。这些函数使用 R 的自定义二进制格式 RDS 存储数据。这意味着当重新加载对象时，您加载的是*完全相同的* R 对象。'
- en: '[PRE30]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The arrow package allows you to read and write parquet files, a fast binary
    file format that can be shared across programming languages. We’ll return to arrow
    in more depth in [Chapter 22](ch22.xhtml#chp-arrow).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: arrow 包允许您读取和写入 parquet 文件，这是一种快速的二进制文件格式，可以在多种编程语言之间共享。我们将在 [第 22 章](ch22.xhtml#chp-arrow)
    中更深入地讨论 arrow。
- en: '[PRE31]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Parquet tends to be much faster than RDS and is usable outside of R but does
    require the arrow package.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Parquet 比 RDS 更快，并且可在 R 之外使用，但需要 arrow 包。
- en: Data Entry
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据输入
- en: 'Sometimes you’ll need to assemble a tibble “by hand” doing a little data entry
    in your R script. There are two useful functions to help you do this, which differ
    in whether you lay out the tibble by columns or by rows. [`tibble()`](https://tibble.tidyverse.org/reference/tibble.xhtml)
    works by column:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要在 R 脚本中手动组装 tibble 进行一些数据输入。有两个有用的函数可以帮助您完成此操作，这两个函数在按列或按行布局 tibble 方面有所不同。[`tibble()`](https://tibble.tidyverse.org/reference/tibble.xhtml)
    按列工作：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Laying out the data by column can make it hard to see how the rows are related,
    so an alternative is [`tribble()`](https://tibble.tidyverse.org/reference/tribble.xhtml),
    short for *tr*ansposed t*ibble*, which lets you lay out your data row by row.
    [`tribble()`](https://tibble.tidyverse.org/reference/tribble.xhtml) is customized
    for data entry in code: column headings start with `~` and entries are separated
    by commas. This makes it possible to lay out small amounts of data in an easy-to-read
    form:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 按列排列数据可能会使行之间的关系难以看清，因此另一种选择是[`tribble()`](https://tibble.tidyverse.org/reference/tribble.xhtml)，即*tr*ansposed
    t*ibble*，它允许你逐行布置数据。[`tribble()`](https://tibble.tidyverse.org/reference/tribble.xhtml)专为在代码中进行数据输入而定制：列标题以`~`开头，条目之间用逗号分隔。这使得可以以易于阅读的形式布置少量数据：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to load CSV files with [`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)
    and to do your own data entry with [`tibble()`](https://tibble.tidyverse.org/reference/tibble.xhtml)
    and [`tribble()`](https://tibble.tidyverse.org/reference/tribble.xhtml). You’ve
    learned how CSV files work, some of the problems you might encounter, and how
    to overcome them. We’ll come to data import a few times in this book: [Chapter 20](ch20.xhtml#chp-spreadsheets)
    will show you how to load data from Excel and Google Sheets, [Chapter 21](ch21.xhtml#chp-databases)
    from databases, [Chapter 22](ch22.xhtml#chp-arrow) from parquet files, [Chapter 23](ch23.xhtml#chp-rectangling)
    from JSON, and [Chapter 24](ch24.xhtml#chp-webscraping) from websites.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何使用[`read_csv()`](https://readr.tidyverse.org/reference/read_delim.xhtml)加载
    CSV 文件，并使用[`tibble()`](https://tibble.tidyverse.org/reference/tibble.xhtml)和[`tribble()`](https://tibble.tidyverse.org/reference/tribble.xhtml)进行自己的数据输入。你已经了解了
    CSV 文件的工作原理，可能会遇到的一些问题以及如何克服它们。我们将在本书中多次涉及数据导入：[第20章](ch20.xhtml#chp-spreadsheets)将向你展示如何从
    Excel 和 Google Sheets 加载数据，[第21章](ch21.xhtml#chp-databases)从数据库中加载，[第22章](ch22.xhtml#chp-arrow)从
    Parquet 文件中加载，[第23章](ch23.xhtml#chp-rectangling)从 JSON 中加载，以及[第24章](ch24.xhtml#chp-webscraping)从网站中加载。
- en: 'We’re just about at the end of this section of the book, but there’s one important
    last topic to cover: how to get help. So in the next chapter, you’ll learn some
    good places to look for help, how to create a reprex to maximize your chances
    of getting good help, and some general advice on keeping up with the world of
    R.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经完成了本书章节的结尾，但还有一个重要的主题需要讨论：如何获取帮助。因此，在下一章中，你将学习一些寻求帮助的好方法，如何创建一个示范性代码以最大化获取良好帮助的机会，以及一些关于跟上
    R 世界的一般建议。
- en: ^([1](ch07.xhtml#idm44771312718064-marker)) The [janitor package](https://oreil.ly/-J8GX)
    is not part of the tidyverse, but it offers handy functions for data cleaning
    and works well within data pipelines that use `|>`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.xhtml#idm44771312718064-marker)) [janitor 包](https://oreil.ly/-J8GX)不属于
    tidyverse 的一部分，但它提供了方便的数据清理功能，并且在使用`|>`的数据管道中运行良好。
- en: ^([2](ch07.xhtml#idm44771312159040-marker)) You can override the default of
    1,000 with the `guess_max` argument.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.xhtml#idm44771312159040-marker)) 你可以使用`guess_max`参数覆盖默认的1,000。
