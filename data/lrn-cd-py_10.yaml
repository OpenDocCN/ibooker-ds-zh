- en: Lesson 8\. Advanced string operations
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8课\. 高级字符串操作
- en: After reading [lesson 8](#ch08), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 [第8课](#ch08) 之后，你将能够
- en: Manipulate substrings
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作子串
- en: Do mathematical operations with strings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对字符串进行数学运算
- en: If you’re given a long file, it’s typical to read the entire file as one large
    string. But working with such a large string can be cumbersome. One useful thing
    you might do is break it into smaller substrings—most often, by new lines, so
    that every paragraph or every data entry could be looked at separately. Another
    beneficial thing is to find multiple instances of the same word. You could decide
    that using the word *very* more than 10 times is annoying. Or if you’re reading
    the transcript of someone’s award acceptance speech, you may want to find all
    instances of the word *like* and remove those before posting it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到一个长文件，通常会将整个文件作为一个大字符串来读取。但是处理这样一个大字符串可能会很麻烦。你可能要做的一件有用的事情是将它分解成更小的子串——通常是通过换行符，这样每个段落或每个数据条目都可以单独查看。另一件有益的事情是找到相同单词的多个实例。你可以决定使用单词
    *very* 超过10次是令人烦恼的。或者如果你正在阅读某人的获奖感言的记录，你可能想要找到所有 *like* 的实例并在发布之前将其删除。
- en: '|  |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下情况**'
- en: 'While researching the way that teens text, you gather some data. You’re given
    a long string with many lines, in the following format:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究青少年发短信的方式时，你收集了一些数据。你得到了一个包含许多行的长字符串，格式如下：
- en: '#0001: gr8 lets meet up 2day'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '#0001: gr8 lets meet up 2day'
- en: '#0002: hey did u get my txt?'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '#0002: hey did u get my txt?'
- en: '#0003: ty, pls check for me'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '#0003: ty, pls check for me'
- en: '...'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...'
- en: Given that this is originally one large string, what are some steps that you
    could take to make the data more approachable by analyzing it?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这是一个原始的大字符串，那么你可以采取哪些步骤来通过分析使其数据更易于接近？
- en: 'Answer:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：
- en: '**1**.  Separate the big data string into a substring for each line.'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  将大数据字符串分割成每行的子串。'
- en: '**2**.  Replace common acronyms with proper words (for example, pls with please).'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  将常见的首字母缩略词替换为正确的单词（例如，pls 替换为 please）。'
- en: '**3**.  Count the number of times certain words occur in order to report on
    the most popular acronyms.'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  统计某些单词出现的次数，以便报告最受欢迎的首字母缩略词。'
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.1\. Operations related to substrings
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 与子串相关的操作
- en: In [lesson 7](kindle_split_018.html#ch07), you learned to retrieve a substring
    from a string when you knew what indices you wanted to use. You can do more-advanced
    operations that can give you more information regarding the composition of a string.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第7课](kindle_split_018.html#ch07) 中，你学习了当你知道要使用哪些索引时如何从字符串中检索子串。你可以执行更高级的操作，这些操作可以给你更多关于字符串组成的信息。
- en: 8.1.1\. Find a specific substring in a string with find()
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 使用 `find()` 函数在字符串中查找特定子串
- en: Suppose you have a long list of filenames on your computer and want to find
    out whether a specific file exists, or you want to search for a word in a text
    document. You can find a particular case-sensitive substring inside a larger string
    by using the `find()` command.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你电脑上有一长串文件名，你想知道某个特定文件是否存在，或者你想要在文本文档中搜索一个单词。你可以通过使用 `find()` 命令在更大的字符串中找到特定的区分大小写的子串。
- en: 'As with the commands to manipulate case, you write the string you want to do
    the operation on, then a dot, then the command name, and then the parentheses.
    For example: `"some_string".find()`. Note that the empty string, `''''`, is in
    every string.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作大小写的命令一样，你写下要执行操作的字符串，然后是一个点，然后是命令名称，然后是括号。例如：`"some_string".find()`。注意，空字符串
    `''` 在每个字符串中都是存在的。
- en: But this isn’t all. In addition, you tell the command what substring you want
    to find by putting it in the parentheses—for example, `"some_string".find("ing")`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是全部。此外，你还通过将子串放入括号中来告诉命令你想要查找什么子串——例如，`"some_string".find("ing")`。
- en: The substring you want to find must be a string object. The result you get back
    is the index (starting from 0), in the string, where the substring starts. If
    more than one substring matches, you get the index of the first one found. If
    the substring isn’t in the string, you get `-1`. For example, `"some_string".find("ing")`
    evaluates to `8` because `"ing"` starts at index 8 in `"some_string"`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要查找的子串必须是一个字符串对象。你得到的结果是子串在字符串中开始的索引（从0开始）。如果有多个子串匹配，你得到第一个找到的子串的索引。如果子串不在字符串中，你得到
    `-1`。例如，`"some_string".find("ing")` 的结果是 `8`，因为 `"ing"` 在 `"some_string"` 中从索引8开始。
- en: If you want to start looking for a substring from the end of the string instead
    of the beginning, you can use a different command, `rfind()`. The `r` in `rfind`
    stands for *reverse find*. It looks for the substring nearest to the end of the
    string and reports the index (starting from 0) at which the substring starts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从字符串的末尾开始查找子字符串而不是从开头开始，你可以使用不同的命令，`rfind()`。`rfind`中的`r`代表*反向查找*。它查找离字符串末尾最近的子字符串，并报告子字符串开始的位置（从0开始）。
- en: 'If you have `who = "me myself and I"`, then [figure 8.1](#ch08fig01) shows
    how to evaluate the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设置 `who = "me myself and I"`，那么[图8.1](#ch08fig01)展示了如何评估以下内容：
- en: '`who.find("and")` evaluates to `10` because the substring starts at index 10.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`who.find("and")`的评估结果为`10`，因为子字符串从索引10开始。'
- en: '`who.find("you")` evaluates to `-1` because the substring isn’t in the string.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`who.find("you")`的评估结果为`-1`，因为子字符串不在字符串中。'
- en: '`who.find("e")` evaluates to `1` because the first occurrence of the substring
    is at index 1.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`who.find("e")`的评估结果为`1`，因为子字符串的第一个出现位置在索引1。'
- en: '`who.rfind("el")` evaluates to `6` because the first occurrence of the substring
    nearest to the end of the string is at index 6.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`who.rfind("el")`的评估结果为`6`，因为离字符串末尾最近的子字符串的第一个出现位置在索引6。'
- en: Figure 8.1\. Four examples of substrings to find in the string `"me myself and
    I"`. The arrows indicate the direction in which you’re finding the substring.
    The check mark tells you the index in which you found the substring. An x tells
    you that the substring wasn’t found.
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1. 在字符串`"me myself and I"`中查找子字符串的四个示例。箭头指示查找子字符串的方向。勾号告诉你找到子字符串的索引。一个x告诉你子字符串没有找到。
- en: '![](images/08fig01_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](images/08fig01_alt.jpg)'
- en: '|  |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 8.1**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查8.1**'
- en: 'You’re given `a = "python 4 ever&EVER"`. Evaluate the following expressions.
    Then try them in Spyder to check yourself:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`a = "python 4 ever&EVER"`。评估以下表达式。然后在Spyder中尝试它们以检查自己：
- en: '**[1](kindle_split_056.html#app01qa32q0a1)**'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa32q0a1)**'
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.find("E")`'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.find("E")`'
- en: '**[2](kindle_split_056.html#app01qa32q0a2)**'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa32q0a2)**'
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.find("eve")`'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.find("eve")`'
- en: '**[3](kindle_split_056.html#app01qa32q0a3)**'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa32q0a3)**'
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.rfind("rev")`'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.rfind("rev")`'
- en: '**[4](kindle_split_056.html#app01qa32q0a4)**'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa32q0a4)**'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.rfind("VER")`'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.rfind("VER")`'
- en: '**[5](kindle_split_056.html#app01qa32q0a5)**'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](kindle_split_056.html#app01qa32q0a5)**'
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.find(" ")`'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.find(" ")`'
- en: '**[6](kindle_split_056.html#app01qa32q0a6)**'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6](kindle_split_056.html#app01qa32q0a6)**'
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.rfind(" ")`'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.rfind(" ")`'
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.1.2\. Find out whether a substring is in the string with “in”
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2. 使用“in”查找字符串中是否存在子字符串
- en: The `find` and `rfind` operations tell you where to find a substring. Sometimes
    you only want to know whether the substring is in the string. This is a small
    variation on `find` and `rfind`. You can use the yes or no answer to this question
    more efficiently when you don’t need to know the exact location of the substring.
    Because there are only two values, the answer to this question is an object of
    type Boolean, and the value you get back will be either `True` or `False`. The
    operation to find the answer to this question uses the keyword `in`. For example,
    `"a" in "abc"` is an expression that evaluates to `True` because the string `"a"`
    is in the string `"abc"`. The keyword `in` is used frequently in Python because
    it makes a lot of the code you write look very much like English.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`和`rfind`操作会告诉你子字符串的位置。有时你只想知道子字符串是否在字符串中。这是`find`和`rfind`的一个小变化。当你不需要知道子字符串的确切位置时，你可以更有效地使用这个问题的“是”或“否”答案。因为只有两个值，所以这个问题的答案是布尔类型的对象，你得到的结果将是`True`或`False`。用于找到这个问题的答案的操作使用关键字`in`。例如，`"a"
    in "abc"`是一个评估为`True`的表达式，因为字符串`"a"`在字符串`"abc"`中。关键字`in`在Python中经常使用，因为它使得你编写的很多代码看起来非常像英语。'
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 8.2**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查8.2**'
- en: 'You’re given `a = "python 4 ever&EVER"`. Evaluate the following expressions.
    Then try them in Spyder to check yourself:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`a = "python 4 ever&EVER"`。评估以下表达式。然后在Spyder中尝试它们以检查自己：
- en: '**[1](kindle_split_056.html#app01qa33q0a1)**'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa33q0a1)**'
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`"on" in a`'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`"on" in a`'
- en: '**[2](kindle_split_056.html#app01qa33q0a2)**'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa33q0a2)**'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`"" in a`'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`"" in a`'
- en: '**[3](kindle_split_056.html#app01qa33q0a3)**'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa33q0a3)**'
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`"2 * 2" in a`'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`"2 * 2" in a`'
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.1.3\. Count the number of times a substring occurs with count()
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3. 使用count()计算子字符串出现的次数
- en: Especially when editing a document, you’ll find it useful to make sure you aren’t
    overusing words. Suppose you’re editing an essay and find that within the first
    paragraph, you used the word *so* five times already. Instead of manually counting
    the number of times that word occurs in the whole essay, you can take the text
    you’ve written and automatically find the number of times the substring `"so"`
    occurs by using an operation on strings.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在编辑文档时，您会发现确保您没有过度使用单词很有用。假设您正在编辑一篇文章，并发现在前一段落中，您已经使用了单词 *so* 五次。您不必手动计算整个文章中该单词出现的次数，而是可以通过对字符串进行操作自动找到子字符串
    `"so"` 出现的次数。
- en: You can count the number of times a substring occurs in a string by using `count()`,
    which will give you back an integer. For example, if you have `fruit = "banana"`,
    then `fruit.count("an")` evaluates to `2`. One important point about `count()`
    is that it doesn’t count overlapping substrings. `fruit.count("ana")` evaluates
    to `1` because the `"a"` overlaps between the two occurrences of `"ana"`, as shown
    in [figure 8.2](#ch08fig02).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `count()` 方法来计算一个子字符串在字符串中出现的次数，这将返回一个整数。例如，如果您有 `fruit = "banana"`，那么
    `fruit.count("an")` 的结果为 `2`。关于 `count()` 的一个重要点是它不会计算重叠的子字符串。`fruit.count("ana")`
    的结果为 `1`，因为 `"a"` 在 `"ana"` 的两次出现之间重叠，如图 8.2 所示。
- en: Figure 8.2\. Counting the number of occurrences of `"ana"` in the string `"banana"`.
    The answer is 1 because `"a"` overlaps between the two occurrences, and the Python
    `count()` command doesn’t take this into account.
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2. 计算字符串 `"banana"` 中 `"ana"` 出现的次数。答案是 1，因为 `"a"` 在两次出现之间重叠，而 Python 的
    `count()` 命令不考虑这一点。
- en: '![](images/08fig02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](images/08fig02.jpg)'
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 8.3**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 8.3**'
- en: 'You’re given `a = "python 4 ever&EVER"`. Evaluate the following expressions.
    Then try them in Spyder to check yourself:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `a = "python 4 ever&EVER"`，评估以下表达式。然后尝试在 Spyder 中运行它们以检查自己：
- en: '**[1](kindle_split_056.html#app01qa34q0a1)**'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa34q0a1)**'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.count("ev")`'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.count("ev")`'
- en: '**[2](kindle_split_056.html#app01qa34q0a2)**'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa34q0a2)**'
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.count(" ")`'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.count(" ")`'
- en: '**[3](kindle_split_056.html#app01qa34q0a3)**'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa34q0a3)**'
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.count(" 4 ")`'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.count(" 4 ")`'
- en: '**[4](kindle_split_056.html#app01qa34q0a4)**'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa34q0a4)**'
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.count("eVer")`'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.count("eVer")`'
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.1.4\. Replace substrings with replace()
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4. 使用 replace() 替换子字符串
- en: 'Suppose your son wrote a short report on his favorite fruit: apples. The morning
    of the day it’s due, he changes his mind, hates apples, and now loves pears. You
    can take his entire report as a string and easily replace all instances of the
    word *apple* with *pear*.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的儿子写了一篇关于他最喜欢的水果——苹果的简短报告。报告截止的那天早上，他改变了主意，不再喜欢苹果，现在喜欢梨了。您可以将其整个报告作为一个字符串，并轻松地替换所有
    *apple* 单词为 *pear*。
- en: A final useful string operation is to replace one substring in the string with
    another substring. This command operates on a string, as the previous ones do,
    but you have to put in two items in the parentheses, separated by a comma. The
    first item is the substring to find, and the second is the substring replacement.
    This command replaces all occurrences. For example, `"variables have no spaces".replace("
    ", "_")` replaces all occurrences of the space string with the underscore string
    in the string `"variables have no spaces"`, and evaluates to `"variables_have_no_spaces"`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个有用的字符串操作是将字符串中的一个子字符串替换为另一个子字符串。这个命令与之前的命令一样作用于字符串，但您必须在括号中输入两个项目，用逗号分隔。第一个项目是要查找的子字符串，第二个项目是替换的子字符串。这个命令会替换所有出现。例如，`"variables
    have no spaces".replace(" ", "_")` 将字符串 `"variables have no spaces"` 中的所有空格字符串替换为下划线字符串，并计算为
    `"variables_have_no_spaces"`。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 8.4**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 8.4**'
- en: 'You’re given `a = "Raining in the spring time."` Evaluate the following expressions.
    Then try them in Spyder to check yourself:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `a = "Raining in the spring time."`，评估以下表达式。然后尝试在 Spyder 中运行它们以检查自己：
- en: '**[1](kindle_split_056.html#app01qa35q0a1)**'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa35q0a1)**'
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.replace("R", "r")`'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.replace("R", "r")`'
- en: '**[2](kindle_split_056.html#app01qa35q0a2)**'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa35q0a2)**'
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.replace("ing", "")`'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.replace("ing", "")`'
- en: '**[3](kindle_split_056.html#app01qa35q0a3)**'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa35q0a3)**'
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`a.replace("!", ".")`'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`a.replace("!", ".")`'
- en: '**[4](kindle_split_056.html#app01qa35q0a4)**'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa35q0a4)**'
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`b = a.replace("time","tiempo")`'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`b = a.replace("time","tiempo")`'
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.2\. Mathematical operations
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. 数学运算
- en: 'You can do only two mathematical operations on string objects: addition and
    multiplication.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在字符串对象上执行两种数学运算：加法和乘法。
- en: Addition, which is allowed only between two string objects, is called *concatenation*.
    For example, `"one" + "two"` evaluates to `'onetwo'`. When you add two strings,
    you put the values of each string together, in the order of the addition, to make
    a new string object. You may want to add one string to another if, for example,
    you have three people who worked on a report and wrote individual sections; all
    that remains is to combine the first, then the second, and lastly, the third.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 加法操作只能在两个字符串对象之间进行，这被称为*连接*。例如，`"one" + "two"`的结果是`'onetwo'`。当你把两个字符串相加时，你会按照加法的顺序把每个字符串的值放在一起，以创建一个新的字符串对象。你可能想要把一个字符串加到另一个字符串上，比如，如果你有三个人共同完成了一份报告，并且各自写了不同的部分；剩下的只是将第一部分、第二部分和最后第三部分合并起来。
- en: Multiplication, which is allowed only between a string object and an integer,
    is called *repetition*. For example, `3 * "a"` evaluates to `'aaa'`. When you
    multiply a string by an integer, the string is repeated that many times. Multiplying
    a string by a number is often used to save time and for precision. For example,
    let’s say you want to create a string representing all unknown letters when playing
    hangman. Instead of initializing a string as `"----------",` you could do `"-"
    * 10`. This is especially useful if you don’t know the size of the word to guess
    in advance, and you can store the size in a variable that you’ll then multiply
    by the `"-"` character.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法操作只能在字符串对象和整数之间进行，这被称为*重复*。例如，`3 * "a"`的结果是`'aaa'`。当你用一个整数乘以一个字符串时，字符串会被重复那么多次。用数字乘以字符串通常用于节省时间和提高精度。例如，假设你想创建一个字符串，代表玩“猜字谜”游戏时所有的未知字母。你不必初始化一个字符串为`"----------"`，而是可以这样做：`"-"
    * 10`。这在事先不知道要猜测的单词大小的情况下特别有用，你可以将大小存储在一个变量中，然后乘以`"-"`字符。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 8.5**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 8.5**'
- en: 'Evaluate the following expressions. Then try them in Spyder to check yourself:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 评估以下表达式。然后在 Spyder 中尝试它们以检查自己：
- en: '**[1](kindle_split_056.html#app01qa36q0a1)**'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa36q0a1)**'
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`"la" + "la" + "Land"`'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`"la" + "la" + "Land"`'
- en: '**[2](kindle_split_056.html#app01qa36q0a2)**'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa36q0a2)**'
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`"USA" + " vs " + "Canada"`'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`"USA" + " vs " + "Canada"`'
- en: '**[3](kindle_split_056.html#app01qa36q0a3)**'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa36q0a3)**'
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**[4](kindle_split_056.html#app01qa36q0a4)**'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa36q0a4)**'
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this lesson, my objective was to teach you about more operations you can
    do with string objects, specifically related to substrings. You learned how to
    find whether a substring is in a string, get its index location, count the number
    of times it occurred, and replace all occurrences of the substring. You also saw
    how to add two strings and what it means to multiply a string with a number. Here
    are the major takeaways:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你更多关于字符串对象的操作，特别是与子字符串相关的操作。你学习了如何查找子字符串是否在字符串中，获取其索引位置，计算其出现的次数，以及替换所有子字符串的出现。你还看到了如何将两个字符串相加，以及用数字乘以字符串的含义。以下是主要收获：
- en: You can manipulate a string with just a few operations to make it look the way
    you’d like.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只需通过几个操作就可以操纵一个字符串，使其看起来是你想要的样子。
- en: Concatenating two strings means you’re adding them together.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接两个字符串意味着你正在将它们相加。
- en: Repeating a string means you’re multiplying the string by a number.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复一个字符串意味着你正在用数字乘以字符串。
- en: Let’s see if you got this...
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: '**[Q8.1](kindle_split_056.html#app01qa37q0a1)**'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q8.1](kindle_split_056.html#app01qa37q0a1)**'
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a program that initializes a string with the value `"Eat Work Play Sleep
    repeat"`. Then, use the string manipulation commands you’ve learned so far to
    get the string `"working playing"`.
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个程序，初始化一个字符串值为 `"Eat Work Play Sleep repeat"`。然后，使用你迄今为止学到的字符串操作命令来获取字符串
    `"working playing"`。
