- en: 8 Adversarial search
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 对抗搜索
- en: A two-player, zero-sum, perfect information game is one in which both opponents
    have all of the information about the state of the game available to them, and
    any gain in advantage for one is a loss of advantage for the other. Such games
    include tic-tac-toe, Connect Four, checkers, and chess. In this chapter, we will
    study how to create an artificial opponent that can play such games with great
    skill. In fact, the techniques discussed in this chapter, coupled with modern
    computing power, can create artificial opponents that play simple games of this
    class perfectly and that can play complex games beyond the ability of any human
    opponent.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 双人零和完全信息游戏是指两个对手都有关于游戏状态的全部信息，并且任何一方优势的增加都会导致另一方优势的减少。这类游戏包括井字棋、四子棋、跳棋和国际象棋。在本章中，我们将研究如何创建一个能够以高超技艺玩这类游戏的人工对手。实际上，本章讨论的技术，结合现代计算能力，可以创建出能够完美玩这类简单游戏的人工对手，并且能够玩超越任何人类对手能力的复杂游戏。
- en: 8.1 Basic board game components
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 基本棋盘游戏组件
- en: As with most of our more complex problems in this book, we will try to make
    our solution as generic as possible. In the case of adversarial search, that means
    making our search algorithms non-game-specific. Let’s start by defining some simple
    interfaces that define all of the ways to access state that our search algorithms
    will need. Later, we can implement those interfaces for the specific games we
    are interested in developing (tic-tac-toe and Connect Four) and feed the implementations
    into the search algorithms to make them “play” the games. Here are those interfaces.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书中我们遇到的大多数更复杂的问题一样，我们将尝试使我们的解决方案尽可能通用。在对抗搜索的情况下，这意味着使我们的搜索算法非游戏特定。让我们首先定义一些简单的接口，这些接口定义了我们的搜索算法将需要访问状态的所有方式。稍后，我们可以为我们要开发的特定游戏（井字棋和四子棋）实现这些接口，并将实现输入到搜索算法中，使它们“玩”这些游戏。以下是这些接口。
- en: Listing 8.1 Piece.java
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 Piece.java
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Piece is an interface for a piece on the board in a game. It will also double
    as our turn indicator. This is why the opposite method is needed. We need to know
    whose turn follows a given turn.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Piece 是游戏棋盘上棋子的接口。它也将作为我们的回合指示器。这就是为什么需要相反的方法。我们需要知道给定回合之后是哪个玩家的回合。
- en: TIP Because tic-tac-toe and Connect Four only have one kind of piece, a single
    Piece implementation can double as a turn indicator in this chapter. For a more
    complex game, like chess, that has different kinds of pieces, turns can be indicated
    by an integer or a Boolean. Alternatively, just the “color” attribute of a more
    complex Piece type could be used to indicate turn.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：由于井字棋和四子棋只有一种棋子，所以在这个章节中，单个 Piece 实现可以同时作为回合指示器。对于更复杂的游戏，如国际象棋，回合可以通过整数或布尔值来指示。或者，可以使用更复杂的
    Piece 类型的“颜色”属性来指示回合。
- en: Listing 8.2 Board.java
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 Board.java
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Board describes the interface for a class that is the actual maintainer of
    positional state. For any given game that our search algorithms will compute,
    we need to be able to answer four questions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Board 描述了一个实际维护位置状态的类的接口。对于我们的搜索算法将计算的任何给定游戏，我们需要能够回答四个问题：
- en: Whose turn is it?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁的回合？
- en: What legal moves can be played in the current position?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前局面中可以采取哪些合法的走法？
- en: Is the game won?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏是否已经获胜？
- en: Is the game drawn?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏是否平局？
- en: 'That last question, about draws, is actually a combination of the previous
    two questions for many games. If the game is not won but there are no legal moves,
    then it is a draw. This is why our interface, Board, can already have a concrete
    default implementation of the isDraw() method. In addition, there are a couple
    of actions we need to be able to take:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那最后一个问题，关于平局，实际上是将前两个问题结合在一起，对于许多游戏来说。如果游戏没有获胜，但没有合法的走法，那么就是平局。这就是为什么我们的接口 Board
    已经可以有一个具体的默认实现 isDraw() 方法。此外，还有一些我们需要能够执行的操作：
- en: Make a move to go from the current position to a new position.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行一步棋，从当前位置移动到新的位置。
- en: Evaluate the position to see which player has an advantage.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估位置，以查看哪个玩家有优势。
- en: Each of the methods and properties in Board is a proxy for one of the preceding
    questions or actions. The Board interface could also be called Position in game
    parlance, but we will use that nomenclature for something more specific in each
    of our subclasses.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Board 中的每个方法和属性都是对前面提出的问题或动作的一个代理。在游戏术语中，Board 接口也可以称为 Position，但我们将使用这个术语来表示每个子类中更具体的东西。
- en: Board has a generic type, Move. The Move type will represent a move in a game.
    In this chapter, it can just be an integer. In games like tic-tac-toe and Connect
    Four, an integer can represent a move by indicating a square or column where a
    piece should be placed. In more complex games, more than an integer may be needed
    to describe a move. Making Move generic allows Board to represent a wider variety
    of games.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Board有一个通用类型，Move。Move类型将表示游戏中的移动。在本章中，它可以是整数。在跳棋和四子棋等游戏中，一个整数可以通过指示放置棋子的方格或列来表示一个移动。在更复杂的游戏中，可能需要比整数更多的信息来描述一个移动。使Move通用允许Board表示更广泛的游戏类型。
- en: 8.2 Tic-tac-toe
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 跳棋
- en: Tic-tac-toe is a simple game, but it can be used to illustrate the same minimax
    algorithm that can be applied in advanced strategy games like Connect Four, checkers,
    and chess. We will build a tic-tac-toe AI that plays perfectly using minimax.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 跳棋是一个简单的游戏，但它可以用来说明可以应用于四子棋、国际象棋等高级策略游戏的相同最小-最大算法。我们将构建一个使用最小-最大算法完美玩跳棋的AI。
- en: Note This section assumes that you are familiar with the game tic-tac-toe and
    its standard rules. If not, a quick search on the web should get you up to speed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节假设您熟悉跳棋及其标准规则。如果不熟悉，网上快速搜索应该能帮助您了解情况。
- en: 8.2.1 Managing tic-tac-toe state
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 管理跳棋状态
- en: Let’s develop some structures to keep track of the state of a tic-tac-toe game
    as it progresses.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一些结构来跟踪跳棋游戏的状态，随着游戏的进行。
- en: First, we need a way of representing each square on the tic-tac-toe board. We
    will use an enum called TTTPiece, an implementer of Piece. A tic-tac-toe piece
    can be X, O, or empty (represented by E in the enum).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种表示跳棋棋盘上每个方格的方法。我们将使用一个名为TTTPiece的枚举，它是Piece的实现者。跳棋棋子可以是X、O或空（在枚举中用E表示）。
- en: Listing 8.3 TTTPiece.java
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.3 TTTPiece.java
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The enum TTTPiece has a method, opposite, that returns another TTTPiece. This
    will be useful for flipping from one player’s turn to the other player’s turn
    after a tic-tac-toe move. To represent moves, we will just use an integer that
    corresponds to a square on the board where a piece is placed. As you will recall,
    Move was a generic type in Board. We will specify that Move is an Integer when
    we define TTTBoard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型TTTPiece有一个名为opposite的方法，它返回另一个TTTPiece对象。这在跳棋移动后从一位玩家的回合切换到另一位玩家的回合时将非常有用。为了表示移动，我们将仅使用一个整数，该整数对应于放置棋子的棋盘上的一个方格。如您所回忆的，Move是Board的通用类型。当我们定义TTTBoard时，我们将指定Move是整数。
- en: A tic-tac-toe board has nine positions organized in three rows and three columns.
    For simplicity, these nine positions can be represented using a one-dimensional
    array. Which squares receive which numeric designation (a.k.a., index in the array)
    is arbitrary, but we will follow the scheme outlined in figure 8.1.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 跳棋棋盘有九个位置，组织成三行三列。为了简单起见，这九个位置可以使用一维数组表示。哪些方格接收哪些数字标识（即数组的索引）是任意的，但我们将遵循图8.1中概述的方案。
- en: '![8-1](../Images/8-1.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![8-1](../Images/8-1.png)'
- en: Figure 8.1 The one-dimensional array indices that correspond to each square
    in the tic-tac-toe board
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 跳棋棋盘上每个方格对应的一维数组索引
- en: 'The main holder of state will be the class TTTBoard. TTTBoard keeps track of
    two different pieces of state: the position (represented by the aforementioned
    one-dimensional list) and the player whose turn it is.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 状态的主要持有者是类TTTBoard。TTTBoard跟踪两个不同的状态：位置（由上述一维列表表示）和当前轮到哪个玩家。
- en: Listing 8.4 TTTBoard.java
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 TTTBoard.java
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A default board is one where no moves have yet been made (an empty board). The
    no-parameter constructor for TTTBoard initializes such a position, with X to move
    (the usual first player in tic-tac-toe). getTurn() indicates whose turn it is
    in the current position, X or O.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认棋盘是指尚未进行任何移动的棋盘（一个空棋盘）。TTTBoard的无参数构造函数初始化这样的位置，X轮到移动（跳棋中的通常第一个玩家）。getTurn()指示当前位置轮到哪个玩家，X或O。
- en: TTTBoard is an informally immutable data structure; TTTBoards should not be
    modified. Instead, every time a move needs to be played, a new TTTBoard with the
    position changed to accommodate the move will be generated. This will later be
    helpful in our search algorithm. When the search branches, we will not inadvertently
    change the position of a board from which potential moves are still being analyzed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TTTBoard是一个非正式不可变的数据结构；TTTBoards不应该被修改。相反，每次需要执行移动时，都会生成一个新的TTTBoard，其位置已更改以适应移动。这将在我们的搜索算法中很有帮助。当搜索分支时，我们不会无意中更改仍在分析潜在移动的棋盘的位置。
- en: Listing 8.5 TTTBoard.java continued
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.5 TTTBoard.java 继续内容
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A legal move in tic-tac-toe is any empty square. getLegalMoves() looks for any
    empty squares on the board and returns a list of them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋的一个合法走法是任何空方格。getLegalMoves() 方法在棋盘上寻找任何空方格，并返回它们的列表。
- en: Listing 8.6 TTTBoard.java continued
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 TTTBoard.java 继续内容
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are many ways to scan the rows, columns, and diagonals of a tic-tac-toe
    board to check for wins. The following implementation of the method isWin(), along
    with its helper method, checkPos(), does so with a hardcoded, seemingly endless
    amalgamation of &&, ||, and ==. It is not the prettiest code, but it does the
    job in a straightforward manner.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以扫描井字棋板的行、列和对角线以检查胜利。以下方法 isWin() 的实现及其辅助方法 checkPos() 以硬编码的、看似无尽的 &&、||
    和 == 的组合来完成。这不是最漂亮的代码，但它以直接的方式完成了工作。
- en: Listing 8.7 TTTBoard.java continued
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 TTTBoard.java 继续内容
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If all of a row’s, column’s, or diagonal’s squares are not empty, and they contain
    the same piece, the game has been won.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一行、一列或对角线上的所有方格都不为空，并且它们包含相同的棋子，那么游戏已经获胜。
- en: A game is drawn if it is not won and there are no more legal moves left; that
    property was already covered by the Board interface’s default method isDraw().
    Finally, we need a way of evaluating a particular position and pretty-printing
    the board.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游戏没有获胜且没有剩余的合法走法，则游戏是平局；这个属性已经被 Board 接口的默认方法 isDraw() 所涵盖。最后，我们需要一种评估特定位置和美化打印棋盘的方法。
- en: Listing 8.8 TTTBoard.java continued
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 TTTBoard.java 继续内容
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For most games, an evaluation of a position needs to be an approximation, because
    we cannot search the game to the very end to find out with certainty who wins
    or loses depending on what moves are played. But tic-tac-toe has a small enough
    search space that we can search from any position to the very end. Therefore,
    the evaluate() method can simply return one number if the player wins, a worse
    number for a draw, and an even worse number for a loss.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数游戏，对位置的评估需要是一个近似值，因为我们无法搜索整个游戏以确定谁赢谁输，这取决于所采取的走法。但是，井字棋的搜索空间足够小，我们可以从任何位置搜索到游戏结束。因此，evaluate()
    方法可以简单地返回一个数字，如果玩家获胜，则返回一个更差的数字表示平局，如果玩家失败，则返回一个更差的数字。
- en: 8.2.2 Minimax
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 Minimax
- en: Minimax is a classic algorithm for finding the best move in a two-player, zero-sum
    game with perfect information, like tic-tac-toe, checkers, or chess. It has been
    extended and modified for other types of games as well. Minimax is typically implemented
    using a recursive function in which each player is designated either the maximizing
    player or the minimizing player.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Minimax 是一个经典的算法，用于在两人零和游戏中找到最佳走法，如井字棋、跳棋或国际象棋。它已经被扩展和修改用于其他类型的游戏。Minimax 通常使用递归函数实现，其中每个玩家被指定为最大化玩家或最小化玩家。
- en: The maximizing player aims to find the move that will lead to maximal gains.
    However, the maximizing player must account for moves by the minimizing player.
    After each attempt to maximize the gains of the maximizing player, minimax is
    called recursively to find the opponent’s reply that minimizes the maximizing
    player’s gains. This continues back and forth (maximizing, minimizing, maximizing,
    and so on) until a base case in the recursive function is reached. The base case
    is a terminal position (a win or a draw) or a maximal search depth.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化的玩家旨在找到能带来最大收益的走法。然而，最大化玩家必须考虑到最小化玩家的走法。在尝试最大化最大化玩家的收益之后，minimax 递归调用以找到对手的回应，该回应将最小化最大化玩家的收益。这个过程来回进行（最大化、最小化、最大化，等等），直到递归函数中的基本案例被达到。基本案例是一个终端位置（胜利或平局）或最大搜索深度。
- en: Minimax will return an evaluation of the starting position for the maximizing
    player. For the evaluate() method of the TTTBoard class, if the best possible
    play by both sides will result in a win for the maximizing player, a score of
    1 will be returned. If the best play will result in a loss, -1 is returned. A
    0 is returned if the best play is a draw.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Minimax 将返回最大化玩家的起始位置的评估。对于 TTTBoard 类的 evaluate() 方法，如果双方的最佳走法将导致最大化玩家获胜，则返回分数
    1。如果最佳走法将导致失败，则返回 -1。如果最佳走法是平局，则返回 0。
- en: These numbers are returned when a base case is reached. They then bubble up
    through all of the recursive calls that led to the base case. For each recursive
    call to maximize, the best evaluations one level further down bubble up. For each
    recursive call to minimize, the worst evaluations one level further down bubble
    up. In this way, a decision tree is built. Figure 8.2 illustrates such a tree
    that facilitates bubbling up for a game with two moves left.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到基本案例时，会返回这些数字。然后，这些数字会通过所有导致基本案例的递归调用向上冒泡。对于每个最大化递归调用，下一级最佳评价会向上冒泡。对于每个最小化递归调用，下一级最差评价会向上冒泡。通过这种方式，构建了一个决策树。图8.2展示了这样一个树，它有助于在只剩两步棋的情况下进行冒泡。
- en: For games that have a search space too deep to reach a terminal position (such
    as checkers and chess), minimax is stopped after a certain depth (the number of
    moves deep to search, sometimes called *ply*). Then the evaluation function kicks
    in, using heuristics to score the state of the game. The better the game is for
    the originating player, the higher the score that is awarded. We will come back
    to this concept with Connect Four, which has a much larger search space than tic-tac-toe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于搜索空间太深而无法达到终端位置的游戏（如跳棋和国际象棋），在达到一定深度后（搜索的步数深度，有时称为*ply*）minimax会停止。然后，评估函数开始工作，使用启发式方法对游戏状态进行评分。游戏对原始玩家越有利，所获得的分数就越高。我们将在四子棋中回到这个概念，它的搜索空间比井字棋大得多。
- en: '![8-2](../Images/8-2.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![8-2](../Images/8-2.png)'
- en: Figure 8.2 A minimax decision tree for a tic-tac-toe game with two moves left.
    To maximize the likelihood of winning, the initial player, O, will choose to play
    O in the bottom center. Arrows indicate the positions from which a decision is
    made.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 一个剩余两步棋的井字游戏minimax决策树。为了最大化获胜的可能性，初始玩家O会选择在底部中央放置O。箭头指示决策的位置。
- en: Here is minimax() in its entirety.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是整个minimax()函数。
- en: Listing 8.9 Minimax.java
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.9 Minimax.java
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In each recursive call, we need to keep track of the board position, whether
    we are maximizing or minimizing, and who we are trying to evaluate the position
    for (originalPlayer). The first few lines of minimax() deal with the base case:
    a terminal node (a win, loss, or draw) or the maximum depth being reached. The
    rest of the function is the recursive cases.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个递归调用中，我们需要跟踪棋盘位置、我们是在最大化还是最小化，以及我们试图为谁评估位置（originalPlayer）。minimax()的前几行处理基本案例：终端节点（胜利、失败或平局）或达到最大深度。函数的其余部分是递归情况。
- en: One recursive case is maximization. In this situation, we are looking for a
    move that yields the highest possible evaluation. The other recursive case is
    minimization, where we are looking for the move that results in the lowest possible
    evaluation. Either way, the two cases alternate until we reach a terminal state
    or the maximum depth (base case).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 递归情况之一是最大化。在这种情况下，我们正在寻找一个能产生最高评价的走法。另一个递归情况是最小化，我们正在寻找导致最低可能评价的走法。无论哪种情况，这两个情况会交替进行，直到我们达到终端状态或最大深度（基本案例）。
- en: Unfortunately, we cannot use our implementation of minimax() as is to find the
    best move for a given position. It returns an evaluation (a double value). It
    does not tell us what best first move led to that evaluation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们不能直接使用我们的minimax()实现来找到给定位置的最佳走法。它返回一个评估（一个双精度值）。它不会告诉我们是什么最佳第一步导致了那个评估。
- en: Instead, we will create a helper function, findBestMove(), that loops through
    calls to minimax() for each legal move in a position to find the move that evaluates
    to the highest value. You can think of findBestMove() as the first maximizing
    call to minimax(), but with us keeping track of those initial moves.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个辅助函数findBestMove()，该函数会遍历对位置中每个合法走法的minimax()调用，以找到评估为最高值的走法。你可以将findBestMove()视为对minimax()的第一个最大化调用，但我们要跟踪那些初始走法。
- en: Listing 8.10 Minimax.java continued
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 Minimax.java 续
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now have everything ready to find the best possible move for any tic-tac-toe
    position.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好找到任何井字棋位置的最佳可能走法。
- en: 8.2.3 Testing minimax with tic-tac-toe
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 使用井字棋测试minimax
- en: Tic-tac-toe is such a simple game that it’s easy for us, as humans, to figure
    out the definite correct move in a given position. This makes it possible to easily
    develop unit tests. In the following code snippet, we will challenge our minimax
    algorithm to find the correct next move in three different tic-tac-toe positions.
    The first is easy and only requires it to think to the next move for a win. The
    second requires a block; the AI must stop its opponent from scoring a victory.
    The last is a little bit more challenging and requires the AI to think two moves
    into the future.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋如此简单，以至于我们作为人类很容易在给定位置中找出正确的下一步。这使得我们能够轻松地开发单元测试。在下面的代码片段中，我们将挑战我们的最小-最大算法在三个不同的井字棋位置中找到正确的下一步。第一个很简单，只需要考虑下一步就能获胜。第二个需要阻止；AI必须阻止对手得分。最后一个稍微有点挑战性，需要AI考虑两步之内的未来。
- en: WARNING At the beginning of this book I promised you that all examples would
    use only the Java standard library. And, unfortunately for this next snippet of
    code, I have stuck to my promise. In reality, unit testing is best done using
    a mature framework like JUnit, instead of rolling your own, as we do here. But
    this example is interesting for its illustration of reflection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: WARNING 在本书的开头，我承诺所有示例都将仅使用Java标准库。不幸的是，对于接下来的代码片段，我坚持了我的承诺。实际上，单元测试最好使用成熟的框架，如JUnit，而不是像我们在这里所做的那样自己构建。但这个例子因其对反射的说明而很有趣。
- en: Listing 8.11 TTTMinimaxTests.java
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.11 TTTMinimaxTests.java
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As was mentioned in the preceding note, it’s probably not a good idea to roll
    your own unit testing framework instead of using something like JUnit. That said,
    it’s also not that hard, thanks to Java’s reflection capabilities. Each method
    representing a test is annotated with a custom annotation called UnitTest, defined
    at the top of the file. The method runAllTests() looks for all methods with that
    annotation and runs them along with some helpful printouts. assertEquality() checks
    if two items are equal, and if they’re not, prints them out. While it might not
    be a good idea to define your own unit testing framework, it is interesting to
    see how one could work. To take our framework to the next level, we would probably
    define a base class that includes runAllTests() and assertEquality() that other
    testing classes could extend.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，自己构建单元测试框架而不是使用JUnit等工具可能不是一个好主意。但话说回来，这也不难，多亏了Java的反射能力。代表测试的每个方法都使用在文件顶部定义的自定义注解UnitTest进行注解。runAllTests()方法查找所有带有该注解的方法，并运行它们，同时还有一些有用的打印输出。assertEquality()检查两个项目是否相等，如果不相等，则打印它们。虽然定义自己的单元测试框架可能不是一个好主意，但了解它是如何工作的很有趣。为了将我们的框架提升到下一个层次，我们可能会定义一个基类，该类包括runAllTests()和assertEquality()，其他测试类可以扩展它。
- en: All three of the tests should pass when you run TTTMinimaxTests.java.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行TTTMinimaxTests.java时，所有三个测试都应该通过。
- en: TIP It does not take much code to implement minimax, and it will work for many
    more games than just tic-tac-toe. If you plan to implement minimax for another
    game, it is important to set yourself up for success by creating data structures
    that work well for the way minimax is designed, like the Board class. A common
    mistake for students learning minimax is to use a modifiable data structure that
    gets changed by a recursive call to minimax and then cannot be rewound to its
    original state for additional calls.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 实现最小-最大算法并不需要很多代码，它适用于比井字棋更多的游戏。如果你计划为另一款游戏实现最小-最大算法，重要的是通过创建适合最小-最大算法设计的数据结构来为自己设定成功的基础，例如Board类。学生在学习最小-最大算法时常见的错误是使用可修改的数据结构，该数据结构会被最小-最大算法的递归调用所更改，然后无法回滚到其原始状态以进行额外的调用。
- en: 8.2.4 Developing a tic-tac-toe AI
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 开发井字棋AI
- en: With all of these ingredients in place, it is trivial to take the next step
    and develop a full artificial opponent that can play an entire game of tic-tac-toe.
    Instead of evaluating a test position, the AI will just evaluate the position
    generated by each opponent’s move. In the following short code snippet, the tic-tac-toe
    AI plays against a human opponent who goes first.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些成分都到位的情况下，下一步开发一个完整的井字棋人工智能对手是微不足道的。AI不会评估测试位置，而是评估每个对手移动生成的位置。在下面的简短代码片段中，井字棋AI与先手的人类对手进行对弈。
- en: Listing 8.12 TicTacToe.java
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 TicTacToe.java
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By setting the maxDepth parameter of findBestMove() to 9 (it could be 8, really),
    this tic-tac-toe AI will always see to the very end of the game. (The maximum
    number of moves in tic-tac-toe is nine, and the AI goes second.) Therefore, it
    should play perfectly every time. A perfect game is one in which both opponents
    play the best possible move every turn. The result of a perfect game of tic-tac-toe
    is a draw. With this in mind, you should never be able to beat the tic-tac-toe
    AI. If you play your best, it will be a draw. If you make a mistake, the AI will
    win. Try it out yourself. You should not be able to beat it. Here’s an example
    run of our program:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 findBestMove() 方法的 maxDepth 参数设置为 9（实际上可以是 8），这个井字棋 AI 将始终看到游戏的尽头。（井字棋的最大移动次数是九次，AI
    是第二位玩家。）因此，它应该每次都玩得完美。完美游戏是指双方在每个回合都做出最佳可能的移动。井字棋完美游戏的结果是平局。考虑到这一点，你永远不应该能够击败井字棋
    AI。如果你发挥出最佳水平，结果将是平局。如果你犯了一个错误，AI 将获胜。试试看吧。你不应该能够击败它。以下是我们程序的一个示例运行：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 8.3 Connect Four
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 四子棋
- en: In Connect Four,[1](#pgfId-1164433) two players alternate dropping different-colored
    pieces in a seven-column, six-row vertical grid. Pieces fall from the top of the
    grid to the bottom until they hit the bottom or another piece. In essence, the
    player’s only decision each turn is which of the seven columns to drop a piece
    into. The player cannot drop it into a full column. The first player that has
    four pieces of their color next to one another with no breaks in a row, column,
    or diagonal wins. If no player achieves this, and the grid is completely filled,
    the game is a draw.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在四子棋游戏中，[1](#pgfId-1164433) 两位玩家轮流在七列六行的垂直网格中投放不同颜色的棋子。棋子从网格顶部落下到底部，直到碰到底部或另一个棋子。本质上，玩家每轮唯一的决定就是将棋子投放到哪一列。玩家不能将棋子投放到已满的列中。第一个将四颗同色棋子连成一线（无间断的行、列或对角线）的玩家获胜。如果没有任何玩家达到这个条件，且网格完全填满，则游戏为平局。
- en: 8.3.1 Connect Four game machinery
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 四子棋游戏机制
- en: Connect Four, in many ways, is similar to tic-tac-toe. Both games are played
    on a grid and require the player to line up pieces to win. But because the Connect
    Four grid is larger and has many more ways to win, evaluating each position is
    significantly more complex.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，四子棋与井字棋相似。两款游戏都在网格上进行，要求玩家排列棋子以获胜。但由于四子棋的网格更大，获胜的方式更多，评估每个位置要复杂得多。
- en: Some of the following code will look very familiar, but the data structures
    and the evaluation method are quite different from tic-tac-toe. Both games are
    built using classes that implement the same base Piece and Board interfaces you
    saw at the beginning of the chapter, making minimax() usable for both games.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的一些代码看起来非常熟悉，但数据结构和评估方法与井字棋有很大不同。两款游戏都是使用在章节开头看到的相同基类 Piece 和 Board 接口实现的类构建的，这使得
    minimax() 方法可以用于两款游戏。
- en: Listing 8.13 C4Piece.java
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.13 C4Piece.java
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The C4Piece class is almost identical to the TTTPiece class. We will also have
    a convenience class, C4Location for keeping track of a location on the board’s
    grid (a column/row pair). Connect Four is a column-oriented game, so we implement
    all of its grid code in the unusual format of column first.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: C4Piece 类几乎与 TTTPiece 类相同。我们还将有一个便利类，C4Location，用于跟踪棋盘网格上的位置（一列/一行对）。四子棋是一种以列为导向的游戏，因此我们以列优先的不寻常格式实现了其所有网格代码。
- en: Listing 8.14 C4Location.java
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14 C4Location.java
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we turn to the heart of our Connect Four implementation, the C4Board class.
    This class defines some static constants and one static method. The static method
    generateSegments() returns a list of arrays of grid locations (C4Locations). Each
    array in the list contains four grid locations. We call each of these arrays of
    four grid locations a *segment*. If any segment from the board is all the same
    color, that color has won the game.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们转向四子棋实现的精髓，即 C4Board 类。这个类定义了一些静态常量和一种静态方法。静态方法 generateSegments() 返回一个包含网格位置数组（C4Locations）的列表。列表中的每个数组包含四个网格位置。我们称这些四个网格位置的数组为
    *段*。如果棋盘上的任何段都是同一种颜色，那么这种颜色就赢得了游戏。
- en: Being able to quickly search all of the segments on the board is useful for
    both checking whether a game is over (someone has won) and for evaluating a position.
    Hence, you will notice in the next code snippet that we cache the segments for
    the board as a class variable called SEGMENTS in the C4Board class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 能够快速搜索棋盘上的所有段对于检查游戏是否结束（有人获胜）以及评估位置都很有用。因此，你会在下一个代码片段中注意到，我们在 C4Board 类中将棋盘的段缓存为类变量
    SEGMENTS。
- en: Listing 8.15 C4Board.java
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.15 C4Board.java
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We store the current position in a two-dimensional array of C4Piece called position.
    In most cases, two-dimensional arrays are indexed row first. But thinking about
    the Connect Four board as a group of seven columns is conceptually powerful and
    makes writing the rest of the C4Board class slightly easier. For example, the
    accompanying array, columnCount, keeps track of how many pieces are in any given
    column at a time. And this makes generating legal moves easy, since each move
    is essentially a selection of a non-filled column.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前位置存储在一个名为 position 的二维 C4Piece 数组中。在大多数情况下，二维数组是按行索引的。但将四子棋棋盘视为一组七个列在概念上非常强大，这使得编写
    C4Board 类的其余部分稍微容易一些。例如，伴随的数组 columnCount 跟踪任何给定时间任何列中的棋子数量。这使得生成合法走法变得容易，因为每一步本质上是一个非填充列的选择。
- en: The next four methods are fairly similar to their tic-tac-toe equivalents.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个方法与井字棋的对应方法相当相似。
- en: Listing 8.16 C4Board.java continued
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.16 C4Board.java 继续内容
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A private helper method, countSegment(), returns the number of black or red
    pieces in a particular segment. It is followed by the win-checking method, isWin(),
    which looks at all of the segments in the board and determines a win by using
    countSegment() to see if any segments have four of the same color.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个私有辅助方法，countSegment()，返回特定片段中黑色或红色棋子的数量。它后面是 win-checking 方法，isWin()，它检查棋盘上的所有片段，并使用
    countSegment() 来确定是否有任何片段有四种同色棋子。
- en: Listing 8.17 C4Board.java continued
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.17 C4Board.java 继续内容
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Like TTTBoard, C4Board can use the Board interface’s isDraw() default method
    without modification.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TTTBoard 一样，C4Board 可以不修改地使用 Board 接口的 isDraw() 默认方法。
- en: Finally, to evaluate a position, we will evaluate all of its representative
    segments, one segment at a time, and sum those evaluations to return a result.
    A segment that has both red and black pieces will be considered worthless. A segment
    that has two of the same color and two empties will be considered a score of 1\.
    A segment with three of the same color will be scored 100\. Finally, a segment
    with four of the same color (a win) is scored 1,000,000\. These evaluate numbers
    are arbitrary in absolute terms but their importance lies in their relative weight
    to one another. If the segment is the opponent’s segment, we will negate its score.
    evaluateSegment() is a private helper method that evaluates a single segment using
    the preceding formula. The composite score of all segments using evaluateSegment()
    is generated by evaluate().
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了评估一个位置，我们将评估其所有代表性片段，一次评估一个片段，并将这些评估相加以返回一个结果。同时包含红色和黑色棋子的片段将被视为毫无价值。包含两种颜色各两个棋子和两个空位的片段将被视为得分为
    1。包含三种同色棋子的片段得分为 100。最后，包含四种同色棋子（胜利）的片段得分为 1,000,000。这些评估数字在绝对意义上是任意的，但它们的重要性在于它们相互之间的相对权重。如果片段是对手的片段，我们将取其分数的相反数。evaluateSegment()
    是一个私有辅助方法，它使用前面的公式评估单个片段。使用 evaluateSegment() 生成所有片段的复合分数由 evaluate() 生成。
- en: Listing 8.18 C4Board.java continued
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.18 C4Board.java 继续内容
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 8.3.2 A Connect Four AI
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 四子棋 AI
- en: Amazingly, the same minimax() and findBestMove() functions we developed for
    tic-tac-toe can be used unchanged with our Connect Four implementation. In the
    following code snippet, there are only a couple of changes from the code for our
    tic-tac-toe AI. The big difference is that maxDepth is now set to 5. That enables
    the computer’s thinking time per move to be reasonable. In other words, our Connect
    Four AI looks at (evaluates) positions up to five moves in the future.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们为井字棋开发的 minimax() 和 findBestMove() 函数可以无需修改地直接用于我们的四子棋实现。在下面的代码片段中，与我们的井字棋
    AI 代码相比，只有几个改动。最大的不同是 maxDepth 现在设置为 5。这使得计算机每步的思考时间变得合理。换句话说，我们的四子棋 AI 会评估未来五步的位置。
- en: Listing 8.19 ConnectFour.java
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.19 ConnectFour.java
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Try playing the Connect Four AI. You will notice that it takes a few seconds
    to generate each move, unlike the tic-tac-toe AI. It will probably still beat
    you unless you’re carefully thinking about your moves. It at least will not make
    any completely obvious mistakes. We can improve its play by increasing the depth
    that it searches, but each computer move will take exponentially longer to compute.
    Here’s the first few moves of a game against our AI:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试玩四子棋 AI。你会注意到它生成每一步需要几秒钟，这与井字棋 AI 不同。除非你仔细思考你的走法，否则它可能仍然会打败你。至少它不会犯任何完全明显的错误。我们可以通过增加它搜索的深度来提高其表现，但每一步的计算机计算时间将呈指数增长。以下是我们与
    AI 对战的前几步棋：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: TIP Did you know Connect Four has been “solved” by computer scientists? To solve
    a game means to know the best move to play in any position. The best first move
    in Connect Four is to place your piece in the center column.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：你知道四子棋已经被计算机科学家“解决”了吗？解决一个游戏意味着知道在任何位置下最佳走法。四子棋的最佳第一步是将你的棋子放在中间列。
- en: 8.3.3 Improving minimax with alpha-beta pruning
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 使用 alpha-beta 剪枝改进 minimax
- en: 'Minimax works well, but we are not getting a very deep search at present. There
    is a small extension to minimax, known as *alpha-beta pruning*, that can improve
    search depth by excluding positions in the search that will not result in improvements
    over positions already searched. This magic is accomplished by keeping track of
    two values between recursive minimax calls: alpha and beta. *Alpha* represents
    the evaluation of the best maximizing move found up to this point in the search
    tree, and *beta* represents the evaluation of the best minimizing move found so
    far for the opponent. If beta is ever less than or equal to alpha, it’s not worth
    further exploring this branch of the search, because a better or equivalent move
    has already been found than will be found farther down this branch. This heuristic
    decreases the search space significantly.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Minimax 算法效果良好，但目前我们并没有进行非常深入的搜索。有一种对 minimax 的扩展，称为 *alpha-beta 剪枝*，可以通过排除搜索中不会比已搜索位置产生改进的位置来提高搜索深度。这种神奇的效果是通过在递归
    minimax 调用之间跟踪两个值来实现的：alpha 和 beta。*Alpha* 代表在搜索树中找到的最佳最大化走法的评估，而 *beta* 代表迄今为止找到的最佳最小化走法的评估。如果
    beta 低于或等于 alpha，那么进一步探索这个搜索分支就不再值得，因为已经找到了比在这个分支下更优或等效的走法。这种启发式方法可以显著减少搜索空间。
- en: Here is alphabeta() as just described. It should be put into our existing Minimax.java
    file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是刚刚描述的 alphabeta()。它应该放入我们现有的 Minimax.java 文件中。
- en: Listing 8.20 Minimax.java continued
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.20 Minimax.java 继续部分
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now you can make two very small changes to take advantage of our new function.
    Change findBestMove() in Minimax.java to use alphabeta() instead of minimax(),
    and change the search depth in ConnectFour.java to 7 from 5. With these changes,
    your average Connect Four player will not be able to beat our AI. On my computer,
    using minimax() at a depth of 7, our Connect Four AI takes about 20 seconds per
    move, whereas using alphabeta() at the same depth takes just a couple seconds.
    That’s one tenth of the time! That is quite an incredible improvement.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以进行两个非常小的改动来利用我们新的函数。将 Minimax.java 中的 findBestMove() 改为使用 alphabeta() 而不是
    minimax()，并将 ConnectFour.java 中的搜索深度从 5 改为 7。有了这些改动，你的平均四子棋玩家将无法击败我们的 AI。在我的电脑上，使用
    minimax() 在深度为 7 时，我们的四子棋 AI 每步大约需要 20 秒，而使用 alphabeta() 在相同深度下只需几秒钟。这几乎是十分之一的时间！这是一个相当惊人的改进。
- en: 8.4 Minimax improvements beyond alpha-beta pruning
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 超过 alpha-beta 剪枝的 minimax 改进
- en: The algorithms presented in this chapter have been deeply studied, and many
    improvements have been found over the years. Some of those improvements are game-specific,
    such as “bitboards” in chess decreasing the time it takes to generate legal moves,
    but most are general techniques that can be utilized for any game.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提出的算法已经经过了深入研究，多年来发现了许多改进。其中一些改进是针对特定游戏的，例如在棋类游戏中使用“位图”来减少生成合法走法的耗时，但大多数改进是通用的技术，可以用于任何游戏。
- en: One common technique is iterative deepening. In iterative deepening, first the
    search function is run to a maximum depth of 1\. Then it is run to a maximum depth
    of 2\. Then it is run to a maximum depth of 3, and so on. When a specified time
    limit is reached, the search is stopped. The result from the last completed depth
    is returned.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的技术是迭代加深。在迭代加深中，首先将搜索函数运行到最大深度为 1。然后运行到最大深度为 2。然后运行到最大深度为 3，以此类推。当达到指定的时间限制时，搜索停止。返回最后完成深度的结果。
- en: The examples in this chapter were hardcoded to a certain depth. This is okay
    if the game is played without a game clock and time limits or if we do not care
    how long the computer takes to think. Iterative deepening enables an AI to take
    a fixed amount of time to find its next move instead of a fixed amount of search
    depth with a variable amount of time to complete it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例被硬编码到一定的深度。如果游戏没有游戏时钟和时间限制，或者我们不在乎电脑思考的时间长短，这样做是可以的。迭代加深使 AI 能够在固定时间内找到其下一步走法，而不是在固定搜索深度下，完成它需要可变的时间。
- en: Another potential improvement is quiescence search. In this technique, the minimax
    search tree will be further expanded along routes that cause large changes in
    position (captures in chess, for instance), rather than routes that have relatively
    “quiet” positions. In this way, ideally the search will not waste computing time
    on boring positions that are unlikely to gain the player a significant advantage.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种潜在的改进是静默搜索。在这种技术中，最小-最大搜索树将沿着导致位置发生重大变化（例如，象棋中的捕获）的路径进一步扩展，而不是沿着具有相对“安静”位置的路径。以这种方式，理想情况下，搜索将不会在不太可能为玩家带来显著优势的乏味位置上浪费计算时间。
- en: The two best ways to improve upon minimax search is to search to a greater depth
    in the allotted amount of time or improve upon the evaluation function used to
    assess a position. Searching more positions in the same amount of time requires
    spending less time on each position. This can come from finding code efficiencies
    or using faster hardware, but it can also come at the expense of the latter improvement
    technique--improving the evaluation of each position. Using more parameters or
    heuristics to evaluate a position may take more time, but it can ultimately lead
    to a better engine that needs less search depth to find a good move.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要改进最小-最大搜索，有两种最好的方法：在分配的时间内搜索更深的层次，或者改进用于评估位置的评估函数。在相同的时间内搜索更多位置需要在每个位置上花费更少的时间。这可以通过找到代码效率或使用更快的硬件来实现，但也可能以牺牲后者改进技术——改进每个位置的评估为代价。使用更多参数或启发式方法来评估位置可能需要更多时间，但最终可能导致需要更少搜索深度来找到好走的引擎。
- en: Some evaluation functions used for minimax search with alpha-beta pruning in
    chess have dozens of heuristics. Genetic algorithms have even been used to tune
    these heuristics. How much should the capture of a knight be worth in a game of
    chess? Should it be worth as much as a bishop? These heuristics can be the secret
    sauce that separates a great chess engine from one that is just good.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用于象棋中alpha-beta剪枝的最小-最大搜索的一些评估函数有数十种启发式方法。甚至已经使用遗传算法来调整这些启发式方法。在象棋游戏中，骑士的捕获应该值多少？它应该和主教一样值吗？这些启发式方法可能是区分优秀象棋引擎和一般象棋引擎的秘密成分。
- en: 8.5 Real-world applications
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 真实世界的应用
- en: Minimax, combined with further extensions like alpha-beta pruning, is the basis
    of most modern chess engines. It has been applied to a wide variety of strategy
    games with great success. In fact, most of the board game artificial opponents
    that you play on your computer probably use some form of minimax.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最小-最大算法，结合如alpha-beta剪枝等进一步的扩展，是大多数现代象棋引擎的基础。它已经成功应用于各种策略游戏。事实上，你可能在电脑上玩的大部分棋类游戏的人工对手可能都使用了某种形式的最小-最大算法。
- en: Minimax (with its extensions, like alpha-beta pruning) has been so effective
    in chess that it led to the famous 1997 defeat of the human chess world champion,
    Gary Kasparov, by Deep Blue, a chess-playing computer made by IBM. The match was
    a highly anticipated and game-changing event. Chess was seen as a domain of the
    highest intellectual caliber. The fact that a computer could exceed human ability
    in chess meant, to some, that artificial intelligence should be taken seriously.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最小-最大算法（及其扩展，如alpha-beta剪枝）在象棋中的效果如此显著，以至于它导致了1997年IBM制造的象棋计算机Deep Blue击败人类象棋世界冠军加里·卡斯帕罗夫的著名事件。这场比赛是一个高度期待且具有变革性的事件。象棋被视为最高智力水平的领域。计算机在象棋中超越人类能力的事实，对某些人来说意味着人工智能应该被认真对待。
- en: Two decades later, the vast majority of chess engines still are based on minimax.
    Today’s minimax-based chess engines far exceed the strength of the world’s best
    human chess players. New machine learning techniques are starting to challenge
    pure minimax-based (with extensions) chess engines, but they have yet to definitively
    prove their superiority in chess.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 二十年后，绝大多数象棋引擎仍然基于最小-最大算法。今天基于最小-最大算法的象棋引擎远远超过了世界上最好的人类象棋选手。新的机器学习技术开始挑战纯最小-最大算法（及其扩展）的象棋引擎，但它们还没有在象棋中明确证明其优越性。
- en: The higher the branching factor for a game, the less effective minimax will
    be. The branching factor is the average number of potential moves in a position
    for some game. This is why recent advances in computer play of the board game
    Go have required exploration of other domains, like machine learning. A machine
    learning-based Go AI has now defeated the best human Go player. The branching
    factor (and therefore the search space) for Go is simply overwhelming for minimax-based
    algorithms that attempt to generate trees containing future positions. But Go
    is the exception rather than the rule. Most traditional board games (checkers,
    chess, Connect Four, Scrabble, and the like) have search spaces small enough that
    minimax-based techniques can work well.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的分支因子越高，最小-最大算法的效果就越差。分支因子是指某些游戏中某个位置的平均潜在移动数。这就是为什么最近在计算机玩围棋方面的进步需要探索其他领域，如机器学习。基于机器学习的围棋
    AI 现在已经击败了最好的围棋人类选手。围棋的分支因子（因此是搜索空间）对于尝试生成包含未来位置的树的基于最小-最大算法来说，是压倒性的。但围棋是个例外，而不是规则。大多数传统棋盘游戏（国际象棋、围棋、四子棋、拼字游戏等）的搜索空间足够小，使得基于最小-最大技术的算法可以很好地工作。
- en: If you are implementing a new board game artificial opponent or even an AI for
    a turn-based purely computer-oriented game, minimax is probably the first algorithm
    you should reach for. Minimax can also be used for economic and political simulations,
    as well as experiments in game theory. Alpha-beta pruning should work with any
    form of minimax.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现一个新的棋盘游戏人工智能对手，甚至是一个针对回合制纯计算机游戏的 AI，最小-最大算法可能是你应该首先尝试的算法。最小-最大算法也可以用于经济和政治模拟，以及博弈论实验。Alpha-beta
    剪枝应该与任何形式的最小-最大算法兼容。
- en: 8.6 Exercises
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 练习
- en: Add unit tests to tic-tac-toe to ensure that the methods getLegalMoves(), isWin(),
    and isDraw() work correctly.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为井字棋添加单元测试，以确保 getLegalMoves()、isWin() 和 isDraw() 方法正确工作。
- en: Create minimax unit tests for Connect Four.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为四子棋创建最小-最大单元测试。
- en: The code in TicTacToe.java and ConnectFour.java is almost identical. Refactor
    it into two methods that can be used for either game.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TicTacToe.java 和 ConnectFour.java 中的代码几乎相同。将其重构为两个方法，这两个方法可以用于任何一种游戏。
- en: Change ConnectFour.java to have the computer play against itself. Does the first
    player or the second player win? Is it the same player every time?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 ConnectFour.java 修改为让计算机与自身对弈。是先手玩家还是后手玩家获胜？每次都是同一个玩家吗？
- en: Can you find a way (through profiling the existing code or otherwise) to optimize
    the evaluation method in ConnectFour.java to enable a higher search depth in the
    same amount of time?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否找到一种方法（通过分析现有代码或其他方式）来优化 ConnectFour.java 中的评估方法，以便在相同的时间内实现更高的搜索深度？
- en: Use the alphabeta() function developed in this chapter together with a Java
    library for legal chess move generation and maintenance of chess game state to
    develop a chess AI.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本章开发的 alphabeta() 函数，结合一个用于合法棋步生成和维护棋局状态的 Java 库，来开发一个棋类人工智能。
- en: '* * *'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1. Connect Four is a trademark of Hasbro, Inc. It is used here only in a descriptive
    and positive manner.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 四子棋是 Hasbro, Inc. 的商标。在这里，它仅用于描述性和积极的用途。
