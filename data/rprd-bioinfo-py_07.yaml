- en: 'Chapter 6\. Finding the Hamming Distance: Counting Point Mutations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章\. 找到海明距离：计算点突变
- en: 'The Hamming distance, named after the same Richard Hamming mentioned in the
    Preface, is the number of edits required to change one string into another. It’s
    one metric for gauging sequence similarity. I have written a couple of other metrics
    for this, starting in [Chapter 1](ch01.html#ch01) with tetranucleotide frequency
    and continuing in [Chapter 5](ch05.html#ch05) with GC content. While the latter
    can be practically informative as coding regions tend to be GC-rich, tetranucleotide
    frequency falls pretty short of being useful. For example, the sequences *AAACCCGGGTTT*
    and *CGACGATATGTC* are wildly different yet produce the same base frequencies:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 海明距离，以前言中提到的理查德·哈明的名字命名，是将一个字符串转变为另一个所需的编辑次数。这是衡量序列相似性的一种度量。我为此编写了几个其他度量标准，从[第1章](ch01.html#ch01)开始使用四核苷酸频率，继续到[第5章](ch05.html#ch05)使用GC含量。尽管后者在实际中可能是有信息量的，因为编码区域倾向于富含GC，但四核苷酸频率远远不能称得上是有用的。例如，序列*AAACCCGGGTTT*和*CGACGATATGTC*完全不同，但产生相同的碱基频率：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Taken alone, tetranucleotide frequency makes these sequences seem identical,
    but it’s quite obvious that they would produce entirely different protein sequences
    and so would be functionally unlike. [Figure 6-1](#fig_6.1) depicts an alignment
    of the 2 sequences indicating that only 3 of the 12 bases are shared, meaning
    they are only 25% similar.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 单独观察，四核苷酸频率使这些序列看起来相同，但很明显它们会产生完全不同的蛋白质序列，因此在功能上是不同的。[图 6-1](#fig_6.1)显示了这2个序列的对齐，表明只有12个碱基中的3个是相同的，这意味着它们只有25%的相似性。
- en: '![mpfb 0601](assets/mpfb_0601.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0601](assets/mpfb_0601.png)'
- en: Figure 6-1\. An alignment of two sequences with vertical bars showing matching
    bases
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1\. 显示匹配碱基的垂直条的两个序列的对齐
- en: Another way to express this is to say that 9 of the 12 bases need to be changed
    to turn one of the sequences into the other. This is the Hamming distance, and
    it’s somewhat equivalent in bioinformatics to single-nucleotide polymorphisms
    (SNPs, pronounced *snips*) or single-nucleotide variations (SNVs, pronounced *snivs*).
    This algorithm only accounts for the change of one base to another value and falls
    far short of something like sequence alignment that can identify insertions and
    deletions. For instance, [Figure 6-2](#fig_6.2) shows that the sequences *AAACCCGGGTTT*
    and *AACCCGGGTTTA* are 92% similar when aligned (on the left), as they differ
    by a single base. The Hamming distance (on the right), though, shows only 8 bases
    are in common, which means they are only 66% similar.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表达这个概念的方式是说，12个碱基中有9个需要改变才能将其中一个序列变成另一个。这就是海明距离，它在生物信息学中与单核苷酸多态性（SNP，发音为*snips*）或单核苷酸变异（SNVs，发音为*snivs*）有些类似。该算法只考虑将一个碱基更改为另一个值，并且远远不能像序列对齐那样识别插入和删除。例如，[图 6-2](#fig_6.2)显示，当对齐时序列*AAACCCGGGTTT*和*AACCCGGGTTTA*是92%相似的（在左边），因为它们仅相差一个碱基。然而，海明距离（在右边）只显示有8个碱基是相同的，这意味着它们只有66%的相似性。
- en: '![mpfb 0602](assets/mpfb_0602.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0602](assets/mpfb_0602.png)'
- en: Figure 6-2\. The alignment of these sequences shows them to be nearly identical,
    while the Hamming distance finds they’re only 66% similar
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2\. 这些序列的对齐显示它们几乎相同，而海明距离发现它们只有66%的相似性
- en: This program will always compare strings strictly from their beginnings, which
    limits the practical application to real-world bioinformatics. Still, it turns
    out that this naïve algorithm is a useful metric for sequence similarity, and
    writing the implementation presents many interesting solutions in Python.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将始终严格比较字符串从它们的开头开始，这限制了实际应用于真实世界生物信息学的可能性。尽管如此，这个天真的算法事实证明是衡量序列相似性的一个有用的度量，并且编写实现在Python中提出了许多有趣的解决方案。
- en: 'In this chapter, you will learn:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到：
- en: How to use the `abs()` and `min()` functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`abs()`和`min()`函数
- en: How to combine the elements from two lists of possibly unequal lengths
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组合两个可能长度不等的列表的元素
- en: How to write `map()` using `lambda` or existing functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`lambda`或现有函数编写`map()`
- en: How to use functions from the `operator` module
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`operator`模块中的函数
- en: How to use the `itertools.starmap()` function
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`itertools.starmap()`函数
- en: Getting Started
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'You should work in the *06_hamm* directory of the repository. I suggest you
    start by getting a feel for how the solutions work, so copy one of them to the
    `hamm.py` program and request the help:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在存储库的*06_hamm*目录中工作。我建议您先了解这些解决方案的工作原理，然后将其中一个复制到`hamm.py`程序中并请求帮助：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The program requires two positional arguments, which are the two sequences
    to compare, and the program should print the Hamming distance. For example, I
    would need to make seven edits to change one of these sequences to the other:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序需要两个位置参数，即要比较的两个序列，并应打印汉明距离。例如，要将其中一个序列更改为另一个序列，我需要进行七次编辑：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the tests (either with **`pytest`** or **`make test`**) to see a passing
    suite. Once you feel you understand what’s expected, remove this file and start
    from scratch:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '运行测试（使用**`pytest`**或**`make test`**）以查看通过的测试套件。一旦您了解了预期的内容，请删除此文件并从头开始： '
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the parameters so that the program requires two positional arguments
    which are the two sequences:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 定义参数，以便程序需要两个位置参数，这两个参数是字符串值：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-1)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-1)'
- en: The program arguments will have two string values for the two sequences.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 程序参数将包含两个字符串值，用于这两个序列。
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-2)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-2)'
- en: The two sequences are required positional string values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个序列是必需的位置字符串值。
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-3)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO1-3)'
- en: Instantiate the `Args` object using the two sequences.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化`Args`对象，使用这两个序列。
- en: The order in which you define positional parameters must match the order in
    which the arguments are provided on the command line. That is, the first positional
    parameter will hold the first positional argument, the second positional parameter
    will match the second positional argument, etc. The order in which you define
    optional parameters does not matter, and optional parameters may be defined before
    or after positional parameters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 定义位置参数的顺序必须与在命令行上提供参数的顺序相匹配。也就是说，第一个位置参数将保存第一个位置参数，第二个位置参数将匹配第二个位置参数，依此类推。定义可选参数的顺序无关紧要，可选参数可以在位置参数之前或之后定义。
- en: 'Change the `main()` function to print the two sequence:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`main()`函数以打印这两个序列：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By this point, you should have a program that prints the usage, validates that
    the user supplies two sequences, and prints the sequences:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该有一个打印用法的程序，验证用户提供了两个序列，并打印这些序列：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you run **`pytest -xvv`** (the two `v`s increase the verbosity of the output),
    you should find that the program passes the first three tests. It should fail
    `test_input1` with a message like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行**`pytest -xvv`**（两个`v`增加输出的详细程度），您应该会发现程序通过了前三个测试。它应该在`test_input1`测试中失败，并显示类似以下的消息：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-1)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-1)'
- en: The inputs for the test come from the file *./tests/inputs/1.txt*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的输入来自文件*./tests/inputs/1.txt*。
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-2)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-2)'
- en: The file is opened and read for the two sequences and the expected result.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件并读取两个序列和预期结果。
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-3)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-3)'
- en: The program is run with the two sequences.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个序列运行程序。
- en: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-4)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-4)'
- en: The `assert` fails when it finds the output from the program does not match
    the expected answer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序的输出与预期答案不匹配时，`assert`会失败。
- en: '[![5](assets/5.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-5)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO2-5)'
- en: Specifically, the program printed the two sequences when it should have printed
    `7`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，当程序应该打印两个序列时，它却打印了`7`。
- en: Iterating the Characters of Two Strings
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代两个字符串的字符。
- en: 'Now to find the Hamming distance between the two sequences. To start, consider
    these two sequences:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来找到这两个序列之间的汉明距离。首先，考虑这两个序列：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The distance is 2 because you would either need to add *GT* to the first sequence
    or remove *GT* from the second sequence to make them the same. I would suggest
    that the baseline distance is the difference in their lengths. Note that the Rosalind
    challenge assumes two strings of equal lengths, but I want to use this exercise
    to consider strings of different lengths.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 距离为2，因为你需要在第一个序列中添加*GT*或从第二个序列中删除*GT*使它们相同。我建议基线距离是它们长度的差异。请注意，Rosalind挑战假设两个相等长度的字符串，但我想使用这个练习来考虑长度不同的字符串。
- en: 'Depending on the order in which you do the subtraction, you might end up with
    a negative number:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据做减法的顺序，可能会得到一个负数：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use the `abs()` function to get the absolute value:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`abs()`函数获取绝对值：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now I will consider how to iterate the characters they have in common. I can
    use the `min()` function to find the length of the shorter sequence:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将考虑如何迭代它们共有的字符。我可以使用`min()`函数找到较短序列的长度：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And I can use this with the `range()` function to get the indexes of the common
    characters:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`range()`函数与这个一起，以获取相同字符的索引：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When these two characters are *not* equal, the `distance` variable should be
    incremented because I would have to change one of the values to match the other.
    Remember that the Rosalind challenge always compares the two sequences from their
    beginnings. For instance, the sequences *ATTG* and *TTG* differ by one base, as
    I can either remove *A* from the first or add it to the second to make them match,
    but the rules of this particular challenge would say that the correct answer is
    3:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个字符*不*相等时，应增加`distance`变量，因为我必须更改一个值以使其匹配另一个。请记住，Rosalind挑战总是从它们的开头比较这两个序列。例如，序列*ATTG*和*TTG*在一个碱基上不同，因为我可以从第一个中删除*A*或将其添加到第二个中以使它们匹配，但这个特定挑战的规则会说正确答案是3：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: I believe this should be enough information for you to craft a solution that
    passes the test suite. Once you have a working solution, explore some other ways
    you might write your algorithm, and keep checking your work using the test suite.
    In addition to running the tests via **`pytest`**, be sure to use the **`make
    test`** option to verify that your code also passes the various linting and type-checking
    tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信这些信息足以帮助您编写一个通过测试套件的解决方案。一旦您有了可用的解决方案，请探索一些其他编写算法的方法，并使用测试套件不断检查您的工作。除了通过**`pytest`**运行测试外，确保使用**`make
    test`**选项验证您的代码也通过各种linting和类型检查测试。
- en: Solutions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: This section works through eight variations on how to find the Hamming distance,
    starting with an entirely manual calculation that takes several lines of code
    and ending with a solution that combines several functions in a single line.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍如何计算汉明距离的八种变体，从完全手动计算几行代码到将几个函数合并在一行的解决方案。
- en: 'Solution 1: Iterating and Counting'
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案1：迭代和计数
- en: 'The first solution follows from the suggestions in the previous section:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案来自前一节的建议：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-1)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-1)'
- en: Copy the two sequences into variables.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个序列复制到变量中。
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-2)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-2)'
- en: Since I’ll use the lengths more than once, I store them in variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我会多次使用长度，我将它们存储在变量中。
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-3)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-3)'
- en: The base distance is the difference between the two lengths.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 基础距离是两个长度之间的差异。
- en: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-4)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-4)'
- en: Use the shorter length to find the indexes in common.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用较短的长度来找到共有的索引。
- en: '[![5](assets/5.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-5)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-5)'
- en: Check the letters at each position.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个位置的字母。
- en: '[![6](assets/6.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-6)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-6)'
- en: Increment the distance by 1.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将距离增加1。
- en: '[![7](assets/7.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-7)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO3-7)'
- en: Print the distance.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打印距离。
- en: This solution is very explicit, laying out every individual step needed to compare
    all the characters of two strings. The following solutions will start to shorten
    many of the steps, so be sure you are comfortable with exactly what I’ve shown
    here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案非常明确，列出了比较两个字符串所有字符所需的每个单独步骤。接下来的解决方案将开始缩短许多步骤，所以请确保你对这里展示的内容非常熟悉。
- en: 'Solution 2: Creating a Unit Test'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案2：创建单元测试
- en: The first solution leaves me feeling vaguely uncomfortable because the code
    to calculate the Hamming distance should be in a function with tests. I’ll start
    by creating a function called `hamming()` after the `main()` function. As a matter
    of style, I like to put `get_args()` first so I can read it immediately when I
    open the program. My `main()` function always comes second, and all other functions
    and tests after that.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方案让我感到有些不舒服，因为计算汉明距离的代码应该在一个带有测试的函数中。我将首先创建一个名为`hamming()`的函数，放在`main()`函数之后。就风格而言，我喜欢先放`get_args()`，这样我一打开程序就能立即看到。我的`main()`函数总是其次，其他所有函数和测试都在其后。
- en: 'I’ll start by imagining the inputs and output of my function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从想象函数的输入和输出开始：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-1)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-1)'
- en: The function will accept two strings as positional arguments and will return
    an integer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将接受两个字符串作为位置参数，并返回一个整数。
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-2)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO4-2)'
- en: To start, the function will always return `0`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，该函数将始终返回`0`。
- en: I want to stress the fact that the function does not *print* the answer but
    rather *returns it as a result*. If you wrote this function to `print()` the distance,
    you would not be able to write a unit test. You would have to rely entirely on
    the integration test that looks to see if the program prints the correct answer.
    As much as possible, I would encourage you to write pure functions that act only
    on the arguments and have no side effects. Printing is a side effect, and, while
    the program does need to print the answer eventually, this function’s job is solely
    to return an integer when given two strings.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调的是，该函数并不*打印*答案，而是*作为结果返回*。如果你写了这个函数来`print()`距离，你将无法编写单元测试。你必须完全依赖于集成测试来查看程序是否打印了正确的答案。尽可能地，我鼓励你编写纯函数，它们只对参数进行操作，没有副作用。打印是副作用，尽管程序最终确实需要打印答案，但这个函数的任务仅仅是在给定两个字符串时返回一个整数。
- en: 'I’ve already shown a few test cases I can encode. Feel free to add other tests
    of your own devising:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展示了一些测试用例，你可以自行添加其他测试：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-1)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-1)'
- en: I always think it’s good practice to send empty strings for string inputs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是认为将空字符串发送给字符串输入是一种良好的实践。
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-2)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-2)'
- en: The difference is due only to length.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 差异仅仅是长度的不同。
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-3)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO5-3)'
- en: This is the example from the documentation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是文档中的示例。
- en: I’m aware that this may seem a bit extreme, because this function is essentially
    the entire program. I’m almost duplicating the integration test, I know, but I’m
    using this to point out best practices for writing programs. The `hamming()` function
    is a good unit of code, and it belongs in a function with a test. In a much larger
    program, this would be one of perhaps dozens to hundreds of other functions, and
    each should be *encapsulated*, *documented*, and *tested*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这可能看起来有点极端，因为这个函数本质上就是整个程序。我几乎是在复制集成测试，我知道，但我用它来指出编写程序的最佳实践。`hamming()`函数是一个很好的代码单元，并且应该与测试一起放入函数中。在一个更大的程序中，这可能是数十到数百个其他函数之一，每个函数都应该*封装*、*文档化*和*测试*。
- en: 'Following test-driven principles, run **`pytest`** on the program to ensure
    that the test fails:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循测试驱动的原则，在程序上运行**`pytest`**以确保测试失败：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now copy the code from `main()` to fix the function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从`main()`中复制代码以修复函数：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Verify that your function is correct:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 验证函数的正确性：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can incorporate it into your `main()` function like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样将其整合到您的`main()`函数中：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO6-1)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO6-1)'
- en: Print the return value from the function for the two given sequences.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 打印给定序列的函数返回值。
- en: This hides the complexity of the program inside a named, documented, tested
    unit, shortening the main body of the program and improving the readability.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将程序的复杂性隐藏在一个命名、文档化和测试过的单元中，缩短了程序的主体并提高了可读性。
- en: 'Solution 3: Using the zip() Function'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案3：使用`zip()`函数
- en: 'The following solution uses the `zip()` function to combine the elements from
    two sequences. The result is a list of tuples containing the characters from each
    position (see [Figure 6-3](#fig_6.3)). Note that `zip()` is another lazy function,
    so I’ll use `list()` to coerce the values in the REPL:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的解决方案使用`zip()`函数将两个序列的元素组合起来。结果是一个包含每个位置字符的元组列表（见图6-3）。请注意，`zip()`是另一个惰性函数，因此我将使用`list()`在REPL中强制执行值：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![mpfb 0603](assets/mpfb_0603.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0603](assets/mpfb_0603.png)'
- en: Figure 6-3\. The tuples are composed of characters in common positions
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-3。元组由共同位置的字符组成。
- en: 'If I use the *AC* and *ACGT* sequences, you’ll notice that `zip()` stops with
    the shorter sequence, as shown in [Figure 6-4](#fig_6.4):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我使用*AC*和*ACGT*序列，您将注意到`zip()`会停在较短的序列处，如图6-4所示：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![mpfb 0604](assets/mpfb_0604.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0604](assets/mpfb_0604.png)'
- en: Figure 6-4\. The `zip()` function will stop at the shortest sequence
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-4。`zip()`函数将在最短序列处停止
- en: 'I can use a `for` loop to iterate over each pair. So far in my `for` loops,
    I’ve used a single variable to represent each element in a list like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`for`循环遍历每一对。到目前为止，在我的`for`循环中，我使用单个变量表示列表中的每个元素，就像这样：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In [Chapter 1](ch01.html#ch01), I showed how to *unpack* the values from a
    tuple into separate variables. The Python `for` loop allows me to unpack each
    tuple into the two characters, like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch01)，我展示了如何将元组中的值*解包*为单独的变量。Python的`for`循环允许我将每个元组解包为两个字符，如下所示：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `zip()` function obviates a couple of lines from the first implementation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip()`函数省去了第一个实现中的几行：'
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-1)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-1)'
- en: Start with the absolute difference of the lengths.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从长度的绝对差开始。
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-2)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-2)'
- en: Use `zip()` to pair up the characters of the two strings.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`zip()`将两个字符串的字符配对。
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-3)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-3)'
- en: Check if the two characters are not equal.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个字符是否不相等。
- en: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-4)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO7-4)'
- en: Increment the distance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 增加距离。
- en: 'Solution 4: Using the zip_longest() Function'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案4：使用`zip_longest()`函数
- en: 'The next solution imports the `zip_longest()` function from the `itertools`
    module. As the name implies, it will zip the lists to the length of the longest
    list. [Figure 6-5](#fig_6.5) shows that the function will insert `None` values
    when a shorter sequence has been exhausted:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个解决方案从 `itertools` 模块导入 `zip_longest()` 函数。顾名思义，它将把列表压缩到最长列表的长度。[Figure 6-5](#fig_6.5)
    显示当较短的序列已用尽时，该函数将插入 `None` 值：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![mpfb 0605](assets/mpfb_0605.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0605](assets/mpfb_0605.png)'
- en: Figure 6-5\. The `zip_longest()` function will stop at the longest sequence
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-5\. `zip_longest()` 函数将在最长序列处停止
- en: 'I no longer need to start by subtracting the lengths of the sequences. Instead,
    I’ll initialize a `distance` variable to `0` and then use `zip_longest()` to create
    tuples of bases to compare:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我不再需要从序列长度开始减去。相反，我将初始化一个 `distance` 变量为 `0`，然后使用 `zip_longest()` 创建要比较的碱基元组：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-1)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-1)'
- en: Initialize the distance to `0`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化距离为 `0`。
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-2)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-2)'
- en: Zip to the longest sequence.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将序列压缩到最长的长度。
- en: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-3)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-3)'
- en: Compare the characters.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 比较字符。
- en: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-4)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO8-4)'
- en: Increment the counter.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 增加计数器。
- en: 'Solution 5: Using a List Comprehension'
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Solution 5: 使用列表推导式'
- en: All the solutions up to this point have used a `for` loop. I hope you’re starting
    to anticipate that I’m going to show you how to convert this into a list comprehension
    next. When the goal is to create a new list or reduce a list of values to some
    answer, it’s often shorter and preferable to use a list comprehension.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的解决方案都使用了 `for` 循环。我希望你开始预见我接下来会展示如何将其转换为列表推导式。当目标是创建一个新列表或将值列表缩减为某个答案时，通常使用列表推导式会更短和更可取。
- en: 'The first version is going to use an `if` expression to return a `1` if the
    two characters are the same or a `0` if they are not:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本将使用一个 `if` 表达式，如果两个字符相同则返回 `1`，如果它们不同则返回 `0`：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The Hamming distance, then, is the sum of these:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，汉明距离是这些的总和：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Another way to express this idea is to only produce the `1`s by using a *guard*
    clause, which is a conditional statement at the end of the list comprehension
    that decides whether or not a particular element is allowed:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表达这个想法的方式是通过使用 *保护* 子句，即在列表推导式末尾的条件语句，决定是否允许特定元素：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO9-1)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO9-1)'
- en: The `if` statement is the guard that will produce the value `1` if the two characters
    are not equal.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句是保护子句，如果两个字符不相等，则产生值 `1`。'
- en: 'You could also use the Boolean/integer coercion I showed in [Chapter 5](ch05.html#ch05),
    where each `True` value will be treated as `1` and `False` is `0`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用我在 [Chapter 5](ch05.html#ch05) 中展示的布尔值/整数强制转换，其中每个 `True` 值将被视为 `1`，而
    `False` 是 `0`：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Any of these ideas will reduce the function to a single line of code that passes
    the tests:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些想法都将函数简化为一行代码，以通过测试：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Solution 6: Using the filter() Function'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Solution 6: 使用 `filter()` 函数'
- en: 'Chapters [4](ch04.html#ch04) and [5](ch05.html#ch05) show that a list comprehension
    with a guard can also be expressed using the `filter()` function. The syntax is
    a little ugly because Python doesn’t allow the unpacking of the tuples from `zip_longest()`
    into separate variables. That is, I want to write a `lambda` that unpacks `char1`
    and `char2` into separate variables, but this is not possible:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 章节 [4](ch04.html#ch04) 和 [5](ch05.html#ch05) 表明，带有保护子句的列表推导式也可以使用 `filter()`
    函数来表达。语法有些难看，因为Python不允许将 `zip_longest()` 中的元组解包为单独的变量。也就是说，我想编写一个 `lambda` 函数，将
    `char1` 和 `char2` 解包为单独的变量，但这是不可能的：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Instead, I will usually call the `lambda` variable `tup` or `t` to remind me
    this is a tuple. I will use the positional tuple notation to compare the element
    in the zeroth position to the element in the first position. `filter()` will only
    produce those tuples where the elements are different:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我通常会将`lambda`变量称为`tup`或`t`，以提醒我这是一个元组。我将使用位置元组表示法将零位置的元素与一位置的元素进行比较。`filter()`只会生成那些元素不同的元组：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The Hamming distance then is the length of this list. Note that the `len()`
    function will not prompt `filter()` to produce values:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，汉明距离就是这个列表的长度。请注意，`len()`函数不会促使`filter()`生成值：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is one of those instances where the code must use `list()` to force the
    lazy `filter()` function to generate the results. Here is how I can incorporate
    these ideas:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码必须使用`list()`来强制惰性`filter()`函数生成结果的一个例子。以下是我如何将这些思想整合到一起的方式：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-1)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-1)'
- en: Use `filter()` to find tuple pairs of different characters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter()`查找不同字符的元组对。
- en: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-2)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO10-2)'
- en: Return the length of the resulting list.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 返回结果列表的长度。
- en: 'Solution 7: Using the map() Function with zip_longest()'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 7：使用`map()`函数和`zip_longest()`函数
- en: 'This solution uses `map()` instead of `filter()` only to show you that the
    same inability to unpack the tuples also applies. I’d like to use `map()` to produce
    a list of Boolean values indicating whether the character pairs match or not:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此解决方案使用`map()`而不是`filter()`，只是为了向您展示元组无法解包的相同情况。我想使用`map()`来生成一个布尔值列表，指示字符对是否匹配：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `lambda` is identical to the one to `filter()` that was used as the *predicate*
    to determine which elements are allowed to pass. Here the code *transforms* the
    elements into the result of applying the `lambda` function to the arguments, as
    shown in [Figure 6-6](#fig_6.6). Remember that `map()` will always return the
    same number of elements it consumes, but `filter()` may return fewer or none at
    all.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`lambda`与用作*谓词*来确定哪些元素被允许通过的`filter()`中的lambda完全相同。在这里，代码*转换*元素成为应用`lambda`函数到参数后的结果，如[Figure 6-6](#fig_6.6)所示。记住，`map()`将始终返回与其消耗相同数量的元素，但`filter()`可能返回较少或根本不返回。
- en: '![mpfb 0606](assets/mpfb_0606.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0606](assets/mpfb_0606.png)'
- en: Figure 6-6\. The `map()` function transforms each tuple into a Boolean value
    representing the inequality of the two elements
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-6\. `map()`函数将每个元组转换为表示两个元素不等的布尔值
- en: 'I can sum these Booleans to get the number of mismatched pairs:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将这些布尔值求和，得到不匹配对的数量：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is the function with this idea:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是带有此想法的函数：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Even though these functions have gone from 10 or more lines of code to a single
    line, it still makes sense for this to be a function with a descriptive name and
    tests. Eventually, you’ll start creating modules of reusable code to share across
    your projects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些函数已经从10多行代码减少到一行，但将其作为具有描述性名称和测试的函数仍然是有意义的。最终，您将开始创建可在项目间共享的可重用代码模块。
- en: 'Solution 8: Using the starmap() and operator.ne() Functions'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 8：使用`starmap()`和`operator.ne()`函数
- en: 'I confess that I showed the last few solutions solely to build up to this last
    solution. Let me start by showing how I can assign a `lambda` to a variable:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认，我展示最后几个解决方案只是为了建立到这个最后一个解决方案。让我首先展示如何将`lambda`分配给一个变量：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is not recommended syntax, and `pylint` will definitely fail your code
    on this and recommend a `def` instead:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是推荐的语法，并且`pylint`肯定会在此处失败并推荐使用`def`代替：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Both will create a function called `not_same()` that will accept a tuple and
    return whether the two elements are the same:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都将创建一个名为`not_same()`的函数，接受一个元组并返回两个元素是否相同：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If, however, I wrote the function to accept two positional arguments, the same
    error I saw before would crop up:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我编写函数来接受两个位置参数，那么之前看到的相同错误将会出现：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'What I need is a version of `map()` that can splat the incoming tuple (as I
    first showed in [Chapter 1](ch01.html#ch01)) by adding `*` (*star*, *asterisk*,
    or *splat*) to the tuple to expand it into its elements, which is exactly what
    the function `itertools.starmap()` does (see [Figure 6-7](#fig_6.7)):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要的是`map()`的一个版本，它可以展开传入的元组（正如我在[第1章](ch01.html#ch01)中首次展示的那样），通过在元组前添加`*`（星号、星号、星形）来将其展开为其元素，这正是`itertools.starmap()`函数所做的（参见[图6-7](#fig_6.7)）：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![mpfb 0607](assets/mpfb_0607.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 0607](assets/mpfb_0607.png)'
- en: Figure 6-7\. The `starmap()` function applies a splat to the incoming tuple
    to turn it into the two values that the `lambda` expects
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-7. `starmap()`函数对传入的元组应用星号，将其转换为`lambda`所期望的两个值
- en: 'But wait, there’s more! I don’t even need to write my own `not_same()` function
    because I already have `operator.ne()` (not equal), which I usually write using
    the `!=` operator:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，还有更多！我甚至不需要编写自己的`not_same()`函数，因为我已经有`operator.ne()`（不等于），通常使用`!=`操作符来编写：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'An *operator* is a special binary function (accepting two arguments) where
    the function name is usually some symbol like `+` that sits between the arguments.
    In the case of `+`, Python has to decide if this means `operator.add()`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*运算符*是一种特殊的二元函数（接受两个参数），函数名称通常是一些符号，如`+`，它位于参数之间。对于`+`，Python必须决定这是否意味着`operator.add()`：'
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'or `operator.concat()`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 或者`operator.concat()`：
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The point is that I already have an existing function that expects two arguments
    and returns whether they are equal, and I can use `starmap()` to properly expand
    the tuples into the needed arguments:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我已经有一个现有的函数，期望两个参数并返回它们是否相等，并且我可以使用`starmap()`来正确地将元组扩展为所需的参数：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As before, the Hamming distance is the sum of the unmatched pairs:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，汉明距离是不匹配对的总和：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To see it in action:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 看它如何运作：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO11-1)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_finding_the_hamming_distance___span_class__keep_together__counting_point_mutations__span__CO11-1)'
- en: Zip the sequences, transform the tuples to Boolean comparisons, and sum.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将序列压缩，将元组转换为布尔比较，并求和。
- en: This final solution relies entirely on fitting four functions that I didn’t
    write. I believe the best code is code you don’t write (or test or document).
    While I prefer this purely functional solution, you may feel this code is overly
    clever. You should use whatever version you’ll be able to understand a year later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此最终解决方案完全依赖于适合的四个我没有编写的函数。我相信最好的代码是你不编写（或测试或文档化）的代码。虽然我更喜欢这个纯函数解决方案，但你可能认为这段代码过于巧妙。你应该使用一年后你能理解的版本。
- en: Going Further
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更进一步
- en: Without looking at the source code, write a version of `zip_longest()`. Be sure
    to start with a test, then write the function that satisfies the test.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不查看源代码，编写`zip_longest()`的一个版本。确保从测试开始，然后编写满足测试的函数。
- en: Expand your program to handle more than two input sequences. Have your program
    print the Hamming distance between every pair of sequences. That means the program
    will print *n* choose *k* numbers which will be *n*! / *k*!(*n* – *k*)!. For three
    sequences, your program will print 3! / (2!(3 – 2)!) = 6 / 2 = 3 distance pairs.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展你的程序以处理超过两个输入序列。使你的程序打印每对序列之间的汉明距离。这意味着程序将打印*n*选择*k*个数，即*n*！/（*k*！（*n* - *k*）！）。对于三个序列，你的程序将打印3！/（2！（3
    - 2）！）= 6 / 2 = 3距离对。
- en: Try writing a sequence alignment algorithm that will show there is, for instance,
    just one difference between the sequences *AAACCCGGGTTT* and *AACCCGGGTTTA*.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试编写一个序列对齐算法，该算法将显示例如序列*AAACCCGGGTTT*和*AACCCGGGTTTA*之间仅有一个差异。
- en: Review
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: 'This was a rather deep rabbit hole to go down just to find the Hamming distance,
    but it highlights lots of interesting bits about Python functions:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当深的兔子洞，只为了找到汉明距离，但它突出了关于Python函数的许多有趣细节：
- en: The built-in `zip()` function will combine two or more lists into a list of
    tuples, grouping elements at common positions. It stops at the shortest sequence,
    so use the `itertools.zip_longest()` function if you want to go to the longest
    sequence.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的`zip()`函数将两个或更多个列表合并为元组列表，将相同位置的元素分组。它会停在最短的序列处，因此如果要处理最长的序列，请使用`itertools.zip_longest()`函数。
- en: Both `map()` and `filter()` apply a function to some iterable of values. The
    `map()` function will return a new sequence transformed by the function, while
    `filter()` will only return those elements that return a truthy value when the
    function is applied.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()` 和 `filter()` 都会将函数应用于某些可迭代的值。`map()` 函数将由函数转换的新序列返回，而 `filter()` 仅在应用函数时返回那些返回真值的元素。'
- en: The function passed to `map()` and `filter()` can be an anonymous function created
    by `lambda` or an existing function.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给 `map()` 和 `filter()` 的函数可以是由 `lambda` 创建的匿名函数，也可以是现有函数。
- en: The `operator` module contains many functions like `ne()` (not equal) that can
    be used with `map()` and `filter()`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator` 模块包含许多像 `ne()`（不等于）这样的函数，可以与 `map()` 和 `filter()` 一起使用。'
- en: The `functools.starmap()` function works just like `map()` but will splat the
    function’s incoming values to expand them into a list of values.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functools.starmap()` 函数的工作方式类似于 `map()`，但会将函数的传入值展开成值列表。'
