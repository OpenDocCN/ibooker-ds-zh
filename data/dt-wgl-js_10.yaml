- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Server-side visualization
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端可视化
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Rendering charts and visualizations with Node.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js渲染图表和可视化
- en: Building reusable functions for rendering charts that we can use when doing
    exploratory data analysis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建可重用函数以渲染图表，我们可以在进行数据探索分析时使用
- en: Using a headless browser to capture web pages to PNG image files and PDF documents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无头浏览器捕获网页到PNG图像文件和PDF文档
- en: Taking web scraping to the next level with a headless browser
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无头浏览器将网络抓取提升到下一个水平
- en: When we’re doing exploratory coding (chapter 5) or data analysis (chapter 9),
    we want to render charts and visualizations to explore and understand our data.
    In chapter 10, we learned how to create web-based interactive visualizations for
    the browser. That’s a normal and common way to create visualizations in JavaScript.
    Browser-based visualization techniques are well known and well understood, and
    you can easily find help on the internet.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行探索性编码（第5章）或数据分析（第9章）时，我们希望渲染图表和可视化来探索和理解我们的数据。在第10章中，我们学习了如何为浏览器创建基于Web的交互式可视化。这是在JavaScript中创建可视化的正常和常见方式。基于浏览器的可视化技术众所周知，并且很容易在网上找到帮助。
- en: How about we take the browser out of the equation? What if we want to render
    our charts and visualization on the server directly from Node.js? Well, we can
    do that, but unlike browser-based visualization, this isn’t a common use case,
    and it can be difficult to find the help you need online.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把浏览器从等式中去掉怎么样？如果我们想直接从Node.js在服务器上渲染我们的图表和可视化呢？嗯，我们可以这样做，但与基于浏览器的可视化不同，这并不是一个常见的用例，而且在网上找到你需要帮助可能会很困难。
- en: First, though, you might wonder why it’s useful to render charts on the server
    side? It’s convenient for us to render charts directly from Node.js while doing
    exploratory data analysis (that’s what we were doing in chapter 9). This approach
    to data analysis is common in Python, and it would be nice if we could replicate
    it in Node.js.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能想知道为什么在服务器端渲染图表是有用的？在进行数据探索分析（这就是我们在第9章中所做的）时，直接从Node.js渲染图表对我们来说很方便。这种数据分析方法在Python中很常见，如果我们能在Node.js中复制它，那将很棒。
- en: It’s also a useful capability for us to prerender visualizations on the server
    side. We might do this so that we can generate reports or to precache images for
    display in a web page. Server-side rendering of visualizations is so useful that
    I think it’s worth pushing through the complexity and difficulty of getting set
    up so that we can add this technique to our toolkit.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在服务器端预先渲染可视化也是一项有用的功能。我们可能这样做是为了生成报告或为了在网页中显示而预先缓存图像。服务器端渲染可视化如此有用，以至于我认为值得克服设置时的复杂性和困难，以便我们可以将这项技术添加到我们的工具箱中。
- en: Remember that we worked through data analysis techniques in chapter 9, and we
    rendered various charts to illustrate those techniques. We created those charts
    from Node.js by calling toolkit functions such as `renderLineChart` and `renderBarChart``.`
    In chapter 9, I provided those functions for you. But in this chapter, you’ll
    learn how to create such functions and render static visualizations in Node.js.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在第9章中处理了数据分析技术，并渲染了各种图表来展示这些技术。我们通过调用工具函数，如`renderLineChart`和`renderBarChart`，从Node.js创建了这些图表。在第9章中，我为你提供了这些函数。但本章，你将学习如何创建这样的函数并在Node.js中渲染静态可视化。
- en: 11.1 Expanding your toolkit
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 扩展你的工具箱
- en: How might we go about rendering charts in Node.js? When working in the browser,
    we have so many visualization libraries at our disposal, although ordinarily we
    can’t use any of these options directly from Node.js. Wouldn’t it be great if
    we could take our pick from any of the browser-based visualization libraries and
    use them from Node.js?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Node.js中渲染图表呢？当在浏览器中工作时，我们有这么多可视化库可供选择，尽管通常我们无法直接从Node.js使用这些选项。如果我们能从任何基于浏览器的可视化库中选择并从Node.js使用它们，那岂不是很好？
- en: Well, I’m here to tell you that you can use any of the browser-based visualization
    libraries to create visualizations from Node.js, although we still do need a web
    browser operating somewhere under the hood. In this chapter, we’ll use something
    called a *headless browser* to make browser-based visualization libraries work
    for us under Node.js.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我要告诉你的是，你可以使用任何基于浏览器的可视化库来从Node.js创建可视化，尽管我们仍然需要在内部某个地方运行一个网络浏览器。在本章中，我们将使用一种称为*无头浏览器*的东西，以便在Node.js下使基于浏览器的可视化库为我们工作。
- en: A headless browser is a web browser, but it’s one that has no visible user interface.
    You can think of it as a browser that’s invisible. In this chapter, we’ll add
    Nightmare to our toolkit. This Node.js library that you can install through npm
    allows you to control the Electron web browser in a headless manner. You won’t
    use Electron directly; it will be controlled only from code through the Nightmare
    API. It’s important to note that Electron is a web browser similar to Chrome or
    Edge; in fact, it’s similar to Chrome because it’s built from the same open source
    code base.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无头浏览器是一个Web浏览器，但它没有可见的用户界面。你可以将其想象为一个不可见的浏览器。在本章中，我们将把Nightmare添加到我们的工具箱中。这个可以通过npm安装的Node.js库允许你以无头方式控制Electron网络浏览器。你不会直接使用Electron；它将通过Nightmare
    API从代码中控制。重要的是要注意，Electron是一个类似于Chrome或Edge的网络浏览器；事实上，它与Chrome相似，因为它是由相同的开源代码库构建的。
- en: A headless browser is useful for many tasks, but we’ll focus on how we can render
    visualizations and reports under Node.js. We’ll learn how to remotely control
    our headless browser from Node.js and capture web-based charts and visualizations
    to static image files. In the process, we’ll recreate the `renderLineChart` function
    that we used previously in chapter 9; this is an example of a function that we
    can use to render a chart from Node.js without having to explicitly create or
    interact with a web-based visualization, even though there will be a web-based
    visualization running under the hood! We’ll also learn how we can use these techniques
    to render multipage PDF reports that include graphics and charts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无头浏览器对于许多任务都很有用，但我们将关注如何在Node.js下渲染可视化报表。我们将学习如何从Node.js远程控制无头浏览器并捕获基于Web的图表和可视化到静态图像文件。在这个过程中，我们将重新创建在第9章中使用的`renderLineChart`函数；这是一个示例，说明我们可以使用该函数从Node.js渲染图表，而无需显式创建或与基于Web的可视化交互，尽管底层将运行基于Web的可视化！我们还将学习如何使用这些技术渲染包含图形和图表的多页PDF报表。
- en: 11.2 Getting the code and data
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 获取代码和数据
- en: The code and data for this chapter are available in the Data Wrangling with
    JavaScript Chapter-11 repository in GitHub at [https://github.com/data-wrangling-with-javascript/chapter-11](https://github.com/data-wrangling-with-javascript/chapter-11)[.](http://.)
    Each subdirectory in the repository is a complete working example and corresponds
    to one of the listings throughout this chapter. Before attempting to run the code
    in each subdirectory, please be sure to install npm and browser dependencies as
    necessary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码和数据可在GitHub上的Data Wrangling with JavaScript Chapter-11仓库中找到，网址为[https://github.com/data-wrangling-with-javascript/chapter-11](https://github.com/data-wrangling-with-javascript/chapter-11)[.](http://.)
    仓库中的每个子目录都是一个完整的示例，对应本章中的某个列表。在尝试运行每个子目录中的代码之前，请确保已安装npm和浏览器依赖项。
- en: '[Listing 11.11](#listing11.11) comes with a Vagrant script to demonstrate how
    to use this technique on a headless Linux server. Refer to “Getting the code and
    data” in chapter 2 for help on getting the code and data.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表11.11](#listing11.11) 包含一个Vagrant脚本，演示如何在无头Linux服务器上使用这项技术。有关获取代码和数据的帮助，请参阅第2章中的“获取代码和数据”。'
- en: 11.3 The headless browser
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 无头浏览器
- en: When we think of a web browser, we often think of the graphical software that
    we interact with on a day-to-day basis when browsing the World Wide Web. Normally,
    we interact with such a browser directly, viewing it with our eyes and controlling
    it with our mouse and keyboard, as shown in [figure 11.1](#figure11.1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到网络浏览器时，我们通常想到的是我们在浏览万维网时每天与之交互的图形软件。通常情况下，我们直接与这样的浏览器交互，用眼睛观看它，用鼠标和键盘控制它，如图11.1所示。
- en: '![c11_01.eps](Images/c11_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![c11_01.eps](Images/c11_01.png)'
- en: '[Figure 11.1](#figureanchor11.1) The normal state of affairs: our visualization
    renders in a browser, and the user interacts directly with the browser.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.1](#figureanchor11.1) 通常情况：我们的可视化在浏览器中渲染，用户直接与浏览器交互。'
- en: A headless browser is a web browser that has no graphical user interface and
    no direct means for us to control it. You might ask, what’s the use of a browser
    that we can’t directly see or interact with?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无头浏览器是一个没有图形用户界面且没有直接控制手段的Web浏览器。你可能会问，我们无法直接看到或与之交互的浏览器有什么用？
- en: As developers, we’d typically use a headless browser for automating and testing
    websites. Let’s say that you’ve created a web page and you want to run a suite
    of automated tests against it to prove that it works as expected. The test suite
    is automated, which means it’s controlled from code, so we need to *drive* the
    browser from code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们通常使用无头浏览器来自动化和测试网站。假设你已经创建了一个网页，并且想要运行一系列自动化测试来证明它按预期工作。测试套件是自动化的，这意味着它由代码控制，因此我们需要从代码中“驾驶”浏览器。
- en: We use a headless browser for automated testing because we don’t need to directly
    see or interact with the web page that’s being tested. Viewing such an automated
    test in progress is unnecessary; all we need to know is if the test passed or
    failed—and if it failed, we’d like to know why. Indeed, having a GUI for the browser
    would be a hindrance for a continuous-integration or continuous-deployment server,
    where we want many such tests to run in parallel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用无头浏览器进行自动化测试，因为我们不需要直接看到或与正在测试的网页交互。查看这种自动化测试的进行过程是不必要的；我们只需要知道测试是否通过——如果失败了，我们还想知道原因。实际上，为浏览器提供一个GUI在持续集成或持续部署服务器上可能会成为障碍，我们希望许多这样的测试可以并行运行。
- en: Headless browsers are often used for automated testing of our web pages, but
    I’ve also found that they’re incredibly useful for capturing browser-based visualizations
    and outputting them to PNG images or PDF files. To make this work, we need a web
    server and a visualization, which we learned about in chapter 10\. We must then
    write code to instance a headless browser and point it at our web server. Our
    code then instructs the headless browser to take a screenshot of the web page
    and save it to our file system as a PNG or PDF file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无头浏览器通常用于我们网页的自动化测试，但我还发现它们在捕获基于浏览器的可视化并将其输出为PNG图像或PDF文件方面非常有用。为了使这成为可能，我们需要一个Web服务器和一个可视化工具，这些我们在第10章中已经学过。然后我们必须编写代码来实例化一个无头浏览器，并将其指向我们的Web服务器。然后我们的代码指示无头浏览器捕获网页截图，并将其保存到我们的文件系统中作为PNG或PDF文件。
- en: For a more specific example, see [figure 11.2](#figure11.2). Here we take the
    New York City temperature chart from chapter 10 and use our headless browser to
    capture a screenshot to the file nyc-temperature.png. In a moment we’ll learn
    how easy it is to do this, at least in development. By the end of the chapter,
    we’ll face up to the difficulties of getting this to work in our production environment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个更具体的例子，请参阅[图11.2](#figure11.2)。在这里，我们使用第10章中的纽约市温度图表，并使用我们的无头浏览器捕获一个截图到文件nyc-temperature.png。我们很快就会了解到这样做有多简单，至少在开发过程中是这样。到本章结束时，我们将面对在生产环境中实现这一功能的困难。
- en: '![c11_02.eps](Images/c11_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![c11_02.eps](Images/c11_02.png)'
- en: '[Figure 11.2](#figureanchor11.2) We can use a headless browser under Node.js
    to capture our visualization to a static image file.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.2](#figureanchor11.2) 我们可以使用Node.js下的无头浏览器将我们的可视化捕获到静态图像文件中。'
- en: 11.4 Using Nightmare for server-side visualization
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 使用Nightmare进行服务器端可视化
- en: Nightmare is the headless browser we’ll use. It’s a Node.js library (installed
    using npm) that’s built on Electron. Electron is a web browser that’s normally
    used for building cross-platform desktop apps that are based on web technologies.
    We don’t need to directly interact with or understand how to use Electron; we’ll
    interact with it only through Nightmare, and we can think of Electron as if it
    were a standard web browser.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Nightmare是我们将使用的无头浏览器。它是一个基于Electron构建的Node.js库（使用npm安装）。Electron是一个通常用于构建基于Web技术的跨平台桌面应用程序的Web浏览器。我们不需要直接交互或理解如何使用Electron；我们只通过Nightmare与之交互，我们可以将Electron视为一个标准Web浏览器。
- en: 11.4.1 Why Nightmare?
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.1 为什么选择Nightmare？
- en: 'The browser is called Nightmare, but it’s definitely not a nightmare to use.
    In fact, it’s the simplest and most convenient headless browser that I’ve used.
    It automatically includes Electron, so to get started, we install Nightmare into
    our Node.js project as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器名为Nightmare，但使用起来绝对不是噩梦。事实上，这是我使用过的最简单、最方便的无头浏览器。它自动包含Electron，因此要开始使用，我们需要按照以下步骤将Nightmare安装到我们的Node.js项目中：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That’s all we need to install Nightmare, and we can start using it immediately
    from JavaScript!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是安装Nightmare所需的所有步骤，我们就可以立即从JavaScript开始使用它了！
- en: 'Nightmare comes with almost everything we need: a scripting library with an
    embedded headless browser. It also includes the communication mechanism to control
    the headless browser from Node.js. For the most part, it’s seamless and well integrated
    into Node.js, but the API can take a bit of getting used to.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 恶梦伴随着我们需要的几乎所有东西：一个带有嵌入式无头浏览器的脚本库。它还包括从Node.js控制无头浏览器的通信机制。大部分情况下，它无缝且很好地集成到Node.js中，但API可能需要一些时间来习惯。
- en: Over the following sections, we’ll build up a new function to render a chart
    under Node.js. We’ll add this function to our toolkit, and you can reuse it on
    your development workstation for exploratory coding and data analysis.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将构建一个新的函数，在Node.js下渲染图表。我们将把这个函数添加到我们的工具箱中，你可以在你的开发工作站上重复使用它进行探索性编码和数据分析。
- en: When it comes to production usage—say, building an automated reporting system—Nightmare
    is a bit trickier to get working. We’ll need to do extra work, but we’ll deal
    with the difficulties later in the chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到生产使用——比如，构建一个自动报告系统时——Nightmare要复杂一些才能正常工作。我们需要做一些额外的工作，但我们在本章的后面会处理这些困难。
- en: 11.4.2 Nightmare and Electron
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.2 Nightmare和Electron
- en: When you install Nightmare using npm, it automatically comes with an embedded
    version of Electron. We can say that Nightmare isn’t only a library for controlling
    a headless browser; it effectively is the headless browser. This is another reason
    I like Nightmare. With several of the other headless browsers, the control library
    is separate, or it’s worse than that, and they don’t have a Node.js control library
    at all. In the worst case, you have to roll your own communication mechanism to
    control the headless browser.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用npm安装Nightmare时，它会自动附带一个嵌入式的Electron版本。我们可以这样说，Nightmare不仅仅是一个控制无头浏览器的库；它实际上就是一个无头浏览器。这也是我喜欢Nightmare的另一个原因。与其他几个无头浏览器相比，控制库是分开的，或者更糟的是，它们根本就没有Node.js控制库。在最坏的情况下，你必须自己开发通信机制来控制无头浏览器。
- en: Nightmare creates an instance of the Electron process using the Node.js `child_process`
    module. It then uses interprocess communication and a custom protocol to control
    the Electron instance. The relationship is shown in [figure 11.3](#figure11.3).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Nightmare使用Node.js的`child_process`模块创建Electron进程的实例。然后它使用进程间通信和自定义协议来控制Electron实例。这种关系在[图11.3](#figure11.3)中显示。
- en: '![c11_03.eps](Images/c11_03.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![c11_03.eps](Images/c11_03.png)'
- en: '[Figure 11.3](#figureanchor11.3) Nightmare allows us to control Electron running
    as a headless browser.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.3](#figureanchor11.3) Nightmare允许我们控制作为无头浏览器运行的Electron。'
- en: Electron is built on Node.js and Chromium and maintained by GitHub. It is the
    basis for other popular desktop applications, although from our point of view,
    we can think of it as an ordinary web browser.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Electron建立在Node.js和Chromium之上，由GitHub维护。它是其他流行桌面应用程序的基础，尽管从我们的角度来看，我们可以将其视为一个普通的Web浏览器。
- en: 'These are the reasons that I choose to use Nightmare over any other headless
    browser:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我选择使用Nightmare而不是其他任何无头浏览器的原因：
- en: Electron is stable.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Electron是稳定的。
- en: Electron has good performance.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子具有优良的性能。
- en: The API is simple and easy to learn.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API简单且易于学习。
- en: It doesn’t have a complicated configuration (you can start using it quickly).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有复杂的配置（你可以快速开始使用它）。
- en: It’s well integrated with Node.js.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与Node.js集成良好。
- en: Electron can be a little tricky to get working in your production environment,
    but we’ll solve that soon enough.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Electron在你的生产环境中可能有点棘手，但我们很快就会解决这个问题。
- en: '11.4.3 Our process: capturing visualizations with Nightmare'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.3 我们的过程：使用Nightmare捕获可视化
- en: Let’s look at the process for rendering a visualization to an image file. To
    start with, our data will be hard-coded in our visualization. As we iterate and
    evolve our code, we’ll build a new toolkit function for rendering a chart. Ultimately,
    we’d like to pump our data from Node.js into this chart, and that means the data
    will have to be external to the visualization.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将可视化渲染到图像文件的过程。首先，我们的数据将硬编码在我们的可视化中。随着我们迭代和改进我们的代码，我们将构建一个新的工具箱函数来渲染图表。最终，我们希望将数据从Node.js泵入这个图表，这意味着数据必须位于可视化之外。
- en: 'This is the full process that we’re aiming for:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们追求的完整过程：
- en: Acquire our data.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取我们的数据。
- en: Start a local web server to host our visualization.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动本地Web服务器以托管我们的可视化。
- en: Inject our data into the web server.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的数据注入到Web服务器中。
- en: Instance a headless browser and point it at our local web server.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个无头浏览器并将其指向我们的本地Web服务器。
- en: Wait for the visualization to be displayed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待可视化显示。
- en: Capture a screenshot of the visualization to an image file.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将可视化的截图保存到图像文件中。
- en: Shut down the headless browser.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭无头浏览器。
- en: Shut down the local web server.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭本地网络服务器。
- en: This process probably all sounds rather complicated, but don’t worry; in our
    usual fashion we’ll start simple and ramp up the complexity over multiple iterations.
    By the end, we’ll have this process wrapped up in a convenient and easy-to-reuse
    toolkit function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能听起来相当复杂，但别担心；我们一如既往地从简单开始，并在多次迭代中逐步增加复杂性。最终，我们将把这个过程封装在一个方便且易于重用的工具函数中。
- en: 11.4.4 Prepare a visualization to render
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.4 准备要渲染的可视化
- en: The first thing we need is to have a visualization. We’ll start with one that
    you’re familiar with from chapter 10\. [Figure 11.4](#figure11.4) shows the yearly
    chart of average New York temperatures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要有一个可视化。我们将从第 10 章中您所熟悉的一个开始。[图 11.4](#figure11.4) 显示了纽约市平均年温度图表。
- en: '![c11_04.png](Images/c11_04.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![c11_04.png](Images/c11_04.png)'
- en: '[Figure 11.4](#figureanchor11.4) The chart we''ll use from chapter 10: NYC
    average yearly temperature'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.4](#figureanchor11.4) 我们将从第 10 章中使用的图表：纽约市平均年温度'
- en: 'The code for this chart is shown in listings 11.1a and 11.1b. It’s similar
    to [listing 10.3](c10.xhtml#listing10.3) in chapter 10\. You can test this chart
    now using live-server (the same as we did in chapter 10):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表的代码显示在列表 11.1a 和 11.1b 中。它与第 10 章中的 [列表 10.3](c10.xhtml#listing10.3) 类似。您现在可以使用
    live-server 测试此图表（与第 10 章中我们所做的一样）：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running live-server in the listing-11.1 subdirectory opens a browser automatically,
    and you should see a visualization like [figure 11.4](#figure11.4).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 listing-11.1 子目录中运行 live-server 会自动打开浏览器，您应该会看到一个类似于 [图 11.4](#figure11.4)
    的可视化。
- en: It’s a good idea to check that your visualization works directly in a browser
    before you try to capture it in a headless browser because there could easily
    be something wrong with it. Problems are much easier to troubleshoot in a real
    browser than in the headless browser.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试在无头浏览器中捕获之前，检查您的可视化是否在浏览器中直接工作是一个好主意，因为很容易出现问题。在实际浏览器中解决问题比在无头浏览器中容易得多。
- en: Listing 11.1a HTML file for the browser-based visualization (listing-11.1/index.html)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1a 用于浏览器可视化的 HTML 文件（listing-11.1/index.html）
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing 11.1b JavaScript file for the browser-based visualization (listing-11.1/app.js)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1b 用于浏览器可视化的 JavaScript 文件（listing-11.1/app.js）
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I have an important addition to [listing 11.1b](#listing11.1b) to explain. Look
    at the chart definition and notice where I set the duration of the animated transition
    to zero. This effectively disables animation in the C3 chart. Animation isn’t
    useful here because we’re rendering the chart to a static image, and it can cause
    problems in our captured image file, so it’s best to disable the animation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 [列表 11.1b](#listing11.1b) 有一个重要的补充要解释。看看图表定义，注意我设置动画过渡时间为零的地方。这实际上禁用了 C3
    图表的动画。在这里动画没有用，因为我们正在将图表渲染为静态图像，这可能会在我们的捕获图像文件中引起问题，所以最好禁用动画。
- en: By default, C3 animates our data into the chart, which means that it fades in.
    If this happens while we’re capturing the image (it’s a timing thing), then we’ll
    end up capturing a chart that’s partially transparent, which probably isn’t what
    we wanted, and the effect won’t be consistent. It drove me half-crazy trying to
    figure out why my charts were partially transparent when I first started rendering
    visualizations using this method.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，C3 将我们的数据动画化到图表中，这意味着它会淡入。如果在捕获图像时发生这种情况（这是一个时间问题），那么我们最终会捕获到一个部分透明的图表，这可能不是我们想要的，而且效果不会一致。当我第一次开始使用这种方法渲染可视化时，我的图表部分透明让我几乎要疯了，试图找出原因。
- en: 11.4.5 Starting the web server
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.5 启动网络服务器
- en: To host our visualization, we’ll need a web server. Again, we can start by reusing
    code from chapter 10\. Note that we could serve our web page from the file system
    by pointing our headless browser at `index.html` and preceding it with the `file://`
    protocol. This approach can work well in simple cases, but we need a custom way
    to feed our data into the visualization, so let’s jump straight into using a custom
    Node.js web server to host our visualization.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要托管我们的可视化，我们需要一个网络服务器。同样，我们可以从第 10 章中重用代码。请注意，我们可以通过将无头浏览器指向 `index.html` 并在前面加上
    `file://` 协议来从文件系统提供服务。这种方法在简单情况下可以很好地工作，但我们需要一种自定义方式来将数据喂入可视化，所以让我们直接使用自定义 Node.js
    网络服务器来托管我们的可视化。
- en: Please note that depending on your requirements, you may not need the custom
    web server. You might simplify your own process by serving your visualization
    using the file system or maybe using something off-the-shelf such as live-server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据你的需求，你可能不需要自定义网络服务器。你可以通过使用文件系统或可能使用现成的工具如 live-server 来简化你的流程。
- en: '[Listing 11.2](#listing11.2) shows the code for our web server. This is similar
    to [listing 10.4](c10.xhtml#listing10.4a) from chapter 10\. Before trying to capture
    the visualization in the headless browser, let’s test that it works in the normal
    way:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.2](#listing11.2) 展示了我们的网络服务器代码。这与第 10 章中的 [列表 10.4](c10.xhtml#listing10.4a)
    类似。在尝试在无头浏览器中捕获可视化之前，让我们测试它是否以正常方式工作：'
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now open a regular web browser and point it at [http://localhost:3000](http://localhost:3000).
    You should see the same chart of NYC yearly average temperature that we saw earlier
    in [figure 11.4](#figure11.4).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开一个常规网络浏览器，将其指向 [http://localhost:3000](http://localhost:3000)。你应该看到我们之前在
    [图 11.4](#figure11.4) 中看到的纽约市年度平均温度图表。
- en: Listing 11.2 Basic Node.js web server for the browser-based visualization (listing-11.2/index.js)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 基于浏览器的可视化基本 Node.js 网络服务器（listing-11.2/index.js）
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a simple web server, but it’s not enough to meet our needs. We also
    need to dynamically start and stop it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的网络服务器，但它不足以满足我们的需求。我们还需要能够动态地启动和停止它。
- en: 11.4.6 Procedurally start and stop the web server
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.6 程序化启动和停止网络服务器
- en: Let’s make changes to our web server so that we can programmatically start and
    stop it. We’ll start it before we capture the visualization and then stop it afterward.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的网络服务器进行修改，以便我们可以程序化地启动和停止它。我们在捕获可视化之前启动它，然后之后停止它。
- en: Let’s upgrade the code from [listing 11.2](#listing11.2) to achieve this. We’ll
    start by refactoring the web server into a separate reusable code module, as shown
    in the following listing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 [列表 11.2](#listing11.2) 中的代码升级以实现这一点。我们将首先将网络服务器重构为一个可重用的代码模块，如下所示。
- en: Listing 11.3a Our web server is refactored into a reusable code module (listing-11.3/web-server.js)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3a 我们的网络服务器被重构为一个可重用的代码模块（listing-11.3/web-server.js）
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code module in [listing 11.3a](#listing11.3a) exports a `start` function
    that we can call to kick-start our web server. An example of how we’ll use this
    is shown in [listing 11.3b](#listing11.3b), where we start the web server and
    then subsequently stop it. In between you can see a placeholder where we’ll soon
    add code to render the web page and take a screenshot.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.3a](#listing11.3a) 中的代码模块导出了一个 `start` 函数，我们可以调用它来启动我们的网络服务器。我们将如何使用这个函数的例子在
    [列表 11.3b](#listing11.3b) 中展示，其中我们启动了网络服务器，然后随后停止它。在这之间，你可以看到一个占位符，我们将很快在这里添加代码来渲染网页并截图。'
- en: Listing 11.3b Using the reusable code module to start and stop the web server
    (listing-11.3/index.js)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3b 使用可重用代码模块启动和停止网络服务器（listing-11.3/index.js）
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This technique, starting and stopping our web server, is also useful for doing
    automated integration testing on a website. Imagine that the placeholder comment
    in [listing 11.3b](#listing11.3b) is replaced by a series of tests that poke and
    prod the web page to see how it responds. We’ll take another look at automated
    testing in chapter 14.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术，即启动和停止我们的网络服务器，对于在网站上执行自动集成测试也是很有用的。想象一下，[列表 11.3b](#listing11.3b) 中的占位符被一系列测试所取代，这些测试会探测和刺激网页以查看其响应。我们将在第
    14 章中再次探讨自动测试。
- en: Now we have our browser-based visualization, and we also have a web server that
    can be started and stopped on demand. These are the raw ingredients we need for
    capturing server-side visualizations. Let’s mix it up with Nightmare!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基于浏览器的可视化，我们还拥有一个可以根据需要启动和停止的网络服务器。这些是我们捕获服务器端可视化的基本原料。让我们用 Nightmare
    来混合它们！
- en: 11.4.7 Rendering the web page to an image
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.7 将网页渲染为图像
- en: Now let’s replace the placeholder comment from [listing 11.3b](#listing11.3b)
    with code that captures a screenshot of our visualization. [Listing 11.4](#listing11.4)
    has new code that instances Nightmare, points it at our web server, and then takes
    a screenshot. You can run this code, and it will render the chart and produce
    the file nyc-temperatures.png to the output subdirectory under the listing-11.4
    directory.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用捕获我们可视化的截图的代码替换 [列表 11.3b](#listing11.3b) 中的占位符。[列表 11.4](#listing11.4)
    有新的代码，它实例化 Nightmare，将其指向我们的网络服务器，然后进行截图。你可以运行此代码，它将渲染图表并在 listing-11.4 目录下的输出子目录中生成
    nyc-temperatures.png 文件。
- en: Listing 11.4 Capturing the chart to an image file using Nightmare (listing-11.4/index.js)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 使用 Nightmare 将图表捕获到图像文件（listing-11.4/index.js）
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the use of the `goto` function; this is what directs the browser to load
    our visualization. Web pages usually take time to load. That’s probably not going
    to be long, especially because we’re running a local web server, but still we
    face the danger of taking a screenshot of the headless browser before or during
    its initial paint.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `goto` 函数的使用；这是指导浏览器加载我们的可视化内容的方式。网页通常需要一段时间才能加载。这可能不会太长，尤其是因为我们正在运行本地 web
    服务器，但我们仍然面临在无头浏览器初始绘制之前或期间截图的风险。
- en: Also, because we’re loading the data into our chart asynchronously, we need
    to ensure that the data is loaded in the chart before we take the screenshot.
    That’s why we must use the `wait` function shown in [listing 11.4](#listing11.4)
    to wait until the chart’s `svg` element appears in the browser’s DOM before we
    call the `screenshot` function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们正在异步地将数据加载到图表中，我们需要确保在截图之前数据已经加载到图表中。这就是为什么我们必须使用[列表 11.4](#listing11.4)中显示的
    `wait` 函数，等待图表的 `svg` 元素出现在浏览器 DOM 中，然后再调用 `screenshot` 函数。
- en: Eventually, the `end` function is called. Up until now, we effectively built
    a list of commands to send to the headless browser. The `end` function flushes
    the command list; then the commands are sent to the browser, which visits the
    page, renders the chart, takes the screenshot, and outputs the file nyc-temperatures.png.
    After the image file has been captured, we finish up by shutting down the web
    server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，会调用 `end` 函数。到目前为止，我们实际上构建了一个要发送给无头浏览器的命令列表。`end` 函数刷新命令列表；然后，命令被发送到浏览器，浏览器访问页面，渲染图表，截图，并输出文件
    nyc-temperatures.png。在图像文件被捕获后，我们通过关闭 web 服务器来完成后续工作。
- en: Note that we could have used `goto` to send the browser to any website, not
    only our own web server. We could have also used the `file://` protocol to point
    the browser at any HTML file in our local filesystem. This gives you, with such
    a small amount of code, the impressive ability to procedurally capture screenshots
    of any website or HTML file.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们本可以使用 `goto` 将浏览器发送到任何网站，而不仅仅是我们的自己的 web 服务器。我们也可以使用 `file://` 协议将浏览器指向本地文件系统中任何
    HTML 文件。这使得你只需这么少的代码，就能以程序化的方式捕获任何网站或 HTML 文件的截图。
- en: 11.4.8 Before we move on . . .
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.8 在我们继续之前...
- en: Hopefully getting this far hasn’t been too taxing, but now things are going
    to start getting more complicated. Before that, though, let’s tidy up what we’ve
    done so far.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到目前为止的工作并没有让你感到过于吃力，但现在事情将开始变得更加复杂。不过，在之前，让我们整理一下到目前为止我们所做的工作。
- en: Unfortunately, running [listing 11.4](#listing11.4) leaves us with a captured
    image that has a transparent background. To fix this, we must set the background
    color of our visualization to a solid color. In listings 11.5a and 11.5b, you
    can see how I’ve used CSS to set the background of the body element to white.
    That makes our background opaque.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，运行[列表 11.4](#listing11.4)给我们留下了一个具有透明背景的捕获图像。为了解决这个问题，我们必须将我们的可视化背景颜色设置为纯色。在列表
    11.5a 和 11.5b 中，你可以看到我是如何使用 CSS 将 body 元素的背景设置为白色的。这使得我们的背景不透明。
- en: Listing 11.5a Setting the background of the web page (listing-11.5/public/app.css)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5a 设置网页背景（listing-11.5/public/app.css）
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 11.5b Adding app.css to our browser-based visualization (listing-11.5/public/index.html)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5b 将 app.css 添加到基于浏览器的可视化中（listing-11.5/public/index.html）
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we’re updating the CSS for your visualization, I hope it occurs to you that
    we’re dealing with a normal web page here, and we can add anything to it that
    we might add to any other web page: JavaScript, CSS, other Bower modules, and
    so on. You can use this technique to capture anything that you can fit on a web
    page.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新你的可视化 CSS 时，我希望你意识到我们在这里处理的是一个正常的网页，我们可以添加任何可能添加到任何其他网页上的内容：JavaScript、CSS、其他
    Bower 模块等。你可以使用这种技术来捕获任何可以放在网页上的内容。
- en: The other thing I wanted to do before we move on is to refactor our current
    code so that we have a reusable toolkit function for capturing a web page. I’m
    doing this now because it’s a convenient way to reuse and extend this code throughout
    the rest of the chapter. The following listing shows the refactored function `captureWebPage`
    that we can use to capture any web page given its URL.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我还想重构我们当前的代码，以便我们有一个可重用的工具函数来捕获网页。我现在这么做是因为这是一个方便的方式，可以在本章的其余部分重用和扩展这段代码。以下列表显示了重构后的函数
    `captureWebPage`，我们可以使用它来捕获给定 URL 的任何网页。
- en: Listing 11.5c A reusable toolkit function for server-side chart rendering (listing-11.5/toolkit/capture-web-page.js)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5c 用于服务器端图表渲染的可重用工具包函数（listing-11.5/toolkit/capture-web-page.js）
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The following listing is an example of how we use our new toolkit function `captureWebPage`
    to capture our visualization.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了我们如何使用我们新的工具包函数 `captureWebPage` 来捕获我们的可视化。
- en: Listing 11.5d Using our reusable toolkit function to render the server-side
    chart (listing-11.5/index.js)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5d 使用我们的可重用工具包函数来渲染服务器端图表（listing-11.5/index.js）
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that we have the bare bones of a reusable code module, let’s make improvements
    and tackle several of its deficiencies.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可重用代码模块的骨架，让我们进行改进，并解决其几个缺陷。
- en: 11.4.9 Capturing the full visualization
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4.9 捕获完整可视化
- en: If you scrutinize the visualization that we’ve captured so far, you may notice
    that we’ve captured extra unnecessary space around the chart! This is happening
    because we’re capturing the entire visible area of the browser. What we want is
    to constrain our screenshot to only the exact area of the chart.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细检查我们迄今为止捕获的可视化，你可能注意到我们在图表周围捕获了额外的非必要空间！这是因为我们在捕获整个浏览器的可见区域。我们想要的是将截图限制在图表的确切区域。
- en: Alternatively, if our chart were bigger, it wouldn’t fit within the visible
    area of the browser. Plus, in our captured image, we’d see the browser’s scrollbars,
    and only part of the chart would be visible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们的图表更大，它就不会适合在浏览器的可见区域内。此外，在我们的捕获图像中，我们会看到浏览器的滚动条，并且只有图表的一部分是可见的。
- en: 'To fix these problems, we need to do two things:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们需要做两件事：
- en: Expand the visible area of the browser so that it completely contains the chart
    (so that we don’t capture any scrollbars).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将浏览器可见区域扩展，使其完全包含图表（这样我们就不捕获任何滚动条）。
- en: Constrain the screenshot to the area of the chart (so that we don’t capture
    any extra space).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将截图限制在图表区域（这样我们就不捕获任何额外空间）。
- en: Our solution to this problem is complicated because we must now execute code
    within the headless browser to determine the size of the chart and the size of
    the web page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个问题的解决方案很复杂，因为我们现在必须在无头浏览器中执行代码来确定图表的大小和网页的大小。
- en: '[Listing 11.6](#listing11.6) is an extended code example that can capture the
    entire chart no matter how small or large it might be. Note how we use the `evaluate`
    function to execute JavaScript code within the headless browser. This code determines
    the size of the chart and scrollable area of the web page. Nightmare then copies
    this data from the headless browser process back to Node.js so that we may use
    it.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.6](#listing11.6) 是一个扩展的代码示例，可以捕获无论大小如何的整个图表。注意我们如何使用 `evaluate` 函数在无头浏览器中执行
    JavaScript 代码。这段代码确定图表的大小和网页的可滚动区域。然后，Nightmare 将这些数据从无头浏览器进程复制回 Node.js，以便我们可以使用它。'
- en: We now call the `viewport` function to expand the browser’s viewport and make
    visible the entire scrollable area of the web page. This removes the scrollbars
    from our captured image.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在调用 `viewport` 函数来扩展浏览器的视口，并使网页的整个可滚动区域可见。这从我们的捕获图像中移除了滚动条。
- en: We’ve also modified the call to `screenshot` to pass in a rectangle that defines
    the part of the web page that we want to capture. This limits the screenshot so
    that it captures only the chart and nothing else that might also be on the web
    page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还修改了对 `screenshot` 的调用，传递了一个矩形，定义了我们想要捕获的网页部分。这限制了截图，使其只捕获图表，而不捕获网页上的其他任何内容。
- en: Listing 11.6 Capturing the entire chart (listing-11.6/toolkit/capture-web-page.js)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 捕获整个图表（listing-11.6/toolkit/capture-web-page.js）
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note how we pass `captureElementSelector` into the `evaluate` function. This
    allows us to use this variable in the browser code, which is normally cut off
    from the Node.js code. The headless browser runs in a separate process, so we
    can’t directly access Node.js variables from the browser code. Any data that we
    require in the browser code must be passed as a parameter to the `evaluate` function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将 `captureElementSelector` 传递给 `evaluate` 函数。这允许我们在浏览器代码中使用这个变量，而通常这个变量与
    Node.js 代码是隔离的。无头浏览器在单独的进程中运行，所以我们不能直接从浏览器代码中访问 Node.js 变量。任何在浏览器代码中需要的数据都必须作为参数传递给
    `evaluate` 函数。
- en: Feeding the chart with data
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向图表中添加数据
- en: We’re now finally in a position to recreate the `renderLineChart` function that
    we used in chapter 9\. We have everything we need to render and capture a chart
    under Node.js; now we need to package it up into a function that we can feed with
    the data to be visualized.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以重新创建第 9 章中使用的 `renderLineChart` 函数了。我们已经有了一切所需来在 Node.js 下渲染和捕获图表；现在我们需要将其打包成一个函数，我们可以用要可视化的数据来调用它。
- en: The function that we used in chapter 9 was based on c3-chart-maker, a code module
    of mine that’s available on npm and that you can integrate in your own Node.js
    applications for server-side rendering of C3 charts. For the sake of learning,
    though, we won’t use c3-chart-maker here. We’ll implement this from scratch based
    on everything we’ve already learned.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 9 章中使用的函数是基于 c3-chart-maker，这是一个可在 npm 上找到的代码模块，您可以将它集成到自己的 Node.js 应用程序中，用于服务器端渲染
    C3 图表。然而，为了学习，我们在这里不会使用 c3-chart-maker。我们将从头开始实现，基于我们已经学到的所有内容。
- en: We already have a web server and visualization for a line chart. We have our
    `captureWebPage` function from [listing 11.6](#listing11.6) that we can use to
    render our visualization to an image file. Let’s adapt these so that we can mix
    in whatever data we want. To achieve this, we must take full advantage of our
    custom web server. We’ll feed the data to the web server, and it will then feed
    the data to the visualization.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了网络服务器和折线图的可视化。我们有来自 [列表 11.6](#listing11.6) 的 `captureWebPage` 函数，我们可以用它将我们的可视化渲染到图像文件中。让我们调整这些，以便我们可以混合我们想要的任何数据。为了实现这一点，我们必须充分利用我们的自定义网络服务器。我们将数据输入到网络服务器，然后它将数据传递给可视化。
- en: These changes will go all the way through our code. First, we need to change
    our web app (shown in the following listing) to accept the data (and the chart
    size) from the web server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将贯穿我们的代码。首先，我们需要更改我们的网络应用（如下列表所示），使其能够从网络服务器接收数据（以及图表大小）。
- en: Listing 11.7a Modify our web app to retrieve data from our Node.js app (listing-11.7/toolkit/template-chart/public/app.js)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7a 修改我们的网络应用以从我们的 Node.js 应用中检索数据（列表-11.7/toolkit/template-chart/public/app.js）
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we must modify our web server so that it can be passed the data (and the
    chart size) and then expose them to the web app through the REST API (see the
    following listing).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须修改我们的网络服务器，使其能够传递数据（以及图表大小），然后通过 REST API 将其暴露给网络应用（见以下列表）。
- en: Listing 11.7b Modify the web server to pass the C3 data object through to the
    web app (listing-11.7/toolkit/template-chart/web-server.js)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7b 修改网络服务器以将 C3 数据对象传递给网络应用（列表-11.7/toolkit/template-chart/web-server.js）
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we can feed data through the web server to our line chart, we can
    create our function `renderLineChart`. As you can see in [listing 11.7c](#listing11.7c),
    this function accepts data, the chart size, and the output path for the rendered
    image file. It’s similar to what we’ve seen throughout this chapter: start the
    web server (but this time feeding data into it) and then capture the web page
    using Nightmare.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过网络服务器将数据传递给我们的折线图，我们可以创建我们的 `renderLineChart` 函数。正如您在 [列表 11.7c](#listing11.7c)
    中可以看到的，这个函数接受数据、图表大小以及渲染图像文件输出路径。它与本章中看到的内容类似：启动网络服务器（但这次向其中输入数据）然后使用 Nightmare
    捕获网页。
- en: Listing 11.7c The new toolkit function renderLineChart that can render a data
    set to a chart (listing-11.7/toolkit/charts.js)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7c 新的 toolkit 函数 renderLineChart，可以将数据集渲染成图表（列表-11.7/toolkit/charts.js）
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last thing to do is to show you how to use the new function. The following
    listing demonstrates the function by feeding hard-coded data into our new `renderLineChart`
    function. You can run this code yourself and inspect the image file that is written
    to the *output* subdirectory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是向您展示如何使用这个新函数。以下列表通过将硬编码的数据输入到我们新的 `renderLineChart` 函数中来演示该函数。您可以运行此代码并检查写入到
    *output* 子目录中的图像文件。
- en: Listing 11.7d Calling the new renderLineChart toolkit function (listing-11.7/index.js)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7d 调用新的 renderLineChart 工具包函数（列表-11.7/index.js）
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now have a reusable function for rendering a line chart under Node.js! It’s
    taken much work for us to get to this point, but our new function is simple and
    easy to use. We can use it over and over again with different data sets and reap
    the benefit of the investment that we made to make this function possible.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个在 Node.js 下渲染折线图的可重用函数！我们为此付出了很多努力，但我们的新函数简单易用。我们可以用不同的数据集反复使用它，并从中获得我们为使此函数成为可能所做出的投资的回报。
- en: Even though there are improvements we could still make, the important thing
    is that we have something that works! And I believe it’s always better to have
    something that works before trying to strive for perfection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还可以进行改进，但重要的是我们有一个可以工作的事物！我相信在追求完美之前，拥有一个可以工作的事物总是更好的。
- en: You can easily adapt `renderLineChart` and create your own toolkit functions
    to render different chart types or to add different configuration options or to
    control the look and function of the chart. Feel free to experiment and see where
    you can take it next!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地修改 `renderLineChart` 并创建自己的工具函数来渲染不同类型的图表，或者添加不同的配置选项，或者控制图表的外观和功能。请随意实验，看看你可以将其带到哪里！
- en: Multipage reports
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多页报告
- en: Up to now, we’ve only captured a single chart from a web page. What would also
    be useful— say, for generating a data analysis report—would be if we could capture
    multiple pages of information to a PDF file. Nightmare supports this capability
    directly, and we can use the `pdf` function to capture multipage documents.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只从网页中捕获了一个图表。如果我们能够捕获多页信息到 PDF 文件中，那也会很有用——比如说，用于生成数据分析报告。Nightmare
    直接支持这一功能，我们可以使用 `pdf` 函数来捕获多页文档。
- en: 'Let’s copy our toolkit function `captureWebPage`, rename it to `captureReport`,
    and make the following changes so that we can capture a report:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制我们的工具函数 `captureWebPage`，将其重命名为 `captureReport`，并做出以下更改，以便我们可以捕获报告：
- en: We need to restructure our template web page to have multiple pages.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要重新构建我们的模板网页以包含多个页面。
- en: We call the `pdf` function instead of the `screenshot` function.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用 `pdf` 函数而不是 `screenshot` 函数。
- en: We capture the entire web page and not only the individual chart.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们捕获整个网页，而不仅仅是单个图表。
- en: Restructure the page
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重新构建页面
- en: First, we have to divide our HTML document into multiple pages*.* Each page
    will be a separate page in the output PDF file. In the following listing, you
    can see that we’ve added the page class to the CSS file, and we’ll use this to
    define each individual page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须将我们的 HTML 文档划分为多个页面。*.* 每个页面将在输出 PDF 文件中作为单独的页面。在以下列表中，你可以看到我们已经将页面类添加到
    CSS 文件中，我们将使用它来定义每个单独的页面。
- en: Listing 11.8a Additional CSS for defining a page (extract from listing-11.8/public/app.css)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8a 定义页面的额外 CSS（摘自 listing-11.8/public/app.css）
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use the page class to delineate three separate pages as shown in the following
    listing, and we’ve put a separate chart in each page.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用页面类来划分三个独立的页面，如下所示列表，并且我们在每个页面中放置了一个单独的图表。
- en: Listing 11.8b Adding separate pages to the HTML document (extract from listing-11.8/public/index.html)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8b 将单独的页面添加到 HTML 文档中（摘自 listing-11.8/public/index.html）
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Call the pdf function and capture the entire page
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用 pdf 函数并捕获整个页面
- en: '[Listing 11.8c](#listing11.8c) shows the new `captureReport` function that
    can render a web page to a PDF file. We’ve copied and evolved this code from the
    earlier `captureWebPage` function. The main changes are that we’re now capturing
    the entire web page, and we’re calling the `pdf` function to render it to a PDF
    file.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.8c](#listing11.8c) 展示了新的 `captureReport` 函数，该函数可以将网页渲染为 PDF 文件。我们已经从早期的
    `captureWebPage` 函数复制并改进了这段代码。主要的变化是我们现在正在捕获整个网页，并且我们调用 `pdf` 函数将其渲染为 PDF 文件。'
- en: Listing 11.8c Rendering a multipage report to a PDF file (extract from listing-11.8/index.js)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.8c 将多页报告渲染为 PDF 文件（摘自 listing-11.8/index.js）
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the `printOptions` that we are passing to the `pdf` function. This allows
    us to control aspects of the generated PDF file. We clear out the margins (we
    can now control the margins in CSS), we set the page size (in microns, oddly enough),
    and we can set either landscape or portrait orientation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们传递给 `pdf` 函数的 `printOptions`。这允许我们控制生成的 PDF 文件的一些方面。我们清除边距（我们现在可以在 CSS 中控制边距），我们设置页面大小（奇怪的是，以微米为单位），并且我们可以设置横幅或纵向方向。
- en: Debugging code in the headless browser
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在无头浏览器中调试代码
- en: What happens when we have problems in the code for our visualization? We can’t
    see the headless browser, and we haven’t talked about error handling yet. How
    do we debug any issues that might come up?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在可视化代码中遇到问题时会发生什么？我们看不到无头浏览器，而且我们还没有讨论错误处理。我们如何调试可能出现的任何问题？
- en: First, if you think you have a problem in the visualization, run it under a
    real browser (instead of the headless browser). Now you can use your browser’s
    console and devtools to debug the problem as you would with any normal web app.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你认为可视化中存在问题，请在真实浏览器中运行它（而不是无头浏览器）。现在你可以使用浏览器的控制台和开发者工具来调试问题，就像处理任何正常的Web应用一样。
- en: The most effective way to prevent problems is to thoroughly test and debug your
    visualization before you put it under the headless browser. However, if it works
    in a normal browser but then you have problems in the headless browser, you’ll
    want to use Nightmare’s debugging features along with proper error handling.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 防止问题的最有效方法是，在你将可视化内容放入无头浏览器之前，对其进行彻底的测试和调试。然而，如果它在普通浏览器中运行正常，但在无头浏览器中出现问题，你将需要使用Nightmare的调试功能以及适当的错误处理。
- en: '[Listing 11.9](#listing11.9) shows how we can create the Nightmare instance
    and display the browser’s window (it’s useful to see what’s being rendered) and
    also to enable the browser’s devtools (Electron is based on Chromium, so we get
    all the same lovely devtools that are in Chrome). This makes it much easier for
    us to debug issues that are happening within the headless browser (because it’s
    not so headless anymore).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表11.9](#listing11.9) 展示了我们可以如何创建Nightmare实例并显示浏览器的窗口（查看正在渲染的内容很有用），以及启用浏览器的开发者工具（Electron基于Chromium，因此我们得到与Chrome中相同的所有可爱的开发者工具）。这使得我们更容易调试在无头浏览器中发生的问题（因为它不再是那么无头了）。'
- en: Listing 11.9 Creating the Nightmare instance for debugging
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 创建用于调试的Nightmare实例
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It’s also important to make sure we can see any errors that might come from
    the headless browser. We should have included error handling from the start, but
    I didn’t want to complicate things too early.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们能够看到任何可能来自无头浏览器的错误也很重要。我们应该从一开始就包含错误处理，但我不想过早地使事情复杂化。
- en: The following listing attaches an error handler to the `Nightmare` instance.
    Now any console logging or errors that occur within the headless browser are passed
    back to Node.js so we can deal with them.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表将错误处理程序附加到`Nightmare`实例。现在，任何在无头浏览器中发生的控制台日志记录或错误都会传递回Node.js，以便我们可以处理它们。
- en: Listing 11.10 Adding error handling to the Nightmare instance
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.10 向Nightmare实例添加错误处理
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Making it work on a Linux server
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Linux服务器上使其工作
- en: Using Nightmare becomes more complicated on a headless Linux server. Electron
    isn’t truly headless (at least not yet), so it still requires a framebuffer for
    its (invisible) rendering.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在无头Linux服务器上使用Nightmare会变得更加复杂。Electron并不是真正的无头（至少目前还不是），因此它仍然需要一个framebuffer来渲染其（不可见的）内容。
- en: If you’re rendering visualizations on your development workstation with a normal
    UI-based operating system, then you’re all good, and you can make visualizations
    as part of your data analysis or for reports and presentations and so on. The
    problem comes when you want to capture visualizations as part of an automated
    process on a headless Linux server.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个基于正常UI操作系统的开发工作站上渲染可视化，那么一切都很顺利，你可以将可视化作为数据分析或报告和演示等部分。问题出现在你想要在无头Linux服务器上作为自动化过程的一部分捕获可视化时。
- en: Say that you have an automated pipeline for report generation (you’ll see how
    this can work in chapter 12). In response to an event or maybe as a scheduled
    task, your Linux server aggregates recent data in your database, and either your
    `captureWebPage` or `captureReport` function generates an image or PDF file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个用于报告生成的自动化管道（你将在第12章中看到它是如何工作的）。作为对事件或可能是计划任务的响应，你的Linux服务器会聚合数据库中的最近数据，然后你的`captureWebPage`或`captureReport`函数生成一个图像或PDF文件。
- en: Unfortunately, this won’t work using Nightmare by itself because your headless
    Linux server (that is, Linux running without a graphical UI) doesn’t have a framebuffer
    that Electron can render to. Like I said earlier, Electron isn’t truly headless,
    and it still needs somewhere to be rendered.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，仅使用Nightmare本身是无法实现这一点的，因为你的无头Linux服务器（即没有图形用户界面的Linux）没有Electron可以渲染的framebuffer。正如我之前所说的，Electron并不是真正的无头，它仍然需要一个地方进行渲染。
- en: Fortunately, we can install software on Linux that creates a *virtual framebuffer*.
    I’m not going to cover how to install such software because that’s likely to be
    different depending on your flavor of Linux. But after we have this software installed,
    we can use the xvfb npm module to start a virtual framebuffer, and this enables
    us to capture visualizations from our headless Linux server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以在Linux上安装创建*虚拟帧缓冲区*的软件。我不会介绍如何安装此类软件，因为这可能取决于你的Linux版本。但安装好此软件后，我们可以使用xvfb
    npm模块启动虚拟帧缓冲区，这使我们能够从我们的无头Linux服务器捕获可视化。
- en: You can see how this works in [listing 11.11](#listing11.11). Most of the code
    is the same as the earlier version of `captureWebPage`, except now we’re starting
    the virtual framebuffer before we capture our visualization and then stop it afterward.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[列表11.11](#listing11.11)中看到这是如何工作的。大部分代码与之前版本的`captureWebPage`相同，但现在我们在捕获我们的可视化之前启动虚拟帧缓冲区，然后在之后停止它。
- en: If you want to try this for yourself, please use the Vagrant script that you’ll
    find in the listing-11.11 subdirectory of the repo. This Vagrant script boots
    an Ubuntu virtual machine and installs the Xvfb software ready for you to use.
    If you shell into the virtual machine, you can run the *xvfb-version* of the code
    that’s presented in the following listing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想亲自尝试，请使用仓库中列表-11.11子目录下的Vagrant脚本。这个Vagrant脚本启动一个Ubuntu虚拟机，并安装好Xvfb软件，以便你使用。如果你登录到虚拟机，你可以运行以下列表中展示的*xvfb-version*代码。
- en: Listing 11.11 Using a virtual framebuffer for server-side chart rendering on
    a headless Linux server (listing-11.11/xvfb-version/toolkit/capture-web-page.js)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.11 在无头Linux服务器上使用虚拟帧缓冲区进行服务器端图表渲染（listing-11.11/xvfb-version/toolkit/capture-web-page.js）
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the repo you’ll find both Xvfb and non-Xvfb versions of this code. Feel free
    to try the non-Xvfb version on the headless Ubuntu virtual machine; you’ll see
    that trying to use Nightmare without the virtual framebuffer will hang your script.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中，你可以找到Xvfb和非Xvfb版本的此代码。你可以在无头Ubuntu虚拟机上自由尝试非Xvfb版本；你会发现，在没有虚拟帧缓冲区的情况下尝试使用Nightmare会导致你的脚本挂起。
- en: The Xvfb version does work on the headless Ubuntu virtual machine. In fact,
    it will only work on a machine that has Xvfb installed. If you were to try running
    this—for example, on a Windows PC—it would give you errors.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Xvfb版本在无头Ubuntu虚拟机上确实可以工作。实际上，它只会在安装了Xvfb的机器上工作。如果你尝试在例如Windows PC上运行它，它会给你错误。
- en: 11.5 You can do much more with a headless browser
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 你可以用无头浏览器做更多的事情
- en: At this point you might wonder what else we can do with a headless browser.
    Early in the chapter, I mentioned that the primary reason a developer uses a headless
    browser is for automated testing of web applications. We’ve also seen in this
    chapter how useful a headless browser is for rendering browser-based visualizations
    under Node.js. Here are other reasons you might want to use a headless browser.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能想知道我们还能用无头浏览器做些什么。在章节的开头，我提到开发者使用无头浏览器的主要原因是进行Web应用的自动化测试。在本章中，我们也看到了无头浏览器在Node.js下渲染基于浏览器的可视化时的有用性。以下是一些你可能想要使用无头浏览器的原因。
- en: 11.5.1 Web scraping
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 网络爬取
- en: We touched briefly on web scraping in chapter 4, and I avoided issues that you’d
    probably encounter if you were to delve further into web scraping—issues such
    as authentication or executing JavaScript in the web page *before* scraping it.
    The headless browser is the tool we need to take our web scraping to the next
    level.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，我们简要地提到了网络爬取，我避免了你深入网络爬取时可能会遇到的问题——比如身份验证或在爬取网页之前在网页中执行JavaScript。无头浏览器是我们将网络爬取提升到下一个层次所需的工具。
- en: We can use Nightmare to completely simulate the web page we’re trying to scrape—that
    means JavaScript in the page has executed normally before we try to scrape it.
    We can also procedurally interact with the page—that means we can authenticate
    with the server or whatever else we need to prepare the web page for scraping.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Nightmare完全模拟我们想要爬取的网页——这意味着在尝试爬取之前，页面中的JavaScript已经正常执行。我们还可以与页面进行程序性交互——这意味着我们可以与服务器进行身份验证或准备网页进行爬取所需的其他任何操作。
- en: One thing can make this even easier. We can install the Daydream Chrome extension.
    This allows us to use a web page and simultaneously record a Nightmare script
    of our actions. We can essentially rehearse and then replay any sequence of actions
    that we might need to perform to make web scraping possible.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有一样东西可以使这更加容易。我们可以安装Daydream Chrome扩展。这允许我们使用网页并同时记录我们的Nightmare脚本操作。我们实际上可以排练并回放任何可能需要执行以使网络爬取成为可能的操作序列。
- en: 11.5.2 Other uses
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.2 其他用途
- en: We can use a headless browser for many other tasks, such as capturing screenshots
    for documentation and marketing or prerendering visualization for our website
    (maybe as part of our build process). We also might use it to wrap a legacy web
    page as an API. I’m sure you can dream of other uses for a headless browser because
    it’s such a useful tool to have in your toolkit.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用无头浏览器执行许多其他任务，例如捕获文档和营销的屏幕截图或为我们的网站预渲染可视化（可能是作为构建过程的一部分）。我们还可能用它来封装遗留网页作为API。我相信你可以想象出无头浏览器在其他方面的用途，因为它是你工具箱中一个非常有用的工具。
- en: We’ve come full circle! In chapter 9, we learned about data analysis with the
    aid of several toolkit functions to render charts directly from Node.js. In chapter
    10, we learned how to create such charts to run in the browser using the C3 charting
    library. In this chapter, we learned how to render visualizations from Node.js
    and even how to do so on a headless Linux server. We are now able to capture any
    web page to an image or PDF file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了整个循环！在第9章，我们学习了在Node.js的帮助下使用几个工具函数进行数据分析，直接渲染图表。在第10章，我们学习了如何使用C3图表库创建在浏览器中运行的图表。在本章中，我们学习了如何从Node.js渲染可视化，甚至如何在无头Linux服务器上这样做。我们现在能够将任何网页捕获为图像或PDF文件。
- en: After learning this technique, we now understand how the chart rendering functions
    from chapter 9 worked, and we can create our own functions to render any browser-based
    visualization that we can conceive. We can easily produce reports that might be
    needed for our business. In chapter 12, we’ll look at how automated reporting
    might be used in a live data pipeline.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了这项技术后，我们现在理解了第9章中图表渲染函数是如何工作的，并且我们可以创建自己的函数来渲染任何基于浏览器的可视化。我们可以轻松地生成可能对我们业务所需的报告。在第12章中，我们将探讨如何在实时数据管道中使用自动化报告。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned how to use Nightmare to capture charts to images under Node.js.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你学习了如何使用Nightmare在Node.js下将图表捕获为图像。
- en: You saw how to capture a multipage report to a PDF document.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你看到了如何将多页报告捕获为PDF文档。
- en: You know that you must use Xvfb to create a virtual framebuffer so that you
    can run Nightmare on a headless Linux server.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道你必须使用Xvfb来创建一个虚拟帧缓冲区，这样你就可以在无头Linux服务器上运行Nightmare。
- en: You learned that a headless browser can take your web scraping to the next level.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你了解到无头浏览器可以将你的网络爬取提升到下一个层次。
