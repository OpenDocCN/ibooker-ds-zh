- en: 4 Creating a responsive web newspaper layout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 创建响应式网络报纸布局
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using the CSS Multi-column Layout Module to create a newspaper layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CSS 多列布局模块创建报纸布局
- en: Using the `counter-style` CSS at-rule to create custom list styles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `counter-style` CSS 规则创建自定义列表样式
- en: Styling images using the `filter` property
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `filter` 属性样式化图片
- en: Handling broken images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理损坏的图片
- en: Formatting captions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化标题
- en: Using the `quotes` property to add quotation marks to HTML elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `quotes` 属性向 HTML 元素添加引号
- en: Using media queries to change the layout based on screen size
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用媒体查询根据屏幕大小更改布局
- en: In chapter 1, we looked at creating a single-column article, which taught us
    the basic principles of CSS. The design, however, was simple. Let’s revisit the
    concept of formatting articles but make it much more visually interesting. In
    this chapter, we’ll style our content to look like a page out of a newspaper,
    as shown in figure 4.1.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们探讨了创建单列文章，这使我们了解了 CSS 的基本原理。然而，设计很简单。让我们重新审视文章格式化的概念，但要使其更具视觉吸引力。在本章中，我们将样式化我们的内容，使其看起来像报纸的一页，如图
    4.1 所示。
- en: '![](../Images/04-01.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-01.png)'
- en: Figure 4.1 The result we want to achieve
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 我们想要达到的结果
- en: To create the content columns, we’ll use the CSS Multi-column Layout Module.
    Along the way, we’ll also look at how we can manage the space between the columns,
    how to span elements across columns, and how to control where the content breaks
    to a new column.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建内容列，我们将使用 CSS 多列布局模块。在这个过程中，我们还将探讨如何管理列之间的空间，如何跨列扩展元素，以及如何控制内容如何断行到新列。
- en: Part of the newspaper page uses a list of items, which has some default styles
    provided to us by the user agent (UA) stylesheet. We’ll look at how to use the
    CSS Lists and Counters Module, which allows us to customize how our `list-items`
    counters (the numbers and bullets) are styled.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 报纸页面的一部分使用了一个项目列表，它由用户代理（UA）样式表为我们提供的默认样式。我们将探讨如何使用 CSS 列表和计数器模块，它允许我们自定义我们的
    `list-items` 计数器（数字和项目符号）的样式。
- en: Another concept we’ll cover in this chapter is how to style images, including
    the use of the `filter` property in conjunction with functions to alter the image’s
    appearance. We’ll also look at solutions for broken images and ways to make them
    fail gracefully. When we say “fail gracefully” (sometimes known as *graceful degradation*),
    we’re putting in place fallbacks to employ if the thing we’re trying to load is
    having an problem or a feature we’re trying to use isn’t compatible with the user’s
    browser.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的另一个概念是如何样式化图片，包括使用 `filter` 属性和函数来改变图片的外观。我们还将探讨解决损坏图片的方法以及使它们优雅失败的方式。当我们说“优雅失败”（有时也称为
    *优雅降级*）时，我们正在设置回退，以便在我们要加载的东西出现问题或我们要使用的功能与用户的浏览器不兼容时使用。
- en: You can find the code for our project in the `chapter-04` folder of the GitHub
    repository ([http://mng.bz/OpOa](http://mng.bz/OpOa)) or on CodePen at [https://codepen.io/michaelgearon/pen/yLxzbr](https://codepen.io/michaelgearon/pen/yLxzbr).
    Our starting HTML consists of the elements in listing 4.1\. Within the `<body>`
    element are the title of the newspaper and print date followed by an article.
    The article has a heading, author name, a quote, two subheadings, a list, some
    paragraphs, and an image.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 仓库的 `chapter-04` 文件夹中找到我们项目的代码（[http://mng.bz/OpOa](http://mng.bz/OpOa)）或
    CodePen 上的 [https://codepen.io/michaelgearon/pen/yLxzbr](https://codepen.io/michaelgearon/pen/yLxzbr)。我们的起始
    HTML 由列表 4.1 中的元素组成。在 `<body>` 元素中是报纸的标题和印刷日期，然后是一篇文章。文章有一个标题、作者姓名、引言、两个副标题、一个列表、一些段落和一张图片。
- en: Listing 4.1 Starting HTML
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 起始 HTML
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Newspaper title (main heading)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ① 报纸标题（主标题）
- en: ② Print date
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ② 印刷日期
- en: ③ Start of the article
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 文章开始
- en: ④ Article heading
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 文章标题
- en: ⑤ Article author
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 文章作者
- en: ⑥ Quote
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 引言
- en: ⑦ First subheading
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 第一个副标题
- en: ⑧ List
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 列表
- en: ⑨ Second subheading
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 第二个副标题
- en: ⑩ Image
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 图片
- en: ⑪ End of the article
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 文章结束
- en: Figure 4.2 shows our starting point. The styles applied to the HTML are the
    defaults provided by the browser. No author styles have been applied to the page
    yet.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 显示了我们的起始点。应用于 HTML 的样式是浏览器提供的默认样式。页面尚未应用任何作者样式。
- en: '![](../Images/04-02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-02.png)'
- en: Figure 4.2 Starting point
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 起始点
- en: Before we worry about layout, let’s define our theme.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们担心布局之前，让我们定义我们的主题。
- en: 4.1 Setting up our theme
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 设置我们的主题
- en: The theme sets the tone for the page; it generally consists of colors, fonts,
    borders, and sometimes padding. Our theme will stay the same regardless of screen
    size or layout. Often, the theme of a website is tightly coupled to its logo and
    brand colors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 主题为页面设定基调；它通常包括颜色、字体、边框，有时还包括填充。我们的主题将保持不变，无论屏幕大小或布局如何。通常，网站的主题与其标志和品牌颜色紧密相关。
- en: We’ll set some defaults on the `<body>` element that can be inherited by its
    descendants. As a general rule, styles that revolve around typography (`color`,
    `font-family`, and so on) can be inherited by most elements. Exceptions are some
    form elements, which we cover in chapter 10\. When we set inheritable properties
    on the parent, the styles trickle down to the descendents, relieving us of the
    need to apply them to every element.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `<body>` 元素上设置一些默认值，这些值可以被其后代继承。作为一般规则，围绕排版（`color`、`font-family` 等）的样式可以被大多数元素继承。例外是一些表单元素，我们将在第
    10 章中介绍。当我们设置父级的可继承属性时，样式会向下传递到后代，从而减轻了我们需要将它们应用到每个元素上的需求。
- en: 4.1.1 Fonts
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 字体
- en: We apply a background color, font, and text color (listing 4.2). Notice that
    before the `body` rule, we import our chosen `font-family` from Google Fonts.
    Google Fonts ([https://fonts.google.com](https://fonts.google.com)) is a popular
    option with developers, as it’s freely available, and users don’t need to create
    an account or worry about licensing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用背景颜色、字体和文字颜色（列表 4.2）。注意，在 `body` 规则之前，我们从 Google Fonts 导入我们选择的 `font-family`。Google
    Fonts ([https://fonts.google.com](https://fonts.google.com)) 是开发者中流行的选项，因为它免费提供，用户无需创建账户或担心许可问题。
- en: WARNING When loading libraries or assets, including fonts, from a content delivery
    network (CDN), always check the privacy and data terms, and make sure that they’re
    compliant with local laws such as General Data Protection Regulation (GDPR) and
    European Union laws. When in doubt, ask your legal team. If CDNs aren’t an option
    for you, check out chapter 9 for details on loading fonts locally.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：当从内容分发网络（CDN）加载库或资产，包括字体时，始终检查隐私和数据条款，并确保它们符合当地法律，如通用数据保护条例（GDPR）和欧盟法律。如有疑问，请咨询您的法律团队。如果您没有
    CDN 选项，请查看第 9 章以获取有关本地加载字体的详细信息。
- en: PT Serif, for example, isn’t a font we can expect a user to have already loaded
    on their computer; therefore, we have to import it for the browser to tell it
    what the *glyphs* (letters, numbers, and symbols) should look like. We also provide
    a default of `serif` as a fallback should the import fail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，PT Serif 并不是我们期望用户已经在他们的电脑上加载的字体；因此，我们必须导入它，以便浏览器知道 *glyphs*（字母、数字和符号）应该看起来像什么。我们还提供了一个默认的
    `serif` 作为回退选项，以防导入失败。
- en: Web-safe fonts
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全字体
- en: Only a few web-safe fonts (fonts we can assume that most devices will have access
    to) are available. According to W3Schools ([http://mng.bz/Y6Ea](http://mng.bz/Y6Ea)),
    some safe options are Arial, Verdana, Helvetica, Tahoma, Trebuchet MS, Times New
    Roman, Georgia, Garamond, Courier New, and Brush Script MT. But no official standard
    specifies what constitutes a web-safe font or which ones would truly be available
    on all browsers and devices. Therefore, regardless of the font family we choose,
    it’s good practice always to provide a fallback value (`serif`, `sans-serif`,
    `monospace`, `cursive`, or `fantasy`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的网络安全字体（我们可以假设大多数设备都能访问到的字体）只有少数。根据 W3Schools ([http://mng.bz/Y6Ea](http://mng.bz/Y6Ea))，一些安全选项包括
    Arial、Verdana、Helvetica、Tahoma、Trebuchet MS、Times New Roman、Georgia、Garamond、Courier
    New 和 Brush Script MT。但没有官方标准规定构成网络安全字体或哪些字体会在所有浏览器和设备上真正可用。因此，无论我们选择哪种字体族，始终提供回退值（`serif`、`sans-serif`、`monospace`、`cursive`
    或 `fantasy`）是一个好习惯。
- en: Although we’ll do the bulk of the layout later in the chapter, we’ll add some
    left and right padding on our body now to move our text away from the edge.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在本章后面部分进行大量布局，但现在我们将在主体上添加一些左右填充，以便将文本从边缘移开。
- en: Listing 4.2 Defining some theme styles
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 定义一些主题样式
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Imports PT Serif from Google Fonts
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从 Google Fonts 导入 PT Serif
- en: ② Applies PT Serif to our content and provides a fallback
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将 PT Serif 应用于我们的内容并提供回退选项
- en: Figure 4.3 shows our updated page. Notice that all the elements in the `<body>`
    have inherited the `color` and `font-family`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 展示了我们的更新页面。注意，`<body>` 中的所有元素都继承了 `color` 和 `font-family`。
- en: '![](../Images/04-03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3](../Images/04-03.png)'
- en: Figure 4.3 Theme styles applied to the body being inherited by descendants
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 主题样式应用于主体并继承到后代
- en: Next, we’ll style the main heading and subheadings. Let’s start with the newspaper
    title, which is the `<h1>` in the HTML. We want to change the `font-family` to
    use a typeface called Oswald, increase the text size, make it bold, transform
    the font to use all capital letters, set the line height, and center the text.
    Like PT Serif, Oswald isn’t a font that we can expect most users’ devices to know
    about, so we’ll import it much as we did PT Serif.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对主标题和副标题进行样式设计。让我们从报纸标题开始，它在 HTML 中是 `<h1>`。我们希望将 `font-family` 改为使用名为
    Oswald 的字体，增加文本大小，使其加粗，将字体转换为全大写字母，设置行高，并使文本居中。像 PT Serif 一样，Oswald 并不是大多数用户设备上都能识别的字体，所以我们就像导入
    PT Serif 一样导入它。
- en: Notice that for the text size, we use unit `rem`, which stands for “root em.”
    An *em* is a relative unit based on the font size of the element’s parent. If
    a container `div` has a font size of `12px`, and we set a child element’s size
    to `.5em`, the child element’s size would equal to 12 x .5 or `6px`. The `rem`
    unit works similarly, but instead of being relative to the parent’s font size,
    its base value is that of the root element—in our case, `<html>`. We didn’t set
    a font size on the HTML element; therefore, our base will be the browser’s default,
    which in most cases is `16px`. With that in mind, a font size of `4rem`—the size
    we set on our main heading—would be equivalent to 4 x 16 or `64px.`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于文本大小，我们使用单位 `rem`，它代表“根 em”。一个 *em* 是基于元素父字体大小的相对单位。如果一个容器 `div` 的字体大小为
    `12px`，我们将子元素的大小设置为 `.5em`，则子元素的大小将是 12 x .5 或 `6px`。`rem` 单位的工作方式类似，但它不是相对于父元素的字体大小，而是基于根元素的基础值——在我们的例子中，是
    `<html>`。我们没有在 HTML 元素上设置字体大小；因此，我们的基础将是浏览器的默认值，在大多数情况下是 `16px`。考虑到这一点，`4rem`
    的字体大小——我们设置在主标题上的大小——将相当于 4 x 16 或 `64px`。
- en: To import Oswald from Google Fonts, we can add a second `@import` at the top
    of our file, or for better performance, we can combine the two imports into one
    `@import` statement. The ability to combine the two imports is specific to Google
    Fonts; not all CDNs have this ability.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Google Fonts 导入 Oswald，我们可以在文件顶部添加第二个 `@import`，或者为了更好的性能，我们可以将两个导入合并为一个
    `@import` 语句。合并两个导入的能力是 Google Fonts 特有的；并非所有 CDN 都有这种能力。
- en: Notice in listing 4.3 that in our `@import`, after the name of the font, we
    see `:wght@400;700`. This code indicates which Oswald font weights we want to
    import.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在列表 4.3 中，在我们的 `@import` 之后，我们看到 `:wght@400;700`。此代码表示我们想要导入哪些 Oswald 字体权重。
- en: Listing 4.3 Styling the newspaper title
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 样式化报纸标题
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① Updated import that includes both Oswald and PT Serif
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ① 包含 Oswald 和 PT Serif 的更新导入
- en: ② Equivalent to using a value of bold
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ② 等同于使用粗体值
- en: Figure 4.4 shows our updated title.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 显示了我们的更新后的标题。
- en: '![](../Images/04-04.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-04.png)'
- en: Figure 4.4 Styled title
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 样式化标题
- en: 4.1.2 The font-weight property
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 字体权重属性
- en: The `font-weight` property can take either a number value between `100` and
    `900` or a keyword value (`normal`, `bold`, `lighter`, or `bolder`). `normal`
    is equivalent to `400`, and `bold` to `700`. `lighter` and `bolder` change the
    element’s font weight based on the font weight of the parent element. Table 4.1
    shows the relationships between numeric `font-weight` values and their common
    name equivalents.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`font-weight` 属性可以接受介于 `100` 和 `900` 之间的数字值或关键字值（`normal`、`bold`、`lighter`
    或 `bolder`）。`normal` 等同于 `400`，而 `bold` 等同于 `700`。`lighter` 和 `bolder` 会根据父元素的字体权重来改变元素的字体权重。表
    4.1 显示了数字 `font-weight` 值与其常见名称等效关系。'
- en: Table 4.1 `font-weight` values and their common weight names
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 `font-weight` 值及其常见名称
- en: '| Value | Common weight name |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 常见名称 |'
- en: '| `100` | Thin (Hairline) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `100` | 薄（细线）|'
- en: '| `200` | Extra Light (Ultra Light) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `200` | 额外轻量（超轻量）|'
- en: '| `300` | Light |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `300` | 轻量 |'
- en: '| `400` | Normal (Regular) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `400` | 正常（常规）|'
- en: '| `500` | Medium |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `500` | 中等 |'
- en: '| `600` | Semi Bold (Demi Bold) |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `600` | 半粗体（半粗）|'
- en: '| `700` | Bold |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `700` | 粗体 |'
- en: '| `800` | Extra Bold (Ultra Bold) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `800` | 额外粗体（超粗体）|'
- en: '| `900` | Black (Heavy) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `900` | 黑色（粗体）|'
- en: '| `950` | Extra Black (Ultra Black) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `950` | 额外黑色（超黑色）|'
- en: If we don’t import the weight that matches the one we set in the rule, the browser
    will apply the closest weight it has access to. Therefore, had we imported Oswald
    only with a weight of `400` and applied a `font-weight` value of `bold` to our
    element, the browser would have displayed our text with a weight of `400` because
    that value would be the only one it had to work with.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有导入与规则中设置的权重相匹配的权重，浏览器将应用它所能访问的最接近的权重。因此，如果我们只以`400`的权重导入Oswald，并将我们的元素应用`font-weight`值为`bold`，浏览器将显示我们的文本为`400`的权重，因为这个值是它唯一可以工作的值。
- en: 4.1.3 The font shorthand property
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 字体简写属性
- en: 'Using the `font` shorthand property, we can combine most of the styles in our
    rule. The `font` property requires us to provide a `font-family` and `size`, optionally
    followed by `style`, `variant`, `weight`, `stretch`, and `line-height`, using
    the following syntax: `font:` `font-style` `font-variant` `font-weight` `font-stretch`
    `font-size/line-height` `font-family`. The next listing shows our updated rule
    using `font`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`font`简写属性，我们可以将规则中的大多数样式组合在一起。`font`属性要求我们提供一个`font-family`和`size`，可选地后跟`style`、`variant`、`weight`、`stretch`和`line-height`，使用以下语法：`font:`
    `font-style` `font-variant` `font-weight` `font-stretch` `font-size/line-height`
    `font-family`。下一个列表显示了使用`font`的更新规则。
- en: Listing 4.4 Title styles using the `font` shorthand property
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 使用`font`简写属性设置标题样式
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s apply the concepts we’ve covered regarding importing fonts, `font-weight`,
    and the `font` shorthand property to style the article’s main heading and subheadings.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将关于导入字体、`font-weight`和`font`简写属性的概念应用到样式化文章的主要标题和副标题。
- en: 4.1.4 Visual hierarchy
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 视觉层次结构
- en: To create a visual hierarchy on the page, we’ll set the article heading `<h2>`
    to be smaller than our newspaper’s main heading `<h1>` but larger than the subheadings
    within the article `<h3>`. Generally speaking, the larger an element is, the more
    important it’s perceived to be, so we use size to make our headers stand out.
    By using a different `font-family` from the one we use for the main body text
    and making all the heading letters uppercase, we further the distinction.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在页面上创建视觉层次结构，我们将文章标题`<h2>`设置为比报纸的主要标题`<h1>`小，但比文章内的副标题`<h3>`大。一般来说，元素越大，人们认为它越重要，所以我们使用大小来使标题突出。通过使用与正文文本不同的`font-family`，并将所有标题字母转换为大写，我们进一步区分了它们。
- en: Creating a visual hierarchy is important, as it allows the user to glance at
    the screen and immediately recognize elements of interest. It also segments information
    into groups, making the information easier to process and understand.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视觉层次结构很重要，因为它使用户能够快速浏览屏幕并立即识别感兴趣元素。它还将信息分成组，使信息更容易处理和理解。
- en: Listing 4.5 shows our header rules. We’ll keep the same font family, uppercase
    the lettering, and adjust the sizing. We’ll also remove the browser-provided bottom
    margins of both article headers to keep them closer to the text they precede.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5显示了我们的标题规则。我们将保持相同的字体族，将字母转换为大写，并调整大小。我们还将移除文章标题的浏览器提供的底部边距，以使它们更接近它们之前的文本。
- en: Listing 4.5 Article header rules
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.5 文章标题规则
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Article heading
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ① 文章标题
- en: ② Article subheadings
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ② 文章副标题
- en: Now our article’s headers look like figure 4.5.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们文章的标题看起来像图4.5。
- en: '![](../Images/04-05.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-05.png)'
- en: Figure 4.5 Styled article headings
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 样式化的文章标题
- en: 4.1.5 Inline versus block elements
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 内联元素与块元素
- en: 'Let’s continue to make important elements stand out from the rest of the content,
    starting with the publication date, which is inside a `<time>` element in our
    HTML. The `<time>` element semantically denotes a specific period in time; it
    takes an optional `datetime` attribute that provides the date as a machine-readable
    format for search engines. Our `<time>` element looks like this: `<time` `datetime="2021-09-07">Tuesday,`
    `5<sup>th</sup>` `September` `2021</time>`. Figure 4.6 shows the look we want
    to achieve.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使重要元素从其余内容中脱颖而出，从出版日期开始，该日期位于我们的HTML中的`<time>`元素内。`<time>`元素在语义上表示特定的时间段；它接受一个可选的`datetime`属性，该属性以机器可读的格式提供日期，以便搜索引擎搜索。我们的`<time>`元素看起来像这样：`<time
    datetime="2021-09-07">Tuesday,` `5<sup>th</sup>` `September` `2021</time>`。图4.6显示了我们要达到的外观。
- en: '![](../Images/04-06.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-06.png)'
- en: Figure 4.6 Styled publication date
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 样式化的出版日期
- en: Starting with the typography, we center the text and use the Oswald font family,
    set the `font-size` to `1.5rem`, and make the text uppercase and bold. Then we
    change the text size of the *th* found in the superscript element (`<sup>`) to
    a slightly smaller font size and normal weight to decrease its prominence.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从字体排印开始，我们使文本居中，使用Oswald字体家族，将`font-size`设置为`1.5rem`，并将文本改为大写和粗体。然后我们将上标元素（`<sup>`）中找到的`*th`的文本大小改为略小的字体大小和正常重量，以降低其突出度。
- en: Next, we add the top and bottom borders to be 3-pixel-thick, solid, dark gray
    lines. After adding the borders, we add some top and bottom padding so that we
    have some breathing room between the text and the borders.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加顶部和底部边框，使其为3像素粗细的实心深灰色线条。添加边框后，我们添加一些顶部和底部填充，以便在文本和边框之间留出一些空间。
- en: The `<time>` element is an inline-level element, meaning that it takes up only
    the exact amount of space it needs for its content, the same way that a `<span>`
    or `<a>` element does.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`<time>`元素是一个内联级元素，这意味着它只占据其内容所需的确切空间，就像`<span>`或`<a>`元素一样。'
- en: By contrast, block-level elements (such as `<div>`, `<p>`, and `<ul>`) place
    themselves on a new line and take the full width of their available space unless
    given a set width. To achieve the design in figure 4.6, we want our `<time>` element
    to behave as though it were a block-level element so that the text will place
    itself in the middle of the screen, and the borders will take the full width of
    the page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，块级元素（如`<div>`、`<p>`和`<ul>`）将自己放置在新的一行上，并占据其可用空间的全宽，除非指定了固定宽度。为了实现图4.6中的设计，我们希望`<time>`元素表现得像块级元素，这样文本就会放置在屏幕中间，边框将占据整个页面的宽度。
- en: '![](../Images/04-07.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-07.png)'
- en: Figure 4.7 The `<time>` element exhibiting inline behavior
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 `<time>`元素表现出内联行为
- en: To change the element’s default behavior, we’ll use the `display` property and
    give it a value of `block`. Figures 4.7 and 4.8 show the `<time>` element before
    and after we add the `display` property. In figure 4.7 (before adding the `display`
    property), the element is exhibiting its default behavior as an inline-level element.
    In figure 4.8 (after adding the `display` property), the element behaves like
    a block-level element, taking the full width of the screen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改元素默认行为，我们将使用`display`属性并为其提供一个值为`block`的值。图4.7和图4.8显示了在添加`display`属性之前和之后`<time>`元素的表现。在图4.7（添加`display`属性之前），元素表现出其作为内联级元素的默认行为。在图4.8（添加`display`属性之后），元素表现得像块级元素，占据整个屏幕的宽度。
- en: '![](../Images/04-08.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-08.png)'
- en: Figure 4.8 The `<time>` element exhibiting block behavior
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 `<time>`元素表现出块级行为
- en: 'Styling the publication date in this manner serves two purposes: the styling
    makes it stand out, and it creates a visual divide between the newspaper information
    (the date and newspaper’s main heading) and the article itself (everything below
    the date). The following listing contains the rules we wrote to achieve our design.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式样式化出版日期有两个目的：样式使其突出，并在报纸信息（日期和报纸的主要标题）与文章本身（日期以下的所有内容）之间创建视觉分隔。以下列表包含我们编写的以实现我们设计的规则。
- en: Listing 4.6 Styling the publication date
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 样式化出版日期
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Typography
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ① 字体排印
- en: ② Handles the borders and padding
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ② 处理边框和填充
- en: ③ Makes the element behave like a block-level element
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使元素表现得像块级元素
- en: ④ Styles the “th”
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 样式化“th”
- en: 4.1.6 Quotes
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.6 引用
- en: The last bit of text we want to feature is the `<blockquote>` after the second
    paragraph in the article. Sticking with our theme, as with all the other elements
    we want to make stand out, we’ll make the font bigger and bolder. We’ll also adjust
    the line height and add a margin to the element. Isolating an element from the
    content around it makes it easier to spot. By adding a top and bottom margin,
    we add space between the quote and the paragraphs above and below it, creating
    whitespace around the element. By adding left and right margins, we change its
    alignment, effectively indenting it. The added whitespace creates isolation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要突出的最后一段文本是文章中第二段之后的`<blockquote>`。继续我们的主题，就像我们想要突出的所有其他元素一样，我们将使字体更大、更粗。我们还将调整行高并为元素添加边距。将元素与其周围的内容隔离开来使其更容易被发现。通过添加顶部和底部边距，我们在引用和其上下的段落之间添加空间，在元素周围创建空白。通过添加左右边距，我们改变其对齐方式，实际上使其缩进。添加的空白创建了隔离。
- en: Let’s also add quotation marks to our `<blockquote>`. To add the quotation marks
    at the beginning and end of our quote, we could simply go into the HTML and add
    them manually, or we can do the job programmatically with CSS.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也将引号添加到我们的 `<blockquote>` 中。为了在引语的开头和结尾添加引号，我们可以简单地进入 HTML 并手动添加它们，或者我们可以使用
    CSS 逐行编程来完成这项工作。
- en: The `quotes` property allows us to define custom quotation marks. We can pass
    to this property the symbols we want to use as our double- and single-quote glyphs.
    Not all languages use the same symbols. American English, for example, uses “
    ... ” and ‘ ... ’, but French uses « ... » and ‹ ... ›. Using the `quotes` property,
    we can customize the symbols we want to use. If we don’t provide a value for `quotes`,
    the browser’s default behavior is to use what is customary for the language set
    on the document.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`quotes` 属性允许我们定义自定义引号。我们可以将我们想要用作双引号和单引号图标的符号传递给此属性。并非所有语言都使用相同的符号。例如，美式英语使用
    “ ... ” 和 ‘ ... ’，但法语使用 « ... » 和 ‹ ... ›。使用 `quotes` 属性，我们可以自定义我们想要使用的符号。如果我们没有为
    `quotes` 提供值，浏览器默认行为是使用文档上设置的语言的常规符号。'
- en: The `quotes` property, however, only defines the symbols; it doesn’t add them.
    To add them, we use the `content` property values `open-quote` and `close-quote`
    in conjunction with the `::before` and `::after` pseudo-elements, as shown in
    listing 4.7\. The pseudo-elements allow us to insert content via the `content`
    property before and after the element to which they’re applied, respectively.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`quotes` 属性仅定义了符号；它不会添加它们。为了添加它们，我们使用 `content` 属性的 `open-quote` 和 `close-quote`
    值，结合 `::before` 和 `::after` 伪元素，如列表 4.7 所示。伪元素允许我们通过 `content` 属性在应用它们的元素之前和之后插入内容。
- en: Listing 4.7 Styling the `blockquote`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 样式化 `blockquote`
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `open-quote` and `close-quote` keywords represent opening and closing quotation
    marks as defined by the `quotes` property. Because we didn’t add a `quotes` declaration
    to our `blockquote` rule, the browser will use what is conventional for the document’s
    language, which we set to `en-US` in the language (`lang`) attribute of the `<html>`
    tag. The value of `en-US` specifies that our document is written in American English;
    therefore, the symbols that the browser renders are “ and ”, as we see in figure
    4.9\.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`open-quote` 和 `close-quote` 关键字代表由 `quotes` 属性定义的开头和结尾引号。因为我们没有在我们的 `blockquote`
    规则中添加 `quotes` 声明，所以浏览器将使用文档语言的常规符号，我们在 `<html>` 标签的 `lang` 属性中将其设置为 `en-US`。`en-US`
    的值指定我们的文档是用美式英语编写的；因此，浏览器渲染的符号是 “ 和 ”，正如我们在图 4.9 中看到的那样。'
- en: '![](../Images/04-09.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-09.png)'
- en: Figure 4.9 Styled title, heading, subheadings, and quote
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 样式化的标题、标题、副标题和引语
- en: With our quote styled, let’s turn our attention to the bulleted list in the
    middle of the article.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的引语样式化之后，让我们将注意力转向文章中间的列表。
- en: 4.2 Using CSS counters
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 使用 CSS 计数器
- en: Our article contains an unordered (bulleted) list. Currently, each list item
    has the default bullet before it. We can alter what our bullet looks like by using
    the `list-style-type` property. By default, we can choose disc (•), circle (○),
    square (▪), and numbers or letters in several languages, alphabets, and number
    formats. But let’s say we want our bullet to be an emoji—specifically, the hot-beverage
    emoji (☕). We’ll have to create a custom list style.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文章包含一个无序列表（项目符号列表）。目前，每个列表项前面都有一个默认的项目符号。我们可以通过使用 `list-style-type` 属性来改变我们的项目符号的外观。默认情况下，我们可以选择圆点（•）、圆圈（○）、方块（▪），以及多种语言、字母表和数字格式中的数字或字母。但假设我们想要我们的项目符号是一个表情符号——具体来说，是热饮表情符号（☕）。我们必须创建一个自定义列表样式。
- en: To create our custom list style, we’ll use the `@counter-style` at-rule. We
    used at-rules in chapter 3 when we created keyframes. In this case, instead of
    defining how an animation will behave, we’ll define how a list looks and behaves.
    The at-rule is called `counter-style` because it specifically addresses the built-in
    counting mechanism for list items in CSS. Under the covers, regardless of whether
    the list is ordered or unordered, the browser keeps track of the position of the
    item in the list—that is, it counts the items.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的自定义列表样式，我们将使用 `@counter-style` at 规则。我们在第 3 章创建关键帧时使用了 at 规则。在这种情况下，我们不是定义动画将如何行为，而是定义列表的外观和行为。这个
    at 规则被称为 `counter-style`，因为它专门针对 CSS 中列表项的内置计数机制。在底层，无论列表是有序的还是无序的，浏览器都会跟踪列表中项目的位置——也就是说，它会计数项目。
- en: As with keyframes (which we named so we could reference them inside our `animation`
    property), we’ll name our `@counter-style` so we can reference it with the `list-style`
    property and apply it to our list. Let’s name our list-style `emoji`. Our at-rule,
    therefore, will be `@counter-style` `emoji` `{` `}`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与关键帧（我们将其命名为以便在 `animation` 属性内部引用）一样，我们将命名我们的 `@counter-style`，以便我们可以使用 `list-style`
    属性引用它并将其应用到我们的列表。让我们将我们的列表样式命名为 `emoji`。因此，我们的 at 规则将是 `@counter-style` `emoji`
    `{` `}`。
- en: 'Next, we’ll define the behavior our `list-style` needs to have inside of our
    at-rule. We’ll use three properties: `symbols`, `system`, and `suffix`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的 at 规则内部定义 `list-style` 需要的行为。我们将使用三个属性：`symbols`、`system` 和 `suffix`。
- en: 4.2.1 The symbols descriptor
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 符号描述符
- en: The `symbols` descriptor defines what will be used to create the bullet style.
    To define our emoji as the symbol to use, we can use the emoji directly or use
    its Unicode value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbols` 描述符定义了将用于创建项目符号样式的元素。为了将我们的表情符号作为要使用的符号，我们可以直接使用表情符号或使用其 Unicode
    值。'
- en: '*Unicode* is a character-encoding standard that specifies how a 16-bit binary
    value is represented as a string. In other words, it’s the code representation
    of our emoji. The actual emoji image is determined by the operating system and
    browser, which is why we see variations in how emojis look between iOS and Android,
    for example. The Unicode value tells the machine what to render.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unicode* 是一种字符编码标准，它指定了如何将 16 位二进制值表示为字符串。换句话说，它是我们表情符号的代码表示。实际的表情符号图像由操作系统和浏览器决定，这就是为什么我们在
    iOS 和 Android 等设备上看到表情符号的外观有所不同。Unicode 值告诉机器如何渲染。'
- en: 'We use lookup tables such as the one at [http://mng.bz/GRQJ](http://mng.bz/GRQJ)
    to find this value for our emoji. ☕ is listed as having the following code: `U+2615`.
    To tell our CSS that we’re using a Unicode value, we’ll replace the `U+` with
    a backslash (`\`). Using the Unicode value, our declaration value will be `symbols:`
    `"\2615"`. If we use the emoji, our declaration value will be `symbols:` ☕;.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类似 [http://mng.bz/GRQJ](http://mng.bz/GRQJ) 的查找表来找到我们表情符号的此值。☕ 被列为以下代码：`U+2615`。为了告诉我们的
    CSS 我们正在使用 Unicode 值，我们将用反斜杠 (`\`) 替换 `U+`。使用 Unicode 值，我们的声明值将是 `symbols:` `"\2615"`。如果我们使用表情符号，我们的声明值将是
    `symbols:` ☕;。
- en: Next, we need to define our `system` descriptor.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义我们的 `system` 描述符。
- en: 4.2.2 The system descriptor
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 系统描述符
- en: Regardless of type of list (ordered or unordered), under the covers the browser
    keeps track of the list item it’s styling based on its position inside the list.
    The first item’s integer value is 1, the second is 2, and so on. The `system`
    descriptor value defines the algorithm used to convert that integer value to the
    visual representation we see on the screen.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 无论列表类型（有序或无序列表），浏览器在底层都会根据列表项在列表中的位置跟踪它所设置的样式。第一个项的整数值是 1，第二个是 2，依此类推。`system`
    描述符值定义了将此整数值转换为我们在屏幕上看到的视觉表示所使用的算法。
- en: We’re going to use the `cyclic` value. Earlier, we provided only one emoji in
    our `symbols` declaration, but we could have included multiple different emojis
    using a space-delimited list. A `cyclic` value tells the browser to loop through
    these values and, when it runs out, to start back at the beginning. Because we
    have only one value, the browser will apply the ☕ to the first list item and then
    run out of symbols. Having run out before the second list item, the browser starts
    back at the beginning of the list, applying the ☕ once again but to the second
    list item this time. Then the browser will run again, moving on to the third list
    item, and the cycle continues. Finally, we’ll set a suffix.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `cyclic` 值。之前，我们在 `symbols` 声明中只提供了一个表情符号，但我们可以使用空格分隔的列表包含多个不同的表情符号。`cyclic`
    值告诉浏览器循环遍历这些值，当用完时，从列表开头重新开始。因为我们只有一个值，浏览器将把 ☕ 应用到第一个列表项，然后符号用完。在第二个列表项之前用完符号后，浏览器从列表开头重新开始，这次将
    ☕ 应用到第二个列表项。然后浏览器再次运行，移动到第三个列表项，循环继续。最后，我们将设置一个后缀。
- en: 4.2.3 The suffix descriptor
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 后缀描述符
- en: The `suffix` descriptor defines what comes between the bullet (our emoji) and
    the contents of the list item—by default, a period. We want to replace the period
    with plain whitespace between our emoji and list-item content. Therefore, we’ll
    set our `suffix` descriptor value to `"` `"` (a blank space).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`suffix` 描述符定义了项目符号（我们的表情符号）和列表项内容之间的内容——默认情况下是一个句点。我们想要在表情符号和列表项内容之间替换句点，用空格。因此，我们将我们的
    `suffix` 描述符值设置为 `"` `"`（一个空格）。'
- en: 4.2.4 Putting everything together
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 将一切组合起来
- en: With our `counter-style` defined, we can apply it to our list. Remember that
    we named the `counter-style` rule `emoji`. We’ll apply the name as the `list-style`
    property value for our list, as shown in the following listing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `counter-style` 定义完成后，可以将其应用到我们的列表中。记住，我们给 `counter-style` 规则命名为 `emoji`。我们将使用这个名称作为列表的
    `list-style` 属性值，如下所示。
- en: Listing 4.8 Styling the list
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 样式化列表
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① The at-rule defining the custom list-style’s behavior
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ① 定义自定义列表样式的 at 规则
- en: ② ☕
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ② ☕
- en: ③ Applies the custom list-style to the article’s lists
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将自定义列表样式应用于文章的列表
- en: Figure 4.10 shows our newly styled list.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 显示了我们的新样式列表。
- en: '![](../Images/04-10.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-10.png)'
- en: Figure 4.10 List styled using ☕ as counters
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 使用 ☕ 作为计数器的样式化列表
- en: 4.2.5 @counter versus list-style-image
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 @counter 与 list-style-image
- en: Another way to change the list item marker being used is to use the `list-style-image`
    property and assign an image to it, similarly to the way we can set a background
    image by using the `background-image` property. We didn’t use that approach in
    this project because we used an emoji, which is a Unicode character and not an
    image. The counter also provides us much more control, such as assigning a suffix
    or specifying how the counter cycles through the item markers being displayed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更改正在使用的列表项标记的方法是使用 `list-style-image` 属性并将其分配给一个图像，类似于我们可以通过使用 `background-image`
    属性来设置背景图像的方式。我们没有在这个项目中使用这种方法，因为我们使用了表情符号，这是一个 Unicode 字符而不是图像。计数器还为我们提供了更多的控制，例如分配后缀或指定计数器如何循环显示的项标记。
- en: If we’re looking only to change the marker to a specific image, `list-style-image`
    is perfect. But if we want to have more granular control or, as in our case, to
    use text, we need to use `@counter`. Let’s continue going down the page, styling
    the image next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想将标记更改为特定的图片，`list-style-image` 是完美的。但如果我们想要更精细的控制，或者在我们这个例子中，使用文本，我们需要使用
    `@counter`。让我们继续向下滚动页面，接下来对图片进行样式设置。
- en: 4.3 Styling images
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 图片样式
- en: Historically, newspapers were printed in black and white. Colored ink in newsprint
    is a fairly new thing when we consider the history of print. To give our design
    a bit of a retro vibe, therefore, we’ll make our image grayscale. First, we’ll
    look at how to alter our image using filters. Unlike in print, on the web we need
    to worry about resources not loading or links being broken, so we’ll also look
    at how to make the image fail gracefully should it fail to load. Finally, we’ll
    add a caption to accompany the image.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，报纸是以黑白印刷的。当我们考虑印刷的历史时，新闻纸中的彩色油墨是一个相对较新的东西。因此，为了给我们的设计增添一点复古感，我们将使我们的图像变为灰度。首先，我们将看看如何使用滤镜来改变我们的图像。与印刷不同，在网络上我们需要担心资源加载失败或链接损坏，因此我们还将看看如果图像加载失败，如何使图像优雅地失败。最后，我们将添加一个标题来伴随图像。
- en: 4.3.1 Using the filter property
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 使用 filter 属性
- en: 'As in photo editors or on social-media websites like Instagram, we can apply
    filters to images with CSS. We can alter colors, blur, and add drop shadows, for
    example. Figure 4.11 shows examples of some of the things we can do to our images
    by using filters in CSS. Check out this code sample in CodePen to see it in action:
    [https://codepen.io/michaelgearon/pen/porovxJ](https://codepen.io/michaelgearon/pen/porovxJ)`.`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在照片编辑器或像 Instagram 这样的社交媒体网站上一样，我们可以使用 CSS 对图像应用滤镜。我们可以改变颜色、模糊并添加阴影，例如。图 4.11
    显示了我们可以通过在 CSS 中使用滤镜对图像进行的一些操作示例。查看 CodePen 中的此代码示例以查看其效果：[https://codepen.io/michaelgearon/pen/porovxJ](https://codepen.io/michaelgearon/pen/porovxJ)。
- en: '![](../Images/04-11.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-11.png)'
- en: Figure 4.11  Examples of images altered with the `filter` property
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 使用 `filter` 属性修改的图片示例
- en: If we think about pre-digital-era photography, when we used film and had to
    go to a shop to have it developed, we applied filters by adding a translucent
    disk over our lens, which altered the light coming into the camera box and onto
    the film. By altering the nature of the light, we altered the image being produced.
    If we used a red filter while taking a picture, for example, only the red-colored
    wavelength was allowed through; our picture was tinted red. Polarized sunglasses
    are another example of a filter that alters the light coming through a lens.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑数字时代之前的摄影，当我们使用胶片并需要去商店冲洗时，我们通过在镜头上添加一个半透明的圆盘来应用滤镜，这改变了进入相机箱和胶片的光线。通过改变光线的性质，我们改变了产生的图像。例如，如果我们拍照时使用红色滤镜，那么只有红色波长的光线被允许通过；我们的照片被染成了红色。偏光太阳镜是另一种改变通过镜头进入的光线的滤镜的例子。
- en: We can still use physical filters with digital cameras. In many cases, however,
    filters are applied digitally after the picture has been taken.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以在数码相机上使用物理过滤器。然而，在许多情况下，过滤器是在拍照后以数字方式应用的。
- en: In CSS, we use the `filter` property to apply a filter to the image; then we
    use a function that defines the behavior we want the filter to have. You can find
    a list of the available functions at [http://mng.bz/zmYA](http://mng.bz/zmYA).
    We’ll use the `grayscale()` function to make our picture appear to be a black-and-white
    photo.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，我们使用`filter`属性对图像应用过滤器；然后我们使用一个函数来定义过滤器应有的行为。您可以在[http://mng.bz/zmYA](http://mng.bz/zmYA)找到可用函数的列表。我们将使用`grayscale()`函数使我们的图片看起来像黑白照片。
- en: The `grayscale()` function takes a percentage, which represents how much we
    want to reduce the amount of color in the image. We want to remove all the color,
    so we’ll pass in a value of `100%`. Our rule, then, will be `img` `{` `filter:`
    `grayscale(100%)` `}`. Figure 4.12 shows the filter applied to our image.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`grayscale()`函数接受一个百分比，表示我们想要减少图像中颜色的程度。我们想要移除所有颜色，所以我们将传递一个`100%`的值。因此，我们的规则将是`img
    { filter: grayscale(100%) }`。图4.12显示了应用在我们图像上的过滤器。'
- en: '![](../Images/04-12.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-12.png)'
- en: Figure 4.12 Grayscale Image
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 灰度图像
- en: One consideration to make before using filters is their impact on website performance.
    Some of the filter functions, such as `grayscale()`, are relatively simple for
    the browser to process, but functions such as `drop-shadow``()` and `blur``()`
    can be resource-intensive. If we find that we’re applying many filters to a large
    number of images, we should consider the impact of the filters on overall page
    performance and whether we should be preprocessing the image rather than applying
    the change with CSS.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用过滤器之前，需要考虑它们对网站性能的影响。一些过滤器函数，如`grayscale()`，对浏览器来说处理起来相对简单，但像`drop-shadow()`和`blur()`这样的函数可能会消耗大量资源。如果我们发现我们在大量图像上应用了许多过滤器，我们应该考虑过滤器对整体页面性能的影响，以及我们是否应该预处理图像而不是用CSS应用更改。
- en: 4.3.2 Handling broken images
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 处理损坏的图像
- en: Even with the most thorough diligence and best testing practices, broken image
    links can happen. Let’s add some fallbacks to ensure that if our image fails to
    load (regardless of the reason), we’ll maintain a positive experience for our
    users.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是最彻底的勤勉和最佳测试实践，损坏的图像链接也可能发生。让我们添加一些回退机制，以确保如果我们的图像无法加载（无论原因如何），我们仍然能为用户提供积极的体验。
- en: 'First, let’s deliberately break our link. In the HTML, we’ll replace the path
    to the image with an image file that doesn’t exist in our project, like so: `<img`
    `src="./my-broken-image.jpg"` `alt="my` `broken` `link"` `/>.` The image will
    display as broken, as shown in figure 4.13.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们故意破坏我们的链接。在HTML中，我们将图像的路径替换为项目中不存在的图像文件，如下所示：`<img src="./my-broken-image.jpg"
    alt="my broken link" />`。图像将显示为损坏，如图4.13所示。
- en: '![](../Images/04-13.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-13.png)'
- en: Figure 4.13 Broken link with `alt` text
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 带有`alt`文本的损坏链接
- en: Notice that the text provided in the `alt` attribute is displayed. The `alt`
    attribute allows assistive technologies to inform users about the image being
    displayed. A common use case is a blind user accessing content via a screen reader.
    In this particular case, because the image is broken, the text replaces the image.
    Although the situation isn’t ideal, in the event of an image failure, users can
    still be informed of the content that the image was supposed to provide.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在`alt`属性中提供的文本会被显示出来。`alt`属性允许辅助技术向用户告知正在显示的图像。一个常见的用例是盲人用户通过屏幕阅读器访问内容。在这种情况下，因为图像损坏，文本替换了图像。尽管这种情况并不理想，但在图像损坏的情况下，用户仍然可以了解图像原本应该提供的内容。
- en: 'In our case, the image is purely decorative and doesn’t provide any content
    value, so if the link is broken, we’ll hide the image. Nothing will be there,
    but “nothing” is less unsightly than a broken-image icon. Because there’s no way
    to detect that an image is broken in CSS, we need to use a little bit of JavaScript
    to know when to hide the image. We’ll use the `onerror` JavaScript event handler
    to trigger a change in styles as follows: `<img` `src="..."` `alt="..."` `onerror="this.style.display=''none''"`
    `>.` The bit of code that is of interest to us here is the `onerror` attribute.
    When an error occurs, the JavaScript inside the `onerror` attribute triggers and
    sets the image’s `display` property to `none`, hiding the image. We can see that,
    in figure 4.14, our broken image is missing.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，图像纯粹是装饰性的，不提供任何内容价值，因此如果链接损坏，我们将隐藏图像。那里将什么都没有，但“什么都没有”比破损图像图标更不显眼。由于
    CSS 中无法检测图像是否损坏，我们需要使用一点 JavaScript 来知道何时隐藏图像。我们将使用 `onerror` JavaScript 事件处理器来触发以下样式更改：`<img
    src="..." alt="..." onerror="this.style.display='none'" >`。这里对我们有意义的代码片段是 `onerror`
    属性。当发生错误时，`onerror` 属性内的 JavaScript 触发并将图像的 `display` 属性设置为 `none`，隐藏图像。我们可以看到，在图
    4.14 中，我们的破损图像缺失。
- en: '![](../Images/04-14.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-14.png)'
- en: Figure 4.14 The broken image is missing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 破损的图像缺失。
- en: 'The `onerror` code triggers only when the image fails to load, so let’s fix
    our resource path to our image but keep the error handling: `<img` `src="./image.jpg"`
    `alt=""` `onerror="this.style.display=''none''"` `>.` Now our image is restored
    (figure 4.15), but we have a safeguard in case it fails.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`onerror` 代码仅在图像加载失败时触发，因此让我们修复我们的资源路径到我们的图像，但保留错误处理：`<img src="./image.jpg"
    alt="" onerror="this.style.display=''none''" >`。现在我们的图像已恢复（图 4.15），但我们有一个安全措施以防它失败。'
- en: '![](../Images/04-15.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-15.png)'
- en: Figure 4.15 Restored image with fallback
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 恢复的图像及备用
- en: Next, let’s add a caption to the image.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们给图像添加一个标题。
- en: 4.3.3 Formatting captions
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 格式化标题
- en: The image doesn’t have a caption, so we’re going to add one by using the `<figure>`
    and `<figcaption>` HTML elements. Then we’ll style it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图像没有标题，因此我们将通过使用 `<figure>` 和 `<figcaption>` HTML 元素来添加一个标题。然后我们将对其进行样式化。
- en: These two elements go hand in hand. `<figure>` contains the image and then the
    optional `<figcaption>`. Often in books and other publishing material, a diagram,
    chart, or image has text below it that describes it or relates it to the text.
    Semantically, the benefit of grouping the image and the caption is that grouping
    programmatically links the image with its caption. From a styling perspective,
    having the elements together in a parent element allows us to position the element
    and its caption as a unit. The following listing shows how to change the HTML
    to add the figure and caption.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个元素是相辅相成的。`<figure>` 包含图像，然后是可选的 `<figcaption>`。在书籍和其他出版材料中，图表、图表或图像下面通常有文本来描述它或将其与文本相关联。从语义上讲，将图像和标题分组的好处是程序性地将图像与其标题链接起来。从样式化的角度来看，将元素与其标题一起放在父元素中允许我们将元素及其标题作为一个单元进行定位。以下列表显示了如何更改
    HTML 以添加图像和标题。
- en: Listing 4.9 Adding a `<figure>` and `<figcaption>` to the HTML
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 向 HTML 添加 `<figure>` 和 `<figcaption>`
- en: '[PRE8]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Start of the figure
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ① 图像开始
- en: ② Our image
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们的图像
- en: ③ Our image caption
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们的图像标题
- en: ④ End of the figure
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 图像结束
- en: Let’s style the figure and the caption, starting by removing the browser-provided
    margins (figure 4.16) that are currently being applied to the figure.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始样式化图像和标题，首先移除当前应用于图像的浏览器提供的边距（图 4.16）。
- en: '![](../Images/04-16.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-16.png)'
- en: Figure 4.16 `<figure>` with browser-provided styles
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 带有浏览器提供样式的 `<figure>`
- en: Next, we’ll reinstate a bottom margin so that our caption is kept separate from
    the paragraph below it. Finally, we’ll center the image and caption. We’ll style
    the caption’s text to use the Oswald font family (the one we used for all the
    headers) to differentiate it visually from the article text. The following listing
    shows the CSS used to style the figure and caption.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将恢复底部边距，以便我们的标题与下面的段落保持分离。最后，我们将居中图像和标题。我们将标题文本的样式设置为使用 Oswald 字体家族（我们用于所有标题的字体）来在视觉上将其与文章文本区分开来。以下列表显示了用于样式化图像和标题的
    CSS。
- en: Listing 4.10 `figure` and `figcaption` styles
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 `figure` 和 `figcaption` 样式
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '① Padding shorthand property: top, left, and right padding set to 0 and bottom
    set to 12px'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ① 内边距简写属性：上、左和右边距设置为 0，下边距设置为 12px
- en: Figure 4.17 shows the progress we’ve made on our project thus far. At this point,
    the page looks good on narrow screens, but we still need to display our columns
    on wide screens. Next, we’ll look at how to create a multicolumn layout using
    the CSS Multi-column Layout Module.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 展示了到目前为止我们在项目上取得的进展。到目前为止，页面在窄屏幕上看起来不错，但我们仍然需要在宽屏幕上显示我们的列。接下来，我们将探讨如何使用
    CSS 多列布局模块创建多列布局。
- en: '![](../Images/04-17.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-17.png)'
- en: Figure 4.17 Progress thus far, including styled figure and image caption
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 展示了到目前为止的进展，包括样式化的图表和图像标题
- en: 4.4 Using the CSS Multi-column Layout Module
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 使用 CSS 多列布局模块
- en: The CSS Multi-column Layout Module is perhaps less known than Grid and Flexbox
    as a way to present content, but it’s no less useful. The purpose of this module
    is to allow content to flow naturally between multiple columns. It works similarly
    to the way we create multiple column layouts in a Microsoft Word or Google Docs
    document. We assign columns to a section of content, and the content naturally
    flows from one column to another. Because we want our content to be placed in
    columns only on wider screens, we’ll use a media query to apply our columns conditionally
    only after the window reaches a particular size.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 多列布局模块可能不如 Grid 和 Flexbox 那样广为人知，但它的用途同样重要。此模块的目的是允许内容在多个列之间自然流动。它的工作方式类似于我们在
    Microsoft Word 或 Google Docs 文档中创建多列布局的方式。我们将列分配给内容的一部分，内容自然地从一列流到另一列。因为我们希望我们的内容仅在较宽的屏幕上以列的形式显示，所以我们将使用媒体查询在窗口达到特定大小时有条件地应用我们的列。
- en: 4.4.1 Creating media queries
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 创建媒体查询
- en: A *media query* is a type of at-rule; we looked at it briefly in chapter 2 when
    we changed our grid layout to depend on the width of the screen. Like `@counter-style`,
    which we used earlier in this chapter, it starts with an at (`@)` symbol followed
    by the identifier `media`. Then we set the instruction about what to do when the
    rules inside the media query apply. We want to place the content in columns when
    our window width is greater than or equal to 955 pixels. Therefore, our media
    query will be `@media(min-width:` `955px)` `{}`. Figure 4.18 breaks down the individual
    pieces of the query. Inside the media query, we’ll define our columns.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*媒体查询*是一种 at 规则；我们在第 2 章中简要介绍了它，当时我们更改了网格布局，使其依赖于屏幕宽度。就像我们本章早些时候使用的 `@counter-style`
    一样，它以 at (`@`) 符号开头，后跟标识符 `media`。然后我们设置媒体查询内规则应用时的指令。我们希望在窗口宽度大于或等于 955 像素时放置内容。因此，我们的媒体查询将是
    `@media(min-width: 955px) {}`。图 4.18 分解了查询的各个部分。在媒体查询内部，我们将定义我们的列。'
- en: '![](../Images/04-18.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-18.png)'
- en: Figure 4.18 Media-query breakdown
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 媒体查询分解
- en: 4.4.2 Defining and styling columns
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 定义和样式化列
- en: 'There are two ways we can define how the columns are created:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种定义列创建方式的方法：
- en: '*Dictate a column width*. The browser will create as many columns of that width
    as it can in the available space.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定列宽*。浏览器将在可用空间内创建尽可能多的该宽度的列。'
- en: '*Dictate how many columns we want.* The browser will fit that number of equal-size
    columns in the available space.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*指定我们想要多少列*。浏览器将在可用空间内适应该数量的等宽列。'
- en: We’ll go with the second option because we already know that we want to create
    three columns. We specifically target the article, and using the `column-count`
    property, we set our quantity to `3`, as shown in the following listing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择第二个选项，因为我们已经知道我们想要创建三列。我们特别针对文章，并使用 `column-count` 属性将数量设置为 `3`，如下面的列表所示。
- en: Listing 4.11 Conditionally breaking an article into three columns based on screen
    width
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 根据屏幕宽度有条件地将文章分为三列
- en: '[PRE10]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Media query
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ① 媒体查询
- en: ② Sets how many columns we want
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置我们想要多少列
- en: Figure 4.19 shows our article laid out in three columns using the CSS from listing
    4.11.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 展示了使用列表 4.11 中的 CSS 将文章布局为三列。
- en: '![](../Images/04-19.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-19.png)'
- en: Figure 4.19 Three-column layout
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 三列布局
- en: Next, we’ll adjust the spacing between columns and add vertical lines between
    them. Let’s start with the vertical lines.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调整列之间的间距，并在它们之间添加垂直线。让我们从垂直线开始。
- en: 4.4.3 Using the column-rule property
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 使用 column-rule 属性
- en: To create a clear separation between our columns, we’ll add a vertical line
    between them, using the `column-rule` property. As with borders and outlines,
    we need to set a line type, width, and color. To keep our line work consistent,
    we’ll use the same color and style of line that we set for the borders above and
    below the date at the top of the page. We’ll make the lines slightly narrower,
    however.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的列之间创建清晰的分隔，我们将使用`column-rule`属性添加一条垂直线。与边框和外框一样，我们需要设置线型、宽度和颜色。为了保持我们的线条工作一致，我们将使用与页面顶部日期上方和下方边框相同的颜色和样式。然而，我们将使线条略窄一些。
- en: The lines at the top of the screen separate content types (title, date, and
    article). Here, we’re within the same content type. We add the lines to make visual
    separation of the columns easier; we don’t want to break up the content. We want
    the lines to be less prominent, so we’ll make them thinner.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕顶部的线条将内容类型（标题、日期和文章）分开。在这里，我们处于相同的内容类型中。我们添加线条是为了使列之间的视觉分隔更容易；我们不希望打断内容。我们希望线条不那么突出，所以我们将它们做得更细。
- en: To create the lines, we add `column-rule:` `2px` `solid` `#333333;` to the existing
    article rule inside the media query. Now our article looks like figure 4.20.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建线条，我们在媒体查询中现有的文章规则内添加了`column-rule:` `2px` `solid` `#333333;`。现在我们的文章看起来像图4.20。
- en: '![](../Images/04-20.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-20.png)'
- en: Figure 4.20 Columns with added vertical lines
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 添加了垂直线的列
- en: With our lines in place, we see that we have some crowding between the article
    itself and the date and that we could use a bit more space between our lines and
    our text.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在线条到位后，我们看到文章本身和日期之间有一些拥挤，我们可以在我们的线条和文本之间使用更多空间。
- en: 4.4.4 Adjusting spacing with the column-gap property
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 使用 column-gap 属性调整间距
- en: 'Now we need to do two things: increase the container spacing between the date
    of the article and the body of the article, and increase the gap between columns
    within the article. To adjust the spacing between the article and the date, we’ll
    add `36px` of margin to the top of the article. Because working out a value to
    use isn’t an absolute science, sometimes we need a bit of trial and error to determine
    what will look right on the page. We want to create enough room that each item
    has its own space and is clear, but not so much room that the items are too far
    apart and look separated.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做两件事：增加文章日期和文章正文之间的容器间距，以及增加文章内部列之间的间隔。为了调整文章和日期之间的间距，我们将在文章顶部添加`36px`的边距。因为确定使用值并不是一门绝对的科学，有时我们需要进行一些试错来确定页面上看起来合适的内容。我们希望留出足够的空间，使每个项目都有其自己的空间并且清晰可见，但又不至于空间过大，使得项目看起来过于分散。
- en: Gestalt design principles
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 格式塔设计原则
- en: The *Gestalt principles* of design are a collection of principles of human perception
    that describe how humans group similar elements. One of the seven principles is
    proximity, which talks about how things that are close together appear to be more
    related than things that are spaced farther apart. For more information about
    the Gestalt principles, see [http://mng.bz/0yNv](http://mng.bz/0yNv).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 设计的*格式塔原则*是一组描述人类感知原则的集合，它描述了人类如何将相似元素分组。七个原则之一是邻近性，它讨论了靠近在一起的事物看起来比间隔更远的事物更相关。有关格式塔原则的更多信息，请参阅[http://mng.bz/0yNv](http://mng.bz/0yNv)。
- en: With the space between the article and the date handled, let’s turn our attention
    to the space between the columns. To add a gap between our vertical lines and
    our text, we’ll use the `column-gap` property, which defines the amount of whitespace
    we want to have between our columns. We will set ours to `42px;`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完文章和日期之间的空间后，让我们将注意力转向列之间的空间。为了在垂直线和文本之间添加间隔，我们将使用`column-gap`属性，该属性定义了我们希望在列之间拥有的空白量。我们将我们的设置为`42px;`。
- en: We continue to add these styles inside the media query as shown in listing 4.12
    because we want them to apply only when our layout is columned. We don’t want
    these style changes to apply to narrower screens.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续在媒体查询中添加这些样式，如列表4.12所示，因为我们希望它们只在我们的布局为列时应用。我们不希望这些样式更改应用于较窄的屏幕。
- en: Listing 4.12 Updated media query and article rule
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.12 更新的媒体查询和文章规则
- en: '[PRE11]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With these adjustments made (figure 4.21), let’s turn our attention to the quote.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这些调整（图4.21）后，让我们将注意力转向引用。
- en: '![](../Images/04-21.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-21.png)'
- en: Figure 4.21 Layout with adjusted spacing
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 调整间距后的布局
- en: Earlier in this chapter, we styled the block quote so that it would stand out.
    But now that we have a multicolumn format, it gets a little lost in the other
    visual elements on the page. Let’s make it span multiple columns to make it pop.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们设计了块引用的样式，使其突出。但现在我们有了多列格式，它在页面上的其他视觉元素中有点迷失。让我们让它跨越多个列以使其更加突出。
- en: 4.4.5 Making content span multiple columns
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.5 使内容跨越多个列
- en: 'We can make elements span multiple columns by using the `column-span` property.
    Our choices of values are `all` and `none`. Because we want the quote to go across
    the entire page, we’ll choose `all`. Inside our media query, we’ll add the following
    rule: `blockquote` `{` `column-span:` `all` `}`. This rule results in the layout
    shown in figure 4.22.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `column-span` 属性来使元素跨越多个列。我们的选择是 `all` 和 `none`。因为我们想让引用跨越整个页面，所以我们将选择
    `all`。在我们的媒体查询中，我们将添加以下规则：`blockquote` `{` `column-span:` `all` `}`。这个规则导致图4.22所示的布局。
- en: '![](../Images/04-22.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-22.png)'
- en: Figure 4.22 Content reflow due to spanning the `blockquote` across the columns
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 由于跨越列的 `blockquote` 而导致的内容重新排列
- en: Notice that the flow of the content has changed. We added arrows to show the
    new flow introduced by making the quote span the screen. Instead of flowing the
    entire article from top left to bottom right, evenly distributed across the columns,
    we added `column-span:` `all` to the quote, so content that’s before the quote
    now flows from top left to top right across the page above the quote. The content
    after the quote does the same. As a result of spanning content, we changed the
    flow of the text through our columns.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到内容流程已经改变。我们添加了箭头以显示通过使引用跨越屏幕而引入的新流程。我们不再将整个文章从左上角到右下角均匀分布在整个列中，而是将 `column-span:`
    设置为 `all` 应用于引用，因此引用之前的内容现在从左上角到右上角跨越页面上的引用上方。引用之后的内容也做同样处理。由于内容跨越，我们改变了文本通过列的流程。
- en: When we look at the content flow, we notice that the caption and the image have
    been split across two columns, which isn’t ideal. Let’s prevent that from happening.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看内容流程时，我们注意到标题和图片已经被分割到两个列中，这并不理想。让我们防止这种情况发生。
- en: 4.4.6 Controlling content breaks
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.6 控制内容断行
- en: To prevent the image and its caption from ending up in different columns, we
    can use the `break-inside` property with the keyword value `avoid`, which we set
    on the `<figure>` element. With this declaration, we inform the browser that when
    it’s generating the columns, the contents of the element should stay together
    as a unit, not be split across multiple columns. In other words, the image and
    figure caption should remain together. The rule we add to the media query is `figure`
    `{` `break-inside:` `avoid` `}`. Figure 4.23 shows the resulting output.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止图片及其标题出现在不同的列中，我们可以使用 `break-inside` 属性与关键字值 `avoid`，我们将它设置在 `<figure>`
    元素上。通过这个声明，我们通知浏览器在生成列时，元素的内容应作为一个单元保持在一起，而不是被分割到多个列中。换句话说，图片和图题应该保持在一起。我们添加到媒体查询的规则是
    `figure` `{` `break-inside:` `avoid` `}`。图4.23显示了结果输出。
- en: '![](../Images/04-23.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-23.png)'
- en: Figure 4.23 Keeping the image and caption together
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 保持图片和标题在一起
- en: 4.5 Adding the finishing touches
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 添加最终细节
- en: With our content flowing the way we want it across the columns, let’s polish
    some final details. One of the hallmarks of newspaper layouts is that the text
    is often justified.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的内容按我们想要的流程在列中流动后，让我们完善一些最终细节。报纸布局的一个特点是文本经常是齐行的。
- en: 4.5.1 Justifying and hyphenating text
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 文本齐行和连字符
- en: '*Justification* refers to the alignment of the lines inside a body of text,
    as illustrated in figure 4.24\. When text is *justified*, the lines of text start
    and end at the same spot, forming a box. By contrast, text that is left-aligned
    has ragged ends.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*齐行*指的是文本主体内行的对齐，如图4.24所示。当文本*齐行*时，文本行从同一位置开始和结束，形成一个框。相比之下，左对齐的文本有参差不齐的结尾。'
- en: '![](../Images/04-24.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-24.png)'
- en: Figure 4.24 Text justification
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 文本齐行
- en: Let’s justify our paragraph text. To do this, we’ll use the `text-align` property
    and give it a value of `justify`. To make the lines equal in length, we’ll distribute
    extra space across the line. We can tune how the space is redistributed by using
    the `text-justify` property. If we don’t set a `text-justify` value, the browser
    will choose what it thinks is best for the situation. We have a fluid design;
    it grows and shrinks with the window size. What is best may be different based
    on the window size, so we’ll let the browser decide what will work best.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使段落文本居中。为此，我们将使用 `text-align` 属性并将其值设置为 `justify`。为了使行长度相等，我们将额外空间分配到行上。我们可以通过使用
    `text-justify` 属性来调整空间重新分配的方式。如果我们不设置 `text-justify` 值，浏览器将选择它认为最适合该情况的方式。我们有一个流体设计；它随着窗口大小的变化而增长和缩小。最好的选择可能因窗口大小而异，所以我们将让浏览器决定什么最适合。
- en: We’ll add some hyphens, however. By default, browsers don’t hyphenate a word
    at the end of a line; they simply continue to the next line. We can alter this
    behavior by setting the `hyphens` property to `auto`. Allowing the browser to
    hyphenate words at the end of lines will help diminish the amount of whitespace
    that’s needed between our words to justify the text.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将添加一些连字符。默认情况下，浏览器不会在行尾断开单词；它们简单地继续到下一行。我们可以通过将 `hyphens` 属性设置为 `auto`
    来改变这种行为。允许浏览器在行尾断开单词将有助于减少我们之间所需的空白量，以便对齐文本。
- en: Listing 4.13 shows our paragraph rule. We continue to include our updates inside
    our media query, as these changes are relevant only when we switch to the columns
    layout.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 展示了我们的段落规则。我们继续在我们的媒体查询中包含我们的更新，因为这些更改仅在切换到列布局时相关。
- en: Listing 4.13 Justifying paragraph text
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 居中段落文本
- en: '[PRE12]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now our paragraphs look like those in figure 4.25.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的段落看起来像图 4.25 中的那些。
- en: '![](../Images/04-25.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-25.png)'
- en: Figure 4.25 Justified and hyphenated paragraph text
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 居中和带连字符的段落文本
- en: As we look at our layout, we notice that the image at the bottom of the second
    column looks a little odd and out of place. Let’s fix that.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看布局时，我们注意到第二列底部的图像看起来有点奇怪，位置不合适。让我们修复这个问题。
- en: 4.5.2 Wrapping the text around the image
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 将文本围绕图像包裹
- en: To reconnect the image with the subsequent text, we’ll push the image and its
    caption to the left and have the text wrap around the image. To create this effect,
    we’ll use the `float` property. Applying the `float` property to an element pushes
    it to the left or the right, allowing text and inline elements to wrap around
    it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将图像与后续文本重新连接，我们将图像及其标题推到左边，并让文本围绕图像。为了创建这种效果，我们将使用 `float` 属性。将 `float` 属性应用于一个元素将其推到左边或右边，允许文本和内联元素围绕它。
- en: In this situation, having the image and caption as a unit inside a `<figure>`
    element comes in handy for styling. Because both items are contained in the `<figure>`,
    we’ll apply `float` to the figure, neatly wrapping the text around both the image
    and the caption.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将图像和标题作为一个单元放在 `<figure>` 元素内对于样式化很有用。因为这两个项目都包含在 `<figure>` 中，我们将对图形应用
    `float`，整洁地围绕图像和标题包裹文本。
- en: Listing 4.14 shows how we float the figure. Notice that we added a right margin
    to the figure. Because we are floating the figure to the left, it places itself
    on the left side of the column, allowing the text to wrap around it in the leftover
    space to the right, as shown in figure 4.26\. The right margin creates a space
    between the image and the text so that the text doesn’t come right up against
    the edge of the image.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 展示了如何浮动图形。注意我们给图形添加了一个右边距。因为我们把图形浮动到左边，它把自己放在列的左边，允许文本在剩余的右边空间中围绕它，如图
    4.26 所示。右边距在图像和文本之间创建了一个空间，这样文本就不会紧挨着图像的边缘。
- en: Listing 4.14 Floating the figure
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 浮动图形
- en: '[PRE13]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/04-26.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04-26.png)'
- en: Figure 4.26 Floated image
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 浮动图像
- en: As you’ll see in chapter 7, we can do a lot more cool things with floating images.
    For now, though, let’s focus on our newspaper page. The last thing we’ll address
    is handling how the page behaves in an extremely wide window.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第 7 章中看到的，我们可以用浮动图像做更多酷的事情。不过，现在让我们专注于我们的报纸页面。我们将要解决的最后一件事情是如何处理在极其宽的窗口中页面的行为。
- en: 4.5.3 Using max-width and a margin value of auto
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 使用 max-width 和自动边距值
- en: Figure 4.26 shows that our layout starts to degrade as the window gets extremely
    wide. The wider the window, the worse the problem gets. More and more users have
    extra-wide screens, so we need to consider what would happen if they have the
    window maximized, taking up the entire screen. To handle this use case, we’ll
    use the same trick that we used for the loader in chapter 2\. We’ll set a maximum
    width for our layout and then set its left and right margins to `auto`, which
    will center the container horizontally when the window is larger than our maximum
    width.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26显示，当窗口变得极其宽时，我们的布局开始退化。窗口越宽，问题越严重。越来越多的用户拥有超宽屏幕，因此我们需要考虑如果他们最大化窗口，占据整个屏幕会发生什么。为了处理这种情况，我们将使用与第2章中使用的加载器相同的技巧。我们将为我们的布局设置一个最大宽度，然后将其左右边距设置为`auto`，这样当窗口宽度大于我们的最大宽度时，容器将在水平方向上居中。
- en: For our page, our container is the body, so we’ll give our `body` a `max-width`
    of `1200px` and set our left and right margins to `auto`. We also need to move
    the `background-color` from being set on the `body` to being set on the `html`
    element rule; otherwise, when our screen is wider than 1,200 pixels, we’ll end
    up with a white band to the left and right sides of our page.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的页面，我们的容器是`body`，因此我们将给我们的`body`一个`max-width`为`1200px`，并将左右边距设置为`auto`。我们还需要将`background-color`从在`body`上设置移动到在`html`元素规则上设置；否则，当我们的屏幕宽度超过1,200像素时，我们会在页面的左右两侧出现白色带状区域。
- en: These changes won’t go inside the media query. We’ll edit the styles we set
    on the `body` at the beginning of this chapter and add an `html` rule to set the
    background color. The following listing shows our changes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改不会进入媒体查询内部。我们将编辑本章开头设置的`body`样式，并添加一个`html`规则来设置背景颜色。以下列表显示了我们的更改。
- en: Listing 4.15 Changes to the `body` and `html` elements
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15 `body`和`html`元素的更改
- en: '[PRE14]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Moves the background color from the body rule to the html rule
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将背景颜色从body规则移动到html规则
- en: ② Sets the maximum width our page can become
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ② 设置页面可以成为的最大宽度
- en: ③ Centers the page
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使页面居中
- en: With these final changes, we have a page that works for both mobile and desktop
    users. Figure 4.27 shows our finished layout.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些最终更改，我们有一个适用于移动和桌面用户的页面。图4.27显示了我们的最终布局。
- en: '![](../Images/04-27.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04-27.png)'
- en: Figure 4.27 Finished layout
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27 完成布局
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A theme is the general look and feel that we maintain throughout an application.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题是在整个应用程序中保持的一般外观和感觉。
- en: We may need to import our fonts, as few fonts are universally available. Because
    no officially defined list of web-safe fonts exists, we should always use a keyword
    fallback.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能需要导入我们的字体，因为很少的字体是普遍可用的。由于没有官方定义的Web安全字体列表，我们应该始终使用关键字回退。
- en: Creating a visual hierarchy will help our users orient themselves to the page
    and identify important information.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建视觉层次结构将帮助我们的用户在页面上定位自己并识别重要信息。
- en: We can control which symbols the browser uses when it’s instructed to display
    quotation marks.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以控制浏览器在指令显示引号时使用的符号。
- en: We can customize the way our lists display their bullets by using the `counter-style`
    at-rule.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用`counter-style` at规则来自定义列表显示其项目符号的方式。
- en: Filters allow us to alter the appearance of an image.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器允许我们改变图像的外观。
- en: We can create multicolumn layouts by using the CSS Multi-column Layout Module.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用CSS多列布局模块来创建多列布局。
- en: We can make content span all the columns when creating multicolumn layouts.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建多列布局时，我们可以使内容跨越所有列。
- en: We can make the browser use hyphens to break words at the end of lines.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使浏览器在行尾使用连字符来断开单词。
- en: Floating allows us to wrap text around an element.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮动允许我们围绕元素包裹文本。
