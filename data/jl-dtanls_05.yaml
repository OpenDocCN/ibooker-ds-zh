- en: 4 Working with collections in Julia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 在 Julia 中处理集合
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working with arrays
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组一起工作
- en: Using dictionaries to handle key-value mappings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典来处理键值映射
- en: 'Handling immutable collection types: tuples and named tuples'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不可变集合类型：元组和命名元组
- en: In chapters 2 and 3, you learned basic elements of the Julia language. We have
    mostly used scalar types (like numbers) in all the examples. However, in data
    science, you will typically work with data *collections*, groupings of a variable
    number of data items. One collection type already introduced in chapter 2 is a
    vector.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章和第 3 章中，你学习了 Julia 语言的基本元素。我们一直在所有示例中主要使用标量类型（如数字）。然而，在数据科学中，你通常会处理数据
    *集合*，即一组变量数量的数据项。在第 2 章中已经介绍的一种集合类型是向量。
- en: 'In this chapter, you will learn how to use several fundamental collections
    that are most used in practical scenarios: arrays, dictionaries, tuples, and named
    tuples.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用在实际情况中最常用的几个基本集合：数组、字典、元组和命名元组。
- en: 4.1 Working with arrays
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 与数组一起工作
- en: 'In this section, you will learn the basics of working with arrays in Julia:
    their creation, indexing into arrays, and the most common operations you can expect
    to perform with them. Arrays are commonly used collections in data science. Most
    machine learning algorithms expect data stored in arrays as their inputs. In Julia
    (as opposed to, for example, Python), arrays are part of the language specification,
    so they are equipped with a convenient syntax. Working with them requires learning
    only one set of rules, and they are fast.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习在 Julia 中处理数组的基础知识：它们的创建、对数组的索引以及你可以期望对这些数组执行的最常见操作。数组是数据科学中常用的集合。大多数机器学习算法都期望以数组形式存储数据作为它们的输入。在
    Julia（与例如 Python 相比），数组是语言规范的一部分，因此它们配备了方便的语法。与它们一起工作只需要学习一套规则，而且它们运行速度快。
- en: 'To learn how to work with arrays in Julia, we will analyze Anscombe’s quartet
    data ([http://mng.bz/69ZZ](http://mng.bz/69ZZ)). As you will learn in this section,
    it consists of four data sets that have identical simple descriptive statistics
    but very different distributions. Each of the four data sets consists of 11 observations
    and has two variables: one feature denoted as x and one target denoted as y. Table
    4.1 shows the data.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何在 Julia 中处理数组，我们将分析安斯康姆四重奏数据（[http://mng.bz/69ZZ](http://mng.bz/69ZZ)）。正如你将在本节中学到的，它由四个数据集组成，这些数据集具有相同的基本描述性统计，但分布却非常不同。每个数据集包含
    11 个观测值，有两个变量：一个表示为 x 的特征和一个表示为 y 的目标。表 4.1 显示了数据。
- en: Table 4.1 Anscombe’s quartet data
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 安斯康姆四重奏数据
- en: '| Data set 1 | Data set 2 | Data set 3 | Data set 4 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 数据集 1 | 数据集 2 | 数据集 3 | 数据集 4 |'
- en: '| x | y | x | y | x | y | x | y |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| x | y | x | y | x | y | x | y |'
- en: '| 10.0 | 8.04 | 10.0 | 9.14 | 10.0 | 7.46 | 8.0 | 6.58 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 10.0 | 8.04 | 10.0 | 9.14 | 10.0 | 7.46 | 8.0 | 6.58 |'
- en: '| 8.0 | 6.95 | 8.0 | 8.14 | 8.0 | 6.77 | 8.0 | 5.76 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 8.0 | 6.95 | 8.0 | 8.14 | 8.0 | 6.77 | 8.0 | 5.76 |'
- en: '| 13.0 | 7.58 | 13.0 | 8.74 | 13.0 | 12.74 | 8.0 | 7.71 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 13.0 | 7.58 | 13.0 | 8.74 | 13.0 | 12.74 | 8.0 | 7.71 |'
- en: '| 9.0 | 8.81 | 9.0 | 8.77 | 9.0 | 7.11 | 8.0 | 8.84 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 9.0 | 8.81 | 9.0 | 8.77 | 9.0 | 7.11 | 8.0 | 8.84 |'
- en: '| 11.0 | 8.33 | 11.0 | 9.26 | 11.0 | 7.81 | 8.0 | 8.47 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 11.0 | 8.33 | 11.0 | 9.26 | 11.0 | 7.81 | 8.0 | 8.47 |'
- en: '| 14.0 | 9.96 | 14.0 | 8.10 | 14.0 | 8.84 | 8.0 | 7.04 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 14.0 | 9.96 | 14.0 | 8.10 | 14.0 | 8.84 | 8.0 | 7.04 |'
- en: '| 6.0 | 7.24 | 6.0 | 6.13 | 6.0 | 6.08 | 8.0 | 5.25 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 6.0 | 7.24 | 6.0 | 6.13 | 6.0 | 6.08 | 8.0 | 5.25 |'
- en: '| 4.0 | 4.26 | 4.0 | 3.10 | 4.0 | 5.39 | 19.0 | 12.50 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 4.0 | 4.26 | 4.0 | 3.10 | 4.0 | 5.39 | 19.0 | 12.50 |'
- en: '| 12.0 | 10.84 | 12.0 | 9.13 | 12.0 | 8.15 | 8.0 | 5.56 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 12.0 | 10.84 | 12.0 | 9.13 | 12.0 | 8.15 | 8.0 | 5.56 |'
- en: '| 7.0 | 4.82 | 7.0 | 7.26 | 7.0 | 6.42 | 8.0 | 7.91 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 7.0 | 4.82 | 7.0 | 7.26 | 7.0 | 6.42 | 8.0 | 7.91 |'
- en: '| 5.0 | 5.68 | 5.0 | 4.74 | 5.0 | 5.73 | 8.0 | 6.89 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 5.0 | 5.68 | 5.0 | 4.74 | 5.0 | 5.73 | 8.0 | 6.89 |'
- en: 'Our goal is to perform the following operations on each of these data sets:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是对这些数据集执行以下操作：
- en: Calculate the mean and standard deviation of x and y variables
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算变量 x 和 y 的平均值和标准差
- en: Calculate Pearson’s correlation coefficient of x and y variables
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算变量 x 和 y 的皮尔逊相关系数
- en: Fit a linear regression explaining y by x and compute its coefficient of determination
    R²
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 x 解释 y 并计算其确定系数 R²
- en: Investigate the data visually by using plots
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用图表来直观地调查数据
- en: Terminology used in the book for tabular data
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 书中用于表格数据的术语
- en: When describing tabular data in this book, I use the following terminology.
    Rows of data are called observations, and columns are called variables.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中描述表格数据时，我使用了以下术语。数据行被称为观测值，列被称为变量。
- en: In the context of a predictive model, a variable that is explained by the model
    is called a *target* (other names that are alternatively used are output or dependent
    variable). The variables used to make a prediction are called features (other
    names include input or independent variable).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在预测模型的上下文中，由模型解释的变量被称为*目标*（其他交替使用的名称包括输出或因变量）。用于进行预测的变量被称为特征（其他名称包括输入或自变量）。
- en: The same terminology is used in the MLJ.jl ecosystem ([https://github.com/alan-turing-institute/MLJ.jl](https://github.com/alan-turing-institute/MLJ.jl)),
    which is a popular toolbox for machine learning in Julia.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在MLJ.jl生态系统（[https://github.com/alan-turing-institute/MLJ.jl](https://github.com/alan-turing-institute/MLJ.jl)）中使用了相同的术语，这是一个在Julia中用于机器学习的流行工具箱。
- en: 4.1.1 Getting the data into a matrix
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 将数据放入矩阵中
- en: We want to analyze data stored in table 4.1\. The table has eight columns and
    11 rows. Each column represents one variable. Note that columns 1, 3, 5, and 7
    (odd columns) are the x feature variables in data sets 1, 2, 3, and 4, respectively.
    Likewise, columns 2, 4, 6, and 8 (even columns) are the y target variables in
    the respective data sets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要分析存储在表4.1中的数据。该表有八个列和11行。每一列代表一个变量。请注意，列1、3、5和7（奇数列）分别是数据集1、2、3和4中的x特征变量。同样，列2、4、6和8（偶数列）是相应数据集中的y目标变量。
- en: Creating a matrix
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建矩阵
- en: Before analyzing the data, we need to store it in the computer’s memory. Since
    the data is of a homogeneous type (these are all numbers), it is natural to use
    a matrix as a container. In this section, you will see how to create this matrix
    and check its basic properties.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析数据之前，我们需要将其存储在计算机的内存中。由于数据是同质的类型（这些都是数字），使用矩阵作为容器是自然的。在本节中，你将看到如何创建这个矩阵并检查其基本属性。
- en: We start with creating a variable bound to a matrix storing our data, as shown
    in the following listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建一个变量并将其绑定到存储我们数据的矩阵开始，如下所示。
- en: Listing 4.1 Defining a matrix storing Anscombe’s quartet data
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 定义存储Anscombe的四重奏数据的矩阵
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The aq variable is a Matrix holding Float64 values. Note that in Julia, it is
    easy to create a matrix storing predefined data. You just need to write each row
    of data as a single line of the input, using whitespace as a separator of columns,
    and wrap everything in square brackets. If you would like to learn about additional
    options for constructing arrays, consult the “Array Literals” section of the Julia
    Manual ([http://mng.bz/M0vo](http://mng.bz/M0vo)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: aq变量是一个包含Float64值的Matrix。请注意，在Julia中，创建存储预定义数据的矩阵很容易。你只需将数据的一行作为输入的单行写入，使用空白作为列的分隔符，并用方括号将一切括起来。如果你想要了解构建数组的其他选项，请参阅Julia手册中的“数组字面量”部分（[http://mng.bz/M0vo](http://mng.bz/M0vo)）。
- en: 'In the head of the output of our operation in listing 4.1, we can see that
    the matrix has 11 rows and eight columns. We can check this by using the size
    function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.1中我们操作输出的头部，我们可以看到矩阵有11行和8列。我们可以通过使用size函数来检查这一点：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The size function can take either one argument, in which case it returns a tuple
    of dimensions, or two arguments, where the second argument is the dimension that
    we want to investigate (where 1 stands for rows and 2 stands for columns).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: size函数可以接受一个参数，在这种情况下，它返回一个维度的元组，或者接受两个参数，其中第二个参数是我们想要调查的维度（其中1代表行，2代表列）。
- en: Working with tuples
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与元组一起工作
- en: Before moving forward, let’s briefly discuss what a *tuple* is. You can think
    of it as a vector but with a fixed length and immutable. It is created using parentheses,
    while vectors are created with square brackets. You can get elements of the tuple,
    as with vectors, but you cannot set them, unlike with vectors, because tuples
    are immutable; see figure 4.1\. Tuples in Julia are similar to tuples in Python,
    and their type is Tuple.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，让我们简要讨论一下什么是*tuple*。你可以把它想象成一个向量，但长度固定且不可变。它是使用括号创建的，而向量是使用方括号创建的。你可以像向量一样获取元组的元素，但与向量不同，你不能设置它们，因为元组是不可变的；参见图4.1。Julia中的元组与Python中的元组类似，它们的类型是Tuple。
- en: '![CH04_F01_Kaminski2](../Images/CH04_F01_Kaminski2.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F01_Kaminski2](../Images/CH04_F01_Kaminski2.png)'
- en: Figure 4.1 A comparison of a vector and a tuple. You can get elements of vectors
    and tuples, but Julia allows setting elements of only a vector.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 向量和元组的比较。你可以获取向量和元组的元素，但Julia只允许设置向量的元素。
- en: 'The results of the operations shown in figure 4.1, executed in the Julia REPL,
    are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1中所示操作的执行结果，在Julia REPL中如下所示：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, note that both vectors and tuples use *1-based indexing*. This
    means, as discussed in chapter 2, that the first element of a vector and a tuple
    has an index of 1\. The same convention is used in R, Fortran, and MATLAB. This
    is especially important to remember if you work a lot with Python, Java, or C++,
    since these programming languages use 0-based indexing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，请注意，向量和元组都使用 *基于 1 的索引*。这意味着，正如在第 2 章中讨论的，向量和元组的第一个元素的索引为 1。在 R、Fortran
    和 MATLAB 中也使用相同的约定。如果你大量使用 Python、Java 或 C++，这一点尤其重要，因为这些编程语言使用基于 0 的索引。
- en: Tuples vs. vectors
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 元组与向量的比较
- en: You might ask what the benefit is of using tuples instead of vectors. The considerations
    are as follows.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问使用元组而不是向量的好处是什么。考虑如下。
- en: Tuples are immutable, so if in your code you want to ensure that the user will
    not be able to change them, they are safer to use.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是不可变的，因此如果你想在代码中确保用户无法更改它们，使用它们会更安全。
- en: Since tuples are immutable, they are faster, as the compiler does not have to
    use dynamic memory allocation to work with them (in type-stable code) and is able
    to know the types of variables stored in them even if they are heterogeneous (refer
    to the Julia Manual, [http://mng.bz/epPP](http://mng.bz/epPP), for a list of tips
    ensuring the performance of Julia code).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组是不可变的，因此它们更快，因为编译器不需要使用动态内存分配来处理它们（在类型稳定的代码中），并且能够知道存储在其中的变量的类型，即使它们是异构的（有关确保
    Julia 代码性能的提示列表，请参阅 Julia 手册，[http://mng.bz/epPP](http://mng.bz/epPP)）。
- en: As a downside, I do not recommend creating tuples that store a large number
    of elements (they are best suited to holding small collections). Large tuples
    may lead to significant compilation time of your programs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为缺点，我不建议创建存储大量元素的元组（它们最适合存储小集合）。大元组可能会导致你的程序编译时间显著增加。
- en: Representation of vectors in Julia
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中向量的表示
- en: In this section, we are discussing a basic kind of a vector used in Julia that
    has the Vector type. In general, Julia supports other vector types, and you will
    learn about several in the following chapters. In particular, it is useful to
    know that, unlike the Vector type, some vector types are not mutable or do not
    use 1-based indexing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论的是 Julia 中使用的一种基本向量类型，它具有 Vector 类型。一般来说，Julia 支持其他向量类型，你将在接下来的章节中了解到其中的一些。特别是，了解以下内容是有用的：与
    Vector 类型不同，某些向量类型是不可变的或不需要基于 1 的索引。
- en: For more technically oriented readers, let me mention that in Julia, tuples
    are allocated on the stack, and standard arrays are heap allocated. If you do
    not know these memory allocation models, see [http://mng.bz/o5a2](http://mng.bz/o5a2).
    For working efficiently with Julia, you do not need to know the details of how
    memory management is handled. It’s enough to understand that heap allocation is
    slower than stack allocation. Additionally, heap allocation requires an additional
    process called *garbage collection* (*GC*) to be run. GC is responsible for releasing
    the memory that has been heap allocated and is not referenced anymore.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更技术性的读者，让我提一下，在 Julia 中，元组是在栈上分配的，而标准数组是在堆上分配的。如果你不知道这些内存分配模型，请参阅 [http://mng.bz/o5a2](http://mng.bz/o5a2)。为了有效地使用
    Julia，你不需要知道内存管理是如何处理的细节。只需了解堆分配比栈分配慢即可。此外，堆分配需要运行一个称为 *垃圾回收* (*GC*) 的额外过程。GC
    负责释放不再被引用的堆分配内存。
- en: Figure 4.2 shows a benchmark for creating a tuple versus a vector. You can see
    in the Memory estimate section (marked with a rectangle) that creating a vector
    requires one memory allocation, while creating a tuple does not lead to any allocations.
    Therefore, in the GC section (marked with a rounded rectangle), you can see that
    when benchmarking the creation of a tuple, GC is never triggered, while when benchmarking
    a vector, GC is occasionally run.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 展示了创建元组与向量的基准测试。你可以在内存估计部分（用矩形标记）看到，创建向量需要一次内存分配，而创建元组不会导致任何分配。因此，在 GC
    部分（用圆角矩形标记），你可以看到，在基准测试元组创建时，GC 从未触发，而在基准测试向量时，GC 有时会运行。
- en: '![CH04_F02_Kaminski2](../Images/CH04_F02_Kaminski2.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F02_Kaminski2](../Images/CH04_F02_Kaminski2.png)'
- en: Figure 4.2 A benchmark comparing the creation time of a tuple and a vector.
    Creating tuples is faster and does not lead to memory allocation on the heap.
    Run using BenchmarkTools before executing the computations presented in this figure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 比较元组与向量创建时间的基准测试。创建元组更快，并且不会导致堆内存分配。在执行此图所示的计算之前，请使用 BenchmarkTools 运行。
- en: 'To wrap up the comparison of vectors and tuples, let’s discuss their construction
    when you pass data of mixed types. When you construct a vector using square brackets,
    Julia will try to promote all passed elements to a common type, while constructing
    a tuple does not result in such a conversion. Here is an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结向量和元组的比较，让我们讨论当传递混合类型的数据时它们的构造。当你使用方括号构造一个向量时，Julia会尝试将所有传递的元素提升到公共类型，而构造元组不会导致这种转换。以下是一个例子：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the code, when constructing a vector, we pass 1 (an integer) and 2.0 (a floating-point
    value). In the produced vector, the integer 1 is converted to floating-point 1.0.
    When constructing a tuple, the passed values are stored in it without any conversion.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，当构造向量时，我们传递1（一个整数）和2.0（一个浮点值）。在产生的向量中，整数1被转换为浮点数1.0。当构造元组时，传递的值被存储在其中而不进行任何转换。
- en: 4.1.2 Computing basic statistics of the data stored in a matrix
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 计算矩阵中存储的数据的基本统计量
- en: 'Now we are ready to compute means and standard deviations of variables stored
    in the aq matrix. For this, we will use the mean and std functions defined in
    the Statistics module:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好计算存储在aq矩阵中的变量的均值和标准差。为此，我们将使用Statistics模块中定义的mean和std函数：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aq matrix defined in listing 4.1, the columns 1, 3, 5, and 7 store the
    x feature. In the presented summaries, both for the mean and std functions, the
    values in positions 1, 3, 5, and 7 are equal. This means that the x feature in
    all these cases has the same mean and standard deviation. We have the same situation
    for columns 2, 4, 6, and 8 that store the y target variables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4.1列出的aq矩阵中，第1、3、5和7列存储x特征。在所提供的摘要中，无论是均值函数还是标准差函数，位置1、3、5和7的值都是相等的。这意味着在这些所有情况下，x特征具有相同的均值和标准差。对于存储y目标变量的第2、4、6和8列，也存在相同的情况。
- en: Note that we have used the dims keyword argument to signal the dimension along
    which we want to compute the statistics. Here it is dims=1, as we have observations
    stored in rows, so we want to compute the statistics over the first dimension
    of the aq matrix. In other words, we compute the statistics columnwise of the
    aq matrix because the variables we want to analyze are stored as its columns.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了dims关键字参数来指示我们想要计算统计量的维度。这里dims=1，因为我们有按行存储的观测值，所以我们想要在aq矩阵的第一维上计算统计量。换句话说，我们按列计算aq矩阵的统计量，因为我们想要分析的数据存储为其列。
- en: 'Let’s discuss two alternative ways to compute the required statistics. Here
    is the first one:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论两种计算所需统计量的替代方法。这是第一种方法：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s dissect this example. The eachcol(aq) call returns a collection iterating
    columns of our matrix (for reference, eachrow(aq) would iterate its rows). Next,
    we apply the map function (discussed in chapter 2), which applies the appropriate
    function (mean and std, respectively) to each of the columns. As a reminder from
    chapter 2, note that we could have used the do-end notation with the map function
    like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个例子。eachcol(aq)调用返回一个迭代矩阵列的集合（作为参考，eachrow(aq)将迭代其行）。接下来，我们应用map函数（在第2章中讨论过），它将适当的函数（均值和标准差，分别）应用于每一列。作为第2章的提醒，请注意，我们可以像这样使用do-end符号与map函数：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, in this case, this would be more verbose than just passing the mean
    function as a first positional argument to map.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，这会比将mean函数作为map的第一个位置参数传递更冗长。
- en: 'Instead of using the map function, we could have used a comprehension to create
    a vector by iterating columns of the aq matrix:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用map函数，我们可以使用理解来通过迭代aq矩阵的列创建一个向量：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the comprehension uses the for keyword argument, after which
    we specify which variable (col, in this case) should store values produced by
    an iterator (eachcol(aq), in this case). Then, before the for keyword, we write
    the expression that should be evaluated, which can depend on the col variable.
    As a result, we get an array collecting the produced results. Figure 4.3 compares
    the syntax when using the map function and the comprehension.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，理解使用了for关键字参数，之后我们指定哪个变量（在这种情况下为col）应存储由迭代器产生的值（在这种情况下为eachcol(aq)）。然后在for关键字之前，我们写出应该评估的表达式，它可以依赖于col变量。结果，我们得到一个收集产生的结果的数组。图4.3比较了使用map函数和理解时的语法。
- en: '![CH04_F03_Kaminski2](../Images/CH04_F03_Kaminski2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F03_Kaminski2](../Images/CH04_F03_Kaminski2.png)'
- en: Figure 4.3 Syntax used when working with the map function and the comprehension.
    When using a comprehension, you explicitly give a name to the variable that is
    used to store the values you iterate (col in our case).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 使用 map 函数和列表推导式时的语法。当使用列表推导式时，您明确地为用于存储迭代值的变量命名（在我们的例子中是 col）。
- en: 'In most scenarios, the choice between using a comprehension and using the map
    function follows programmer’s convenience and code readability (in particular,
    you can expect similar performance). Their differences are most visible if you
    want to operate on several collections at the same time. Refer to the Julia Manual
    at [http://mng.bz/aPZo](http://mng.bz/aPZo) and [http://mng.bz/gR1x](http://mng.bz/gR1x)
    for examples. Another difference is that comprehensions always produce arrays,
    while the map function can produce values of a different type. Here is an example
    of taking the absolute value of several numbers stored in a tuple. A comprehension
    produces a vector, while map returns a tuple:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用列表推导式和使用 map 函数之间的选择取决于程序员的便利性和代码可读性（特别是，您可以期望相似的性能）。它们的区别在您想要同时操作几个集合时最为明显。请参阅
    Julia 手册 [http://mng.bz/aPZo](http://mng.bz/aPZo) 和 [http://mng.bz/gR1x](http://mng.bz/gR1x)
    以获取示例。另一个区别是，列表推导式始终产生数组，而 map 函数可以产生不同类型的值。以下是一个示例，展示如何取存储在元组中的几个数字的绝对值。列表推导式产生一个向量，而
    map 返回一个元组：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 4.1.3 Indexing into arrays
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 数组索引
- en: Often you want to select part of a matrix to be able to work with it later.
    This is easily done using indexing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您想选择矩阵的一部分以便以后使用它。这可以通过索引轻松完成。
- en: 'We illustrate indexing by presenting yet another way to specify the computation
    of column statistics in our aq matrix:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过展示另一种指定计算 aq 矩阵中列统计的方法来说明索引：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This time, we are using indexing in the aq matrix. The axes function is similar
    to the size function discussed previously. The difference is that instead of returning
    the length of the given dimension, it produces a valid range of indices in a given
    dimension. In this example, it is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在 aq 矩阵中使用索引。axes 函数与之前讨论的 size 函数类似。区别在于它不是返回给定维度的长度，而是在给定维度中产生一个有效的索引范围。在这个例子中，如下所示：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the indices start from 1 and span through 8. I have included
    the documentation of the OneTo object that is returned so that you know exactly
    what it represents. In practice, you will not need to construct it yourself, but
    occasionally you might encounter it produced by standard Julia functions, so it’s
    worthwhile to be aware of what it does.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，索引从 1 开始，跨越到 8。我包括了返回的 OneTo 对象的文档，以便您确切了解它代表什么。在实践中，您不需要自己构建它，但偶尔您可能会遇到由标准
    Julia 函数产生的它，因此了解它的作用是有价值的。
- en: Why is OneTo prefixed with Base?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 OneTo 以 Base 开头？
- en: 'We can see that Julia prints the information about the OneTo type by prefixing
    it with Base—for example, Base.OneTo(8). This output gives us two pieces of information:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Julia 通过在前面加上 Base 来打印 OneTo 类型的信息——例如，Base.OneTo(8)。这个输出给我们提供了两条信息：
- en: The OneTo type is defined in the Base module (the default module that is always
    loaded when you start Julia).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OneTo 类型定义在 Base 模块中（这是启动 Julia 时始终加载的默认模块）。
- en: This type is not exported to the Main module. Therefore, you can access it only
    by prefixing its name with the name of the module that defines it.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此类型未导出到 Main 模块。因此，您只能通过在其名称前加上定义它的模块名称来访问它。
- en: Section 3.3 explains the Base and Main modules and how name exporting works.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3.3 节解释了 Base 和 Main 模块以及名称导出是如何工作的。
- en: In our comprehension, since we now iterate indices of the second dimension of
    our matrix, we need to extract its single column. This is done using the aq[:,
    j] expression. The colon (:) means that we pick all rows of the j-th column of
    aq.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的理解中，因为我们现在正在迭代矩阵的第二维索引，我们需要提取它的单个列。这是通过使用 aq[:, j] 表达式完成的。冒号 (:) 表示我们选择
    aq 的第 j 列的所有行。
- en: 'Matrix indexing: practical guidance'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵索引：实用指南
- en: If you use matrices, use two indices (for rows and for columns) to access its
    elements, just as in the preceding example. Similarly, when indexing vectors,
    use a single index. In general, Julia allows for other indexing styles, which
    come in handy when writing advanced generic code, but I recommend you stick to
    the basic rule of *as many indices as dimensions of an array*, as this will make
    your code readable and easier to debug.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用矩阵，使用两个索引（行和列）来访问其元素，就像前面的例子一样。同样，当索引向量时，使用单个索引。一般来说，Julia允许其他索引风格，这在编写高级泛型代码时很有用，但我建议你坚持“数组维度与索引数量一样多”的基本规则，这样会使你的代码更易于阅读和调试。
- en: 'A final note related to the aq[:, j] expression is that it makes a copy of
    the j-th column of our matrix. Sometimes, for performance reasons, you might prefer
    not to copy data, but use a view into the aq matrix instead. This can be done
    using the view function or the @view macro as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于aq[:, j]表达式的最后一点是，它会复制我们矩阵的第j列。有时，出于性能考虑，你可能更愿意不复制数据，而是使用aq矩阵的视图。这可以通过使用视图函数或@view宏来实现，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first example, when calculating the mean, we use the view function. In
    this case, we pass the indices as consecutive arguments to it. When using the
    @view macro, we can use the standard indexing syntax. I have shown this approach
    when calculating the standard deviation. Apart from syntax differences, writing
    view(aq, :, j) and @view aq[:, j] are equivalent.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，当计算平均值时，我们使用视图函数。在这种情况下，我们将索引作为连续的参数传递给它。当使用@view宏时，我们可以使用标准的索引语法。我在计算标准差时展示了这种方法。除了语法差异之外，编写view(aq,
    :, j)和@view aq[:, j]是等效的。
- en: What is a view?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是视图？
- en: In Julia, if you have an array and create its view, no data from the parent
    array is copied. Instead, a lightweight object is created that lazily references
    the parent array. Therefore, the parent and its view share the same memory to
    store data. If you modify data stored in a view, this change is also visible in
    the parent.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，如果你有一个数组并创建其视图，则不会从父数组复制任何数据。相反，创建了一个轻量级对象，它延迟引用父数组。因此，父数组和它的视图共享相同的内存来存储数据。如果你修改视图中的数据，这种更改也会在父数组中可见。
- en: In the context of the @view macro, let me remind you of one important aspect
    of the way macros work in Julia (we discussed this in chapter 3). If you invoke
    a macro without parentheses, it eagerly considers all that follows as an expression;
    as much code as possible is taken to be an expression.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在@view宏的上下文中，让我提醒你一下Julia中宏工作方式的一个重要方面（我们在第3章讨论过）。如果你不带括号调用宏，它会急切地考虑所有跟随的内容作为一个表达式；尽可能多的代码被视为一个表达式。
- en: 'Here is an example where that leads to a problem. Assume you want to create
    a tuple consisting of two views of a vector, and try the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，说明这会导致问题。假设你想要创建一个包含向量两个视图的元组，并尝试以下代码：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What is the reason for the error? The problem is that the x[1:2], @view[3:4]
    part of the code is a single expression passed to the first @view call. To solve
    this problem, you need to use the second style of macro invocation that uses parentheses
    (just as when you call functions):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的原因是什么？问题是代码中的x[1:2], @view[3:4]部分是一个单独的表达式，传递给了第一个@view调用。为了解决这个问题，你需要使用第二种宏调用风格，它使用括号（就像调用函数一样）：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 4.1.4 Performance considerations of copying vs. making a view
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 复制与创建视图的性能考虑
- en: You might ask how much making a copy affects the performance of operations.
    This section presents how to compare the performance of copying to that of making
    a view. To do this, we will need a data set much bigger than our aq matrix, as
    it is too small for a practically relevant benchmark.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问复制对操作性能的影响有多大。本节将介绍如何比较复制和创建视图的性能。为此，我们需要一个比aq矩阵大得多的数据集，因为对于实际相关的基准测试来说，它太小了。
- en: 'Here’s an example benchmark on a matrix of 10,000,000 rows and 10 columns:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在1000万行和10列的矩阵上的基准测试示例：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Recall from chapter 3 that we write $x in the code to get a proper benchmark
    result because x is a global variable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 回想第3章，我们用$x在代码中写出来以获得适当的基准结果，因为x是一个全局变量。
- en: We first create a large matrix filled with 1s, using the ones function. As you
    can see from the benchmarks, using the views uses up much less memory and is faster.
    In the benchmark, we additionally include the mean(x, dims=1) call that also produces
    the expected result. This function is built into standard Julia distribution and
    tuned for performance. The benchmark shows that our code is roughly as efficient.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用ones函数创建一个填充1的大矩阵。从基准测试中可以看出，使用视图（views）使用更少的内存并且更快。在基准测试中，我们还包括了mean(x,
    dims=1)的调用，它也会产生预期的结果。这个函数是标准Julia分布的一部分，并且针对性能进行了优化。基准测试显示我们的代码大致上效率相当。
- en: 4.1.5 Calculating correlations between variables
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 计算变量之间的相关性
- en: Let’s apply what you’ve learned to calculate correlations between the studied
    variables, as this is also a statistic that we want to compute. The difference
    from our examples of calculating the mean and the standard deviation is that when
    computing correlation, we need to pass two columns to a function simultaneously.
    In this section, you will learn how to do that.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将你所学到的知识应用到计算研究变量之间的相关性上，因为这同样是我们想要计算的统计量。与计算均值和标准差的不同之处在于，在计算相关性时，我们需要同时将两个列传递给一个函数。在本节中，你将学习如何做到这一点。
- en: 'We want to calculate the correlation of columns 1 and 2, 3 and 4, 5 and 6,
    and 7 and 8\. Here is a simple approach using the cor function from the Statistics
    module:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要计算第1列和第2列、第3列和第4列、第5列和第6列、以及第7列和第8列之间的相关性。这里是一个使用Statistics模块中的cor函数的简单方法：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This time, the cor function is passed two vectors (related to the x and y variables,
    respectively). As you can see, the correlations are similar. Let me comment on
    the 1:2:7 expression. You’ve already learned about ranges of the form start:stop
    that span all values starting from start and finishing at stop, inclusive, with
    step equal to 1. The style start:step:stop is a generalization of this syntax,
    allowing you to specify the step of the range via the parameter step; see figure
    4.4.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，cor函数传递了两个向量（分别与x和y变量相关）。正如你所见，相关性相似。让我来解释一下1:2:7的表达式。你已经学习了关于start:stop形式的范围，它从start开始，到stop结束，包含start和stop，步长为1。start:step:stop这种风格是这种语法的推广，允许你通过参数step指定范围的步长；参见图4.4。
- en: '![CH04_F04_Kaminski2](../Images/CH04_F04_Kaminski2.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F04_Kaminski2](../Images/CH04_F04_Kaminski2.png)'
- en: 'Figure 4.4 Interpretation of range syntax with a custom step size. In this
    example, step has the value 2, so we are iterating odd numbers: 1, 3, 5, 7.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 解释具有自定义步长的范围语法。在这个例子中，步长值为2，所以我们正在迭代奇数：1, 3, 5, 7。
- en: 'Let’s check that the step parameter works as I explained by using the collect
    function that you learned about in chapter 3:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用你在第3章中学到的collect函数来检查step参数是否按我解释的那样工作：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the [cor(aq[:, i], aq[:, i+1]) for i in 1:2:7] expression, I have used copying
    operations on purpose. I encourage you to rewrite this code by using views as
    an exercise.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[cor(aq[:, i], aq[:, i+1]) for i in 1:2:7]表达式中，我故意使用了复制操作。我鼓励你通过使用视图作为练习来重写这段代码。
- en: Exercise 4.1 Rewrite the expression [cor(aq[:, i], aq[:, i+1]) for i in 1:2:7]
    by using views (either the view function or the @view macro). Compare the performance
    of both approaches by using the @benchmark macro from the BenchmarkTools.jl package.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.1 使用视图（无论是view函数还是@view宏）重写[cor(aq[:, i], aq[:, i+1]) for i in 1:2:7]表达式。通过使用BenchmarkTools.jl包中的@benchmark宏来比较两种方法的性能。
- en: 4.1.6 Fitting a linear regression
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.6 拟合线性回归
- en: We can now turn to fitting a linear regression by using ordinary least squares
    (OLS). Later you will learn a more general and convenient API for estimating parameters
    of such models using the GLM.jl package, but for now, we restrict ourselves to
    a basic approach to learn how to work with matrices in Julia. The linear regression
    that we want to fit has the form *y = a + b * x + error*, where *a* and *b* are
    unknown coefficients that must be estimated. We will choose them so that the sum
    of squares of *error* terms across all observations is minimized.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以转向使用普通最小二乘法（OLS）来拟合线性回归。稍后你将学习使用GLM.jl包估计此类模型参数的更通用和方便的API，但到目前为止，我们只限于基本方法来学习如何在Julia中处理矩阵。我们想要拟合的线性回归形式为*y
    = a + b * x + error*，其中*a*和*b*是必须估计的未知系数。我们将选择它们，使得所有观测值中误差项的平方和最小化。
- en: 'As you might know from an introductory statistics course, to estimate the parameters
    of the linear regression, we need a vector y holding the target variable and a
    matrix of model features. It is crucially important that, since we want to learn
    two parameters, a and b, we have two features in our model. The feature related
    to the a parameter is called a *constant term* and must be represented as a column
    consisting only of 1s. The second feature should be our *x* variable. Let’s build
    the target vector y and the feature matrix X from our aq data set by extracting
    the first set of *x* and *y* variables at indices 1 and 2:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如同你可能从入门统计学课程中学到的，为了估计线性回归的参数，我们需要一个包含目标变量的向量y和一个模型特征矩阵。至关重要的是，因为我们想要学习两个参数a和b，所以我们的模型中有两个特征。与a参数相关的特征被称为*常数项*，必须表示为一个只包含1的列。第二个特征应该是我们的*x*变量。让我们从我们的aq数据集中提取第一组*x*和*y*变量（索引1和2）来构建目标向量y和特征矩阵X：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ We use 11 because we know our data has 11 observations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们使用11是因为我们知道我们的数据有11个观测值。
- en: What might surprise you is the [ones(11) aq[:, 1]] syntax. However, you’ve already
    learned all the building blocks we use here. The ones function generates a vector
    of eleven 1s. Then we use the method of constructing matrices in which you merge
    columns by separating them with a whitespace and wrapping them in square brackets.
    This is the same approach we used at the beginning of this section. The only difference
    is that now we are horizontally concatenating whole vectors, not just single cells
    of a matrix.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让你惊讶的是[ones(11) aq[:, 1]]语法。然而，你已经学习了我们在这里使用的一切构建块。ones函数生成一个包含11个1的向量。然后我们使用构造矩阵的方法，通过在列之间用空格分隔并将它们括在方括号中来合并列。这是我们在这个部分开始时使用的方法。唯一的区别是现在我们是在水平连接整个向量，而不是矩阵的单个单元格。
- en: This operation works as expected, because in Julia vectors are always considered
    to be columnar. When you write [1, 2, 3], which is a literal defining a vector,
    with a syntax that is visually horizontal (to save vertical space in your code),
    the produced object is a columnar vector. This is highlighted by the fact that
    Julia prints the vectors vertically in the REPL, as opposed to R, which prints
    them horizontally.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作按预期工作，因为在Julia中向量总是被视为列向量。当你用[1, 2, 3]这样的字面量定义一个向量，使用视觉上水平的语法（为了在代码中节省垂直空间），产生的对象是一个列向量。这一点通过Julia在REPL中垂直打印向量的事实得到了强调，而R则是水平打印。
- en: 'We are ready to estimate the parameters of our model. You can use the backslash
    (\) operator:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备估计我们模型的参数。你可以使用反斜杠（\）操作符：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, the constant term is approximately estimated to be 3.0, and the
    coefficient with the *x* variable to be 0.5.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，常数项被近似估计为3.0，与*x*变量的系数为0.5。
- en: The \ operator
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠操作符
- en: The result of the A \ B operation, when A is a matrix, depends on its shape.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当A是矩阵时，A \ B操作的结果取决于其形状。
- en: If A is square, the result X is such that A * X = B.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果A是方阵，结果X满足A * X = B。
- en: If A is not square, the result X is a minimizer of the expression norm(A * X
    - B), where norm is a function computing the Euclidean norm; it is defined in
    the LinearAlgebra module.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果A不是方阵，结果X是表达式norm(A * X - B)的最小化器，其中norm是一个计算欧几里得范数的函数；它在LinearAlgebra模块中定义。
- en: In the context of linear regression, when A is a feature matrix and B is a target
    variable vector, then A \ B produces the least squares estimate or regression
    parameters.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性回归的背景下，当A是特征矩阵而B是目标变量向量时，A \ B会产生最小二乘估计或回归参数。
- en: 'We are now ready to estimate all four models:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备估计所有四个模型：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, all models are almost identical. Notice that this time, we have created
    a vector that contains vectors. In Julia, arrays can store objects of any type,
    which includes other arrays (typically called *nested arrays*). If you expect
    to work a lot with these data structures, you might consider learning the features
    provided by the ArraysOfArrays.jl package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有模型几乎都是相同的。注意这次，我们创建了一个包含向量的向量。在Julia中，数组可以存储任何类型的对象，包括其他数组（通常称为*嵌套数组*）。如果你预计会大量使用这些数据结构，你可能会考虑学习ArraysOfArrays.jl包提供的功能。
- en: Precision of floating-point calculations
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数计算的精度
- en: Floating-point operations are done with finite precision. One consequence is
    that running the same Julia code on different hardware or using different implementations
    of libraries performing linear algebra operations might produce a slightly different
    result. (Julia allows switching linear algebra libraries; see [https://github.com/JuliaLinearAlgebra/MKL.jl](https://github.com/JuliaLinearAlgebra/MKL.jl).)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点运算使用有限精度进行。一个后果是，在不同的硬件上运行相同的Julia代码或使用执行线性代数运算的不同库的实现可能会产生略微不同的结果。（Julia允许切换线性代数库；见[https://github.com/JuliaLinearAlgebra/MKL.jl](https://github.com/JuliaLinearAlgebra/MKL.jl)。）
- en: You might see this effect when working with examples in this book. For example,
    the X \ y expression we used in this section can produce an output different from
    what I showed previously. The differences could be seen in the least significant
    digits of the output.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在本书的示例中看到这种效果。例如，我们在这个部分使用的X \ y表达式可能会产生与我之前展示不同的输出。差异可能出现在输出的最低有效位。
- en: 'We are now ready to compute the R² coefficient of determination:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以计算确定系数R²：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'First, we define the R² function that takes the x feature and y target. Remember
    that if you do not remember how to type 2, you can easily get help by pressing
    ? and pasting 2:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个R²函数，它接受x特征和y目标。记住，如果你不记得如何输入2，你可以通过按?并粘贴2来轻松获取帮助：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the R² function, we first reproduce the steps to estimate the model parameters
    we just discussed. Then we make a prediction by using this model with the X *
    model expression. Here we take advantage of the fact that the multiplication operator
    in Julia performs matrix multiplication out of the box. Next, we store the prediction
    errors in the error variable. The coefficient of determination is defined as 1
    minus the ratio of the sum of squared errors of the model and the sum of deviations
    of the target variable from its mean. We compute these quantities in the last
    part of our function. In the body of the R² function, we use the mean function,
    which requires that you first load the Statistics module to ensure that the computations
    are executed without error.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在R²函数中，我们首先重现了我们刚才讨论的模型参数估计步骤。然后，我们使用X * 模型表达式来预测，利用了Julia中的乘法运算符默认执行矩阵乘法的事实。接下来，我们将预测误差存储在error变量中。确定系数定义为1减去模型平方误差之和与目标变量与其均值偏差之和的比。我们在函数的最后部分计算这些量。在R²函数的主体中，我们使用了mean函数，这要求你首先加载Statistics模块以确保计算无错误执行。
- en: As you can see, applying the R² function to our data produces almost the same
    result for all four data sets. This is the last analysis we wanted to perform.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，将R²函数应用于我们的数据几乎为所有四个数据集产生了相同的结果。这是我们想要进行的最后分析。
- en: 4.1.7 Plotting the Anscombe’s quartet data
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.7 绘制Anscombe的四重奏数据
- en: 'Now you are ready to learn why the Anscombe’s quartet data is so famous. Let’s
    plot the data to discover that the distribution of all four data sets is radically
    different. We will use the Plots.jl package to do the plotting. First, we plot
    the first data set on a scatterplot to warm up:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好学习为什么Anscombe的四重奏数据如此著名了。让我们绘制数据以发现所有四个数据集的分布都截然不同。我们将使用Plots.jl包来进行绘图。首先，我们在散点图上绘制第一个数据集以热身：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Figure 4.5 presents the output you should see.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5展示了你应该看到的输出。
- en: '![CH04_F05_Kaminski2](../Images/CH04_F05_Kaminski2.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F05_Kaminski2](../Images/CH04_F05_Kaminski2.png)'
- en: Figure 4.5 The plot of the first data set from Anscombe’s quartet. The points
    are scattered but seem to roughly follow a linear trend.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 Anscombe的四重奏的第一个数据集的图表。点分布散乱，但似乎大致遵循线性趋势。
- en: If you run the example code, you will see that the time to produce the plot
    for the first time is noticeable. As explained in section 1.4, this is expected,
    as Julia needs to compile the function we call. Fortunately, this is a one-time
    cost, and consecutive plots are produced quickly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行示例代码，你会看到第一次生成图表的时间是明显的。正如1.4节中解释的那样，这是预期的，因为Julia需要编译我们调用的函数。幸运的是，这是一个一次性成本，连续生成的图表会很快。
- en: 'Now let’s visualize the four plots. With Plots.jl, this is quite easy. You
    just need to wrap four scatter calls with a plot function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们可视化四个图表。使用Plots.jl，这相当简单。你只需要用plot函数包裹四个scatter调用：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This produces the plot shown in figure 4.6\. As you can see, the four data sets
    look completely different.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成图4.6中所示的图表。正如你所见，四个数据集看起来完全不同。
- en: '![CH04_F06_Kaminski2](../Images/CH04_F06_Kaminski2.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F06_Kaminski2](../Images/CH04_F06_Kaminski2.png)'
- en: Figure 4.6 The plot of the four data sets from Anscombe's quartet. Although,
    as we have checked, all four data sets have identical basic summary statistics,
    the relationships between the x and y variables are completely different in each
    of them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 Anscombe四重奏中的四个数据集的图表。尽管，正如我们所检查的，所有四个数据集都具有相同的基本统计摘要，但x和y变量之间的关系在每个数据集中都是完全不同的。
- en: 'Before we finish this section, let me show you another way to make the last
    plot. You might have thought that there was a lot of unnecessary typing. Indeed,
    there was. Here is the code that uses a comprehension to achieve the same result:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本节之前，让我向大家展示另一种制作最后图表的方法。你可能认为有很多不必要的输入。确实如此。以下是使用列表推导式达到相同结果的代码：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Observe, however, that we had to add one small detail. Since the plot function
    accepts subplots as its consecutive positional arguments, we cannot just pass
    a vector produced by our comprehension to it, as that would produce an error.
    We need to expand the vector into multiple positional arguments in the function
    call. This operation, called *splatting*, is performed using the triple dots (...).
    In our code, they directly follow the comprehension expression inside the function
    call.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们必须添加一个小的细节。由于绘图函数接受子图作为其连续的位置参数，我们不能直接将我们的列表推导式产生的向量传递给它，因为这会产生错误。我们需要在函数调用中将向量展开为多个位置参数。这种操作称为*展开*，它使用三个点(...)执行。在我们的代码中，它们直接位于函数调用中的列表推导式之后。
- en: If you are interested in more details about working with arrays, check out the
    Julia Manual section on multidimensional arrays ([https://docs.julialang.org/en/v1/manual/arrays/](https://docs.julialang.org/en/v1/manual/arrays/)).
    You also can check [http://mng.bz/neYe](http://mng.bz/neYe) to find out how the
    problem we have described can be solved using DataFrames.jl (we will work with
    this package in part 2).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对手数组操作的更多细节感兴趣，请查看Julia手册中关于多维数组的部分（[https://docs.julialang.org/en/v1/manual/arrays/](https://docs.julialang.org/en/v1/manual/arrays/)）。你还可以查看[http://mng.bz/neYe](http://mng.bz/neYe)以了解我们描述的问题如何使用DataFrames.jl（我们将在第二部分中使用此包）来解决。
- en: At this point, you should have a working knowledge of how to create vectors
    and arrays, manipulate them, and pass them to statistical and plotting functions.
    Arrays are a special type of collection in which every dimension can be indexed
    into with a continuous range of integers. However, sometimes you need a data structure
    that allows you to use any values for indexing. This is possible with dictionaries,
    which we discuss next.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经掌握了如何创建向量数组和数组，如何操作它们，以及如何将它们传递给统计和绘图函数。数组是一种特殊类型的集合，其中每个维度都可以用连续的整数范围进行索引。然而，有时你需要一种允许你使用任何值进行索引的数据结构。这是可能的，使用字典，我们将在下一节中讨论。
- en: 4.2 Mapping key-value pairs with dictionaries
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 使用字典映射键值对
- en: Another type of standard collection often used when doing data science is the
    dictionary. We will introduce dictionaries by solving the famous Sicherman dice
    puzzle. In this section, you will learn how to create a dictionary, add keys to
    a dictionary, retrieve values from it, and compare dictionaries.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据科学时，经常使用的一种标准集合类型是字典。我们将通过解决著名的Sicherman骰子谜题来介绍字典。在本节中，你将学习如何创建字典，向字典中添加键，从中检索值，以及比较字典。
- en: The Sicherman puzzle
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Sicherman谜题
- en: A standard die has six sides, with faces numbered from 1 to 6\. In many games,
    players roll two standard dice and sum the obtained results. In the Sicherman
    puzzle, we are asked to check if it is possible to number the faces of a pair
    of cubes in a way completely different from that of standard dice so that the
    cubes can be used in any dice game and all the odds will be the same as they are
    when standard dice are used. More formally, we want to check if there exist other
    pairs of two six-sided dice, not necessarily identical, with faces numbered with
    positive integers that have the same probability distribution for the sum of rolled
    values as standard dice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标准的骰子有六个面，面上的数字从1到6。在许多游戏中，玩家掷两个标准的骰子，并将得到的结果相加。在Sicherman谜题中，我们被要求检查是否有可能以与标准骰子完全不同的方式给一对立方体的面编号，以便这些立方体可以用于任何骰子游戏，并且所有概率都将与使用标准骰子时相同。更正式地说，我们想要检查是否存在其他成对的两个六面骰子，这些骰子的面用正整数编号，并且它们掷出的值的总和的概率分布与标准骰子相同。
- en: To solve this puzzle, we will use dictionaries. A *dictionary* is a mapping
    of keys to values. In our example, since we consider two six-sided dice, we can
    have 36 distinct toss results (we have six sides of each die, and 6 × 6 = 36 possible
    combinations of outcomes). Therefore, our mapping will tell us, for every value
    of the sum of rolled values, how many times (out of the total 36) it occurs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个谜题，我们将使用字典。*字典*是键到值的映射。在我们的例子中，由于我们考虑两个六面的骰子，我们可以有36种不同的投掷结果（每个骰子有六个面，6
    × 6 = 36种可能的结果组合）。因此，我们的映射将告诉我们，对于投掷值的总和的每个值，它在总共36次中出现了多少次。
- en: Creating a dictionary
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个字典
- en: 'Let’s first create a dictionary of this distribution for a pair of standard
    dice:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先为标准骰子的一个对创建这个分布的字典：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our code, we first create an empty two_standard dictionary. Note that by
    writing Dict{Int, Int}, we specify two parameters for our type. The first parameter
    is the type of allowed keys, and the second is the type of allowed values.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们首先创建一个空的two_standard字典。请注意，通过写入Dict{Int, Int}，我们为我们的类型指定了两个参数。第一个参数是允许的键的类型，第二个参数是允许的值的类型。
- en: Next, using a double-nested loop, we traverse 36 combinations of possible outcomes
    of tosses and sum them, storing the sum in the s variable. Inside the loop, using
    the haskey function, we check whether the dictionary already contains a mapping
    for the s key. If it does, we increase the count for the entry of the dictionary
    by one. Otherwise, this is the first time we encounter the given key, and we assign
    it the count equal to 1. Note that indexing into a dictionary uses square brackets,
    just like indexing into arrays or tuples.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用双层循环，我们遍历投掷的可能结果的36种组合，并将它们相加，将总和存储在s变量中。在循环内部，使用haskey函数，我们检查字典是否已经包含s键的映射。如果包含，我们增加字典条目的计数。否则，这是我们第一次遇到给定的键，我们将其赋值为1。请注意，字典的索引使用方括号，就像数组或元组的索引一样。
- en: 'We can easily extract a list of the keys and values of the dictionary:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地提取字典的键和值的列表：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can see that the types of both values do not seem to be vectors. They are
    both just views of the dictionary contents. Therefore, if we wanted to plot the
    distribution of the sum of rolls, we would need to collect them, which materializes
    the views as vectors. Here’s how this should be done:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这两个值的类型看起来都不像是向量。它们只是字典内容的视图。因此，如果我们想绘制投掷总和的分布图，我们需要收集它们，这样就会将视图转换为向量。以下是应该这样做的方法：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that by using the xaxis keyword argument, we explicitly set the x-axis
    label in the plot. Figure 4.7 shows the plot you should obtain.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过使用xaxis关键字参数，我们明确设置了图中的x轴标签。图4.7显示了你应该获得的图表。
- en: '![CH04_F07_Kaminski2](../Images/CH04_F07_Kaminski2.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F07_Kaminski2](../Images/CH04_F07_Kaminski2.png)'
- en: Figure 4.7 Distribution of the sum of rolling two standard dice. The possible
    outcomes range from 2 to 12\. The distribution is symmetric.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 投掷两个标准骰子的总和分布。可能的结果范围从2到12。分布是对称的。
- en: In the preceding example, I wanted to show you the use of the keys and values
    functions. However, Plots.jl allows you to visualize the contents of the dictionaries
    more easily. You could write scatter(two_standard; legend=false, xaxis=2:12) to
    get the same plot.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我想向你展示keys和values函数的使用。然而，Plots.jl允许你更轻松地可视化字典的内容。你可以写scatter(two_standard;
    legend=false, xaxis=2:12)来获得相同的图表。
- en: Solving the Sicherman puzzle
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 解决Sicherman谜题
- en: 'Now we are ready to start solving the puzzle. To reduce the search space, note
    that since the minimal sum equaling 2 occurs only once, we must have exactly one
    1 on both dice. Similarly, note that the largest sum equals 12, so the maximum
    number on any die is 11\. We thus concentrate on five sides of a die (one and
    only one side must contain 1, as discussed) with values ranging from 2 to 11\.
    Let’s generate a vector of all such dice. Notice that we can concentrate only
    on nondecreasing sequences of numbers posted on dice:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始解决这个谜题了。为了减少搜索空间，请注意，由于等于2的最小总和只出现一次，两个骰子上必须恰好有一个1。同样，请注意，最大的总和等于12，所以任何骰子上的最大数字是11。因此，我们专注于骰子的五个面（正如讨论的那样，只有一个面必须包含1）的值，范围从2到11。让我们生成一个包含所有这些骰子的向量。请注意，我们只能关注骰子上非递减的数字序列：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that in this code, we have used a nice feature of comprehension syntax
    in Julia that we have not discussed yet. The for loops can be nested, and the
    loops that follow previous loops can use the variables defined in outer loops.
    Such a nested comprehension works as if we have written multiple for loops, one
    inside the other.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段代码中，我们使用了Julia中尚未讨论的语法的一个很好的特性。for循环可以嵌套，并且跟随前一个循环的循环可以使用外部循环中定义的变量。这样的嵌套理解就像我们编写了多个for循环，一个嵌套在另一个内部。
- en: 'We now see that we have 2,002 such dice. We are ready to test all pairs of
    dice to check which have the same distribution as our two_standard distribution.
    Here is how to do this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到我们有2,002个这样的骰子。我们准备测试所有骰子对，以检查哪些具有与我们的两个_标准分布相同的分布。以下是操作方法：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code, we create the test dictionary in the same way as we created the
    two_ standard dictionary earlier. The only difference is that we use a different,
    shorter style of writing the for loop. For instance, in for i in d1, j in d2,
    we immediately create a nested loop iterating over a Cartesian product of d1 and
    d2 values.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们以与之前创建两个_标准字典相同的方式创建测试字典。唯一的区别是我们使用了一种不同的、更简洁的for循环写法。例如，在for i in
    d1, j in d2中，我们立即创建一个嵌套循环，遍历d1和d2值的笛卡尔积。
- en: Also notice that we can use the == comparison to check whether two dictionaries
    have identical mappings of keys to values.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们可以使用==比较来检查两个字典是否具有相同的键到值的映射。
- en: Our code outputs three pairs of dice. One is a pair of standard dice, as expected.
    The other two pairs are the same, just in reverse order. Thus, we have learned
    that there is a unique solution to the Sicherman dice puzzle. Somewhat surprisingly,
    we now know that if we take one die with numbers 1, 2, 2, 3, 3, 4 and the other
    with numbers 1, 3, 4, 5, 6, 8, then the distribution of the sum of their tossed
    values is indistinguishable from the distribution for the two standard dice.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码输出了三对骰子。一对是标准的骰子，正如预期的那样。另外两对相同，只是顺序相反。因此，我们已经了解到Sicherman骰子谜题有一个独特的解决方案。有些令人惊讶的是，我们现在知道，如果我们拿一个有数字1、2、2、3、3、4的骰子和另一个有数字1、3、4、5、6、8的骰子，那么它们投掷值的总和的分布与两个标准骰子的分布是无法区分的。
- en: 'The example code has one shortcoming. It violates the *don''t repeat yourself*
    (*DRY*) principle. We have repeated the same code for filling the Dict{Int, Int}
    dictionary twice: the first time it was used to fill the two_standard dictionary,
    and the next time it was used to repeatedly fill the test dictionary. In such
    situations, I usually wrap the repeated code in a function. This operation is
    a task left for you as an exercise to reinforce your learning of function definition
    syntax in Julia.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码有一个缺点。它违反了“不要重复自己”（DRY）原则。我们两次重复了相同的代码来填充Dict{Int, Int}字典：第一次用于填充two_standard字典，第二次用于反复填充测试字典。在这种情况下，我通常将重复的代码封装在函数中。这项操作是作为练习留给你的，以加强你在Julia中学习函数定义语法的知识。
- en: Exercise 4.2 Rewrite the code solving the Sicherman puzzle, wrapping the logic
    of the processing in functions. Create one function, dice_ distribution, that
    produces a dictionary with a distribution of the sum of possible combinations
    of values on two dice passed as its arguments. Next, write another function, test_dice,
    in which you create the all_dice variable, then the two_standard variable, and
    finally run the main loop comparing the distribution of all dice from the all_dice
    vector against the two_ standard distribution.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.2：重写解决Sicherman谜题的代码，将处理逻辑封装在函数中。创建一个名为dice_distribution的函数，该函数接受两个骰子的值作为参数，并生成一个包含这些值可能组合的总和分布的字典。接下来，编写另一个名为test_dice的函数，在该函数中创建all_dice变量，然后创建two_standard变量，并最终运行主循环，比较all_dice向量中所有骰子的分布与two_standard分布。
- en: Standard data collections in Julia
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的标准数据集合
- en: In this section, we have given one short example of using dictionaries. If you
    would like to learn more about other collection types that are supported by Base
    Julia, refer to the Julia Manual ([https://docs.julialang.org/en/v1/base/collections/](https://docs.julialang.org/en/v1/base/collections/)).
    Additionally, the DataStructures.jl package provides even more collection types
    that you might need in your code. Following are several collection types that
    are most needed in practice.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提供了一个使用字典的简短示例。如果你想了解更多关于 Base Julia 支持的其他集合类型，请参阅 Julia 手册（[https://docs.julialang.org/en/v1/base/collections/](https://docs.julialang.org/en/v1/base/collections/)）。此外，DataStructures.jl
    包提供了更多你可能需要的集合类型。以下是在实践中最需要的几个集合类型。
- en: A data structure related to dictionaries, and sometimes used in data science
    workflows, is the *set*. The Set type is available in Base Julia. Instead of keeping
    key-value pairs, as dictionaries do, sets just keep a set of unique values. The
    basic operations that sets allow you to do are adding values, removing values,
    and quickly checking if a certain value is present in a set.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典相关的一种数据结构，有时在数据科学工作流程中使用，是 *集合*。Set 类型在 Base Julia 中可用。与字典不同，集合只保留一组唯一的值。集合允许你执行的基本操作包括添加值、移除值和快速检查某个值是否存在于集合中。
- en: Both the Dict and Set types in Base Julia store their elements in an undefined
    order. The types that preserve insertion order are provided in the DataStructures.jl
    package and are, respectively, OrderedDict dictionary and OrderedSet set.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Base Julia 中，Dict 和 Set 类型存储它们的元素顺序未定义。在 DataStructures.jl 包中提供的保留插入顺序的类型分别是
    OrderedDict 字典和 OrderedSet 集合。
- en: If you are interested in an alternative solution to the Sicherman dice puzzle
    using DataFrames.jl, check out my blog post “Solving Sicherman Dice Puzzle Using
    DataFrames.jl” ([http://mng.bz/p692](http://mng.bz/p692)).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于使用 DataFrames.jl 解决 Sicherman 掷骰子谜题的替代方案感兴趣，请查看我的博客文章“使用 DataFrames.jl
    解决 Sicherman 掷骰子谜题”([http://mng.bz/p692](http://mng.bz/p692))。
- en: You now know how to work with dictionaries, which, unlike arrays, allow you
    to use any values for indexing. A natural question is whether we can have a data
    structure that would allow both integer indexing and selection of values by their
    name. Indeed, Julia provides such a collection. It is called NamedTuple, and we
    will discuss it next.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道了如何使用字典，与数组不同，字典允许你使用任何值作为索引。一个自然的问题是我们是否可以有一个数据结构，它既能支持整数索引，又能通过名称选择值。确实，Julia
    提供了这样的集合。它被称为 NamedTuple，我们将在下一节讨论它。
- en: 4.3 Structuring your data by using named tuples
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 通过使用命名元组来结构化你的数据
- en: When we were analyzing the Anscombe’s quartet data in section 4.1, you might
    have had the feeling that we were missing some structure in our data. The NamedTuple
    type is a basic method to add structure to your code. You can think of a NamedTuple
    as a way to add names to the consecutive elements of a tuple.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 4.1 节分析 Anscombe 的四重奏数据时，你可能会有一种感觉，那就是我们在数据中缺少一些结构。NamedTuple 类型是向你的代码添加结构的基本方法。你可以把
    NamedTuple 视为给元组的连续元素添加名称的方式。
- en: In this section, you will learn how to create a NamedTuple and access its elements.
    You will also see how to fit linear models using the GLM.jl package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何创建 NamedTuple 并访问其元素。你还将看到如何使用 GLM.jl 包拟合线性模型。
- en: 'We will rewrite the Anscombe’s quartet data example using the NamedTuple type.
    Start with the aq matrix we already defined in listing 4.1 (repeated here for
    your convenience):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 NamedTuple 类型重写 Anscombe 的四重奏数据示例。从我们已经在列表 4.1 中定义的 aq 矩阵开始（这里重复列出以方便你使用）：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 4.3.1 Defining named tuples and accessing their contents
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 定义命名元组和访问其内容
- en: 'First, create a named tuple for the first data set as an exercise:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，作为一个练习，为第一个数据集创建一个命名元组：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, creating a NamedTuple is easy. It is similar to a Tuple, except
    we are giving names to the elements. NamedTuple, just like a Tuple, is immutable.
    You can index into it by using a number, but you can also access its fields by
    using a dot (.) and field name:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建一个 NamedTuple 很简单。它与 Tuple 类似，只是我们给元素命名了。NamedTuple，就像 Tuple 一样，是不可变的。你可以通过数字索引它，但也可以通过点（.）和字段名来访问其字段：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let’s now create a nested named tuple holding our four data sets in the next
    listing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在下一个列表中创建一个嵌套的命名元组，包含我们的四个数据集。
- en: Listing 4.2 Defining a named tuple storing Anscombe’s quartet data
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 定义一个存储 Anscombe 的四重奏数据的命名元组
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now you can fetch a single data set from our collection like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像这样从我们的集合中获取单个数据集：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 4.3.2 Analyzing Anscombe’s quartet data stored in a named tuple
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 分析存储在命名元组中的 Anscombe 四重奏数据
- en: 'We are now ready to reproduce selected steps of the analysis we did in section
    4.1 by using the data variable. First, calculate the means of x variables in each
    set:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用数据变量重制第 4.1 节中分析的选定步骤。首先，计算每个集合中 x 变量的平均值：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the code, we create an anonymous function s -> mean(s.x) that extracts the
    x field from a passed NamedTuple and computes its mean. An interesting feature
    to note is that the map function is smart enough to return a NamedTuple that keeps
    the names of processed fields from the source NamedTuple. Calculation of Pearson’s
    correlation works similarly:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们创建了一个匿名函数 s -> mean(s.x)，它从传递的 NamedTuple 中提取 x 字段并计算其平均值。值得注意的是，map
    函数足够智能，可以返回一个 NamedTuple，它保留了源 NamedTuple 中处理过的字段的名称。计算皮尔逊相关系数的工作方式类似：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, let’s fit a linear model for the first data set by using the GLM.jl
    package. In the model, the target variable is y, and we have one feature x:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用 GLM.jl 包为第一个数据集拟合一个线性模型。在模型中，目标变量是 y，我们有一个特征 x：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ This part of the output indicates the type of the model variable. You can
    safely ignore it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 输出的一部分表示模型变量的类型。您可以安全地忽略它。
- en: ❷ This indicates the formula used to fit the model.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这表示拟合模型所使用的公式。
- en: 'Observe several features in this code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下代码中的几个特点：
- en: We use the @formula(y ~ x) syntax to say that the x field of our NamedTuple
    is a feature and y is a target variable. Inside the @formula macro, we are passing
    the target variable name, followed by a tilde (~) and the feature variable name.
    In part 2, we will discuss how such formulas are constructed in more detail. If
    you would like to learn all the details of the @formula domain-specific language,
    you can find them in the StatsModels.jl package documentation ([http://mng.bz/O6Qo](http://mng.bz/O6Qo)).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 @formula(y ~ x) 语法来说明我们的 NamedTuple 中的 x 字段是一个特征，而 y 是目标变量。在 @formula 宏内部，我们传递目标变量名称，然后是波浪号
    (~) 和特征变量名称。在第 2 部分，我们将更详细地讨论此类公式的构建方式。如果您想了解 @formula 领域特定语言的全部细节，可以在 StatsModels.jl
    包的文档中找到它们（[http://mng.bz/O6Qo](http://mng.bz/O6Qo)）。
- en: The first positional argument to the lm function is the model formula, and the
    second positional argument is a table represented by our data.set1 named tuple.
    The lm function takes the data from the passed table and fits the linear regression
    model specified by the passed formula. The object returned by the lm function
    stores information about the estimated parameters of our model. When this object
    is printed in the REPL, it gives us a table with summary statistics of the model,
    in which the x variable and the intercept in our model automatically get proper
    names.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lm 函数的第一个位置参数是模型公式，第二个位置参数是由我们的 data.set1 命名元组表示的表。lm 函数从传递的表中获取数据，并拟合由传递的公式指定的线性回归模型。lm
    函数返回的对象存储了我们模型估计参数的信息。当在 REPL 中打印此对象时，它给我们一个包含模型总结统计信息的表，其中我们的模型中的 x 变量和截距自动获得适当的名称。
- en: As you can see, the obtained estimates of our linear model are the same as obtained
    in section 4.1.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们线性模型得到的估计值与第 4.1 节中得到的结果相同。
- en: 'As the last example, let’s use the r2 function from GLM.jl to calculate the
    coefficient of determination of our model:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个例子，让我们使用 GLM.jl 中的 r2 函数计算我们模型的确定系数：
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Again, the results are in line with what we had earlier. Building models using
    the GLM.jl package is much more powerful than doing it manually, as we did in
    section 4.1\. Now you are ready to reproduce figure 4.6 (showing scatterplots
    of all four data sets in one plot) using data stored in NamedTuple.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，结果与之前的一致。使用 GLM.jl 包构建模型比我们在第 4.1 节中手动构建模型要强大得多。现在您可以使用存储在 NamedTuple 中的数据重制图
    4.6（在一个图中显示所有四个数据集的散点图）。
- en: Exercise 4.3 Reproduce figure 4.6 using the data named tuple defined in listing
    4.2.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.3 使用 4.2 列表中定义的命名元组数据重制图 4.6。
- en: 4.3.3 Understanding composite types and mutability of values in Julia
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 理解 Julia 中的复合类型和值的可变性
- en: 'Before we wrap up this section, it is worth discussing two important concepts
    in more depth: *composite structures* and *mutability* of values. I discuss these
    topics here to help you better understand the differences between arrays, dictionaries,
    named tuples, and other types discussed in this chapter.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，深入讨论两个重要概念是值得的：*复合结构*和值的*可变性*。我在这里讨论这些主题是为了帮助您更好地理解数组、字典、命名元组以及本章讨论的其他类型之间的差异。
- en: Composite types
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型
- en: The model variable that we worked with in section 4.3.2 has a TableRegressionModel
    type that is a composite type—namely, a struct. When doing basic operations, you
    will most likely not need to create them on your own, but you will often encounter
    them returned by functions from packages.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.3.2节中我们使用的模型变量是一个`TableRegressionModel`类型的复合类型——即一个结构体。在进行基本操作时，你很可能不需要自己创建它们，但你经常会遇到它们作为函数从包中返回的结果。
- en: 'The TableRegressionModel type is defined in the StatsModels.jl package as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableRegressionModel`类型在`StatsModels.jl`包中定义如下：'
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At a basic level, you do not need to understand all the details of this definition.
    What is important for us now is that the struct defines three fields: model, mf,
    and mm. When you get a value having such a type, you can easily access its fields
    by using a dot (.), just as for a NamedTuple (in part 2, you will learn that the
    way the dot operator works is a bit more complex, but by default it behaves in
    the way I describe here):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，你不需要理解这个定义的所有细节。对我们来说现在重要的是，这个结构体定义了三个字段：model、mf和mm。当你得到具有这种类型的值时，你可以通过使用点（.）轻松访问其字段，就像在命名元组（在第二部分，你将了解到点操作符的工作方式要复杂一些，但默认情况下它以我描述的方式行为）中一样：
- en: '[PRE40]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Therefore, you can think of these objects as being similar to NamedTuple, with
    the difference being that their type has a specific name (TableRegressionModel,
    in our case), and it cannot be indexed with numbers like a NamedTuple. You can
    learn more about defining composite types in the Julia Manual ([http://mng.bz/YKwK](http://mng.bz/YKwK)).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以将这些对象视为与命名元组类似，区别在于它们的类型有一个特定的名称（在我们的例子中是`TableRegressionModel`），并且不能像命名元组那样用数字索引。你可以在Julia手册中了解更多关于定义复合类型的信息（[http://mng.bz/YKwK](http://mng.bz/YKwK)）。
- en: Mutability of values
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 值的可变性
- en: 'Julia distinguishes between mutable and immutable types. Here is a classification
    of selected types encountered so far in this book:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Julia区分可变和不可变类型。以下是本书中遇到的一些类型分类：
- en: '*Immutable*—Int, Float64, String, Tuple, NamedTuple, struct'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可变*——Int、Float64、String、Tuple、NamedTuple、结构体'
- en: '*Mutable*—Array (so also Vector and Matrix), Dict, and struct created with
    mutable keyword added'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可变*——数组（因此也包括向量和矩阵）、字典以及使用`mutable`关键字创建的结构体'
- en: You might ask how immutable and mutable types differ. The point is that mutable
    values can be changed. This might sound obvious, but the crucial thing is that
    they can also be changed by functions to which they are passed. Such side effects
    can be quite surprising. Therefore, as discussed in chapter 2, it is crucially
    important to annotate the functions that mutate their arguments with the exclamation
    point suffix (!). Also, as discussed in chapter 2, remember that adding ! at the
    end of a function is only a convention (functions whose names end with ! get no
    special treatment by the Julia compiler; the convention is only meant to make
    it visually explicit for the user that the function might mutate its arguments).
    Here are two examples of data mutation at work.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问不可变和可变类型有什么区别。关键是可变值可以被改变。这听起来可能很显然，但关键的是它们也可以被传递给它们的函数所改变。这样的副作用可能会相当令人惊讶。因此，正如第2章所讨论的，对那些会改变其参数的函数使用感叹号后缀（!）进行注释至关重要。同样，正如第2章所讨论的，记住在函数末尾添加!只是一种约定（以!结尾的函数不会得到Julia编译器的特殊处理；这种约定只是为了让用户更直观地看到函数可能会改变其参数）。以下是两个数据突变的工作示例。
- en: 'In the first example, we see the difference between calling the unique and
    unique! functions on a vector. They both remove duplicates from a collection.
    The difference between them is that unique returns a new vector, while unique!
    works in place:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们看到在向量上调用`unique`和`unique!`函数之间的区别。它们都从集合中移除重复项。它们之间的区别在于`unique`返回一个新的向量，而`unique!`则就地工作：
- en: '[PRE41]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ The unique function returns a new vector. It does not mutate the passed vector.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `unique`函数返回一个新的向量。它不会改变传入的向量。
- en: ❷ The x vector is unchanged.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ x向量未改变。
- en: ❸ The unique! function changes the x vector in place.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 独特的`unique`函数会就地改变x向量。
- en: ❹ The x vector is changed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ x向量被改变。
- en: The unique function does not change the passed argument, but instead allocates
    a new vector and de-duplicates it. On the other hand, the unique! function updates
    the passed vector in place.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique`函数不会改变传入的参数，而是分配一个新的向量并去重。另一方面，`unique!`函数会就地更新传入的向量。'
- en: 'The second example is meant to show you that even if your data structure is
    immutable, it might contain mutable elements that can be changed by a function.
    In this example, we use the empty! function that takes a mutable collection as
    its argument and removes all elements stored in it in place:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例旨在向您展示，即使您的数据结构是不可变的，它也可能包含可变元素，这些元素可以被函数修改。在这个例子中，我们使用 empty! 函数，它接受一个可变集合作为参数，并就地移除存储在其内的所有元素：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ The empty_field! function calls the empty! function on the i-th element of
    the nt object.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ empty_field! 函数在 nt 对象的第 i 个元素上调用 empty! 函数。
- en: ❷ The nt named tuple has a dictionary as its first element; dictionaries are
    mutable.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ nt 命名元组的第一个元素是一个字典；字典是可变的。
- en: ❸ After executing the empty_field! function, the dictionary stored in the nt
    named tuple is empty.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行 empty_field! 函数后，存储在 nt 命名元组中的字典为空。
- en: 'In this example, we create the empty_field! function that takes an object and
    tries to index into it in position i and empty the stored value in place by using
    the empty! function. Next, we create a NamedTuple that has two fields: a dictionary
    and an integer. The Dict("a" => 1, "b" => 2) syntax is a convenient approach to
    initially populating a dictionary, where each element "a" => 1 is a Pair object
    mapping a single key to a single value.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了 empty_field! 函数，它接受一个对象并尝试在位置 i 上对其进行索引，然后使用 empty! 函数就地清空存储的值。接下来，我们创建一个具有两个字段的命名元组：一个字典和一个整数。Dict("a"
    => 1, "b" => 2) 语法是一种方便的方法来初始化字典，其中每个元素 "a" => 1 是一个 Pair 对象，将单个键映射到单个值。
- en: The crucial thing to observe is that when we call empty_field!(nt, 1), the dictionary
    stored in the nt variable gets emptied, although nt is a NamedTuple that is immutable.
    However, it contains a mutable object as its field.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 需要观察的关键点是，当我们调用 empty_field!(nt, 1) 时，存储在 nt 变量中的字典被清空，尽管 nt 是一个不可变的命名元组。然而，它包含一个可变对象作为其字段。
- en: In summary, stressing what we have already discussed, Julia does not copy data
    when passing arguments to a function. If an object is passed to a function and
    contains a structure (even a nested one) that is mutable, that object can potentially
    be mutated by the function. If you want to create a fully independent object when
    passing a value to a function, to be sure that the original value is guaranteed
    not to be mutated, use the deepcopy function to create it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，强调我们已经讨论过的内容，Julia 在向函数传递参数时不会复制数据。如果一个对象被传递给函数，并且它包含一个结构（即使是嵌套的）是可变的，那么该对象可能被函数修改。如果你想创建一个在传递给函数时完全独立的对象，以确保原始值不会被修改，请使用
    deepcopy 函数来创建它。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Arrays are the most common containers in Julia, as most machine learning algorithms
    take arrays as their input. In Julia, arrays are part of the core of the language,
    so they are efficient and easy to use.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是 Julia 中最常见的容器，因为大多数机器学习算法都使用数组作为输入。在 Julia 中，数组是语言的核心部分，因此它们既高效又易于使用。
- en: You can use the Statistics module and the GLM.jl package to easily perform analysis
    of your data, including determining the mean, standard deviation, correlation,
    and estimation of linear models. All functions providing these functionalities
    accept arrays as their input.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Statistics 模块和 GLM.jl 包轻松地对您的数据进行分析，包括确定均值、标准差、相关性和线性模型的估计。所有提供这些功能的函数都接受数组作为输入。
- en: Julia, like R, Fortran, and MATLAB, by default uses 1-based indexing for arrays.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 R、Fortran 和 MATLAB 一样，Julia 默认使用基于 1 的索引数组。
- en: In Julia, vectors are always considered to be columnar.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中，向量始终被认为是列向量。
- en: You can use dictionaries in Julia to store key-value mappings. It is important
    to remember that in Julia, keys in a dictionary can be values of any type.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用字典在 Julia 中存储键值映射。重要的是要记住，在 Julia 中，字典中的键可以是任何类型的值。
- en: Arrays and dictionaries are mutable containers, which means that you can change
    their contents.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和字典是可变容器，这意味着您可以更改其内容。
- en: Tuples and named tuples are similar to one-dimensional arrays, but they are
    immutable containers. After they are created, you are not allowed to change their
    contents.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组和命名元组类似于一维数组，但它们是不可变容器。一旦创建，就不允许更改其内容。
- en: Named tuples differ from tuples in that all their elements, apart from having
    an index, also have names, which you can use to access them.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名元组与元组不同，除了有索引外，它们的所有元素还具有名称，您可以使用这些名称来访问它们。
