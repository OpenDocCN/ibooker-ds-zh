- en: Part 2
  id: totrans-0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二部分
- en: Adapting real-world projects
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 适应现实世界的项目
- en: Part 1 of this book explored the module system’s basics and how to compile,
    package, and run modular applications. In addition to teaching the relevant mechanisms,
    it showed how future Java projects will be organized and developed.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本书第一部分探讨了模块系统的基本知识以及如何编译、打包和运行模块化应用程序。除了教授相关机制外，它还展示了未来的Java项目将如何组织和发展。
- en: But what about existing projects? I’m sure you’d like to see them running on
    Java 9 or later, maybe even as modules. This part covers how to make that happen.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但对于现有的项目呢？我相信你们希望看到它们在Java 9或更高版本上运行，也许甚至作为模块。这部分将介绍如何实现这一点。
- en: The first step, getting a project to compile and run on Java 9+, is obligatory
    for any code base that doesn’t want to stay on Java 8 past its end of life or
    pay for support. The second step, turning the project’s artifacts into modular
    JARs, is optional and can be done over time.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一步，让项目在Java 9+上编译和运行，对于任何不想在Java 8的生命周期结束后继续使用或支付支持费用的代码库来说是强制性的。第二步，将项目的工件转换为模块化JAR文件，是可选的，并且可以逐步完成。
- en: Chapters 6 and 7 are dedicated to the migration to Java 9\. They’re all about
    making your non-modular, class path-based project work on the newest release (without
    creating any modules). Chapter 8 then covers the features that allow you to incrementally
    modularize your project. Chapter 9 gives some strategic advice on how to migrate
    and modularize your project by using what you learned in chapters 6–8.
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第6章和第7章专门介绍迁移到Java 9。它们都是关于让你的非模块化、基于类路径的项目在新版本上工作（而不创建任何模块）。第8章介绍了允许你逐步模块化项目的功能。第9章提供了一些战略建议，教你如何使用第6章至第8章中学到的知识迁移和模块化你的项目。
- en: 'I recommend reading the chapters in that order, but if you prefer studying
    the technical details only when you need them, you could start with chapter 9\.
    Alternatively, you could read up on the challenges you’ll most likely encounter
    first: dependencies on JEE modules (section 6.1) and on JDK internals (section
    7.1).'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我建议按照这个顺序阅读这些章节，但如果你更喜欢只在需要时研究技术细节，你可以从第9章开始。或者，你也可以先了解你可能会遇到的最大挑战：对JEE模块的依赖（第6.1节）和对JDK内部的依赖（第7.1节）。
- en: There are no specific examples for everything shown in this part of the book.
    The repository at [https://github.com/CodeFX-org/demo-java-9-migration](https://github.com/CodeFX-org/demo-java-9-migration)
    contains a variant of the ServiceMonitor application with a bunch of problems
    that need fixing to work on Java 9+. Give it a try!
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本书本部分没有针对所有内容提供具体的示例。在[https://github.com/CodeFX-org/demo-java-9-migration](https://github.com/CodeFX-org/demo-java-9-migration)的存储库中包含了一个ServiceMonitor应用程序的变体，其中包含一些需要修复才能在Java
    9+上运行的问题。试试看吧！
- en: '6'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '6'
- en: Compatibility challenges when moving to Java 9 or later
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 移动到Java 9或更高版本时的兼容性挑战
- en: This chapter covers
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why JEE modules are deprecated and not resolved by default
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么JEE模块被弃用且默认不解析
- en: Compiling and running code that depends on JEE modules
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译和运行依赖于JEE模块的代码
- en: Why casts to `URLClassLoader` fail
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么`URLClassLoader`的转换失败
- en: Understanding the new JDK runtime image layout
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解新的JDK运行时图像布局
- en: Replacing the removed extension mechanism, endorsed standards override mechanism,
    and boot class path option
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换已删除的扩展机制、支持标准覆盖机制和引导类路径选项
- en: This chapter and chapter 7 discuss compatibility challenges when migrating an
    existing code base to Java 9 and beyond. You won’t be creating any modules yet;
    these chapters are about building and running an existing project on the newest
    release.
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章和第7章讨论了将现有代码库迁移到Java 9及更高版本时的兼容性挑战。你目前不会创建任何模块；这些章节是关于在最新版本上构建和运行现有项目。
- en: Why does moving to Java 9+ require two entire chapters? Can’t you install the
    newest JDK and expect everything to just work? Isn’t Java meant to be backward-compatible?
    Yes—if your project, including its dependencies, only relies on nondeprecated,
    standardized, documented behavior. But that’s a big if, and it turns out that
    in the absence of any enforcement, the wider Java community has strayed from that
    path.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么移动到Java 9+需要两整个章节？难道你不能安装最新的JDK并期望一切都能正常工作吗？Java不是应该向后兼容的吗？是的——如果你的项目及其依赖项只依赖于非弃用、标准化、有文档记录的行为。但这只是一个大前提，而且结果证明，在没有任何强制措施的情况下，更广泛的Java社区已经偏离了这条道路。
- en: 'As you’ll see in this chapter, the module system deprecated some Java features,
    removed others, and changed some internals:'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你将在本章中看到的，模块系统弃用了一些Java特性，移除了其他特性，并更改了一些内部结构：
- en: Modules containing JEE APIs are deprecated and need to be resolved manually
    (section 6.1).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含JEE API的模块已弃用，需要手动解决（第6.1节）。
- en: The application class loader (also called the system class loader) is no longer
    a `URLClassLoader`, which breaks some casts (section 6.2).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序类加载器（也称为系统类加载器）不再是`URLClassLoader`，这破坏了一些类型转换（第6.2节）。
- en: The directory layout of the Java runtime image (JRE and JDK) was overhauled
    (section 6.3)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java运行时图像（JRE和JDK）的目录布局已彻底翻新（第6.3节）
- en: A number of mechanisms like compact profiles and the endorsed-standards override
    mechanisms were removed (section 6.4).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些机制，如紧凑配置文件和endorsed-standards覆盖机制已被移除（第6.4节）。
- en: A few smaller things were changed, too, like no longer allowing the single underscore
    as an identifier (section 6.5).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一些小的变化，比如不再允许单下划线作为标识符（第6.5节）。
- en: That’s not all, though. Chapter 7 discusses two more challenges (internal APIs
    and split packages). They got their own chapter because chances are you’ll encounter
    them again with non-JDK modules after you’ve migrated your project.
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但这还不是全部。第7章讨论了两个更多挑战（内部API和分割包）。它们各自有自己的章节，因为在你迁移项目后，你可能会再次遇到它们与非JDK模块一起。
- en: Taken together, these changes break some libraries, frameworks, tools, techniques,
    and maybe your code, too, so unfortunately updating to Java 9+ isn’t always an
    easy task. Generally speaking, the larger and older the project, the higher the
    chances it will take some work. Then again, it’s usually well-invested time, because
    it’s an opportunity to pay back some technical debt and get the code base into
    better shape.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些变化一起破坏了一些库、框架、工具、技术和可能也是你的代码，因此不幸的是，更新到Java 9+并不总是容易的任务。一般来说，项目越大、越老，它需要的工作就越多。然而，这通常是值得的投资，因为它是一个偿还技术债务并使代码库变得更好的机会。
- en: By the end of this chapter and the next, you’ll know the challenges of updating
    to Java 9, 10, and 11 or even later. Given an application, you’ll be able to make
    informed guesses about what needs to be done; and assuming all your dependencies
    play along, you’ll be able to make it work on the newest release. You’ll also
    be well prepared for chapter 9, which discusses strategies for migrating to Java
    9 and later.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到本章和下一章结束时，你将了解更新到Java 9、10、11甚至更晚版本的挑战。给定一个应用程序，你将能够对需要做什么做出明智的猜测；并且假设所有依赖项都配合，你将能够在最新版本上使其工作。你还将为第9章做好准备，该章节讨论了迁移到Java
    9及以后的策略。
- en: About the class path
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于类路径
- en: 'Chapter 8 has a lot to say about how non-modular code runs on the modularized
    JDK. For now you only need to know the following:'
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第8章详细讨论了非模块化代码如何在模块化的JDK上运行。目前你只需要知道以下内容：
- en: The class path is still fully functional. During a migration to Java 9+, you’ll
    continue to use it instead of the module path.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径仍然完全有效。在迁移到Java 9+的过程中，你将继续使用它而不是模块路径。
- en: 'Even then, the module system is still in play: for example, regarding module
    resolution.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使如此，模块系统仍然在发挥作用：例如，关于模块解析。
- en: 'Code on the class path will automatically read most modules (but not all: check
    section 6.1), so they’re available at compile time or run time without additional
    configuration.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径上的代码将自动读取大多数模块（但并非全部：请参阅第6.1节），因此它们在编译时或运行时无需额外配置即可使用。
- en: 6.1 Working with JEE modules
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.1 与JEE模块一起工作
- en: 'A lot of code in Java SE is related to Java EE / Jakarta EE (which I abbreviate
    as JEE): CORBA comes to mind, and so do Java Architecture for XML Binding (JAXB)
    and Java API for XML Web Services (JAX-WS). These and other APIs ended up in the
    six modules shown in [table 6.1](part0020.html#filepos731837). This could be nothing
    more than a small side note and the end of the story, but unfortunately it’s not.
    When you try to compile or run code that depends on a class from these modules,
    the module system will claim the modules are missing from the graph.'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java SE中的许多代码都与Java EE / Jakarta EE（我将其缩写为JEE）相关：CORBA就是其中之一，Java Architecture
    for XML Binding (JAXB)和Java API for XML Web Services (JAX-WS)也是如此。这些和其他API最终出现在[表6.1](part0020.html#filepos731837)中显示的六个模块中。这可能会是一个微不足道的旁白和故事的结尾，但不幸的是并非如此。当你尝试编译或运行依赖于这些模块中的类的代码时，模块系统会声称这些模块在图中缺失。
- en: 'Here’s a compile error on Java 9 for a class using `JAXBException` from the
    java.xml.bind module:'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 9中，对于使用java.xml.bind模块中的`JAXBException`的类，存在一个编译错误：
- en: '`> error: package javax.xml.bind is not visible > import javax.xml.bind.JAXBException;
    > ^ > (package javax.xml.bind is declared in module java.xml.bind, > which is
    not in the module graph) > 1 error`'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 错误：包javax.xml.bind不可见 > import javax.xml.bind.JAXBException; > ^ > （包javax.xml.bind在模块java.xml.bind中声明，
    > 该模块不在模块图中） > 1个错误`'
- en: 'If you get it past the compiler but forget to massage the runtime, you’ll get
    a `NoClassDefFoundError`:'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你通过了编译器，但忘记了调整运行时，你会得到一个`NoClassDefFoundError`错误：
- en: '`> Exception in thread "main" java.lang.NoClassDefFoundError: > javax/xml/bind/JAXBException
    > at monitor.Main.main(Main.java:27) > Caused by: ClassNotFoundException: > javax.xml.bind.JAXBException
    > at java.base/BuiltinClassLoader.loadClass > (BuiltinClassLoader.java:582) >
    at java.base/ClassLoaders$AppClassLoader.loadClass > (ClassLoaders.java:185) >
    at java.base/ClassLoader.loadClass > (ClassLoader.java:496) > ... 1 more`'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 线程"main"中的异常 java.lang.NoClassDefFoundError: > javax/xml/bind/JAXBException
    > at monitor.Main.main(Main.java:27) > 原因：ClassNotFoundException: > javax.xml.bind.JAXBException
    > at java.base/BuiltinClassLoader.loadClass > (BuiltinClassLoader.java:582) >
    at java.base/ClassLoaders$AppClassLoader.loadClass > (ClassLoaders.java:185) >
    at java.base/ClassLoader.loadClass > (ClassLoader.java:496) > ... 更多`'
- en: What’s going on? Why are properly standardized Java APIs not present for code
    on the class path, and what can be done about that?
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 发生了什么？为什么在类路径上的代码中没有正确标准化的Java API，对此能做些什么？
- en: Table 6.1 The six JEE modules. The descriptions cite the documentation.
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表6.1 六个JEE模块。描述引用了文档。
- en: '| Module name   | Description   | Packages   |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 模块名称   | 描述   | 包   |'
- en: '| java.activation   | Defines the JavaBeans Activation Framework (JAF) API   |
    `javax.activation`   |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| java.activation   | 定义了JavaBeans激活框架（JAF）API   | `javax.activation`   |'
- en: '| java.corba   | Defines the Java binding of the Open Management Group (OMG)
    CORBA APIs, and the RMI-IIOP API   | `javax.activity`, `javax.rmi`, `javax.rmi.CORBA`,
    `org.omg.*`   |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| java.corba   | 定义了Open Management Group（OMG）CORBA API的Java绑定和RMI-IIOP API   |
    `javax.activity`, `javax.rmi`, `javax.rmi.CORBA`, `org.omg.*`   |'
- en: '| java.transaction   | Defines a subset of the Java Transaction API (JTA) to
    support CORBA interop   | `javax.transaction`   |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| java.transaction   | 定义了Java事务API（JTA）的一个子集，以支持CORBA互操作   | `javax.transaction`   |'
- en: '| java.xml.bind   | Defines the JAXB API   | `javax.xml.bind.*`   |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| java.xml.bind   | 定义了JAXB API   | `javax.xml.bind.*`   |'
- en: '| java.xml.ws   | Defines the JAX-WS and Web Services Metadata APIs   | `javax.jws`,
    `javax.jws.soap`, `javax.xml.soap`, `javax.xml.ws.*`   |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| java.xml.ws   | 定义了JAX-WS和Web服务元数据API   | `javax.jws`, `javax.jws.soap`,
    `javax.xml.soap`, `javax.xml.ws.*`   |'
- en: '| java.xml.ws.annotation   | Defines a subset of the Common Annotations API
    to support programs running on the Java SE platform   | `javax.annotation`   |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| java.xml.ws.annotation   | 定义了Common Annotations API的一个子集，以支持在Java SE平台上运行的程序   |
    `javax.annotation`   |'
- en: 6.1.1 WHY ARE THE JEE MODULES SPECIAL?
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.1.1 为什么JEE模块是特殊的？
- en: 'Java SE contains a few packages that consist of endorsed standards and standalone
    technologies. These technologies are developed outside the Java Community Process
    (JCP), often because they rely on standards governed by other bodies. Examples
    are the Document Object Model (DOM), developed by the World Wide Web Consortium
    (W3C) and the Web Hypertext Application Technology Working Group (WHATWG), and
    Simple API for XML (SAX). If you’re interested, you can find a list of them and
    the packages they’re in at [http://mng.bz/8Ek7](http://mng.bz/8Ek7). Disproportionately
    many of them fall into the JEE modules listed in [table 6.1](part0020.html#filepos731837):
    java.corba, java.xml.bind, and java.xml.ws.'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java SE包含一些由认可的规范和独立技术组成的包。这些技术是在Java社区进程（JCP）之外开发的，通常因为它们依赖于由其他机构管理的标准。例如，由万维网联盟（W3C）和Web超文本应用技术工作组（WHATWG）开发的文档对象模型（DOM），以及简单XML
    API（SAX）。如果你感兴趣，你可以在[http://mng.bz/8Ek7](http://mng.bz/8Ek7)找到它们的列表和它们所在的包。其中许多不均衡地落入表6.1中列出的JEE模块：java.corba、java.xml.bind和java.xml.ws。
- en: Historically, the Java Runtime Environment (JRE) shipped with implementations
    of these technologies but was ready to let users upgrade them independently of
    the JRE. This could be done with the endorsed standards override mechanism (see
    section 6.5.3).
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从历史上看，Java运行时环境（JRE）附带这些技术的实现，但准备让用户独立于JRE进行升级。这可以通过认可的规范覆盖机制（见第6.5.3节）来完成。
- en: Similarly, application servers often extend or upgrade the CORBA, JAXB, or JAX-WS
    APIs as well as the JavaBeans Activation Framework (in java.activation) or the
    JTA (in java.transaction) by providing their own implementations. Finally, java.xml.ws.annotation
    contains the `javax.annotation` package. It’s often extended by the various JSR
    305 implementations, which are most famous for their `null`-related annotations.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类似地，应用服务器通常通过提供自己的实现来扩展或升级CORBA、JAXB或JAX-WS API，以及JavaBeans激活框架（在java.activation中）或JTA（在java.transaction中）。最后，java.xml.ws.annotation包含了`javax.annotation`包。它通常被各种JSR
    305实现扩展，这些实现最著名的是它们与`null`相关的注解。
- en: 'In all these cases of extending or replacing APIs that ship with Java, the
    trick is to use the exact same package and class names, so the classes are loaded
    from an external JAR instead of the built in ones. In the parlance of the module
    system, this is called a split package: the same package is split across different
    modules or a module and the class path.'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在所有这些扩展或替换Java附带API的案例中，技巧是使用完全相同的包和类名，这样类就会从外部JAR加载而不是内置的。在模块系统的术语中，这被称为拆分包：相同的包在不同的模块或模块和类路径之间拆分。
- en: The end of split packages
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拆分包的终结
- en: 'Splitting packages no longer works in Java 9+ and later. We’ll look into that
    in detail in section 7.2—for now it suffices to know that classes on the class
    path in a package that’s distributed with Java are effectively invisible:'
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 9+及以后的版本中，拆分包不再有效。我们将在第7.2节中详细探讨这个问题——现在只需知道，与Java一起分发的包中的类路径上的类实际上是不可见的：
- en: If Java contains a class with the same fully qualified name, that one will be
    loaded.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Java包含一个具有相同完全限定名的类，那么将加载那个类。
- en: If the Java built-in version of the package doesn’t contain the required class,
    the result is the compile error or `NoClassDefFoundError` that I showed earlier.
    And that happens regardless of whether the class is present on the class path.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Java内置的包版本不包含所需的类，结果将是前面展示的编译错误或`NoClassDefFoundError`。而且这无论类是否存在于类路径上都会发生。
- en: 'This is a general mechanism for all packages of all modules: splitting them
    between a module and the class path makes the classpath portion invisible. What
    makes the six JEE modules special is that unlike other modules, it’s customary
    to extend or upgrade them with the split-package approach.'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个适用于所有模块的所有包的通用机制：将它们在模块和类路径之间拆分使得类路径部分不可见。使六个JEE模块特殊的是，与其他模块不同，通常使用拆分包方法来扩展或升级它们。
- en: 'To keep application servers and libraries like the JSR 305 implementations
    working without extensive configuration, a trade-off was made: for code on the
    class path, Java 9 and 10 by default don’t resolve the JEE modules, meaning they
    don’t make it into the module graph and hence aren’t available (see section 3.4.3
    for unresolved modules and section 8.2.2 for details of the class path scenario).'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使应用服务器和像JSR 305实现这样的库在没有大量配置的情况下工作，做出了一些权衡：对于类路径上的代码，Java 9和10默认不解析JEE模块，这意味着它们不会进入模块图，因此不可用（有关未解析的模块，请参阅第3.4.3节；有关类路径场景的详细信息，请参阅第8.2.2节）。
- en: That works well for applications that come with their own implementations of
    these JEE APIs, but not so much for those that relied on the JDK variants. Without
    further configuration, code on the class path using types from those six modules
    will fail to compile and run.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这对于带有这些JEE API自己实现的程序来说效果很好，但对于依赖于JDK变体的程序来说就不那么好了。没有进一步的配置，使用这些六个模块中的类型在类路径上的代码将无法编译和运行。
- en: To get rid of this complexity and to properly separate Java SE from JEE, these
    modules are deprecated in Java 9 and removed in Java 11\. With their removal,
    command-line tools like `wsgen` and `xjc` are also no longer shipped with the
    JDK.
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了消除这种复杂性并正确地将Java SE与JEE分开，这些模块在Java 9中被弃用，在Java 11中被移除。随着它们的移除，命令行工具如`wsgen`和`xjc`也不再随JDK一起提供。
- en: 6.1.2 MANUALLY RESOLVING JEE MODULES
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.1.2 手动解析JEE模块
- en: 'What do you do if you get a compile or runtime error due to missing JEE APIs,
    or if a JDeps analysis (see appendix D) shows that you depend on JEE modules?
    There are three answers:'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果由于缺少JEE API而导致编译或运行时错误，或者如果JDeps分析（见附录D）显示你依赖于JEE模块，你会怎么做？有三个答案：
- en: If your application runs in an application server, it may provide an implementation
    of those APIs, in which case you shouldn’t encounter runtime errors. Depending
    on your setup, you may have to fix build errors, though—either of the other two
    solutions should do that.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的应用程序在应用程序服务器中运行，它可能提供了这些 API 的实现，在这种情况下，你可能不会遇到运行时错误。根据你的配置，你可能需要修复构建错误，不过——其他两种解决方案都应该能解决这个问题。
- en: Pick a third-party implementation of that API, and add it as a dependency to
    your project. Because JEE modules aren’t resolved by default, that implementation
    is used during compilation and at run time without problems.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择该 API 的第三方实现，并将其作为依赖项添加到你的项目中。由于 JEE 模块默认不解析，该实现将在编译和运行时无问题地使用。
- en: On Java 9 and 10, add the platform module with `--add-modules` as described
    in section 3.4.3\. Because the JEE modules are removed in Java 11, this won’t
    work there.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 9 和 10 中，如第 3.4.3 节所述，使用 `--add-modules` 添加平台模块。由于 Java 11 中移除了 JEE 模块，这在那里将不起作用。
- en: 'The example at the beginning of the section tried to use `JAXBException` from
    the java.xml.bind module. Here’s how to make that module available for compilation
    with `--add-modules`:'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该节开头提供的示例尝试使用 java.xml.bind 模块中的 `JAXBException`。以下是使用 `--add-modules` 使该模块可用于编译的方法：
- en: '`$ javac --classpath ${jars} --add-modules java.xml.bind -d ${output-dir} ${source-files}`'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --classpath ${jars} --add-modules java.xml.bind -d ${output-dir} ${source-files}`'
- en: 'When the code is compiled and packaged, you need to add the module again for
    execution:'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当代码编译和打包时，你需要再次添加模块以执行：
- en: '`$ java --classpath ${jars} --add-modules java.xml.bind ${main-class}`'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --classpath ${jars} --add-modules java.xml.bind ${main-class}`'
- en: If you depend on a few of the JEE APIs, it may be easier to add the java.se.ee
    module instead of each individual module. It makes all six EE modules available,
    which simplifies things a bit. (How does it make them available? Read about aggregator
    modules in section 11.1.5.)
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你依赖于几个 JEE API，添加 java.se.ee 模块可能比添加每个单独的模块更容易。它使得所有六个 EE 模块都可用，这简化了一些事情。（它是如何使它们可用的？请阅读第
    11.1.5 节中关于聚合模块的内容。）
- en: ESSENTIAL INFO Instead of `--add-modules`, I recommend seriously considering
    adding third-party implementations of the required APIs as regular project dependencies.
    Section 9.1.4 discusses the drawbacks of using command-line options, so make sure
    to give it a read before going down that road. And because the JEE modules are
    removed in Java 11, sooner or later you’ll need a third-party implementation anyway.
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息**：而不是使用 `--add-modules`，我强烈建议认真考虑将所需的 API 的第三方实现作为常规项目依赖项添加。第 9.1.4
    节讨论了使用命令行选项的缺点，所以在走这条路之前请务必阅读。而且由于 Java 11 中移除了 JEE 模块，迟早你需要第三方实现。'
- en: 'The effort of manually adding JEE modules is only required for unmodularized
    code. Once it’s modularized, the EE modules stop being special: you can require
    them like any other module, and they will be resolved like any other module—at
    least, until they’re removed.'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 手动添加 JEE 模块的努力仅适用于非模块化代码。一旦它被模块化，EE 模块就不再特殊：你可以像要求任何其他模块一样要求它们，并且它们将像任何其他模块一样被解析——至少，直到它们被移除。
- en: Third-party JEE implementations
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第三方 JEE 实现
- en: Comparing and discussing third-party implementations of the various JEE APIs
    would lead far away from the module system, so I won’t do it here. For a list
    of alternatives, see JEP 320 ([http://openjdk.java.net/jeps/320](http://openjdk.java.net/jeps/320))
    or Stack Overflow ([http://mng.bz/0p29](http://mng.bz/0p29)).
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 比较和讨论各种 JEE API 的第三方实现将远离模块系统，因此在这里我不会这么做。有关替代方案列表，请参阅 JEP 320 ([http://openjdk.java.net/jeps/320](http://openjdk.java.net/jeps/320))
    或 Stack Overflow ([http://mng.bz/0p29](http://mng.bz/0p29))。
- en: 6.1.3 DROPPING IN THIRD-PARTY IMPLEMENTATIONS OF JEE MODULES
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.1.3 添加 JEE 模块的第三方实现
- en: Maybe you’ve been using the endorsed standards override mechanism to update
    standards and standalone technologies. In that case, you may wonder what happened
    to it in a time of modules. As you may have guessed, it was removed and replaced
    by something new.
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能你一直在使用受支持的规范覆盖机制来更新规范和独立技术。在这种情况下，你可能想知道在模块时代它发生了什么。正如你可能猜到的，它被移除并由新事物取代了。
- en: 'Both the compiler and runtime offer the `--upgrade-module-path` option, which
    accepts a list of directories, formatted like the ones for the module path. When
    the module system creates the module graph, it searches those directories for
    artifacts and uses them to replace upgradeable modules. The six JEE modules are
    always upgradeable:'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译器和运行时都提供了`--upgrade-module-path`选项，该选项接受一个目录列表，格式类似于模块路径的格式。当模块系统创建模块图时，它会搜索这些目录以查找工件，并使用它们来替换可升级的模块。六个JEE模块始终可升级：
- en: java.activation
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.activation`'
- en: java.corba
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.corba`'
- en: java.transaction
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.transaction`'
- en: java.xml.bind
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.bind`'
- en: java.xml.ws
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.ws`'
- en: java.xml.ws.annotation
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.ws.annotation`'
- en: JDK vendors may make more modules upgradeable. On Oracle JDK, for example, this
    applies to java.jnlp. Furthermore, application modules that were linked into an
    image with `jlink` are always upgradeable—see section 14.2.1 for more on that.
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDK供应商可能会使更多模块可升级。例如，在Oracle JDK上，这适用于java.jnlp。此外，使用`jlink`链接到映像中的应用程序模块始终可升级——有关更多信息，请参阅第14.2.1节。
- en: JARs on the upgrade module path don’t have to be modular. If they lack a module
    descriptor, they’ll be turned into automatic modules (see section 8.3) and can
    still replace Java modules.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 升级模块路径上的JAR文件不必是模块化的。如果它们缺少模块描述符，它们将被转换为自动模块（请参阅第8.3节），并且仍然可以替换Java模块。
- en: 6.2 Casting to URLClassLoader
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.2 将其转换为`URLClassLoader`
- en: 'Running a project on Java 9 or later, you may encounter a class-cast exception
    like the one shown in the following example. Here, the JVM complains that it couldn’t
    cast an instance of `jdk.internal.loader.ClassLoaders.AppClassLoader` to `URLClassLoader`:'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 9或更高版本上运行项目时，您可能会遇到类似于以下示例中的类转换异常。在这里，JVM抱怨它无法将`jdk.internal.loader.ClassLoaders.AppClassLoader`实例转换为`URLClassLoader`：
- en: '`> Exception in thread "main" java.lang.ClassCastException:` `> java.base/jdk.internal.loader.ClassLoaders$AppClassLoader`
    [`①`](part0020.html#filepos756952)`> cannot be cast to java.base/java.net.URLClassLoader`
    [`②`](part0020.html#filepos757319) `> at monitor.Main.getClassPathContent(Main.java:46)
    > at monitor.Main.main(Main.java:28)`'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 线程 "main" 中发生异常 java.lang.ClassCastException:` `> java.base/jdk.internal.loader.ClassLoaders$AppClassLoader`
    [`①`](part0020.html#filepos756952)`> 无法转换为 java.base/java.net.URLClassLoader`
    [`②`](part0020.html#filepos757319) `> 在 monitor.Main.getClassPathContent(Main.java:46)
    > 在 monitor.Main.main(Main.java:28)`'
- en: ①
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: The class loader returned by getClass is an AppClassLoader.
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`getClass()`返回的类加载器是`AppClassLoader`。'
- en: ②
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: AppClassLoader doesn’t extend URLClassLoader, so the cast fails.
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`AppClassLoader`不扩展`URLClassLoader`，因此转换失败。'
- en: What’s this new type, and why does it break the code? Let’s find out! In the
    process, you’ll learn how Java 9 changes class-loading behavior to improve launch
    performance. So even if your project doesn’t suffer from this particular problem,
    it’s still a great opportunity to deepen your Java knowledge.
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是什么新类型，为什么它会破坏代码？让我们找出答案！在这个过程中，您将了解Java 9如何更改类加载行为以改进启动性能。因此，即使您的项目没有遇到这个问题，这也是加深Java知识的好机会。
- en: 6.2.1 APPLICATION CLASS LOADERS, THEN AND NOW
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.2.1 应用程序类加载器，过去和现在
- en: In all Java versions, the application class loader (often called the system
    class loader) is one of three class loaders the JVM uses to run an application.
    It loads JDK classes that don’t need any special privileges as well as all application
    classes (unless the app uses its own class loaders, in which case none of the
    following applies).
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在所有Java版本中，应用程序类加载器（通常称为系统类加载器）是JVM用于运行应用程序的三个类加载器之一。它加载不需要任何特殊权限的JDK类以及所有应用程序类（除非应用程序使用自己的类加载器，在这种情况下，以下内容不适用）。
- en: You can access the application class loader by calling `ClassLoader.getSystemClassLoader()`
    or by calling `getClass().getClassLoader()` on an instance of one of your classes.
    Both methods promise to give you an instance of type `ClassLoader`. On Java 8
    and before, the application class loader is a `URLClassLoader`, a subtype of `ClassLoader`;
    and because `URLClassLoader` offers some methods that can come in handy, it’s
    common to cast the instance to it. You can see an example of that in [listing
    6.1](part0020.html#filepos761187).
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以通过调用`ClassLoader.getSystemClassLoader()`或在一个实例上调用`getClass().getClassLoader()`来访问应用程序类加载器。这两种方法都承诺给您一个`ClassLoader`类型的实例。在Java
    8及之前，应用程序类加载器是`URLClassLoader`，它是`ClassLoader`的子类型；由于`URLClassLoader`提供了一些有用的方法，因此通常将其实例转换为它。您可以在[列表6.1](part0020.html#filepos761187)中看到一个示例。
- en: Without modules as a runtime representation of JARs, `URLClassLoader` has no
    idea in which artifact to find a class; as a consequence, whenever a class needs
    to be loaded, `URLClassLoader` scans every artifact on the class path until it
    finds what it’s looking for (see [figure 6.1](part0020.html#filepos762868)). That’s
    obviously pretty ineffective.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有模块作为 JAR 的运行时表示，`URLClassLoader` 没有办法知道在哪个工件中查找一个类；因此，每当需要加载一个类时，`URLClassLoader`
    会扫描类路径上的每个工件，直到找到它所寻找的内容（参见[图 6.1](part0020.html#filepos762868)）。这显然非常低效。
- en: Listing 6.1 Casting the application class loader to `URLClassLoader`
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 6.1 将应用程序类加载器转换为 `URLClassLoader`
- en: '`private String getClassPathContent() { URLClassLoader loader =` `(URLClassLoader)
    this.getClass().getClassLoader();` [`①`](part0020.html#filepos762060)`return Arrays.stream(loader.getURLs())`
    [`②`](part0020.html#filepos762432) `.map(URL::toString) .collect(joining(", "));
    }`'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private String getClassPathContent() { URLClassLoader loader =` `(URLClassLoader)
    this.getClass().getClassLoader();` [`①`](part0020.html#filepos762060)`return Arrays.stream(loader.getURLs())`
    [`②`](part0020.html#filepos762432) `.map(URL::toString) .collect(joining(", "));
    }`'
- en: ①
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Gets the application class loader and casts it to URLClassLoader
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 获取应用程序类加载器并将其转换为 `URLClassLoader`
- en: ②
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: getURLs doesn’t exist on ClassLoader, which is the reason for the cast.
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`getURLs` 不存在于 `ClassLoader` 中，这就是进行类型转换的原因。'
- en: '![](../images/00018.jpeg)'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00018.jpeg)'
- en: '[Figure 6.1](part0020.html#filepos760733) Without modules (top), a particular
    class is loaded by scanning all artifacts on the class path. With modules (bottom),
    the class loader knows which modular JAR a package comes from and loads it directly
    from there.'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 6.1](part0020.html#filepos760733) 没有模块（顶部），通过扫描类路径上的所有工件来加载特定的类。有模块（底部），类加载器知道一个包来自哪个模块化
    JAR，并直接从那里加载。'
- en: 'Now let’s turn to Java 9+. With JARs getting a proper representation at run
    time, the class-loading behavior could be improved: when a class needs to be loaded,
    the package it belongs to is identified and used to determine a specific modular
    JAR. Only that JAR is scanned for the class (see [figure 6.1](part0020.html#filepos762868)).
    This relies on the assumption that no two modular JARs contain types in the same
    package—if they do, it’s called a split package, and the module system throws
    an error as section 7.2 explains.'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在让我们转向 Java 9+。随着 JAR 在运行时得到了适当的表示，类加载行为可以得到改善：当需要加载一个类时，会识别它所属的包，并使用它来确定一个特定的模块化
    JAR。只有那个 JAR 才会被扫描以查找类（参见[图 6.1](part0020.html#filepos762868)）。这依赖于这样一个假设，即没有两个模块化
    JAR 包含同一包中的类型——如果它们确实包含，则称为拆分包，模块系统会抛出一个错误，如第 7.2 节所述。
- en: The new type `AppClassLoader` and its equally new supertype `BuiltinClassLoader`
    implement the new behavior, and from Java 9 on, the application class loader is
    an `AppClassLoader`. That means the occasional `(URLClassLoader) getClass().getClassLoader()`
    sequence will no longer execute successfully. If you want to learn more about
    the structure and relationships of class loaders in Java 9+, take a look at section
    12.4.1.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新类型 `AppClassLoader` 和其同样新的超类型 `BuiltinClassLoader` 实现了新的行为，并且从 Java 9 开始，应用程序类加载器是一个
    `AppClassLoader`。这意味着偶尔的 `(URLClassLoader) getClass().getClassLoader()` 序列将不再成功执行。如果你想了解更多关于
    Java 9+ 中类加载器结构和关系的信息，请参阅第 12.4.1 节。
- en: 6.2.2 GETTING BY WITHOUT URLCLASSLOADER
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.2.2 没有使用 URLCLASSLOADER
- en: 'If you encounter a cast to `URLClassLoader` in a project you depend on and
    there’s no Java 9+-compatible version to update to, you can’t do much except one
    of the following:'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你在一个你依赖的项目中遇到 `URLClassLoader` 的类型转换，并且没有 Java 9+-兼容的版本可以更新，你除了以下几种方法外别无选择：
- en: Open an issue with the project, or contribute a fix.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目打开一个问题，或者贡献一个修复方案。
- en: Fork or patch the project locally.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地分叉或修补项目。
- en: Wait.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待。
- en: If push came to shove, you could switch to another library or framework if it
    had versions that run fine on Java 9+.
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果迫不得已，你可以切换到另一个库或框架，如果它有在 Java 9+ 上运行良好的版本。
- en: If your own code does the casting, you can (and have to) do something about
    it. Unfortunately, chances are you may have to give up a feature or two. It’s
    likely you cast to `URLClassLoader` to use its specific API, and although there
    have been additions to `ClassLoader`, it can’t fully replace `URLClassLoader`.
    Still, have a look—it may do the thing you want.
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你自己的代码进行了类型转换，你可以（并且必须）对此采取措施。不幸的是，你可能不得不放弃一些功能。你很可能将 `URLClassLoader` 转换为使用其特定的
    API，尽管 `ClassLoader` 已经有所增加，但它不能完全替代 `URLClassLoader`。不过，看看它可能做你想做的事情。
- en: If you just need to see the class path an application was launched with, check
    the system property `java.class.path`. If you’ve used `URLClassLoader` to dynamically
    load user-provided code (for example, as part of a plugin infrastructure) by appending
    JARs to the class path, then you have to find a new way to do that, because it
    can’t be done with the application class loader used by Java 9 and later versions.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你只是需要查看应用程序启动时使用的类路径，请检查系统属性`java.class.path`。如果你已经使用`URLClassLoader`通过将JAR文件附加到类路径来动态加载用户提供的代码（例如，作为插件基础设施的一部分），那么你必须找到一种新的方法来做这件事，因为使用Java
    9及以后版本的应用程序类加载器无法做到这一点。
- en: Instead, consider creating a new class loader—which has the added advantage
    that you’ll be able to get rid of the new classes, because they aren’t loaded
    into the application class loader. If you’re compiling at least against Java 9,
    layers could be an even better solution (see section 12.4).
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 相反，考虑创建一个新的类加载器——它还有一个额外的好处，就是你将能够丢弃新类，因为它们没有被加载到应用程序类加载器中。如果你至少编译了Java 9，层可能是一个更好的解决方案（参见第12.4节）。
- en: You may be tempted to investigate `AppClassLoader` and use its abilities if
    it does what you need. Generally speaking, don’t! Relying on `AppClassLoader`
    is ugly because it’s a private inner class, so you have to use reflection to call
    it. Relying on its public supertype `BuiltinClassLoader` isn’t recommended, either.
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会想调查`AppClassLoader`并使用它的能力，如果它满足你的需求。一般来说，不要这样做！依赖`AppClassLoader`很丑陋，因为它是一个私有内部类，所以你必须使用反射来调用它。依赖其公共超类型`BuiltinClassLoader`也不推荐。
- en: As the package name `jdk.internal.loader` suggests, it’s an internal API; and
    because the package was added in Java 9, it isn’t available by default, so you’d
    have to use `--add-exports` or even `--add-opens` (see section 7.1 for details).
    This not only complicates the code and build process, it also exposes you to possible
    compatibility problems on future Java updates—for example, when these classes
    are refactored. So don’t do it unless it’s absolutely necessary to implement a
    mission-critical feature.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如包名`jdk.internal.loader`所暗示的，它是一个内部API；并且因为该包是在Java 9中添加的，所以默认情况下不可用，所以你必须使用`--add-exports`甚至`--add-opens`（有关详细信息，请参阅第7.1节）。这不仅使代码和构建过程复杂化，还使你面临未来Java更新中可能出现的兼容性问题——例如，当这些类被重构时。所以除非绝对必要以实现关键功能，否则不要这样做。
- en: 6.2.3 FINDING TROUBLESOME CASTS
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.2.3 寻找麻烦的转换
- en: 'Examining the code for these casts is simple: a full-text search for “(URLClassLoader)”
    should do it and contain few false positives (include the parentheses to only
    find casts). As for finding them in your dependencies, I don’t know of any tool
    that make that process comfortable. I guess a combination of build-tool magic
    (to get all your dependencies’ source JARs in one place), command-line sorcery
    (to access all their `.java` files and their file content), and yet another full-text
    search could do the trick.'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查这些转换的代码很简单：通过全文搜索“（URLClassLoader）”应该就能找到，并且很少出现误报（包含括号以仅找到转换）。至于在依赖项中找到它们，我不知道有任何工具能让这个过程变得舒适。我猜可能需要一个构建工具的魔法（以将所有依赖项的源JAR文件放在一个地方），命令行魔法（以访问所有`.java`文件及其文件内容），以及另一个全文搜索才能做到这一点。
- en: 6.3 Updated runtime image directory layout
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.3 更新运行时图像目录布局
- en: 'The JDK’s and JRE’s directory structures evolved incrementally, and it shouldn’t
    be surprising that over the course of more than 20 years, they collected dust.
    One reason for not reorganizing them over time was, of course, backward compatibility.
    As is true for seemingly every detail, some code depends on their specific layout.
    Two examples:'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDK和JRE的目录结构是逐步演化的，在超过20年的时间里，它们积累了灰尘。不随时间重新组织它们的一个原因当然是向后兼容性。正如对看似每个细节一样，一些代码依赖于它们的特定布局。两个例子：
- en: Some tools, particularly IDEs, depend on the exact location of `rt.jar` (the
    classes making up the core Java runtime), `tools.jar` (support classes for tools
    and utilities), and `src.zip` (the JDK source code).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些工具，尤其是IDE，依赖于`rt.jar`（构成核心Java运行时的类）、`tools.jar`（工具和实用程序的类）和`src.zip`（JDK源代码）的确切位置。
- en: There exists code that searches for Java commands like `javac`, `jar`, or `javadoc`
    by speculating that the running JRE has a sibling directory `bin` containing them—which
    is true if the JRE is part of a JDK install, because that contains a `bin` folder
    with those commands and a `jre` folder next to each other.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在着通过推测运行中的JRE有一个包含它们的`bin`子目录来搜索Java命令（如`javac`、`jar`或`javadoc`）的代码——如果JRE是JDK安装的一部分，这是真的，因为其中包含一个包含这些命令的`bin`文件夹和一个相邻的`jre`文件夹。
- en: 'Then came the module system, which broke with the basic assumptions that made
    these two examples possible:'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后是模块系统，它打破了使这两个示例成为可能的基本假设：
- en: The JDK code is now modularized and should hence be delivered in individual
    modules instead of monolithic JARs like `rt.jar` and `tools.jar`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 代码现在已模块化，因此应该以单个模块的形式交付，而不是像 `rt.jar` 和 `tools.jar` 这样的单体 JAR。
- en: With a modularized Java code base and a tool like `jlink`, runtime images can
    be created from any set of modules.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块化的 Java 代码库和像 `jlink` 这样的工具，可以从任何一组模块创建运行时图像。
- en: '`Starting with Java 11, there is no longer a standalone JRE package. Running
    a program requires either a JDK or a package created by jlink.`'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`从 Java 11 开始，不再有独立的 JRE 软件包。运行程序需要 JDK 或由 jlink 创建的软件包。`'
- en: 'As it became clear the module system would incur some breaking changes, the
    decision was made to go all the way and completely reorganize the runtime image
    directory structure. You can see the resulting changes in [figure 6.2](part0020.html#filepos775260).
    Overall, the new layout is much simpler:'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于模块化系统将带来一些破坏性变化，因此决定彻底重新组织运行时图像目录结构。您可以在[图 6.2](part0020.html#filepos775260)中看到这些变化的结果。总体而言，新的布局要简单得多：
- en: A single `bin` directory and no duplicate binaries
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单独的 `bin` 目录，没有重复的二进制文件
- en: A single `lib` directory
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单独的 `lib` 目录
- en: A single directory, `conf`, to contain all files meant for configuration
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单独的目录，`conf`，用于包含所有配置文件
- en: '![](../images/00033.jpeg)'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: '[Figure 6.2](part0020.html#filepos774303) Comparison of the directory structure
    of JDK 8 and 9\. The new one is much cleaner.'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 6.2](part0020.html#filepos774303) 比较 JDK 8 和 9 的目录结构。新的结构要干净得多。'
- en: The most immediate consequence of these changes is that you need to update your
    development tools, because old versions likely won’t work with JDK installs of
    version 9 and later. Depending on the project, it may make sense to search it
    for code that rummages around in the JDK/JRE folder to look up binaries, property
    files, or anything else.
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些变化的直接后果是您需要更新您的开发工具，因为旧版本可能无法与 9 版本及以后的 JDK 安装一起使用。根据项目情况，可能有必要搜索代码中在 JDK/JRE
    文件夹中查找二进制文件、属性文件或其他内容的代码。
- en: 'The URL you get for system resources, for example from `ClasLoader::getSystemResource`,
    has also changed. It used to be of the following form, where `${path}` is something
    like `java/lang/String.class`:'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 系统资源获取的 URL 已更改，例如来自 `ClasLoader::getSystemResource`，它曾经是这样的形式，其中 `${path}`
    是类似 `java/lang/String.class` 的内容：
- en: '`jar:file:${java-home}/lib/rt.jar!${path}`'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`jar:file:${java-home}/lib/rt.jar!${path}`'
- en: 'It now looks like this:'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它现在看起来是这样的：
- en: '`jrt:/${module}/${path}`'
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`jrt:/${module}/${path}`'
- en: All JDK APIs that create or consume such URLs operate on the new schema, but
    non-JDK code handcrafting these URLs must be updated for Java 9+.
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有创建或消耗此类 URL 的 JDK API 都在新的方案上操作，但非 JDK 代码必须更新以生成这些 URL，以适应 Java 9+。
- en: 'Furthermore, the `Class::getResource*` and `ClassLoader::getResource*` methods
    no longer read JDK-internal resources. Instead, to access module-internal resources,
    use `Module::getResourceAsStream` or create a JRT file system as follows:'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，`Class::getResource*` 和 `ClassLoader::getResource*` 方法不再读取 JDK 内部资源。相反，要访问模块内部资源，请使用
    `Module::getResourceAsStream` 或创建一个如下所示的 JRT 文件系统：
- en: '`FileSystem fs = FileSystems.getFileSystem(URI.create("jrt:/")); fs.getPath("java.base",
    "java/lang/String.class"));`'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FileSystem fs = FileSystems.getFileSystem(URI.create("jrt:/")); fs.getPath("java.base",
    "java/lang/String.class"));`'
- en: For more details on how to access resources, see section 5.2.
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有关如何访问资源的更多详细信息，请参阅第 5.2 节。
- en: 6.4 Selecting, replacing, and extending the platform
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.4 选择、替换和扩展平台
- en: When compiling code or launching the JVM, there used to be various ways to specify
    which classes constitute the JDK platform. You could select a subset of the JDK,
    replace a specific technology (like JAXB) with another, add a few classes, or
    pick an entirely different platform version to compile against or launch with.
    The module system made some of these features obsolete and reimplemented others
    with a more modern approach; and regardless of the JPMS, the Java 9 release removes
    a few more.
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在编译代码或启动 JVM 时，曾经有各种方式来指定构成 JDK 平台的类。您可以选择 JDK 的一个子集，用另一个技术（如 JAXB）替换特定技术，添加几个类，或者选择一个完全不同的平台版本来编译或启动。模块系统使一些这些功能变得过时，并以更现代的方法重新实现了其他功能；而且无论
    JPMS 如何，Java 9 版本还移除了一些功能。
- en: If you’re relying on one or more of the features discussed in this section,
    you’ll have to put in some work to keep your project running. Nobody likes to
    be forced into reworking something that doesn’t cause any apparent problems, but
    looking over these features (most of which I never used), I can only imagine how
    much simpler the JDK internals became without them.
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您依赖于本节中讨论的其中一个或多个功能，您将不得不做一些工作来保持您的项目运行。没有人喜欢被迫重做没有引起任何明显问题的东西，但回顾这些功能（其中大部分我从未使用过），我只能说没有它们，JDK内部变得多么简单。
- en: 6.4.1 NO MORE COMPACT PROFILES
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.4.1 紧凑型配置文件不再需要
- en: As section 1.5.5 explains, one goal of the module system was to allow users
    to create a runtime image with only the modules they need. This is particularly
    interesting for small devices with limited storage and for virtualizing environments,
    because both are interested in small runtime images. When it became apparent the
    module system wouldn’t be released with Java 8, which was the plan for a while,
    compact profiles were created as an interim solution.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第1.5.5节所述，模块系统的一个目标允许用户创建仅包含所需模块的运行时镜像。这对于存储空间有限的设备以及虚拟化环境尤其有趣，因为两者都关注较小的运行时镜像。当模块系统不会与Java
    8一起发布变得明显时，这曾是计划的一部分，紧凑型配置文件被创建为一个临时解决方案。
- en: The three compact profiles define subsets of the Java SE 8 API and JREs with
    just the required classes to support those API subsets. After picking a profile
    that matches your application’s requirements, you’d use the `javac` option `-profile`
    to compile against it (to make sure you stay within the selected subset) and then
    run the bytecode on the matching variant.
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 三个紧凑型配置文件定义了Java SE 8 API和JREs的子集，仅包含支持这些API子集所需的类。在选择了与您的应用程序需求相匹配的配置文件后，您将使用`javac`选项`-profile`来针对它进行编译（以确保您保持在所选子集内），然后运行匹配变体的字节码。
- en: With the module system in play, much more flexible runtime images can be created
    with `jlink` (see section 14.1), and compact profiles are no longer needed. The
    Java 9+ compiler will hence only accept `-profile` if compiling for Java 8\. To
    compile against a specific selection of modules, you can use the `--limit-modules`
    option, as explained in section 5.3.5.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块系统的作用下，可以使用`jlink`创建出更加灵活的运行时镜像（参见第14.1节），紧凑型配置文件就不再需要了。因此，Java 9+编译器在编译Java
    8时将仅接受`-profile`选项。要针对特定模块的选择进行编译，您可以使用`--limit-modules`选项，如第5.3.5节所述。
- en: 'These are the modules you need to get the same APIs as the three compact profiles:'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些是您需要以获得与三个紧凑型配置文件相同的API的模块：
- en: For the compact1 profile —java.base, java.logging, and java.scripting
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于紧凑1配置文件——java.base、java.logging和java.scripting
- en: For the compact2 profile —Those for compact1 plus java.rmi, java.sql, and java.xml
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于紧凑2配置文件——紧凑1的类加上java.rmi、java.sql和java.xml
- en: For the compact3 profile —Those for compact2 plus java.compiler, java.instrument,
    java.management, java.naming, java.prefs,java.security.jgss, java.security.sasl,
    java.sql.rowset, and java.xml.crypto
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于紧凑3配置文件——紧凑2的类加上java.compiler、java.instrument、java.management、java.naming、java.prefs、java.security.jgss、java.security.sasl、java.sql.rowset和java.xml.crypto
- en: Instead of relying on a fixed selection, I recommend a different approach. Use
    `jlink` to create an image with only the platform modules you need (see section
    14.1); if your application and its dependencies are fully modularized, you can
    even include your application modules (see section 14.2).
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而不是依赖于固定的选择，我建议采用不同的方法。使用`jlink`创建仅包含您需要的平台模块的镜像（参见第14.1节）；如果您的应用程序及其依赖项完全模块化，甚至可以包含您的应用程序模块（参见第14.2节）。
- en: 6.4.2 EXTENSION MECHANISM REMOVED
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.4.2 扩展机制已移除
- en: 'Before Java 9, the extension mechanism let us add classes to the JDK without
    having to place them on the class path. It loaded them from various directories:
    from directories named by the system property `java.ext.dirs`, from `lib/ext`
    in the JRE, or from a platform-specific system-wide directory. Java 9 removes
    this feature, and the compiler and runtime will exit with an error if the JRE
    directory exists or the system property is set.'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 9之前，扩展机制允许我们在不将它们放在类路径上的情况下向JDK添加类。它从各种目录中加载它们：从由系统属性`java.ext.dirs`命名的目录中，从JRE中的`lib/ext`，或从特定平台的全局系统目录中。Java
    9删除了此功能，如果JRE目录存在或系统属性已设置，编译器和运行时将退出并显示错误。
- en: 'Alternatives are as follows:'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 替代方案如下：
- en: The `java` and `javac` option `--patch-module` injects content into modules
    (see section 7.2.4).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java`和`javac`选项`--patch-module`将内容注入到模块中（参见第7.2.4节）。'
- en: The `java` and `javac` option `--upgrade-module-path` replaces an upgradeable
    platform module with another one (see section 6.1.3).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java` 和 `javac` 选项 `--upgrade-module-path` 用另一个模块替换可升级的平台模块（参见第 6.1.3 节）。'
- en: The extending artifacts can be placed on the class path.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展的工件可以放置在类路径上。
- en: 6.4.3 ENDORSED STANDARDS OVERRIDE MECHANISM REMOVED
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.4.3 已移除 ENDORSED STANDARDS OVERRIDE MECHANISM
- en: Before Java 9, the endorsed standards override mechanism let us replace certain
    APIs with custom implementations. It loaded them from the directories named by
    the system property `java.endorsed.dirs` or the `lib/endorsed` directory in the
    JRE. Java 9 removes this feature, and the compiler and runtime will exit with
    an error if the JRE directory exists or the system property is set. The alternatives
    are the same as for the extension mechanism (section 6.4.2).
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，endorsed standards override mechanism 允许我们用自定义实现替换某些 API。它从系统属性
    `java.endorsed.dirs` 或 JRE 中的 `lib/endorsed` 目录命名的目录中加载它们。Java 9 移除了这个特性，如果 JRE
    目录存在或系统属性被设置，编译器和运行时会因为错误而退出。替代方案与扩展机制（第 6.4.2 节）相同。
- en: 6.4.4 SOME BOOT CLASS PATH OPTIONS REMOVED
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.4.4 已移除某些 BOOT CLASS PATH 选项
- en: 'The `-Xbootclasspath` and `-Xbootclasspath/p` options were removed. Use the
    following options instead:'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 已移除 `-Xbootclasspath` 和 `-Xbootclasspath/p` 选项。请使用以下选项代替：
- en: The `javac` option `--system` specifies an alternate source of system modules.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac` 选项 `--system` 指定系统模块的替代来源。'
- en: The `javac` option `--release` specifies an alternate platform version.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac` 选项 `--release` 指定了一个替代的平台版本。'
- en: The `java` and `javac` option `--patch-module` injects content into modules
    in the initial module graph.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java` 和 `javac` 选项 `--patch-module` 将内容注入初始模块图中的模块。'
- en: 6.4.5 NO COMPILATION FOR JAVA 5
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.4.5 不再为 Java 5 进行编译
- en: The Java compiler can process sources from various Java language versions (for
    example, Java 7, specified with `-source`) and can likewise produce bytecode for
    various JVM versions (for example, for Java 8, specified with `-target`). Java
    used to follow a "one plus three back" policy, which means `javac` 9 supports
    Java 9 (obviously) as well as 8, 7, and 6.
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 编译器可以处理来自各种 Java 语言版本的源代码（例如，使用 `-source` 指定的 Java 7）并且可以同样为各种 JVM 版本生成字节码（例如，为
    Java 8，使用 `-target` 指定）。Java 以前遵循“一加三回”的政策，这意味着 `javac` 9 支持 Java 9（显然）以及 8、7
    和 6。
- en: Setting `-source 5` or `-target 5` on `javac` 8 leads to a deprecation warning
    and is no longer supported by `javac` 9\. Similarly, setting `-source 6` or `-target
    6` on Java 9 results in the same warning. Now that there are releases every six
    months, this policy no longer applies. Java 10, 11, and 12 can compile for Java
    6 just fine.
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 `javac` 8 中设置 `-source 5` 或 `-target 5` 会引发弃用警告，并且不再由 `javac` 9 支持。类似地，在 Java
    9 中设置 `-source 6` 或 `-target 6` 也会产生相同的警告。现在每六个月就会有一个新版本发布，这项政策不再适用。Java 10、11
    和 12 可以很好地编译 Java 6。
- en: NOTE The compiler can recognize and process bytecode of all previous JDKs—it
    just no longer produces bytecode for versions before 6.
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：编译器可以识别和处理所有之前 JDK 的字节码——它只是不再为 6 版本之前的版本生成字节码。
- en: 6.4.6 JRE VERSION SELECTION REMOVED
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.4.6 已移除 JRE 版本选择
- en: 'Before Java 9, you could use the `-version:N` option on `java` (or the corresponding
    manifest entry) to launch the application with a JRE of version `N`. In Java 9,
    the feature was removed: the Java launcher quits with an error for the command-line
    option and prints a warning for the manifest entry while otherwise ignoring it.
    If you’ve been relying on that feature, here’s what the Java documentation has
    to say about that:'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，您可以在 `java`（或相应的清单条目）上使用 `-version:N` 选项来使用版本 `N` 的 JRE 启动应用程序。在
    Java 9 中，该功能已被移除：Java 启动器会因为命令行选项而退出并显示错误，对于清单条目会打印警告，而其他方面则忽略它。如果您一直依赖这个功能，以下是
    Java 文档对该功能的说明：
- en: Modern applications are typically deployed via Java Web Start (JNLP), native
    OS packaging systems, or active installers. These technologies have their own
    methods to manage the JREs needed, by finding or downloading and updating the
    required JRE, as needed. This makes the launcher’s launch-time JRE version selection
    obsolete.
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现代应用程序通常通过 Java Web Start (JNLP)、本地操作系统打包系统或活动安装程序进行部署。这些技术有自己的方法来管理所需的 JRE，通过查找或下载并更新所需的
    JRE，按需进行。这使得启动器的启动时 JRE 版本选择变得过时。
- en: Looks like the docs think applications using `-version:N` aren’t modern—what
    a rude thing to say. Joking aside, if your application depended on that feature,
    you have no other option but to make it work without `-version:N`; for example,
    by bundling it with the JRE it works best on.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 看起来文档认为使用`-version:N`的应用程序不够现代——这真是个无礼的说法。开个玩笑，如果你的应用程序依赖于这个特性，你除了让它在没有`-version:N`的情况下工作外别无选择；例如，通过将其与它运行得最好的JRE捆绑在一起。
- en: 6.5 Little things that make big things fail
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.5 导致重大失败的小事
- en: 'In addition to the larger challenges posed by the module system, there are
    a few changes, often not related to the JPMS, that are smaller but will cause
    trouble all the same:'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了模块系统带来的更大挑战外，还有一些变化，通常与JPMS无关，虽然规模较小，但同样会带来麻烦：
- en: New format for version strings
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本字符串的新格式
- en: Removal of a number of JDK and JRE tools
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除一些JDK和JRE工具
- en: Single underscore no longer a valid identifier
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单下划线不再是有效的标识符
- en: Java Network Launch Protocol (JNLP) syntax update
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java网络启动协议（JNLP）语法更新
- en: Removal of JVM options
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM选项的移除
- en: I don’t want to keep you too long, but I also don’t want to leave out something
    that stops your migration dead in its tracks. So I’ll address each of these but
    be quick about it.
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我不想让你等太久，但我也不想遗漏那些会阻止你的迁移的事情。所以我会快速地解决这些问题。
- en: 6.5.1 NEW VERSION STRINGS
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.5.1 新版本字符串
- en: After more than 20 years, Java has finally and officially accepted that it’s
    no longer on version 1.x. About time. From now on, the system property `java.version`
    and its siblings `java.runtime.version`, `java.vm.version`, `java.specification.version`,
    and `java.vm.specification.version` no longer start with `1.x` but with `x`. Similarly,
    `java -version` returns `x`, so on Java 9 you get `9.something`.
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 经过20多年的发展，Java终于正式接受它不再处于1.x版本。是时候了。从现在起，系统属性`java.version`及其同族`java.runtime.version`、`java.vm.version`、`java.specification.version`和`java.vm.specification.version`不再以`1.x`开头，而是以`x`开头。同样，`java
    -version`返回`x`，所以在Java 9中你得到`9.something`。
- en: Version string format
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 版本字符串格式
- en: The exact format of the new version-string is still in flux. On Java 9, you
    get `9.${MINOR}.${SECURITY}.${PATCH}`, where `${SECURITY}` has the peculiarity
    that it doesn’t reset to zero when a new minor version is released—you’ll always
    be able to tell which version contains more security patches by looking at that
    number.
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新版本字符串的确切格式仍在变动中。在Java 9中，你得到`9.${MINOR}.${SECURITY}.${PATCH}`，其中`${SECURITY}`有一个特性，即当发布新的次要版本时，它不会重置为零——你可以通过查看这个数字来判断哪个版本包含更多的安全补丁。
- en: On Java 10 and later, you get `${FEATURE}.${INTERIM}.${UPDATE}.${PATCH}`, where
    `${FEATURE}` starts with `10` and increases every six months with each feature
    release. `${INTERIM}` acts as you’d expect from `${MINOR}`, but because no minor
    releases are planned in the new schedule, it’s assumed to always stay `0`.
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 10及以后版本，你得到`${FEATURE}.${INTERIM}.${UPDATE}.${PATCH}`，其中`${FEATURE}`从`10`开始，每六个月随着每个功能发布而增加。`${INTERIM}`的作用与`${MINOR}`类似，但由于新计划中没有计划发布次要版本，它被假定为始终为`0`。
- en: An unfortunate side effect is that version-sniffing code may suddenly stop reporting
    the correct results, which could lead to weird program behavior. A full-text search
    for the involved system properties should find such code.
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个不幸的副作用是，版本嗅探代码可能会突然停止报告正确的结果，这可能导致程序出现奇怪的行为。全文搜索相关的系统属性应该能找到这样的代码。
- en: 'As for updating it, if you’re willing to raise a project’s requirements to
    Java 9+, you can eschew the system property prodding and parsing and instead use
    the new `Runtime.Version` type, which is much easier:'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 至于更新它，如果你愿意将项目的需求提升到Java 9+，你可以避免系统属性的探测和解析，而是使用新的`Runtime.Version`类型，这要容易得多：
- en: '``Version version = Runtime.version(); // on Java 10 and later, use `version.feature()`
    switch (version.major()) { case 9: System.out.println("Modularity"); break; case
    10: System.out.println("Local-Variable Type Inference"); break; case 11: System.out.println("Pattern
    Matching (we hope)"); break; }``'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '``Version version = Runtime.version(); // 在Java 10及以后版本，使用 `version.feature()`
    switch (version.major()) { case 9: System.out.println("Modularity"); break; case
    10: System.out.println("Local-Variable Type Inference"); break; case 11: System.out.println("Pattern
    Matching (we hope)"); break; } $`'
- en: 6.5.2 TOOL EXODUS
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.5.2 工具外流
- en: 'The JDK accrued a lot of tools, and over time some became superfluous or were
    superseded by others. Some were included in Java 9’s spring cleaning:'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDK积累了很多工具，随着时间的推移，一些变得不再需要或被其他工具取代。一些被包含在Java 9的春季大扫除中：
- en: JavaDB is no longer included. It was an Apache Derby DB, which you can download
    from [https://db.apache.org](https://db.apache.org).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaDB不再包含。它曾是Apache Derby DB，您可以从[https://db.apache.org](https://db.apache.org)下载。
- en: VisualVM is no longer bundled with the JDK and became a standalone project at
    [https://github.com/oracle/visualvm](https://github.com/oracle/visualvm).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VisualVM不再与JDK捆绑，并在[https://github.com/oracle/visualvm](https://github.com/oracle/visualvm)成为独立项目。
- en: The `hprof` agent library has been removed. Tools replacing its features are
    `jcmd`, `jmap`, and the Java Flight Recorder.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hprof`代理库已被移除。替代其功能的工具是`jcmd`，`jmap`和Java飞行记录器。'
- en: The `jhat` heap visualizer was removed.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jhat`堆可视化器已被移除。'
- en: The `java-rmi.exe` and `java-rmi.cgi` launchers were removed. As an alternative,
    use a servlet to proxy RMI over HTTP.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java-rmi.exe`和`java-rmi.cgi`启动器已被移除。作为替代，请使用servlet通过HTTP代理RMI。'
- en: The `native2ascii` tool was used to convert UTF-8–based property resource bundles
    to ISO-8859-1\. Java 9+ supports UTF-8 based bundles, though, so the tool became
    superfluous and was removed.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native2ascii`工具用于将基于UTF-8的属性资源包转换为ISO-8859-1。然而，Java 9+支持基于UTF-8的包，因此该工具变得多余并被移除。'
- en: Furthermore, all JEE-related command-line tools like `wsgen` and `xjc` are no
    longer available on Java 11 because they were removed together with the modules
    containing them (see section 6.1 for details on JEE modules).
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，所有与JEE相关的命令行工具，如`wsgen`和`xjc`，在Java 11中也不再可用，因为它们与其包含的模块一起被移除（有关JEE模块的详细信息，请参阅第6.1节）。
- en: 6.5.3 THE LITTLEST THINGS
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.5.3 最小的事情
- en: 'Here comes probably the littlest thing that can make your Java 9 build fail:
    Java 8 deprecated the single underscore `_` as an identifier, and on Java 9 you
    get a compile error when using it as one. This was done to reclaim the underscore
    as a possible keyword; future Java versions will give it special meaning.'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下面可能是导致您的Java 9构建失败的最小问题：Java 8已弃用单下划线`_`作为标识符，在Java 9中使用它作为标识符时会导致编译错误。这样做是为了回收下划线作为可能的关键字；未来的Java版本将赋予它特殊含义。
- en: 'Another issue: `Thread.stop(Throwable)` now throws an `UnsupportedOperationException`.
    The other `stop` overloads continue to work, but using them is highly discouraged.'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个问题：`Thread.stop(Throwable)`现在会抛出`UnsupportedOperationException`。其他`stop`重载仍然可以工作，但使用它们被高度不建议。
- en: The JNLP syntax has been updated to conform with the XML specification and “to
    remove inconsistencies, make code maintenance easier, and enhance security.” I
    won’t list the changes—you can find them at [http://mng.bz/dnfM](http://mng.bz/dnfM).
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JNLP语法已更新，以符合XML规范，并“为了消除不一致性，简化代码维护，并增强安全性”。我不会列出更改——您可以在[http://mng.bz/dnfM](http://mng.bz/dnfM)找到它们。
- en: Each Java version removes some deprecated JVM options, and Java 9 is no different.
    It has a particular focus on garbage collection, where a few combinations are
    no longer supported (`DefNew` + `CMS`, `ParNew` + `SerialOld`, `Incremental CMS`)
    and some configurations were removed (`-Xincgc`, `-XX:+CMSIncrementalMode`, `-XX:+UseCMSCompactAtFullCollection`,
    `-XX:+CMSFullGCsBeforeCompaction`, `-XX:+UseCMSCollectionPassing`) or deprecated
    (`-XX:+UseParNewGC`). Java 10, in turn, removes `-Xoss`, `-Xsqnopause`, `-Xoptimize`,
    `-Xboundthreads`, and `-Xusealtsigs`.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个Java版本都会移除一些已弃用的JVM选项，Java 9也不例外。它特别关注垃圾回收，其中一些组合不再受支持（`DefNew` + `CMS`，`ParNew`
    + `SerialOld`，`Incremental CMS`），一些配置被移除（`-Xincgc`，`-XX:+CMSIncrementalMode`，`-XX:+UseCMSCompactAtFullCollection`，`-XX:+CMSFullGCsBeforeCompaction`，`-XX:+UseCMSCollectionPassing`）或已弃用（`-XX:+UseParNewGC`）。Java
    10随后移除了`-Xoss`，`-Xsqnopause`，`-Xoptimize`，`-Xboundthreads`和`-Xusealtsigs`。
- en: 6.5.4 NEW DEPRECATIONS IN JAVA 9, 10, AND 11
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.5.4 JAVA 9，10和11中的新弃用功能
- en: 'Finally, here’s a non-exhaustive list of things that are deprecated in Java
    9, 10, and 11:'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，这里是一个非详尽的列表，列出了Java 9，10和11中弃用的功能：
- en: The Applet API in the `java.applet` package, together with the `appletviewer`
    tool and the Java browser plugin
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.applet`包中的Applet API，以及`appletviewer`工具和Java浏览器插件'
- en: Java Web Start, JNLP, and the `javaws` tool
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Web Start，JNLP，以及`javaws`工具
- en: The Concurrent Mark Sweep (CMS) garbage collector
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发标记清除（Concurrent Mark Sweep，CMS）垃圾回收器
- en: The HotSpot FlatProfiler, activated with `-Xprof`
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`-Xprof`激活的HotSpot FlatProfiler
- en: The `policytool` security tool
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`policytool`安全工具'
- en: 'Java 10 and 11 already followed through on some of the deprecations:'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 10和11已经实施了一些弃用：
- en: Java 10 removes FlatProfiler and `policytool`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 10移除了FlatProfiler和`policytool`。
- en: Java 11 removes the Applet API and Web Start.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 11移除了Applet API和Web Start。
- en: 'For more, as well as for details and suggested alternatives, check the release
    notes (Java 9: [http://mng.bz/GLkN](http://mng.bz/GLkN); Java 10: [http://mng.bz/zLeV](http://mng.bz/zLeV))
    and the list of deprecated code that’s marked for removal (Java 9: [http://mng.bz/YX9e](http://mng.bz/YX9e);
    Java 10: [http://mng.bz/qRoU](http://mng.bz/qRoU)).'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更多信息，以及详细信息和建议的替代方案，请查看发布说明（Java 9：[http://mng.bz/GLkN](http://mng.bz/GLkN)；Java
    10：[http://mng.bz/zLeV](http://mng.bz/zLeV)）和标记为删除的已弃用代码列表（Java 9：[http://mng.bz/YX9e](http://mng.bz/YX9e)；Java
    10：[http://mng.bz/qRoU](http://mng.bz/qRoU)）。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: JEE modules are deprecated in Java 9 and removed in Java 11\. You need to find
    a third-party dependency that fulfills your requirements sooner rather than later.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JEE模块在Java 9中被弃用，在Java 11中被移除。您需要尽早找到一个满足您要求的第三方依赖项。
- en: In Java 9 and 10, these modules aren’t resolved by default, which can lead to
    compile-time and runtime errors. To fix this, either use a third-party dependency
    that implements the same API or make the JEE module available with `--add-modules`.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 9 和 10 中，默认情况下不会解析这些模块，这可能导致编译时和运行时错误。要修复此问题，您可以使用实现相同API的第三方依赖项，或者使用
    `--add-modules` 使JEE模块可用。
- en: The application class loader is no longer of type `URLClassLoader`, so code
    like `(URLClassLoader) getClass().getClassLoader()` fails. Solutions are to only
    rely on the `ClassLoader` API, even if that means a feature must be removed (recommended);
    create a layer to dynamically load new code (recommended); or hack into the class-loader
    internals and use `BuiltinClassLoader` or even `AppClassLoader` (not recommended).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序类加载器不再是 `URLClassLoader` 类型，因此像 `(URLClassLoader) getClass().getClassLoader()`
    这样的代码将失败。解决方案是仅依赖 `ClassLoader` API，即使这意味着必须删除某些功能（推荐）；创建一个动态加载新代码的层（推荐）；或者侵入类加载器内部并使用
    `BuiltinClassLoader` 或甚至 `AppClassLoader`（不推荐）。
- en: The directory structure of the runtime image changed, and you likely have to
    update your tools, particularly IDEs, to work with Java 9 and later. Code rattling
    around in JDK/JRE directories or handcrafting URLs for system resources needs
    to be updated, too.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时镜像的目录结构已更改，您可能需要更新您的工具，特别是IDE，以与Java 9及以后的版本一起工作。也需要更新在 JDK/JRE 目录中四处游荡的代码或为系统资源手工创建URL。
- en: 'Several mechanisms that modified the set of classes constituting the platform
    were removed. For most of them, the module system offers alternatives:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除了一些修改构成平台的类集合的机制。对于大多数机制，模块系统提供了替代方案：
- en: Instead of using compact profiles, create runtime images with `jlink` and configure
    compilation with `--limit-modules`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是使用紧凑配置文件，请使用 `jlink` 创建运行时镜像，并使用 `--limit-modules` 配置编译。
- en: Instead of the extension mechanism or the endorsed standards mechanism, use
    `--patch-module`, `--upgrade-module-path`, or the class path.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是使用扩展机制或认可标准机制，请使用 `--patch-module`、`--upgrade-module-path` 或类路径。
- en: Instead of the `-Xbootclasspath` option, use `--system`, `--release`, or `--patch-module`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是使用 `-Xbootclasspath` 选项，请使用 `--system`、`--release` 或 `--patch-module`。
- en: It’s no longer possible to compile for Java 5 or to use the `-version:N` option
    to launch an application with Java version `N`.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在不再可能为Java 5编译，也不能使用 `-version:N` 选项以Java版本 `N` 启动应用程序。
- en: Java’s command-line tools and the system property `java.version` report their
    version as `9.${MINOR}.${SECURITY}.${PATCH}` (in Java 9) or as `${FEATURE}.${INTERIM}.${UPDATE}.${PATCH}`
    (in Java 10 and later), meaning on Java X they start with `X` instead of `1.x`.
    A new API `Runtime.Version` makes parsing that property unnecessary.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java的命令行工具和系统属性 `java.version` 报告的版本为 `9.${MINOR}.${SECURITY}.${PATCH}`（在Java
    9中）或为 `${FEATURE}.${INTERIM}.${UPDATE}.${PATCH}`（在Java 10及以后），这意味着在Java X中它们以
    `X` 开头而不是 `1.x`。一个新的API `Runtime.Version` 使得解析该属性变得不再必要。
- en: 'The following tools were removed:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下工具已被移除：
- en: 'In Java 9: JavaDB, VisualVM, `hprof`, `jhat`, `java-rmi.exe`, `java-rmi.cgi`,
    and `native2ascii`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 9 中：JavaDB、VisualVM、`hprof`、`jhat`、`java-rmi.exe`、`java-rmi.cgi` 和 `native2ascii`
- en: 'In Java 10: `policytool`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 10 中：`policytool`
- en: 'In Java 11: `idlj`, `orbd`, `schemagen`, `servertool`, `tnameserv`, `wsgen`,
    `wsimport`, and `xjc`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 11 中：`idlj`、`orbd`、`schemagen`、`servertool`、`tnameserv`、`wsgen`、`wsimport`
    和 `xjc`
- en: The single underscore is no longer a valid identifier.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单下划线不再是有效的标识符。
- en: The JNLP syntax has been updated to conform with the XML specification, so you
    may have to update your JNLP files.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JNLP语法已更新以符合XML规范，因此您可能需要更新您的JNLP文件。
- en: Each Java version removes deprecated JVM command-line options, which may break
    some of your scripts.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Java版本都会删除已弃用的JVM命令行选项，这可能会破坏您的某些脚本。
- en: Java 9 deprecates the Applet technology and Java Web Start, and Java 11 removes
    them.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9 废弃了 Applet 技术和 Java Web Start，Java 11 则移除了它们。
- en: '7'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '7'
- en: Recurring challenges when running on Java 9 or later
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Java 9 或更高版本上运行时的反复挑战
- en: This chapter covers
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Distinguishing standardized, supported, and internal JDK APIs
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分标准化的、受支持的以及内部的 JDK API
- en: Finding dependencies on JDK-internal APIs with JDeps
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JDeps 查找对 JDK 内部 API 的依赖
- en: Compiling and running code that depends on internal APIs
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译和运行依赖于内部 API 的代码
- en: Why a split package can make classes invisible
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么分割包会使类不可见
- en: Mending split packages
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复分割包
- en: 'Chapter 6 discusses some problems you may come up against when migrating a
    project to Java 9+. Once you’re done with that, though, you aren’t going to encounter
    those issues again unless you pick up pre-Java 9 dependencies. This chapter explores
    two challenges you might still need to deal with:'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 6 章讨论了在将项目迁移到 Java 9+ 时可能会遇到的一些问题。一旦完成这些，除非你选择使用 Java 9 之前的依赖项，否则你将不会再次遇到这些问题。本章探讨了两个你可能仍然需要解决的问题：
- en: Relying on internal APIs leads to compile errors (section 7.1). This is true
    for JDK-internal APIs, such as classes from `sun.*` packages, but also for code
    internal to the libraries or frameworks you depend on.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于内部 API 会导致编译错误（第 7.1 节）。这适用于 JDK 内部 API，例如来自 `sun.*` 包的类，也适用于你依赖的库或框架内部的代码。
- en: 'Splitting packages across artifacts causes compile-time and runtime errors
    (section 7.2). Again, this can happen between your code and JDK modules as well
    as between any other two artifacts: for example, your code and a third-party dependency.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工件之间分割包会导致编译时和运行时错误（第 7.2 节）。同样，这可能会发生在你的代码和 JDK 模块之间，以及任何其他两个工件之间：例如，你的代码和第三方依赖项。
- en: 'Just like the problems we’ve discussed so far, you’ll also have to work through
    these two issues when getting your project to work on Java 9+, but it doesn’t
    stop there: you’ll occasionally encounter them, even after migration, when working
    on code or pulling in new dependencies. Dependencies on module internals and split
    packages cause trouble regardless of the kinds of modules involved. You’re just
    as likely to encounter them with class-path code and platform modules (the migration
    scenario) as with application modules (a scenario in which you’re already running
    on Java 9 or later and are using modules).'
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就像我们之前讨论的问题一样，当你的项目需要在 Java 9+ 上运行时，你也必须解决这两个问题，但这并不仅限于此：即使迁移之后，在编写代码或引入新依赖项时，你偶尔也会遇到这些问题。无论涉及的是哪种类型的模块，对模块内部和分割包的依赖都会引起麻烦。你遇到这些问题的可能性与使用类路径代码和平台模块（迁移场景）一样，与使用应用程序模块（你已经在
    Java 9 或更高版本上运行并使用模块的场景）一样。
- en: This chapter shows how to break a module’s encapsulation and how to mend package
    splits, regardless of the context in which these situations occur. Together with
    chapter 6, this prepares you for most things that could go wrong during a migration.
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章展示了如何打破模块的封装以及如何修复包分割，无论这些情况发生在何种背景下。与第 6 章一起，这为你准备在迁移过程中可能出现的几乎所有问题。
- en: About the class path
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于类路径
- en: 'In case you didn’t read the note in chapter 6, I want to repeat it here:'
  id: totrans-250
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你在第 6 章中没有阅读到注意事项，我想在这里重复一遍：
- en: The class path is still fully functional, and during a migration to Java 9+
    you’ll continue to use it instead of the module path.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径仍然完全有效，在迁移到 Java 9+ 的过程中，你将继续使用它而不是模块路径。
- en: Even then, the module system is still in play, particularly regarding strong
    encapsulation.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使如此，模块系统仍然在发挥作用，尤其是在强封装方面。
- en: Code on the class path will automatically read most modules (but not all; check
    section 6.1), so they’re available at compile time or run time without additional
    configuration.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径上的代码将自动读取大多数模块（但不是全部；请参阅第 6.1 节），因此它们在编译时或运行时无需额外配置即可可用。
- en: 7.1 Encapsulation of internal APIs
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1 内部 API 的封装
- en: One of the module system’s biggest selling points is strong encapsulation. As
    section 3.3 explains in depth, we can finally make sure only supported APIs are
    accessible to outside code while keeping implementation details hidden.
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统最大的卖点之一是强封装。正如第 3.3 节深入解释的那样，我们终于可以确保只有受支持的 API 对外部代码可访问，同时隐藏实现细节。
- en: 'The inaccessibility of internal APIs applies to the platform modules shipped
    with the JDK, where only `java.*` and`javax.*` packages are fully supported. As
    an example, this happens when you try to compile a class with a static dependency
    (meaning an import or a fully qualified class name, as opposed to reflective access)
    on `NimbusLookAndFeel` in the now-encapsulated package `com.sun.java.swing.plaf.nimbus`:'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 内部 API 的不可访问性适用于与 JDK 一起分发的平台模块，其中只有 `java.*` 和 `javax.*` 包得到完全支持。例如，当您尝试编译一个在现在已封装的包
    `com.sun.java.swing.plaf.nimbus` 中对 `NimbusLookAndFeel` 有静态依赖（意味着导入或完全限定的类名，而不是反射访问）的类时，就会发生这种情况：
- en: '`> error: package com.sun.java.swing.plaf.nimbus is not visible > import com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel;
    > ^ > (package com.sun.java.swing.plaf.nimbus is declared > in module java.desktop,
    which does not export it) > 1 error`'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 错误：包 com.sun.java.swing.plaf.nimbus 不可见 > 导入 com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel;
    > ^ > （包 com.sun.java.swing.plaf.nimbus 已在模块 java.desktop 中声明，但没有导出它） > 1 个错误`'
- en: Surprisingly, many libraries and frameworks, but also application code (often
    the more important parts), use classes from `sun.*` or `com.sun.*` packages, most
    of which are inaccessible from Java 9 on. In this section, I’ll show you how to
    find such dependencies and what to do about them.
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 令人惊讶的是，许多库和框架，甚至应用代码（通常是更重要的部分），都使用了来自 `sun.*` 或 `com.sun.*` 包的类，其中大多数在 Java
    9 及以后版本中无法访问。在本节中，我将向您展示如何找到这样的依赖项以及如何处理它们。
- en: 'But why discuss that? If internal APIs are inaccessible, there’s nothing to
    talk about, right? Well, it’s time to let you in on something: they’re not totally
    inaccessible. At run time, everything will continue to work until the next major
    Java release (although you may get some undesired warning messages); and with
    control over the command line, any package can be made accessible at compile time.
    (I think I just heard a sigh of relief—was that you?)'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但为什么要讨论这个呢？如果内部 API 不可访问，那就没有什么可讨论的，对吧？好吧，是时候让您知道一些事情了：它们并不是完全不可访问。在运行时，一切都将继续工作，直到下一个主要的
    Java 版本（尽管您可能会收到一些不期望的警告消息）；并且通过控制命令行，任何包都可以在编译时被访问。（我想我听到了一声松了一口气——那是你吗？）
- en: Section 9.1.4 discusses the broader implications of using command-line options
    to configure the module system; here we focus on solving the immediate problem.
    We’ll distinguish between static and reflective and between compile-time and runtime
    access (sections 7.1.3 and 7.1.4) because there are some critical differences.
    But before we get to that, you need to know exactly what constitutes an internal
    API and how the Java Dependency Analysis Tool (JDeps) can help find problematic
    code in your project and your dependencies.
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 9.1.4 节讨论了使用命令行选项配置模块系统的更广泛影响；在这里，我们专注于解决当前问题。我们将区分静态和反射以及编译时和运行时访问（第 7.1.3
    和 7.1.4 节），因为存在一些关键差异。但在我们深入探讨之前，您需要确切了解内部 API 的构成以及 Java 依赖分析工具（JDeps）如何帮助您在项目和依赖项中找到有问题的代码。
- en: TIP If you’re not sure how exactly reflection works, have a look at appendix
    B, which gives a brief introduction. Also, in this section we focus on reflective
    access into the JDK; for a more general view of reflection in a modular world,
    see chapter 12.
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提示：如果您不确定反射是如何工作的，请参阅附录 B，其中提供了简要介绍。此外，在本节中，我们专注于对 JDK 的反射访问；对于模块化世界中反射的更一般性观点，请参阅第
    12 章。
- en: When you’re done with this section, it will be an easy task for you to break
    open modules to benefit from APIs their maintainers didn’t want you to use. More
    important, you’ll be able to evaluate the benefits and drawbacks of that strategy,
    so you can make an informed decision about whether it’s worth going down that
    road.
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您完成本节后，您将能够轻松地打开模块以利用维护者不希望您使用的 API。更重要的是，您将能够评估该策略的利弊，以便您可以在是否值得走这条路方面做出明智的决定。
- en: 7.1.1 INTERNAL APIS UNDER THE MICROSCOPE
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.1 内部 API 的显微镜下
- en: Which APIs are internal? In general, every class that’s not public or not in
    an exported package—and this rule fully applies to application modules. Regarding
    the JDK, the answer isn’t that simple, though. On top of the already historically
    complicated situation with standardized, supported, and internal APIs, Java 9+
    adds a layer of complexity by making a special case for some APIs and removing
    others. Let’s unravel the situation step by step.
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪些 API 是内部的？一般来说，每个既不是公共的也不是在导出包中的类——这个规则完全适用于应用模块。至于 JDK，答案并不那么简单。在标准化、受支持和内部
    API 的历史复杂情况之上，Java 9+ 通过对某些 API 进行特殊处理并删除其他 API，增加了一层复杂性。让我们一步一步地解开这个情况。
- en: 'THREE KINDS OF JDK APIS: STANDARDIZED, SUPPORTED, AND INTERNAL'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDK API 的三种类型：标准化、支持和内部
- en: 'Historically speaking, the Java Runtime Environment (JRE) has three kinds of
    APIs:'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从历史的角度来看，Java 运行时环境（JRE）有三种类型的 API：
- en: The public classes found in `java.*` and `javax.*` packages are standardized
    and fully supported across all JREs. Using only these makes for the most portable
    code.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `java.*` 和 `javax.*` 包中找到的公共类是标准化的，并且在所有 JRE 中完全支持。仅使用这些类可以编写最可移植的代码。
- en: Some `com.sun.*` and `jdk.*` packages and some classes they contain are marked
    with the `jdk.Exported` annotation, in which case they’re supported by Oracle
    but not necessarily present in non-Oracle JREs. Depending on these binds code
    to specific JREs.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 `com.sun.*` 和 `jdk.*` 包以及它们包含的一些类被标记为 `jdk.Exported` 注解，在这种情况下，它们由 Oracle
    支持，但并不一定存在于非 Oracle JRE 中。这些绑定将代码绑定到特定的 JRE。
- en: Most `com.sun.*` packages and all `sun.*` packages as well as all nonpublic
    classes are internal and can change between different versions and JREs. Depending
    on these is the most unstable, because such code could theoretically stop working
    on any minor update.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数 `com.sun.*` 包以及所有 `sun.*` 包以及所有非公共类都是内部的，并且可以在不同的版本和 JRE 之间更改。依赖这些是最不稳定的，因为这样的代码理论上可能在任何小版本更新中停止工作。
- en: 'With Java 9+ and the module system in play, these three kinds of APIs—standardized,
    supported, and internal—still exist. Whether a module exports a package is a key
    indicator but obviously doesn’t suffice to demarcate three categories. The other
    indicator is the module’s name. As you may recall from section 3.1.4, platform
    modules are split into those defined by the Java specification (prefixed with
    java.*) and JDK-specific ones (prefixed with jdk.*):'
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Java 9+ 和模块系统的作用下，这三种类型的 API——标准化、支持和内部——仍然存在。一个模块是否导出包是一个关键指标，但显然不足以划分三个类别。另一个指标是模块的名称。如您在
    3.1.4 节中回忆的那样，平台模块分为由 Java 规范定义的（以 java.* 前缀）和 JDK 特定的（以 jdk.* 前缀）：
- en: The public classes found in packages exported by java.* modules (these can be
    `java.\*` and `javax.*` packages) are standardized.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 java.* 模块导出的包中找到的公共类（这些可以是 `java.*` 和 `javax.*` 包）是标准化的。
- en: The public classes found in packages exported by jdk.* modules aren’t standardized
    but are supported on Oracle’s and OpenJDK’s JDK.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 jdk.* 模块导出的包中找到的公共类不是标准化的，但在 Oracle 和 OpenJDK 的 JDK 上得到支持。
- en: All other classes are internal APIs.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他类都是内部 API。
- en: Which specific classes are standardized, supported, or internal is largely unchanged
    from Java 8 to Java 9+. As a consequence, many classes in `com.sun.*` and all
    classes in `sun.*` are internal APIs just as they were before. The difference
    is that the module system turns this convention into an actively enforced distinction.
    [Figure 7.1](part0021.html#filepos830743) shows the split where internal APIs
    are not exported.
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从 Java 8 到 Java 9+，哪些具体的类被标准化、支持或内部化几乎没有变化。因此，`com.sun.*` 中的许多类和 `sun.*` 中的所有类都像之前一样是内部
    API。区别在于模块系统将这种约定转化为一个积极执行的区分。[图 7.1](part0021.html#filepos830743) 展示了内部 API 未导出的分割点。
- en: '![](../images/00074.jpeg)'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00074.jpeg)'
- en: '[Figure 7.1](part0021.html#filepos830379) In Java 8 (left), package names and
    the rarely seen `@jdk.Exported` annotation decided whether an API was standardized,
    supported, or internal. From Java 9 on (right), module names and export directives
    fill this role.'
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 7.1](part0021.html#filepos830379) 在 Java 8（左侧），包名和很少看到的 `@jdk.Exported`
    注解决定了 API 是否标准化、支持或内部化。从 Java 9 开始（右侧），模块名和导出指令扮演了这一角色。'
- en: That the jdk.* modules aren’t standardized is only a convention, and the module
    system is unaware of it. So although it may not be wise to depend on their exported
    APIs, the JPMS won’t encapsulate them, and none of the command-line options we’ll
    discuss are necessary. Here, when I talk about internal APIs, I mean those the
    module system makes inaccessible because classes aren’t public or packages aren’t
    exported.
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: jdk.* 模块不是标准化的只是一个约定，模块系统对此一无所知。因此，尽管依赖它们的导出 API 可能并不明智，但 JPMS 不会封装它们，我们讨论的任何命令行选项都不是必要的。在这里，当我提到内部
    API 时，我指的是模块系统使其不可访问的类，因为类不是公共的或包没有导出。
- en: A SPECIAL CASE FOR THE INFAMOUS SUN.MISC.UNSAFE
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于臭名昭著的 `sun.misc.Unsafe`
- en: As you might imagine, the original idea was to encapsulate every API that was
    internal prior to Java 9\. That caused a ruckus when the larger Java community
    realized it in 2015\. Although the average Java developer may only occasionally
    use internal APIs, many of the best-known libraries and frameworks do so frequently,
    and some of their most-critical features depend on it.
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如你所想，最初的想法是封装Java 9之前的所有内部API。当2015年更大的Java社区意识到这一点时，引起了骚动。尽管平均Java开发者可能只偶尔使用内部API，但许多最知名的库和框架经常这样做，它们的一些最关键功能依赖于它。
- en: The poster child for this situation is `sun.misc.Unsafe`, a class that, given
    its package name, is obviously internal. It offers functionality that’s uncommon
    for Java and, as the class name suggests, unsafe. (Talk about expressive names!)
    Maybe the best example is direct memory access, which the JDK has to perform occasionally.
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种情况的典型代表是`sun.misc.Unsafe`类，根据其包名，显然是内部的。它提供了Java中不常见的功能，并且正如类名所暗示的，是不安全的。（说到表达性的名称！）也许最好的例子是直接内存访问，这是JDK偶尔必须执行的操作。
- en: But it went beyond the JDK. With `Unsafe` readily available, some libraries,
    particularly those focused on high performance, started using it; over time, large
    parts of the ecosystem ended up directly or indirectly depending on it. The prospect
    of that class and others like it getting encapsulated led to the community uproar.
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但它超出了JDK的范围。由于`Unsafe`易于使用，一些库，尤其是那些专注于高性能的库，开始使用它；随着时间的推移，生态系统中很大一部分直接或间接地依赖于它。这种类和其他类似类被封装的前景导致了社区的强烈反响。
- en: 'Following that, the team working on Project Jigsaw decided to allow a smoother
    migration path. A survey of the existing internal APIs and their use outside the
    JDK yielded this result:'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 随后，Project Jigsaw团队决定允许更平滑的迁移路径。对现有内部API及其在JDK之外的使用的调查产生了以下结果：
- en: Most affected APIs are rarely or never used.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数受影响的API很少或从未使用。
- en: Some affected APIs are occasionally used, but standardized alternatives existed
    before Java 9\. A prime example is the `BASE64Encoder`/`BASE64Decoder` pair in
    `sun.misc`, which can be replaced with `java.util.Base64`.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些受影响的API偶尔使用，但在Java 9之前已经存在标准化替代方案。一个典型的例子是`sun.misc`中的`BASE64Encoder`/`BASE64Decoder`对，它可以被`java.util.Base64`替代。
- en: Some affected APIs are used occasionally but deliver critical functionality,
    for which no alternatives exist. This is where `sun.misc.Unsafe` can be found.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些受影响的API偶尔使用，但提供关键功能，没有替代方案。这就是`sun.misc.Unsafe`可以找到的地方。
- en: The decision was made to encapsulate the first two kinds but leave the third
    accessible for at least another major Java version. Exporting them from their
    respective modules would be confusing, though, because it would make them look
    like supported or even standardized APIs, which they’re most definitely not. How
    better to make that point than by creating a suitably named module?
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 决定封装前两种类型，但至少在下一个主要Java版本中保持第三种类型可访问。但从各自的模块导出它们会令人困惑，因为这会使它们看起来像是受支持或甚至标准化的API，而它们绝对不是。还有什么比创建一个合适命名的模块更能说明这一点呢？
- en: 'The critical APIs, for which no replacements existed before Java 9, are exported
    by the module jdk.unsupported. As the name suggests, it’s JDK-specific (only guaranteed
    to be present on Oracle JDK and OpenJDK) and unsupported (content may change in
    the next release). In Java 9 to 11, it contains the following classes:'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 9之前没有替代方案的临界API由模块jdk.unsupported导出。正如其名称所暗示的，它是JDK特定的（仅保证在Oracle JDK和OpenJDK上存在）且不受支持（内容可能在下一个版本中更改）。在Java
    9到11中，它包含以下类：
- en: 'From `sun.misc`: `Signal`, `SignalHandler`, and `Unsafe`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`sun.misc`的：`Signal`、`SignalHandler`和`Unsafe`
- en: 'From `sun.reflect`: `Reflection` and `ReflectionFactory`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`sun.reflect`的：`Reflection`和`ReflectionFactory`
- en: 'From `com.sun.nio.file`: `ExtendedCopyOption`, `ExtendedOpenOption`, `ExtendedWatchEventModifier`,
    and `SensitivityWatchEventModifier`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`com.sun.nio.file`的：`ExtendedCopyOption`、`ExtendedOpenOption`、`ExtendedWatchEventModifier`和`SensitivityWatchEventModifier`
- en: If your code or dependencies depend on these classes (section 7.1.2 shows how
    to find out), then even though they were internal API before Java 9, you don’t
    need to do anything to keep using them. For now. As standardized alternatives
    for their functionality are released (like variable handles, which replace parts
    of `Unsafe`), they will be encapsulated. I strongly recommend you have a close
    look at your use of these classes and prepare for their eventual disappearance.
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你的代码或依赖项依赖于这些类（第7.1.2节展示了如何找出），那么尽管在Java 9之前它们是内部API，但你目前不需要做任何事情来继续使用它们。随着它们功能的标准替代方案（如变量句柄，它替代了`Unsafe`的一部分）的发布，它们将被封装。我强烈建议你仔细检查对这些类的使用，并为它们最终消失做好准备。
- en: REMOVED APIS
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 已移除的API
- en: 'Although some internal APIs remain available for a few more years and most
    have been encapsulated, a few met an even harsher fate and were removed or renamed.
    This breaks code that uses them beyond the reach of any transition period and
    command-line option. Here they are:'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管一些内部API在接下来的几年内仍然可用，大多数已经被封装，但有一些遭遇了更严厉的命运，被移除或重命名。这打破了使用它们的代码，超出了任何过渡期和命令行选项的范围。以下是它们：
- en: 'Everything in `sun.misc` and `sun.reflect` that isn’t part of jdk.unsupported:
    for example, `sun.misc.BASE64Encoder`, `sun.misc.BASE64Decoder`, `sun.misc.Cleaner`,
    and `sun.misc.Service`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.misc` 和 `sun.reflect` 中不属于 jdk.unsupported 部分的所有内容：例如，`sun.misc.BASE64Encoder`、`sun.misc.BASE64Decoder`、`sun.misc.Cleaner`
    和 `sun.misc.Service`'
- en: '`com.sun.image.codec.jpeg` and `sun.awt.image.codec`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.sun.image.codec.jpeg` 和 `sun.awt.image.codec`'
- en: '`com.apple.concurrent`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.apple.concurrent`'
- en: '`com.sun.security.auth.callback.DialogCallbackHandler`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.sun.security.auth.callback.DialogCallbackHandler`'
- en: Methods `addPropertyChangeListener` and removePropertyChangeListener on `java.util.logging.LogManager`,
    `java.util.jar.Pack200.Packer`, and `java.util.jar.Pack200.Unpacker` (deprecated
    in Java 8)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.logging.LogManager`、`java.util.jar.Pack200.Packer` 和 `java.util.jar.Pack200.Unpacker`
    上的 `addPropertyChangeListener` 和 `removePropertyChangeListener` 方法（在Java 8中被弃用）'
- en: Methods with parameters or return types from `java.awt.peer` and `java.awt.dnd.peer`
    (these packages were never standardized and are internal in Java 9 and later)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数或返回类型来自 `java.awt.peer` 和 `java.awt.dnd.peer` 的方法（这些包从未标准化，并且在Java 9及以后的版本中是内部的）
- en: Most of these classes and packages have alternatives, and you can use JDeps
    to learn about them.
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数这些类和包都有替代方案，你可以使用 JDeps 来了解它们。
- en: 7.1.2 ANALYZING DEPENDENCIES WITH JDEPS
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.2 使用JDeps分析依赖关系
- en: Now that we’ve discussed the distinction between standardized, supported, and
    internal APIs and the special case of jdk.unsupported, it’s time to apply that
    knowledge to a real-life project. For it to be compatible with Java 9+, you need
    to figure out which internal APIs it depends on.
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了标准化、受支持和内部API之间的区别以及 jdk.unsupported 的特殊情况，现在是时候将这方面的知识应用到实际项目中。为了与Java
    9+兼容，你需要找出它所依赖的内部API。
- en: Just going through the project’s code base won’t cut it—you’re in trouble if
    the libraries and frameworks it depends on cause problems, so you need to analyze
    them as well. This sounds like horrible manual work, sifting through a lot of
    code in the search for references to such APIs. Fortunately, there’s no need to
    do that.
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仅通过查看项目的代码库是不够的——如果它所依赖的库和框架出现问题，你就会遇到麻烦，因此你需要分析它们。这听起来像是一项可怕的手动工作，需要筛选大量代码以查找对这些API的引用。幸运的是，没有必要这样做。
- en: Since Java 8, the JDK ships with the command-line Java Dependency Analysis Tool
    (JDeps). It analyses Java bytecode, meaning `.class` files and JARs, and records
    all statically declared dependencies between classes, which can then be filtered
    or aggregated. It’s a neat tool for visualizing and exploring the various dependency
    graphs I’ve been talking about. Appendix D provides a JDeps primer; you may want
    to read it if you’ve never used JDeps. It isn’t strictly necessary to understand
    this section, though.
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自Java 8以来，JDK附带命令行Java依赖分析工具（JDeps）。它分析Java字节码，即 `.class` 文件和JARs，并记录类之间所有静态声明的依赖关系，然后可以进行过滤或聚合。这是一个用于可视化探索我一直在谈论的各种依赖图的
    neat 工具。附录D提供了JDeps入门指南；如果你从未使用过JDeps，你可能想阅读它。尽管如此，理解这一节并不是严格必要的。
- en: 'One feature is particularly interesting in the context of internal APIs: the
    option `--jdk-internals` makes JDeps list all internal APIs that the referenced
    JARs depend on, including those exported by jdk.unsupported. The output contains
    the following:'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在内部API的背景下，有一个特性特别有趣：选项 `--jdk-internals` 使得 JDeps 列出所有引用的JARs所依赖的内部API，包括由
    jdk.unsupported 导出的API。输出包含以下内容：
- en: The analyzed JAR and the module containing the problematic API
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析的 JAR 文件和包含问题 API 的模块
- en: The specific classes involved
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及的具体类
- en: The reason that dependency is problematic
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种依赖关系成为问题的原因
- en: 'I’m going to use JDeps on Scaffold Hunter, “a Java-based open source tool for
    the visual analysis of data sets.” The following command analyzes internal dependencies:'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我将使用 JDeps 对 Scaffold Hunter 进行分析，Scaffold Hunter 是“一个基于 Java 的开源工具，用于数据集的可视化分析。”以下命令分析内部依赖关系：
- en: '`$ jdeps --jdk-internals` [`①`](part0021.html#filepos845028)`-R --class-path
    ''libs/*''` [`②`](part0021.html#filepos845379)`scaffold-hunter-2.6.3.jar` [`③`](part0021.html#filepos845724)'
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jdeps --jdk-internals` [`①`](part0021.html#filepos845028)`-R --class-path
    ''libs/*''` [`②`](part0021.html#filepos845379)`scaffold-hunter-2.6.3.jar` [`③`](part0021.html#filepos845724)'
- en: ①
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Tells JDeps to analyze use of internal APIs
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 告知 JDeps 分析内部 API 的使用
- en: ②
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Recursively analyzes all dependencies
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 递归分析所有依赖
- en: ③
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Starts with the application JAR
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从应用程序 JAR 文件开始
- en: 'The output begins with mentions of split packages, which we’ll look at in section
    7.2\. It then reports on problematic dependencies, of which a few are shown next.
    The output is detailed and gives all the information you need to examine the code
    in question or open issues in the respective projects:'
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出以提及拆分包开始，我们将在第 7.2 节中探讨。然后报告有问题的依赖关系，其中一些将在下面展示。输出详细，提供了检查相关代码或分别在项目中打开问题的所有所需信息：
- en: '`> batik-codec.jar -> JDK removed internal API` [`①`](part0021.html#filepos848801)`>
    JPEGImageWriter -> com.sun.image.codec.jpeg.JPEGCodec` [`②`](part0021.html#filepos849148)`>
    JDK internal API (JDK removed internal API)` [`③`](part0021.html#filepos849533)
    `> JPEGImageWriter -> com.sun.image.codec.jpeg.JPEGEncodeParam > JDK internal
    API (JDK removed internal API) > JPEGImageWriter -> com.sun.image.codec.jpeg.JPEGImageEncoder
    > JDK internal API (JDK removed internal API) # [...]` `> guava-18.0.jar -> jdk.unsupported`
    [`④`](part0021.html#filepos849867)`> Striped64 -> sun.misc.Unsafe` [`⑤`](part0021.html#filepos850208)
    `> JDK internal API (jdk.unsupported) > Striped64$1 -> sun.misc.Unsafe > JDK internal
    API (jdk.unsupported) > Striped64$Cell -> sun.misc.Unsafe > JDK internal API (jdk.unsupported)
    # [...]` `> scaffold-hunter-2.6.3.jar -> java.desktop` [`⑥`](part0021.html#filepos850592)
    `> SteppedComboBox -> com.sun.java.swing.plaf.windows.WindowsComboBoxUI > JDK
    internal API (java.desktop) > SteppedComboBox$1 -> com.sun.java.swing.plaf.windows.WindowsComboBoxUI
    > JDK internal API (java.desktop)`'
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> batik-codec.jar -> JDK 已删除的内部 API` [`①`](part0021.html#filepos848801)`>
    JPEGImageWriter -> com.sun.image.codec.jpeg.JPEGCodec` [`②`](part0021.html#filepos849148)`>
    JDK 内部 API (JDK 已删除的内部 API)` [`③`](part0021.html#filepos849533) `> JPEGImageWriter
    -> com.sun.image.codec.jpeg.JPEGEncodeParam > JDK 内部 API (JDK 已删除的内部 API) > JPEGImageWriter
    -> com.sun.image.codec.jpeg.JPEGImageEncoder > JDK 内部 API (JDK 已删除的内部 API) # [...]`
    `> guava-18.0.jar -> jdk.unsupported` [`④`](part0021.html#filepos849867)`> Striped64
    -> sun.misc.Unsafe` [`⑤`](part0021.html#filepos850208) `> JDK 内部 API (jdk.unsupported)
    > Striped64$1 -> sun.misc.Unsafe > JDK 内部 API (jdk.unsupported) > Striped64$Cell
    -> sun.misc.Unsafe > JDK 内部 API (jdk.unsupported) # [...]` `> scaffold-hunter-2.6.3.jar
    -> java.desktop` [`⑥`](part0021.html#filepos850592) `> SteppedComboBox -> com.sun.java.swing.plaf.windows.WindowsComboBoxUI
    > JDK 内部 API (java.desktop) > SteppedComboBox$1 -> com.sun.java.swing.plaf.windows.WindowsComboBoxUI
    > JDK 内部 API (java.desktop)`'
- en: ①
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: batik-codec depends on the removed API.
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: batik-codec 依赖于已删除的 API。
- en: ②
  id: totrans-321
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: JPEGImageWriter (I truncated the package) depends on a few different classes.
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPEGImageWriter（我已截断包名）依赖于几个不同的类。
- en: ③
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: States what the problem is
  id: totrans-324
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明问题是什么
- en: ④
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Guava depends on jdk.unsupported.
  id: totrans-326
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guava 依赖于 jdk.unsupported。
- en: ⑤
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: Striped64 depends on sun.misc.Unsafe, and so do two of its internal classes.
  id: totrans-328
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Striped64 依赖于 sun.misc.Unsafe，以及其两个内部类也是如此。
- en: ⑥
  id: totrans-329
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑥
- en: Scaffold Hunter depends on classes internal to java.desktop.
  id: totrans-330
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Scaffold Hunter 依赖于 java.desktop 内部的类。
- en: 'JDeps ends with the following note, which gives useful background information
    and suggestions for some of the discovered problems:'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDeps 以以下注释结束，提供了有关一些发现问题的有用背景信息和建议：
- en: '`> Warning: JDK internal APIs are unsupported and private to JDK > implementation
    that are subject to be removed or changed incompatibly > and could break your
    application. Please modify your code to eliminate > dependence on any JDK internal
    APIs. For the most recent update on JDK > internal API replacements, please check:
    > https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool > >
    JDK Internal API Suggested Replacement > ---------------- ---------------------
    > com.sun.image.codec.jpeg.JPEGCodec Use javax.imageio @since 1.4 > com.sun.image.codec.jpeg.JPEGDecodeParam
    Use javax.imageio @since 1.4 > com.sun.image.codec.jpeg.JPEGEncodeParam Use javax.imageio
    @since 1.4 > com.sun.image.codec.jpeg.JPEGImageDecoder Use javax.imageio @since
    1.4 > com.sun.image.codec.jpeg.JPEGImageEncoder Use javax.imageio @since 1.4 >
    com.sun.image.codec.jpeg.JPEGQTable Use javax.imageio @since 1.4 > com.sun.image.codec.jpeg.TruncatedFileException
    > Use javax.imageio @since 1.4 > sun.misc.Unsafe See JEP 260 > sun.reflect.ReflectionFactory
    See JEP 260`'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 警告：JDK 内部 API 不受支持，且仅限于 JDK 实现的私有 API，可能会被移除或以不兼容的方式更改，从而破坏您的应用程序。请修改您的代码以消除对任何
    JDK 内部 API 的依赖。有关 JDK 内部 API 替换的最新更新，请查看：> https://wiki.openjdk.java.net/display/JDK8/Java+Dependency+Analysis+Tool
    > > JDK 内部 API 建议替换 > ---------------- --------------------- > com.sun.image.codec.jpeg.JPEGCodec
    使用 javax.imageio @since 1.4 > com.sun.image.codec.jpeg.JPEGDecodeParam 使用 javax.imageio
    @since 1.4 > com.sun.image.codec.jpeg.JPEGEncodeParam 使用 javax.imageio @since
    1.4 > com.sun.image.codec.jpeg.JPEGImageDecoder 使用 javax.imageio @since 1.4 >
    com.sun.image.codec.jpeg.JPEGImageEncoder 使用 javax.imageio @since 1.4 > com.sun.image.codec.jpeg.JPEGQTable
    使用 javax.imageio @since 1.4 > com.sun.image.codec.jpeg.TruncatedFileException
    > 使用 javax.imageio @since 1.4 > sun.misc.Unsafe 查看 JEP 260 > sun.reflect.ReflectionFactory
    查看 JEP 260`'
- en: 7.1.3 COMPILING AGAINST INTERNAL APIS
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.3 编译针对内部 API
- en: The purpose of strong encapsulation is that the module system by default doesn’t
    let you use internal APIs. This affects the compilation and runtime behavior of
    any Java version starting with 9\. Here we discuss compilation—section 7.1.4 addresses
    runtime behavior. In the beginning, strong encapsulation will mostly be relevant
    for platform modules, but as your dependencies are modularized, you’ll see the
    same barrier around their code.
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 强封装的目的在于模块系统默认不允许您使用内部 API。这会影响从 Java 9 开始的任何 Java 版本的编译和运行时行为。在这里，我们讨论编译——第
    7.1.4 节讨论了运行时行为。最初，强封装主要与平台模块相关，但随着您的依赖项模块化，您将看到它们代码周围存在相同的障碍。
- en: Sometimes, though, you may be in a situation where you absolutely have to use
    a public class in a non-exported package to solve the problem at hand. Fortunately,
    that’s possible even with the module system in place. (I’m stating the obvious,
    but I want to point out that this is only a problem for your code, because your
    dependencies are already compiled—they will still be impacted by strong encapsulation,
    but only at run time.)
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，有时您可能处于必须使用非导出包中的公共类来解决当前问题的境地。幸运的是，即使在模块系统存在的情况下，这也是可能的。（我在说显而易见的事情，但我想指出，这仅是您代码的问题，因为您的依赖项已经编译——它们仍将受到强封装的影响，但仅限于运行时。）
- en: Exporting to a module
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 导出到模块
- en: The option `--add-exports ${module}/${package}=${reading-module}`, available
    for the `java` and `javac` commands, exports `${package}` of ${module} to ${reading-module}.
    Code in ${reading-module} can hence access all public types in `${package}`, but
    other modules can’t.
  id: totrans-337
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 `--add-exports ${module}/${package}=${reading-module}`，在 `java` 和 `javac`
    命令中可用，将 ${module} 的 ${package} 导出给 ${reading-module}。因此，${reading-module} 中的代码可以访问
    `${package}` 中的所有公共类型，但其他模块则不能。
- en: When setting ${reading-module} to `ALL-UNNAMED`, all code from the class path
    can access that package. When migrating to Java 9+, you’ll always use that placeholder—only
    once your own code runs in modules can you limit exports to specific modules.
  id: totrans-338
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当将 ${reading-module} 设置为 `ALL-UNNAMED` 时，类路径上的所有代码都可以访问该包。在迁移到 Java 9+ 时，您将始终使用该占位符——只有当您自己的代码在模块中运行时，您才能将导出限制为特定模块。
- en: Until now, exports were always untargeted, so being able to export to specific
    modules is a new aspect. This feature is available for module descriptors as well,
    as section 11.3 explains. Also, I’m being a little handwavy about what `ALL-UNNAMED`
    means. It’s connected to the unnamed module, which section 8.2 discusses in detail,
    but for now “all code from the class path” is a good approximation.
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，导出始终是无目标的，因此能够导出到特定模块是一个新的方面。此功能也适用于模块描述符，如第 11.3 节所述。此外，我在 `ALL-UNNAMED`
    的含义上有点含糊。它与未命名的模块相关，第 8.2 节详细讨论了这一点，但就目前而言，“类路径上的所有代码”是一个很好的近似。
- en: 'Let’s return to the code that caused the following compile error:'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们回到导致以下编译错误的代码：
- en: '`> error: package com.sun.java.swing.plaf.nimbus is not visible > import com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel;
    > ^ > (package com.sun.java.swing.plaf.nimbus is declared > in module java.desktop,
    which does not export it) > 1 error`'
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 错误：包com.sun.java.swing.plaf.nimbus不可见 > 导入com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel;
    > ^ > （包com.sun.java.swing.plaf.nimbus在模块java.desktop中声明，但没有导出它） > 1 个错误`'
- en: Here, some class (which I omitted from the output because it’s irrelevant) imports
    `NimbusLookAndFeel` from the encapsulated package `com.sun.java.swing.plaf.nimbus`.
    Note how the error message points out the specific problem, including the module
    that contains the class.
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里，某个类（由于它与问题无关，我已经从输出中省略）从封装的包`com.sun.java.swing.plaf.nimbus`中导入了`NimbusLookAndFeel`。注意错误信息如何指出具体问题，包括包含该类的模块。
- en: This clearly doesn’t work out of the box on Java 9, but what if you want to
    keep using it? Then you’d likely be making a mistake, because there’s a standardized
    alternative in `javax.swing.plaf.nimbus`; on Java 10, only that version remains,
    because the internal version is removed. But for the sake of this example, let’s
    say you still want to use the internal version—maybe to interact with legacy code
    that can’t be changed.
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这在Java 9中显然不能直接工作，但如果您想继续使用它呢？那么您可能是在犯一个错误，因为`javax.swing.plaf.nimbus`中有一个标准化的替代方案；在Java
    10中，只有这个版本保留了下来，因为内部版本已被移除。但为了这个示例，让我们假设您仍然想使用内部版本——也许是为了与无法更改的遗留代码进行交互。
- en: 'All you have to do to successfully compile against `com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel`
    is to add `--add-exports java.desktop/com.sun.java.swing.plaf.nimbus=ALL-UNNAMED`
    to the compiler command. If you do that manually, it will look similar to the
    following (all placeholders would have to be replaced with concrete values):'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要成功编译针对`com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel`的代码，您只需在编译器命令中添加`--add-exports
    java.desktop/com.sun.java.swing.plaf.nimbus=ALL-UNNAMED`即可。如果您手动这样做，它将类似于以下内容（所有占位符都必须替换为具体值）：
- en: '`$ javac --add-exports java.desktop/com.sun.java.swing.plaf.nimbus=ALL-UNNAMED
    --class-path ${dependencies} -d ${target-folder} ${source-files}`'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --add-exports java.desktop/com.sun.java.swing.plaf.nimbus=ALL-UNNAMED
    --class-path ${dependencies} -d ${target-folder} ${source-files}`'
- en: With a build tool, you’ll have to put the option somewhere in the build descriptor.
    Check your tool’s documentation to find out how to add command-line options for
    the compiler.
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用构建工具时，您需要在构建描述符中放置该选项的某个位置。请查阅您工具的文档以了解如何为编译器添加命令行选项。
- en: This way, code happily compiles against encapsulated classes. But it’s important
    to realize that you’ve only pushed the problem to run time! Adding this export
    on the command line only changes the one compilation—no information is put into
    the resulting bytecode that would allow that class to access the package during
    execution. You still have to figure out how to make it work at run time.
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样，代码可以愉快地编译针对封装类。但重要的是要意识到，您只是将问题推迟到了运行时！在命令行上添加此导出只改变了一次编译——没有将任何信息放入生成的字节码中，以允许该类在执行期间访问该包。您仍然需要弄清楚如何在运行时使其工作。
- en: 7.1.4 EXECUTING AGAINST INTERNAL APIS
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.4 对内部API的执行
- en: I mentioned that, at least in Java 9, 10, and 11, JDK-internal dependencies
    are still available at run time. With everything else I’ve been telling you, that
    should be a little surprising. Throughout the book, I’ve been touting the benefits
    of strong encapsulation and said it’s as important as visibility modifiers—so
    why isn’t it enforced at run time?
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我提到，至少在Java 9、10和11中，JDK内部依赖项在运行时仍然可用。结合我之前告诉您的所有内容，这应该有点令人惊讶。在整个书中，我一直强调强封装的好处，并说它和可见性修饰符一样重要——那么为什么在运行时不强制执行呢？
- en: 'Like many other Java quirks, this one was born from a dedication to backward
    compatibility: strong encapsulation of JDK internals will break a lot of applications.
    Even if it’s just the outdated use of the Nimbus look and feel, the application
    will crash. How many end users or IT departments would install Java 9+ if legacy
    apps stopped working? How many teams would develop against Java 9+ if few users
    had it available?'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就像许多其他Java怪癖一样，这个怪癖源于对向后兼容性的承诺：强封装JDK内部会破坏许多应用程序。即使只是过时的Nimbus外观和感觉的使用，应用程序也会崩溃。有多少最终用户或IT部门会在遗留应用程序停止工作后安装Java
    9+？有多少团队会在很少用户有Java 9+可用的情况下针对Java 9+进行开发？
- en: 'To make sure the module system doesn’t split the ecosystem in “pre Java 9”
    and “post Java 9,” the decision was made to grant code on the class path illegal
    access to JDK-internal APIs until at least Java 11\. Each of those aspects was
    chosen deliberately:'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了确保模块系统不会将生态系统分成“Java 9 之前”和“Java 9 之后”，决定授予类路径上的代码对 JDK 内部 API 的非法访问，直到至少
    Java 11。每个这些方面都是经过深思熟虑的：
- en: Code on the class path … —Running code from the module path expresses that it
    has been prepared for the module system, in which case there’s no need to make
    an exception. It’s hence limited to class-path code.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径上的代码 … ——从模块路径运行代码表示它已为模块系统做好准备，在这种情况下，没有必要做出例外。因此，它仅限于类路径代码。
- en: … to JDK-internal APIs —From a compatibility perspective, there’s no reason
    to grant access to application modules, because they didn’t exist before Java
    9\. So the exception is limited to platform modules.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: …到 JDK-internal APIs ——从兼容性的角度来看，没有理由授予应用程序模块访问权限，因为它们在 Java 9 之前不存在。因此，异常仅限于平台模块。
- en: … at least Java 11—If the exception were permanent, the incentive to update
    troublesome code would be much lower.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: …至少 Java 11——如果异常是永久的，那么更新麻烦代码的动力将会大大降低。
- en: As you saw in chapter 6, this doesn’t solve all problems an application may
    run into when being executed on Java 9, 10, or 11, but it will be more likely
    to run successfully.
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你在第 6 章中看到的，这并不能解决应用程序在 Java 9、10 或 11 上执行时可能遇到的所有问题，但它更有可能成功运行。
- en: MANAGING BLANKET ILLEGAL ACCESS TO JDK-INTERNAL APIS
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 管理对 JDK 内部 API 的全面非法访问
- en: 'For a successful migration, it’s important to understand the details behind
    the blanket illegal access to JDK-internal APIs; but exploring it will make your
    mental model of the module system more complicated. It helps to keep the big picture
    in mind: strong encapsulation disallows access to all internal APIs at compile
    time and run time. On top of that, a big exception was built, whose specific design
    was driven by compatibility concerns. It will disappear over time, though, bringing
    us back to the much more clear-cut behavior.'
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了成功迁移，了解对 JDK 内部 API 的全面非法访问背后的细节很重要；但探索它会使你对模块系统的心理模型更加复杂。保持大局意识有助于：强封装在编译时和运行时禁止访问所有内部
    API。此外，还建立了一个大异常，其具体设计是由兼容性考虑驱动的。然而，随着时间的推移，它将消失，使我们回到更加明确的行性行为。
- en: 'When allowing class-path code to access JDK-internal APIs, a distinction is
    made between code that statically depends on them and code that accesses them
    reflectively:'
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当允许类路径代码访问 JDK 内部 API 时，会区分静态依赖于它们的代码和通过反射访问它们的代码：
- en: Reflective access results in warnings. Because it’s impossible to exactly identify
    all such calls by static analysis, execution is the only time to reliably report
    them.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射访问会产生警告。由于静态分析无法精确识别所有此类调用，因此执行是唯一可靠报告它们的时间。
- en: Static access results in no warning. It can easily be discovered during compilation
    or with JDeps. Due to the omnipresence of static access, it’s also a performance-sensitive
    area, where checking for and occasionally emitting log messages is problematic.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态访问不会产生警告。它可以在编译期间或使用 JDeps 时轻松发现。由于静态访问的普遍存在，它也是一个性能敏感的区域，检查和偶尔发出日志消息是有问题的。
- en: 'The exact behavior can be configured with a command-line option. The `java`
    option `--illegal-access=${value}` manages how illegal access to JDK-internal
    APIs is handled, where `${value}` is one of the following:'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以使用命令行选项配置确切的行为。`java` 选项 `--illegal-access=${value}` 管理如何处理对 JDK 内部 API 的非法访问，其中
    `${value}` 是以下之一：
- en: '`permit` —Access to all JDK-internal APIs is permitted to code on the class
    path. For reflective access, a single warning is issued for the first access to
    each package.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permit` — 允许对类路径上的代码访问所有 JDK 内部 API。对于反射访问，每个包的第一次访问都会发出一个警告。'
- en: '`warn` —Behaves like `permit`, but a warning is issued for each reflective
    access.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warn` — 与 `permit` 的行为类似，但每次反射访问都会发出警告。'
- en: '`debug` —Behaves like `warn`, but a stack trace is included in each warning.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug` — 与 `warn` 的行为类似，但每个警告都包含堆栈跟踪。'
- en: '`deny` —The option for those who believe in strong encapsulation: all illegal
    access is forbidden by default.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deny` — 对于那些相信强封装的人来说：默认情况下禁止所有非法访问。'
- en: On Java 9 to 11, `permit` is the default value. In some future Java version,
    `deny` will become the default; and at some point the entire option may disappear,
    but I’m sure that will take a few more years.
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Java 9 到 11 中，`permit` 是默认值。在某些未来的 Java 版本中，`deny` 将成为默认值；并且在某些时候，整个选项可能会消失，但我确信这还需要几年时间。
- en: 'It looks like once you get troubling code past the compiler, either by using
    the Java 8 version or by adding the required options to the Java 9+ version, the
    Java 9+ runtime will begrudgingly execute it. To see `--illegal-access` in action,
    it’s time to finally look at the class that plays around with the internal Nimbus
    look and feel:'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 看起来，一旦你通过使用Java 8版本或向Java 9+版本添加所需选项，将麻烦代码通过编译器，Java 9+运行时会不情愿地执行它。要看到`--illegal-access`的实际效果，现在是时候最终查看那个玩弄内部Nimbus外观和感觉的类了：
- en: '`import com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel;  public class Nimbus
    {  public static void main(String[] args) throws Exception { NimbusLookAndFeel
    nimbus = new NimbusLookAndFeel(); System.out.println("Static access to " + nimbus);  Object
    nimbusByReflection = Class .forName("com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel")
    .getConstructor() .newInstance(); System.out.println("Reflective access to " +
    nimbusByReflection); }  }`'
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`import com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel;  public class Nimbus
    {  public static void main(String[] args) throws Exception { NimbusLookAndFeel
    nimbus = new NimbusLookAndFeel(); System.out.println("Static access to " + nimbus);  Object
    nimbusByReflection = Class .forName("com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel")
    .getConstructor() .newInstance(); System.out.println("Reflective access to " +
    nimbusByReflection); }  }`'
- en: 'It doesn’t do anything particularly useful, but it clearly tries to access
    `NimbusLookAndFeel` both statically and reflectively. To compile it, you need
    to use `--add-exports`, as described in the previous section. Running it is simpler:'
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它并没有做任何特别有用的事情，但它显然试图以静态和反射的方式访问`NimbusLookAndFeel`。要编译它，你需要使用前一个章节中描述的`--add-exports`。运行它则更简单：
- en: '`$ java --class-path ${class} j9ms.internal.Nimbus  > Static access to "Nimbus
    Look and Feel" > WARNING: An illegal reflective access operation has occurred
    > WARNING: Illegal reflective access by j9ms.internal.Nimbus > (file:...) to constructor
    NimbusLookAndFeel() > WARNING: Please consider reporting this to the maintainers
    > of j9ms.internal.Nimbus > WARNING: Use --illegal-access=warn to enable warnings
    of > further illegal reflective access operations > WARNING: All illegal access
    operations will be denied in a > future release > Reflective access to "Nimbus
    Look and Feel"`'
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --class-path ${class} j9ms.internal.Nimbus  > 静态访问到 "Nimbus Look and
    Feel" > 警告：发生了非法的反射访问操作 > 警告：j9ms.internal.Nimbus的非法反射访问 > (文件：...) 到构造函数NimbusLookAndFeel()
    > 警告：请考虑向j9ms.internal.Nimbus的维护者报告此问题 > 警告：使用--illegal-access=warn启用进一步非法反射访问操作的警告
    > 警告：在未来的版本中，所有非法访问操作都将被拒绝 > 反射访问到 "Nimbus Look and Feel"`'
- en: 'You can observe the behavior defined by the default option `--illegal-access=permit`:
    static access succeeds without comments, but reflective access results in a lengthy
    warning. Setting the option to `warn` would change nothing, because there’s only
    one access, and `debug` adds the stack trace for the troublesome call. With `deny`,
    you get the same messages you saw in section 3.3.3 when you tested the accessibility
    requirements:'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以观察到默认选项`--illegal-access=permit`定义的行为：静态访问成功，无需注释，但反射访问会导致一个冗长的警告。将选项设置为`warn`不会改变任何东西，因为只有一个访问，而`debug`会为麻烦的调用添加堆栈跟踪。使用`deny`，你会得到与3.3.3节中测试可访问性要求时看到相同的消息：
- en: '`$ java --class-path ${class} --illegal-access=deny j9ms.internal.Nimbus  >
    Exception in thread "main" java.lang.IllegalAccessError: > class j9ms.internal.Nimbus
    (in unnamed module @0x6bc168e5) cannot > access class com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel
    (in > module java.desktop) because module java.desktop does not export > com.sun.java.swing.plaf.nimbus
    to unnamed module @0x6bc168e5`'
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --class-path ${class} --illegal-access=deny j9ms.internal.Nimbus  >
    线程"main"中的异常 java.lang.IllegalAccessError: > 类j9ms.internal.Nimbus（在未命名的模块@0x6bc168e5中）无法访问类com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel（在模块java.desktop中），因为模块java.desktop没有将com.sun.java.swing.plaf.nimbus导出到未命名的模块@0x6bc168e5`'
- en: 'There’s one more detail to discuss: what happens with illegal access to JDK
    internals introduced in Java 9? Because the `--illegal-access` option was introduced
    to ease migration, it would be a shame if it made the eventual transition harder
    by giving you a few years to start depending on new internal APIs. That’s indeed
    a risk!'
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需要讨论的一个细节是：在Java 9中引入的非法访问JDK内部结构会发生什么？因为`--illegal-access`选项是为了简化迁移而引入的，如果它让你有几年时间开始依赖新的内部API，反而使得最终过渡变得更加困难，那就太遗憾了！这确实是一个风险！
- en: ESSENTIAL INFO To minimize the risk of depending on new JDK-internal APIs, `--illegal-access`
    doesn’t apply to packages introduced in Java 9\. This shrinks the set of new APIs
    that projects may accidentally depend on to classes added to packages that existed
    before Java 9.
  id: totrans-374
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 为了最小化依赖于新的JDK内部API的风险，`--illegal-access`不适用于Java 9中引入的包。这缩小了项目可能意外依赖的新API集，这些API被添加到Java
    9之前存在的包中。'
- en: The things that are done for compatibility—I told you it would get more complex.
    And I’m not done yet, because we can also manage illegal access more specifically
    (see the next section). [Table 7.1](part0021.html#filepos884309) in section 7.1.5
    then compares the different variants.
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了兼容性所做的这些事情——我告诉你这会变得更复杂。而且我还没有说完，因为我们还可以更具体地管理非法访问（参见下一节）。7.1.5节中的[表7.1](part0021.html#filepos884309)比较了不同的变体。
- en: MANAGING SPECIFIC ILLEGAL ACCESS TO SELECTED APIS
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 管理对选定API的具体非法访问
- en: 'The `illegal-access` option is characterized by three central properties:'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`illegal-access`选项有三个核心特性：'
- en: It manages illegal access in a wholesale manner.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它以整体方式管理非法访问。
- en: It’s a transitional option that will eventually disappear.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个过渡选项，最终将消失。
- en: It bugs you with warnings.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过警告困扰你。
- en: What happens when it’s gone? Will strong encapsulation be insurmountable? The
    answer is no, it won’t be. There will always be edge cases that require access
    to internal APIs (of platform and application modules), and hence some mechanism
    (maybe not an overly comfortable one) should exist to make that possible. Once
    again, we turn to command-line options.
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当它消失时会发生什么？强封装是否无法克服？答案是：不会。总会有一些边缘情况需要访问平台和应用模块的内部API，因此应该存在某种机制（可能不是特别舒适的一种）来实现这一点。再次强调，我们转向命令行选项。
- en: ESSENTIAL INFO As I mentioned in section 7.1.3 when discussing internal APIs
    during compilation, `--add-exports` is also available for the `java` command.
    It works just the same and makes the specified package accessible to either the
    specified module or all running code. That means such code can use public members
    of public types in these packages, which covers all static access.
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 如我在7.1.3节中讨论编译期间内部API时提到的，`--add-exports`对于`java`命令也是可用的。它的工作方式完全相同，并使指定的包对指定的模块或所有运行代码可访问。这意味着此类代码可以使用这些包中公共类型的公共成员，这涵盖了所有静态访问。'
- en: 'The class `NimbusLookAndFeel` is public, so all you need to do to properly
    access it is export the package that contains it. To make sure you observe the
    effect of `--add-exports`, deactivate the default permission of illegal access
    with `--illegal-access=deny`:'
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`NimbusLookAndFeel`类是公共的，所以你只需导出包含它的包即可正确访问它。为了确保你观察到`--add-exports`的效果，使用`--illegal-access=deny`取消默认的非法访问权限：'
- en: '`$ java --class-path ${class} --illegal-access=deny --add-exports java.desktop/com.sun.java.swing.plaf.nimbus=ALL-UNNAMED
    j9ms.internal.Nimbus  > Static access to ${Nimbus Look and Feel} > Reflective
    access to ${Nimbus Look and Feel}`'
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --class-path ${class} --illegal-access=deny --add-exports java.desktop/com.sun.java.swing.plaf.nimbus=ALL-UNNAMED
    j9ms.internal.Nimbus  > 静态访问 ${Nimbus Look and Feel} > 反射访问 ${Nimbus Look and
    Feel}`'
- en: The reflective access goes through. Also notice that you don’t get a warning—more
    on that in a minute.
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 反射访问得以通过。同时请注意，你不会收到警告——关于这一点，我们稍后再谈。
- en: 'This covers access to public members of public types, but reflection can do
    more than that: with the generous use of `setAccessible(true)`, it allows interaction
    with nonpublic classes as well as nonpublic fields, constructors, and methods.
    Even in an exported package, these members are encapsulated, though, so to successfully
    reflect over them, you need something else.'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这涵盖了访问公共类型中的公共成员，但反射可以做得更多：通过大量使用`setAccessible(true)`，它允许与非公共类以及非公共字段、构造函数和方法进行交互。即使在导出包中，这些成员也是封装的，但为了成功反射它们，你需要其他东西。
- en: The option `--add-opens` uses the same syntax as `--add-exports` and opens the
    package to deep reflection, meaning all of its types and their members are accessible
    regardless of their visibility modifiers. Because of its primary relation to reflection,
    the option is more formally introduced in section 12.2.2.
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项`--add-opens`使用与`--add-exports`相同的语法，并使包对深度反射开放，这意味着无论其可见性修饰符如何，其所有类型及其成员都是可访问的。由于其与反射的主要关系，该选项在12.2.2节中更正式地介绍。
- en: Still, its use case is to access internal APIs, so it makes sense to look at
    an example here. A fairly common one is provided by tools generating instances
    of classes from other representations, for example JAXB creating a `Customer`
    instance from an XML file. Many such libraries rely on internals of the class-loading
    mechanism, for which they reflectively accessed nonpublic members of the JDK class
    `ClassLoader`. Note that there are plans to remove the `–illegal-access` option
    in a future version of Java, but Oracle has not yet decided which version.
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管如此，它的用途是访问内部API，所以在这里查看一个例子是有意义的。一个相当常见的是由生成其他表示形式的类实例的工具提供的，例如JAXB从XML文件创建一个
    `Customer` 实例。许多这样的库依赖于类加载机制的内部，它们通过反射访问了JDK类 `ClassLoader` 的非公共成员。请注意，有计划在Java的下一个版本中删除
    `–illegal-access` 选项，但Oracle尚未决定是哪个版本。
- en: 'If you run such code with `--illegal-access=deny`, you’ll get an error:'
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你使用 `--illegal-access=deny` 运行这样的代码，你会得到一个错误：
- en: '`> Caused by: java.lang.reflect.InaccessibleObjectException: > Unable to make
    ClassLoader.defineClass accessible: > module java.base does not "opens java.lang"
    to unnamed module`'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> Caused by: java.lang.reflect.InaccessibleObjectException: > Unable to make
    ClassLoader.defineClass accessible: > module java.base does not "opens java.lang"
    to unnamed module`'
- en: 'The message is pretty clear—the solution is to use `--add-opens` when launching
    the application:'
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 消息非常明确——解决方案是在启动应用程序时使用 `--add-opens`：
- en: '`$ java --class-path ${jars} --illegal-access=deny --add-opens java.base/java.lang=ALL-UNNAMED
    ${main-class}`'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --class-path ${jars} --illegal-access=deny --add-opens java.base/java.lang=ALL-UNNAMED
    ${main-class}`'
- en: Unlike `--illegal-access` and its current default value `permit`, the options
    `--add-exports` and `--add-opens` can be seen as “the proper way” (or rather,
    “the least shady way”) to access internal APIs. Developers deliberately formulate
    them based on their project requirements, and the JDK supports them in the long
    term. Accordingly, the module system emits no warnings for access permitted by
    these options.
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与 `--illegal-access` 及其当前默认值 `permit` 不同，选项 `--add-exports` 和 `--add-opens`
    可以被视为“正确的方式”（或者更确切地说，“最不神秘的方式”）来访问内部API。开发者会根据项目需求故意制定它们，并且JDK长期支持它们。因此，模块系统不会对这些选项允许的访问发出警告。
- en: 'More than that, they keep `illegal-access` from emitting warnings for packages
    that are made accessible by them. If these warnings bug you but you can’t solve
    the underlying problem, exporting and opening packages this way makes the warnings
    go away. If even that won’t work for you (maybe you don’t have access to the command
    line), take a look at this on Stack Overflow: [http://mng.bz/Bx6s](http://mng.bz/Bx6s).
    But don’t tell anyone where you got that link.'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更重要的是，它们阻止 `illegal-access` 为它们使可访问的包发出警告。如果这些警告让你烦恼，但你无法解决根本问题，通过这种方式导出和打开包可以让警告消失。如果即使这样对你也不起作用（也许你没有访问命令行的权限），请查看Stack
    Overflow上的这个链接：[http://mng.bz/Bx6s](http://mng.bz/Bx6s)。但不要告诉任何人你从哪里得到这个链接。
- en: NOTE As I explain in section 7.1.2, JDeps is a great tool to find static access
    to JDK-internal APIs. But what about reflective access? There’s no foolproof way
    to find uses of APIs called via reflection, but a call hierarchy on `java.lang.reflect.AccessibleObject::setAccessible`
    or a full-text search for setAccessible will uncover most of them in your code.
    To verify your project as a whole, run the test suite or the entire application
    with `--illegal-access=debug` or `deny` to ferret out all illegal access via reflection.
  id: totrans-395
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：正如我在7.1.2节中解释的，JDeps是一个很好的工具，用于查找对JDK-内部API的静态访问。但关于反射访问呢？没有万无一失的方法来查找通过反射调用的API的使用，但通过
    `java.lang.reflect.AccessibleObject::setAccessible` 的调用层次结构或对 setAccessible 的全文搜索将在你的代码中揭示大部分。为了验证整个项目，请使用
    `--illegal-access=debug` 或 `deny` 运行测试套件或整个应用程序，以找出所有通过反射进行的非法访问。
- en: 7.1.5 COMPILER AND JVM OPTIONS FOR ACCESSING INTERNAL APIS
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.1.5 访问内部API的编译器和JVM选项
- en: After working through this section, you’ve earned a pat on the back. The whole
    problem of internal APIs may look simple on the surface, but once you factor in
    the ecosystem’s legacy and compatibility concerns, it gets a little complicated.
    [Table 7.1](part0021.html#filepos884309) gives an overview of the options and
    how they behave.
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在完成本节内容后，你应得到掌声。表面上看，内部API的整个问题可能很简单，但一旦考虑到生态系统的遗留和兼容性问题，它就会变得稍微复杂一些。[表7.1](part0021.html#filepos884309)概述了选项及其行为方式。
- en: Table 7.1 A comparison of the different mechanisms allowing runtime access to
    internal APIs; split between static access (code compiled against such classes
    or members) and reflective access (using the reflection API)
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表 7.1 允许在运行时访问内部 API 的不同机制的比较；静态访问（针对此类或成员编译的代码）与反射访问（使用反射 API）之间的拆分
- en: '| Static access   |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 静态访问   |'
- en: '| Class or member   | Public   | Nonpublic   |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 类或成员   | 公共   | 非公共   |'
- en: '| Package   | Exported   | Non-exported   | Exported   | non-exported   |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 包   | 导出   | 未导出   | 导出   | 未导出   |'
- en: '| Strong encapsulation   | ✔   | ✘   | ✘   | ✘   |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 强封装   | ✔   | ✘   | ✘   | ✘   |'
- en: '| Default in Java 9 due to `--illegal-access=permit`   | ✔   | ✔   | ✘   |
    ✘   |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 由于 Java 9 中的 `--illegal-access=permit` 而默认   | ✔   | ✔   | ✘   | ✘   |'
- en: '| `--illegal-access=warn`   | ✔   | ✔   | ✘   | ✘   |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `--illegal-access=warn`   | ✔   | ✔   | ✘   | ✘   |'
- en: '| `--illegal-access=debug`   | ✔   | ✔   | ✘   | ✘   |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `--illegal-access=debug`   | ✔   | ✔   | ✘   | ✘   |'
- en: '| `--illegal-access=deny`   | ✔   | ✘   | ✘   | ✘   |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `--illegal-access=deny`   | ✔   | ✘   | ✘   | ✘   |'
- en: '| `--add-exports`   | ✔   | ✔   | ✘   | ✘   |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `--add-exports`   | ✔   | ✔   | ✘   | ✘   |'
- en: '| `--add-opens`   | ✔   | ✔   | ✘   | ✘   |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `--add-opens`   | ✔   | ✔   | ✘   | ✘   |'
- en: '| Reflective access   |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| 反射访问   |'
- en: '| Class or member   | Public   | Nonpublic   |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 类或成员   | 公共   | 非公共   |'
- en: '| Package   | Exported   | Non-exported   | Exported   | Non-exported   |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 包   | 导出   | 未导出   | 导出   | 未导出   |'
- en: '| Strong encapsulation   | ✔   | ✘   | ✘   | ✘   |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 强封装   | ✔   | ✘   | ✘   | ✘   |'
- en: '| Default in Java 9 due to `--illegal-access=permit`   | ✔   | ✘   | Pre Java
    9 ⚠ on first / else ✘   | ✘   |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 由于 Java 9 中的 `--illegal-access=permit` 而默认   | ✔   | ✘   | Java 9 之前 ⚠ 在首次
    / 否则 ✘   | ✘   |'
- en: '| `--illegal-access=warn`   | ✔   | ✘   | Pre Java 9 ⚠ on all / else ✘   |
    ✘   |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `--illegal-access=warn`   | ✔   | ✘   | Java 9 之前 ⚠ 在所有 / 否则 ✘   | ✘   |'
- en: '| `--illegal-access=debug`   | ✔   | ✘   | Pre Java 9: ⚠ on all, and stack
    trace / else ✘   | ✘   |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `--illegal-access=debug`   | ✔   | ✘   | Java 9 之前：⚠ 在所有，以及堆栈跟踪 / 否则 ✘   |
    ✘   |'
- en: '| `--illegal-access=deny`   | ✔   | ✘   | ✘   | ✘   |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| `--illegal-access=deny`   | ✔   | ✘   | ✘   | ✘   |'
- en: '| `--add-exports`   | ✔   | ✔   | ✘   | ✘   |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `--add-exports`   | ✔   | ✔   | ✘   | ✘   |'
- en: '| `--add-opens`   | ✔   | ✔   | ✔   | ✔   |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `--add-opens`   | ✔   | ✔   | ✔   | ✔   |'
- en: Beyond technical details, it’s important to look at possible strategies that
    bind these and other options together in a path to Java 9 compatibility. That’s
    what section 9.1 does. If you’re not looking forward to specifying options on
    the command line (for example, because you’re building an executable JAR), take
    an especially close look at section 9.1.4—it shows three alternatives to that
    approach.
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在技术细节之外，重要的是要考虑可能的策略，这些策略将这些选项和其他选项结合起来，以实现 Java 9 兼容。这正是第 9.1 节所做的事情。如果你不希望指定命令行选项（例如，因为你正在构建可执行的
    JAR），请特别仔细地查看第 9.1.4 节——它展示了三种替代方法。
- en: 7.2 Mending split packages
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2 修复拆分包
- en: 'Problems with illegal access to internal APIs, with unresolved JEE modules,
    or with most of the other changes discussed so far, as annoying as they may be,
    have something going for them: the underlying concepts are fairly easy to grasp;
    and thanks to precise error messages, the problems are easy to recognize. Neither
    can be said about split packages. In the worst case, the only symptom you’ll see
    is the compiler or JVM throwing errors because a class that’s clearly in a JAR
    on the class path can’t be found.'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于非法访问内部 API、未解决的 JEE 模块或迄今为止讨论的大多数其他更改，尽管它们可能很烦人，但它们有一些优点：基本概念相对容易理解；多亏了精确的错误消息，问题容易识别。对于拆分包则不能这么说。在最坏的情况下，你唯一会看到的症状是编译器或
    JVM 抛出错误，因为一个显然位于类路径上的 JAR 中的类找不到。
- en: 'As an example, let’s take the class `MonitorServer`, which, among other annotations,
    uses JSR 305’s `@Nonnull`. (Don’t worry if you’ve never seen it—I explain in a
    minute.) Here’s what happens when I try to compile it:'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，让我们以类 `MonitorServer` 为例，它除了其他注解外，还使用了 JSR 305 的 `@Nonnull`。 （如果你从未见过它，不要担心——我马上会解释。）以下是我尝试编译它时发生的情况：
- en: '`> error: cannot find symbol > symbol: class javax.annotation.Nonnull > location:
    class monitor.MonitorServer`'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 错误：找不到符号 > 符号：类 javax.annotation.Nonnull > 位置：类 monitor.MonitorServer`'
- en: That’s even though `jsr305-3.0.2.jar` is on the class path.
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管有 `jsr305-3.0.2.jar` 在类路径上。
- en: What’s happening? Why are some types not loaded even though the class path contains
    them? The critical observation is that those types are in a package that’s also
    contained in a module. Now let’s see why that makes a difference and leads to
    classes not being loaded.
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 发生了什么？为什么即使类路径中包含它们，某些类型仍然没有被加载？关键观察结果是这些类型位于一个也包含在模块中的包中。现在让我们看看这为什么会造成差异，并导致类无法加载。
- en: When different artifacts contain classes in the same package (exported or not),
    they’re said to split the package. If at least one of the modular JARs doesn’t
    export the package, this is also called a concealed package conflict. The artifacts
    may contain classes with the same fully qualified name, in which case the splits
    overlap; or the classes may have different names and only share the package name
    prefix. Regardless of whether split packages are concealed and whether they overlap,
    the effects discussed in this section are the same. [Figure 7.2](part0021.html#filepos913233)
    shows a split and concealed package.
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当不同的工件包含同一包中的类（无论是否导出）时，它们被称为分割包。如果至少有一个模块化的 JAR 没有导出该包，这也被称为隐藏包冲突。这些工件可能包含具有相同完全限定名的类，在这种情况下，分割重叠；或者类可能具有不同的名称，但只共享包名前缀。无论分割包是否隐藏以及它们是否重叠，本节讨论的效果是相同的。[图
    7.2](part0021.html#filepos913233) 展示了一个分割和隐藏包。
- en: '![](../images/00032.jpeg)'
  id: totrans-427
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00032.jpeg)'
- en: '[Figure 7.2](part0021.html#filepos912886) When two modules contain types in
    the same package, they split the package.'
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 7.2](part0021.html#filepos912886) 当两个模块包含同一包中的类型时，它们分割了该包。'
- en: Split packages and unit tests
  id: totrans-429
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分包和单元测试
- en: The split-package problem is one of two reasons unit tests, which are usually
    placed in a different source tree but in the same package as the production code,
    don’t make up their own module. (The other reason is strong encapsulation, because
    unit tests often test classes and methods that aren’t public or aren’t in an exported
    package.)
  id: totrans-430
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分包问题是有两个原因之一，单元测试通常放置在不同的源树中，但与生产代码在同一包中，它们不构成自己的模块。（另一个原因是强封装，因为单元测试通常测试非公共或不在导出包中的类和方法。）
- en: Abundant sources for split-package examples are application servers, which typically
    run various JDK technologies. Take, for example, the JBoss application server
    and the artifact jboss-jaxb-api_2.2_spec. It contains classes like `javax.xml.bind.Marshaller`,
    `javax.xml.bind.JAXB`, and `javax.xml.bind.JAXBException`. This clearly overlaps
    with and thus splits the `javax.xml.bind` package, contained in the java.xml.bind
    module. (By the way, JBoss is doing nothing wrong—JAXB is a standalone JEE technology,
    as explained in section 6.1.1 and the artifact contains a full implementation
    of it.)
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分包示例的丰富来源是应用程序服务器，它们通常运行各种 JDK 技术。以 JBoss 应用程序服务器和工件 jboss-jaxb-api_2.2_spec
    为例。它包含像 `javax.xml.bind.Marshaller`、`javax.xml.bind.JAXB` 和 `javax.xml.bind.JAXBException`
    这样的类。这显然与并因此分割了包含在 java.xml.bind 模块中的 `javax.xml.bind` 包。（顺便说一下，JBoss 没有做错什么——JAXB
    是一个独立的 JEE 技术，如第 6.1.1 节所述，该工件包含它的完整实现。）
- en: An example for a non-overlapping and generally more questionable split package
    comes from JSR 305\. The Java Specification Request (JSR) 305 wanted to bring
    “annotations for software defect detection” into the JDK. It decided on a few
    annotations like `@Nonnull` and `@Nullable` that it wanted to add to the `javax.annotation`
    package, created a reference implementation, was successfully reviewed according
    to the Java Community Process (JCP), and then—went silent. That was 2006.
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个非重叠且通常更具疑问性的分包示例来自 JSR 305。Java 规范请求（JSR）305 希望将“用于软件缺陷检测的注解”引入 JDK。它决定添加一些注解，如
    `@Nonnull` 和 `@Nullable`，到 `javax.annotation` 包中，创建了一个参考实现，根据 Java 社区过程（JCP）成功审查，然后——沉默了。那是
    2006 年。
- en: The community, on the other hand, liked the annotations, so static analysis
    tools like FindBugs supported them and many projects adopted them. Although not
    exactly standard practice, they’re commonly used throughout the Java ecosystem.
    Even in Java 9, they aren’t part of the JDK, and unfortunately the reference implementation
    places most of the annotations in the `javax.annotation` package. This creates
    a non-overlapping split with the java.xml.ws.annotation module.
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，社区喜欢这些注解，因此静态分析工具如 FindBugs 支持它们，许多项目也采用了它们。尽管这不是标准做法，但它们在 Java 生态系统中被广泛使用。即使在
    Java 9 中，它们也不是 JDK 的一部分，而且不幸的是，参考实现将大多数注解放在了 `javax.annotation` 包中。这创建了一个与 java.xml.ws.annotation
    模块非重叠的分割。
- en: 7.2.1 WHAT’S THE PROBLEM WITH SPLIT PACKAGES?
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.1 分包的问题是什么？
- en: What’s wrong with split packages? Why would they lead to classes not being found
    even though they’re obviously present? The answer isn’t straightforward.
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分包有什么问题？为什么即使它们显然存在，它们也会导致找不到类？答案并不直接。
- en: A strictly technical aspect of split packages is that Java’s entire class-loading
    mechanism was implemented on the assumption that any fully qualified class name
    is unique—at least, within the same class loader, but because there’s by default
    only one class loader for the entire application code, this is no meaningful way
    to relax this requirement. Unless Java’s class loading is redesigned and reimplemented
    from the ground up, this forbids overlapping package splits. (Section 13.3 shows
    how to tackle that problem by creating multiple class loaders.)
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拆分包的一个严格技术方面是，Java的整个类加载机制都是基于这样一个假设：任何完全限定的类名都是唯一的——至少，在同一类加载器中，但由于默认情况下整个应用程序代码只有一个类加载器，这并不是放松这一要求的有意义的方式。除非Java的类加载被重新设计和从头开始重新实现，否则这禁止了重叠的包拆分。（第13.3节展示了如何通过创建多个类加载器来解决这个问题。）
- en: Another technical aspect is that the JDK team wanted to use the module system
    to improve class-loading performance. Section 6.2.1 describes the details, but
    the gist is that it relies on knowing for each package which module it belongs
    to. This is simpler and more performant if every package only belongs to a single
    module.
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个技术方面是，JDK团队希望利用模块系统来提高类加载性能。第6.2.1节描述了细节，但关键是它依赖于知道每个包属于哪个模块。如果每个包只属于一个模块，这将更简单、性能更高。
- en: 'Then, split packages collide with an important goal of the module system: strong
    encapsulation across module boundaries. What happens when different modules split
    a package? Shouldn’t they be able to access each other’s package-visible classes
    and members? Allowing that would seriously undermine encapsulation—but disallowing
    that would collide head-on with your understanding of visibility modifiers. Not
    a design decision I’d want to make.'
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后，拆分包与模块系统的一个重要目标相冲突：模块边界之间的强封装。当不同的模块拆分一个包时会发生什么？它们是否应该能够访问彼此的包可见类和成员？允许这样做将严重破坏封装——但是禁止这样做将直接与您对可见性修饰符的理解相冲突。这不是我想做出的设计决策。
- en: Maybe the most important aspect is conceptual, though. A package is supposed
    to contain a coherent set of classes with a single purpose, and a module is supposed
    to contain a coherent set of packages with a single, although somewhat larger,
    purpose. In that sense, two modules containing the same package have overlapping
    purposes. Maybe they should be one module, then … ?
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 也许最重要的方面是概念性的。一个包应该包含一个具有单一目的的连贯的类集，而一个模块应该包含一个具有单一、尽管稍微大一些的目的的连贯的包集。从这个意义上讲，包含相同包的两个模块具有重叠的目的。也许它们应该是一个模块，然后……？
- en: Although there’s no single killer argument against split packages, they have
    a lot of properties that are undesired and would foster inconsistencies and ambiguity.
    The module system hence views them with suspicion and wants to prevent them.
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然没有单一的杀手论点反对拆分包，但它们有很多不希望的特性，会促进不一致性和歧义。因此，模块系统对它们持怀疑态度，并希望防止它们。
- en: 7.2.2 THE EFFECTS OF SPLIT PACKAGES
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.2 拆分包的影响
- en: 'Given the inconsistencies and ambiguities split packages can incur, the module
    system practically forbids them:'
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于拆分包可能导致的不一致性和歧义，模块系统实际上禁止了它们：
- en: A module isn’t allowed to read the same package from two different modules.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模块不允许从两个不同的模块中读取相同的包。
- en: No two modules in the same layer are allowed to contain the same package (exported
    or not).
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一层的两个模块不允许包含相同的包（无论是导出还是未导出）。
- en: What’s a layer? As section 12.4 explains, it’s a container bundling a class
    loader with an entire graph of modules. So far, you’ve always implicitly been
    in the single-layer case, in which the second bullet wholly includes the first
    one. So unless different layers are involved, split packages are forbidden.
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么是层？正如第12.4节所解释的，它是一个包含类加载器及其整个模块图的容器。到目前为止，您一直隐式地处于单层情况，其中第二个要点完全包含第一个要点。因此，除非涉及不同的层，否则禁止拆分包。
- en: As you’ll see next, the module system behaves differently, though, depending
    on where the split occurs. After we’ve covered that, we can finally turn to mending
    the split.
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如您接下来将看到的，模块系统的行为会根据拆分发生的位置而有所不同。在我们覆盖了这一点之后，我们最终可以转向修复拆分。
- en: SPLITS BETWEEN MODULES
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块之间的拆分
- en: When two modules, such as a platform module and an application module, split
    a package, the module system will detect that and throw an error. This can happen
    at compile time or run time.
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当两个模块（如平台模块和应用模块）拆分一个包时，模块系统将检测到这一点并抛出错误。这可以在编译时或运行时发生。
- en: 'As an example, let’s fiddle with the ServiceMonitor application. As you may
    recall, the monitor.statistics module contains a package `monitor.statistics`.
    Let’s create a package with the same name (and the class `SimpleStatistician`)
    in monitor. When compiling that module, I get the following error:'
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以ServiceMonitor应用程序为例。如您所回忆的，monitor.statistics模块包含一个名为`monitor.statistics`的包。让我们在monitor中创建一个具有相同名称（以及`SimpleStatistician`类）的包。当编译该模块时，我遇到了以下错误：
- en: '`> monitor/src/main/java/monitor/statistics/SimpleStatistician.java:1: > error:
    package exists in another module: monitor.statistics > package monitor.statistics;
    > ^ > 1 error`'
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor/src/main/java/monitor/statistics/SimpleStatistician.java:1: > error:
    package exists in another module: monitor.statistics > package monitor.statistics;
    > ^ > 1 error`'
- en: '![](../images/00096.jpeg)'
  id: totrans-451
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00096.jpeg)'
- en: '[Figure 7.3](part0021.html#filepos928956) Class-path content isn’t exposed
    to module checks, and its packages aren’t indexed. If it splits a package with
    a module, the class loader will only know about the module and look there for
    classes. Here it looks for `org.company` and checks the corresponding module,
    ignoring the class-path portion of the package.'
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图7.3](part0021.html#filepos928956) 类路径内容不会暴露给模块检查，其包也不会被索引。如果它与模块分割了一个包，类加载器只会知道该模块，并在此处查找类。在这里，它查找`org.company`并检查相应的模块，忽略包的类路径部分。'
- en: When trying to compile a module with a package that’s also exported from a required
    module, the compiler notices the error. But what happens when the package isn’t
    exported, meaning you have a concealed package conflict?
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当尝试编译一个包含从所需模块导出的包的模块时，编译器会注意到错误。但是，当包没有被导出时，即你有一个隐藏的包冲突，会发生什么？
- en: To find out, I added a class `monitor.Utils` to monitor.statistics, which means
    I split the `monitor` package between monitor and monitor.statistics. The split
    is concealed, because monitor.statistics doesn’t export `monitor`.
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了找出原因，我在monitor.statistics中添加了一个名为`monitor.Utils`的类来监控统计信息，这意味着我将`monitor`包分成了`monitor`和`monitor.statistics`两部分。这种分割是隐藏的，因为monitor.statistics没有导出`monitor`。
- en: 'In that situation—and I found this a little surprising—compiling monitor works.
    It’s up to the runtime to report the error, which it dutifully does, immediately
    when launching the application:'
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在那种情况下——这让我有些惊讶——编译monitor是可行的。错误报告的责任落在运行时，它会尽职尽责地立即在启动应用程序时报告错误：
- en: '`> Error occurred during initialization of boot layer > java.lang.reflect.LayerInstantiationException:
    > Package monitor in both module monitor.statistics and module monitor`'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 初始化引导层时发生错误 > java.lang.reflect.LayerInstantiationException: > 包monitor在模块monitor.statistics和模块monitor中`'
- en: 'The same is true if two modules (where neither requires the other) contain
    the same package: not the compiler but the runtime will find the error.'
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果两个模块（其中任何一个都不需要另一个）包含相同的包：不是编译器而是运行时会发现错误。
- en: SPLITS BETWEEN A MODULE AND THE CLASS PATH
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块与类路径之间的分割
- en: This chapter is focused on compiling and running a class-path application on
    Java 9 or later, so let’s turn back to that use case. Interestingly, the module
    system’s behavior is different. All code from the class path ends up in the unnamed
    module (more on that in section 8.2); to maximize compatibility, it is, generally
    speaking, not scrutinized, and no module-related checks are applied to it. As
    a consequence, the module system won’t discover split packages and lets you compile
    and launch the application.
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章主要关注在Java 9或更高版本上编译和运行类路径应用程序，因此让我们回到这个用例。有趣的是，模块系统的行为是不同的。所有来自类路径的代码最终都会进入未命名的模块（更多内容请参阅第8.2节）；为了最大化兼容性，通常不会对其进行审查，也不会对其应用任何模块相关的检查。因此，模块系统不会发现分割的包，并允许您编译和启动应用程序。
- en: 'At first that may sound great: one less thing to worry about. Alas, the problem
    is still there, it just got less obvious. And arguably worse.'
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 起初这听起来可能很好：少了一件需要担心的事情。然而，问题仍然存在，只是不那么明显了。而且可能更糟。
- en: The module system knows for each named module (as opposed to the unnamed module),
    which packages it contains and that each package belongs to only one module. As
    I explained in section 6.2.1, the new class-loading strategy benefits from that
    knowledge; whenever it loads a class, it looks up the module containing the package
    and tries to load from there. If it contains the class, great; if it doesn’t,
    the result is a `NoClassDefFoundError`.
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统知道每个命名模块（与未命名的模块相对）包含哪些包，以及每个包只属于一个模块。正如我在第6.2.1节中解释的，新的类加载策略得益于这种知识；每次它加载一个类时，它会查找包含该包的模块，并尝试从那里加载。如果它包含该类，那就太好了；如果不包含，结果就是`NoClassDefFoundError`。
- en: If a package is split between a module and the class path, the class loader
    will always and only look into the module when loading classes from that package
    (see [figure 7.3](part0021.html#filepos923713)). Classes in the class-path portion
    of the package are effectively invisible! This is true for splits between platform
    modules and the class path and just the same for application modules (meaning
    JARs loaded from the module path) and the class path.
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一个包在模块和类路径之间分割，类加载器在加载该包的类时将始终且仅检查模块（参见[图 7.3](part0021.html#filepos923713)）。包的类路径部分的类实际上是不可见的！这对于平台模块和类路径之间的分割同样适用，对于应用程序模块（即从模块路径加载的
    JAR）和类路径也是如此。
- en: 'Yes, you got that right. If some code contains a class from, say, the `javax.annotation`
    package, then the class loader will look into the only module that contains that
    package: java.xml.ws.annotation. If the class isn’t found there, you get a `NoClassDefFoundError`,
    even if the class is present on the class path!'
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的，你说对了。如果某些代码包含来自，比如说，`javax.annotation` 包的类，那么类加载器将检查唯一包含该包的模块：java.xml.ws.annotation。如果在那里找不到该类，即使该类存在于类路径上，你也会得到一个
    `NoClassDefFoundError` 错误！
- en: As you may imagine, arbitrarily missing classes can lead to some head-scratching.
    This is the precise reason JEE modules, which foster package splits, aren’t resolved
    by default, as section 6.1 explains. Still, these modules can make for the weirdest
    split-package case.
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如你所想，任意缺失的类可能会导致一些令人困惑的情况。这正是 JEE 模块（它们促进包分割）默认不解析的精确原因，如第 6.1 节所述。尽管如此，这些模块可能会造成最奇怪的分割包情况。
- en: Consider a project that uses the annotations `@Generated` and `@Nonnull`. The
    first is present in Java 8, and the second comes from a JSR 305 implementation
    the project has on its class path. Both are in the `javax.annotation` package.
    What happens when you compile that on Java 9 or later?
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑一个使用注解 `@Generated` 和 `@Nonnull` 的项目。第一个存在于 Java 8 中，第二个来自项目类路径上的 JSR 305
    实现。两者都在 `javax.annotation` 包中。当你使用 Java 9 或更高版本编译时会发生什么？
- en: '`> error: cannot find symbol > symbol: class Generated > location: package
    javax.annotation`'
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 错误：找不到符号 > 符号：类 Generated > 位置：包 javax.annotation`'
- en: 'So the Java class is missing? Yes, because it comes from the JEE module java.xml.ws.annotation,
    which isn’t resolved by default. But the error message is different here: it doesn’t
    hint toward the solution. Fortunately, you paid attention earlier and know that
    you can fix this by adding the containing module with `--add-modules java.xml.ws.annotation`.
    Then you get the following:'
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所以 Java 类缺失了？是的，因为它来自 JEE 模块 java.xml.ws.annotation，而这个模块默认不解析。但这里的错误信息不同：它没有指向解决方案。幸运的是，你之前已经注意到了，知道可以通过添加包含的模块
    `--add-modules java.xml.ws.annotation` 来解决这个问题。然后你得到以下结果：
- en: '`> error: cannot find symbol > symbol: class Nonnull > location: class MonitorServer`'
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 错误：找不到符号 > 符号：类 Nonnull > 位置：类 MonitorServer`'
- en: The compiler found that class a minute ago—why doesn’t it now? Because now there’s
    a module containing the `javax.annotation` package, so the class-path portion
    becomes invisible.
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译器一分钟前找到了那个类——为什么现在找不到？因为现在有一个包含 `javax.annotation` 包的模块，所以类路径部分变得不可见。
- en: 'To repeat (you can also see this in [figure 7.4](part0021.html#filepos934002)):'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了重复（你也可以在[图 7.4](part0021.html#filepos934002)中看到）：
- en: The first error was caused by JEE modules not being resolved by default.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个错误是由 JEE 模块默认不解析引起的。
- en: The second error was caused by the module system ignoring the class-path part
    of a split package.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个错误是由模块系统忽略分割包的类路径部分引起的。
- en: Makes perfect sense (right?). Now that you thoroughly understand what’s going
    on, let’s turn toward fixing the situation.
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这完全说得通（对吧？）。现在你已经彻底理解了发生了什么，让我们转向解决问题的方法。
- en: '![](../images/00037.jpeg)'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00037.jpeg)'
- en: '[Figure 7.4](part0021.html#filepos933088) Loading from the same package can
    fail for different reasons. At left, the JEE module java.xml.ws.annotation wasn’t
    added, so loading `@Generated` fails because the JSR 305 artifact on the class
    path doesn’t contain it. At right, the module was added, so class loading tries
    to load all `javax.annotation` classes from there—even `@Nonnull`, which only
    JSR 305 contains. In the end, both approaches fail to load all required annotations.'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图 7.4](part0021.html#filepos933088) 从同一包加载可能会因为不同的原因而失败。在左侧，没有添加 JEE 模块 java.xml.ws.annotation，因此加载
    `@Generated` 失败，因为类路径上的 JSR 305 艺术品不包含它。在右侧，添加了模块，因此类加载尝试从那里加载所有 `javax.annotation`
    类——甚至 `@Nonnull`，它只由 JSR 305 包含。最终，两种方法都未能加载所有必需的注解。'
- en: 7.2.3 MANY WAYS TO HANDLE SPLIT PACKAGES
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.3 处理分割包的多种方法
- en: 'There are quite a few ways to make a split package work. Here they are, in
    the general order I recommend considering them:'
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有很多方法可以使拆分包工作。以下是一般推荐考虑的顺序：
- en: Rename one of the packages.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名其中一个包。
- en: Move all parts of the split package into the same artifact.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将拆分包的所有部分移动到同一个工件中。
- en: Merge the artifacts.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并工件。
- en: Leave both artifacts on the class path.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个工件都留在类路径上。
- en: Upgrade the JDK module with the artifact.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级带有工件的JDK模块。
- en: Patch a module with the artifact’s content.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工件的内容修补模块。
- en: NOTE Only the last two apply to the typical split-package scenario during a
    migration, where the package is split between a platform module and an artifact
    on the class path.
  id: totrans-484
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：只有最后两个适用于迁移期间典型的拆分包场景，其中包在平台模块和类路径上的工件之间拆分。
- en: The first approach works when the package-name collision was accidental—it should
    be the most obvious choice and be used whenever possible. When the split was made
    on purpose, this is unlikely to work, though. In that case, you could try to mend
    the split by moving a few classes or by merging the artifacts. These first three
    options are proper, long-term solutions to the problem, but obviously they only
    work when you have control over the splitting artifacts.
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一种方法在包名冲突是意外的情况下有效——它应该是最明显的选择，并且尽可能使用。当拆分是故意进行的时候，这不太可能有效。在这种情况下，你可以尝试通过移动一些类或合并工件来修复拆分。这三种选项是解决问题的适当、长期解决方案，但显然它们只在你控制拆分工件的情况下有效。
- en: If the splitting code doesn’t belong to you, or the solutions aren’t applicable,
    you need other options that make the module system work even though the package
    remains split. A straightforward fix is to leave both artifacts on the class path,
    where they will be bundled into the same unnamed module and behave as they did
    before Java 9\. This is a valid intermediate strategy while you wait for the project(s)
    to hash out the collision and fix it.
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果拆分代码不属于你，或者解决方案不适用，你需要其他选项来确保模块系统能够正常工作，即使包仍然是拆分的。一个直接的修复方法是让这两个工件都留在类路径上，它们将被捆绑到同一个未命名的模块中，并像Java
    9之前那样表现。这是一个有效的中间策略，在你等待项目解决冲突并修复它的时候。
- en: Unfortunately, none of the solutions discussed so far apply when part of the
    split belongs to a JDK module, because you have no direct control over it—to overcome
    that split, you need bigger guns. If you’re lucky, the splitting artifact consists
    of more than just a few classes that go into a random JDK package and a replacement
    for an entire, upgradeable JDK module is provided. In that case, see section 6.1.3,
    which explains how to use `--upgrade-module-path`.
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不幸的是，到目前为止讨论的任何解决方案都不适用于拆分的部分属于JDK模块的情况，因为你无法直接控制它——为了克服这种拆分，你需要更大的火力。如果你很幸运，拆分的工件由不仅仅是几个随机放入JDK包的类和一些整个可升级的JDK模块的替代品组成。在这种情况下，请参阅第6.1.3节，该节解释了如何使用`--upgrade-module-path`。
- en: 'If none of that helped, you’re stuck with the final and most hacky approach:
    patching modules.'
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果上述方法都没有帮助，你将陷入最后的也是最复杂的解决方案：修补模块。
- en: '7.2.4 PATCHING MODULES: LAST RESORT FOR HANDLING SPLIT PACKAGES'
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.4 修补模块：处理拆分包的最后手段
- en: 'One technique can fix pretty much every split package but should always be
    the last resort: making the module system pretend the troublesome classes on the
    class path belonged into the split package’s module. The compiler and runtime
    option `--patch-module ${module}=${artifact}` merges all classes from `${artifact}`
    into `${module}`. There are a few things to look out for, but let’s see an example
    before we get to them.'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一种技术可以修复几乎所有的拆分包，但应该始终作为最后的手段：让模块系统假装类路径上的麻烦类属于拆分包的模块。编译器和运行时选项`--patch-module
    ${module}=${artifact}`将所有来自`${artifact}`的类合并到`${module}`中。有一些需要注意的事项，但让我们在讨论它们之前先看一个例子。
- en: 'Earlier, we looked at the example of a project that uses the annotations `@Generated`
    (from the java.xml.ws.annotation module) and `@Nonnull` (from a JSR 305 implementation).
    We discovered three things:'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 之前，我们查看了一个使用注解`@Generated`（来自java.xml.ws.annotation模块）和`@Nonnull`（来自JSR 305实现）的项目示例。我们发现了三件事：
- en: Both annotations are in the `javax.annotation` package, thus creating a split.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两个注解都在`javax.annotation`包中，从而创建了拆分。
- en: You need to add the module manually, because it’s a JEE module.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要手动添加模块，因为它是一个JEE模块。
- en: Doing so makes the JSR 305 portion of the split package invisible.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样做使得拆分包中的JSR 305部分变得不可见。
- en: 'Now you know that you can use `--patch-module` to mend the split:'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你知道了你可以使用`--patch-module`来修复拆分：
- en: '`javac --add-modules java.xml.ws.annotation --patch-module java.xml.ws.annotation=jsr305-3.0.2.jar
    --class-path ''libs/*'' -d classes/monitor.rest ${source-files}`'
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`javac --add-modules java.xml.ws.annotation --patch-module java.xml.ws.annotation=jsr305-3.0.2.jar
    --class-path ''libs/*'' -d classes/monitor.rest ${source-files}`'
- en: This way, all classes in `jsr305-3.0.2.jar` become part of the module java.xml.ws.annotation
    and can be loaded for a successful compilation (or, on `java`, execution). Yay!
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样，`jsr305-3.0.2.jar` 中的所有类都成为 java.xml.ws.annotation 模块的一部分，并且可以在成功编译（或在 `java`
    上执行）时被加载。太好了！
- en: There are a few things to look out for. First, patching a module doesn’t automatically
    add it to the module graph. If it isn’t required explicitly, it may still need
    to be added with `--add-modules` (see section 3.4.3).
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有几点需要注意。首先，修补一个模块并不会自动将其添加到模块图中。如果它没有被显式地要求，可能还需要使用 `--add-modules`（参见第3.4.3节）来添加它。
- en: 'Next, classes added to a module with `--patch-module` are subject to normal
    accessibility rules (see section 3.3 and figure7.5):'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来，使用 `--patch-module` 添加到模块中的类将遵循正常的可访问性规则（参见第3.3节和图7.5）：
- en: '![](../images/00099.jpeg)'
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00099.jpeg)'
- en: Figure 7.5 If a module’s classes are patched into another module (here B into
    A), the patched module’s incoming and outgoing dependencies as well as package
    exports must be manually edited for the included classes to work properly.
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图7.5 如果一个模块的类被修补到另一个模块中（这里B修补到A），修补模块的输入和输出依赖以及包导出必须手动编辑，以便包含的类能够正常工作。
- en: Code that depends on such classes needs to read the patched module, which must
    export the necessary packages.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于此类代码的需要读取修补的模块，该模块必须导出必要的包。
- en: Likewise, these classes’ dependencies need to be in exported packages in modules
    read by the patched one.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，这些类的依赖也需要在修补模块读取的模块中的导出包中。
- en: This may require manipulating the module graph with command-line options like
    `--add-reads` (see section 3.4.4) and `--add-exports` (see section 11.3.4). Because
    named modules can’t access code from the class path, it may also be necessary
    to create some automatic modules (see section 8.3).
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这可能需要使用命令行选项如 `--add-reads`（参见第3.4.4节）和 `--add-exports`（参见第11.3.4节）来操作模块图。因为命名模块不能从类路径中访问代码，可能还需要创建一些自动模块（参见第8.3节）。
- en: 7.2.5 FINDING SPLIT PACKAGES WITH JDEPS
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.5 使用JDEPS查找拆分包
- en: Finding split packages by trial and error is unnerving. Fortunately, JDeps reports
    them. Appendix D gives a general introduction to the tool; you don’t need to know
    much more than that, because split packages are included in pretty much any output.
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过试错来查找拆分包令人不安。幸运的是，JDeps会报告它们。附录D对该工具进行了一般介绍；你不需要知道更多，因为拆分包几乎包含在任何输出中。
- en: 'Let’s see what JDeps reports for the application that uses `javax.annotation.Generated`
    from java.xml.ws.annotationand `javax.annotation.Nonnull` from JSR 305\. After
    copying all dependencies into the `lib` folder, you can execute JDeps as follows:'
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们看看JDeps对使用 `javax.annotation.Generated` 从 java.xml.ws.annotation 和 `javax.annotation.Nonnull`
    从 JSR 305 的应用程序的报告。在将所有依赖复制到 `lib` 文件夹后，你可以按照以下方式执行JDeps：
- en: '`$ jdeps -summary -recursive --class-path ''libs/*'' project.jar  > split package:
    javax.annotation > [jrt:/java.xml.ws.annotation, libs/jsr305-3.0.2.jar] > # lots
    of project dependencies truncated`'
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jdeps -summary -recursive --class-path ''libs/*'' project.jar > 拆分包: javax.annotation
    > [jrt:/java.xml.ws.annotation, libs/jsr305-3.0.2.jar] > # 大量项目依赖被截断`'
- en: 'That’s unambiguous, right? If you’re curious what depends on the split package,
    you can use `--package` and `-verbose:class`:'
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这很明确，对吧？如果你好奇哪些依赖于拆分包，可以使用 `--package` 和 `-verbose:class`：
- en: '`$ jdeps -verbose:class --package javax.annotation -recursive --class-path
    ''libs/*'' project.jar  # split packages truncated # dependencies *from* javax.annotation
    truncated  > rest-1.0-SNAPSHOT.jar -> libs/jsr305-3.0.2.jar > monitor.rest.MonitorServer
    -> Nonnull jsr305-3.0.2.jar`'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jdeps -verbose:class --package javax.annotation -recursive --class-path
    ''libs/*'' project.jar  # 拆分包被截断 # 从 javax.annotation 截断的依赖  > rest-1.0-SNAPSHOT.jar
    -> libs/jsr305-3.0.2.jar > monitor.rest.MonitorServer -> Nonnull jsr305-3.0.2.jar`'
- en: 7.2.6 A NOTE ON DEPENDENCY VERSION CONFLICTS
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.6 关于依赖版本冲突的注意事项
- en: You saw in section 1.3.3 how Java 8 has no out-of-the-box support for running
    multiple versions of the same JAR—for example, if an application transitively
    depends on both Guava 19 and 20\. Just a few pages later, in section 1.5.6, you
    learned that, unfortunately, the module system won’t change that. With what we
    just discussed about split packages, it should be clear why that’s the case.
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您在第1.3.3节中看到，Java 8没有内置支持来运行同一JAR的多个版本——例如，如果应用程序间接依赖于Guava 19和20。就在几页之后，在第1.5.6节中，您了解到不幸的是，模块系统不会改变这一点。根据我们刚才讨论的拆分包，应该很清楚为什么会出现这种情况。
- en: The Java module system changed the class-loading strategy (looking into specific
    modules instead of scanning the class path) but didn’t change underlying assumptions
    and mechanisms. For each class loader, there can still be only one class with
    the same fully qualified name, which makes multiple versions of the same artifact
    impossible. For more details on the module system’s support for versions, check
    out chapter 13.
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java模块系统改变了类加载策略（查找特定模块而不是扫描类路径），但没有改变底层假设和机制。对于每个类加载器，仍然只能有一个具有相同完全限定名称的类，这使得同一艺术品的多个版本成为不可能。有关模块系统对版本支持的更多详细信息，请参阅第13章。
- en: TIP You’ve learned about all the common and a few of the uncommon migration
    challenges. If you’re eager to put your knowledge into practice and upgrade a
    project to Java 9+, skip to chapter 9—it discusses how to best approach that.
    Once your application runs on Java 9+, you can use `jlink` to create runtime images
    with just the modules it needs—see section 14.1\. If you’re interested in the
    next step, turning an existing code base into modules, read on in chapter 8.
  id: totrans-514
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TIP 您已经了解了所有常见的以及一些不常见的迁移挑战。如果您渴望将您的知识付诸实践并将项目升级到Java 9+，请跳转到第9章——它讨论了如何最佳地处理这个问题。一旦您的应用程序在Java
    9+上运行，您就可以使用`jlink`来创建仅包含所需模块的运行时镜像——参见第14.1节。如果您对下一步感兴趣，即将现有代码库转换为模块，请继续阅读第8章。
- en: Summary
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'To know how the classes your project may depend on can be accessed under the
    module system, it’s important to understand how they’re categorized in the era
    of the module system:'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解您的项目可能依赖的类在模块系统下如何访问，了解它们在模块系统时代如何分类是很重要的：
- en: All public classes in `java.*` or `javax.*` packages are standardized. These
    packages are exported by java.* modules and are safe to depend on, so no changes
    are required.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.*`或`javax.*`包中的所有公共类都是标准化的。这些包由java.*模块导出，并且可以安全地依赖，因此不需要进行任何更改。'
- en: Public classes in some `com.sun.*` packages are supported by Oracle. Such packages
    are exported by jdk.* modules, and depending on them limits the code base to specific
    JDK vendors.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle支持某些`com.sun.*`包中的公共类。这些包由jdk.*模块导出，依赖它们将代码库限制在特定的JDK供应商。
- en: A few select classes in `sun.*` packages are temporarily supported by Oracle
    until replacements are introduced in future Java versions. They’re exported by
    jdk-unsupported.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun.*`包中的一些选定类在Oracle的支持下暂时可用，直到未来Java版本中引入替代品。它们由jdk-unsupported导出。'
- en: All other classes are unsupported and inaccessible. Using them is possible with
    command-line flags, but code that does so can break on JVMs with different minor
    versions or from different vendors; thus it’s generally inadvisable.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他类均不受支持且无法访问。虽然可以使用命令行标志使用它们，但这样做可能会在不同的小版本或不同供应商的JVM上中断，因此通常不建议这样做。
- en: Some internal APIs have been removed, so there’s no way to continue using them
    even with command-line options.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些内部API已被删除，因此即使使用命令行选项也无法继续使用它们。
- en: 'Although strong encapsulation generally forbids access to internal APIs, an
    exception is made for code on the class path accessing JDK-internal APIs. This
    will ease migration considerably but also complicates the module system’s behavior:'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管强封装通常禁止访问内部API，但对于类路径上访问JDK内部API的代码，有一个例外。这将大大简化迁移，但也会使模块系统的行为复杂化：
- en: During compilation, strong encapsulation is fully active and prevents access
    to JDK-internal APIs. If some APIs are required nevertheless, it’s possible to
    grant access with `--add-exports`.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译期间，强封装完全激活并阻止访问JDK内部API。如果仍然需要某些API，则可以使用`--add-exports`授予访问权限。
- en: At run time, static access to public classes in non-exported JDK packages is
    allowed by default on Java 9 to 11\. This makes it more likely that existing applications
    will work out of the box, but that will change with future releases.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，Java 9 到 11 默认允许对非导出 JDK 包中的公共类进行静态访问。这使得现有应用程序更有可能直接运行，但随着未来版本的发布，这一情况将会改变。
- en: Reflective access to all JDK-internal APIs is permitted by default but will
    result in a warning either on first access to a package (default) or on each access
    (with `--illegal-access=warn`). The best way to analyze this is `--illegal-access=debug`,
    which includes a stack trace in each warning.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，允许反射访问所有 JDK 内部 API，但首次访问包时（默认）或每次访问时（使用 `--illegal-access=warn`）都会产生警告。分析这一问题的最佳方法是使用
    `--illegal-access=debug`，它会在每个警告中包含堆栈跟踪。
- en: Stricter behavior for static and reflective access is possible with `--illegal-access=deny`,
    using `--add-exports` and `--add-opens` where necessary to access critically required
    packages. Working toward that target early on makes migration to future Java updates
    easier.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--illegal-access=deny` 可以实现静态和反射访问的更严格行为，在必要时使用 `--add-exports` 和 `--add-opens`
    访问关键所需的包。尽早朝着这个目标努力会使迁移到未来的 Java 更新变得更容易。
- en: The module system forbids two modules (in the same layer) to contain the same
    package—exported or not. This isn’t checked for code on the class path, though,
    so an undiscovered package split between a platform module and class-path code
    is possible.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块系统禁止同一层级的两个模块包含相同的包——无论是否导出。然而，对于类路径上的代码，这一规则并不适用，因此，一个未发现的包可能被分割在平台模块和类路径代码之间是可能的。
- en: If a package is split between a module and the class path, the class-path portion
    is essentially invisible, leading to surprising compile-time and runtime errors.
    The best fix is to remove the split, but if that isn’t possible, the platform
    module in question can either be replaced with the splitting artifact with `--upgrade-module-path`
    (if it’s an upgradeable module) or patched with its content with `--patch-module`.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个包被分割在模块和类路径之间，类路径部分基本上是看不见的，这会导致令人惊讶的编译时和运行时错误。最好的解决办法是移除分割，但如果这不可能，相关的平台模块可以用
    `--upgrade-module-path`（如果它是可升级的模块）替换分割的工件，或者用 `--patch-module` 用其内容修复。
- en: '8'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '8'
- en: Incremental modularization of existing projects
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现有项目的增量模块化
- en: This chapter covers
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working with the unnamed
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与未命名的工件一起工作
- en: Helping modularization with automatic modules
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动模块帮助模块化
- en: Incrementally modularizing a code base
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步模块化代码库
- en: Mixing class path and module path
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合类路径和模块路径
- en: Depending on how smoothly your migration to Java 9+ went (see chapters 6 and
    7), you may have encountered a few of the more unpleasant effects of introducing
    a module system to an ecosystem that’s old enough to order its own beer. The good
    news is it was worth it! As I briefly showed in section 1.7.1, Java 9+ has a lot
    to offer beyond the module system. If you’re in a position to raise your project’s
    Java requirements to 9, you can start using them right away.
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据你的 Java 9+ 迁移过程是否顺利（见第 6 章和第 7 章），你可能已经遇到了将模块系统引入足够成熟到可以自己点啤酒的生态系统的一些不那么愉快的影响。好消息是，这是值得的！正如我在第
    1.7.1 节中简要展示的，Java 9+ 之外还有很多东西可以提供。如果你有机会将你的项目 Java 要求提升到 9，你就可以立即开始使用它们。
- en: You can also finally start modularizing your project. By turning artifacts into
    modular JARs, you and your users can benefit from reliable configuration (see
    section 3.2.1), strong encapsulation (section 3.3.1), decoupling via services
    (see chapter 10), runtime images including entire applications (see 14.2), and
    more module-related goodness. As section 9.3.4 shows, you can even modularize
    projects that run on Java 8 and before.
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你也可以最终开始模块化你的项目。通过将工件转换为模块化 JAR，你和你的用户可以受益于可靠的配置（见第 3.2.1 节）、强大的封装（第 3.3.1 节）、通过服务解耦（见第
    10 章）、包含整个应用程序的运行时镜像（见 14.2 节）以及更多与模块相关的优点。正如第 9.3.4 节所示，你甚至可以模块化运行在 Java 8 及之前的项目。
- en: 'There are two ways to make JARs modular:'
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使 JARs 模块化的有两种方式：
- en: Wait until all your dependencies are modularized, and then create module descriptors
    for all artifacts in one fell swoop.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等到所有依赖项都模块化后，一次性为所有工件创建模块描述符。
- en: Start early by modularizing only artifacts, possibly just a few at a time.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期开始模块化工件，可能一次只模块化几个。
- en: 'Given everything discussed in chapters 3, 4, and 5, implementing the first
    option should be straightforward. You may need some of the more-advanced module
    system features that chapters 10 and 11 present, but other than that, you’re good
    to go: create a module declaration for each artifact you’re building, and model
    their relationships as you learned earlier.'
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑到第3章、第4章和第5章中讨论的所有内容，实现第一个选项应该是直截了当的。你可能需要第10章和第11章中介绍的更高级的模块系统功能，但除此之外，你就可以开始了：为你要构建的每个工件创建一个模块声明，并像你之前学的那样建模它们之间的关系。
- en: Maybe your project sits atop a deep dependency tree, though, and you’re not
    one to wait until all the dependencies are finished modularizing. Or perhaps your
    project is too big to turn all artifacts into modules in one go. In those cases,
    you may be curious about the second option, which allows you to incrementally
    modularize artifacts regardless of whether their dependencies are modular or plain
    JARs.
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，也许你的项目位于一个深层次的依赖树之上，你不愿意等到所有依赖都完成模块化后再进行。或者，也许你的项目太大，无法一次性将所有工件转换为模块。在这些情况下，你可能对第二种选择感兴趣，它允许你无论依赖是否模块化，都可以逐步模块化工件。
- en: Being able to use modular and mon-modular artifacts side by side not only is
    important for individual projects, but also means the ecosystem as a whole can
    embrace modules independently of one another. Without that, the ecosystem’s modularization
    might have taken several decades—this way, everyone should be able to do it within
    one decade.
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 能够同时使用模块化和单模块工件不仅对单个项目很重要，而且意味着整个生态系统可以独立地接受模块。如果没有这一点，生态系统的模块化可能需要几十年的时间——这样，每个人都应该能在十年内完成。
- en: 'This chapter is dedicated to features that enable incrementally modularizing
    existing projects: we start by discussing the combination of class path and module
    path, then examine the unnamed module, and wrap up by looking at automatic modules.
    When you’re done, your project or parts of it will benefit from the module system
    despite potentially unmodularized dependencies. You’ll also be well prepared for
    chapter 9, which discusses strategies for modularizing applications.'
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章致力于介绍能够逐步模块化现有项目的特性：我们首先讨论类路径和模块路径的组合，然后检查未命名的模块，最后通过查看自动模块来结束讨论。当你完成这些步骤后，即使可能存在未模块化的依赖，你的项目或其部分也将从模块化系统中受益。你也将为第9章中讨论的应用程序模块化策略做好充分准备。
- en: 8.1 Why incremental modularization is an option
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.1 为什么逐步模块化是一个选择
- en: Before we get into how to incrementally modularize a project, I want to contemplate
    why that is even an option. Module systems usually require everything to be a
    module. But if they’re late to the game (like the JPMS) or are only used by a
    small share of their ecosystem (like OSGi or JBoss Modules), they can hardly expect
    that to be the case. They have to find a way to interact with mon-modular artifacts.
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我们讨论如何逐步模块化一个项目之前，我想思考一下为什么这是一个选择。模块系统通常要求所有内容都必须是模块。但如果它们来得太晚（比如JPMS）或者只被其生态系统的一小部分使用（比如OSGi或JBoss
    Modules），它们几乎不能期望这种情况发生。它们必须找到一种方式与单模块工件交互。
- en: In this section, we first ponder what would happen if every JAR had to be modular
    to run on Java 9+, leading to the conclusion that it must be possible to mix plain
    JARs and modules (section 8.1.2). I then show how using the class path and the
    module path side by side allows this mix-and-match approach (section 8.1.3).
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本节中，我们首先思考如果每个JAR都必须在Java 9+上模块化才能运行会发生什么，得出结论认为必须能够混合使用普通JAR和模块（第8.1.2节）。然后，我展示了如何使用类路径和模块路径并行使用这种混合匹配方法（第8.1.3节）。
- en: 8.1.1 IF EVERY JAR HAD TO BE MODULAR …
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.1.1 如果每个JAR都必须是模块化的……
- en: If the JPMS was strict and demanded that everything be a module, you could only
    use it if all JARs contained a module descriptor. And because the module system
    is an integral part of Java 9+, by extension you couldn’t even update to it without
    having modularized all your code and dependencies. Imagine the consequences if
    that were the case.
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果JPMS非常严格，要求所有内容都必须是模块，那么只有当所有JAR都包含模块描述符时才能使用它。由于模块系统是Java 9+的一个组成部分，因此，即使没有对代码和依赖进行模块化，也无法升级到它。想象一下如果这种情况发生会有什么后果。
- en: Some projects might update to Java 9+ early, forcing all their users to modularize
    their code bases or stop using the project. Others might not want to force that
    decision or have other reasons not to make the jump, thus holding their users
    back. I wouldn’t want my project to have dependencies that made opposing decisions.
    What could I do?
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些项目可能会提前更新到 Java 9+，迫使所有用户模块化他们的代码库或停止使用该项目。其他人可能不想强迫做出这个决定，或者有其他原因不做出跳跃，从而阻碍他们的用户。我不希望我的项目有导致对立决定的依赖项。我能做什么呢？
- en: Then again, some projects would ship separate variants with and without module
    descriptors, for which they would have to use two entirely disjoint sets of dependencies
    (one with and one without module descriptors). Furthermore, unless they were backporting
    across old major and minor versions, users would be forced to perform a lot of
    (possibly time-consuming) updates all at once to be able to make the jump to Java
    9+. And that doesn’t even consider projects that are no longer maintained, which
    would swiftly become unusable on Java 9+ even if they didn’t have any dependencies
    themselves.
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，一些项目会提供带有和不带有模块描述符的独立变体，为此他们必须使用两组完全不同的依赖项（一个带有，一个不带模块描述符）。此外，除非他们是在旧的主版本和次版本之间回溯，否则用户将被迫一次性进行大量（可能是耗时）的更新，才能跳转到
    Java 9+。而且这还不考虑那些不再维护的项目，即使它们自己没有任何依赖项，在 Java 9+ 上也会迅速变得无法使用。
- en: 'The only way to avoid wasted effort and a deep split would be for the entire
    ecosystem to have a day on which every project updated to Java 9+ and started
    to release modular JARs. But there’s no way that would work. And whichever way
    we sliced it, anyone executing a JAR would have to know which Java version it
    was created for, because it wouldn’t work on 8 and 9\. In summary: we’d be in
    big trouble!'
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 避免浪费努力和深度分裂的唯一方法是在整个生态系统有一个日子，所有项目都更新到 Java 9+ 并开始发布模块化 JAR 文件。但这是不可能实现的。无论我们如何分割，执行
    JAR 文件的人都必须知道它是为哪个 Java 版本创建的，因为它在 8 和 9 上无法工作。总的来说：我们会陷入大麻烦！
- en: 8.1.2 MIXING AND MATCHING PLAIN JARS WITH MODULES
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.1.2 将普通 JAR 文件与模块混合使用
- en: To bypass that trouble, the module system must offer a way to run mon-modularized
    code on top of the modularized JVM. In the introduction to chapter 6, I explain
    that this is indeed the case and that plain JARs on the class path work just as
    they did before Java 9+. (As chapters 6 and 7 explain, the code they contain may
    not function, but that’s a different matter.) Section 8.2 explains how class-path
    mode works.
  id: totrans-554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了绕过这个麻烦，模块系统必须提供一种方法，在模块化的 JVM 上运行单模块化代码。在第 6 章的引言中，我解释了这确实如此，并且类路径上的普通 JAR
    文件与 Java 9+ 之前的工作方式一样。（正如第 6 章和第 7 章所解释的，它们包含的代码可能无法运行，但这又是另一个问题。）第 8.2 节解释了类路径模式是如何工作的。
- en: 'Just the fact that it works is already an important revelation: the module
    system can handle mon-modularized artifacts and knows how to navigate the boundary
    between them and explicit modules. That’s good news—and there’s more: that boundary
    isn’t set in stone. It doesn’t have to separate application JARs from JVM modules.
    As [figure 8.1](part0022.html#filepos965015) shows and the rest of this chapter
    explores, the module system allows you to move that boundary and to mix and match
    modularized and mon-modularized application JARs with platform modules as your
    projects require.'
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仅仅它能工作就已经是一个重要的启示：模块系统可以处理单模块化工件，并且知道如何在这些工件和显式模块之间导航边界。这是个好消息——而且还有更多：这个边界不是一成不变的。它不必将应用程序
    JAR 文件与 JVM 模块分开。正如 [图 8.1](part0022.html#filepos965015) 所示，以及本章的其余部分所探讨的，模块系统允许你移动这个边界，并根据项目需求混合和匹配模块化和单模块化应用程序
    JAR 文件与平台模块。
- en: '![](../images/00115.jpeg)'
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00115.jpeg)'
- en: '[Figure 8.1](part0022.html#filepos964484) The module system allows non-modular
    code to run on a modular JDK (left). More important, it gives you the tools to
    move that boundary (right).'
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 8.1](part0022.html#filepos964484) 模块系统允许非模块化代码在模块化 JDK 上运行（左）。更重要的是，它为你提供了移动这个边界的工具（右）。'
- en: 8.1.3 TECHNICAL UNDERPINNINGS OF INCREMENTAL MODULARIZATION
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.1.3 增量模块化的技术基础
- en: The basic principle that makes incremental modularization possible is that the
    class path and module path can be used side by side. There is no need to move
    all application JARs from the class to the module path in one go. Instead, existing
    projects are encouraged to start on the class path and then slowly move their
    artifacts to the module path as modularization efforts progress.
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使增量模块化成为可能的基本原则是类路径和模块路径可以并行使用。没有必要一次性将所有应用程序 JAR 从类路径移动到模块路径。相反，鼓励现有项目从类路径开始，然后随着模块化工作的进展，逐渐将它们的工件移动到模块路径。
- en: Using both paths at the same time with plain as well as modular JARs requires
    a clear understanding of how these concepts relate. You may be thinking that JARs
    lacking a module descriptor go onto the class path and that modular JARs go onto
    the module path. Although I never said it like that, you’d be excused for having
    read between the lines. Nevertheless, that theory is wrong, and now is the time
    to let go of it.
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同时使用类路径以及平凡和模块化 JAR 的路径需要对这些概念之间关系的清晰理解。你可能认为没有模块描述符的 JAR 会进入类路径，而模块化 JAR 会进入模块路径。尽管我从未那样说过，但你可能会从字里行间读出这样的意思。然而，那个理论是错误的，现在是时候放下它了。
- en: 'Two mechanisms invalidate that theory and make incremental modularization possible:'
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两种机制使那个理论无效，并使增量模块化成为可能：
- en: The unnamed module is implicitly created by the module system with all the content
    loaded from the class path. In it, the chaos of the class path lives on. (Section
    8.2 explains in detail.)
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未命名模块是由模块系统隐式创建的，其中包含从类路径加载的所有内容。在这里，类路径的混乱得以延续。（第 8.2 节详细解释。）
- en: An automatic module is created by the module system for each plain JAR it finds
    on the module path. (Section 8.3 is dedicated to this concept.)
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块系统为它在模块路径上找到的每个平凡 JAR 创建一个自动模块。（第 8.3 节专门介绍这个概念。）
- en: 'The class path makes no distinction between plain and modular JARs: if it’s
    on the class path, it ends up in the unnamed module. Similarly, the module path
    makes little distinction between plain and modular JARs: if it’s on the module
    path, it ends up as its own named module. (For plain JARs, the module system creates
    an automatic module; for modular JARs, it creates an explicit module according
    to the description.)'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类路径对平凡和模块化 JAR 没有区别：如果它在类路径上，它最终会进入未命名模块。同样，模块路径对平凡和模块化 JAR 的区别也很小：如果它在模块路径上，它最终会变成它自己的命名模块。（对于平凡
    JAR，模块系统创建一个自动模块；对于模块化 JAR，它根据描述创建一个显式模块。）
- en: To understand the rest of this chapter as well as to perform a modularization,
    it’s important to fully internalize that behavior. [Table 8.1](part0022.html#filepos968581)
    shows a two-dimensional recast. Not the type of JAR (plain or modular) but the
    path it’s placed on (class path or module path) determines whether it becomes
    part of the unnamed module or a named module.
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要理解本章的其余部分以及执行模块化，重要的是要完全理解这种行为。[表 8.1](part0022.html#filepos968581) 展示了一个二维重构。不是
    JAR 的类型（平凡或模块化），而是它放置的路径（类路径或模块路径）决定了它是否成为未命名模块的一部分或命名模块。
- en: Table 8.1 It isn’t the type of the JAR but the path it’s placed on that determines
    whether a class ends up as a named module or in the unnamed module.
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表 8.1 并不是 JAR 的类型（平凡或模块化）决定了类最终成为命名模块还是未命名模块，而是它放置的路径（类路径或模块路径）。
- en: '|    | Class path   | Module path   |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '|    | 类路径   | 模块路径   |'
- en: '| Plain JAR   | Unnamed module (section 8.2)   | Automatic module (section
    8.3)   |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| 平凡 JAR   | 未命名模块（第 8.2 节）   | 自动模块（第 8.3 节）   |'
- en: '| Modular JAR   |    | Explicit module (section 3.1.4)   |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| 模块化 JAR   |    | 显式模块（第 3.1.4 节）   |'
- en: When deciding whether to place a JAR on the class path or the module path, it’s
    not about where the code comes from (is the JAR modular?); it’s about where you
    need the code to be (in the unnamed or a named module). The class path is for
    code you want to go into the ball of mud, and the module path is for code you
    want to be a module.
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在决定将 JAR 放置在类路径或模块路径上时，并不是关于代码来自哪里（JAR 是否模块化？）；而是关于你需要代码在何处（在未命名模块或命名模块中）。类路径是用于你想进入泥球代码的代码，而模块路径是用于你想成为模块的代码。
- en: But how do you decide where code needs to go? As a general guideline, the unnamed
    module is about compatibility, enabling projects using the class path to work
    on Java 9+; whereas automatic modules are about modularization, allowing projects
    to use the module system even if dependencies aren’t yet modularized.
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但你如何决定代码应该放在哪里？作为一个一般准则，未命名模块关乎兼容性，使得使用类路径的项目能够在 Java 9+ 上工作；而自动模块关乎模块化，即使依赖项尚未模块化，也允许项目使用模块系统。
- en: For a more detailed answer, it’s time to look more closely at the unnamed and
    automatic modules. Chapter 9 then defines larger modularization strategies. If
    you’re wondering whether modularizing an existing project is worth the hassle,
    take a look at section 15.2.1.
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了得到更详细的答案，现在是时候更仔细地研究未命名的和自动模块了。第9章随后定义了更大的模块化策略。如果您在考虑是否值得麻烦对现有项目进行模块化，请参阅第15.2.1节。
- en: NOTE Your build tool may make a lot of these decisions for you. You’re still
    likely to end up in situations where something went wrong, though, in which case
    you can apply what we explore in this chapter to correctly configure your build.
  id: totrans-573
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：您的构建工具可能会为您做出很多这些决定。尽管如此，您仍然可能会遇到某些事情出错的情况，在这种情况下，您可以应用本章中探讨的内容来正确配置您的构建。
- en: 8.2 The unnamed module, aka the class path
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.2 未命名的模块，即类路径
- en: 'There’s one aspect I haven’t yet explained in detail: how do the module system
    and the class path work together? The first part of the book gives a clear view
    of how modular applications place everything on the module path and run on the
    modularized JDK. Then came chapters 6 and 7, which are big on compiling non-modular
    code and running applications from the class path. But how does the class-path
    content interact with the module system? Which modules are resolved, and how?
    Why can the class-path content access all platform modules? The unnamed module
    answers these questions.'
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我还没有详细解释的一个方面是：模块系统和类路径是如何一起工作的？本书的第一部分清楚地说明了模块化应用程序如何将一切放置在模块路径上，并在模块化的JDK上运行。然后是第6章和第7章，它们主要涉及编译非模块化代码和从类路径运行应用程序。但是类路径内容是如何与模块系统交互的？哪些模块被解析，以及如何解析？为什么类路径内容可以访问所有平台模块？未命名的模块回答了这些问题。
- en: Exploring them has more than academic value. Unless an application is fairly
    small, it probably can’t be modularized all at once; but incremental modularization
    involves mixing JARs and modules, class path and module path. This makes it important
    to understand the underlying details of how the module system’s class-path mode
    works.
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 探索它们不仅仅具有学术价值。除非应用程序相当小，否则它可能无法一次性全部模块化；但是增量模块化涉及到混合JAR和模块、类路径和模块路径。这使得理解模块系统类路径模式的工作底层细节变得很重要。
- en: NOTE The mechanisms surrounding the unnamed module generally apply at compile
    time and run time, but always mentioning both needlessly bloats the text. Instead,
    I describe runtime behavior and only mention compile time if the behavior isn’t
    exactly the same.
  id: totrans-577
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：围绕未命名的模块的机制通常在编译时和运行时适用，但总是提及两者是不必要的，会使文本膨胀。相反，我描述运行时行为，只有在行为确实不同时才提及编译时。
- en: The unnamed module contains all mon-modular classes, which are
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 未命名的模块包含所有单模块类，这些类
- en: At compile time, the classes being compiled, if they don’t include a module
    descriptor
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时，正在编译的类，如果它们没有包含模块描述符
- en: At compile time and run time, all classes loaded from the class path
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时和运行时，从类路径加载的所有类
- en: 'As section 3.1.3 describes, all modules have three central properties, and
    this is also true for the unnamed module:'
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第3.1.3节所述，所有模块都有三个核心属性，这同样适用于未命名的模块：
- en: Name —The unnamed module has none (makes sense, right?), which means no other
    module can mention it in their declarations (for example, to require it).
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称——未命名的模块没有名称（这是合理的，对吧？），这意味着没有其他模块可以在它们的声明中提及它（例如，为了要求它）。
- en: Dependencies —The unnamed module reads all other modules that make it into the
    graph.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系——未命名的模块读取所有进入图的模块。
- en: Exports —The unnamed module exports all its packages and also opens them for
    reflection (see section 12.2 for details on open packages and modules).
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出——未命名的模块导出其所有包，并且也允许它们进行反射（有关开放包和模块的详细信息，请参阅第12.2节）。
- en: In contrast to the unnamed module, all other modules are said to be named. Services
    provided in `META-INF/services` are made available to the `ServiceLoader`. See
    chapter 10 for an introduction to services and particularly section 10.2.6 for
    their interaction with the unnamed module.
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与未命名的模块相反，所有其他模块都被认为是命名的。`META-INF/services`中提供的服务对`ServiceLoader`可用。有关服务的介绍，请参阅第10章，特别是第10.2.6节，以了解它们与未命名的模块的交互。
- en: Although it isn’t exactly straightforward, the concept of the unnamed module
    makes sense. Here you have the orderly module graph, and over there, a little
    to the side, you have the chaos of the class path, lumped into its own free-for-all
    module with some special properties (see [figure 8.2](part0022.html#filepos980942)).
    (To not make matters more complicated than they have to be, I didn’t tell you
    at the time, but the unnamed module underlies all of chapters 6 and 7, where you
    could replace every occurrence of class-path content with unnamed module.)
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这并不完全直接，但未命名模块的概念是有意义的。这里你有有序的模块图，而那边，稍微偏一点，你有类路径的混乱，它被组合成自己的自由模块，具有一些特殊属性（见[图8.2](part0022.html#filepos980942)）。（为了不让事情比必要的更复杂，我没有当时告诉你，但未命名模块是第6章和第7章的基础，在那里你可以用未命名模块替换类路径内容的每个出现。）
- en: Let’s get back to the ServiceMonitor application and assume it was written before
    Java 9\. The code and its organization are identical to what we discussed in previous
    chapters, but it lacks module declarations, so you create plain JARs instead of
    modular JARs.
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们回到ServiceMonitor应用程序，并假设它是在Java 9之前编写的。代码及其组织与我们之前章节中讨论的相同，但它缺少模块声明，因此你创建的是普通JAR文件而不是模块JAR文件。
- en: 'Assuming the `jars` folder contains all application JARs and `libs` contains
    all dependencies, you can launch the application as follows:'
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设`jars`文件夹包含所有应用程序JAR文件，而`libs`包含所有依赖项，你可以按以下方式启动应用程序：
- en: '`$ java --class-path ''jars/*'':''libs/*'' monitor.Main`'
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --class-path ''jars/*'':''libs/*'' monitor.Main`'
- en: This works on Java 9+, and, aside from the alternative form of the `--class-path`
    option, it does the same on Java 8 and earlier. [Figure 8.2](part0022.html#filepos980942)
    shows the module graph the module system creates for this launch configuration.
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这在Java 9及更高版本中有效，除了`--class-path`选项的替代形式外，在Java 8和更早版本中也做同样的事情。[图8.2](part0022.html#filepos980942)显示了模块系统为这种启动配置创建的模块图。
- en: '![](../images/00051.jpeg)'
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00051.jpeg)'
- en: '[Figure 8.2](part0022.html#filepos978573) Launched with all application JARs
    on the class path, the module system builds a module graph from the platform modules
    (left) and assigns all classes on the class path to the unnamed module (right),
    which can read all other modules'
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图8.2](part0022.html#filepos978573)当所有应用程序JAR文件都在类路径上启动时，模块系统从平台模块（左侧）构建一个模块图，并将类路径上的所有类分配给未命名模块（右侧），该模块可以读取所有其他模块'
- en: Armed with that understanding, you’re well prepared to run simple, mon-modular
    applications from the class path. Beyond that basic use case, and particularly
    when slowly modularizing an application, the subtleties of the unnamed module
    become relevant, so we look at them next.
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 带着这种理解，你已准备好从类路径运行简单的单模块应用程序。超出这个基本用例，尤其是在逐步模块化应用程序时，未命名模块的细微之处变得相关，因此我们接下来看看它们。
- en: 8.2.1 THE CHAOS OF THE CLASS PATH, CAPTURED BY THE UNNAMED MODULE
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.2.1 未命名模块捕捉到的类路径混乱
- en: The unnamed module’s main goal is to capture class-path content and make it
    work in the module system. Because there were never any boundaries between JARs
    on the class path, it makes no sense to establish them now; so having a single
    unnamed module for the entire class path is a reasonable decision. Within it,
    just like on the class path, all public classes are accessible and the concept
    of split packages doesn’t exist.
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 未命名模块的主要目标是捕获类路径内容，使其在模块系统中工作。由于类路径上的JAR文件之间从未有过边界，现在建立它们是没有意义的；因此，为整个类路径保留一个未命名模块是一个合理的决定。在其内部，就像在类路径上一样，所有公共类都是可访问的，并且不存在分割包的概念。
- en: The unnamed module’s distinct role and its focus on backward compatibility give
    it a few special properties. You saw in section 7.1 that at run time, strong encapsulation
    of platform modules is mostly disabled for code in the unnamed module (at least
    on Java 9, 10, and 11). When we discussed split packages in section 7.2, you discovered
    that the unnamed module isn’t scanned, so package splits between it and other
    modules aren’t discovered and the class path portion isn’t available.
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 未命名模块的独特角色及其对向后兼容性的关注赋予它一些特殊属性。你在7.1节中看到，在运行时，平台模块的强封装对于未命名模块中的代码大部分是禁用的（至少在Java
    9、10和11中）。当我们讨论7.2节中的分割包时，你发现未命名模块没有被扫描，因此它与其他模块之间的包分割没有被发现，类路径部分也不可用。
- en: 'One detail that’s a little counterintuitive and easy to get wrong is what constitutes
    the unnamed module. It seems obvious that modular JARs become modules and hence
    plain JARs go into the unnamed module, right? As explained in section 8.1.3, this
    is wrong: the unnamed module is in charge of all JARs on the class path, modular
    or not.'
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有一个细节稍微有些反直觉且容易出错，那就是未命名模块的构成。看起来很明显，模块化 JAR 文件变成了模块，因此普通的 JAR 文件进入未命名模块，对吧？如第
    8.1.3 节所述，这是错误的：未命名模块负责类路径上的所有 JAR 文件，无论是模块化还是非模块化。
- en: As a consequence, modular JARs aren’t bound to be loaded as modules! If a library
    starts delivering modular JARs, its users are by no means forced to use them as
    modules. Users can instead leave them on the class path, where their code is bundled
    into the unnamed module. As section 9.2 explains in more detail, this allows the
    ecosystem to modularize almost independently of one another.
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，模块化 JAR 文件并不一定必须作为模块加载！如果一个库开始提供模块化 JAR 文件，其用户并不一定被迫使用它们作为模块。用户可以选择将它们留在类路径上，这样它们的代码就被捆绑到未命名模块中。如第
    9.2 节更详细地解释，这允许生态系统几乎独立地进行模块化。
- en: 'As an example, let’s launch the fully modularized version of ServiceMonitor,
    once from the class path and once from the module path:'
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，让我们启动 ServiceMonitor 的完全模块化版本，一次从类路径启动，一次从模块路径启动：
- en: '`$ java --class-path ''mods/*'':''libs/*'' -jar monitor $ java --module-path
    mods:libs --module monitor`'
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --class-path ''mods/*'':''libs/*'' -jar monitor $ java --module-path
    mods:libs --module monitor`'
- en: Both work fine and without any obvious differences.
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这两种方法都运行良好，且没有明显的差异。
- en: One way to see how the module system treats both cases is to use an API that
    we take a closer look at in section 12.3.3\. You can call `getModule` on a class
    to get the module it belongs to and then call `getName` on that module to see
    what it’s called. For the unnamed module, `getName` returns `null`.
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要了解模块系统如何处理这两种情况，可以使用我们在第 12.3.3 节中更详细探讨的 API。您可以在一个类上调用 `getModule` 来获取它所属的模块，然后在该模块上调用
    `getName` 来查看它的名称。对于未命名模块，`getName` 返回 `null`。
- en: 'Let’s include the following lines of code in `Main`:'
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们在 `Main` 中包含以下代码行：
- en: '`String moduleName = Main.class.getModule().getName(); System.out.println("Module
    name: " + moduleName);`'
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`String moduleName = Main.class.getModule().getName(); System.out.println("Module
    name: " + moduleName);`'
- en: 'When launched from the class path, the output is `Module name: null`, indicating
    that the `Main` class ended up in the unnamed module. When launched from the module
    path, you get the expected `Module name: monitor`.'
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '从类路径启动时，输出为 `Module name: null`，表明 `Main` 类最终进入了未命名模块。从模块路径启动时，您会得到预期的 `Module
    name: monitor`。'
- en: 'Section 5.2.3 discusses how the module system encapsulates resources in packages.
    This only partly applies to the unnamed module: within a module, there are no
    access restrictions (so all JARs on the class path can access resources from one
    another), and the unnamed module opens all packages to reflection (so all modules
    can access resources from JARs on the class path). Strong encapsulation does apply
    to access from the unnamed to a named module, though.'
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 5.2.3 节讨论了模块系统如何将资源封装在包中。这仅部分适用于未命名模块：在模块内部，没有访问限制（因此类路径上的所有 JAR 文件都可以相互访问资源），未命名模块向所有包开放反射（因此所有模块都可以访问类路径上的
    JAR 文件中的资源）。然而，从未命名模块到命名模块的访问确实应用了强封装。
- en: 8.2.2 MODULE RESOLUTION FOR THE UNNAMED MODULE
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.2.2 未命名模块的模块解析
- en: An important aspect of the unnamed module’s relation to the rest of the module
    graph is which other modules it can read. As described, it can read all modules
    that make it into the graph. But which modules are those?
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 未命名模块与模块图其他部分关系的一个重要方面是它可以读取哪些其他模块。如前所述，它可以读取所有进入图中的模块。但那些模块是哪些呢？
- en: Remember from section 3.4.1 that module resolution builds a module graph by
    starting with the root modules (particularly the initial module) and then iteratively
    adding all their direct and transitive dependencies. How would that work if the
    code under compilation or the application’s `main` method is in the unnamed module,
    as is the case when launching an application from the class path? After all, plain
    JARs don’t express any dependencies.
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住第 3.4.1 节的内容，模块解析通过从根模块（特别是初始模块）开始构建模块图，然后迭代地添加所有它们的直接和传递依赖项。如果编译下的代码或应用程序的
    `main` 方法在未命名模块中，就像从类路径启动应用程序时那样，这将如何工作？毕竟，普通 JAR 文件不表达任何依赖项。
- en: 'If the initial module is the unnamed one, module resolution starts in a predefined
    set of root modules. As a rule of thumb, these are the system modules (see section
    3.1.4) that don’t contain JEE APIs, but the actual rule is a little more detailed:'
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果初始模块是没有命名的模块，模块解析将从预定义的根模块集合开始。一般来说，这些是不包含JEE API的系统模块（参见第3.1.4节），但实际规则要详细一些：
- en: 'The precise set of java.* modules that become root depends on the presence
    of the java.se module (the module representing the entire Java SE API—it’s present
    in full Java images but may be absent from custom runtime images created with
    `jlink`):'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为根模块的java.*模块的精确集合取决于java.se模块的存在（代表整个Java SE API的模块——它在完整的Java镜像中存在，但可能不在使用`jlink`创建的自定义运行时镜像中）：
- en: If java.se is observable, it becomes root.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果java.se是可观察的，它就变成根模块。
- en: If it isn’t, every java.* system module and java.* module from the upgrade module
    path that exports at least one package without qualification (meaning without
    limitation to who can access the package—see section 11.3) becomes root.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是这样，每个java.*系统模块和来自升级模块路径的java.*模块（如果至少导出一个未加限定的包，意味着不受限于谁可以访问该包——参见第11.3节）都成为根模块。
- en: Beyond java.* modules, every other system module and module on the upgrade module
    path that isn’t an incubating module and exports at least one package without
    qualification becomes a root module. This is particularly relevant to jdk.* and
    javafx.* modules.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了java.*模块之外，所有其他系统模块以及升级模块路径上的模块（如果不是孵化模块并且至少导出一个未加限定的包）都成为根模块。这对于jdk.*和javafx.*模块尤其相关。
- en: Modules defined with `--add-modules` (see section 3.4.3) are always root modules.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--add-modules`定义的模块（参见第3.4.3节）始终是根模块。
- en: '![](../images/00080.jpeg)'
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00080.jpeg)'
- en: '[Figure 8.3](part0022.html#filepos992285) Which modules become the root for
    module resolution (see section 3.4.1) depends on whether the initial module was
    defined with `--module` (if not, the unnamed module is the initial one) and whether
    java.se is observable. In any case, modules defined with `--add-modules` are always
    root modules.'
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图8.3](part0022.html#filepos992285) 模块解析的根模块（参见第3.4.1节）取决于初始模块是否使用`--module`定义（如果没有，则无命名的模块是初始模块）以及java.se是否可观察。在任何情况下，使用`--add-modules`定义的模块始终是根模块。'
- en: This is a little complicated (see [figure 8.3](part0022.html#filepos991148)
    for a visualization), but it may become important in edge cases. The rule of thumb
    that all system modules except the JEE and incubating ones are resolved should
    cover at least 90% of cases.
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这有点复杂（参见[图8.3](part0022.html#filepos991148)以获取可视化），但在边缘情况下可能会变得很重要。所有系统模块（除了JEE和孵化模块）都应解决的规则应该至少覆盖90%的情况。
- en: 'As an example, you can run `java --show-module-resolution` and observe the
    first few lines of output:'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，你可以运行`java --show-module-resolution`并观察输出的前几行：
- en: '`> root java.se jrt:/java.se > root jdk.xml.dom jrt:/jdk.xml.dom > root javafx.web
    jrt:/javafx.web > root jdk.httpserver jrt:/jdk.httpserver > root javafx.base jrt:/javafx.base
    > root jdk.net jrt:/jdk.net > root javafx.controls jrt:/javafx.controls > root
    jdk.compiler jrt:/jdk.compiler > root oracle.desktop jrt:/oracle.desktop > root
    jdk.unsupported jrt:/jdk.unsupported`'
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 根 java.se jrt:/java.se > 根 jdk.xml.dom jrt:/jdk.xml.dom > 根 javafx.web jrt:/javafx.web
    > 根 jdk.httpserver jrt:/jdk.httpserver > 根 javafx.base jrt:/javafx.base > 根 jdk.net
    jrt:/jdk.net > 根 javafx.controls jrt:/javafx.controls > 根 jdk.compiler jrt:/jdk.compiler
    > 根 oracle.desktop jrt:/oracle.desktop > 根 jdk.unsupported jrt:/jdk.unsupported`'
- en: This isn’t the entire output, and the order could be different on your system.
    But starting at the top, you can see that java.se is the only java.* module. Then
    there are a bunch of jdk.* and javafx.* modules (spot jdk.unsupported from section
    7.1.1) as well as an oracle.* module (no idea what that one does).
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这不是完整的输出，并且在不同系统上的顺序可能不同。但从顶部开始，你可以看到java.se是唯一的java.*模块。然后有一系列jdk.*和javafx.*模块（注意第7.1.1节中的jdk.unsupported）以及一个oracle.*模块（不知道这个模块做什么）。
- en: ESSENTIAL INFO Note that with the unnamed module as the initial one, the set
    of root modules is always a subset of the system modules contained in the runtime
    image. Modules present on the module path will never be resolved unless added
    explicitly with`--add-modules`. If you handcrafted the module path to contain
    exactly the modules you need, you may want to add all of them with `--add-modules
    ALL-MODULE-PATH`, as explained in section 3.4.3.
  id: totrans-622
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要信息注意，如果没有命名的模块作为初始模块，根模块集合始终是运行时图像中包含的系统模块的子集。除非显式添加`--add-modules`，否则模块路径上存在的模块永远不会被解析。如果你手工制作模块路径以包含你需要的所有模块，你可能想使用`--add-modules
    ALL-MODULE-PATH`将它们全部添加，如第3.4.3节所述。
- en: 'You can easily observe that behavior by launching ServiceMonitor from the module
    path without defining an initial module:'
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以通过从模块路径启动 ServiceMonitor 而不定义初始模块来轻松观察到这种行为：
- en: '`$ java --module-path mods:libs monitor.Main  > Error: Could not find or load
    main class monitor.Main > Caused by: java.lang.ClassNotFoundException: monitor.Main`'
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path mods:libs monitor.Main  > 错误：找不到或加载主类 monitor.Main >
    原因：java.lang.ClassNotFoundException: monitor.Main`'
- en: Running the same command with `--show-module-resolution` confirms that no monitor.*
    modules are resolved. To fix that, you can either use `--add-modules monitor`,
    in which case monitor is added to the list of root modules, or `--module monitor/monitor.Main`,
    in which case monitor becomes the only root module (the initial module).
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `--show-module-resolution` 运行相同的命令确认没有解析出 monitor.* 模块。要修复这个问题，您可以使用 `--add-modules
    monitor`，在这种情况下，monitor 被添加到根模块列表中，或者使用 `--module monitor/monitor.Main`，在这种情况下，monitor
    成为唯一的根模块（初始模块）。
- en: 8.2.3 DEPENDING ON THE UNNAMED MODULE
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.2.3 依赖于未命名的模块
- en: 'One of the module system’s primary goals is reliable configuration: a module
    must express its dependencies, and the module system must be able to guarantee
    their presence. We settled that in section 3.2 for explicit modules with a module
    descriptor. What would happen if you tried to expand reliable configuration to
    the class path?'
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统的主要目标之一是可靠的配置：一个模块必须表达其依赖关系，并且模块系统必须能够保证它们的可用性。我们在第 3.2 节中为具有模块描述符的显式模块解决了这个问题。如果您尝试将可靠的配置扩展到类路径，会发生什么？
- en: Let’s make a thought experiment. Imagine modules could depend on the class-path
    content, maybe with something like `requires class-path` in their descriptor.
    What guarantees could the module system make for such a dependency? As it turns
    out, almost none. As long as there is at least one class on the class path, the
    module system would have to assume the dependency is fulfilled. That wouldn’t
    be helpful (see [figure 8.4](part0022.html#filepos998569)).
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们做一个思想实验。想象模块可以依赖于类路径内容，也许在它们的描述符中使用 `requires class-path`。模块系统可以为这样的依赖提供哪些保证？实际上，几乎没有。只要类路径上至少有一个类，模块系统就必须假设依赖已经满足。这不会很有帮助（参见[图
    8.4](part0022.html#filepos998569)）。
- en: '![](../images/00100.jpeg)'
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00100.jpeg)'
- en: '[Figure 8.4](part0022.html#filepos998257) If com.framework depended on some
    class-path content with the hypothetical `requires class-path`, the module system
    couldn’t determine whether that requirement was fulfilled (left). If you build
    your application on that framework, you wouldn’t know what to do to fulfill that
    dependency (right).'
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 8.4](part0022.html#filepos998257) 如果 com.framework 依赖于一些具有假设的 `requires
    class-path` 的类路径内容，模块系统无法确定该要求是否满足（左）。如果您在这个框架上构建应用程序，您就不知道如何满足这个依赖（右）。'
- en: Even worse, it would seriously undermine reliable configuration, because you
    might end up depending on a module that `requires class-path`. Well, that contains
    next to no information—what exactly needs to go on the class path (again, see
    [figure 8.4](part0022.html#filepos998569))?
  id: totrans-631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更糟糕的是，它将严重破坏可靠的配置，因为您可能最终依赖于一个 `requires class-path` 的模块。嗯，这几乎不包含任何信息——需要将什么放在类路径上（再次参见[图
    8.4](part0022.html#filepos998569)）？
- en: 'Spinning this hypothetical even further, imagine two modules, com.framework
    and org.library, depended on the same third module, say SLF4J. One declared the
    dependency before SLF4J was modularized and hence `requires class-path`; the other
    declared its dependency on a modularized SLF4J and hence `requires org.slf4j`
    (assuming that’s the module name). Now, on which path would anybody depending
    on com.framework and org.library place the SLF4J JAR? Whichever they chose: the
    module system had to determine that one of the two transitive dependencies wasn’t
    fulfilled. [Figure 8.5](part0022.html#filepos1001698) shows this hypothetical
    situation.'
  id: totrans-632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将这个假设进一步扩展，想象有两个模块，com.framework 和 org.library，它们依赖于同一个第三方模块，比如 SLF4J。一个在 SLF4J
    模块化之前声明了依赖，因此 `requires class-path`；另一个在模块化的 SLF4J 上声明了依赖，因此 `requires org.slf4j`（假设这是模块名）。现在，任何依赖于
    com.framework 和 org.library 的人会在哪个路径上放置 SLF4J JAR？无论他们选择哪个：模块系统都必须确定这两个传递依赖中的一个是未满足的。[图
    8.5](part0022.html#filepos1001698) 展示了这种情况。
- en: '![](../images/00110.jpeg)'
  id: totrans-633
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00110.jpeg)'
- en: '[Figure 8.5](part0022.html#filepos1001353) If com.framework depended on SLF4J
    with the hypothetical `requires class-path` and org.library required it as a module
    with `requires org.slf4j`, there would be no way to satisfy both requirements.
    Whether SLF4J was placed on the class path (left) or the module path (right),
    one of the two dependencies would be considered unfulfilled.'
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图8.5](part0022.html#filepos1001353) 如果com.framework依赖于SLF4J，假设使用`requires
    class-path`，而org.library以`requires org.slf4j`作为模块依赖它，那么将无法满足这两个要求。无论SLF4J是放在类路径上（左）还是模块路径上（右），这两个依赖项中的一个将被视为未满足。'
- en: Thinking this through leads to the conclusion that depending on arbitrary class-path
    content isn’t a good idea if you want reliable modules. And for that reason, there’s
    no `requires class-path`.
  id: totrans-635
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 深思熟虑后得出结论，如果你想要可靠的模块，依赖于任意的类路径内容并不是一个好主意。因此，没有`requires class-path`。
- en: How do we best express that the module that ends up holding the class-path content
    can’t be depended on? In a module system that uses names to reference other modules?
    Not giving that module a name—making it unnamed, so to speak—sounds reasonable.
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们如何最好地表达最终持有类路径内容的模块无法被依赖？在一个使用名称来引用其他模块的模块系统中？不给该模块命名——换句话说，使其成为未命名的模块——听起来是合理的。
- en: 'And there you have it: the unnamed module has no name because no module is
    supposed to ever reference it in a `requires` directive—or any other directive,
    for that matter. Without `requires`, there’s no readability edge, and without
    that edge, code in the unnamed module is inaccessible to modules.'
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由此可知：未命名的模块没有名称，因为没有模块应该在任何`requires`指令或其他指令中引用它。没有`requires`，就没有可读性的优势，而没有这种优势，未命名的模块中的代码对其他模块不可访问。
- en: In summary, for an explicit module to depend on an artifact, that artifact has
    to be on the module path. As mentioned in section 8.1.3, this may mean you place
    plain JARs on the module path, which turns them into automatic modules—a concept
    we explore next.
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结来说，为了使显式模块依赖于一个工件，该工件必须位于模块路径上。如第8.1.3节所述，这可能意味着你将纯JAR放在模块路径上，这样它们就变成了自动模块——这是我们接下来要探讨的概念。
- en: '8.3 Automatic modules: Plain JARs on the module path'
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.3 自动模块：模块路径上的纯JAR
- en: The long-term goal of any modularization effort is to upgrade plain JARs to
    modular JARs and to move them from the class path to the module path. One way
    to get there is to wait until all your dependencies come to you as modules and
    then modularize your own project—this is a bottom-up approach. That could be a
    long wait, though, so the module system also allows top-down modularization.
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何模块化工作的长期目标都是将纯JAR升级为模块化JAR，并将它们从类路径移动到模块路径。达到这一目标的一种方法是在所有依赖项都以模块的形式到达你这里之后，然后模块化你的项目——这是一种自下而上的方法。但这可能需要很长时间，因此模块系统也允许自顶向下的模块化。
- en: 'Section 9.2 explains both approaches in detail, but for the top-down approach
    to work you first need a new ingredient. Think about it: how can you declare a
    module if your dependencies come in plain JARs? As you saw in section 8.2.3, if
    you place them on the class path, they end up in the unnamed module, and your
    module can’t access that. But you paid attention in section 8.1.3, so you know
    that plain JARs can also go onto the module path, where the module system automatically
    creates modules for them.'
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第9.2节详细解释了两种方法，但为了自顶向下的方法能够工作，你首先需要一个新成分。想想看：如果你的依赖项以纯JAR的形式出现，你如何声明一个模块？正如你在第8.2.3节中看到的，如果你将它们放在类路径上，它们最终会进入未命名的模块，而你的模块无法访问它。但在第8.1.3节中你注意到了，所以你知道纯JAR也可以放在模块路径上，模块系统会自动为它们创建模块。
- en: NOTE The mechanisms surrounding automatic modules generally apply at compile
    time and run time. As I said earlier, always mentioning both adds little information
    and makes the text harder to read.
  id: totrans-642
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：自动模块周围的机制通常在编译时间和运行时适用。正如我之前所说的，总是提及两者添加的信息很少，并且使文本更难阅读。
- en: 'For every JAR on the module path that has no module descriptor, the module
    system creates an automatic module. Like any other named module, it has three
    central properties (see section 3.1.3):'
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于模块路径上每个没有模块描述符的JAR，模块系统都会创建一个自动模块。像任何其他命名模块一样，它有三个核心属性（见第3.1.3节）：
- en: Name —An automatic module’s name can be defined in the JAR’s manifest with the
    `Automatic-Module-Name` header. If it’s missing, the module system generates a
    name from the filename.
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称——自动模块的名称可以在JAR的清单中使用`Automatic-Module-Name`头定义。如果它缺失，模块系统会从文件名生成一个名称。
- en: Dependencies —An automatic module reads all other modules that make it into
    the graph, including the unnamed module (as you’ll see soon, this is important).
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系——自动模块读取所有进入图的模块，包括未命名的模块（正如你很快就会看到的，这很重要）。
- en: Exports —An automatic module exports all its packages and also opens them for
    reflection (see section 12.2 for details on open packages and modules).
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出——自动模块导出其所有包，并且也允许它们进行反射（有关开放包和模块的详细信息，请参阅第 12.2 节）。
- en: In addition, executable JARs result in executable modules, which have their
    main class marked as described in section 4.5.3\. Services provided in `META-INF/services`
    are made available to the `ServiceLoader`—see chapter 10 for an introduction to
    services and particularly section 10.2.6 for their interaction with automatic
    modules.
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，可执行 JARs 导致可执行模块，其主类如第 4.5.3 节所述进行标记。在 `META-INF/services` 中提供的服务对 `ServiceLoader`
    可用——请参阅第 10 章介绍服务和第 10.2.6 节介绍它们与自动模块的交互。
- en: 'Once again assuming ServiceMonitor wasn’t yet modularized, you can nonetheless
    place its artifacts on the module path. If the directory `jars-mp` contains `monitor.jar`,
    `monitor.observer.jar`, and `monitor.statistics.jar`, and `jars-cp` contains all
    other application and dependency JARs, you could launch ServiceMonitor as follows:'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设 ServiceMonitor 尚未模块化，您仍然可以将其工件放置在模块路径上。如果目录 `jars-mp` 包含 `monitor.jar`、`monitor.observer.jar`
    和 `monitor.statistics.jar`，而 `jars-cp` 包含所有其他应用程序和依赖 JARs，则可以按以下方式启动 ServiceMonitor：
- en: '`$ java --module-path jars-mp --class-path ''jars-cp/*'' --module monitor/monitor.Main`'
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --module-path jars-mp --class-path ''jars-cp/*'' --module monitor/monitor.Main`'
- en: You can see the resulting module graph in [figure 8.6](part0022.html#filepos1010671).
    Some details may be unclear (like, why did all three automatic modules make it
    into the graph even though only monitor was referenced on the command line?).
    Don’t worry; I explain in the next sections.
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在[图 8.6](part0022.html#filepos1010671)中看到生成的模块图。一些细节可能不清楚（比如，为什么尽管命令行上只引用了
    monitor，但所有三个自动模块都进入了图？）。别担心；我将在下一节中解释。
- en: '![](../images/00038.jpeg)'
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00038.jpeg)'
- en: '[Figure 8.6](part0022.html#filepos1010060) With the plain JARs `monitor.jar`,
    `monitor.observer.jar`, and `monitor.statistics.jar` on the module path, the JPMS
    creates three automatic modules for them. The class-path content ends up in the
    unnamed module as before. Note how automatic modules read each other and the unnamed
    module, creating lots of cycles in the graph.'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 8.6](part0022.html#filepos1010060) 在模块路径上有普通 JARs `monitor.jar`、`monitor.observer.jar`
    和 `monitor.statistics.jar` 时，JPMS 为它们创建了三个自动模块。类路径的内容最终作为未命名的模块存在，就像以前一样。注意自动模块如何相互读取以及读取未命名的模块，在图中创建了许多循环。'
- en: Automatic modules are full-fledged named modules, which means
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自动模块是完整的命名模块，这意味着
- en: 'They can be referenced by name in other modules’ declarations: for example,
    to require them.'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在其他模块的声明中通过名称引用：例如，要求它们。
- en: Strong encapsulation keeps them from using platform module internals (unlike
    for the unnamed module).
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强封装使它们无法使用平台模块内部（与未命名的模块不同）。
- en: They’re subject to split-package checks.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们会受到拆分包检查的影响。
- en: On the other hand, they do have a few peculiarities. I want to discuss those
    before you start using automatic modules in earnest in section 9.2.
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，它们确实有一些特殊性。在您开始认真使用自动模块之前，我想在 9.2 节中讨论这些特殊性。
- en: '8.3.1 AUTOMATIC MODULE NAMES: SMALL DETAIL, BIG IMPACT'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.3.1 自动模块名称：小细节，大影响
- en: The main point of turning plain JARs into modules is to be able to require them
    in module declarations. For this they need a name, but lacking module descriptors,
    where does it come from?
  id: totrans-659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将普通 JARs 转换为模块的主要目的是能够在模块声明中要求它们。为此，它们需要一个名称，但缺少模块描述符，这个名称从哪里来呢？
- en: FIRST MANIFEST ENTRIES, THEN FILENAME
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先是清单条目，然后是文件名
- en: One way to determine a plain JAR’s module name relies on its manifest, which
    is a file `MANIFEST.MF` in a JAR’s `META-INF` folder. The manifest contains all
    kinds of information in the form of header-value pairs. One of the most prominent
    headers is `Main-Class`, which defines a mon-modular application’s entry point
    by naming the class containing the main method—this makes it possible to launch
    the application with `java -jar app.jar`.
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确定普通 JAR 的模块名称的一种方法依赖于其清单，这是一个位于 JAR 的 `META-INF` 文件夹中的文件 `MANIFEST.MF`。清单包含各种信息，形式为标题-值对。最突出的标题之一是
    `Main-Class`，它通过命名包含 main 方法的类来定义单模块应用程序的入口点——这使得可以使用 `java -jar app.jar` 启动应用程序。
- en: 'If a JAR on the module path contains no descriptor, the module system follows
    a two-step process to determine the automatic module’s name:'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果模块路径上的 JAR 文件没有描述符，模块系统将遵循两步过程来确定自动模块的名称：
- en: It looks for the `Automatic-Module-Name` header in the manifest. If it finds
    it, it uses the corresponding value as the module’s name.
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它会在清单文件中查找 `Automatic-Module-Name` 标头。如果找到，它将使用相应的值作为模块的名称。
- en: If the header isn’t present in the manifest, the module system infers a module
    name from the filename.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果清单中没有该标头，模块系统将从文件名中推断模块名称。
- en: Being able to infer the module’s name from the manifest is preferable by a wide
    margin because it’s much more stable—see section 8.3.4 for details.
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从清单中推断模块名称比猜测更可靠，因为它要稳定得多——有关详细信息，请参阅第 8.3.4 节。
- en: 'The exact rules for inferring a module name from the filename are a little
    complicated, but the details aren’t overly important. Here’s the gist:'
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从文件名推断模块名称的精确规则有点复杂，但细节并不十分重要。以下是关键点：
- en: JAR filenames often end with a version string (like `-2.0.5`). These are recognized
    and ignored.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR 文件名通常以版本字符串结尾（例如 `-2.0.5`）。这些会被识别并忽略。
- en: Every character apart from letters and digits is turned into a dot.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了字母和数字之外的所有字符都被转换成了点号。
- en: 'This process can lead to unfortunate results, where the resulting module name
    is invalid. An example is the bytecode manipulation tool Byte Buddy: it’s published
    in Maven Central as `byte-buddy-${version}.jar`, which leads to the automatic
    module name `byte.buddy`. Unfortunately, this is illegal, because `byte` is a
    Java keyword. (Section 9.3.3 gives advice for how to fix such problems.)'
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个过程可能会导致不幸的结果，其中生成的模块名称无效。一个例子是字节码操作工具 Byte Buddy：它在 Maven Central 上发布为 `byte-buddy-${version}.jar`，这导致自动模块名称为
    `byte.buddy`。不幸的是，这是非法的，因为 `byte` 是 Java 关键字。（第 9.3.3 节提供了如何修复此类问题的建议。）
- en: 'To not leave you guessing which name the module system chooses for a given
    JAR, you can use the `jar` tool to find out:'
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了不让你猜测模块系统为给定的 JAR 文件选择的名称，您可以使用 `jar` 工具来查询：
- en: '`$ jar --describe-module --file=${jarfile}`'
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --describe-module --file=${jarfile}`'
- en: 'If the JAR lacks a module descriptor, the output starts as follows:'
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 JAR 文件缺少模块描述符，输出将如下所示：
- en: '`> No module descriptor found. Derived automatic module. > > ${module-name}@${module-version}
    automatic > requires java.base mandated`'
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 未找到模块描述符。派生自动模块。> > ${module-name}@${module-version} 自动 > requires java.base
    mandated`'
- en: '`${module-name}` is a placeholder for the actual name—which is what you’re
    looking for. Unfortunately, this doesn’t tell you whether the name was picked
    from the manifest entry or the filename. To find that out, you have several options:'
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`${module-name}` 是实际名称的占位符——这是您要查找的内容。不幸的是，这并不能告诉您名称是从清单条目还是文件名中选择的。要找出这一点，您有几个选择：'
- en: Extract the manifest with `jar --file ${jarfile} --extract META-INF/MANIFEST.MF`,
    and look at it manually.
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `jar --file ${jarfile} --extract META-INF/MANIFEST.MF` 提取清单，并手动查看。
- en: On Linux, `unzip -p ${jarfile} META-INF/MANIFEST.MF` prints the manifest to
    the terminal and thus saves you opening the file.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 系统上，`unzip -p ${jarfile} META-INF/MANIFEST.MF` 将清单文件打印到终端，从而避免了打开文件的需要。
- en: Rename the file, and run `jar --describe-module` again.
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名文件，然后再次运行 `jar --describe-module` 命令。
- en: 'Let’s pick Guava 20.0 as an example:'
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下以 Guava 20.0 版本为例：
- en: '`$ jar --describe-module --file guava-20.0.jar  > No module descriptor found.
    Derived automatic module. > > guava@20.0 automatic > requires java.base mandated
    # truncated contained packages`'
  id: totrans-679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --describe-module --file guava-20.0.jar > 未找到模块描述符。派生自动模块。> > guava@20.0
    自动 > requires java.base mandated # 省略包含的包`'
- en: 'Used as an automatic module, Guava 20.0 is known as guava. But is that universal
    or due to the module name? Using `unzip`, I looked at the manifest:'
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为自动模块使用时，Guava 20.0 被称为 guava。但这是否是通用的，还是由于模块名称的原因？使用 `unzip` 命令，我查看了清单文件：
- en: '`Manifest-Version: 1.0 Build-Jdk: 1.7.0-google-v5 Built-By: cgdecker Created-By:
    Apache Maven Bundle Plugin [... truncated OSGi-related entries ...]`'
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Manifest-Version: 1.0 Build-Jdk: 1.7.0-google-v5 Built-By: cgdecker Created-By:
    Apache Maven Bundle Plugin [... 省略 OSGi 相关条目 ...]`'
- en: As you can see, `Automatic-Module-Name` isn’t set. Renaming the file to `com.google.guava-20.0.jar`
    yields the module name com.google.guava.
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如您所见，`Automatic-Module-Name` 没有设置。将文件重命名为 `com.google.guava-20.0.jar` 后，模块名称变为
    com.google.guava。
- en: 'If you used a less outdated version of Guava—23.6, for example—you’d get the
    following output:'
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您使用的是较旧的 Guava 版本——例如 23.6，您将得到以下输出：
- en: '`$ jar --describe-module --file guava-23.6-jre.jar  > No module descriptor
    found. Derived automatic module. > > com.google.common@23.6-jre automatic > requires
    java.base mandated # truncated contained packages`'
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --describe-module --file guava-23.6-jre.jar > 未找到模块描述符。派生的自动模块。> > com.google.common@23.6-jre
    automatic > requires java.base mandated # truncated contained packages`'
- en: 'As you can see from the fact that the chosen name and the filename aren’t the
    same, Google chose com.google.common as Guava’s module name. Let’s check with
    `unzip`:'
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如你所见，所选的名称和文件名并不相同，谷歌选择了 com.google.common 作为 Guava 的模块名称。让我们用 `unzip` 命令来检查：
- en: '`Manifest-Version: 1.0 Automatic-Module-Name: com.google.common Build-Jdk:
    1.8.0_112-google-v7`'
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Manifest-Version: 1.0 Automatic-Module-Name: com.google.common Build-Jdk:
    1.8.0_112-google-v7`'
- en: 'There you go: `Automatic-Module-Name` is set.'
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就这样：`Automatic-Module-Name` 已经设置。
- en: WHEN TO SET AUTOMATIC-MODULE-NAME
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设置 `AUTOMATIC-MODULE-NAME` 的时间
- en: If you’re maintaining a project that’s publicly released, meaning its artifacts
    are available via Maven Central or another public repository, you should carefully
    consider when to set `Automatic-Module-Name` in the manifest. As I’ll explain
    in section 8.3.4, it makes using a project as an automatic module much more reliable,
    but it also comes with the promise that future, explicit modules will be drop-in
    replacements for the current JARs. You’re essentially saying, “This is what the
    modules will look like; I just didn’t get around to releasing them yet.”
  id: totrans-689
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你维护的是一个公开发布的项目，这意味着其工件可以通过 Maven Central 或其他公共仓库获取，你应该仔细考虑在清单中何时设置 `Automatic-Module-Name`。正如我将在第
    8.3.4 节中解释的那样，这使将项目作为自动模块的使用更加可靠，但它也带来了未来明确模块将是当前 JAR 文件的直接替代品的承诺。你本质上是在说：“这就是模块的样子；我只是还没有发布它们。”
- en: 'The fact that defining an automatic module name invites users to start relying
    on your project artifacts as modules has a few important implications:'
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义自动模块名称的事实鼓励用户开始依赖你的项目工件作为模块，这有几个重要的含义：
- en: The names of the future modules must be exactly those that you declare now.
    (Otherwise, reliable configuration will bite your users because modules are missing.)
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来模块的名称必须与你现在声明的完全一致。（否则，可靠的配置将让用户感到痛苦，因为缺少模块。）
- en: The artifact structure must remain the same, so you can’t move supported classes
    or packages from one JAR to another. (Even without modules, this isn’t recommended
    practice. But with the class path, it doesn’t matter which JAR contains a class,
    so you could get away with it. With the module system in play, on the other hand,
    a class’s origin is relevant because accessibility forces users to require the
    correct module.)
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件结构必须保持不变，因此你不能将受支持的类或包从一个 JAR 文件移动到另一个 JAR 文件中。（即使没有模块，这种做法也不推荐。但有了类路径，哪个
    JAR 文件包含一个类并不重要，所以你可以侥幸逃脱。另一方面，在模块系统的作用下，一个类的来源是相关的，因为可访问性迫使用户要求正确的模块。）
- en: The project runs reasonably well on Java 9+. If it needs command-line options
    or other workarounds, these are well documented. (Otherwise, you can’t be sure
    there aren’t problems hidden in your code that make the other promises moot.)
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目在 Java 9+ 上运行得相当好。如果它需要命令行选项或其他解决方案，这些都有很好的文档记录。（否则，你无法确定代码中是否隐藏着使其他承诺失效的问题。）
- en: Software development is, of course … let’s say, “not entirely predictable,”
    so these can’t be guarantees. But you should have good reasons to believe you
    can hold to these promises. If you don’t have the bandwidth to test on Java 9+,
    or you discovered problems that make a modularization unpredictable, be honest
    about it and don’t set `Automatic-Module-Name` yet. If you set it and have to
    make such changes anyway, a major version bump is in order. [Figure 8.7](part0022.html#filepos1025887)
    shows an example of setting `Automatic-Module-Name`.
  id: totrans-694
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 软件开发当然……让我们说，"并不完全可预测"，因此这些不能作为保证。但你应该有充分的理由相信你可以坚持这些承诺。如果你没有带宽在 Java 9+ 上进行测试，或者你发现了使模块化不可预测的问题，请诚实地说明，并且不要设置
    `Automatic-Module-Name`。如果你设置了它并且无论如何都需要进行此类更改，那么需要进行主要版本号的升级。[图 8.7](part0022.html#filepos1025887)
    展示了设置 `Automatic-Module-Name` 的一个示例。
- en: '![](../images/00011.jpeg)'
  id: totrans-695
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00011.jpeg)'
- en: '[Figure 8.7](part0022.html#filepos1025427) If you’re planning to move classes
    between packages or packages between JARs before modularizing your project, wait
    to set `Automatic-Module-Name` until you’re finished. Here, the project’s JARs
    (left) were refactored before being published with an automatic module name (middle),
    so when they’re modularized (right), the structure doesn’t change.'
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 8.7](part0022.html#filepos1025427) 如果你计划在模块化你的项目之前在包之间或 JAR 之间移动类，请等待设置`Automatic-Module-Name`直到你完成。在这里，项目的
    JAR（左侧）在发布带有自动模块名称之前被重构（中间），因此当它们被模块化（右侧）时，结构不会改变。'
- en: Your project doesn’t need to target Java 9+ for you to be able to set `Automatic-Module-Name`.
    The JAR may contain bytecode compiled for older JVM versions, but defining the
    module name still helps users who are using the module system. The same is even
    true for module descriptors, as section 9.3.4 explains.
  id: totrans-697
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使你的项目不需要针对 Java 9+，你也能设置`Automatic-Module-Name`。JAR 可能包含为旧 JVM 版本编译的字节码，但定义模块名称仍然有助于使用模块系统的用户。正如第
    9.3.4 节所解释的，这也适用于模块描述符。
- en: 8.3.2 MODULE RESOLUTION FOR AUTOMATIC MODULES
  id: totrans-698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.3.2 自动模块的模块解决
- en: A critical ingredient to comprehending and predicting the module system’s behavior
    is to understand how it builds the module graph during module resolution. For
    explicit modules, this is straightforward (it follows requires directives; see
    section 3.4.1); but for the unnamed modules, it’s more complicated (see section
    7.2.2) because plain JARs can’t express dependencies.
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 理解和预测模块系统行为的一个关键因素是了解它在模块解决过程中如何构建模块图。对于显式模块，这是直接的（它遵循要求指令；参见第 3.4.1 节）；但对于未命名的模块，则更复杂（参见第
    7.2.2 节），因为普通 JAR 不能表达依赖关系。
- en: 'Automatic modules are also created from plain JARs, so they have no explicit
    dependencies either, which begs the question how they behave during resolution.
    We’ll answer that question momentarily, but as you’ll see, that leads to a new
    one: Should you place an automatic module’s dependencies on the class or the module
    path? When you’re done with this section, you’ll know.'
  id: totrans-700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自动模块也是从普通 JAR 创建的，因此它们也没有显式的依赖关系，这引出了一个问题：在解决过程中它们是如何表现的。我们将稍后回答这个问题，但正如你将看到的，这又引出了一个新的问题：你应该将自动模块的依赖项放在类路径还是模块路径上？当你完成本节后，你就会知道了。
- en: RESOLVING AUTOMATIC MODULE DEPENDENCIES
  id: totrans-701
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决自动模块依赖项
- en: The first question to answer is what happens during module resolution if the
    JPMS encounters an automatic module. Automatic modules were created for modularization
    in the face of mon-modular dependencies, so they’re used in situations where developers
    are actively working on a modular representation of their project. In that scenario,
    it would be detrimental if automatic modules pulled in nearly every platform module
    (like the unnamed module does), so they don’t do that. (To be clear, they also
    don’t pull in any explicit application modules.)
  id: totrans-702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需要回答的第一个问题是，当 JPMS 遇到自动模块时，模块解决过程中会发生什么。自动模块是为了面对单模块依赖而创建的模块化，因此它们在开发者积极工作于项目模块表示的情况下被使用。在这种情况下，如果自动模块几乎拉入了所有平台模块（就像未命名的模块所做的那样），这将是有害的，因此它们不会这样做。（为了明确，它们也不会拉入任何显式的应用程序模块。）
- en: Still, JARs have the tendency to depend on one another; and if the module system
    only resolved automatic modules that were explicitly required, all other automatic
    modules would have to be added to the graph with `--add-modules`. Imagine doing
    that for a large project with hundreds of dependencies you decided to place on
    the module path. To prevent such excessive and fragile manual module-adding, the
    JPMS pulls in all automatic modules once it encounters the first one.
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，JAR 有依赖彼此的倾向；如果模块系统只解决显式要求的自动模块，所有其他自动模块都必须通过`--add-modules`添加到图中。想象一下，对于一个有数百个依赖项的大型项目，你决定将它们放置在模块路径上，这样做会是什么样子。为了防止这种过度且脆弱的手动模块添加，JPMS
    一旦遇到第一个自动模块，就会拉入所有自动模块。
- en: As soon as one automatic module is resolved, so are all others. You get either
    all plain JARs as automatic modules (if at least one is required or added) or
    none (otherwise). That explains why [figure 8.6](part0022.html#filepos1010671)
    shows three monitor.* modules even though only monitor, which can’t express dependencies,
    was explicitly resolved by making it the root module.
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦一个自动模块被解决，所有其他模块也会随之解决。你将获得所有作为自动模块的普通 JAR（如果至少需要一个或添加了一个）或者一个也没有（否则）。这就解释了为什么[图
    8.6](part0022.html#filepos1010671)显示了三个监控器模块，尽管只有监控器模块（它不能表达依赖关系）被明确地通过将其作为根模块来解决。
- en: Note that automatic modules imply readability (see section 9.1) on other automatic
    modules, which means any module that reads one, reads all of them. Keep this in
    mind when determining dependencies on automatic modules—going with trial and error
    can lead to fewer `requires` directives than are needed.
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，自动模块意味着对其他自动模块的可读性（见第 9.1 节），这意味着任何读取一个模块的模块都会读取所有这些模块。在确定自动模块的依赖关系时，请记住这一点——通过试错可能会导致比所需的
    `requires` 指令更少。
- en: 'In the ServiceMonitor application, the monitor.rest module depends on the Spark
    web framework and, for the sake of this example, on Guava. Both dependencies are
    plain JARs, so monitor.rest needs to require them as automatic modules:'
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 ServiceMonitor 应用程序中，monitor.rest 模块依赖于 Spark 网络框架，以及为了这个示例，依赖于 Guava。这两个依赖都是普通
    JAR，所以 monitor.rest 需要将它们作为自动模块来要求：
- en: '`module monitor.rest { requires spark.core; requires com.google.common; requires
    monitor.statistics;  exports monitor.rest; }`'
  id: totrans-707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.rest { requires spark.core; requires com.google.common; requires
    monitor.statistics;  exports monitor.rest; }`'
- en: The thing is, one of the `requires` directives on spark.core or com.google.common
    could be missing, and everything would still work. As soon as the module system
    resolves the first automatic module, it resolves all others, and any module reading
    one of them reads all of them.
  id: totrans-708
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 问题是，spark.core 或 com.google.common 上的一个 `requires` 指令可能缺失，但一切仍然可以正常工作。一旦模块系统解析了第一个自动模块，它就会解析所有其他模块，任何读取其中任何一个的模块都会读取所有这些模块。
- en: So even without `requires com.google.common`, `guava.jar` would be picked up
    as an automatic module together with `spark.core.jar`; and because monitor.rest
    reads spark.core, it would also read guava. Be sure to properly determine dependencies
    (for example, with JDeps—see appendix D)!
  id: totrans-709
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使没有 `requires com.google.common`，`guava.jar` 也会作为一个自动模块与 `spark.core.jar` 一起被选中；由于
    monitor.rest 读取 spark.core，它也会读取 guava。务必正确确定依赖关系（例如，使用 JDeps—见附录 D）！
- en: Cycles in the module graph
  id: totrans-710
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**模块图中的循环**'
- en: 'There’s a detail hidden in “automatic modules read all other modules” that’s
    worth pointing out: this approach creates cycles in module graphs. Apparently
    at least one module depends on the automatic module (why else would it be there?)
    and thus reads it, and likewise the automatic module reads it back.'
  id: totrans-711
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “自动模块读取所有其他模块”这个细节中隐藏着一个值得注意的细节：这种方法会在模块图中创建循环。显然，至少有一个模块依赖于自动模块（否则它为什么会存在呢？），因此会读取它，同样地，自动模块也会读取它。
- en: Although this has no practical consequence, I bring it up to clarify that it
    isn’t in violation of the rule stated in section 3.2.1 that there can’t be static
    dependency cycles. The cycles due to automatic modules aren’t statically declared—they’re
    introduced dynamically by the module system.
  id: totrans-712
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这没有实际影响，但我提出来是为了澄清，这并不违反第 3.2.1 节中提到的规则，即不能有静态依赖循环。由于自动模块产生的循环不是静态声明的，而是由模块系统动态引入的。
- en: If automatic modules could only read other named modules, you’d be done. Once
    you placed a plain JAR on the module path, all of its direct dependencies would
    have to go onto the module path as well, and then their dependencies, and so on,
    until all transitive dependencies were treated as modules, explicit or automatic.
  id: totrans-713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果自动模块只能读取其他命名模块，那么你就完成了。一旦你将一个普通 JAR 放在模块路径上，它的所有直接依赖都必须进入模块路径，然后是它们的依赖，以此类推，直到所有传递依赖都被视为模块，无论是显式的还是自动的。
- en: Turning all plain JARs into automatic modules has downsides, though (more on
    that in section 8.3.3), so it would be nice to be able to leave them on the class
    path and have them loaded into the unnamed module. And the module system allows
    just that by letting automatic modules read the unnamed module, which means their
    dependencies can be on the class path or the module path.
  id: totrans-714
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将所有普通 JAR 转换为自动模块有缺点（更多内容见第 8.3.3 节），所以能够将它们留在类路径上，并让它们被无名称模块加载会很好。模块系统正是通过允许自动模块读取无名称模块来实现这一点的，这意味着它们的依赖关系可以是类路径或模块路径。
- en: CHOOSING A PATH FOR TRANSITIVE DEPENDENCIES
  id: totrans-715
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**选择传递依赖关系的路径**'
- en: 'You generally have two options for automatic modules’ dependencies (remember,
    you can use JDeps to list them, too): the class path or the module path. Unfortunately,
    not all circumstances allow you to choose freely, and in some cases, you need
    to do more than just decide on the path.'
  id: totrans-716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于自动模块的依赖关系，你通常有两个选择（记住，你也可以使用 JDeps 来列出它们）：类路径或模块路径。不幸的是，并非所有情况都允许你自由选择，在某些情况下，你需要做的不仅仅是决定路径。
- en: '[Table 8.2](part0022.html#filepos1039390) presents the options to bring those
    dependencies into the module graph, based on whether they’re required by another
    module and whether they’re platform modules, plain JARs, or modular JARs. The
    following figures shine a spotlight on specific situations:'
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[表 8.2](part0022.html#filepos1039390) 展示了根据它们是否被另一个模块需要以及它们是否是平台模块、平凡 JAR 或模块化
    JAR，将这些依赖项引入模块图的选择。以下图例将重点放在特定情况上：'
- en: '[Figure 8.8](part0022.html#filepos1037662) shows how platform modules that
    are only required by an automatic module aren’t resolved by default.'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图 8.8](part0022.html#filepos1037662) 展示了仅由自动模块需要的平台模块默认不会被解决。'
- en: '![](../images/00088.jpeg)'
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00088.jpeg)'
- en: '[Figure 8.8](part0022.html#filepos1037485) If a project (`your.app` in this
    case) uses an automatic module (org.jooq), you can’t be sure the module graph
    works out of the box. Automatic modules don’t express dependencies, so platform
    modules they need may not make it into the graph (here, that happened with java.sql)
    and have to be added manually with `--add-modules`.'
  id: totrans-720
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 8.8](part0022.html#filepos1037485) 如果一个项目（本例中为 `your.app`）使用自动模块（org.jooq），你不能确定模块图会自动工作。自动模块不表达依赖关系，因此它们需要的平台模块可能不会出现在图中（这里，java.sql
    就发生了这种情况），并且必须使用 `--add-modules` 手动添加。'
- en: '[Figure 8.9](part0022.html#filepos1049986) covers the different cases for plain
    JARs that are needed by an automatic module.'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图 8.9](part0022.html#filepos1049986) 覆盖了自动模块需要的平凡 JAR 的不同情况。'
- en: '[Figure 8.10](part0022.html#filepos1051656) shows the module graph’s evolution
    if a transitive dependency is turned from a plain into a modular JAR.'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[图 8.10](part0022.html#filepos1051656) 展示了如果将传递依赖从普通 JAR 转换为模块化 JAR，模块图将如何演变。'
- en: Table 8.2 How to add an automatic module’s dependencies to the module graph
  id: totrans-723
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表 8.2 如何将自动模块的依赖项添加到模块图中
- en: '| Dependency required by another, explicit module   |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| 由另一个显式模块需要的依赖项   |'
- en: '|    | Class path   | Module path   |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
  zh: '|    | 类路径   | 模块路径   |'
- en: '| Platform module   |    | ✔   |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '| 平台模块   |    | ✔   |'
- en: '| Plain JAR   | ✘ (dependency unfulfilled)   | ✔   |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| 平凡 JAR   | ✘ (依赖未满足)   | ✔   |'
- en: '| Modular JAR   | ✘ (dependency unfulfilled)   | ✔   |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '| 模块化 JAR   | ✘ (依赖未满足)   | ✔   |'
- en: '| Dependency not required by an explicit module   |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
  zh: '| 由显式模块不需要的依赖项   |'
- en: '|    | Class path   | Module path   |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '|    | 类路径   | 模块路径   |'
- en: '| Platform module   |    | ! (resolve manually)   |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '| 平台模块   |    | ! (手动解决)   |'
- en: '| Plain JAR   | ✔   | ✔ (automatically resolved)   |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| 平凡 JAR   | ✔   | ✔ (自动解决)   |'
- en: '| Modular JAR   | ✔   | ! (resolve manually)   |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| 模块化 JAR   | ✔   | ! (手动解决)   |'
- en: Focusing on platform modules for a moment, we see that an automatic module can’t
    express dependencies on them. As a consequence, the module graph may or may not
    contain them; and if it doesn’t, the automatic module is likely to fail at run
    time with an exception due to missing classes.
  id: totrans-734
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 专注于平台模块一段时间，我们会看到自动模块不能表达对它们的依赖关系。因此，模块图可能包含也可能不包含它们；如果不包含，自动模块在运行时可能会因为缺少类而抛出异常。
- en: The only way around this is for the project’s maintainers to publicly document
    which modules they need, so their users can make sure the required modules are
    present. Users can do that by requiring them either explicitly, for example in
    the module that depends on the automatic module, or with `--add-modules`.
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决这个问题的唯一方法是由项目的维护者公开记录他们需要的模块，这样他们的用户就可以确保所需的模块存在。用户可以通过明确要求它们，例如在依赖于自动模块的模块中，或者使用
    `--add-modules` 来实现。
- en: '![](../images/00007.jpeg)'
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00007.jpeg)'
- en: '[Figure 8.9](part0022.html#filepos1039125) Starting with the dependency of
    monitor.rest (a modular JAR) on spark.core (a plain JAR), the latter needs to
    be placed on the module path. But what about its dependency slf4j (another plain
    JAR)? Here you see the resulting module graphs depending on whether slf4j is required
    by another modular JAR (top versus bottom row) or which path it’s placed on (middle
    versus right column). Looks like a clear win for the module path, but take a look
    at [figure 8.10](part0022.html#filepos1051656).'
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 8.9](part0022.html#filepos1039125) 从 monitor.rest（一个模块化 JAR）对 spark.core（一个平凡
    JAR）的依赖关系开始，后者需要放置在模块路径上。但它的依赖项 slf4j（另一个平凡 JAR）怎么办？在这里，你可以看到根据 slf4j 是否被另一个模块化
    JAR 所需要（顶部与底部行）或放置在哪个路径上（中间与右侧列）而产生的模块图。看起来模块路径是一个明显的胜利，但看看 [图 8.10](part0022.html#filepos1051656)。'
- en: '![](../images/00036.jpeg)'
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00036.jpeg)'
- en: '[Figure 8.10](part0022.html#filepos1039378) In the same situation as [figure
    8.9](part0022.html#filepos1049986)''s bottom right corner, what happens if an
    automatic module’s transitive dependency (slf4j) that’s placed on the module path
    gets modularized? It’s no longer resolved by default and needs to be added manually
    with `--add-modules`.'
  id: totrans-739
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 8.10](part0022.html#filepos1039378) 在与 [图 8.9](part0022.html#filepos1049986)
    右下角相同的情况下，如果一个自动模块的传递依赖项（slf4j）被放置在模块路径上并进行了模块化，会发生什么？它将不再默认解析，需要手动使用 `--add-modules`
    添加。'
- en: 'With dependencies on platform modules checked off, let’s look at application
    modules. If an automatic module’s dependencies are required by an explicit module,
    they have to be placed on the module path and are then resolved by the module
    system—nothing else needs to be done. If no explicit module requires them, JARs
    can either be placed on the class path, where they’re rolled into the unnamed
    module and are hence always accessible, or be placed on the module path, where
    some other mechanism needs to pull them into the graph:'
  id: totrans-740
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在检查了平台模块的依赖项之后，让我们看看应用程序模块。如果一个自动模块的依赖项被一个显式模块所需要，它们必须放置在模块路径上，然后由模块系统解析——不需要做其他任何事情。如果没有显式模块需要它们，JAR
    包可以被放置在类路径上，在那里它们被合并到未命名的模块中，因此始终可访问，或者被放置在模块路径上，在那里需要某种其他机制将它们拉入图中：
- en: Plain JARs are pulled in by the all-or-nothing approach to automatic module
    loading.
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯粹的 JAR 包是通过自动模块加载的全有或全无方法被拉入的。
- en: Platform and explicit application modules aren’t resolved by default. You either
    have to require them from some other module or add them manually with `--add-modules`
    (see section 3.4.3).
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台和显式应用程序模块默认不解析。您必须从其他模块中要求它们，或者使用 `--add-modules` 手动添加它们（参见第 3.4.3 节）。
- en: 'Combined with the fact that most or even all dependencies will at some point
    go from plain to modular JARs, these two observations attract attention: they
    imply that transitive dependencies on the module path work fine as long as they’re
    plain JARs, but disappear from the module graph as soon as they’re modularized.'
  id: totrans-743
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结合这样一个事实，即大多数或甚至所有依赖项最终都会从纯 JAR 包转换为模块化 JAR 包，这两个观察结果引起了人们的注意：它们意味着只要它们是纯 JAR
    包，模块路径上的传递依赖项就可以正常工作，但一旦它们被模块化，就会从模块图中消失。
- en: Let’s focus on the second bullet point and consider modules that mon-modular
    dependencies need to access. If neither you nor other modules require them, they
    won’t make it into the module graph, and dependencies won’t be able to access
    them. In that case, you can either require them in your module descriptors (don’t
    forget to add a comment why you do that) or add them with command-line flags during
    compilation and at launch time. Sections 9.2.2 and 9.2.3 briefly discuss the trade-offs
    involved in that decision, depending on the specific scenario.
  id: totrans-744
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们专注于第二个要点，并考虑单模块依赖项需要访问的模块。如果您和其他模块都不需要它们，它们将无法进入模块图，依赖项将无法访问它们。在这种情况下，您可以在模块描述符中要求它们（不要忘记添加注释说明为什么这样做）或在使用命令行标志进行编译和启动时添加它们。第
    9.2.2 节和第 9.2.3 节简要讨论了该决策中涉及到的权衡，具体取决于特定场景。
- en: 'An additional bump in the road can be the types an automatic module exposes
    in its public API. Assume a project (a modular JAR) depends on a library (a plain
    JAR) with a method that returns an `ImmutableList` from Guava (also a plain JAR):'
  id: totrans-745
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 道路上的另一个障碍可能是自动模块在其公共 API 中公开的类型。假设一个项目（一个模块化 JAR 包）依赖于一个库（一个纯 JAR 包），该库有一个从
    Guava 返回 `ImmutableList` 的方法（Guava 也是一个纯 JAR 包）：
- en: '`public ImmutableList<String> getAllTheStrings() { // ... }`'
  id: totrans-746
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public ImmutableList<String> getAllTheStrings() { // ... }`'
- en: 'If you place the project and the library on the module path and Guava on the
    class path, you’ll get the module graph shown in [figure 8.11](part0022.html#filepos1056380):
    the project (explicit module) reads the library (automatic module), which reads
    the unnamed module (containing Guava). If the code now calls the method that returns
    an `ImmutableList`, the accessibility check for that type won’t end in your favor,
    because your module doesn’t read the unnamed one.'
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您将项目和库放置在模块路径上，将 Guava 放置在类路径上，您将得到 [图 8.11](part0022.html#filepos1056380)
    中所示的模块图：项目（显式模块）读取库（自动模块），该库读取未命名的模块（包含 Guava）。如果代码现在调用返回 `ImmutableList` 的方法，对该类型的可访问性检查不会对您有利，因为您的模块没有读取未命名的模块。
- en: '![](../images/00056.jpeg)'
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00056.jpeg)'
- en: '[Figure 8.11](part0022.html#filepos1055663) If a method in an automatic module
    (org.lib in this case) returns a type from the unnamed module (`ImmutableList`),
    named modules (your.app) can’t access it, because they don’t read the unnamed
    module. This crashes the application if the method declares that it returns the
    inaccessible type (`ImmutableList`). Declaring a supertype (here, most likely
    `List`) would work.'
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 8.11](part0022.html#filepos1055663) 如果一个自动模块（本例中为 org.lib）中的方法返回未命名的模块（`ImmutableList`）的类型，那么命名模块（your.app）无法访问它，因为它们没有读取未命名的模块。如果该方法声明返回不可访问的类型（`ImmutableList`），这将导致应用程序崩溃。声明一个超类型（这里可能是
    `List`）将有效。'
- en: This isn’t entirely new. If `ImmutableList` were a nonpublic type of the library,
    you also wouldn’t be able to call that method due to lacking visibility. And just
    as in that case, this hinges on the declared return type. If the method instead
    declared to return a `List` and then chose an `ImmutableList` as the concrete
    type to return, everything would be fine. This is about which type the API declares,
    not which type it returns.
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这并不是全新的。如果 `ImmutableList` 是库的非公开类型，你也将无法调用该方法，因为缺乏可见性。就像在那个情况下一样，这也取决于声明的返回类型。如果方法声明返回
    `List`，然后选择 `ImmutableList` 作为返回的具体类型，那么一切都会正常。这是关于 API 声明哪种类型，而不是它返回哪种类型。
- en: Consequently, if an automatic module exposes types from another JAR, that JAR
    needs to go onto the module path as well. Otherwise, its types would end up in
    the unnamed module, where they’re inaccessible to explicit modules. This would
    result in an `IllegalAccessError` due to a lacking read edges, as described in
    section 3.3.3.
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，如果一个自动模块暴露了另一个 JAR 的类型，那么该 JAR 也需要添加到模块路径上。否则，其类型最终会出现在未命名的模块中，那里它们对显式模块不可访问。这会导致由于缺少读取边而出现
    `IllegalAccessError`，如第 3.3.3 节所述。
- en: If, despite your best efforts, you end up in a situation where a named module
    needs to access the unnamed module, you’re left with one option—literally. The
    command-line option `--add-reads`, introduced in section 3.4.4, can be used to
    add a readability edge from a named module to the unnamed module by using `ALL-UNNAMED`
    as the target value. This couples your modular code to the unpredictable class-path
    content, though, so it should be a last resort.
  id: totrans-752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使你尽了最大努力，如果最终需要命名的模块访问未命名的模块，你只剩下一种选择——字面上的。在第 3.4.4 节中引入的命令行选项 `--add-reads`
    可以通过使用 `ALL-UNNAMED` 作为目标值，将命名模块到未命名的模块的读取边添加进来。然而，这会将你的模块化代码与不可预测的类路径内容耦合，因此它应该是最后的手段。
- en: By using `--add-reads`, the example with Guava on the class path and an automatic
    module returning an `ImmutableList` can work out after all. If the explicit module
    that gets the instance of `ImmutableList` (and subsequently fails the accessibility
    check) was named app, then adding `--add-reads app=ALL-UNNAMED` to both compiler
    and runtime would make the application work.
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过使用 `--add-reads`，在类路径上使用 Guava 并返回 `ImmutableList` 的自动模块最终可以工作。如果获取 `ImmutableList`
    实例（并随后失败访问性检查）的显式模块被命名为 app，那么将 `--add-reads app=ALL-UNNAMED` 添加到编译器和运行时将使应用程序工作。
- en: All that said, when do you choose which path? Should you go all in on automatic
    modules or prefer leaving as many dependencies as possible on the class path?
    Read on to find out.
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有这些话，你何时选择哪种路径？你应该完全依赖自动模块，还是更倾向于将尽可能多的依赖项留在类路径上？继续阅读以了解详情。
- en: 8.3.3 ALL IN ON AUTOMATIC MODULES?
  id: totrans-755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.3.3 全力投入自动模块？
- en: With the ability to place plain JARs on the module path to turn them into automatic
    modules, do you still need the class path? Can’t you place every JAR on the module
    path, turning them all into explicit or automatic modules (depending on whether
    they contain a descriptor)? The technical answer to that question is, yes, you
    could do that. Nevertheless, I don’t recommend it—let me explain why.
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有能力将普通 JAR 放置在模块路径上以将其转换为自动模块，你还需要类路径吗？难道你不能将每个 JAR 放置在模块路径上，将它们全部转换为显式或自动模块（取决于它们是否包含描述符）？对这个问题的技术答案是，你可以这样做。尽管如此，我不推荐这样做——让我解释原因。
- en: PLAIN JARS DON’T MAKE GOOD MODULES
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: PLAIN JARS DON’T MAKE GOOD MODULES
- en: 'Generally speaking, plain JARs don’t make good modules:'
  id: totrans-758
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一般而言，普通 JAR 不适合作为模块：
- en: They may access JDK-internal APIs (see section 7.1).
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可能访问 JDK 内部 API（参见第 7.1 节）。
- en: They may split packages between themselves and JEE modules (see section 7.2).
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们可能会在它们自己和 JEE 模块之间分割包（参见第 7.2 节）。
- en: They don’t express their dependencies.
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们没有表达他们的依赖关系。
- en: If they’re turned into automatic modules, the module system will impose its
    rules on them, and you may have to spend some time fixing the resulting issues.
    On top of that, once a plain JAR is upgraded to a modular JAR, it’s no longer
    resolved by default (see [table 8.2](part0022.html#filepos1039390) and [figure
    8.10](part0022.html#filepos1051656)), so for every such upgrade somewhere in your
    project’s dependency tree, you have to go in and add it manually. The only upside
    of automatic modules is that they can be required by explicit modules, but if
    you don’t need that, you get little in return for your troubles making everything
    automatic.
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它们被转换为自动模块，模块系统将对其施加规则，你可能需要花一些时间来解决由此产生的问题。除此之外，一旦普通 JAR 升级为模块化 JAR，它将默认不再被解析（参见
    [表 8.2](part0022.html#filepos1039390) 和 [图 8.10](part0022.html#filepos1051656)），因此对于你项目依赖树中的每个此类升级，你都必须手动添加它。自动模块的唯一优点是它们可以被显式模块要求，但如果你不需要这个，那么你为使一切自动化所付出的努力几乎得不到任何回报。
- en: If left on the class path, on the other hand, the JARs are rolled into the unnamed
    module, where
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，如果留在类路径上，JAR 将被合并到未命名的模块中，
- en: Illegal access is by default allowed for at least one more Java release.
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，至少允许对 Java 的一个更多版本进行非法访问。
- en: Splits between JARs don’t matter, although they still do between JARs and platform
    modules.
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR 之间的分割并不重要，尽管它们在 JAR 和平台模块之间仍然重要。
- en: They can read all Java SE platform modules if they contain the application entry
    point.
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们包含应用程序入口点，它们可以读取所有 Java SE 平台模块。
- en: Nothing needs to be done when a plain JAR is upgraded to a modular JAR
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个普通 JAR 升级为模块化 JAR 时，无需进行任何操作。
- en: This makes life much easier.
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使得生活变得更加容易。
- en: ESSENTIAL INFO Despite the thrill of having everything as a module, I recommend
    that you place only the minimum number of plain JARs on the module path that are
    needed to make a project work, and put the rest on the class path.
  id: totrans-769
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 尽管将所有内容都作为模块使用令人兴奋，但我建议你只将使项目工作的最小数量的普通 JAR 放在模块路径上，其余的放在类路径上。'
- en: An automatic module’s modularized dependencies, on the other hand, should generally
    go onto the module path. Because they come as modular JARs, they shouldn’t need
    the module system to treat them as leniently as the unnamed module; if loaded
    as modules, they benefit from reliable configuration and strong encapsulation.
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，自动模块的模块化依赖项通常应该放在模块路径上。因为它们是以模块化 JAR 的形式出现的，所以它们不需要模块系统像对待未命名的模块那样宽容；如果作为模块加载，它们将受益于可靠的配置和强大的封装。
- en: AUTOMATIC MODULES AS A BRIDGE TO THE CLASS PATH
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**自动模块作为通往类路径的桥梁**'
- en: 'There’s a philosophical point to be made for working with fewer automatic modules:
    this turns them into a bridge between the modular world and the chaotic class
    path ([figure 8.12](part0022.html#filepos1066820)). Modules can sit on one side
    and require their direct dependencies as automatic modules, and indirect dependencies
    can remain on the other side. Every time one of your dependencies turns into an
    explicit module, it leaves the bridge on the modular side and draws its direct
    dependencies as automatic modules onto the bridge. This is the top-down approach
    I mentioned earlier; we’ll look at it more closely when discussing modularization
    strategies in section 9.2.'
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在使用更少的自动模块工作时，有一个哲学观点需要提出：这使它们成为模块世界和混乱的类路径之间的桥梁（[图 8.12](part0022.html#filepos1066820)）。模块可以坐在一边，并以自动模块的形式要求它们的直接依赖项，而间接依赖项可以留在另一边。每次你的依赖项变成显式模块时，它就会离开模块一侧的桥梁，并将它的直接依赖项作为自动模块拉到桥梁上。这就是我之前提到的自上而下的方法；我们将在第
    9.2 节讨论模块化策略时更详细地探讨它。
- en: '![](../images/00012.jpeg)'
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00012.jpeg)'
- en: '[Figure 8.12](part0022.html#filepos1066035) Long Biên Bridge in Hanoi 1939\.
    Photo by manhhai. Used under Creative Commons CC BY 2.0.'
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 8.12](part0022.html#filepos1066035) 河内长贝桥，1939 年。照片由 manhhai 提供。在 Creative
    Commons CC BY 2.0 许可下使用。'
- en: 8.3.4 DEPENDING ON AUTOMATIC MODULES
  id: totrans-775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8.3.4 依赖自动模块
- en: 'The sole purpose of automatic modules is to depend on plain JARs, so it becomes
    possible to create explicit modules without having to wait until all dependencies
    are modularized. There’s an important caveat, though: if the JAR’s manifest doesn’t
    contain the `Automatic-Module-Name` entry, the dependency is inherently fragile.'
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自动模块的唯一目的是依赖于普通的 JAR 文件，因此可以在不等待所有依赖项模块化之前创建显式模块。然而，有一个重要的注意事项：如果 JAR 的清单中没有包含
    `Automatic-Module-Name` 条目，依赖项本质上是脆弱的。
- en: 'As section 8.3.1 explains, without that entry, the automatic module name is
    inferred from the filename. But depending on their setup, different projects may
    use different names for the same JARs. Furthermore, most projects use a Maven-backed
    local repository, where the JAR files are named `${artifactID}-${version}`, from
    which the module system will likely infer ${artifactID} as the automatic module’s
    name. That’s problematic because artifact IDs generally don’t follow the reverse-domain
    naming schema defined in section 3.1.3: once the project is modularized, the module
    name will likely change.'
  id: totrans-777
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第8.3.1节所述，如果没有该条目，自动模块名称将根据文件名推断。但根据它们的配置，不同的项目可能为相同的JAR文件使用不同的名称。此外，大多数项目使用由Maven支持的本地仓库，其中JAR文件命名为`${artifactID}-${version}`，模块系统可能会推断`${artifactID}`作为自动模块的名称。这是问题所在，因为工件ID通常不遵循第3.1.3节中定义的反域名命名方案：一旦项目模块化，模块名称很可能会改变。
- en: Because it’s so commonly used, Google’s Guava continues to be a great example.
    As you saw earlier, for `guava-20.0.jar`, the module system derives the automatic
    module name guava. That’s the name the file has in Maven’s local repository, but
    other projects may have a different setup.
  id: totrans-778
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于其广泛使用，Google的Guava继续是一个很好的例子。正如你之前看到的，对于`guava-20.0.jar`，模块系统推导出自动模块名称guava。这是文件在Maven本地仓库中的名称，但其他项目可能有不同的配置。
- en: Let’s say one names JARs `${groupID}-${artifactID}-${version}`, in which case
    the file would be called `com.google.guava-guava-20.0.jar` and the automatic module
    name would be com.google.guava.guava. A modularized Guava, on the other hand,
    will be called com.google.common, so none of the automatic module names were correct.
  id: totrans-779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设我们将JAR命名为`${groupID}-${artifactID}-${version}`，那么文件将被称为`com.google.guava-guava-20.0.jar`，自动模块名称将是com.google.guava.guava。另一方面，模块化的Guava将被称为com.google.common，因此没有任何自动模块名称是正确的。
- en: In summary, the same JAR may get different module names in different projects
    (depending on their setup) and at different times (before and after modularization).
    This has the potential to cause havoc downstream.
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结来说，相同的JAR在不同的项目（取决于它们的配置）和不同时间（在模块化之前和之后）可能会有不同的模块名称。这有可能在下层造成混乱。
- en: Think about your favorite project, and imagine that one of your dependencies
    referenced one of its dependencies as an automatic module with a name that doesn’t
    match the project’s setup (see [figure 8.13](part0022.html#filepos1072014)). Maybe
    the dependency named files `${groupID}-${artifactID}-${version}`, whereas you
    use Maven and name them `${artifactID}-${version}`. Now the dependency requires
    an automatic module `${groupID}.${artifactID}`, but the module system will infer
    `${artifactID}` in your project. That would break the build—and although there
    are ways to fix it (see section 9.3.3), none of them are pleasant.
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想想你最喜欢的项目，并想象其中一个依赖项将其依赖项作为具有不匹配项目设置的自动模块名称引用（参见[图8.13](part0022.html#filepos1072014)）。也许依赖项命名文件`${groupID}-${artifactID}-${version}`，而你使用Maven并将它们命名为`${artifactID}-${version}`。现在，依赖项需要自动模块`${groupID}.${artifactID}`，但模块系统将在你的项目中推断`${artifactID}`。这将破坏构建——尽管有方法可以修复它（参见第9.3.3节），但没有一个是令人愉快的。
- en: '![](../images/00109.jpeg)'
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00109.jpeg)'
- en: '[Figure 8.13](part0022.html#filepos1070924) The dependency org.lib requires
    Guava by the automatic module name it got in the build, which is com.google.guava.guava.
    Unfortunately, on the system, the artifact is called `guava.jar`, so the module
    name guava is derived. Without further work, the module system will complain about
    missing dependencies.'
  id: totrans-783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图8.13](part0022.html#filepos1070924) 依赖项org.lib通过在构建中获得的自动模块名称com.google.guava.guava来要求Guava。不幸的是，在系统上，工件被称为`guava.jar`，因此推导出模块名称guava。如果没有进一步的工作，模块系统将抱怨缺少依赖项。'
- en: 'And it’s getting worse! Stick with that same project, and mentally add another
    dependency that requires the same automatic module but with a different name (see
    [figure 8.14](part0022.html#filepos1074055)). This is the modular diamond of death
    described in section 3.2.2: a single JAR can’t fulfill requirements for modules
    with different names, and multiple JARs with the same content won’t work due to
    the rule against split packages. This situation needs to be avoided at all costs!'
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而且情况还在恶化！继续使用同一个项目，并在心理上添加另一个需要相同自动模块但名称不同的依赖项（参见[图8.14](part0022.html#filepos1074055)）。这就是第3.2.2节中描述的“死亡模块钻石”：单个JAR文件无法满足具有不同名称的模块的要求，并且由于拆分包的规则，具有相同内容的多个JAR文件也无法工作。这种情况必须不惜一切代价避免！
- en: '![](../images/00062.jpeg)'
  id: totrans-785
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00062.jpeg)'
- en: '[Figure 8.14](part0022.html#filepos1073459) Compared to [figure 8.12](part0022.html#filepos1066820),
    the situation has gotten worse. Another dependency, com.framework, also depends
    on Guava, but it requires it with a different name (guava). Now the same JAR needs
    to appear as two differently named modules—that ain’t gonna work.'
  id: totrans-786
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图8.14](part0022.html#filepos1073459) 与[图8.12](part0022.html#filepos1066820)相比，情况变得更糟。另一个依赖项com.framework也依赖于Guava，但它使用不同的名称（guava）。现在同一个JAR需要以两个不同名称的模块出现——这是行不通的。'
- en: In both cases, it may look as if the critical mistake was to require a plain
    JAR by a module name that’s based on its filename. But that’s not the case—using
    this approach is fine for applications and in other scenarios where the developer
    has full control over the module descriptors requiring such automatic modules.
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这两种情况下，可能看起来关键错误是要求模块通过基于其文件名的模块名来使用一个普通的JAR。但事实并非如此——使用这种方法对于应用程序和其他开发者完全控制模块描述符要求此类自动模块的场景是可行的。
- en: The straw that broke the camel’s back was publishing modules with such dependencies
    to a public repository. Only then could users be into a situation where a module
    implicitly depends on details they have no control over, and that can lead to
    additional work or even unresolvable divergences.
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 打破骆驼背的最后一根稻草是将具有此类依赖关系的模块发布到公共存储库。只有在这种情况下，用户才可能处于一个模块隐式依赖于他们无法控制的细节的情况，这可能导致额外的工作甚至无法解决的分歧。
- en: The conclusion is that you should never publish (to an openly accessible repository)
    modules that require a plain JAR without an `Automatic-Module-Name` entry in its
    manifest. Only with that entry are automatic module names sufficiently stable
    to rely on.
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结论是，你不应该发布（到一个公开可访问的存储库）需要普通JAR而没有在它的清单中包含`Automatic-Module-Name`条目的模块。只有有了这个条目，自动模块名称才足够稳定，可以依赖。
- en: Yes, that may mean you can’t yet publish a modularized version of your library
    or framework and must wait for your dependencies to add that entry. That’s unfortunate,
    but doing it anyway would be a great disservice to your users.
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的，这可能意味着你目前还不能发布你库或框架的模块化版本，必须等待你的依赖项添加该条目。这是不幸的，但无论如何这样做都会对你的用户造成极大的不便。
- en: TIP Migration and modularization—we’ve covered all the challenges and mechanisms
    that apply to existing code bases. Continue to chapter 9 to find out how to best
    apply them. After that, part 3 teaches the module system’s more advanced features.
  id: totrans-791
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小贴士：迁移和模块化——我们已经涵盖了适用于现有代码库的所有挑战和机制。继续阅读第9章，了解如何最佳应用它们。之后，第3部分将教授模块系统的更高级功能。
- en: Summary
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: An incremental modularization will often use the class path and the module path.
    It’s important to understand that any JAR on the class path, plain or modular,
    ends up in the unnamed module and that any JAR on the module path ends up as a
    named module—either as an automatic module (for a plain JAR) or an explicit module
    (for a modular JAR). This allows the user of a JAR (instead of its creator) to
    determine whether it becomes a named module.
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量模块化通常会使用类路径和模块路径。重要的是要理解，类路径上的任何JAR（无论是普通还是模块化的）最终都会进入未命名的模块，而模块路径上的任何JAR最终都会成为命名模块——无论是自动模块（对于普通JAR）还是显式模块（对于模块化JAR）。这使用户（而不是创建者）能够确定它是否成为命名模块。
- en: 'The unnamed module is a compatibility feature that makes the module system
    work with the class path:'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未命名的模块是一个兼容性特性，使得模块系统可以与类路径一起工作：
- en: It captures class-path content, has no name, reads every other module, and exports
    and opens all packages.
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它捕获类路径内容，没有名称，读取每个其他模块，并导出和打开所有包。
- en: Because it has no name, explicit modules can’t refer to it in their module declarations.
    One consequence is that they can’t read the unnamed module and can hence never
    use types that are defined on the class path.
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为它没有名称，显式模块无法在其模块声明中引用它。一个后果是它们无法读取未命名的模块，因此永远无法使用在类路径上定义的类型。
- en: If the unnamed module is the initial one, a specific set of rules is used to
    ensure that the right set of modules is resolved. By and large these are the non-JEE
    modules and their dependencies. This lets code from the class path read all Java
    SE APIs without further configuration, thus maximizing compatibility.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未命名的模块是初始模块，则使用一组特定的规则来确保正确解决模块集。总的来说，这些是非JEE模块及其依赖项。这使得类路径上的代码可以读取所有Java
    SE API而无需进一步配置，从而最大化兼容性。
- en: 'Automatic modules are a migration feature that allows modules to depend on
    plain JARs:'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动模块是一个迁移特性，允许模块依赖于普通的JAR：
- en: An automatic module is created for each JAR on the module path. Its name is
    defined by the `Automatic-Module-Name` header in the JAR’s manifest (if present)
    or derived from its filename otherwise. It reads every other module, including
    the unnamed one, and exports and opens all packages.
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于模块路径上的每个JAR文件，都会创建一个自动模块。其名称由JAR文件清单中的`Automatic-Module-Name`头定义（如果存在）或从其文件名推导出来。它读取每个其他模块，包括未命名的模块，并导出和打开所有包。
- en: It’s a regular named module and as such can be referenced in module declarations,
    for example to require it. This allows projects that are being modularized to
    depend on others that haven’t been yet.
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个常规命名的模块，因此可以在模块声明中引用它，例如要求它。这允许正在模块化的项目依赖于尚未模块化的其他项目。
- en: An automatic module’s dependency can be placed on the class path or the module
    path. Which path to use depends on circumstances, but placing modular dependencies
    on the module path and plain ones on the class path is a sensible default.
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动模块的依赖项可以放置在类路径或模块路径上。使用哪个路径取决于具体情况，但将模块化依赖项放置在模块路径上，将普通依赖项放置在类路径上是一个合理的默认设置。
- en: As soon as the first automatic module is resolved, so are all others. Furthermore,
    any module that reads one automatic module reads all of them due to implied readability.
    Take this into account when testing out dependencies on automatic modules.
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦第一个自动模块被解析，其他所有模块也会随之解析。此外，任何读取一个自动模块的模块都会由于隐含的可读性而读取所有模块。在测试自动模块的依赖关系时，请考虑这一点。
- en: '9'
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '9'
- en: Migration and modularization strategies
  id: totrans-804
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 迁移和模块化策略
- en: This chapter covers
  id: totrans-805
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Preparing a migration to Java 9 and beyond
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备迁移到Java 9及更高版本
- en: Continually integrating changes
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成更改
- en: Incrementally modularizing projects
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步模块化项目
- en: Generating module declarations with JDeps
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JDeps生成模块声明
- en: Hacking third-party JARs with the `jar` tool
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`jar`工具修改第三方JAR文件
- en: Publishing modular JARs for Java 8 and older
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布适用于Java 8及更早版本的模块化JAR文件
- en: Chapters 6, 7, and 8 discuss the technical details behind migrating to Java
    9+ and turning an existing code base into a modular one. This chapter takes a
    broader view and looks at how to best compose these details into successful migration
    and modularization efforts. We’ll first discuss how to perform a gradual migration
    that cooperates well with the development process, particularly build tools and
    continuous integration. Next, we’ll look at how to use the unnamed module and
    automatic modules as building blocks for specific modularization strategies. And
    finally, we’ll cover options for making JARs modular—yours or your dependencies’.
    When you’re done with this chapter, you’ll not only understand the mechanisms
    behind migration challenges and modularization features—you’ll also know how to
    best employ them in your efforts.
  id: totrans-812
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第6章、第7章和第8章讨论了迁移到Java 9+以及将现有代码库转变为模块化代码库的技术细节。本章从更广阔的角度来看，探讨如何将这些细节最佳地组合成成功的迁移和模块化努力。我们首先讨论如何进行逐步迁移，这种迁移与开发过程（尤其是构建工具和持续集成）配合得很好。接下来，我们将探讨如何使用未命名的模块和自动模块作为特定模块化策略的构建块。最后，我们将介绍使JAR文件模块化的选项——无论是你的还是你的依赖项的。当你完成本章后，你不仅会了解迁移挑战和模块化功能的机制，还会知道如何最好地在你自己的努力中运用它们。
- en: 9.1 Migration strategies
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.1 迁移策略
- en: With all the knowledge you’ve gathered in chapters 6 and 7, you’re prepared
    for every fight Java 9+ may pick with you. Now it’s time to broaden your view
    and develop a larger strategy. How can you arrange the bits and pieces to make
    the migration as thorough and predictable as possible? This section gives advice
    on preparing for a migration, estimating migration efforts, setting up a continuous
    build on Java 9+, and drawbacks of command-line options.
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在第6章和第7章中收集的所有知识，使你准备好应对Java 9+可能对你提出的每一个挑战。现在，是时候拓宽你的视野并制定一个更广泛的策略了。你该如何安排这些零散的部分，使迁移尽可能全面和可预测？本节提供了关于准备迁移、估算迁移工作量、在Java
    9+上设置持续构建以及命令行选项的缺点等方面的建议。
- en: NOTE Many topics in this section are connected to build tools, but they’re kept
    generic enough that they don’t require you to know any specific tool. At the same
    time, I wanted to share my experience with Maven (the only build tool I’ve used
    on Java 9+ so far), so I occasionally point out the Maven feature I used to fulfill
    a specific requirement. I won’t go into any detail, though, so you’ll have to
    figure out for yourself how those features help.
  id: totrans-815
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：本节中的许多主题都与构建工具相关，但它们保持足够的通用性，不需要你了解任何特定工具。同时，我想分享我在Maven（到目前为止我在Java 9+上使用的唯一构建工具）上的经验，所以我偶尔会指出我用来满足特定要求的Maven功能。不过，我不会深入细节，所以你需要自己弄清楚这些功能是如何帮助你的。
- en: 9.1.1 PREPARATORY UPDATES
  id: totrans-816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.1.1 准备更新
- en: First, if you’re not on Java 8 yet, you should make that update! Do yourself
    a favor and don’t jump two or more Java versions at once. Make an update, get
    all your tools and processes working, run it in production for a while, and then
    tackle the next update. The same is true if you want to update from Java 8 to
    11—take it one step at a time. If you have any problems, you’ll really want to
    know which Java version or dependency update caused them.
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，如果你还没有在Java 8上，你应该进行这次更新！做件好事，一次不要跳过两个或更多Java版本。进行更新，确保所有工具和流程正常工作，在生产环境中运行一段时间，然后再处理下一个更新。如果你想要从Java
    8更新到11，也是一样，一步一步来。如果你遇到任何问题，你真的会想知道是哪个Java版本或依赖项更新导致了这些问题。
- en: Speaking of dependencies, another thing you can do without even looking at Java
    9+ is to start updating them as well as your tools. Besides the general benefit
    of being up to date, you may inadvertently update from a version that has problems
    with Java 9+ to one that works fine with it. You won’t even notice you had a problem.
    If there’s no version compatible with Java 9+ yet, being on the most recent release
    of your dependency or tool still makes it easier to update once a compatible version
    is published.
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 谈到依赖项，你还可以在不查看Java 9+的情况下开始更新它们以及你的工具。除了保持更新的普遍好处外，你可能会无意中从与Java 9+有问题的版本更新到一个与之兼容的版本。你甚至都不会注意到你遇到了问题。如果还没有与Java
    9+兼容的版本，那么使用你依赖项或工具的最新版本仍然会在兼容版本发布后更容易更新。
- en: AdoptOpenJDK quality outreach
  id: totrans-819
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 采用AdoptOpenJDK质量推广
- en: 'AdoptOpenJDK, “a community of Java user group members, Java developers and
    vendors who are advocates of OpenJDK,” has a list of various open source projects
    and how well they’re doing on the latest and next version of Java: [http://mng.bz/90HA](http://mng.bz/90HA).'
  id: totrans-820
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: AdoptOpenJDK，“一个由Java用户群成员、Java开发人员和倡导OpenJDK的供应商组成的社区”，有一个各种开源项目的列表以及它们在最新和下一个Java版本上的表现情况：[http://mng.bz/90HA](http://mng.bz/90HA)。
- en: 9.1.2 ESTIMATING THE EFFORT
  id: totrans-821
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.1.2 估计工作量
- en: There are a few things you can do to get an idea of what lies ahead, and we’ll
    look at those first. The next step is to evaluate and categorize the problems
    you found. I end this section with a small note on estimating concrete numbers.
  id: totrans-822
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有几件事情你可以做来了解接下来会发生什么，我们首先看看这些。下一步是评估和分类你发现的问题。我在本节结束时简要说明一下估计具体数字的方法。
- en: LOOKING FOR TROUBLE
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 寻找问题
- en: 'These are the most obvious choices to gather a list of problems:'
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些是最明显的选择来收集问题列表：
- en: 'Configure your build to compile and test on Java 9+ (Maven: toolchain), ideally
    in a way that lets you gather all errors instead of stopping at the first (Maven:
    `--fail-never`).'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '配置你的构建过程以在Java 9+上编译和测试（Maven: toolchain），理想情况下以能够收集所有错误而不是在第一个错误停止的方式（Maven:
    `--fail-never`）。'
- en: 'Run your entire build on Java 9+ (Maven: `~/.mavenrc`), again gathering all
    errors.'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在Java 9+上运行你的整个构建过程（Maven: `~/.mavenrc`），再次收集所有错误。'
- en: If you’re developing an application, build it as you do normally (meaning not
    yet on Java 9+), and then run it on Java 9+. Use `--illegal-access=debug` or `deny`
    to get more information on illegal access.
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在开发应用程序，按照通常的方式构建它（意味着还不是在Java 9+上），然后在Java 9+上运行它。使用`--illegal-access=debug`或`deny`来获取有关非法访问的更多信息。
- en: Carefully analyze the output, take note of new warnings and errors, and try
    to link them to what previous chapters discussed. Look out for the removed command-line
    options described in section 6.5.3.
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仔细分析输出结果，注意新的警告和错误，并尝试将它们与前面章节讨论的内容联系起来。留意第6.5.3节中描述的已删除的命令行选项。
- en: 'It’s a good idea to apply some quick fixes like adding exports or JEE modules.
    This allows you to see the tougher problems that may be hiding behind benign ones.
    In this phase, no fix is too quick or too dirty—anything that gets the build to
    throw a new error is a victory. If you get too many compile errors, you could
    compile with Java 8 and just run the tests on Java 9+ (Maven: `mvn surefire:test`).'
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '应用一些快速修复措施，如添加导出或JEE模块是个好主意。这让你能够看到可能隐藏在良性问题背后的更困难的问题。在这个阶段，没有修复是太快或太脏的——任何能让构建抛出新错误的都是胜利。如果你有太多的编译错误，你可以用Java
    8编译，然后在Java 9+上运行测试（Maven: `mvn surefire:test`）。'
- en: Then run JDeps on your project and your dependencies. Analyze dependencies on
    JDK-internal APIs (section 7.1.2), and note any JEE modules (section 6.1). Also
    look for split packages between platform modules and application JARs (section7.2.5).
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后，在你的项目和依赖项上运行JDeps。分析对JDK内部API的依赖（第7.1.2节），并注意任何JEE模块（第6.1节）。还要寻找平台模块和应用JAR之间的分割包（第7.2.5节）。
- en: Finally, search your code base for calls to `AccessibleObject::setAccessible`
    (section 7.1.4), casts to`URLClassLoader` (section 6.2), parsing of `java.version`
    system properties (section 6.5.1), or handcrafting resource URLs (section 6.3).
    Put everything you found on one big list—now it’s time to analyze it.
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，搜索你的代码库中调用`AccessibleObject::setAccessible`（第7.1.4节）、转换到`URLClassLoader`（第6.2节）、解析`java.version`系统属性（第6.5.1节）或手工制作资源URL（第6.3节）的地方。把所有找到的东西列在一个大列表上——现在是你分析它的时候了。
- en: HOW BAD IS IT?
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这有多糟糕？
- en: 'The problems you’ve found should fall into two categories: “I’ve seen it in
    this book” and “What the &*!# is going on?” For the former, split the issue further
    into “Has at least a temporary fix” and “Is a hard problem.” Particularly difficult
    problems are removed APIs and package splits between platform modules and JARs
    that don’t implement an endorsed standard or a standalone technology.'
  id: totrans-833
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你发现的问题应该分为两类：“我在这本书里见过”和“到底发生了什么？”对于前者，进一步将问题分为“至少有一个临时修复”和“是难题。”特别困难的问题包括移除的API和平台模块与不实现推荐标准或独立技术的JAR之间的包分割。
- en: It’s important not to confuse prevalence with importance! You may get about
    a thousand errors because a JEE module is missing, but fixing that is trivial.
    You’re in big trouble, on the other hand, if your core feature depends on one
    cast of the application class loader to `URLClassLoader`. Or you may have a critical
    dependency on a removed API but because you’ve designed your system well, it just
    causes a few compile errors in one subproject.
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是不要混淆普遍性与重要性！你可能因为一个JEE模块缺失而有大约一千个错误，但修复它是微不足道的。另一方面，如果你的核心功能依赖于应用程序类加载器到`URLClassLoader`的一次转换，那你就麻烦了。或者你可能有一个对移除的API的临界依赖，但由于你很好地设计了系统，它只是导致一个子项目中出现几个编译错误。
- en: A good approach is to ask yourself for each specific problem for which you don’t
    know a solution off the top of your head, “How bad would it be if I cut out the
    troublesome code and everything that depends on it?” How much would that hurt
    your project? In that vein, would it be possible to temporarily deactivate the
    troublesome code? Tests can be ignored, and features can be toggled with flags.
    Get a sense for the how feasible it is to delay a fix and run the build and the
    application without it.
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个好的方法是，对于每个你不知道解决方案的具体问题，问自己，“如果我删除了麻烦的代码及其所有依赖，会发生什么？”这会对你的项目造成多大的伤害？按照这个思路，是否有可能暂时禁用麻烦的代码？测试可以忽略，特性可以通过标志来切换。感受一下延迟修复并运行构建和应用程序的可行性。
- en: 'When you’re finished, you should have a list of issues in these three categories:'
  id: totrans-836
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你完成时，你应该有三个类别的问题列表：
- en: A known problem with an easy fix
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知问题但有简单修复
- en: A known, hard problem
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知的难题
- en: An unknown problem that needs investigation
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要调查的未知问题
- en: For problems in the last two categories, you should know how dangerous they
    are for your project and how easily you could get by without fixing them right
    now.
  id: totrans-840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于最后两个类别中的问题，你应该知道它们对你的项目有多危险，以及你有多容易在不修复它们的情况下通过。
- en: ON ESTIMATING NUMBERS
  id: totrans-841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于估计数字
- en: Chances are that somebody wants you to make an estimate that involves some hard
    numbers—maybe in hours, maybe in currency. That’s tough in general, but here it’s
    particularly problematic.
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很可能有人希望你做出一个涉及一些硬数字的估计——可能是小时，也可能是货币。这通常很难，但在这里尤其有问题。
- en: A Java 9+ migration makes you face the music of decisions long past. Your project
    may be tightly coupled to an outdated version of a web framework you wanted to
    update for years, or it may have accrued a lot of technical debt around an unmaintained
    library. And unfortunately, both stop working on Java 9+. What you have to do
    now is pay back some technical debt—and everybody knows the fees and interest
    can be difficult to estimate. Finally, just like a good boss battle, the critical
    problem—the one that costs the most to fix—may be hidden behind a few other troublemakers,
    so you can’t see it until you’re in too deep. I’m not saying these scenarios are
    likely, just that they’re possible, so be careful about guessing how long it may
    take you to migrate to Java 9.
  id: totrans-843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 9+ 迁移让您面对早已过去的决策。您的项目可能紧密耦合到一个您已经多年想要更新的旧版 Web 框架，或者它可能围绕一个未维护的库积累了大量技术债务。不幸的是，这两者都无法在
    Java 9+ 上工作。您现在必须偿还一些技术债务——众所周知，费用和利息可能很难估计。最后，就像一场好的老板战斗一样，关键问题——修复成本最高的那个问题——可能隐藏在几个其他麻烦制造者后面，所以您只能在陷入太深时才能看到它。我并不是说这些场景很可能会发生，只是说它们是可能的，所以请小心猜测您迁移到
    Java 9 可能需要多长时间。
- en: 9.1.3 CONTINUOUSLY BUILD ON JAVA 9+
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.1.3 在 Java 9+ 上持续构建
- en: 'Assuming you’re continuously building your project, the next step is to set
    up a successful Java 9+ build. There are many decisions to make:'
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设您正在持续构建您的项目，下一步是设置一个成功的 Java 9+ 构建。有许多决策需要做出：
- en: Which branch should you build?
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该构建哪个分支？
- en: Should there be a separate version?
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应该有一个单独的版本？
- en: How should you slice the build if it can’t fully run on Java 9+ from day one?
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果从第一天开始就无法在 Java 9+ 上完全运行构建，你应该如何切割构建？
- en: How do you keep Java 8 and Java 9+ builds running side by side?
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您如何保持 Java 8 和 Java 9+ 构建并行运行？
- en: In the end, it’s up to you to find answers that fit your project and continuous
    integration (CI) setup. Let me share some ideas that worked well in my migrations,
    and you can combine them any way you like.
  id: totrans-850
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，找到适合您项目和持续集成（CI）设置的答案取决于您。让我分享一些在我的迁移中效果很好的想法，您可以根据自己的喜好进行组合。
- en: WHICH BRANCH TO BUILD?
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该构建哪个分支？
- en: 'You may be tempted to set up your own branch for the migration effort and let
    your CI server build that one with Java 9+ while the others are built with Java
    8 as before. But the migration can take time, so it’s likely to result in a long-lived
    branch—and I generally try not to have those for various reasons:'
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会想为迁移工作设置自己的分支，并让 CI 服务器使用 Java 9+ 构建该分支，而其他分支则像以前一样使用 Java 8。但是，迁移可能需要花费时间，因此很可能会导致长期存在的分支——出于各种原因，我通常尽量避免这种情况：
- en: You’re on your own, and your changes aren’t continuously scrutinized by a team
    that bases their work on them.
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将独自一人，您的更改不会持续受到基于这些更改工作的团队的审查。
- en: Both branches may accrue a lot of changes, which increases the chance of conflicts
    when updating or merging the Java 9+ branch.
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个分支都可能积累很多更改，这增加了在更新或合并 Java 9+ 分支时发生冲突的机会。
- en: If it takes a while for changes on the main development branch to find their
    way into the Java 9+ branch, the rest of the team is free to add code that creates
    new problems on Java 9+ without getting immediate feedback.
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果主开发分支上的更改需要一段时间才能进入 Java 9+ 分支，那么其他团队成员可以自由地添加代码，在 Java 9+ 上创建新的问题，而无需立即获得反馈。
- en: Although it can make sense to do the initial investigation into the migration
    on a separate branch, I recommend switching to the main development branch early
    and setting up CI there. That does require a little more fiddling with your build
    tool, though, because you need to separate some parts of the configuration (for
    example, command-line options for the compiler) by Java version (the Java compiler
    doesn’t like unknown options).
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然在单独的分支上进行迁移的初步调查是有意义的，但我建议尽早切换到主开发分支并在那里设置 CI。但这确实需要您对构建工具进行一些额外的调整，因为您需要根据
    Java 版本（Java 编译器不喜欢未知选项）来分离配置的一些部分（例如，编译器的命令行选项）。
- en: WHICH VERSION TO BUILD?
  id: totrans-857
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该构建哪个版本？
- en: Should the Java 9+ build create a separate version of your artifacts—something
    like `-JAVA-LATEST-SNAPSHOT`? If you’ve decided to create a separate Java 9+ branch,
    you’re likely forced to create a separate version, too. Otherwise, it’s easy to
    mix snapshot artifacts from different branches, which is bound to break the build,
    the more the branches deviate. If you’ve decided to build from the main development
    branch, creating a separate version may not be easy; but I never tried, because
    I found no good reason to do it.
  id: totrans-858
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JAVA 9+构建是否应该创建你工件的一个单独版本——比如`-JAVA-LATEST-SNAPSHOT`？如果你决定创建一个单独的JAVA 9+分支，你很可能被迫创建一个单独的版本。否则，很容易混合来自不同分支的快照工件，这很可能会破坏构建，分支越偏离，这种情况就越有可能发生。如果你决定从主开发分支构建，创建一个单独的版本可能不容易；但我从未尝试过，因为我没有找到做这件事的好理由。
- en: 'Regardless of how you handle versions, when trying to get something to work
    on Java 9+, you’ll probably occasionally build the same subproject with the same
    version with Java 8\. One thing I do again and again, even though I resolve not
    to, is install the artifacts I build with Java 9+ in my local repository. You
    know, the knee-jerk `mvn clean install`? That’s not a good idea: then you can’t
    use those artifacts in a Java 8 build, because it doesn’t support Java 9+ bytecode.'
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论你如何处理版本，当尝试在JAVA 9+上使某些内容工作的时候，你可能会偶尔用JAVA 8构建相同的子项目并使用相同的版本。尽管我决定不再这样做，但我还是会反复安装我用JAVA
    9+构建的工件。你知道的，就是那种条件反射式的`mvn clean install`？这并不是一个好主意：然后你无法在JAVA 8构建中使用这些工件，因为JAVA
    8不支持JAVA 9+的字节码。
- en: When building locally with Java 9+, try to remember not to install the artifacts!
    I use `mvn clean verify` for that.
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用JAVA 9+在本地构建时，尽量记住不要安装工件！我使用`mvn clean verify`来做这件事。
- en: WHAT TO BUILD WITH JAVA 9+?
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用JAVA 9+能构建什么？
- en: 'The end goal is to have the build tool run on Java 9+ and build all projects
    across all phases/tasks. Depending on how many items on that list you created
    earlier, it’s possible you only need to change a few things to get there. In that
    case, go for it—there’s no reason to complicate the process. On the other hand,
    if your list is more daunting, there are several ways to slice the Java 9 build:'
  id: totrans-862
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最终目标是让构建工具在JAVA 9+上运行，并在所有阶段/任务中构建所有项目。根据你之前创建的列表中的项目数量，你可能只需要更改几个东西就能达到这个目标。在这种情况下，就去做吧——没有必要使过程复杂化。另一方面，如果你的列表更令人畏惧，有几种方法可以切割JAVA
    9构建：
- en: You may run the build on Java 8 and only compile and test against Java 9+. I’ll
    discuss that in a minute.
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在JAVA 8上运行构建，但只编译和测试JAVA 9+。我稍后会讨论这一点。
- en: You may make the migration per goal/task, meaning you first try to compile your
    entire project against Java 9+ before starting to make the tests work.
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以按目标/任务进行迁移，这意味着你首先尝试编译整个项目以JAVA 9+为目标，然后再开始使测试工作。
- en: You may migrate by subproject, meaning you first try to compile, test, and package
    an entire subproject before moving to the next.
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以按子项目进行迁移，这意味着你首先尝试编译、测试和打包整个子项目，然后再进行下一个。
- en: Generally speaking, I prefer the “by goal/task” approach for large, monolithic
    projects and the “by subproject” approach if the project is split into parts small
    enough to be tackled in one go.
  id: totrans-866
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一般而言，对于大型单体项目，我更喜欢“按目标/任务”的方法，如果项目被拆分成足够小以至于可以一次性解决的部分，则采用“按子项目”的方法。
- en: 'If you go by subproject, but one of them can’t be built on Java 9+ for whatever
    reason, you can’t easily build the subprojects depending on it. I was in that
    situation once, and we decided to set up the Java 9 build in two runs:'
  id: totrans-867
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你按子项目进行，但其中一个子项目由于某种原因无法在JAVA 9+上构建，那么你无法轻松构建依赖于它的子项目。我曾经遇到过这种情况，我们决定分两步设置JAVA
    9构建：
- en: Build everything with Java 8.
  id: totrans-868
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JAVA 8构建所有内容。
- en: Build everything with Java 9+ except the troublesome subprojects (subprojects
    depending on them were then built against the Java 8 artifacts).
  id: totrans-869
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了有问题的子项目外，用JAVA 9+构建所有内容（然后这些依赖于它们的子项目是用JAVA 8的工件构建的）。
- en: YOUR BUILD TOOL ON JAVA 9+
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在JAVA 9+上的构建工具
- en: 'Until your project is fully migrated to Java 9+, you may need to switch often
    between building it with 8 and 9+. See how you can configure the version of Java
    for your build tool of choice without having to set the default Java version for
    your entire machine (Maven: `~/.mavenrc` or the toolchain). Then consider automating
    the switch. I ended up writing a little script that set `$JAVA_HOME` to either
    JDK 8 or JDK 9+, so I could quickly pick the one I need.'
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '在你的项目完全迁移到Java 9+之前，你可能需要经常在用8和9+构建之间切换。看看你如何配置你选择的构建工具的Java版本，而无需为你的整个机器设置默认的Java版本（Maven:
    `~/.mavenrc`或工具链）。然后考虑自动化切换。我最终编写了一个小脚本，将`$JAVA_HOME`设置为JDK 8或JDK 9+，这样我就可以快速选择我需要的版本。'
- en: Then, and this is a little meta, the build tool may not work properly on Java
    9+. Maybe the tool needs a JEE module, or maybe a plugin uses removed APIs. (I
    had that problem with a JAXB plugin for Maven, which needs java.xml.bind and relies
    on its internals.)
  id: totrans-872
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后，这有点元信息，构建工具可能在Java 9+上无法正常工作。可能需要JEE模块，或者可能有一个插件使用了已删除的API。（我有一个使用Maven的JAXB插件的例子，它需要java.xml.bind并依赖于其内部结构。）
- en: In that case, you could consider running the build on Java 8 and only compiling
    or testing against Java 9+, but that won’t work if the build does something with
    the created bytecode (for Java 9+) in its own process (which is Java 8). (I ran
    into that problem with the Java Remote Method Invocation Compiler (`rmic`); it
    forced us to run the entire build on Java 9+ even though we would have preferred
    not to.)
  id: totrans-873
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以考虑在Java 8上运行构建，但只编译或测试针对Java 9+，但如果构建在其自己的进程中（Java 8）对创建的字节码（Java
    9+）执行某些操作，则这不会起作用。（我遇到了Java远程方法调用编译器（`rmic`）的问题；它迫使我们整个构建都在Java 9+上运行，尽管我们更愿意不这样做。）
- en: 'If you decide to run the build on Java 9+ even though it doesn’t play nicely,
    you’ll have to configure the build process with some of the new command-line options.
    Doing this so it’s easy on your fellow team members (nobody wants to add options
    manually) while keeping it working on Java 8 (which doesn’t know the new options)
    can be nontrivial (Maven: `jvm.config`). I found no way to make it work on both
    versions without requiring a file rename, so I ended up including that in my “Switch
    Java version” script.'
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '如果你决定在Java 9+上运行构建，即使它表现不佳，你也必须配置构建过程以使用一些新的命令行选项。这样做以便对团队成员来说更容易（没有人想手动添加选项），同时保持它在Java
    8上也能工作（Java 8不知道新选项），可能不是一件简单的事情（Maven: `jvm.config`）。我发现没有方法可以在不要求文件重命名的情况下使它在两个版本上都能工作，所以我最终将其包含在我的“切换Java版本”脚本中。'
- en: HOW TO CONFIGURE THE JAVA 9+ BUILD
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如何配置Java 9+的构建
- en: 'How do you keep a Java 8 build and a Java 9+ build running when you have to
    add version-specific configuration options to compiler, test runtime, or other
    build tasks? Your build tool should help. It likely has a feature that allows
    you to adapt the overall configuration to various circumstances (Maven: profiles).
    Familiarize yourself with it, because you may end up using it a lot.'
  id: totrans-876
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '当你必须向编译器、测试运行时或其他构建任务添加特定版本的配置选项时，如何保持Java 8构建和Java 9+构建的运行？你的构建工具应该提供帮助。它可能有一个功能允许你根据各种情况调整整体配置（Maven:
    配置文件）。熟悉它，因为你可能会经常使用它。'
- en: 'When working with version-specific command-line options for the JVM, there’s
    an alternative to letting your build tool sort them out: with the nonstandard
    JVM option `-XX:+IgnoreUnrecognizedVMOptions`, you can instruct the launching
    VM to ignore unknown command-line options. (This option isn’t available on the
    compiler.) Although this allows you to use the same options for both Java 8 and
    Java 9+, I recommend not making it your first choice because it disables checks
    that can help you find mistakes. Instead, I prefer separating the options by version
    if at all possible.'
  id: totrans-877
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当与JVM的特定版本命令行选项一起工作时，有一个替代方案，即让构建工具来处理它们：使用非标准的JVM选项`-XX:+IgnoreUnrecognizedVMOptions`，你可以指示启动的VM忽略未知的命令行选项。（此选项在编译器中不可用。）尽管这允许你为Java
    8和Java 9+使用相同的选项，但我建议不要将其作为首选，因为它禁用了可以帮助你找到错误的检查。相反，如果可能的话，我更喜欢按版本分离选项。
- en: TESTING ON BOTH PATHS
  id: totrans-878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在两个路径上测试
- en: If you’re working on a library or framework, you have no control over the path,
    class path, or module path on which users place your JAR. Depending on the project,
    that may make a difference, in which case it becomes necessary to test both variants.
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在开发一个库或框架，你无法控制用户放置你的JAR文件的路径、类路径或模块路径。根据项目的情况，这可能会产生影响，在这种情况下，测试两种变体就变得必要了。
- en: Unfortunately, I can’t give any tips here. At the time of writing, neither Maven
    nor Gradle has good support for running the tests once on each path, and you may
    end up having to create a second build configuration. Let’s hope tool support
    improves over time.
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很遗憾，我这里不能提供任何建议。在撰写本文时，Maven和Gradle都没有很好地支持在每个路径上运行测试，你可能不得不创建第二个构建配置。让我们希望工具支持随着时间的推移而改进。
- en: FIX FIRST, SOLVE LATER
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 先修复，再解决
- en: 'Typically, most items on the list of Java 9+ problems are straightforward to
    fix with a command-line flag. Exporting an internal API, for example, is easy.
    That doesn’t solve the underlying problem, though. Sometimes the solution is easy
    as well, like replacing the internal `sun.reflect.generics.reflectiveObjects.NotImplementedException`
    with an `UnsupportedOperationException` (no kidding: I’ve had to do that more
    than once), but often it isn’t.'
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，Java 9+问题列表中的大多数项目都可以通过命令行标志轻松修复。例如，导出内部API很容易。但这并没有解决根本问题。有时解决方案也很简单，比如将内部的`sun.reflect.generics.reflectiveObjects.NotImplementedException`替换为`UnsupportedOperationException`（不是开玩笑：我不得不这样做好几次），但通常并不是这样。
- en: 'Should you aim for quick and dirty or for proper solutions that take a little
    longer? In the phase of trying to get a full build working, I recommend making
    the quick fix:'
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你是追求快速且粗糙的解决方案，还是追求更长时间的正确解决方案？在尝试使完整构建正常工作的阶段，我建议采取快速修复：
- en: Add command-line flags where necessary.
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在必要时添加命令行标志。
- en: Deactivate tests, preferably just on Java 9+ (on JUnit 4 it’s easy to use assumptions
    for that; on JUnit 5 I recommend conditions).
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭测试，最好是仅针对Java 9+（在JUnit 4中，使用假设很容易做到；在JUnit 5中，我推荐使用条件）。
- en: Switch a subproject back to compiling or testing against Java 8 if it uses a
    removed API.
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子项目使用了已删除的API，将其切换回编译或测试Java 8。
- en: If all else fails, skip the project entirely.
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有其他方法都失败了，就完全跳过该项目。
- en: A working build that gives the entire team immediate feedback on their project’s
    Java 9+ compatibility is worth a lot, including taking shortcuts to get there.
    To be able to improve on these temporary fixes later, I recommend coming up with
    a system that helps identify them.
  id: totrans-888
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个能够立即向整个团队提供项目Java 9+兼容性反馈的工作构建非常有价值，包括采取捷径来实现这一点。为了能够以后改进这些临时修复，我建议制定一个有助于识别它们的系统。
- en: 'I mark temporary fixes with a comment like `// [JAVA LATEST, <PROBLEM>]: <explanation>`
    so a full-text search for `JAVA LATEST, GEOTOOLS` leads me to all tests I had
    to deactivate because the GeoTools version wasn’t Java 9-compatible.'
  id: totrans-889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '我用注释如`// [JAVA LATEST, <PROBLEM>]: <explanation>`标记临时修复，这样全文搜索`JAVA LATEST,
    GEOTOOLS`就会把我带到所有必须禁用的测试，因为GeoTools版本与Java 9不兼容。'
- en: It’s common to find new problems that were originally hidden behind an earlier
    build error. If that happens, make sure to add them to your list of Java 9+ problems.
    Likewise, scratch off those that you solve.
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在早期构建错误背后发现新问题是常见的。如果发生这种情况，请确保将它们添加到你的Java 9+问题列表中。同样，划掉那些你已经解决的问题。
- en: KEEPING IT GREEN
  id: totrans-891
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 保持绿色
- en: Once you’ve set up a successful build, you should have a complete picture of
    all the Java 9+ challenges you face. It’s now time to solve them one by one.
  id: totrans-892
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦你成功设置了构建，你应该对面临的全部Java 9+挑战有一个完整的了解。现在是时候逐一解决它们了。
- en: Some of the issues may be tough or time-intensive to solve; you may even determine
    they can’t be addressed until a later point—maybe once an important release is
    made or the budget has a little wiggle room. Don’t worry if it takes some time.
    With a build that every developer on the team can break and fix, you can never
    take a step in the wrong direction; even if you have a lot of work ahead of you,
    you’ll eventually get there in little steps.
  id: totrans-893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些问题可能很难解决或耗时，你甚至可能确定它们只能在稍后解决——比如在发布一个重要版本或预算有一些灵活性之后。如果需要一些时间，请不要担心。有了每个团队成员都可以破坏和修复的构建，你永远不会走错方向；即使你面前有很多工作，你最终也会一步步到达那里。
- en: 9.1.4 THOUGHTS ON COMMAND-LINE OPTIONS
  id: totrans-894
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.1.4 关于命令行选项的想法
- en: 'With Java 9+, you may end up applying more command-line options than ever before—it
    sure has been like that for me. I have a few insights I want to share about the
    following:'
  id: totrans-895
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Java 9+中，你可能需要应用比以往更多的命令行选项——对我来说确实是这样。我想分享一些关于以下方面的见解：
- en: Four ways to apply command-line options
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用命令行选项的四种方法
- en: Relying on weak encapsulation
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖于脆弱的封装
- en: Pitfalls of command-line options
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行选项的陷阱
- en: Let’s go through them one by one.
  id: totrans-899
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 逐个来看。
- en: FOUR WAYS TO APPLY COMMAND-LINE OPTIONS
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用命令行选项的四种方法
- en: The most obvious way to apply command-line options is to use the command line
    and append the options after `java` or `javac`. But did you know there are three
    more possibilities?
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用命令行选项最明显的方法是使用命令行，并在 `java` 或 `javac` 后附加选项。但你是否知道还有三种其他可能性？
- en: If your application is delivered as an executable JAR, using the command line
    isn’t an option. In that case, you can use the new manifest entries `Add-Exports`
    and `Add-Opens`, which take a comma-separated list of `${module}/${package}` pairs
    and export or open that package to code on the class path. The JVM only scans
    the application’s executable JAR, meaning the one specified with the runtime’s
    `-jar` option, for these manifest entries, so there’s no point in adding them
    to library JARs.
  id: totrans-902
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你的应用程序以可执行 JAR 的形式交付，使用命令行不是一种选择。在这种情况下，你可以使用新的清单条目 `Add-Exports` 和 `Add-Opens`，它们接受以逗号分隔的
    `${module}/${package}` 对的列表，并将该包导出或对类路径上的代码打开。JVM 只扫描应用程序的可执行 JAR，即通过运行时的 `-jar`
    选项指定的 JAR，以查找这些清单条目，因此没有必要将它们添加到库 JAR 中。
- en: Another way to permanently set command-line options, at least for the JVM, is
    the environment variable `JDK_JAVA_OPTIONS`. It was introduced in Java 9+, so
    Java 8 won’t pick it up. You’re hence free to include any command-line options
    specific to Java 9+ that each execution of `java` on your machine will apply.
    This will hardly be a long-term solution, but it may make some experiments easier.
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一种永久设置命令行选项的方法（至少对于 JVM 来说）是环境变量 `JDK_JAVA_OPTIONS`。它在 Java 9+ 中引入，因此 Java
    8 不会拾取它。因此，你可以自由地包含任何特定于 Java 9+ 的命令行选项，这些选项将在你的机器上每次执行 `java` 时应用。这几乎不会是一个长期解决方案，但它可能会使一些实验更容易进行。
- en: Finally, command-line options don’t have to be entered directly on the command
    line. An alternative is so-called argument files (or @-files), which are plain-text
    files that can be referenced on the command line with `@${filename}`. Compiler
    and runtime will then act as if the file content had been added to the command.
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，命令行选项不必直接在命令行中输入。一种替代方法是所谓的参数文件（或 @-文件），这些是纯文本文件，可以在命令行中使用 `@${filename}`
    来引用。编译器和运行时会像文件内容已被添加到命令中一样操作。
- en: 'Section 7.2.4 shows how to compile code that uses annotations from JEE and
    JSR 305:'
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7.2.4 节展示了如何编译使用 JEE 和 JSR 305 注解的代码：
- en: '`$ javac --add-modules java.xml.ws.annotation --patch-module java.xml.ws.annotation=jsr305-3.0.2.jar
    --class-path ''libs/*'' -d classes/monitor.rest ${source-files}`'
  id: totrans-906
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac --add-modules java.xml.ws.annotation --patch-module java.xml.ws.annotation=jsr305-3.0.2.jar
    --class-path ''libs/*'' -d classes/monitor.rest ${source-files}`'
- en: 'Here, `--add-modules` and `--patch-module` are added to make the compilation
    work on Java 9+. You could put these two lines in a file called `java-LATEST-args`
    and then compile as follows:'
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里，`--add-modules` 和 `--patch-module` 被添加以使编译在 Java 9+ 上工作。你可以将这些两行放入一个名为 `java-LATEST-args`
    的文件中，然后按照以下方式编译：
- en: '`$ javac @java-LATEST-args --class-path ''libs/*'' -d classes/monitor.rest
    ${source-files}`'
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ javac @java-LATEST-args --class-path ''libs/*'' -d classes/monitor.rest
    ${source-files}`'
- en: What’s new in Java 9+ is that the JVM also recognizes argument files, so they
    can be shared between compilation and execution.
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 9+ 的新特性是 JVM 也识别参数文件，因此它们可以在编译和执行之间共享。
- en: Maven and argument files
  id: totrans-910
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Maven 和参数文件
- en: Unfortunately, argument files don’t work with Maven. The compiler plugin already
    creates a file for all its own options, and Java doesn’t supported nested argument
    files.
  id: totrans-911
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不幸的是，参数文件与 Maven 不兼容。编译器插件已经为所有自己的选项创建了一个文件，并且 Java 不支持嵌套的参数文件。
- en: RELYING ON WEAK ENCAPSULATION
  id: totrans-912
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 依赖脆弱封装
- en: As section 7.1 explains in detail, the Java 9–11 (or more) runtimes allow illegal
    access by default with nothing more than a warning. That’s great for running unprepared
    applications, but I advise against relying on it during a proper build because
    it allows new illegal accesses to slip by unnoticed. Instead, I collect all the
    `--add-exports` and `--add-opens` I need and then activate strong encapsulation
    at run time with `--illegal-access=deny`.
  id: totrans-913
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如 7.1 节详细解释的那样，Java 9–11（或更高）运行时默认允许非法访问，只需一个警告即可。这对于运行未准备好的应用程序来说很棒，但我建议在正式构建过程中不要依赖它，因为它允许新的非法访问悄悄通过而未被注意到。相反，我会收集我需要的所有
    `--add-exports` 和 `--add-opens`，然后在运行时通过 `--illegal-access=deny` 激活强封装。
- en: THE PITFALLS OF COMMAND-LINE OPTIONS
  id: totrans-914
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命令行选项的陷阱
- en: 'Using command-line options has a few pitfalls:'
  id: totrans-915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用命令行选项有几个陷阱：
- en: These options are infectious in the sense that if a JAR needs them, all of its
    dependencies need them as well.
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些选项具有传染性，如果 JAR 需要它们，所有其依赖项也需要它们。
- en: Developers of libraries and frameworks that require specific options will hopefully
    document that their clients need to apply them, but nobody reads the documentation
    until it’s too late.
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些需要特定选项的库和框架的开发者希望记录下他们的客户端需要应用这些选项，但没有人会在为时已晚之前阅读文档。
- en: Application developers must maintain a list of options that merge the requirements
    of several libraries and frameworks they use.
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序开发者必须维护一个选项列表，以合并他们使用的几个库和框架的要求。
- en: It isn’t easy to maintain the options in a way that allows sharing them between
    different build phases and execution.
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一种允许在不同构建阶段和执行之间共享选项的方式维护选项并不容易。
- en: It isn’t easy to determine which options can be removed due to an update to
    a Java 9–compatible version.
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Java 9兼容版本更新，很难确定哪些选项可以被移除。
- en: 'It can be tricky to apply the options to the right Java processes: for example,
    for a build-tool plugin that doesn’t run in the same process as the build tool.'
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将选项应用于正确的Java进程可能会很棘手：例如，对于不与构建工具在同一个进程运行的构建工具插件。
- en: 'These pitfalls make one thing clear: command-line options are a fix, not a
    proper solution, and they have their own long-term costs. This is no accident—they
    were designed to make the undesired possible. Not easy, though, or there would
    be no incentive to solve the underlying problem.'
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些陷阱清楚地表明：命令行选项是一种权宜之计，而不是一个恰当的解决方案，并且它们有其自身的长期成本。这不是偶然——它们被设计成使得不希望发生的事情成为可能。尽管如此，这并不容易，否则就没有解决根本问题的动力。
- en: Do your best to only rely on public and supported APIs, not to split packages,
    and to generally avoid the trouble this chapter describes. And, importantly, reward
    libraries and frameworks that do the same! But the road to hell is paved with
    good intentions, so if everything else fails, use every command-line flag at your
    disposal.
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽量只依赖公共和支持的API，不要拆分包，并通常避免本章描述的麻烦。并且，重要的是要奖励那些做同样事情的库和框架！但通往地狱的道路是由好意铺就的，所以如果其他所有方法都失败了，就使用你所能使用的每一个命令行标志。
- en: 9.2 Modularization strategies
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.2 模块化策略
- en: In chapter 8, you learned all about the unnamed module, automatic modules, and
    mixing plain JARs, modular JARs, class path, and module path. But how do you put
    that into practice? What are the best strategies to incrementally modularize a
    code base? To answer these questions, imagine the entire Java ecosystem as a huge
    layered graph of artifacts (see [figure 9.1](part0023.html#filepos1123815)).
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在第8章中，你学习了所有关于未命名模块、自动模块以及混合普通JAR、模块化JAR、类路径和模块路径的内容。但如何将这些知识付诸实践？将代码库逐步模块化的最佳策略是什么？为了回答这些问题，想象整个Java生态系统是一个巨大的分层图，由各种工件组成（见[图9.1](part0023.html#filepos1123815)）。
- en: At the bottom is the JDK, which used to be a single node but, thanks to the
    module system, is now made up of about a hundred nodes with java.base as the foundation.
    On top of them sit libraries that have no runtime dependencies outside the JDK
    (like SLF4J, Vavr, and AssertJ), followed by those with just a few (for example,
    Guava, JOOQ, and JUnit 5). Somewhere in the middle are the frameworks with their
    deeper stacks (for example, Spring and Hibernate), and at the very top sit the
    applications.
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在底层是JDK，它曾经是一个单独的节点，但由于模块系统的存在，现在由大约一百个节点组成，其中java.base作为基础。在其之上是没有任何JDK外部运行时依赖的库（如SLF4J、Vavr和AssertJ），然后是只有少数依赖的库（例如Guava、JOOQ和JUnit
    5）。在中间位置是具有更深层次结构的框架（例如Spring和Hibernate），而在最顶层则是应用程序。
- en: '![](../images/00022.jpeg)'
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00022.jpeg)'
- en: '[Figure 9.1](part0023.html#filepos1122777) Artistic interpretation of the Java
    ecosystem’s global dependency graph: java.base with the rest of the JDK at the
    bottom; then libraries without third-party dependencies; further above more complex
    libraries and frameworks; and applications on top. (Don’t pay attention to any
    individual dependencies.)'
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图9.1](part0023.html#filepos1122777) 对Java生态系统全局依赖图的美术诠释：java.base位于底部，其余的JDK；然后是无第三方依赖的库；再往上是一些更复杂的库和框架；最顶层是应用程序。（不要关注任何个别依赖。）'
- en: Except for the JDK, all these artifacts were plain JARs when Java 9 came out,
    and it will take a few years before most of them contain a module descriptor.
    But how will that happen? How can the ecosystem undergo such a massive change
    without breaking apart? The modularization strategies enabled by the unnamed module
    (section 8.2) and automatic modules (section 8.3) are the answer. They make it
    possible for the Java community to modularize the ecosystem almost independently
    of one another.
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了JDK之外，所有这些工件在Java 9发布时都是普通的JAR文件，而且可能需要几年时间才能大多数包含模块描述符。但这是如何发生的？生态系统如何在不破裂的情况下经历如此巨大的变化？由未命名的模块（第8.2节）和自动模块（第8.3节）启用的模块化策略是答案。这使得Java社区几乎可以独立地对生态系统进行模块化。
- en: The developers who have it easiest maintain a project that has no dependencies
    outside the JDK or whose dependencies were already modularized—they can implement
    the bottom-up strategy (section 9.2.1). For applications, the top-down approach
    (section 9.2.2) offers a way forward. Maintainers of libraries and frameworks
    with unmodularized dependencies have it a little harder and need to do things
    inside-out (section 9.2.3).
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于那些最轻松的开发者来说，维护一个没有依赖JDK外部或其依赖项已经模块化的项目——他们可以实施自下而上的策略（第9.2.1节）。对于应用程序，自上而下的方法（第9.2.2节）提供了一种前进的方式。维护具有未模块化依赖项的库和框架的开发者会稍微困难一些，需要从内到外做事（第9.2.3节）。
- en: Looking at the ecosystem as a whole, your project’s place in it determines which
    strategy you must use. [Figure 9.2](part0023.html#filepos1126882) will help you
    pick the right one. But as section 9.2.4 explains, these approaches also work
    within individual projects, in which case you can choose any of the three. Before
    we come to that, though, learning the strategies is easier when we assume you
    modularize all artifacts at once.
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从整体生态系统来看，你的项目在其中的位置决定了你必须使用哪种策略。[图9.2](part0023.html#filepos1126882)将帮助你选择正确的策略。但正如第9.2.4节所解释的，这些方法也可以在单个项目中使用，在这种情况下，你可以选择这三种中的任何一种。在我们到达那里之前，如果我们假设你一次模块化所有工件，学习这些策略会更容易。
- en: '![](../images/00103.jpeg)'
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片00103](../images/00103.jpeg)'
- en: '[Figure 9.2](part0023.html#filepos1126190) How to decide which modularization
    strategy fits your project'
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图9.2](part0023.html#filepos1126190) 如何决定哪种模块化策略适合你的项目'
- en: By including a module descriptor in your JARs, you advertise that the project
    is ready to be used as a module on Java 9+. You should do that only if you’ve
    taken all possible steps to ensure it works smoothly—chapters 6 and 7 explains
    most challenges, but if your code uses reflection, you should also read chapter
    12.
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过在你的JAR文件中包含模块描述符，你宣布该项目已准备好在Java 9+上作为模块使用。只有在你已经采取所有可能的步骤确保其顺利工作时才应该这样做——第6章和第7章解释了大多数挑战，但如果你的代码使用了反射，你也应该阅读第12章。
- en: If users have to do anything to make your modules work, like adding command-line
    flags to their application, this should be well documented. Note that you can
    create modular JARs that still work seamlessly on Java 8 and older versions—section
    9.3.4 has you covered.
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果用户必须做任何事情才能使你的模块工作，比如向他们的应用程序添加命令行标志，这应该有很好的文档记录。请注意，你可以创建仍然可以在Java 8和更早版本上无缝工作的模块化JAR文件——第9.3.4节为你提供了覆盖。
- en: 'As I’ve often mentioned, a module has three basic properties: a name, a clearly
    defined API, and explicit dependencies. When creating a module, you obviously
    have to pick the name. The exports can be quibbled over, but are mostly predetermined
    by which classes need to be accessible. The real challenges, and where the rest
    of the ecosystem comes into play, are the dependencies. This section focuses on
    that aspect.'
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如我经常提到的，模块有三个基本属性：一个名称、一个明确定义的API和显式的依赖关系。在创建模块时，显然你必须选择名称。导出可能会有争议，但主要是由需要访问哪些类来预定的。真正的挑战，以及生态系统其他部分发挥作用的地方，是依赖关系。本节重点介绍这一方面。
- en: Know your dependencies
  id: totrans-937
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 了解你的依赖关系
- en: You have to know quite a bit about your dependencies, direct and indirect, to
    modularize a project. Remember that you can use JDeps to determine dependencies
    (particularly on platform modules; see appendix D) and `jar --describe-module`
    to check a JAR’s modularization status (see sections 4.5.2 and 8.3.1).
  id: totrans-938
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你必须对你的依赖关系有相当的了解，无论是直接的还是间接的，才能对项目进行模块化。记住，你可以使用JDeps来确定依赖关系（尤其是在平台模块方面；参见附录D）和`jar
    --describe-module`来检查JAR的模块化状态（参见4.5.2节和8.3.1节）。
- en: With all of that said, it’s time to see how the three modularization strategies
    work.
  id: totrans-939
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说了这么多，是时候看看三种模块化策略是如何工作的了。
- en: '9.2.1 BOTTOM-UP MODULARIZATION: IF ALL PROJECT DEPENDENCIES ARE MODULAR'
  id: totrans-940
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.2.1 自下而上模块化：如果所有项目依赖项都是模块化的
- en: 'This is the easiest case for turning a project’s JARs into modules: the assumption
    is that the code only depends on explicit modules (directly and indirectly). It
    doesn’t matter whether those are platform or application modules; you can go straight
    ahead:'
  id: totrans-941
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是将项目的 JAR 包转换为模块的最简单情况：假设代码只依赖于显式模块（直接和间接）。这些模块是平台模块还是应用模块无关紧要；你可以直接进行：
- en: Create module declarations that require all your direct dependencies.
  id: totrans-942
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建需要所有直接依赖项的模块声明。
- en: Place the JARs with your non-JDK dependencies on the module path.
  id: totrans-943
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含你的非 JDK 依赖项的 JAR 包放置在模块路径上。
- en: You’ve now fully modularized your project—congratulations! If you’re maintaining
    a library or framework and users place your JARs on the module path, they will
    become explicit modules, and users can start benefiting from the module system.
    See [Figure 9.3](part0023.html#filepos1131598) for an example of a bottom-up modularization.
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，你已经完全模块化了你的项目——恭喜！如果你在维护一个库或框架，并且用户将你的 JAR 包放置在模块路径上，它们将成为显式模块，用户可以开始从模块系统中受益。参见[图
    9.3](part0023.html#filepos1131598)以了解自下而上的模块化示例。
- en: Almost as important but less obvious, thanks to the fact that all JARs on the
    class path end up in the unnamed module (see section 8.2), no one is forced to
    use it as a module. If someone sticks with the class path a while longer, your
    project will work just as if the module descriptor weren’t there. If you’d like
    to modularize your library but your dependencies aren’t modules yet, see section
    9.2.3.
  id: totrans-945
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 几乎同样重要但不太明显的是，由于所有类路径上的 JAR 包最终都会进入未命名的模块（参见第 8.2 节），没有人被迫将其用作模块。如果有人继续使用类路径一段时间，你的项目将像模块描述符不存在一样正常工作。如果你想要模块化你的库，但你的依赖项还不是模块，请参阅第
    9.2.3 节。
- en: '![](../images/00050.jpeg)'
  id: totrans-946
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00050.jpeg)'
- en: '[Figure 9.3](part0023.html#filepos1130716) Artifacts depending on modular JARs
    can be modularized straight away, leading to a bottom-up migration'
  id: totrans-947
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 9.3](part0023.html#filepos1130716) 依赖于模块化 JAR 包的工件可以立即进行模块化，从而导致自下而上的迁移'
- en: '9.2.2 TOP-DOWN MODULARIZATION: IF AN APPLICATION CAN’T WAIT FOR ITS DEPENDENCIES'
  id: totrans-948
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.2.2 自上而下模块化：如果应用程序不能等待其依赖项
- en: 'If you’re an application developer and want to modularize any time soon, it’s
    unlikely that all your dependencies already ship modular JARs. If they do, you’re
    lucky and can take the bottom-up approach I just described. Otherwise, you have
    to use automatic modules and start mixing module path and class path as follows:'
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你是一名应用程序开发者，并且希望尽快模块化，那么你的所有依赖项很可能还没有提供模块化的 JAR 包。如果它们已经有了，那么你很幸运，可以采用我刚才描述的自下而上的方法。否则，你必须使用自动模块，并开始混合模块路径和类路径，如下所示：
- en: Create module declarations that require all your direct dependencies.
  id: totrans-950
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建需要所有直接依赖项的模块声明。
- en: Place all modular JARs, the ones you build and your dependencies, on the module
    path.
  id: totrans-951
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有模块化 JAR 包，包括你构建的和你依赖的，放置在模块路径上。
- en: Place all plain JARs that are directly required by modular JARs on the module
    path, where they’re turned into automatic modules.
  id: totrans-952
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有由模块化 JAR 包直接需要的普通 JAR 包放置在模块路径上，在那里它们被转换为自动模块。
- en: Ponder what to do with the remaining plain JARs (see section 8.3.3).
  id: totrans-953
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 思考如何处理剩余的普通 JAR 包（参见第 8.3.3 节）。
- en: It may be easiest to place all remaining JARs on the module path in your build
    tool or IDE and give it a try. Although I don’t think that’s generally the best
    approach, it may work for you. In that case, go for it.
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能最简单的方法是将所有剩余的 JAR 包放置在你的构建工具或 IDE 的模块路径上，并尝试一下。虽然我不认为这通常是最好的方法，但它可能对你有效。在这种情况下，就去做吧。
- en: If you have problems with package splits or access to JDK-internal APIs, you
    may try placing those JARs on the class path. Because only automatic modules need
    them, and they can read the unnamed module, that works fine.
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你遇到包拆分或访问 JDK 内部 API 的问题，你可以尝试将这些 JAR 包放置在类路径上。因为只有自动模块需要它们，并且它们可以读取未命名的模块，所以这可以正常工作。
- en: In the future, once a formerly automatic module is modularized, that setup may
    fail because it’s now a modular JAR on the module path and hence can’t access
    code from the class path. I consider that to be a good thing, because it gives
    better insight into which dependencies are modules and which aren’t—it’s also
    a good opportunity to check out its module descriptor and learn about the project.
    To fix the problem, move that module’s dependencies onto the module path. See
    [Figure 9.4](part0023.html#filepos1134981) for an example of a top-down modularization.
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在未来，一旦一个以前自动的模块被模块化，这种设置可能会失败，因为现在它是一个模块化JAR文件，位于模块路径上，因此无法访问类路径上的代码。我认为这是一个好事，因为它可以更好地了解哪些依赖项是模块，哪些不是——这也是检查其模块描述符并了解项目的好机会。要解决这个问题，将那个模块的依赖项移动到模块路径上。参见[图9.4](part0023.html#filepos1134981)中一个自顶向下的模块化示例。
- en: '![](../images/00013.jpeg)'
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00013.jpeg)'
- en: '[Figure 9.4](part0023.html#filepos1134626) Thanks to automatic modules it’s
    possible to modularize artifacts that depend on plain JARs. Applications can use
    this to modularize from the top down.'
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图9.4](part0023.html#filepos1134626) 由于自动模块的存在，可以模块化依赖于普通JAR文件的工件。应用程序可以使用这一点从上向下进行模块化。'
- en: Note that you don’t have to worry about where automatic module names come from
    (see section 8.3.4). True, if they’re based on the filename, you have to change
    some `requires` directives once they get an explicit module name; but because
    you control all module declarations, that’s not a big deal.
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，你不必担心自动模块名称的来源（参见第8.3.4节）。确实，如果它们基于文件名，一旦它们获得显式的模块名称，你可能需要更改一些`requires`指令；但因为你控制所有模块声明，所以这并不是什么大问题。
- en: What about making sure modules that non-modular dependencies require make it
    into the graph? An application could either require them in a module declaration
    or use `--add-modules` to add them manually at compile and launch time. The latter
    is an option only if you have control over the launch command. The build tool
    may be able to make these decisions, but you still need to be aware of the options
    and how to configure them, so you can fix problems should they arise.
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那么如何确保非模块化依赖项所需的模块进入图中呢？应用程序可以在模块声明中要求它们，或者使用`--add-modules`在编译和启动时手动添加它们。后者只有在你可以控制启动命令的情况下才是可选的。构建工具可能能够做出这些决定，但你仍然需要了解这些选项以及如何配置它们，以便在出现问题时可以解决问题。
- en: '9.2.3 INSIDE-OUT MODULARIZATION: IF A PROJECT IS IN THE MIDDLE OF THE STACK'
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.2.3 内部-外部模块化：如果项目位于堆栈中间
- en: 'Most libraries and, particularly, frameworks are neither at the bottom nor
    at the top of the stack—what are they to do? They modularize inside-out. This
    process has a bit of bottom-up (section 9.2.1) in it because releasing modular
    JARs doesn’t force users to use them as modules. Other than that, it works like
    top-down (section 9.2.2), with one important difference: you’re planning to publish
    the modular JARs you built. See [figure 9.5](part0023.html#filepos1137792) for
    an example of an inside-out modularization.'
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数库和，尤其是框架，既不在堆栈的底部也不在顶部——它们该怎么办？它们从内部向外进行模块化。这个过程包含一点自下而上的（第9.2.1节），因为发布模块化JAR文件并不强制用户将它们作为模块使用。除此之外，它的工作方式类似于自顶向下（第9.2.2节），但有一个重要区别：你计划发布你构建的模块化JAR文件。参见[图9.5](part0023.html#filepos1137792)中一个内部-外部模块化示例。
- en: '![](../images/00107.jpeg)'
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00107.jpeg)'
- en: '[Figure 9.5](part0023.html#filepos1137434) If automatic modules are used carefully,
    libraries and frameworks in the middle of the stack can publish modular JARs even
    though their dependencies and their users may still be plain JARs, thus modularizing
    the ecosystem from the inside out.'
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图9.5](part0023.html#filepos1137434) 如果自动模块被谨慎使用，堆栈中间的库和框架可以发布模块化JAR文件，尽管它们的依赖项和用户仍然是普通的JAR文件，从而从内部向外模块化生态系统。'
- en: As I discussed at length in section 8.3.4, you should only ever publish modules
    with dependencies on automatic modules if those plain JARs define the `Automatic-Module-Name`
    entry in their manifest. Otherwise, the risk of causing problems down the road
    when the module name changes is too high.
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如我在第8.3.4节中详细讨论的那样，你应该只发布依赖于自动模块的模块，如果那些普通的JAR文件在它们的清单中定义了`Automatic-Module-Name`条目。否则，当模块名称更改时，造成未来问题的风险太高。
- en: This may mean you can’t yet modularize your project. If you’re in this situation,
    please resist the temptation to do it anyway, or you’re likely to cause users
    difficult problems.
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这可能意味着你目前还不能模块化你的项目。如果你处于这种情况，请抵制住无论如何都要做的诱惑，否则你可能会给用户带来困难的问题。
- en: 'I want to take this one step further: examine your direct and indirect dependencies,
    and make sure none depend on an automatic module whose name is derived from the
    JAR filename. You’re looking for any dependency that isn’t a modular JAR and doesn’t
    define the `Automatic-Module-Name` entry. I wouldn’t publish an artifact with
    a module descriptor that pulls in any such JAR—whether it’s my dependency or somebody
    else’s.'
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我想要更进一步：检查你的直接和间接依赖项，确保没有任何依赖项依赖于由JAR文件名派生的自动模块。你正在寻找任何不是模块化JAR且没有定义`Automatic-Module-Name`条目的依赖项。我不会发布任何包含此类JAR的模块描述符——无论是我的依赖项还是他人的。
- en: There’s also a subtle difference when it comes to platform modules your non-modular
    dependencies need but you don’t. Whereas applications can easily use command-line
    options, libraries or frameworks can’t. They can only document for users that
    they need to be added, but that’s bound to be overlooked by some users. I hence
    advise explicitly requiring all platform modules that non-modular dependencies
    need.
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当涉及到平台模块时，也存在一个微妙的不同之处，这些平台模块是你非模块化依赖项需要的，但你不需要。虽然应用程序可以轻松使用命令行选项，但库或框架却不能。它们只能为用户提供文档说明需要添加，但一些用户可能会忽略这一点。因此，我建议明确要求所有非模块化依赖项需要的平台模块。
- en: 9.2.4 APPLYING THESE STRATEGIES WITHIN A PROJECT
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.2.4 在项目内部应用这些策略
- en: 'Which of the three strategies to use is determined by a project’s place in
    the gigantic, ecosystem-wide dependency graph. But if a project is rather large,
    you may not be able to modularize it all at once and may wonder how to instead
    do that incrementally. Good news: you can apply similar strategies on a smaller
    scale.'
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用哪种策略取决于项目在庞大的、生态系统范围内的依赖图中的位置。但如果项目相当大，你可能无法一次性将其全部模块化，并可能想知道如何分步骤进行。好消息是，你可以在较小范围内应用类似的策略。
- en: It’s often easiest to apply a bottom-up strategy to a project, first modularizing
    subprojects that only depend on code outside your code base. This works particularly
    well if your dependencies are already modularized, but it isn’t limited to that
    scenario. If they aren’t, you need to apply top-down logic to the lowest rung
    of your subprojects, making them use automatic modules to depend on plain JARs,
    and then build up from there.
  id: totrans-971
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将自下而上的策略应用于项目通常更容易，首先模块化只依赖于代码库外代码的子项目。如果依赖项已经模块化，这尤其有效，但并不局限于这种情况。如果没有，你需要将自上而下的逻辑应用于子项目的最低层，使它们使用自动模块来依赖于普通JAR，然后从那里构建起来。
- en: Applied to a single project, the top-down approach works the same as when applied
    to the ecosystem as a whole. Modularize an artifact at the top of the graph, place
    it on the module path, and turn its dependencies into automatic modules. Then
    slowly progress down the dependency tree.
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将自上而下的方法应用于单个项目，与应用于整个生态系统时效果相同。在图的最顶层模块化一个工件，将其放置在模块路径上，并将它的依赖项转换为自动模块。然后逐步向下进行依赖树。
- en: 'You may even do it inside-out. Chapter 10 introduces services: a great way
    to use the module system to decouple dependencies internal to your project but
    also across different projects. They’re a good reason to start modularizing somewhere
    in the middle of a project’s dependency graph and move upward or downward from
    there.'
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你甚至可以反过来操作。第10章介绍了服务：这是一个使用模块系统解耦项目内部以及不同项目之间依赖项的绝佳方式。它们是开始模块化项目依赖图中间某个位置并从那里向上或向下移动的好理由。
- en: ESSENTIAL INFO Note that whatever approach you chose internally, you still mustn’t
    publish explicit modules that depend on automatic modules whose names aren’t defined
    by the JAR filename as opposed to the `Automatic-Module-Name` manifest entry.
  id: totrans-974
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是要注意，无论你内部选择了哪种方法，你仍然不能发布依赖于未由JAR文件名定义而是由`Automatic-Module-Name`清单条目定义的名称的自动模块的显式模块。
- en: 'Although all that’s possible, you shouldn’t needlessly complicate matters.
    Once you’ve settled on an approach, try to quickly and methodically modularize
    your project. Drawing out this process and creating modules here and there means
    you’ll have a hard time understanding the project’s dependency graph—and that’s
    the antithesis of one of the module system’s important goals: reliable configuration.'
  id: totrans-975
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管所有这些都是可能的，但你不应无谓地使事情复杂化。一旦你确定了一种方法，就尝试快速而有条理地将你的项目模块化。将这个过程分解并创建模块意味着你将难以理解项目的依赖图——而这与模块系统的一个重要目标——可靠的配置——是相反的。
- en: 9.3 Making JARs modular
  id: totrans-976
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.3 使JAR模块化
- en: 'All you need to do to turn a plain JAR into a modular JAR is add a module declaration
    to the source. Easy, right? Yes (wait for it), but (there you go!) there’s more
    to say about that step than immediately meets the eye:'
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将一个普通的 JAR 转换为模块化 JAR，你只需要在源代码中添加一个模块声明。简单，对吧？是的（等着听），但是（看这里！）关于这一步还有更多要说，不仅仅是表面上的：
- en: You may want to consider creating open modules (see section 9.3.1 for a quick
    explanation).
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能想要考虑创建开放模块（参见 9.3.1 节以获取快速解释）。
- en: You may be overwhelmed by creating dozens or even hundreds of module declarations
    and wish for a tool that does it for you (section 9.3.2).
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会因为创建数十个甚至数百个模块声明而感到不知所措，并希望有一个工具为你完成这项工作（参见 9.3.2 节）。
- en: You may want to modularize a JAR you didn’t build yourself, or maybe a dependency
    fouled up their module descriptor and you need to fix it (section 9.3.3).
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能想要模块化一个你自己没有构建的 JAR，或者可能是依赖项搞乱了它们的模块描述符，你需要修复它（参见 9.3.3 节）。
- en: You may wonder about module descriptors in JARs built for Java 8 or earlier—is
    that even possible (section 9.3.4)?
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会对为 Java 8 或更早版本构建的 JAR 中的模块描述符感到好奇——这是否可能（参见 9.3.4 节）？
- en: This section tackles these topics to make sure you’re getting the most bang
    for your buck.
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本节将探讨这些主题，以确保你得到物有所值的回报。
- en: 9.3.1 OPEN MODULES AS AN INTERMEDIATE STEP
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.3.1 作为中间步骤的开放模块
- en: 'A concept that can be useful during incremental modularization of an application
    is that of open modules. Section 12.2.4 goes into details, but the gist is that
    an open module opts out of strong encapsulation: all its packages are exported
    and opened to reflection, which means all its public types are accessible during
    compilation and all other types and members are accessible via reflection. It’s
    created by beginning its module declaration with `open module`.'
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在应用程序的增量模块化过程中，一个可能有用的概念是开放模块。第 12.2.4 节将详细介绍，但要点是开放模块放弃了强封装：所有其包都是导出和开放的，以便进行反射，这意味着所有其公共类型在编译期间都是可访问的，所有其他类型和成员都可以通过反射访问。它是通过以
    `open module` 开头开始其模块声明来创建的。
- en: Open modules come in handy when you aren’t happy with a JAR’s package layout.
    Maybe there are lots of packages, or maybe many packages contain public types
    that you’d rather not have accessible—in both cases, a refactoring may take too
    much time in the moment. Or maybe the module is used heavily under reflection,
    and you don’t want to go through determining all the packages you need to open.
  id: totrans-985
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你对 JAR 的包布局不满意时，开放模块会很有用。也许有很多包，或者也许许多包包含你不想公开访问的公共类型——在这两种情况下，重构可能需要太多时间。或者，也许模块在反射中使用得非常频繁，你不想通过确定所有需要打开的包来处理这些问题。
- en: In such cases, opening the entire module is a good way to push those problems
    into the future. Caveats about technical debt apply—these modules opt out of strong
    encapsulation, which denies them the benefits that come with it.
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种情况下，打开整个模块是将这些问题推迟到未来的好方法。关于技术债务的注意事项适用——这些模块选择放弃强封装，这使他们无法获得其带来的好处。
- en: ESSENTIAL INFO Because turning an open module into a regular, encapsulated module
    is an incompatible change, libraries and frameworks should never take the route
    of starting out with an open module with the goal to close it down later. It’s
    hard to come up with any reason why such a project should ever publish an open
    module. Better to only use it for applications.
  id: totrans-987
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息**：因为将开放模块转换为常规的、封装的模块是一个不兼容的更改，库和框架永远不应该选择从开放模块开始，目的是稍后关闭它。很难想出一个理由说明这样的项目为什么应该发布开放模块。最好是只将其用于应用程序。'
- en: 9.3.2 GENERATING MODULE DECLARATIONS WITH JDEPS
  id: totrans-988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.3.2 使用 JDEPS 生成模块声明
- en: 'If you have a big project, you may have to create dozens or even hundreds of
    module declarations, which is a daunting task. Fortunately, you can use JDeps
    for most of it, because large parts of that work are mechanical:'
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你有一个大项目，你可能需要创建数十个甚至数百个模块声明，这是一项艰巨的任务。幸运的是，你可以使用 JDeps 来完成大部分工作，因为这项工作的很大一部分是机械的：
- en: The module name can often be derived from the JAR name.
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名称通常可以从 JAR 名称中推导出来。
- en: A project’s dependencies can be analyzed by scanning bytecode across JAR boundaries.
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个项目的依赖关系可以通过跨 JAR 边界扫描字节码来分析。
- en: Exports are the inverse of that analysis, meaning all packages that other JARs
    depend on that need to be exported.
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出是上述分析的逆过程，意味着所有其他 JAR 依赖的包都需要导出。
- en: Beyond those basic properties, some fine-tuning may be involved to make sure
    all dependencies are recorded and to configure the use of services (see chapter
    10) or more detailed dependencies and APIs (see chapter 11), but everything up
    to that point can be generated by JDeps.
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了这些基本属性之外，可能还需要进行一些微调，以确保记录所有依赖关系，并配置服务（参见第 10 章）或更详细的依赖关系和 API（参见第 11 章），但所有这些都可以由
    JDeps 生成。
- en: 'Launched with `--generate-module-info ${target-dir} ${jar-dir}`, JDeps analyzes
    all JARs in `${jar-dir}` and generates `module-info.java` for each one in `${target-dir}/${module-name}`:'
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `--generate-module-info ${target-dir} ${jar-dir}` 启动，JDeps 分析 `${jar-dir}`
    中的所有 JAR 文件，并在 `${target-dir}/${module-name}` 中为每个 JAR 生成 `module-info.java` 文件：
- en: The module name is derived from the JAR filename as it has been for automatic
    modules (including heeding the `Automatic-Module-Name` header; see section 8.3.1).
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块名称是从 JAR 文件名派生出来的，就像自动模块（包括注意 `Automatic-Module-Name` 标头；参见第 8.3.1 节）一样。
- en: Dependencies are derived based on JDeps’ dependency analysis. Exposed dependencies
    are marked with the `transitive` keyword (see section 11.1).
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖关系基于 JDeps 的依赖关系分析。暴露的依赖关系用 `transitive` 关键字标记（参见第 11.1 节）。
- en: All packages that contain types used by other JARs in the analysis are exported.
  id: totrans-997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有包含在分析中其他 JAR 所用类型的包都被导出。
- en: When JDeps generates the `module-info.java` files, it’s up to you to inspect
    and adapt them and move them into the correct source folders, so your next build
    can compile and package them.
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当 JDeps 生成 `module-info.java` 文件时，你需要检查和调整它们，并将它们移动到正确的源文件夹中，以便你的下一次构建可以编译和打包它们。
- en: Once again assuming ServiceMonitor wasn’t yet modularized, you could use JDeps
    to generate module declarations. To that end, you build ServiceMonitor and place
    its JARs together with its dependencies in a directory `jars`. Then you call `jdeps
    --generate-module-info declarations jars`, and JDeps generates module declarations,
    which it writes into the directory structure shown in [figure 9.6](part0023.html#filepos1151794).
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次假设 ServiceMonitor 尚未模块化，你可以使用 JDeps 生成模块声明。为此，你构建 ServiceMonitor，并将它的 JAR
    文件及其依赖项一起放在一个名为 `jars` 的目录中。然后你调用 `jdeps --generate-module-info declarations jars`，JDeps
    生成模块声明，并将其写入如图 9.6 所示的目录结构中。
- en: '![](../images/00067.jpeg)'
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00067.jpeg)'
- en: '[Figure 9.6](part0023.html#filepos1151483) After you call `jdeps --generate-module-info
    declarations jars`, JDeps analyzes the dependencies among all JARs in the `jars`
    directory (not shown) and creates module declarations for them in the `declarations`
    directory (non-ServiceMonitor projects aren’t shown).'
  id: totrans-1001
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 9.6](part0023.html#filepos1151483) 在你调用 `jdeps --generate-module-info declarations
    jars` 之后，JDeps 分析 `jars` 目录中所有 JAR 之间的依赖关系（未显示），并在 `declarations` 目录中为它们创建模块声明（非
    ServiceMonitor 项目未显示）。'
- en: JDeps creates a folder for each module and places in them module declarations
    that look similar to the ones you wrote by hand earlier. (To jog your memory,
    you can find them in [listing 2.2](part0015.html#filepos266357), but the details
    aren’t important here.)
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDeps 为每个模块创建一个文件夹，并将类似你之前手动编写的模块声明放入其中。（为了唤起你的记忆，你可以在 [列表 2.2](part0015.html#filepos266357)
    中找到它们，但细节在这里并不重要。）
- en: JDeps can also generate module declarations for open modules (see section 12.2.4)
    with `--generate-open-module`. Module names and `requires` directives are determined
    as before; but because open modules can’t encapsulate anything, no exports are
    required, and hence none are generated.
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDeps 还可以使用 `--generate-open-module` 为开放模块生成模块声明（参见第 12.2.4 节）。模块名称和 `requires`
    指令与之前一样确定；但由于开放模块不能封装任何内容，不需要导出，因此没有生成。
- en: INSPECTING GENERATED DECLARATIONS
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查生成的声明
- en: JDeps does a good job of generating module declarations, but you should still
    manually check them. Are the module names to your liking? (Probably not, because
    JAR names rarely follow the inverse-domain naming scheme; see section 3.1.3.)
    Are dependencies properly modeled? (See sections 11.1 and 11.2 for more options.)
    Are those the packages you want your public API to consist of? Maybe you need
    to add some services. (See chapter 10.)
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDeps 在生成模块声明方面做得很好，但你仍然需要手动检查它们。模块名称是否符合你的喜好？（可能不是，因为 JAR 名称很少遵循反向域名命名方案；参见第
    3.1.3 节。）依赖关系是否被正确建模？（有关更多选项，请参阅第 11.1 和 11.2 节。）这些是否是你希望你的公共 API 包含的包？你可能需要添加一些服务。（参见第
    10 章。）
- en: 'If you develop an application that has too many JARs to manually inspect all
    declarations, and you’re fine with some hiccups, there’s a more lenient option:
    you may get away with trusting your tests, your CI pipeline, and your fellow developers
    and testers with finding the little problems. In that case, make sure you have
    some time before the next release, so you can be confident you’ve fixed everything.'
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你开发的应用程序有太多的 JAR 需要手动检查所有声明，并且你能够容忍一些小问题，那么有一个更宽容的选项：你可以信任你的测试、CI 管道以及你的同事和测试人员来发现这些小问题。在这种情况下，确保在下一个版本发布之前留出一些时间，这样你可以确信你已经修复了一切。
- en: If you’re publishing artifacts, though, you absolutely have to check declarations
    with great care! These are the most public parts of your API, and changing them
    is often incompatible—work hard to prevent that from happening without good reason.
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在发布工件，那么你必须非常仔细地检查声明！这些是你 API 最公开的部分，更改它们通常是不兼容的——努力防止在没有充分理由的情况下发生这种情况。
- en: BEWARE OF MISSING DEPENDENCIES
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小心缺少的依赖项
- en: 'For JDeps to properly generate `requires` directives for a set of JARs, all
    of these JARs as well as all their direct dependencies must be present in the
    scanned directory. If dependencies are missing, JDeps will report them as follows:'
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了 JDeps 能够为一系列 JAR 生成正确的 `requires` 指令，所有这些 JAR 以及它们的所有直接依赖都必须存在于扫描的目录中。如果依赖项缺失，JDeps
    将会如下报告：
- en: '`> Missing dependence: .../module-info.java not generated > Error: missing
    dependencies > depending.type -> missing.type not found > ...`'
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 缺少依赖：> .../module-info.java 未生成 > 错误：缺少依赖 > depending.type -> missing.type
    未找到 > ...`'
- en: To avoid erroneous module declarations, none are generated for modules where
    not all dependencies are present.
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了避免错误的模块声明，如果模块中不是所有依赖项都存在，则不会为这些模块生成任何声明。
- en: 'When generating module declarations for ServiceMonitor, I glossed over these
    messages. Some indirect dependencies were missing, presumably because Maven regarded
    them as optional, but that didn’t hinder the correct creation of ServiceMonitor’s
    declarations:'
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在为 ServiceMonitor 生成模块声明时，我忽略了这些信息。一些间接依赖项缺失，可能是由于 Maven 将它们视为可选的，但这并没有阻碍 ServiceMonitor
    声明的正确创建：
- en: '`> Missing dependence: > declarations/jetty.servlet/module-info.java not generated
    # truncated further log messages > Missing dependence: > declarations/utils/module-info.java
    not generated # truncated further log messages > Missing dependence: > declarations/jetty.server/module-info.java
    not generated # truncated further log messages > Missing dependence: > declarations/slf4j.api/module-info.java
    not generated # truncated further log messages > Error: missing dependencies >
    org.eclipse.jetty.servlet.jmx.FilterMappingMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    not found > org.eclipse.jetty.servlet.jmx.HolderMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    not found > org.eclipse.jetty.servlet.jmx.ServletMappingMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    not found > org.eclipse.jetty.server.handler.jmx.AbstractHandlerMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    not found > org.eclipse.jetty.server.jmx.AbstractConnectorMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    not found > org.eclipse.jetty.server.jmx.ServerMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    not found > org.slf4j.LoggerFactory > -> org.slf4j.impl.StaticLoggerBinder not
    found > org.slf4j.MDC > -> org.slf4j.impl.StaticMDCBinder not found > org.slf4j.MarkerFactory
    > -> org.slf4j.impl.StaticMarkerBinder not found`'
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 缺少依赖：> declarations/jetty.servlet/module-info.java 未生成 # 省略更多日志信息 > 缺少依赖：>
    declarations/utils/module-info.java 未生成 # 省略更多日志信息 > 缺少依赖：> declarations/jetty.server/module-info.java
    未生成 # 省略更多日志信息 > 缺少依赖：> declarations/slf4j.api/module-info.java 未生成 # 省略更多日志信息
    > 错误：缺少依赖 > org.eclipse.jetty.servlet.jmx.FilterMappingMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    未找到 > org.eclipse.jetty.servlet.jmx.HolderMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    未找到 > org.eclipse.jetty.servlet.jmx.ServletMappingMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    未找到 > org.eclipse.jetty.server.handler.jmx.AbstractHandlerMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    未找到 > org.eclipse.jetty.server.jmx.AbstractConnectorMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    未找到 > org.eclipse.jetty.server.jmx.ServerMBean > -> org.eclipse.jetty.jmx.ObjectMBean
    未找到 > org.slf4j.LoggerFactory > -> org.slf4j.impl.StaticLoggerBinder 未找到 > org.slf4j.MDC
    > -> org.slf4j.impl.StaticMDCBinder 未找到 > org.slf4j.MarkerFactory > -> org.slf4j.impl.StaticMarkerBinder
    未找到`'
- en: CAREFULLY ANALYZE EXPORTS
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仔细分析导出项
- en: Export directives are solely based on the analysis of which types are needed
    by other JARs. This almost guarantees that library JARs will see way too few exports.
    Keep this in mind when checking JDeps’ output.
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 导出指令仅基于分析其他 JAR 需要哪些类型的依赖。这几乎保证了库 JAR 将看到非常少的导出项。在检查 JDeps 输出时请记住这一点。
- en: As a library or framework developer, you may not feel comfortable publishing
    artifacts that export packages you consider internal to a project just because
    several of your modules need them. Have a look at qualified exports in section11.3
    to address that problem.
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为库或框架开发者，你可能不希望发布导出你认为是项目内部包的工件，仅仅因为你的几个模块需要它们。请查看第11.3节中的合格导出，以解决这个问题。
- en: 9.3.3 HACKING THIRD-PARTY JARS
  id: totrans-1017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.3.3 破解第三方JAR
- en: It can sometimes be necessary to update third-party JARs. Maybe you need ones
    to be an explicit module or at least an automatic module with a specific name.
    Maybe it’s already a module, but the module descriptor is faulty or causes problems
    with dependencies you’d prefer not to draw in. In such cases, the time has come
    to pull out the sharp tools and get to work. (Be careful not to cut yourself.)
  id: totrans-1018
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时可能需要更新第三方JAR。可能你需要的是显式模块或至少是具有特定名称的自动模块。也许它已经是一个模块，但模块描述符有误或与你不希望引入的依赖项造成问题。在这种情况下，是时候拿出锋利的工具开始工作了。（小心不要割伤自己。）
- en: 'A good example for the weird edge cases that are bound to exist in an ecosystem
    as large as Java’s is the bytecode-manipulation tool Byte Buddy. It’s published
    in Maven Central as `bytebuddy-${version}.jar`, and when you try to use it as
    an automatic module, you get this reply from the module system:'
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个很好的例子是，在像Java这样庞大的生态系统中，必然存在的奇怪边缘情况之一是字节码操作工具Byte Buddy。它以`bytebuddy-${version}.jar`的形式发布在Maven
    Central上，当你尝试将其用作自动模块时，模块系统会给出以下回复：
- en: '`> byte.buddy: Invalid module name: ''byte'' is not a Java identifier`'
  id: totrans-1020
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> byte.buddy: 无效的模块名称：''byte'' 不是一个Java标识符`'
- en: 'Oops: `byte` isn’t a valid Java identifier because it clashes with the primitive
    type of the same name. This particular case is solved in Byte Buddy version 1.7.3
    and later (with the `Automatic-Module-Name` entry), but you may run into similar
    edge cases and need to be prepared.'
  id: totrans-1021
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哎呀：`byte`不是一个有效的Java标识符，因为它与同名的原始类型冲突。这个特定的情况在Byte Buddy 1.7.3及以后的版本中得到了解决（通过`Automatic-Module-Name`条目），但你可能会遇到类似的边缘情况，需要做好准备。
- en: In general, it’s not advisable to locally modify published JARs, because it’s
    hard to do that reliably and in a self-documenting fashion. It gets a little easier
    if your development process includes a local artifact repository like Sonatype’s
    Nexus that all developers connect to. In that case, somebody can create a modified
    variant, change the version to make the modification obvious (for example, by
    adding `-patched`), and then upload it to the internal repository.
  id: totrans-1022
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，不建议本地修改已发布的JAR，因为这很难可靠且以自文档化的方式进行。如果你的开发流程包括一个所有开发者都连接到的本地工件存储库，如Sonatype的Nexus，那么这会变得容易一些。在这种情况下，某人可以创建一个修改过的变体，将版本更改为使修改明显（例如，通过添加`-patched`），然后将其上传到内部存储库。
- en: It may also be possible to execute the modification during the build, in which
    case standard JARs can be used and edited on the fly as needed. The modification
    then becomes part of the build script.
  id: totrans-1023
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在构建过程中执行修改也可能是有可能的，在这种情况下，可以即时使用和编辑标准JAR，根据需要。修改后将成为构建脚本的一部分。
- en: Note that you should never publish artifacts that depend on modified JARs! Users
    won’t be able to easily reproduce the modifications and will be left with a broken
    dependency. This largely limits the following advice to applications.
  id: totrans-1024
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，你永远不应该发布依赖于修改过的JAR的工件！用户将无法轻松地重现这些修改，并且会留下一个损坏的依赖项。这很大程度上限制了以下建议仅适用于应用程序。
- en: With the caveats out of the way, let’s see how to manipulate third-party JARs
    if they don’t work well with your project. I show you how to add or edit an automatic
    module name, add or edit a module descriptor, and add classes to modules.
  id: totrans-1025
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在排除这些注意事项之后，让我们看看如果第三方JAR与你的项目不兼容时，如何操作第三方JAR。我会展示如何添加或编辑自动模块名称，添加或编辑模块描述符，以及将类添加到模块中。
- en: ADDING AND EDITING AN AUTOMATIC MODULE NAME
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加和编辑自动模块名称
- en: A good reason to add an automatic module name to a JAR, other than the scenario
    where the JPMS otherwise can’t derive a name, is if the project already defined
    one in newer versions but you can’t yet update to it for whatever reason. In that
    case, editing the JAR allows you to use a future-proof name in your module declarations.
  id: totrans-1027
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了JPMS无法从中推导出名称的场景之外，将自动模块名称添加到JAR中的另一个很好的理由是，如果项目在较新版本中已经定义了一个名称，但你由于某种原因还不能更新到它。在这种情况下，编辑JAR允许你在模块声明中使用一个未来兼容的名称。
- en: The `jar` tool has an option `--update` (alternative is `-u`) that allows modification
    of an existing Java archive. Together with the `--manifest=${manifest-file}` option,
    you can append anything to the existing manifest—the `Automatic-Module-Name` entry,
    for example.
  id: totrans-1028
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`jar` 工具有一个选项 `--update`（备选是 `-u`），允许修改现有的 Java 归档。结合 `--manifest=${manifest-file}`
    选项，你可以将任何内容添加到现有的清单中——例如，`Automatic-Module-Name` 条目。'
- en: 'Let’s take an older version of Byte Buddy, version 1.6.5, and make sure it
    works fine as an automatic module. First create a plain text file, say `manifest.txt`
    (you can choose any name you want), that contains a single line:'
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们以一个较旧的 Byte Buddy 版本，版本 1.6.5，为例，确保它作为一个自动模块正常工作。首先创建一个纯文本文件，比如 `manifest.txt`（你可以选择任何你想要的名称），其中包含一行：
- en: '`Automatic-Module-Name: net.bytebuddy`'
  id: totrans-1030
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Automatic-Module-Name: net.bytebuddy`'
- en: 'Then use `jar` to append that line to the existing manifest:'
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后使用 `jar` 将该行添加到现有的清单中：
- en: '`$ jar --update --file bytebuddy-1.6.5.jar --manifest=manifest.txt`'
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --update --file bytebuddy-1.6.5.jar --manifest=manifest.txt`'
- en: 'Now let’s check whether it worked:'
  id: totrans-1033
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，让我们检查它是否工作：
- en: '`$ jar --describe-module --file bytebuddy-1.6.5.jar  > No module descriptor
    found. Derived automatic module. > > net.bytebuddy@1.6.5 automatic > requires
    java.base mandated`'
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --describe-module --file bytebuddy-1.6.5.jar  > 未找到模块描述符。派生自动模块。 > >
    net.bytebuddy@1.6.5 自动 > 需要 java.base 强制指定`'
- en: 'Neat: no error, and the module name is as desired.'
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很好：没有错误，模块名称符合预期。
- en: The same approach can be used to edit an existing automatic module name. The
    `jar` tool will complain about `Duplicate name in Manifest`, but the new value
    nevertheless replaces the old one.
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同样的方法可以用来编辑现有的自动模块名称。`jar` 工具会抱怨 `Manifest 中的重复名称`，但新值仍然会替换旧值。
- en: ADDING AND EDITING MODULE DESCRIPTORS
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加和编辑模块描述符
- en: 'If turning a third-party JAR into a properly named automatic module isn’t enough,
    or you have trouble with an explicit module, you can use `jar --update` to add
    or override a module descriptor. An important use case for the latter is to resolve
    the modular diamond of death described in section 8.3.4:'
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果将第三方 JAR 转换为正确命名的自动模块还不够，或者你在显式模块上遇到麻烦，可以使用 `jar --update` 来添加或覆盖模块描述符。后者的重要用例是解决第
    8.3.4 节中描述的模块死亡菱形问题：
- en: '`$ jar --update --file ${jar} module-info.class`'
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --update --file ${jar} module-info.class`'
- en: This adds the file `module-info.class` to `${jar}`. Note that `--update` doesn’t
    perform any checks. This makes it easy to, accidentally or on purpose, create
    JARs whose module descriptor and class files don’t agree, for example on required
    dependencies. Use with care!
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这会将文件 `module-info.class` 添加到 `${jar}`。请注意，`--update` 不会执行任何检查。这使得意外或故意创建模块描述符和类文件不一致的
    JAR 文件变得容易，例如在必需的依赖关系上。请谨慎使用！
- en: The more complicated task is to come up with a module descriptor. For the compiler
    to create one, you need not only a module declaration, but also all dependencies
    (their presence is checked as part of reliable configuration) and some representation
    of the JAR’s code (as sources or bytecode; otherwise the compiler complains of
    nonexistent packages).
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更复杂的任务是创建模块描述符。为了编译器创建一个，你需要的不只是模块声明，还有所有依赖（它们的存放在可靠配置的一部分中进行检查）以及 JAR 代码的一些表示（作为源代码或字节码；否则编译器会抱怨不存在包）。
- en: 'Your build tool should be able to help you with the dependencies (Maven: copy-dependencies).
    For the code, it’s important that the compiler sees the entire module, not just
    the declaration. This can best be achieved by compiling the declaration while
    the module’s bytecode is added from its JAR with `--patch-module`. Section 7.2.4
    introduces that option, and the following example shows how to use it:'
  id: totrans-1042
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你的构建工具应该能够帮助你处理依赖关系（Maven：copy-dependencies）。对于代码来说，编译器看到整个模块，而不仅仅是声明，这一点非常重要。这最好通过在模块的字节码通过
    `--patch-module` 添加时编译声明来实现。第 7.2.4 节介绍了该选项，以下示例展示了如何使用它：
- en: '`$ jdeps --generate-module-info . jars` [`①`](part0023.html#filepos1171905)`#
    edit ${module-name}/module-info.java` [`②`](part0023.html#filepos1172305)`$ javac`
    [`③`](part0023.html#filepos1172649) `--module-path jars --patch-module ${module-name}=jars/${jar}
    ${module-name}/module-info.java` `$ mv ${module-name}/module-info.java .` [`④`](part0023.html#filepos1173083)`$
    jar --update --file jars/${jar} module-info.class` [`⑤`](part0023.html#filepos1173500)`$
    jar --describe-module --file jars/${jar}` [`⑥`](part0023.html#filepos1173844)'
  id: totrans-1043
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jdeps --generate-module-info . jars` [`①`](part0023.html#filepos1171905)`#
    编辑 ${module-name}/module-info.java` [`②`](part0023.html#filepos1172305)`$ javac`
    [`③`](part0023.html#filepos1172649) `--module-path jars --patch-module ${module-name}=jars/${jar}
    ${module-name}/module-info.java` `$ mv ${module-name}/module-info.java .` [`④`](part0023.html#filepos1173083)`$
    jar --update --file jars/${jar} module-info.class` [`⑤`](part0023.html#filepos1173500)`$
    jar --describe-module --file jars/${jar}` [`⑥`](part0023.html#filepos1173844)'
- en: ①
  id: totrans-1044
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Generates module declarations for all JARs (although only the one for ${jar}
    is of interest)
  id: totrans-1045
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为所有 JAR 文件生成模块声明（尽管只有 ${jar} 的那个对我们感兴趣）
- en: ②
  id: totrans-1046
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Edit the declaration as you see fit.
  id: totrans-1047
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 按照你的需求编辑声明。
- en: ③
  id: totrans-1048
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Compiles the declaration by using jars as module path and patching the module’s
    bytecode into the module with --patch-module
  id: totrans-1049
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 jars 作为模块路径编译声明，并通过 --patch-module 选项将模块的字节码修补到模块中
- en: ④
  id: totrans-1050
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Moves the module descriptor for ${jar} to the root folder (otherwise, updating
    the JAR won’t work properly)
  id: totrans-1051
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 ${jar} 的模块描述符移动到根目录（否则更新 JAR 文件将无法正常工作）
- en: ⑤
  id: totrans-1052
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: Adds the module descriptor to ${jar}
  id: totrans-1053
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将模块描述符添加到 ${jar}
- en: ⑥
  id: totrans-1054
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑥
- en: Verifies that everything worked—the module should now have the desired properties
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 验证一切是否正常——模块现在应该具有所需的属性
- en: ADDING CLASSES TO MODULES
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 向模块中添加类
- en: If you already need to add some classes to a dependency’s packages, you may
    have placed them on the class path. Once that dependency moves to the module path,
    the rule against split packages forbids that approach, though. Section 7.2.4 shows
    how to handle that situation on the fly with the `--patch-module` option. If you’re
    looking for a more lasting solution to your problem, you can once again use `jar
    --update`, in this case to add class files.
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你已经需要向依赖项的包中添加一些类，你可能已经将它们放在了类路径上。一旦那个依赖项移动到模块路径，反对拆分包的规则就禁止了那种方法。第 7.2.4
    节展示了如何使用 `--patch-module` 选项动态处理这种情况。如果你在寻找一个更持久的解决方案，你还可以再次使用 `jar --update`，在这种情况下是为了添加类文件。
- en: 9.3.4 PUBLISHING MODULAR JARS FOR JAVA 8 AND OLDER
  id: totrans-1058
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9.3.4 为 JAVA 8 及更早版本发布模块化 JAR
- en: Whether you maintain an application, a library, or a framework, it’s possible
    you target more than one Java version. Does that mean you have to skip the module
    system? Fortunately, no! There are two ways to deliver modular artifacts that
    work fine on Java versions older than 9.
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论你是维护一个应用程序、库还是框架，你可能需要针对多个 Java 版本。这意味着你必须跳过模块系统吗？幸运的是，不是！有两种方法可以提供在 Java
    9 版本之前的版本上运行良好的模块化工件。
- en: Whichever you chose, you first need to build your project for the target version.
    You can use either the compiler from the corresponding JDK or a newer one by setting
    `-source` and `-target`. If you pick the Java 9+ compiler, check out the new flag
    `--release` in section 4.4\. Finish this step by creating a JAR as you normally
    would. Note that this JAR runs perfectly on your desired Java release but doesn’t
    yet contain a module descriptor.
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论你选择哪种方式，首先你需要为目标版本构建你的项目。你可以使用对应 JDK 的编译器，或者通过设置 `-source` 和 `-target` 使用一个更新的版本。如果你选择了
    Java 9+ 编译器，请查看第 4.4 节中的新标志 `--release`。完成这一步后，就像平常一样创建一个 JAR 文件。请注意，这个 JAR 文件在你的期望的
    Java 版本上运行得非常好，但还没有包含模块描述符。
- en: The next step is to compile the module declarations with Java 9+. The best and
    most reliable way is to build the entire project with the Java 9+ compiler. Now
    you have two options for how to get the module descriptor into your JAR, described
    next.
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下一步是使用 Java 9+ 编译模块声明。最好的和最可靠的方法是使用 Java 9+ 编译器构建整个项目。现在你有两种方法可以将模块描述符放入你的 JAR
    文件中，下面将进行描述。
- en: USING JAR --UPDATE
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 JAR --UPDATE
- en: You can use `jar --update` as described in section 9.3.3 to add the module descriptor
    to the JAR. That works because JVMs before version 9 ignore the module descriptor.
    They only see other class files; and because you build them for the correct version,
    everything just works.
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以使用第 9.3.3 节中描述的 `jar --update` 命令将模块描述符添加到 JAR 文件中。这是因为版本 9 之前的 JVM 忽略模块描述符。它们只看到其他类文件；而且因为你为正确的版本构建它们，所以一切正常。
- en: Although that’s true for the JVM, it can’t necessarily be said for all tools
    that process bytecode. Some trip over `module-info.class` and thus become useless
    for modular JARs. If you want to prevent that, you have to create a multi-release
    JAR.
  id: totrans-1064
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这在JVM中是正确的，但对于处理字节码的所有工具来说并不一定如此。有些工具会遇到`module-info.class`并因此对模块JAR变得无用。如果你想防止这种情况，你必须创建一个多版本JAR。
- en: CREATING A MULTI-RELEASE JAR
  id: totrans-1065
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建多版本JAR
- en: From Java 9 on, `jar` allows the creation of multi-release JARs (MR-JARs), which
    contain bytecode for different Java versions. Appendix E gives a thorough introduction
    to this new feature; to make the most out of this section, you should give it
    a read. Here, I’m focusing on how to use MR-JARs so the module descriptor doesn’t
    end up in the JAR’s root.
  id: totrans-1066
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从Java 9开始，`jar`允许创建多版本JAR（MR-JAR），其中包含不同Java版本的字节码。附录E对这个新特性进行了详细介绍；为了充分利用这一部分，你应该阅读它。在这里，我专注于如何使用MR-JAR，以确保模块描述符不会出现在JAR的根目录中。
- en: 'Let’s say you have a regular JAR and want to turn it into a multi-release JAR,
    where a module descriptor is loaded on Java 9 (and later). Here’s how to do that
    with `--update` and `--release`:'
  id: totrans-1067
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你有一个常规JAR，并想将其转换为多版本JAR，其中模块描述符在Java 9（及以后版本）上加载。以下是使用`--update`和`--release`进行转换的方法：
- en: '`$ jar --update --file ${jar} --release 9 module-info.class`'
  id: totrans-1068
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --update --file ${jar} --release 9 module-info.class`'
- en: 'You can also create a multi-release JAR in one go:'
  id: totrans-1069
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你也可以一次创建一个多版本JAR：
- en: '`$ jar --create --file mr.jar -C classes . --release 9 classes-9/module-info.class`'
  id: totrans-1070
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --create --file mr.jar -C classes . --release 9 classes-9/module-info.class`'
- en: The first three lines are the regular way to create a JAR from class files in
    `classes`. Then comes `--release 9`, followed by the additional sources to be
    loaded by JVMs version 9 and higher. [Figure 9.7](part0023.html#filepos1180964)
    show the resulting JAR—as you can see, the root directory doesn’t contain `module-info.class`.
  id: totrans-1071
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 前三行是从`classes`中的类文件创建JAR的常规方式。然后是`--release 9`，后面跟着JVM版本9及以上需要加载的额外源。![图9.7](part0023.html#filepos1180964)显示了生成的JAR——正如你所见，根目录不包含`module-info.class`。
- en: '![](../images/00102.jpeg)'
  id: totrans-1072
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00102.jpeg)'
- en: '[Figure 9.7](part0023.html#filepos1180452) By creating a multi-release JAR,
    you can place the module descriptor in `META-INF/versions/9` instead of the artifact’s
    root.'
  id: totrans-1073
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图9.7](part0023.html#filepos1180452) 通过创建多版本JAR，你可以将模块描述符放在`META-INF/versions/9`而不是工件根目录下。'
- en: This feature goes far beyond adding module descriptors. So, if you haven’t already,
    I recommend reading appendix E.
  id: totrans-1074
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个功能远不止添加模块描述符。所以，如果你还没有的话，我建议阅读附录E。
- en: Now that we’ve covered the basics for green-field projects as well for existing
    code bases, read on to learn about the module system’s advanced features in part
    3.
  id: totrans-1075
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了绿色字段项目和现有代码库的基本知识，继续阅读以了解模块系统的高级功能在第3部分。
- en: Summary
  id: totrans-1076
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: If you’re not yet on Java 8, make that update first. If a preliminary analysis
    shows that some of your dependencies cause problems on Java 9+, update them next.
    This ensures that you take one step at a time, thus keeping complexity to a minimum.
  id: totrans-1077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你还没有使用Java 8，首先进行这个更新。如果初步分析显示你的某些依赖项在Java 9+上存在问题，接下来更新它们。这确保了你一次只迈出一小步，从而将复杂性保持在最低。
- en: 'You can do several things to analyze migration problems:'
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以采取一些措施来分析迁移问题：
- en: Build on Java 9+, and apply quick fixes (`--add-modules`, `--add-exports`, `--add-opens`,
    `--patch-module`, and others) to get more information.
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 9+上构建，并应用快速修复（`--add-modules`、`--add-exports`、`--add-opens`、`--patch-module`等）以获取更多信息。
- en: Use JDeps to find split packages and dependencies on internal APIs.
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JDeps来查找分割包和内部API的依赖关系。
- en: Search for specific patterns that cause problems, like casts to `URLClassLoader`
    and the use of removed JVM mechanisms.
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索导致问题的特定模式，如对`URLClassLoader`的转换和使用已删除的JVM机制。
- en: After gathering this information, it’s important to properly evaluate it. What
    are the risks of the quick fixes? How hard is it to solve them properly? How important
    is the affected code for your project?
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集这些信息后，正确评估它们非常重要。快速修复的风险是什么？正确解决它们有多难？受影响的代码对你的项目有多重要？
- en: When you start your migration, make an effort to continuously build your changes,
    ideally from the same branch the rest of the team uses. This makes sure the Java
    9+ efforts and regular development are well integrated.
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你开始迁移时，努力持续构建你的更改，理想情况下是从团队其他成员使用的同一分支开始。这确保了Java 9+的努力和常规开发得到了很好的整合。
- en: Command-line options give you the ability to quickly fix the challenges you
    face when getting a build to work on Java 9+, but be wary of keeping them around
    too long. They make it easy to ignore problems until future Java releases exacerbate
    them. Instead, work toward a long-term solution.
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行选项使你能够快速解决在Java 9+上使构建工作时的挑战，但要注意不要长时间保留它们。它们使得忽略问题变得容易，直到未来的Java版本加剧这些问题。相反，应致力于长期解决方案。
- en: 'Three modularization strategies exist. Which one applies to a project as a
    whole depends on its type and dependencies:'
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在三种模块化策略。适用于整个项目的策略取决于其类型和依赖关系：
- en: Bottom-up is for projects that only depend on modules. Create module declarations,
    and place all dependencies on the module path.
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自下而上的方法适用于仅依赖于模块的项目。创建模块声明，并将所有依赖项放置在模块路径上。
- en: Top-down is for applications whose dependencies aren’t yet all modularized.
    They can create module declarations and place all direct dependencies on the module
    path—plain JARs are turned into automatic modules that can be depended on.
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自上而下的方法适用于尚未完全模块化的应用程序。它们可以创建模块声明，并将所有直接依赖项放置在模块路径上——普通JAR文件被转换为可以依赖的自动模块。
- en: Inside-out is for libraries and frameworks whose dependencies aren’t yet all
    modularized. It works like top-down but has the limitation that only automatic
    modules that define an `Automatic-Module-Name` manifest entry can be used. Otherwise,
    the automatic module name is unstable across build setups and over time, which
    can lead to significant problems for users.
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自内而外适用于尚未完全模块化的库和框架。它的工作方式类似于自上而下，但有一个限制，即只能使用定义了`Automatic-Module-Name`清单条目的自动模块。否则，自动模块名称在构建设置和时间上可能不稳定，这可能导致用户遇到重大问题。
- en: Within a project, you can choose any strategy that fits its specific structure.
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目内部，你可以选择适合其特定结构的任何策略。
- en: JDeps allows the automatic generation of module declarations with `jdeps --generate-module-info`.
    This is particularly relevant to large projects, where hand-writing module declarations
    would take a lot of time.
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDeps允许使用`jdeps --generate-module-info`自动生成模块声明。这对于大型项目尤其相关，手动编写模块声明会花费大量时间。
- en: 'With the `jar` tool’s `--update` option, you can modify existing JARs: for
    example, to set `Automatic-Module-Name` or to add or overwrite a module descriptor.
    If a dependency’s JAR makes problems that aren’t otherwise fixable, this is the
    sharpest tool to resolve them.'
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`jar`工具的`--update`选项，你可以修改现有的JAR文件：例如，设置`Automatic-Module-Name`或添加或覆盖模块描述符。如果依赖项的JAR文件存在无法解决的错误，这是解决这些问题的最有效工具。
- en: By compiling and packaging source code for an older Java version and then adding
    the module descriptor (either in the JARs root directory or with `jar --version`
    to a Java 9+ specific subdirectory), you can create modular JARs that work on
    various Java versions and as a module if placed on a Java 9 module path.
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为较旧的Java版本编译和打包源代码，然后添加模块描述符（可以在JARs根目录中，或者使用`jar --version`命令添加到Java 9+特定的子目录中），你可以创建在多种Java版本上运行的模块化JAR文件，如果放置在Java
    9模块路径上，还可以作为一个模块使用。
