- en: 6 Managing application state
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 管理应用程序状态
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Passing shared state to those components that need it
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将共享状态传递给需要它的组件
- en: Coping when state isn’t passed down—the props are missing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当状态未向下传递时的应对策略——缺少属性
- en: Lifting state up the component tree to make it more widely available
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态提升到组件树中以提高其可用性
- en: Passing dispatch and updater functions to child components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分派和更新函数传递给子组件
- en: Maintaining function identity with the `useCallback` hook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useCallback` 钩子保持函数身份
- en: Up to this point, we’ve seen how components can manage their own state with
    the `useState`, `useReducer`, and `useRef` hooks and load state data with the
    `useEffect` hook. It’s common, however, for components to work together, using
    shared state values to generate their UI. Each component may have a whole hierarchy
    of descendant components nested within it, chirping and chirruping to be fed data,
    so state values may need to reach deep down into the descendant depths.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了组件如何使用 `useState`、`useReducer` 和 `useRef` 钩子来管理自己的状态，以及如何使用 `useEffect`
    钩子加载数据状态。然而，组件通常需要协同工作，使用共享状态值来生成它们的 UI。每个组件可能都有一个嵌套在其内部的整个子组件层级，它们在等待数据时发出声音，因此状态值可能需要深入到子组件的深处。
- en: In this chapter, we investigate concepts and methods for deciding how to manage
    the availability of state values for child components that need to consume them,
    by lifting state to common parents. In chapter 8, we’ll see how and when React’s
    Context API can be used to make values available directly to components that need
    them. Here, we stick to using props to pass state down to children.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究如何通过将状态提升到公共父组件来决定如何管理需要消费状态值的子组件的状态值可用性。在第 8 章中，我们将看到 React 的 Context
    API 如何被用来直接将值提供给需要它们的组件。在这里，我们坚持使用属性将状态向下传递给子组件。
- en: 'We start, in section 6.1, with a new `Colors` component that shares a selected
    color with three child components. We see how to update the shared state, managed
    by the parent, from a child. The rest of the chapter uses the bookings app example
    to explore two approaches to sharing state: passing a state object and a dispatch
    function for a reducer to the children and passing a single state value and its
    updater function to the children. Both approaches are common patterns and help
    to highlight some common questions regarding state, props, effects, and dependencies.
    We finish with a look at `useCallback`, a hook that lets us enlist React’s help
    to maintain the identity of functions we pass as props, particularly when child
    components treat those functions as dependencies.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第 6.1 节开始，介绍一个新的 `Colors` 组件，该组件与三个子组件共享一个选中的颜色。我们看到如何从子组件更新由父组件管理的共享状态。本章的其余部分使用预订应用程序示例来探讨两种共享状态的方法：将状态对象和分派函数传递给子组件，以及将单个状态值及其更新函数传递给子组件。这两种方法都是常见的模式，有助于突出一些关于状态、属性、效果和依赖关系的常见问题。我们最后将查看
    `useCallback` 钩子，这个钩子允许我们请求 React 的帮助来保持我们作为属性传递的函数的身份，尤其是在子组件将这些函数视为依赖项时。
- en: 'For our first trick, let’s refresh our knowledge of props: pick a color, any
    color. . . .'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个技巧，让我们先复习一下属性的知识：选择一种颜色，任何颜色……
- en: 6.1 Passing shared state to child components
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 将共享状态传递给子组件
- en: 'When different components use the same data to build their UI, the most explicit
    way to share that data is to pass it as a prop from parent to children. This section
    introduces passing props (in particular, passing the state value and updater function
    returned by `useState`) by looking at a new example, a `Colors` component, shown
    in figure 6.1\. The component includes three UI sections:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同的组件使用相同的数据来构建它们的 UI 时，最明确地共享该数据的方式是将它作为从父组件到子组件的属性传递。本节通过查看一个新示例，即图 6.1 所示的
    `Colors` 组件，介绍了传递属性（特别是传递由 `useState` 返回的状态值和更新函数）的方法。该组件包括三个 UI 部分：
- en: A list of colors with the selected color highlighted
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有选中颜色高亮的颜色列表
- en: Text showing the selected color
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所选颜色的文本
- en: A bar with a background set to the selected color
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个背景设置为所选颜色的条
- en: '![](../Images/6-1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片 6-1](../Images/6-1.png)'
- en: Figure 6.1 The `Colors` component. When a user selects a color, the menu, text,
    and color bar all update. When goldenrod is selected, its menu circle is larger,
    the text says “. . . goldenrod!” and the bar’s color is goldenrod.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 `Colors` 组件。当用户选择一种颜色时，菜单、文本和颜色条都会更新。当选择金盏花时，其菜单圆圈更大，文本显示“……金盏花！”并且条的颜色是金盏花。
- en: Clicking a color in the list (one of the circles) highlights that selection
    and updates the text and the color bar. You can see the component in action on
    CodeSandbox ([https://hgt0x.csb.app/](https://hgt0x.csb.app/)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 点击列表中的颜色（其中一个圆圈）会突出显示该选择并更新文本和颜色条。您可以在CodeSandbox上看到组件的实际操作效果 ([https://hgt0x.csb.app/](https://hgt0x.csb.app/))。
- en: 6.1.1 Passing state from a parent by setting props on the children
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 通过在子组件上设置属性从父组件传递状态
- en: 'Listing 6.1 shows the code for the `Colors` component. It imports three child
    components: `ColorPicker`, `ColorChoiceText`, and `ColorSample`. Each child needs
    the selected color, so the `Colors` component holds that state and passes it to
    them as a prop, an attribute in the JSX. It also passes the available colors and
    the `setColor` updater function to the `ColorPicker` component.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1显示了 `Colors` 组件的代码。它导入了三个子组件：`ColorPicker`、`ColorChoiceText` 和 `ColorSample`。每个子组件都需要所选颜色，因此
    `Colors` 组件持有该状态并将其作为属性传递给它们，即JSX中的属性。它还传递了可用颜色和 `setColor` 更新函数到 `ColorPicker`
    组件。
- en: '*Live*: [https://hgt0x.csb.app/](https://hgt0x.csb.app/), *Code*: [https://codesandbox.io/s/colorpicker-hgt0x](https://codesandbox.io/s/colorpicker-hgt0x)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时预览*: [https://hgt0x.csb.app/](https://hgt0x.csb.app/), *代码*: [https://codesandbox.io/s/colorpicker-hgt0x](https://codesandbox.io/s/colorpicker-hgt0x)'
- en: Listing 6.1 The `Colors` component
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 `Colors` 组件
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Import the child components.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入子组件。
- en: ❷ Define state values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义状态值。
- en: ❸ Pass the appropriate state values to the child components as props.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将适当的状态值作为属性传递给子组件。
- en: 'The `Colors` component passes down two types of props: state values to be used
    in the children’s UI, `colors` and `color`; and a function to update the shared
    state, `setColor`. Let’s look at state values first.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Colors` 组件向下传递两种类型的属性：用于子组件UI的状态值 `colors` 和 `color`；以及一个更新共享状态的函数 `setColor`。让我们首先看看状态值。'
- en: 6.1.2 Receiving state from a parent as a prop
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 将状态作为属性从父组件接收
- en: Both the `ColorChoiceText` component and the `ColorSample` component display
    the currently selected color. `ColorChoiceText` includes it in its message, and
    `ColorSample` uses it to set the background color. They receive the color value
    from the `Colors` component, as shown in figure 6.2.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorChoiceText` 组件和 `ColorSample` 组件都显示当前所选颜色。`ColorChoiceText` 将其包含在其消息中，而
    `ColorSample` 使用它来设置背景颜色。它们从 `Colors` 组件接收颜色值，如图6.2所示。'
- en: '![](../Images/6-2.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-2.png)'
- en: Figure 6.2 The `Colors` component passes the current color state value to the
    child components.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 `Colors` 组件将当前颜色状态值传递给子组件。
- en: '`Colors` is the closest shared parent of the child components that share the
    state, so we manage the state within `Colors`. Figure 6.3 shows the `ColorChoiceText`
    component displaying a message that includes the selected color. The component
    simply uses the color value as part of its UI; it doesn’t need to update the value.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Colors` 是共享状态的子组件最近的共享父组件，因此我们在 `Colors` 中管理状态。图6.3显示了 `ColorChoiceText` 组件显示包含所选颜色的消息。该组件只需将颜色值作为其UI的一部分即可；它不需要更新该值。'
- en: '![](../Images/6-3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-3.png)'
- en: Figure 6.3 The `ColorChoiceText` component includes the selected color in its
    message.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 `ColorChoiceText` 组件在其消息中包含所选颜色。
- en: The `ColorChoiceText` component’s code is in listing 6.2\. When React calls
    the component, it passes it as the component’s first argument, an object containing
    all of the props set by the parent. The code here destructures the props, assigning
    the `color` prop to a local variable of the same name.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorChoiceText` 组件的代码在列表6.2中。当React调用该组件时，它将其作为组件的第一个参数传递，即一个包含父组件设置的 所有属性的对象。这里的代码解构了属性，将
    `color` 属性分配给同名的局部变量。'
- en: '*Live*: [https://hgt0x.csb.app/](https://hgt0x.csb.app/), *Code*: [https://codesandbox.io/s/colorpicker-hgt0x](https://codesandbox.io/s/colorpicker-hgt0x)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时预览*: [https://hgt0x.csb.app/](https://hgt0x.csb.app/), *代码*: [https://codesandbox.io/s/colorpicker-hgt0x](https://codesandbox.io/s/colorpicker-hgt0x)'
- en: Listing 6.2 The `ColorChoiceText` component
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 `ColorChoiceText` 组件
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Receive the color state from the parent as a prop.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从父组件接收颜色状态作为属性。
- en: ❷ Check that there is a color.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查是否存在颜色。
- en: ❸ Use the prop in the UI.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在UI中使用属性。
- en: ❹ Return alternate UI if the parent doesn’t set a color.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果父组件未设置颜色，则返回备用UI。
- en: What if the parent doesn’t set a `color` prop? The `ColorChoiceText` component
    is happy for there to be no `color` prop; it returns alternate UI saying no color
    was selected.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父组件未设置 `color` 属性会怎样？`ColorChoiceText` 组件对没有 `color` 属性感到高兴；它返回备用UI，表示没有选择颜色。
- en: The `ColorSample` component, shown in figure 6.4, displays a bar with its background
    set to the selected color.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 6.4 所示的 `ColorSample` 组件显示一个背景设置为所选颜色的条形。
- en: '![](../Images/6-4.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-4.png)'
- en: Figure 6.4 The `ColorSample` component displays a bar of the selected color.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 `ColorSample` 组件显示所选颜色的条形。
- en: '`ColorSample` takes a different approach to a missing prop. It returns no UI
    at all! In the following listing, you can see the component checking for the `color`
    value. If it’s missing, the component returns `null` and React renders nothing
    at that point in the element tree.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorSample` 对缺失属性采取了不同的方法。它根本不返回任何 UI！在下面的列表中，你可以看到组件正在检查 `color` 值。如果它缺失，组件返回
    `null`，React 在元素树中的该点不渲染任何内容。'
- en: '*Live*: [https://hgt0x.csb.app/](https://hgt0x.csb.app/), *Code*: [https://codesandbox.io/s/colorpicker-hgt0x](https://codesandbox.io/s/colorpicker-hgt0x)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*直播*: [https://hgt0x.csb.app/](https://hgt0x.csb.app/), *代码*: [https://codesandbox.io/s/colorpicker-hgt0x](https://codesandbox.io/s/colorpicker-hgt0x)'
- en: Listing 6.3 The `ColorSample` component
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 `ColorSample` 组件
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Receive the state from the parent as a prop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将状态从父组件作为属性接收。
- en: ❷ Check that there is a color.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查是否存在颜色。
- en: ❸ Don’t render any UI if there’s no color.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果没有颜色，则不渲染任何 UI。
- en: You could set a default value for `color` as part of the prop’s destructuring.
    Maybe if the parent doesn’t specify a color, then it should be white?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在属性解构中将 `color` 的默认值设置为部分。也许如果父组件没有指定颜色，那么它应该是白色？
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Specify a default value for the prop.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为属性指定默认值。
- en: A default value will work for some components, but for our color-based components
    that need to share state, we’d have to make sure all of the defaults were the
    same. So, we either have alternate UI or no UI. If the component just won’t work
    without a prop, and a default doesn’t make sense, you can throw an error explaining
    that the prop is missing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些组件，默认值可能就足够了，但对我们需要共享状态的基于颜色的组件，我们必须确保所有默认值都是相同的。因此，我们要么有替代的 UI，要么没有 UI。如果组件没有属性就无法工作，并且默认值没有意义，你可以抛出一个错误，解释属性缺失的原因。
- en: Although we won’t explore them in this book, you can also use PropTypes to specify
    expected props and their types. React will use the PropTypes to warn of problems
    during development ([https://reactjs.org/docs/typechecking-with-proptypes.html](https://reactjs.org/docs/typechecking-with-proptypes.html)).
    Alternatively, use TypeScript rather than JavaScript and type-check your whole
    application ([www.typescriptlang.org](http://www.typescriptlang.org)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这本书中不会探讨它们，但你也可以使用 PropTypes 来指定预期的属性及其类型。React 将使用 PropTypes 在开发期间警告问题（[https://reactjs.org/docs/typechecking-with-proptypes.html](https://reactjs.org/docs/typechecking-with-proptypes.html)）。或者，使用
    TypeScript 而不是 JavaScript，并对整个应用程序进行类型检查（[www.typescriptlang.org](http://www.typescriptlang.org)）。
- en: 6.1.3 Receiving an updater function from a parent as a prop
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 从父组件作为属性接收更新器函数
- en: 'The `ColorPicker` component uses two state values to generate its UI: a list
    of available colors and the selected color. It displays the available color values
    as list items, and the app uses CSS to style them as a row of colored circles,
    as you can see in figure 6.5\. The selected item, *goldenrod* in the figure, is
    styled larger than the others.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorPicker` 组件使用两个状态值来生成其 UI：可用颜色列表和所选颜色。它显示可用颜色值作为列表项，应用程序使用 CSS 将它们样式化为一行彩色圆圈，如图
    6.5 所示。图中的所选项目，*goldenrod*，比其他项目样式更大。'
- en: '![](../Images/6-5.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-5.png)'
- en: Figure 6.5 The `ColorPicker` component displays a list of colors and highlights
    the selected color.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 `ColorPicker` 组件显示颜色列表并突出显示所选颜色。
- en: The `Colors` component passes the `ColorPicker` component the two state values
    it uses. `Colors` also needs to provide a way to update the selected color for
    all three children. It delegates that responsibility to the `ColorPicker` component
    by passing it the `setColor` updater function, as illustrated in figure 6.6.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Colors` 组件将使用的两个状态值传递给 `ColorPicker` 组件。`Colors` 还需要提供一种更新所有三个子组件所选颜色的方式。它通过传递
    `setColor` 更新器函数将此责任委托给 `ColorPicker` 组件，如图 6.6 所示。'
- en: '![](../Images/6-6.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-6.png)'
- en: Figure 6.6 The `Colors` component passes two state values to `ColorPicker`.
    It also passes the `setColor` updater function, so the color state value can be
    set from the child.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 `Colors` 组件将两个状态值传递给 `ColorPicker`。它还传递了 `setColor` 更新器函数，因此可以从子组件设置颜色状态值。
- en: 'The following listing shows the `ColorPicker` component destructuring its props
    argument, assigning the three props to local variables: `colors`, `color`, and
    `setColor`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `ColorPicker` 组件解构其属性参数，将三个属性分配给局部变量：`colors`、`color` 和 `setColor`。
- en: '*Live*: [https://hgt0x.csb.app/](https://hgt0x.csb.app/), *Code*: [https://codesandbox.io/s/colorpicker-hgt0x](https://codesandbox.io/s/colorpicker-hgt0x)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*Live*: [https://hgt0x.csb.app/](https://hgt0x.csb.app/), *Code*: [https://codesandbox.io/s/colorpicker-hgt0x](https://codesandbox.io/s/colorpicker-hgt0x)'
- en: Listing 6.4 The `ColorPicker` component
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 `ColorPicker` 组件
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Receive the state and updater function from the parent as props.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将状态和更新函数从父组件作为属性接收。
- en: ❷ Use the updater function to set the parent’s state.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用更新函数设置父组件的状态。
- en: 'The destructuring syntax includes a default value for `colors`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 解构语法为 `colors` 包含一个默认值：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ColorPicker` component iterates over the `colors` array to create a list
    item for each available color. Using an empty array as a default value causes
    the component to return an empty unordered list if the parent component doesn’t
    set the `colors` prop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorPicker` 组件遍历 `colors` 数组以为每个可用颜色创建一个列表项。使用空数组作为默认值会导致组件在父组件未设置 `colors`
    属性时返回一个空的未排序列表。'
- en: 'More interesting (for a book about React Hooks) are the `color` and `setColor`
    props. These props have come from a call to `useState` in the parent:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一本关于 React Hooks 的书来说，更有趣的是 `color` 和 `setColor` 属性。这些属性来自父组件中对 `useState`
    的调用：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `ColorPicker` doesn’t care where they’ve come from; it just expects a `color`
    prop to hold the current color and a `setColor` prop to be a function it can call
    to set the color somewhere. `ColorPicker` uses the `setColor` updater function
    in the `onClick` handler for each list item. By calling the `setColor` function,
    the child component, `ColorPicker`, is able to set the state for the parent component,
    `Colors`. The parent then re-renders, updating all of its children with the newly
    selected color.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorPicker` 不关心它们来自哪里；它只期望有一个 `color` 属性来保存当前颜色，以及一个 `setColor` 属性，它是一个可以调用来设置颜色的函数。`ColorPicker`
    使用每个列表项的 `onClick` 处理器中的 `setColor` 更新函数。通过调用 `setColor` 函数，子组件 `ColorPicker`
    能够设置父组件 `Colors` 的状态。然后父组件重新渲染，使用新选定的颜色更新所有子组件。'
- en: We created the `Colors` component from scratch, knowing we needed shared state
    to pass down to child components. Sometimes we work with existing components and,
    as a project develops, realize they hold state that other siblings may also need.
    The next sections look at a couple of ways of lifting state up from children to
    parents to make it more widely available.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从头创建了 `Colors` 组件，因为我们知道我们需要共享状态来传递给子组件。有时我们与现有组件一起工作，随着项目的开发，我们会意识到它们持有的状态其他兄弟组件也可能需要。接下来的几节将探讨几种将状态从子组件提升到父组件的方法，使其更广泛可用。
- en: 6.2 Breaking components into smaller pieces
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 将组件拆分为更小的部分
- en: React gives us the `useState` and `useReducer` hooks as two ways of managing
    state in our apps. Each hook provides a means to update the state, triggering
    a re-render. As our app develops, we balance the convenience of being able to
    access local state directly from a single component’s effects, handler functions,
    and UI against the inconvenience of that component’s state becoming bloated and
    tangled, with state changes from one part of the UI triggering re-renders of the
    whole component.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: React 通过 `useState` 和 `useReducer` 钩子为我们提供了两种在应用程序中管理状态的方法。每个钩子都提供了一种更新状态的方式，从而触发重新渲染。随着我们的应用程序的发展，我们在能够直接从单个组件的效果、处理函数和
    UI 中访问本地状态的便利性与该组件的状态变得膨胀和混乱的不便之间取得平衡，其中一个部分的 UI 的状态变化会触发整个组件的重新渲染。
- en: New components in the app may want a piece of the existing state pie, so we
    now need to share state that, previously, one component encapsulated. Do we lift
    state values and updater functions up to parents? Or maybe lift reducers and dispatch
    functions? How does moving state around change the structure of the existing components?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的新组件可能想要分享现有状态的一部分，因此我们现在需要共享之前由一个组件封装的状态。我们是将状态值和更新函数提升到父组件吗？或者可能是提升减少器和分发函数？移动状态会如何改变现有组件的结构？
- en: 'In this section, we continue building out the bookings app example as a context
    for these questions. In particular, we explore the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们继续构建预订应用程序示例，作为这些问题的背景。特别是，我们探索以下内容：
- en: Seeing components as part of a bigger app
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组件视为更大应用程序的一部分
- en: Organizing multiple components within a page’s UI
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面 UI 中组织多个组件
- en: Creating a `BookableDetails` component
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 `BookableDetails` 组件
- en: The concepts encountered are nothing new for existing React developers. Our
    aim here is to consider if and how they change when using React Hooks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到的概念对现有的React开发者来说并不新鲜。我们的目标是考虑在使用React Hooks时，它们是否以及如何发生变化。
- en: 6.2.1 Seeing components as part of a bigger app
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 将组件视为更大应用的一部分
- en: 'In chapter 5, we left the `BookablesList` component doing double duty: displaying
    a list of bookables for the selected group and displaying details for the selected
    bookable. Figure 6.7 shows the component with the list and details visible.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我们让`BookablesList`组件承担双重职责：显示所选组的可预订项列表，并显示所选可预订项的详情。图6.7显示了具有列表和详情的组件。
- en: '![](../Images/6-7.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-7.png)'
- en: Figure 6.7 The previous `BookablesList` component, from chapter 5, showed the
    list of bookables and the details of the selected bookable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 第5章中的先前`BookablesList`组件显示了可预订项列表和所选可预订项的详情。
- en: 'The component managed all of the state: the bookables, the selected group,
    and the selected bookable, and flags for displaying details, loading state, and
    errors. As a single function component with no child components, all of the state
    was in local scope and available to use when generating the returned UI. But toggling
    the Show Details check box would cause a re-render of the whole component, and
    we had to think carefully about persisting timer IDs across renders when using
    Presentation Mode.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件管理所有状态：可预订项、所选组、所选可预订项，以及用于显示详情、加载状态和错误的标志。作为一个没有子组件的单个函数组件，所有状态都在本地作用域中，并在生成返回的UI时可用。但是，切换“显示详情”复选框会导致整个组件重新渲染，并且在使用演示模式时，我们必须仔细考虑在渲染之间持久化计时器ID。
- en: We also need a list of bookables on the Bookings page. Various components will
    be vying for screen real estate, and we want the flexibility to be able to display
    the list of bookables separately from the bookable details, as shown in figure
    6.8, where the list of bookables is on the left. In fact, as in the figure, we
    might not want to display the bookable details at all, saving that information
    for the dedicated Bookables page.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在预订页面上有一个可预订项列表。各种组件将争夺屏幕空间，我们希望有灵活性，能够将可预订项列表与详情分开显示，如图6.8所示，其中可预订项列表位于左侧。实际上，如图所示，我们可能根本不想显示可预订详情，将此信息保留在专门的“可预订”页面上。
- en: '![](../Images/6-8.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-8.png)'
- en: Figure 6.8 The list of bookables (on the left) is also used on the Bookings
    page.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 可预订项列表（在左侧）也用于预订页面上。
- en: To be able to use the list and details sections of the `BookableList` UI independently,
    we’ll create a separate component for the details of the selected bookable. The
    `BookablesList` component will continue to display the groups, list of bookables,
    and Next button, but the new `BookableDetails` component will display the details
    and manage the Show Details check box.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够独立使用`BookableList` UI的列表和详情部分，我们将为所选可预订项的详情创建一个单独的组件。`BookablesList`组件将继续显示组、可预订项列表和“下一步”按钮，但新的`BookableDetails`组件将显示详情并管理“显示详情”复选框。
- en: The `BookablesPage` component currently imports and renders the `BookablesList`
    component. We need to do a bit of rearranging to use the new version of the list
    along with the `BookableDetails` component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当前`BookablesPage`组件导入并渲染`BookablesList`组件。我们需要做一些调整，以便使用新的列表版本以及`BookableDetails`组件。
- en: 6.2.2 Organizing multiple components within a page’s UI
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 在页面UI中组织多个组件
- en: Both the `BookablesList` and the `BookableDetails` components need access to
    the selected bookable. We create a `BookablesView` component to wrap the list
    and details and to manage the shared state. Table 6.1 lists our proliferating
    bookables components and outlines how they work together.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesList`和`BookableDetails`组件都需要访问所选的可预订项。我们创建了一个`BookablesView`组件来包装列表和详情，并管理共享状态。表6.1列出了我们日益增长的组件，并概述了它们如何协同工作。'
- en: Table 6.1 Bookables components and how they work together
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 可预订组件及其协同工作方式
- en: '| Component | Purpose |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 目的 |'
- en: '| `BookablesPage` | Shows the `BookablesView` component (and, later, forms
    for adding and editing bookables) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `BookablesPage` | 显示`BookablesView`组件（以及稍后用于添加和编辑可预订项的表单） |'
- en: '| `BookablesView` | Groups the `BookablesList` and `BookableDetails` components
    and manages their shared state |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `BookablesView` | 将`BookablesList`和`BookableDetails`组件分组，并管理它们的共享状态 |'
- en: '| `BookablesList` | Shows a list of bookables by group and lets the user select
    a bookable, either by clicking a bookable or using the Next button |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `BookablesList` | 通过分组显示可预订项列表，并允许用户通过点击可预订项或使用“下一步”按钮来选择可预订项 |'
- en: '| `BookableDetails` | Shows the details of the selected bookable with a check
    box to toggle the display of the bookable’s availability |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `BookableDetails` | 显示选定可预订项的详细信息，并带有用于切换可预订项可用性显示的复选框 |'
- en: 'In sections 6.3 and 6.4, we look at two approaches to lifting the state up
    to the `BookablesView` component:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6.3节和第6.4节中，我们将探讨两种将状态提升到`BookablesView`组件的方法：
- en: Lifting the existing reducer from `BookablesList` to the `BookablesView` component
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的reducer从`BookablesList`提升到`BookablesView`组件
- en: Lifting the selected bookable from `BookablesList` to the `BookablesView` component
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将选定的可预订项从`BookablesList`提升到`BookablesView`组件
- en: First, as shown in the following listing, we update the page component to import
    and show `BookablesView` rather than `BookablesList`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如以下列表所示，我们更新页面组件以导入并显示`BookablesView`而不是`BookablesList`。
- en: 'Branch: 0601-lift-reducer, File: src/components/Bookables/BookablesPage.js'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0601-lift-reducer，文件：src/components/Bookables/BookablesPage.js
- en: Listing 6.5 The `BookablesPage` component
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 `BookablesPage`组件
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Import the new component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入新组件。
- en: ❷ Use the new component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用新组件。
- en: On separate repo branches, we’ll create a different version of the `BookablesView`
    component for each of the two state-sharing approaches we take. The `BookableDetails`
    component will be the same either way, so let’s build that first.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的仓库分支上，我们将为两种状态共享方法中的每一种创建一个不同的`BookablesView`组件版本。`BookableDetails`组件将保持不变，所以让我们先构建它。
- en: 6.2.3 Creating a BookableDetails component
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 创建可预订详情组件
- en: The new `BookableDetails` component performs exactly the same task as the second
    half of the old `BookablesList` component UI; it displays the details of the selected
    bookable and a check box for toggling part of that info. Figure 6.9 shows the
    `BookableDetails` component with the check box and bookable title, notes, and
    availability.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`BookableDetails`组件执行与旧`BookablesList`组件UI的后半部分完全相同的任务；它显示选定可预订项的详细信息以及一个用于切换部分信息的复选框。图6.9显示了带有复选框、可预订项标题、备注和可用性的`BookableDetails`组件。
- en: '![](../Images/6-9.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-9.png)'
- en: Figure 6.9 The `BookableDetails` component with check box, title, notes, and
    availability
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 带有复选框、标题、备注和可用性的`BookableDetails`组件
- en: As illustrated in figure 6.10, the `BookablesView` component passes in the selected
    bookable so that `BookableDetails` has the information it needs to display.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如图6.10所示，`BookablesView`组件传递选定的可预订项，以便`BookableDetails`能够显示所需的信息。
- en: '![](../Images/6-10.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-10.png)'
- en: Figure 6.10 `BookablesView` manages the shared state and passes the selected
    bookable to `BookableDetails`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 `BookablesView`管理共享状态并将选定的可预订项传递给`BookableDetails`。
- en: The code for the new component is in the following listing. The component receives
    the selected bookable as a prop but manages its own `hasDetails` state value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 新组件的代码如下所示。该组件接收选定的可预订项作为属性，但管理自己的`hasDetails`状态值。
- en: 'Branch: 0601-lift-reducer, File: src/components/Bookables/BookableDetails.js'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0601-lift-reducer，文件：src/components/Bookables/BookableDetails.js
- en: Listing 6.6 The `BookableDetails` component
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6 `BookableDetails`组件
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Receive the current bookable via props.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过属性接收当前可预订项。
- en: ❷ Use local state to hold the hasDetails flag.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用本地状态来保存`hasDetails`标志。
- en: ❸ Use the updater function to toggle the hasDetails flag.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用更新器函数来切换`hasDetails`标志。
- en: ❹ Toggle the hasDetails flag when the check box is clicked.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 当点击复选框时切换`hasDetails`标志。
- en: ❺ Use the hasDetails flag to set the check box.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用`hasDetails`标志来设置复选框。
- en: ❻ Use the hasDetails flag to show or hide the availability section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用`hasDetails`标志来显示或隐藏可用性部分。
- en: No other components in `BookablesView` care about the `hasDetails` state value,
    so it makes good sense to encapsulate it completely within `BookableDetails`.
    If a component is the sole user of a certain state, putting that state within
    the component seems like an obvious approach.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesView`组件中的其他组件不关心`hasDetails`状态值，因此将其完全封装在`BookableDetails`中是很有意义的。如果一个组件是某个特定状态的唯一使用者，那么将那个状态放在组件中似乎是一个明显的做法。'
- en: '`BookableDetails` is a simple component that just displays the selected bookable.
    As long as it receives that state value, it’s happy. Exactly how the `BookablesView`
    component manages that state is more of an open question; should it call `useState`
    or `useReducer` or both? The next two sections explore two approaches. Section
    6.4 makes quite a few changes to do away with the reducer. But first, section
    6.3 takes an easier path and uses the existing reducer in `BookablesList`, lifting
    it up into the `BookablesView` component.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookableDetails`是一个简单的组件，它只显示选定的可预订项。只要它接收到那个状态值，它就满意了。`BookablesView`组件如何管理这个状态则是一个更开放的问题；它应该调用`useState`、`useReducer`还是两者都调用？接下来的两个部分将探讨两种方法。第6.4节对reducer进行了相当多的修改以去除它。但首先，第6.3节采取了一条更简单的路径，并使用了现有的`BookablesList`中的reducer，将其提升到`BookablesView`组件中。'
- en: 6.3 Sharing the state and dispatch function from useReducer
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 从useReducer共享状态和dispatch函数
- en: We already have a reducer that manages all of the state changes for the `BookablesList`
    component. The state the reducer manages includes the bookables data, the selected
    group, and the index of the selected bookable, along with properties for loading
    and error states. If we move the reducer up into the `BookablesView` component,
    we can use the state the reducer returns to derive the selected bookable and pass
    it to the child components, as illustrated in figure 6.11.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个reducer来管理`BookablesList`组件的所有状态变化。reducer管理的状态包括可预订项数据、选定的组以及选定可预订项的索引，以及加载和错误状态的属性。如果我们把reducer提升到`BookablesView`组件中，我们可以使用reducer返回的状态来推导出选定的可预订项并将其传递给子组件，如图6.11所示。
- en: '![](../Images/6-11.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-11.png)'
- en: Figure 6.11 `BookablesView` manages the state with a reducer and passes the
    selected bookable or the whole state to its children.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 `BookablesView`使用reducer管理状态，并将选定的可预订项或整个状态传递给其子组件。
- en: While `BookableDetails` needs only the selected bookable, `BookablesList` needs
    the rest of the state the reducer returns and a way to continue dispatching actions
    as users select bookables and switch groups. Figure 6.11 also shows `BookablesView`
    passing the reducer’s state and dispatch function to `BookablesList`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`BookableDetails`只需要选定的可预订项，但`BookablesList`需要reducer返回的其余状态以及用户选择可预订项和切换组时继续dispatch动作的方式。图6.11还显示了`BookablesView`将reducer的状态和dispatch函数传递给`BookablesList`。
- en: 'Lifting the state up from `BookablesList` into the `BookablesView` component
    is relatively straightforward. We complete it in three steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态从`BookablesList`提升到`BookablesView`组件相对直接。我们分三步完成它：
- en: Managing state in the `BookablesView` component
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BookablesView`组件中管理状态
- en: Removing an action from the reducer
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从reducer中移除一个动作
- en: Receiving state and dispatch in the `BookablesList` component
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BookablesList`组件中接收状态和dispatch
- en: Let’s start by updating the `BookablesView` component to take control of the
    state.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先更新`BookablesView`组件以控制状态。
- en: 6.3.1 Managing state in the BookablesView component
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 在BookablesView组件中管理状态
- en: The `BookablesView` component needs to import its two children. It can then
    pass them the state they need and the means to update that state if required.
    In the following listing, you can see the imports for the new components, the
    state that `BookablesView` is managing, the call to the `useReducer` hook, and
    the UI as JSX, with state values and the dispatch function set as props.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesView`组件需要导入它的两个子组件。然后它可以向它们传递它们所需的状态以及更新该状态的途径。在下面的列表中，你可以看到新组件的导入、`BookablesView`管理的状态、对`useReducer`钩子的调用，以及作为JSX的UI，状态值和dispatch函数被设置为props。'
- en: 'Branch: 0601-lift-reducer, File: src/components/Bookables/BookablesView.js'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0601-lift-reducer，文件：src/components/Bookables/BookablesView.js
- en: Listing 6.7 Moving the bookables state into the `BookablesView` component
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7 将可预订项状态移动到`BookablesView`组件
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Import all the components that make up the UI.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入构成UI的所有组件。
- en: ❷ Import the reducer that BookablesList was using.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入BookablesList使用的reducer。
- en: ❸ Set up the initial state without hasDetails.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置初始状态，不包含hasDetails。
- en: ❹ Manage the state and reducer within BookablesView.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在BookablesView中管理状态和reducer。
- en: ❺ Derive the selected bookable from state.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从状态中推导出选定的可预订项。
- en: ❻ Pass state and dispatch to BookablesList.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将状态和dispatch传递给BookablesList。
- en: ❼ Pass the selected bookable to BookableDetails.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将选定的可预订项传递给BookableDetails。
- en: The `BookablesView` component imports the child components it needs and sets
    up the initial state that used to live in the `BookablesList` component. We’ve
    removed the `hasDetails` property from the state; the new `BookableDetails` component
    manages its own state for whether to show details or not.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesView`组件导入它需要的子组件并设置初始状态，该状态原本位于`BookablesList`组件中。我们已经从状态中移除了`hasDetails`属性；新的`BookableDetails`组件管理是否显示详细信息的自身状态。'
- en: 6.3.2 Removing an action from the reducer
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 从减法器中删除动作
- en: 'With the `BookableDetails` component happily toggling its own details, the
    reducer no longer needs to handle an action for toggling a shared `hasDetails`
    state value, so the following case can be removed from reducer.js:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`BookableDetails`组件愉快地切换自己的详细信息，减法器不再需要处理用于切换共享`hasDetails`状态值的动作，因此可以从reducer.js中删除以下情况：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Apart from that, the reducer can stay as it is. Nice!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，减法器可以保持原样。太棒了！
- en: 6.3.3 Receiving state and dispatch in the BookablesList component
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 在BookablesList组件中接收状态和分发
- en: 'The `BookablesList` component needs a few tweaks. Instead of relying on its
    own local reducer and actions, it’s now dependent on the `BookablesView` component
    (or any other parent component that renders it). The code for `BookablesList`
    is relatively long, so we consider it section by section. The structure of the
    code looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesList`组件需要进行一些调整。它现在依赖于`BookablesView`组件（或任何其他渲染它的父组件），而不是依赖于它自己的本地减法器和动作。`BookablesList`的代码相对较长，所以我们按部分考虑。代码的结构看起来像这样：'
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The following four subsections discuss any changes that are necessary. If you
    stitch the pieces together, you’ll have the complete component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四个小节讨论了必要的任何更改。如果您将这些部分拼接在一起，您将拥有完整的组件。
- en: Variables
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: Apart from the two new props, `state` and `dispatch`, there are no additions
    to the variables in the `BookablesList` component. But with the reducer lifted
    up to the `BookablesView` component and the need to display the bookable details
    removed, there are some deletions. The following listing shows what’s left.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个新属性`state`和`dispatch`外，`BookablesList`组件中的变量没有其他添加。但是，由于减法器提升到`BookablesView`组件，并且不再需要显示可预订的详细信息，因此有一些删除。以下列表显示了剩余的内容。
- en: 'Branch: 0601-lift-reducer, File: src/components/Bookables/BookablesList.js'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0601-lift-reducer，文件：src/components/Bookables/BookablesList.js
- en: 'Listing 6.8 `BookablesList`: 1\. Variables'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 `BookablesList`：1\. 变量
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Assign the state and dispatch props to local variables.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将状态和分发属性分配给局部变量。
- en: The reducer and its initial state are gone, as is the `hasDetails` flag. Finally,
    we no longer need to display the bookable details, so we removed the `bookable`
    variable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 减法器及其初始状态以及`hasDetails`标志都不再存在。最后，我们不再需要显示可预订的详细信息，因此我们移除了`bookable`变量。
- en: Effect
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 影响
- en: The effect is pretty much unchanged apart from one small detail. In the following
    listing, you can see that we have added the `dispatch` function to the effect’s
    dependency array.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个小细节外，效果几乎没有任何变化。在以下列表中，您可以看到我们已将`dispatch`函数添加到效果依赖数组中。
- en: 'Branch: 0601-lift-reducer, File: src/components/Bookables/BookablesList.js'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0601-lift-reducer，文件：src/components/Bookables/BookablesList.js
- en: 'Listing 6.9 `BookablesList`: 2\. Effect'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9 `BookablesList`：2\. 影响
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Assign the dispatch prop to a local variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将分发属性分配给局部变量。
- en: ❷ Include dispatch in the dependency array for the effect.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将分发函数包含在效果的依赖数组中。
- en: In the previous version, when we called `useReducer` from within the `BookablesList`
    component and assigned the dispatch function to the `dispatch` variable, React
    knew that the identity of the dispatch function would never change, so it didn’t
    need to be declared as a dependency for the effect. Now that a parent component
    passes `dispatch` in as a prop, `BookablesList` doesn’t know where it comes from
    so can’t be sure it won’t change. Leaving `dispatch` out of the dependency array
    prompts a warning in the browser console like the one in figure 6.12.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个版本中，当我们从`BookablesList`组件内部调用`useReducer`并将分发函数分配给`dispatch`变量时，React知道分发函数的身份永远不会改变，因此不需要将其声明为效果的依赖项。现在，由于父组件将`dispatch`作为属性传入，`BookablesList`不知道它从何而来，因此无法确定它不会改变。省略`dispatch`会导致浏览器控制台出现如图6.12所示的警告。
- en: '![](../Images/6-12.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-12.png)'
- en: Figure 6.12 React warns us when dispatch is missing from the dependency array.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 React在分发从依赖数组中缺失时警告我们。
- en: Including `dispatch` in the dependency array is good practice here; *we* know
    it won’t change (at least for now), so the effect won’t run unnecessarily. Notice
    that the warning in figure 6.12 says “If ‘dispatch’ changes too often, find the
    parent component that defines it and wrap that definition in useCallback.” We
    look at using the `useCallback` hook to maintain the identity of functions that
    are dependencies in section 6.5.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在依赖数组中包含`dispatch`是一种良好的实践；我们知道它不会改变（至少现在是这样），因此效果不会不必要地运行。注意图6.12中的警告说“如果‘dispatch’变化得太频繁，找到定义它的父组件，并将该定义包裹在`useCallback`中。”我们将在第6.5节中查看使用`useCallback`钩子来保持函数依赖项的标识。
- en: Handler functions
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数
- en: Now that the details for the selected bookable are shown by a different component,
    we can remove the `toggleDetails` handler function. Everything else stays the
    same. Easy!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选定的可预订项的详细信息由不同的组件显示，我们可以移除`toggleDetails`处理函数。其他一切保持不变。简单！
- en: UI
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: UI
- en: Goodbye, `bookableDetails` div! We completely cut out the second section of
    the UI, for displaying the bookable details. The following listing shows the updated,
    super-slim `BookablesList` UI.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再见，`bookableDetails` div！我们完全切除了UI的第二部分，用于显示可预订的详细信息。以下列表显示了更新后的、超级精简的`BookablesList`
    UI。
- en: 'Branch: 0601-lift-reducer, File: src/components/Bookables/BookablesList.js'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0601-lift-reducer，文件：src/components/Bookables/BookablesList.js
- en: 'Listing 6.10 `BookablesList`: 4\. UI'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.10 `BookablesList`：4. UI
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All that’s left in the UI is the list of bookables with its associated group
    picker and Next button. So, we also remove the `Fragment` component that was grouping
    the two big chunks of UI.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: UI中剩下的只是可预订列表及其关联的分组选择器和下一步按钮。因此，我们也移除了将两个大块UI分组的`Fragment`组件。
- en: With the bookable details off on their own adventures and the reducer lifted
    up to the parent, the changes to the `BookablesList` component mostly took the
    form of deletions. One key addition was the inclusion of `dispatch` in the dependency
    array for the data-loading effect. Housing the state in the `BookablesView` component
    (or maybe even higher up the component tree) seems easy. Stick all the data there,
    and pass a dispatch function to any descendant components that need to make changes
    to the state. It’s a valid approach, and one sometimes used by users of popular
    state-store libraries like Redux. But before throwing all the state up to the
    top of the app, even if most components don’t care about most of the state that
    ends up there, let’s investigate an alternative.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当可预订的详细信息独立行动，并且reducer提升到父组件时，对`BookablesList`组件的更改主要采取了删除的形式。一个关键的增加是将`dispatch`包含在数据加载效果的依赖数组中。将状态存储在`BookablesView`组件中（或者甚至更高层次的组件树中）看起来很简单。把所有数据都放在那里，并将dispatch函数传递给任何需要更改状态的子组件。这是一个有效的方法，有时也被Redux等流行状态存储库的用户使用。但在将所有状态提升到应用顶部之前，即使大多数组件不关心最终存储在那里的大多数状态，让我们先调查一个替代方案。
- en: 6.4 Sharing the state value and updater function from useState
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 从useState共享状态值和更新函数
- en: 'In this section, we try a different approach. We lift only the state that needs
    to be shared: the selected bookable. Figure 6.13 shows the `BookablesView` component
    passing the selected bookable to its two child components. The `BookableDetails`
    and `BookablesList` components still get exactly what they need, and rather than
    giving `BookablesView` a whole load of state it doesn’t need to share, `BookablesList`
    will manage the rest of the state and functionality that it needs: the loading
    indicators and errors.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们尝试了一种不同的方法。我们只提升需要共享的状态：选定的可预订项。图6.13显示了`BookablesView`组件将选定的可预订项传递给其两个子组件。`BookableDetails`和`BookablesList`组件仍然得到他们需要的，而且`BookablesList`不会给`BookablesView`提供它不需要共享的大量状态，而是将剩余的状态和所需的功能管理起来：加载指示器和错误。
- en: '![](../Images/6-13.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6-13.png)'
- en: Figure 6.13 `BookablesView` manages only the shared state. It passes the bookable
    to the `BookableDetails` component. It passes the bookable and its updater function
    to `BookablesList`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 `BookablesView`只管理共享状态。它将可预订项传递给`BookableDetails`组件。它将可预订项及其更新函数传递给`BookablesList`。
- en: 'Lifting the selected bookable up from `BookablesList` into the `BookablesView`
    component requires much less work in `BookablesView` but a number of changes in
    `BookablesList`. We complete the changes in two steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将选定的可预订项从`BookablesList`提升到`BookablesView`组件在`BookablesView`中需要做的工作要少得多，但在`BookablesList`中需要进行许多更改。我们分两步完成这些更改：
- en: Managing the selected bookable in the `BookablesView` component
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BookablesView`组件中管理选定的可预订项
- en: Receiving the bookable and updater function in `BookablesList`
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`BookablesList`中接收可预订项和更新函数
- en: The `BookablesList` component still needs a way to let `BookablesView` know
    that a user has selected a new bookable. `BookablesView` passes `BookablesList`
    the updater function for the selected bookable. Let’s take a closer look at the
    latest code for the `BookablesView` component.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesList`组件仍然需要一种方式来让`BookablesView`知道用户已选择一个新的可预订项。`BookablesView`将选中的可预订项的更新函数传递给`BookablesList`。让我们更仔细地看看`BookablesView`组件的最新代码。'
- en: 6.4.1 Managing the selected bookable in the BookablesView component
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 在`BookablesView`组件中管理选中的可预订项
- en: As you can see in listing 6.11, the `BookablesView` component in this version
    is very simple; it doesn’t have to deal with the reducer, initial state, or deriving
    the selected bookable from state. It includes a single call to the `useState`
    hook to manage the selected bookable state value. It then passes the selected
    bookable to both children and the updater function to `BookablesList`. When a
    user selects a bookable, the `BookablesList` component can use the updater function
    to let `BookablesView` know that the state has changed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表6.11所示，这个版本的`BookablesView`组件非常简单；它不需要处理reducer、初始状态或从状态中推导出选中的可预订项。它包含一个对`useState`钩子的调用，以管理选中的可预订项状态值。然后，它将选中的可预订项传递给子组件和更新函数到`BookablesList`。当用户选择一个可预订项时，`BookablesList`组件可以使用更新函数让`BookablesView`知道状态已更改。
- en: 'Branch: 0602-lift-bookable, File: /src/components/Bookables/BookablesView.js'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0602-lift-bookable，文件：/src/components/Bookables/BookablesView.js
- en: Listing 6.11 Putting the selected bookable in the `BookablesView` component
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 将选中的可预订项放入`BookablesView`组件
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Manage the selected bookable as a state value.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将选中的可预订项作为状态值管理。
- en: ❷ Pass the bookable and its updater function down.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将可预订项及其更新函数向下传递。
- en: ❸ Pass the bookable down.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将可预订项向下传递。
- en: '`BookablesView` no longer needs to do the filtering of the bookables for the
    current group or grab the current bookable from that filtered list. Let’s see
    how `BookablesList` changes to adapt to the new approach.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesView`不再需要为当前组过滤可预订项或从该过滤列表中获取当前可预订项。让我们看看`BookablesList`如何适应新的方法。'
- en: 6.4.2 Receiving the bookable and updater function in BookablesList
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 在`BookablesList`中接收可预订项和更新函数
- en: 'By letting the `BookablesView` component manage the selected bookable, we change
    how the `BookablesList` component works. In the reducer version, `BookablesView`
    stored the `bookableIndex` and `group` as part of state. Now, with `BookablesList`
    receiving the bookable directly, those state values are no longer needed. The
    selected bookable looks something like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让`BookablesView`组件管理选中的可预订项，我们改变了`BookablesList`组件的工作方式。在reducer版本中，`BookablesView`将`bookableIndex`和`group`作为状态的一部分存储。现在，由于`BookablesList`直接接收可预订项，这些状态值不再需要。选中的可预订项看起来像这样：
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It includes an `id` and a `group` property. Whatever group the selected bookable
    is in is the current group; we don’t need a separate `group` state value. Also,
    it’s easy to find the index of the selected bookable within the array of bookables
    in its group; we don’t need a `bookableIndex` state value. With the `group`, `bookableIndex`,
    and `hasDetails` state values no longer needed, resulting in a smaller, simpler
    state, let’s switch back to using calls to `useState` rather than a reducer.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括一个`id`和一个`group`属性。无论选中的可预订项在哪个组中，都是当前组；我们不需要单独的`group`状态值。此外，很容易在组内的可预订项数组中找到选中可预订项的索引；我们不需要`bookableIndex`状态值。由于不再需要`group`、`bookableIndex`和`hasDetails`状态值，结果是一个更小、更简单的状态，让我们切换回使用`useState`调用而不是reducer。
- en: 'There are changes to all sections of the `BookablesList` component, so we consider
    the code section by section. The structure of the code looks like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesList`组件的所有部分都进行了更改，因此我们按部分考虑代码。代码的结构看起来像这样：'
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each of the next four subsections discusses one of the code sections. If you
    stitch the pieces together, you’ll have the complete component.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个小节中的每一个都讨论了一个代码部分。如果你将这些部分拼接在一起，你将拥有完整的组件。
- en: Variables
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: The `BookablesList` component now receives the selected bookable as a prop.
    The selected bookable includes an `id` and a `group` property. We use the `group`
    property to filter the list and the `id` to highlight the selected bookable.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesList`组件现在接收选中的可预订项作为属性。选中的可预订项包括一个`id`和一个`group`属性。我们使用`group`属性来过滤列表，并使用`id`来突出显示选中的可预订项。'
- en: The following listing shows the updated `BookablesList` component receiving
    `bookable` and `setBookable` as props and setting up three pieces of local state
    by calling `useState` three times.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了更新的 `BookablesList` 组件接收 `bookable` 和 `setBookable` 作为属性，并通过三次调用 `useState`
    设置三件本地状态。
- en: 'Branch: 0602-lift-bookable, File: /src/components/Bookables/BookablesList.js'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0602-lift-bookable，文件：/src/components/Bookables/BookablesList.js
- en: 'Listing 6.12 `BookablesList`: 1\. Variables'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 `BookablesList`：1. 变量
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Import useState rather than useReducer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 `useState` 而不是 `useReducer`。
- en: ❷ Receive the selected bookable and updater function as props.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 接收选定的可预订项和更新函数作为属性。
- en: ❸ Manage state with calls to the useState hook.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过对 `useState` 钩子的调用管理状态。
- en: ❹ Get the current group from the selected bookable.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从选定的可预订项获取当前组。
- en: 'Listing 6.12 grabs the current group from the selected bookable by using the
    *optional chaining operato*r, `?.`, a recent addition to JavaScript:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 通过使用 *可选链操作符*，`?.`，从 JavaScript 中最近添加的一个，获取选定的可预订项的当前组：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If no bookable is selected, the expression `bookable?.group` returns `undefined`.
    It saves us from checking whether the bookable exists before accessing the `group`
    property:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有选择可预订项，表达式 `bookable?.group` 返回 `undefined`。它在我们访问 `group` 属性之前避免了检查可预订项是否存在：
- en: '[PRE20]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Until a bookable is selected, the group will be `undefined` and `bookablesInGroup`
    will be an empty array. We need to select a bookable as soon as the bookables
    data is loaded into the component. Let’s look at the loading process.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择可预订项之前，组将是 `undefined`，而 `bookablesInGroup` 将是一个空数组。我们需要在将可预订项数据加载到组件中后立即选择一个可预订项。让我们看看加载过程。
- en: Effect
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 影响
- en: The following listing shows the updated effect code. It now uses updater functions
    rather than dispatching actions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了更新的影响代码。现在它使用更新函数而不是发送动作。
- en: 'Branch: 0602-lift-bookable, File: /src/components/Bookables/BookablesList.js'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0602-lift-bookable，文件：/src/components/Bookables/BookablesList.js
- en: 'Listing 6.13 `BookablesList`: 2\. Effect'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13 `BookablesList`：2. 影响
- en: '[PRE21]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Use the setBookable prop to select the first bookable.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `setBookable` 属性选择第一个可预订项。
- en: ❷ Use the local updater function to set the bookables state.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用本地更新函数设置可预订项状态。
- en: ❸ If there’s an error, set the error state.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果有错误，设置错误状态。
- en: ❹ Include the external function in the dependency list.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将外部函数包含在依赖列表中。
- en: 'The first effect still uses the `getData` utility function, created in chapter
    4, to load the bookables. But instead of dispatching actions to a reducer, the
    effect uses all four of the listing’s updater functions: `setBookable` (passed
    in as a prop) and `setBookables`, `setIsLoading`, and `setError` (from local calls
    to `useState`).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个影响仍然使用在第 4 章中创建的 `getData` 工具函数来加载可预订项。但是，它不是向reducer发送动作，而是使用列表中的所有四个更新函数：`setBookable`（作为属性传入）和
    `setBookables`、`setIsLoading` 以及 `setError`（通过本地调用 `useState`）。
- en: 'When the data loads, it assigns the data to the bookables state value and calls
    `setBookable` with the first bookable in the array:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据加载时，它将数据分配给可预订项状态值，并使用数组中的第一个可预订项调用 `setBookable`：
- en: '[PRE22]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: React is able to sensibly respond to multiple state update calls, like the three
    just listed. It can batch updates to efficiently schedule any re-renders and DOM
    changes needed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: React 能够合理地响应多个状态更新调用，如刚刚列出的三个。它可以批量更新以有效地安排所需的任何重新渲染和DOM更改。
- en: As we saw with the `dispatch` prop in the reducer version in section 6.3, React
    doesn’t trust functions passed in as props to be the same on each render. In this
    version, `BookingsView` passes in the `setBookable` function as a prop, so we
    include it in the dependency array for the first effect. Indeed, we sometimes
    might define our own updater functions rather than directly using those that `useState`
    returns. We look at how to make such functions work nicely as dependencies in
    section 6.5, where we introduce the `useCallback` hook.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 6.3 节中关于 reducer 版本的 `dispatch` 属性所看到的，React 不信任作为属性传入的函数在每个渲染中都是相同的。在这个版本中，`BookingsView`
    将 `setBookable` 函数作为属性传入，因此我们将其包含在第一个影响的依赖数组中。实际上，我们有时可能定义自己的更新函数而不是直接使用 `useState`
    返回的函数。我们将在第 6.5 节中介绍如何使这些函数作为依赖项很好地工作，那里我们将介绍 `useCallback` 钩子。
- en: 'If an error was thrown in the course of loading the data, the `catch` method
    sets it as the error state value:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在加载数据的过程中抛出了错误，`catch` 方法将其设置为错误状态值：
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Handler functions
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数
- en: In the previous version of the `BookablesList` component, the handler functions
    dispatched actions to the reducer. In this new version, the handler functions’
    key task is to set the bookable. In the following listing, notice how each handler
    function includes a call to `setBookable`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BookablesList` 组件的先前版本中，处理函数向 reducer 发送动作。在这个新版本中，处理函数的主要任务是设置可预订项。在下面的列表中，注意每个处理函数都包含对
    `setBookable` 的调用。
- en: 'Branch: 0602-lift-bookable, File: /src/components/Bookables/BookablesList.js'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0602-lift-bookable，文件：/src/components/Bookables/BookablesList.js
- en: 'Listing 6.14 `BookablesList`: 3\. Handler functions'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6.14 `BookablesList`: 3. 处理函数'
- en: '[PRE24]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Filter for the selected group.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 过滤所选组。
- en: ❷ Set the bookable to the first in the new group.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将可预订项设置为新组中的第一个。
- en: 'The current group is derived from the selected bookable; we no longer have
    a `group` state value. So when a user chooses a group from the drop-down, the
    `changeGroup` function doesn’t directly set the new group. Instead, it selects
    the first bookable in the chosen group:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当前组是从所选可预订项派生出来的；我们不再有 `group` 状态值。因此，当用户从下拉列表中选择一个组时，`changeGroup` 函数不会直接设置新组。相反，它选择所选组中的第一个可预订项：
- en: '[PRE25]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `setBookable` updater function is from the `BookablesView` component and
    triggers a re-render of `BookablesView`. `BookablesView`, in turn, re-renders
    the `BookablesList` component, passing it the newly selected bookable as a prop.
    The `BookablesList` component uses the bookable’s `group` and `id` properties
    to select the correct group in the drop-down, show just the bookables in the group,
    and highlight the selected bookable in the list.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`setBookable` 更新器函数来自 `BookablesView` 组件，并触发 `BookablesView` 的重新渲染。`BookablesView`
    然后，重新渲染 `BookablesList` 组件，并将新选定的可预订项作为属性传递给它。`BookablesList` 组件使用可预订项的 `group`
    和 `id` 属性来在下拉列表中选择正确的组，仅显示该组中的可预订项，并在列表中突出显示所选的可预订项。'
- en: 'The `changeBookable` function has no surprises: it sets the selected bookable
    and moves focus to the Next button. In addition to setting the bookable to the
    next in the current group, `nextBookable` wraps back to the first if necessary.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeBookable` 函数没有惊喜：它设置了所选的可预订项并将焦点移动到“下一步”按钮。除了将可预订项设置为当前组中的下一个之外，`nextBookable`
    如果需要会回滚到第一个。'
- en: UI
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: UI
- en: We no longer have the `bookableIndex` value in state. The following listing
    shows how we use the bookable `id` instead.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再在状态中有 `bookableIndex` 值。下面的列表显示了我们是如何使用可预订项 `id` 的。
- en: 'Branch: 0602-lift-bookable, File: /src/components/Bookables/BookablesList.js'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：0602-lift-bookable，文件：/src/components/Bookables/BookablesList.js
- en: 'Listing 6.15 `BookablesList`: 4\. UI'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6.15 `BookablesList`: 4. UI'
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Use the ID to check whether a bookable should be highlighted.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 ID 检查是否应该突出显示可预订项。
- en: ❷ Pass the bookable to the changeBookable handler function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将可预订项传递给 `changeBookable` 处理函数。
- en: 'Some key changes to the UI occur in the list of bookables. The code iterates
    through the bookables in the same group as the selected bookable. One by one,
    the bookables in the group are assigned to the `b` variable. The `bookable` variable
    represents the selected bookable. If `b.id` and `bookable.id` are the same, the
    current bookable in the list should be highlighted, so we set its class to `selected`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在可预订项列表中发生了一些关键的 UI 变化。代码遍历与所选可预订项相同的组中的可预订项。一个接一个地，组中的可预订项被分配给 `b` 变量。`bookable`
    变量代表所选的可预订项。如果 `b.id` 和 `bookable.id` 相同，列表中的当前可预订项应该被突出显示，因此我们将其类设置为 `selected`：
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When a user clicks a bookable to select it, the `onClick` handler passes the
    whole bookable object, `b`, to the `changeBookable` function, rather than just
    the bookable’s index:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击可预订项以选择它时，`onClick` 处理函数将整个可预订项对象 `b` 传递给 `changeBookable` 函数，而不仅仅是可预订项的索引：
- en: '[PRE28]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And that’s the `BookablesList` component without a reducer again. A few changes
    were made, but with its more focused role of just listing bookables, it’s also
    simpler overall.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 再次没有使用 reducer 的 `BookablesList` 组件。虽然做了一些改动，但鉴于其仅列出可预订项的更专注的角色，整体上它也更简单。
- en: Which approach do you find easier to understand? Dispatching actions to a reducer
    in the parent or managing most of the state in the component that uses it? In
    the first approach, we moved the reducer up to the `BookablesView` component without
    making many changes. Could we have simplified the state held in the reducer in
    the same way we did for the variables in the second approach? Whichever implementation
    you prefer, this chapter gave you a chance to practice calling the `useState`,
    `useReducer`, and `useEffect` hooks and consider some of the nuances of passing
    dispatch and updater functions to child components.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得哪种方法更容易理解？在父组件中将动作派发到 reducer，还是在使用它的组件中管理大部分状态？在第一种方法中，我们没有做太多修改就将 reducer
    移到了 `BookablesView` 组件。我们能否以与第二种方法中变量相同的方式简化 reducer 中持有的状态？无论你更喜欢哪种实现方式，本章都给了你练习调用
    `useState`、`useReducer` 和 `useEffect` 钩子，并考虑传递给子组件的派发和更新函数的一些细微差别的机会。
- en: Challenge 6.1
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 6.1
- en: Split the `UsersList` component into `UsersList` and `UserDetails` components.
    Use the `UsersPage` component to manage the selected user, passing it to `UsersList`
    and `UserDetails`. Find a solution on the 0603-user-details branch.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `UsersList` 组件拆分为 `UsersList` 和 `UserDetails` 组件。使用 `UsersPage` 组件来管理选定的用户，将其传递给
    `UsersList` 和 `UserDetails`。在 0603-user-details 分支中找到解决方案。
- en: 6.5 Passing functions to useCallback to avoid redefining them
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 将函数传递给 `useCallback` 以避免重新定义它们
- en: Now that our applications are growing, and we have components working together
    to provide functionality, it’s natural to be passing state values down to children
    as props. As we’ve seen in this chapter, those values can include functions. If
    the functions are updater or dispatch functions from `useState` or `useReducer`,
    React guarantees that their identity will be stable. But for functions we define
    ourselves, the very nature of components as functions that React calls means our
    functions will be defined on every render. In this section, we explore the problems
    such redefining can cause and look at a new hook, `useCallback`, that can help
    solve such problems.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用程序正在增长，并且组件正在协同工作以提供功能，将状态值向下传递给子组件作为属性是很自然的。正如我们在本章中看到的，这些值可以包括函数。如果这些函数是来自
    `useState` 或 `useReducer` 的更新器或派发函数，React 保证它们的身份将是稳定的。但对于我们自己定义的函数，组件作为 React
    调用的函数的本质意味着我们的函数将在每次渲染时定义。在本节中，我们探讨了这种重新定义可能引起的问题，并查看了一个新的钩子 `useCallback`，它可以帮助解决这些问题。
- en: 6.5.1 Depending on functions we pass in as props
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 依赖于我们传递给属性中的函数
- en: 'In the previous section, the state for the selected bookable is managed by
    the `BookablesView` component. It passes both the bookable and its updater function,
    `setBookable`, to `BookablesList`. `BookablesList` calls `setBookable` whenever
    a user choses a bookable and also within the effect wrapping the data-fetching
    code, shown here without the `catch` block:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，所选可预订项的状态由 `BookablesView` 组件管理。它将可预订项及其更新器函数 `setBookable` 传递给 `BookablesList`。`BookablesList`
    在用户选择可预订项时调用 `setBookable`，并在包含数据获取代码的效果中调用，这里没有包含 `catch` 块：
- en: '[PRE29]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Once the data arrives, set the current bookable to the first.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 数据到达后，将当前可预订项设置为第一个。
- en: ❷ Include the setBookable function as a dependency.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 `setBookable` 函数作为依赖项包含。
- en: We include the `setBookable` updater function as a dependency. The effect reruns
    whenever the values in its dependency list change. But up to now, `setBookable`
    has been an updater function returned by `useState` and, as such, is guaranteed
    not to change value; the data-fetching effect runs only once.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `setBookable` 更新器函数作为依赖项包含。每当其依赖项列表中的值发生变化时，该效果会重新运行。但到目前为止，`setBookable`
    一直是由 `useState` 返回的更新器函数，因此保证其值不会改变；数据获取效果只运行一次。
- en: The parent component, `BookablesView`, assigns the updater function to the `setBookable`
    variable and sets it directly as one of `BookablesList`’s props. But it’s not
    uncommon to do some kind of validation or processing of values before updating
    state. Say `BookablesView` wants to check that the bookable exists and, if it
    does, add a timestamp property before updating state. The following listing shows
    such a custom setter.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件 `BookablesView` 将更新器函数分配给 `setBookable` 变量，并将其直接设置为 `BookablesList` 的属性之一。但在更新状态之前进行某种类型的验证或处理值并不罕见。假设
    `BookablesView` 想要检查是否存在可预订项，如果存在，则在更新状态之前添加一个时间戳属性。以下列表显示了这样的自定义设置器。
- en: Listing 6.16 Validating and enhancing a value in `BookablesView` before setting
    state
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.16 在设置状态之前验证和增强 `BookablesView` 中的值
- en: '[PRE30]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Check that the bookable exists.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查是否存在可预订项。
- en: ❷ Add a timestamp property.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加时间戳属性。
- en: ❸ Set the state.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置状态。
- en: ❹ Pass our handler function as the updater prop.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将我们的处理函数作为更新属性传递。
- en: '`BookablesView` now assigns the custom `updateBookable` function as the `setBookable`
    prop for `BookablesList`. The `BookablesList` component cares not a jot, and happily
    calls the new updater function whenever it wants to select a bookable. So, what’s
    the problem?'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookablesView` 现在将自定义的 `updateBookable` 函数作为 `setBookable` 属性分配给 `BookablesList`。`BookablesList`
    组件对此毫不在意，并且随时调用新的更新函数来选择可预订项。那么，问题是什么？'
- en: 'If you update the code to use the new updater function and load the Bookables
    page, the Network tab of the Developer Tools highlights some disturbing activity:
    the bookables are being fetched again and again, as shown in figure 6.14.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更新代码以使用新的更新函数并加载可预订项页面，开发者工具的网络标签页将突出显示一些令人不安的活动：可预订项被反复获取，如图6.14所示。
- en: '![](../Images/6-14.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/6-14.png)'
- en: Figure 6.14 The Network tab of the Developer Tools shows bookables being fetched
    repeatedly.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 开发者工具的网络标签页显示了可预订项被反复获取。
- en: The parent component, `BookablesView`, manages the state for the selected bookable.
    Whenever `BookablesList` loads the bookables data and sets the bookable, `BookablesView`
    re-renders; React runs its code again, defining the `updateBookable` function
    again and passing the new version of the function to `BookablesList`. The `useEffect`
    call in `BookablesList` sees that the `setBookable` prop is a new function and
    runs the effect again, refetching the bookables data and setting the bookable
    again, restarting the loop. We need a way to maintain the identity of our updater
    function, so that it doesn’t change from render to render.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件 `BookablesView` 管理所选可预订项的状态。每当 `BookablesList` 加载可预订项数据并设置可预订项时，`BookablesView`
    会重新渲染；React会再次运行其代码，重新定义 `updateBookable` 函数并将新版本的函数传递给 `BookablesList`。`BookablesList`
    中的 `useEffect` 调用会看到 `setBookable` 属性是一个新函数，并再次运行效果，重新获取可预订项数据并再次设置可预订项，重新启动循环。我们需要一种方法来保持我们的更新函数的身份，使其在渲染之间不发生变化。
- en: 6.5.2 Maintaining function identity with the useCallback hook
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 使用 `useCallback` 钩子保持函数身份
- en: 'When we want to use the same function from render to render but don’t want
    it to be redefined each time, we can pass the function to the `useCallback` hook.
    React will return the same function from the hook on every render, redefining
    it only if one of the function’s dependencies changes. Use the hook like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在渲染之间使用相同的函数，但又不希望每次都重新定义它时，我们可以将函数传递给 `useCallback` 钩子。React将在每次渲染时从钩子返回相同的函数，只有在函数的依赖项之一发生变化时才会重新定义它。使用钩子的方式如下：
- en: '[PRE31]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The function that `useCallback` returns is stable while the values in the dependency
    list don’t change. When the dependencies change, React redefines, caches, and
    returns the function using the new dependency values. The following listing shows
    how to use the new hook to solve our endless fetch problem.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当依赖项列表中的值不改变时，`useCallback` 返回的函数是稳定的。当依赖项改变时，React会重新定义、缓存并返回使用新依赖项值的函数。下面的列表显示了如何使用新的钩子来解决我们的无限获取问题。
- en: Listing 6.17 Maintaining a stable function identity with `useCallback`
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.17 使用 `useCallback` 保持稳定的函数身份
- en: '[PRE32]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Import the useCallback hook.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 `useCallback` 钩子。
- en: ❷ Pass the updater function to useCallback.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将更新函数传递给 `useCallback`。
- en: ❸ Specify the dependencies.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 指定依赖项。
- en: ❹ Assign the stable function as a prop.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将稳定的函数作为属性分配。
- en: Wrapping our updater function in `useCallback` means React will return the same
    function on every render, unless the dependencies change values. But we’ve used
    an empty dependency list, so the values will never change and React will always
    return the exact same function. The `useEffect` call in `BookablesList` will now
    see that its `setBookable` dependency is stable, and it’ll stop endlessly refetching
    the bookables data.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的更新函数包裹在 `useCallback` 中意味着React将在每次渲染时返回相同的函数，除非依赖项的值发生变化。但我们已经使用了一个空的依赖项列表，因此值永远不会改变，React将始终返回完全相同的函数。`BookablesList`
    中的 `useEffect` 调用现在会看到其 `setBookable` 依赖项是稳定的，并且它将停止无限期地重新获取可预订项数据。
- en: 'The `useCallback` hook can be useful, in exactly the same way, when working
    with components that re-render only when their props change. Such components can
    be created with React’s `memo` function, described in the React docs: [https://reactjs.org/
    docs/react-api.html#reactmemo](https://reactjs.org/docs/react-api.html#reactmemo).'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当与仅在它们的属性更改时重新渲染的组件一起工作时，`useCallback` 钩子可以非常有用。这些组件可以使用React的 `memo` 函数创建，这在React文档中有描述：[https://reactjs.org/docs/react-api.html#reactmemo](https://reactjs.org/docs/react-api.html#reactmemo)。
- en: '`useCallback` lets us memoize functions. To prevent the redefinition or recalculation
    of values more generally, React also provides the `useMemo` hook, and we’ll look
    at that in the next chapter.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCallback`允许我们缓存函数。为了更普遍地防止值的重新定义或重新计算，React还提供了`useMemo`钩子，我们将在下一章中探讨这一点。'
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'If components share the same state value, lift the value up to the closest
    shared ancestor component in the component tree and pass the state down via props:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果组件共享相同的状态值，将值提升到组件树中最接近的共享祖先组件，并通过属性传递状态：
- en: '[PRE33]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Pass the updater function returned by `useState` to child components if they
    need to update the shared state:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子组件需要更新共享状态，请将`useState`返回的更新函数传递给它们：
- en: '[PRE34]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Destructure the props parameter, assigning properties to local variables:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构属性参数，将属性分配给局部变量：
- en: '[PRE35]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Consider using default values for props. If the prop isn’t set, the default
    value will be used:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑为属性使用默认值。如果属性未设置，将使用默认值：
- en: '[PRE36]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check for `undefined` or `null` prop values. Return alternative UI if appropriate:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`undefined`或`null`属性值。如果适当，返回替代UI：
- en: '[PRE37]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Return `null` when it is appropriate to render nothing.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当适当渲染无内容时，返回`null`。
- en: To let a child component update the state managed by a parent, pass the child
    an updater function or a dispatch function. If the function is used in an effect,
    include the function in the effect’s dependency list.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要让子组件更新由父组件管理的状态，向子组件传递一个更新函数或一个分发函数。如果函数在效果中使用，请将函数包含在效果依赖列表中。
- en: 'Maintain the identity of functions across renders by wrapping them in calls
    to the `useCallback` hook. React will redefine the function only when the dependencies
    change:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将函数包装在`useCallback`钩子的调用中来保持函数在渲染之间的身份。React仅在依赖项更改时重新定义函数：
- en: '[PRE38]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
