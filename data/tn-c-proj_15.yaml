- en: 15 Tic-tac-toe
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 井字棋
- en: At the climax of the 1983 film *WarGames*, the computer that’s about to start
    World War III is directed to play a game of tic-tac-toe with itself. Recognizing
    that the game is silly because experienced players often end play in a draw, the
    computer determines that nuclear war is futile. It decides not to blow up the
    world. This conclusion should add some excitement to this chapter, because you
    can equate any game of tic-tac-toe—even one simulated on a computer—to nuclear
    war.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在1983年电影《战争游戏》的高潮部分，即将引发第三次世界大战的计算机被指示与自己玩井字棋。计算机意识到这个游戏很愚蠢，因为经验丰富的玩家通常以平局结束游戏，因此它决定核战争是徒劳的。它决定不炸毁世界。这个结论应该会给本章增添一些兴奋感，因为你可以将任何井字棋游戏——即使是计算机模拟的——等同于核战争。
- en: 'Game play for tic-tac-toe is simple. It’s easy to code. If you haven’t yet
    done so, now is the time to write your own version of the game. Of course, it’s
    made more complex when you consider such tasks as:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋的游戏玩法很简单。很容易编写代码。如果你还没有这样做，现在就是时候编写你自己的游戏版本了。当然，当你考虑以下任务时，它会变得更加复杂：
- en: Coding a game loop
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写游戏循环
- en: Programming turns for players
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程玩家的回合
- en: Determining when the game is over
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定游戏何时结束
- en: Adding the computer as a player
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加计算机作为玩家
- en: Giving the computer some intelligence
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给计算机一些智能
- en: The biggest hurdle you face when programming a text-mode game like tic-tac-toe
    is that I/O in C isn’t interactive. Unless you use a third-party library, such
    as Ncurses, you must rely upon stream I/O for your programs. It can work, but
    stream I/O brings potential problems to the table that the code must deal with,
    lest everything get hinky for the user.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编程像井字棋这样的文本模式游戏时，你面临的最大挑战是C语言中的I/O不是交互式的。除非你使用第三方库，如Ncurses，否则你必须依赖流I/O来编写你的程序。它可以工作，但流I/O会为代码带来潜在的问题，代码必须处理这些问题，否则用户可能会遇到麻烦。
- en: 15.1 A silly kids’ game
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 一个愚蠢的儿童游戏
- en: 'No one knows the exact origins of the game tic-tac-toe, so I thought I’d make
    up some interesting facts: in ancient Egypt, a game similar to tic-tac-toe was
    played on a wooden peg board with tokens carved from the severed toes of enemy
    soldiers. The Romans enjoyed a game of *tria ordine*, which involved lining up
    pebbles on a marble tablet. The prize was to slap your opponent in the face. And
    in medieval Europe, Norwegian children played a game of tossing fish into baskets,
    which has nothing to do with tic-tac-toe, but it smelled terrible.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人知道井字棋游戏的确切起源，所以我想到编造一些有趣的事实：在古埃及，一种类似于井字棋的游戏是在一个木制钉板上用从敌人截断的脚趾雕刻的标记玩的。罗马人喜欢玩一种叫做“tria
    ordine”的游戏，涉及在大理石板上排列鹅卵石。奖品是打对手的脸。在中世纪的欧洲，挪威的孩子玩一种将鱼扔进篮子的游戏，这与井字棋无关，但味道很糟糕。
- en: Yes, I made all that up.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我编造了所有这些。
- en: The earliest written reference to tic-tac-toe comes from the late 1800s using
    the name *noughts and crosses*. Even today, that is the game’s name in the Commonwealth
    outside America. The US name tic-tac-toe, originally tick-tack-toe, came about
    in the early 20th century. The first tic-tac-toe computer program was programmed
    in the early 1950s.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋最早的书面记载来自19世纪末，当时使用的是“noughts and crosses”这个名字。即使在今天，这仍然是除美国以外的英联邦国家的游戏名称。美国名称井字棋，最初是tick-tack-toe，起源于20世纪初。第一个井字棋计算机程序是在20世纪50年代初编写的。
- en: That’s your history lesson for today—some parts true, but others mostly false.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是今天的历史课——一些部分是真的，但其他部分大多是假的。
- en: 15.1.1 Playing tic-tac-toe
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.1 玩井字棋
- en: I’m obligated by the Computer Authors Guild to explain the game of tic-tac-toe
    despite your complete familiarity with it. Even so, remember that—unlike playing
    on a piece of paper, in the dirt, or on a fogged mirror—coding the game requires
    that you review the game play.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据计算机作者协会的要求，我必须解释井字棋游戏，尽管你对它非常熟悉。即便如此，请记住——与在纸上、在泥土中或在雾蒙蒙的镜子上玩不同——编写这个游戏需要你回顾游戏玩法。
- en: 'Figure 15.1 shows the standard tic-tac-toe grid: two vertical lines intersecting
    two horizontal lines. This grid holds nine squares, which become the battlefield.
    These are numbered in the figure, one through nine, also with handy mnemonics
    for each square’s location: top, middle, and bottom with left, center, and right.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1显示了标准的井字棋网格：两条垂直线与两条水平线相交。这个网格包含九个方格，它们成为战场。这些方格在图中编号，从一到九，并为每个方格的位置提供了方便的记忆法：顶部、中间和底部，以及左、中、右。
- en: '![15-01](Images/15-01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![15-01](Images/15-01.png)'
- en: Figure 15.1 The tic-tac-toe game grid, squares numbered and labeled
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 井字棋游戏网格，方格编号并标注
- en: Players take turns setting a mark into one of the nine grid squares. After choosing
    who goes first (an advantage), the players alternatively mark an X or O in the
    squares. Traditionally, the first player marks X, though this choice isn’t a rule.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家轮流在一个九宫格方块中放置标记。在选择谁先手（一个优势）之后，玩家交替在方块中标记X或O。传统上，第一个玩家标记X，尽管这个选择并不是规则。
- en: The winner is the first player to place three of their marks in a row. If this
    goal fails, the game is a tie, or “cat’s game.” All but the stupidest humans can
    achieve a tie, so desperate adults play with small kids to make themselves feel
    victorious.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利者是第一个在其标记连成一行的情况下放置三个标记的玩家。如果这个目标未能实现，游戏就是平局，或者称为“猫的游戏”。除了最愚蠢的人类之外，所有人都能实现平局，所以绝望的成年人会和小孩子玩游戏，让自己感觉胜利。
- en: Experienced players know that going first is advantageous. Further, marking
    the center square during the first turn, or *ply*, is the best strategy. Otherwise,
    good players attempt to set a triangle of squares, as illustrated in figure 15.2,
    which guarantees a win because their opponent can block only one of the legs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的玩家知道先手是有利的。此外，在第一回合或“回合”中标记中心方块是最佳策略。否则，优秀的玩家会尝试设置一个方块三角形，如图15.2所示，这保证了胜利，因为他们的对手只能阻止一条腿。
- en: '![15-02](Images/15-02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![15-02](Images/15-02.png)'
- en: Figure 15.2 Arrangements for a winning triangle
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 获胜三角形的排列
- en: 'Regardless of the strategy, tic-tac-toe has only eight paths to victory: three
    rows, three columns, or two diagonals. Despite the variety of games, only these
    eight possibilities define a winner. Because of the nine squares in the grid,
    victory is achieved in nine or fewer moves, making the game easy to learn, quick
    to play, and fun for a short measure of time.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无论策略如何，井字棋只有八条通往胜利的路径：三行、三列或两条对角线。尽管游戏种类繁多，但只有这八种可能性定义了胜利者。由于网格中有九个方块，胜利可以在九步或更少的步骤中实现，这使得游戏易于学习，快速玩耍，并且短时间内很有趣。
- en: 15.1.2 Approaching the game mathematically
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.2 以数学方式接近游戏
- en: As a nerd, I’m compelled to discuss the mathematical details regarding the game
    of tic-tac-toe. Some of these details come into play when you code your own game—specifically,
    if you dare to code a computer opponent and make it somewhat intelligent.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名极客，我不得不讨论有关井字棋游戏的数学细节。其中一些细节在你编写自己的游戏时会有所体现——特别是，如果你敢于编写一个具有一定智能的计算机对手。
- en: The total number of permutations possible for a game of tic-tac-toe is 19,683\.
    Don’t trust me; someone else did the math. The number accounts for each of nine
    grid squares holding either an X or an O or being blank. Keep in mind that the
    game grid is ternary, not binary. I touch upon this point again at the end of
    this section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 井字棋游戏可能的排列总数是19,683。不要相信我；有人做了数学计算。这个数字考虑了每个九宫格方块可以放置X、O或者为空。记住，游戏网格是三进制，而不是二进制。我在本节的末尾再次提到这一点。
- en: The 19,683 number doesn’t account for actual game play, because X and O follow
    each other and eliminate squares; the number of permutations is reduced as play
    moves forward. In practice, the game has 3,200 possible permutations. Removing
    those situations where the game is already won or tied drops the number further
    to 2,460.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 19,683这个数字并不包括实际的游戏玩法，因为X和O会跟随对方并消除方块；随着游戏的进行，排列的数量会减少。实际上，这个游戏有3,200种可能的排列。去掉那些游戏已经获胜或平局的情况，数字进一步减少到2,460。
- en: A final reduction is made by eliminating duplicates due to rotating or mirroring
    the game grid. When these repetitions are removed, the total number of tic-tac-toe
    game permutations drops to 120\. As this value is a lot easier to handle than
    19,683, many programmers opt to create all 120 permutations in memory and use
    this database to guide the computer during game play.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消除由于旋转或镜像游戏网格而产生的重复项，进行最后的减少。当这些重复项被移除后，井字棋游戏排列的总数降至120。由于这个值比19,683更容易处理，许多程序员选择在内存中创建所有120种排列，并使用这个数据库在游戏过程中指导计算机。
- en: The coding approach to handle 120 permutations is to create a game tree. This
    structure contains all possible game plays from which the program can choose a
    path to victory. In a way, this approach works like a giant cheat sheet, with
    the computer cribbing its next move based on all the possibilities, with a bias
    toward exploring only those paths to victory or a tie.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 处理120种排列的编码方法是创建一个游戏树。这个结构包含所有可能的玩法，程序可以从中选择一条通往胜利的路径。从某种意义上说，这种方法就像一张巨大的作弊表，计算机根据所有可能性来抄袭其下一步动作，并倾向于只探索通往胜利或平局的路径。
- en: 'My approach to the computer’s game play isn’t as smart as following a game
    tree. Instead, I chose to emulate the way people play the game: move to win or
    move to block. Later in this chapter, I expand upon this technique.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我对计算机游戏玩法的处理并不像遵循游戏树那样聪明。相反，我选择模仿人们玩游戏的方式：移动以获胜或移动以阻止。在本章的后面部分，我将扩展这一技术。
- en: 'Finally, it’s important to remember that the game gird is ternary: blank, X,
    or O. Obviously, you use an array to store values in the grid. I originally used
    values 0, 1, and 2 for blank, X, and O, respectively. This approach made the math
    more difficult when examining rows, columns, and diagonals. So, I instead used
    0 for blank, but -1 for O and +1 for X. You can read more about these choices
    in the next section.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要记住游戏网格是三元的：空白、X或O。显然，你使用数组在网格中存储值。最初，我使用值0、1和2分别代表空白、X和O。这种方法在检查行、列和对角线时使数学变得复杂。因此，我改用0表示空白，但用-1表示O和+1表示X。你可以在下一节中了解更多关于这些选择的信息。
- en: 15.2 The basic game
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 基本游戏
- en: For my implementation of tic-tac-toe, I began by coding the game grid. In fact,
    I’ve written many programs that output tic-tac-toe grids, but never bothered writing
    any game play, probably because the game itself isn’t rewarding to play.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的井字棋实现，我首先编写了游戏网格的代码。实际上，我编写了许多输出井字棋网格的程序，但从未费心编写任何游戏玩法，可能是因为游戏本身并不好玩。
- en: At the core of any interactive text mode game is a game play loop. It accepts
    input for new moves, updates the grid, and determines when a winning condition
    occurs. It’s the winning condition that breaks the loop, though other options
    for bailing out are also provided.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 任何交互式文本模式游戏的核心都是一个游戏循环。它接受新的移动输入，更新网格，并确定何时满足胜利条件。虽然也提供了其他退出循环的选项，但正是胜利条件打破了循环。
- en: For this first round, I’m coding a human-versus-human version of the game. It
    features functions that output the game grid, prompt for input, and determine
    a winner. An updated version that adds the computer as an opponent is covered
    later in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一轮中，我正在编写一个人类对人类版本的游戏。它包含输出游戏网格、提示输入和确定胜者的函数。在本章后面部分将介绍添加计算机作为对手的更新版本。
- en: 15.2.1 Creating the game grid
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.1 创建游戏网格
- en: Programming a tic-tac-toe grid is one of the basic duties beginners perform
    when learning C programming. After all, the grid represents a real-life example
    of a two-dimensional array, with rows and columns. It can be implemented in several
    ways, as shown in figure 15.3.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编程井字棋网格是初学者在学习C语言编程时执行的基本任务之一。毕竟，网格代表了二维数组的真实生活示例，具有行和列。它可以以多种方式实现，如图15.3所示。
- en: '![15-03](Images/15-03.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![15-03](Images/15-03.png)'
- en: Figure 15.3 Various options for presenting a text-mode tic-tac-toe game grid
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 展示了文本模式井字棋游戏网格的各种呈现选项
- en: I experimented with each of the varieties shown in figure 15.3 before I decided
    it would be more fun to use color text to show the grid. Color text output is
    covered in chapter 13\. It involves sending ANSI escape sequences to standard
    output, which are interpreted by most terminals as color. The grid I chose is
    shown in the lower right in figure 15.3, the color-coded squares.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定使用彩色文本来显示网格会更有趣之前，我实验了图15.3中显示的每种变体。彩色文本输出在第13章中介绍。它涉及向标准输出发送ANSI转义序列，这些序列被大多数终端解释为颜色。我选择的网格显示在图15.3的右下角，彩色方格。
- en: 'Seven color constants are created to achieve the colors I want, as shown in
    table 15.1\. Two different values are used for each of the three square possibilities:
    blank, X, and O. The alternating values help set a checkerboard pattern, which
    helps me avoid adding ugly ASCII line art to build the game grid.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了七个颜色常量来实现我想要的颜色，如表15.1所示。对于三种方格可能性：空白、X和O，每个都使用两个不同的值。交替的值有助于设置棋盘图案，这有助于我避免添加丑陋的ASCII线艺术来构建游戏网格。
- en: Table 15.1 Color constants and their values used to create the tic-tac-toe game
    grid
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1 用于创建井字棋游戏网格的颜色常量和它们的值
- en: '| Constant Name | Code | For Output |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 常量名称 | 代码 | 输出 |'
- en: '| bfwb[] | \x1b[32;47m | Blank square, green foreground/white background |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| bfwb[] | \x1b[32;47m | 空白方格，绿色前景/白色背景 |'
- en: '| bf[] | \x1b[32m | Blank square, green foreground |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| bf[] | \x1b[32m | 空白方格，绿色前景 |'
- en: '| xfwb[] | \x1b[31;47m | X square, red foreground/white background |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| xfwb[] | \x1b[31;47m | X方格，红色前景/白色背景 |'
- en: '| xf[] | \x1b[31m | X square, red foreground |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| xf[] | \x1b[31m | X方格，红色前景 |'
- en: '| ofwb[] | \x1b[34;47m | O square, blue foreground/white background |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| ofwb[] | \x1b[34;47m | O方格，蓝色前景/白色背景 |'
- en: '| of[] | \x1b[34m | O square, blue foreground |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| of[] | \x1b[34m | O 方块，蓝色前景 |'
- en: '| reset[] | \x1b[0m | Color values off |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| reset[] | \x1b[0m | 关闭颜色值 |'
- en: Each sequence sets a foreground or foreground-background combination. The background
    colors are used, every other square, to create the checkerboard pattern. The final
    reset[] sequence removes color from the output, which avoids color spill between
    lines in the output.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个序列设置前景或前景-背景组合。背景颜色用于每隔一个方块，以创建棋盘图案。最后的 reset[] 序列从输出中移除颜色，避免了输出行之间的颜色溢出。
- en: The next listing shows the source code for ttt01.c, the foundation upon which
    all code in this chapter is built. The *showgrid()* function outputs the game
    grid with alternating colors, numbering each position, one through nine. A *switch-case*
    test determines whether the square is occupied with an O (-1), an X (+1), or a
    blank (0). In the *main()* function, the grid is initialized in the grid[] array
    and then output. The purpose of this tiny program is to ensure that the output
    looks good.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了 ttt01.c 的源代码，这是本章所有代码的基础。*showgrid()* 函数输出带有交替颜色的游戏网格，并为每个位置编号，从一至九。一个
    *switch-case* 测试确定方块是否被 O（-1）、X（+1）或空白（0）占据。在 *main()* 函数中，网格在 grid[] 数组中初始化，然后输出。这个小程序的目的是确保输出看起来很好。
- en: Listing 15.1 Source code for ttt01.c
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.1 ttt01.c 的源代码
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The grid[] array is passed as an integer pointer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 grid[] 数组作为整数指针传递。
- en: ❷ Constants to define colors for grid output
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义网格输出的颜色常量
- en: ❸ Loops through the entire grid, nine squares
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历整个网格，九个方块
- en: '❹ Tests the value of each square: -1 for O, +1 for X, and 0 for blank'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测试每个方块的价值：-1 表示 O，+1 表示 X，0 表示空白
- en: ❺ O occupies the square.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ O 占据了方块。
- en: ❻ Outputs the square with a background (and the O)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 输出带有背景（和 O）的方块
- en: ❼ Outputs the square without a background
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 输出没有背景的方块
- en: ❽ Repeats the same output for X
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 重复相同的输出给 X
- en: ❾ Numbers the unoccupied squares, adding 1 for human eyeballs
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 为未占据的方块编号，为人类眼睛增加 1
- en: ❿ Every third square, adds a newline
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 每隔三个方块，添加一个换行符
- en: ⓫ The game grid is initialized here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 在这里初始化游戏网格。
- en: ⓬ Outputs the grid
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 输出网格
- en: The *showgrid()* function processes squares in the game grid. For each possible
    value—-1, +1, or 0—two options are available for output. The first is triggered
    for odd-numbered squares, where a background color is applied. For even squares,
    no background color is used. The effect is to output the current state of play
    in a consistent pattern, with no extra text characters required to build the grid.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*showgrid()* 函数处理游戏网格中的方块。对于每个可能的值——-1、+1 或 0——输出有两个选项。第一个是在奇数方块上触发的，其中应用了背景颜色。对于偶数方块，不使用背景颜色。这种效果是在一致的图案中输出当前游戏状态，无需额外的文本字符来构建网格。'
- en: 'Here is a sample run:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例运行：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The numbers in the grid help reference squares as the game progresses. Eventually,
    they’re replaced by X and O characters, which not only informs the user that the
    same square can’t be played twice but also shows the game’s progress.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 网格中的数字有助于在游戏过程中参考方块。最终，它们会被 X 和 O 字符替换，这不仅告知用户同一个方块不能被两次使用，还显示了游戏的进度。
- en: You can stop here and just admire your work. But no. The next step is to add
    game play.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里停下来，只是欣赏你的作品。但不行。下一步是添加游戏玩法。
- en: 15.2.2 Adding game play
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.2 添加游戏玩法
- en: I’m unsure whether every game works this way, but all the text-mode games I’ve
    written contain a primary game play loop. The loop checks for input, updates the
    game field, and determines when the game is over.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我不确定每个游戏是否都以这种方式进行，但所有我编写的文本模式游戏都包含一个主要游戏循环。循环检查输入，更新游戏区域，并确定何时游戏结束。
- en: Generally, the game play loop is endless. The terminating condition is winning
    the game, losing the game, or the player giving up.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，游戏循环是无尽的。终止条件是赢得游戏、输掉游戏或玩家放弃。
- en: 'To update the existing ttt01.c code, the game play loop must display the grid,
    prompt for input, and then update the grid[] array. This loop is shown in the
    next listing, added just below the *puts()* statement that outputs the game title.
    Two integer variables must be declared: ply and p.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新现有的 ttt01.c 代码，游戏循环必须显示网格，提示输入，然后更新 grid[] 数组。这个循环在下一个列表中显示，位于输出游戏标题的 *puts()*
    语句下方。必须声明两个整数变量：ply 和 p。
- en: Listing 15.2 The game play loop in the *main()* function
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.2 *main()* 函数中的游戏循环
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Turns, or plies, start at zero.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 轮次，或回合，从零开始。
- en: ❷ The loop is endless, relying on a win or exit command to break.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 循环是无尽的，依赖于胜利或退出命令来中断。
- en: ❸ Outputs the grid
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出网格
- en: ❹ Accepts input, returning the square to place a token
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 接受输入，返回放置标记的方格
- en: ❺ If the user inputs zero, the game quits.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果用户输入零，则游戏退出。
- en: ❻ Sets the token on the grid, subtracts one from p to obtain the array offset,
    and uses the current ply to determine whether O (-1) or X (+1) has played
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在网格上设置标记，从 p 中减去一以获得数组偏移量，并使用当前回合来确定是 O (-1) 还是 X (+1) 在玩游戏
- en: ❼ Increments the ply to the next turn
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将 ply 增加到下一个回合
- en: The *prompt()* function obtains user input, either the square in which to place
    a mark or zero to exit the game. The zero return value is tested to break the
    loop, ending the game. Otherwise, the grid[] array is updated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*prompt()* 函数获取用户输入，即放置标记的方格或零以退出游戏。零返回值被测试以中断循环，结束游戏。否则，grid[] 数组将被更新。'
- en: The value of variable ply (the current turn) determines whether X or O is playing.
    It’s assumed that X goes first. When ply%2 is 0, then O or -1 is generated in
    the grid; otherwise, X or +1 is set.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 ply（当前回合）的值决定了是 X 还是 O 在玩游戏。假设 X 先走。当 ply%2 为 0 时，则在网格中生成 O 或 -1；否则，设置 X
    或 +1。
- en: A text mode game must rely upon stream I/O to do its thing. Such a trick is
    possible if input is limited and makes sense to the user. For my tic-tac-toe game,
    numeric input is all that’s allowed. I rely upon the *scanf()* function, which
    I detest, but it does the job.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 文本模式游戏必须依赖于流 I/O 来完成其功能。如果输入有限并且对用户有意义，则这种技巧是可能的。对于我的井字棋游戏，只允许数字输入。我依赖于 *scanf()*
    函数，虽然我讨厌它，但它完成了工作。
- en: The following listing shows the *prompt()* function, which is called from the
    *main()* function in the endless *while* loop, shown earlier in listing 15.2\.
    The function’s argument is the current ply, the game’s next turn. This value is
    tested to determine whether X or O is playing. Input ranges from 1 through 9 (human
    numbers, not the actual array offsets), with 0 indicating the player wants to
    quit. Out-of-range values are interpreted as 0.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 *prompt()* 函数，该函数在前面列表 15.2 中显示的无限 *while* 循环中从 *main()* 函数中被调用。函数的参数是当前回合，游戏的下一个回合。该值被测试以确定是
    X 还是 O 在玩游戏。输入范围从 1 到 9（人类数字，而不是实际的数组偏移量），0 表示玩家想要退出。超出范围的值被解释为 0。
- en: Listing 15.3 The *prompt()* function
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.3 *prompt()* 函数
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Uses the ply value in variable p to determine which is the current play, X
    or O
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用变量 p 中的 ply 值来确定当前是 X 还是 O 在玩游戏
- en: ❷ Obtains numeric input
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取数字输入
- en: ❸ For out of range values, returns 0 (exit)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于超出范围的值，返回 0（退出）
- en: 'The *main()* function uses the return value from *prompt()* to set X or O into
    the grid. The complete source code is available in the online repository as ttt02.c.
    Here’s a sample run:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*main()* 函数使用 *prompt()* 函数的返回值将 X 或 O 设置到网格中。完整的源代码可在在线存储库中找到，作为 ttt02.c。以下是一个示例运行：'
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code successfully places an X or O on the grid, taking turns. What’s missing
    from the code is the capability to determine when a square is already occupied.
    As you can see from this sample run, O was able to capture the center square after
    it was already taken by X. The code also lacks a method to determine when the
    game is over; game play continues until the user inputs zero to quit.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 代码成功地在网格上放置了 X 或 O，轮流进行。从这次示例运行中可以看出，O 在 X 已经占用了中心方格之后，仍然能够捕获中心方格。代码还缺少确定游戏何时结束的方法；游戏将继续进行，直到用户输入零以退出。
- en: 15.2.3 Limiting the input to free squares
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3 限制输入到空白方格
- en: The ttt02.c code has plenty of room for improvement. The priority for me at
    this point is to restrict play to only blank squares in the grid. For example,
    if the center square is occupied by an X, player O is unable to choose the square.
    This update requires a few modifications. To prevent squares from being retaken,
    the *prompt()* function must be updated as well as the game play loop in the *main()*
    function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ttt02.c 代码有很多改进的空间。目前对我来说，优先级是限制游戏只限于网格中的空白方格。例如，如果中心方格被 X 占用，玩家 O 就无法选择该方格。这次更新需要一些修改。为了防止方格被重新占用，必须更新
    *prompt()* 函数以及 *main()* 函数中的游戏循环。
- en: The updated *prompt()* function is shown next. The grid[] array must be passed
    as an argument so that the function can determine whether a square is occupied.
    Further, -1 is added as a return value to flag that a square is occupied or an
    input value is out of range. Otherwise, the return values are 1 through 9 to select
    an open square, or 0 to quit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 *prompt()* 函数如下所示。必须将 grid[] 数组作为参数传递，以便函数能够确定一个方格是否被占用。此外，-1 被添加为返回值，以标记一个方格被占用或输入值超出范围。否则，返回值从
    1 到 9，用于选择一个空方格，或 0 用于退出。
- en: Listing 15.4 The updated *prompt()* function
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.4 更新的`*prompt()*`函数
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Array grid[] is used as pointer variable g here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这里，数组`grid[]`被用作指针变量`g`。
- en: ❷ Informs the user that the value is out of range
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通知用户值超出范围
- en: ❸ Returns -1 for invalid input
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对于无效输入返回-1
- en: ❹ Tests for the 0 to quit here; otherwise, the value is returned and used improperly
    on array grid[]
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在这里测试0以退出；否则，返回值被使用，并在数组`grid[]`上使用不当。
- en: ❺ If the value chosen is occupied, or not zero; note that 1 is subtracted because
    the input is 1 through 9, though the array elements are numbered 0 through 8.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果选择的值已被占用，或者不是零；请注意，减去1，因为输入是1到9，尽管数组元素编号为0到8。
- en: ❻ Informs the user that the square is occupied and to try again
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 通知用户方块已被占用，请重试
- en: ❼ Returns -1 for invalid input
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 对于无效输入返回-1
- en: ❽ Returns the square chosen, which is unoccupied
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 返回选择的方块，该方块是空的
- en: 'To make the updated *prompt()* function work, the statement that calls the
    function must be modified. Bad input must be dealt with right away. Therefore,
    I chose to set the function into a *while* loop, where the return value from *prompt()*
    is the condition:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使更新的`*prompt()*`函数工作，必须修改调用函数的语句。必须立即处理不良输入。因此，我选择将函数放入`*while*`循环中，其中`*prompt()*`的返回值是条件：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *while* loop repeatedly calls the *prompt()* function as long as the value
    returned is -1\. Only valid input—0 or an open square number—breaks the loop.
    The remainder of the *main()* function is unchanged.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`*while*`循环会重复调用`*prompt()*`函数，直到返回值是-1。只有有效的输入——0或开放的方块编号——才会中断循环。`*main()*`函数的其余部分保持不变。'
- en: 'The updated source code is found in the online repository as ttt03.c. Here
    is a sample run:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的源代码可以在在线存储库中找到，作为`ttt03.c`。以下是一个示例运行：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the second move, the program successfully prevents O from choosing X’s square.
    It outputs a message displaying the issue and urges the player to try again.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次移动时，程序成功阻止了O选择X的方块。它输出一条消息显示问题，并敦促玩家再试一次。
- en: 15.2.4 Determining the winner
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.4 确定胜者
- en: The game works so far, with players able to go back-and-forth choosing squares
    and setting their marks. But the code doesn’t know when you’ve won. Further, because
    the game play loop is infinite, eventually you run out of open squares and the
    game doesn’t stop, nor does the program know when to call a tie, or cat’s game.
    Fixing is in order.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏目前运行良好，玩家可以来回选择方块并设置他们的标记。但是代码不知道何时你赢了。此外，由于游戏循环是无限的，最终你会耗尽开放的方块，游戏不会停止，程序也不知道何时叫平局，或者猫的游戏。需要进行修复。
- en: To determine a winner, I wrote the *winner()* function. It examines the eight
    slices through the game grid where a win is possible, as illustrated in figure
    15.4\. For a slice to identify as a winner, all of its squares must contain the
    same value—+1 for X or -1 for O. The total for a given slice must be either +3
    or -3 to win the game.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定胜者，我编写了`*winner()*`函数。该函数检查游戏网格中可能获胜的八个切片，如图15.4所示。为了使一个切片被识别为胜者，它所有的方块必须包含相同的值——X为+1，O为-1。给定切片的总和必须是+3或-3才能赢得游戏。
- en: '![15-04](Images/15-04.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![15-04](Images/15-04.png)'
- en: Figure 15.4 The eight slices defining a win in tic-tac-toe
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 定义井字棋胜利的八个切片
- en: 'The *winner()* function accepts the game grid as an argument. Each square is
    examined as columns, rows, and diagonals, as shown in figure 15.4\. The notation
    to do the math was clunky in the function’s original version. For example, to
    test the left column, I used the following statement:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`*winner()*`函数接受游戏网格作为参数。每个方块都按列、行和对角线进行检查，如图15.4所示。函数原始版本中的数学表示法很笨拙。例如，为了测试左列，我使用了以下语句：'
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Element 0 of the slice[] array holds the total for the first column—squares
    0, 3, and 6\. However, I find the *(g+n) notation to be clumsy and confusing:
    each square is represented by integer pointer g, plus an offset into the array.
    Because I constantly had to refer to a map (see figure 15.1) when writing the
    code, I opted to create some defined constants to reference the various squares
    more easily:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 切片数组`slice[]`的元素0持有第一列的总和——方块0、3和6。然而，我发现`(g+n)`表示法很笨拙且令人困惑：每个方块都由整数指针`g`加上数组中的偏移量表示。因为我编写代码时经常需要参考地图（见图15.1），所以我选择创建一些定义的常量来更容易地引用各种方块：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The mnemonics of these defined constants, also appearing in figure 15.1, make
    it easier to define the slices. They also play a role later in the program’s development,
    when the computer is attempting to block or make a win.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义的常数的助记符，也出现在图15.1中，使定义切片更容易。它们还在程序开发的后期发挥作用，当电脑试图阻止或赢得胜利时。
- en: The next listing shows the *winner()* function. Its argument is the game grid.
    The slice[] array contains the totals of the eight possible winning combinations,
    totaling the values in each of the three squares for each slice. If a slice contains
    all the same tokens, its value is -3 for an O win or +3 for an X win. A *for*
    loop tests these possibilities. When a win occurs, the function returns 1, or
    0 otherwise.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了*winner()*函数。它的参数是游戏网格。slice[]数组包含八种可能的胜利组合的总和，每个切片中三个方格的值总和。如果一个切片包含相同的标记，它的值是-3（O胜利）或+3（X胜利）。一个*for*循环测试这些可能性。当发生胜利时，函数返回1，否则返回0。
- en: Listing 15.5 The *winner()* function
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.5 *winner()*函数
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Eight possible ways to win; the slice[] array holds the totals.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 八种可能的胜利方式；slice[]数组持有总和。
- en: ❷ Tallies the columns, rows, and diagonals for each slice
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算每个切片的列、行和对角线
- en: ❸ Reviews the totals
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 审查总和
- en: ❹ Checks for an O victory
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查O胜利
- en: ❺ Outputs the winning game grid
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出胜利的游戏网格
- en: ❻ Informs the user
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 通知用户
- en: ❼ Exits with 1, meaning a player has 1
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 退出时返回1，表示玩家有1
- en: ❽ Repeats the same sequence for an X victory
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 重复相同的序列以实现X胜利
- en: ❾ Returns 0 if no one has 1
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 如果没有人有1，则返回0
- en: The *winner()* function must be integrated into the *main()* function within
    the game play loop to report a victory. It also provides another way to terminate
    the loop beyond the user typing zero to quit the game.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*winner()*函数必须集成到游戏循环中的*main()*函数内，以报告胜利。它还提供了一种在用户输入0退出游戏之外终止循环的另一种方式。'
- en: After the *winner()* function is added, another change to the game play loop
    is to set a termination condition for the *while* loop. After all, only nine plies
    (turns) are possible for a game of tic-tac-toe, assuming it’s a draw.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加*winner()*函数后，游戏循环的另一个更改是为*while*循环设置一个终止条件。毕竟，井字棋游戏只有九次回合（回合）是可能的，假设是平局。
- en: After the game play loop, I added another if test to determine whether the game
    was a draw. These items are called out in the next code listing, which shows the
    updated code from the *main()* function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环之后，我添加了另一个if测试以确定游戏是否为平局。这些项目在下一个代码列表中列出，显示了*main()*函数的更新代码。
- en: Listing 15.6 Updating the game play loop in the *main()* function
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.6 在*main()*函数中更新游戏循环
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Limits the loop to nine turns
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将循环限制为九次回合
- en: ❷ Calls the *winner()* function, which returns 1 when a win is detected
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用*winner()*函数，当检测到胜利时返回1
- en: ❸ Halts the loop
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 停止循环
- en: ❹ Tests to see whether the loop terminated in a no-win
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 测试循环是否以无胜利结束
- en: ❺ Outputs the grid to show the draw
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出网格以显示平局
- en: ❻ Informs the user
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 通知用户
- en: 'The complete update is found in the online repository as ttt04.c. The game
    now allows two players to compete. It accurately reports a winner and determines
    when the game ends in a draw. Here is sample output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的更新可以在在线仓库中找到，作为ttt04.c。现在游戏允许两名玩家竞争。它准确报告了胜利者，并确定游戏何时以平局结束。以下是示例输出：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Think of all the paper you can save when you play tic-tac-toe on the computer!
    Of course, most users don’t want to play against a human challenger, probably
    because they have no friends. The true foe for a game of tic-tac-toe is . . .
    a computer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 想想当你用电脑玩井字棋时可以节省多少纸张！当然，大多数用户不想与人类挑战者玩游戏，可能是因为他们没有朋友。井字棋游戏的真正对手是……一台电脑。
- en: 15.3 The computer plays
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 电脑玩游戏
- en: In the movie *WarGames*, the genius programmer is asked whether his game of
    tic-tac-toe has a configuration where the computer can play itself. It does. The
    key is to enter zero for the number of players. The computer plays itself, realizes
    that the game is futile, and we go to DEFCON 5.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影《战争游戏》中，天才程序员被问及他的井字棋游戏是否有电脑可以自己玩的游戏配置。有的。关键是输入玩家数量为0。电脑自己玩，意识到游戏毫无意义，然后我们进入DEFCON
    5。
- en: 'Obviously, anyone who codes a computer version of tic-tac-toe is compelled
    to provide the same “number of players equals zero” option available to our intrepid
    cinematic heroes. Who doesn’t want to see the computer battle wits with itself?
    This feature not only makes the game more interesting but also tests the programmer’s
    logic: when the computer plays against itself, does the game always end in a draw?'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，任何编写井字棋计算机版本的程序员都会被迫提供与我们的勇敢电影英雄相同的“玩家数量为零”的选项。谁不想看到计算机与自身斗智呢？这个功能不仅使游戏更有趣，而且考验程序员的逻辑：当计算机与自身对战时，游戏是否总是以平局结束？
- en: 15.3.1 Choosing the number of players
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1 选择玩家数量
- en: The decision tree required to set the number of players for the tic-tac-toe
    program certainly is ugly. I tried making it beautiful, but with three options
    to sift through, the coding choices are limited.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为井字棋程序设置玩家数量的决策树确实很丑陋。我尝试让它变得美观，但面对三个选项进行筛选，编码选择有限。
- en: 'The prompt is easy enough to code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 提示输入很容易编写：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Set in the *main()* function, immediately after the program’s title is output,
    the prompt asks for the number of players: 0, 1, or 2\. If an invalid number is
    input, the program quits.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *main()* 函数中设置，程序标题输出后立即提示输入玩家数量：0、1 或 2。如果输入无效数字，程序将退出。
- en: 'In the game play loop, however, decisions are made based on the number of players:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在游戏循环中，决策是基于玩家数量的：
- en: When the number of players is 0, the computer plays every turn.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家数量为 0 时，计算机进行每一轮。
- en: When the number of players is 1, the computer alternates every other turn.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家数量为 1 时，计算机轮流进行每轮。
- en: When the number of players is 2, humans take turns, as in the ttt04.c version
    of the game.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家数量为 2 时，人类轮流进行，就像游戏 ttt04.c 版本一样。
- en: The following listing shows the updated *main()* function. The number of players
    is input, and then an *if-else* contraption sifts through the players, ensuring
    that human and computer take their turns. If the player count is 1, play alternates
    between computer and player, with the player going first.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了更新的 *main()* 函数。输入玩家数量，然后一个 *if-else* 结构筛选玩家，确保人类和计算机轮流进行。如果玩家数量为 1，游戏在计算机和玩家之间交替进行，玩家先手。
- en: Listing 15.7 The updated *main()* function
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.7 更新的 *main()* 函数
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '❶ Variable players tracks the number of players: 0, 1, or 2.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 变量 players 跟踪玩家数量：0、1 或 2。
- en: ❷ Seeds the randomizer for computer play
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为计算机游戏设置随机种子
- en: ❸ Prompts for input
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提示输入
- en: ❹ Exits the program upon invalid input
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在无效输入时退出程序
- en: ❺ Zero players are specified.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 未指定玩家数量。
- en: ❻ The computer always plays itself, every turn.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 计算机始终自己玩，每轮都如此。
- en: ❼ One player is specified.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 指定一个玩家。
- en: ❽ On odd turns, the computer plays.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 在奇数回合，计算机进行游戏。
- en: ❾ The *prompt()* function handles the player’s turn.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ *prompt()* 函数处理玩家的回合。
- en: ❿ For two players, the *prompt()* function handles both turns.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 对于两位玩家，*prompt()* 函数处理两个回合。
- en: The *computer()* function handles the computer’s play, even when both players
    are the computer. The *prompt()* function deals with human player interaction.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*computer()* 函数处理计算机的玩法，即使两个玩家都是计算机。*prompt()* 函数处理人类玩家的交互。'
- en: The code isn’t done. The *computer()* function must be written, which is covered
    in the next section. To complete the update from this section, however, you must
    add directives to include the stdlib.h and time.h header files, which support
    the *srand()* statement in the *main()* function, as well as the *rand()* statement
    in the *computer()* function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 代码尚未完成。必须编写 *computer()* 函数，这将在下一节中介绍。然而，为了完成本节的更新，你必须添加指令以包含 stdlib.h 和 time.h
    头文件，这些文件支持 *main()* 函数中的 *srand()* 语句，以及 *computer()* 函数中的 *rand()* 语句。
- en: 15.3.2 Coding a dumb opponent
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2 编写一个愚蠢的对手
- en: At this point in the game’s development, the *computer()* function need not
    harbor insidious intelligence nor an intimate knowledge of how to win the game.
    So, I coded a purely random selection routine, as shown in the next listing. The
    function tests for an available random square in the grid and sets its token at
    that location. The random value is returned—in a range compatible with the human
    player’s choice—where the token is set in the *main()* function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发的这个阶段，*computer()* 函数不需要隐藏狡猾的智慧或对如何赢得游戏的深入了解。因此，我编写了一个纯随机选择程序，如下一列表所示。该函数检查网格中是否有可用的随机方格，并在该位置设置其标记。随机值返回——与人类玩家选择兼容的范围内——在
    *main()* 函数中将标记设置在。
- en: Listing 15.8 The *computer()* function
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.8 *computer()* 函数
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Generates a random value, 0 through 8
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成一个随机值，0 到 8
- en: ❷ Confirms that the square is empty, or keeps looping otherwise
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确认方格是空的，否则继续循环
- en: ❸ Increments the square value for humans as well as for consistency with the
    *prompt()* function
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为人类玩家以及与 *prompt()* 函数的一致性增加方格值
- en: ❹ Informs the user
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通知用户
- en: The complete code, including the updated *main()* function from the preceding
    section as well as the *computer()* function, is available in the online repository
    as ttt05.c.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码，包括上一节更新的 *main()* 函数以及 *computer()* 函数，可以在在线仓库中找到，文件名为 ttt05.c。
- en: 'At this point in the program’s evolution, the computer always goes second,
    playing O for its moves. Here is some sample output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序演化的这个阶段，电脑总是第二个出手的，用 O 表示其移动。以下是一些示例输出：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s possible to attribute some intelligence to the admittedly dumb *computer()*
    function, but nothing of the sort exists. I’d provide a sample run that makes
    you believe the computer is smart, but instead run the code on your own, setting
    0 as the number of players, and review the output. Occasionally, it seems like
    the computer is being smart. Trust me—it’s not.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以给承认愚蠢的 *computer()* 函数增加一些智能，但事实上并没有这样的东西。我会提供一个示例运行，让你相信电脑很聪明，但相反，你应该自己运行代码，将玩家数量设置为
    0，并查看输出。偶尔，电脑看起来像是聪明的。相信我——它不是。
- en: Exercise 15.1
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 15.1
- en: 'The computer complains that it’s unfair that it always goes second in a one-on-one
    battle. To remedy this situation, update the *main()* function from ttt05.c so
    that a random choice is made, determining which player goes first: computer or
    human.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 电脑抱怨说，在一对一的对战中，它总是第二个出手的，这很不公平。为了解决这个问题，更新 ttt05.c 中的 *main()* 函数，以便进行随机选择，确定哪个玩家先出手：电脑或人类。
- en: 'Here is the first part of the output from my solution:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我解决方案输出的第一部分：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The random choice of who goes first is required only when one player is selected,
    a human-versus-computer battle. My solution is found in the online repository
    as ttt06.c.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个玩家被选中，即人机对战时，才需要随机选择谁先出手。我的解决方案可以在在线仓库中找到，文件名为 ttt06.c。
- en: 15.3.3 Adding some intelligence
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3 增加一些智能
- en: Most of the nerds who program a computer to play tic-tac-toe use a game tree.
    They plot every move and its consequences, all 120 or so permutations of the game.
    I looked into this approach, but it seemed like a lot of work. Being lazy, I instead
    rolled my own approach for the computer to play, and hopefully win, tic-tac-toe.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编写电脑玩井字棋的程序员都使用游戏树。他们绘制每一个移动及其后果，所有大约 120 种游戏排列。我也考虑了这种方法，但感觉工作量很大。由于懒惰，我为电脑玩井字棋并希望获胜想出了一个自己的方法。
- en: 'My code has three pieces of intelligence for the computer player. First, if
    it’s the first turn (ply zero) and the computer moves first, it should snag the
    center square. This update is made to the *computer()* function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我的代码为电脑玩家提供了三个智能点。首先，如果它是第一个回合（回合值为 0）并且电脑先出手，它应该抓住中心方格。这个更新是针对 *computer()*
    函数的：
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Variable p is the current ply value from the game play loop in the *main()*
    function. When its value is 0, the computer is taking the first turn and all squares
    are open. A message is output, and the function returns 5, the center square.
    The value should be 4, because this is the offset in the grid[] array, but the
    *computer()* function must be compatible with the user’s *prompt()* function and
    return values in the range 1 through 9\. (Remember that *prompt()* returns 0 to
    quit the game.)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 p 是 *main()* 函数中游戏循环的当前回合值。当其值为 0 时，电脑是第一个出手的，所有方格都是开放的。输出一条消息，并函数返回 5，即中心方格。这个值应该是
    4，因为这是 grid[] 数组中的偏移量，但 *computer()* 函数必须与用户的 *prompt()* 函数兼容，并返回 1 到 9 范围内的值。（记住，*prompt()*
    返回 0 以退出游戏。）
- en: 'This *if* test can be improved to check the center square during the second
    ply: if the computer goes second but its human opponent is too stupid to grab
    the center square, it should take it. Here is the update to the if decision:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 *if* 测试可以改进为在第二回合检查中心方格：如果电脑是第二个出手的，但它的对手太笨拙而无法抓住中心方格，它应该去占据它。以下是 if 决策的更新：
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The *if* condition reads, “If it’s the first turn—or if it’s the second turn
    and the center square (MC) remains empty—grab the center square.” The center square
    is a position of strength in this game. In fact, taking the center is one of the
    first tricks a kid learns when first playing tic-tac-toe.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*if* 条件读取为：“如果是第一回合——或者如果是第二回合且中心方格（MC）仍然是空的——则占据中心方格。”在这个游戏中，中心方格是一个强势位置。事实上，占据中心是孩子在第一次玩井字棋时学会的第一个技巧。'
- en: 'The second iota of intelligence is to play a corner square when the center
    square is taken. This move provides the best defense when moving second. The *if*
    decision here is an easy one:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第二项智慧是在中心方块被占据时玩一个角落方块。这个移动在第二个移动时提供了最好的防御。这里的 *if* 决定很简单：
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The *if* condition reads, “If it’s the second ply (turn) and the top-left (TL)
    square is empty, take it.” The value 1 is returned. At this point in the *computer()*
    function, the center square has already been taken—guaranteed. The preceding *if*
    condition rules out MC as anything other than 0\. Therefore, on the second ply,
    p==1, the top-left (TL) square is most likely empty. The *if* condition tests
    for it anyway and defensively moves to the top-left square.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*if* 条件读取：“如果是第二个回合（回合）且左上角（TL）方块为空，则取它。”返回值 1。在 *computer()* 函数的这个点，中心方块已经被占据——这是保证的。前面的
    *if* 条件排除了 MC 不是 0 的可能性。因此，在第二个回合，p==1，左上角（TL）方块最可能是空的。*if* 条件仍然测试它，并防御性地移动到左上角方块。'
- en: The third piece of intelligence consists of a game grid scan for moves to block
    or moves to win. Before the computer resorts to a random move, it scans all eight
    possible winning slices on the game grid. If any of these slices contains two
    of the same tokens plus an empty square, the empty square is filled so that the
    computer wins or blocks a win.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第三项智慧是扫描游戏网格以寻找阻止或获胜的移动。在计算机求助于随机移动之前，它会扫描游戏网格上所有八个可能的获胜切片。如果这些切片中的任何一个包含两个相同的标记加上一个空方块，则填充空方块，以便计算机获胜或阻止获胜。
- en: 'I originally wrote two functions, *towin()* and *toblock()*, to carry out the
    game grid scan. Eventually, it dawned on me that both functions work the same,
    just look for different values. The *towin()* function wants the computer’s tokens
    to add up to 2 or -2; the *toblock()* function wants the opponent’s tokens to
    add up to 2 or -2\. I wrote the *three()* function to handle both conditions:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初写了两个函数，*towin()* 和 *toblock()*，用于执行游戏网格扫描。最终，我意识到这两个函数工作方式相同，只是查找不同的值。*towin()*
    函数希望计算机的标记总和为 2 或 -2；*toblock()* 函数希望对手的标记总和为 2 或 -2。我编写了 *three()* 函数来处理这两种情况：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The function’s arguments are g, the game grid, and p, the token to look for:
    -1 for O and +1 for X.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数是 g，游戏网格，和 p，要查找的标记：-1 代表 O，+1 代表 X。
- en: 'The *three()* function’s statements are repetitive, with each block representing
    one of the eight slices that establish a win. Defined constants shown earlier
    in this chapter represent the specific squares. Here is a typical block:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*three()* 函数的语句是重复的，每个块代表建立胜利的八个切片中的一个。在本章前面定义的常量代表特定的方块。以下是一个典型的块：'
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Defined constants TL, ML, and BL represent the first column in the grid. If
    their total is equal to two times variable p, the column contains two matching
    tokens and a blank. This result holds true whether p is -1 for O or +1 for X.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了常量 TL、ML 和 BL 代表网格的第一列。如果它们的总和等于变量 p 的两倍，则该列包含两个匹配的标记和一个空白。无论 p 是 -1 代表 O
    还是 +1 代表 X，这个结果都成立。
- en: 'After a slice is identified as a potential win or block, the function returns
    a value representing the blank square: If it’s the top-left square, TL, 0 is returned.
    If the middle-left square is blank, ML==0, its offset is returned. This logic
    allows the computer to either win or block, depending on the value of variable
    p.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定一个切片为潜在的获胜或阻止后，函数返回一个表示空白方块的值：如果是左上角方块，则返回 TL，0。如果中间左边的方块为空，ML==0，则返回其偏移量。这种逻辑允许计算机根据变量
    p 的值获胜或阻止。
- en: The *three()* function continues with similar tests for each of the eight slices.
    The value returned is the square to choose, reported to the *computer()* function
    shown in the next listing. The code first checks for a win, and then for a block.
    If neither test is successful (-1 is returned), the computer randomly chooses
    an available square, as before.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*three()* 函数继续对八个切片中的每一个进行类似的测试。返回的值是要选择的方块，报告给下一个列表中显示的 *computer()* 函数。代码首先检查获胜，然后检查阻止。如果这两个测试都不成功（返回
    -1），则计算机随机选择一个可用的方块，就像以前一样。'
- en: Listing 15.9 The updated *computer()* function
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.9 更新的 *computer()* 函数
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Variable p is the current ply and g is the game grid.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 变量 p 是当前回合，g 是游戏网格。
- en: ❷ Grabs the center square if it’s empty
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果中心方块为空，则抓取它
- en: ❸ On the second turn, grabs the corner square if it’s empty
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在第二轮，如果角落方块为空，则抓取它
- en: '❹ Detects a win using the ply value: 0 means it’s O’s turn, 1 for X.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用回合值检测获胜：0 代表 O 的回合，1 代表 X。
- en: ❺ Checks for a win for O (-1)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查 O 的获胜（-1）
- en: ❻ Checks for a win for X (+1)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查 X 的获胜（+1）
- en: ❼ If a win isn’t detected, *three()* returns -1; checks for a block (you want
    to win before you block).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有检测到胜利，*three()* 返回 -1；检查是否有阻挡（你希望在阻挡之前获胜）。
- en: ❽ Determines whether X or O is moving next
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 确定下一个是 X 还是 O 在移动
- en: ❾ Blocks for X
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 为 X 阻挡
- en: ❿ Blocks for O
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 为 O 阻挡
- en: ⓫ If r is equal to -1e, the computer hasn’t won or blocked; time for a random
    square pick.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 如果 r 等于 -1e，计算机没有获胜或阻挡；是时候随机选择一个格子了。
- en: ⓬ Increments r to represent the proper offset, 1 through 9
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 将 r 增加以表示适当的偏移量，1 到 9
- en: ⓭ Informs the user
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 通知用户
- en: 'The smarts in the *computer()* function work from the top down: first comes
    the center square check, and then the computer tries to grab the corner square.
    After that, the *three()* function is checked first to win and then to block.
    When these efforts fail, shown by the value -1 returned, the computer uses the
    randomizer.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*computer()* 函数中的智能从上到下工作：首先是中心格检查，然后计算机尝试抓住角落格。之后，首先检查 *three()* 函数以获胜，然后以阻挡。当这些努力失败时，返回值
    -1 显示，计算机使用随机数生成器。'
- en: 'The *main()* function must also be updated, reflecting the new argument for
    the *computer()* function. Two updates are required to modify this statement:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*main()* 函数也必须更新，以反映 *computer()* 函数的新参数。需要两个更新来修改这个语句：'
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'into this statement:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 进入这个语句：
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The ply argument is used in the *computer()* function for its call to the *three()*
    function. It’s this variable’s value that determines whether the function is blocking
    or winning because, in the program, X always moves first.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *computer()* 函数中，ply 参数用于调用 *three()* 函数。因为这个变量的值决定了函数是阻挡还是获胜，因为在程序中，X 总是先走。
- en: All changes, including the full *three()* function, are found in the online
    repository in the source code file ttt07.c. The computer player isn’t perfectly
    intelligent, but it’s smart enough to prove a challenge—for at least a few games
    and definitely to defeat a small child or stupid adult.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所有更改，包括完整的 *three()* 函数，都可以在在线仓库的源代码文件 ttt07.c 中找到。计算机玩家并不完美聪明，但足够聪明，可以构成挑战——至少在几场比赛中，肯定可以击败一个小孩或愚蠢的成人。
- en: 'The true test, of course, is when the computer plays itself. In theory, it
    should tie each time. But the program still uses random-number generation to plot
    its initial game. Specifically, in the computer-to-computer output shown here,
    see how the computer grabs the center square as well as the upper-left square?
    These are advantageous and defensive moves, respectively:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，真正的测试是在计算机与自己对战时。理论上，它应该每次都平局。但程序仍然使用随机数生成来规划其初始游戏。具体来说，在下面显示的计算机对计算机输出中，看看计算机如何抓住中心格以及左上角格？这些是优势性和防御性移动：
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: From the output, you can see that the computer did well against itself. It’s
    not exactly smart, but it’s challenging enough—and the game ended in a tie.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，你可以看到计算机在与自己对战时表现不错。它并不特别聪明，但挑战性足够大——游戏以平局结束。
- en: Further updates to the code at this point would lead to a game tree strategy,
    where you map out the best second, third, and fourth moves in a complex tree decision
    structure-thing. At some point, however, playing the game employs the tactics
    of blocking and winning.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上对代码的进一步更新将导致游戏树策略，其中你在一个复杂的树形决策结构中规划最佳的第二、第三和第四步。然而，在某个时候，玩游戏会采用阻挡和获胜的策略。
- en: One devious improvement I considered was to have the computer cheat. It could,
    for example, replace an opponent’s token with its own or prevent an opponent from
    selecting a winning square. Though such a modification would be fun, it involves
    rewriting a lot of the existing code. I leave this task up to you, though not
    as an official exercise.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我考虑的一个狡猾的改进是让计算机作弊。例如，它可以替换对手的棋子或阻止对手选择一个获胜的格子。尽管这样的修改很有趣，但它涉及到重写大量现有的代码。不过，这个任务就留给你们了，虽然不是正式的练习。
