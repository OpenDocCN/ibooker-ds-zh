- en: 7 Integration with systemd
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 与systemd的集成
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Running systemd within the container as the primary process
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中将systemd作为主进程运行
- en: Generating systemd unit files from existing containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有容器生成systemd单元文件
- en: Socket-activated containerized services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 套接字激活的容器化服务
- en: Using `sd-notify` containerized services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sd-notify`容器化服务
- en: The advantages of using journald as a logging driver and events backend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用journald作为日志驱动程序和事件后端的优势
- en: Using Podman and systemd to manage containerized services’ life cycles on edge
    devices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Podman和systemd管理边缘设备上容器化服务的生命周期
- en: Systemd is the de facto init system for Linux. Almost every distribution of
    Linux defaults to systemd as the first process launched after the kernel, which
    then launches all of the services, including the login sessions for the user.
    Podman embraces the power of systemd and uses it for starting up lots of its services.
    When starting containerized services at boot time, Podman encourages users to
    use systemd unit files with Podman commands. Unit files are what systemd calls
    its configuration files. Systemd supports a few different types of unit files,
    including service files in which you can define a service, which you would want
    systemd to manage. A SystemD.socket is another kind of unit file systemd uses
    (see section 7.6). The systemd service unit files are a way to share your containerized
    service with the world. As you see in figure 7.1, Podman’s fork/exec model grants
    systemd the ability to track the processes within a containerized service.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd是Linux的事实上的初始化系统。几乎每个Linux发行版都将systemd作为内核启动后的第一个进程默认启动，然后启动所有服务，包括用户的登录会话。Podman拥抱systemd的力量，并使用它来启动许多服务。在启动引导时的容器化服务时，Podman鼓励用户使用systemd单元文件与Podman命令一起使用。单元文件是systemd所说的配置文件。Systemd支持几种不同类型的单元文件，包括可以定义服务的服务文件，你希望systemd管理这些服务。SystemD.socket是systemd使用的另一种类型的单元文件（见第7.6节）。systemd服务单元文件是向世界分享你的容器化服务的一种方式。如图7.1所示，Podman的fork/exec模型赋予了systemd跟踪容器化服务内进程的能力。
- en: '![](../../OEBPS/Images/07-01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-01.png)'
- en: Figure 7.1 Systemd executing a Podman container
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 Systemd执行Podman容器
- en: Systemd puts all the processes within a unit file service (called a scope) into
    the same cgroup hierarchy. It then uses the PID cgroup to keep track of all the
    processes and uses this information to manage the service. Container engines that
    use client-server methodology prevent systemd from keeping track of the containerized
    processes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd将一个单元文件服务（称为作用域）内的所有进程放入相同的cgroup层次结构中。然后它使用PID cgroup来跟踪所有进程，并使用这些信息来管理服务。使用客户端-服务器方法的容器引擎阻止systemd跟踪容器化进程。
- en: Podman also takes advantage of other services, as you will see in this chapter,
    to handle auto-restarting containers, auto-updating, and basic management of containerized
    services. You will be exposed to many Podman and systemd features in this chapter,
    but first you will run systemd within a Podman container.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Podman也利用了其他服务，正如你将在本章中看到的，来处理容器的自动重启、自动更新以及容器化服务的常规管理。在本章中，你将接触到许多Podman和systemd的功能，但首先你将在Podman容器中运行systemd。
- en: 7.1 Running systemd within a container
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 在容器中运行systemd
- en: When containerization was first becoming popular, many evangelists taught the
    concept of microservices. A *microservice* is defined as one specialized service
    within a container. This single service runs as the initial PID (PID 1) within
    the containers and writes its logs directly to `stdout` and `stderr`. Kubernetes
    assumes microservices, and thus gathers logs from the `stdin`/`stderr` of the
    containers it runs. Figure 7.2 shows Podman running microservices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器化技术刚开始流行时，许多传教士教授了微服务概念。*微服务*被定义为容器中的一个专业服务。这个单一的服务作为容器中的初始PID（PID 1）运行，并将其日志直接写入`stdout`和`stderr`。Kubernetes假设微服务，因此从它运行的容器中收集`stdin`/`stderr`的日志。图7.2显示了Podman运行微服务。
- en: '![](../../OEBPS/Images/07-02.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-02.png)'
- en: Figure 7.2 Podman running three microservices
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 Podman运行三个微服务
- en: An alternative idea was to run systemd as the initial PID within the container
    and then allow systemd to start one or more services within the container. This
    school of thought argues that containerized services are to be launched the same
    way they are launched within a VM. Because service package designers (e.g., RPM
    and APT) develop systemd unit files as a precise way of launching their services
    within the OS, container developers should take advantage of these unit files.
    This approach allows running multiple services within the same container, taking
    advantage of local communications paths, and speeding up the conversion of large
    multiservice applications into a container and then, over time, breaking each
    service into its own microservice.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个想法是在容器内以初始 PID 运行 systemd，然后允许 systemd 在容器内启动一个或多个服务。这种观点认为，容器化服务应以与在虚拟机内启动相同的方式启动。因为服务包设计者（例如，RPM
    和 APT）将 systemd 单元文件作为在操作系统内启动其服务的一种精确方式，容器开发者应该利用这些单元文件。这种方法允许在同一个容器内运行多个服务，利用本地通信路径，并加快将大型多服务应用程序转换为容器，然后随着时间的推移，将每个服务分解为其自己的微服务。
- en: A final huge advantage of systemd in a container is that the init system handles
    the cleaning up of a zombie process. In Linux, when a process exits, the kernel
    sends the signal `SIGCHLD` to the parent process, and the parent process is supposed
    to collect the exit status of the exiting process. The kernel removes the process
    from the system when the parent reads the exit status. If no parent process reads
    the exit status, the exited process is left in the exited status and is referred
    to as a *zombie process*. The init system, systemd, reaps most processes on the
    system. In containers, the initial process running within the container is supposed
    to reap these processes. Sometimes container processes exit, and if PID1 does
    not reap them, they just linger and never disappear.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 在容器中的最后一个巨大优势是 init 系统处理僵尸进程的清理。在 Linux 中，当进程退出时，内核向父进程发送信号 `SIGCHLD`，父进程应该收集退出进程的退出状态。当父进程读取退出状态时，内核从系统中删除该进程。如果没有父进程读取退出状态，退出的进程将保留在退出状态，被称为
    *僵尸进程*。init 系统，systemd，回收系统中的大多数进程。在容器中，容器内运行的初始进程应该回收这些进程。有时容器进程会退出，如果 PID1 不回收它们，它们就会徘徊，永远不会消失。
- en: Note The `podman-run` command supports an `–init` option, which will launch
    a tiny init program just to reap the zombie processes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`podman-run` 命令支持 `–init` 选项，该选项将启动一个微小的 init 程序，专门用于回收僵尸进程。
- en: Podman was designed to support both methods—microservices as well as multiservice
    containers. Figure 7.3 shows systemd running a multiservice application within
    a container.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 被设计为支持两种方法——微服务和多服务容器。图 7.3 显示了 systemd 在容器内运行多服务应用程序。
- en: '![](../../OEBPS/Images/07-03.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-03.png)'
- en: Figure 7.3 Podman running systemd in a container with three services
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 Podman 在容器中运行 systemd 并包含三个服务
- en: Podman examines the `cmd` option of a container and then launches systemd for
    init or system. It then automatically launches the container in systemd mode.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 检查容器的 `cmd` 选项，然后启动 systemd 以进行 init 或系统。然后它自动以 systemd 模式启动容器。
- en: 'The following list shows all the commands that trigger Podman to run in systemd
    mode:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了所有触发 Podman 在 systemd 模式下运行的命令：
- en: /sbin/init
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /sbin/init
- en: /usr/sbin/init
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /usr/sbin/init
- en: /usr/local/sbin/init
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /usr/local/sbin/init
- en: /*/systemd (any path ending with the systemd command)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /*/systemd（任何以 systemd 命令结尾的路径）
- en: The registry.access.redhat.com/ubi8-init image is an example of an image intended
    to run in systemd mode.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: registry.access.redhat.com/ubi8-init 图像是一个旨在以 systemd 模式运行的图像示例。
- en: 'Pull down the ubi8-init image, and examine the command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 ubi8-init 图像，并检查命令：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Systemd requires the environment to be configured in a certain way; otherwise,
    systemd attempts to correct the environment. The next section explains how Podman
    satisfies systemd requirements.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 需要环境以某种方式配置；否则，systemd 会尝试纠正环境。下一节将解释 Podman 如何满足 systemd 的要求。
- en: 7.1.1 Containerized systemd requirements
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 容器化 systemd 要求
- en: Systemd makes some assumptions about the environment it starts in, like /run
    and /tmp need to have tmpfs mounted on them. When the environment is incorrect,
    systemd attempts to correct it by mounting tmpfs on /run and /tmp. Mounting requires
    `CAP_SYS_ADMIN` privilege within the container, which is not allowed in unprivileged
    containers. Systemd then blows up.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 对其启动的环境做出一些假设，例如 /run 和 /tmp 需要挂载上 tmpfs。当环境不正确时，systemd 会尝试通过在 /run
    和 /tmp 上挂载 tmpfs 来纠正它。挂载需要在容器内具有 `CAP_SYS_ADMIN` 权限，这在非特权容器中是不允许的。然后 systemd 会崩溃。
- en: To fix this problem, after examining the entry point and `CMD` of a container
    image to see if they are running systemd, Podman modifies the container environment
    to match systemd expectations. When systemd sees the mounts, it skips them, allowing
    systemd to run within a locked-down environment. Table 7.1 describes the requirements
    systemd needs and Podman provides to successfully run within an unprivileged container.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在检查容器镜像的入口点和 `CMD` 以查看它们是否运行 systemd 之后，Podman 修改容器环境以匹配 systemd 的期望。当
    systemd 看到挂载时，它会跳过它们，允许 systemd 在锁定环境中运行。表 7.1 描述了 systemd 需要的要求和 Podman 提供的要求，以便在非特权容器中成功运行。
- en: Table 7.1 Systemd requirements for running within a nonprivileged container
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 在非特权容器中运行 systemd 的要求
- en: '| Systemd expectations | Description |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| Systemd expectations | 描述 |'
- en: '| /run on a tmpfs | Systemd requires /run to have a tmpfs mounted on it. If
    /run is not mounted with a tmpfs, systemd will attempt to mount a tmpfs on /run.
    A default locked-down container is prevented from mounting, so systemd will fail.
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| /run on a tmpfs | systemd 需要挂载在 /run 上的 tmpfs。如果 /run 没有使用 tmpfs 挂载，systemd
    将尝试在 /run 上挂载一个 tmpfs。默认的锁定容器被阻止挂载，因此 systemd 将失败。|'
- en: '| /tmp on a tmpfs | Similarly to /run, systemd will attempt to mount a tmpfs
    on /tmp, if there is not already one mounted there. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| /tmp on a tmpfs | 类似于 /run，systemd 将尝试在 /tmp 上挂载一个 tmpfs，如果那里还没有挂载的话。|'
- en: '| /var/log/journald as a tmpfs | Systemd within the container expects to be
    able to write to /var/log/journald, so Podman mounts a tmpfs to make this possible.
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| /var/log/journald as a tmpfs | 容器内的 systemd 期望能够写入 /var/log/journald，因此 Podman
    挂载一个 tmpfs 来实现这一点。|'
- en: '| `container` environment variable | Systemd uses the fact that a `container`
    environment variable is set to change some of its default behavior, making it
    run better within a container. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `container` environment variable | systemd 利用 `container` 环境变量已设置的事实来改变其一些默认行为，使其在容器内运行得更好。|'
- en: '| `STOPSIGNAL=SIGRTMIN+3` | Unlike most processes on a system, systemd ignores
    `SIGTERM` and will only cleanly exit with it when it receives the signal `SIGRTMIN+3
    (37)`. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `STOPSIGNAL=SIGRTMIN+3` | 与系统上的大多数进程不同，systemd 忽略 `SIGTERM`，并且只有在接收到信号 `SIGRTMIN+3
    (37)` 时才会干净地退出。|'
- en: 7.1.2 Podman container in systemd mode
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 Podman 容器在 systemd 模式下
- en: 'You can examine the environment of a systemd-based container with the `--systemd
    =always` flag. First, launch a container with systemd mode enabled with the `--systemd=always`
    flag. This option runs the container in systemd mode even when not running systemd,
    making it easier to debug the environment. You can `exec systemd` at this point
    and start it as PID1:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `--systemd =always` 标志检查基于 systemd 的容器的环境。首先，使用 `--systemd=always` 标志启动一个启用
    systemd 模式的容器。此选项即使在未运行 systemd 的情况下也会以 systemd 模式运行容器，这使得调试环境更容易。您现在可以 `exec
    systemd` 并将其作为 PID1 启动：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use `podman` `inspect` to examine the `StopSignal` for the container; Podman
    set it to `37` `(SIGRTMIN+3)`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `podman` `inspect` 检查容器的 `StopSignal`；Podman 将其设置为 `37` `(SIGRTMIN+3)`：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, start up the container, and look at the mounts for /run and /tmp; you
    will see that both are mounted with a tmpfs. Finally, check to see if the container
    environment variable is set:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动容器，查看 /run 和 /tmp 的挂载情况；您将看到两者都使用 tmpfs 挂载。最后，检查容器环境变量是否已设置：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you just run a container based on `ubi8-init`, you will see systemd launched:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仅运行基于 `ubi8-init` 的容器，您将看到 systemd 启动：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here you can notice that systemd ignores `SIGTERM` by pressing Ctrl-C. So to
    stop this container you need to go to a different terminal and execute
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以注意到 systemd 通过按 Ctrl-C 忽略 `SIGTERM`。因此，要停止此容器，您需要进入不同的终端并执行
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This causes Podman to send the proper `STOPSIGNAL` `(SIGRTMIN+3)` to systemd
    in the container. Systemd will shut down instantly when it receives this signal.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致 Podman 向容器中的 systemd 发送正确的 `STOPSIGNAL` `(SIGRTMIN+3)`。当 systemd 收到此信号时，它会立即关闭。
- en: Now that you understand what systemd requires, it is time to create a service
    systemd will run. In the following section, you will build a systemd-based Apache
    service that will run with systemd within the container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 systemd 的要求，是时候创建一个 systemd 将要运行的服务了。在下面的章节中，你将构建一个基于 systemd 的 Apache
    服务，该服务将在容器内与 systemd 一起运行。
- en: 7.1.3 Running an Apache service within a systemd container
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 在 systemd 容器内运行 Apache 服务
- en: In this section, you will create a Containerfile that uses ubi8-init as the
    base image and then install Apache `httpd`. Finally, you will enable this service
    and set up the Apache script we have been working with.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个 `Containerfile`，使用 `ubi8-init` 作为基础镜像，然后安装 Apache `httpd`。最后，你将启用此服务并设置我们一直在使用的
    Apache 脚本。
- en: 'Create a Containerfile:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `Containerfile`：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Recall that the `FROM` `ubi8-init` line will tell Podman to use the ubi8-init
    image as the base image for your new image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`FROM` `ubi8-init` 这行命令将告诉 Podman 使用 `ubi8-init` 镜像作为新镜像的基础镜像：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `RUN` `dnf` `-y` `install` `httpd;` `dnf` `-y` `clean` `all` line tells
    Podman to run a container that executes the `dnf` command and install the `httpd`
    package on top of the `ubi8-init` image. The second `dnf` command removes excess
    files and logs `dnf` created while installing, as there is no reason to include
    these in the image:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN` `dnf` `-y` `install` `httpd;` `dnf` `-y` `clean` `all` 这行命令告诉 Podman
    运行一个容器，执行 `dnf` 命令并在 `ubi8-init` 镜像上安装 `httpd` 软件包。第二个 `dnf` 命令删除多余的文件并记录安装过程中创建的
    `dnf` 日志，因为这些文件没有必要包含在镜像中：'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final `RUN` `systemctl` `enable` `httpd.service` command tells Podman to
    launch another build container and execute the `systemctl` command to enable the
    `httpd` `.service`. When systemd runs on a container created from the newly created
    image, the `httpd` service will be started:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `RUN` `systemctl` `enable` `httpd.service` 命令告诉 Podman 启动另一个构建容器并执行 `systemctl`
    命令以启用 `httpd` `.service`。当 systemd 在从新创建的镜像创建的容器上运行时，`httpd` 服务将被启动：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now build the image using `podman` `build`, and name the image `my-systemd`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用 `podman` 的 `build` 命令构建镜像，并将镜像命名为 `my-systemd`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now run a container on this systemd-based container image with a volume mounted
    from the host. Since the default Apache package listens on port `80`, use `--p`
    `8080:80`, which, as you learned, maps port `8080` to port `80` within the container.
    Use an html folder with index.xhtml from section 3.1:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行一个基于 systemd 的容器镜像，并从主机挂载一个卷。由于默认的 Apache 软件包监听端口 `80`，使用 `--p` `8080:80`，正如你所学的，这会将端口
    `8080` 映射到容器内的端口 `80`。使用来自第 3.1 节的 html 文件夹和 index.xhtml 文件：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You volume mounted `(-v` `./html/:/var/www/html:Z)` in the ./html directory,
    with the goodbye world index.xhtml file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 ./html 目录中挂载了卷 `(-v` `./html/:/var/www/html:Z)`，并包含 goodbye world index.xhtml
    文件：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Launch a web browser to check whether the containerized service is working
    (as seen in figure 7.4):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个网页浏览器来检查容器化服务是否正常工作（如图 7.4 所示）：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../../OEBPS/Images/07-04.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-04.png)'
- en: Figure 7.4 Web browser window showing system-based container image running your
    content
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 显示基于系统容器的镜像运行你的内容的网页浏览器窗口
- en: Notice that you did not need to specially handle the HTTPD server processes
    when designing the image; your container is running HTTPD the same way a VM would.
    If you need to enable another service within the image, you can easily do this
    by installing the package and enabling its unit file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在设计镜像时，你不需要特别处理 HTTPD 服务器进程；你的容器以与虚拟机相同的方式运行 HTTPD。如果你需要在镜像内启用另一个服务，你可以通过安装软件包并启用其单元文件轻松地做到这一点。
- en: 'To see one of the shortcomings of this setup, you can run the `podman` `logs`
    command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这种设置的不足之处，你可以运行 `podman` 的 `logs` 命令：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is no output. Since systemd is running at the PID1 of the container, it
    is not writing any output to the logs. You need to exec into the container and
    use `journalctl` or read the `httpd` logs in /var/log/httpd/error_log to see if
    there were any problems. Now that you have seen how to use systemd within a container,
    it is time to see how you can use systemd and Podman to take advantage of advanced
    systemd features.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输出。由于 systemd 在容器的 PID1 上运行，它没有将任何输出写入日志。你需要进入容器并使用 `journalctl` 或读取 `/var/log/httpd/error_log`
    中的 `httpd` 日志来查看是否有任何问题。现在你已经看到了如何在容器中使用 systemd，是时候看看你如何可以使用 systemd 和 Podman
    利用高级 systemd 功能了。
- en: 7.2 Journald for logging and events
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 Journald 用于日志和事件
- en: The systemd journal (journald) is the modern logging system on Linux. It is
    a system service that collects and stores logging data. A big advantage of using
    journald is that records are permanently stored, and log rotation is built in.
    Podman uses journald by default for storing its logging data.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 日志（journald）是 Linux 上的现代日志系统。它是一个收集和存储日志数据的系统服务。使用 journald 的一个主要优势是记录永久存储，并且日志轮转是内置的。Podman
    默认使用 journald 存储其日志数据。
- en: 7.2.1 Log driver
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 日志驱动程序
- en: Podman defaults to using journald as the log driver on systems running with
    systemd as the init system. If you run Podman in a container without systemd running,
    it falls back to using the file driver. One consideration when picking a log driver
    is whether the log data persists when the container is removed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 默认在以 systemd 作为初始化系统的系统上使用 journald 作为日志驱动程序。如果你在没有 systemd 运行的容器中运行
    Podman，它将回退到使用文件驱动程序。在选择日志驱动程序时，需要考虑的一个因素是当容器被移除时日志数据是否会持久化。
- en: A second concern is how large the log file grows. The log records all `stdout`
    and `stderr` within the container. Containers running for a very long time can
    create a lot of log content. Only the journald driver has log rotation built into
    it, provided by systemd. If you use the k8s-file driver there is a risk your system
    could run out of space. Table 7.2 shows the available log drivers and whether
    the log data persists and the system supports log rotation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关注点是日志文件的大小。日志记录了容器内的所有 `stdout` 和 `stderr`。运行时间非常长的容器可以创建大量的日志内容。只有 journald
    驱动程序内置了日志轮转，由 systemd 提供。如果你使用 k8s-file 驱动程序，你的系统可能会耗尽空间。表 7.2 展示了可用的日志驱动程序以及日志数据是否持久化以及系统是否支持日志轮转。
- en: Table 7.2 Log driver options
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 日志驱动程序选项
- en: '| Library | Description | Persist logs after container removal | Log rotation
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| Library | 描述 | 容器移除后持久化日志 | 日志轮转 |'
- en: '| Journald | Use systemd journal to store logging information | ✔ | ✔ |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| Journald | 使用 systemd 日志存储日志信息 | ✔ | ✔ |'
- en: '| k8s-file | Store logging data in Kubernetes format flat file | ✘ | ✘ |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| k8s-file | 以 Kubernetes 格式将日志数据存储在平面文件中 | ✘ | ✘ |'
- en: '| None | Do not store any logging information | ✘ | ✘ |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| None | 不存储任何日志信息 | ✘ | ✘ |'
- en: While I recommend you use journald for the log driver, some rootless users are
    not allowed to use journald, depending on their system configuration. In other
    cases, like running Podman within a container, journald is not available.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我推荐你使用 journald 作为日志驱动程序，但根据系统配置，一些无根用户可能不允许使用 journald。在其他情况下，例如在容器内运行 Podman，journald
    可能不可用。
- en: 'You can see the default log driver on your system by using the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令查看系统上的默认日志驱动程序：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For some reason, the system settings on your host were set to log to k8s-file.
    It is simple to override the default log driver for your system using containers.conf.
    Create a log_driver.conf file in the home directory, $HOME/.config/containers/containers
    .conf.d, with the `log_driver` option set:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，你的主机系统设置被设置为将日志记录到 k8s-file。使用 containers.conf 覆盖系统默认日志驱动程序很简单。在主目录中创建一个
    log_driver.conf 文件，$HOME/.config/containers/containers .conf.d，并设置 `log_driver`
    选项：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Great. Next, you will see the benefits of the journald log driver by launching
    a container with the `--rm` option to remove the container when it exits:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。接下来，你将通过使用 `--rm` 选项启动容器来移除容器退出时的日志驱动程序的好处：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check that the journal keeps a record of the container being launched:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 检查日志是否记录了容器启动的情况：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you had launched with the `k8s_file` option, Podman would have removed the
    log file when the container was removed. No log entry would be left behind. Like
    logs, Podman supports using the systemd journal to store events.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `k8s_file` 选项启动，当容器被移除时，Podman 会移除日志文件。不会留下任何日志条目。与日志一样，Podman 支持使用 systemd
    日志存储事件。
- en: 7.2.2 Events
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 事件
- en: 'Podman events record different steps in the container life cycle; for example,
    you can see the start event of the last container you ran:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 事件记录了容器生命周期中的不同步骤；例如，你可以看到你运行的最后一个容器的启动事件：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Examine the default events logger with the Podman info command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Podman info 命令检查默认的事件记录器：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can modify the events logger with the `events_logger` option in containers.conf
    similarly to how you did for the `log_driver`. Table 7.3 shows the available events
    logging options.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 containers.conf 中使用 `events_logger` 选项来修改事件记录器，类似于你为 `log_driver` 所做的修改。表
    7.3 展示了可用的日志记录选项。
- en: Table 7.3 Events logger options
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.3 事件记录器选项
- en: '| Library | Description | Persist log data on reboot | Log rotation |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| Library | 描述 | 重启后持久化日志数据 | 日志轮转 |'
- en: '| Journald | The systemd journal will record all events. | ✔ | ✔ |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Journald | systemd 日志将记录所有事件。 | ✔ | ✔ |'
- en: '| File | Store events in a file, usually on /run. | ✘ | ✘ |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| File | 将事件存储在文件中，通常在 /run。 | ✘ | ✘ |'
- en: '| None | Do not store any events information. | ✘ | ✘ |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| None | 不存储任何事件信息。 | ✘ | ✘ |'
- en: If your system uses the file event logger, the events backend file is stored
    on `$XDG_RUNTIME_DIR` for rootless users, which is on a tmpfs by default. The
    events backend file grows continuously, until you reboot the system when using
    the file driver. This could cause failures to run containers or the system to
    run out of space, since the events backend does not roll over unless you are using
    journald. Also, when you reboot, the events log is lost. Switching to journald
    preserves the events and handles rotation of the events log. I recommend you keep
    the log driver and the events driver the same values, either as journald, a flat
    file, or none, if you don’t need the events and logs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你的系统使用文件事件记录器，事件后端文件存储在 `$XDG_RUNTIME_DIR`，对于 rootless 用户默认在 tmpfs 上。事件后端文件会持续增长，直到你使用文件驱动程序重启系统。这可能会导致容器运行失败或系统空间不足，因为事件后端不会自动回滚，除非你使用
    journald。此外，当你重启时，事件日志会丢失。切换到 journald 可以保留事件并处理事件日志的轮换。我建议你保持日志驱动程序和事件驱动程序具有相同的值，无论是
    journald、平面文件还是 none，如果你不需要事件和日志。 '
- en: You have examined using systemd within Podman as well as journald to manage
    log files and events. Now you will look at how to set up your system to automatically
    run a container when the system comes up using systemd.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经检查了在 Podman 中使用 systemd 以及 journald 来管理日志文件和事件。现在，你将了解如何设置系统，以便在系统启动时使用 systemd
    自动运行容器。
- en: 7.3 Starting containers at boot
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 启动时启动容器
- en: As you learned in chapter 1, Podman does not run as a daemon, meaning you cannot
    rely on a daemon to automatically start containers at boot time. Often you will
    need to run containerized services via systemd. Systemd can be configured to install,
    run, and manage containerized applications. Many applications are shipped as container
    images and will include systemd service unit files for launching. There are many
    features provided by systemd to improve the way containerized services run on
    your system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第 1 章中学到的，Podman 不会作为守护进程运行，这意味着你无法依赖守护进程在启动时自动启动容器。通常，你需要通过 systemd 运行容器化服务。Systemd
    可以配置为安装、运行和管理容器化应用程序。许多应用程序以容器镜像的形式提供，并将包含用于启动的系统服务单元文件。systemd 提供了许多功能，以改善容器化服务在你的系统上的运行方式。
- en: 7.3.1 Restarting containers
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 容器重启
- en: Podman relies on systemd to start containerized services by launching Podman
    within systemd unit files. The `podman` `run` command allows you to choose whether
    to restart a container (`--restart`) if it is not stopped by a user—for example,
    if the container crashes or the system reboots. Table 7.4 shows the restart policies
    available to Podman.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 依赖于 systemd 通过在 systemd 单元文件中启动 Podman 来启动容器化服务。`podman run` 命令允许你选择是否在容器未由用户停止时重启容器（例如，如果容器崩溃或系统重启）。表
    7.4 显示了 Podman 可用的重启策略。
- en: One simple way systemd helps is by starting containers with a restart policy
    of `always`. If you set the `always` option and the system reboots, Podman uses
    two systemd services to automatically restart containers marked with `--restart=always`.
    One service handles rootful containers, and the other handles all rootless containers
    on the system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: systemd 帮助的一个简单方法是使用 `always` 重启策略启动容器。如果你设置了 `always` 选项并且系统重启，Podman 将使用两个
    systemd 服务自动重启标记为 `--restart=always` 的容器。一个服务处理 rootful 容器，另一个处理系统上的所有 rootless
    容器。
- en: Table 7.4 Restart policy
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.4 重启策略
- en: '| Option | Description | Restart on boot |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 | 启动时重启 |'
- en: '| `no` | Do not restart containers on exit. | ✘ |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `no` | 容器退出时不重启。 | ✘ |'
- en: '| `on-failure[:max_retries]` | Restart containers when they exit with a nonzero
    exit code, retrying indefinitely or until the optional `max_retries` count is
    hit. | ✘ |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `on-failure[:max_retries]` | 当容器以非零退出码退出时重启容器，无限重试或直到达到可选的 `max_retries`
    重试次数。 | ✘ |'
- en: '| `always` or `unless-stopped` | Restart containers when they exit, regardless
    of status, retrying indefinitely. | ✔ |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `always` 或 `unless-stopped` | 当容器退出时重启容器，无论状态如何，无限重试。 | ✔ |'
- en: 'When your system boots up, systemd runs the following Podman command to start
    any containers with restart policy set to `always`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的系统启动时，systemd 会运行以下 Podman 命令以启动任何设置为 `always` 重启策略的容器：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note Podman ships with two systemd service files used to restart services—one
    for rootful and one for rootless:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Podman 随附两个 systemd 服务文件，用于重启服务——一个用于 rootful，一个用于 rootless：
- en: /usr/lib/systemd/system/podman-restart.service
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: /usr/lib/systemd/system/podman-restart.service
- en: /usr/lib/systemd/user/podman-restart.service
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: /usr/lib/systemd/user/podman-restart.service
- en: The `--restart=always` works great, but it requires you to create a container
    on the system and will restart containers even if they fail. Systemd was designed
    to run services; you will see in the next section that you can easily create a
    service unit file with Podman to run your containerized service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`--restart=always` 工作得很好，但它要求你在系统上创建一个容器，并且即使容器失败也会重启容器。systemd 是为了运行服务而设计的；你将在下一节中看到，你可以使用
    Podman 轻松创建一个服务单元文件来运行你的容器化服务。'
- en: 7.3.2 Podman containers as systemd services
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 Podman 容器作为 systemd 服务
- en: As you have seen, systemd uses unit files to specify how to run a service. Figure
    7.5 shows how systemd works with Podman to launch a container.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，systemd 使用单元文件来指定如何运行一个服务。图 7.5 展示了 systemd 如何与 Podman 协同启动一个容器。
- en: '![](../../OEBPS/Images/07-05.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5](../../OEBPS/Images/07-05.png)'
- en: Figure 7.5 Podman fork/exec architecture is ideal for systemd service management.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 Podman fork/exec 架构非常适合 systemd 服务管理。
- en: In figure 7.5, I point out that systemd is able to monitor all the processes
    running within the systemd unit file. This allows it to easily start and stop
    the processes. The `conmon` process is also running within the systemd service
    monitoring the container processes. `conmon` still notices when the container
    exits, saves its exit code, and cleanly shuts down the container environment.
    Systemd does not know about the container; it only knows about the processes running
    within the unit file, including the container processes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 7.5 中，我指出 systemd 能够监控 systemd 单元文件中运行的所有进程。这使得它能够轻松地启动和停止进程。`conmon` 进程也在
    systemd 服务中运行，监控容器进程。`conmon` 仍然会在容器退出时注意到，保存其退出代码，并干净地关闭容器环境。systemd 并不知道容器；它只知道单元文件中运行的进程，包括容器进程。
- en: 'Systemd unit files have many different ways to run and launch processes, and
    Podman has many different options for running containers. Configuring the unit
    files can be very complex. Many users have written unit files to run containers,
    but several have stumbled over problems when doing so. The most common problem
    is running the `podman` `run` `--detach` command within a unit file. When the
    Podman command detaches and exits, systemd assumes the service is complete and
    takes it down, even though `conmon` and the container are still running. One of
    the most common questions I hear from users is the following: “How should I run
    my container within a systemd unit file?”'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd 单元文件有许多不同的方式来运行和启动进程，而 Podman 提供了许多不同的选项来运行容器。配置单元文件可能非常复杂。许多用户已经编写了单元文件来运行容器，但在这样做时遇到了一些问题。最常见的问题是，在单元文件中运行
    `podman run --detach` 命令。当 Podman 命令断开连接并退出时，systemd 假设服务已完成并将其关闭，即使 `conmon`
    和容器仍在运行。我经常从用户那里听到以下问题：“我应该如何在 systemd 单元文件中运行我的容器？”
- en: Podman has a feature to generate unit files with the best defaults. First, re-create
    the container from `myimage`, and then use `podman` `systemd` `generate` to create
    a systemd service unit file to manage your container.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 有一个功能可以生成具有最佳默认设置的单元文件。首先，从 `myimage` 重新创建容器，然后使用 `podman systemd generate`
    创建一个 systemd 服务单元文件来管理你的容器。
- en: 'Create a container based on the image you created in chapter 2:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你在第 2 章中创建的镜像创建一个容器：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now use Podman to generate a unit file off of this container:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用 Podman 生成一个基于此容器的单元文件：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice in the myapp.service script that Podman created an `ExecStart` field.
    On service start, systemd will execute the `ExecStart` command, which simply starts
    the container you created:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 myapp.service 脚本中，Podman 创建了一个 `ExecStart` 字段。在服务启动时，systemd 将执行 `ExecStart`
    命令，该命令简单地启动你创建的容器：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On service stop, systemd executes the `ExecStop` command added to the unit
    file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务停止时，systemd 执行单元文件中添加的 `ExecStop` 命令：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To make this all work, you need to tell systemd to reload its database, so
    it will notice changes in the unit files:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这一切都能正常工作，你需要告诉 systemd 重新加载其数据库，这样它就会注意到单元文件中的更改：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Start the service with the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动服务：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Check to see that the service is running:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 检查服务是否正在运行：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now you can run the web browser against localhost port `8080` to see it is
    running (see figure 7.6):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过 localhost 端口 `8080` 运行浏览器来查看它是否正在运行（见图 7.6）：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](../../OEBPS/Images/07-06.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6](../../OEBPS/Images/07-06.png)'
- en: Figure 7.6 Web browser window connecting `myapp`
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 浏览器窗口连接 `myapp`
- en: To shut down the service, execute
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭服务，执行
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The ability to generate systemd service files offers a lot of flexibility to
    users, and it intentionally blurs the difference between a container and any other
    program or service on the host.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 systemd 服务文件的能力为用户提供了很多灵活性，并且故意模糊了容器与主机上任何其他程序或服务之间的区别。
- en: 'One problem with this unit file is that it’s specific to the container you
    created. You need to first create the container and generate specific service
    files. You are not able to hand the unit file to another user and have them run
    your service on their machine. Luckily, Podman has support for creating a more
    portable systemd unit file: `podman` `generate` `systemd` `--new.`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元文件的一个问题是它特定于你创建的容器。你需要首先创建容器并生成特定的服务文件。你不能将单元文件交给另一个用户，让他们在你的机器上运行你的服务。幸运的是，Podman
    支持创建更便携的 systemd 单元文件：`podman` `generate` `systemd` `--new`。
- en: 7.3.3 Distributing systemd unit files to manage Podman containers
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 分发 systemd 单元文件以管理 Podman 容器
- en: 'As shown previously, the `podman` `generate` `systemd` `command` generated
    a unit file, which started and stopped an existing container. The `--new` flag
    instructs Podman to generate units that run, stop, and remove containers. Try
    it out in the same container:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`podman` `generate` `systemd` `command` 生成了一个单元文件，该文件启动并停止了一个现有的容器。`--new`
    标志指示 Podman 生成运行、停止和删除容器的单元。在同一个容器中试一试：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that with the `--new` option, Podman creates a slightly different unit
    file. Examine the following `ExecStart` command, and you will see the original
    `podman` `create` `-p` `8080:8080` `--name` `myapp` `quay.io/rhatdan/myimage`
    command you used to create the container has been changed to use the `podman`
    `run` command. Also notice that Podman added additional options to make running
    under systemd easier `(--cidfile =%t/%n.ctr-id` `--cgroups=no-conmon` `--rm` `--sdnotify=conmon`
    `-d` `--replace).`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用 `--new` 选项时，Podman 创建了一个略微不同的单元文件。检查以下 `ExecStart` 命令，你会看到你用来创建容器的原始 `podman`
    `create` `-p` `8080:8080` `--name` `myapp` `quay.io/rhatdan/myimage` 命令已被更改为使用
    `podman` `run` 命令。同时注意，Podman 添加了额外的选项，以使在 systemd 下运行更容易（`--cidfile =%t/%n.ctr-id`
    `--cgroups=no-conmon` `--rm` `--sdnotify=conmon` `-d` `--replace`)。
- en: Podman now adds the `ExecStop` command (`/usr/bin/podman` `stop` `--ignore`
    `--cidfile=%t/%n.ctr-id`), which tells systemd how to stop the container when
    someone executes `systemctl` `stop` or the system shuts down.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 现在添加了 `ExecStop` 命令 (`/usr/bin/podman` `stop` `--ignore` `--cidfile=%t/%n.ctr-id`)，它告诉
    systemd 当有人执行 `systemctl` `stop` 或系统关闭时如何停止容器。
- en: 'Finally, Podman adds an `ExecStopPost` command (`/usr/bin/podman` `rm` `-f`
    `--ignore` `--cidfile=%t/%n.ctr-idType=notify`), which systemd executes once the
    `ExecStop` command completes. The Podman command removes the container from the
    system:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Podman 添加了一个 `ExecStopPost` 命令 (`/usr/bin/podman` `rm` `-f` `--ignore` `--cidfile=%t/%n.ctr-idType=notify`)，systemd
    在 `ExecStop` 命令完成后执行该命令。Podman 命令从系统中删除容器：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can remove the container and the image from your system, and when you tell
    `systemctl` to start the service, Podman will pull the image and create a new
    container. This means the myapp-new.service unit file can be shared with a different
    user, and when they run the service, Podman will likewise pull the image and run
    the container on their systems, without them ever creating the container in the
    first place. Table 7.5 shows the different commands added to the unit file based
    on whether you used the `--new` flag.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从系统中删除容器和镜像，当你告诉 `systemctl` 启动服务时，Podman 将拉取镜像并创建一个新的容器。这意味着 myapp-new.service
    单元文件可以与其他用户共享，当他们运行服务时，Podman 同样会拉取镜像并在他们的系统上运行容器，而他们从未创建过容器。表7.5显示了根据你是否使用了 `--new`
    标志添加到单元文件中的不同命令。
- en: Table 7.5 Differences between unit files
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.5 单元文件之间的差异
- en: '| Option | Commands |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 命令 |'
- en: '| With `--new` | `ExecStart=/usr/bin/podman run ...--cidfile=%t/%n.ctr-id --cgroups=no-`➥
    `conmon --rm --sdnotify=conmon -d --replace -p 8080:8080 --name`➥ `myapp quay.io/rhatdan/myimage``ExecStop=/usr/bin/podman
    stop --ignore --cidfile=%t/%n.ctr-id``ExecStopPost=/usr/bin/podman rm -f --ignore
    --cidfile=%t/%n`➥ `.ctr-idType=notify` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 使用 `--new` | `ExecStart=/usr/bin/podman run ...--cidfile=%t/%n.ctr-id --cgroups=no-`➥
    `conmon --rm --sdnotify=conmon -d --replace -p 8080:8080 --name`➥ `myapp quay.io/rhatdan/myimage``ExecStop=/usr/bin/podman
    stop --ignore --cidfile=%t/%n.ctr-id``ExecStopPost=/usr/bin/podman rm -f --ignore
    --cidfile=%t/%n`➥ `.ctr-idType=notify` |'
- en: '| Without `--new` | `ExecStart=/usr/bin/podman start 8879112805...``ExecStop=/usr/bin/podman
    stop -t 10 8879112805...``ExecStopPost=/usr/bin/podman stop -t 10 8879112805...`
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 不使用 `--new` | `ExecStart=/usr/bin/podman start 8879112805...``ExecStop=/usr/bin/podman
    stop -t 10 8879112805...``ExecStopPost=/usr/bin/podman stop -t 10 8879112805...`
    |'
- en: 'Once you have your containerized service running on many machines, you need
    to think about maintaining it. Podman has a way to do this without human intervention:
    auto-update.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的容器化服务在多台机器上运行，你需要考虑如何维护它。Podman有一种无需人工干预的方式来维护：自动更新。
- en: 7.3.4 Automatically updating Podman containers
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 自动更新Podman容器
- en: In chapter 2, we talked about container images aging like stinky cheese. When
    the container image gets updated with new software or vulnerability fixes, you
    need to reach out to these machines, pull the updated images, and re-create the
    containerized services. It is much less labor intensive when machines manage their
    own updates.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们讨论了容器镜像像臭奶酪一样老化。当容器镜像通过新的软件或漏洞修复进行更新时，你需要联系这些机器，拉取更新的镜像，并重新创建容器化服务。当机器自己管理自己的更新时，这要少得多的人工干预。
- en: Imagine you configure a service to run on a container image on hundreds of nodes.
    A few months later, you add new features to the application in the image or, more
    importantly, a new CVE is found. Now you need to update the image and then recreate
    the service on all of the nodes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你配置了一个服务在数百个节点上运行在容器镜像上。几个月后，你在镜像中的应用程序中添加了新功能，或者更重要的是，发现了一个新的CVE。现在你需要更新镜像，然后在所有节点上重新创建服务。
- en: Podman automates this process with auto-update; each node watches for new images
    to appear in a container registry. When the image shows up, the node pulls down
    the image and re-creates the container. No human interaction is involved.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Podman通过自动更新自动化此过程；每个节点都会监视容器注册库中出现的新镜像。当镜像出现时，节点会拉取镜像并重新创建容器。无需人工交互。
- en: Podman auto-update enables you to use Podman in edge use cases, update workloads
    once they are connected to the network, and roll back failures to a known good
    state. In addition, running containers is essential for implementing edge computing
    in remote data centers or on internet-of-things (IoT) devices. Auto-updates enable
    you to use Podman in edge use cases, update workloads once they are connected
    to the network, and reduce maintenance costs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Podman自动更新功能使你能够在边缘用例中使用Podman，一旦连接到网络，就更新工作负载，并将故障回滚到已知良好状态。此外，在远程数据中心或物联网（IoT）设备上实施边缘计算时，运行容器是至关重要的。自动更新使你能够在边缘用例中使用Podman，一旦连接到网络就更新工作负载，并降低维护成本。
- en: To implement this behavior, Podman requires containers to have a special label,
    `--label` `"io.containers.autoupdate=registry"`, and the container must be run
    in a systemd unit generated by `podman` `generate` `systemd` `--new`. Table 7.6
    describes the auto-update modes available.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此行为，Podman需要容器具有特殊的标签，`--label` `"io.containers.autoupdate=registry"`，并且容器必须以由`podman`
    `generate` `systemd` `--new`生成的systemd单元运行。表7.6描述了可用的自动更新模式。
- en: Table 7.6 Auto-update modes
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.6 自动更新模式
- en: '| `io.containers.autoupdate` | Description |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `io.containers.autoupdate` | 描述 |'
- en: '| `registry` | Podman connects to the container registry and checks if a different
    image than the one used to create the container is available; if there is one,
    Podman will update the container. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `registry` | Podman连接到容器注册库，并检查是否有与创建容器时使用的不同镜像可用；如果有，Podman将更新容器。|'
- en: '| `local` | Podman connects to the container registry but compares local images
    to the one the container was created with; if they are different, Podman updates
    the container. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `local` | Podman连接到容器注册库，但将本地镜像与创建容器时使用的镜像进行比较；如果它们不同，Podman将更新容器。|'
- en: 'First, stop the systemd service if it is running, and remove the existing `myapp`
    container:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果systemd服务正在运行，请停止它，并删除现有的`myapp`容器：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Re-create the myapp container with the special label `"io.containers.autoupdate=registry"`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊标签`"io.containers.autoupdate=registry"`重新创建myapp容器：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Re-create the systemd unit file with the `--new` option:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--new`选项重新创建systemd单元文件：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Tell systemd the unit file changed by executing `daemon-reload`, and start
    the service:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行`daemon-reload`告诉systemd单元文件已更改，并启动服务：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `myapp-new` service is now ready to be automatically updated. When you
    execute the `podman` `auto-update` command, Podman examines running containers
    for the `io.containers.autoupdate` label set to `image`. For each container with
    that label, Podman reaches out to the container registry and checks if the image
    has changed since the container was created. If the image has changed, Podman
    restarts the corresponding systemd unit. Recall that on a systemd restart, the
    following steps happen:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`myapp-new`服务现在已准备好自动更新。当您执行`podman` `auto-update`命令时，Podman会检查运行中的容器是否有设置为`image`的`io.containers.autoupdate`标签。对于带有该标签的每个容器，Podman会联系容器注册表，检查镜像自容器创建以来是否已更改。如果镜像已更改，Podman将重启相应的systemd单元。回想一下，在systemd重启时，以下步骤会发生：'
- en: 'Systemd stops the service by executing the `podman` `stop` command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd通过执行`podman` `stop`命令来停止服务：
- en: '[PRE37]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Systemd executes the `ExecStopPost` script. Once the container stops, this
    script removes the container with `podman` `rm`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd通过执行`ExecStopPost`脚本来停止服务。一旦容器停止，此脚本将使用`podman` `rm`删除容器：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Systemd restarts the services with the `podman` `run` command, including the
    `--label` `"io.containers.autoupdate=registry"` option:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: systemd使用`podman` `run`命令重启服务，包括`--label` `"io.containers.autoupdate=registry"`选项：
- en: '[PRE39]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `podman` `run` command in the third step will reach out to the registry
    and pull down the updated container image and re-create the containerized application
    on it. The container, its environment, and all dependencies are restarted.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步中的`podman` `run`命令将联系注册表并拉取更新的容器镜像，并在其上重新创建容器化应用程序。容器、其环境和所有依赖项都将重新启动。
- en: 'You can test this by changing your image, pushing it to a registry, and then
    running the `podman` `auto-update` command as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改镜像，将其推送到注册表，然后按照以下方式运行`podman` `auto-update`命令来测试：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now commit the image as `myimage-new`, and push it to the registry with the
    original name: `myimage`. Finally, remove the image from the local store to simulate
    that the image was never on your system:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将镜像提交为`myimage-new`，并使用原始名称`myimage`推送到注册表。最后，从本地存储中删除镜像以模拟该镜像从未在您的系统上存在：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once the new image is at the registry, and you have removed it from local storage,
    you can run `podman` `auto-update`, which notices the new image and restarts the
    service. This triggers Podman to pull the new image and re-create the containerized
    service:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新镜像在注册表中，并且您已将其从本地存储中删除，您就可以运行`podman` `auto-update`，它会注意到新镜像并重启服务。这会触发Podman拉取新镜像并重新创建容器化服务：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Your application has been updated to the latest version of the image.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序已更新到镜像的最新版本。
- en: 'Some notable `podman` `auto-update` options include the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一些显著的`podman` `auto-update`选项包括以下内容：
- en: '`--dry-run`—This option is useful to see if any containers need to be updated,
    without actually updating them.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dry-run`——此选项很有用，可以查看是否有任何容器需要更新，而实际上并不更新它们。'
- en: '`--roll-back`—This option tells Podman to roll back to the previous image if
    the update fails, as covered in the next section.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--roll-back`——此选项告诉Podman在更新失败时回滚到上一个镜像，如下一节所述。'
- en: systemd timers trigger Podman updates
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: systemd定时器触发Podman更新
- en: 'Podman ships with two auto-update systemd timer units and two auto-update service
    units—one each for rootful containers and rootless containers. The timer units
    triggered by systemd once per day are the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Podman附带两个自动更新systemd定时器单元和两个自动更新服务单元——每个用于rootful容器和rootless容器。systemd每天触发一次的定时器单元如下：
- en: /usr/lib/systemd/system/podman-auto-update.timer
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /usr/lib/systemd/system/podman-auto-update.timer
- en: /usr/lib/systemd/user/podman-auto-update.timer
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /usr/lib/systemd/user/podman-auto-update.timer
- en: 'The timer units tell systemd to execute the appropriate auto-update service
    unit file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器单元告诉systemd执行适当的自动更新服务单元文件：
- en: /usr/lib/systemd/system/podman-auto-update.service
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /usr/lib/systemd/system/podman-auto-update.service
- en: /usr/lib/systemd/user/podman-auto-update.service
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /usr/lib/systemd/user/podman-auto-update.service
- en: With this feature, systemd will launch Podman, which looks for containers with
    the `"io.containers.autoupdate=registry"` label, like you created last section.
    Once Podman finds a container with the label, it checks if the container’s image
    has been updated on the registry. If the image has changed, Podman starts the
    update process. This means you can run your systems unattended, and they are updated
    within 24 hours with the newest version of the container image every time you
    push an updated image to a registry. If you share the unit file you generated
    with others, then they also get the auto-updates.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此功能，systemd将启动Podman，Podman会寻找带有`"io.containers.autoupdate=registry"`标签的容器，就像你在上一节创建的那样。一旦Podman找到带有标签的容器，它会检查容器镜像是否已在注册表中更新。如果镜像已更改，Podman将启动更新过程。这意味着你可以无人值守地运行系统，每次你向注册表推送更新镜像时，系统都会在24小时内更新到最新的容器镜像版本。如果你与他人共享你生成的单元文件，那么他们也会获得自动更新。
- en: A big concern with auto-update is what happens if the update is broken. In that
    case, you will have hundreds of nodes updated to a broken service. Systemd has
    a feature called `sd-notify`, which allows a service to say its initialization
    is complete and it is ready to be used as a service.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 自动更新的一大担忧是如果更新失败会发生什么。在这种情况下，你将有数百个节点更新到一个损坏的服务。Systemd有一个名为`sd-notify`的功能，允许服务声明其初始化已完成，并且它已准备好作为服务使用。
- en: Note Some of this section is based on previously written blogs copied and rewritten
    from the “How to use auto-updates and rollbacks in Podman” blog ([http://mng.bz/neDK](http://mng.bz/neDK)),
    written by myself and coworkers Valentin Rothberg and Preethi Thomas.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节的部分内容基于我之前撰写的博客，从“如何在Podman中使用自动更新和回滚”博客（[http://mng.bz/neDK](http://mng.bz/neDK)）中复制并改写，该博客由我和同事Valentin
    Rothberg和Preethi Thomas撰写。
- en: 7.4 Running containers in notify unit files
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 在notify单元文件中运行容器
- en: Unit file services can specify that they wait to start until other services
    are up and running. For example, you can have a website that relies on a database
    to be running before the web service accepts connections. Systemd usually considers
    a service started after it launches the primary process of the service. However,
    many services take time to initialize and can’t accept connections right away.
    The database in the previous example might take minutes before it is ready for
    the web service to start receiving connections.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件服务可以指定它们等待其他服务启动并运行后再开始。例如，你可以有一个在网站接受连接之前需要数据库运行的网站。Systemd通常认为在启动服务的主要进程之后启动的服务已启动。然而，许多服务需要一段时间才能初始化，不能立即接受连接。在先前的例子中，数据库可能需要几分钟才能准备好让网站开始接收连接。
- en: Systemd defines a special service type called `notify` (or `sd-notify`) that
    allows the service process to notify systemd when it is actually fully up and
    running. Systemd starts the web service only when systemd is notified that the
    database is ready.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd定义了一种特殊的服务类型，称为`notify`（或`sd-notify`），允许服务进程在实际上完全启动并运行时通知systemd。Systemd仅在接收到数据库已准备好的通知后才会启动网络服务。
- en: Systemd tells a service that it needs to be notified that the service is ready
    by passing the `NOTIFY_SOCKET` environment variable pointing to the systemd socket
    to be notified. By default, systemd listens on the /run/SystemD/notify socket.
    When Podman executes within a `NOTIFY` unit file, it needs to volume mount the
    socket into the container and pass down the environment variable into the container
    (figure 7.7).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd通过传递指向要通知的systemd套接字的`NOTIFY_SOCKET`环境变量来告诉服务它需要通知服务已准备好。默认情况下，systemd监听在/run/SystemD/notify套接字上。当Podman在`NOTIFY`单元文件中执行时，它需要将套接字挂载到容器中，并将环境变量传递到容器中（图7.7）。
- en: '![](../../OEBPS/Images/07-07.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/07-07.png)'
- en: Figure 7.7 Containerized `sd_notify` systemd service launched by Podman
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 Podman启动的容器化`sd_notify` systemd服务
- en: If the service does not notify systemd within the specified time, systemd will
    mark the service as failed. Podman auto-update checks if the new service is fully
    up and running, and if the check fails, Podman can automatically roll back to
    the previous container—again, without human intervention.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务在指定时间内没有通知systemd，systemd会将该服务标记为失败。Podman自动更新会检查新服务是否完全启动并运行，如果检查失败，Podman可以自动回滚到之前的容器——同样，无需人工干预。
- en: 7.5 Rolling back failed containers after update
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 更新后回滚失败的容器
- en: If your defined service supports `sd-notify` and writes to the notify socket
    within the time limit, the `podman` `auto-update` command will succeed. However,
    if it fails, Podman will remove the new container and retag the original image.
    Finally, it will create the container on the previous image, and your service
    will come back up in the previous state. You could even set up your system-based
    containerized service to notify your logging system that the update failed. The
    rollback gives you time to figure out what went wrong and ship a new image, triggering
    the auto-update again. As you can see, systemd can be used as the container orchestrator
    of a single system.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您定义的服务支持`sd-notify`并在时间限制内写入通知套接字，则`podman` `auto-update`命令将成功。然而，如果失败，Podman将删除新的容器并重新标记原始镜像。最后，它将在之前的镜像上创建容器，并且您的服务将恢复到之前的状态。您甚至可以设置基于系统的容器化服务来通知您的日志系统更新失败。回滚给您时间来找出问题所在并发布新镜像，再次触发自动更新。如您所见，systemd可以用作单个系统的容器编排器。
- en: You have now discovered a few nice features systemd provides for running containers
    without human intervention. One additional feature Podman can take advantage of
    is socket activation, which allows you to specify a container within a unit file
    that will not be running until the first packet comes to its socket.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经发现了一些systemd提供的功能，可以在无需人工干预的情况下运行容器。Podman可以利用的一个额外功能是套接字激活，它允许您在单元文件中指定一个容器，该容器将在第一个数据包到达其套接字之前不会运行。
- en: 7.6 Socket-activated Podman containers
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 套接字激活的Podman容器
- en: When systemd was first introduced, it was lauded for speeding up the boot of
    a system. Before systemd, each service started sequentially, and services that
    relied on different services to be run needed to wait. To speed up the boot and
    get better with resource allocation, systemd uses *socket-activated services*.
    When you set up a socket-activated service, systemd sets up listening IP or UNIX
    domain sockets on behalf of your service, without starting the service (figure
    7.8).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当systemd首次推出时，它因加快系统启动速度而受到赞誉。在systemd之前，每个服务都是顺序启动的，依赖于其他服务启动的服务需要等待。为了加快启动速度并优化资源分配，systemd使用*套接字激活服务*。当您设置套接字激活服务时，systemd代表您的服务设置监听IP或UNIX域套接字，而无需启动服务（见图7.8）。
- en: '![](../../OEBPS/Images/07-08.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-08.png)'
- en: Figure 7.8 Systemd listening on a socket for a socket-activated container
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 Systemd在套接字上监听套接字激活的容器
- en: When a connection to the socket arrives, systemd activates the service and hands
    the connection to it. Afterwards, the service handles connections. The service
    can at some point in the future idle itself by exiting. If a new connection comes
    in, systemd accepts the new connection and starts the service again.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当套接字连接到达时，systemd激活服务并将连接交给它。之后，服务处理连接。服务可以在未来的某个时刻通过退出使自己空闲。如果新的连接进来，systemd接受新的连接并再次启动服务。
- en: Socket activation allows systemd to indicate that a service started instantly,
    without actually starting or waiting for the service to start, speeding up the
    boot process. Socket activation allows systemd to run more services on the system,
    since many services are idle and not using system resources. Basically, your services
    can be stopped and only run when they are actually needed and not sit idle, waiting
    for another connection. With containerized services, the main process of the service
    is Podman, and it needs to pass the connection down to the service running within
    the container (figure 7.9).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字激活允许systemd指示一个服务立即启动，而无需实际启动或等待服务启动，从而加快启动过程。套接字激活允许systemd在系统上运行更多服务，因为许多服务处于空闲状态且未使用系统资源。基本上，您的服务可以在实际需要时停止，而不是空闲等待另一个连接。对于容器化服务，服务的主要进程是Podman，它需要将连接传递给容器内运行的服务（见图7.9）。
- en: '![](../../OEBPS/Images/07-09.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-09.png)'
- en: Figure 7.9 When a connection to the socket systemd is listening on arrives,
    systemd activates Podman, which launches the container, passing the socket down
    to the container.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 当连接到systemd正在监听的套接字时，systemd激活Podman，它启动容器，并将套接字传递给容器。
- en: 'Shut down the myapp.service, and create the myapp.socket:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭myapp.service，并创建myapp.socket：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, enable the socket, and make sure no containers are running:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启用套接字，并确保没有容器正在运行：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Connect a web browser to the socket (see figure 7.10):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将网络浏览器连接到套接字（见图7.10）：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![](../../OEBPS/Images/07-10.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/07-10.png)'
- en: Figure 7.10 A web browser window connecting to the `ubi8/httpd-24` container
    running in Podman with updated Hello World HTML.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 一个网络浏览器窗口连接到在 Podman 中运行的更新后的 `ubi8/httpd-24` 容器，该容器运行了 Hello World HTML。
- en: 'Notice that podman.socket started the podman.service, which created a container
    to handle the connection:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 podman.socket 启动了 podman.service，该服务创建了一个容器来处理连接：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now if you stop the service, not only will the container be stopped, but it
    will be removed:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您停止服务，不仅容器会停止，它还会被移除：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Socket activation allows you to run the service only when needed, saving system
    resources. Later, you can take the service down, knowing that if a new connection
    comes in, systemd and Podman will handle it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Socket 激活允许您仅在需要时运行服务，从而节省系统资源。稍后，您可以停止该服务，知道如果新的连接到来，systemd 和 Podman 将会处理它。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Podman enables running systemd as the primary process within a container.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 允许在容器内以 systemd 作为主要进程运行。
- en: Journald is recommended for Podman logs and events.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Journald 推荐用于 Podman 的日志和事件。
- en: Systemd can be used to start and restart containers at boot time.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Systemd 可以在启动时启动和重启容器。
- en: Podman auto-update is used to manage the life cycle of a container and its image.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman 自动更新用于管理容器及其镜像的生命周期。
- en: Socket-activated systemd services can be used with Podman-based containers.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用基于 Podman 的容器与 Socket-activated systemd 服务一起使用。
- en: The `podman` `generate` `systemd` command makes it easy to generate systemd
    service files for running your containers.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman` `generate` `systemd` 命令可以轻松生成运行您的容器的 systemd 服务文件。'
