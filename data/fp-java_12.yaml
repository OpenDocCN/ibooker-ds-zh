- en: Chapter 13\. Functional input/output
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章\. 函数式输入/输出
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖***'
- en: Applying effects safely from inside contexts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上下文中安全地应用效果
- en: Adding effect application to `Result` and `List`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将效果应用添加到`Result`和`List`
- en: Combining effects for successes and failures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功和失败效果的组合
- en: Reading data safely from the console, from file, or from memory, with the `Reader`
    abstraction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Reader`抽象从控制台、文件或内存中安全地读取数据
- en: Handling input/output with the `IO` type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`IO`类型处理输入/输出
- en: So far, you’ve learned how to write functional programs that haven’t really
    produced any usable results. You learned how to compose true functions to build
    more-powerful functions. More interestingly, you learned how to use nonfunctional
    operations in a safe, functional way. Nonfunctional operations are operations
    producing side effects, like throwing exceptions, changing the outside world,
    or simply depending on the outside world to produce a result. For example, you
    learned how to take an integer division, which is a potentially unsafe operation,
    and turn it into a safe one by using it inside a computational context.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何编写没有真正产生任何可用结果的函数式程序。你学习了如何组合真正的函数来构建更强大的函数。更有趣的是，你学习了如何以安全、函数式的方式使用非函数操作。非函数操作是产生副作用的操作，如抛出异常、改变外部世界或简单地依赖于外部世界来产生结果。例如，你学习了如何进行整数除法，这是一个可能不安全的操作，通过在计算上下文中使用它，你可以将其转换为安全的操作。
- en: 'You’ve already encountered several such computational contexts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经遇到了几个这样的计算上下文：
- en: The `Result` type you developed in [chapter 7](kindle_split_014.xhtml#ch07)
    is such a computational context, allowing you to use a function that could produce
    an error in a safe, error-free way.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在[第7章](kindle_split_014.xhtml#ch07)中开发的`Result`类型就是这样一种计算上下文，它允许你以安全、无错误的方式使用可能产生错误的函数。
- en: The `Option` type from [chapter 6](kindle_split_013.xhtml#ch06) is also a computational
    context used to safely apply functions that could sometimes (for some arguments)
    produce no data.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第6章](kindle_split_013.xhtml#ch06)中的`Option`类型也是一个计算上下文，用于安全地应用有时（对于某些参数）可能不会产生数据的函数。'
- en: The `List` class you studied in [chapters 5](kindle_split_012.xhtml#ch05) and
    [8](kindle_split_015.xhtml#ch08) is a computational context, but rather than dealing
    with errors, it allows the use of functions that work on single elements in the
    context of a collection of elements. It also deals with the absence of data represented
    by an empty list.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在[第5章](kindle_split_012.xhtml#ch05)和[第8章](kindle_split_015.xhtml#ch08)学习的`List`类是一个计算上下文，但它不是处理错误，而是允许在元素集合的上下文中使用对单个元素工作的函数。它还处理由空列表表示的数据缺失问题。
- en: While studying these types, as well as others like `Stream`, `Map`, `Heap`,
    and `State`, you didn’t care about producing a useful result. In this chapter,
    however, you’ll learn several techniques for producing useful results from your
    functional programs. This includes displaying a result for a human user or passing
    a result to another program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习这些类型以及`Stream`、`Map`、`Heap`和`State`等其他类型时，你并不关心产生有用的结果。然而，在本章中，你将学习从你的函数式程序中产生有用结果的技术。这包括为人类用户显示结果或将结果传递给另一个程序。
- en: 13.1\. Applying effects in context
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1\. 在上下文中应用效果
- en: 'Recall what you did to apply a function to the result of an integer operation.
    Let’s say you want to write an `inverse` function that computes the inverse of
    an integer value:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下你是如何将函数应用于整数操作的结果的。假设你想编写一个`inverse`函数，该函数计算整数的倒数：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This function can be applied to an integer value, but when composed with other
    functions, the value will be the output of another function, so it will usually
    already be in context, and often the same type of context. Here’s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以应用于整数值，但当与其他函数组合时，值将是另一个函数的输出，因此它通常已经处于上下文中，并且通常是同一类型的上下文。以下是一个例子：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It’s important to note that you don’t take the value in `ri` out of its context
    to apply the function. It works the other way around: you pass the function to
    the context (the `Result` type) so that it can be applied inside it, producing
    a new context, possibly wrapping the resulting value. Here, you pass the function
    to the `ri` context, producing the new `rd` result.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，你不会将`ri`中的值从其上下文中取出以应用函数。相反：你将函数传递给上下文（`Result`类型），以便它可以在其中应用，产生一个新的上下文，可能包含产生的结果。在这里，你将函数传递给`ri`上下文，产生新的`rd`结果。
- en: 'This is very neat and safe. No bad things can happen; no exceptions can be
    thrown. This is the beauty of functional programming: you have a program that
    will always work, whatever data you use as input. But the question is, how can
    you use this result? Suppose you want to display the result on the console—how
    can you do this?'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常整洁且安全。不会发生任何坏事；不会抛出异常。这是函数式编程的美丽之处：无论你使用什么数据作为输入，你的程序都将始终有效。但问题是，你如何使用这个结果？假设你想要在控制台上显示结果——你该如何做？
- en: 13.1.1\. What are effects?
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1\. 什么是效果？
- en: I defined pure functions as functions without any observable side effects. An
    effect is anything that can be observed from outside the program. The role of
    a function is to return a value, and a side effect is anything, besides the returned
    value, that’s observable from the outside of the function. It’s called a *side
    effect* because it comes in addition to the value that’s returned. An *effect*
    (without “side”) is like a side effect, but it’s the main (and generally unique)
    role of a program. Functional programming is about writing programs with pure
    functions (with no side effects) and pure effects in a functional way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我将纯函数定义为没有任何可观察副作用的功能。效果是任何可以从程序外部观察到的内容。函数的作用是返回一个值，而副作用是除了返回值之外，可以从函数外部观察到的任何内容。它被称为“副作用”，因为它是在返回值之外附加的。一个没有“副”的效果就像副作用，但它是一个程序的主要（并且通常是唯一的）作用。函数式编程是关于以函数式方式编写具有纯函数（没有副作用）和纯效果的程序。
- en: The question is, what does it mean to handle effects in a functional way? The
    closest definition I can give at this stage is “handling effects in a way that
    doesn’t interfere with the principles of functional programming, the most important
    principle being referential transparency.” There are several ways to approach
    or reach this goal, and reaching this goal fully can be complex. Often, approaching
    it is sufficient. It’s up to you to decide which technique you want to use. Applying
    effects to contexts is the simplest (although not fully functional) way to make
    otherwise functional programs produce observable effects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，以函数式方式处理效果意味着什么？在这个阶段，我能给出的最接近的定义是“以不干扰函数式编程原则的方式处理效果，最重要的原则是引用透明性。”有几种方法可以接近或达到这个目标，完全达到这个目标可能很复杂。通常，接近它就足够了。取决于你决定使用哪种技术。将效果应用于上下文是使其他功能程序产生可观察效果的最简单（尽管不是完全函数式）的方法。
- en: 13.1.2\. Implementing effects
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2\. 实现效果
- en: As I just said, an effect is anything that’s observable from outside the program.
    Of course, to be valuable, this effect must generally reflect the result of the
    program, so you’ll generally need to take the result of the program and do something
    observable with it. Note that “observable” doesn’t always mean observable by a
    human operator. Often the result is observable by another program, which might
    then translate this effect into something observable by a human operator, either
    in synchronous or asynchronous form. Printing to the computer screen can be seen
    by the operator. Writing to a database, on the other hand, might not always be
    directly visible to a human user. Sometimes the result will be looked up by a
    human, but usually it will be read later by another program. In [chapter 14](kindle_split_021.xhtml#ch14),
    you’ll learn how such effects can be used by programs to communicate with other
    programs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我刚才说的，效果是任何可以从程序外部观察到的内容。当然，为了有价值，这种效果通常必须反映程序的结果，所以你通常需要将程序的结果与它进行某种可观察的操作。请注意，“可观察”并不总是指由人类操作员观察。通常，结果可以被另一个程序观察，然后这个程序可能将这种效果转换成人类操作员可以观察的形式，无论是同步还是异步形式。打印到计算机屏幕可以被操作员看到。另一方面，写入数据库可能并不总是直接对人类用户可见。有时结果将由人类查找，但通常它将在稍后由另一个程序读取。在第14章（[kindle_split_021.xhtml#ch14](https://kindle_split_021.xhtml#ch14)）中，你将了解到这样的效果如何被程序用来与其他程序通信。
- en: 'Because an effect is generally applied to a value, a pure effect can be modeled
    as a special kind of function, returning no value. I represent this in the book
    by the following interface:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为效果通常应用于一个值，所以纯效果可以被建模为一种特殊类型的函数，不返回任何值。我在书中通过以下接口表示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that this is equivalent to Java’s `Consumer` interface. Only the name of
    the class and the name of the method are different. In fact, as I mentioned several
    times in the beginning of this book, names are irrelevant, but meaningful names
    are better.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这相当于 Java 的 `Consumer` 接口。只有类的名称和方法名称不同。实际上，正如我在本书开头提到的几次，名称无关紧要，但有意义的名称更好。
- en: 'The `Effect` interface is what Java calls a functional interface, which roughly
    means an interface with a single abstract method (SAM). To define an effect consisting
    of printing a `Double` value to the screen, you can write this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Effect` 接口是 Java 所称的功能式接口，这大致意味着一个只有一个抽象方法（SAM）的接口。为了定义一个将 `Double` 值打印到屏幕上的效果，你可以编写如下代码：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or better, you can use a method reference:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好，你可以使用方法引用：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that this creates an object of type `Effect<Double>`, so it’s generally
    not the most efficient way to handle effects. Naming effects is similar to naming
    functions: anonymous lambdas (not to be confused with anonymous classes) generally
    compile to a few additional instructions added to the underlying code, whereas
    named lambdas compile to objects. So it’s generally better to use effects as anonymous
    lambdas or anonymous method references. Moreover, using anonymous lambdas relieves
    us of the need to declare the type explicitly.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这创建了一个类型为 `Effect<Double>` 的对象，所以通常这不是处理效果最高效的方式。命名效果类似于命名函数：匿名 lambda（不要与匿名类混淆）通常编译为添加到底层代码的几个额外指令，而命名
    lambda 编译为对象。因此，通常更好的做法是使用匿名 lambda 或匿名方法引用作为效果。此外，使用匿名 lambda 可以使我们不必显式声明类型。
- en: 'What you need is something like this, where `rd` is the `Result` from the example
    in [section 13.1](#ch13lev1sec1):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的是类似这样的东西，其中 `rd` 是 [第 13.1 节](#ch13lev1sec1) 中的示例的 `Result`：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unfortunately, this doesn’t compile because the expression `System.out.println(x)`
    returns `void`, and it would have to return a value to make the code compile.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这无法编译，因为表达式 `System.out.println(x)` 返回 `void`，而它必须返回一个值才能使代码编译。
- en: 'You could use a function that returns a value and prints as a side effect.
    You’d just have to ignore the returned value. But you can do better, as you saw
    in [chapter 7](kindle_split_014.xhtml#ch07). In that chapter, you wrote a `forEach`
    method in the `Result` class that takes an effect and applies it to the underlying
    value. This method was implemented in the `Empty` class as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个返回值并打印副作用的函数。你只需忽略返回的值即可。但你可以做得更好，正如你在第 7 章中看到的。在第 7 章中，你编写了一个 `forEach`
    方法，该方法接受一个效果并将其应用于底层值。这个方法在 `Empty` 类中如下实现：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `Success` class, it was implemented like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Success` 类中，它是这样实现的：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, you can’t write unit tests for this method. To verify that it works,
    you can run the program shown in the following listing and look at the result
    on the screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不能为这个方法编写单元测试。为了验证它是否工作，你可以运行以下列表中的程序，并查看屏幕上的结果。
- en: Listing 13.1\. Outputting data
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1. 输出数据
- en: '![](Images/345fig01_alt.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/345fig01_alt.jpg)'
- en: 'This program produces the following result:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序产生以下结果：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Exercise 13.1
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 13.1
- en: Write a `forEach` method in the `List` class that takes an effect and applies
    it to all the elements of the list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `List` 类中编写一个 `forEach` 方法，该方法接受一个效果并将其应用于列表的所有元素。
- en: Solution 13.1
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 13.1
- en: 'The implementation for the `Nil` class is the same as for `Result.Empty`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nil` 类的实现与 `Result.Empty` 相同：'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The simplest recursive implementation for the `Cons` class would be as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cons` 类的最简单递归实现如下：'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unfortunately, this implementation will blow the stack if you have more than
    a few thousand elements.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果你有超过几千个元素，这个实现将会耗尽堆栈。
- en: 'There are many different solutions to this problem. You can’t use the `TailCall`
    class directly to make recursion stack-safe, but you can use a helper function
    with a side effect and ignore the result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，有许多不同的解决方案。你不能直接使用 `TailCall` 类来使递归堆栈安全，但你可以使用一个带有副作用的帮助函数并忽略结果：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This implementation uses a side effect of the `forEach` helper function, but
    because you’re implementing the application of an effect, it doesn’t really matter
    much. Another (more efficient) solution is simply to use a `while` loop. Choosing
    the implementation is up to you.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现使用了 `forEach` 辅助函数的副作用，但由于你正在实现效果的运用，这实际上并不重要。另一个（更高效）的解决方案是简单地使用 `while`
    循环。选择哪种实现取决于你。
- en: 13.1.3\. More-powerful effects for failures
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.3. 更强大的失败效果
- en: Although it makes sense to do nothing when a list is empty (and the same is
    true for `Option.None` and `Result.Empty`), it’s certainly not enough for processing
    results that might be errors. In that case you might need to apply an effect to
    the errors.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当列表为空时（对于 `Option.None` 和 `Result.Empty` 也是如此）什么都不做是有意义的，但在处理可能出现的错误结果时，这显然是不够的。在这种情况下，你可能需要将效果应用到错误上。
- en: Your `Result` class will contain an `Exception` in case of error. You might
    think of two different effects for this case. The first effect is to throw the
    exception, and the second is to handle the exception in some other way, avoiding
    throwing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `Result` 类在出现错误的情况下将包含一个 `Exception`。你可能认为对于这种情况有两种不同的效果。第一种效果是抛出异常，第二种是处理异常的另一种方式，避免抛出异常。
- en: In [chapter 7](kindle_split_014.xhtml#ch07), you wrote the `forEachOrThrow`
    method in the `Result` class, which took an `Effect` as its argument and applied
    it to the underlying value if it was present, or threw an exception if it was
    a `Failure`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第7章](kindle_split_014.xhtml#ch07) 中，你在 `Result` 类中编写了 `forEachOrThrow` 方法，它接受一个
    `Effect` 作为参数，如果底层值存在，则应用它，如果它是 `Failure`，则抛出异常。
- en: 'The `Empty` implementation of `forEachOrThrow` does nothing and is similar
    to the `forEach` implementation. The `Failure` implementation simply throws the
    contained exception:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEachOrThrow` 的 `Empty` 实现不执行任何操作，类似于 `forEach` 的实现。`Failure` 实现简单地抛出包含的异常：'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Success` implementation is again similar to `forEach` and will apply the
    effect to the contained value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Success` 的实现再次类似于 `forEach`，并将效果应用到包含的值上：'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Throwing an exception in the case of a failure isn’t what you generally want
    to do, at least in the `Result` class. Generally it’s up to the client to decide
    what to do, and you might want to do something less radical than throwing an exception.
    For example, you might want to log the exception before continuing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败的情况下抛出异常并不是你通常想要做的，至少在 `Result` 类中是这样。通常，决定做什么是由客户端来决定的，你可能想要做一些比抛出异常更温和的事情。例如，你可能在继续之前记录这个异常。
- en: Logging isn’t very functional, because logging is generally a side effect. No
    programs are written with logging as their main goal. Applying an effect with
    a method like `forEach` is breaking the functional contract. This isn’t a problem
    in itself, but when you log, you’re suddenly ceasing to be functional—this is
    in some respects the end of a functional program. After the effect is applied,
    you’re ready to start another new functional program.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记录日志并不非常实用，因为日志通常是一个副作用。没有程序是以记录日志作为其主要目标的。使用类似 `forEach` 这样的方法来应用效果是违反函数式契约的。这本身并不是一个问题，但当你记录日志时，你突然就不再是函数式的——这在某些方面意味着函数式程序的终结。效果应用之后，你就可以开始另一个新的函数式程序了。
- en: The frontier between imperative and functional programming won’t be very clear
    if your application logs in every method. But because logging is generally a requirement,
    at least in the Java world, you may want a clean way to do it. You have no simple
    way to log an exception in case of a failure. What you need is to transform a
    failure into a success of its exception. For this, you need direct access to the
    exception, which can’t be done from outside the `Result` context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序在每一个方法中都记录日志，那么命令式编程和函数式编程之间的边界将不会非常清晰。但是，因为日志通常是一个要求，至少在 Java 世界中是这样，你可能想要一个干净的方式来处理它。在失败的情况下，你没有简单的方法来记录一个异常。你需要的是将失败转换为异常的成功。为此，你需要直接访问异常，而这不能从
    `Result` 上下文之外完成。
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Why logging is dangerous**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么记录日志是危险的**'
- en: In functional programming, you won’t see much logging. This is because functional
    programming makes logging mostly useless. Functional programs are built by composing
    pure functions, meaning functions that always return the same value given the
    same argument, so there can’t be any surprises. On the other hand, logging is
    ubiquitous in imperative programming because in imperative programs you can’t
    predict the output for a given input. Logging is like saying “I don’t know what
    the program might produce at this point, so I’ll write it to a log file. If everything
    goes well, I won’t need this log file, but if something goes wrong, I’ll be able
    to look at the logs to see what the program’s state was at this point.” This is
    nonsense.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，你不会看到很多日志记录。这是因为函数式编程使得日志记录变得几乎无用。函数式程序是通过组合纯函数构建的，这意味着对于相同的参数，函数总是返回相同的值，因此不可能有任何意外。另一方面，在命令式编程中，日志记录无处不在，因为在命令式程序中，你无法预测给定输入的输出。日志记录就像是在说“我不知道程序在这个点可能会产生什么，所以我将其写入日志文件。如果一切顺利，我就不需要这个日志文件，但如果出了问题，我就能查看日志来了解程序在这个点的状态。”这是无意义的。
- en: In functional programming, there’s no need for such logs. If all functions are
    correct, which can generally be proved, you don’t need to know the intermediate
    states. Furthermore, logging in imperative programs is often made conditional,
    which means that some logging code will only be executed in very rare and unknown
    states. This code is often untested. If you’ve ever seen an imperative Java program
    that worked well in INFO mode suddenly break when run in TRACE mode, you know
    what I mean.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，不需要这样的日志。如果所有函数都是正确的，这通常是可以证明的，你不需要知道中间状态。此外，在命令式程序中的日志记录通常是条件性的，这意味着某些日志代码只有在非常罕见和未知的状态下才会执行。这段代码通常未经测试。如果你曾经看到过一个在INFO模式下运行良好的命令式Java程序，在TRACE模式下运行时突然崩溃，你就知道我的意思了。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exercise 13.2
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2练习
- en: In [chapter 7](kindle_split_014.xhtml#ch07), you wrote a `forEachOrException`
    method in the `Result` type that worked like `forEach` in `Empty` and `Success`,
    with the addition that it would return a `Result.Empty`, and that returned a `Result.Success<Exception>`
    in the `Failure` class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](kindle_split_014.xhtml#ch07)中，你在`Result`类型中编写了一个`forEachOrException`方法，它在`Empty`和`Success`中的工作方式类似于`forEach`，增加的是它会返回一个`Result.Empty`，并在`Failure`类中返回一个`Result.Success<Exception>`。
- en: Write a `forEachOrFail` method that will return a `Result<String>` with the
    exception message, instead of the exception itself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`forEachOrFail`方法，该方法将返回一个包含异常信息的`Result<String>`，而不是异常本身。
- en: Note that these two methods aren’t functional. Although they return a value,
    they might have a side effect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个方法都不是函数式的。尽管它们返回一个值，但它们可能具有副作用。
- en: Solution 13.2
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2解决方案
- en: 'The implementation in `Empty` does nothing and returns `Empty`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Empty`中的实现不执行任何操作并返回`Empty`：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The implementations in `Success` applies the effect and returns `Empty`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Success`中的实现应用了效果并返回`Empty`：'
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Failure` implementations just return a `Success` of the contained exception
    or of its message:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Failure`实现只是返回包含的异常或其消息的`Success`：'
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These methods, although not functional, greatly simplify the use of `Result`
    values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法，尽管不是函数式的，但极大地简化了`Result`值的用法：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This program will print the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将打印以下内容：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 13.2\. Reading data
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. 读取数据
- en: So far, you’ve only dealt with output. As you saw, outputting data occurs at
    the end of the program, once the result is computed. This allows most of the program
    to be written functionally, with all the benefits of that paradigm. Only the output
    part isn’t functional. I also said that output could be done by sending data to
    other programs, but you haven’t looked at how to input data into your programs.
    Let’s do that now.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只处理了输出。正如你所看到的，数据输出发生在程序的最后，一旦计算出了结果。这允许大多数程序以函数式的方式编写，并享有该范式的所有好处。只有输出部分不是函数式的。我也说过，输出可以通过将数据发送到其他程序来完成，但你还没有看到如何将数据输入到你的程序中。现在让我们来做这件事。
- en: Later we’ll look at a functional way to input data. But first, as we did for
    output, we’ll discuss how to input data in a clean (although nonfunctional and
    imperative) way that fits nicely with the functional parts.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一种函数式的方法来输入数据。但首先，就像我们讨论输出那样，我们将讨论如何以干净（尽管非函数式和命令式的）的方式输入数据，这样就可以很好地与函数式部分相匹配。
- en: 13.2.1\. Reading data from the console
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.1\. 从控制台读取数据
- en: As an example, you’ll read data from the console in a way that, although imperative,
    allows testing by making your programs deterministic. The approach you’ll use
    is similar to what you did with the random generator in [chapter 12](kindle_split_019.xhtml#ch12).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，你将以一种虽然命令式但允许通过使程序确定性来测试的方式从控制台读取数据。你将使用的方法与你对第 12 章中的随机生成器所做的方法类似。
- en: You’ll first develop an example that reads integers and strings. The following
    listing shows the interface you need to implement.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先开发一个示例，该示例读取整数和字符串。以下列表显示了你需要实现的接口。
- en: Listing 13.2\. An interface for inputting data
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2\. 输入数据的接口
- en: '![](Images/350fig01_alt.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/350fig01_alt.jpg)'
- en: You could write a concrete implementation for this interface, but first you’ll
    write an abstract one (because you might want to read data from some other source,
    such as a file). You’ll put the common code in an abstract class and extend it
    for each type of input. The following listing shows this implementation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为这个接口编写一个具体实现，但首先你会写一个抽象实现（因为你可能想从其他来源读取数据，例如文件）。你将把通用代码放在一个抽象类中，并为每种输入类型扩展它。以下列表显示了这种实现。
- en: Listing 13.3\. The `AbstractReader` implementation
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3\. `AbstractReader` 的实现
- en: '![](Images/ch13ex03-0.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch13ex03-0.jpg)'
- en: '![](Images/ch13ex03-1.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch13ex03-1.jpg)'
- en: Now you just have to implement the concrete class in order to read from the
    console. This class will be responsible for providing the `reader`. Additionally,
    you’ll re-implement the two default methods from the interface to display a prompt
    to the user.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要实现一个具体类来从控制台读取。这个类将负责提供 `reader`。此外，你将重新实现接口中的两个默认方法，向用户显示提示。
- en: Listing 13.4\. The `ConsoleReader` implementation
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.4\. `ConsoleReader` 的实现
- en: '![](Images/ch13ex04-0.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch13ex04-0.jpg)'
- en: '![](Images/ch13ex04-1.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch13ex04-1.jpg)'
- en: Now you can use your `ConsoleReader` class with what you’ve learned to write
    a complete program, from input to output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用你学到的 `ConsoleReader` 类来编写一个完整的程序，从输入到输出。
- en: Listing 13.5\. A complete program, from input to output
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.5\. 从输入到输出的完整程序
- en: '![](Images/351fig02_alt.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/351fig02_alt.jpg)'
- en: This isn’t very impressive. It’s the equivalent of the ubiquitous “hello” program
    that’s usually the second example (just after “hello world”) in most programming
    courses! Of course, this is only an example. What’s interesting is how easy it
    is to evolve it into something more useful.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不非常令人印象深刻。这相当于大多数编程课程中普遍存在的“hello”程序，通常是第二个示例（在“hello world”之后）。当然，这只是一个示例。有趣的是，它如何容易地演变成为一个更有用的东西。
- en: Exercise 13.3
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 13.3
- en: Write a program that repeatedly asks the user to input an integer ID, a first
    name, and a last name, and that later displays the list of people on the console.
    Data input stops as soon as the user enters a blank ID, and the list of entered
    data is then displayed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序会反复提示用户输入一个整数 ID、一个名字和一个姓氏，并在稍后显示控制台上的人员列表。当用户输入一个空 ID 时，数据输入停止，然后显示输入的数据列表。
- en: Hint
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You’ll need a class to hold each line of data. Use the `Person` class shown
    in the following listing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个类来保存每行数据。使用以下列表中显示的 `Person` 类。
- en: Listing 13.6\. The `Person` class
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.6\. `Person` 类
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the solution in the main method of a `ReadConsole` class. Use the
    `Stream.unfold` method to produce a stream of persons. You might find it easier
    to create a separate method for inputting the data corresponding to a single person,
    and use a method reference as the argument of `unfold`. This method could have
    the following signature:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ReadConsole` 类的主方法中实现解决方案。使用 `Stream.unfold` 方法生成人员流。你可能发现为输入单个人员对应的数据创建一个单独的方法更容易，并使用方法引用作为
    `unfold` 的参数。此方法可以具有以下签名：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Solution 13.3
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 13.3
- en: 'The solution is very simple. Considering that you have a method for inputting
    the data for a single person, you can create a stream of persons and print the
    result as follows (ignoring any error in this case):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案非常简单。考虑到你有一个用于输入单个人员数据的函数，你可以创建一个人员流，并按如下方式打印结果（忽略任何错误）：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All you need now is the `person` method. This method will simply ask for the
    ID, the first name, and the last name, producing three `Result` instances that
    can be combined using the comprehension pattern you learned in previous chapters:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在只需要 `person` 方法。此方法将简单地询问 ID、名字和姓氏，生成三个 `Result` 实例，这些实例可以使用你在前几章中学到的理解模式进行组合：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the comprehension pattern is probably one of the most important patterns
    in functional programming, so you really want to master it. Other languages such
    as Scala or Haskell have syntactic sugar for it, but Java doesn’t. This corresponds,
    in pseudo code, to something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，理解模式可能是函数式编程中最重要的一种模式，所以你真的需要掌握它。其他语言，如 Scala 或 Haskell，为此提供了语法糖，但 Java 没有提供。在伪代码中，这对应于以下内容：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: But you don’t really need the syntactic sugar. The `flatMap` idiom is perhaps
    more difficult to master at first, but it really shows what’s happening.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但你实际上并不需要这种语法糖。`flatMap` 习语可能一开始比较难掌握，但它确实展示了正在发生的事情。
- en: 'By the way, many programmers know this pattern as the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，许多程序员都知道这个模式如下：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'They often think it’s always a series of `flatMap`s ending with a `map`. This
    is absolutely not the case. Whether it ends with `map` or `flatMap` depends solely
    on the return type. It often happens that the last method (here, `getSomething`)
    returns a bare value, which is why the pattern ends with a `map`. But if `getSomething`
    were to return a context (such as a `Result`), the pattern would be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 他们常常认为它总是以一系列的 `flatMap` 结尾，最后是 `map`。这绝对不是事实。它是否以 `map` 或 `flatMap` 结尾完全取决于返回类型。通常情况下，最后一个方法（这里指的是
    `getSomething`）返回一个裸值，这就是为什么模式以 `map` 结尾。但如果 `getSomething` 返回一个上下文（例如 `Result`），模式如下：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 13.2.2\. Reading from a file
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.2. 从文件中读取
- en: The way you’ve designed the program makes it very simple to adapt it to reading
    files. The `FileReader` class is very similar to the `ConsoleReader`. The only
    difference is that the static factory method must handle an `IOException` so it
    returns a `Result<Input>` instead of a bare value.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你设计的程序使得将其适应读取文件变得非常简单。`FileReader` 类与 `ConsoleReader` 非常相似。唯一的区别是静态工厂方法必须处理
    `IOException`，因此它返回 `Result<Input>` 而不是裸值。
- en: Listing 13.7\. The `FileReader` implementation
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.7. `FileReader` 的实现
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Exercise 13.4
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 13.4
- en: Write a `ReadFile` program, similar to `ReadConsole`, but that reads from a
    file containing the entries, each one on a separate line. An example file is provided
    with the code accompanying this book ([http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `ReadFile` 程序，类似于 `ReadConsole`，但它从包含条目的文件中读取，每行一个条目。本书附带代码中提供了一个示例文件（[http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava)）。
- en: Hint
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Although it’s similar to the `ReadConsole` program, you’ll have to deal with
    the fact that the factory method returns a `Result`. Try to reuse the same `person`
    method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它与 `ReadConsole` 程序类似，但你必须处理工厂方法返回 `Result` 的事实。尽量重用相同的 `person` 方法。
- en: Solution 13.4
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 13.4
- en: The solution is given in [listing 13.8](#ch13ex08). Note how the `Result` returned
    by the factory method is handled before calling the `person` method, allowing
    you to use the same method as for the `ConsoleReader`. (You could also use the
    `read` methods that don’t take any parameters.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案在 [列表 13.8](#ch13ex08) 中给出。注意在调用 `person` 方法之前如何处理工厂方法返回的 `Result`，这允许你使用与
    `ConsoleReader` 相同的方法。（你也可以使用不带任何参数的 `read` 方法。）
- en: Listing 13.8\. The `ReadFile` implementation
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.8. `ReadFile` 的实现
- en: '![](Images/354fig01_alt.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/354fig01_alt.jpg)'
- en: 13.2.3\. Testing with input
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.2.3. 使用输入进行测试
- en: One of the benefits of the approach you took in the preceding solution is that
    the program is easily testable. Of course, it would be possible to test your programs
    by providing files instead of user input at the console, but it’s just as easy
    to interface your program with another program that produces a script of the input
    commands. The following listing shows an example `ScriptReader` that could be
    used for testing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个解决方案中采取的方法的一个好处是程序很容易测试。当然，你可以通过在控制台提供文件而不是用户输入来测试你的程序，但与将程序与生成输入命令脚本的另一个程序接口一样容易。以下列表显示了一个可以用于测试的示例
    `ScriptReader`。
- en: Listing 13.9\. A `ScriptReader` that allows you to use a list of input commands
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.9. 允许使用输入命令列表的 `ScriptReader`
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The next listing shows an example of using the `ScriptReader` class. In the
    code accompanying this book, you’ll find examples of unit testing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了一个使用 `ScriptReader` 类的示例。在本书的代码中，你可以找到单元测试的示例。
- en: Listing 13.10\. Using the `ScriptReader` to enter data
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.10. 使用 `ScriptReader` 输入数据
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 13.3\. Really functional input/output
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3. 真正的功能性输入/输出
- en: What you’ve learned so far is sufficient for most Java programmers. Separating
    the functional part of the program from the nonfunctional parts is essential,
    and also sufficient. But it’s interesting to see how Java programs can be made
    even more functional.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止学到的知识对于大多数Java程序员来说已经足够了。将程序的函数部分与非函数部分分开是必要的，也是足够的。但是，了解Java程序如何变得更加函数化是非常有趣的。
- en: Whether you use the following techniques in Java programs in production is up
    to you. It might not be worth the additional complexity. It is, however, useful
    and interesting to learn these techniques so you can make an educated choice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否在Java程序的生产环境中使用以下技术取决于你。这可能不值得额外的复杂性。然而，学习这些技术是有用且有趣的，这样你可以做出明智的选择。
- en: 13.3.1\. How can input/output be made fully functional?
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1\. 如何使输入/输出完全函数化？
- en: 'There are several answers to this question. The shortest answer is this: it
    can’t. According to our definition of a functional program, which is “a program
    that has no other observable effect than returning a value,” there’s no way to
    do any input or output.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题有几个答案。最简短的答案是：它不能。根据我们对函数式程序的定义，即“一个除了返回值外没有其他可观察效果的程序”，无法进行任何输入或输出。
- en: 'But many programs don’t need to do any input or output. For example, many libraries
    fall into that category. Libraries are programs that are designed to be used by
    other programs. They receive argument values, and they return values resulting
    from computations based on their arguments. What you did in the first two sections
    of this chapter was separate your programs into three parts: one doing the input,
    one doing the output, and a third part acting as a library and being fully functional.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，许多程序不需要进行任何输入或输出。例如，许多库都属于这一类。库是设计为供其他程序使用的程序。它们接收参数值，并根据它们的参数返回计算结果。在本章的前两节中，你将你的程序分为三个部分：一个进行输入，一个进行输出，第三个部分作为库，并且完全函数化。
- en: Another way to handle the problem is to write this library part, and produce,
    as the final return value, another (nonfunctional) program that handles all the
    input and output. This is very similar in concept to laziness. You can handle
    input and output as something that will happen later, in a separate program that
    will be the returned value of your pure functional program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 处理问题的另一种方法是编写这个库部分，并生成一个最终返回值，即另一个（非功能性的）程序，该程序处理所有输入和输出。这在概念上与惰性非常相似。你可以将输入和输出视为将来在单独的程序中发生的事情，该程序将是你的纯函数式程序的返回值。
- en: 13.3.2\. Implementing purely functional input/output
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2\. 实现纯函数式输入/输出
- en: In this section, you’ll see how to implement purely functional input/output.
    Let’s start with output. Imagine that you simply want to display a welcome message
    to the console. For now, you’ll assume you already know the name to use for the
    message. Instead of writing this
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解如何实现纯函数式输入/输出。让我们从输出开始。想象一下，你只想在控制台显示一条欢迎信息。目前，你将假设你已经知道要使用的信息名称。而不是编写这个
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'we could make the `sayHello` method return a program that, once run, will have
    the same effect. To do so, you might use a lambda and the `Runnable` interface,
    like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使得`sayHello`方法返回一个程序，一旦运行，就会产生相同的效果。为此，你可能使用lambda和`Runnable`接口，如下所示：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can use this method as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方法使用此方法：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code is purely functional. You could argue that it doesn’t do anything
    visible, and this is true. It produces a program that can be run to produce the
    desired effect. This program can be run by calling the `run` method on the `Runnable`
    it produces. The returned program isn’t functional, but you don’t care. Your program
    is functional.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是纯函数式的。你可以争论说它没有做任何可见的事情，这是真的。它生成一个可以运行以产生所需效果的程序。这个程序可以通过调用它生成的`Runnable`对象的`run`方法来运行。返回的程序不是函数式的，但你并不关心。你的程序是函数式的。
- en: Is this cheating? No. Think of a program written in any “functional” language.
    In the end, it’s compiled into an executable program that’s absolutely not functional
    and that can be run on your computer. You’re doing exactly the same thing, except
    that the program you’re producing might seem to be written in Java. In fact, it’s
    not. It’s written in some kind of DSL (domain-specific language) that your program
    is constructing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在作弊吗？不是。想想任何“函数式”语言编写的程序。最终，它被编译成一个可执行的程序，这个程序绝对不是函数式的，并且可以在你的计算机上运行。你正在做的是完全相同的事情，只是你生成的程序可能看起来像是用Java编写的。实际上，它不是。它是用某种类型的DSL（领域特定语言）编写的，你的程序正在构建这种语言。
- en: To execute this program, you can simply write
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个程序，你可以简单地写下：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Be aware that most code-checker programs won’t like the fact that `run` is called
    on a `Runnable`. This is why, in previous chapters, you created the `Executable`
    interface to do the same thing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，大多数代码检查程序不会喜欢在`Runnable`上调用`run`的事实。这就是为什么在之前的章节中，你创建了`Executable`接口来做同样的事情。
- en: 'Here, you need something much more powerful, so you’ll create a new interface
    named `IO`. You’ll start with a single `run` method. At this stage, it’s no different
    from `Runnable`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要更强大的功能，所以你会创建一个新的接口名为`IO`。你将从单个`run`方法开始。在这个阶段，它与`Runnable`没有区别：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Suppose you have the three following methods:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有以下三个方法：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You might write the following purely functional program:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会编写以下纯函数式程序：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This program produces another program that can later be executed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序生成另一个可以稍后执行的程序：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 13.3.3\. Combining IO
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.3\. 结合IO
- en: With your `IO` interface, you can potentially build any program, but as a single
    unit. It would be interesting to be able to combine such programs. The simplest
    combination you could use consists of grouping two programs into one. This is
    what you’ll do in the following exercise.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的`IO`接口，你可以构建任何程序，但作为一个单一单元。能够组合这样的程序将很有趣。你可以使用的最简单的组合是将两个程序组合成一个。这就是你将在以下练习中做的。
- en: Exercise 13.5
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习13.5
- en: 'Create a method in the `IO` interface allowing you to group two `IO` instances
    into one. This method will be called `add`, and it will have a default implementation.
    Here’s the signature:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IO`接口中创建一个方法，允许你将两个`IO`实例组合成一个。这个方法将被称为`add`，并且它将有一个默认实现。以下是签名：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Solution 13.5
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案13.5
- en: 'The solution is simply to return a new `IO` with a `run` implementation that
    will first execute the current `IO`, and then the argument `IO`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很简单，就是返回一个新的`IO`，它有一个`run`实现，首先执行当前的`IO`，然后执行参数`IO`：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You’ll later need a “do nothing” `IO` to serve as a neutral element for some
    `IO` combinations. This can easily be created in the IO interface as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你稍后需要一个“什么也不做”的`IO`来作为某些`IO`组合的中性元素。这可以在IO接口中轻松创建，如下所示：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using these new methods, you can create more-sophisticated programs by combining
    `IO` instances:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些新方法，你可以通过组合`IO`实例来创建更复杂的程序：
- en: '![](Images/359fig01_alt.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/359fig01_alt.jpg)'
- en: 'Of course, you can simplify the process:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以简化这个过程：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can also create a program from a list of instructions:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从一系列指令创建一个程序：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Does this look like an imperative program? In fact, it is. To “compile it,”
    you might use a right fold:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个命令式程序吗？实际上，它是。为了“编译”它，你可能使用一个右折叠：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or a left fold:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个左折叠：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can see why you needed a “do nothing” implementation. Finally, you can
    run the program as usual:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到为什么需要一个“什么也不做”的实现。最后，你可以像通常一样运行程序：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 13.3.4\. Handling input with IO
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.4\. 使用IO处理输入
- en: 'At this point, your `IO` type can only handle output. To make it handle input,
    one necessary change is to parameterize it with the type of the input value, so
    that it can be used to handle this value. Here’s the new parameterized `IO` type:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的`IO`类型只能处理输出。为了使其能够处理输入，一个必要的更改是使用输入值的类型对其进行参数化，以便它可以用来处理这个值。以下是新的参数化`IO`类型：
- en: '![](Images/359fig02_alt.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/359fig02_alt.jpg)'
- en: As you can see, the `IO` interface creates a context for computations in the
    same way `Option`, `Result`, `List`, `Stream`, `State`, and the like did. It similarly
    has a method returning an empty instance, as well as a method that puts a bare
    value in context.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`IO`接口以与`Option`、`Result`、`List`、`Stream`、`State`等类似的方式创建计算上下文。它同样有一个返回空实例的方法，以及一个将裸值放入上下文的方法。
- en: In order to perform computations on `IO` values, you now need methods like `map`
    and `flatMap` to bind functions to the `IO` context.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`IO`值上执行计算，你现在需要像`map`和`flatMap`这样的方法来将函数绑定到`IO`上下文。
- en: Exercise 13.6
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习13.6
- en: Define a `map` method in `IO<A>` that takes as its argument a function from
    `A` to `B` and returns an `IO<B>`. Make this a `default` implementation in the
    `IO` interface.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IO<A>`中定义一个`map`方法，它接受一个从`A`到`B`的函数作为其参数，并返回一个`IO<B>`。在`IO`接口中将其作为默认实现。
- en: Solution 13.6
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案13.6
- en: 'Here’s the implementation, which applies the function to the value of `this`,
    and returns the result in a new `IO` context:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现，它将函数应用于`this`的值，并在新的`IO`上下文中返回结果：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Exercise 13.7
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习13.7
- en: Write a `flatMap` method that takes a function from `A` to `IO<B>` as its argument
    and returns an `IO<B>`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`flatMap`方法，它接受一个从`A`到`IO<B>`的函数作为其参数，并返回一个`IO<B>`。
- en: Hint
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t worry about a potential stack problem. You’ll deal with this later.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心潜在的栈问题。您将在以后处理这个问题。
- en: Solution 13.7
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 13.7
- en: 'Applying the function to the value obtained by running `thisIO` would give
    an `IO<IO<B>>`. You need to flatten this result, which can be done very simply
    by running it, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数应用于运行 `thisIO` 获得的值将给出 `IO<IO<B>>`。您需要展开这个结果，这可以通过简单地运行它来完成，如下所示：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, this is kind of recursive. It won’t be a problem at first, because
    there’s only one recursion step, but it could become a problem if you were to
    chain a huge number of `flatMap` calls.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这有点递归。一开始这不会是问题，因为只有一个递归步骤，但如果您要链式调用大量的 `flatMap` 调用，它可能会成为问题。
- en: To see your new methods in action, use the following `Console` class.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您的新方法如何工作，请使用以下 `Console` 类。
- en: Listing 13.11\. The `Console` class
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.11\. `Console` 类
- en: '![](Images/ch13ex11-0.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch13ex11-0.jpg)'
- en: '![](Images/ch13ex11-1.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch13ex11-1.jpg)'
- en: It’s important to note that these two methods are purely functional. They don’t
    throw any exceptions, nor do they read from or print to the console. They only
    return programs that do those things.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这两个方法完全是函数式的。它们不会抛出任何异常，也不会从控制台读取或打印。它们只返回执行这些操作的程序。
- en: To see this at work, you can run the following example program.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个程序的工作情况，您可以运行以下示例程序。
- en: Listing 13.12\. Reading from and printing to the console in a purely functional
    way
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.12\. 以纯函数方式从控制台读取和打印
- en: '![](Images/361fig01_alt.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/361fig01_alt.jpg)'
- en: 13.3.5\. Extending the IO type
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.5\. 扩展 IO 类型
- en: By using the `IO` type, you can create impure programs (programs with effects)
    in a purely functional way. But at this stage, these programs only allow us to
    read from and print to an element such as your `Console` class. You can extend
    your DSL by adding instructions to create control structures, such as loops and
    conditionals.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `IO` 类型，您可以在纯函数方式中创建不纯的程序（具有效果的程序）。但在这个阶段，这些程序只能让我们从类似 `Console` 类的元素中读取和打印。您可以通过添加创建控制结构（如循环和条件）的指令来扩展您的
    DSL。
- en: First, you’ll implement a loop similar to the `for` indexed loop. This will
    take the form of a `repeat` method that takes the number of iterations and the
    `IO` to repeat as its parameters.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将实现一个类似于 `for` 索引循环的循环。这将采取 `repeat` 方法的形式，该方法接受迭代次数和要重复的 `IO` 作为参数。
- en: Exercise 13.8
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 13.8
- en: 'Implement `repeat` as a static method in the `IO` interface with the following
    signature:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `IO` 接口中将 `repeat` 实现为一个静态方法，其签名如下：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Hint
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'You should create a collection of `IO` instances representing each iteration,
    and then fold this collection by combining the `IO` instances. To do this, you’ll
    need something more powerful than the `add` method. Start by implementing a `map2`
    method with the following signature:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该创建一个表示每个迭代的 `IO` 实例的集合，然后通过组合 `IO` 实例来折叠这个集合。为此，您需要比 `add` 方法更强大的功能。首先，实现一个具有以下签名的
    `map2` 方法：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Solution 13.8
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 13.8
- en: 'The `map2` method can be implemented as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`map2` 方法可以按以下方式实现：'
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is a simple application of the ubiquitous comprehension pattern. With
    this method at hand, you can easily implement `repeat` as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普遍存在的理解模式的简单应用。有了这个方法，您可以轻松地实现 `repeat`，如下所示：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note that you create a stream using the `Stream.fill()` method, which has the
    following signature:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您使用 `Stream.fill()` 方法创建流，该方法具有以下签名：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It returns a `Stream` of *n* (lazily evaluated) instances of `T`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含 `T` 类型 `n` 个（懒加载）实例的 `Stream`。
- en: 'This may look a bit complex, but that’s partly because of the line being wrapped
    for printing, and partly because it’s written as a one-liner for optimization.
    It’s equivalent to this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点复杂，但部分原因是由于打印时换行，部分原因是它被写成一行以进行优化。它与以下内容等效：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you’re using an IDE, it’s relatively easy to find the types. For example,
    in IntelliJ, you just have to put the mouse pointer on a reference while holding
    down the Ctrl key to display the type.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 IDE，找到类型相对容易。例如，在 IntelliJ 中，您只需在按住 Ctrl 键的同时将鼠标指针放在引用上，就可以显示类型。
- en: 'With these methods you can now write the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法，您现在可以编写以下代码：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will give you a program corresponding to calling the following method
    as `sayHello(3)`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出一个与调用以下方法作为 `sayHello(3)` 相对应的程序：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The very important difference, however, is that calling `sayHello(3)` will execute
    the effect three times eagerly, whereas `IO.repeat(3, sayHello())` will simply
    return a (non-evaluated) program that will do the same only when its `run` method
    is called.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非常重要的区别是，调用`sayHello(3)`会三次积极地执行效果，而`IO.repeat(3, sayHello())`将简单地返回一个（未评估的）程序，它只有在调用其`run`方法时才会执行相同的效果。
- en: It’s possible to define many other control structures. You’ll find examples
    in the accompanying code that can be downloaded from [http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava).
    The following listing shows an example of using `when` and `doWhile` methods that
    do exactly the same thing as `if` and `while` in imperative Java.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义许多其他控制结构。你可以在附带的代码中找到示例，这些代码可以从[http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava)下载。以下列表显示了使用`when`和`doWhile`方法的示例，这些方法与命令式Java中的`if`和`while`做完全相同的事情。
- en: Listing 13.13\. Using `IO` to wrap imperative programming
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.13\. 使用`IO`封装命令式编程
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This example isn’t meant to suggest that you should program like this. It’s
    certainly better to use the `IO` type only for input and output, doing all the
    computations in functional programming. After all, if you choose to learn functional
    programming, it’s probably not to implement an imperative language in functional
    code. But it’s interesting to do it as an exercise, to understand how it works.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子并不是建议你应该这样编程。当然，最好只使用`IO`类型进行输入和输出，在函数式编程中完成所有计算。毕竟，如果你选择学习函数式编程，可能不是为了在函数式代码中实现命令式语言。但作为一个练习，了解它是如何工作的，这是很有趣的。
- en: 13.3.6\. Making the IO type stack-safe
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.6\. 使`IO`类型堆栈安全
- en: In the previous exercises, you might not have noticed that some of the `IO`
    methods used the stack in the same way recursive methods do. The `repeat` method,
    for example, will overflow the stack if the number of repetitions is too high.
    How much “too high” is depends on the stack size and how full it is when the program
    returned by the method is run. (By now, I expect you understand that calling the
    `repeat` method won’t blow the stack. Only running the program it returns might
    do so.)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，你可能没有注意到一些`IO`方法使用了与递归方法相同的方式使用栈。例如，`repeat`方法如果重复次数太高，就会导致栈溢出。"太高"的具体数值取决于栈的大小以及当方法返回的程序运行时栈的满载程度。（到现在为止，我期望你已经理解调用`repeat`方法不会导致栈溢出。只有运行它返回的程序才可能这样做。）
- en: Exercise 13.9
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 13.9
- en: 'In order to experiment with blowing the stack, create a `forever` method that
    takes an `IO` as its argument and returns a new `IO` executing the argument in
    an endless loop. Here’s the corresponding signature:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验栈溢出，创建一个接受`IO`作为参数并返回一个在无限循环中执行该参数的新`IO`的`forever`方法。以下是相应的签名：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Solution 13.9
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案 13.9
- en: 'This is as simple to implement as it is useless! All you have to do is make
    the constructed program infinitely recursive. Be aware that the `forever` method
    itself should not be recursive. Only the returned program should be. The solution
    is to use a `Supplier`, and to `flatMap` the `IO` argument with an `IO` executing
    `get` on this `Supplier`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像它的无用性一样简单实现！你所要做的就是使构造的程序无限递归。请注意，`forever`方法本身不应该递归。只有返回的程序应该递归。解决方案是使用`Supplier`，并将`IO`参数与执行`get`操作的`Supplier`的`IO`进行`flatMap`：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This method can be used as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以这样使用：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It will blow the stack after a few thousand iterations. Note that this is equivalent
    to the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它在几千次迭代后会溢出栈。请注意，这与以下代码等效：
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you don’t see why it blows the stack, consider the following pseudo code
    (which won’t compile!) where the `t` variable is replaced by the corresponding
    expression:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道为什么会导致栈溢出，可以考虑以下伪代码（这个代码无法编译！）其中`t`变量被相应的表达式替换：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now let’s replace the recursive call with the corresponding code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用相应的代码替换递归调用：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You could continue forever recursively. (Remember, you shouldn’t try to compile
    this code!) What you may notice is that the calls to `flatMap` would be nested,
    resulting in the current state being pushed onto the stack with each call, which
    would indeed blow the stack after a few thousand steps. Unlike in imperative code,
    where you’d execute one instruction after the other, you call the `flatMap` method
    recursively.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以无限递归地继续。 （记住，你不应该尝试编译这段代码！）你可能注意到`flatMap`的调用将是嵌套的，每次调用都会将当前状态推入栈中，这确实会在几千步后导致栈溢出。与命令式代码不同，在命令式代码中你会依次执行一条指令，你调用`flatMap`方法递归。
- en: 'To make `IO` stack-safe, you can use the same technique you used in [chapter
    4](kindle_split_011.xhtml#ch04) to create stack-safe recursive methods and functions.
    First, you’ll need to represent three states of your program:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`IO`堆栈安全，你可以使用与你在[第4章](kindle_split_011.xhtml#ch04)中创建堆栈安全递归方法和函数相同的技巧。首先，你需要表示你程序的三种状态：
- en: '`Return` will represent a computation that’s finished, meaning that you just
    have to return the result.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Return`将表示一个完成的计算，这意味着你只需返回结果。'
- en: '`Suspend` will represent a suspended computation, when some effect has to be
    applied before resuming the current computation.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Suspend`将表示一个挂起的计算，当在恢复当前计算之前必须应用某些效果时。'
- en: '`Continue` will represent a state where the program has to first apply a subcomputation
    before continuing with the next one.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Continue`将表示一个程序必须首先应用子计算然后再继续下一个的状态。'
- en: These states will be represented by the three classes shown in [listing 13.14](#ch13ex14).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态将由以下三个类表示[列表13.14](#ch13ex14)。
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Listings 13.14](#ch13ex14) through [13.16](#ch13ex16) are parts of a whole.
    They aren’t supposed to be used with the code constructed so far, but together.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表13.14](#ch13ex14)至[列表13.16](#ch13ex16)是整体的一部分。它们不应该与迄今为止构建的代码一起使用，而应该一起使用。'
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 13.14\. The three classes needed to make `IO` stack-safe
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.14\. 使`IO`堆栈安全所需的三个类
- en: '![](Images/ch13ex14-0.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch13ex14-0.jpg)'
- en: '![](Images/ch13ex14-1.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch13ex14-1.jpg)'
- en: Some modifications must be made to the enclosing `IO` interface, as shown in
    [listings 13.15](#ch13ex15) and [13.16](#ch13ex16).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 必须对封装的`IO`接口进行一些修改，如[列表13.15](#ch13ex15)和[13.16](#ch13ex16)所示。
- en: Listing 13.15\. Changes in the stack-safe version of `IO`
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.15\. `IO`堆栈安全版本的更改
- en: '![](Images/ch13ex15-0.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch13ex15-0.jpg)'
- en: '![](Images/ch13ex15-1.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch13ex15-1.jpg)'
- en: Listing 13.16\. The stack-safe `run` method
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.16\. 堆栈安全的`run`方法
- en: '![](Images/ch13ex16-0.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch13ex16-0.jpg)'
- en: '![](Images/ch13ex16-1.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch13ex16-1.jpg)'
- en: The new stack-safe version can be used as follows.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 新的堆栈安全版本可以使用如下方式。
- en: Listing 13.17\. The new `Console` class using the stack-safe version
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.17\. 使用堆栈安全版本的`Console`类
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now you can use `forever` or `doWhile` without the risk of overflowing the stack.
    You can also rewrite `repeat` to make it stack-safe. I won’t show the new implementation
    here, but you’ll find it in the accompanying code ([http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava)).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用`forever`或`doWhile`而不用担心堆栈溢出。你也可以重写`repeat`使其堆栈安全。这里我不会展示新的实现，但你可以从配套代码([http://github.com/fpinjava/fpinjava](http://github.com/fpinjava/fpinjava))中找到它。
- en: Keep in mind that this is not the recommended way to write functional programs.
    Take it as an example of what can ultimately be done, rather than as good practice.
    Also note that “ultimately,” here, applies to Java programming. With a more functional-friendly
    language, you can craft much more powerful programs.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这并不是编写函数式程序的建议方式。将其视为一个最终可以完成的例子，而不是作为良好实践。此外，请注意，“最终”在这里适用于Java编程。使用更函数式友好的语言，你可以构建更强大的程序。
- en: 13.4\. Summary
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4\. 摘要
- en: Effects can be passed into `List`, `Result`, and other contexts to be safely
    applied to values, rather than extracting values from these contexts and applying
    the effects outside, which might produce errors if there are no values.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将效果传递到`List`、`Result`和其他上下文中，安全地应用于值，而不是从这些上下文中提取值并在外部应用效果，如果没有值，这可能会导致错误。
- en: Handling two different effects for success and failure can be abstracted inside
    the `Result` type.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功和失败两种不同效果的处理可以抽象在`Result`类型内部。
- en: Reading data can be done in the same way as random numbers were generated in
    [chapter 12](kindle_split_019.xhtml#ch12).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取数据可以像在[第12章](kindle_split_019.xhtml#ch12)中生成随机数一样进行。
- en: Reading from files is done in exactly the same way as reading from the console
    or from memory through the `Reader` abstraction.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中读取的方式与从控制台或通过`Reader`抽象从内存中读取的方式完全相同。
- en: More-functional input/output can be obtained through the `IO` type.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`IO`类型可以获得更多功能的输入/输出。
- en: The `IO` type can be extended to a more generic type that makes it possible
    to perform any imperative task in a functional way by building a program that
    will be executed later.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IO`类型可以扩展为一个更通用的类型，这使得通过构建稍后将要执行的程序以函数式方式执行任何命令式任务成为可能。'
- en: The `IO` type can be made stack-safe by using the same techniques we used for
    stack-safe recursive methods.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用与堆栈安全递归方法和函数相同的技巧来使`IO`类型堆栈安全。
