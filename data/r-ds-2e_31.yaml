- en: Chapter 26\. Iteration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 26 章 迭代
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, you’ll learn tools for iteration, repeatedly performing the
    same action on different objects. Iteration in R generally tends to look rather
    different from other programming languages because so much of it is implicit and
    we get it for free. For example, if you want to double a numeric vector `x` in
    R, you can just write `2 * x`. In most other languages, you’d need to explicitly
    double each element of `x` using some sort of for loop.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习迭代工具，重复对不同对象执行相同操作。在 R 中，迭代通常看起来与其他编程语言大不相同，因为其中很多都是隐含的并且我们可以免费获取。例如，如果您想在
    R 中将数值向量 `x` 加倍，您只需写 `2 * x`。而在大多数其他语言中，您需要使用某种循环显式地将 `x` 的每个元素加倍。
- en: 'This book has already given you a small but powerful number of tools that perform
    the same action for multiple “things”:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书已经为您提供了一些小而强大的工具，用于对多个“事物”执行相同操作：
- en: '[`facet_wrap()`](https://ggplot2.tidyverse.org/reference/facet_wrap.xhtml)
    and [`facet_grid()`](https://ggplot2.tidyverse.org/reference/facet_grid.xhtml)
    draw a plot for each subset.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`facet_wrap()`](https://ggplot2.tidyverse.org/reference/facet_wrap.xhtml)
    和 [`facet_grid()`](https://ggplot2.tidyverse.org/reference/facet_grid.xhtml) 分别为每个子集绘制图表。'
- en: '[`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml) plus [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)
    computes a summary statistics for each subset.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`group_by()`](https://dplyr.tidyverse.org/reference/group_by.xhtml) 加上 [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)
    为每个子集计算汇总统计信息。'
- en: '[`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    and [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    create new rows and columns for each element of a list column.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    和 [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    分别为列表列的每个元素创建新的行和列。'
- en: 'Now it’s time to learn some more general tools, often called *functional programming*
    tools because they are built around functions that take other functions as inputs.
    Learning functional programming can easily veer into the abstract, but in this
    chapter we’ll keep things concrete by focusing on three common tasks: modifying
    multiple columns, reading multiple files, and saving multiple objects.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习一些更通用的工具了，通常称为*函数式编程*工具，因为它们围绕接受其他函数作为输入的函数构建。学习函数式编程很容易偏向抽象，但在本章中，我们将通过专注于三个常见任务来保持具体性：修改多个列、读取多个文件和保存多个对象。
- en: Prerequisites
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'In this chapter, we’ll focus on tools provided by dplyr and purrr, both core
    members of the tidyverse. You’ve seen dplyr before, but [purrr](https://oreil.ly/f0HWP)
    is new. We’re just going to use a couple of purrr functions in this chapter, but
    it’s a great package to explore as you improve your programming skills:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于 tidyverse 的核心成员 dplyr 和 purrr 提供的工具。您之前见过 dplyr，但是[purrr](https://oreil.ly/f0HWP)是新的。在本章中，我们只会使用
    purrr 的一些函数，但随着您提高编程技能，它是一个探索的好工具包：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Modifying Multiple Columns
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改多个列
- en: 'Imagine you have this simple tibble and you want to count the number of observations
    and compute the median of every column:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个简单的 tibble，并且您想计算每列的观察数量并计算中位数：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You could do it with copy and paste:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过复制粘贴来完成：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That breaks our rule of thumb to never copy and paste more than twice, and
    you can imagine that this will get tedious if you have tens or even hundreds of
    columns. Instead, you can use [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这违反了我们的经验法则，即不要复制粘贴超过两次，您可以想象，如果您有数十甚至数百列，这将变得很乏味。相反，您可以使用 [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) has three
    particularly important arguments, which we’ll discuss in detail in the following
    sections. You’ll use the first two every time you use [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml):
    the first argument, `.cols`, specifies which columns you want to iterate over,
    and the second argument, `.fns`, specifies what to do with each column. You can
    use the `.names` argument when you need additional control over the names of output
    columns, which is particularly important when you use [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml). We’ll also
    discuss two important variations, [`if_any()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    and [`if_all()`](https://dplyr.tidyverse.org/reference/across.xhtml), which work
    with [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) 有三个特别重要的参数，我们将在以下部分详细讨论。每次使用
    [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) 时，您都会使用前两个参数：第一个参数
    `.cols` 指定要迭代的列，第二个参数 `.fns` 指定要对每列执行的操作。当您在 [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)
    中使用 [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) 时，使用 `.names`
    参数能够对输出列的名称进行额外控制，这尤其重要。我们还将讨论两个重要的变体，[`if_any()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    和 [`if_all()`](https://dplyr.tidyverse.org/reference/across.xhtml)，它们与 [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)
    一起使用。'
- en: Selecting Columns with .cols
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `.cols` 选择列
- en: The first argument to [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml),
    `.cols`, selects the columns to transform. This uses the same specifications as
    [`select()`](https://dplyr.tidyverse.org/reference/select.xhtml), [“select()”](ch03.xhtml#sec-select),
    so you can use functions such as [`starts_with()`](https://tidyselect.r-lib.org/reference/starts_with.xhtml)
    and [`ends_with()`](https://tidyselect.r-lib.org/reference/starts_with.xhtml)
    to select columns based on their name.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) 的第一个参数 `.cols`
    选择要转换的列。这使用与 [`select()`](https://dplyr.tidyverse.org/reference/select.xhtml)
    相同的规范，所以您可以使用诸如 [`starts_with()`](https://tidyselect.r-lib.org/reference/starts_with.xhtml)
    和 [`ends_with()`](https://tidyselect.r-lib.org/reference/starts_with.xhtml) 的函数根据列名选择列。'
- en: 'There are two additional selection techniques that are particularly useful
    for [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml): [`everything()`](https://tidyselect.r-lib.org/reference/everything.xhtml)
    and [`where()`](https://tidyselect.r-lib.org/reference/where.xhtml). [`everything()`](https://tidyselect.r-lib.org/reference/everything.xhtml)
    is straightforward: it selects every (nongrouping) column:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种额外的选择技术特别适用于[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)：[`everything()`](https://tidyselect.r-lib.org/reference/everything.xhtml)
    和 [`where()`](https://tidyselect.r-lib.org/reference/where.xhtml)。[`everything()`](https://tidyselect.r-lib.org/reference/everything.xhtml)
    很简单：它选择每个（非分组）列：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note grouping columns (`grp` here) are not included in [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml),
    because they’re automatically preserved by [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意分组列（此处为 `grp`）不包括在 [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    中，因为它们会被 [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)
    自动保留。
- en: '[`where()`](https://tidyselect.r-lib.org/reference/where.xhtml) allows you
    to select columns based on their type:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[`where()`](https://tidyselect.r-lib.org/reference/where.xhtml) 允许您根据列的类型进行选择：'
- en: '`where(is.numeric)`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`where(is.numeric)`'
- en: Selects all numeric columns.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有数值列。
- en: '`where(is.character)`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`where(is.character)`'
- en: Selects all string columns.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有字符串列。
- en: '`where(is.Date)`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`where(is.Date)`'
- en: Selects all date columns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有日期列。
- en: '`where(is.POSIXct)`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`where(is.POSIXct)`'
- en: Selects all date-time columns.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有日期时间列。
- en: '`where(is.logical)`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`where(is.logical)`'
- en: selects all logical columns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 选择所有逻辑列。
- en: Just like other selectors, you can combine these with Boolean algebra. For example,
    `!where(is.numeric)` selects all non-numeric columns, and `starts_with("a") &
    where(is.logical)` selects all logical columns whose name starts with “a.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他选择器一样，您可以将它们与布尔代数结合使用。例如，`!where(is.numeric)` 选择所有非数值列，而 `starts_with("a")
    & where(is.logical)` 选择所有名称以“a”开头的逻辑列。
- en: Calling a Single Function
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用单个函数
- en: 'The second argument to [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    defines how each column will be transformed. In simple cases, as shown, this will
    be a single existing function. This is a pretty special feature of R: we’re passing
    one function (`median`, `mean`, `str_flatten`, …) to another function (`across`).
    This is one of the features that makes R a functional programming language.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) 的第二个参数定义了每一列将如何转换。在简单的情况下，如上所示，这将是一个单一的现有函数。这是R的一个非常特殊的功能：我们将一个函数（`median`，`mean`，`str_flatten`，…）传递给另一个函数（`across`）。'
- en: 'It’s important to note that we’re passing this function to [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml),
    so [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) can call it;
    we’re not calling it ourselves. That means the function name should never be followed
    by `()`. If you forget, you’ll get an error:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们将这个函数传递给[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)，所以[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    可以调用它；我们不是自己调用它。这意味着函数名后面不应跟着`()`。如果忘记了，会收到一个错误：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This error arises because you’re calling the function with no input, e.g.:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误的原因是您在没有输入的情况下调用了函数，例如：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Calling Multiple Functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用多个函数
- en: 'In more complex cases, you might want to supply additional arguments or perform
    multiple transformations. Let’s motivate this problem with a simple example: what
    happens if we have some missing values in our data? [`median()`](https://rdrr.io/r/stats/median.xhtml)
    propagates those missing values, giving us a suboptimal output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的情况下，您可能需要提供额外的参数或执行多个转换。让我们用一个简单的例子来激发这个问题：如果我们的数据中有一些缺失值会发生什么？[`median()`](https://rdrr.io/r/stats/median.xhtml)
    会传播这些缺失值，给我们一个次优的输出：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It would be nice if we could pass along `na.rm = TRUE` to [`median()`](https://rdrr.io/r/stats/median.xhtml)
    to remove these missing values. To do so, instead of calling [`median()`](https://rdrr.io/r/stats/median.xhtml)
    directly, we need to create a new function that calls [`median()`](https://rdrr.io/r/stats/median.xhtml)
    with the desired arguments:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够将`na.rm = TRUE`传递给[`median()`](https://rdrr.io/r/stats/median.xhtml)来删除这些缺失值就好了。为了做到这一点，我们需要创建一个新的函数，该函数使用所需的参数调用[`median()`](https://rdrr.io/r/stats/median.xhtml)而不是直接调用它：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a little verbose, so R comes with a handy shortcut: for this sort of
    throwaway (or *anonymous*)^([1](ch26.xhtml#idm44771267612512)) function, you can
    replace `function` with `\`:^([2](ch26.xhtml#idm44771267610256))'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点啰嗦，所以R提供了一个方便的快捷方式：对于这种一次性（或*匿名*）^([1](ch26.xhtml#idm44771267612512))函数，您可以用`\`代替`function`：^([2](ch26.xhtml#idm44771267610256))
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In either case, [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    effectively expands to the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) 实际上会扩展为以下代码：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we remove the missing values from the [`median()`](https://rdrr.io/r/stats/median.xhtml),
    it would be nice to know just how many values were removed. We can find that out
    by supplying two functions to [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml):
    one to compute the median and the other to count the missing values. You supply
    multiple functions by using a named list to `.fns`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从[`median()`](https://rdrr.io/r/stats/median.xhtml)中移除缺失值时，了解被移除的值的数量是很有用的。我们可以通过向[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)提供两个函数来实现：一个用于计算中位数，另一个用于计算缺失值的数量。您可以使用命名列表`.fns`来提供多个函数：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you look carefully, you might intuit that the columns are named using a glue
    specification ([“str_glue()”](ch14.xhtml#sec-glue)) like `{.col}_{.fn}` where
    `.col` is the name of the original column and `.fn` is the name of the function.
    That’s not a coincidence! As you’ll learn in the next section, you can use the
    `.names` argument to supply your own glue spec.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您可能会直觉到列名是使用一个glue规范（[“str_glue()”](ch14.xhtml#sec-glue)）命名的，例如 `{.col}_{.fn}`，其中`.col`是原始列的名称，`.fn`是函数的名称。这不是巧合！正如您将在下一节中了解到的那样，您可以使用`.names`参数来提供自己的glue规范。
- en: Column Names
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列名
- en: The result of [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    is named according to the specification provided in the `.names` argument. We
    could specify our own if we wanted the name of the function to come first:^([3](ch26.xhtml#idm44771267377264))
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) 的结果根据`.names`参数中提供的规范命名。如果需要，我们可以指定自己的规范，使函数名首先出现：^([3](ch26.xhtml#idm44771267377264))'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `.names` argument is particularly important when you use [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml). By default,
    the output of [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    is given the same names as the inputs. This means that [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    in [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml) will replace
    existing columns. For example, here we use [`coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.xhtml)
    to replace `NA`s with `0`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)中使用[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)时，`.names`参数尤为重要。默认情况下，[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)的输出与输入具有相同的名称。这意味着在[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)中使用的[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)将替换现有列。例如，在这里我们使用[`coalesce()`](https://dplyr.tidyverse.org/reference/coalesce.xhtml)将`NA`替换为`0`：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you’d like to instead create new columns, you can use the `.names` argument
    to give the output new names:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建新的列，可以使用`.names`参数为输出命名：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Filtering
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤
- en: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) is a great
    match for [`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)
    and [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml), but it’s
    more awkward to use with [`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml),
    because you usually combine multiple conditions with either `|` or `&`. It’s clear
    that [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) can help
    to create multiple logical columns, but then what? So dplyr provides two variants
    of [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) called [`if_any()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    and [`if_all()`](https://dplyr.tidyverse.org/reference/across.xhtml):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)非常适合与[`summarize()`](https://dplyr.tidyverse.org/reference/summarise.xhtml)和[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)配对使用，但与[`filter()`](https://dplyr.tidyverse.org/reference/filter.xhtml)一起使用时则比较尴尬，因为通常需要使用`|`或`&`组合多个条件。显然，[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)可以帮助创建多个逻辑列，但接下来呢？因此，dplyr提供了两个变体的[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)称为[`if_any()`](https://dplyr.tidyverse.org/reference/across.xhtml)和[`if_all()`](https://dplyr.tidyverse.org/reference/across.xhtml)：'
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: across() in Functions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: across()中的函数
- en: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) is particularly
    useful to program with because it allows you to operate on multiple columns. For
    example, [Jacob Scott](https://oreil.ly/6vVc4) uses this little helper that wraps
    a bunch of lubridate functions to expand all date columns into year, month, and
    day columns:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)在编程中特别有用，因为它允许您操作多个列。例如，[Jacob
    Scott](https://oreil.ly/6vVc4)使用了一个小助手，该助手将一系列lubridate函数包装起来，以将所有日期列扩展为年、月和日列：'
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) also makes
    it easy to supply multiple columns in a single argument because the first argument
    uses tidy-select; you just need to remember to embrace that argument, as we discussed
    in [“When to Embrace?”](ch25.xhtml#sec-embracing). For example, this function
    will compute the means of numeric columns by default. But by supplying the second
    argument you can choose to summarize just selected columns:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)还可以轻松地在单个参数中提供多列，因为第一个参数使用tidy-select；您只需记住在该参数周围加上括号，正如我们在[“何时使用括号？”](ch25.xhtml#sec-embracing)中讨论的那样。例如，此函数将默认计算数值列的均值。但通过提供第二个参数，您可以选择仅总结所选列：'
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Versus pivot_longer()
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与pivot_longer()相比
- en: 'Before we go on, it’s worth pointing out an interesting connection between
    [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml) and [`pivot_longer()`](https://tidyr.tidyverse.org/reference/pivot_longer.xhtml)
    ([“Lengthening Data”](ch05.xhtml#sec-pivoting)). In many cases, you perform the
    same calculations by first pivoting the data and then performing the operations
    by group rather than by column. For example, take this multifunction summary:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，值得指出[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)与[`pivot_longer()`](https://tidyr.tidyverse.org/reference/pivot_longer.xhtml)（“数据扩展”）之间有一个有趣的关联。在许多情况下，您通过首先将数据进行透视，然后按组而不是按列执行操作，来执行相同的计算。例如，看看这个多功能摘要：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We could compute the same values by pivoting longer and then summarizing:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更长的透视来计算相同的值，然后进行总结：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And if you wanted the same structure as [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml),
    you could pivot again:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望与[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)相同的结构，您可以再次进行数据透视：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is a useful technique to know about because sometimes you’ll hit a problem
    that’s not currently possible to solve with [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml):
    when you have groups of columns that you want to compute with simultaneously.
    For example, imagine that our data frame contains both values and weights and
    we want to compute a weighted mean:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的技术，因为有时您会遇到一个问题，目前使用[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)无法解决：当您有一组列，想要同时进行计算时。例如，假设我们的数据框同时包含值和权重，并且我们想计算加权平均值：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There’s currently no way to do this with [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml),^([4](ch26.xhtml#idm44771266547392))
    but it’s relatively straightforward with [`pivot_longer()`](https://tidyr.tidyverse.org/reference/pivot_longer.xhtml):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有办法使用[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)来做到这一点，^([4](ch26.xhtml#idm44771266547392))但使用[`pivot_longer()`](https://tidyr.tidyverse.org/reference/pivot_longer.xhtml)却相对简单：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If needed, you could [`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.xhtml)
    this back to the original form.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以使用[`pivot_wider()`](https://tidyr.tidyverse.org/reference/pivot_wider.xhtml)将其转换回原始形式。
- en: Exercises
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Practice your [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    skills by:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下方式练习您的[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)技能：
- en: Computing the number of unique values in each column of [`palmerpenguins::penguins`](https://allisonhorst.github.io/palmerpenguins/reference/penguins.xhtml).
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算[`palmerpenguins::penguins`](https://allisonhorst.github.io/palmerpenguins/reference/penguins.xhtml)中每一列的唯一值数量。
- en: Computing the mean of every column in `mtcars`.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`mtcars`中每一列的平均值。
- en: Grouping `diamonds` by `cut`, `clarity`, and `color` and then counting the number
    of observations and computing the mean of each numeric column.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`cut`、`clarity`和`color`对`diamonds`进行分组，并计算每个数值列的观测数和平均值。
- en: What happens if you use a list of functions in [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml),
    but don’t name them? How is the output named?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)中使用一个函数列表，但不给它们命名，会发生什么？输出会如何命名？
- en: Adjust `expand_dates()` to automatically remove the date columns after they’ve
    been expanded. Do you need to embrace any arguments?
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`expand_dates()`函数以在展开日期列后自动移除它们。您需要使用哪些参数吗？
- en: Explain what each step of the pipeline in this function does. What special feature
    of [`where()`](https://tidyselect.r-lib.org/reference/where.xhtml) are we taking
    advantage of?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释这个函数中每个步骤的管道是做什么的。我们利用了[`where()`](https://tidyselect.r-lib.org/reference/where.xhtml)的哪个特殊特性？
- en: '[PRE23]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Reading Multiple Files
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取多个文件
- en: 'In the previous section, you learned how to use [`dplyr::across()`](https://dplyr.tidyverse.org/reference/across.xhtml)
    to repeat a transformation on multiple columns. In this section, you’ll learn
    how to use [`purrr::map()`](https://purrr.tidyverse.org/reference/map.xhtml) to
    do something to every file in a directory. Let’s start with a little motivation:
    imagine you have a directory full of Excel spreadsheets^([5](ch26.xhtml#idm44771266252816))
    you want to read. You could do it with copy and paste:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您学会了如何使用[`dplyr::across()`](https://dplyr.tidyverse.org/reference/across.xhtml)在多列上重复转换。在本节中，您将学习如何使用[`purrr::map()`](https://purrr.tidyverse.org/reference/map.xhtml)来对目录中的每个文件执行某些操作。让我们先看一些动机：想象一下，您有一个充满Excel电子表格的目录^([5](ch26.xhtml#idm44771266252816))，您想要读取。您可以通过复制粘贴来完成：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then use [`dplyr::bind_rows()`](https://dplyr.tidyverse.org/reference/bind_rows.xhtml)
    to combine them all together:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用[`dplyr::bind_rows()`](https://dplyr.tidyverse.org/reference/bind_rows.xhtml)将它们全部合并：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can imagine that this would get tedious quickly, especially if you had
    hundreds of files, not just four. The following sections show you how to automate
    this sort of task. There are three basic steps: use [`list.files()`](https://rdrr.io/r/base/list.files.xhtml)
    to list all the files in a directory, then use [`purrr::map()`](https://purrr.tidyverse.org/reference/map.xhtml)
    to read each of them into a list, and then use [`purrr::list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)
    to combine them into a single data frame. We’ll then discuss how you can handle
    situations of increasing heterogeneity, where you can’t do the same thing to every
    file.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，如果有数百个文件而不仅仅是四个，这将很快变得乏味。接下来的章节将向你展示如何自动化这类任务。有三个基本步骤：使用[`list.files()`](https://rdrr.io/r/base/list.files.xhtml)来列出目录中的所有文件，然后使用[`purrr::map()`](https://purrr.tidyverse.org/reference/map.xhtml)将它们中的每一个读入列表，最后使用[`purrr::list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)将它们合并成一个单一的数据框。然后我们将讨论如何处理日益多样化的情况，即你不能对每个文件都采取相同的操作。
- en: Listing Files in a Directory
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出目录中的文件
- en: 'As the name suggests, [`list.files()`](https://rdrr.io/r/base/list.files.xhtml)
    lists the files in a directory. You’ll almost always use three arguments:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名，[`list.files()`](https://rdrr.io/r/base/list.files.xhtml)会列出目录中的文件。你几乎总是会使用三个参数：
- en: The first argument, `path`, is the directory to look in.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数`path`是要查找的目录。
- en: '`pattern` is a regular expression used to filter the filenames. The most common
    pattern is something like `[.]xlsx$` or `[.]csv$` to find all files with a specified
    extension.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pattern`是用于过滤文件名的正则表达式。最常见的模式之一是类似于`[.]xlsx$`或`[.]csv$`，用于查找具有特定扩展名的所有文件。'
- en: '`full.names` determines whether the directory name should be included in the
    output. You almost always want this to be `TRUE`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`full.names`决定了是否包括目录名在输出中。你几乎总是希望这个参数为`TRUE`。'
- en: 'To make our motivating example concrete, this book contains a folder with 12
    Excel spreadsheets containing data from the gapminder package. Each file contains
    one year’s worth of data for 142 countries. We can list them all with the appropriate
    call to [`list.files()`](https://rdrr.io/r/base/list.files.xhtml):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的示例更具体化，本书包含一个包含来自gapminder包的数据的文件夹，其中有12个Excel电子表格文件。每个文件包含142个国家一年的数据。我们可以使用适当的[`list.files()`](https://rdrr.io/r/base/list.files.xhtml)调用列出它们所有：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Lists
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'Now that we have these 12 paths, we could call `read_excel()` 12 times to get
    12 data frames:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这12个路径，我们可以调用`read_excel()` 12次来获取12个数据框：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But putting each sheet into its own variable is going to make it hard to work
    with them a few steps down the road. Instead, they’ll be easier to work with if
    we put them into a single object. A list is the perfect tool for this job:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，将每个工作表放入自己的变量中将使得稍后的几个步骤变得难以处理。相反，如果我们将它们放入一个单一对象中，那么它们将更容易处理。列表就是这项工作的完美工具：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that you have these data frames in a list, how do you get one out? You
    can use `files[[i]]` to extract the *i*th element:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你把这些数据框都放在一个列表里了，那么怎么取出其中一个呢？你可以使用`files[[i]]`来提取第*i*个元素：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ll come back to `[[` in more detail in [“Selecting a Single Element with
    $ and [[”](ch27.xhtml#sec-subset-one).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更详细地讨论`[[`，见[“使用 $ 和 [[ 选择单个元素”](ch27.xhtml#sec-subset-one)。
- en: purrr::map() and list_rbind()
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: purrr::map() 和 list_rbind()
- en: 'The code to collect those data frames in a list “by hand” is basically just
    as tedious to type as code that reads the files one by one. Happily, we can use
    [`purrr::map()`](https://purrr.tidyverse.org/reference/map.xhtml) to make even
    better use of our `paths` vector. [`map()`](https://purrr.tidyverse.org/reference/map.xhtml)
    is similar to [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml),
    but instead of doing something to each column in a data frame, it does something
    to each element of a vector. `map(x, f)` is shorthand for:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “手动”收集这些数据框的代码基本上和逐个读取文件的代码一样乏味。幸运的是，我们可以使用[`purrr::map()`](https://purrr.tidyverse.org/reference/map.xhtml)更好地利用我们的`paths`向量。[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)类似于[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)，但不是对数据框中的每一列进行操作，而是对向量中的每一个元素进行操作。`map(x,
    f)`是以下代码的简写：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So we can use [`map()`](https://purrr.tidyverse.org/reference/map.xhtml) to
    get a list of 12 data frames:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)来获得一个包含12个数据框的列表：
- en: '[PRE31]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (This is another data structure that doesn’t display particularly compactly
    with [`str()`](https://rdrr.io/r/utils/str.xhtml), so you might want to load it
    into RStudio and inspect it with [`View()`](https://rdrr.io/r/utils/View.xhtml)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: （这是另一种数据结构，使用[`str()`](https://rdrr.io/r/utils/str.xhtml)显示时并不特别紧凑，因此您可能希望将其加载到RStudio中，并使用[`View()`](https://rdrr.io/r/utils/View.xhtml)进行检查）。
- en: 'Now we can use [`purrr::list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)
    to combine that list of data frames into a single data frame:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用[`purrr::list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)将这些数据框的列表合并成一个单独的数据框：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or we could do both steps at once in a pipeline:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以一次在管道中完成两个步骤：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What if we want to pass in extra arguments to `read_excel()`? We use the same
    technique that we used with [`across()`](https://dplyr.tidyverse.org/reference/across.xhtml).
    For example, it’s often useful to peak at the first few rows of the data with
    `n_max = 1`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要传递额外的参数给`read_excel()`怎么办？我们使用与[`across()`](https://dplyr.tidyverse.org/reference/across.xhtml)相同的技术。例如，使用`n_max
    = 1`查看数据的前几行通常是有用的：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This makes it clear that something is missing: there’s no `year` column because
    that value is recorded in the path, not the individual files. We’ll tackle that
    problem next.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明缺少了一些内容：没有`year`列，因为该值记录在路径中，而不是单独的文件中。我们将在下一步解决这个问题。
- en: Data in the Path
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径中的数据
- en: Sometimes the name of the file is data itself. In this example, the filename
    contains the year, which is not otherwise recorded in the individual files. To
    get that column into the final data frame, we need to do two things.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时文件的名称本身就是数据。在这个例子中，文件名包含年份，这在单独的文件中没有记录。为了将该列添加到最终的数据框中，我们需要做两件事。
- en: 'First, we name the vector of paths. The easiest way to do this is with the
    [`set_names()`](https://rlang.r-lib.org/reference/set_names.xhtml) function, which
    can take a function. Here we use [`basename()`](https://rdrr.io/r/base/basename.xhtml)
    to extract just the file name from the full path:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们给路径向量命名。最简单的方法是使用[`set_names()`](https://rlang.r-lib.org/reference/set_names.xhtml)函数，它可以使用函数。在这里，我们使用[`basename()`](https://rdrr.io/r/base/basename.xhtml)从完整路径中提取文件名：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Those names are automatically carried along by all the map functions, so the
    list of data frames will have those same names:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称将自动通过所有的映射函数传递，因此数据框的列表将具有相同的名称：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That makes this call to [`map()`](https://purrr.tidyverse.org/reference/map.xhtml)
    shorthand for:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得对[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)的调用成为一种简写形式：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also use `[[` to extract elements by name:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`[[`按名称提取元素：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then we use the `names_to` argument to [`list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)
    to tell it to save the names into a new column called `year` and then use [`readr::parse_number()`](https://readr.tidyverse.org/reference/parse_number.xhtml)
    to extract the number from the string:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`names_to`参数来告诉[`list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)将名称保存到一个名为`year`的新列中，然后使用[`readr::parse_number()`](https://readr.tidyverse.org/reference/parse_number.xhtml)从字符串中提取数字：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In more complicated cases, there might be other variables stored in the directory
    name, or maybe the filename contains multiple bits of data. In that case, use
    [`set_names()`](https://rlang.r-lib.org/reference/set_names.xhtml) (without any
    arguments) to record the full path and then use [`tidyr::separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)
    and friends to turn them into useful columns:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的情况下，目录名称中可能存储有其他变量，或者文件名包含多个数据位。在这种情况下，使用[`set_names()`](https://rlang.r-lib.org/reference/set_names.xhtml)（不带任何参数）记录完整路径，然后使用[`tidyr::separate_wider_delim()`](https://tidyr.tidyverse.org/reference/separate_wider_delim.xhtml)等函数将它们转换为有用的列：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Save Your Work
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存你的工作
- en: 'Now that you’ve done all this hard work to get to a nice tidy data frame, it’s
    a great time to save your work:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了所有这些艰苦的工作，得到了一个整洁的数据框，现在是保存你的工作的好时机：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now when you come back to this problem in the future, you can read in a single
    CSV file. For large and richer datasets, using parquet might be a better choice
    than `.csv`, as discussed in [“The Parquet Format”](ch22.xhtml#sec-parquet).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您将来再次遇到这个问题时，您可以读取一个单独的CSV文件。对于大型和更丰富的数据集，使用Parquet格式可能比`.csv`更好，如["Parquet格式"](ch22.xhtml#sec-parquet)中讨论的那样。
- en: If you’re working in a project, we suggest calling the file that does this sort
    of data prep work, something like `0-cleanup.R`. The `0` in the filename suggests
    that this should be run before anything else.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在一个项目中工作，我们建议称呼执行这种数据准备工作的文件为`0-cleanup.R`之类的名称。文件名中的`0`表示应在任何其他操作之前运行。
- en: If your input data files change over time, you might consider learning a tool
    like [targets](https://oreil.ly/oJsOo) to set up your data cleaning code to automatically
    rerun whenever one of the input files is modified.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的输入数据文件随时间变化，你可能考虑学习像[targets](https://oreil.ly/oJsOo)这样的工具，以便将你的数据清理代码设置为在输入文件修改时自动重新运行。
- en: Many Simple Iterations
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多简单的迭代
- en: 'Here we loaded the data directly from disk and were lucky enough to get a tidy
    dataset. In most cases, you’ll need to do some additional tidying, and you have
    two basic options: you can do one round of iteration with a complex function or
    do multiple rounds of iteration with simple functions. In our experience, most
    folks reach first for one complex iteration, but you’re often better off doing
    multiple simple iterations.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们直接从磁盘加载数据，幸运地获得了一个整洁的数据集。在大多数情况下，你需要做一些额外的整理工作，你有两个基本选择：你可以用一个复杂的函数做一轮迭代，或者用简单的函数做多轮迭代。根据我们的经验，大多数人首先选择一次复杂的迭代，但你通常最好选择多次简单的迭代。
- en: 'For example, imagine that you want to read in a bunch of files, filter out
    missing values, pivot, and then combine. One way to approach the problem is to
    write a function that takes a file and does all those steps and then call [`map()`](https://purrr.tidyverse.org/reference/map.xhtml)
    once:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想读入一堆文件，过滤掉缺失值，进行数据透视，然后组合。解决问题的一种方法是编写一个接受文件并执行所有这些步骤的函数，然后只调用[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)一次：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, you could perform each step of `process_file()` for every file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以对每个文件执行`process_file()`的每一步：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We recommend this approach because it stops you from getting fixated on getting
    the first file right before moving on to the rest. By considering all of the data
    when doing tidying and cleaning, you’re more likely to think holistically and
    end up with a higher-quality result.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐这种方法，因为它可以防止你在处理第一个文件之前陷入固定思维。在整理和清理数据时，考虑所有数据，你更有可能进行全面思考，并获得更高质量的结果。
- en: 'In this particular example, there’s another optimization you could make, by
    binding all the data frames together earlier. Then you can rely on regular dplyr
    behavior:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，你可以进行另一种优化，即更早地将所有数据框架绑定在一起。然后你可以依赖于正常的 dplyr 行为：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Heterogeneous Data
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异构数据
- en: 'Unfortunately, sometimes it’s not possible to go from [`map()`](https://purrr.tidyverse.org/reference/map.xhtml)
    straight to [`list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)
    because the data frames are so heterogeneous that [`list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)
    either fails or yields a data frame that’s not useful. In that case, it’s still
    useful to start by loading all of the files:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有时从[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)直接转到[`list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)是不可能的，因为数据框架之间差异很大，[`list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)可能会失败，或者生成一个没有用的数据框架。在这种情况下，最好还是从加载所有文件开始：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then a useful strategy is to capture the structure of the data frames so that
    you can explore it using your data science skills. One way to do so is with this
    handy `df_types` function^([6](ch26.xhtml#idm44771264920592)) that returns a tibble
    with one row for each column:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个有用的策略是捕捉数据框架的结构，这样你就可以利用你的数据科学技能进行探索。一种方法是使用这个方便的`df_types`函数^([6](ch26.xhtml#idm44771264920592))，它返回一个
    tibble，每列为一个行：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can then apply this function to all of the files and maybe do some pivoting
    to make it easier to see where the differences are. For example, this makes it
    easy to verify that the gapminder spreadsheets that we’ve been working with are
    all quite homogeneous:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将此函数应用于所有文件，也许进行一些数据透视以便更容易看到差异的位置。例如，这使得验证我们一直在处理的 gapminder 电子表格是相当同质的变得容易：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If the files have heterogeneous formats, you might need to do more processing
    before you can successfully merge them. Unfortunately, we’re now going to leave
    you to figure that out on your own, but you might want to read about [`map_if()`](https://purrr.tidyverse.org/reference/map_if.xhtml)
    and [`map_at()`](https://purrr.tidyverse.org/reference/map_if.xhtml). [`map_if()`](https://purrr.tidyverse.org/reference/map_if.xhtml)
    allows you to selectively modify elements of a list based on their values; [`map_at()`](https://purrr.tidyverse.org/reference/map_if.xhtml)
    allows you to selectively modify elements based on their names.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件具有异构格式，您可能需要在成功合并它们之前进行更多处理。不幸的是，我们现在要让您自己来解决这个问题，但您可能需要阅读关于[`map_if()`](https://purrr.tidyverse.org/reference/map_if.xhtml)和[`map_at()`](https://purrr.tidyverse.org/reference/map_if.xhtml)的内容。[`map_if()`](https://purrr.tidyverse.org/reference/map_if.xhtml)允许您基于其值选择性地修改列表的元素；[`map_at()`](https://purrr.tidyverse.org/reference/map_if.xhtml)允许您基于其名称选择性地修改元素。
- en: Handling Failures
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理失败
- en: 'Sometimes the structure of your data might be sufficiently wild that you can’t
    even read all the files with a single command. And then you’ll encounter one of
    the downsides of `map()`: it succeeds or fails as a whole. [`map()`](https://purrr.tidyverse.org/reference/map.xhtml)
    will either successfully read all of the files in a directory or fail with an
    error, reading zero files. This is annoying: why does one failure prevent you
    from accessing all the other successes?'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您的数据结构可能非常复杂，甚至无法使用单个命令读取所有文件。然后您会遇到`map()`的一个缺点：它要么全部成功，要么全部失败。[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)要么成功读取目录中的所有文件，要么出现错误，一无所获。这很烦人：为什么一个失败会阻止您访问所有其他成功的文件呢？
- en: 'Luckily, purrr comes with a helper to tackle this problem: [`possibly()`](https://purrr.tidyverse.org/reference/possibly.xhtml).
    [`possibly()`](https://purrr.tidyverse.org/reference/possibly.xhtml) is what’s
    known as a *function operator*: it takes a function and returns a function with
    modified behavior. In particular, [`possibly()`](https://purrr.tidyverse.org/reference/possibly.xhtml)
    changes a function from erroring to returning a value that you specify:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，purrr提供了一个助手来解决这个问题：[`possibly()`](https://purrr.tidyverse.org/reference/possibly.xhtml)。[`possibly()`](https://purrr.tidyverse.org/reference/possibly.xhtml)是一个称为*函数操作符*的东西：它接受一个函数并返回一个具有修改行为的函数。特别地，[`possibly()`](https://purrr.tidyverse.org/reference/possibly.xhtml)将一个会出错的函数改变成返回您指定的值的函数：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This works particularly well here because [`list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml),
    like many tidyverse functions, automatically ignores `NULL`s.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这在这里特别有效，因为[`list_rbind()`](https://purrr.tidyverse.org/reference/list_c.xhtml)等许多tidyverse函数会自动忽略`NULL`。
- en: 'Now you have all the data that can be read easily, and it’s time to tackle
    the hard part of figuring out why some files failed to load and what to do about
    it. Start by getting the paths that failed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经可以轻松读取所有数据了，是时候着手解决难点了，弄清楚为什么某些文件加载失败以及如何处理。首先，获取失败的路径：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then call the import function again for each failure and figure out what went
    wrong.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对每个失败再次调用导入函数，并找出出了什么问题。
- en: Saving Multiple Outputs
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存多个输出
- en: 'In the previous section, you learned about [`map()`](https://purrr.tidyverse.org/reference/map.xhtml),
    which is useful for reading multiple files into a single object. In this section,
    we’ll now explore sort of the opposite problem: how can you take one or more R
    objects and save it to one or more files? We’ll explore this challenge using three
    examples:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您学习了[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)，它用于将多个文件读取到单个对象中。在本节中，我们将探讨相反的问题：如何将一个或多个R对象保存到一个或多个文件中？我们将使用三个示例来探讨这个挑战：
- en: Saving multiple data frames into one database
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个数据框保存到一个数据库中
- en: Saving multiple data frames into multiple `.csv` files
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个数据框保存为多个`.csv`文件
- en: Saving multiple plots to multiple `.png` files
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个图表保存为多个`.png`文件
- en: Writing to a Database
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入数据库
- en: Sometimes when working with many files at once, it’s not possible to fit all
    your data into memory at once, and you can’t do `map(files, read_csv)`. One approach
    to deal with this problem is to load your data into a database so you can access
    just the bits you need with dbplyr.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候一次处理多个文件时，不可能一次将所有数据装入内存，也不能使用`map(files, read_csv)`。解决这个问题的一种方法是将数据加载到数据库中，这样你就可以使用dbplyr仅访问你需要的部分。
- en: 'If you’re lucky, the database package you’re using will provide a handy function
    that takes a vector of paths and loads them all into the database. This is the
    case with duckdb’s `duckdb_read_csv()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您很幸运，您正在使用的数据库包将提供一个方便的函数，它接受一个路径向量并将它们全部加载到数据库中。这在duckdb的`duckdb_read_csv()`中就是这种情况：
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This would work well here, but we don’t have CSV files; instead, we have Excel
    spreadsheets. So we’re going to have to do it “by hand.” Learning to do it by
    hand will also help you when you have a bunch of CSV files and the database that
    you’re working with doesn’t have one function that will load them all in.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在这里很有效，但我们没有CSV文件；相反，我们有Excel电子表格。因此，我们将不得不手工进行操作。学会手动操作还将帮助您处理一堆CSV文件和您正在使用的数据库没有可以加载它们全部的功能的情况。
- en: 'We need to start by creating a table that will fill in with data. The easiest
    way to do this is by creating a template, a dummy data frame that contains all
    the columns we want, but only a sampling of the data. For the gapminder data,
    we can make that template by reading a single file and adding the year to it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先创建一个将填充数据的表格。这样做的最简单方法是创建一个模板，一个虚拟的数据框，包含我们想要的所有列，但只有部分数据。对于gapminder数据，我们可以通过读取一个文件并将年份添加到其中来制作该模板：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we can connect to the database and use [`DBI::dbCreateTable()`](https://dbi.r-dbi.org/reference/dbCreateTable.xhtml)
    to turn our template into a database table:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以连接到数据库并使用[`DBI::dbCreateTable()`](https://dbi.r-dbi.org/reference/dbCreateTable.xhtml)将我们的模板转换为数据库表：
- en: '[PRE52]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`dbCreateTable()` doesn’t use the data in `template`, just the variable names
    and types. So if we inspect the `gapminder` table now, you’ll see that it’s empty,
    but it has the variables we need with the types we expect:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbCreateTable()`不使用`template`中的数据，只使用变量名和类型。因此，如果现在检查`gapminder`表，您将看到它是空的，但具有我们需要的变量和我们期望的类型：'
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we need a function that takes a single file path, reads it into R, and
    adds the result to the `gapminder` table. We can do that by combining `read_excel()`
    with [`DBI::dbAppendTable()`](https://dbi.r-dbi.org/reference/dbAppendTable.xhtml):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个函数，它接受一个文件路径，将其读入R，并将结果添加到`gapminder`表中。我们可以通过结合`read_excel()`和[`DBI::dbAppendTable()`](https://dbi.r-dbi.org/reference/dbAppendTable.xhtml)来实现这一点：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we need to call `append_file()` once for each element of `paths`. That’s
    certainly possible with [`map()`](https://purrr.tidyverse.org/reference/map.xhtml):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为`paths`的每个元素调用`append_file()`一次。使用[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)肯定是可能的：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But we don’t care about the output of `append_file()`, so instead of [`map()`](https://purrr.tidyverse.org/reference/map.xhtml),
    it’s slightly nicer to use [`walk()`](https://purrr.tidyverse.org/reference/map.xhtml).
    [`walk()`](https://purrr.tidyverse.org/reference/map.xhtml) does exactly the same
    thing as [`map()`](https://purrr.tidyverse.org/reference/map.xhtml) but throws
    the output away:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们不关心`append_file()`的输出，所以与其使用[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)，使用[`walk()`](https://purrr.tidyverse.org/reference/map.xhtml)会稍微更好一些。[`walk()`](https://purrr.tidyverse.org/reference/map.xhtml)与[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)完全相同，但会丢弃输出：
- en: '[PRE56]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now we can see if we have all the data in our table:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看我们的表中是否有所有数据：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Writing CSV Files
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入CSV文件
- en: 'The same basic principle applies if we want to write multiple CSV files, one
    for each group. Let’s imagine that we want to take the [`ggplot2::diamonds`](https://ggplot2.tidyverse.org/reference/diamonds.xhtml)
    data and save one CSV file for each `clarity`. First we need to make those individual
    datasets. There are many ways you could do that, but there’s one way we particularly
    like: [`group_nest()`](https://dplyr.tidyverse.org/reference/group_nest.xhtml).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为每个组编写多个CSV文件，同样的基本原则适用。让我们想象一下，我们想要取[`ggplot2::diamonds`](https://ggplot2.tidyverse.org/reference/diamonds.xhtml)数据，并为每个`clarity`保存一个CSV文件。首先，我们需要制作这些单独的数据集。有许多方法可以做到这一点，但有一种方法我们特别喜欢：[`group_nest()`](https://dplyr.tidyverse.org/reference/group_nest.xhtml)。
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This gives us a new tibble with eight rows and two columns. `clarity` is our
    grouping variable, and `data` is a list column containing one tibble for each
    unique value of `clarity`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个新的tibble，有八行和两列。`clarity`是我们的分组变量，`data`是一个列表列，包含每个`clarity`唯一值的一个tibble：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'While we’re here, let’s create a column that gives the name of the output file,
    using [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml) and [`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的同时，让我们创建一个列，它给出输出文件的名称，使用[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)和[`str_glue()`](https://stringr.tidyverse.org/reference/str_glue.xhtml)：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'So if we were going to save these data frames by hand, we might write something
    like:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们要手动保存这些数据框，我们可以编写如下内容：
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This is a little different from our previous uses of [`map()`](https://purrr.tidyverse.org/reference/map.xhtml)
    because there are two arguments that are changing, not just one. That means we
    need a new function: [`map2()`](https://purrr.tidyverse.org/reference/map2.xhtml),
    which varies both the first and second arguments. And because we again don’t care
    about the output, we want [`walk2()`](https://purrr.tidyverse.org/reference/map2.xhtml)
    rather than [`map2()`](https://purrr.tidyverse.org/reference/map2.xhtml). That
    gives us:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前使用[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)的用法有些不同，因为有两个参数在变化，而不只是一个。这意味着我们需要一个新的函数：[`map2()`](https://purrr.tidyverse.org/reference/map2.xhtml)，它同时变化第一个和第二个参数。因为我们再次不关心输出，所以我们想要[`walk2()`](https://purrr.tidyverse.org/reference/map2.xhtml)而不是[`map2()`](https://purrr.tidyverse.org/reference/map2.xhtml)。这给我们带来了：
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Saving Plots
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存图表
- en: 'We can take the same basic approach to create many plots. Let’s first make
    a function that draws the plot we want:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用相同的基本方法来创建多个图表。首先让我们创建一个绘制所需图表的函数：
- en: '[PRE63]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![Histogram of carats of diamonds from the by_clarity dataset, ranging from
    0 to 5 carats. The distribution is unimodal and right skewed with a peak around
    1 carat.](assets/rds2_26in01.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![来自by_clarity数据集中钻石克拉数的直方图，范围从0到5克拉。分布是单峰的，右偏，峰值约为1克拉。](assets/rds2_26in01.png)'
- en: 'Now we can use [`map()`](https://purrr.tidyverse.org/reference/map.xhtml) to
    create a list of many plots^([7](ch26.xhtml#idm44771263913536)) and their eventual
    file paths:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)来创建许多图表的列表^([7](ch26.xhtml#idm44771263913536))及其最终文件路径：
- en: '[PRE64]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then use [`walk2()`](https://purrr.tidyverse.org/reference/map2.xhtml) with
    [`ggsave()`](https://ggplot2.tidyverse.org/reference/ggsave.xhtml) to save each
    plot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用[`walk2()`](https://purrr.tidyverse.org/reference/map2.xhtml)和[`ggsave()`](https://ggplot2.tidyverse.org/reference/ggsave.xhtml)来保存每个图表：
- en: '[PRE65]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This is shorthand for:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简写：
- en: '[PRE66]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you saw how to use explicit iteration to solve three problems
    that come up frequently when doing data science: manipulating multiple columns,
    reading multiple files, and saving multiple outputs. But in general, iteration
    is a superpower: if you know the right iteration technique, you can easily go
    from fixing one problem to fixing all the problems. Once you’ve mastered the techniques
    in this chapter, we highly recommend learning more by reading the [“Functionals”
    chapter](https://oreil.ly/VmXg4) of *Advanced R* and consulting the [purrr website](https://oreil.ly/f0HWP).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用显式迭代来解决数据科学中经常遇到的三个问题：操作多列、读取多个文件和保存多个输出。但总体而言，迭代是一种超能力：如果你掌握了正确的迭代技巧，你可以轻松地从解决一个问题过渡到解决所有问题。一旦你掌握了本章的技巧，我们强烈建议通过阅读《*Advanced
    R*》的[“Functionals”章节](https://oreil.ly/VmXg4)和咨询[purrr网站](https://oreil.ly/f0HWP)来进一步学习。
- en: 'If you know much about iteration in other languages, you might be surprised
    that we didn’t discuss the `for` loop. That’s because R’s orientation toward data
    analysis changes how we iterate: in most cases you can rely on an existing idiom
    to do something to each column or each group. And when you can’t, you can often
    use a functional programming tool like [`map()`](https://purrr.tidyverse.org/reference/map.xhtml)
    that does something to each element of a list. However, you will see `for` loops
    in wild-caught code, so you’ll learn about them in the next chapter where we’ll
    discuss some important base R tools.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对其他语言中的迭代了解很多，你可能会对我们没有讨论 `for` 循环感到惊讶。这是因为 R 对数据分析的取向改变了我们如何进行迭代：在大多数情况下，你可以依赖现有的惯用语来对每一列或每一组执行某些操作。当你无法做到这一点时，你通常可以使用函数式编程工具如[`map()`](https://purrr.tidyverse.org/reference/map.xhtml)，它可以对列表的每个元素执行某些操作。然而，在野外捕获的代码中，你会看到
    `for` 循环，所以我们会在下一章讨论一些重要的基础 R 工具时学习它们。
- en: ^([1](ch26.xhtml#idm44771267612512-marker)) Anonymous, because we never explicitly
    gave it a name with `<-`. Another term programmers use for this is *lambda function*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch26.xhtml#idm44771267612512-marker)) 匿名的，因为我们从未用 `<-` 明确地给它命名。程序员用的另一个术语是*lambda函数*。
- en: ^([2](ch26.xhtml#idm44771267610256-marker)) In older code you might see syntax
    that looks like `~ .x + 1`. This is another way to write anonymous functions,
    but it works only inside tidyverse functions and always uses the variable name
    `.x`. We now recommend the base syntax, `\(x) x + 1`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch26.xhtml#idm44771267610256-marker)) 在旧代码中，你可能会看到类似 `~ .x + 1` 的语法。这是另一种匿名函数的写法，但它只在
    tidyverse 函数内部起作用，并始终使用变量名 `.x`。我们现在推荐使用基本语法 `\(x) x + 1`。
- en: ^([3](ch26.xhtml#idm44771267377264-marker)) You can’t currently change the order
    of the columns, but you could reorder them after the fact using [`relocate()`](https://dplyr.tidyverse.org/reference/relocate.xhtml)
    or similar.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch26.xhtml#idm44771267377264-marker)) 目前无法更改列的顺序，但可以在事后使用[`relocate()`](https://dplyr.tidyverse.org/reference/relocate.xhtml)或类似方法重新排序。
- en: ^([4](ch26.xhtml#idm44771266547392-marker)) Maybe there will be one day, but
    currently we don’t see how.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch26.xhtml#idm44771266547392-marker)) 或许有一天会有，但目前我们看不出来怎么做。
- en: ^([5](ch26.xhtml#idm44771266252816-marker)) If you instead had a directory of
    CSV files with the same format, you can use the technique from [“Reading Data
    from Multiple Files”](ch07.xhtml#sec-readr-directory).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch26.xhtml#idm44771266252816-marker)) 如果你有一个具有相同格式的CSV文件目录，可以使用来自[“从多个文件读取数据”](ch07.xhtml#sec-readr-directory)的技术。
- en: ^([6](ch26.xhtml#idm44771264920592-marker)) We’re not going to explain how it
    works, but if you look at the docs for the functions used, you should be able
    to puzzle it out.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch26.xhtml#idm44771264920592-marker)) 我们不会解释它的工作原理，但如果你查看使用的函数文档，应该能够自己弄清楚。
- en: ^([7](ch26.xhtml#idm44771263913536-marker)) You can print `by_clarity$plot`
    to get a crude animation—you’ll get one plot for each element of `plots`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch26.xhtml#idm44771263913536-marker)) 你可以打印`by_clarity$plot`来获得一个简单的动画
    —— 每个`plots`元素对应一个图表。
