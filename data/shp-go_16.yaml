- en: Appendix B. Using Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B：使用Python
- en: In this appendix, we will build an API and pipeline with Python-specific tools
    using Python 3.8 with `pip` installed. Please ensure that you have it installed
    ([https://www.python.org/downloads/](https://www.python.org/downloads/)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我们将使用Python 3.8和已安装的`pip`使用Python特定的工具构建一个API和管道。请确保你已经安装了它（[https://www.python.org/downloads/](https://www.python.org/downloads/)）。
- en: B.1 Poetry
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 Poetry
- en: Before we build our project, we need to create a repeatable environment to work
    in. Python follows a common practice of sharing libraries among several projects.
    Languages like C, Java, and even Go use a central repository of libraries that
    are downloaded and stored locally on your machine. The problem with this process
    is that if you are not keeping track of the versions, the next person who sets
    up their development environment may have different versions of libraries, which
    can introduce new issues or break current functionality. Most of these languages,
    therefore, store the version of the library so that the environment can be set
    up almost identically.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建项目之前，我们需要创建一个可重复的工作环境。Python遵循在多个项目之间共享库的常见做法。像C、Java甚至Go这样的语言使用一个中央库仓库，这些库被下载并存储在您的机器上。这个过程的问题在于，如果您没有跟踪版本，下一个设置开发环境的人可能会有不同版本的库，这可能会引入新的问题或破坏当前的功能。因此，这些语言中的大多数都存储库的版本，以便环境可以几乎完全相同地设置。
- en: With Go, we have the `go.mod` file which will allow Go to redownload all dependencies
    for a given module. Python provides us with a very basic option called the virtual
    environment which allows developers to act like they are running on a fresh installation
    of Python with no additional libraries. Any subsequent libraries are installed
    using a tool called `pip`. After they are installed, you can create a requirements
    document. This is created by the `pip` `freeze` command which outputs all libraries
    installed. If we want something more explicit in our application dependency, it
    will require us to use a separate tool called Poetry to handle libraries, installation,
    and building.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go，我们有一个`go.mod`文件，它将允许Go重新下载给定模块的所有依赖项。Python为我们提供了一个非常基本的选项，称为虚拟环境，它允许开发者像在没有任何额外库的新安装的Python上运行一样操作。任何后续的库都是通过一个名为`pip`的工具安装的。安装完成后，你可以创建一个需求文档。这个文档是通过`pip`的`freeze`命令创建的，该命令输出所有已安装的库。如果我们想在应用程序的依赖项中更明确地指定某些内容，那么我们需要使用一个名为Poetry的单独工具来处理库、安装和构建。
- en: 'First, we need to install Poetry by running this command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过运行以下命令来安装Poetry：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then we create a new project by typing the command:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过输入以下命令来创建一个新的项目：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Simple as that! Now let’s write our API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 简单到这个程度！现在让我们编写我们的API。
- en: B.2 Coding
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 编码
- en: 'We will use a combination of tools to host our API. The framework that will
    create the handlers is called FastAPI, a relatively new routing library that is,
    well, fast. It will run on a `uvicorn` server. As before, our backend will require
    a Redis database, so we need those dependencies as well. To add those libraries
    to our project, we simply type this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一系列工具来托管我们的API。创建处理器的框架称为FastAPI，这是一个相对较新的路由库，运行速度快。它将在`uvicorn`服务器上运行。和之前一样，我们的后端需要一个Redis数据库，因此我们还需要这些依赖项。要将这些库添加到我们的项目中，我们只需输入以下命令：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The libraries will be installed, and your `pyproject.toml` will be updated for
    these dependencies. Now we can create our application. Create a new file in the
    `hello_api` directory called `app.py`, and add the code in the following listing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 库将被安装，并且你的`pyproject.toml`文件将更新以包含这些依赖项。现在我们可以创建我们的应用程序。在`hello_api`目录中创建一个名为`app.py`的新文件，并添加以下列表中的代码。
- en: Listing B.1 `app.py`
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.1 `app.py`
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Creates a base handler
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个基本处理器
- en: ❷ Loads the redis client
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加载redis客户端
- en: ❸ Injects the Redis client into the handler
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将Redis客户端注入到处理器中
- en: This handler should look familiar. Here, we create the app, a set of dependencies,
    and a route to translate the word. Our translation function requires an interface
    and a dependency to fulfill the interface, so let’s create those. First, we create
    the interface in a file called `repo.py` with the code in the following listing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理器应该看起来很熟悉。在这里，我们创建了一个应用程序、一组依赖项和一个翻译单词的路由。我们的翻译函数需要一个接口和一个依赖项来满足这个接口，所以让我们创建这些。首先，我们在一个名为`repo.py`的文件中创建接口，代码如下所示。
- en: Listing B.2 `repo.py`
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.2 `repo.py`
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Establishes an interface that can be duck typed
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 建立一个可以鸭式类型化的接口
- en: While we name this an interface, it technically isn’t because Python doesn’t
    have explicit interface types. This is a simple way to leverage Python’s duck-typing
    system, just like we did in Go. This interface is more like an abstract class
    in which the methods are not supposed to be implemented, only defined. All we
    need to do is implement the interface in our `redis.py` with the code in the following
    listing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们称这为一个接口，但从技术上讲它并不是，因为Python没有显式的接口类型。这是一个利用Python的鸭子类型系统的简单方法，就像我们在Go中做的那样。这个接口更像是抽象类，其中方法不应该被实现，而只是被定义。我们只需要在我们的`redis.py`中实现接口，如下面的列表所示。
- en: Listing B.3 `repo.py`
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.3 `repo.py`
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Implements the interface
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 实现接口
- en: ❷ Instantiates the client or sets an optional client variable
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 实例化客户端或设置可选的客户端变量
- en: ❸ Satisfies the interface
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 满足接口
- en: Here, you can see that we extend the interface and implement its methods. We
    can create our connection and handle the requests. The last step is to leverage
    FastApi’s dependency injection tool by creating a file called `deps.py`, which
    will house functions to fetch the required dependency to run the service with
    the code in the following listing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们扩展了接口并实现了其方法。我们可以创建我们的连接并处理请求。最后一步是通过创建一个名为`deps.py`的文件来利用FastApi的依赖注入工具，该文件将包含运行服务所需的依赖项的函数，如下面的列表所示。
- en: Listing B.4 `deps.py`
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.4 `deps.py`
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Required for FastAPI dependency injection
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于FastAPI依赖注入的必需项
- en: To run your application, type
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行您的应用程序，请输入
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: and you should be in business! Now let’s add our checks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该可以开始业务了！现在让我们添加我们的检查。
- en: B.3 Testing
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 测试
- en: 'We will use a different approach to testing our Python application than what
    we did in the Go chapters. Instead of using a Redis container to simulate the
    database connection, we will instead use an in-memory Redis replacement called
    `redislite`. We will use dependency injection to replace the actual connection,
    and everything should be the same. We need to add two testing libraries for our
    tests to work by running the following commands:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与在Go章节中不同的方法来测试我们的Python应用程序。我们不会使用Redis容器来模拟数据库连接，而是将使用一个内存中的Redis替代品，称为`redislite`。我们将使用依赖注入来替换实际连接，并且一切都应该相同。我们需要通过运行以下命令添加两个测试库，以便测试能够工作：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a directory called `tests`, and add the code in the following listing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`tests`的目录，并添加下面的列表中的代码。
- en: Listing B.5 `test_hello_api.py`
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.5 `test_hello_api.py`
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Internal function to create a mock redis client
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建模拟redis客户端的内部函数
- en: ❷ Sets up the test
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置测试
- en: ❸ Overrides the dependency function with an internal function
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用内部函数覆盖依赖函数
- en: Now we should be able to verify that our tests work. To do this, we will use
    a tool to help us keep our tests and formatting standardized.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够验证我们的测试是否工作。为此，我们将使用一个工具来帮助我们保持测试和格式的标准化。
- en: B.4 Nox
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.4 Nox
- en: 'Nox is an open source tool that allows you to organize and standardize your
    testing and linting scripts. To use this tool, you must install Nox globally,
    so open a new terminal window, and type the following commands:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Nox是一个开源工具，允许您组织和标准化您的测试和代码检查脚本。要使用此工具，您必须全局安装Nox，因此打开一个新的终端窗口，并输入以下命令：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we create a `noxfile.py` file at the root of the project. We then add
    the options in the next listing to the file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在项目的根目录下创建一个`noxfile.py`文件。然后，我们将下面的列表中的选项添加到文件中。
- en: Listing B.6 `noxfile.py`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.6 `noxfile.py`
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Jobs that can be completed
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 可以完成的作业
- en: ❷ Files the jobs can be completed on
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 可以完成作业的文件
- en: ❸ Runs the command
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行命令
- en: That’s it! Notice that Nox uses `flake8` as our linter. We want to configure
    it a bit, and to do this, we need to create a `.flake8` file and add the code
    in the following listing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！请注意，Nox使用`flake8`作为我们的代码检查工具。我们想要对其进行一些配置，为此，我们需要创建一个`.flake8`文件，并在下面的列表中添加代码。
- en: Listing B.7 `\.flake8`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表B.7 `\.flake8`
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Defines rules for linting
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义代码检查规则
- en: ❷ Sets the max line width
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置最大行宽
- en: 'Nox will take care of the rest for us. To lint and test, we need to run the
    following commands:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Nox将为我们处理其余的工作。要执行代码检查和测试，我们需要运行以下命令：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You will see the script run through each of these stages with the proper output.
    We have the linting and testing incorporated, which are the last steps before
    the pipeline defines the container it should run in.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到脚本将依次通过这些阶段，并输出正确的结果。我们已经将代码检查和测试合并，这是在管道定义它应该运行的容器之前的最后步骤。
- en: B.5 Defining the container
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.5 定义容器
- en: Packaging scripting languages are a bit different than packaging compiled languages.
    In our Go and Kotlin examples, we built the application and were left with a file
    that we could distribute and copy around. In languages such as Python and JavaScript,
    it becomes more important to set up the environment correctly for the scripts
    to run; otherwise, they will fail on startup or in the middle of a request. This
    is why we chose a package and dependency manager like Poetry. It will manage all
    of this for us. Let’s define our container, as in the next listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 打包脚本语言与打包编译语言略有不同。在我们的 Go 和 Kotlin 示例中，我们构建了应用程序，并留下了一个可以分发和复制的文件。在 Python 和
    JavaScript 等语言中，正确设置脚本运行的环境变得更为重要；否则，它们将在启动时或在请求过程中失败。这就是我们选择使用 Poetry 这样的打包和依赖管理器的原因。它将为我们管理所有这些。让我们定义我们的容器，如以下列表所示。
- en: Listing B.8 Dockerfile
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B.8 Dockerfile
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Production-level environmental variables for container
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为容器设置生产级别的环境变量
- en: ❷ Installs poetry
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安装 poetry
- en: ❸ Runs server
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 运行服务器
- en: We have our Dockerfile and can move on to our pipeline.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了 Dockerfile，可以继续到我们的管道。
- en: B.6 Creating the pipeline
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.6 创建管道
- en: This pipeline will lint, test, and build the container. To get started, create
    a new workflow file in `.github/workflows/pipeline.yml` and add the following
    code. First we will set up Nox to run our linter (see the following listing).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此管道将进行代码检查、测试和构建容器。要开始，请在 `.github/workflows/pipeline.yml` 中创建一个新的工作流程文件，并添加以下代码。首先，我们将设置
    Nox 来运行我们的代码检查器（见以下列表）。
- en: Listing B.9 `pipeline.yml`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B.9 `pipeline.yml`
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Installs Nox
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安装 Nox
- en: ❷ Runs Nox lint
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 运行 Nox 代码检查
- en: Then, in the next listing, we will use Nox to run our tests.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在下一个列表中，我们将使用 Nox 来运行我们的测试。
- en: Listing B.10 `pipeline.yml`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B.10 `pipeline.yml`
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Uses Nox to run tests
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Nox 运行测试
- en: Finally, we will build and ship our container in the following listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在以下列表中构建和分发我们的容器。
- en: Listing B.11 `.pipeline.yml`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 B.11 `.pipeline.yml`
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Builds a Docker image
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建 Docker 镜像
- en: Due to how large the Python ecosystem is, at this point there may be a bunch
    of other ways to create and deploy your Python application. The point is that
    tools and processes can be put in place to protect your code and reduce bugs.
    This is especially important for languages like Python because they trade type
    safety and compile time errors for flexibility, allowing for rapid development.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 生态系统很大，此时可能有多种创建和部署 Python 应用程序的方法。关键是可以通过工具和流程来保护代码并减少错误。这对于像 Python
    这样的语言尤为重要，因为它们以类型安全和编译时错误为代价换取灵活性，从而允许快速开发。
