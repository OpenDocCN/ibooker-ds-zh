- en: 7 Comparing objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 比较对象
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Implementing the `GetCustomerByName` method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现的 `GetCustomerByName` 方法
- en: Viewing methods through the lens of lambda calculus
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 lambda 演算的视角查看方法
- en: Using nullable types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可空类型
- en: Using custom exceptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义异常
- en: Operator overloading and custom equality comparisons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载和自定义等价比较
- en: In the previous chapter, we implemented the `CustomerRepository` where we can
    add a customer to the database. We also learned how to use dependency injection
    to write testable code. This is a splendid start, but we are not done yet. We
    can add a `Customer` instance to the database, but how about retrieving one? See
    figure 7.1 for where we are in the scheme of the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了 `CustomerRepository`，其中我们可以向数据库中添加客户。我们还学习了如何使用依赖注入来编写可测试的代码。这是一个出色的开始，但我们还没有完成。我们可以向数据库中添加一个
    `Customer` 实例，但如何检索一个呢？见图 7.1 了解我们在本书方案中的位置。
- en: '![](../Images/07_01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07_01.png)'
- en: Figure 7.1 In this chapter, we’ll continue the implementation of the `CustomerRepository`
    we started in chapter 6\. This is the first step in implementing all the repositories
    for the Flying Dutchman Airlines service.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 在本章中，我们将继续实现我们在第 6 章开始的 `CustomerRepository` 实现。这是实现 Flying Dutchman Airlines
    服务所有存储库的第一步。
- en: In this chapter, we’ll create the `GetCustomerByName` method that returns an
    appropriate `Customer` object when given a string containing the customer’s name.
    Implementing this method allows us to touch on some technical concepts we may
    have missed otherwise. As before, we’ll use test-driven development “light” to
    ensure our code quality is adequate. Even though the API doesn’t require an endpoint
    to get customers from the database, this method will prove useful for us when
    we implement our booking endpoint.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建 `GetCustomerByName` 方法，当给定包含客户名称的字符串时，该方法将返回适当的 `Customer` 对象。实现此方法使我们能够触及一些我们可能否则会错过的技术概念。和之前一样，我们将使用测试驱动开发“轻量级”来确保我们的代码质量足够好。尽管
    API 不需要端点从数据库中获取客户，但此方法在我们实现预订端点时将非常有用。
- en: 7.1 The GetCustomerByName method
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 `GetCustomerByName` 方法
- en: 'To get started, let’s create the following new unit test that does absolutely
    nothing besides an attempt to call our new (not yet created) method:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们创建以下新的单元测试，它除了尝试调用我们新的（尚未创建的）方法外，什么都不做：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After switching to the `CustomerRepository` class, let’s add the `GetCustomerByName`
    method. Let’s also add an argument of type `string` to the method signature, signifying
    the `CustomerName` we want passed in. We’ll also add code to return a new instance
    of type `Customer`, to satisfy the return type of `Task<Customer>` in the method
    signature. We do not have any `await` calls in the method yet, so the compiler
    warns us of that (and we’ll handle it in section 7.1.1). For now, we are okay
    with executing `GetCustomerByName` synchronously as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换到 `CustomerRepository` 类后，让我们添加 `GetCustomerByName` 方法。我们还将向方法签名中添加一个 `string`
    类型的参数，表示我们想要传递的 `CustomerName`。我们还将添加代码以返回 `Customer` 类型的新实例，以满足方法签名中 `Task<Customer>`
    的返回类型。我们目前还没有任何 `await` 调用，因此编译器会警告我们（我们将在 7.1.1 节中处理它）。现在，我们可以同步执行 `GetCustomerByName`，如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the compilation warning resolved, we can attempt another test run. Of
    course, we aren’t testing anything yet. We want the unit test to check for and
    assert the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了编译警告后，我们可以尝试再次运行测试。当然，我们还没有进行任何测试。我们希望单元测试检查并断言以下内容：
- en: The returned `Customer` instance is not null.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的 `Customer` 实例不为 null。
- en: The `Customer` instance has valid data for the `CustomerId`, `Name`, and `Booking`
    fields.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Customer` 实例具有 `CustomerId`、`Name` 和 `Booking` 字段的有效数据。'
- en: 'Those assertions should be fairly simple to write. Let’s assert that the returned
    `Customer` instance is not null as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断言应该相当简单编写。让我们断言返回的 `Customer` 实例不为 null，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we remember the red-green traffic light of test-driven development, we see
    that we have transitioned from the red stage (not compiling) to the green stage
    (compiling and our tests work). Now let’s make the light red again. The red-green
    instant feedback loop provides small, gratifying wins throughout the procedure,
    making TDD very satisfying to use.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还记得测试驱动开发的红绿灯模型，我们会看到我们已经从红色阶段（无法编译）过渡到了绿色阶段（编译且测试通过）。现在让我们再次将灯光调回红色。红绿灯即时反馈循环在整个过程中提供了小而令人满意的胜利，使得
    TDD 非常令人满意地使用。
- en: 'Now that we are in the red stage, we can add some new tests to assert based
    on code we have not written yet. So, what do we want to do in `GetCustomerByName`?
    As shown in figure 7.2:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处于红色阶段，我们可以添加一些新的测试来基于我们尚未编写的代码进行断言。那么，我们在`GetCustomerByName`中想做什么呢？如图7.2所示：
- en: Validate the input parameter (`name`, string).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证输入参数（`name`，字符串）。
- en: Check the internal database set of Entity Framework Core for the appropriate
    customer.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Entity Framework Core的内部数据库以找到适当的客户。
- en: Return the found customer or throw an exception saying we did not find the customer.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回找到的客户或抛出未找到客户的异常。
- en: '![](../Images/07_02.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07_02.png)'
- en: Figure 7.2 The three steps to implementing `GetCustomerByName` are (1) validate
    the input parameters, (2) check the database for an existing customer, and (3)
    return the found customer or an exception.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 实现`GetCustomerByName`的三个步骤是（1）验证输入参数，（2）检查数据库中是否存在客户，（3）返回找到的客户或抛出异常。
- en: 'There’s a lot to unpack, so let’s start with the simplest (and first) item
    in the list: validating our input parameters. You may recall that we discussed
    input validation in section 6.2.1.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多要解释的内容，所以让我们从列表中最简单（也是第一个）的项目开始：验证我们的输入参数。你可能还记得我们在第6.2.1节中讨论了输入验证。
- en: '| ![](../Images/LightBulb.png)   | Before we move on, let me offer another
    argument about why we want to validate all our input parameters, regardless of
    whether they *should* have been validated and/or sanitized upstream. If we examine
    the abstract concept of a method through the lens of lambda calculus, we could
    say that any method (if visualized as a function), at its most basic level, is
    an isolated construct of an input, a function body, and an output. We can write
    this using some simple syntax where the lambda is wrapped (λ) in parentheses with
    the input followed by a period and the output, as shown in figure 7.3. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 在我们继续之前，让我再提出一个关于为什么我们要验证所有输入参数的理由，无论它们*应该*在上游被验证和/或清理。如果我们通过lambda演算的透镜来审视方法的抽象概念，我们可以说任何方法（如果将其视为一个函数），在其最基本层面上，是一个输入、函数体和输出的独立结构。我们可以使用一些简单的语法来编写这个，其中lambda（λ）被括号包裹，输入后面跟着一个点，然后是输出，如图7.3所示。|'
- en: '![](../Images/07_03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07_03.png)'
- en: Figure 7.3 A method can be seen as a lambda function. It has an input, some
    logic that operates on that input, and a resulting output. Using lambda functions
    helps with adhering to the “code should read like a narrative” principle because
    you have room to do only one atomic operation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '图7.3 方法可以被视为一个lambda函数。它有一个输入，一些在该输入上操作的逻辑，以及一个结果输出。使用lambda函数有助于遵循“代码应该像叙述一样阅读”的原则，因为你可以只进行一个原子操作。 '
- en: We should treat this method as a so-called black box. We do not have any insight
    into the inner workings of the function, so how are we supposed to know whether
    a certain input is correct? The function should return a valid output for any
    input, regardless of how it processes the data. If we assume that a parameter
    is validated in an earlier method in the code and we pass in an invalid value
    to the method, we cause our (programmatic) method in code to hard crash. We do
    not comply with this lambda calculus black box thing we have going on. Note that
    because lambda calculus deals with mathematical functions, it’s not the function
    itself that crashes but rather our flawed code implementation of the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将这种方法视为所谓的黑盒。我们对函数的内部工作原理没有任何洞察，那么我们该如何知道某个输入是否正确呢？无论它如何处理数据，函数都应该为任何输入返回一个有效的输出。如果我们假设在代码中的某个早期方法中验证了一个参数，并且我们向该方法传递了一个无效的值，那么我们将导致我们的（程序性）代码方法硬崩溃。我们没有遵守我们正在进行的这个lambda演算黑盒事务。请注意，由于lambda演算处理数学函数，崩溃的不是函数本身，而是我们系统实现的代码有缺陷。
- en: '7.1.1 Question marks: Nullable types and their applications'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 问号：可空类型及其应用
- en: Now that we have a skeleton for the `CustomerRepositoryTests.GetCustomerByName
    _Success` unit test and the `CustomerRepository.GetCustomerByName` method, we
    can validate the input into `GetCustomerByName`. What are the rules for our input
    arguments to abide by? Well, we never want a null value, so that should be the
    first check.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了`CustomerRepositoryTests.GetCustomerByName _Success`单元测试和`CustomerRepository.GetCustomerByName`方法的框架，我们可以验证`GetCustomerByName`的输入。我们的输入参数需要遵守哪些规则呢？嗯，我们绝对不希望有一个null值，所以这应该是第一个检查。
- en: Until C# 8, any reference type was nullable. This meant you could assign a null
    value to reference types and prevent the compiler from throwing an error when
    it found a null value. In practice, this often was the reason why we saw null-pointer
    exceptions being raised at runtime. Many times, you did not know a reference type
    would be null, yet you’d still try to use it somehow. To combat runtime null-pointer
    exceptions, C# 8 introduced explicit nullable reference types, which lets us make
    a reference type null by explicitly signaling that we want to do so. The overarching
    goal behind nullable reference types is to remove unexpected null-pointer exceptions
    in C#. If the only time a reference type can be null is when you explicitly allow
    it to be null, you are in control. Instead of guessing whether a reference type
    could be null when you try to use it (or digging through lots of code to find
    out), you can look at its underlying type. If it is nullable, assume that it can
    be null and perform null checks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 8 之前，任何引用类型都是可空的。这意味着你可以将 null 值赋给引用类型，并在编译器发现 null 值时防止其抛出错误。在实践中，这往往是我们在运行时看到空指针异常的原因。很多时候，你并不知道一个引用类型会是
    null，但你仍然试图以某种方式使用它。为了应对运行时的空指针异常，C# 8 引入了显式可空引用类型，这允许我们通过显式地表示我们想要这样做来使引用类型为
    null。可空引用类型的总体目标是消除 C# 中的意外空指针异常。如果引用类型只能在你显式允许其为 null 时为 null，那么你就处于控制之中。当你尝试使用引用类型时（或者挖掘大量代码以找出），你不需要猜测引用类型是否可能为
    null（或者挖掘大量代码以找出），你可以查看其底层类型。如果它是可空的，假设它可以为 null 并执行空检查。
- en: To enable nullable reference types, either add the `<Nullable>enable</Nullable>`
    flag to your project file (.csproj) or add the `#nullable enable` tag per source
    file, if you do not want to enable nullable reference types for the entire project.
    (You can also use `#nullable disable` to disable nullable for a particular source
    file when enabling nullable for the entire project.) In effect, when using C#
    8 or higher with the nullable reference type support enabled, if you want a reference
    type to be null, you need to declare the type to be nullable by post-fixing a
    question mark to the type, for example, `int?` or `Customer?`. Nullable value
    types have been present in C# since C# 2.0 and follow the same pattern. The provided
    `name` always needs to be valid. A valid name means a non-null or empty string.
    Let’s say `name` is an invalid value—what then? We could throw an exception or
    return a null value up to the controller. In general, a good frame of mind is
    to limit any null returns. Because it is a value people rarely expect to be returned
    (unless the return type is `Nullable<T>` or an explicit nullable reference type),
    we should not throw the receiving method a curveball. Let’s go with a custom `Exception`.
    Alternately, you can use one of the exceptions that .NET provides us. Some suggested
    choices are `ArgumentNullException` or `InvalidOperationException` (also discussed
    in section 14.1.1).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用可空引用类型，可以将 `<Nullable>enable</Nullable>` 标志添加到你的项目文件 (.csproj) 中，或者如果你不想为整个项目启用可空引用类型，可以为每个源文件添加
    `#nullable enable` 标签。（你还可以在为整个项目启用可空引用类型时使用 `#nullable disable` 来禁用特定源文件的可空引用类型。）实际上，当使用
    C# 8 或更高版本并启用可空引用类型支持时，如果你想使引用类型为 null，你需要通过在类型后添加问号来声明类型为可空的，例如，`int?` 或 `Customer?`。可空值类型自
    C# 2.0 以来就存在于 C# 中，并遵循相同的模式。提供的 `name` 总是必须有效的。有效的名称意味着一个非空或非空字符串。假设 `name` 是一个无效值——那么会怎样？我们可以抛出异常或返回一个
    null 值到控制器。一般来说，限制任何 null 返回是一个好的心态。因为这是一个人们很少期望返回的值（除非返回类型是 `Nullable<T>` 或显式可空引用类型），我们不应该给接收方法一个惊喜。让我们使用自定义的
    `Exception`。或者，你可以使用 .NET 提供给我们的一些异常。一些建议的选择是 `ArgumentNullException` 或 `InvalidOperationException`（在
    14.1.1 节中也有讨论）。
- en: 7.1.2 Custom exceptions, LINQ, and extension methods
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 自定义异常、LINQ 和扩展方法
- en: Every exception in C# inherits from the `Exception` class. Of course, intermediate
    layers of inheritance can exist, but in the end, it all boils down to the `Exception`
    class. For example, the `InvalidCastException` class inherits `SystemException`,
    which inherits the `Exception` class, as shown in figure 7.4.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的每个异常都继承自 `Exception` 类。当然，可以存在中间层的继承，但最终，所有这些都归结为 `Exception` 类。例如，`InvalidCastException`
    类继承自 `SystemException`，而 `SystemException` 继承自 `Exception` 类，如图7.4所示。
- en: '![](../Images/07_04.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07_04.png)'
- en: Figure 7.4 `InvalidCastException` inherits from `SystemException`, which inherits
    from `Exception`. `Exception` inherits from and implements the `ISerializable`
    interface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 `InvalidCastException` 继承自 `SystemException`，而 `SystemException` 继承自 `Exception`。`Exception`
    类实现了 `ISerializable` 接口。
- en: 'The `Exception` inheritance tree means that if we create a class that inherits
    from `Exception`, we can use `SystemException` and `InvalidCastException` like
    they are any other instance of `Exception`. I propose we use inheritance from
    the `Exception` class to create a class called `CustomerNotFoundException`. Throughout
    the book, the exception-handling strategy used boils down to the following four
    major steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exception` 继承树意味着如果我们创建一个从 `Exception` 继承的类，我们可以像使用任何其他 `Exception` 实例一样使用
    `SystemException` 和 `InvalidCastException`。我建议我们使用 `Exception` 类的继承来创建一个名为 `CustomerNotFoundException`
    的类。在整个书中，所使用的异常处理策略归结为以下四个主要步骤：'
- en: Check if an exception needs to be thrown.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否需要抛出异常。
- en: Create an instance of a custom exception.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义异常的实例。
- en: Raise the custom exception.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出自定义异常。
- en: Catch the exception one layer above where it was thrown, and decide whether
    to handle there or rethrow it.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在抛出异常的上一层捕获异常，并决定是否在那里处理它或重新抛出它。
- en: 'If `customerName` is an invalid name (we can use the `IsInvalidName` method
    we created in section 6.2.3), we “throw” our new exception. If we want to throw
    an exception (or “raise” it, as some languages would say), we use the `throw`
    keyword with the exception we want to throw. And because we want to be organized,
    we should also create a dedicated folder for custom exceptions (aptly named “Exceptions”),
    as shown next:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `customerName` 是一个无效的名称（我们可以使用我们在第 6.2.3 节中创建的 `IsInvalidName` 方法），我们“抛出”我们的新异常。如果我们想抛出异常（或者像某些语言所说的“提升”它），我们使用
    `throw` 关键字和我们要抛出的异常。而且为了保持组织性，我们还应该为自定义异常创建一个专门的文件夹（命名为“Exceptions”），如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because we do not need any functionality from `CustomerNotFoundException` besides
    what the `Exception` class already gives us, this code is the entire exception.
    After adding the appropriate import to the `CustomerRepository` class (`using
    FlyingDutchmanAirlines.Exceptions`), we can use our new exception and validate
    the input of `name` as follows`:`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不需要从 `CustomerNotFoundException` 中获取除了 `Exception` 类已经提供之外的功能，因此这段代码就是整个异常。在向
    `CustomerRepository` 类添加适当的导入（`using FlyingDutchmanAirlines.Exceptions`）之后，我们可以使用我们新的异常，并如下验证
    `name` 的输入：`
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We could have used an `ArgumentException` instead of our custom exception,
    but to me, it makes sense that a method that retrieves customer names from a database
    can return an exception called `CustomerNotFoundException`. By running our existing
    tests, we verify that the new code does not break any existing functionality.
    We can test for the invalid input by creating a new test in `CustomerRepositoryTests`
    that passes a negative integer to `GetCustomerByName` and then checks that the
    method threw an exception of type `CustomerNotFoundException` during execution.
    In section 4.1.2, we discussed how to check the type of an object through the
    `typeof` keyword. We use this knowledge in our failure case test. We can check
    for a thrown exception with MSTest in the following ways:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用 `ArgumentException` 而不是我们的自定义异常，但对我来说，一个从数据库检索客户名称的方法返回一个名为 `CustomerNotFoundException`
    的异常是有意义的。通过运行我们的现有测试，我们验证新代码没有破坏任何现有功能。我们可以通过在 `CustomerRepositoryTests` 中创建一个新的测试，将负整数传递给
    `GetCustomerByName`，然后在执行期间检查该方法是否抛出了 `CustomerNotFoundException` 类型的异常来测试无效输入。在第
    4.1.2 节中，我们讨论了如何通过 `typeof` 关键字检查对象的类型。我们在失败情况测试中使用这一知识。我们可以使用以下方式在 MSTest 中检查抛出的异常：
- en: Decorate the test method with a method attribute of type `[ExpectedException
    (typeof([your exception]))]`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型为 `[ExpectedException (typeof([your exception]))]` 的方法属性装饰测试方法。
- en: Add a `try-catch` block in the code, and assert that the exception is the correct
    type.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中添加一个 `try-catch` 块，并断言异常是正确的类型。
- en: 'For us, both approaches would work. There is a slight caveat with the first
    approach: the method attribute of type `ExpectedException(typeof([your exception])`
    does not allow us to access any of the properties of the thrown exception. So,
    if you attach some kind of message, custom data, or stack trace to your exception,
    you cannot access it unless you use the second approach. Not having access to
    a stack trace is not an issue for us, so let’s use the first approach, as shown
    here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，两种方法都会工作。第一种方法有一个小的限制：类型为 `ExpectedException(typeof([your exception]))`
    的方法属性不允许我们访问抛出异常的任何属性。所以，如果你在异常中附加某种消息、自定义数据或堆栈跟踪，除非使用第二种方法，否则无法访问它。对我们来说，没有访问堆栈跟踪不是一个问题，所以让我们使用第一种方法，如下所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the test; it should pass. If it does not, check whether your `ExpectedException`
    is of the right type (`CustomerNotFoundException`).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试；它应该通过。如果没有通过，请检查您的 `ExpectedException` 是否为正确的类型（`CustomerNotFoundException`）。
- en: 'Switching back to the success case test, we can move on to the second item
    on our list of items to do in the `GetCustomerByName` method: check the internal
    database set of the Entity Framework Core for the appropriate customer. To test
    the logic, we must first have a `Customer` instance to check against. Before we
    can access a `Customer` instance, we need to add one to the in-memory database.
    Following that, we use the `GetCustomerByName` method to retrieve it. How about
    we add that in the `TestInitialize` method so we have access to `Customer` in
    the database in every test?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 回到成功案例测试，我们可以继续到 `GetCustomerByName` 方法中的第二个项目：检查 Entity Framework Core 的内部数据库集合中是否有适当的客户。为了测试逻辑，我们首先需要一个
    `Customer` 实例来检查。在我们能够访问 `Customer` 实例之前，我们需要将其添加到内存数据库中。随后，我们使用 `GetCustomerByName`
    方法检索它。我们是否可以在 `TestInitialize` 方法中添加它，这样我们就可以在每次测试中访问数据库中的 `Customer`？
- en: We already wrote code to add a `Customer` instance to a database in the `CreateCustomer`
    method, so let’s use that (rather than calling the method itself in an initialization
    method). To add a `Customer` instance to the in-memory database, we need to add
    a new instance of `Customer` to the internal database set for `Customer` and save
    the changes through Entity Framework Core, as shown in the next listing. Because
    we should `await` the `SaveChangesAsync` call, we need to convert `TestInitialize`
    to an asynchronous method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `CreateCustomer` 方法中编写了将 `Customer` 实例添加到数据库的代码，所以让我们使用它（而不是在初始化方法中调用该方法本身）。要将
    `Customer` 实例添加到内存数据库中，我们需要将一个新的 `Customer` 实例添加到 `Customer` 的内部数据库集合中，并通过 Entity
    Framework Core 保存更改，如下一列表所示。因为我们应该 `await` `SaveChangesAsync` 调用，所以我们需要将 `TestInitialize`
    转换为异步方法。
- en: Listing 7.1 CustomerRepositoryTests.cs `TestInitialize` with in-memory database
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 CustomerRepositoryTests.cs 中的 `TestInitialize` 与内存数据库
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates a new instance of Customer. The customer’s name field is set to "Linus
    Torvalds".
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的 Customer 实例。客户的姓名字段设置为 "Linus Torvalds"。
- en: ❷ Adds the testCustomer object to the DbSet<Customer> by calling the database
    context and accessing the DbSet<Customer>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过调用数据库上下文并访问 DbSet<Customer> 将测试客户对象添加到 DbSet<Customer>
- en: ❸ Saves the changes to the in-memory database
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将更改保存到内存数据库中
- en: As we can see by the bold code in listing 7.1, adding a new `Customer` object
    to the database is pretty straightforward. Let’s hop back to the `GetCustomerByName_Success`
    test and see if we can get that `Customer` object back from the `GetCustomerByName`
    method. Remember, though, that what we inevitably get back from the method is
    not the same instance as what we stored in the database, but it is congruent to
    that instance (more on congruence in section 7.2). We know that the `Customer`
    object in the database has a `CustomerName` of `"Linus Torvalds"`, so we do not
    need to adjust that part of the existing test.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 7.1 中的粗体代码所示，将新的 `Customer` 对象添加到数据库相当直接。让我们回到 `GetCustomerByName_Success`
    测试，看看我们是否可以从 `GetCustomerByName` 方法中获取那个 `Customer` 对象。记住，尽管我们不可避免地从该方法返回的并不是我们在数据库中存储的相同实例，但它与该实例是一致的（关于一致性的更多内容请见第
    7.2 节）。我们知道数据库中的 `Customer` 对象的 `CustomerName` 为 `"Linus Torvalds"`，因此我们不需要调整现有测试的这一部分。
- en: 'We want `GetCustomerByName` to search the database for an existing `Customer`
    object matching the input argument. We need to change this to grab the correct
    `Customer` object from the database. We grab the correct element from the database
    by accessing the database context’s `DbSet<Customer>` and requesting the `Customer`
    instance with the given `CustomerName`. When querying a collection for an element,
    we can use the `DbSet<Customer>` and find our wanted `Customer` instance in two
    ways:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 `GetCustomerByName` 方法能够搜索数据库以找到与输入参数匹配的现有 `Customer` 对象。我们需要将其更改为从数据库中获取正确的
    `Customer` 对象。我们通过访问数据库上下文的 `DbSet<Customer>` 并请求具有给定 `CustomerName` 的 `Customer`
    实例来从数据库中获取正确的元素。在查询集合以获取元素时，我们可以使用 `DbSet<Customer>` 并以两种方式找到我们想要的 `Customer`
    实例：
- en: We can loop over the collection with a `foreach`, `while`, or `for` loop.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `foreach`、`while` 或 `for` 循环遍历集合。
- en: We can use LINQ.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 LINQ。
- en: 'We have seen examples of both in the book so far. Let’s contrast these approaches.
    To use a loop to select our customer, we could end up with the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，书中已经展示了这两个示例。让我们对比一下这些方法。要使用循环选择我们的客户，我们可能会得到以下代码：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is nothing wrong with that code. It is readable and to the point. Still,
    there is a better way to do it: with LINQ commands to query collections, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有问题。它既易读又直接。然而，还有更好的方法来做这件事：使用LINQ命令查询集合，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That is definitely shorter but also looks more intimidating. Let’s unpack what
    this one-liner does. We access the `DbSet<Customer>` by using `context.Customer`—nothing
    we haven’t seen before. But the next part is a bit odd: `FirstOrDefault(c => c.Name
    == name)`. The lambda expression finds matches between `name` properties, but
    we have not seen `FirstOrDefault` before. `FirstOrDefault` is an extension method
    defined in `System.Linq`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实更短，但也看起来更令人畏惧。让我们来分解这一行代码做了什么。我们通过`context.Customer`访问`DbSet<Customer>`——这没有什么我们之前没见过的。但下一部分有点奇怪：`FirstOrDefault(c
    => c.Name == name)`。Lambda表达式在`name`属性之间找到匹配项，但我们之前没有见过`FirstOrDefault`。`FirstOrDefault`是在`System.Linq`中定义的扩展方法。
- en: Extension methods
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法
- en: 'Extension methods are static methods, and we call them on specific types. For
    example, we can call the `FirstOrDefault` LINQ extension method on any instance
    implementing the `IQueryable` interface. How do we know what type an extension
    method operates on and can be used with? Look at the method signature of an extension
    method: extension methods always have an argument that starts with the `this`
    keyword, followed by the specific type (or interface) they want to operate on.
    For example, `public static string MyExtensionMethod(this IDisposable arg)` signifies
    an extension method that any object implementing `IDisposable` can call that returns
    a string.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法是静态方法，我们可以在特定类型上调用它们。例如，我们可以调用任何实现`IQueryable`接口的实例上的`FirstOrDefault` LINQ扩展方法。我们如何知道扩展方法操作的是哪种类型，并且可以与之一起使用？看看扩展方法的签名：扩展方法始终有一个以`this`关键字开始的参数，后面跟着它们想要操作的具体类型（或接口）。例如，`public
    static string MyExtensionMethod(this IDisposable arg)`表示任何实现`IDisposable`的对象都可以调用的扩展方法，它返回一个字符串。
- en: '![](../Images/07_04_UN01.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07_04_UN01.png)'
- en: The `FirstOrDefault` LINQ extension method selects the first element in a collection
    that matches a provided predicate. If no matching elements are found, the `FirstOrDefault`
    method returns the default value for the return type. What we want, in this code,
    is to find the first element in the `context.Customer` set that has a matching
    `Name` to our input argument of `name`. If no first matching `Customer` is found,
    `FirstOrDefault` returns a null value (the default value for `Customer`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`FirstOrDefault` LINQ扩展方法从集合中选择与提供的谓词匹配的第一个元素。如果没有找到匹配的元素，`FirstOrDefault`方法返回返回类型的默认值。在这段代码中，我们想要找到`context.Customer`集中与我们的输入参数`name`匹配的`Name`的第一个元素。如果没有找到第一个匹配的`Customer`，`FirstOrDefault`返回一个null值（`Customer`的默认值）。'
- en: 'That brings us to the second unfamiliar part of the return statement: `?? throw
    new CustomerNotFoundException();`. As you may recall from section 5.3.6, we call
    the `??` operator the “null-coalescing operator.” A null-coalescing operator allows
    us to say, “If this thing is null, use this other value instead.” So, in our case,
    “If the `FirstOrDefault` returns a null value (the default value for `Customer`),
    throw an exception of type `CustomerNotFoundException` instead.” The asynchronous
    version of `FirstOrDefault` is `FirstOrDefaultAsync`, as shown next:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了返回语句的第二部分不熟悉的部分：`?? throw new CustomerNotFoundException();`。如您从第5.3.6节中回忆的那样，我们将`??`运算符称为“空合并运算符”。空合并运算符允许我们说，“如果这个值是null，则使用这个其他值。”因此，在我们的情况下，“如果`FirstOrDefault`返回一个null值（`Customer`的默认值），则抛出一个`CustomerNotFoundException`类型的异常。”`FirstOrDefault`的异步版本是`FirstOrDefaultAsync`，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can now go back to our success case test and run it once more, verifying
    that all tests pass.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以回到我们的成功案例测试，再次运行它，验证所有测试是否通过。
- en: '7.2 Congruence: From the Middle Ages to C#'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 一致性：从中世纪到C#
- en: 'According to myth and legend, local medieval legend Grutte Pier (a seven-foot-tall
    rebel leader with a massive sword, shown in figure 7.5) used a Frisian saying
    as a shibboleth to determine whether he faced an enemy (usually the Habsburgs
    and Saxons) or a true Frisian. Because Frisian is one of the closest linguistic
    relatives to Old English (modern-day English is still part of the Anglo-Frisian
    language group), see if you can pick out its meaning and give it a whirl:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 根据神话和传说，当地中世纪传说中的Grutte Pier（一个身高七英尺的持剑叛乱领袖，如图7.5所示）使用弗里斯语谚语作为试金石来判断他面对的是敌人（通常是哈布斯堡王朝和萨克森人）还是真正的弗里斯人。因为弗里斯语是古英语（现代英语仍然是盎格鲁-弗里斯语族的一部分）最接近的语言亲属之一，看看你是否能找出它的意思并试一试：
- en: “Bûter, brea, en griene tsiis; wa’t dat net sizze kin is gjin oprjochte Fries”
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: “黄油、面包和绿色奶酪；谁如果说这不是一个真诚的弗里斯兰人，那他就说错了”
- en: 'When translated to English, that strange-looking text means: “Butter, bread,
    and green cheese; who cannot say this is not a sincere Frisian.” (The green cheese
    refers to a Frisian cheese embedded with cumin and cloves. The cheese’s natural
    rind can take on a greenish hue.) So, what does a shibboleth have to do with C#
    or programming? Well, not a whole lot, but I can use it to show you the following
    example of equality and congruence:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当翻译成英语时，那个看起来奇怪的文本意思是：“黄油、面包和绿色奶酪；谁如果说这不是一个真诚的弗里斯兰人，那他就说错了。”（绿色奶酪指的是嵌有孜然和丁香的一种弗里斯兰奶酪。奶酪的自然皮可以呈现出绿色。）那么，口令与C#或编程有什么关系呢？嗯，关系不大，但我可以用它来向你展示以下关于相等性和相容性的例子：
- en: '![](../Images/07_04_UN02.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07_04_UN02.png)'
- en: You see, Grutte Pier was testing whether somebody was a Frisian. Was Pier testing
    if person *A* was equal (in the sense of identical properties, not social equality)
    to person *B*? No. Person *A* may have blond hair, whereas person *B* may not.
    He tested for congruence between person *A* and the Frisian people. If you could
    say his shibboleth, he deemed you congruent to a Frisian and, therefore, you got
    to live. And you said congruence never saved somebody’s life! If we use mathematical
    set notation and state that a set *A* is equal to {bûter,brea,grieneTsiis} and
    set *B* equals {*aachje ... zeppelin*} representing all Frisian words in somebody’s
    vocabulary, we can say {*x* |*x* ∈ *A* ∧ *x* ∈*B* } ⇔ *frisian*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，Grutte Pier是在测试某人是否是弗里斯兰人。Pier是在测试人*A*是否与人*B*相等（在相同属性、而非社会平等的意义上）吗？不是的。人*A*可能有一头金发，而人*B*可能没有。他测试了人*A*与弗里斯兰人民之间的相容性。如果你能说出他的口令，他就认为你与弗里斯兰人相容，因此你可以活下去。而且你说相容性从未救过任何人的命！如果我们使用数学集合符号，并声明集合*A*等于{黄油、面包、绿色奶酪}，集合*B*等于{aachje
    ... zeppelin}，代表某人词汇表中的所有弗里斯兰单词，我们可以说{∗x∣∗x∈∗A∧∗x∈∗B∗} ⇔ ∗frisian∗。
- en: '![](../Images/07_05.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07_05.png)'
- en: Figure 7.5 A drawing of Grutte Pier by Pieter Feddes van Harlingen (1568–1623).
    The Latin inscription at the bottom of the painting roughly translates to “we
    assert to the great liberty of Pier.” Pier is the keeper of liberty for the Frisian
    people.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 Pieter Feddes van Harlingen（1568–1623）绘制的Grutte Pier。画底部的拉丁文铭文大致翻译为“我们断言Pier的伟大自由。”Pier是弗里斯兰人民自由的守护者。
- en: In section 7.1, we implemented and tested the `CustomerRepository.GetCustomerByName`
    method, which accepts an input parameter representing a customer’s name and returns
    the appropriate `Customer` instance from the database. Before we call it a day,
    however, I want to take a slight detour and see whether there is anything else
    we can do to improve the unit tests in the `CustomerRepositoryTests` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7.1节中，我们实现了并测试了`CustomerRepository.GetCustomerByName`方法，该方法接受一个表示客户名称的输入参数，并从数据库中返回适当的`Customer`实例。然而，在我们结束之前，我想稍微偏离一下，看看我们是否还能做些什么来改进`CustomerRepositoryTests`类中的单元测试。
- en: 'I’d say we have the following, more elegant ways to check for equality (or,
    rather, congruity) between the `Customer` instance in the database and the `Customer`
    instance we used to assert in the `GetCustomerByName_Success` unit test:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以说，我们有以下更优雅的方式来检查数据库中的`Customer`实例与我们用于断言的`GetCustomerByName_Success`单元测试中的`Customer`实例之间的相等性（或者更确切地说，是相容性）：
- en: Creating a custom comparer class using `EqualityComparer<T>` (section 7.2.1).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`EqualityComparer<T>`（第7.2.1节）创建自定义比较器类。
- en: Overriding `object.Equals` (section 7.2.2).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写`object.Equals`（第7.2.2节）。
- en: Operator overloading (section 7.2.3).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载（第7.2.3节）。
- en: In the following three sections, we combine these approaches into one unified
    way of testing for equality. If you are just looking for the simplest way of achieving
    this, overriding `object.Equals` is the easiest (and a common) way of doing equality
    checks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三个部分中，我们将这些方法结合成一种统一的测试相等性的方式。如果你只是想找到实现这一点的最简单方法，重写`object.Equals`是最简单（也是最常见的）的相等性检查方法。
- en: 7.2.1 Creating a “comparer” class using EqualityComparer<T>
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 使用EqualityComparer<T>创建“比较器”类
- en: A “comparer” class allows us to define how to compare two instances of the same
    type and when they are “equal.” We already discussed congruence, and, in this
    section, we apply the concept of congruence to equality comparisons.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“比较器”类允许我们定义如何比较同一类型的两个实例，以及它们何时是“相等”的。我们之前已经讨论了相容性，在本节中，我们将相容性的概念应用于相等性比较。
- en: 'In my opinion, the use of the term “equality” is unfortunate because we really
    say that something is congruent, not equal, to something else. But, alas, these
    are the cards .NET 5 and C# have dealt us. A “comparer” class derives from the
    `EqualityComparer<T>` class. The `EqualityComparer<T>` class is an abstract class
    that contains the following two abstract methods that the compiler forces us to
    override and implement:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，使用“相等”这个词是不幸的，因为我们实际上是在说某物与另一物是**同构的**，而不是相等的。但是，唉，这就是 .NET 5 和 C# 给我们出的牌。一个“比较器”类是从
    `EqualityComparer<T>` 类派生出来的。`EqualityComparer<T>` 类是一个抽象类，它包含以下两个抽象方法，编译器强制我们重写并实现：
- en: '`bool Equals(T argumentX, T argumentY)`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool Equals(T argumentX, T argumentY)`'
- en: '`int GetHashCode(T obj``)`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int GetHashCode(T obj``)`'
- en: By overriding and implementing the `Equals` and `GetHashCode` methods, we adhere
    to the requirements of the `EqualityComparer<T>` base class. At first, you may
    think it strange we need to implement the `GetHashCode` method. After all, don’t
    we just want to determine something is equal to something else? Yes, but `GetHashCode`
    (as well as `Equals`) is a method present on the `Object` class in .NET. Because
    *every* class in .NET derives ultimately from the `Object` class, the `GetHashCode`
    method is present in every class, be it explicitly or implicitly through inheritance
    up to the object class. Dictionaries use hash codes under the hood to perform
    element lookups and equality comparisons. This means that a dictionary is a conceptual
    hash table. (C# does have an explicit `Hashtable` implementation. The difference
    is that a dictionary is generic, whereas `Hashtable` is not.) By using hash codes,
    we get the benefit of very quick lookup, insert, and delete operations when compared
    to a regular list (which does not use hash codes).[¹](#pgfId-1195795) Hash codes
    operate under the assumption that the same hash code is always generated for the
    same object. So, if two objects are identical, two identical hash codes are generated.
    If by chance two objects are not different but the same hash code is generated
    for both of them, we speak of a *hash collision*. This means we have to come up
    with some other way to insert the items into the array.[²](#pgfId-1195822)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重写和实现 `Equals` 和 `GetHashCode` 方法，我们遵循了 `EqualityComparer<T>` 基类的要求。起初，你可能觉得我们需要实现
    `GetHashCode` 方法很奇怪。毕竟，我们不是只想确定某物等于另一物吗？是的，但 `GetHashCode`（以及 `Equals`）是 .NET
    中 `Object` 类上的一个方法。因为 *每个* .NET 中的类最终都派生自 `Object` 类，所以 `GetHashCode` 方法存在于每个类中，无论是显式还是通过继承到对象类。字典在底层使用哈希码来执行元素查找和相等比较。这意味着字典是一个概念上的哈希表。（C#
    确实有一个显式的 `Hashtable` 实现。区别在于字典是泛型的，而 `Hashtable` 不是。）通过使用哈希码，我们得到了与普通列表（不使用哈希码）相比非常快速查找、插入和删除操作的好处。[¹](#pgfId-1195795)
    哈希码在假设相同的哈希码总是为相同的对象生成的情况下操作。因此，如果两个对象是相同的，就会生成两个相同的哈希码。如果两个对象不是不同的，但为它们都生成了相同的哈希码，我们称之为
    *哈希冲突*。这意味着我们必须想出其他方法来将这些项目插入到数组中。[²](#pgfId-1195822)
- en: Because `GetHashCode` is present on every object in .NET, we can come up with
    a somewhat dynamic way of generating a hash code by using another class’s `GetHashCode`
    implementation. To generate a hash code, we do need some seed information. The
    `Customer` object has only two fields we can use on which to base our hash code–generation
    logic. We can use a combination of the length property of `Customer.Name`, the
    `Customer.CustomerID` property, and a “randomly” generated integer, as shown in
    the next listing. Note that a lot of discussions arise around when and when not
    to use `GetHashCode`. I would refer you to the Microsoft documentation for the
    most up-to-date information on this (as well as for the plethora of warnings to
    keep in mind when using `GetHashCode`).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `GetHashCode` 存在于 .NET 中的每个对象上，我们可以通过使用另一个类的 `GetHashCode` 实现来提出一种相对动态的生成哈希码的方法。要生成哈希码，我们需要一些种子信息。`Customer`
    对象只有两个字段我们可以用来基于我们的哈希码生成逻辑。我们可以使用 `Customer.Name` 的长度属性、`Customer.CustomerID`
    属性以及一个“随机”生成的整数组合，如下一列表所示。请注意，关于何时以及何时不使用 `GetHashCode` 的讨论很多。我会建议您查阅微软文档以获取有关此的最新信息（以及使用
    `GetHashCode` 时要牢记的大量警告）。
- en: Listing 7.2 CustomerEqualityComparer’s `GetHashCode` implementation
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 CustomerEqualityComparer 的 `GetHashCode` 实现方法
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Overrides the abstract GetHashCode method
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重写抽象的 `GetHashCode` 方法
- en: ❷ Generates a random number up to half of the maximum integer value
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 生成一个不超过最大整数值一半的随机数
- en: ❸ Concatenates variables and fields and hashes the resulting value
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 连接变量和字段，并对结果值进行哈希处理
- en: 'We can generate “random” numbers in C# using the following two general methods:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下两种通用方法在C#中生成“随机”数字：
- en: Use the `Random` class.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Random`类。
- en: Use the `RandomNumberGenerator` class.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RandomNumberGenerator`类。
- en: 'At first glance, they may seem similar, but if we dig a little deeper, we see
    differences. The `Random` class lives in the (root) `System` namespace, whereas
    the `RandomNumberGenerator` class lives in the `System.Security.Cryptography`
    namespace. The namespaces in which the respective classes live provide a major
    hint at why they both exist: the `Random` class is a low-overhead random-number
    picker that is very good at quickly spitting out a number based on a time seed
    number. The `RandomNumberGenerator` class excels at generating “random” numbers
    through a variety of cryptography concepts, making sure that numbers are fairly
    unique and somewhat equally distributed in a range over time.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，它们可能看起来很相似，但如果我们深入挖掘，我们会看到差异。`Random`类位于（根）`System`命名空间中，而`RandomNumberGenerator`类位于`System.Security.Cryptography`命名空间中。这些类所在的命名空间提供了它们为什么都存在的主要原因的提示：`Random`类是一个低开销的随机数选择器，它非常擅长根据时间种子数快速生成一个数字。`RandomNumberGenerator`类擅长通过各种密码学概念生成“随机”数字，确保数字在一段时间内的范围内是相当独特且大致均匀分布的。
- en: In other words, if you were to use the `Random` class in a high throughput application
    and request two random numbers at the same time, chances are you would get the
    same number back from the “random” generator. Generating a pseudo-random number
    is fine for a lot of applications, but for a web service, where we cannot predict
    what load the system could be under, it is unsuitable. We may very well be in
    a situation where two people want to retrieve information for the same flight
    at the exact same moment. We now have two customers generating the same hash code
    and a security flaw on our hands. That is why we should use the `RandomNumberGenerator`
    class instead of the `Random` class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果你在一个高吞吐量应用中使用`Random`类并且同时请求两个随机数，那么你很可能从“随机”生成器那里得到相同的数字。生成伪随机数对于许多应用来说是可行的，但对于一个我们不能预测系统可能承受什么负载的Web服务来说，这是不合适的。我们可能会遇到两个人同时想要获取同一航班信息的情况。现在我们有两个客户生成了相同的哈希码，我们手头出现了安全漏洞。这就是为什么我们应该使用`RandomNumberGenerator`类而不是`Random`类的原因。
- en: '| ![](../Images/LightBulb.png)   | As you explore the world of random numbers
    and cryptography in C#, you may come across people advocating the usage of the
    `RNGCryptoServiceProvider` class. The `RandomNumberGenerator` class is a wrapper
    around the `RNGCryptoServiceProvider` class and much easier to use. A good resource
    for further cryptography information is David Wong’s *Real-World Cryptography*
    (Manning, 2021). |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   | 当你在C#的世界中探索随机数和密码学时，你可能会遇到一些人推崇使用`RNGCryptoServiceProvider`类。`RandomNumberGenerator`类是`RNGCryptoServiceProvider`类的包装，并且使用起来更加简单。关于密码学的更多信息，一个好的资源是David
    Wong的*《现实世界密码学》*（Manning，2021）。|'
- en: “Random” is never random
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: “随机”永远不会是随机的
- en: Imagine you want to listen to some music through your favorite music-streaming
    application. You probably have a playlist with thousands of songs but don’t want
    to start at the top every time you want to listen to music. You would tire of
    listening to the same songs in the same pattern very quickly. So, you press the
    “shuffle” button, assuming that your application shuffles your playlist randomly
    and plays the songs in a new order. Unfortunately, I am here to burst that bubble.
    Shuffling a playlist rarely gets you a true random representation of your music.
    Applications like Spotify use a shuffling algorithm that attempts to create an
    on-the-fly playlist shuffle experience where no songs from the same album or artist
    are played after each other. We have all had that experience, though. Why is it
    that shuffling a playlist is such a tricky problem? The issue is that randomness
    in computing is never completely random.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想要通过你最喜欢的音乐流媒体应用听一些音乐。你可能有一个包含数千首歌曲的播放列表，但每次你想听音乐时都不想从顶部开始。很快你就会厌倦以同样的模式听同样的歌曲。所以，你按下“随机播放”按钮，假设你的应用会随机打乱你的播放列表并按新的顺序播放歌曲。不幸的是，我就在这里来打破这个幻想。随机播放播放列表很少能给你一个真正的随机音乐表示。像Spotify这样的应用使用的是一种随机算法，试图创建一种即时的播放列表随机播放体验，其中同一专辑或艺术家的歌曲不会连续播放。我们都有过这样的经历。为什么随机播放播放列表是一个如此棘手的问题呢？问题在于计算中的随机性永远不是完全随机的。
- en: It all boils down to the fact that computers have to be told how to pick a random
    number. Random-number pickers use an algorithm that bases their starting point
    on a “seed” number, often the current timestamp. A seed number of *X* always returns
    the same return *Y*. If you use the current time as your seed number, running
    the same algorithm in parallel starting at the same moment, you get two identical
    (but “random”) outputs. This makes picking a random number a potential security
    issue. If you know the seed number and algorithm used by the picker, you can predict
    the next output value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都归结为这样一个事实：计算机必须被告知如何选择一个随机数。随机数生成器使用一个算法，其起点基于一个“种子”数字，通常是当前的时间戳。一个 *X*
    的种子数字总是返回相同的 *Y*。如果你使用当前时间作为种子数字，在相同时刻并行运行相同的算法，你会得到两个相同的（但“随机”的）输出。这使得选择随机数成为一个潜在的安全问题。如果你知道选择器的种子数字和算法，你可以预测下一个输出值。
- en: Hackers use “random-number-generator attacks” to exploit this vulnerability.
    A historical example of problems around randomness in computing is failing to
    generate a correct random value for an elliptic curve digital signature algorithm
    in Sony’s Playstation 3 video game console. By exploiting this error, hackers
    could tell the system that homebrew applications (and as a result, pirated video
    games) were valid applications and, therefore, to run them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客使用“随机数生成器攻击”来利用这个漏洞。计算中随机性问题的一个历史例子是索尼的 PlayStation 3 游戏机中椭圆曲线数字签名算法未能生成正确的随机值。通过利用这个错误，黑客可以告诉系统，自制应用程序（以及因此，盗版视频游戏）是有效应用程序，因此可以运行它们。
- en: 'I leave you with this quote by computing pioneer John von Neumann, intended
    as a lighthearted warning against misunderstanding the limits of randomness in
    computing:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以下这句话留给你们，这是计算先驱约翰·冯·诺伊曼（John von Neumann）所说，旨在轻松地提醒大家不要误解计算中随机性的限制：
- en: '*“Anyone who considers arithmetical methods of producing random digits is,
    of course, in a state of sin.”*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*“任何认为可以通过算术方法产生随机数字的人，当然是在犯罪。”*'
- en: We overrode and implemented the `GetHashCode` method, so now it is time to do
    the same for the `Equals` method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重写并实现了 `GetHashCode` 方法，现在是时候为 `Equals` 方法做同样的事情了。
- en: 7.2.2 Testing equality by overriding the Equals method
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 通过重写 Equals 方法来测试等价性
- en: 'Before we override `Equals`, let’s settle on what things need to be equal to
    say that `Customer` instance *X* is “equal” to `Customer` instance *Y*. The `Customer`
    class does not have a lot of properties to check for: only `CustomerId` and `Name`
    are usable. The `Booking` field is a collection representing any foreign key constraints
    on the `Customer` model. But, for our congruence check, those properties are not
    relevant because we don’t use them to establish congruence, so we don’t use the
    collection in our check. If `Customer` *X* has the same `Name` and `CustomerId`
    property values as `Customer` *Y*, they are equal (and so, we return a `bool`
    set to `true` out of the `Equals` method, as shown in the next listing).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们重写 `Equals` 方法之前，让我们确定一下哪些属性需要相等，才能说 `Customer` 实例 *X* 与 `Customer` 实例 *Y*
    是“相等”的。`Customer` 类没有很多属性需要检查：只有 `CustomerId` 和 `Name` 是可用的。`Booking` 字段是一个集合，代表对
    `Customer` 模型的任何外键约束。但是，对于我们的等价性检查，这些属性并不相关，因为我们不使用它们来建立等价性，所以我们不使用这个集合进行检查。如果
    `Customer` *X* 的 `Name` 和 `CustomerId` 属性值与 `Customer` *Y* 相同，它们就是相等的（因此，我们在 `Equals`
    方法中返回一个设置为 `true` 的 `bool`，如下一列表所示）。
- en: Listing 7.3 CustomerEqualityComparer’s `Equals` method implementation
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 CustomerEqualityComparer 的 `Equals` 方法实现
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Verifies that both Customer instances have the same CustomerId value
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 验证两个 Customer 实例是否具有相同的 CustomerId 值
- en: ❷ Verifies that both Customer instances have the same Name value
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证两个 Customer 实例是否具有相同的 Name 值
- en: 'We want to call our `Equals` method every time we compare two instances of
    type `Customer`. We could expose an `Equals` method in the `Customer` class and
    call the `CustomerEqualityComparer.Equals` method. That would work very well,
    because `Equals` is part of `object` and, therefore, available to most derived
    types. It is probably what you want to do in real life, and I am assuming you
    can implement this on your own. However, this presents an excellent opportunity
    for me to talk about something else: if we are already going down a bit of a rabbit
    hole by implementing a “comparer” class, we may as well go all the way. Probably
    the most common technique of checking equality in two objects is by using the
    equality operator: `==`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在比较两个 `Customer` 类型的实例时每次都调用我们的 `Equals` 方法。我们可以在 `Customer` 类中公开一个 `Equals`
    方法并调用 `CustomerEqualityComparer.Equals` 方法。这将非常有效，因为 `Equals` 是 `object` 的一部分，因此对大多数派生类型都是可用的。这可能是你现实生活中想要做的，我假设你可以自己实现这一点。然而，这为我提供了一个很好的机会来谈论其他事情：如果我们已经在实现“比较器”类的小径上走了一段，我们不妨一直走下去。检查两个对象相等性的最常见技术可能是使用赋值运算符：`==`。
- en: 7.2.3 Overloading the equality operator
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3 赋值运算符的重载
- en: 'Most of the time, you never think twice about the functionality behind the
    equality operator. Sure, you probably mistype and accidentally put down the assignment
    operator (`=`) at times, but surely the actual functionality of the equality operator
    is somewhat set in stone. In general, you can rely on the equality operator doing
    reference-type equality checks, but that functionality doesn’t work for us. Checking
    the reference pointers on two objects is not sufficient for comparing two `Customer`
    objects because the result would always be `false`. What to do? The solution is
    simple: if there is an implementation that does not meet your needs for a specific
    set of inputs, overload the implementation. In C#, we can overload operators.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你不会对赋值运算符背后的功能进行二次思考。当然，你可能偶尔会打字错误，不小心写下赋值运算符（`=`），但赋值运算符的实际功能似乎已经固定。一般来说，你可以依赖赋值运算符进行引用类型相等性检查，但这个功能对我们来说不起作用。检查两个对象的引用指针不足以比较两个
    `Customer` 对象，因为结果总是 `false`。怎么办？解决方案很简单：如果某个实现不能满足你对特定输入集的需求，就重载该实现。在 C# 中，我们可以重载运算符。
- en: Overloading an operator works much like overriding (more so than overloading)
    a method. In the world of operators, their programmatic names are their symbols
    (e.g., the plus sign, `+`, for the addition operator). One enormous difference
    between method and operator overloads, however, is that operator overloads are
    always static and public. It makes little sense to create an operator that is
    instance-level (static). Non-instance-level overridden operators create a confusing
    scenario where you have multiple versions of the same operator for the same type
    floating around with no clear boundaries to the casual observer. The syntax for
    using an operator does not allow for an `[instance].[operator]`, or `string.+`
    construct (this is allowed in languages such as Scala). As far as the `public`
    access modifier is concerned, when you use an operator on a specific type, you
    are not operating within that type’s class file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重载运算符的工作方式与重写（比重载更多）方法非常相似。在运算符的世界里，它们的程序化名称是它们的符号（例如，加号 `+` 是加法运算符）。然而，方法和运算符重载之间有一个巨大的区别，即运算符重载始终是静态和公共的。创建实例级别的运算符（静态）几乎没有意义。非实例级别的重写运算符会创建一个令人困惑的场景，其中同一类型的多个相同运算符在周围漂浮，对旁观者来说没有明确的界限。使用运算符的语法不允许使用
    `[实例].[运算符]` 或 `string.+` 构造（这在 Scala 等语言中是允许的）。至于 `public` 访问修饰符，当你对一个特定类型使用运算符时，你并不在那个类型的类文件中进行操作。
- en: 'To overload an operator, use the following syntax: `public static [return type]
    operator [operator name] (T x, T y) { ... }`, where `T` stands for the type you
    want to operate on. In our overload of the equality operator inside the `Customer`
    class, we want to call the `CustomerEqualityOperator`’s `Equals` method and return
    the result, as shown in the next code sample.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要重载一个运算符，请使用以下语法：`public static [返回类型] operator [运算符名称] (T x, T y) { ... }`，其中
    `T` 代表你想要操作的类型。在我们对 `Customer` 类中赋值运算符的重载中，我们想要调用 `CustomerEqualityOperator` 的
    `Equals` 方法并返回结果，如以下代码示例所示。
- en: NOTE When overloading operators, if the operator has a matching operator (e.g.,
    `==` and `!=)`, you have to overload both operators.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当重载运算符时，如果运算符有一个匹配的运算符（例如，`==` 和 `!=`），你必须重载这两个运算符。
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Right now, we create a new instance of the comparer every time we call the overloaded
    operator. In an actual production codebase, you should consider moving the instantiation
    to the instance level. This sidesteps incurring the overhead of instantiation
    on every call to the overloaded operator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，每次调用重载运算符时，我们都创建一个新的比较器实例。在实际的生产代码库中，你应该考虑将实例化移动到实例级别。这样可以避免在每次调用重载运算符时产生实例化的开销。
- en: 'The overload of the `!=` operator calls our overload of the equality operator
    and negates the result from that method’s execution. Now comes the fun part: we
    get to use the overloaded operators in our `CustomerRepositoryTests.GetCustomerByName
    _Success` unit test instead of having to check for congruity by comparing object
    fields.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`!=` 运算符的重载调用我们的等号运算符重载，并否定该方法执行的结果。现在到了有趣的部分：我们可以在 `CustomerRepositoryTests.GetCustomerByName
    _Success` 单元测试中使用重载的运算符，而不是通过比较对象字段来检查一致性。'
- en: To check the instance in the database against the returned `Customer` from the
    `GetCustomerByName` method, we first need to grab the `Customer` from the in-memory
    database using the LINQ `First` method, as shown in the next listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据库中的实例与 `GetCustomerByName` 方法返回的 `Customer` 对比，我们首先需要使用 LINQ 的 `First` 方法从内存数据库中获取
    `Customer`，如下一个列表所示。
- en: Listing 7.4 Use LINQ’s `First` method on a database’s internal set (EF Core)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 在数据库的内部集合上使用 LINQ 的 `First` 方法（EF Core）
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Gets a Customer from the in-memory database
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从内存数据库中获取一个客户
- en: ❷ Grabs the first (and only) element directly from the in-memory database
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 直接从内存数据库中获取第一个（也是唯一一个）元素
- en: ❸ Uses the overloaded equality operator
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用重载的等号运算符
- en: ❹ Verifies that both Customer instances are “equal”
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 验证两个客户实例是否“相等”
- en: 'In listing 7.4, we used our overloaded equality operator to test for our definition
    of equivalence between two instances of `Customer`. Before we wrap up this chapter,
    I’m going to let you in on one other secret: we can condense the code in listing
    7.4 even more and make it more idiomatic. The `Assert.AreEqual` method calls the
    object’s `Equal` method, which in turn (depending on the provided implementation)
    uses the equality operator. Because we overloaded the equality operator for `Customer`,
    the CLR (indirectly) calls the overloaded equality operator when we use the `Assert.AreEqual`
    method on two instances of `Customer`! Let’s give it a whirl:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 7.4 中，我们使用重载的等号运算符来测试两个 `Customer` 实例之间我们定义的等价性。在我们结束本章之前，我要向你透露另一个秘密：我们可以进一步精简列表
    7.4 中的代码，并使其更加符合惯例。`Assert.AreEqual` 方法调用对象的 `Equal` 方法，而该方法（根据提供的实现）会使用等号运算符。因为我们为
    `Customer` 重载了等号运算符，所以当我们在两个 `Customer` 实例上使用 `Assert.AreEqual` 方法时，CLR（间接地）调用重载的等号运算符！让我们试试看：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How about we actually run the `GetCustomerByName_Success` test? Did it pass?
    Good. Now run all the other unit tests as well. Every unit test should pass, as
    shown in figure 7.6\. If one doesn’t, please go back to the respective section
    and see what went wrong before moving on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在实际运行 `GetCustomerByName_Success` 测试怎么样？它通过了吗？很好。现在运行所有其他单元测试。每个单元测试都应该通过，如图
    7.6 所示。如果有一个没有通过，请回到相应的部分，看看出了什么问题，然后再继续。
- en: '![](../Images/07_06.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07_06.png)'
- en: Figure 7.6 All our existing tests pass (as shown in the Visual Studio Test Explorer).
    The checkmarks represent tests that have passed. We also see the run time for
    the tests both individually and combined.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 我们所有的现有测试都通过了（如图所示在 Visual Studio 测试资源管理器中）。勾号代表已通过的测试。我们还可以看到测试的运行时间，无论是单独的还是组合的。
- en: We can now add a new customer to the database and get it back when given an
    ID. That covers all the functionality we need from the `CustomerRepository`. We
    use the patterns used in the `CustomerRepository` in the remaining repositories.
    In section 6.2, we examined how the inherited codebase handled adding a new customer
    to the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向数据库添加一个新客户，并在给定 ID 时检索它。这涵盖了我们从 `CustomerRepository` 需要的所有功能。我们在剩余的存储库中使用
    `CustomerRepository` 中的模式。在第 6.2 节中，我们研究了继承的代码库是如何处理向数据库添加新客户的。
- en: 'Let’s recap our findings there. We determined that the major design flaws of
    the existing codebases with adding a `Customer` object to the database were as
    follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的发现。我们确定现有代码库在向数据库添加 `Customer` 对象时的主要设计缺陷如下：
- en: The code should be self-documenting.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码应该是自文档化的。
- en: We should not use hardcoded SQL statements.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该使用硬编码的 SQL 语句。
- en: We should use explicit types instead of implicit types (the `var` keyword).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该使用显式类型而不是隐式类型（`var` 关键字）。
- en: I think we did very well in addressing those concerns. Our code is readable
    and clean. The code is self-documenting, and we use Entity Framework Core to abstract
    away any SQL queries. How did the existing code retrieve `Customer` objects from
    the database? Well, it did not retrieve any `Customer` objects from the database
    at all! That seems odd at first. If the existing codebase retrieved nothing from
    the `Customer` table, why does our service retrieve `Customer` entities? Keep
    in mind that to book a flight, we need access to an up-to-date `Customer` object.
    The old service created a new `Customer` object every time somebody booked a flight
    through its API, resulting in potentially duplicate entries in the database for
    the same `Customer`. We know better and do not have that issue, as long as we
    pass the correct information to our methods. In this chapter, you also learned
    how to use an equality “comparer” class and operator overloads to test for your
    definition of equivalency (or rather, congruity).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们在处理那些担忧方面做得很好。我们的代码可读且整洁。代码是自我文档化的，我们使用 Entity Framework Core 来抽象任何 SQL
    查询。现有的代码是如何从数据库中检索 `Customer` 对象的？嗯，它根本就没有从数据库中检索任何 `Customer` 对象！一开始这似乎很奇怪。如果现有的代码库没有从
    `Customer` 表中检索任何内容，那么我们的服务为什么还要检索 `Customer` 实体？记住，为了预订航班，我们需要访问最新的 `Customer`
    对象。旧的服务每次有人通过其 API 预订航班时都会创建一个新的 `Customer` 对象，这可能导致数据库中同一 `Customer` 的重复条目。我们知道得更好，只要我们向我们的方法传递正确的信息，我们就不会有这个问题。在本章中，你还学习了如何使用等价“比较器”类和运算符重载来测试你的等价定义（或者更确切地说，等价性）。
- en: Exercises
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 7.1
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.1
- en: Currently, there is no unit test around a possible null condition when returning
    from `GetCustomerByName` when the given name does not match a `Customer` object
    in the database. How would we test for this?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当从 `GetCustomerByName` 返回时，如果给定的名称与数据库中的 `Customer` 对象不匹配，没有围绕可能的空条件进行单元测试。我们将如何测试这一点？
- en: Exercise 7.2
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.2
- en: Which of the following is a valid nullable type?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个是有效的可空类型？
- en: a. `Customer!`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: a. `Customer!`
- en: b. `Customer?`
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: b. `Customer?`
- en: c. `^Customer`
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: c. `^Customer`
- en: Exercise 7.3
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.3
- en: 'Fill in the blank: A custom exception has to inherit from the __________ class
    so we can throw it where appropriate.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 填空：自定义异常必须从 ________ 类继承，这样我们就可以在适当的位置抛出它。
- en: Exercise 7.4
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.4
- en: What does the LINQ extension method `FirstOrDefault` return if it cannot find
    a matching item in the collection?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 LINQ 扩展方法 `FirstOrDefault` 在集合中找不到匹配项，它返回什么？
- en: a. A null value
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: a. 一个空值
- en: b. `-1`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: b. `-1`
- en: c. The default value for the collection’s type
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: c. 集合类型的默认值
- en: Exercise 7.5
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.5
- en: What does the equality operator test for in this code snippet, and what is its
    verdict?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，等号运算符测试什么，它的结论是什么？
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: a. The equality operator tests for reference equality. It returns `false`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: a. 等号运算符测试引用相等性。它返回 `false`。
- en: b. The equality operator tests for reference equality. It returns `true`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: b. 等号运算符测试引用相等性。它返回 `true`。
- en: c. The equality operator tests for value equality. It returns `false`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: c. 等号运算符测试值相等性。它返回 `false`。
- en: d. The equality operator tests for value equality. It returns `true`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: d. 等号运算符测试值相等性。它返回 `true`。
- en: Exercise 7.6
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.6
- en: What does the equality operator test for in this code snippet, and what is its
    verdict?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，等号运算符测试什么，它的结论是什么？
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: a. The equality operator tests for reference equality. It returns `false`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: a. 等号运算符测试引用相等性。它返回 `false`。
- en: b. The equality operator tests for reference equality. It returns `true`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: b. 等号运算符测试引用相等性。它返回 `true`。
- en: c. The equality operator tests for value equality. It returns `false`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: c. 等号运算符测试值相等性。它返回 `false`。
- en: d. The equality operator tests for value equality. It returns `true`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: d. 等号运算符测试值相等性。它返回 `true`。
- en: Exercise 7.7
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.7
- en: True or false? When we overload an equality comparison operator, we can determine
    congruence between two types and return our own definition of equality.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？当我们重载等价比较运算符时，我们可以确定两个类型之间的等价性，并返回我们自己的等价定义。
- en: Exercise 7.8
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.8
- en: When we overload the equality comparison operator, we also need to overload
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重载等价比较运算符时，我们还需要重载
- en: a. `!=`
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: a. `!=`
- en: b. `^=`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: b. `^=`
- en: c. `==`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: c. `==`
- en: Exercise 7.9
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.9
- en: True or false? By using the `Random` class to generate a random number, we are
    guaranteed a perfect random number.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？通过使用 `Random` 类生成随机数，我们保证得到一个完美的随机数。
- en: Exercise 7.10
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.10
- en: True or false? By using the `RandomNumberGenerator` class to generate a random
    number, we are guaranteed a perfect random number.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？通过使用 `RandomNumberGenerator` 类生成随机数，我们保证得到一个完美的随机数。
- en: Exercise 7.11
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 7.11
- en: True or false? In many (pseudo) random-number-generation algorithms, using the
    same seed number twice results in the same random numbers.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？在许多（伪）随机数生成算法中，使用相同的种子数字两次会产生相同的随机数。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We can examine input validation through the lens of lambda calculus. If we treat
    any function as a black box, with just an input and an output, separated from
    all other functions, we have to do input validation or risk a bad outcome. We
    shouldn’t rely on the validation of arguments elsewhere.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过λ演算的视角来检查输入验证。如果我们把任何函数视为一个黑盒，只有一个输入和一个输出，与其他所有函数分离，我们就必须进行输入验证，否则可能会得到不良的结果。我们不应该依赖于其他地方的参数验证。
- en: Nullable reference types allow us to explicitly state which reference types
    may have a null value. Using nullable reference types helps to avoid unexpected
    null-pointer exceptions.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可空引用类型允许我们明确指出哪些引用类型可能有空值。使用可空引用类型有助于避免意外的空指针异常。
- en: 'To designate a type as nullable, you add the `?` operator: `int? myNullableInt
    = 0;`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要指定一个类型为可空，你添加 `?` 运算符：`int? myNullableInt = 0;`。
- en: Every thrown exception (ultimately) derives from the `Exception` base class.
    This allows us to create our own (custom) exceptions and throw them like any other.
    Custom exceptions promote atomic error handling.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个抛出的异常（最终）都源自 `Exception` 基类。这允许我们创建自己的（自定义）异常并将它们像其他任何异常一样抛出。自定义异常促进了原子错误处理。
- en: You can check if a method throws a specific exception during a unit test run
    by adding the `[ExpectedException(typeof([your exception]))]` method attribute
    to your unit test. This allows you to unit-test failure scenarios of your code.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在单元测试运行期间通过添加 `[ExpectedException(typeof([your exception]))]` 方法属性到你的单元测试中来检查一个方法是否抛出了特定的异常。这允许你测试代码的失败场景。
- en: Entity Framework Core can operate under an “in-memory” mode. This allows you
    to spin up a local, in-memory database identical to your real one. Because we
    don’t want to unit-test against live data, this provides us with the “fake” database
    we need.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core可以在“内存”模式下运行。这允许你启动一个与真实数据库相同的本地内存数据库。因为我们不想针对实时数据进行单元测试，所以这为我们提供了所需的“假”数据库。
- en: You can use a custom `Comparer` class to create equivalency checks between two
    types if the standard reference equivalency check does not suffice. This allows
    you to reconcile two different instances of the same object, with the same values
    but different pointers.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果标准的引用等价性检查不足以在两种类型之间创建等价性检查，你可以使用自定义的 `Comparer` 类。这允许你协调同一对象的两个不同实例，它们具有相同的值但不同的指针。
- en: We can overload operators such as the equality operator to provide our own definition
    of equality and congruence. This is useful when wanting to compare two reference
    types for congruence instead of pure equality (the memory address matches).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以重载像等号运算符这样的运算符，以提供我们自己的等性和同余定义。当想要比较两个引用类型以检查同余而不是纯等性（内存地址匹配）时，这很有用。
- en: '* * *'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '***'
- en: ^(1.)The average time complexity of a hash table’s insert, lookup, and search
    operations (and, by extension, a dictionary) is *O*(1). The worst case for these
    operations is *O*(*n*). A generic list in C#, (`List<T>`), acts as a dynamic array.
    For a dynamic array, the average and worst-case time complexity for search, insertion,
    and deletion is *O*(*n*), where *n* is the number of elements in the dynamic array.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (1.) 哈希表的插入、查找和搜索操作（以及由此扩展的字典）的平均时间复杂度是 *O*(1)。这些操作的最坏情况是 *O*(*n*)。在C#中，泛型列表（`List<T>`）充当动态数组。对于动态数组，搜索、插入和删除的平均和最坏情况时间复杂度是
    *O*(*n*)，其中 *n* 是动态数组中的元素数量。
- en: '^(2.)A hash collision is an unwanted result but not a rare occurrence. Donald
    Knuth writes about the “Birthday Paradox” in *The Art of Computer Programming
    Volume 3: Sorting and Searching* (2nd edition; Addison-Wesley, 1998): given a
    hash function that generates hash codes based on a person’s birthday and a room
    with at least 23 people (a map of *n* people to a table of size 365, one entry
    for each day of a non–leap year, where *n* ≥ 23), the probability of at least
    two people sharing the same birthday (and generating the same hash code) is 0.4927.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (2.)哈希冲突是一个不希望出现的结果，但并非罕见事件。唐纳德·克努特在《计算机程序设计艺术 第3卷：排序与搜索》（第2版；Addison-Wesley，1998年）中提到了“生日悖论”：给定一个基于个人生日的哈希函数和一个至少有23人的房间（将*n*个人映射到大小为365的表中，每人对应非闰年的一天，其中*n*
    ≥ 23），至少有两个人共享相同的生日（并生成相同的哈希码）的概率是0.4927。
