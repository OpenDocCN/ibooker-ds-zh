- en: 6 Generalizing to higher dimensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 将概念推广到高维
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Implementing a Python abstract base class for general vectors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个Python抽象基类以实现通用向量
- en: Defining vector spaces and listing their useful properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义向量空间并列举它们的 useful properties
- en: Interpreting functions, matrices, images, and sound waves as vectors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数、矩阵、图像和声波解释为向量
- en: Finding useful subspaces of vector spaces containing data of interest
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找包含感兴趣数据的向量空间的有用子空间
- en: 'Even if you’re not interested in animating teapots, the machinery of vectors,
    linear transformations, and matrices can still be useful. In fact, these concepts
    are so useful there’s an entire branch of math devoted to them: *linear algebra*.
    Linear algebra generalizes everything we know about 2D and 3D geometry to study
    data in any number of dimensions.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你对动画茶壶不感兴趣，向量、线性变换和矩阵的机制仍然很有用。事实上，这些概念非常有用，以至于有一个整个数学分支专门研究它们：*线性代数*。线性代数将我们关于2D和3D几何的已知知识概括到研究任何数量的维度中的数据。
- en: 'As a programmer, you’re probably skilled at generalizing ideas. When writing
    complex software, it’s common to find yourself writing similar code over and over.
    At some point, you catch yourself doing this, and you consolidate the code into
    one class or function capable of handling all of the cases you see. This saves
    you typing and often improves code organization and maintainability. Mathematicians
    follow the same process: after encountering similar patterns over and over, they
    can better state exactly what they see and refine their definitions.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你可能擅长概括思想。在编写复杂的软件时，你可能会发现自己一遍又一遍地编写相似的代码。在某个时刻，你会发现自己正在这样做，并将代码合并到一个可以处理你所看到的所有情况的类或函数中。这可以节省你的打字时间，并经常改善代码的组织和可维护性。数学家遵循同样的过程：在反复遇到相似的图案后，他们可以更好地陈述他们所看到的内容，并完善他们的定义。
- en: In this chapter, we use this kind of logic to define *vector spaces*. Vector
    spaces are collections of objects we can treat like vectors. These can be arrows
    in the plane, tuples of numbers, or objects completely different from the ones
    we’ve seen so far. For instance, you can treat images as vectors and take a linear
    combination of them (figure 6.1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用这种逻辑来定义*向量空间*。向量空间是我们可以将它们视为向量的对象集合。这些可以是平面上的箭头、数字的元组，或者与我们迄今为止所看到的不同完全的对象。例如，你可以将图像视为向量，并对它们进行线性组合（图6.1）。
- en: '![](../Images/CH06_F01_Orland.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F01_Orland.png)'
- en: Figure 6.1 A linear combination of two pictures produces a new picture.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 两个图像的线性组合产生了一个新的图像。
- en: The key operations in a vector space are vector addition and scalar multiplication.
    With these, you can make linear combinations (including negation, subtraction,
    weighted averages, and so on), and you can reason about which transformations
    are linear. It turns out these operations help us make sense of the word *dimension*.
    For instance, we’ll see that the images used in figure 6.1 are 270,000-dimensional
    objects! We’ll cover higher-dimensional and even infinite-dimensional spaces soon
    enough, but let’s start by reviewing the 2D and 3D spaces we already know.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 向量空间中的关键操作是向量加法和数乘。有了这些，你可以进行线性组合（包括取反、减法、加权平均等），并且可以推理哪些变换是线性的。结果证明，这些操作帮助我们理解“维度”这个词的含义。例如，我们将看到图6.1中使用的图像是270,000维的对象！我们很快就会涵盖更高维甚至无限维的空间，但让我们先回顾一下我们已知的2D和3D空间。
- en: 6.1 Generalizing our definition of vectors
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 概括我们向量的定义
- en: 'Python supports object-oriented programming (OOP), which is a great framework
    for generalization. Specifically, Python classes support *inheritance* : you can
    create new classes of objects that inherit properties and behaviors of an existing
    parent class. In our case, we want to realize the 2D and 3D vectors we’ve already
    seen as instances of a more general class of objects simply called vectors. Then
    any other objects that inherit behaviors from the parent class can rightly be
    called vectors as well (figure 6.2).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持面向对象编程（OOP），这是一个很好的概括框架。具体来说，Python类支持*继承*：你可以创建新的对象类，这些类继承现有父类的属性和行为。在我们的例子中，我们希望将我们已看到的2D和3D向量实现为更一般类对象的实例，这个类简单地称为向量。然后，任何从父类继承行为的其他对象也可以正确地被称为向量（图6.2）。
- en: '![](../Images/CH06_F02_Orland.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F02_Orland.png)'
- en: Figure 6.2 Treating 2D vectors, 3D vectors, and other objects as special cases
    of vectors using inheritance
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 使用继承将2D向量、3D向量和其他对象视为向量的特殊情况
- en: If you haven’t done object-oriented programming or you haven’t seen it done
    in Python, don’t worry. I stick to simple use cases in this chapter and will help
    you pick it up as we go. In case you want to learn more about classes and inheritance
    in Python before getting started, I’ve covered them in appendix B.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有做过面向对象编程，或者你没有在 Python 中见过它，不要担心。我在本章中坚持简单的用例，并且会在我们前进的过程中帮助你掌握它。如果你想在开始之前更多地了解
    Python 中的类和继承，我在附录 B 中进行了介绍。
- en: 6.1.1 Creating a class for 2D coordinate vectors
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 为二维坐标向量创建一个类
- en: 'In code, our 2D and 3D vectors have been *coordinate* vectors, meaning that
    they were defined as tuples of numbers, which are their coordinates. (We also
    saw that vector arithmetic can be defined geometrically in terms of arrows, but
    we can’t translate that approach directly into Python code.) For 2D coordinate
    vectors, the data is the ordered pair of the *x* − and *y*-coordinates. A tuple
    is a great way to store this data, but we can equivalently use a class. We’ll
    call the class representing 2D coordinate vectors `Vec2` :'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们的二维和三维向量是 *坐标* 向量，这意味着它们被定义为数字的元组，即它们的坐标。（我们也看到向量算术可以基于箭头在几何上定义，但我们不能直接将这种方法转换为
    Python 代码。）对于二维坐标向量，数据是 *x* 和 *y* 坐标的有序对。元组是存储这种数据的好方法，但我们可以等效地使用一个类。我们将代表二维坐标向量的类称为
    `Vec2`：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can initialize a vector like `v = Vec2(1.6,3.8)` and retrieve its coordinates
    as `v.x` and `v.y`. Next, we can give this class the methods required to do 2D
    vector arithmetic, specifically addition and scalar multiplication. The addition
    function, `add`, takes a second vector as an argument and returns a new `Vec2`
    object whose coordinates are the sum of the *x* − and *y*-coordinates, respectively:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以初始化一个向量，例如 `v = Vec2(1.6,3.8)`，并检索其坐标为 `v.x` 和 `v.y`。接下来，我们可以给这个类添加进行二维向量算术运算所需的方法，特别是加法和标量乘法。加法函数
    `add` 接收一个第二个向量作为参数，并返回一个新的 `Vec2` 对象，其坐标分别是 *x* 和 *y* 坐标的和：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ When adding to an existing class, I sometimes use ... as a placeholder for
    existing code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当向现有类添加内容时，我有时会使用 ... 作为现有代码的占位符。
- en: 'Doing vector addition with `Vec2` could look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Vec2` 进行向量加法可能看起来像这样：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Creates a new Vec2 called *v* with an x-coordinate 3 and y-coordinate 4
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的名为 *v* 的 Vec2，其 x 坐标为 3，y 坐标为 4
- en: ❷ Adds a second Vec2 to *v* to produce a new Vec2 instance called w. This operation
    returns (3,4) + (−2,6) = (1,10).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将第二个 Vec2 添加到 *v* 中，以产生一个新的名为 w 的 Vec2 实例。这个操作返回 (3,4) + (−2,6) = (1,10)。
- en: ❸ Prints the x-coordinate of w. The result is 1.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打印 w 的 x 坐标。结果是 1。
- en: 'Like our original implementation of vector addition, we do not perform the
    addition “in-place.” That is, the two input vectors are not modified; a new `Vec2`
    object is created to store the sum. We can implement scalar multiplication in
    a similar way, taking a scalar as input and returning a new, scaled vector as
    output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们原始的向量加法实现一样，我们不执行“就地”加法。也就是说，两个输入向量不会被修改；创建一个新的 `Vec2` 对象来存储和。我们可以以类似的方式实现标量乘法，接收一个标量作为输入，并返回一个新的、缩放后的向量作为输出：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Vec(1,1).scale(50)` returns a new vector with the *x* -and *y*-coordinates
    both equal to 50\. There’s one more critical detail we need to take care of: currently
    the output of a comparison like `Vec2(3,4) == Vec2(3,4)` is `False`. This is problematic
    because these instances represent the same vector. By default, Python compares
    instances by their references (asking whether they are located in the same place
    in memory) rather than by their values. We can fix this by overriding the equality
    method, which causes Python to treat the `==` operator differently for objects
    of the `Vec2` class. (If you haven’t seen this before, appendix B explains it
    in more depth.)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vec(1,1).scale(50)` 返回一个新的向量，其 *x* 和 *y* 坐标都等于 50。还有一个关键细节我们需要注意：目前比较操作 `Vec2(3,4)
    == Vec2(3,4)` 的结果是 `False`。这是有问题的，因为这些实例代表的是同一个向量。默认情况下，Python 通过引用（询问它们是否位于内存中的同一位置）来比较实例，而不是通过它们的值。我们可以通过重写相等方法来修复这个问题，这将导致
    Python 对 `Vec2` 类的对象使用 `==` 操作符的方式不同。（如果你之前没有见过，附录 B 会更深入地解释。）'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We want two 2D coordinate vectors to be equal if their *x* − and *y*-coordinates
    agree, and this new definition of equality captures that. With this implemented,
    you’ll find that `Vec2(3,4) == Vec2(3,4)`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望两个二维坐标向量相等，如果它们的 *x* 和 *y* 坐标相同，这个新的相等定义正是如此。实现后，你会发现 `Vec2(3,4) == Vec2(3,4)`。
- en: Our `Vec2` class now has the fundamental vector operations of addition and scalar
    multiplication, as well as an equality test that makes sense. We can now turn
    our attention to some syntactic sugar.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Vec2`类现在具有基本的向量运算，如加法和标量乘法，以及一个有意义的相等性测试。现在我们可以将注意力转向一些语法糖。
- en: 6.1.2 Improving the Vec2 class
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 改进Vec2类
- en: 'As we changed the behavior of the `==` operator, we can also customize the
    Python operators `+` and `*` to mean vector addition and scalar multiplication,
    respectively. This is called *operator overloading*, and it is covered in appendix
    B:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们改变了`==`运算符的行为，我们还可以自定义Python运算符`+`和`*`，分别表示向量加法和标量乘法。这被称为*运算符重载*，它在本附录B中有详细说明：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The __mul__ and __rmul__ methods define both orders of multiplication, so
    we can multiply vectors by scalars on the left or the right. Mathematically, we
    consider both orders to mean the same thing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `__mul__`和`__rmul__`方法定义了乘法的两种顺序，因此我们可以从左或右将向量与标量相乘。从数学上讲，我们考虑这两种顺序意味着相同的事情。
- en: 'We can now write a linear combination concisely. For instance, `3.0 * Vec2(1,0)
    + 4.0 * Vec2(0,1)` gives us a new `Vec2` object with *x*-coordinate 3.0 and *y*-coordinate
    4.0\. It’s hard to read this in an interactive session though, because Python
    doesn’t print `Vec2` nicely:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以简洁地写出线性组合。例如，`3.0 * Vec2(1,0) + 4.0 * Vec2(0,1)`给我们一个新的`Vec2`对象，其*x*坐标为3.0，*y*坐标为4.0。然而，在交互式会话中阅读它很困难，因为Python没有很好地打印`Vec2`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Python gives us the memory address of the resulting `Vec2` instance, but we
    already observed that’s not what’s important to us. Fortunately, we can change
    the string representation of `Vec2` objects by overriding the `__repr__` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了结果`Vec2`实例的内存地址，但我们已经观察到这并不是我们关心的。幸运的是，我们可以通过重写`__repr__`方法来改变`Vec2`对象的字符串表示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This string representation shows the coordinates that are the most important
    data for a `Vec2` object. The results of `Vec2` arithmetic are much clearer now:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字符串表示法显示了对于`Vec2`对象来说最重要的坐标数据。现在`Vec2`算术的结果更加清晰：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’re doing the same math here as we did with our original tuple vectors but,
    in my opinion, this is a lot nicer. Building a class required some boilerplate,
    like the custom equality we wanted, but it also enabled operator overloading for
    vector arithmetic. The custom string representation also makes it clear that we’re
    not just working with *any* tuples, but rather 2D vectors that we intend to use
    in a certain way. Now, we can implement 3D vectors represented by their own special
    class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的数学运算与我们在原始元组向量上所做的相同，但在我看来，这要优雅得多。构建一个类需要一些样板代码，比如我们想要的定制相等性，但它也使得向量的算术运算可以进行运算符重载。定制的字符串表示法也清楚地表明，我们不仅仅是在处理任何元组，而是在以某种特定方式使用2D向量。现在，我们可以实现由自己的特殊类表示的3D向量。
- en: 6.1.3 Repeating the process with 3D vectors
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 使用3D向量重复此过程
- en: I’ll call the 3D vector class `Vec3`, and it looks a lot like the 2D `Vec2`
    class except that its defining data will be three coordinates instead of two.
    In each method that explicitly references the coordinates, we need to make sure
    to properly use the *x*, *y*, and *z* values for `Vec3`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我将3D向量类称为`Vec3`，它看起来与2D的`Vec2`类非常相似，除了它的定义数据将是三个坐标而不是两个。在显式引用坐标的每个方法中，我们需要确保正确使用`Vec3`的*x*、*y*和*z*值。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now write 3D vector math in Python using the built-in arithmetic operators:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Python的内置算术运算符编写3D向量数学：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `Vec3` class, much like the `Vec2` class, puts us in a good place to think
    about generalization. There are a few different directions we can go, and like
    many software design choices, the decision is subjective. We could, for example,
    focus on simplifying the arithmetic. Instead of implementing `add` differently
    for `Vec2` and `Vec3`, they can both use the `add` function we built in chapter
    3, which already handles coordinate vectors of any size. We could also store coordinates
    internally as a tuple or list, letting the constructor accept any number of coordinates
    and create a 2D, 3D, or other coordinate vector. I’ll leave these possibilities
    as exercises for you, however, and take us in a different direction.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Vec3`类，就像`Vec2`类一样，使我们处于一个很好的位置来考虑泛化。我们可以走几个不同的方向，就像许多软件设计选择一样，这个决定是主观的。例如，我们可以专注于简化算术。我们不需要为`Vec2`和`Vec3`实现不同的`add`函数，它们都可以使用我们在第3章中构建的`add`函数，该函数已经可以处理任何大小的坐标向量。我们还可以将坐标内部存储为元组或列表，让构造函数接受任意数量的坐标并创建2D、3D或其他坐标向量。然而，我将这些可能性留给你作为练习，并带我们走向不同的方向。
- en: 'The generalization I want to focus on is based on how we *use* the vectors,
    not on how they work. This gets us to a mental model that both organizes the code
    well and aligns with the mathematical definition of a vector. For instance, we
    can write a generic `average` function that can be used on any kind of vector:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要关注的一般化是基于我们如何使用向量，而不是它们是如何工作的。这使我们达到一个既能很好地组织代码又与向量的数学定义相一致的心理模型。例如，我们可以编写一个通用的
    `average` 函数，它可以用于任何类型的向量：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can insert either 3D vectors or 2D vectors; for instance, `average(Vec2(9.0,
    1.0), Vec2(8.0,6.0))` and `average(Vec3(1,2,3), Vec3(4,5,6))` both give us correct
    and meaningful results. As a spoiler, we will soon be able to average pictures
    together as well. Once we’ve implemented a suitable class for images, we’ll be
    able to write `average(img1, img2)` and get a new image back.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以插入3D向量或2D向量；例如，`average(Vec2(9.0, 1.0), Vec2(8.0,6.0))` 和 `average(Vec3(1,2,3),
    Vec3(4,5,6))` 都会给出正确且有意义的结果。作为预告，我们很快就能将图片一起平均。一旦我们实现了适合图像的类，我们就能编写 `average(img1,
    img2)` 并得到一个新的图像。
- en: This is where we see the beauty and the economy that comes with generalization.
    We can write a single, generic function like `average` and use it for a wide variety
    of types of inputs. The only constraint on the input is that it needs to support
    multiplication by scalars and addition with one another. The implementation of
    arithmetic varies between `Vec2` objects, `Vec3` objects, images, or other kinds
    of data, but there’s always an important overlap in *what* arithmetic we can do
    with them. When we separate the *what* from the *how*, we open the door for code
    reuse and far-reaching mathematical statements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们看到一般化带来的美和经济效益的地方。我们可以编写一个单一的通用函数，如 `average`，并用于广泛的输入类型。对输入的唯一约束是它需要支持与标量相乘和相互相加。算术的实现因
    `Vec2` 对象、`Vec3` 对象、图像或其他类型的数据而异，但它们之间始终存在一个重要的重叠，即我们可以用它们做什么算术。当我们把“做什么”与“怎么做”分开时，我们为代码重用和广泛的数学陈述打开了大门。
- en: How can we best describe *what* we can do with vectors separately from the details
    of *how* we carry them out? We can capture this in Python using an abstract base
    class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何最好地描述我们可以用向量做什么，而不是我们如何执行这些操作的细节？我们可以使用Python中的抽象基类来捕捉这一点。
- en: 6.1.4 Building a vector base class
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 构建向量基类
- en: 'The basic things we can do with `Vec2` or `Vec3` include constructing a new
    instance, adding with other vectors, multiplying by a scalar, testing equality
    with another vector, and representing an instance as a string. Of these, only
    addition and scalar multiplication are distinctive vector operations. Any new
    Python class automatically includes the rest. This prompts a definition of a `Vector`
    base class:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `Vec2` 或 `Vec3` 做的基本事情包括构造一个新的实例、与其他向量相加、乘以一个标量、测试与另一个向量的相等性，以及将实例表示为字符串。在这些操作中，只有加法和标量乘法是独特的向量操作。任何新的Python类都会自动包含其余的操作。这促使我们定义一个
    `Vector` 基类：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `abc` module contains helper classes, functions, and method decorators
    that help define an *abstract base class*, a class that is not intended to be
    instantiated. Instead, it’s designed to be used as a template for classes that
    inherit from it. The `@abstractmethod` decorator means that a method is not implemented
    in the base class and needs to be implemented for any child class. For instance,
    if you try to instantiate a vector with code like `v = Vector()`, you get the
    following `TypeError` :'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc` 模块包含辅助类、函数和方法装饰器，这些可以帮助定义一个抽象基类，一个不打算实例化的类。相反，它被设计成用作继承自它的类的模板。`@abstractmethod`
    装饰器意味着基类中没有实现该方法，并且任何子类都需要实现它。例如，如果你尝试使用如下代码实例化一个向量 `v = Vector()`，你会得到以下 `TypeError`：'
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This makes sense; there is no such thing as a vector that is “just a vector.”
    It needs to have some concrete manifestation such as a list of coordinates, an
    arrow in the plane, or something else. But this is still a useful base class because
    it forces any child class to include requisite methods. It is also useful to have
    this base class because we can equip it with all the methods that depend only
    on addition and scalar multiplication, like our operator overloads:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意义的；不存在“仅仅是一个向量”的向量。它需要有一些具体的体现，比如坐标列表、平面上的箭头或其他东西。但这个基类仍然很有用，因为它迫使任何子类都包含必需的方法。此外，拥有这个基类也很有用，因为我们可以在其中装备所有只依赖于加法和标量乘法的依赖方法，就像我们的运算符重载一样：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In contrast to the abstract methods `scale` and `add`, these implementations
    are automatically available to any child class. We can simplify `Vec2` and `Vec3`
    to inherit from `Vector`. Here’s a new implementation for `Vec2` :'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与抽象方法`scale`和`add`相比，这些实现自动适用于任何子类。我们可以简化`Vec2`和`Vec3`，使它们继承自`Vector`。以下是`Vec2`的新实现：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This has indeed saved us from repeating ourselves! The methods that were identical
    between `Vec2` and `Vec3` now live in the `Vector` class. All remaining methods
    on `Vec2` are specific to 2D vectors; they need to be modified to work for `Vec3`(as
    you will see in the exercises) or for vectors with any other number of coordinates.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实让我们免于重复自己！在`Vec2`和`Vec3`之间相同的那些方法现在都生活在`Vector`类中。`Vec2`上剩余的所有方法都是针对二维向量的；它们需要修改才能为`Vec3`（你将在练习中看到）或任何其他坐标数的向量工作。
- en: 'The `Vector` base class is a good representation of what we can do with vectors.
    If we can add any useful methods to it, chances are they will be useful for *any*
    kind of vector. For instance, we can add two methods to `Vector` :'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector`基类是向量的一个很好的表示。如果我们可以向它添加任何有用的方法，那么它们很可能会对 *任何* 类型的向量都很有用。例如，我们可以向`Vector`添加两个方法：'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And without any modification of `Vec2`, we can automatically subtract them:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何修改的情况下，我们可以自动从`Vec2`中减去它们：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This abstract class makes it easier to implement general vector operations,
    and it also agrees with the mathematical definition of a vector. Let’s switch
    languages from Python to English and see how the abstraction carries over from
    code to become a real mathematical definition.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象类使得实现一般的向量运算变得更容易，并且它与向量的数学定义一致。让我们从Python语言切换到英语，看看这种抽象是如何从代码转化为真正的数学定义的。
- en: 6.1.5 Defining vector spaces
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.5 定义向量空间
- en: In math, a vector is defined by what it does rather than what it is, much like
    how we defined the abstract `Vector` class. Here’s a first (incomplete) definition
    of a vector.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，向量是通过它的作用来定义的，而不是通过它的本质，这与我们定义的抽象`Vector`类非常相似。这里是一个向量的第一个（不完整）定义。
- en: DEFINITION A vector is an object equipped with a *suitable* way to add it to
    other vectors and multiply it by scalars.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个向量是一个具有将自身添加到其他向量以及乘以标量的合适方式的对象。
- en: Our `Vec2` or `Vec3` objects, or any other objects inheriting from the `Vector`
    class can be added to each other and multiplied by scalars. This definition is
    incomplete because I haven’t said what “suitable” means, and that ends up being
    the most important part of the definition!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Vec2`或`Vec3`对象，或任何从`Vector`类继承的对象，可以相互相加，并且可以与标量相乘。这个定义是不完整的，因为我没有说“合适”是什么意思，而这最终是定义中最重要的一部分！
- en: 'There are a few important rules outlawing weird behaviors, many of which you
    might have already assumed. It’s not necessary to memorize all these rules. If
    you ever find yourself testing whether a new kind of object can be thought of
    as a vector, you can refer back to these rules. The first set of rules says that
    addition should be well-behaved. Specifically:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的规则禁止奇怪的行为，其中许多你可能已经假设了。没有必要记住所有这些规则。如果你发现自己正在测试一种新的对象是否可以被视为向量，你可以参考这些规则。第一组规则说加法应该表现得很好。具体来说：
- en: 'Adding vectors in any order shouldn’t matter: ***v*** + ***w*** = ***w*** +
    ***v*** for any vectors ***v*** and ***w***.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以任何顺序添加向量不应该有关系：对于任何向量 ***v*** 和 ***w***，***v*** + ***w*** = ***w*** + ***v***。
- en: 'Adding vectors in any grouping shouldn’t matter: ***u*** + (***v*** + ***w***)
    should be the same as (***u*** + ***v***) + ***w***, meaning that a statement
    like ***u*** + ***v*** + ***w*** should be unambiguous.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何分组中添加向量不应该有关系：***u*** + (***v*** + ***w***) 应该等于 (***u*** + ***v***) + ***w***，这意味着像
    ***u*** + ***v*** + ***w*** 这样的陈述应该是无歧义的。
- en: A good counterexample is adding strings by concatenation. In Python, you can
    do the sum `"hot" + "dog"`, but this doesn’t support the case that strings can
    be vectors because the sums `"hot" + "dog"` and `"dog" + "hot"` are not equal,
    violating rule 1.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的反例是通过连接字符串。在Python中，你可以做 `sum `"hot" + "dog"`，但这不支持字符串可以作为向量的情况，因为 `"hot"
    + "dog"` 和 `"dog" + "hot"` 的和不相等，违反了规则1。
- en: 'Scalar multiplication also needs to be well-behaved and compatible with addition.
    For instance, a whole number scalar multiple should be equal to a repeated addition
    (like 3***v*** = ***v*** + ***v*** + ***v***). Here are the specific rules:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 标量乘法也需要表现得很好，并且与加法兼容。例如，一个整数标量乘数应该等于重复加法（如 3***v*** = ***v*** + ***v*** + ***v***）。以下是具体的规则：
- en: Multiplying vectors by several scalars should be the same as multiplying by
    all the scalars at once. If *a* and *b* are scalars and ***v*** is a vector, then
    *a* · (*b* · ***v***) should be the same as (*a* · *b*) · ***v***.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量乘以多个标量应该与一次乘以所有标量相同。如果 *a* 和 *b* 是标量，而 ***v*** 是一个向量，那么 *a* · (*b* · ***v***)
    应该与 (*a* · *b*) · ***v*** 相同。
- en: 'Multiplying a vector by 1 should leave it unchanged: 1 · ***v*** = ***v***.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量乘以 1 应该不会改变它：1 · ***v*** = ***v***。
- en: 'Addition of scalars should be compatible with scalar multiplication: *a* ·
    ***v*** + *b* · ***v*** should be the same as (*a* + *b*) · ***v***.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标量的加法应该与标量乘法兼容：*a* · ***v*** + *b* · ***v*** 应该与 (*a* + *b*) · ***v*** 相同。
- en: 'Addition of vectors should also be compatible with scalar multiplication: *a*
    · (***v*** + ***w***) should be the same as *a* · ***v*** + *a* · ***w***.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向量的加法也应该与标量乘法兼容：*a* · (***v*** + ***w***) 应该与 *a* · ***v*** + *a* · ***w***
    相同。
- en: None of these rules should be too surprising. For instance, 3 · ***v*** + 5
    · ***v*** could be translated to English as “3 of ***v*** added together plus
    5 of ***v*** added together.” Of course, this is the same as 8 of ***v*** added
    together, or 8 · ***v***, agreeing with rule 5.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则中没有任何一条应该令人惊讶。例如，3 · ***v*** + 5 · ***v*** 可以翻译成英语为“3 个 ***v*** 相加再加上 5
    个 ***v*** 相加。”当然，这等同于 8 个 ***v*** 相加，或者 8 · ***v***，与规则 5 一致。
- en: The takeaway from these rules is that not all addition and multiplication operations
    are created equal. We need to verify each of the rules to ensure that addition
    and multiplication behave as expected. If so, the objects in question can rightly
    be called vectors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则得出的结论是，并非所有的加法和乘法运算都是平等的。我们需要验证每一条规则，以确保加法和乘法的行为符合预期。如果是这样，那么所讨论的对象就可以正确地被称为向量。
- en: 'A *vector space* is a collection of compatible vectors. Here’s the definition:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量空间** 是一组兼容的向量集合。以下是定义：'
- en: DEFINITION A vector space is a collection of objects called vectors, equipped
    with suitable vector addition and scalar multiplication operations (obeying the
    rules above), such that every linear combination of vectors in the collection
    produces a vector that is also in the collection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 向量空间是一组称为向量的对象集合，配备了适当的向量加法和标量乘法运算（遵守上述规则），使得该集合中向量的每个线性组合都产生一个也在集合中的向量。'
- en: A collection like `[Vec2(1,0),` `Vec2(5,−3),` `Vec2(1.1,0.8)]` is a group of
    vec-tors that can be suitably added and multiplied, but it is not a vector space.
    For instance, `1 * Vec2(1,0) + 1 * Vec2(5,−3)` is a linear combination whose result
    is `Vec2(6,−3)`, which is not in the collection. One example of a vector space
    is the infinite collection of all possible 2D vectors. In fact, most vector spaces
    you meet are infinite sets; there are infinitely many linear combinations using
    infinitely many scalars after all!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `[Vec2(1,0), Vec2(5,−3), Vec2(1.1,0.8)]` 的集合是一组可以适当相加和乘以的向量，但它不是一个向量空间。例如，`1
    * Vec2(1,0) + 1 * Vec2(5,−3)` 是一个线性组合，其结果是 `Vec2(6,−3)`，它不在集合中。向量空间的一个例子是所有可能的
    2D 向量的无限集合。事实上，你遇到的绝大多数向量空间都是无限集合；毕竟，使用无限多个标量可以有无限多个线性组合！
- en: 'There are two implications of the fact that vector spaces need to contain all
    their scalar multiples, and these implications are important enough to mention
    on their own. First, no matter what vector ***v*** you pick in a vector space,
    0 · ***v*** gives you the same result, which is called the *zero vector* and denoted
    as **0**(bold, to distinguish it from the number 0). Adding the zero vector to
    any vector leaves that vector unchanged: **0** + ***v*** = ***v*** + **0** = ***v***.
    The second implication is that every vector ***v*** has an opposite vector, −1
    · ***v*** *,* written as -***v***. Due to rule #5, ***v*** + -***v*** = (1 + −1)
    · ***v*** = 0 · ***v*** = **0**. For every vector, there is another vector in
    the vector space that “cancels it out” by addition. As an exercise, you can improve
    the `Vector` class by adding a zero vector and a negation function as required
    members.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '向量空间需要包含所有它们的标量倍数的事实有两个含义，并且这些含义足够重要，可以单独提及。首先，无论你在向量空间中选取什么向量 ***v***，0 ·
    ***v*** 都会得到相同的结果，这个结果被称为 *零向量*，表示为 **0**（粗体，以区别于数字 0）。将零向量加到任何向量上都不会改变该向量：**0**
    + ***v*** = ***v*** + **0** = ***v***。第二个含义是每个向量 ***v*** 都有一个相反向量，表示为 -1 · ***v***，写作
    -***v***。由于规则 #5，***v*** + -***v*** = (1 + −1) · ***v*** = 0 · ***v*** = **0**。对于每个向量，向量空间中都有一个向量可以通过加法“抵消”它。作为一个练习，你可以通过添加零向量和否定函数作为必需的成员来改进
    `Vector` 类。'
- en: A class like `Vec2` or `Vec3` is not a collection per se, but it does describe
    a collection of values. In this way, we can think of the classes `Vec2` and `Vec3`
    as representing two different vector spaces, and their instances represent vectors.
    We’ll see a lot more examples of vector spaces with classes that represent them
    in the next section, but first, let’s look at how to validate that they satisfy
    the specific rules we’ve covered.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `Vec2` 或 `Vec3` 的类本身不是集合，但它确实描述了一组值。这样，我们可以将 `Vec2` 和 `Vec3` 类视为代表两个不同的向量空间，它们的实例代表向量。在下一节中，我们将看到更多由表示它们的类实现的向量空间示例，但首先，让我们看看如何验证它们是否满足我们已讨论的特定规则。
- en: 6.1.6 Unit testing vector space classes
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.6 单元测试向量空间类
- en: It was helpful to use an abstract `Vector` base class to think about what a
    vector should be able to do, rather than how it’s done. But even giving the base
    class an abstract `add` method doesn’t guarantee every inheriting class will implement
    a suitable addition operation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象的 `Vector` 基类来思考向量应该能够做什么，而不是如何做，这很有帮助。但即使给基类提供一个抽象的 `add` 方法，也不能保证每个继承类都会实现合适加法操作。
- en: 'In math, the usual way we guarantee suitability is by *writing a proof*. In
    code, and especially in a dynamic language like Python, the best we can do is
    to write unit tests. For instance, we can check rule #6 from the previous section
    by creating two vectors and a scalar and making sure the equality holds:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '在数学中，我们通常通过 *写出证明* 来保证适宜性。在代码中，尤其是在像 Python 这样的动态语言中，我们能做的最好的事情就是编写单元测试。例如，我们可以通过创建两个向量和标量，并确保它们相等来检查上一节中的规则
    #6：'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is often how unit tests are written, but it’s a pretty weak test because
    we’re only trying one example. We can make it stronger by plugging in random numbers
    and ensuring that it works. Here I use the `random.uniform` function to generate
    evenly distributed floating-point numbers between −10 and 10:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是编写单元测试的方式，但这是一个相当弱的测试，因为我们只尝试了一个例子。我们可以通过插入随机数字并确保它工作来使其更强。在这里，我使用 `random.uniform`
    函数生成介于 -10 和 10 之间的均匀分布的浮点数：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Unless you’re lucky, this test will fail with an `AssertionError`. Here are
    the offending values of *a*, *u*, and *v* that caused the test to fail for me:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你很幸运，否则这个测试将以 `AssertionError` 失败。以下是我测试失败时 *a*、*u* 和 *v* 的值：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And the expressions from the left and right of the equals sign in the `assert`
    call from the previous code have these values:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 并且上一段代码中 `assert` 调用左边和右边的等号表达式具有这些值：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These are two different vectors, but only because their components differ by
    a few quadrillionths (very, very small numbers). This doesn’t mean that the math
    is wrong, just that floating-point arithmetic is approximate rather than exact.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个向量是不同的，但仅仅因为它们的分量相差几个十亿分之一（非常、非常小的数字）。这并不意味着数学是错误的，只是说明浮点运算是大致而非精确的。
- en: 'To ignore such small discrepancies, we can use another notion of equality suitable
    for testing. Python’s `math.isclose` function checks that two float values don’t
    differ by a significant amount (by default, by more than one-billionth of the
    larger value). Using that function instead, the test passes 100 times in a row:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了忽略这样的小差异，我们可以使用适合测试的另一种相等性概念。Python 的 `math.isclose` 函数检查两个浮点值之间的差异不是很大（默认情况下，大于较大值的十亿分之一）。使用该函数代替，测试可以连续通过
    100 次：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Tests whether the *x* and y components are close (even if not equal)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查 *x* 和 *y* 分量是否接近（即使不相等）
- en: ❷ Runs the test for 100 different randomly generated scalars and pairs of vectors
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对 100 个不同随机生成的标量和向量对运行测试
- en: ❸ Replaces a strict equality check with the new function
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用新函数替换严格的相等性检查
- en: 'With the floating-point error removed from the equation, we can test all six
    of the vector space properties in this way:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从方程中移除浮点误差后，我们可以以这种方式测试所有六个向量空间属性：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Passes in the equality test function as eq. This keeps the test function agnostic
    as to the particular concrete vector implementation being passed in.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将相等性测试函数作为 eq 传入。这使测试函数对传入的特定具体向量实现保持无偏见。
- en: This test shows that all six rules (properties) hold for 100 different random
    selections of scalars and vectors. That 600 randomized unit tests pass is a good
    indication that our `Vec2` class satisfies the list of properties from the previous
    section. Once you implement the `zero()` property and the negation operator in
    the exercises, you can test a few more properties.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试表明，对于 100 个不同的随机选择的标量和向量，所有六个规则（性质）都成立。600 个随机单元测试通过是一个很好的迹象，表明我们的 `Vec2`
    类满足上一节中列出的性质列表。一旦你在练习中实现了 `zero()` 属性和否定运算符，你就可以测试更多性质。
- en: This setup isn’t completely generic; we had to write special functions to generate
    random `Vec2` instances and to compare them. The important part is that the `test`
    function itself and the expressions within it are completely generic. As long
    as the class we’re testing inherits from `Vector`, it can run expressions like
    `*a* * *v* + *a* * *w*` and `*a* * (v + w)` that we can then test for equality.
    Now, we can go wild exploring all the different objects that can be treated as
    vectors, and we know how to test them as we go.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置并不完全通用；我们不得不编写特殊函数来生成随机的 `Vec2` 实例，以及进行比较。重要的是，`test` 函数本身以及其中的表达式是完全通用的。只要我们测试的类继承自
    `Vector`，它就可以运行像 `*a* * *v* + *a* * *w*` 和 `*a* * (v + w)` 这样的表达式，然后我们可以测试它们的相等性。现在，我们可以尽情探索所有可以作为向量对待的不同对象，并且我们知道如何测试它们。
- en: 6.1.7 Exercises
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.7 练习
- en: '| **Exercise 6.1**: Implement a `Vec3` class inheriting from `Vector`.**Solution**:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.1**: 实现一个从 `Vector` 继承的 `Vec3` 类。**解决方案**：'
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.2-Mini Project**: Implement a `CoordinateVector` class inheriting
    from `Vector` with an abstract property representing the dimension. This should
    save repetitious work when implementing specific coordinate vector classes. Inheriting
    from `CoordinateVector` and setting the dimension to `6` should be all you need
    to do to implement a `Vec6` class.**Solution**: We can use the dimension-independent
    operations `add` and `scale` from chapters 2 and 3\. The only thing not implemented
    in the following class is the dimension, and not knowing how many dimensions we’re
    working with prevents us from instantiating a `CoordinateVector` :'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.2-迷你项目**：实现一个从 `Vector` 继承的 `CoordinateVector` 类，具有表示维度的抽象属性。这应该在实现特定的坐标向量类时节省重复工作。从
    `CoordinateVector` 继承并设置维度为 `6` 应该是你实现 `Vec6` 类所需做的全部工作。**解决方案**：我们可以使用第 2 章和第
    3 章中的维度无关操作 `add` 和 `scale`。在以下类中没有实现的是维度，而不知道我们正在处理多少维度阻止了我们实例化一个 `CoordinateVector`：'
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once we pick a dimension (say 6), we have a concrete class that we can instantiate:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了一个维度（比如说 6），我们就有一个具体的类可以实例化：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The definitions of addition, scalar multiplication, and so on are picked up
    from the `CoordinateVector` base class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 加法、标量乘法等定义是从 `CoordinateVector` 基类中获取的：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.3**: Add a `zero` abstract method to the `Vector` class to return
    the zero vector in a given vector space, as well as an implementation for the
    negation operator. These are useful because we’re required to have a zero vector
    and negations of any vector in a vector space.**Solution**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.3**: 向 `Vector` 类添加一个返回给定向量空间中零向量的 `zero` 抽象方法，以及否定运算符的实现。这些方法很有用，因为我们需要有一个零向量以及向量空间的任何向量的否定。**解决方案**'
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '❶ zero is a class method because there’s only one zero value for any vector
    space.❷ It’s also an abstract property because we haven’t said what zero is yet.❸
    Special method name for overloading negationWe don’t need to implement `__neg__`
    for any child class because its definition is included in the parent class, based
    only on scalar multiplication. We do, however, need to implement `zero` for each
    class:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 零是一个类方法，因为任何向量空间只有一个零值。❷ 它也是一个抽象属性，因为我们还没有定义什么是零。❸ 特殊方法名称用于重载否定运算符。我们不需要为任何子类实现
    `__neg__`，因为它的定义仅基于标量乘法包含在父类中。然而，我们确实需要为每个类实现 `zero`：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.4**: Write unit tests to show that the addition and scalar multiplication
    operations for `Vec3` satisfy the vector space properties.**Solution**: Because
    the test function is general, we only need to supply a new equality function for
    `Vec3` objects and 100 random sets of inputs:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.4**: 编写单元测试以显示 `Vec3` 的加法和标量乘法运算满足向量空间的性质。**解决方案**：因为测试函数是通用的，我们只需要为
    `Vec3` 对象提供一个新的相等性函数和 100 组随机输入：'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.5**: Add unit tests to check that **0** + *v* = *v*, 0 · *v*
    = **0**, and -v + *v* = **0** for any vector ***v***, where again 0 is the number
    zero and **0** is the zero vector.**Solution**: Because the zero vector is different,
    depending on which class we’re testing, we need to pass it in as an argument to
    the function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.5**：添加单元测试以检查对于任何向量***v***，**0** + *v* = *v*，0 · *v* = **0**，和-v +
    *v* = **0**。再次，0是数字零，**0**是零向量。**解决方案**：因为零向量取决于我们正在测试的类，我们需要将其作为参数传递给函数：'
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can test any vector class with a `zero` method implemented (see exercise
    6.3):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用实现了`zero`方法的任何向量类进行测试（参见练习6.3）：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.6**: As equality is implemented for `Vec2` and `Vec3`, it turns
    out that `Vec2(1,2) == Vec3(1,2,3)` returns `True`. Python’s duck typing is too
    forgiving for its own good! Fix this by adding a check that classes must match
    before testing vector equality.**Solution**: It turns out, we need to do the check
    for addition as well!'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.6**：由于`Vec2`和`Vec3`实现了相等性，结果`Vec2(1,2) == Vec3(1,2,3)`返回`True`。Python的鸭子类型对自己过于宽容！通过添加一个检查，确保在测试向量相等性之前类必须匹配来修复这个问题。**解决方案**：实际上，我们还需要对加法进行检查！'
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To be safe, you can add checks like this to other child classes of `Vector`
    as well. |
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，您还可以将此类检查添加到`Vector`的其他子类中。|
- en: '| **Exercise 6.7**: Implement a `__truediv__` function on `Vector` that allows
    you to divide vectors by scalars. You can divide vectors by a non-zero scalar
    by multiplying them by the reciprocal of the scalar (1.0/scalar).**Solution**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.7**：在`Vector`上实现一个`__truediv__`函数，允许您用标量除以向量。您可以通过乘以标量的倒数（1.0/scalar）来除以非零标量。**解决方案**：'
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With this implemented, you can do division like `Vec2(1,2)/2`, getting back
    `Vec2(0.5,1.0)`. |
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了这一点，您就可以进行除法，如`Vec2(1,2)/2`，返回`Vec2(0.5,1.0)`。|
- en: 6.2 Exploring different vector spaces
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 探索不同的向量空间
- en: Now that you know what a vector space is, let’s look at some examples. In each
    case, we take a new kind of object and implement it as a class that inherits from
    `Vector`. At that point, no matter what kind of object it is, we can do addition,
    scalar multiplication, or any other vector operation with it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了向量空间是什么，让我们看看一些例子。在每种情况下，我们取一种新的对象类型，并将其实现为一个从`Vector`继承的类。到那时，无论它是什么类型的对象，我们都可以用它进行加法、标量乘法或其他任何向量运算。
- en: 6.2.1 Enumerating all coordinate vector spaces
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 列举所有坐标向量空间
- en: We’ve spent *a* lot of time on the coordinate vectors `Vec2` and `Vec3` so far,
    so coordinate vectors in 2D and 3D don’t need much more explanation. It is worth
    reviewing, however, that a vector space of coordinate vectors can have *any* number
    of coordinates. `Vec2` vectors have two coordinates, `Vec3` vectors have three,
    and we could just as well have a `Vec15` class with 15 coordinates. We can’t picture
    it geometrically, but `Vec15` objects represent points in a 15D space.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止已经花费了很多时间在坐标向量`Vec2`和`Vec3`上，所以2D和3D中的坐标向量不需要更多的解释。然而，值得回顾的是，坐标向量的向量空间可以具有任何数量的坐标。`Vec2`向量有两个坐标，`Vec3`向量有三个，我们也可以有一个具有15个坐标的`Vec15`类。我们无法在几何上想象它，但`Vec15`对象代表15维空间中的点。
- en: 'One special case worth mentioning is the class we might call `Vec1`, vectors
    with a single coordinate. The implementation looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的一个特殊情况是我们可能称之为`Vec1`的类，它具有单个坐标的向量。其实现如下：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is a lot of boilerplate to wrap a single number, and it doesn’t give us
    any arithmetic we don’t already have. Adding and multiplying `Vec1` scalar objects
    is just addition and multiplication of the underlying numbers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大堆样板代码，只是为了包装一个单个数字，而且它并没有给我们带来任何我们已有的算术。添加和乘以`Vec1`标量对象只是底层数字的加法和乘法：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For this reason, we probably will never need a `Vec1` class. But it is important
    to know that numbers on their own are vectors. The set of all real numbers (including
    integers, fractions, and irrational numbers like *π*) is denoted as ℝ, and it
    is a vector space in its own right. This is a special case where the scalars and
    the vectors are the same kind of objects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能永远不需要`Vec1`类。但重要的是要知道，单独的数字本身就是向量。所有实数的集合（包括整数、分数和像*π*这样的无理数）表示为ℝ，它本身就是一个向量空间。这是一个特殊情况，其中标量和向量是同一种类型的对象。
- en: 'Coordinate vector spaces are denoted ℝ^(*n*), where *n* is the dimension or
    number of coordinates. For instance, the 2D plane is denoted as ℝ² and 3D space
    is denoted as ℝ³. As long as you use real numbers as your scalars, any vector
    space you stumble across is some ℝ^(*n*) in disguise.[1](#pgfId-1120402) This
    is why we need to mention the vector space ℝ, even if it is boring. The other
    vector space we need to mention is the *zero-dimensional* one, ℝ⁰. This is the
    set of vectors with zero coordinates that we can describe as empty tuples or as
    a `Vec0` class inheriting from `Vector` :'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标向量空间表示为 ℝ^(*n*)，其中 *n* 是维度或坐标的数量。例如，二维平面表示为 ℝ²，三维空间表示为 ℝ³。只要你的标量是实数，你遇到的任何向量空间都是某种伪装的
    ℝ^(*n*)。[1](#pgfId-1120402) 这就是为什么我们需要提到向量空间 ℝ，即使它很无聊。我们还需要提到的另一个向量空间是*零维*的，即
    ℝ⁰。这是由零坐标组成的向量集合，我们可以将其描述为空元组或作为从 `Vector` 继承的 `Vec0` 类：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'No coordinates don’t mean that there are no possible vectors; it means there
    is exactly one zero-dimensional vector. This makes zero-dimensional vector math
    stupidly easy; any result vector is always the same:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 没有坐标并不意味着没有可能的向量；这意味着恰好有一个零维向量。这使得零维向量数学非常简单；任何结果向量总是相同的：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is something like a singleton class from an OOP perspective. From a mathematical
    perspective, we know that every vector space has to have a zero vector, so we
    can think of `Vec0()` as being this zero vector.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从面向对象的角度来看，这就像是一个单例类。从数学的角度来看，我们知道每个向量空间都必须有一个零向量，因此我们可以将 `Vec0()` 视为零向量。
- en: That covers it for coordinate vectors of dimensions zero, one, two, three, or
    more. Now, when you see a vector in the wild, you’ll be able to match it up with
    one of these vector spaces.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就涵盖了零维、一维、二维、三维或更多维度的坐标向量。现在，当你看到自然界中的向量时，你将能够将其与这些向量空间之一相匹配。
- en: 6.2.2 Identifying vector spaces in the wild
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 在自然界中识别向量空间
- en: 'Let’s return to an example from chapter 1 and look at a data set of used Toyota
    Priuses. In the source code, you’ll see how to load the data set generously provided
    by my friend Dan Rathbone at CarGraph.com. To make the cars easy to work with,
    I’ve loaded them into a class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到第1章的一个例子，并查看一个二手丰田普锐斯的数据集。在源代码中，你会看到如何加载由我的朋友 Dan Rathbone 在 CarGraph.com
    提供的慷慨数据集。为了使车辆易于处理，我将它们加载到一个类中：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It would be useful to think of `CarForSale` objects as vectors. Then, for example,
    I could average them together as a linear combination to see what the typical
    Prius for sale looks like. To do that, I need to retrofit this class to inherit
    from `Vector`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `CarForSale` 对象视为向量是有用的。例如，我可以将它们作为一个线性组合的平均值来查看典型的销售普锐斯是什么样的。为了做到这一点，我需要将这个类修改为从
    `Vector` 继承。
- en: How can we add two cars? The numeric fields `model_year`, `mileage`, and `price`
    can be added like components of a vector, but the string properties can’t be added
    in a meaningful way. (Remember, you saw that we can’t think of strings as vectors.)
    When we do arithmetic on cars, the result is not a real car for sale but a *virtual*
    car defined by its properties. To represent this, I’ll change all the string properties
    to the string
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将两辆车相加？数值字段 `model_year`、`mileage` 和 `price` 可以像向量的分量一样相加，但字符串属性无法以有意义的方式相加。（记住，你看到我们不能将字符串视为向量。）当我们对车辆进行算术运算时，结果不是一辆真正的销售车辆，而是一个由其属性定义的*虚拟*车辆。为了表示这一点，我将所有的字符串属性更改为字符串
- en: '`“(virtual)”` to remind us of this. Finally, we can’t add datetimes, but we
    can add time spans. In figure 6.3, I use the day I retrieved the data as a reference
    point and add the time spans since the cars were posted for sale. The code for
    the entire process is shown in listing 6.1.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`“(虚拟）”` 以提醒我们这一点。最后，我们无法添加日期时间，但我们可以添加时间跨度。在图6.3中，我使用我获取数据的那天作为参考点，并添加了自车辆发布以来经过的时间跨度。整个过程的代码在列表6.1中显示。'
- en: '![](../Images/CH06_F03_Orland.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F03_Orland.png)'
- en: Figure 6.3 Timeline of cars posted for sale
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3发布销售车辆的时序图
- en: All this applies to scalar multiplication as well. We can multiply the numeric
    properties and the time span since posting by a scalar. The string properties
    are no longer meaningful, however.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些也适用于标量乘法。我们可以将数值属性和自发布以来的时间跨度乘以一个标量。然而，字符串属性不再有意义。
- en: Listing 6.1 Making `CarForSale` behave like a `Vector` by implementing required
    methods
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1通过实现所需方法使 `CarForSale` 表现得像 `Vector`
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ I retrieved the data set from CarGraph.com on 11/30/2018 at noon.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我在2018年11月30日中午从 CarGraph.com 获取了数据集。
- en: ❷ To simplify construction of virtual cars, all of the string parameters are
    optional with a default value “(virtual)”.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为了简化虚拟汽车的构建，所有的字符串参数都是可选的，默认值为“(virtual)”。
- en: ❸ Helper function that adds dates by adding the time spans from the reference
    date
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 辅助函数，通过添加从参考日期的时间跨度来添加日期
- en: ❹ Adds CarForSale objects by adding underlying properties and constructing a
    new object
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过添加底层属性并构建一个新的对象来添加CarForSale对象
- en: ❺ Helper function that scales a datetime by scaling the time span from the reference
    date
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 辅助函数，通过缩放从参考日期的时间跨度来缩放日期时间
- en: 'In the source code, you’ll find the complete implementation of the class as
    well as the code to load a list of sample car data. With the list of cars loaded,
    we can try some vector arithmetic:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，你可以找到类的完整实现以及加载样本汽车数据的代码。加载了汽车列表后，我们可以尝试一些向量运算：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The sum of the first two cars is evidently a Prius from model year 4012 (maybe
    it can fly?) with 306,000 miles on it and going for an asking price of $6,100\.
    It was posted for sale at 3:59 AM on the same day I looked at CarGraph.com. This
    unusual car doesn’t look too helpful, but bear with me, averages (as shown in
    the following) look a lot more meaningful:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前两辆车的总和显然是一辆4012年款的普锐斯（也许它能飞？），行驶里程为306,000英里，要价6,100美元。它是在我查看CarGraph.com的同一天早上3:59
    AM发布的。这辆不同寻常的汽车看起来不太有用，但请耐心等待，平均数（如下所示）看起来要更有意义：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can learn real things from this result. The average Prius for sale is about
    6 years old, has about 88,000 miles on it, is selling for about $12,500, and was
    posted at 9:49 AM the morning I accessed the website. (In Part 3, we spend a lot
    of time learning from data sets by treating them as vectors.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这个结果中学习到真实的东西。市场上平均的普锐斯车龄约为6年，行驶里程约为88,000英里，售价约为12,500美元，而我访问网站的那天早上9:49
    AM就已经发布了。（在第三部分，我们将花费大量时间通过将数据集视为向量来学习数据集。）
- en: Ignoring the text data, `CarForSale` behaves like a vector. In fact, it behaves
    like a 4D vector having dimensions of price, model year, mileage, and datetime
    of posting. It’s not quite a coordinate vector because the posting date is not
    a number. Even though the data is not numeric, the class satisfies the vector
    space properties (you verify this with unit tests in the exercises), so its objects
    are vectors and can be manipulated as such. Specifically, they are 4D vectors,
    so it is possible to write a 1-to−1 mapping between `CarForSale` objects and `Vec4`
    objects (also an exercise for you). For our next example, we’ll see some objects
    that look even less like coordinate vectors but still satisfy the defining properties.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略文本数据，`CarForSale`的行为就像一个向量。实际上，它就像一个具有价格、车型年份、里程和发布日期的4D向量。它不是一个坐标向量，因为发布日期不是一个数字。尽管数据不是数字的，但该类满足向量空间属性（你可以在练习中的单元测试中验证这一点），因此其对象是向量，可以像这样操作。具体来说，它们是4D向量，因此可以在`CarForSale`对象和`Vec4`对象之间编写一对一的映射（这也是你的一个练习）。在我们的下一个例子中，我们将看到一些看起来更像坐标向量但仍然满足定义属性的对象。
- en: 6.2.3 Treating functions as vectors
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 将函数视为向量
- en: 'It turns out that mathematical functions can be thought of as vectors. Specifically,
    I’m talking about functions that take in a single real number and return a single
    real number, though there are plenty of other types of mathematical functions.
    The mathematical shorthand to say that a function *f* takes any real number and
    returns a real number is *f*: ℝ: → ℝ. With Python, we’ll think of functions that
    take `float` values in and return `float` values.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '结果表明，数学函数可以被看作是向量。具体来说，我指的是那些接受一个实数并返回一个实数的函数，尽管还有许多其他类型的数学函数。用数学简写来说，函数*f*接受任何实数并返回实数是*f*:
    ℝ: → ℝ。在Python中，我们将考虑接受`float`值并返回`float`值的函数。'
- en: As with 2D or 3D vectors, we can do addition and scalar multiplication of functions
    visually or algebraically. To start, we can write functions algebraically; for
    instance, *f*(*x*) = 0.5 · *x* + 3 or *g*(*x*) = sin(*x*). Alternatively, we can
    visualize these with a graph.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像2D或3D向量一样，我们可以通过直观或代数方法进行函数的加法和标量乘法。首先，我们可以代数地写出函数；例如，*f*(*x*) = 0.5 · *x*
    + 3 或 *g*(*x*) = sin(*x*)。或者，我们可以用图形来可视化这些函数。
- en: 'In the source code, I’ve written a simple `plot` function that draws the graph
    of one or more functions on a specified range of inputs (figure 6.4). For instance,
    the following code plots both of our functions *f*(*x*) and *g*(*x*) on *x* values
    between −10 and 10:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，我编写了一个简单的`plot`函数，该函数可以在指定的输入范围内绘制一个或多个函数的图形（图6.4）。例如，以下代码在-10到10的*x*值之间绘制了我们的两个函数*f*(*x*)和*g*(*x*)：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![](../Images/CH06_F04_Orland.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F04_Orland.png)'
- en: Figure 6.4 Graph of the functions *f*(*x*) = 0.5 · *x* + 3 and *g*(*x*) = sin(*x*)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 函数 *f*(*x*) = 0.5 · *x* + 3 和 *g*(*x*) = sin(*x*) 的图像
- en: Algebraically, we can add functions by adding the expressions that define them.
    This means *f* + *g* is a function defined by (*f* + *g*)(*x*) = *f*(*x*) + *g*(*x*)
    = 0.5 · *x* + 3 + sin(*x*). Graphically, the *y* values of each point are added,
    so it’s something like stacking the two functions together as shown in figure
    6.5.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从代数上讲，我们可以通过相加定义它们的表达式来相加函数。这意味着 *f* + *g* 是一个由 (*f* + *g*)(*x*) = *f*(*x*)
    + *g*(*x*) = 0.5 · *x* + 3 + sin(*x*) 定义的函数。从图形上看，每个点的 *y* 值被相加，所以它就像将两个函数堆叠在一起，如图
    6.5 所示。
- en: '![](../Images/CH06_F05_Orland.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F05_Orland.png)'
- en: Figure 6.5 Visualizing the sum of two functions on a graph
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 在图上可视化两个函数的和
- en: 'To implement this sum, you can write some functional Python code. This code
    takes two functions as inputs and returns a new one, which is their sum:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个和，你可以编写一些功能性的 Python 代码。这段代码接受两个函数作为输入，并返回一个新的函数，即它们的和：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Likewise, we can multiply a function by a scalar by multiplying its expression
    by the scalar. For instance, 3 *g* is defined by (3 *g*)(*x*) = 3 · *g*(*x*) =
    3 · sin(*x*). This has the effect of stretching the graph of the function *g*
    in the *y* direction by a factor of 3 (figure 6.6).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过将函数的表达式乘以标量来乘以一个函数。例如，3 *g* 定义为 (3 *g*)(*x*) = 3 · *g*(*x*) = 3 · sin(*x*)。这会使函数
    *g* 在 *y* 方向上拉伸 3 倍（如图 6.6 所示）。
- en: '![](../Images/CH06_F06_Orland.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F06_Orland.png)'
- en: Figure 6.6 The function (3g) looks like the function g stretched by a factor
    of 3 in the y direction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 函数 (3g) 看起来就像函数 g 在 *y* 方向上拉伸了 3 倍。
- en: It’s possible to nicely wrap Python functions in a class that inherits from
    vector, and I leave it as an exercise for you. After doing so, you can write satisfying
    function arithmetic expressions like 3 · *f* or 2 · *f* − 6 · *g*. You can even
    make the class *callable* or able to accept arguments as if it were a function
    to allow expressions like (*f* + *g*)(6). Unfortunately, unit testing to determine
    if functions satisfy the vector space properties is much harder because it’s difficult
    to generate random functions or to test whether two functions are equal. To really
    know if two functions are equal, you have to know that they return the same output
    for every single possible input. That means a test for every real number or at
    least every `float` value!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 Python 函数封装在一个继承自向量的类中，这留作你的练习。完成之后，你可以编写令人满意的函数算术表达式，如 3 · *f* 或 2 · *f*
    − 6 · *g*。你甚至可以使这个类 *可调用* 或接受参数，就像它是一个函数一样，允许表达式如 (*f* + *g*)(6)。不幸的是，为了确定函数是否满足向量空间属性，单元测试要困难得多，因为很难生成随机函数或测试两个函数是否相等。要真正知道两个函数是否相等，你必须知道它们对每个可能的输入都返回相同的输出。这意味着要对每个实数或至少每个
    `float` 值进行测试！
- en: 'This brings us to another question: what is the *dimension* of the vector space
    of functions? Or, to be concrete, how many real number coordinates are needed
    to uniquely identify a function?'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了另一个问题：函数向量空间的 *维度* 是什么？或者，更具体地说，需要多少个实数坐标才能唯一标识一个函数？
- en: Instead of naming the coordinates of a `Vec3` object *x*, *y*, and *z*, you
    could index them from *i* = 1 to 3\. Likewise, you could index the coordinates
    of a `Vec15` from *i* = 1 to 15\. A function, however, has infinitely many numbers
    that define it; for instance, the values *f*(*x*) for any value of *x*. In other
    words, you can think of the coordinates of *f* as being its values at every point,
    indexed by all real numbers instead of the first few integers. This means that
    the vector space of functions is *infinite dimensional*. This has important implications,
    but it mostly makes the vector space of all functions hard to work with. We’ll
    return to this space later, specifically looking at some subsets that are simpler.
    For now, let’s return to the comfort of finitely many dimensions and look at two
    more examples.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与将 `Vec3` 对象的坐标命名为 *x*、*y* 和 *z* 不同，你可以从 *i* = 1 到 3 对它们进行索引。同样，你也可以从 *i* =
    1 到 15 对 `Vec15` 的坐标进行索引。然而，一个函数有无限多个定义它的数字；例如，任何 *x* 值的 *f*(*x*)。换句话说，你可以将 *f*
    的坐标视为它在每个点的值，通过所有实数而不是前几个整数进行索引。这意味着函数向量空间是 *无限维的*。这有重要的含义，但它主要使得所有函数的向量空间难以处理。我们稍后会回到这个空间，具体来看一些更简单的子集。现在，让我们回到有限维度的舒适区，看看两个更多的例子。
- en: 6.2.4 Treating matrices as vectors
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 将矩阵视为向量
- en: Because an *n* -by- *m* matrix is a list of *n* · *m* numbers, albeit arranged
    in a rectangle, we can treat it as a *n* · *m* -dimensional vector. The only difference
    between the vector space of, say, 5×3 matrices from the vector space of 15D coordinate
    vectors is that the coordinates are presented in a matrix. We still add and scalar
    multiply coordinate by coordinate. Figure 6.7 shows how this addition looks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一个 *n* × *m* 矩阵是一系列 *n* · *m* 个数字，尽管它们排列成一个矩形，但我们仍然可以将其视为一个 *n* · *m* 维向量。例如，5×3
    矩阵的向量空间与 15D 坐标向量的向量空间之间的唯一区别是坐标以矩阵的形式呈现。我们仍然逐个坐标地相加和进行标量乘法。图 6.7 展示了这种加法是如何进行的。
- en: '![](../Images/CH06_F07_Orland.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F07_Orland.png)'
- en: Figure 6.7 Adding two 5×3 matrices by adding their corresponding entries
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 通过相加对应项来加两个 5×3 矩阵
- en: Implementing a class for 5×3 matrices inheriting from `Vector` is more typing
    than simply implementing a `Vec15` class because you need two loops to iterate
    over a matrix. The arithmetic, however, is no more complicated than as that shown
    in this listing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 5×3 矩阵的类继承自 `Vector` 比简单地实现一个 `Vec15` 类需要更多的输入，因为你需要两个循环来遍历矩阵。然而，算术运算并不比本列表中展示的更复杂。
- en: Listing 6.2 A class representing 5×3 matrices thought of as vectors
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 将 5×3 矩阵视为向量的类
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ You need to know the number of rows and columns to be able to construct the
    zero matrix.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你需要知道行数和列数才能构造零矩阵。
- en: ❷ The zero vector for 5×3 matrices is a 5×3 matrix consisting of all zeroes.
    Adding this to any other 5×3 matrix M returns M.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 5×3 矩阵的零向量是一个由所有零组成的 5×3 矩阵。将这个向量加到任何其他 5×3 矩阵 M 上，结果仍然是 M。
- en: You could just as well create a `Matrix2_by_2` class or a `Matrix99_by_17` class
    to represent different vector spaces. In these cases, much of the implementation
    would be the same, but the dimensions would no longer be 15, they would be 2 ·
    2 = 4 or 99 · 17 = 1,683\. As an exercise, you can create a `Matrix` class inheriting
    from `Vector` that includes all the data except for specified numbers of rows
    and columns. Then any `MatrixM_by_N` class could inherit from `Matrix`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你同样可以创建一个 `Matrix2_by_2` 类或一个 `Matrix99_by_17` 类来表示不同的向量空间。在这些情况下，大部分实现都是相同的，但维度将不再是
    15，而是 2 × 2 = 4 或 99 × 17 = 1,683。作为一个练习，你可以创建一个继承自 `Vector` 的 `Matrix` 类，包括所有数据，除了指定的行数和列数。然后任何
    `MatrixM_by_N` 类都可以继承自 `Matrix`。
- en: 'The interesting thing about matrices isn’t that they are numbers arranged in
    grids, but rather that we can think of them as representing linear functions.
    We already saw that lists of numbers and functions are two cases of vector spaces,
    but it turns out that matrices are vectors in both senses. If a matrix *a* has
    *n* rows and *m* columns, it represents a linear function from *m* -dimensional
    space to *n* -dimensional space. (You can write *a* : ℝ^(*m*) → ℝ^(*n*) to say
    this same sentence in mathematical shorthand.)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '矩阵的有趣之处不在于它们是排列成网格的数字，而在于我们可以将它们视为表示线性函数。我们已经看到数字列表和函数是向量空间的两种情况，但结果是矩阵在两种意义上都是向量。如果一个矩阵
    *a* 有 *n* 行和 *m* 列，它表示从 *m* 维空间到 *n* 维空间的线性函数。（你可以用 *a* : ℝ^(*m*) → ℝ^(*n*) 来用数学简写表达同样的句子。）'
- en: Just as we added and scalar-multiplied functions from ℝ → ℝ, so can we add and
    scalar multiply functions from ℝ^(*m*) → ℝ^(*n*). In a mini-project at the end
    of this section, you can try running the vector space unit tests on matrices to
    check they are vectors in both senses. That doesn’t mean grids of numbers aren’t
    useful in their own right; sometimes we don’t care to interpret them as functions.
    For instance, we can use arrays of numbers to represent images.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们添加和标量乘以从 ℝ → ℝ 的函数一样，我们也可以添加和标量乘以从 ℝ^(*m*) → ℝ^(*n*) 的函数。在本节末尾的小型项目中，你可以尝试运行矩阵的向量空间单元测试，以检查它们在两种意义上都是向量。这并不意味着数字网格本身没有用处；有时我们并不关心将它们解释为函数。例如，我们可以使用数字数组来表示图像。
- en: 6.2.5 Manipulating images with vector operations
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.5 使用向量运算操作图像
- en: On a computer, images are displayed as arrays of colored squares called *pixels*.
    A typical image can be a few hundred pixels tall by a few hundred pixels wide.
    In a color image, three numbers are needed to specify the red, green, and blue
    (RGB) content of the color of any given pixel (figure 6.8). In total, a 300×300
    pixel image is specified by 300 · 300 · 3 = 270,000 numbers. When thinking of
    images of this size as vectors, the pixels live in a 270,000-dimensional space!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上，图像以称为 *像素* 的彩色方块的数组形式显示。典型的图像可以有几百像素高和几百像素宽。在彩色图像中，需要三个数字来指定任何给定像素的颜色（RGB）的红色、绿色和蓝色内容（图
    6.8）。总共，一个 300×300 像素的图像由 300 · 300 · 3 = 270,000 个数字指定。当将这种大小的图像视为向量时，像素存在于一个
    270,000 维的空间中！
- en: '![](../Images/CH06_F08_Orland.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F08_Orland.png)'
- en: Figure 6.8 Zooming in on a picture of my dog, Melba, until we can pick out one
    pixel with red, green, and blue content (230, 105, 166, respectively)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 将我的狗梅尔巴的图片放大，直到我们可以挑选出一个包含红色、绿色和蓝色内容（分别为 230、105、166）的像素
- en: Depending on what format you’re reading this, you may or may not see the pink
    color of Melba’s tongue. But because we’ll represent color numerically rather
    than visually in this discussion, everything should still make sense. You can
    also see the pictures in full color in the source code for this book.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你阅读的格式，你可能看不到梅尔巴舌头的粉红色。但因为我们将在这次讨论中以数值而不是视觉方式表示颜色，所以一切应该仍然有意义。你还可以在本书的源代码中查看全彩图片。
- en: Python has a de-facto standard image manipulation library, PIL, which is distributed
    in pip under the package name `pillow`. You won’t need to learn much about the
    library because we immediately encapsulate our use of it inside a new class (listing
    6.3). This class, `ImageVector`, inherits from `Vector`, stores the pixel data
    of a 300×300 image, and supports addition and scalar multiplication.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个事实上的标准图像处理库 PIL，它以 `pillow` 包名在 pip 中分发。你不需要学习很多关于这个库的知识，因为我们立即将我们对它的使用封装在一个新的类（列表
    6.3）中。这个类 `ImageVector` 从 `Vector` 继承，存储 300×300 图像的像素数据，并支持加法和标量乘法。
- en: Listing 6.3 A class representing an image as a vector
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 表示图像为向量的类
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '❶ Handles images of a fixed size: 300×300 pixels, for example'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理固定大小的图像：例如 300×300 像素
- en: ❷ The constructor accepts the name of an image file. We create an Image object
    with PIL, resize it to 300×300, and then extract its list of pixels with the getdata()
    method. Each pixel is a triple consisting of red, green, and blue values.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构造函数接受图像文件的名称。我们使用 PIL 创建一个 Image 对象，将其调整大小为 300×300，然后使用 getdata() 方法提取其像素列表。每个像素是一个由红色、绿色和蓝色值组成的元组。
- en: ❸ The constructor also accepts a list of pixels directly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 构造函数还接受像素列表。
- en: ❹ This method returns the underlying PIL image, reconstructed from the pixels
    stored as an attribute on the class. The values must be converted to integers
    to create a displayable image.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此方法返回由类上存储的像素重建的基本 PIL 图像。值必须转换为整数以创建可显示的图像。
- en: ❺ Performs vector addition for images by adding the respective red, green, and
    blue values for each pixel
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 通过为每个像素的相应红色、绿色和蓝色值执行向量加法来对图像执行向量加法
- en: ❻ Performs scalar multiplication by multiplying every red, green, and blue value
    for every pixel by the given scalar
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 通过将每个像素的红色、绿色和蓝色值乘以给定的标量来执行标量乘法
- en: ❼ The zero image has zero red, green, or blue content at any pixel.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 零图像在任何像素处都没有红色、绿色或蓝色内容。
- en: ❽ Jupyter notebooks can display PIL images inline, as long as we pass the implementation
    of the function _repr_png_ from the underlying image.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ Jupyter 笔记本可以显示 PIL 图像的内联，只要我们传递底层图像的 _repr_png_ 函数的实现。
- en: 'Equipped with this library, we can load images by filename and do vector arithmetic
    with the images. For instance, the average of two pictures can be computed as
    a linear combination as follows with a result shown in figure 6.9:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了这个库，我们可以通过文件名加载图像，并对图像执行向量运算。例如，两个图片的平均值可以按以下方式计算为线性组合，结果如图 6.9 所示：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![](../Images/CH06_F09_Orland.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F09_Orland.png)'
- en: Figure 6.9 The average of two images of Melba as a linear combination
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 梅尔巴两张图像的平均值作为线性组合
- en: While any `ImageVector` is valid, the minimum and maximum color values that
    render as visually different are 0 and 255, respectively. Because of this, the
    negative of any image you import will be black, having gone below the minimum
    brightness at every pixel. Likewise, positive scalar multiples quickly become
    washed out with most pixels exceeding the maximum displayable brightness. Figure
    6.10 shows these characteristics.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何 `ImageVector` 都是有效的，但渲染为视觉上不同的最小和最大颜色值分别是 0 和 255。因此，任何导入的图像的负值将是黑色，因为每个像素的亮度都低于最小亮度。同样，正标量乘数很快就会变得苍白，因为大多数像素都超过了可显示的最大亮度。图
    6.10 展示了这些特性。
- en: '![](../Images/CH06_F10_Orland.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F10_Orland.png)'
- en: Figure 6.10 Negation and scalar multiplication of an image
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 图像的否定和标量乘法
- en: To make visually interesting changes, you need to do operations that land you
    in the right brightness range for all colors. The zero vector (black) and the
    vector with all values equal to 255 (white) are good reference points. For instance,
    subtracting an image from an all white image has the effect of reversing the colors.
    As figure 6.11 shows, for the following white vector
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建视觉上有趣的变化，您需要执行将您带入所有颜色正确亮度范围的运算。零向量（黑色）和所有值都等于 255 的向量（白色）是很好的参考点。例如，从图像中减去一个全白色图像的效果是反转颜色。如图
    6.11 所示，对于以下白色向量
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: subtracting an image yields an eerily recolored picture. (The difference should
    be striking even if you’re looking at the picture in black and white.)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 减去一个图像会产生一个令人毛骨悚然的重新着色的图片。（即使你在黑白图片中查看，差异也应该很显著。）
- en: '![](../Images/CH06_F11_Orland.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F11_Orland.png)'
- en: Figure 6.11 Reversing the color of an image by subtracting it from a plain,
    white image
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 通过从纯白色图像中减去图像来反转图像的颜色
- en: 'Vector arithmetic is clearly a general concept: the defining concepts of addition
    and scalar multiplication apply to numbers, coordinate vectors, functions, matrices,
    images, and many other kinds of objects. It’s striking to see such visual results
    when we apply the same math across unrelated domains. We’ll keep all of these
    examples of vector spaces in mind and continue to explore the generalizations
    we can make across them.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 向量代数显然是一个通用概念：加法和标量乘法的定义概念适用于数字、坐标向量、函数、矩阵、图像以及许多其他类型的对象。当我们将相同的数学应用于无关领域时，看到这样的视觉结果是非常引人注目的。我们将记住所有这些向量空间的例子，并继续探索它们之间可以做出的推广。
- en: 6.2.6 Exercises
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.6 练习
- en: '| **Exercise 6.8**: Run the vector space unit tests with float values for `u`,
    `v`, and `w`, rather than with objects inheriting from the `Vector` class. This
    demonstrates that real numbers are indeed vectors.**Solution**: With vectors as
    random scalars, the number zero as the zero vector, and `math.isclose` as the
    equality test, the 100 random tests pass:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.8**：使用 `u`、`v` 和 `w` 的浮点值而不是从 `Vector` 类继承的对象来运行向量空间单元测试。这表明实数确实是向量。**解决方案**：使用随机标量作为向量、零向量作为零向量，以及
    `math.isclose` 作为相等测试，100 次随机测试通过：'
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.9−Mini Project**: Run the vector space unit tests for `CarForSale`
    to show its objects form a vector space (ignoring their textual attributes).**Solution**:
    Most of the work is generating random data and building an approximate equality
    test that handles datetimes as shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.9-迷你项目**：运行 `CarForSale` 的向量空间单元测试以显示其对象形成一个向量空间（忽略它们的文本属性）。**解决方案**：大部分工作是在生成随机数据并构建一个近似相等测试，如下所示，该测试处理日期和时间：'
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.10**: Implement the class `Function(Vector)` that takes a function
    of one variable as an argument to its constructor and implement a `__call__` method
    so you can treat it as a function. You should be able to run `plot([f,g,f+g,3*g],−10,10)`.**Solution**:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.10**：实现一个名为 `Function(Vector)` 的类，该类将其构造函数的参数为一个单变量函数，并实现一个 `__call__`
    方法，以便您可以将其视为一个函数。您应该能够运行 `plot([f,g,f+g,3*g],−10,10)`。**解决方案**：'
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The result of the last line is shown in this plot:![](../Images/CH06_F11_Orland_UN01.png)Our
    objects `f` and `g` behave like vectors, so we can add and scalar multiply them.
    Because they also behave like functions, we can plot them. |
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后行的结果是显示在这个图中：![](../Images/CH06_F11_Orland_UN01.png)我们的对象 `f` 和 `g` 的行为像向量，因此我们可以将它们相加并标量乘以它们。因为它们也像函数一样，我们可以绘制它们。|
- en: '| **Exercise 6.11-Mini Project**: Testing equality of functions is difficult.
    Do your best to write a function to test whether two functions are equal.**Solution**:
    Because we’re usually interested in well-behaved, continuous functions, it might
    be enough to check that their values are close for a few random input values as
    shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.11-迷你项目**：测试函数的等价性是困难的。尽力编写一个函数来测试两个函数是否相等。**解答**：因为我们通常对行为良好、连续的函数感兴趣，所以检查它们在几个随机输入值上的值是否接近可能就足够了，如下所示：'
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Unfortunately, this can give us misleading results. The following returns `True`,
    even though the functions cannot be equal to zero:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这可能会给我们带来误导性的结果。以下返回`True`，尽管函数不能等于零：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It turns out that computing equality of functions is an *undecidable* problem.
    That is, it has been proved there is no algorithm that can guarantee whether any
    two functions are equal. |
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，计算函数的等价性是一个**不可解**的问题。也就是说，已经证明没有算法可以保证任意两个函数是否相等。|
- en: '| **Exercise 6.12-Mini Project**: Unit test your `Function` class to demonstrate
    that functions satisfy the vector space properties.**Solution**: It’s difficult
    to test function equality, and it’s also difficult to generate random functions.
    Here, I used a `Polynomial` class (that you’ll meet in the next section) to generate
    some random polynomial functions. Using `approx_equal _function` from the previous
    mini-project, we can get the test to pass:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.12-迷你项目**：对`Function`类进行单元测试，以证明函数满足向量空间的属性。**解答**：测试函数等价性很困难，生成随机函数也很困难。在这里，我使用了一个`Polynomial`类（你将在下一节中遇到）来生成一些随机的多项式函数。使用前一个迷你项目中的`approx_equal_function`，我们可以使测试通过：'
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '|'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.13-Mini Project**: Implement a class `Function2(Vector)` that
    stores a function of *two* variables like *f*(*x*, *y*) = *x* + *y*.**Solution**:
    The definition is not much different than the `Function` class, but all functions
    are given two arguments:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.13-迷你项目**：实现一个`Function2(Vector)`类，它存储一个像*f(x, y)* = *x* + *y*这样的两个变量的函数。**解答**：定义与`Function`类没有太大区别，但所有函数都给出了两个参数：'
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For instance, the sum of *f*(*x*, *y*) = *x* + *y* and *g*(*x*, *y*) = *x*
    − *y* +1 should be 2*x* + 1\. We can confirm this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*f(x, y)* = *x* + *y*和*g(x, y)* = *x* − *y* +1的和应该是2*x* + 1。我们可以确认这一点：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.14**: What is the dimension of the vector space of 9×9 matrices?'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.14**：9×9矩阵的向量空间的维度是多少？'
- en: '9'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '9'
- en: '18'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '18'
- en: '27'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '27'
- en: '81'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '81'
- en: '**Solution**: A 9×9 matrix has 81 entries, so there are 81 independent numbers
    (or coordinates) that determine it. It, therefore, is an 81-dimensional vector
    space and answer *d* is correct. |'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**：一个9×9矩阵有81个条目，所以有81个独立的数字（或坐标）来决定它。因此，它是一个81维的向量空间，答案*d*是正确的。|'
- en: '| **Exercise 6.15-Mini Project**: Implement a `Matrix` class inheriting from
    `Vector` with abstract properties representing the number of rows and number of
    columns. You should not be able to instantiate a `Matrix` class, but you could
    make a `Matrix5_by_3` class by inheriting from `Matrix` and explicitly specifying
    the number of rows and columns.**Solution**:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.15-迷你项目**：实现一个从`Vector`继承的`Matrix`类，具有表示行数和列数的抽象属性。你不应该能够实例化一个`Matrix`类，但你可以通过从`Matrix`继承并显式指定行数和列数来创建一个`Matrix5_by_3`类。**解答**：'
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| We can now quickly implement any class representing a vector space of matrices
    of fixed size, for instance, 2×2:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '| 现在我们可以快速实现任何表示固定大小矩阵的向量空间类，例如，2×2：'
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then we can compute with 2×2 matrices as vectors:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像向量一样使用2×2矩阵：
- en: '[PRE59]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '|'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.16**: Unit test the `Matrix5_by_3` class to demonstrate that
    it obeys the defining properties of a vector space.**Solution**:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.16**：对`Matrix5_by_3`类进行单元测试，以证明它遵循向量空间的定义属性。**解答**：'
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '|'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.17-Mini Project**: Write a `LinearMap3d_to_5d` class inheriting
    from `Vector` that uses a 5×3 matrix as its data but implements `__call__` to
    act as a linear map from ℝ³ to ℝ⁵. Show that it agrees with `Matrix5_by_3` in
    its underlying computations and that it independently passes the defining properties
    of a vector space. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **练习6.17-迷你项目**：编写一个从`Vector`继承的`LinearMap3d_to_5d`类，它使用5×3矩阵作为其数据，但实现`__call__`以作为从ℝ³到ℝ⁵的线性映射。证明它与`Matrix5_by_3`在底层计算上是一致的，并且它独立地通过了向量空间的定义属性。|'
- en: '| **Exercise 6.18−Mini Project**: Write a Python function enabling you to multiply
    `Matrix5_by_3` objects by `Vec3` objects in the sense of matrix multiplication.
    Update your overloading of the `*` operator for the vector and matrix classes
    so you can multiply vectors on their left by either scalars or matrices. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.18-迷你项目**：编写一个 Python 函数，使你能够将 `Matrix5_by_3` 对象与 `Vec3` 对象按矩阵乘法的方式进行乘法。更新向量类和矩阵类的
    `*` 操作符的重载，以便你可以将向量左乘以标量或矩阵。|'
- en: '| **Exercise 6.19**: Convince yourself that the zero vector for the `ImageVector`
    class doesn’t visibly alter any image when it is added.**Solution**: For any image
    of your choice, look at the result of `ImageVector ("my_ image.jpg") + ImageVector.zero()`.
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.19**: 证明对于 `ImageVector` 类的零向量，当它被添加时不会明显改变任何图像。**解决方案**：对于你选择的任何图像，查看
    `ImageVector ("my_image.jpg") + ImageVector.zero()` 的结果。|'
- en: '| **Exercise 6.20**: Pick two images and display 10 different weighted averages
    of them. These will be points on a line segment connecting the images in 270,000-dimensional
    space!**Solution**: I ran the following code with *s* = 0.1, 0.2, 0.3, ..., 0.9,
    1.0:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.20**: 选择两张图像，并显示它们的 10 个不同加权平均值。这些将在 270,000 维空间中连接图像的线段上的点！**解决方案**：我运行了以下代码，其中
    *s* = 0.1, 0.2, 0.3, ..., 0.9, 1.0：'
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When you put your images side-by-side, you’ll get something like this:![](../Images/CH06_F11_Orland_UN02.png)Several
    different weighted averages of two images |
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当你并排放置你的图像时，你会得到类似这样的东西！![多个图像的加权平均值](../Images/CH06_F11_Orland_UN02.png)两张图像的多个不同加权平均值
- en: '| **Exercise 6.21**: Adapt the vector space unit tests to images and run them.
    What do your randomized unit tests look like as images?**Solution**: One way to
    generate random images is to put random red, green, and blue values at every pixel,
    for example,'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.21**: 将向量空间单元测试适配到图像并运行它们。你的随机单元测试作为图像看起来是什么样子？**解决方案**：生成随机图像的一种方法是在每个像素处放置随机的红色、绿色和蓝色值，例如，'
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| ![](../Images/CH06_F11_Orland_UN03.png)The result is a fuzzy mess, but that
    doesn’t matter to us. The unit tests compare each pixel. With an approximate equality
    test such as the following, we can run the tests:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '| ![](../Images/CH06_F11_Orland_UN03.png)结果是模糊的一团糟，但这对我们来说无关紧要。单元测试比较每个像素。使用以下近似相等测试，我们可以运行测试：'
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 6.3 Looking for smaller vector spaces
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 寻找更小的向量空间
- en: The vector space of 300×300 color images has a whopping 270,000 dimensions,
    meaning we need to list as many numbers to specify any image of that size. This
    isn’t a problematic amount of data on its own, but when we have larger images,
    a large quantity of images, or thousands of images chained together to make a
    movie, the data can add up.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 300×300 彩色图像的向量空间有 270,000 维，这意味着我们需要列出这么多数字来指定任何这种大小的图像。这本身并不是一个问题的数据量，但当我们有更大的图像、大量的图像，或者将成千上万的图像连接起来制作电影时，数据量就会累积起来。
- en: In this section, we look at how to start with a vector space and find smaller
    ones (having fewer dimensions) that retain most of the interesting data from the
    original space. With images, we can reduce the number of distinct pixels used
    in an image or convert it to black and white. The result may not be beautiful,
    but it can still be recognizable. For instance, the image on the right in figure
    6.12 takes 900 numbers to specify, compared to the 270,000 numbers to specify
    the image on the left.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨如何从一个向量空间开始，找到更小的空间（具有更少的维度），同时保留原始空间中的大部分有趣数据。对于图像，我们可以减少图像中使用的不同像素的数量，或者将其转换为黑白。结果可能不美丽，但仍然可以辨认。例如，图
    6.12 右侧的图像需要 900 个数字来指定，而左侧的图像需要 270,000 个数字来指定。
- en: '![](../Images/CH06_F12_Orland.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH06_F12_Orland.png)'
- en: Figure 6.12 Converting from an image specified by 270,000 numbers (left) to
    another one specified by 900 numbers (right)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 将由 270,000 个数字指定的图像（左侧）转换为由 900 个数字指定的另一个图像（右侧）
- en: Pictures that look like the one on the right live in a 900-dimensional *subspace*
    of a 270,000-dimensional space. That means that they are still 270,000-dimensional
    image vectors, but they can be represented or stored with only 900 coordinates.
    This is a starting point for a study of *compression*. We won’t go too deep into
    the best practices of compression, but we will take a close look at subspaces
    of vector spaces.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像右侧的图片生活在 270,000 维空间的 900 维 *子空间* 中。这意味着它们仍然是 270,000 维的图像向量，但可以用只有 900
    个坐标来表示或存储。这是研究 *压缩* 的起点。我们不会深入探讨压缩的最佳实践，但我们会仔细研究向量空间的子空间。
- en: 6.3.1 Identifying subspaces
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 识别子空间
- en: 'A vector *subspace*, or subspace for short, is just what it sounds like: a
    vector space that exists inside another vector space. One example we’ve looked
    at a few times already is the 2D *x*,*y* plane within 3D space as the plane where
    *z* = 0\. To be specific, the subspace consists of vectors of the form (*x*, *y*,
    0). These vectors have three components, so they are veritable 3D vectors, but
    they form a subset that happens to be constrained to lie on a plane. For that
    reason, we say this is a 2D subspace of ℝ³.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 向量子空间，或简称子空间，正如其名所示：存在于另一个向量空间内部的向量空间。我们已经多次看过的例子是3D空间内的2D *x*, *y*平面，即*z* =
    0的平面。具体来说，这个子空间由形式为(*x*, *y*, 0)的向量组成。这些向量有三个分量，因此它们是真正的3D向量，但它们形成了一个恰好位于平面上的子集。因此，我们说这是ℝ³的2D子空间。
- en: NOTE At the risk of being pedantic, the 2D vector space ℝ², which consists of
    the ordered pairs (*x*, *y*), is not technically a subspace of 3D space ℝ³. That’s
    because vectors of the form (*x*, y) are not 3D vectors. However, it has a one-to-one
    correspondence with the set of vectors (*x*, *y*, 0), and vector arithmetic looks
    the same whether or not the extra zero *z*-coordinate is present. For these reasons,
    I consider it okay to call ℝ² a subspace of ℝ³.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了避免过于繁琐，由有序对(*x*, *y*)组成的2D向量空间ℝ²，在技术上不是3D空间ℝ³的子空间。这是因为形式为(*x*, y)的向量不是3D向量。然而，它与向量(*x*,
    *y*, 0)的集合一一对应，向量代数在是否有额外的零*z*坐标的情况下看起来都一样。因此，我认为称ℝ²为ℝ³的子空间是可以的。
- en: Not every subset of 3D vectors is a subspace. The plane where *z* = 0 is special
    because the vectors (x, y, 0) form a self-contained vector space. There’s no way
    to build a linear combination of vectors in this plane that somehow “escapes”
    it; the third coordinate always remains zero. In math lingo, the precise way to
    say that a subspace is self-contained is to say it is *closed* under linear combinations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 并非3D向量的每个子集都是子空间。*z* = 0的平面是特殊的，因为向量(x, y, 0)形成了一个自包含的向量空间。在这个平面上，无法构建向量的线性组合，使其“逃离”这个平面；第三个坐标始终为零。在数学术语中，精确地说一个子空间是自包含的，可以说它是线性组合下的*封闭*。
- en: To get the feel for what a vector subspace looks like in general, let’s search
    for subsets of vector spaces that are also subspaces (figure 6.13). What subsets
    of vectors in the plane can make a standalone vector space? Can we just draw any
    region in the plane and only take vectors that live within it?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解向量子空间在一般情况下是什么样的，让我们寻找向量空间的子集，这些子集也是子空间（见图6.13）。平面上哪些向量的子集可以构成一个独立的向量空间？我们能否仅仅在平面上画任何区域，然后只取其内部的向量？
- en: '![](../Images/CH06_F13_Orland.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F13_Orland.png)'
- en: Figure 6.13 S is a subset of points (vectors) in the plane ℝ². Is S a subspace
    of ℝ²?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 S是平面ℝ²中点的（向量）子集。S是ℝ²的子空间吗？
- en: 'The answer is no: the subset in figure 6.13 contains some vectors that lie
    on the x-axis and some that live on the y-axis. These can respectively be scaled
    to give us the standard basis vectors ***e***[1] = (1, 0) and ***e***[2] = (0,
    1). From these vectors, we can make linear combinations to get to any point in
    the plane, not only the ones in *S*(figure 6.14).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的：图6.13中的子集包含一些位于x轴上的向量和一些位于y轴上的向量。这些向量分别可以被缩放，给我们标准的基向量***e***[1] = (1,
    0)和***e***[2] = (0, 1)。从这些向量中，我们可以通过线性组合得到平面上的任何点，而不仅仅是*S*（见图6.14）。
- en: '![](../Images/CH06_F14_Orland.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F14_Orland.png)'
- en: Figure 6.14 Linear combinations of two vectors in *S* give us an “escape route”
    from *S*. It cannot be a subspace of the plane.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 *S*中两个向量的线性组合为我们提供了一个“逃离”*S*的途径。它不能是平面的子空间。
- en: Instead of drawing a random subspace, let’s mimic the example of the plane in
    3D. There is no *z*-coordinate, so let’s instead choose the points where *y* =
    0\. This leaves us with the points on the x-axis, having the form (*x*, 0). No
    matter how hard we try, we can’t find a linear combination of vectors of this
    form that have a non-zero *y*-coordinate (figure 6.15).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是画一个随机的子空间，让我们模仿3D空间中平面的例子。没有*z*坐标，所以我们选择*y* = 0的点。这留下了x轴上的点，形式为(*x*, 0)。无论我们如何努力，我们都无法找到这种形式的向量的线性组合，它们具有非零的*y*坐标（见图6.15）。
- en: '![](../Images/CH06_F15_Orland.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F15_Orland.png)'
- en: Figure 6.15 Focusing on the line where y = 0\. This is a vector space, containing
    all linear combinations of its points.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 关注y = 0的直线。这是一个向量空间，包含其所有点的线性组合。
- en: This line, *y* = 0, is a vector subspace of ℝ². As we originally found a 2D
    subspace of 3D, we also have found a 1D subspace of 2D. Instead of a 3D *space*
    or a 2D *plane*, a 1D vector space like this is called a *line*. In fact, we can
    identify this subspace as the real number line ℝ.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这条线，*y* = 0，是 ℝ² 的向量子空间。正如我们最初在三维空间中找到一个二维子空间一样，我们也找到了二维空间中的一个一维子空间。与三维 *空间*
    或二维 *平面* 不同，这样的1维向量空间被称为 *线*。实际上，我们可以将这个子空间识别为实数线 ℝ。
- en: 'The next step could be to set *x* = 0 as well. Once we’ve set both *x* = 0
    and *y* = 0 to zero, there’s only one point remaining: the zero vector. This is
    a vector subspace as well! No matter how you take linear combinations of the zero
    vector, the result is the zero vector. This is a *zero-dimensional subspace* of
    the 1D line, the 2D plane, and the 3D space. Geometrically, a zero-dimensional
    subspace is a point, and that point has to be zero. If it were some other point,
    *v* for instance, it would also contain 0 · *v* = 0 and an infinity of other different
    scalar multiples like 3 · *v* and −42 · *v*. Let’s run with this idea.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步可以是设置 *x* = 0。一旦我们将 *x* = 0 和 *y* = 0 都设置为0，就只剩下一个点：零向量。这同样是一个向量子空间！无论你如何取零向量的线性组合，结果都是零向量。这是1维线、2维平面和3维空间的零维子空间。从几何上看，零维子空间是一个点，而这个点必须是零。如果它是其他点，例如
    *v*，它也会包含 0 · *v* = 0 和无数其他不同的标量倍数，如 3 · *v* 和 −42 · *v*。让我们继续这个想法。
- en: 6.3.2 Starting with a single vector
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 从单个向量开始
- en: A vector subspace containing a non-zero vector ***v*** contains (at least) all
    of the scalar multiples of ***v***. Geometrically, the set of all scalar multiples
    of a non-zero vector ***v*** lie on a line through the origin as shown in figure
    6.16.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 包含非零向量 ***v*** 的向量子空间包含（至少）***v*** 的所有标量倍数。从几何上看，非零向量 ***v*** 的所有标量倍数都位于原点的一条线上，如图6.16所示。
- en: '![](../Images/CH06_F16_Orland.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F16_Orland.png)'
- en: Figure 6.16 Two different vectors with dotted lines, showing where all of their
    scalar multiples will lie.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 两条不同的向量，用虚线表示它们所有标量倍数的位置。
- en: 'Each of these lines through the origin is a vector space. There’s no way to
    escape any line like this by adding or scaling vectors that lie in it. This is
    true of lines through the origin in 3D as well: they are all of the linear combinations
    of a single 3D vector, and they form a vector space. This is the first example
    of a general way of building subspaces: picking a vector and seeing all of the
    linear combinations that must come with it.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过原点的每条线都是一个向量空间。无法通过添加或缩放该空间内的向量来逃离任何这样的线。这在三维空间中通过原点的线也是成立的：它们都是单个三维向量的线性组合，并形成一个向量空间。这是构建子空间的一般方法的第一例：选择一个向量，并查看所有必须与之一起出现的线性组合。
- en: 6.3.3 Spanning a bigger space
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 生成更大的空间
- en: Given a set of one or more vectors, their *span* is defined as the set of all
    linear combinations. The important part of the span is that it’s automatically
    a vector subspace. To rephrase what we just discovered, the span of a single vector
    ***v*** is a line through the origin. We denote a set of objects by including
    them in curly braces, so the set containing only ***v*** is {***v***}, and the
    span of this set could be written span({***v***}).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组一个或多个向量，它们的 *span* 被定义为所有线性组合的集合。span的重要之处在于它自动是一个向量子空间。为了重新表述我们刚才发现的，单个向量
    ***v*** 的span是通过原点的一条线。我们通过在大括号中包含对象来表示一组对象，因此只包含 ***v*** 的集合是 {***v***}，这个集合的span可以写成
    span({***v***})。
- en: As soon as we include another vector ***w***, which is not parallel to ***v***,
    the space gets bigger because we are no longer constrained to a single linear
    direction. The span of the set of two vectors {***v***, ***w***} includes two
    lines, span({***v***}) and span({***w***}), as well as linear combinations including
    both ***v*** and ***w***, which lie on neither line (figure 6.17).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们包含另一个向量 ***w***，它不与 ***v*** 平行，空间就会变大，因为我们不再局限于单一线性方向。由两个向量 {***v***, ***w***}
    生成的空间包括两条线，即 span({***v***}) 和 span({***w***})，以及包含 ***v*** 和 ***w*** 的线性组合，这些组合既不在任何一条线上（见图6.17）。
- en: '![](../Images/CH06_F17_Orland.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F17_Orland.png)'
- en: Figure 6.17 The span of two non-parallel vectors. Each individual vector spans
    a line, but together they span more points, for instance, *v* + *w* lies on neither
    line.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 两条非平行向量的空间。每个向量单独生成一条线，但它们一起生成更多的点，例如，*v* + *w* 不在任何一条线上。
- en: It might not be obvious, but the span of these two vectors is the entire plane.
    This is true of any pair of non-parallel vectors in the plane, but most strikingly
    for the standard basis vectors. Any point (*x*, *y*) can be reached as the linear
    combination *x* · (1, 0) + *y* · (0, 1). The same is true for other pairs of non-parallel
    vectors like ***v*** = (1, 0) and ***w*** = (1, 1), but there’s a bit more arithmetic
    to see it.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能不太明显，但这两个向量的张成空间是整个平面。这在平面上任何一对非平行向量中都是成立的，但对于标准基向量来说尤为显著。任何点(*x*, *y*)都可以表示为线性组合*x*
    · (1, 0) + *y* · (0, 1)。对于其他非平行向量对，如**v** = (1, 0)和**w** = (1, 1)，也是如此，但需要更多的代数运算来证明。
- en: You can get any point like (4, 3) by taking the right linear combination of
    (1, 0) and (1, 1). The only way to get the *y*-coordinate of 3 is to have three
    of the vector (1, 1). That’s (3, 3) instead of (4, 3), so you can correct the
    *x*-coordinate by adding one unit of (1, 0). That gets us a linear combination
    3 · (1, 1) + 1 · (1, 0), which takes us to the point (4, 3) as shown in figure
    6.18.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过(1, 0)和(1, 1)的适当线性组合得到任何点，如(4, 3)。要得到3的*y*坐标，需要三个向量(1, 1)。那就是(3, 3)而不是(4,
    3)，所以可以通过添加一个单位的(1, 0)来纠正*x*坐标。这样我们就得到了线性组合3 · (1, 1) + 1 · (1, 0)，它将我们带到了图6.18中显示的点(4,
    3)。
- en: '![](../Images/CH06_F18_Orland.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F18_Orland.png)'
- en: Figure 6.18 Getting to an arbitrary point (4, 3) by a linear combination of
    (1, 0) and (1, 1)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 通过(1, 0)和(1, 1)的线性组合得到任意点(4, 3)
- en: A single non-zero vector spans a line in 2D or 3D, and it turns out, two non-parallel
    vectors can span either the whole 2D plane or a plane passing through the origin
    in 3D space. A plane spanned by two 3D vectors could look like that shown in figure
    6.19.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 单个非零向量在2D或3D中张成一条线，而且，两个非平行向量可以张成整个2D平面或在3D空间中通过原点的平面。由两个3D向量张成的平面可能看起来像图6.19中所示的那样。
- en: '![](../Images/CH06_F19_Orland.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F19_Orland.png)'
- en: Figure 6.19 A plane spanned by two 3D vectors
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 由两个3D向量张成的平面
- en: It’s slanted, so it doesn’t look like the plane where *z* = 0, and it doesn’t
    contain any of the three standard basis vectors. But it’s still a plane and a
    vector subspace of 3D space. One vector spans a 1D space, and two non-parallel
    vectors span a 2D space. If we add a third non-parallel vector to the mix, do
    the three vectors span a 3D space? Figure 6.20 shows that clearly the answer is
    no.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 它是斜的，所以它看起来不像*z* = 0的平面，它也不包含三个标准基向量中的任何一个。但仍然是一个平面，是3D空间的一个向量子空间。一个向量张成1D空间，两个非平行向量张成2D空间。如果我们向其中添加一个第三个非平行向量，这三个向量是否张成3D空间？图6.20清楚地表明答案是否定的。
- en: '![](../Images/CH06_F20_Orland.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F20_Orland.png)'
- en: Figure 6.20 Three non-parallel vectors that only span a 2D space
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 只能张成2D空间的三个非平行向量
- en: No pair of the vectors ***u***, ***v***, and ***w*** is parallel, but these
    vectors don’t span a 3D space. They all live in the 2D plane, so no linear combination
    of them can
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 向量**u**、**v**和**w**的任意一对都不平行，但这些向量并不张成3D空间。它们都位于2D平面上，因此它们的任意线性组合都不能张成3D空间。
- en: magically obtain a *z*-coordinate. We need a better generalization of the concept
    of “non-parallel” vectors.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 神奇地获得一个*z*坐标。我们需要对“非平行”向量的概念进行更好的推广。
- en: If we want to add a vector to a set and span a higher dimensional space, the
    new vector needs to point in a new direction that isn’t included in the span of
    the existing ones. In the plane, three vectors always have some redundancy. For
    instance, as shown in figure 6.21, a linear combination of ***u*** and ***w***
    gives us ***v***.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将一个向量添加到集合中并生成一个更高维度的空间，新的向量需要指向一个不在现有向量张成空间中的新方向。在平面上，三个向量总是存在一些冗余。例如，如图6.21所示，**u**和**w**的线性组合给出了**v**。
- en: '![](../Images/CH06_F21_Orland.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F21_Orland.png)'
- en: Figure 6.21 A linear combination of *z* and *w* returns *v*, so the span of
    *u*, *v*, and *w* should be no bigger than the span of *z* and w.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 *z*和*w*的线性组合返回*v*，因此**u**、**v**和**w**的张成空间不应大于**z**和*w*的张成空间。
- en: The right generalization of “non-parallel” is *linearly independent*. A collection
    of vectors is *linearly dependent* if any of its members can be obtained as a
    linear combination of the others. Two parallel vectors are linearly dependent
    because they are scalar multiples of each other. Likewise, the set of three vectors
    {***u***, ***v***, ***w***} is linearly dependent because we can make ***v***
    out of a linear combination of ***u*** and ***w***(or ***w*** out of a linear
    combination of ***u*** and ***v***, and so on). You should make sure to get a
    feel for this concept yourself. As one of the exercises at the end of this section,
    you can check that any of the three vectors (1, 0), (1, 1) and (−1, 1) can be
    written as a linear combination of the other two.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: “非平行”的正确推广是**线性无关**。如果一个向量集合中的任何一个向量都可以表示为其他向量的线性组合，那么这个向量集合就是**线性相关**的。两个平行的向量是线性相关的，因为它们是彼此的标量倍数。同样，向量集合{***u***,
    ***v***, ***w***}是线性相关的，因为我们可以用***u***和***w***的线性组合来得到***v***（或者用***w***的线性组合来得到***u***和***v***，以此类推）。你应该确保自己对这个概念有深刻的理解。作为本节末尾的一个练习，你可以检查一下三个向量（1,
    0），（1, 1）和（−1, 1）中的任何一个都可以写成另外两个向量的线性组合。
- en: By contrast, the set {***u***, ***v***} is *linearly independent* because the
    components are non-parallel and cannot be scalar multiples of one another. This
    means that ***u*** and ***v*** span a bigger space than either on its own. Similarly,
    the standard basis {***e***[1], ***e***[2], ***e***[3] } for ℝ³ is a linearly
    independent set. None of these vectors can be built as a linear combination of
    the other two, and all three are required to span 3D space. We’re starting to
    get at the properties of a vector space or subspace that indicate its dimension.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，集合{***u***, ***v***}是**线性无关**的，因为它们的分量非平行，不能是彼此的标量倍数。这意味着***u***和***v***张成的空间比它们各自单独张成的空间要大。同样，标准基{***e***[1],
    ***e***[2], ***e***[3] }对于ℝ³是一个线性无关的集合。这些向量中的任何一个都不能由其他两个向量构建，而且需要所有三个向量来张成三维空间。我们开始接触到向量空间或子空间的性质，这些性质表明了它的维度。
- en: 6.3.4 Defining the word dimension
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.4 定义维度
- en: 'Here’s a motivational question: is the following set of 3D vectors linearly
    independent?'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个激励人心的问题：以下这组三维向量是否线性无关？
- en: '{(1, 1, 1), (2, 0, −3), (0, 0, 1), (−1, −2, 0)}'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '{(1, 1, 1), (2, 0, −3), (0, 0, 1), (−1, −2, 0)}'
- en: 'To answer this, you could draw these vectors in 3D or attempt to find a linear
    combination of three of them to get the fourth. But there’s an easier answer:
    only three vectors are needed to span all of 3D space, so any list of four 3D
    vectors has to have some redundancy.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，你可以在三维空间中绘制这些向量，或者尝试找到三个向量的线性组合来得到第四个向量。但有一个更简单的答案：只需要三个向量就可以张成整个三维空间，所以任何包含四个三维向量的列表都必须有一些冗余。
- en: 'We know that a set with one or two 3D vectors will span a line or plane, respectively,
    rather than all of ℝ³. Three is the magic number of vectors that can both span
    a 3D space and still be linearly independent. That’s really *why* we call it three-dimensional:
    there are three independent directions after all.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，一个包含一个或两个三维向量的集合将分别张成一条线或一个平面，而不是整个ℝ³。三个向量是魔法数字，既可以张成三维空间，又可以保持线性无关。这正是我们称之为三维的原因：毕竟有三个独立的方向。
- en: A linearly independent set of vectors that spans a whole vector space like {***e***[1],
    ***e***[2], ***e***[3] } for ℝ³ is called a *basis*. Any basis for a space has
    the same number of vectors, and that number is its *dimension*. For instance,
    we saw (1, 0) and (1, 1) are linearly independent and span the whole plane, so
    they are a basis for the vector space ℝ². Likewise (1, 0, 0) and (0, 1, 0) are
    linearly independent and span the plane where *z* = 0 in ℝ³. That makes them a
    basis for this 2D subspace, albeit not a basis for all of ℝ³.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一个张成整个向量空间（如ℝ³的{***e***[1], ***e***[2], ***e***[3] }）的线性无关向量集合被称为**基**。任何空间的一个基都有相同数量的向量，这个数量就是它的**维度**。例如，我们看到了（1,
    0）和（1, 1）是线性无关的，并且张成了整个平面，因此它们是向量空间ℝ²的一个基。同样，（1, 0, 0）和（0, 1, 0）是线性无关的，并且张成了ℝ³中*z*
    = 0的平面。这使得它们成为这个二维子空间的基，尽管不是整个ℝ³的基。
- en: I have already used the word *basis* in the context of the “standard basis”
    for ℝ² and for ℝ³. These are called “standard” because they are such natural choices.
    It takes no computation to decompose a coordinate vector in the standard basis;
    the coordinates *are* the scalars in this decomposition. For instance, (3, 2)
    means the linear combination 3 · (1, 0) + 2 · (0, 1) or 3***e***[1] + 2***e***[2].
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在“标准基”的上下文中使用了“基”这个词，对于 ℝ² 和 ℝ³。它们被称为“标准”，因为它们是如此自然的选择。在标准基中分解坐标向量不需要计算；坐标
    *就是* 这个分解中的标量。例如，(3, 2) 表示线性组合 3 · (1, 0) + 2 · (0, 1) 或 3***e***[1] + 2***e***[2]。
- en: In general, deciding whether vectors are linearly independent requires some
    work. Even if you know that a vector is a linear combination of some other vectors,
    finding that linear combination requires doing some algebra. In the next chapter,
    we cover how to do that; it ends up being a ubiquitous computational problem in
    linear algebra. But before that let’s get in some more practice identifying subspaces
    and measuring their dimensions.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，判断向量是否线性无关需要一些工作。即使你知道一个向量是某些其他向量的线性组合，找到这个线性组合也需要做一些代数运算。在下一章中，我们将介绍如何做到这一点；这最终成为线性代数中的一个普遍计算问题。但在那之前，让我们再练习一下识别子空间和测量它们的维度。
- en: 6.3.5 Finding subspaces of the vector space of functions
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.5 寻找函数向量空间的子空间
- en: 'Mathematical functions from ℝ to ℝ contain an infinite amount of data, namely
    the output value when they are given any of infinitely many real numbers as inputs.
    That doesn’t mean that it takes infinite data to describe a function though. For
    instance, a linear function requires only two real numbers. They are the values
    of *a* and *b* in this general formula that you’ve probably seen:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ℝ 到 ℝ 的数学函数包含无限多的数据，即当它们被给以无限多个实数作为输入时的输出值。但这并不意味着描述一个函数需要无限多的数据。例如，线性函数只需要两个实数。它们是这个通用公式中
    *a* 和 *b* 的值，你可能已经见过：
- en: '*f*(*x*) = *ax* + *b*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*) = *ax* + *b*'
- en: where *a* and *b* can be any real number. This is much more tractable than the
    infinite-dimensional space of all functions. Any linear function can be specified
    by two real numbers, so it looks like the subspace of linear functions will be
    2D.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a* 和 *b* 可以是任何实数。这比所有函数的无限维空间更容易处理。任何线性函数都可以由两个实数指定，所以看起来线性函数的子空间将是 2D。
- en: 'CAUTION I’ve used the word *linear* in a lot of new contexts in the last few
    chapters. Here, I’m returning to a meaning you used in high school algebra: a
    *linear function* is a function whose graph is a straight line. Unfortunately,
    functions of this form are not linear in the sense we spent all of chapter 4 discussing,
    and you can prove it yourself in an exercise. Because of this, I’ll try to be
    clear as to which sense of the word *linear* I’m using at any point.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我在过去几章中使用了“线性”这个词的许多新上下文。在这里，我回到了你在高中代数中使用的含义：一个 *线性函数* 是其图形是一条直线的函数。不幸的是，这种形式的函数在我们花了整个第四章讨论的意义上不是线性的，你可以在练习中自己证明这一点。因此，我将尽力在任何时候都清楚地说明我使用的“线性”这个词的含义。
- en: We can quickly implement a `LinearFunction` class inheriting from `Vector`.
    Instead of holding a function as its underlying data, it can hold two numbers
    for the coefficients *a* and *b*. We can add these functions by adding coefficients
    because
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速实现一个继承自 `Vector` 的 `LinearFunction` 类。它不是持有函数作为其底层数据，而是可以持有两个数字作为系数 *a*
    和 *b*。我们可以通过相加系数来添加这些函数，因为
- en: (*ax* + *b*) + (*cx* + *d*) = (*ax* + *cx*) + (*b* + *d*) = (*a* + *c*)*x* +
    (*b* + *d*)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: (*ax* + *b*) + (*cx* + *d*) = (*ax* + *cx*) + (*b* + *d*) = (*a* + *c*)*x* +
    (*b* + *d*)
- en: 'And we can scale the function by multiplying both coefficients by the scalar:
    *r*(*ax* + *b*) = *rax* + *rb*. Finally, it turns out the zero function *f*(*x*)
    = 0 is linear. It’s the case where *a* = *b* = 0\. Here’s the implementation:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将两个系数乘以标量来缩放函数：*r*(*ax* + *b*) = *rax* + *rb*。最后，结果证明零函数 *f*(*x*) = 0
    也是线性的。这是 *a* = *b* = 0 的情况。以下是实现方法：
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As figure 6.22 shows, the result is a linear function `plot([LinearFunction
    (−2,2)],−5,5)` gives us the straight line graph of *f*(*x*) = −2*x* + 2.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 6.22 所示，结果是线性函数 `plot([LinearFunction (−2,2)],−5,5)` 给出了 *f*(*x*) = −2*x*
    + 2 的直线图。
- en: '![](../Images/CH06_F22_Orland.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F22_Orland.png)'
- en: Figure 6.22 The graph of `LinearFunction(−2,2)` representing *f*(*x*) = −2*x*
    + 2
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 代表 *f*(*x*) = −2*x* + 2 的 `LinearFunction(−2,2)` 的图形
- en: We can prove to ourselves that linear functions form a vector subspace of dimension
    2 by writing a basis. The basis vectors should both be functions, they should
    span the whole space of linear functions, and they should be linearly independent
    (not multiples of one another). Such a set is {*x*, 1} or, more specifically,
    {*f*(*x*) = *x*, *g*(*x*) = 1}. Named this way, functions of the form *ax* + *b*
    can be written as a linear combination *a* · *f* + *b* · *g*.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过写一个基来证明线性函数形成了一个维度为2的向量子空间。基向量应该是函数，它们应该覆盖整个线性函数空间，并且应该是线性无关的（不是彼此的倍数）。这样的集合是{*x*,
    1}，或者更具体地说，是{*f*(*x*) = *x*, *g*(*x*) = 1}。这样命名，形式为*ax* + *b*的函数可以写成线性组合*a* ·
    *f* + *b* · *g*。
- en: This is as close as we can get to a standard basis for linear functions; *f*(*x*)
    = *x* and *f*(*x*) = 1 are clearly different functions, not scalar multiples of
    one another. By contrast, *f*(*x*) = *x* and *h*(*x*) = 4*x* *are* scalar multiples
    of one another and would not be a linearly independent pair. But {*x*, 1} is not
    the only basis we could have chosen; {4 *x* + 1, *x* − 3} is also a basis.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们能接近线性函数标准基的最接近的方法；*f*(*x*) = *x*和*f*(*x*) = 1是明显不同的函数，不是彼此的标量倍数。相比之下，*f*(*x*)
    = *x*和*h*(*x*) = 4*x*是彼此的标量倍数，不会是一个线性无关的对。但是{*x*, 1}不是我们唯一能选择的基；{4 *x* + 1, *x*
    − 3}也是一个基。
- en: The same concept applies to *quadratic functions* having the form *f*(*x*) =
    *ax*² + *bx* + *c*. These form a 3D subspace of the vector space of functions
    with one choice of basis being {*x*², *x*, 1}. Linear functions form a vector
    subspace of the space of quadratic functions where the *x*² component is zero.
    Linear functions and quadratic functions are examples of *polynomial functions*,
    which are linear combinations of powers of *x* ; for example,
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的概念适用于形式为*f*(*x*) = *ax*² + *bx* + *c*的*二次函数*。这些构成了函数向量空间中的一个3维子空间，其中一个基的选择是{*x*²,
    *x*, 1}。线性函数构成了一个向量子空间，其中二次函数的*x*²分量是零。线性函数和二次函数是*多项式函数*的例子，它们是*x*的幂的线性组合；例如，
- en: '*f*(*x*) = *a*[0] + *a*[1] *x* + *a*[2] *x*² + ... + *a[n]* *x^n*'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*) = *a*[0] + *a*[1] *x* + *a*[2] *x*² + ... + *a[n]* *x^n*'
- en: Linear and quadratic functions have *degree* 1 and 2, respectively, because
    those are the highest powers of *x* that appear in each. The polynomial written
    in the previous equation has degree *n* and *n* + 1 coefficients in total. In
    the exercises, you’ll see that the space of polynomials of *any* degree forms
    another vector subspace of the space of functions.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 线性函数和二次函数分别具有*次数*1和2，因为每个函数中出现的最高次幂是*x*。前面方程中写的多项式具有*n*次幂，总共有*n* + 1个系数。在练习中，你会看到任何次数的多项式空间构成了函数空间中的另一个向量子空间。
- en: 6.3.6 Subspaces of images
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.6 图像子空间
- en: Because our `ImageVector` objects are represented by 270,000 numbers, we could
    follow the standard basis formula and construct a basis of 270,000 images, each
    with one of the 270,000 numbers equal to 1 and all others equal to 0\. The listing
    shows what the first basis vector would look like.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`ImageVector`对象由270,000个数字表示，我们可以遵循标准基公式并构建一个由270,000个图像组成的基，每个图像中有一个270,000个数字等于1，其余都等于0。列表显示了第一个基向量将看起来是什么样子。
- en: Listing 6.4 Pseudocode that builds a first standard basis vector
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4构建第一个标准基向量的伪代码
- en: '[PRE65]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '❶ Only the first pixel in the first row is non-zero: it has a red value of
    1\. All the other pixels have a value of (0,0,0).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只有第一行的第一个像素是非零的：它有一个红色值为1。所有其他像素的值为(0,0,0)。
- en: ❷ The second row consists of 300 black pixels, each with a value (0,0,0).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第二行由300个黑色像素组成，每个像素的值为(0,0,0)。
- en: ❸ I skipped the next 298 rows, but they are all identical to row 2; no pixels
    have any color values.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我跳过了接下来的298行，但它们都与第2行相同；没有任何像素有任何颜色值。
- en: This single vector spans a 1D subspace consisting of the images that are black
    except for a single, red pixel in the top left corner. Scalar multiples of this
    image could have brighter or dimmer red pixels at this location, but no other
    pixels can be illuminated. In order to show more pixels, we need more basis vectors.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单个向量覆盖了一个一维子空间，其中图像除了左上角有一个红色像素外都是黑色的。这个图像的标量倍数在这个位置可以有更亮或更暗的红色像素，但其他像素不能被照亮。为了显示更多像素，我们需要更多的基向量。
- en: 'There’s not too much to be learned from writing out these 270,000 basis vectors.
    Let’s instead look for a small set of vectors that span an interesting subspace.
    Here’s a single `ImageVector` consisting of dark gray pixels at every position:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 从列出这些270,000个基向量中学习的东西并不多。相反，让我们寻找一组可以覆盖有趣子空间的向量。这里有一个由每个位置上的深灰色像素组成的单个`ImageVector`：
- en: '[PRE66]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'More concisely, we could write this instead:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 更简洁地说，我们可以这样写：
- en: '[PRE67]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: One way to picture the subspace spanned by the single vector gray is to look
    at some vectors that belong to it. Figure 6.23 shows scalar multiples of gray.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 想象由单个向量灰度生成的子空间的一种方法是通过查看属于它的某些向量。图6.23显示了灰度的标量倍数。
- en: '![](../Images/CH06_F23_Orland.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F23_Orland.png)'
- en: Figure 6.23 Some of the vectors in the 1D subspace of images spanned by the
    gray instance of `ImageVector`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23 由`ImageVector`的灰度实例生成的1D子空间中的一些向量。
- en: This collection of images is “one-dimensional” in the colloquial sense. There’s
    only one thing changing about them, their brightness.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这组图像在通俗意义上是“一维”的。它们只有一个属性在变化，那就是亮度。
- en: Another way we can look at this subspace is by thinking about the pixel values.
    In this subspace, any image has the same value at each pixel. For any given pixel,
    there is a 3D space of color possibilities measured by red, green, and blue coordinates.
    Gray pixels form a 1D subspace of this, containing points with all coordinates
    *s* · (1, 1, 1) for some scalar *s*(figure 6.24).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个子空间的方法是考虑像素值。在这个子空间中，任何图像在每个像素处的值都相同。对于任何给定的像素，有一个由红、绿、蓝坐标测量的3D颜色可能性空间。灰度像素形成这个空间的1D子空间，包含所有坐标为*s*
    · (1, 1, 1)的点，其中*s*是一个标量（图6.24）。
- en: '![](../Images/CH06_F24_Orland.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F24_Orland.png)'
- en: Figure 6.24 Gray pixels of varying brightness on a line. The gray pixels form
    a 1D subspace of the 3D vector space of pixel values.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24 一条线上的不同亮度的灰度像素。灰度像素形成像素值3D向量空间的1D子空间。
- en: Each of the images in the basis would be black, except for one pixel that would
    be a very dim red, green, or blue. Changing one pixel at a time doesn’t yield
    striking results, so let’s look for smaller and more interesting subspaces.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 基础中的每个图像都会是黑色，除了一个像素会是非常暗的红色、绿色或蓝色。一次改变一个像素不会产生显著的结果，所以让我们寻找更小、更有趣的子空间。
- en: 'There are many subspaces of images you can explore. You could look at solid
    color images of any color. These would be images of the form:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以探索许多图像的子空间。你可以查看任何颜色的纯色图像。这些图像的形式如下：
- en: '[PRE68]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: There are no constraints on the pixels themselves; the only constraint on a
    solid color image is that every pixel is the same. As a final example, you could
    consider a subspace consisting of low resolution, grayscale images like that shown
    in figure 6.25.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 像素本身没有约束；纯色图像的唯一约束是每个像素都相同。作为一个最终的例子，你可以考虑由图6.25所示的类似低分辨率、灰度图像组成的子空间。
- en: '![](../Images/CH06_F25_Orland.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F25_Orland.png)'
- en: Figure 6.25 A low resolution grayscale image. Each 10×10 block of pixels has
    the same value.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 一个低分辨率的灰度图像。每个10×10像素块具有相同的值。
- en: Each 10×10 pixel block has a constant gray value across its pixels, making it
    look like a 30×30 grid. There are only 30 · 30 = 900 numbers defining this image,
    so images like this one define a 900-dimensional subspace of the 270,000 dimensional
    space of images. It’s a lot less data, but it’s still possible to create recognizable
    images.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 每个像素块在其像素之间具有恒定的灰度值，使其看起来像一个30×30的网格。定义这个图像的只有30×30=900个数字，所以像这样的图像定义了图像270,000维空间中的900维子空间。数据量少得多，但仍然可以创建可识别的图像。
- en: One way to make an image in this subspace is to start with any image and average
    all red, green, and blue values in each 10×10 pixel block. This average gives
    you the brightness *b*, and you can set all pixels in the block to (*b*, *b*,
    *b*) to build your new image. This turns out to be a linear map (figure 6.26),
    and you can implement it later as a mini-project.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子空间中创建图像的一种方法是从任何图像开始，并平均每个10×10像素块中的所有红、绿和蓝色值。这个平均值给出了亮度*b*，你可以将块中的所有像素设置为(*b*,
    *b*, *b*)来构建你的新图像。这实际上是一个线性映射（图6.26），你可以将其作为迷你项目稍后实现。
- en: '![](../Images/CH06_F26_Orland.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH06_F26_Orland.png)'
- en: Figure 6.26 A linear map takes any image (left) and returns a new one (right)
    that lies in a 900-dimensional subspace.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26 线性映射将任何图像（左侧）转换为一个新图像（右侧），该图像位于900维子空间中。
- en: My dog, Melba, isn’t as photogenic in the second picture, but the picture is
    still recognizable. This is the example I mentioned at the beginning of the section,
    and the remarkable thing is that you can tell it’s the same picture with only
    0.3% of the data. There’s clearly room for improvement, but the approach of mapping
    to a subspace is a starting point for more fruitful exploration. In chapter 13,
    we’ll see how to compress audio data in this way.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我家的狗，梅尔巴，在第二张照片中并不那么上镜，但照片仍然可以辨认。这就是我在本节开头提到的例子，令人惊奇的是，你只需用 0.3% 的数据就能判断出这是同一张照片。显然还有改进的空间，但将映射到子空间的方法是更深入探索的起点。在第
    13 章中，我们将看到如何以这种方式压缩音频数据。
- en: 6.3.7 Exercises
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.7 练习题
- en: '| **Exercise 6.22**: Give a geometric argument for why the following region
    *S* of the plane can’t be a vector subspace of the plane.![](../Images/CH06_F26_Orland_UN04.png)**Solution**:
    There are many linear combinations of points in this region that don’t end up
    in the region. More obviously, this region cannot be a vector space because it
    doesn’t include the zero vector. The zero vector is a scalar multiple of any vector
    (by the scalar zero), so it must be included in any vector space or subspace.
    |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.22**: 给出几何论证，说明以下平面区域 *S* 为什么不能成为平面的向量子空间。![图片](../Images/CH06_F26_Orland_UN04.png)**解答**:
    这个区域中许多点的线性组合最终不会落在该区域内。更明显的是，这个区域不能成为向量空间，因为它不包含零向量。零向量是任何向量的标量倍数（通过标量零），因此它必须包含在任何向量空间或子空间中。
    |'
- en: '| **Exercise 6.23**: Show that the region of the plane where *x* = 0 forms
    a 1D vector space.**Solution**: These are the vectors that lie on the y-axis and
    have the form (0, *y*) for a real number *y*. Addition and scalar multiplication
    of vectors of the form (0, *y*) is the same as for real numbers; there just happens
    to be an extra 0 along for the ride. We can conclude that this is ℝ in disguise
    and, therefore, a 1D vector space. If you want to be more rigorous, you can check
    all of the vector space properties explicitly. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.23**: 证明平面上 *x* = 0 的区域形成一个 1D 向量空间。**解答**: 这些是位于 y 轴上的向量，形式为 (0,
    *y*)，其中 *y* 是实数。形式为 (0, *y*) 的向量的加法和标量乘法与实数相同；只是碰巧有一个额外的 0 一起出现。我们可以得出结论，这实际上是
    ℝ 的伪装，因此是一个 1D 向量空间。如果你想要更严谨，你可以明确检查所有向量空间性质。 |'
- en: '| **Exercise 6.24**: Show that three vectors (1, 0), (1, 1), and (−1, 1) are
    linearly dependent by writing each one as a linear combination of the other two.**Solution**:(1,
    0) = ½ · (1, 1) − ½ · (−1, 1)(1, 1) = 2 · (1, 0) + (−1, 1)(−1, 1) = (1, 1) − 2
    · (1, 0) |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.24**: 通过将每个向量表示为其他两个向量的线性组合，证明三个向量 (1, 0), (1, 1), 和 (−1, 1) 是线性相关的。**解答**:(1,
    0) = ½ · (1, 1) − ½ · (−1, 1)(1, 1) = 2 · (1, 0) + (−1, 1)(−1, 1) = (1, 1) − 2
    · (1, 0) |'
- en: '| **Exercise 6.25**: Show that you can get any vector (*x*, *y*) as a linear
    combination of (1, 0) and (1, 1).**Solution**: We know that (1, 0) can’t contribute
    to the *y*-coordinate, so we need *y* times (1, 1) as part of the linear combination.
    To make the algebra work, we need (*x* − *y*) units of (1, 0):(*x*, *y*) = (*x*
    − *y*) · (1, 0) + *y*(1, 1) |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.25**: 证明你可以将任意向量 (*x*, *y*) 表示为 (1, 0) 和 (1, 1) 的线性组合。**解答**: 我们知道
    (1, 0) 不能对 *y*-坐标做出贡献，因此我们需要 *y* 倍的 (1, 1) 作为线性组合的一部分。为了使代数运算成立，我们需要 (*x* − *y*)
    单位的 (1, 0)：(*x*, *y*) = (*x* − *y*) · (1, 0) + *y*(1, 1) |'
- en: '| **Exercise 6.26**: Given a single vector ***v***, explain why the set of
    all linear combinations of ***v*** is the same as the set of all scalar multiples
    of ***v***.**Solution**: Linear combinations of a vector and itself reduce to
    scalar multiples according to one of the vector space laws. For instance, the
    linear combination *a* · ***v*** + *b* · ***v*** is equal to (*a* + *b*) · ***v***.
    |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.26**: 给定一个单个向量 ***v***，解释为什么所有 ***v*** 的线性组合的集合与所有 ***v*** 的标量倍数的集合相同。**解答**:
    向量的线性组合和自身根据向量空间的一条法则简化为标量倍数。例如，线性组合 *a* · ***v*** + *b* · ***v*** 等于 (*a* + *b*)
    · ***v***。 |'
- en: '| **Exercise 6.27**: From a geometric perspective, explain why a line that
    *doesn’t* pass through the origin is not a vector subspace (of the plane or of
    the 3D space).**Solution**: One simple reason this cannot be a subspace is that
    it doesn’t contain the origin (the zero vector). Another reason is that such a
    line will have two non-parallel vectors. Their span would be the whole plane,
    which is much bigger than the line. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.27**: 从几何角度解释为什么不通过原点的直线不是向量子空间（平面或三维空间的子空间）。**解答**: 这不能成为子空间的一个简单原因是它不包含原点（零向量）。另一个原因是这样的直线将有两个非平行向量。它们的生成空间将是整个平面，这比直线大得多。
    |'
- en: '| **Exercise 6.28**: Any two of {***e***[1], ***e***[2], ***e***[3] } will
    fail to span all of ℝ³ and will instead span 2D subspaces of a 3D space. What
    are these subspaces?**Solution**: The span of the set {***e***[1], ***e***[2]
    } consists of all linear combinations *a* · ***e***[1] + *b* · ***e***[2], or
    *a* · (1, 0, 0) + *b* · (0, 1, 0) = (*a*, *b*, 0). Depending on the choice of
    *a* and *b*, this can be any point in the plane where *z* = 0, often called the
    *x*,*y* plane. By the same argument, the vectors {***e***[2], ***e***[3] } span
    the plane where *x* = 0, called the *y*,*z* plane, and the vectors {***e***[1],
    ***e***[3] } span the plane where *y* = 0, called the *x*,*z* plane. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.28**: {***e***[1], ***e***[2], ***e***[3] } 中的任意两个向量都无法张成整个 ℝ³，而是会张成
    3D 空间中的 2D 子空间。这些子空间是什么？**解答**: 集合 {***e***[1], ***e***[2] } 的张成由所有线性组合 *a* ·
    ***e***[1] + *b* · ***e***[2] 组成，或者 *a* · (1, 0, 0) + *b* · (0, 1, 0) = (*a*,
    *b*, 0)。根据 *a* 和 *b* 的选择，这可以是平面上 *z* = 0 的任意一点，通常称为 *x*,*y* 平面。通过同样的论证，向量 {***e***[2],
    ***e***[3] } 张成 *x* = 0 的平面，称为 *y*,*z* 平面，而向量 {***e***[1], ***e***[3] } 张成 *y*
    = 0 的平面，称为 *x*,*z* 平面。|'
- en: '| **Exercise 6.29**: Write the vector (−5, 4) as a linear combination of (0,
    3) and (−2, 1).**Solution**: Only (−2, 1) can contribute to the *x*-coordinate,
    so we need to have 2.5 · (−2, 1) in the sum. That gets us to (−5, 2.5), so we
    need an additional 1.5 units on the *x*-coordinate or 0.5 · (0, 3). The linear
    combination is(−5, 4) = 0.5 · (0, 3) + 2.5 · (−2, 1) |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.29**: 将向量 (−5, 4) 写成 (0, 3) 和 (−2, 1) 的线性组合。**解答**: 只有 (−2, 1) 可以对
    *x* 坐标做出贡献，因此我们需要在和中包含 2.5 · (−2, 1)。这使我们得到 (−5, 2.5)，因此我们需要在 *x* 坐标上额外 1.5 个单位或
    0.5 · (0, 3)。线性组合是(−5, 4) = 0.5 · (0, 3) + 2.5 · (−2, 1) |'
- en: '| **Exercise 6.30−Mini Project**: Are (1, 2, 0), (5, 0, 5), and (2, −6, 5)
    linearly independent or linearly dependent vectors?**Solution**: It’s not easy
    to find, but there is a linear combination of the first two vectors that yields
    the third:−3 · (1, 2, 0) + (5, 0, 5) = (2, −6, 5)This means that the third vector
    is redundant, and the vectors *are* linearly dependent. They only span a 2D subspace
    of 3D rather than all of 3D space. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.30-迷你项目**: 向量 (1, 2, 0), (5, 0, 5), 和 (2, −6, 5) 是线性无关还是线性相关？**解答**:
    找到这一点并不容易，但前两个向量的一个线性组合可以得到第三个向量：−3 · (1, 2, 0) + (5, 0, 5) = (2, −6, 5)。这意味着第三个向量是多余的，向量*是*线性相关的。它们只张成
    3D 空间中的 2D 子空间，而不是整个 3D 空间。|'
- en: '| **Exercise 6.31**: Explain why the linear function *f*(*x*) = *ax* + *b*
    is not a linear map from the vector space ℝ to itself unless *b* = 0.**Solution**:
    We can turn directly to the definition: a linear map must preserve linear combinations.
    We see that *f* doesn’t preserve linear combinations of real numbers. For instance,
    *f*(1+1) = 2*a* + *b* while *f*(1) + *f*(1) = (*a* + *b*) + (*a* + *b*) = 2*a*
    + 2*b*. This won’t hold unless *b* = 0.As an alternative explanation, we know
    that linear functions ℝ: → ℝ should be representable as 1-by−1 matrices. Matrix
    multiplication of a 1D column vector [*x* ] by a 1-by−1 matrix [ *a* ] gives you
    [ *ax* ]. This is an unusual case of matrix multiplication, but your implementation
    from chapter 5 confirms this result. If a function ℝ: → ℝ is going to be linear,
    it must agree with 1-by−1 matrix multiplication and, therefore, be multiplication
    by a scalar. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.31**: 解释为什么线性函数 *f*(*x*) = *ax* + *b* 除非 *b* = 0，否则不是从向量空间 ℝ 到自身的线性映射。**解答**:
    我们可以直接转向定义：线性映射必须保持线性组合。我们看到 *f* 并不保持实数的线性组合。例如，*f*(1+1) = 2*a* + *b*，而 *f*(1)
    + *f*(1) = (*a* + *b*) + (*a* + *b*) = 2*a* + 2*b*。除非 *b* = 0，否则这不会成立。作为另一种解释，我们知道线性函数
    ℝ: → ℝ 应该可以表示为 1x1 矩阵。1D 列向量 [*x* ] 与 1x1 矩阵 [ *a* ] 的矩阵乘法给出 [ *ax* ]。这是一个不寻常的矩阵乘法情况，但第
    5 章中的实现确认了这一结果。如果一个函数 ℝ: → ℝ 将要成为线性函数，它必须与 1x1 矩阵乘法一致，因此必须是乘以一个标量。|'
- en: '| **Exercise 6.32**: Rebuild the `LinearFunction` class by inheriting from
    `Vec2` and implementing the `__call__` method.**Solution**: The data of a `Vec2`
    are called *x* and *y* instead of *a* and *b* ; otherwise, the functionality is
    the same. All you need to do is implement `__call__` :'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.32**: 通过继承 `Vec2` 类并实现 `__call__` 方法来重建 `LinearFunction` 类。**解答**:
    `Vec2` 的数据称为 *x* 和 *y* 而不是 *a* 和 *b*；否则，功能相同。你只需要实现 `__call__` 方法：'
- en: '[PRE69]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '|'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.33**: Prove (algebraically!) that the linear functions of the
    form *f*(*x*) = *ax* + *b* make up a vector subspace of the vector space of all
    functions.**Solution**: To prove this, you need to be sure a linear combination
    of two linear functions is another linear function. If *f*(*x*) = *ax* + *b* and
    *g*(*x*) = *cx* + *d*, then *r* · *f* + *s* · *g* returns*r* · *f* + *s* · *g*
    = *r* · (*ax* + *b*) + *s* · (*cx* + *d*) = *rax* + *b* + *scx* + *d* = (*ra*
    + *sc*) · *x* + (*b* + *d*)Because (*ra* + *sc*) and (*b* + *d*) are scalars,
    this has the form we want. We can conclude that linear functions are closed under
    linear combinations and, therefore, that they form a subspace. |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.33**: 证明（代数地！）形式为 *f*(*x*) = *ax* + *b* 的线性函数构成了所有函数向量空间的一个向量子空间。**解答**：为了证明这一点，你需要确保两个线性函数的线性组合仍然是另一个线性函数。如果
    *f*(*x*) = *ax* + *b* 和 *g*(*x*) = *cx* + *d*，那么 *r* · *f* + *s* · *g* 返回 *r*
    · *f* + *s* · *g* = *r* · (*ax* + *b*) + *s* · (*cx* + *d*) = *rax* + *b* + *scx*
    + *d* = (*ra* + *sc*) · *x* + (*b* + *d*)因为 (*ra* + *sc*) 和 (*b* + *d*) 是标量，这符合我们想要的形式。我们可以得出结论，线性函数在线性组合下是封闭的，因此它们构成一个子空间。|'
- en: '| **Exercise 6.34**: Find a basis for the set of 3-by−3 matrices. What is the
    dimension of this vector space?**Solution**: Here’s a basis consisting of nine,
    3-by−3 matrices:![](../Images/CH06_F26_Orland_UN04_EQ01.png)They are linearly
    independent; each contributes a unique entry to any linear combination. They also
    span the space because any matrix can be constructed as a linear combination of
    these; the coefficient on any particular matrix decides one entry of the result.
    Because these nine vectors provide a basis for the space of 3-by−3 matrices, the
    space has nine dimensions. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.34**: 找到一个 3x3 矩阵集合的基。这个向量空间的维数是多少？**解答**：这里有一个由九个 3x3 矩阵组成的基！它们是线性无关的；每个矩阵都对任何线性组合贡献了一个独特的项。它们也张成了这个空间，因为任何矩阵都可以被表示为这些矩阵的线性组合；任何特定矩阵的系数决定了结果中的一个项。因为这九个向量提供了
    3x3 矩阵空间的基，所以这个空间有九个维度。|'
- en: '| **Exercise 6.35−Mini Project**: Implement a class `QuadraticFunction(Vector)`
    that represents the vector subspace of functions of the form *ax*² + *bx* + *c*.
    What is a basis for this subspace?**Solution**: The implementation looks a lot
    like `LinearFunction`, except there are three coefficients instead of two, and
    the `__call__` function has a square term:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.35-迷你项目**：实现一个类 `QuadraticFunction(Vector)`，它表示形式为 *ax*² + *bx* +
    *c* 的函数向量子空间。这个子空间的基是什么？**解答**：这个实现看起来很像 `LinearFunction`，除了有三个系数而不是两个，并且 `__call__`
    函数有一个平方项：'
- en: '[PRE70]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '|'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| We can take note that *ax*² + *bx* + *c* looks like a linear combination
    of the set {*x*², *x*, 1}. Indeed, these three functions span the space, and none
    of these three can be written as a linear combination of the others. There’s no
    way to get a *x*² term by adding together linear functions, for example. Therefore,
    this is a basis. Because there are three vectors, we can conclude that this is
    a 3D subspace of the space of functions. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 我们可以注意到 *ax*² + *bx* + *c* 看起来像是集合 {*x*², *x*, 1} 的线性组合。确实，这三个函数张成了这个空间，而且这三个函数中的任何一个都不能被表示为其他函数的线性组合。例如，通过将线性函数相加无法得到
    *x*² 项。因此，这是一个基。因为有三个向量，我们可以得出结论，这是函数空间的 3D 子空间。|'
- en: '| **Exercise 6.36−Mini Project**: I claimed that {4 *x* + 1, *x* − 2} are a
    basis for the set of linear functions. Show that you can write −2*x* + 5 as a
    linear combination of these two functions.**Solution**: (1/9) · (4*x* + 1) − (22/9)
    · (*x* − 2) = −2*x* + 5\. If your algebra skills aren’t too rusty, you can figure
    this out by hand. Otherwise, don’t worry; we cover how to solve tricky problems
    like this in the next chapter. |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| **练习 6.36-迷你项目**：我声称 {4 *x* + 1, *x* − 2} 是线性函数集合的一个基。证明你可以将 −2*x* + 5 表示为这两个函数的线性组合。**解答**：(\(
    \frac{1}{9} \)) · (4*x* + 1) − (\( \frac{22}{9} \)) · (*x* − 2) = −2*x* + 5。如果你的代数技能不是很生疏，你可以手动解决这个问题。否则，不用担心；我们将在下一章中介绍如何解决这类难题。|'
- en: '| **Exercise 6.37-Mini Project**: The vector space of all polynomials is an
    infinite-dimensional subspace. Implement that vector space as a class and describe
    a basis (which must be an infinite set!).**Solution**:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 6.37-迷你项目**：所有多项式的向量空间是一个无限维的子空间。实现这个向量空间作为一个类，并描述一个基（这必须是一个无限集！）**解答**：'
- en: '[PRE71]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A basis for the set of all polynomials is the infinite set {1, *x*, *x*², *x*³,
    *x*⁴, ...}. Given all of the possible powers of *x* at your disposal, you can
    build any polynomial as a linear combination. |
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 所有多项式的集合的基是无限集 {1, *x*, *x*², *x*³, *x*⁴, ...}。给定所有可用的 *x* 的幂，你可以将任何多项式表示为线性组合。|
- en: '| **Exercise 6.38**: I showed you pseudocode for a basis vector for the 270,000
    dimensional space of images. What would the second basis vector look like?**Solution**:
    The second basis vector could be given by putting a one in the next possible place.
    It would yield a dim green pixel in the very top left of the image:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.38**：我向你展示了270,000维图像空间的基向量的伪代码。第二个基向量看起来会是什么样子？**解答**：第二个基向量可以通过在下一个可能的位置放置一个1来给出。它将在图像的非常左上角产生一个深绿色像素：'
- en: '[PRE72]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ❶ For the second basis vector, the 1 has moved to the second possible slot.❷
    All other rows remain empty |
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于第二个基向量，1已经移动到第二个可能的位置。❷ 所有其他行保持为空 |
- en: '| **Exercise 6.39**: Write a function `solid_color(r,g,b)` that returns a solid
    color `ImageVector` with the given red, green, and blue content at every pixel.**Solution**:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.39**：编写一个函数`solid_color(r,g,b)`，该函数返回一个具有给定红色、绿色和蓝色内容的每个像素的纯色`ImageVector`。**解答**：'
- en: '[PRE73]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 6.40−Mini Project**: Write a linear map that generates an `ImageVector`
    from a 30×30 grayscale image, implemented as a 30×30 matrix of brightness values.
    Then, implement the linear map that takes a 300×300 image to a 30×30 grayscale
    image by averaging the brightness (average of red, green, and blue) at each pixel.**Solution**:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习6.40-迷你项目**：编写一个线性映射，它从30×30的灰度图像生成一个`ImageVector`，该图像实现为一个30×30的亮度值矩阵。然后，实现一个线性映射，它将300×300的图像转换为30×30的灰度图像，通过在每个像素处平均亮度（红色、绿色和蓝色的平均值）来实现。**解答**：'
- en: '[PRE74]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ❶ Indicates that we’re breaking the picture into a 30×30 grid❷ The function
    takes an ImageVector and returns an array of 30 arrays of 30 values each, giving
    grayscale values square by square.❸ The second function takes a 30×30 matrix and
    returns an image built from 10×10 pixel blocks, having a brightness given by the
    matrix values.Calling `from_lowres_grayscale(to_lowres_grayscale(img))` transforms
    the image `img` in the way I showed in the chapter. |
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表示我们将图片分割成30×30的网格❷ 函数接受一个ImageVector并返回一个包含30个30值数组的数组，每个值代表一个灰度值，按平方排列。❸
    第二个函数接受一个30×30的矩阵，并返回一个由10×10像素块组成的图像，亮度由矩阵值给出。调用`from_lowres_grayscale(to_lowres_grayscale(img))`将图像`img`转换为我在章节中展示的方式。|
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'A vector space is a generalization of the 2D plane and 3D space: a collection
    of objects that can be added and multiplied by scalars. These addition and scalar
    multiplication operations must behave in certain ways (listed in section 6.1.5)
    to mimic the more familiar operations in 2D and 3D.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量空间是二维平面和三维空间的一般化：一组可以加法和标量乘法的对象。这些加法和标量乘法操作必须以某种方式表现（在6.1.5节中列出），以模仿在二维和三维中更熟悉的操作。
- en: You can generalize in Python by pulling common features of different data types
    into an abstract base class and inheriting from it.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在Python中将不同数据类型的共同特性拉入一个抽象基类并从中继承来泛化。
- en: You can overload arithmetic operators in Python so that vector math looks the
    same in code, regardless of what kind of vectors you’re using.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在Python中重载算术运算符，以便无论使用什么类型的向量，代码中的向量数学看起来都一样。
- en: Addition and scalar multiplication need to behave in certain ways to match your
    intuition, and you can verify these behaviors by writing unit tests involving
    random vectors.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法和标量乘法需要以某种方式表现，以符合你的直觉，你可以通过编写涉及随机向量的单元测试来验证这些行为。
- en: Real-world objects like used cars can be described by several numbers (coordinates)
    and, therefore, treated as vectors. This lets us think about abstract concepts
    like a “weighted average of two cars.”
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际对象，如二手车，可以用几个数字（坐标）来描述，因此可以被视为向量。这使得我们可以考虑像“两辆车的加权平均值”这样的抽象概念。
- en: Functions can be thought of as vectors. You add or multiply them by adding or
    multiplying the expressions that define them.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以被看作是向量。你可以通过添加或乘以定义它们的表达式来添加或乘以它们。
- en: Matrices can be thought of as vectors. The entries of an *m* × *n* matrix can
    be thought of as coordinates of an (*m* · *n*)-dimensional vector. Adding or scalar
    multiplying matrices has the same effect as adding or scalar multiplying the linear
    functions they define.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵可以被看作是向量。一个*m* × *n*矩阵的条目可以被看作是一个(*m* · *n*)-维向量的坐标。添加或标量乘以矩阵的效果与添加或标量乘以它们定义的线性函数的效果相同。
- en: Images of a fixed height and width make up a vector space. They are defined
    by a red, green, and blue (RGB) value at each pixel, so the number of coordinates
    and, therefore, the dimension of the space is defined by three times the number
    of pixels.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定高度和宽度的图像组成一个向量空间。它们在每个像素处由红色、绿色和蓝色（RGB）值定义，因此坐标的数量以及空间的维度由像素数量的三倍定义。
- en: A subspace of a vector space is a subset of the vectors in a vector space, which
    is a vector space on its own. That is, linear combinations of vectors in the subspace
    stay in the subspace.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量空间的一个子空间是向量空间中向量的一个子集，它本身也是一个向量空间。也就是说，子空间中向量的线性组合仍然保持在子空间内。
- en: For any line through the origin in 2D or 3D, the set vectors that lie on it
    form a 1D subspace. For any plane through the origin in 3D, the vectors that lie
    on it form a 2D subspace.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于通过原点的任意二维或三维直线，位于其上的向量集形成一个一维子空间。对于通过原点的任意三维平面，位于其上的向量形成一个二维子空间。
- en: The span of a set of vectors is the collection of all linear combinations of
    the vectors. It is guaranteed to be a subspace of whatever space the vectors live
    in.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量集的张成是指所有向量的线性组合的集合。它保证是向量所在空间的子空间。
- en: A set of vectors is linearly *independent* if you can’t make any one of them
    as a linear combination of the others. Otherwise, the set is linearly *dependent*.
    A set of linearly independent vectors that span a vector space (or subspace) is
    called a *basis* for that space. For a given space, any basis will have the same
    number of vectors. That number defines the dimension of the space.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不能将任何一个向量表示为其他向量的线性组合，那么这个向量集是线性**独立**的。否则，该集合是线性**相关**的。一个能够张成向量空间（或子空间）的线性独立向量集被称为该空间的**基**。对于给定的空间，任何基都将包含相同数量的向量。这个数量定义了空间的维度。
- en: When you can think of your data as living in a vector space, subspaces often
    consist of data with similar properties. For instance, the subset of image vectors
    that are solid colors forms a subspace.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你可以将你的数据视为存在于向量空间中时，子空间通常由具有相似属性的数据组成。例如，由纯色图像向量组成的子集形成一个子空间。
- en: '* * *'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1. That is, as long as you can guarantee your vector space has only finitely
    many dimensions! There is a vector space called ℝ∞, but it is not the only infinitely
    dimensional vector space.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 也就是说，只要你能保证你的向量空间只有有限多个维度！存在一个称为ℝ∞的向量空间，但它并不是唯一的无穷维向量空间。
