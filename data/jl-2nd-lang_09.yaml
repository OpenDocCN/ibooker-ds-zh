- en: 7 Understanding types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 理解类型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Understanding type hierarchies
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类型层次结构
- en: Differences between abstract and concrete types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类型和具体类型之间的区别
- en: Combining primitive types to make composite types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始类型组合成复合类型
- en: Harnessing the power of multiple dispatch to solve complex tasks elegantly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用多重分派的力量优雅地解决复杂任务
- en: How multiple dispatch differs from single dispatch in object-oriented languages^([1](#pgfId-1011831))
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多重分派与面向对象语言中的单分派有何不同^([1](#pgfId-1011831))
- en: 'All objects in Julia are of a particular type. Remember, you can use typeof
    to discover the type of any object:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的所有对象都属于特定类型。记住，你可以使用typeof来发现任何对象的类型：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The type decides what you can do with an object. For example, a dictionary
    allows you to look up a value by key, while an array stores elements in order.
    An expression evaluating to a Bool value, such as true or false, can be used in
    an if statement and while loops, while expressions evaluating to a floating-point
    value can’t:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类型决定了你可以对对象做什么。例如，字典允许你通过键查找值，而数组按顺序存储元素。评估为Bool值的表达式，如true或false，可以在if语句和while循环中使用，而评估为浮点值的表达式则不能：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Thus, if you want to create objects with different behavior and features, you
    need to define new types. In programming, we often try to mimic the real world:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想创建具有不同行为和特征的对象，你需要定义新的类型。在编程中，我们经常试图模仿现实世界：
- en: Banking apps have types representing bank accounts, customers, and transactions.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 银行应用程序有代表银行账户、客户和交易的类型。
- en: Video games have objects representing monsters, heroes, weapons, spaceships,
    traps, and so on.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频游戏有代表怪物、英雄、武器、宇宙飞船、陷阱等等的对象。
- en: Graphical user interfaces have objects representing buttons, menu entries, pop-up
    menus, and radio buttons.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形用户界面有代表按钮、菜单项、弹出菜单和单选按钮的对象。
- en: Drawing applications have objects representing different shapes, strokes, colors,
    and drawing tools.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘图应用程序有代表不同形状、笔触、颜色和绘图工具的对象。
- en: So whatever type of application you want to make, you will need to know how
    to create relevant types to the application. This chapter and the next one will
    define types relevant to model behavior in a video game and rocket simulator.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论你想制作哪种类型的应用程序，你都需要知道如何创建与该应用程序相关的类型。本章和下一章将定义与视频游戏和火箭模拟器中的模型行为相关的类型。
- en: 7.1 Creating composite types from primitive types
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 从原始类型创建复合类型
- en: 'Let’s start with the basics: Integers, characters, and floating-point numbers
    are all examples of primitive types. You cannot break them further down into smaller
    parts. In some languages, such as LISP, these are aptly named *atoms*. With the
    isprimitivetype you can check whether a type is *primitive*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始：整数、字符和浮点数都是原始类型的例子。你不能将它们进一步分解成更小的部分。在某些语言中，如LISP，这些被恰当地命名为*原子*。使用isprimitivetype你可以检查一个类型是否是*原始的*：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can combine primitive types to create *composite types*. Composite types
    can even be made out of other composite types. For example, a string is a composite
    type made up of multiple characters, which are primitive types. Let’s demonstrate
    this with a concrete example by defining a composite type that could be useful
    in a video game to represent an archer shooting arrows at opponents.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将原始类型组合成复合类型。复合类型甚至可以由其他复合类型组成。例如，字符串是由多个字符组成的复合类型，而字符是原始类型。让我们通过定义一个在视频游戏中表示弓箭手向对手射箭的有用复合类型来具体演示这一点。
- en: Listing 7.1 Definition of a composite type
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1复合类型的定义
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The name of the archer—say Robin Hood
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 弓箭手的名字——比如说罗宾汉
- en: ❷ Health points left
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 剩余的生命值
- en: ❸ Arrows left in the quiver
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 箭袋中的箭
- en: Think of types as templates or cookie cutters, which you use to stamp out multiple
    objects. The objects you make from a type are called *instances*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型视为模板或模具，你使用它们来制作多个对象。从类型中制作的对象称为*实例*。
- en: Warning Julia composite types may look very similar to classes in Java, C++,
    or Python, but they are not the same thing. They don’t support implementation
    inheritance and don’t have methods attached.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 Julia的复合类型可能看起来与Java、C++或Python中的类非常相似，但它们并不是同一回事。它们不支持实现继承，也没有附加的方法。
- en: The following snippet shows the creation of instances of the Archer type. You
    may also hear people use phrases such as, “Instantiate an Archer object.”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了Archer类型的实例创建。你也可能听到人们使用诸如“实例化一个Archer对象”之类的短语。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Access the name field of the robin object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 访问robin对象的名称字段。
- en: ❷ Access the arrows field of the robin object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问 robin 对象的 arrows 字段。
- en: The definition of a composite type has some similarities with using a dictionary.
    For example, you define fields for storing values that can be accessed through
    their field name. However, unlike a dictionary, you can specify a different type
    for each field using a *type annotation*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 组合类型的定义与使用字典有一些相似之处。例如，你定义字段以存储可以通过其字段名访问的值。然而，与字典不同，你可以使用 *类型注解* 为每个字段指定不同的类型。
- en: 'Important In Julia the :: is used to annotate variables and expressions with
    their type. x::T means variable x should have type T. It helps Julia figure out
    how many bytes are needed to hold all fields in a struct.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '重要提示：在 Julia 中，:: 用于注释变量和表达式及其类型。x::T 表示变量 x 应该具有类型 T。这有助于 Julia 确定需要多少字节来存储结构体中的所有字段。'
- en: To clarify this point, define a dictionary to hold information about an archer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明这一点，定义一个字典来存储关于弓箭手的资料。
- en: Listing 7.2 Using a dictionary to store information about an archer
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 使用字典存储关于弓箭手的资料
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Dictionary with String key and where the value is of type Any
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 字典具有 String 键，其中值是 Any 类型
- en: ❷ Accessing value stored for name key
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问存储在 name 键中的值
- en: A problem with using a dictionary is that it requires every value to be of the
    same type. But wait a minute, how can this be the case? name and arrows are entirely
    different types?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典的一个问题是它要求每个值都具有相同的类型。但是等等，name 和 arrows 完全是不同类型吗？
- en: The short answer is that the values in the dictionary are of type Any. That
    means you can store values of any type. The keys are more restrictive, as they
    are defined to be of type String. But to really understand how this works you
    need to explore Julia type hierarchies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，字典中的值是 Any 类型。这意味着你可以存储任何类型的值。键更加限制性，因为它们被定义为 String 类型。但要真正理解这是如何工作的，你需要探索
    Julia 类型层次结构。
- en: 7.2 Exploring type hierarchies
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 探索类型层次结构
- en: If you are familiar with object-oriented languages, then you should be familiar
    with class^([2](#pgfId-1012946)) inheritance hierarchies. In Julia, you also have
    type hierarchies, but a significant difference is that these hierarchies also
    exist for primitive types. For example, in a language such as Java or C++, an
    integer or floating-point number is just one concrete type. However, in Julia,
    even numbers, collections, and strings are part of deeper type hierarchies (figure
    7.1).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象的语言，那么你应该熟悉类继承层次结构。在 Julia 中，你也有类型层次结构，但一个显著的区别是这些层次结构也存在于原始类型中。例如，在
    Java 或 C++ 这样的语言中，整数或浮点数只是一个具体的类型。然而，在 Julia 中，甚至数字、集合和字符串都是更深层次类型层次结构的一部分（图 7.1）。
- en: '![07-01](../Images/07-01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![07-01](../Images/07-01.png)'
- en: Figure 7.1 Type hierarchy for numbers, showing abstract and concrete types in
    dark and light shaded boxes
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 数字类型层次结构，显示抽象和具体类型在深浅阴影的框中
- en: 'You can explore these hierarchies with the supertype and subtypes functions.
    You can recreate the type hierarchy for numbers in figure 7.1 by starting at the
    top of the type hierarchy and working your way downward, using the subtypes function
    to find subtypes, which can then be explored further:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用超类型和子类型函数来探索这些层次结构。你可以通过从类型层次结构的顶部开始，向下使用子类型函数找到子类型，然后进一步探索来重新创建图 7.1 中数字的类型层次结构：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Find immediate subtypes of the Number type.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查找 Number 类型的直接子类型。
- en: ❷ Discover subtypes of real numbers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 发现实数的子类型。
- en: ❸ Integers can be signed or unsigned.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 整数可以是带符号的或无符号的。
- en: 'But how do you know that the root of the number hierarchy is the Number type?
    You could work your way upward from number types you already know:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但你怎么知道数字层次结构的根是 Number 类型呢？你可以从你已知的数字类型向上工作：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Store the type of 42 in variable T.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 42 的类型存储在变量 T 中。
- en: ❷ Look up supertype Int64, and store it in T.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 查找 Int64 的超类型，并将其存储在 T 中。
- en: 'You can even continue to pass the root of the number hierarchy, until you get
    to the root of the whole Julia type hierarchy. Once you reach Any, you know you
    have reached the top of the type hierarchy because the supertype of Any is also
    Any:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以继续传递数字层次结构的根，直到你到达整个 Julia 类型层次结构的根。一旦你到达 Any，你就知道你已经到达了类型层次结构的顶端，因为 Any
    的超类型也是 Any：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is essential to realize that Julia’s types are first-class objects that you
    can pass around as arguments or store in variables. For example, here you are
    storing the type of the integer 42 in a variable called T. It is a convention
    in many languages to use T as a name for an arbitrary type. Let’s explore the
    type hierarchy with some simple functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要认识到Julia的类型是一等对象，你可以将它们作为参数传递或存储在变量中。例如，这里你将整数42的类型存储在一个名为T的变量中。在许多语言中，使用T作为任意类型的名称是一种约定。让我们通过一些简单的函数来探索类型层次。
- en: Listing 7.3 Finding the root of the type hierarchy
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 查找类型层次的最顶层
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Check if the supertype of T is the same as T.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 检查T的超类型是否与T相同。
- en: 'This is a recursive^([3](#pgfId-1013617)) function, which you can use to find
    the top of the type hierarchy:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个递归函数，你可以用它来找到类型层次的最顶层：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can see that the type hierarchy stops at Any, since the supertype of Any
    is Any. So what is the significance of these type of hierarchies? How do they
    help you as a programmer? Let me give you this example in the REPL to give you
    a hint:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到类型层次在Any处停止，因为Any的超类型是Any。那么这些类型层次有什么意义呢？它们作为程序员如何帮助你？让我给你一个REPL中的例子来给你一些提示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Define an array that can hold Any value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个可以存储Any值的数组。
- en: ❷ Define an array to hold Integer values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个可以存储Integer值的数组。
- en: ❸ Putting a string into anything array works fine.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将字符串放入任何数组中都可以正常工作。
- en: ❹ The integers array will not accept strings.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 整数数组不接受字符串。
- en: Since every object in Julia conforms to the Any type, you can put any object
    into an array where you have specified that each element must be of type Any.
    However, not every Julia object is of type Integer. Thus, putting a text string
    such as "hello" into an array where each element must be of type Integer will
    not work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Julia中的每个对象都符合Any类型，因此你可以将任何对象放入你指定每个元素必须为Any类型的数组中。然而，并非Julia中的每个对象都是Integer类型。因此，将文本字符串“hello”放入必须为Integer类型的数组中是不行的。
- en: 'How do you know what types are compatible? The value you try to store has to
    be of a type that is a subtype of the allowed element type. It turns out you can
    check this programmatically with the <: operator.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何知道哪些类型是兼容的？你尝试存储的值必须是一个允许的元素类型的子类型。实际上，你可以使用<:运算符来程序化地检查这一点。
- en: Listing 7.4 Examining which types are subtypes of each other
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 检查哪些类型是彼此的子类型
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ A string is not a kind of integer.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 字符串不是整数的一种。
- en: ❷ Float64 is a number but not an integer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Float64是一个数字，但不是一个整数。
- en: You can see from this example that types cannot be merely somewhat related (e.g.,
    floating-point numbers and integers). For example, 4.5 is a floating-point number
    but not an integer. However both Int8(4) and Int32(5) are integer numbers; they
    are subtypes of Integer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个例子中看到，类型不能仅仅是有些相关（例如，浮点数和整数）。例如，4.5是一个浮点数，但不是一个整数。然而，Int8(4)和Int32(5)都是整数；它们是Integer的子类型。
- en: That should give you a hint about the advantages of defining composite types
    to hold related data over using a dictionary. Each field can have a different
    type. That provides better type checking at runtime.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给你一些关于定义复合类型来存储相关数据的优势，而不是使用字典的优势的提示。每个字段可以有不同的类型。这提供了更好的运行时类型检查。
- en: 7.3 Creating a battle simulator
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 创建战斗模拟器
- en: To further explore these concepts, you will develop a simple simulator of battles
    between different warriors, as is frequently done in board games, card games,
    and video games.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步探索这些概念，你将开发一个简单的不同战士之间战斗的模拟器，这在桌面游戏、卡牌游戏和视频游戏中很常见。
- en: 'Many computer games work on the rock-paper-scissors principle. Let me clarify:
    there are archers, knights, and pikemen in your game, which you would set up so
    that'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 许多电脑游戏基于石头剪刀布的原则。让我澄清一下：在你的游戏中，有弓箭手、骑士和长矛兵，你会设置它们，使得
- en: archers beat pikemen,
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弓箭手打败了长矛兵，
- en: knights beat archers, and
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骑士打败了弓箭手，并且
- en: pikemen beat knights.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长矛兵打败了骑士。
- en: That is roughly how these units worked historically. Archers would fire arrows
    at slow-moving pikemen and beat them before they could get close enough to attack
    the archers. This strategy would fail with knights who could ride up to the archers
    before they managed to loosen many arrows and cut them down. However, the knights
    could not use this strategy against pikemen, as a wall of spears would prevent
    the knights from charging the pikemen, lest they get skewered.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单位在历史上的工作方式大致如此。弓箭手会向缓慢移动的长矛兵射箭，并在他们接近到足以攻击弓箭手之前击败他们。然而，如果骑士在射出大量箭矢并砍倒他们之前冲到弓箭手身边，这种策略就会失败。但是，骑士不能使用这种策略对付长矛兵，因为一堵长矛墙会阻止骑士冲锋，以免被刺穿。
- en: 'You will be implementing the following in code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在代码中实现以下内容：
- en: An abstract type Warrior for all warrior types
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个适用于所有战士类型的抽象类型Warrior
- en: Concrete warrior types Archer, Pikeman, and Knight
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体的战士类型弓箭手、长矛兵和骑士
- en: An explanation of the relation between concrete and abstract types
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体类型和抽象类型之间关系的解释
- en: Behavior for each warrior type by defining functions such as shoot! and mount!
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义如shoot!和mount!等函数来定义每种战士类型的行为
- en: An attack! function to simulate one warrior attacking another
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个攻击!函数来模拟一个战士攻击另一个战士
- en: A battle! function to simulate two warriors repeatedly attacking each other
    until one is victorious or both perish
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个战斗!函数来模拟两个战士反复攻击对方，直到一方获胜或双方都死亡
- en: 7.3.1 Defining warrior types
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 定义战士类型
- en: Make a file named warriors.jl to store the code you will develop. Start with
    a definition of the types you will use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '创建一个名为warriors.jl的文件来存储你将开发的代码。从定义你将使用的类型开始。 '
- en: Listing 7.5 Definition of types in battle simulator
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 战斗模拟器中类型的定义
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Defines an abstract type Warrior
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个抽象类型Warrior
- en: ❷ Archer defined as a mutable subtype of Warrior
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将弓箭手定义为可变子类型Warrior
- en: ❸ Knights can be mounted on a horse or on foot.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 骑士可以骑马或步行。
- en: 'The code in listing 7.5 is creating a type hierarchy illustrated below. In
    these hierarchies you make distinctions between abstract and concrete types. Archer,
    Pikeman, and Knight are examples of concrete types, while Warrior is an example
    of an abstract type. You can create objects of a concrete type but not of an abstract
    type:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5中的代码正在创建以下所示的类型层次结构。在这些层次结构中，你区分了抽象类型和具体类型。弓箭手、长矛兵和骑士是具体类型的例子，而战士是抽象类型的例子。你可以创建具体类型的对象，但不能创建抽象类型的对象：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The purpose of abstract types is to facilitate the construction of type hierarchies.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类型的目的在于促进类型层次结构的构建。
- en: In figure 7.2, I have added name and health to the Warrior type box. However,
    this is just to clarify that all subtypes are required to have these fields. Julia
    offers no syntax to enforce this. Instead, this is something you do by convention.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在图7.2中，我已将名称和健康添加到战士类型框中。然而，这只是为了说明所有子类型都必须有这些字段。Julia没有提供语法来强制执行此操作。相反，这是通过惯例来做的。
- en: '![07-02](../Images/07-02.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![07-02](../Images/07-02.png)'
- en: Figure 7.2 Warrior type hierarchy. The dark box is abstract and light boxes
    are concrete types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 战士类型层次结构。深色框是抽象类型，浅色框是具体类型。
- en: In Julia, if you define a type as abstract type it cannot have any fields. Only
    concrete types can have fields or a value. A *composite type* is a concrete type
    with fields, while a *primitive type* is a concrete type with a single value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，如果你定义一个类型为抽象类型，它不能有任何字段。只有具体类型才能有字段或值。一个*复合类型*是一个具有字段的具体系列类型，而一个*原始类型*是一个具有单个值的具体系列类型。
- en: 'The subtype operator <: is not only used to check if a type is a subtype of
    another but also to define a type as subtype:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型运算符<:不仅用于检查一个类型是否是另一个类型的子类型，还用于定义一个类型为子类型：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code snippet defines type B as a subtype of type A. In Julia, you cannot
    subtype concrete types. If you have used popular object-oriented languages such
    as Java, C++, C#, Python, or Ruby this will likely come as a surprise to you.
    If you consider the number hierarchy we have just covered this makes sense. You
    know how much space an Int32 or Float64 needs, but how many bytes of storage would
    you need to hold an Integer or Real number? You cannot know that. That is why
    most of the number types are abstract.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段将类型B定义为类型A的子类型。在Julia中，你不能将具体类型作为子类型。如果你使用过流行的面向对象语言，如Java、C++、C#、Python或Ruby，这可能会让你感到惊讶。如果你考虑我们刚刚覆盖的数字层次结构，这就有意义了。你知道Int32或Float64需要多少空间，但你需要多少字节来存储整数或实数？你不知道。这就是为什么大多数数字类型都是抽象的。
- en: 7.3.2 Adding behavior to warriors
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 为战士添加行为
- en: Warriors containing only data isn’t exciting. So you will add behavior to them
    by defining several functions with accompanying methods. Add these to the warrior.jl
    source code file (listing 7.6).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 只包含数据的战士并不令人兴奋。因此，你将通过定义几个带有相应方法的函数来为它们添加行为。将这些添加到warrior.jl源代码文件（列表7.6）中。
- en: All these functions have an exclamation mark in their name because they modify
    a field (remember, this is only a convention). That’s why the composite types
    have the mutable keyword added to their definitions. If a struct type is not defined
    as *mutable*, it will not support functions that modify a field. Without the mutable
    keyword, a composite type will default to being *immutable*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数的名字中都有一个感叹号，因为它们修改了一个字段（记住，这只是一个约定）。这就是为什么组合类型在其定义中添加了可变关键字。如果一个结构类型没有被定义为*可变*，它将不支持修改字段的函数。如果没有可变关键字，组合类型将默认为*不可变*。
- en: Listing 7.6 Adding behavior to warrior types
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6 为战士类型添加行为
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a short description of what each function does:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是每个函数的简要描述：
- en: shoot!—An archer shoots an arrow. Deplete the number of arrows by one.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shoot!—弓箭手射出一支箭。箭矢数量减少一支。
- en: resupply!—Simulate that archer gets a resupply of 24 arrows.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: resupply!—模拟弓箭手获得24支箭矢的补给。
- en: mount!—Change the state of the knight to be mounted on a horse.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mount!—改变骑士的状态，使其骑在马上。
- en: dismount!—Dismount the knight to make ready for foot combat.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dismount!—让骑士下马，为步兵战斗做准备。
- en: Mutable vs. immutable types
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可变与不可变类型
- en: 'The following is an important insight developed within the functional programming
    community: if objects cannot be modified, your program will be less likely to
    have bugs. Objects that cannot be modified are called *immutable*. If they can
    be modified, they are referred to as *mutable*.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在函数式编程社区内发展的重要见解：如果对象不能被修改，你的程序出现bug的可能性会更小。不能被修改的对象被称为*不可变*。如果它们可以被修改，则被称为*可变*。
- en: 'In older languages, objects have tended to be mutable by default. Julia follows
    a modern trend: making objects *immutable* unless explicitly marked as *mutable*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在较老的语言中，对象默认是可变的。Julia遵循一个现代趋势：除非明确标记为可变，否则对象是*不可变*的。
- en: 'With the shoot! function you can simulate how the archer will spend arrows
    in battle. Usually a medieval archer would have 24 arrows in a quiver. When those
    had been spent, the archer would need to resupply:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用shoot!函数可以模拟弓箭手在战斗中如何消耗箭矢。通常，中世纪的弓箭手在箭袋里有24支箭。当这些箭矢用完时，弓箭手需要重新补给：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Archer created with 24 arrows
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建带有24支箭的弓箭手
- en: ❷ Number of arrows left
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 剩余箭矢数量
- en: ❸ Twenty-two arrows left
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 剩余22支箭矢
- en: 'You can improve the shoot! function with a trick I use frequently when developing
    Julia software: I return the object that is most useful to see displayed when
    running a function in the REPL (see listing 7.7). When calling functions that
    modify an object, it is very useful to see what that object looks like after the
    modification. Thus, it is a good habit to return the modified object in mutating
    functions.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个技巧来改进shoot!函数，这个技巧我在开发Julia软件时经常使用：我返回在REPL中运行函数时最有用的对象（参见列表7.7）。在调用修改对象的函数时，看到修改后的对象的样子非常有用。因此，在修改函数中返回修改后的对象是一个好习惯。
- en: Listing 7.7 Modifying mutating functions to be REPL-friendly
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.7 将修改函数修改为REPL友好型
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Returns the archer object modified
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回修改后的弓箭手对象
- en: 'This makes testing functions you are developing, and checking whether they
    perform the correct operations, much simpler:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得测试你正在开发的函数，并检查它们是否执行正确的操作变得简单得多：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Show how the number of arrows is decremented.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 展示箭矢数量的减少。
- en: ❷ The number of arrows has been increased to 24.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 箭矢数量增加到24。
- en: You can use these functions to construct new functions to simulate a warrior
    attacking another. Again, add this code to the warriors.jl file. It looks as if
    you defined attack! twice. How is that possible?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些函数来构建新的函数，以模拟战士攻击另一个战士。再次，将此代码添加到warriors.jl文件中。看起来你定义了两次attack!。这是怎么做到的？
- en: Listing 7.8 Two methods for simulating battle between archers and knights
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8 模拟弓箭手与骑士之间战斗的两种方法
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Simulate an archer attacking another archer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模拟弓箭手攻击另一个弓箭手。
- en: ❷ Cannot attack if you are out of arrows
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果箭矢用尽，则无法攻击
- en: ❸ Roll a six-sided die (d6) to compute arrow damage.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 投掷一个六面骰子（d6）来计算箭矢伤害。
- en: ❹ Use max to avoid ending up with negative health.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用max避免健康值变为负数。
- en: ❺ Simulate an archer attacking a knight.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 模拟弓箭手攻击骑士。
- en: ❻ Roll a six-sided die (d6) to compute arrow damage.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 投掷一个六面骰子（d6）来计算箭矢伤害。
- en: If this was a regular dynamic language, such as JavaScript, Python, Ruby, or
    Lua, the last definition of attack! would have overwritten the first one. If this
    was a statically typed language, such as Java, C#, or C++, you would have created
    something called *function overloading* ^([4](#pgfId-1016501)). But in Julia,
    something entirely different happens.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个常规的动态语言，例如 JavaScript、Python、Ruby 或 Lua，那么 attack! 的最后一个定义将覆盖第一个定义。如果这是一个静态类型语言，例如
    Java、C# 或 C++，你将创建一个称为 *函数重载* 的东西 ^([4](#pgfId-1016501))。但在 Julia 中，发生的事情完全不同。
- en: 7.3.3 Using multiple dispatch to invoke methods
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 使用多重分派调用方法
- en: In Julia, you are not actually defining two functions but rather two *methods*
    attached to the attack! function. I know this sounds confusing, so let me break
    it down in more detail. In Julia, you actually define functions as shown in the
    following listing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，你实际上并没有定义两个函数，而是定义了两个附加到 attack! 函数的 *方法*。我知道这听起来很令人困惑，所以让我更详细地解释一下。在
    Julia 中，你实际上定义函数的方式如下所示。
- en: Listing 7.9 Function definitions in Julia without methods
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9 Julia 中没有方法的函数定义
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Functions are just names. Unless you attach methods to them, they cannot do
    anything. Start up a fresh Julia REPL, and paste the following function definitions
    along with the definitions of the Warrior, Archer, and Knight types (see listing
    7.5), and create some objects to work with:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 函数只是名称。除非你将方法附加到它们，否则它们什么也不能做。启动一个新的 Julia REPL，并将以下函数定义以及战士、弓箭手和骑士类型的定义（参见列表
    7.5）粘贴进去，然后创建一些对象来使用：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now you can try to do things with these objects and see what happens:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以尝试使用这些对象做一些事情，看看会发生什么：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Trying to call a function with no defined methods
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尝试调用没有定义方法的函数
- en: ❷ Attempting to call an undefined function
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试调用未定义的函数
- en: 'You can see from these errors that Julia distinguishes between functions you
    have not defined at all, such as mount!, and functions that are defined but have
    no methods, such as shoot! and attack!. But how do you know they don’t have any
    methods? Julia has a function called methods, which allows you to inspect how
    many methods are attached to a function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这些错误中看出，Julia 区分了你完全没有定义的函数，例如 mount!，以及定义了但没有方法的函数，例如 shoot! 和 attack!。但你怎么知道它们没有任何方法呢？Julia
    有一个名为 methods 的函数，它允许你检查附加到函数的方法数量：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Show that attack! is a function with no methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 证明 attack! 是一个没有方法的函数。
- en: ❷ mount! cannot be found by Julia.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Julia 找不到 mount!。
- en: You can see that Julia reports that attack! doesn’t have any methods. Let’s
    compare this result with loading the warriors.jl file into the REPL.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看 Julia 报告说 attack! 没有任何方法。让我们将这个结果与将 warriors.jl 文件加载到 REPL 中进行比较。
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Loads the code into the Julia REPL
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将代码加载到 Julia REPL 中
- en: Figure 7.3 illustrates what you see in the REPL. Internally, Julia has a list
    of functions. Every function enters another list containing the methods for the
    corresponding function entry. Methods can span different types, as they are not
    attached to types but to functions. Nothing prevents you from adding a shoot!
    method, which operates on a dictionary or array type.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 展示了你在 REPL 中看到的内容。在内部，Julia 有一个函数列表。每个函数都进入另一个列表，包含对应函数条目的方法。方法可以跨越不同的类型，因为它们不是附加到类型上，而是附加到函数上。没有任何东西阻止你添加一个
    shoot! 方法，该方法操作字典或数组类型。
- en: '![07-03](../Images/07-03.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![07-03](../Images/07-03.png)'
- en: Figure 7.3 How Julia attaches methods to functions. Each method handles a unique
    set of arguments.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 Julia 如何将方法附加到函数。每个方法处理一组独特的参数。
- en: 'Let’s create some objects that allow you to play around a bit:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些对象，让你可以玩一玩：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With some objects, you can experiment with using objects of different type
    when invoking the attack! function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些对象，你可以在调用 attack! 函数时使用不同类型的对象进行实验：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Attack a knight with an archer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用弓箭手攻击骑士。
- en: ❷ Health points left for attacker and defender
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 攻击者和防御者剩余的生命值
- en: ❸ Let an archer attack another archer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 让一个弓箭手攻击另一个弓箭手。
- en: ❹ Let a knight attack a knight.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 让一个骑士攻击另一个骑士。
- en: ❺ Method with closest match to the attempted call
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 与尝试调用最接近匹配的方法
- en: I advise you to experiment a bit with this yourself. You can look at how health
    points get depreciated with different attacks. To make it easier to keep track
    of how health points change, each method is set up to return a tuple with the
    health points of the attacker and defender at the end of the fight.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你自己尝试一下。你可以查看不同攻击下生命值是如何减少的。为了更容易地跟踪生命值的变化，每个方法都设置为在战斗结束时返回一个元组，包含攻击者和防御者的生命值。
- en: The interesting point here is the last part, when you try to have a battle between
    two knights. You might have noticed that we have not yet added a method for dealing
    with a fight between two knights. We add one in the following listing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的一点是最后的部分，当你尝试让两个骑士进行战斗时。你可能已经注意到，我们还没有添加处理两个骑士之间战斗的方法。我们将在下面的列表中添加一个。
- en: Listing 7.10 Method for simulating an attack by a knight against another knight
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10 模拟骑士之间攻击的方法
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can add this method to the warriors.jl file and reload it. Instead of reloading
    everything, you could just paste the definition into the REPL. Afterward, you
    will notice that having the black knight Sir Morien attack the white knight Sir
    Lancelot works fine:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此方法添加到 warriors.jl 文件中并重新加载它。你不必重新加载所有内容，只需将定义粘贴到 REPL 中即可。之后，你会注意到黑骑士莫里恩爵士攻击白骑士兰斯洛特爵士是可行的：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And you will notice that Julia reports that the attack! function has three
    methods now:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到 Julia 报告说 attack! 函数现在有三个方法：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s add another attack! method to allow archers to attack pikemen. Then you
    can see for yourself how the number of methods has changed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个 attack! 方法，允许弓箭手攻击长矛兵。然后你可以亲自看到方法数量是如何变化的。
- en: Listing 7.11 Archer attacking pikeman
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.11 箭兵攻击长矛兵
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Only allow an attack if an archer has greater than zero arrows.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 仅当弓箭手剩余箭矢大于零时才允许攻击。
- en: 7.4 How Julia selects method to call
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 Julia 如何选择调用的方法
- en: 'When you invoke attack!(a, b), Julia will find the type of every argument to
    find a tuple of all the argument types:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用攻击!(a, b)时，Julia 将找到每个参数的类型以找到所有参数类型的元组：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Julia will use this tuple of argument types to look through the list of all
    methods to find the one matching. Remember, functions don’t have code in Julia;
    methods have code. If a function doesn’t have any methods, you cannot run that
    function. This process is illustrated in figure 7.4.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 将使用这个参数类型的元组来遍历所有方法列表以找到匹配的方法。记住，在 Julia 中，函数没有代码；方法是代码。如果一个函数没有任何方法，你不能运行该函数。这个过程在图
    7.4 中得到了说明。
- en: '![07-04](../Images/07-04.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![07-04](../Images/07-04.png)'
- en: Figure 7.4 How a method is invoked using multiple-dispatch
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 使用多分派调用方法
- en: 'We assume in this example that an archer is attacking a pikeman, so the a is
    an Archer, and the b is a Pikeman. Let’s look at what happens step by step:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们假设一个弓箭手正在攻击一个长矛兵，所以 a 是一个弓箭手，b 是一个长矛兵。让我们一步一步地看看会发生什么：
- en: Julia tries to evaluate (execute) the attack!(a, b) expression in your program.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Julia 尝试评估（执行）你程序中的 attack!(a, b) 表达式。
- en: It takes the name of the function attack! and looks through a table of all functions,
    until it finds the entry for attack!.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它取函数名 attack! 并查找所有函数的表，直到找到 attack! 的条目。
- en: Julia does the equivalent of (typeof(a), typeof(b)) to get the tuple (Archer,
    Pikeman). Julia scans the list of methods stored on the attack! function from
    top to bottom, until it finds a match at the 4th entry.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Julia 做的是 (typeof(a), typeof(b)) 的等价操作，得到元组 (弓箭手, 长矛兵)。Julia 从上到下扫描存储在攻击!函数上的方法列表，直到在第
    4 个条目处找到匹配项。
- en: Julia locates the method. The method is encoded as an abstract syntax tree (AST).
    This is a common data structure^([5](#pgfId-1018127)) in dynamic languages^([6](#pgfId-1018155))
    for representing functions and methods at runtime.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Julia 定位到该方法。该方法被编码为抽象语法树（AST）。这是动态语言中用于在运行时表示函数和方法的常见数据结构^([5](#pgfId-1018127))。
- en: The Julia JIT compiler converts the AST to machine code,^([7](#pgfId-1018178))
    which gets executed. The compiled machine code gets stored in the methods table,
    so next time the attack(Archer, Pikeman) gets looked up, it can just execute cached
    machine code.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Julia JIT 编译器将 AST 转换为机器代码，^([7](#pgfId-1018178)) 然后执行。编译后的机器代码被存储在方法表中，所以下次查找
    attack(Archer, Pikeman) 时，它可以直接执行缓存的机器代码。
- en: Understanding all of this fully would require a deep dive into compiler and
    interpreter theory, which would be outside the scope of this book. Thus, the best
    way for you to think about this is that you are done at step 4\. Somehow you find
    a representation of your method you can run. The last steps are useful mainly
    to those interested in understanding why Julia has such high performance compared
    to other languages.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解这一点，需要对编译器和解释器理论进行深入研究，这超出了本书的范围。因此，你最好的思考方式是你在第 4 步就完成了。你以某种方式找到了可以运行的方法表示。最后几步主要对那些对理解为什么
    Julia 与其他语言相比有如此高性能感兴趣的人有用。
- en: ASTs for the curious
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ASTs for the curious
- en: This is not a book about compiler concepts, such as ASTs. But I will offer a
    little bit of information about them to help you understand Julia. Consider an
    expression such as
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书不是关于编译器概念，如 AST 的书。但我将提供一些关于它们的信息，以帮助您理解 Julia。考虑以下表达式
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When a compiler or interpreter reads such code it will usually turn it into
    a tree structure called an AST, like in the following figure:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器或解释器读取此类代码时，它通常会将其转换为称为 AST 的树结构，如下面的图所示：
- en: '![07-04-unnumb](../Images/07-04-unnumb.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![07-04-unnumb](../Images/07-04-unnumb.png)'
- en: AST of the expression y = 4*(2 + x)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 y = 4*(2 + x) 的 AST
- en: In Julia, every method is turned into such a tree structure. The methods table
    for each function keeps track of each of these tree structures. The Julia compiler
    uses these to create actual machine code that the computer understands.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，每个方法都会转换为这样的树结构。每个函数的方法表会跟踪这些树结构中的每一个。Julia 编译器使用这些结构来创建计算机能理解的实际机器代码。
- en: 7.4.1 Contrasting Julia’s multiple dispatch with object-oriented languages
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 对比 Julia 的多重分派与面向对象语言
- en: '*Multiple dispatch* is often confusing to developers with a background in object-oriented
    programming languages. Thus I will try to contrast the Julia approach with how
    object-oriented languages work. In an object-oriented language method, implementations
    to execute are picked based on a single argument type. That is why we call the
    approach *single dispatch*. In an object-oriented language, you would not write
    attack!(archer, knight) but the code in the following listing.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*多重分派*对于有面向对象编程语言背景的开发者来说通常很令人困惑。因此，我将尝试将 Julia 方法与面向对象语言的工作方式进行比较。在面向对象语言中，方法的实现是基于单个参数类型来选择的。这就是为什么我们称这种方法为
    *单分派*。在面向对象语言中，你不会编写 attack!(archer, knight)，而是编写以下列表中的代码。'
- en: Listing 7.12 Syntax if Julia was an object-oriented language
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.12 如果 Julia 是面向对象语言，其语法
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: While you cannot write Julia code like that, you can simulate this behavior
    in Julia.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不能像那样编写 Julia 代码，但你可以在 Julia 中模拟这种行为。
- en: Listing 7.13 Single dispatch in Julia
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.13 Julia 中的单分派
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Handle all the cases where the attacker is an Archer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理攻击者类型为 Archer 的所有情况。
- en: ❷ Handle all the cases where the attacker is a Knight.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 处理攻击者类型为 Knight 的所有情况。
- en: That illustrates the limitations of single dispatch. Because attack! methods
    can only be picked based on the first argument type, you need a long list of if-else
    statements to deal with opponents of different types. Let me clarify how single
    dispatch works with a step-by-step explanation (figure 7.5).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了单分派的局限性。因为攻击！方法只能根据第一个参数类型进行选择，所以你需要一个长的 if-else 语句列表来处理不同类型的对手。让我通过逐步解释（图
    7.5）来澄清单分派是如何工作的。
- en: When a.attack!(b) is evaluated, lookup the object referred to by a.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行 a.attack!(b) 时，查找由 a 指向的对象。
- en: On this archer object, there is a hidden field, isa, which points to the type
    of the archer object.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个弓箭手对象上，有一个隐藏的字段，isa，它指向弓箭手对象的类型。
- en: 'The type Archer is an object itself with various fields. It has fields for
    each method: shoot!, attack!, and so on. It is like a dictionary, where you use
    the function name attack! to look up the correct method.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型 Archer 是一个具有各种字段的实体。它为每个方法（如 shoot!、attack! 等）都有字段。它就像一个字典，你可以使用函数名 attack!
    来查找正确的方法。
- en: The method is an AST, which you can evaluate.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法是 AST，你可以对其进行评估。
- en: '![07-05](../Images/07-05.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![07-05](../Images/07-05.png)'
- en: Figure 7.5 How a method is invoked using single dispatch
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 使用单分派调用方法的方式
- en: So the key difference to realize with Julia is that in most mainstream languages,
    methods are stored on the type of an object, while in Julia methods are stored
    on functions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与 Julia 相关的关键区别在于，在大多数主流语言中，方法存储在对象的类型上，而在 Julia 中，方法存储在函数上。
- en: 7.4.2 How is multiple dispatch different from function overloading?
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 多重分派与函数重载有何不同？
- en: Statically typed languages, such as Java, C#, and C++, have something called
    function overloading, which looks superficially the same as multiple dispatch.
    The key difference is that with function overloading, the correct method to call
    is decided at compilation time, which means a method like the one shown in the
    following listing isn’t possible in a statically typed language.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型语言，如 Java、C# 和 C++，有一种称为函数重载的功能，其外观与多重分派相似。关键区别在于，使用函数重载时，正确的方法在编译时就已经确定，这意味着在静态类型语言中不可能有如下列表所示的方法。
- en: Listing 7.14 Writing out the outcome of a battle between two warriors
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.14 编写两位战士之间战斗的结果
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Both a and b must be subtypes of the Warrior type.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ a 和 b 必须是战士类型的子类型。
- en: 'Add this method to your warriors.jl source code file. Reload everything, and
    recreate the usual suspects, white and robin, to test out battle! in the REPL.
    Robin Hood attacks Sir Lancelot multiple times, until the health points of Lancelot
    drop low enough that battle! prints out that he has been defeated:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法添加到你的 warriors.jl 源代码文件中。重新加载一切，并重新创建白罗宾等常用角色，以在 REPL 中测试 battle!。罗宾汉多次攻击兰斯洛特爵士，直到兰斯洛特的生命值足够低，以至于
    battle! 打印出他已经被打败：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When you call battle!(robin, white), Julia will look for a method with the signature
    battle!(a::Archer, b::Knight), but this cannot be found. However battle!(a::Warrior,
    b::Warrior) is a valid match, because both Knight and Archer are subtypes of Warrior.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 battle!(robin, white) 时，Julia 会寻找具有签名 battle!(a::Archer, b::Knight) 的方法，但找不到。然而
    battle!(a::Warrior, b::Warrior) 是一个有效的匹配，因为骑士和弓箭手都是战士的子类型。
- en: When the Julia compiler compiles the battle! method, it cannot know what concrete
    type argument a and b will have. It can only know they are some subtype of Warrior.
    Thus the *compiler* cannot pick the correct attack! method to call. This decision
    can only be made at runtime. That is what makes this different from function overloading.
    Function overloading, as found in Java and C++, relies on the compiler being able
    to pick the correct method.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Julia 编译器编译 battle! 方法时，它无法知道 a 和 b 将具有什么具体类型参数。它只知道它们是战士的某个子类型。因此，*编译器*无法选择正确的
    attack! 方法来调用。这个决定只能在运行时做出。这就是它与函数重载不同的地方。函数重载，如 Java 和 C++ 中所见，依赖于编译器能够选择正确的方法。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Numbers in Julia are part of an elaborate type hierarchy.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的数字是复杂类型层次结构的一部分。
- en: In a type hierarchy, only the leaf nodes can be concrete types. All other types
    are abstract.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型层次结构中，只有叶节点可以是具体类型。所有其他类型都是抽象的。
- en: The typeof, supertype, and subtypes functions can be used to explore type hierarchies.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: typeof、supertype 和 subtypes 函数可以用来探索类型层次结构。
- en: A function is just a name. Without attached methods, they cannot do anything.
    Code is always stored inside methods. The type of the arguments determines which
    method will get executed at runtime.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数只是一个名称。没有附加的方法，它们什么也不能做。代码始终存储在方法中。参数的类型决定了在运行时哪个方法将被执行。
- en: Object-oriented languages use single dispatch, meaning only the type of the
    first function argument decides what method is selected. Julia is multiple dispatch,
    meaning *all* arguments influence which method gets selected.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的语言使用单重分派，这意味着只有第一个函数参数的类型决定选择哪个方法。Julia 是多重分派，这意味着*所有*参数都会影响选择哪个方法。
- en: A composite type, unlike a primitive type, is composed of zero or more fields.
    The struct keyword is used to define a composite type.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合类型与原始类型不同，由零个或多个字段组成。使用 struct 关键字来定义组合类型。
- en: By adding the mutable keyword to a struct definition, you allow individual fields
    in the composite to be modified at runtime.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在结构定义中添加 mutable 关键字，你可以允许在运行时修改组合类型中的单个字段。
- en: '* * *'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)Most mainstream languages today are object oriented. They are designed
    to couple behavior to types and reuse functionality through what we call *inheritance*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ^(1.)今天的大多数主流语言都是面向对象的。它们被设计为将行为与类型耦合，并通过我们所说的*继承*来重用功能。
- en: ^(2.)A *class* in object-oriented programming is a type that can be part of
    a type hierarchy and has associated functions called *methods*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ^(2.)面向对象编程中的*类*是一种可以成为类型层次结构一部分的类型，并且具有称为*方法*的关联函数。
- en: ^(3.)A *recursive function* is a function that calls itself as opposed to using
    a loop.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ^(3.)递归函数是一种函数，它调用自身而不是使用循环。
- en: ^(4.)*Function overloading* is a feature of many statically typed languages.
    It allows defining the same function multiple times with arguments of different
    types. When the code gets compiled, the compiler picks the right function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ^(4.)*函数重载*是许多静态类型语言的一个特性。它允许定义具有不同类型参数的相同函数多次。当代码被编译时，编译器会选择正确的函数。
- en: ^(5.)A *data structure* is a particular way of organizing data in a computer
    program. Arrays, strings, binary trees, linked lists, and hash tables are examples
    of data structures. But almost any composite type could be thought of as defining
    a data structure.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ^(5.)*数据结构*是计算机程序中组织数据的一种特定方式。数组、字符串、二叉树、链表和哈希表是数据结构的例子。但几乎任何组合类型都可以被认为是定义数据结构。
- en: ^(6.)In a dynamic language, you don’t have a compiler analyzing type correctness
    before a program is allowed to run. Julia has a compiler, but it is invoked at
    runtime.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: (6.)在动态语言中，在程序被允许运行之前，没有编译器分析类型正确性。Julia 有编译器，但它是在运行时调用的。
- en: ^(7.)A microprocessor doesn’t understand programming languages such as Julia
    or Java. It only understands machine code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: (7.)微处理器不理解像 Julia 或 Java 这样的编程语言。它只理解机器码。
