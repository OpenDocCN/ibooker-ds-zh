- en: Chapter 15\. Linear Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章 线性模型
- en: 'At this point in the book, we’ve covered the four stages of the data science
    lifecycle to different extents. We’ve talked about formulating questions and obtaining
    and cleaning data, and we’ve used exploratory data analysis to better understand
    the data. In this chapter, we extend the constant model introduced in [Chapter 4](ch04.html#ch-modeling)
    to the *linear model*. Linear models are a popular tool in the last stage of the
    lifecycle: understanding the world.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们已经以不同的程度涵盖了数据科学生命周期的四个阶段。我们已经讨论了如何提出问题、获取和清理数据，并使用探索性数据分析来更好地理解数据。在本章中，我们将常数模型（在[第
    4 章](ch04.html#ch-modeling)中引入）扩展为*线性模型*。线性模型是生命周期的最后阶段中的一种流行工具：理解世界。
- en: 'Knowing how to fit linear models opens the door to all kinds of useful data
    analyses. We can use these models to make *predictions*—for example, environmental
    scientists developed a linear model to predict air quality based on air sensor
    measurements and weather conditions (see [Chapter 12](ch12.html#ch-pa)). In that
    case study, understanding how measurements from two instruments varied enabled
    us to calibrate inexpensive sensors and improve their air quality readings. We
    can also use these models to make *inferences* about the form of a relationship
    between features—for example, in [Chapter 18](ch18.html#ch-donkey) we’ll see how
    veterinarians used a linear model to infer the coefficients for length and girth
    for a donkey’s weight: <math><mi>L</mi> <mi>e</mi> <mi>n</mi> <mi>g</mi> <mi>t</mi>
    <mi>h</mi>  <mo>+</mo>  <mn>2</mn> <mo>×</mo> <mi>G</mi> <mi>i</mi> <mi>r</mi>
    <mi>t</mi> <mi>h</mi>  <mo>−</mo>  <mn>175</mn></math> . In that case study, the
    model enables vets working in the field to prescribe medication for sick donkeys.
    Models can also help *describe relationships* and provide insights—for example,
    in this chapter we explore relationships between factors correlated with upward
    mobility, such as commute time, income inequality, and the quality of K–12 education.
    We carry out a descriptive analysis that follows an analysis social scientists
    have used to shape public conversation and inform policy recommendations.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何拟合线性模型为各种有用的数据分析打开了大门。我们可以使用这些模型进行*预测*——例如，环境科学家开发了一个线性模型，根据空气传感器测量和天气条件预测空气质量（参见[第
    12 章](ch12.html#ch-pa)）。在那个案例研究中，理解两个仪器测量值的变化帮助我们校准廉价传感器，并改善它们的空气质量读数。我们还可以使用这些模型来进行*推断*，例如，在[第
    18 章](ch18.html#ch-donkey)中我们将看到兽医如何使用线性模型推断驴的体重与长度和胸围的系数：<math><mi>L</mi> <mi>e</mi>
    <mi>n</mi> <mi>g</mi> <mi>t</mi> <mi>h</mi>  <mo>+</mo>  <mn>2</mn> <mo>×</mo>
    <mi>G</mi> <mi>i</mi> <mi>r</mi> <mi>t</mi> <mi>h</mi>  <mo>−</mo>  <mn>175</mn></math>。在那个案例研究中，该模型使得在现场工作的兽医能够为生病的驴子开具药物处方。模型还可以帮助*描述关系*并提供见解——例如，在本章中，我们探讨了与上升流动性相关的因素之间的关系，如通勤时间、收入不平等和
    K-12 教育质量。我们进行了描述性分析，按照社会科学家用来塑造公众对话和制定政策建议的分析方法。
- en: We start by describing the simple linear model, which summarizes the relationship
    between two features with a line. We explain how to fit this line to data using
    the loss minimization approach introduced in [Chapter 4](ch04.html#ch-modeling).
    Then we introduce the multiple linear model, which models one feature using multiple
    other features. To fit such a model, we use linear algebra and reveal the geometry
    behind fitting a linear model with squared error loss. Finally, we cover feature
    engineering techniques that let us include categorical features and transformed
    features when building models.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先描述简单线性模型，它总结了两个特征之间的关系，并用一条直线表示。我们解释如何使用在[第 4 章](ch04.html#ch-modeling)介绍的损失最小化方法来拟合这条直线到数据上。然后我们介绍多元线性模型，它使用多个其他特征来模拟一个特征。为了拟合这样的模型，我们使用线性代数，并揭示用平方误差损失拟合线性模型背后的几何学。最后，我们涵盖了特征工程技术，这些技术可以在构建模型时包括分类特征和转换特征。
- en: Simple Linear Model
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单线性模型
- en: Like with the constant model, our goal is to approximate the signal in a feature
    by a constant. Now we have additional information from a second feature to help
    us. In short, we want to use information from a second feature to make a better
    model than the constant model. For example, we might describe the sale price of
    a house by its size or predict a donkey’s weight from its length. In each of these
    examples, we have an *outcome* feature (sale price, weight) that we want to explain,
    describe, or predict with the help of an *explanatory* feature (house size, length).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像常数模型一样，我们的目标是通过常数近似特征中的信号。现在我们有来自第二特征的额外信息来帮助我们。简而言之，我们希望利用第二特征的信息制定比常数模型更好的模型。例如，我们可能会通过房屋的大小描述其销售价格，或者根据驴的长度预测其重量。在这些例子中，我们有一个*结果*特征（销售价格，重量），我们希望用*解释变量*特征（房屋大小，长度）来解释、描述或预测。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We use *outcome* to refer to the feature that we are trying to model and *explanatory*
    for the feature that we are using to explain the outcome. Different fields have
    adopted conventions for describing this relationship. Some call the outcome the
    dependent variable and the explanatory the independent variable. Others use response
    and covariate; regress and regressor; explained and explanatory; endogenous and
    exogenous. In machine learning, *target* and *features* or *predicted* and *predictors*
    are common. Unfortunately, many of these pairs connote a causal relationship.
    The notion of explaining or predicting is not necessarily meant to imply that
    one causes the other. Particularly confusing is the independent-dependent usage,
    and we recommend avoiding it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*结果*来指代我们试图建模的特征，*解释变量*来指代我们用来解释结果的特征。不同领域已经采用了描述这种关系的惯例。有些人称结果为因变量，解释变量为自变量。其他人使用响应和协变量；回归和回归器；被解释和解释性；内生和外生。在机器学习中，*目标*和*特征*或*预测*和*预测因子*是常见的。不幸的是，许多这些对都暗示了因果关系。解释或预测的概念并不一定意味着一个因素导致了另一个因素。特别令人困惑的是独立-依赖的用法，我们建议避免使用它。
- en: 'One possible model we might use is a line. Mathematically, that means we have
    an intercept, <math><msub><mi>θ</mi> <mn>0</mn></msub></math> , and a slope, <math><msub><mi>θ</mi>
    <mn>1</mn></msub></math> , and we use the explanatory feature <math><mi>x</mi></math>
    to approximate the outcome, <math><mi>y</mi></math> , by a point on the line:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会使用的一个可能模型是一条直线。数学上来说，这意味着我们有一个截距<math><msub><mi>θ</mi> <mn>0</mn></msub></math>和一个斜率<math><msub><mi>θ</mi>
    <mn>1</mn></msub></math>，并且我们使用解释特征<math><mi>x</mi></math>来通过直线上的一个点来近似结果<math><mi>y</mi></math>：
- en: <math display="block"><mi>y</mi> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi></math>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mi>y</mi> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi></math>
- en: As <math><mi>x</mi></math> changes, the estimate for <math><mi>y</mi></math>
    changes but still falls on the line. Typically, the estimate isn’t perfect, and
    there is some error in using the model; that’s why we use the symbol <math><mo>≈</mo></math>
    to mean “approximately.”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着<math><mi>x</mi></math>的变化，对<math><mi>y</mi></math>的估计也会变化，但仍然落在直线上。通常情况下，估计并不完美，使用模型会有一些误差；这就是为什么我们使用符号<math><mo>≈</mo></math>来表示“大约”。
- en: 'To find a line that does a good job of capturing the signal in the outcome,
    we use the same approach introduced in [Chapter 4](ch04.html#ch-modeling) and
    minimize the average squared loss. Specifically, we follow these steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一条能够很好地捕捉结果信号的线，我们使用了在[第 4 章](ch04.html#ch-modeling)介绍的相同方法，并最小化平均平方损失。具体来说，我们按照以下步骤进行：
- en: 'Find the errors: <math><msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo>
    <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo> <mo>,</mo>  <mi>i</mi>
    <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>…</mo> <mo>,</mo> <mi>n</mi></math>'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到误差：<math><msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo>
    <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo> <mo>,</mo>  <mi>i</mi>
    <mo>=</mo> <mn>1</mn> <mo>,</mo> <mo>…</mo> <mo>,</mo> <mi>n</mi></math>
- en: 'Square the errors (i.e., use squared loss): <math><mo stretchy="false">[</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo stretchy="false">)</mo> <msup><mo stretchy="false">]</mo>
    <mn>2</mn></msup></math>'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平方误差（即使用平方损失）：<math><mo stretchy="false">[</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo>
    <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo>
    <msup><mo stretchy="false">]</mo> <mn>2</mn></msup></math>
- en: 'Calculate the average loss over the data:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算数据的平均损失：
- en: <math display="block"><mfrac><mn>1</mn> <mi>n</mi></mfrac> <munder><mo>∑</mo>
    <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">[</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo stretchy="false">)</mo> <msup><mo stretchy="false">]</mo> <mn>2</mn></msup></math>
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math display="block"><mfrac><mn>1</mn> <mi>n</mi></mfrac> <munder><mo>∑</mo>
    <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">[</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo stretchy="false">)</mo> <msup><mo stretchy="false">]</mo> <mn>2</mn></msup></math>
- en: To fit the model, we find the slope and intercept that give us the smallest
    average loss; in other words, we minimize the *mean squared error*, or MSE for
    short. We call the minimizing values for the intercept and slope <math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub></math> and <math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub></math> .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拟合模型，我们寻找能够给出最小平均损失的斜率和截距；换句话说，我们最小化*均方误差*，简称MSE。我们称截距和斜率的最小化值为<math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub></math>和<math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub></math>。
- en: Notice that the errors we calculate in step 1 are measured in the vertical direction,
    meaning for a specific <math><mi>x</mi></math> , the error is the vertical distance
    between the data point <math><mo stretchy="false">(</mo> <mi>x</mi> <mo>,</mo>
    <mi>y</mi> <mo stretchy="false">)</mo></math> and the point on the line <math><mo
    stretchy="false">(</mo> <mi>x</mi> <mo>,</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo stretchy="false">)</mo></math>
    . [Figure 15-1](#fig-slr) shows this notion. On the left is a scatterplot of points
    with a line used to estimate <math><mi>y</mi></math> from <math><mi>x</mi></math>
    . We have marked two specific points by squares and their corresponding approximations
    on the line by diamonds. The dotted segment from the actual point to the line
    shows the error. The plot on the right is a scatterplot of all the errors; for
    reference, we marked the errors corresponding to the two square points in the
    left plot with squares in the right plot as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在步骤1中计算的误差是沿垂直方向测量的，这意味着对于特定的<math><mi>x</mi></math>，误差是数据点<math><mo stretchy="false">(</mo>
    <mi>x</mi> <mo>,</mo> <mi>y</mi> <mo stretchy="false">)</mo></math>与线上点<math><mo
    stretchy="false">(</mo> <mi>x</mi> <mo>,</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo stretchy="false">)</mo></math>之间的垂直距离。[图 15-1](#fig-slr)展示了这一概念。左侧是点的散点图，带有用于从<math><mi>x</mi></math>估计<math><mi>y</mi></math>的直线。我们用方块标记了两个特定点，并用菱形表示它们在直线上的估计值。从实际点到直线的虚线段显示了误差。右侧的图是所有误差的散点图；作为参考，我们还标记了左图中两个方块点对应的误差在右图中也用方块标记了。
- en: '![](assets/leds_1501.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_1501.png)'
- en: 'Figure 15-1\. On the left is a scatterplot of <math><mo stretchy="false">(</mo>
    <msub><mi>x</mi> <mi>i</mi></msub> <mo>,</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo stretchy="false">)</mo></math> pairs and a line that we use to estimate <math><mi>y</mi></math>
    from <math><mi>x</mi></math> . Two specific points are represented by squares
    and their estimates by diamonds. On the right is a scatterplot of the errors:
    <math><msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo>
    <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo></math> .'
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-1\. 左侧是<math><mo stretchy="false">(</mo> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>,</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo></math>对的散点图和我们用于从<math><mi>x</mi></math>估计<math><mi>y</mi></math>的直线。具体的两个点用方块表示，它们的估计值用菱形表示。右侧是误差的散点图：<math><msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo stretchy="false">)</mo></math>。
- en: 'Later in this chapter, we derive the values <math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub></math> and <math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub></math> that minimize
    the mean squared error. We show that these are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们推导出使均方误差最小化的值 <math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub></math> 和 <math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></math>。我们表明这些值分别为：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub></mtd> <mtd><mo>=</mo>
    <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo>
    <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub>
    <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow></mtd></mtr>
    <mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></mtd> <mtd><mo>=</mo> <mi>r</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi
    mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo> <mfrac><mrow><mi>S</mi>
    <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub></mtd> <mtd><mo>=</mo>
    <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo>
    <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub>
    <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow></mtd></mtr>
    <mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></mtd> <mtd><mo>=</mo> <mi>r</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi
    mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo> <mfrac><mrow><mi>S</mi>
    <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: Here, <math><mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow></math> represents
    the values <math><msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo> <mo>…</mo> <mo>,</mo>
    <msub><mi>x</mi> <mi>n</mi></msub></math> and <math><mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow></math>
    is similarly defined; <math><mi>r</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi
    mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo></math> is the correlation coefficient of the <math><mo
    stretchy="false">(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>,</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo stretchy="false">)</mo></math> pairs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，<math><mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow></math> 表示值
    <math><msub><mi>x</mi> <mn>1</mn></msub> <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>x</mi>
    <mi>n</mi></msub></math>，而 <math><mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow></math>
    类似定义；<math><mi>r</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow>
    <mo>,</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo></math>
    是 <math><mo stretchy="false">(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>,</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo></math> 对的相关系数。
- en: 'Putting the two together, the equation for the line becomes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将两者结合起来，线性方程变为：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub> <mo>+</mo> <msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub> <mi>x</mi></mtd>
    <mtd><mo>=</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>+</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mi>x</mi></mtd></mtr> <mtr><mtd><mo>=</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo>+</mo> <mi>r</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi
    mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo> <mi>S</mi>
    <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo> <mfrac><mrow><mo stretchy="false">(</mo> <mi>x</mi>
    <mo>−</mo> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub> <mo>+</mo> <msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub> <mi>x</mi></mtd>
    <mtd><mo>=</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>+</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mi>x</mi></mtd></mtr> <mtr><mtd><mo>=</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo>+</mo> <mi>r</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi
    mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo> <mi>S</mi>
    <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo> <mfrac><mrow><mo stretchy="false">(</mo> <mi>x</mi>
    <mo>−</mo> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: 'This equation has a nice interpretation: for a given <math><mi>x</mi></math>
    value, we find how many standard deviations above (or below) average it is, and
    then we predict (or explain, depending on the setting) <math><mi>y</mi></math>
    to be <math><mi>r</mi></math> times as many standard deviations above (or below)
    its average.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程有一个很好的解释：对于给定的 <math><mi>x</mi></math> 值，我们找出其高出（或低于）平均值多少个标准偏差，然后预测（或解释，具体取决于环境）
    <math><mi>y</mi></math> 将是 <math><mi>r</mi></math> 倍的标准偏差高出（或低于）其平均值。
- en: 'We see from the expression for the optimal line that the *sample correlation
    coefficient* plays an important role. Recall that <math><mi>r</mi></math> measures
    the strength of the linear association and is defined as:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从最优线的表达式中我们看到 *样本相关系数* 发挥了重要作用。回想一下，<math><mi>r</mi></math> 衡量了线性关联的强度，定义如下：
- en: <math display="block"><mi>r</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi
    mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo> <mo>=</mo> <munder><mo>∑</mo> <mi>i</mi></munder>
    <mfrac><mrow><mo stretchy="false">(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>−</mo>
    <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow> <mo stretchy="false">)</mo></mrow>
    <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow>
    <mo stretchy="false">)</mo></mrow></mfrac> <mfrac><mrow><mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></math>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mi>r</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi
    mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo> <mo>=</mo> <munder><mo>∑</mo> <mi>i</mi></munder>
    <mfrac><mrow><mo stretchy="false">(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>−</mo>
    <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow> <mo stretchy="false">)</mo></mrow>
    <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow>
    <mo stretchy="false">)</mo></mrow></mfrac> <mfrac><mrow><mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></math>
- en: 'Here are a few important features of the correlation that help us fit linear
    models:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有助于我们拟合线性模型的相关性的几个重要特征：
- en: '<math><mi>r</mi></math> is unitless. Notice that <math><mi>x</mi></math> ,
    <math><mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow></math>
    , and <math><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi
    mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></math> all
    have the same units, so the following ratio has no units (and likewise for the
    terms involving <math><msub><mi>y</mi> <mi>i</mi></msub></math> ):'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math><mi>r</mi></math> 是无量纲的。注意，<math><mi>x</mi></math>，<math><mrow><mover><mi>x</mi>
    <mo stretchy="false">¯</mo></mover></mrow></math> 和 <math><mi>S</mi> <mi>D</mi>
    <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow>
    <mo stretchy="false">)</mo></math> 都有相同的单位，所以下面的比率是无单位的（涉及 <math><msub><mi>y</mi>
    <mi>i</mi></msub></math> 的项同理）：
- en: <math display="block"><mfrac><mrow><mo stretchy="false">(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></math>
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <math display="block"><mfrac><mrow><mo stretchy="false">(</mo> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></math>
- en: <math><mi>r</mi></math> is between <math><mo>−</mo> <mn>1</mn></math> and <math><mo>+</mo>
    <mn>1</mn></math> . Only when all of the points fall exactly along a line is the
    correlation either <math><mo>+</mo> <mn>1</mn></math> or <math><mo>−</mo> <mn>1</mn></math>
    , depending on whether the slope of the line is positive or negative.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math><mi>r</mi></math> 介于 <math><mo>−</mo> <mn>1</mn></math> 和 <math><mo>+</mo>
    <mn>1</mn></math> 之间。只有当所有点恰好位于一条直线上时，相关性才为 <math><mo>+</mo> <mn>1</mn></math>
    或 <math><mo>−</mo> <mn>1</mn></math> ，具体取决于线的斜率是正还是负。
- en: <math><mi>r</mi></math> measures the strength of a linear association, not whether
    or not the data have a linear association. The four scatterplots in [Figure 15-2](#fig-anscombequartet)
    all have the same correlation coefficient of about <math><mn>0.8</mn></math> (as
    well as the same averages and standard deviations), but only one plot, the one
    on the top left, has what we think of as a linear association with random errors
    about the line.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <math><mi>r</mi></math> 衡量线性关联的强度，而不是数据是否具有线性关联。[图 15-2](https://example.org/fig-anscombequartet)
    中的四个散点图都有约为 <math><mn>0.8</mn></math> 的相同相关系数（以及相同的平均值和标准偏差），但只有一个图，即左上角的那个，具有我们认为的带有随机误差的线性关联。
- en: '![](assets/leds_1502.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_1502.png)'
- en: Figure 15-2\. These four sets of points, known as Anscombe’s quartet, have the
    same correlation of 0.8, and the same means and standard deviations. The plot
    in the top left exhibits a linear association; top right shows a perfect nonlinear
    association; bottom left, with the exception of one point, is a perfect linear
    association; and bottom right, with the exception of one point, has no association.
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-2。这四组点，称为安斯康姆的四分位数，具有相同的相关性0.8，以及相同的均值和标准差。左上角的图表展示线性关联；右上角显示完美的非线性关联；左下角除了一个点外，是完美的线性关联；右下角除了一个点外，没有关联。
- en: Again, we do not expect the pairs of data points to fall exactly along a line,
    but we do expect the scatter of points to be reasonably described by the line,
    and we expect the deviations between <math><msub><mi>y</mi> <mi>i</mi></msub></math>
    and the estimate <math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub> <mo>+</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub></math> to be roughly symmetrically
    distributed about the line with no apparent patterns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们不希望数据点对精确地落在一条直线上，但我们期望点的分布能被直线合理描述，并且我们期望<math><msub><mi>y</mi> <mi>i</mi></msub></math>与估计值<math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub> <mo>+</mo> <msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub></math>之间的偏差大致对称分布在直线周围，并且没有明显的模式。
- en: Linear models were introduced in [Chapter 12](ch12.html#ch-pa), where we used
    the relationship between measurements from high-quality air monitors operated
    by the Environmental Protection Agency and neighboring inexpensive air quality
    monitors to calibrate the inexpensive monitors for more accurate predictions.
    We revisit that example to make the notion of a simple linear model more concrete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 线性模型是在[第12章](ch12.html#ch-pa)介绍的，我们在那里使用了由环境保护局操作的高质量空气监测器与邻近的廉价空气质量监测器之间的关系来校准廉价监测器，以进行更准确的预测。我们重新审视那个例子，以使简单的线性模型概念更加具体。
- en: 'Example: A Simple Linear Model for Air Quality'
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：空气质量的简单线性模型
- en: 'Recall from [Chapter 12](ch12.html#ch-pa) that our aim is to use air quality
    measurements from the accurate Air Quality System (AQS) sensors operated by the
    US government to predict the measurements made by PurpleAir (PA) sensors. The
    pairs of data values come from neighboring instruments that measure the average
    daily concentration of particulate matter in the air on the same day. (The unit
    of measurement is an average count of particles under 2.5 mm in size per cubic
    liter of air in a 24-hour period.) In this section, we focus on air quality measurements
    at one location in Georgia. These are a subset of the data we examined in the
    case study in [Chapter 12](ch12.html#ch-pa). The measurements are daily averages
    from August 2019 to mid-November 2019:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请回想一下[第12章](ch12.html#ch-pa)，我们的目标是利用美国政府操作的精确空气质量系统（AQS）传感器的空气质量测量来预测由PurpleAir（PA）传感器进行的测量。数据值对来自同一天测量的邻近仪器，测量空气中直径小于2.5mm颗粒物的平均每日浓度。（测量单位是每立方升空气中的24小时内颗粒物的平均计数。）在本节中，我们关注乔治亚州一个位置的空气质量测量。这些是我们在[第12章](ch12.html#ch-pa)案例研究中检验的数据子集。这些测量是2019年8月至2019年11月中旬的日均值：
- en: '|   | date | id | region | pm25aqs | pm25pa |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|   | 日期 | id | 区域 | pm25aqs | pm25pa |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **5258** | 2019-08-02 | GA1 | Southeast | 8.65 | 16.19 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **5258** | 2019-08-02 | GA1 | 东南 | 8.65 | 16.19 |'
- en: '| **5259** | 2019-08-03 | GA1 | Southeast | 7.70 | 13.59 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **5259** | 2019-08-03 | GA1 | 东南 | 7.70 | 13.59 |'
- en: '| **5260** | 2019-08-04 | GA1 | Southeast | 6.30 | 10.30 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **5260** | 2019-08-04 | GA1 | 东南 | 6.30 | 10.30 |'
- en: '| **...** | ... | ... | ... | ... | ... |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... | ... |'
- en: '| **5439** | 2019-10-18 | GA1 | Southeast | 6.30 | 12.94 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **5439** | 2019-10-18 | GA1 | 东南 | 6.30 | 12.94 |'
- en: '| **5440** | 2019-10-21 | GA1 | Southeast | 7.50 | 13.62 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **5440** | 2019-10-21 | GA1 | 东南 | 7.50 | 13.62 |'
- en: '| **5441** | 2019-10-30 | GA1 | Southeast | 5.20 | 14.55 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **5441** | 2019-10-30 | GA1 | 东南 | 5.20 | 14.55 |'
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The feature `pm25aqs` contains measurements from the AQS sensor and `pm25pa`
    from the PurpleAir monitor. Since we are interested in studying how well the AQS
    measurements predict the PurpleAir measurements, our scatterplot places PurpleAir
    readings on the y-axis and AQS readings on the x-axis. We also add a trend line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 特征`pm25aqs`包含来自AQS传感器的测量值，`pm25pa`来自PurpleAir监测器。由于我们有兴趣研究AQS测量如何预测PurpleAir测量，我们的散点图将PurpleAir读数放在y轴上，AQS读数放在x轴上。我们还添加了趋势线：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](assets/leds_15in01.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in01.png)'
- en: 'This scatterplot shows a linear relationship between the measurements from
    these two kinds of instruments. The model that we want to fit has the following
    form:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个散点图显示了这两种仪器测量值之间的线性关系。我们要拟合的模型具有以下形式：
- en: <math display="block"><mi>P</mi> <mi>A</mi> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>A</mi> <mi>Q</mi></math>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mi>P</mi> <mi>A</mi> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>A</mi> <mi>Q</mi></math>
- en: where <math><mi>P</mi> <mi>A</mi></math> refers to the PurpleAir average daily
    measurement and <math><mi>A</mi> <mi>Q</mi></math> to its partner AQS measurement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<math><mi>P</mi> <mi>A</mi></math>表示PurpleAir的平均日测量值，<math><mi>A</mi> <mi>Q</mi></math>表示其伙伴AQS的测量值。
- en: 'Since `pandas.Series` objects have built-in methods to compute standard deviations
    (SDs) and correlation coefficients, we can quickly define functions that calculate
    the best-fitting line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pandas.Series`对象具有计算标准偏差（SDs）和相关系数的内置方法，因此我们可以快速定义计算最佳拟合线的函数：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can fit the model by computing <math><msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub></math> and <math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub></math> for these
    data:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过计算这些数据的<math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub></math>和<math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></math>来拟合模型：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This model matches the trend line shown in the scatterplot. That’s not by accident.
    The parameter value for `trendline` in the call to `scatter()` is `"ols"`, which
    stands for *ordinary least squares*, another name for fitting a linear model by
    minimizing squared error.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型与散点图中显示的趋势线相匹配。这并非偶然。在调用`scatter()`时，`trendline`的参数值为`"ols"`，表示*普通最小二乘法*，即通过最小化平方误差来拟合线性模型的另一个名称。
- en: 'Let’s examine the errors. First, we find the predictions for PA measurements
    given the AQS measurements, and then we calculate the errors—the difference between
    the actual PA measurements and the predictions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下误差。首先，我们找出了给定AQS测量值的PA测量值的预测值，然后计算误差—实际PA测量值与预测值之间的差异：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s plot these errors against the predicted values:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些误差绘制成预测值的图：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](assets/leds_15in02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in02.png)'
- en: An error of 0 means that the actual measurement falls on the fitted line; we
    also call this line the *least squares line* or the *regression line*. A positive
    value means it is above the line, and negative means it’s below. You might be
    wondering how good this model is and what it says about our data. We consider
    these topics next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 误差为0意味着实际测量值落在拟合线上；我们也称这条线为*最小二乘线*或*回归线*。正值意味着它在线上方，负值意味着它在线下方。你可能想知道这个模型有多好，以及它对我们的数据说了什么。我们接下来考虑这些话题。
- en: Interpreting Linear Models
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释线性模型
- en: The original scatterplot of paired measurements shows that the PurpleAir recordings
    are often quite a bit higher than the more accurate AQS measurements. Indeed,
    the equation for our simple line model has a slope of about 2.1\. We interpret
    the slope to mean that a change of 1 ppm measured by the AQS monitor is associated
    with a change of 2 ppm in the PA measurement, on average. So, if on one day the
    AQS sensor measures 10 ppm and on the next day it is 5 ppm higher, namely 15 ppm,
    then our prediction for the PA measurement increases from one day to the next
    by <math><mn>2</mn> <mo>×</mo> <mn>5</mn> <mo>=</mo> <mn>10</mn></math> ppm.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的成对测量散点图显示，PurpleAir记录往往比更准确的AQS测量值要高得多。事实上，我们简单线性模型的方程的斜率约为2.1。我们解释斜率意味着AQS监视器测得的1
    ppm的变化平均对应于PA测量的2 ppm的变化。因此，如果一天AQS传感器测量10 ppm，第二天它高出5 ppm，即15 ppm，那么我们对于下一天的PA测量的预测将增加<math><mn>2</mn>
    <mo>×</mo> <mn>5</mn> <mo>=</mo> <mn>10</mn></math> ppm。
- en: Any change in the PurpleAir reading is not caused by the change in the AQS reading.
    Rather, they both reflect the air quality, and our model captures the relationship
    between the two devices. Oftentimes, the term *prediction* is taken to mean *causation*,
    but that is not the case here. Instead, the prediction just refers to our use
    of the *linear association* between PA and AQS measurements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 任何PurpleAir读数的变化都不是由AQS读数的变化引起的。相反，它们都反映了空气质量，而我们的模型捕捉了这两个设备之间的关系。通常情况下，术语*预测*被认为是*因果关系*，但在这里并非如此。相反，预测只是指我们对PA和AQS测量之间*线性关联*的使用。
- en: As for the intercept in the model, we might expect it to be 0, since when there
    is no particulate matter in the air we would think that both instruments would
    measure 0 ppm. But for an AQS of 0, the model predicts <math><mo>−</mo> <mn>3.4</mn></math>
    ppm for PurpleAir, which doesn’t make sense. There can’t be negative amounts of
    particles in the air. This highlights the problem of using the model outside the
    range where measurements were taken. We observed AQS recordings between 3 and
    18 ppm, and in this range the model fits well. While it makes sense for the line
    to have an intercept of 0, such a model doesn’t fit well in a practical sense
    and the predictions tend to be much worse.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 至于模型中的截距，我们可能期望它为0，因为当空气中没有颗粒物时，我们认为两个仪器都应该测量0 ppm。但对于AQS为0的情况，模型预测PurpleAir为<math><mo>−</mo>
    <mn>3.4</mn></math> ppm，这是没有意义的。空气中不可能有负的颗粒物。这突显了在超出测量范围时使用模型的问题。我们观察到AQS记录在3到18
    ppm之间，并且在这个范围内，模型拟合良好。虽然在理论上线应该有一个截距为0，但在实际中这样的模型却不适用，预测往往会差得多。
- en: 'George Box, a renowned statistician, famously said, “All models are wrong,
    but some are useful.” Here is a case where despite the intercept of the line not
    passing through 0, the simple linear model is useful in predicting air quality
    measurements for a PurpleAir sensor. Indeed, the correlation between our two features
    is very high:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 著名统计学家George Box曾经说过：“所有模型都是错误的，但有些是有用的。” 在这里，尽管线的截距不通过0，但简单线性模型在预测PurpleAir传感器的空气质量测量方面是有用的。事实上，我们两个特征之间的相关性非常高：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|   | pm25aqs | pm25pa |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|   | pm25aqs | pm25pa |'
- en: '| --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **pm25aqs** | 1.00 | 0.92 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **pm25aqs** | 1.00 | 0.92 |'
- en: '| **pm25pa** | 0.92 | 1.00 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **pm25pa** | 0.92 | 1.00 |'
- en: Aside from looking at correlation coefficients, there are other ways to assess
    the quality of a linear model.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了查看相关系数之外，还有其他评估线性模型质量的方法。
- en: Assessing the Fit
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估拟合
- en: The earlier plot of the errors against the fitted values gives a visual assessment
    of the quality of the fit. (This plot is called a *residual plot* because the
    errors are sometimes referred to as *residuals*.) A good fit should show a cloud
    of points around the horizontal line at 0 with no clear pattern. When there is
    a pattern, we can usually conclude that the simple linear model doesn’t entirely
    capture the signal. We saw earlier that there are no apparent patterns in the
    residual plot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的误差图针对拟合值给出了拟合质量的视觉评估。（这种图称为*残差图*，因为误差有时被称为*残差*。）一个良好的拟合应该显示一群点围绕着0的水平线，没有明显的模式。当出现模式时，我们通常可以得出简单线性模型并没有完全捕捉到信号的结论。我们之前看到残差图中没有明显的模式。
- en: 'Another type of residual plot that can be useful is a plot of the residuals
    against a feature that is not in the model. If we see a pattern, then we may want
    to include this feature in the model, in addition to the feature(s) already in
    the model. Also, when the data have a time component, we want to check for patterns
    in the residuals over time. For these particular data, since the measurements
    are daily averages over a four-month period, we plot the error against the date
    the measurement is recorded:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的残差图类型是残差与不在模型中的特征的图。如果我们看到模式，那么我们可能希望在模型中加入这个特征，除了已经在模型中的特征之外。此外，当数据具有时间组成部分时，我们希望检查残差随时间的模式。对于这些特定的数据，由于测量是在四个月内的每日平均值，我们将错误绘制为测量记录日期：
- en: '![](assets/leds_15in03.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in03.png)'
- en: It looks like there are a few consecutive days near the end of August and again
    near the end of September where the data are far below what is expected. Looking
    back at the original scatterplot (and the first residual plot), we can see two
    small clusters of horizontal points below the main point cloud. The plot we just
    made indicates that we should check the original data and any available information
    about the equipment to determine whether it was properly functioning on those
    days.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来在八月底和九月底附近有几天数据远低于预期。回顾原始散点图（以及第一个残差图），我们可以看到两个小的水平点簇在主要点云下方。我们刚刚制作的图表表明，我们应该检查原始数据以及关于设备的任何可用信息，以确定这些天是否正常运行。
- en: 'The residual plot can also give us a general sense of how accurate the model
    is in its predictions. Most of the errors lie between <math><mo>±</mo> <mn>6</mn></math>
    ppm of the line. And we find the standard deviation of the errors to be about
    2.8 ppm:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 残差图还可以让我们大致了解模型在预测中的准确性。大多数误差在线路的 <math><mo>±</mo> <mn>6</mn></math> ppm 之间。我们发现误差的标准偏差约为
    2.8 ppm：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In comparison, the standard deviation of the PurpleAir measurements is quite
    a bit larger:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，PurpleAir 测量的标准偏差要大得多：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The model error may be further reduced if we find the monitor wasn’t working
    on those days in late August and September and so exclude them from the dataset.
    In any event, for situations where the air is quite clean, the error is relatively
    large, but in absolute terms it is inconsequential. We are typically more concerned
    about the case when there is air pollution, and in that case, an error of 2.8
    ppm seems reasonable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现监测器在八月底和九月份的某些日子不工作，并因此将其排除在数据集之外，可能会进一步减少模型误差。无论如何，在空气非常清洁的情况下，误差相对较大，但在绝对值上并不重要。我们通常更关心空气污染的情况，此时
    2.8 ppm 的误差似乎是合理的。
- en: Let’s return to the process of how to find this line, the process of *model
    fitting*. In the next section, we derive the intercept and slope by minimizing
    the mean squared error.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到如何找到这条线的过程，即*模型拟合*的过程。在接下来的部分，我们通过最小化均方误差来推导截距和斜率。
- en: Fitting the Simple Linear Model
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拟合简单线性模型
- en: 'We stated earlier in this chapter that when we minimize the average loss over
    the data:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早些时候提到，当我们最小化数据的平均损失时：
- en: <math display="block"><mfrac><mn>1</mn> <mi>n</mi></mfrac> <munder><mo>∑</mo>
    <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">[</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo stretchy="false">)</mo> <msup><mo stretchy="false">]</mo> <mn>2</mn></msup></math>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mfrac><mn>1</mn> <mi>n</mi></mfrac> <munder><mo>∑</mo>
    <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">[</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo stretchy="false">)</mo> <msup><mo stretchy="false">]</mo> <mn>2</mn></msup></math>
- en: 'the best-fitting line has intercept and slope:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳拟合线具有截距和斜率：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub></mtd> <mtd><mo>=</mo>
    <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo>
    <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub>
    <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow></mtd></mtr>
    <mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></mtd> <mtd><mo>=</mo> <mi>r</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi
    mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo> <mfrac><mrow><mi>S</mi>
    <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub></mtd> <mtd><mo>=</mo>
    <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow> <mo>−</mo>
    <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub>
    <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow></mtd></mtr>
    <mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></mtd> <mtd><mo>=</mo> <mi>r</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi
    mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo> <mfrac><mrow><mi>S</mi>
    <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: In this section, we use calculus to derive these results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用微积分来推导这些结果。
- en: 'With the simple linear model, the mean squared error is a function of two model
    parameters, the intercept and slope. This means that if we use calculus to find
    the minimizing parameter values, we need to find the partial derivatives of the
    MSE with respect to <math><msub><mi>θ</mi> <mn>0</mn></msub></math> and <math><msub><mi>θ</mi>
    <mn>1</mn></msub></math> . We can also find these minimizing values through other
    techniques:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单线性模型，均方误差是两个模型参数的函数，即截距和斜率。这意味着如果我们使用微积分来找到最小化的参数值，我们需要找到均方误差对 <math><msub><mi>θ</mi>
    <mn>0</mn></msub></math> 和 <math><msub><mi>θ</mi> <mn>1</mn></msub></math> 的偏导数。我们也可以通过其他技术找到这些最小值：
- en: '*Gradient descent*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*梯度下降*'
- en: We can use numerical optimization techniques, such as gradient descent, when
    the loss function is more complex and it’s faster to find an approximate solution
    that’s pretty accurate (see [Chapter 20](ch20.html#ch-gd)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当损失函数更复杂且找到近似解更快时，我们可以使用数值优化技术，如梯度下降（参见 [第20章](ch20.html#ch-gd)）。
- en: '*Quadratic formula*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*二次公式*'
- en: Since the average loss is a quadratic function of <math><msub><mi>θ</mi> <mn>0</mn></msub></math>
    and <math><msub><mi>θ</mi> <mn>1</mn></msub></math> , we can use the quadratic
    formula (along with some algebra) to solve for the minimizing parameter values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于平均损失是关于 <math><msub><mi>θ</mi> <mn>0</mn></msub></math> 和 <math><msub><mi>θ</mi>
    <mn>1</mn></msub></math> 的二次函数，我们可以使用二次公式（以及一些代数）来求解最小化参数值。
- en: '*Geometric argument*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*几何论证*'
- en: Later in this chapter, we use a geometric interpretation of least squares to
    fit multiple linear models. This approach relates to the Pythagorean theorem and
    has several intuitive benefits.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们使用最小二乘法的几何解释来拟合多元线性模型。这种方法与毕达哥拉斯定理相关，并具有几个直观的优点。
- en: 'We choose calculus to optimize the simple linear model since it is quick and
    straightforward. To begin, we take the partial derivatives of the sum of squared
    errors with respect to each parameter (we can ignore the e <math><mn>1</mn> <mrow><mo>/</mo></mrow>
    <mi>n</mi></math> in the MSE because it doesn’t affect the location of the minimum):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用微积分来优化简单线性模型，因为这是快速且直接的方法。首先，我们对平方误差的偏导数进行计算（我们可以忽略 MSE 中的 e <math><mn>1</mn>
    <mrow><mo>/</mo></mrow> <mi>n</mi></math> ，因为它不影响最小值的位置）：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mfrac><mi>∂</mi> <mrow><mi>∂</mi>
    <msub><mi>θ</mi> <mn>0</mn></msub></mrow></mfrac> <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder>
    <mo stretchy="false">[</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mo
    stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo>
    <msup><mo stretchy="false">]</mo> <mn>2</mn></msup></mtd> <mtd><mo>=</mo> <munder><mo>∑</mo>
    <mrow><mi>i</mi></mrow></munder> <mn>2</mn> <mo stretchy="false">(</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>−</mo> <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo>
    <mo stretchy="false">(</mo> <mo>−</mo> <mn>1</mn> <mo stretchy="false">)</mo></mtd></mtr>
    <mtr><mtd><mfrac><mi>∂</mi> <mrow><mi>∂</mi> <msub><mi>θ</mi> <mn>1</mn></msub></mrow></mfrac>
    <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">[</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo stretchy="false">)</mo> <msup><mo stretchy="false">]</mo>
    <mn>2</mn></msup> <mo>,</mo></mtd> <mtd><mo>=</mo> <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder>
    <mn>2</mn> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo>
    <msub><mi>θ</mi> <mn>0</mn></msub> <mo>−</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo> <mo stretchy="false">(</mo>
    <mo>−</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mfrac><mi>∂</mi> <mrow><mi>∂</mi>
    <msub><mi>θ</mi> <mn>0</mn></msub></mrow></mfrac> <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder>
    <mo stretchy="false">[</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mo
    stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo>
    <msup><mo stretchy="false">]</mo> <mn>2</mn></msup></mtd> <mtd><mo>=</mo> <munder><mo>∑</mo>
    <mrow><mi>i</mi></mrow></munder> <mn>2</mn> <mo stretchy="false">(</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>−</mo> <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo>
    <mo stretchy="false">(</mo> <mo>−</mo> <mn>1</mn> <mo stretchy="false">)</mo></mtd></mtr>
    <mtr><mtd><mfrac><mi>∂</mi> <mrow><mi>∂</mi> <msub><mi>θ</mi> <mn>1</mn></msub></mrow></mfrac>
    <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">[</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo stretchy="false">)</mo> <msup><mo stretchy="false">]</mo>
    <mn>2</mn></msup> <mo>,</mo></mtd> <mtd><mo>=</mo> <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder>
    <mn>2</mn> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo>
    <msub><mi>θ</mi> <mn>0</mn></msub> <mo>−</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo> <mo stretchy="false">(</mo>
    <mo>−</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: 'Then we set the partial derivatives equal to 0 and simplify a bit by multiplying
    both sides of the equations by <math><mo>−</mo> <mn>1</mn> <mrow><mo>/</mo></mrow>
    <mn>2</mn></math> to get:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将偏导数设为零，并通过将方程两边乘以 <math><mo>−</mo> <mn>1</mn> <mrow><mo>/</mo></mrow> <mn>2</mn></math>
    进行简化，得到：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mn>0</mn></mtd> <mtd><mo>=</mo>
    <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub> <mo>−</mo> <msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mo>=</mo> <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub> <mo>−</mo> <msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo stretchy="false">)</mo> <msub><mi>x</mi> <mi>i</mi></msub></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mn>0</mn></mtd> <mtd><mo>=</mo>
    <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub> <mo>−</mo> <msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mn>0</mn></mtd>
    <mtd><mo>=</mo> <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub> <mo>−</mo> <msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo stretchy="false">)</mo> <msub><mi>x</mi> <mi>i</mi></msub></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: 'These equations are called the *normal equations*. In the first equation, we
    see that <math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub></math> can be represented as a function of <math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub></math> :'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程式称为*正规方程式*。在第一个方程中，我们看到<math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub></math>可以表示为<math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></math>的函数：
- en: <math display="block"><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub> <mo>=</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow></math>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub> <mo>=</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow></math>
- en: 'Plugging this value into the second equation gives us:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个值代入第二个方程中给出我们：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mn>0</mn></mtd> <mtd><mo>=</mo>
    <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>+</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo>
    <msub><mi>x</mi> <mi>i</mi></msub></mtd></mtr> <mtr><mtd><mo>=</mo> <munder><mo>∑</mo>
    <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">[</mo> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mo stretchy="false">(</mo> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>−</mo> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo stretchy="false">]</mo> <msub><mi>x</mi> <mi>i</mi></msub></mtd></mtr>
    <mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></mtd> <mtd><mo>=</mo> <mfrac><mrow><munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo stretchy="false">)</mo> <msub><mi>x</mi>
    <mi>i</mi></msub></mrow> <mrow><munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder>
    <mo stretchy="false">(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>x</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo stretchy="false">)</mo> <msub><mi>x</mi>
    <mi>i</mi></msub></mrow></mfrac></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mn>0</mn></mtd> <mtd><mo>=</mo>
    <munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>+</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub> <mo stretchy="false">)</mo>
    <msub><mi>x</mi> <mi>i</mi></msub></mtd></mtr> <mtr><mtd><mo>=</mo> <munder><mo>∑</mo>
    <mrow><mi>i</mi></mrow></munder> <mo stretchy="false">[</mo> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo>−</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mo stretchy="false">(</mo> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>−</mo> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo> <mo stretchy="false">]</mo> <msub><mi>x</mi> <mi>i</mi></msub></mtd></mtr>
    <mtr><mtd><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></mtd> <mtd><mo>=</mo> <mfrac><mrow><munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>y</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo stretchy="false">)</mo> <msub><mi>x</mi>
    <mi>i</mi></msub></mrow> <mrow><munder><mo>∑</mo> <mrow><mi>i</mi></mrow></munder>
    <mo stretchy="false">(</mo> <msub><mi>x</mi> <mi>i</mi></msub> <mo>−</mo> <mrow><mover><mi>x</mi>
    <mo stretchy="false">¯</mo></mover></mrow> <mo stretchy="false">)</mo> <msub><mi>x</mi>
    <mi>i</mi></msub></mrow></mfrac></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: 'After some algebra, we can represent <math><msub><mrow><mover><mi>θ</mi> <mo
    stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub></math> in terms of quantities
    that we are familiar with:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些代数运算，我们可以用我们熟悉的量来表示<math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></math>：
- en: <math display="block"><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mo>=</mo> <mi>r</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi
    mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo> <mfrac><mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow>
    <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow>
    <mo stretchy="false">)</mo></mrow></mfrac></math>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mo>=</mo> <mi>r</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi
    mathvariant="bold">x</mi></mrow></mrow> <mo>,</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo> <mfrac><mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow>
    <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow>
    <mo stretchy="false">)</mo></mrow></mfrac></math>
- en: 'As shown earlier in this chapter, this representation says that a point on
    the fitted line at <math><mi>x</mi></math> can be written as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面所示，这个表示法表明拟合线上的点在<math><mi>x</mi></math>处可以写成如下形式：
- en: <math display="block"><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub> <mo>+</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mi>x</mi> <mo>=</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>+</mo> <mi>r</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow>
    <mo>,</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo>
    <mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo> <mfrac><mrow><mo stretchy="false">(</mo> <mi>x</mi>
    <mo>−</mo> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></math>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub> <mo>+</mo> <msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub> <mi>x</mi> <mo>=</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo>+</mo> <mi>r</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow>
    <mo>,</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow> <mo stretchy="false">)</mo>
    <mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo stretchy="false">)</mo> <mfrac><mrow><mo stretchy="false">(</mo> <mi>x</mi>
    <mo>−</mo> <mrow><mover><mi>x</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <mo stretchy="false">)</mo></mrow> <mrow><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow> <mo stretchy="false">)</mo></mrow></mfrac></math>
- en: 'We have derived the equation for the least squares line that we used in the
    previous section. There, we used the `pandas` built-in methods to compute <math><mi>S</mi>
    <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">x</mi></mrow>
    <mo stretchy="false">)</mo></math> , <math><mi>S</mi> <mi>D</mi> <mo stretchy="false">(</mo>
    <mrow><mi mathvariant="bold">y</mi></mrow> <mo stretchy="false">)</mo></math>
    , and <math><mi>r</mi> <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">x</mi></mrow>
    <mo>,</mo> <mrow><mi mathvariant="bold">y</mi></mrow> <mo stretchy="false">)</mo></math>
    , to easily calculate the equation for this line. However, in practice we recommend
    using the functionality provided in `scikit-learn` to do the model fitting:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经推导出了在前一节中使用的最小二乘线方程。在那里，我们使用了`pandas`内置方法来计算<math><mi>S</mi> <mi>D</mi>
    <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">x</mi></mrow> <mo stretchy="false">)</mo></math>，<math><mi>S</mi>
    <mi>D</mi> <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">y</mi></mrow>
    <mo stretchy="false">)</mo></math>和<math><mi>r</mi> <mo stretchy="false">(</mo>
    <mrow><mi mathvariant="bold">x</mi></mrow> <mo>,</mo> <mrow><mi mathvariant="bold">y</mi></mrow>
    <mo stretchy="false">)</mo></math>，以便轻松计算这条线的方程。然而，在实践中，我们建议使用`scikit-learn`提供的功能来进行模型拟合：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our fitted model is:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的拟合模型是：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we provided `y` as an array and `x` as a dataframe to `LinearRegression`.
    We will soon see why when we fit multiple explanatory features in a model.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们将`y`作为数组和`x`作为数据框传递给`LinearRegression`。当我们在模型中引入多个解释特征时，很快就会看到原因。
- en: The `LinearRegression` method offers numerically stable algorithms to fit linear
    models by least squares. This is especially important when fitting multiple variables,
    which we introduce next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearRegression`方法提供了稳定的数值算法来通过最小二乘法拟合线性模型。当拟合多个变量时，这一点尤为重要，接下来我们将介绍。'
- en: Multiple Linear Model
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多元线性模型
- en: So far in this chapter, we’ve used a single input variable to predict an outcome
    variable. Now we introduce the *multiple linear model* that uses more than one
    feature to predict (or describe or explain) the outcome. Having multiple explanatory
    features can improve our model’s fit to the data and improve predictions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们使用单个输入变量预测结果变量。现在我们介绍使用多个特征的*多元线性模型*来预测（或描述或解释）结果。具有多个解释特征可以改善模型对数据的拟合并提高预测能力。
- en: 'We start by generalizing from a simple linear model to one that includes a
    second explanatory variable, called <math><mi>v</mi></math> . This model is linear
    in both <math><mi>x</mi></math> and <math><mi>v</mi></math> , meaning that for
    a pair of values for <math><mi>x</mi></math> and <math><mi>v</mi></math> , we
    can describe, explain, or predict <math><mi>y</mi></math> by the linear combination:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的线性模型推广到包括第二个解释变量的模型，称为<math><mi>v</mi></math>。这个模型在<math><mi>x</mi></math>和<math><mi>v</mi></math>上都是线性的，这意味着对于<math><mi>x</mi></math>和<math><mi>v</mi></math>的一对数值，我们可以用线性组合来描述、解释或预测<math><mi>y</mi></math>：
- en: <math display="block"><mi>y</mi> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>θ</mi>
    <mn>2</mn></msub> <mi>v</mi></math>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mi>y</mi> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>θ</mi>
    <mn>2</mn></msub> <mi>v</mi></math>
- en: 'Notice that for a particular value of <math><mi>v</mi></math> , say <math><msup><mi>v</mi>
    <mo>⋆</mo></msup></math> , we could express the preceding equation as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于特定的<math><mi>v</mi></math>值，比如<math><msup><mi>v</mi> <mo>⋆</mo></msup></math>，我们可以将上述方程表示为：
- en: <math display="block"><mi>y</mi> <mo>≈</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <msup><mi>v</mi>
    <mo>⋆</mo></msup> <mo stretchy="false">)</mo>  <mo>+</mo>  <msub><mi>θ</mi> <mn>1</mn></msub>
    <mi>x</mi></math>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mi>y</mi> <mo>≈</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <msup><mi>v</mi>
    <mo>⋆</mo></msup> <mo stretchy="false">)</mo>  <mo>+</mo>  <msub><mi>θ</mi> <mn>1</mn></msub>
    <mi>x</mi></math>
- en: In other words, when we hold <math><mi>v</mi></math> constant at <math><msup><mi>v</mi>
    <mo>⋆</mo></msup></math> , we have a simple linear relation between <math><mi>x</mi></math>
    and <math><mi>y</mi></math> with slope <math><msub><mi>θ</mi> <mn>1</mn></msub></math>
    and intercept <math><msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mn>2</mn></msub> <msup><mi>v</mi> <mo>⋆</mo></msup></math> . For a different
    value of <math><mi>v</mi></math> , say <math><msup><mi>v</mi> <mo>†</mo></msup></math>
    , we again have a simple linear relationship between <math><mi>x</mi></math> and
    <math><mi>y</mi></math> . The slope for <math><mi>x</mi></math> remains the same
    and the only change is the intercept, which is now <math><msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <msup><mi>v</mi> <mo>†</mo></msup></math>
    .
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当我们将<math><mi>v</mi></math>固定在<math><msup><mi>v</mi> <mo>⋆</mo></msup></math>时，<math><mi>x</mi></math>和<math><mi>y</mi></math>之间有一个简单的线性关系，斜率为<math><msub><mi>θ</mi>
    <mn>1</mn></msub></math>，截距为<math><msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo>
    <msub><mi>θ</mi> <mn>2</mn></msub> <msup><mi>v</mi> <mo>⋆</mo></msup></math>。对于另一个<math><mi>v</mi></math>的值，比如<math><msup><mi>v</mi>
    <mo>†</mo></msup></math>，我们同样有<math><mi>x</mi></math>和<math><mi>y</mi></math>之间的简单线性关系。<math><mi>x</mi></math>的斜率保持不变，唯一的变化是截距，现在是<math><msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <msup><mi>v</mi>
    <mo>†</mo></msup></math>。
- en: With multiple linear regression, we need to remember to interpret the coefficient
    <math><msub><mi>θ</mi> <mn>1</mn></msub></math> of <math><mi>x</mi></math> in
    the presence of the other variables in the model. Holding fixed the values of
    the other variables in the model (that’s just <math><mi>v</mi></math> in this
    case), an increase of 1 unit in <math><mi>x</mi></math> corresponds to a <math><msub><mi>θ</mi>
    <mn>1</mn></msub></math> change in <math><mi>y</mi></math> , on average. One way
    to visualize this kind of multiple linear relationship is to create facets of
    scatterplots of <math><mo stretchy="false">(</mo> <mi>x</mi> <mo>,</mo> <mi>y</mi>
    <mo stretchy="false">)</mo></math> where in each plot the values of <math><mi>v</mi></math>
    are roughly the same. We make such a scatterplot for the air quality measurements
    next, and provide examples of additional visualizations and statistics to examine
    when fitting a multiple linear model.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多元线性回归时，我们需要记住在模型中的其他变量存在的情况下解释<math><msub><mi>θ</mi> <mn>1</mn></msub></math>对<math><mi>x</mi></math>的系数。在保持模型中其他变量（在本例中仅为<math><mi>v</mi></math>）的值不变的情况下，<math><mi>x</mi></math>增加1个单位平均对应于<math><mi>y</mi></math>的<math><msub><mi>θ</mi>
    <mn>1</mn></msub></math>的变化。一种可视化这种多元线性关系的方法是创建散点图的多面板，其中每个图中<math><mi>v</mi></math>的值大致相同。我们接下来为空气质量测量制作这样的散点图，并提供其他可视化和统计学示例以检验拟合多元线性模型时的情况。
- en: 'The scientists who studied the air quality monitors (see [Chapter 12](ch12.html#ch-pa))
    were looking for an improved model that incorporated weather factors. One weather
    variable they examined was a daily measurement for relative humidity. Let’s consider
    a two-variable linear model to explain the PurpleAir measurements based on the
    AQS sensor measurements and relative humidity. This model has the following form:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 研究空气质量监测仪的科学家们（参见[第12章](ch12.html#ch-pa)）寻找一个包含天气因素的改进模型。他们检查的一种天气变量是相对湿度的每日测量值。让我们考虑一个双变量线性模型，以解释基于AQS传感器测量和相对湿度的PurpleAir测量。该模型具有以下形式：
- en: <math display="block"><mi>P</mi> <mi>A</mi> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>A</mi> <mi>Q</mi> <mo>+</mo>
    <msub><mi>θ</mi> <mn>2</mn></msub> <mi>R</mi> <mi>H</mi></math>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mi>P</mi> <mi>A</mi> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>A</mi> <mi>Q</mi> <mo>+</mo>
    <msub><mi>θ</mi> <mn>2</mn></msub> <mi>R</mi> <mi>H</mi></math>
- en: 'where <math><mi>P</mi> <mi>A</mi></math> , <math><mi>A</mi> <mi>Q</mi></math>
    , and <math><mi>R</mi> <mi>H</mi></math> refer to the variables: the PurpleAir
    average daily measurement, AQS measurement, and relative humidity, respectively.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 其中<math><mi>P</mi> <mi>A</mi></math>，<math><mi>A</mi> <mi>Q</mi></math>和<math><mi>R</mi>
    <mi>H</mi></math>分别指代变量：PurpleAir平均每日测量、AQS测量和相对湿度。
- en: 'For a first step, we make a facet plot to compare the relationship between
    the two air quality measurements for fixed values of humidity. To do this, we
    transform relative humidity to a categorical variable so that each facet consists
    of observations with similar humidity:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们制作一个多面板图来比较固定湿度值下两种空气质量测量之间的关系。为此，我们将相对湿度转换为一个分类变量，使每个面板由湿度相似的观测组成。
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we use this qualitative feature to subdivide the data into a two-by-two
    panel of scatterplots:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用这个定性特征将数据划分为一个二乘二的散点图面板：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](assets/leds_15in04.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in04.png)'
- en: These four plots show a linear relationship between the two sources of air quality
    measurements. And the slopes appear to be similar, which means that a multiple
    linear model may fit well. It’s difficult to see from these plots if the relative
    humidity affects the intercept much.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个图表显示了两种空气质量测量来源之间的线性关系。斜率看起来相似，这意味着多重线性模型可能非常合适。从这些图表中很难看出相对湿度是否对截距有显著影响。
- en: 'We also want to examine the pairwise scatterplots between the three features.
    When two explanatory features are highly correlated, their coefficients in the
    model may be unstable. While linear relationships between three or more features
    may not show up in pairwise plots, it’s still a good idea to check:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想检查三个特征之间的成对散点图。当两个解释性特征高度相关时，它们在模型中的系数可能不稳定。虽然三个或更多特征之间的线性关系在成对图中可能不明显，但检查这些图表仍然是一个好主意：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](assets/leds_15in05.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in05.png)'
- en: 'The relationship between humidity and air quality does not appear to be particularly
    strong. Another pairwise measure we should examine is the correlations between
    features:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 湿度与空气质量之间的关系似乎并不特别强。我们应该检查的另一个成对测量是特征之间的相关性：
- en: '|   | pm25pa | pm25aqs | rh |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|   | pm25pa | pm25aqs | rh |'
- en: '| --- | --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **pm25pa** | 1.00 | 0.95 | -0.06 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **pm25pa** | 1.00 | 0.95 | -0.06 |'
- en: '| **pm25aqs** | 0.95 | 1.00 | -0.24 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **pm25aqs** | 0.95 | 1.00 | -0.24 |'
- en: '| **rh** | -0.06 | -0.24 | 1.00 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **rh** | -0.06 | -0.24 | 1.00 |'
- en: One small surprise is that relative humidity has a small negative correlation
    with the AQS measurement of air quality. This suggests that humidity might be
    helpful in the model.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小惊喜是，相对湿度与AQS测量的空气质量具有轻微的负相关。这表明湿度可能对模型有帮助。
- en: 'In the next section, we derive the equation for the fit. But for now, we use
    the functionality in `LinearRegression` to fit the model. The only change from
    earlier is that we provide two columns for the explanatory variables (that’s why
    the `x` input is a dataframe):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将推导适合的方程。但现在，我们使用`LinearRegression`的功能来拟合模型。与之前不同的唯一变化是我们为解释变量提供了两列（这就是为什么`x`输入是一个数据框）：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The fitted multiple linear model, including the coefficient units, is:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 适合的多重线性模型，包括系数单位，是：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The coefficient for humidity in the model adjusts the air quality prediction
    by 0.21 ppm for each percentage point of relative humidity. Notice that the coefficient
    for AQS differs from the simple linear model that we fitted earlier. This happens
    because the coefficient reflects the additional information coming from relative
    humidity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 模型中湿度的系数调整空气质量预测每百分点相对湿度0.21 ppm。请注意，AQS的系数与我们之前拟合的简单线性模型不同。这是因为系数反映了来自相对湿度的额外信息。
- en: 'Lastly, to check the quality of the fit, we make residual plots of the predicted
    values and the errors. This time, we use `LinearRegression` to compute the predictions
    for us:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了检查拟合质量，我们制作了预测值和误差的残差图。这一次，我们使用`LinearRegression`来计算我们的预测：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](assets/leds_15in06.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in06.png)'
- en: 'The residual plot appears to have no clear patterns, which indicates that the
    model fits pretty well. Notice also that the errors nearly all fall within –4
    and +4 ppm, a smaller range than in the simple linear model. And we find the standard
    deviation of the residuals is quite a bit smaller:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 残差图表没有明显的模式，这表明模型拟合得相当好。还要注意，误差几乎都落在–4和+4 ppm之间，比简单线性模型的范围小。我们发现残差的标准偏差要小得多：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The residual standard deviation has been reduced from 2.8 ppm in the one variable
    model to 1.8 ppm, a good size reduction.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 残差标准偏差从单变量模型的2.8 ppm降低到了1.8 ppm，这是一个很好的尺寸缩减。
- en: The correlation coefficient can’t capture the strength of a linear association
    model when we have more than one explanatory variable. Instead, we adapt the MSE
    to give us a sense of model fit. In the next section, we describe how to fit a
    multiple linear model and use the MSE to assess fit.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多个解释变量时，相关系数无法捕捉线性关联模型的强度。相反，我们调整MSE以了解模型的拟合程度。在下一节中，我们描述如何拟合多重线性模型并使用MSE来评估拟合。
- en: Fitting the Multiple Linear Model
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拟合多重线性模型
- en: In the previous section, we considered the case of two explanatory variables;
    one of these we called <math><mi>x</mi></math> and the other <math><mi>v</mi></math>
    . Now we want to generalize the approach to <math><mi>p</mi></math> explanatory
    variables. The idea of choosing different letters to represent variables quickly
    fails us. Instead, we use a more formal and general approach that represents multiple
    predictors as a matrix, as depicted in [Figure 15-3](#fig-design-matrix). We call
    <math><mtext mathvariant="bold">X</mtext></math> the *design matrix*. Notice that
    <math><mtext mathvariant="bold">X</mtext></math> has shape <math><mi>n</mi> <mo>×</mo>
    <mo stretchy="false">(</mo> <mi>p</mi> <mo>+</mo> <mn>1</mn> <mo stretchy="false">)</mo></math>
    . Each column of <math><mtext mathvariant="bold">X</mtext></math> represents a
    feature, and each row represents an observation. That is, <math><msub><mi>x</mi>
    <mrow><mi>i</mi> <mo>,</mo> <mi>j</mi></mrow></msub></math> is the measurement
    taken on observation <math><mi>i</mi></math> for feature <math><mi>j</mi></math>
    .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们考虑了两个解释变量的情况；其中一个我们称为<math><mi>x</mi></math>，另一个为<math><mi>v</mi></math>。现在我们希望将这种方法推广到<math><mi>p</mi></math>个解释变量。选择不同字母来表示变量的想法很快失效了。相反，我们使用一种更正式和通用的方法，将多个预测变量表示为一个矩阵，如[图 15-3](#fig-design-matrix)所示。我们称<math><mtext
    mathvariant="bold">X</mtext></math>为*设计矩阵*。注意，<math><mtext mathvariant="bold">X</mtext></math>的形状为<math><mi>n</mi>
    <mo>×</mo> <mo stretchy="false">(</mo> <mi>p</mi> <mo>+</mo> <mn>1</mn> <mo stretchy="false">)</mo></math>。<math><mtext
    mathvariant="bold">X</mtext></math>的每一列代表一个特征，每一行代表一个观察值。也就是说，<math><msub><mi>x</mi>
    <mrow><mi>i</mi> <mo>,</mo> <mi>j</mi></mrow></msub></math>是在观察值<math><mi>i</mi></math>上针对特征<math><mi>j</mi></math>的测量值。
- en: '![](assets/leds_1503.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_1503.png)'
- en: Figure 15-3\. In this design matrix <math><mi>X</mi></math> , each row represents
    an observation/record and each column a feature/variable
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-3。在这个设计矩阵<math><mi>X</mi></math>中，每一行代表一个观察/记录，每一列代表一个特征/变量
- en: Note
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'One technicality: the design matrix is defined as a mathematical matrix, not
    a dataframe, so you might notice that a matrix doesn’t include the column or row
    labels that a dataframe has.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个技术细节：设计矩阵被定义为数学矩阵，而不是数据框，因此您可能注意到矩阵不包括数据框具有的列或行标签。
- en: That said, we usually don’t have to worry about converting dataframes into matrices
    since most Python libraries for modeling treat dataframes of numbers as if they
    were matrices.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们通常不必担心将数据框转换为矩阵，因为大多数用于建模的Python库将数字数据框视为矩阵。
- en: 'For a given observation, say, the second row in <math><mtext mathvariant="bold">X</mtext></math>
    , we approximate the outcome <math><msub><mi>y</mi> <mn>2</mn></msub></math> by
    the linear combination:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的观察值，比如<math><mtext mathvariant="bold">X</mtext></math>中的第二行，我们通过线性组合近似得到结果<math><msub><mi>y</mi>
    <mn>2</mn></msub></math>：
- en: <math display="block"><mtable columnalign="right" displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mi>y</mi>
    <mn>2</mn></msub> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mrow><mn>2</mn> <mo>,</mo> <mn>1</mn></mrow></msub>
    <mo>+</mo> <mo>…</mo> <mo>+</mo> <msub><mi>θ</mi> <mi>p</mi></msub> <msub><mi>x</mi>
    <mrow><mn>2</mn> <mo>,</mo> <mi>p</mi></mrow></msub></mtd></mtr></mtable></math>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mi>y</mi>
    <mn>2</mn></msub> <mo>≈</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mrow><mn>2</mn> <mo>,</mo> <mn>1</mn></mrow></msub>
    <mo>+</mo> <mo>…</mo> <mo>+</mo> <msub><mi>θ</mi> <mi>p</mi></msub> <msub><mi>x</mi>
    <mrow><mn>2</mn> <mo>,</mo> <mi>p</mi></mrow></msub></mtd></mtr></mtable></math>
- en: 'It’s more convenient to express the linear approximation in matrix notation.
    To do this, we write the model parameters as a <math><mi>p</mi> <mo>+</mo> <mn>1</mn></math>
    column vector <math><mrow><mi mathvariant="bold-italic">θ</mi></mrow></math> :'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用矩阵表示线性近似更方便。为此，我们将模型参数写成一个<math><mi>p</mi> <mo>+</mo> <mn>1</mn></math>列向量<math><mrow><mi
    mathvariant="bold-italic">θ</mi></mrow></math>：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mrow><mi>θ</mi></mrow> <mo>=</mo> <mrow><mo>[</mo>
    <mtable columnalign="center" columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mi>θ</mi>
    <mn>0</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>θ</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><mrow><mo>⋮</mo></mrow></mtd></mtr> <mtr><mtd><msub><mi>θ</mi> <mi>p</mi></msub></mtd></mtr></mtable>
    <mo>]</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mrow><mi>θ</mi></mrow> <mo>=</mo> <mrow><mo>[</mo>
    <mtable columnalign="center" columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mi>θ</mi>
    <mn>0</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>θ</mi> <mn>1</mn></msub></mtd></mtr>
    <mtr><mtd><mrow><mo>⋮</mo></mrow></mtd></mtr> <mtr><mtd><msub><mi>θ</mi> <mi>p</mi></msub></mtd></mtr></mtable>
    <mo>]</mo></mrow></mtd></mtr></mtable></math>
- en: 'Putting these notational definitions together, we can write the vector of predictions
    for the entire dataset using matrix multiplication:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些符号定义放在一起，我们可以使用矩阵乘法为整个数据集编写预测向量：
- en: <math display="block"><mrow><mtext mathvariant="bold">X</mtext></mrow> <mrow><mi
    mathvariant="bold-italic">θ</mi></mrow></math>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mtext mathvariant="bold">X</mtext></mrow> <mrow><mi
    mathvariant="bold-italic">θ</mi></mrow></math>
- en: 'If we check the dimensions of <math><mtext mathvariant="bold">X</mtext></math>
    and <math><mi mathvariant="bold-italic">θ</mi></math> , we can confirm that <math><mrow><mtext
    mathvariant="bold">X</mtext></mrow> <mrow><mi mathvariant="bold-italic">θ</mi></mrow></math>
    is an <math><mi>n</mi></math> -dimensional column vector. So the error in using
    this linear prediction can be expressed as the vector:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查<math><mtext mathvariant="bold">X</mtext></math>和<math><mi mathvariant="bold-italic">θ</mi></math>的维度，我们可以确认<math><mrow><mtext
    mathvariant="bold">X</mtext></mrow><mrow><mi mathvariant="bold-italic">θ</mi></mrow></math>是一个<math><mi>n</mi></math>维列向量。因此，使用这种线性预测的误差可以表示为向量：
- en: <math display="block"><mrow><mi mathvariant="bold">e</mi></mrow> <mo>=</mo>
    <mrow><mi mathvariant="bold">y</mi></mrow> <mo>−</mo> <mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mrow><mi mathvariant="bold-italic">θ</mi></mrow></math>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi mathvariant="bold">e</mi></mrow> <mo>=</mo>
    <mrow><mi mathvariant="bold">y</mi></mrow> <mo>−</mo> <mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mrow><mi mathvariant="bold-italic">θ</mi></mrow></math>
- en: 'where the outcome variable is also represented as a column vector:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其中结果变量也表示为列向量：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mrow><mi mathvariant="bold">y</mi></mrow> <mo>=</mo>
    <mrow><mo>[</mo> <mtable columnalign="center" columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mi>y</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mn>2</mn></msub></mtd></mtr>
    <mtr><mtd><mrow><mo>⋮</mo></mrow></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mi>n</mi></msub></mtd></mtr></mtable>
    <mo>]</mo></mrow></mtd></mtr></mtable></math>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mrow><mi mathvariant="bold">y</mi></mrow> <mo>=</mo>
    <mrow><mo>[</mo> <mtable columnalign="center" columnspacing="1em" rowspacing="4pt"><mtr><mtd><msub><mi>y</mi>
    <mn>1</mn></msub></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mn>2</mn></msub></mtd></mtr>
    <mtr><mtd><mrow><mo>⋮</mo></mrow></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mi>n</mi></msub></mtd></mtr></mtable>
    <mo>]</mo></mrow></mtd></mtr></mtable></math>
- en: 'This matrix representation of the multiple linear model can help us find the
    model that minimizes mean squared error. Our goal is to find the model parameters
    <math><mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>,</mo>
    <msub><mi>θ</mi> <mn>1</mn></msub> <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>θ</mi>
    <mi>p</mi></msub> <mo stretchy="false">)</mo></math> that minimize the mean squared
    error:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多重线性模型的矩阵表示可以帮助我们找到使均方误差最小化的模型。我们的目标是找到模型参数 <math><mo stretchy="false">(</mo>
    <msub><mi>θ</mi> <mn>0</mn></msub> <mo>,</mo> <msub><mi>θ</mi> <mn>1</mn></msub>
    <mo>,</mo> <mo>…</mo> <mo>,</mo> <msub><mi>θ</mi> <mi>p</mi></msub> <mo stretchy="false">)</mo></math>
    ，使均方误差最小化：
- en: <math display="block"><mfrac><mn>1</mn> <mi>n</mi></mfrac> <munder><mo>∑</mo>
    <mi>i</mi></munder> <mo stretchy="false">[</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo>
    <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo>
    <mn>1</mn></mrow></msub> <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <msub><mi>θ</mi> <mi>p</mi></msub>
    <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>p</mi></mrow></msub> <mo stretchy="false">)</mo>
    <msup><mo stretchy="false">]</mo> <mn>2</mn></msup> <mo>=</mo> <mfrac><mn>1</mn>
    <mi>n</mi></mfrac> <mo fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">y</mi></mrow>
    <mo>−</mo> <mrow><mtext mathvariant="bold">X</mtext></mrow> <mrow><mi mathvariant="bold-italic">θ</mi></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></math>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mfrac><mn>1</mn> <mi>n</mi></mfrac> <munder><mo>∑</mo>
    <mi>i</mi></munder> <mo stretchy="false">[</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>−</mo> <mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo>
    <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo>
    <mn>1</mn></mrow></msub> <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <msub><mi>θ</mi> <mi>p</mi></msub>
    <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>p</mi></mrow></msub> <mo stretchy="false">)</mo>
    <msup><mo stretchy="false">]</mo> <mn>2</mn></msup> <mo>=</mo> <mfrac><mn>1</mn>
    <mi>n</mi></mfrac> <mo fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">y</mi></mrow>
    <mo>−</mo> <mrow><mtext mathvariant="bold">X</mtext></mrow> <mrow><mi mathvariant="bold-italic">θ</mi></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></math>
- en: 'Here, we use the notation <math><mo fence="false" stretchy="false">‖</mo> <mrow><mi
    mathvariant="bold">v</mi></mrow> <msup><mo fence="false" stretchy="false">‖</mo>
    <mn>2</mn></msup></math> for a vector <math><mrow><mi mathvariant="bold">v</mi></mrow></math>
    as a shorthand for the sum of each vector element squared: <math><mo fence="false"
    stretchy="false">‖</mo> <mrow><mi mathvariant="bold">v</mi></mrow> <msup><mo fence="false"
    stretchy="false">‖</mo> <mn>2</mn></msup> <mo>=</mo> <munder><mo>∑</mo> <mi>i</mi></munder>
    <msubsup><mi>v</mi> <mi>i</mi> <mn>2</mn></msubsup></math> . The square root,
    <math><msqrt><mo fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">v</mi></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></msqrt></math>
    , corresponds to the length of the vector <math><mrow><mi mathvariant="bold">v</mi></mrow></math>
    and is also called the <math><msub><mi>ℓ</mi> <mn>2</mn></msub></math> norm of
    <math><mrow><mi mathvariant="bold">v</mi></mrow></math> . So, minimizing the mean
    squared error is the same thing as finding the shortest error vector.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用记号 <math><mo fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">v</mi></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></math> 表示向量
    <math><mrow><mi mathvariant="bold">v</mi></mrow></math> 的长度的平方和的简写形式：<math><mo
    fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">v</mi></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup> <mo>=</mo> <munder><mo>∑</mo>
    <mi>i</mi></munder> <msubsup><mi>v</mi> <mi>i</mi> <mn>2</mn></msubsup></math>
    。平方根 <math><msqrt><mo fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">v</mi></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></msqrt></math>
    对应于向量 <math><mrow><mi mathvariant="bold">v</mi></mrow></math> 的长度，也称为向量 <math><mrow><mi
    mathvariant="bold">v</mi></mrow></math> 的 <math><msub><mi>ℓ</mi> <mn>2</mn></msub></math>
    范数。因此，最小化均方误差等同于找到最短的误差向量。
- en: We can fit our model using calculus as we did for the simple linear model. However,
    this approach gets cumbersome, and instead we use a geometric argument that is
    more intuitive and easily leads to useful properties of the design matrix, errors,
    and predicted values.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像简单线性模型那样使用微积分来拟合我们的模型。然而，这种方法变得笨重，我们改用更直观的几何论证，这更容易导致设计矩阵、误差和预测值的有用属性。
- en: Our goal is to find the parameter vector, which we call <math><mrow><mover><mi
    mathvariant="bold-italic">θ</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></math>
    , that minimizes our average squared loss—we want to make <math><mo fence="false"
    stretchy="false">‖</mo> <mrow><mi mathvariant="bold">y</mi></mrow> <mo>−</mo>
    <mrow><mtext mathvariant="bold">X</mtext></mrow> <mrow><mi mathvariant="bold-italic">θ</mi></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></math> as small
    as possible for a given <math><mtext mathvariant="bold">X</mtext></math> and <math><mrow><mi
    mathvariant="bold">y</mi></mrow></math> . The key insight is that we can restate
    this goal in a geometric way. Since the model predictions and the true outcomes
    are both vectors, we can think of them as vectors in a *vector space*. When we
    change our model parameters <math><mrow><mi mathvariant="bold-italic">θ</mi></mrow></math>
    , the model makes different predictions, but any prediction must be a linear combination
    of the column vectors of <math><mrow><mi mathvariant="bold">X</mi></mrow></math>
    ; that is, the prediction must be in what is called <math><mtext>span</mtext>
    <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow> <mo stretchy="false">)</mo></math>
    . This notion is illustrated in [Figure 15-4](#fig-spanx), where the shaded region
    consists of the possible linear models. Notice that <math><mrow><mi mathvariant="bold">y</mi></mrow></math>
    is not entirely captured in <math><mtext>span</mtext> <mo stretchy="false">(</mo>
    <mrow><mi mathvariant="bold">X</mi></mrow> <mo stretchy="false">)</mo></math>
    ; this is typically the case.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是找到参数向量，我们称之为<math><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo
    mathvariant="bold" stretchy="false">^</mo></mover></mrow></math>，使我们的平均平方损失最小化——我们希望使<math><mo
    fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">y</mi></mrow>
    <mo>−</mo> <mrow><mtext mathvariant="bold">X</mtext></mrow> <mrow><mi mathvariant="bold-italic">θ</mi></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></math> 在给定的<math><mtext
    mathvariant="bold">X</mtext></math>和<math><mrow><mi mathvariant="bold">y</mi></mrow></math>
    下尽可能小。关键洞察力在于，我们可以以几何方式重新表述这个目标。由于模型预测和真实结果都是向量，我们可以将它们视为*向量空间*中的向量。当我们改变模型参数<math><mrow><mi
    mathvariant="bold-italic">θ</mi></mrow></math>时，模型会进行不同的预测，但任何预测必须是<math><mrow><mi
    mathvariant="bold">X</mi></mrow></math>的列向量的线性组合；也就是说，预测必须在所谓的<math><mtext>span</mtext>
    <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow> <mo stretchy="false">)</mo></math>
    中。这个概念在[图 15-4](#fig-spanx)中有所体现，阴影区域代表可能的线性模型。请注意，<math><mrow><mi mathvariant="bold">y</mi></mrow></math>并没有完全包含在<math><mtext>span</mtext>
    <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow> <mo stretchy="false">)</mo></math>中；这通常是情况。
- en: '![](assets/leds_1504.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_1504.png)'
- en: Figure 15-4\. In this simplified diagram, the space of all possible model prediction
    vectors <math><mtext>span</mtext> <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow>
    <mo stretchy="false">)</mo></math> is illustrated as a plane in three-dimensional
    space, and the observed <math><mrow><mi mathvariant="bold">y</mi></mrow></math>
    as a vector
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-4。在这个简化的图示中，所有可能的模型预测向量<math><mtext>span</mtext> <mo stretchy="false">(</mo>
    <mrow><mi mathvariant="bold">X</mi></mrow> <mo stretchy="false">)</mo></math>被描绘为三维空间中的一个平面，而观测到的<math><mrow><mi
    mathvariant="bold">y</mi></mrow></math>作为一个向量。
- en: Although the squared loss can’t be exactly zero because <math><mrow><mi mathvariant="bold">y</mi></mrow></math>
    isn’t in the <math><mtext>span</mtext> <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow>
    <mo stretchy="false">)</mo></math> , we can find the vector that lies as close
    to <math><mrow><mi mathvariant="bold">y</mi></mrow></math> as possible while still
    being in <math><mtext>span</mtext> <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow>
    <mo stretchy="false">)</mo></math> . This vector is called <math><mrow><mrow><mover><mi
    mathvariant="bold">y</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></mrow></math>
    .
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管平方损失不能完全为零，因为<math><mrow><mi mathvariant="bold">y</mi></mrow></math>不在<math><mtext>span</mtext>
    <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow> <mo stretchy="false">)</mo></math>中，我们可以找到一个尽可能接近<math><mrow><mi
    mathvariant="bold">y</mi></mrow></math>但仍在<math><mtext>span</mtext> <mo stretchy="false">(</mo>
    <mrow><mi mathvariant="bold">X</mi></mrow> <mo stretchy="false">)</mo></math>中的向量。这个向量被称为<math><mrow><mrow><mover><mi
    mathvariant="bold">y</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></mrow></math>。
- en: The error is the vector <math><mrow><mi mathvariant="bold">e</mi></mrow> <mo>=</mo>
    <mrow><mi mathvariant="bold">y</mi></mrow> <mo>−</mo> <mrow><mrow><mover><mi mathvariant="bold">y</mi>
    <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></mrow></math> .
    Its length <math><mo fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">e</mi></mrow>
    <mo fence="false" stretchy="false">‖</mo></math> represents the distance between
    the true outcome and our model’s prediction. Visually, <math><mrow><mi mathvariant="bold">e</mi></mrow></math>
    has the smallest magnitude when it is *perpendicular* to the <math><mtext>span</mtext>
    <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow> <mo stretchy="false">)</mo></math>
    , as shown in [Figure 15-5](#fig-error-vector-optimal). The proof of this fact
    is omitted, and we rely on the figures to convince you of it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 误差是向量 <math><mrow><mi mathvariant="bold">e</mi></mrow> <mo>=</mo> <mrow><mi
    mathvariant="bold">y</mi></mrow> <mo>−</mo> <mrow><mrow><mover><mi mathvariant="bold">y</mi>
    <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></mrow></math> 。它的长度
    <math><mo fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">e</mi></mrow>
    <mo fence="false" stretchy="false">‖</mo></math> 表示真实结果与我们模型预测之间的距离。从视觉上看，当它与
    <math><mtext>span</mtext> <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow>
    <mo stretchy="false">)</mo></math> *垂直* 时，<math><mrow><mi mathvariant="bold">e</mi></mrow></math>
    的大小最小，如 [图 15-5](#fig-error-vector-optimal) 所示。关于此事实的证明被省略，我们依赖于图表来说服您。
- en: '![](assets/leds_1505.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_1505.png)'
- en: Figure 15-5\. The mean squared error is minimized when the prediction <math><mrow><mrow><mover><mi
    mathvariant="bold">y</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></mrow></math>
    lies in <math><mtext>span</mtext> <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow>
    <mo stretchy="false">)</mo></math> perpendicular to <math><mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow></math>
  id: totrans-191
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-5\. 当预测值 <math><mrow><mrow><mover><mi mathvariant="bold">y</mi> <mo mathvariant="bold"
    stretchy="false">^</mo></mover></mrow></mrow></math> 在 <math><mtext>span</mtext>
    <mo stretchy="false">(</mo> <mrow><mi mathvariant="bold">X</mi></mrow> <mo stretchy="false">)</mo></math>
    垂直于 <math><mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow></math> 时，均方误差达到最小值。
- en: 'The fact that the smallest error, <math><mrow><mi mathvariant="bold">e</mi></mrow></math>
    , must be perpendicular to <math><mrow><mrow><mover><mi mathvariant="bold">y</mi>
    <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></mrow></math> lets
    us derive a formula for <math><mrow><mover><mi mathvariant="bold-italic">θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></math> as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最小误差 <math><mrow><mi mathvariant="bold">e</mi></mrow></math> 必须垂直于 <math><mrow><mrow><mover><mi
    mathvariant="bold">y</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></mrow></math>，这使我们能够推导出
    <math><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo stretchy="false">^</mo></mover></mrow></math>
    的公式如下：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left right" columnspacing="0em
    2em" displaystyle="true" rowspacing="3pt"><mtr><mtd><mtext mathvariant="bold">X</mtext>
    <mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow>
    <mo>+</mo> <mrow><mi mathvariant="bold">e</mi></mrow></mtd> <mtd><mo>=</mo> <mrow><mi
    mathvariant="bold">y</mi></mrow></mtd> <mtd><mo stretchy="false">(</mo> <mtext>the
    definition of </mtext> <mrow><mi mathvariant="bold">y</mi></mrow> <mo>,</mo> <mrow><mover><mrow><mi
    mathvariant="bold">y</mi></mrow> <mo stretchy="false">^</mo></mover></mrow> <mo>,</mo>
    <mrow><mi mathvariant="bold">e</mi></mrow> <mo stretchy="false">)</mo></mtd></mtr>
    <mtr><mtd><msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <mrow><mover><mi mathvariant="bold-italic">θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mo>+</mo> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mi mathvariant="normal">⊤</mi></msup> <mrow><mi mathvariant="bold">e</mi></mrow></mtd>
    <mtd><mo>=</mo> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mrow><mi mathvariant="bold">y</mi></mrow></mtd> <mtd><mo stretchy="false">(</mo>
    <mtext>left-multiply by </mtext> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mi mathvariant="normal">⊤</mi></msup> <mo stretchy="false">)</mo></mtd></mtr>
    <mtr><mtd><msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <mrow><mover><mi mathvariant="bold-italic">θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></mtd> <mtd><mo>=</mo> <msup><mrow><mtext
    mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup> <mrow><mi
    mathvariant="bold">y</mi></mrow></mtd> <mtd><mo stretchy="false">(</mo> <mrow><mi
    mathvariant="bold">e</mi></mrow> <mo>⊥</mo> <mtext>span</mtext> <mo stretchy="false">(</mo>
    <mtext mathvariant="bold">X</mtext> <mo stretchy="false">)</mo> <mo stretchy="false">)</mo></mtd></mtr>
    <mtr><mtd><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo mathvariant="bold"
    stretchy="false">^</mo></mover></mrow></mtd> <mtd><mo>=</mo> <mo stretchy="false">(</mo>
    <msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <msup><mo stretchy="false">)</mo> <mrow><mo>−</mo>
    <mn>1</mn></mrow></msup> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mi mathvariant="normal">⊤</mi></msup> <mrow><mi mathvariant="bold">y</mi></mrow></mtd>
    <mtd><mo stretchy="false">(</mo> <mtext>left-multiply by </mtext> <mo stretchy="false">(</mo>
    <msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <msup><mo stretchy="false">)</mo> <mrow><mo>−</mo>
    <mn>1</mn></mrow></msup> <mo stretchy="false">)</mo></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left right" columnspacing="0em
    2em" displaystyle="true" rowspacing="3pt"><mtr><mtd><mtext mathvariant="bold">X</mtext>
    <mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow>
    <mo>+</mo> <mrow><mi mathvariant="bold">e</mi></mrow></mtd> <mtd><mo>=</mo> <mrow><mi
    mathvariant="bold">y</mi></mrow></mtd> <mtd><mo stretchy="false">(</mo> <mtext>the
    definition of </mtext> <mrow><mi mathvariant="bold">y</mi></mrow> <mo>,</mo> <mrow><mover><mrow><mi
    mathvariant="bold">y</mi></mrow> <mo stretchy="false">^</mo></mover></mrow> <mo>,</mo>
    <mrow><mi mathvariant="bold">e</mi></mrow> <mo stretchy="false">)</mo></mtd></mtr>
    <mtr><mtd><msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <mrow><mover><mi mathvariant="bold-italic">θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mo>+</mo> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mi mathvariant="normal">⊤</mi></msup> <mrow><mi mathvariant="bold">e</mi></mrow></mtd>
    <mtd><mo>=</mo> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mrow><mi mathvariant="bold">y</mi></mrow></mtd> <mtd><mo stretchy="false">(</mo>
    <mtext>left-multiply by </mtext> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mi mathvariant="normal">⊤</mi></msup> <mo stretchy="false">)</mo></mtd></mtr>
    <mtr><mtd><msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <mrow><mover><mi mathvariant="bold-italic">θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></mtd> <mtd><mo>=</mo> <msup><mrow><mtext
    mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup> <mrow><mi
    mathvariant="bold">y</mi></mrow></mtd> <mtd><mo stretchy="false">(</mo> <mrow><mi
    mathvariant="bold">e</mi></mrow> <mo>⊥</mo> <mtext>span</mtext> <mo stretchy="false">(</mo>
    <mtext mathvariant="bold">X</mtext> <mo stretchy="false">)</mo> <mo stretchy="false">)</mo></mtd></mtr>
    <mtr><mtd><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo mathvariant="bold"
    stretchy="false">^</mo></mover></mrow></mtd> <mtd><mo>=</mo> <mo stretchy="false">(</mo>
    <msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <msup><mo stretchy="false">)</mo> <mrow><mo>−</mo>
    <mn>1</mn></mrow></msup> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mi mathvariant="normal">⊤</mi></msup> <mrow><mi mathvariant="bold">y</mi></mrow></mtd>
    <mtd><mo stretchy="false">(</mo> <mtext>left-multiply by </mtext> <mo stretchy="false">(</mo>
    <msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <msup><mo stretchy="false">)</mo> <mrow><mo>−</mo>
    <mn>1</mn></mrow></msup> <mo stretchy="false">)</mo></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: This general approach to derive <math><mrow><mover><mi mathvariant="bold-italic">θ</mi>
    <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></math> for the multiple
    linear model also gives us <math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>0</mn></msub></math> and <math><msub><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow>
    <mn>1</mn></msub></math> for the simple linear model. If we set <math><mrow><mtext
    mathvariant="bold">X</mtext></mrow></math> to be the two-column matrix that contains
    the intercept column and one feature column, this formula for <math><mrow><mover><mi
    mathvariant="bold-italic">θ</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></math>
    and some linear algebra gets the intercept and slope of the least-squares-fitted
    simple linear model. In fact, if <math><mrow><mtext mathvariant="bold">X</mtext></mrow></math>
    is simply a single column of <math><mn>1</mn></math> s, then we can use this formula
    to show that <math><mrow><mrow><mover><mi>θ</mi> <mo stretchy="false">^</mo></mover></mrow></mrow></math>
    is just the mean of <math><mrow><mi mathvariant="bold">y</mi></mrow></math> .
    This nicely ties back to the constant model that we introduced in [Chapter 4](ch04.html#ch-modeling).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这种推导多元线性模型中<math><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo mathvariant="bold"
    stretchy="false">^</mo></mover></mrow></math>的一般方法也给了我们简单线性模型中<math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>0</mn></msub></math>和<math><msub><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow> <mn>1</mn></msub></math>。如果我们将<math><mrow><mtext
    mathvariant="bold">X</mtext></mrow></math>设置为包含截距列和一个特征列的两列矩阵，这个公式用于最小二乘拟合的简单线性模型的截距和斜率。实际上，如果<math><mrow><mtext
    mathvariant="bold">X</mtext></mrow></math>仅是<math><mn>1</mn></math>列的单列，那么我们可以使用这个公式表明<math><mrow><mrow><mover><mi>θ</mi>
    <mo stretchy="false">^</mo></mover></mrow></mrow></math>只是<math><mrow><mi mathvariant="bold">y</mi></mrow></math>的均值。这与我们在[第四章](ch04.html#ch-modeling)中介绍的常数模型很好地联系在一起。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While we can write a simple function to derive the <math><mrow><mover><mi mathvariant="bold-italic">θ</mi>
    <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></math> based on
    the formula
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以编写一个简单的函数来根据公式推导<math><mrow><mover><mi mathvariant="bold-italic">θ</mi>
    <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></math>
- en: <math display="block"><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo
    mathvariant="bold" stretchy="false">^</mo></mover></mrow> <mo>=</mo> <mo stretchy="false">(</mo>
    <msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <msup><mo stretchy="false">)</mo> <mrow><mo>−</mo>
    <mn>1</mn></mrow></msup> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mi mathvariant="normal">⊤</mi></msup> <mrow><mi mathvariant="bold">y</mi></mrow></math>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo
    mathvariant="bold" stretchy="false">^</mo></mover></mrow> <mo>=</mo> <mo stretchy="false">(</mo>
    <msup><mrow><mtext mathvariant="bold">X</mtext></mrow> <mi mathvariant="normal">⊤</mi></msup>
    <mtext mathvariant="bold">X</mtext> <msup><mo stretchy="false">)</mo> <mrow><mo>−</mo>
    <mn>1</mn></mrow></msup> <msup><mrow><mtext mathvariant="bold">X</mtext></mrow>
    <mi mathvariant="normal">⊤</mi></msup> <mrow><mi mathvariant="bold">y</mi></mrow></math>
- en: we recommend leaving the calculation of <math><mrow><mover><mi mathvariant="bold-italic">θ</mi>
    <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></math> to the optimally
    tuned methods provided in the `scikit-learn` and `statsmodels` libraries. They
    handle cases where the design matrix is sparse, highly co-linear, and not invertible.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用优化调整方法来计算<math><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo mathvariant="bold"
    stretchy="false">^</mo></mover></mrow></math>，这些方法由`scikit-learn`和`statsmodels`库提供。它们处理设计矩阵稀疏、高度共线性和不可逆的情况。
- en: 'This solution for <math><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo
    mathvariant="bold" stretchy="false">^</mo></mover></mrow></math> (along with the
    pictures) reveals some useful properties of the fitted coefficients and the predictions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<math><mrow><mover><mi mathvariant="bold-italic">θ</mi> <mo mathvariant="bold"
    stretchy="false">^</mo></mover></mrow></math>的解（以及图像）揭示了拟合系数和预测的一些有用性质：
- en: The residuals, <math><mrow><mi mathvariant="bold">e</mi></mrow></math> , are
    orthogonal to the predicted values, <math><mrow><mover><mrow><mi mathvariant="bold">y</mi></mrow>
    <mo stretchy="false">^</mo></mover></mrow></math> .
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 残差<math><mrow><mi mathvariant="bold">e</mi></mrow></math>与预测值<math><mrow><mover><mrow><mi
    mathvariant="bold">y</mi></mrow> <mo stretchy="false">^</mo></mover></mrow></math>正交。
- en: The average of the residuals is 0 if the model has an intercept term.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果模型有截距项，则残差的平均值为0。
- en: The variance of the residuals is just the MSE.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 残差的方差就是均方误差。
- en: These properties explain why we examine plots of the residuals against the predictions.
    When we fit a multiple linear model, we also plot the residuals against variables
    that we are considering adding to the model. If they showed a linear pattern,
    then we would consider adding them to the model.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性解释了为什么我们要检查残差与预测值的图表。当我们拟合多元线性模型时，我们还会将残差与我们考虑添加到模型的变量绘制在一起。如果它们显示出线性模式，那么我们会考虑将它们添加到模型中。
- en: 'In addition to examining the SD of the errors, the ratio of the MSE for a multiple
    linear model to the MSE for the constant model gives a measure of the model fit.
    This is called the *multiple <math><msup><mi>R</mi> <mn>2</mn></msup></math>*
    and is defined as:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检查错误的标准差之外，多元线性模型的均方误差与常数模型的均方误差比值可以衡量模型的拟合度。这被称为*多元<math><msup><mi>R</mi>
    <mn>2</mn></msup></math>*，其定义如下：
- en: <math display="block"><msup><mi>R</mi> <mn>2</mn></msup> <mo>=</mo> <mn>1</mn>
    <mo>−</mo> <mfrac><mrow><mo fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">y</mi></mrow>
    <mo>−</mo> <mrow><mtext mathvariant="bold">X</mtext></mrow> <mrow><mrow><mover><mi
    mathvariant="bold-italic">θ</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></mrow> <mrow><mo
    fence="false" stretchy="false">‖</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></mrow></mfrac></math>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><msup><mi>R</mi> <mn>2</mn></msup> <mo>=</mo> <mn>1</mn>
    <mo>−</mo> <mfrac><mrow><mo fence="false" stretchy="false">‖</mo> <mrow><mi mathvariant="bold">y</mi></mrow>
    <mo>−</mo> <mrow><mtext mathvariant="bold">X</mtext></mrow> <mrow><mrow><mover><mi
    mathvariant="bold-italic">θ</mi> <mo mathvariant="bold" stretchy="false">^</mo></mover></mrow></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></mrow> <mrow><mo
    fence="false" stretchy="false">‖</mo> <mrow><mrow><mi mathvariant="bold">y</mi></mrow></mrow>
    <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">¯</mo></mover></mrow>
    <msup><mo fence="false" stretchy="false">‖</mo> <mn>2</mn></msup></mrow></mfrac></math>
- en: As the model fits the data closer and closer, the multiple <math><msup><mi>R</mi>
    <mn>2</mn></msup></math> gets nearer to 1\. That might seem like a good thing,
    but there can be problems with this approach because <math><msup><mi>R</mi> <mn>2</mn></msup></math>
    continues to grow even as we add meaningless features to our model, as long as
    the features expand the <math><mtext>span</mtext> <mo stretchy="false">(</mo>
    <mtext mathvariant="bold">X</mtext> <mo stretchy="false">)</mo></math> . To account
    for the size of a model, we often adjust the numerator and denominator in <math><msup><mi>R</mi>
    <mn>2</mn></msup></math> by the number of fitted coefficients in the models. That
    is, we normalize the numerator by <math><mn>1</mn> <mrow><mo>/</mo></mrow> <mo
    stretchy="false">[</mo> <mi>n</mi> <mo>−</mo> <mo stretchy="false">(</mo> <mi>p</mi>
    <mo>+</mo> <mn>1</mn> <mo stretchy="false">)</mo> <mo stretchy="false">]</mo></math>
    and the denominator by <math><mn>1</mn> <mrow><mo>/</mo></mrow> <mo stretchy="false">(</mo>
    <mi>n</mi> <mo>−</mo> <mn>1</mn> <mo stretchy="false">)</mo></math> . Better approaches
    to selecting a model are covered in [Chapter 16](ch16.html#ch-risk).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 随着模型越来越贴近数据，多个<math><msup><mi>R</mi> <mn>2</mn></msup></math>接近于1。这可能看起来是件好事，但这种方法可能存在问题，因为<math><msup><mi>R</mi>
    <mn>2</mn></msup></math>即使在我们为模型添加无意义的特征时也会继续增长，只要这些特征扩展了<math><mtext>span</mtext><mo
    stretchy="false">(</mo><mtext mathvariant="bold">X</mtext><mo stretchy="false">)</mo></math>。为了考虑模型的大小，我们通常通过模型中拟合系数的数量调整<math><msup><mi>R</mi>
    <mn>2</mn></msup></math>的分子和分母。也就是说，我们通过<math><mn>1</mn><mrow><mo>/</mo></mrow><mo
    stretchy="false">[</mo><mi>n</mi><mo>−</mo><mo stretchy="false">(</mo><mi>p</mi><mo>+</mo><mn>1</mn><mo
    stretchy="false">)</mo><mo stretchy="false">]</mo></math>来标准化分子，并通过<math><mn>1</mn><mrow><mo>/</mo></mrow><mo
    stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></math>来标准化分母。在选择模型的更好方法方面，详见[第16章](ch16.html#ch-risk)。
- en: Next, we consider a social science example where there are many variables available
    to us for modeling.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑一个社会科学的例子，在这个例子中，我们有许多可用于建模的变量。
- en: 'Example: Where Is the Land of Opportunity?'
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：什么是机会之地？
- en: The US is called “the land of opportunity” because people believe that even
    those with few resources can end up wealthy in the US—economists call this notion
    “economic mobility.” In one study, economist Raj Chetty and colleagues did a [large-scale
    data analysis on economic mobility in the US](https://doi.org/10.1093/qje/qju022).
    His basic question was whether the US is a land of opportunity. To answer this
    somewhat vague question, Chetty needed a way to measure economic mobility.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 美国被称为“机会之地”，因为人们相信即使资源匮乏的人也可以在美国变得富有，经济学家称这种观念为“经济流动性”。在一项研究中，经济学家拉杰·切蒂及其同事对美国的经济流动性进行了[大规模数据分析](https://doi.org/10.1093/qje/qju022)。他的基本问题是美国是否是一个机会之地。为了回答这个相对模糊的问题，切蒂需要一种衡量经济流动性的方法。
- en: Chetty had access to 2011–2012 federal income tax records for everyone born
    in the US between 1980 and 1982, along with their parents’ tax records filed in
    their birth year. They matched the 30-year-olds to their parents by finding the
    parents’ 1980–1982 tax records that listed them as dependents. In total, his dataset
    had about 10 million people. To measure economic mobility, Chetty grouped people
    born in a particular geographic region whose parents’ income was in the 25th income
    percentile in 1980–1982\. He then found the group’s average income percentile
    in 2011\. Chetty calls this average *absolute upward mobility* (AUM). If a region’s
    AUM is 25, then people born into the 25th percentile generally stay in the 25th
    percentile—they remain where their parents were when they were born. High AUM
    values mean that the region has more upward mobility. Those born into the 25th
    income percentile in these regions generally wind up in a higher income bracket
    than their parents. For reference, the US average AUM is about 41 at the time
    of this writing. Chetty calculated the AUM for regions called commuting zones
    (CZs), which are roughly on the same scale as counties.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Chetty 可以访问1980年至1982年间出生于美国的每个人的2011-2012年联邦所得税记录，以及他们父母在他们出生年份的税务记录。他通过找到列出他们为家庭成员的父母的1980-1982年税务记录来将30岁的人与他们的父母配对。总共，他的数据集约有1000万人。为了衡量经济流动性，Chetty
    将出生在特定地理区域、父母收入位于1980-1982年的第25个收入百分位的人群分组。然后，他找到了该组2011年的平均收入百分位数。Chetty 将这个平均值称为*绝对向上流动*（AUM）。如果一个地区的AUM为25，那么出生在第25百分位的人通常会保持在第25百分位，即他们留在了父母出生时的位置。高AUM值意味着该地区具有更多的向上流动性。在这些地区出生在第25个收入百分位的人通常会进入比他们父母更高的收入阶层。作为参考，美国的平均AUM在撰写本文时约为41。Chetty
    计算了称为通勤区（CZs）的地区的AUM，这些地区大致与县级相同的规模。
- en: While the granularity of the original data is at an individual level, the data
    Chetty analyzed has a granularity at the CZ level. Income records can’t be publicly
    available because of privacy laws, but the AUM for a commuting zone can be made
    available. However, even with the granularity of a commuting zone, not all commuting
    zones are included in the data set because with 40 features in the data, it might
    be possible to identify individuals in small CZs. This limitation points to a
    potential coverage bias. Measurement bias is another potential problem. For example,
    children born into the 25th income percentile who become extremely wealthy may
    not file income tax.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然原始数据的粒度是在个体级别，Chetty分析的数据粒度是在通勤区域级别。由于隐私法规限制，收入记录不能公开，但通勤区域的AUM可以提供。然而，即使有了通勤区域的粒度，也并非所有通勤区域都包含在数据集中，因为在40个特征的数据中，可能会识别出小型通勤区域的个体。这一限制指向潜在的覆盖偏倚。测量偏倚是另一个潜在问题。例如，出生在第25收入百分位的儿童，如果成为极其富有的人，可能不会申报所得税。
- en: We also point out the limitations of working with data that are regional averages
    rather than individual measurements. The relationships found among features are
    often more highly correlated at the aggregate level than at the individual level.
    This phenomenon is called *ecological regression*, and interpretations of findings
    from aggregated data need to be made with care.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指出使用区域平均数据而不是个体测量数据的局限性。在聚合水平上，特征之间的关系通常比在个体水平上更高度相关。这种现象称为*生态回归*，需要谨慎解释从聚合数据中得出的发现。
- en: Chetty had a hunch that some places in the US have higher economic mobility
    than others. His analysis found this to be true. He found that some cities—such
    as San Jose, Calif.; Washington, DC; and Seattle—have higher mobility than others,
    such as Charlotte, N.C.; Milwaukee; and Atlanta. This means that, for example,
    people move from low to high income brackets in San Jose at a higher rate compared
    to Charlotte. Chetty used linear models to find that social and economic factors
    like segregation, income inequality, and local school systems are related to economic
    mobility.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Chetty怀疑美国某些地方的经济流动性较高。他的分析证实了这一点。他发现一些城市，如加利福尼亚州圣何塞、华盛顿特区和西雅图，比其他城市如北卡罗来纳州夏洛特、密尔沃基和亚特兰大有更高的流动性。这意味着，例如，在圣何塞，人们从低收入阶层向高收入阶层的转移速度比在夏洛特要快。Chetty使用线性模型发现社会和经济因素如隔离、收入不平等和当地学校系统与经济流动性相关。
- en: 'In this analysis, our outcome variable is the AUM for a commuting zone, since
    we are interested in finding features that correlate with AUM. There are many
    possible such features in Chetty’s data, but we first investigate one in particular:
    the fraction of people in a CZ who have a 15-minute or shorter commute to work.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个分析中，我们的结果变量是通勤区域的AUM，因为我们有兴趣找出与AUM相关的特征。Chetty的数据中可能有许多这样的特征，但我们首先调查了一个特别的特征：通勤区域内通勤时间在15分钟或更短的人口比例。
- en: Explaining Upward Mobility Using Commute Time
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用通勤时间解释向上流动性
- en: 'We begin our investigation by loading the data into a dataframe called `cz_df`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始通过将数据加载到名为`cz_df`的数据框中进行调查：
- en: '|   | aum | travel_lt15 | gini | rel_tot | ... | taxrate | worked_14 | foreign
    | region |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|   | aum | travel_lt15 | gini | rel_tot | ... | taxrate | worked_14 | foreign
    | 地区 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **0** | 38.39 | 0.33 | 0.47 | 0.51 | ... | 0.02 | 3.75e-03 | 1.18e-02 | South
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 38.39 | 0.33 | 0.47 | 0.51 | ... | 0.02 | 3.75e-03 | 1.18e-02 | 南部
    |'
- en: '| **1** | 37.78 | 0.28 | 0.43 | 0.54 | ... | 0.02 | 4.78e-03 | 2.31e-02 | South
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 37.78 | 0.28 | 0.43 | 0.54 | ... | 0.02 | 4.78e-03 | 2.31e-02 | 南部
    |'
- en: '| **2** | 39.05 | 0.36 | 0.44 | 0.67 | ... | 0.01 | 2.89e-03 | 7.08e-03 | South
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 39.05 | 0.36 | 0.44 | 0.67 | ... | 0.01 | 2.89e-03 | 7.08e-03 | 南部
    |'
- en: '| **...** | ... | ... | ... | ... | ... | ... | ... | ... | ... |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... | ... | ... | ... | ... | ... |'
- en: '| **702** | 44.12 | 0.42 | 0.42 | 0.29 | ... | 0.02 | 4.82e-03 | 9.85e-02 |
    West |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **702** | 44.12 | 0.42 | 0.42 | 0.29 | ... | 0.02 | 4.82e-03 | 9.85e-02 |
    西部 |'
- en: '| **703** | 41.41 | 0.49 | 0.41 | 0.26 | ... | 0.01 | 4.39e-03 | 4.33e-02 |
    West |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| **703** | 41.41 | 0.49 | 0.41 | 0.26 | ... | 0.01 | 4.39e-03 | 4.33e-02 |
    西部 |'
- en: '| **704** | 43.20 | 0.24 | 0.42 | 0.32 | ... | 0.02 | 3.67e-03 | 1.13e-01 |
    West |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **704** | 43.20 | 0.24 | 0.42 | 0.32 | ... | 0.02 | 3.67e-03 | 1.13e-01 |
    西部 |'
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each row represents one commuting zone. The column `aum` has the average AUM
    for people born in the commuting zone in 1980–1982 to parents in the 25th income
    percentile. There are many columns in this dataframe, but for now we focus on
    the fraction of people in a CZ that have a 15-minute or shorter commute time,
    which is called `travel_lt15`. We plot AUM against this fraction to look at the
    relationship between the two variables:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行代表一个通勤区。列 `aum` 是 1980–1982 年出生并且父母收入处于第25百分位数的人群的平均 AUM。数据框中有许多列，但现在我们专注于通勤区内通勤时间不超过15分钟的人群比例，即
    `travel_lt15`。我们将 AUM 与这个比例进行绘图，以探索这两个变量之间的关系：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](assets/leds_15in07.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in07.png)'
- en: 'The scatterplot shows a rough linear association between AUM and commute time.
    Indeed, we find the correlation to be quite strong:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 散点图显示 AUM 与通勤时间之间存在大致的线性关系。事实上，我们发现它们之间的相关性非常强：
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|   | aum | travel_lt15 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|   | aum | travel_lt15 |'
- en: '| --- | --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| aum | 1.00 | 0.68 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| aum | 1.00 | 0.68 |'
- en: '| travel_lt15 | 0.68 | 1.00 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| travel_lt15 | 0.68 | 1.00 |'
- en: 'Let’s fit a simple linear model to explain AUM with commute time:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的线性模型来解释 AUM 与通勤时间的关系：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The coefficients from the MSE minimization are:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: MSE 最小化得到的系数为：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Interestingly, an increase in upward mobility of a CZ is associated with an
    increase in the fraction of people with a short commute time.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，通勤区的向上流动增加与通勤时间较短的人群比例增加相关联。
- en: 'We can compare the SD of the AUM measurements to the SD of the residuals. This
    comparison gives us a sense of how useful the model is in explaining the AUM:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 AUM 测量的标准差与残差的标准差进行比较。这种比较让我们了解模型在解释 AUM 方面的实用性：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The size of the errors about the regression line has decreased from the constant
    model by about 25%.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕回归线的误差大小比常数模型减少了约 25%。
- en: 'Next, we examine the residuals for lack of fit since it can be easier to see
    potential problems with the fit in a residual plot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查残差来判断拟合的不合适，因为在残差图中更容易看出拟合存在的潜在问题：
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![](assets/leds_15in08.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in08.png)'
- en: It appears that the errors grow with AUM. We might try a transformation of the
    response variable, or fitting a model that is quadratic in the commute time fraction.
    We consider transformations and polynomials in the next section. First we see
    whether including additional variables offers a more accurate prediction of AUM.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来随着 AUM 的增加，误差也在增加。我们可以尝试对响应变量进行转换，或者拟合一个在通勤时间分数上是二次的模型。在下一节中我们将考虑变换和多项式。首先，我们看看包含额外变量是否能更准确地预测
    AUM。
- en: Relating Upward Mobility Using Multiple Variables
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个变量来关联向上流动
- en: In his original analysis, Chetty created several high-level features related
    to factors such as segregation, income, and K–12 education. We consider seven
    of Chetty’s predictors as we aim to build a more informative model for explaining
    AUM. These are described in [Table 15-1](#tbl-linear-predictors).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的原始分析中，Chetty 创建了几个与隔离、收入和 K–12 教育等因素相关的高级特征。我们考虑 Chetty 的七个预测因子，旨在构建一个更具信息性的模型来解释
    AUM。这些在 [Table 15-1](#tbl-linear-predictors) 中描述。
- en: Table 15-1\. Potential explanation for modeling AUM
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Table 15-1\. 解释 AUM 建模的潜在原因
- en: '| Column name | Description |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 列名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `travel_lt15` | Fraction of people with a ≤15-minute commute to work. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `travel_lt15` | 上班通勤时间不超过15分钟的人群比例。 |'
- en: '| `gini` | Gini coefficient, a measure of wealth inequality. Values are between
    0 and 1, where small values mean wealth is evenly distributed and large values
    mean more inequality. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `gini` | 基尼系数，财富不平等的度量。取值介于 0 到 1 之间，数值较小表示财富分配较均匀，较大表示不平等程度更大。 |'
- en: '| `rel_tot` | Fraction of people who self-reported as religious. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `rel_tot` | 自报宗教信仰的人群比例。 |'
- en: '| `single_mom` | Fraction of children with a single mother. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `single_mom` | 单身母亲的子女比例。 |'
- en: '| `taxrate` | Local tax rate. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `taxrate` | 地方税率。 |'
- en: '| `worked_14` | Fraction of 14- to 16-year-olds who work. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `worked_14` | 14 到 16 岁工作的人群比例。 |'
- en: '| `foreign` | Fraction of people born outside the US. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `foreign` | 出生于美国以外的人群比例。 |'
- en: 'Let’s first examine the correlations between AUM and the explanatory features
    and between the explanatory features themselves:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查 AUM 与解释性特征以及解释性特征之间的相关性：
- en: '|   | aum | travel_lt15 | gini | rel_tot | single_mom | taxrate | worked_14
    | foreign |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|   | aum | travel_lt15 | gini | rel_tot | single_mom | taxrate | worked_14
    | foreign |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **aum** | 1.00 | 0.68 | -0.60 | 0.52 | -0.77 | 0.35 | 0.65 | -0.03 |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **aum** | 1.00 | 0.68 | -0.60 | 0.52 | -0.77 | 0.35 | 0.65 | -0.03 |'
- en: '| **travel_lt15** | 0.68 | 1.00 | -0.56 | 0.40 | -0.42 | 0.34 | 0.60 | -0.19
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **travel_lt15** | 0.68 | 1.00 | -0.56 | 0.40 | -0.42 | 0.34 | 0.60 | -0.19
    |'
- en: '| **gini** | -0.60 | -0.56 | 1.00 | -0.29 | 0.57 | -0.15 | -0.58 | 0.31 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **gini** | -0.60 | -0.56 | 1.00 | -0.29 | 0.57 | -0.15 | -0.58 | 0.31 |'
- en: '| **rel_tot** | 0.52 | 0.40 | -0.29 | 1.00 | -0.31 | 0.08 | 0.28 | -0.11 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **rel_tot** | 0.52 | 0.40 | -0.29 | 1.00 | -0.31 | 0.08 | 0.28 | -0.11 |'
- en: '| **single_mom** | -0.77 | -0.42 | 0.57 | -0.31 | 1.00 | -0.26 | -0.60 | -0.04
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **single_mom** | -0.77 | -0.42 | 0.57 | -0.31 | 1.00 | -0.26 | -0.60 | -0.04
    |'
- en: '| **taxrate** | 0.35 | 0.34 | -0.15 | 0.08 | -0.26 | 1.00 | 0.35 | 0.26 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **taxrate** | 0.35 | 0.34 | -0.15 | 0.08 | -0.26 | 1.00 | 0.35 | 0.26 |'
- en: '| **worked_14** | 0.65 | 0.60 | -0.58 | 0.28 | -0.60 | 0.35 | 1.00 | -0.15
    |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| **worked_14** | 0.65 | 0.60 | -0.58 | 0.28 | -0.60 | 0.35 | 1.00 | -0.15
    |'
- en: '| **foreign** | -0.03 | -0.19 | 0.31 | -0.11 | -0.04 | 0.26 | -0.15 | 1.00
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **foreign** | -0.03 | -0.19 | 0.31 | -0.11 | -0.04 | 0.26 | -0.15 | 1.00
    |'
- en: We see that the fraction of single mothers in the commuting zone has the strongest
    correlation with AUM, which implies that it is also the single best feature to
    explain AUM. In addition, we see that several explanatory variables are highly
    correlated with each other; the Gini coefficient is highly correlated with the
    fraction of teenagers who work, the fraction of single mothers, and the fraction
    with less than a 15-minute commute. With such highly correlated features, we need
    to take care in interpreting the coefficients because several different models
    might equally explain AUM with the covariates standing in for one another.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，在通勤区中单身母亲的比例与AUM有最强的相关性，这意味着它也是解释AUM的最佳特征。此外，我们看到几个解释变量彼此之间高度相关；基尼系数与工作的青少年比例、单身母亲比例以及15分钟以下通勤比例高度相关。由于这些高度相关的特征，我们在解释系数时需要谨慎，因为几种不同的模型可能同样能够用协变量来解释AUM。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The vector geometry perspective that we introduced earlier in this chapter can
    help us understand the problem. Recall that a feature corresponds to a column
    vector in <math><mi>n</mi></math> -dimensions, like <math><mrow><mi mathvariant="bold">x</mi></mrow></math>
    . With two highly correlated features, <math><msub><mrow><mi mathvariant="bold">x</mi></mrow>
    <mn>1</mn></msub></math> and <math><msub><mrow><mi mathvariant="bold">x</mi></mrow>
    <mn>2</mn></msub></math> , these vectors are nearly in alignment. So the projection
    of the response vector <math><mrow><mi mathvariant="bold">y</mi></mrow></math>
    onto one of these vectors is nearly the same as the projection onto the other.
    The situation gets even murkier when several features are correlated with one
    another.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面介绍的向量几何视角可以帮助我们理解这个问题。回顾一下，一个特征对应于 <math><mi>n</mi></math> 维空间中的一个列向量，如
    <math><mrow><mi mathvariant="bold">x</mi></mrow></math> 。对于两个高度相关的特征 <math><msub><mrow><mi
    mathvariant="bold">x</mi></mrow> <mn>1</mn></msub></math> 和 <math><msub><mrow><mi
    mathvariant="bold">x</mi></mrow> <mn>2</mn></msub></math> ，这些向量几乎是对齐的。因此，响应向量
    <math><mrow><mi mathvariant="bold">y</mi></mrow></math> 在这些向量中的一个上的投影几乎与在另一个上的投影相同。当几个特征彼此相关时，情况变得更加混乱。
- en: To begin, we can consider all possible two-feature models to see which one has
    the smallest prediction error. Chetty derived 40 potential variables to use as
    predictors, which would have us checking <math><mo stretchy="false">(</mo> <mn>40</mn>
    <mo>×</mo> <mn>39</mn> <mo stretchy="false">)</mo> <mrow><mo>/</mo></mrow> <mn>2</mn>
    <mo>=</mo> <mn>780</mn></math> models. Fitting models, with all pairs, triples,
    and so on, of variables quickly grows out of control. And it can lead to finding
    spurious correlations (see [Chapter 17](ch17.html#ch-inf-pred-theory)).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以考虑所有可能的两特征模型，看看哪一个具有最小的预测误差。Chetty导出了40个潜在的变量作为预测变量，这将使我们检查 <math><mo
    stretchy="false">(</mo> <mn>40</mn> <mo>×</mo> <mn>39</mn> <mo stretchy="false">)</mo>
    <mrow><mo>/</mo></mrow> <mn>2</mn> <mo>=</mo> <mn>780</mn></math> 个模型。拟合模型时，所有成对、三元组等变量很快就会失控。这可能导致找到伪相关性（见[第17章](ch17.html#ch-inf-pred-theory)）。
- en: 'Here, we keep things a bit simpler and examine just one two-variable model
    that includes the travel time and single-mother features. After that, we look
    at the model that has all seven numeric explanatory features in our dataframe:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们保持事情稍微简单，只研究包含通勤时间和单身母亲特征的两变量模型。之后，我们查看包含数据框架中所有七个数值解释特征的模型：
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that the coefficient for travel time is quite different than the coefficient
    for this variable in the simple linear model. That’s because the two features
    in our model are highly correlated.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，旅行时间的系数与简单线性模型中这个变量的系数相比有很大不同。这是因为我们模型中的两个特征高度相关。
- en: 'Next we compare the errors from the two fits:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们比较这两个拟合的误差：
- en: '[PRE34]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The SD of the residuals have been reduced by another 30%. Adding a second variable
    to the model seems worth the extra complexity.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 残差的标准偏差进一步减少了30%。增加模型复杂性以添加第二个变量似乎是值得的。
- en: 'Let’s again visually examine the residuals. We use the same scale on the y-axis
    to make it easier to compare this residual plot with the plot for the one-variable
    model:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次直观地检查残差。我们使用与前一个单变量模型相同的y轴刻度，以便与其残差图进行比较：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](assets/leds_15in09.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in09.png)'
- en: The larger variability in the errors for higher AUM is even more evident. The
    implications are that the estimates, <math><mrow><mover><mi>y</mi> <mo stretchy="false">^</mo></mover></mrow></math>
    , are unaffected, but their accuracy depends on AUM. This problem can be addressed
    with *weighted regression*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对更高AUM的误差的较大变异性更为明显。这意味着估计值<math><mrow><mover><mi>y</mi> <mo stretchy="false">^</mo></mover></mrow></math>不受影响，但其准确性取决于AUM。可以通过*加权回归*来解决这个问题。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Once again, we point out that data scientists from different backgrounds use
    different terminology to refer to the same concept. For example, the terminology
    that calls each row in the design matrix <math><mtext mathvariant="bold">X</mtext></math>
    an observation and each column a variable is more common among people with backgrounds
    in statistics. Others say that each column of the design matrix represents a *feature*
    or that each row represents a *record*. Also, we say that our overall process
    of fitting and interpreting models is called *modeling*, while others call it
    *machine learning*.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，不同背景的数据科学家使用不同的术语来指代相同的概念。例如，将设计矩阵<math><mtext mathvariant="bold">X</mtext></math>中的每一行称为一个观察值，每一列称为一个变量的术语在统计背景的人群中更为常见。其他人则称设计矩阵的每一列代表一个*特征*，或者每一行代表一条*记录*。此外，我们称拟合和解释模型的整个过程为*建模*，而其他人则称其为*机器学习*。
- en: 'Now let’s fit a multiple linear model that uses all seven variables to explain
    upward mobility. After fitting the model, we again plot the errors using the same
    y-axis scale as in the previous two residual plots:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们拟合一个多元线性模型，使用所有七个变量来解释上升的流动性。在拟合模型之后，我们再次使用与前两个残差图相同的y轴刻度绘制误差：
- en: '[PRE37]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](assets/leds_15in10.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in10.png)'
- en: 'The model with seven features does not appear to be much better than the two-variable
    model. In fact, the standard deviation of the residuals has only decreased by 8%:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 具有七个特征的模型似乎并没有比具有两个变量的模型好多少。事实上，残差的标准偏差仅减少了8%：
- en: '[PRE39]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can compare the multiple <math><msup><mi>R</mi> <mn>2</mn></msup></math>
    for these three models:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以比较这三个模型的多元<math><msup><mi>R</mi> <mn>2</mn></msup></math>：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The adjustment for the number of features in the model makes little difference
    for us since we have over 700 observations. Now we have confirmed our earlier
    findings that using two variables greatly improves the explanatory capability
    of the model, and the seven-variable model offers little improvement over the
    two-variable model. The small gain is likely not worth the added complexity of
    the model.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，模型中特征数量的调整并没有太大差异，因为我们有超过700个观测值。现在我们已经确认了之前的发现，即使用两个变量大大改善了模型的解释能力，而七个变量模型几乎没有比两个变量模型有所改善。这种小的增益可能不值得模型的复杂性增加。
- en: So far, our models have used only numeric predictor variables. But categorical
    data is often useful for model fitting as well. Additionally, in [Chapter 10](ch10.html#ch-eda)
    we transformed variables and created new variables from combinations of variables.
    We address how to incorporate these variables into linear models next.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的模型仅使用了数值预测变量。但是类别数据在模型拟合中通常也很有用。此外，在[第10章](ch10.html#ch-eda)中，我们对变量进行了转换，并从变量的组合中创建了新的变量。接下来我们将讨论如何将这些变量纳入线性模型。
- en: Feature Engineering for Numeric Measurements
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值测量的特征工程
- en: All of the models that we have fit so far in this chapter have used numeric
    features that were originally provided in the dataframe. In this section, we look
    at variables that are created from transformations of numeric features. Transforming
    variables to use in modeling is called *feature engineering*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本章迄今为止我们拟合的所有模型都使用了最初在数据框中提供的数值特征。在本节中，我们将查看由数值特征变换创建的变量。将变量转换为建模使用的形式称为*特征工程*。
- en: We introduced feature engineering in Chapters [9](ch09.html#ch-wrangling) and
    [10](ch10.html#ch-eda). There, we transformed features so that they had symmetric
    distributions. Transformations can capture more kinds of patterns in the data
    and lead to better and more accurate models.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第[9章](ch09.html#ch-wrangling)和[10章](ch10.html#ch-eda)中引入了特征工程。在那里，我们对特征进行了转换，使它们具有对称分布。变换可以捕捉数据中更多种类的模式，并导致更好和更准确的模型。
- en: 'Let’s return to the dataset we used as an example in [Chapter 10](ch10.html#ch-eda):
    house sale prices in the San Francisco Bay Area. We restrict the data to houses
    sold in 2006, when sale prices were relatively stable, so we don’t need to account
    for trends in price.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们在[第10章](ch10.html#ch-eda)中作为示例使用的数据集：旧金山湾区的房屋销售价格。我们将数据限制在2006年售出的房屋，当时房价相对稳定，因此我们不需要考虑价格趋势。
- en: We wish to model sale price. Recall that visualizations in [Chapter 10](ch10.html#ch-eda)
    showed us that sale price was related to several features, like the size of the
    house, size of the lot, number of bedrooms, and location. We log-transformed both
    sale price and the size of the house to improve their relationship, and we saw
    that box plots of sale price by the number of bedrooms and box plots by city revealed
    interesting relationships too. In this section, we include transformed numeric
    features in a linear model. In the next section, we also add an ordinal feature
    (the number of bedrooms) and a nominal feature (the city) to the model.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望建立销售价格模型。回顾在[第10章](ch10.html#ch-eda)中的可视化结果，我们发现销售价格与多个特征相关，如房屋尺寸、地块尺寸、卧室数量和位置。我们对销售价格和房屋尺寸进行了对数变换以改善它们之间的关系，并且发现了关于卧室数量和城市的箱线图也显示了有趣的关系。在本节中，我们将在线性模型中包括转换后的数值特征。在下一节中，我们还将向模型添加序数特征（卧室数量）和名义特征（城市）。
- en: 'To begin, we’ll model sale price on house size. The correlation matrix tell
    us which of our numeric explanatory variables (original and transformed) is most
    strongly correlated with sale price:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在房屋尺寸上建立销售价格模型。相关矩阵告诉我们哪些数值解释变量（原始和转换后的）与销售价格最相关：
- en: '|   | price | br | lsqft | bsqft | log_price | log_bsqft | log_lsqft | ppsf
    | log_ppsf |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|   | price | br | lsqft | bsqft | log_price | log_bsqft | log_lsqft | ppsf
    | log_ppsf |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| **price** | 1.00 | 0.45 | 0.59 | 0.79 | 0.94 | 0.74 | 0.62 | 0.49 | 0.47
    |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| **price** | 1.00 | 0.45 | 0.59 | 0.79 | 0.94 | 0.74 | 0.62 | 0.49 | 0.47
    |'
- en: '| **br** | 0.45 | 1.00 | 0.29 | 0.67 | 0.47 | 0.71 | 0.38 | -0.18 | -0.21 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **br** | 0.45 | 1.00 | 0.29 | 0.67 | 0.47 | 0.71 | 0.38 | -0.18 | -0.21 |'
- en: '| **lsqft** | 0.59 | 0.29 | 1.00 | 0.46 | 0.55 | 0.44 | 0.85 | 0.29 | 0.27
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **lsqft** | 0.59 | 0.29 | 1.00 | 0.46 | 0.55 | 0.44 | 0.85 | 0.29 | 0.27
    |'
- en: '| **bsqft** | 0.79 | 0.67 | 0.46 | 1.00 | 0.76 | 0.96 | 0.52 | -0.08 | -0.10
    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| **bsqft** | 0.79 | 0.67 | 0.46 | 1.00 | 0.76 | 0.96 | 0.52 | -0.08 | -0.10
    |'
- en: '| **log_price** | 0.94 | 0.47 | 0.55 | 0.76 | 1.00 | 0.78 | 0.62 | 0.51 | 0.52
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| **log_price** | 0.94 | 0.47 | 0.55 | 0.76 | 1.00 | 0.78 | 0.62 | 0.51 | 0.52
    |'
- en: '| **log_bsqft** | 0.74 | 0.71 | 0.44 | 0.96 | 0.78 | 1.00 | 0.52 | -0.11 |
    -0.14 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| **log_bsqft** | 0.74 | 0.71 | 0.44 | 0.96 | 0.78 | 1.00 | 0.52 | -0.11 |
    -0.14 |'
- en: '| **log_lsqft** | 0.62 | 0.38 | 0.85 | 0.52 | 0.62 | 0.52 | 1.00 | 0.29 | 0.27
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **log_lsqft** | 0.62 | 0.38 | 0.85 | 0.52 | 0.62 | 0.52 | 1.00 | 0.29 | 0.27
    |'
- en: '| **ppsf** | 0.49 | -0.18 | 0.29 | -0.08 | 0.51 | -0.11 | 0.29 | 1.00 | 0.96
    |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| **ppsf** | 0.49 | -0.18 | 0.29 | -0.08 | 0.51 | -0.11 | 0.29 | 1.00 | 0.96
    |'
- en: '| **log_ppsf** | 0.47 | -0.21 | 0.27 | -0.10 | 0.52 | -0.14 | 0.27 | 0.96 |
    1.00 |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| **log_ppsf** | 0.47 | -0.21 | 0.27 | -0.10 | 0.52 | -0.14 | 0.27 | 0.96 |
    1.00 |'
- en: 'Sale price correlates most highly with house size, called `bsqft` for building
    square feet. We make a scatterplot of sale price against house size to confirm
    the association is linear:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 销售价格与房屋尺寸最相关，称为`bsqft`（建筑面积）。我们制作了销售价格与房屋尺寸的散点图，以确认这种关联是线性的：
- en: '![](assets/leds_15in11.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in11.png)'
- en: 'The relationship does look roughly linear, but the very large and expensive
    houses are far from the center of the distribution and can overly influence the
    model. As shown in [Chapter 10](ch10.html#ch-eda), the log transformation makes
    the distributions of price and size more symmetric (both are log base 10 to make
    it easier to convert the values into the original units):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 关系看起来大致是线性的，但非常大和昂贵的房屋远离分布中心，可能会对模型产生过度影响。如[第 10 章](ch10.html#ch-eda)所示，对数变换使得价格和尺寸的分布更对称（两者均为以对数
    10 为底以便于将值转换为原始单位）：
- en: '![](assets/leds_15in12.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in12.png)'
- en: Ideally, a model that uses transformations should make sense in the context
    of the data. If we fit a simple linear model based on log(size), then when we
    examine the coefficient, we think in terms of a percentage increase. For example,
    a doubling of <math><mi>x</mi></math> increases the prediction by <math><mi>θ</mi>
    <mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo> <mn>2</mn> <mo stretchy="false">)</mo></math>
    , since <math><mi>θ</mi> <mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo> <mn>2</mn>
    <mi>x</mi> <mo stretchy="false">)</mo> <mo>=</mo> <mi>θ</mi> <mi>log</mi> <mo>⁡</mo>
    <mo stretchy="false">(</mo> <mn>2</mn> <mo stretchy="false">)</mo> <mo>+</mo>
    <mi>θ</mi> <mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo> <mi>x</mi> <mo
    stretchy="false">)</mo></math> .
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，使用变换的模型应当在数据的背景下有意义。如果我们基于对数（大小）拟合一个简单的线性模型，那么在检查系数时，我们可以考虑百分比增加。例如，<math><mi>x</mi></math>翻倍会使预测增加<math><mi>θ</mi><mi>log</mi>
    <mo>⁡</mo> <mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></math>，因为<math><mi>θ</mi><mi>log</mi>
    <mo>⁡</mo> <mo stretchy="false">(</mo><mn>2</mn><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>θ</mi><mi>log</mi>
    <mo>⁡</mo> <mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>θ</mi><mi>log</mi>
    <mo>⁡</mo> <mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math>。
- en: 'Let’s begin by fitting a model that explains log-transformed price by the house’s
    log-transformed size. But first, we note that this model is still considered a
    linear model. If we represent sale price by <math><mi>y</mi></math> and house
    size by <math><mi>x</mi></math> , then the model is:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从拟合一个通过房屋大小的对数变换解释的模型开始。但首先，我们注意到这个模型仍然被认为是一个线性模型。如果我们用<math><mi>y</mi></math>表示销售价格，<math><mi>x</mi></math>表示房屋大小，那么该模型是：
- en: <math display="block"><mtable columnalign="right left" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo>
    <mi>y</mi> <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>log</mi> <mo>⁡</mo>
    <mo stretchy="false">(</mo> <mi>x</mi> <mo stretchy="false">)</mo></mtd></mtr></mtable></math>
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right left" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo>
    <mi>y</mi> <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>log</mi> <mo>⁡</mo>
    <mo stretchy="false">(</mo> <mi>x</mi> <mo stretchy="false">)</mo></mtd></mtr></mtable></math>
- en: '(Note that we have ignored the approximation in this equation to make the linear
    relationship clearer.) This equation may not seem linear, but if we rename <math><mi>log</mi>
    <mo>⁡</mo> <mo stretchy="false">(</mo> <mi>y</mi> <mo stretchy="false">)</mo></math>
    to <math><mi>w</mi></math> and <math><mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo>
    <mi>x</mi> <mo stretchy="false">)</mo></math> to <math><mi>v</mi></math> , then
    we can express this “log–log” relationship as a linear model in <math><mi>w</mi></math>
    and <math><mi>v</mi></math> :'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，在这个方程中，我们忽略了近似以使线性关系更加清晰。）这个方程可能看起来不是线性的，但如果我们将<math><mi>log</mi> <mo>⁡</mo>
    <mo stretchy="false">(</mo> <mi>y</mi> <mo stretchy="false">)</mo></math>重命名为<math><mi>w</mi></math>，<math><mi>log</mi>
    <mo>⁡</mo> <mo stretchy="false">(</mo> <mi>x</mi> <mo stretchy="false">)</mo></math>重命名为<math><mi>v</mi></math>，那么我们可以将这种“对数-对数”关系表达为<math><mi>w</mi></math>和<math><mi>v</mi></math>的线性模型：
- en: <math display="block"><mi>w</mi>  <mo>=</mo>  <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>v</mi></math>
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mi>w</mi>  <mo>=</mo>  <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>v</mi></math>
- en: 'Other examples of models that can be expressed as linear combinations of transformed
    features are:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可以表达为转换特征的线性组合的其他模型示例是：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo>
    <mi>y</mi> <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>θ</mi>
    <mn>2</mn></msub> <msup><mi>x</mi> <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mi>y</mi></mtd>
    <mtd><mo>=</mo>  <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mi>z</mi>
    <mo>+</mo> <msub><mi>θ</mi> <mn>3</mn></msub> <mi>x</mi> <mi>z</mi></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo>
    <mi>y</mi> <mo stretchy="false">)</mo></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>θ</mi>
    <mn>2</mn></msub> <msup><mi>x</mi> <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mi>y</mi></mtd>
    <mtd><mo>=</mo>  <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mi>z</mi>
    <mo>+</mo> <msub><mi>θ</mi> <mn>3</mn></msub> <mi>x</mi> <mi>z</mi></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: 'Again, if we rename <math><mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo>
    <mi>y</mi> <mo stretchy="false">)</mo></math> to <math><mi>w</mi></math> , <math><msup><mi>x</mi>
    <mn>2</mn></msup></math> to <math><mi>u</mi></math> , and <math><mi>x</mi> <mi>z</mi></math>
    as <math><mi>t</mi></math> , then we can express each of these models as linear
    in these renamed features. In order, the preceding models are now:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们将<math><mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo> <mi>y</mi>
    <mo stretchy="false">)</mo></math>重命名为<math><mi>w</mi></math>，<math><msup><mi>x</mi>
    <mn>2</mn></msup></math>重命名为<math><mi>u</mi></math>，<math><mi>x</mi><mi>z</mi></math>重命名为<math><mi>t</mi></math>，那么我们可以将每个模型表示为这些重命名特征的线性组合。按顺序，前述模型现在是：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mi>w</mi></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>θ</mi>
    <mn>2</mn></msub> <mi>u</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo>
    <msub><mi>θ</mi> <mn>2</mn></msub> <mi>z</mi> <mo>+</mo> <msub><mi>θ</mi> <mn>3</mn></msub>
    <mi>t</mi></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mi>w</mi></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi></mtd></mtr>
    <mtr><mtd><mi>y</mi></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi> <mn>0</mn></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo> <msub><mi>θ</mi>
    <mn>2</mn></msub> <mi>u</mi></mtd></mtr> <mtr><mtd><mi>y</mi></mtd> <mtd><mo>=</mo>  <msub><mi>θ</mi>
    <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mi>x</mi> <mo>+</mo>
    <msub><mi>θ</mi> <mn>2</mn></msub> <mi>z</mi> <mo>+</mo> <msub><mi>θ</mi> <mn>3</mn></msub>
    <mi>t</mi></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: In short, we can think of models that include nonlinear transformations of features
    and/or combinations of features as linear in their derived features. In practice,
    we don’t rename the transformed features when we describe the model; instead,
    we write the model using the transformations of the original features because
    it’s important to keep track of them, especially when interpreting the coefficients
    and checking residual plots.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 简言之，我们可以将包含特征的非线性变换和/或特征组合的模型视为其派生特征的线性。在实践中，当我们描述模型时，我们不会重命名转换后的特征；相反，我们使用原始特征的变换，因为在解释系数和检查残差图时保持追踪它们非常重要。
- en: When we refer to these models, we include mention of the transformations. That
    is, we call a model *log–log* when both the outcome and explanatory variables
    are log-transformed; we say it’s *log–linear* when the outcome is log-transformed
    but not the explanatory variable; we describe a model as having *polynomial features*
    of, say, degree two when the first and second power transformations of the explanatory
    variable are included; and we say a model includes an *interaction term* between
    two explanatory features when the product of these two features is included in
    the model.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提及这些模型时，我们包括对变换的提及。也就是说，当结果和解释变量都经过对数变换时，我们称之为*对数-对数*模型；当结果经过对数变换而解释变量没有时，我们称之为*对数-线性*；当解释变量包括二次幂变换时，我们描述模型具有二次*多项式特征*；当两个解释特征的乘积包含在模型中时，我们称之为*交互项*。
- en: 'Let’s fit a log–log model of price on size:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拟合一个价格对大小的对数-对数模型：
- en: '[PRE42]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The coefficients and predicted values from this model cannot be directly compared
    to a model fitted using linear features because the units are the log of dollars
    and log of square feet, not dollars and square feet.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型的系数和预测值不能直接与使用线性特征拟合的模型进行比较，因为其单位是美元和平方英尺的对数，而不是美元和平方英尺。
- en: 'Next, we examine the residuals and predicted values with a plot:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过图表检查残差和预测值：
- en: '[PRE43]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![](assets/leds_15in13.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in13.png)'
- en: The residual plot looks reasonable, but it contains thousands of points, which
    makes it hard to see curvature.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 残差图看起来合理，但其中包含数千个点，这使得难以看到曲线。
- en: 'To see if additional variables might be helpful, we can plot the residuals
    from the fitted model against a variable that is not in the model. If we see patterns,
    that indicates we might want to include this additional feature or a transformation
    of it. Earlier, we found that the distribution of price was related to the city
    where the house is located, so let’s examine the relationship between the residuals
    and city:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看是否有助于增加额外的变量，我们可以绘制拟合模型的残差图针对不在模型中的变量。如果看到模式，那就表明我们可能想要包括这个额外特征或其转换。之前，我们发现价格分布与房屋所在城市相关，因此让我们检查残差与城市之间的关系：
- en: '![](assets/leds_15in14.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in14.png)'
- en: This plot shows us that the distribution of errors appears shifted by city.
    Ideally, the median of each city’s box plot lines up with 0 on the y-axis. Instead,
    more than 75% of the houses sold in Piedmont have positive errors, meaning the
    actual sale price is above the predicted value. And at the other extreme, more
    than 75% of sale prices in Richmond fall below their predicted values. These patterns
    suggest that we should include city in the model. From a context point of view,
    it makes sense for location to impact sale price. In the next section, we show
    how to incorporate a nominal variable into a linear model.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表显示了错误的分布似乎受到城市的影响。理想情况下，每个城市的箱线图中位数应该与y轴上的0对齐。然而，皮德蒙特出售的房屋超过75%存在正误差，这意味着实际销售价格高于预测值。而在另一个极端，里士满超过75%的销售价格低于预测值。这些模式表明我们应该在模型中包括城市变量。从背景来看，地理位置影响销售价格是有道理的。在接下来的部分，我们展示了如何将名义变量纳入线性模型。
- en: Feature Engineering for Categorical Measurements
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类测量的特征工程
- en: 'The first model we ever fit was the constant model in [Chapter 4](ch04.html#ch-modeling).
    There, we minimized squared loss to find the best-fitting constant:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次拟合的模型是[第四章](ch04.html#ch-modeling)中的常数模型。在那里，我们最小化平方损失以找到最适合的常数：
- en: <math display="block"><munder><mo movablelimits="true">min</mo> <mi>c</mi></munder>
    <munder><mo>∑</mo> <mi>i</mi></munder> <mo stretchy="false">(</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <mi>c</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></math>
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><munder><mo movablelimits="true">min</mo> <mi>c</mi></munder>
    <munder><mo>∑</mo> <mi>i</mi></munder> <mo stretchy="false">(</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <mi>c</mi> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></math>
- en: 'We can think of including a nominal feature in a model in a similar fashion.
    That is, we find the best-fitting constant to each subgroup of the data corresponding
    to a category:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑以类似的方式在模型中包含名义特征。也就是说，我们找到每个数据子组中最适合的常数，对应于一个类别：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><munder><mo movablelimits="true">min</mo>
    <mrow><msub><mi>c</mi> <mi>B</mi></msub></mrow></munder> <munder><mo>∑</mo> <mrow><mi>i</mi>
    <mo>∈</mo> <mtext>Berkeley</mtext></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd> <mtd><munder><mo movablelimits="true">min</mo>
    <mrow><msub><mi>c</mi> <mi>L</mi></msub></mrow></munder> <munder><mo>∑</mo> <mrow><mi>i</mi>
    <mo>∈</mo> <mtext>Lamorinda</mtext></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>c</mi> <mi>L</mi></msub>
    <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr> <mtr><mtd><munder><mo
    movablelimits="true">min</mo> <mrow><msub><mi>c</mi> <mi>P</mi></msub></mrow></munder>
    <munder><mo>∑</mo> <mrow><mi>i</mi> <mo>∈</mo> <mtext>Piedmont</mtext></mrow></munder>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>c</mi>
    <mi>P</mi></msub> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd> <mtd>   <munder><mo
    movablelimits="true">min</mo> <mrow><msub><mi>c</mi> <mi>R</mi></msub></mrow></munder>
    <munder><mo>∑</mo> <mrow><mi>i</mi> <mo>∈</mo> <mtext>Richmond</mtext></mrow></munder>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>c</mi>
    <mi>R</mi></msub> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><munder><mo movablelimits="true">min</mo>
    <mrow><msub><mi>c</mi> <mi>B</mi></msub></mrow></munder> <munder><mo>∑</mo> <mrow><mi>i</mi>
    <mo>∈</mo> <mtext>Berkeley</mtext></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>c</mi> <mi>B</mi></msub>
    <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd> <mtd><munder><mo movablelimits="true">min</mo>
    <mrow><msub><mi>c</mi> <mi>L</mi></msub></mrow></munder> <munder><mo>∑</mo> <mrow><mi>i</mi>
    <mo>∈</mo> <mtext>Lamorinda</mtext></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>c</mi> <mi>L</mi></msub>
    <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr> <mtr><mtd><munder><mo
    movablelimits="true">min</mo> <mrow><msub><mi>c</mi> <mi>P</mi></msub></mrow></munder>
    <munder><mo>∑</mo> <mrow><mi>i</mi> <mo>∈</mo> <mtext>Piedmont</mtext></mrow></munder>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>c</mi>
    <mi>P</mi></msub> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd> <mtd>   <munder><mo
    movablelimits="true">min</mo> <mrow><msub><mi>c</mi> <mi>R</mi></msub></mrow></munder>
    <munder><mo>∑</mo> <mrow><mi>i</mi> <mo>∈</mo> <mtext>Richmond</mtext></mrow></munder>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>c</mi>
    <mi>R</mi></msub> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: Another way to describe this model is with *one-hot encoding*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种描述这种模型的方式是*独热编码*。
- en: One-hot encoding takes a categorical feature and creates multiple numeric features
    that have only the values 0 or 1\. To one-hot encode a feature, we create new
    features, one for each unique category. In this case, since we have four cities—Berkeley,
    Lamorinda, Piedmont, and Richmond—we create four new features in a design matrix,
    called <math><msub><mi>X</mi> <mrow><mi>c</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi></mrow></msub></math>
    . Each row in <math><msub><mi>X</mi> <mrow><mi>c</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi></mrow></msub></math>
    contains one value of 1, and it appears in the column that corresponds to the
    city. All other columns contain 0 for that row. [Figure 15-6](#fig-one-hot2) illustrates
    this notion.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 独热编码将分类特征转换为多个只有0或1值的数值特征。为了对一个特征进行独热编码，我们创建新的特征，每个唯一的类别对应一个新的特征。在本例中，由于有四个城市——伯克利、Lamorinda、皮德蒙特和里士满——我们在一个设计矩阵中创建了四个新特征，称为
    <math><msub><mi>X</mi> <mrow><mi>c</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi></mrow></msub></math>
    。 <math><msub><mi>X</mi> <mrow><mi>c</mi> <mi>i</mi> <mi>t</mi> <mi>y</mi></mrow></msub></math>
    中的每一行包含一个值为1，它出现在与城市对应的列中。 [图15-6](#fig-one-hot2)说明了这一概念。
- en: '![](assets/leds_1506.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_1506.png)'
- en: Figure 15-6\. One-hot encoding for a categorical feature with six rows (left)
    and its resulting design matrix (right)
  id: totrans-352
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-6\. 对一个分类特征进行独热编码（左）及其生成的设计矩阵（右）
- en: 'Now we can concisely represent the model as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以简洁地表示模型如下：
- en: <math display="block"><msub><mi>θ</mi> <mi>B</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi>
    <mo>,</mo> <mi>B</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi> <mi>L</mi></msub>
    <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>P</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>R</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub></math>
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><msub><mi>θ</mi> <mi>B</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi>
    <mo>,</mo> <mi>B</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi> <mi>L</mi></msub>
    <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>P</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>R</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub></math>
- en: Here, we have indexed the columns of the design matrix by <math><mi>B</mi></math>
    , <math><mi>L</mi></math> , <math><mi>P</mi></math> , and <math><mi>R</mi></math>
    , rather than <math><mi>j</mi></math> , to make it clear that each column represents
    a column of 0s and 1s where, say, a 1 appears for <math><msub><mi>x</mi> <mrow><mi>i</mi>
    <mo>,</mo> <mi>P</mi></mrow></msub></math> if the <math><mi>i</mi></math> th house
    is located in Piedmont.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用 <math><mi>B</mi></math> ，<math><mi>L</mi></math> ，<math><mi>P</mi></math>
    和 <math><mi>R</mi></math> 对设计矩阵的列进行了索引，而不是 <math><mi>j</mi></math> ，以明确表示每一列代表一个只有0和1的列，例如，如果第
    <math><mi>i</mi></math> 个房屋位于皮德蒙特，则 <math><msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo>
    <mi>P</mi></mrow></msub></math> 为1。
- en: Note
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: One-hot encoding creates features that have only 0-1 values. These features
    are also known as *dummy variable* or *indicator variable*. The term “dummy variable”
    is more common in econometrics, and the usage of “indicator variable” is more
    common in statistics.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 独热编码创建的特征仅具有0-1值。这些特征也被称为*虚拟变量*或*指示变量*。在计量经济学中更常用“虚拟变量”这一术语，在统计学中更常用“指示变量”。
- en: 'Our goal is to minimize least square loss over <math><mi mathvariant="bold-italic">θ</mi></math>
    :'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是最小化关于 <math><mi mathvariant="bold-italic">θ</mi></math> 的最小二乘损失：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mo fence="false" stretchy="false">‖</mo>
    <mrow><mi mathvariant="bold">y</mi></mrow> <mo>−</mo> <mtext mathvariant="bold">X</mtext>
    <mi mathvariant="bold-italic">θ</mi> <msup><mo fence="false" stretchy="false">‖</mo>
    <mn>2</mn></msup></mtd> <mtd><mo>=</mo> <munder><mo>∑</mo> <mi>i</mi></munder>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi>
    <mi>B</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>B</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>L</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>P</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>R</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub>
    <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mo>=</mo>
    <munder><mo>∑</mo> <mrow><mi>i</mi> <mo>∈</mo> <mi>B</mi> <mi>e</mi> <mi>r</mi>
    <mi>k</mi> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>y</mi></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi> <mi>B</mi></msub>
    <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>B</mi></mrow></msub> <msup><mo
    stretchy="false">)</mo> <mn>2</mn></msup>  <mo>+</mo>  <munder><mo>∑</mo> <mrow><mi>i</mi>
    <mo>∈</mo> <mi>L</mi> <mi>a</mi> <mi>m</mi> <mi>o</mi> <mi>r</mi> <mi>i</mi> <mi>n</mi>
    <mi>d</mi> <mi>a</mi></mrow></munder> <mo stretchy="false">(</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi> <mi>L</mi></msub> <msub><mi>x</mi>
    <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></mtd></mtr> <mtr><mtd> <mo>+</mo>  <munder><mo>∑</mo> <mrow><mi>i</mi>
    <mo>∈</mo> <mi>P</mi> <mi>i</mi> <mi>e</mi> <mi>d</mi> <mi>m</mi> <mi>o</mi> <mi>n</mi>
    <mi>t</mi></mrow></munder> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>−</mo> <msub><mi>θ</mi> <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi>
    <mo>,</mo> <mi>P</mi></mrow></msub> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup>  <mo>+</mo>  <munder><mo>∑</mo>
    <mrow><mi>i</mi> <mo>∈</mo> <mi>R</mi> <mi>i</mi> <mi>c</mi> <mi>h</mi> <mi>m</mi>
    <mi>o</mi> <mi>n</mi> <mi>d</mi></mrow></munder> <mo stretchy="false">(</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi> <mi>R</mi></msub> <msub><mi>x</mi>
    <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em"
    displaystyle="true" rowspacing="3pt"><mtr><mtd><mo fence="false" stretchy="false">‖</mo>
    <mrow><mi mathvariant="bold">y</mi></mrow> <mo>−</mo> <mtext mathvariant="bold">X</mtext>
    <mi mathvariant="bold-italic">θ</mi> <msup><mo fence="false" stretchy="false">‖</mo>
    <mn>2</mn></msup></mtd> <mtd><mo>=</mo> <munder><mo>∑</mo> <mi>i</mi></munder>
    <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi>
    <mi>B</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>B</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>L</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>P</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>R</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub>
    <msup><mo stretchy="false">)</mo> <mn>2</mn></msup></mtd></mtr> <mtr><mtd><mo>=</mo>
    <munder><mo>∑</mo> <mrow><mi>i</mi> <mo>∈</mo> <mi>B</mi> <mi>e</mi> <mi>r</mi>
    <mi>k</mi> <mi>e</mi> <mi>l</mi> <mi>e</mi> <mi>y</mi></mrow></munder> <mo stretchy="false">(</mo>
    <msub><mi>y</mi> <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi> <mi>B</mi></msub>
    <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>B</mi></mrow></msub> <msup><mo
    stretchy="false">)</mo> <mn>2</mn></msup>  <mo>+</mo>  <munder><mo>∑</mo> <mrow><mi>i</mi>
    <mo>∈</mo> <mi>L</mi> <mi>a</mi> <mi>m</mi> <mi>o</mi> <mi>r</mi> <mi>i</mi> <mi>n</mi>
    <mi>d</mi> <mi>a</mi></mrow></munder> <mo stretchy="false">(</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi> <mi>L</mi></msub> <msub><mi>x</mi>
    <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></mtd></mtr> <mtr><mtd> <mo>+</mo>  <munder><mo>∑</mo> <mrow><mi>i</mi>
    <mo>∈</mo> <mi>P</mi> <mi>i</mi> <mi>e</mi> <mi>d</mi> <mi>m</mi> <mi>o</mi> <mi>n</mi>
    <mi>t</mi></mrow></munder> <mo stretchy="false">(</mo> <msub><mi>y</mi> <mi>i</mi></msub>
    <mo>−</mo> <msub><mi>θ</mi> <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi>
    <mo>,</mo> <mi>P</mi></mrow></msub> <msup><mo stretchy="false">)</mo> <mn>2</mn></msup>  <mo>+</mo>  <munder><mo>∑</mo>
    <mrow><mi>i</mi> <mo>∈</mo> <mi>R</mi> <mi>i</mi> <mi>c</mi> <mi>h</mi> <mi>m</mi>
    <mi>o</mi> <mi>n</mi> <mi>d</mi></mrow></munder> <mo stretchy="false">(</mo> <msub><mi>y</mi>
    <mi>i</mi></msub> <mo>−</mo> <msub><mi>θ</mi> <mi>R</mi></msub> <msub><mi>x</mi>
    <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub> <msup><mo stretchy="false">)</mo>
    <mn>2</mn></msup></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: where <math><mi mathvariant="bold-italic">θ</mi></math> is the column vector
    <math><mo stretchy="false">[</mo> <msub><mi>θ</mi> <mi>B</mi></msub> <mo>,</mo>
    <msub><mi>θ</mi> <mi>L</mi></msub> <mo>,</mo> <msub><mi>θ</mi> <mi>P</mi></msub>
    <mo>,</mo> <msub><mi>θ</mi> <mi>R</mi></msub> <mo stretchy="false">]</mo></math>
    . Notice that this minimization reduces to four minimizations, one for each city.
    That’s the idea that we started with at the beginning of this section.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 <math><mi mathvariant="bold-italic">θ</mi></math> 是列向量 <math><mo stretchy="false">[</mo>
    <msub><mi>θ</mi> <mi>B</mi></msub> <mo>,</mo> <msub><mi>θ</mi> <mi>L</mi></msub>
    <mo>,</mo> <msub><mi>θ</mi> <mi>P</mi></msub> <mo>,</mo> <msub><mi>θ</mi> <mi>R</mi></msub>
    <mo stretchy="false">]</mo></math> 。注意，这个最小化转化为四个最小化，每个城市对应一个。这正是我们在本节开始时提到的思路。
- en: 'We can use `OneHotEncoder` to create this design matrix:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `OneHotEncoder` 创建这个设计矩阵：
- en: '[PRE45]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|   | Berkeley | Lamorinda | Piedmont | Richmond |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|   | 伯克利 | Lamorinda | 皮德蒙特 | 里士满 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **0** | 1.0 | 0.0 | 0.0 | 0.0 |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **0** | 1.0 | 0.0 | 0.0 | 0.0 |'
- en: '| **1** | 1.0 | 0.0 | 0.0 | 0.0 |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 1.0 | 0.0 | 0.0 | 0.0 |'
- en: '| **2** | 1.0 | 0.0 | 0.0 | 0.0 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 1.0 | 0.0 | 0.0 | 0.0 |'
- en: '| **...** | ... | ... | ... | ... |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... |'
- en: '| **2664** | 0.0 | 0.0 | 0.0 | 1.0 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| **2664** | 0.0 | 0.0 | 0.0 | 1.0 |'
- en: '| **2665** | 0.0 | 0.0 | 0.0 | 1.0 |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| **2665** | 0.0 | 0.0 | 0.0 | 1.0 |'
- en: '| **2666** | 0.0 | 0.0 | 0.0 | 1.0 |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| **2666** | 0.0 | 0.0 | 0.0 | 1.0 |'
- en: '[PRE46]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let’s fit a model using these one-hot encoded features:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些独热编码特征拟合一个模型：
- en: '[PRE47]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And examine the multiple <math><msup><mi>R</mi> <mn>2</mn></msup></math> :'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '并且检查多重 <math><msup><mi>R</mi> <mn>2</mn></msup></math> :'
- en: '[PRE48]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we only know the city where a house is located, the model does a reasonably
    good job of estimating its sale price. Here are the coefficients from the fit:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只知道房屋所在的城市，该模型能够相当不错地估计其销售价格。以下是拟合的系数：
- en: '[PRE49]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As expected from the box plots, the estimated sale price (in log $) depends
    on the city. But if we know the size of the house as well as the city, we should
    have an even better model. We saw earlier that the simple log–log model that explains
    sale price by house size fits reasonably well, so we expect that the city feature
    (as one-hot encoded variables) should further improve the model.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 正如盒图所示，估计的销售价格（以对数$表示）取决于城市。但是，如果我们知道房屋大小和城市，我们应该会有一个更好的模型。我们之前看到，简单的对数模型可以合理解释销售价格与房屋大小的关系，因此我们期望城市特征（作为独热编码变量）应该进一步改进模型。
- en: 'Such a model looks like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的模型如下所示：
- en: <math display="block"><msub><mi>y</mi> <mi>i</mi></msub>  <mo>≈</mo>  <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mi>B</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>B</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>L</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>P</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>R</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub></math>
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><msub><mi>y</mi> <mi>i</mi></msub>  <mo>≈</mo>  <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub> <mo>+</mo> <msub><mi>θ</mi>
    <mi>B</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>B</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>L</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>P</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>R</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub></math>
- en: 'Notice that this model describes the relationship between log(price), which
    is represented as <math><mi>y</mi></math> , and log(size), which is represented
    as <math><mi>x</mi></math> , as linear with the same coefficient for log(size)
    for each city. But the intercept term depends on the city:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个模型描述了对数价格（表示为<math><mi>y</mi></math>）和对数大小（表示为<math><mi>x</mi></math>）之间的关系，对于每个城市的对数大小都具有相同的系数。但截距项取决于城市：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left right" columnspacing="0em
    2em" displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mi>y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>≈</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mi>B</mi></msub></mtd> <mtd><mtext>for houses in
    Berkeley</mtext></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>≈</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mi>L</mi></msub></mtd> <mtd><mtext>for houses in
    Lamorinda</mtext></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>≈</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mi>P</mi></msub></mtd> <mtd><mtext>for houses in
    Piedmont</mtext></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>≈</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mi>R</mi></msub></mtd> <mtd><mtext>for houses in
    Richmond</mtext></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left right" columnspacing="0em
    2em" displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mi>y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>≈</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mi>B</mi></msub></mtd> <mtd><mtext>for houses in
    Berkeley</mtext></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>≈</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mi>L</mi></msub></mtd> <mtd><mtext>for houses in
    Lamorinda</mtext></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>≈</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mi>P</mi></msub></mtd> <mtd><mtext>for houses in
    Piedmont</mtext></mtd></mtr> <mtr><mtd><msub><mi>y</mi> <mi>i</mi></msub></mtd>
    <mtd><mo>≈</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>
    <mo>+</mo> <msub><mi>θ</mi> <mi>R</mi></msub></mtd> <mtd><mtext>for houses in
    Richmond</mtext></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: 'We next make a facet of scatterplots, one for each city, to see if this relationship
    roughly holds:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们制作一个散点图的多面板图，每个城市一个，看看这种关系大致成立：
- en: '[PRE51]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![](assets/leds_15in15.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in15.png)'
- en: 'The shift is evident in the scatterplot. We concatenate our two design matrices
    together to fit the model that includes size and city:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在散点图中可以看出这种偏移。我们将两个设计矩阵连接在一起，以拟合包含大小和城市的模型：
- en: '[PRE52]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|   | log_bsqft | Berkeley | Lamorinda | Piedmont | Richmond |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '|   | log_bsqft | 伯克利 | Lamorinda | 皮德蒙特 | 里士满 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **1** | 3.14 | 1.0 | 0.0 | 0.0 | 0.0 |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| **1** | 3.14 | 1.0 | 0.0 | 0.0 | 0.0 |'
- en: '| **2** | 3.31 | 1.0 | 0.0 | 0.0 | 0.0 |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| **2** | 3.31 | 1.0 | 0.0 | 0.0 | 0.0 |'
- en: '| **3** | 2.96 | 1.0 | 0.0 | 0.0 | 0.0 |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| **3** | 2.96 | 1.0 | 0.0 | 0.0 | 0.0 |'
- en: '| **...** | ... | ... | ... | ... | ... |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| **...** | ... | ... | ... | ... | ... |'
- en: '| **2664** | 3.16 | 0.0 | 0.0 | 0.0 | 1.0 |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| **2664** | 3.16 | 0.0 | 0.0 | 0.0 | 1.0 |'
- en: '| **2665** | 3.47 | 0.0 | 0.0 | 0.0 | 1.0 |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| **2665** | 3.47 | 0.0 | 0.0 | 0.0 | 1.0 |'
- en: '| **2666** | 3.44 | 0.0 | 0.0 | 0.0 | 1.0 |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| **2666** | 3.44 | 0.0 | 0.0 | 0.0 | 1.0 |'
- en: '[PRE53]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now let’s fit a model that incorporates the quantitative feature, the house
    size, and the qualitative feature, location (city):'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们拟合一个包含定量特征（房屋大小）和定性特征（城市）的模型：
- en: '[PRE54]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The intercepts reflect which cities have more expensive houses, even taking
    into account the size of the house:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这些截距反映了哪些城市的房屋更贵，即使考虑到房屋的大小：
- en: '[PRE55]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This fit, which includes the nominal variable `city` and the log-transformed
    house size, is better than both the simple log–log model with house size and the
    model that fits constants for each city.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个拟合模型包括名义变量`city`和对数变换后的房屋大小，比仅包含房屋大小的简单对数模型以及为每个城市拟合常数的模型都要好。
- en: 'Notice that we dropped the intercept from the model so that each subgroup has
    its own intercept. However, a common practice is to remove one of the one-hot
    encoded features from the design matrix and keep the intercept. For example, if
    we drop the feature for Berkeley houses and add the intercept, then the model
    is:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们从模型中删除了截距项，以便每个子组都有自己的截距。然而，一个常见的做法是从设计矩阵中删除一个独热编码特征，并保留截距。例如，如果我们删除伯克利房屋的特征并添加截距，那么模型就是：
- en: <math display="block"><msub><mi>θ</mi> <mn>0</mn></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>L</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>P</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>R</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub></math>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><msub><mi>θ</mi> <mn>0</mn></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>L</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>L</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>P</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>P</mi></mrow></msub>  <mo>+</mo>  <msub><mi>θ</mi>
    <mi>R</mi></msub> <msub><mi>x</mi> <mrow><mi>i</mi> <mo>,</mo> <mi>R</mi></mrow></msub></math>
- en: 'The meaning of the coefficients for the dummy variables has changed in this
    representation. For example, consider this equation for a house in Berkeley and
    a house in Piedmont:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种表示中，虚拟变量的系数意义在这个表述中已经改变了。例如，考虑伯克利和皮德蒙特的房屋的方程式：
- en: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left right" columnspacing="0em
    2em" displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mi>θ</mi> <mn>0</mn></msub></mtd>
    <mtd><mo>+</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub></mtd>
    <mtd><mtext>for a house in Berkeley</mtext></mtd></mtr> <mtr><mtd><msub><mi>θ</mi>
    <mn>0</mn></msub></mtd> <mtd><mo>+</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>+</mo> <msub><mi>θ</mi> <mi>P</mi></msub></mtd> <mtd><mtext>for
    a house in Piedmont</mtext></mtd></mtr></mtable></mtd></mtr></mtable></math>
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true"
    rowspacing="3pt"><mtr><mtd><mtable columnalign="right left right" columnspacing="0em
    2em" displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mi>θ</mi> <mn>0</mn></msub></mtd>
    <mtd><mo>+</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi> <mi>i</mi></msub></mtd>
    <mtd><mtext>for a house in Berkeley</mtext></mtd></mtr> <mtr><mtd><msub><mi>θ</mi>
    <mn>0</mn></msub></mtd> <mtd><mo>+</mo>  <msub><mi>θ</mi> <mn>1</mn></msub> <msub><mi>x</mi>
    <mi>i</mi></msub> <mo>+</mo> <msub><mi>θ</mi> <mi>P</mi></msub></mtd> <mtd><mtext>for
    a house in Piedmont</mtext></mtd></mtr></mtable></mtd></mtr></mtable></math>
- en: In this representation, the intercept <math><msub><mi>θ</mi> <mn>0</mn></msub></math>
    is for Berkeley houses, and the coefficient <math><msub><mi>θ</mi> <mi>P</mi></msub></math>
    measures the typical difference between a Piedmont house and a Berkeley house.
    In this representation, we can more easily compare <math><msub><mi>θ</mi> <mi>P</mi></msub></math>
    to 0 to see if these two cities have essentially the same average price.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表示中，截距<math><msub><mi>θ</mi> <mn>0</mn></msub></math> 是伯克利房屋的，而系数<math><msub><mi>θ</mi>
    <mi>P</mi></msub></math> 衡量皮德蒙特房屋与伯克利房屋之间的典型价格差异。在这种表述中，我们可以更容易地将<math><msub><mi>θ</mi>
    <mi>P</mi></msub></math> 与0比较，看看这两个城市的平均价格是否基本相同。
- en: If we include the intercept and all of the city variables, then the columns
    of the design matrix are linearly dependent, which means that we can’t solve for
    the coefficients. Our predictions will be the same in either case, but there will
    not be a unique solution to the minimization.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们包括截距和所有城市变量，则设计矩阵的列是线性相关的，这意味着我们无法解出系数。我们的预测在任何情况下都将相同，但不会有唯一的最小化解。
- en: We also prefer the representation of the model that drops one dummy variable
    and includes an intercept term when we include one-hot encodings of two categorical
    variables. This practice maintains consistency in the interpretation of the coefficients.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们包含两个分类变量的独热编码时，我们还喜欢采用删除一个虚拟变量并包含截距项的模型表示。这种做法保持了系数解释的一致性。
- en: 'We demonstrate how to build a model with two sets of dummy variables, using
    the `statsmodels` library. This library uses a formula language to describe the
    model to fit, so we don’t need to create the design matrix ourselves. We import
    the formula API:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示如何使用`statsmodels`库构建一个具有两组虚拟变量的模型。该库使用公式语言描述要拟合的模型，因此我们无需自己创建设计矩阵。我们导入公式
    API：
- en: '[PRE58]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s first repeat our fit of the model with the nominal variable `city` and
    house size to show how to use the formula language and compare the results:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们重复使用名义变量`city`和房屋大小拟合模型，以展示如何使用公式语言并比较结果：
- en: '[PRE59]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The string provided for the `formula` parameter describes the model to fit.
    The model has `log_price` as the outcome and fits a linear combination of `log_bsqft`
    and `city` as explanatory variables. Notice that we do not need to create dummy
    variables to fit the model. Conveniently, `smf.ols` does the one-hot encoding
    of the city feature for us. The fitted coefficients of the following model include
    an intercept term and drop the Berkeley indicator variable:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给`formula`参数的字符串描述了要拟合的模型。该模型以`log_price`作为结果，以`log_bsqft`和`city`的线性组合作为解释变量进行拟合。请注意，我们无需创建虚拟变量来拟合模型。方便地，`smf.ols`为我们执行了城市特征的独热编码。以下模型的拟合系数包括截距项，并且省略了伯克利指示变量：
- en: '[PRE60]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we want to drop the intercept, we can add –1 to the formula, which is a
    convention that indicates dropping the column of ones from the design matrix.
    In this particular example, the space spanned by all of the one-hot encoded features
    is equivalent to the space spanned by the 1 vector and all but one of the dummy
    variables, so the fit is the same. However, the coefficients are different as
    they reflect the different parameterization of the design matrix:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要去除截距，我们可以在公式中添加 -1，这是一个指示从设计矩阵中去除 1 列的约定。在这个特定的例子中，所有独热编码特征所张成的空间等同于 1
    向量和除了一个虚拟变量之外的所有虚拟变量所张成的空间，因此拟合是相同的。但是，系数是不同的，因为它们反映了设计矩阵的不同参数化：
- en: '[PRE62]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Additionally, we can add interaction terms between the city and size variables
    to allow each city to have a different coefficient for size. We specify this in
    the formula by adding the term `log_bsqft:city`. We don’t go into details here.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在城市和大小变量之间添加交互项，以允许每个城市对大小具有不同的系数。我们在公式中指定此项，通过添加术语`log_bsqft:city`。我们在这里不详细说明。
- en: 'Now let’s fit a model with two categorical variables: the number of bedrooms
    and the city. Recall that we earlier reassigned the count of bedrooms that were
    above 6 to 6, which essentially collapses 6, 7, 8, … into the category 6+. We
    can see this relationship in the box plots of price (log $) by the number of bedrooms:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们拟合一个具有两个分类变量的模型：卧室数量和城市。回想一下，我们之前重新分配了卧室数量大于 6 的卧室数量为 6，这实际上将 6、7、8、… 折叠到类别
    6+ 中。我们可以在价格（对数 $）按卧室数量的箱线图中看到这种关系：
- en: '[PRE64]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![](assets/leds_15in16.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/leds_15in16.png)'
- en: 'The relationship does not appear linear: for each additional bedroom, the sale
    price does not increase by the same amount. Given that the number of bedrooms
    is discrete, we can treat this feature as categorical, which allows each bedroom
    encoding to contribute a different amount to the cost:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 关系看起来不是线性的：每增加一个卧室，销售价格并不会以相同的金额增加。鉴于卧室数量是离散的，我们可以将此特征视为分类的，这样每个卧室编码都可以为成本贡献不同的金额：
- en: '[PRE65]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We have used the term `C(br)` in the formula to indicate that we want the number
    of bedrooms, which is numeric, to be treated like a categorical variable.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在公式中使用了术语`C(br)`来指示我们希望将卧室数量（数值型）视为分类变量对待。
- en: 'Let’s examine the multiple <math><msup><mi>R</mi> <mn>2</mn></msup></math>
    from the fit:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查拟合的多重<math><msup><mi>R</mi> <mn>2</mn></msup></math>：
- en: '[PRE66]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The multiple <math><msup><mi>R</mi> <mn>2</mn></msup></math> has not increased
    even though we have added five more one-hot encoded features. The <math><msup><mi>R</mi>
    <mn>2</mn></msup></math> is adjusted for the number of parameters in the model
    and by this measure is no better than the earlier one that included only city
    and size.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们添加了五个更多的独热编码特征，但多元 <math><msup><mi>R</mi> <mn>2</mn></msup></math> 并没有增加。多元
    <math><msup><mi>R</mi> <mn>2</mn></msup></math> 根据模型参数数量进行调整，从这个度量来看，并不比之前仅包含城市和大小的模型更好。
- en: In this section, we introduced feature engineering for qualitative features.
    We saw how the one-hot encoding technique lets us include categorical data in
    linear models and gives a natural interpretation for model parameters.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了定性特征的特征工程。我们看到了一种独热编码技术，它让我们在线性模型中包含分类数据，并为模型参数提供了自然的解释。
- en: Summary
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Linear models help us describe relationships between features. We discussed
    the simple linear model and extended it to linear models in multiple variables.
    Along the way, we applied mathematical techniques that are widely useful in modeling—calculus
    to minimize loss for the simple linear model and matrix geometry for the multiple
    linear model.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 线性模型帮助我们描述特征之间的关系。我们讨论了简单线性模型，并将其扩展到多变量线性模型。在此过程中，我们应用了在建模中广泛有用的数学技术—用微积分来最小化简单线性模型的损失，用矩阵几何来处理多变量线性模型。
- en: Linear models may seem basic, but they are used for all sorts of tasks today.
    And they are flexible enough to allow us to include categorical features as well
    as nonlinear transformations of variables, such as log transformations, polynomials,
    and ratios. Linear models have the advantage of being broadly interpretable for
    nontechnical people, yet sophisticated enough to capture many common patterns
    in data.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 线性模型可能看起来很基础，但今天它们被用于各种任务。它们足够灵活，可以允许我们包括分类特征以及变量的非线性转换，如对数转换、多项式和比率。线性模型具有广泛的可解释性，非技术人员也能理解，同时足够复杂以捕捉数据中许多常见模式的特点。
- en: 'It can be tempting to throw all of the variables available to us into a model
    to get the “best fit possible.” But we should keep in mind the geometry of least
    squares when fitting models. Recall that <math><mi>p</mi></math> explanatory variables
    can be thought of as <math><mi>p</mi></math> vectors in <math><mi>n</mi></math>
    -dimensional space, and if these vectors are highly correlated, then the projections
    onto this space will be similar to projections onto smaller spaces made up of
    fewer vectors. This implies that:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 诱人的做法是将所有可用的变量都放入模型中以获得“可能的最佳拟合”。但我们应该记住最小二乘法的几何特性来拟合模型。要记住，<math><mi>p</mi></math>
    个解释变量可以被看作是 <math><mi>n</mi></math> 维空间中的 <math><mi>p</mi></math> 个向量，如果这些向量高度相关，那么在这个空间上的投影将类似于在由较少向量组成的较小空间上的投影。这意味着：
- en: Adding more variables may not provide a large improvement in the model.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多变量可能不会显著改善模型。
- en: Interpretation of the coefficients can be difficult.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释系数可能会很困难。
- en: Several models can be equally effective in predicting/explaining the response
    variable.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几种模型可以同样有效地预测/解释响应变量。
- en: If we are concerned with making inferences, where we want to interpret/understand
    the model, then we should err on the side of simpler models. On the other hand,
    if our primary concern is the predictive ability of a model, then we tend not
    to concern ourselves with the number of coefficients and their interpretation.
    But this “black box” approach can lead to models that, say, overly depend on anomalous
    values in the data or models that are inadequate in other ways. So be careful
    with this approach, especially when the predictions may be harmful to people.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们关心进行推断，希望解释/理解模型，那么我们应该倾向于使用简单的模型。另一方面，如果我们的主要关注是模型的预测能力，那么我们往往不会关心系数的数量及其解释。但是这种“黑箱”方法可能导致模型过度依赖数据中的异常值或在其他方面不足。因此，在预测可能对人们有害时，要小心使用这种方法。
- en: In this chapter, we used linear models in a descriptive way. We introduced a
    few notions for deciding when to include a feature in a model by examining residuals
    for patterns, comparing the size of standard errors and the change in the multiple
    <math><msup><mi>R</mi> <mn>2</mn></msup></math> . Oftentimes, we settled for a
    simpler model that was easier to interpret. In the next chapter, we look at other,
    more formal tools for choosing the features to include in a model.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以描述性方式使用了线性模型。我们介绍了一些决定何时在模型中包含特征的概念，通过检查残差的模式、比较标准误差的大小和多重<math><msup><mi>R</mi>
    <mn>2</mn></msup></math> 的变化来做出决策。通常情况下，我们选择了一个更简单、更容易解释的模型。在下一章中，我们将探讨其他更正式的工具，用于选择模型中要包含的特征。
