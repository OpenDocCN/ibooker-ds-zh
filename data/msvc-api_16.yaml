- en: 12 Testing and validating APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 测试和验证API
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Generating automatic tests for REST APIs using Dredd and Schemathesis
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dredd和Schemathesis为REST API生成自动测试
- en: Writing Dredd hooks to customize the behavior of your Dredd test suite
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Dredd钩子来自定义Dredd测试套件的行为
- en: Using property-based testing to test APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于属性的测试来测试API
- en: Leveraging OpenAPI links to enhance your Schemathesis test suite
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用OpenAPI链接增强Schemathesis测试套件
- en: Testing GraphQL APIs with Schemathesis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Schemathesis测试GraphQL API
- en: This chapter teaches you how to test and validate API implementations. Thus
    far, we’ve learned to design and build APIs to drive integrations between microservices.
    Along the way, we did some manual tests to ensure our implementations exhibited
    the correct behavior. However, those tests were minimal, and most importantly,
    they were purely manual and therefore not repeatable in an automated fashion.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章教你如何测试和验证API实现。到目前为止，我们已经学会了设计和构建API以驱动微服务之间的集成。在这个过程中，我们进行了一些手动测试以确保我们的实现表现出正确的行为。然而，这些测试是有限的，更重要的是，它们完全是手动的，因此无法以自动化的方式重复。
- en: In this chapter, we learn how to run an exhaustive test suite against our API
    implementations using tools such as Dredd and Schemathesis, tools for API testing
    that are part of every API developer’s tool kit. Both Dredd and Schemathesis work
    by looking at the API specification and automatically generating tests against
    our API server. For an API developer, this is very handy because it means you
    can focus your efforts on building your APIs instead of testing them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习如何使用Dredd和Schemathesis等工具对API实现运行全面的测试套件，这些工具是每个API开发人员工具包中的API测试工具。Dredd和Schemathesis都通过查看API规范并自动生成针对我们的API服务器的测试来工作。对于API开发人员来说，这非常方便，因为它意味着你可以将精力集中在构建API上，而不是测试它们。
- en: By using tools such as Dredd and Schemathesis, you can save time and energy
    while resting assured that the implementation you’re delivering is correct. You
    can run Dredd and Schemathesis in combination, or you can choose one of them.
    As you’ll see, Dredd runs a more basic test suite that is very useful in the early
    stages of your API development cycle, while Schemathesis runs a robust test suite
    that is useful before you release your APIs to production.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Dredd和Schemathesis等工具，你可以节省时间和精力，同时确保你交付的实现是正确的。你可以组合使用Dredd和Schemathesis，或者选择其中之一。正如你将看到的，Dredd运行的是一个更基础的测试套件，这在API开发周期的早期阶段非常有用，而Schemathesis运行的是一个健壮的测试套件，在你将API发布到生产之前非常有用。
- en: To illustrate how we test REST APIs, we’ll use the orders API, which we implemented
    in chapters 2 and 6\. To illustrate how we test GraphQL APIs, we’ll use the products
    API, which we implemented in chapter 10\. As a recap, both APIs are part of CoffeeMesh,
    the fictional on-demand coffee delivery platform that we’re building in this book.
    The orders API is the interface to the orders service, which manages customers’
    orders, while the products API is the interface to the products service, which
    manages the catalogue of products CoffeeMesh offers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何测试REST API，我们将使用在第2章和第6章中实现的orders API。为了说明如何测试GraphQL API，我们将使用在第10章中实现的products
    API。作为回顾，这两个API都是CoffeeMesh的一部分，这是一个虚构的按需咖啡配送平台，我们在本书中构建了这个平台。orders API是订单服务的接口，它管理客户的订单，而products
    API是产品服务的接口，它管理CoffeeMesh提供的商品目录。
- en: The code for this chapter is available in GitHub, under the folder named ch12\.
    In section 12.1, we set up the folder structure and the environments to work on
    this chapter’s examples, so make sure you go through that section if you want
    to follow along with the examples in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到，位于名为ch12的文件夹下。在第12.1节中，我们设置了文件夹结构和环境，以便于本章示例的编写，所以如果你想要跟随本章的示例，请确保你已经阅读了那一节。
- en: 12.1 Setting up the environment for API testing
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 设置API测试环境
- en: In this section, we set up the environment to follow along with the examples
    in this chapter. Let’s start by setting up the folder structure. Create a new
    folder called ch12 and `cd` into it. Within this folder, we’ll copy the orders
    API and the products API. To keep things simple in this chapter, we use the implementation
    of the orders API as we left it in chapter 6\. Chapter 6 contains a full implementation
    of the orders API, but it lacks a real database and integration with other services
    (those features were added in chapter 7). Since the goal of this chapter is to
    learn how to test APIs, the implementation in chapter 6 is sufficient and will
    help us stay focused, as we won’t have to set up the database and run additional
    services. In real life, you’d want to test the API layer in isolation and run
    integration tests, including on the database. See the README.md file under the
    ch12/orders folder in the GitHub repository for this chapter for instructions
    on running the tests against the state of the application after chapters 7 and
    11.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们设置环境以跟随本章中的示例。让我们首先设置文件夹结构。创建一个名为 ch12 的新文件夹，并进入它。在这个文件夹中，我们将复制订单 API
    和产品 API。为了使本章内容简单，我们使用第 6 章中留下的订单 API 实现。第 6 章包含了订单 API 的完整实现，但它缺少真实的数据库和其他服务的集成（这些功能在第
    7 章中添加）。由于本章的目标是学习如何测试 API，第 6 章中的实现就足够了，这将帮助我们保持专注，因为我们不需要设置数据库和运行额外的服务。在现实生活中，您可能希望单独测试
    API 层，并运行包括数据库在内的集成测试。有关在章节 7 和 11 之后运行测试的说明，请参阅 GitHub 仓库中 ch12/orders 文件夹下的
    README.md 文件。
- en: 'Within the ch12 folder, copy the implementation of the orders API from ch06/orders
    by running the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ch12 文件夹内，通过运行以下命令复制 ch06/orders 中订单 API 的实现：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`cd` into ch12/orders and run the following command to install the dependencies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 ch12/orders 目录，并运行以下命令来安装依赖项：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Don’t forget to include the `--dev` flag when you run `pipenv` `install`, which
    tells `pipenv` to install both production and development dependencies. In this
    chapter, we’ll use development packages to test the orders API. To run the tests,
    we’ll need `pytest`, `dredd_hooks`, and `schemathesis`, which you can install
    with the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `pipenv install` 时，不要忘记包含 `--dev` 标志，这会告诉 `pipenv` 安装生产环境和开发环境的依赖项。在本章中，我们将使用开发包来测试订单
    API。要运行测试，我们需要 `pytest`、`dredd_hooks` 和 `schemathesis`，您可以使用以下命令进行安装：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To run the tests, we’ll use a slightly modified version of the orders API specification
    without the `bearerAuth` security scheme, which you can find under the ch12/orders/
    oas.yaml file in the GitHub repository for this book. In this chapter, we’ll focus
    on testing that the API implementation complies with the API specification, namely,
    ensuring the API uses the right schemas, the right status codes, and so on. API
    security testing is a whole different topic, and for that I recommend chapter
    11 of Mark Winteringham’s *Testing Web APIs* (Manning, 2022) and Corey J. Ball’s
    *Hacking APIs* (No Starch Press, 2022).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们将使用一个略微修改过的订单 API 规范，其中不包含 `bearerAuth` 安全方案，您可以在本书 GitHub 仓库的 ch12/orders/oas.yaml
    文件中找到它。在本章中，我们将专注于测试 API 实现是否符合 API 规范，即确保 API 使用正确的模式、正确的状态码等。API 安全测试是一个完全不同的主题，为此我推荐
    Mark Winteringham 的 *Testing Web APIs*（Manning，2022）和 Corey J. Ball 的 *Hacking
    APIs*（No Starch Press，2022）的第 11 章。
- en: 'Let’s now copy the implementation of the products API from chapter 10\. Go
    back to the top level of the ch12 directory by running `cd` `..` and then execute
    the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们复制第 10 章中产品的 API 实现。通过运行 `cd ..` 返回 ch12 目录的顶层，然后执行以下命令：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`cd` into ch12/products and run `pipenv` `install` `--dev` to install the dependencies.
    We’ll use `pytest` and `schemathesis` to test the products API, which you can
    install by running the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 ch12/products 目录，并运行 `pipenv install --dev` 命令来安装依赖项。我们将使用 `pytest` 和 `schemathesis`
    来测试产品 API，您可以通过运行以下命令进行安装：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’re now all set up to start testing the APIs. We’ll start our journey by learning
    about the Dredd API testing framework.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好开始测试 API 了。我们将从了解 Dredd API 测试框架开始我们的旅程。
- en: 12.2 Testing REST APIs with Dredd
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 使用 Dredd 测试 REST API
- en: This section explains what Dredd is and how we use it to test REST APIs. Dredd
    is an API testing framework that automatically generates tests to validate the
    behavior of our API server. It generates tests by parsing the API specification
    and learning from it how the API is expected to work. Using Dredd is very helpful
    during development because it means we can focus our efforts on building the API
    while Dredd ensures that our work is going in the right direction. Dredd was released
    by Apiary in 2017 as the first tool of its kind ([http://mng.bz/5maq](http://mng.bz/5maq)),
    and ever since it’s been part of every API developer’s essential tool kit.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了 Dredd 是什么以及我们如何使用它来测试 REST API。Dredd 是一个 API 测试框架，它可以自动生成测试来验证我们的 API
    服务器的行为。它通过解析 API 规范并从中学习 API 应该如何工作来生成测试。使用 Dredd 在开发过程中非常有帮助，因为它意味着我们可以专注于构建
    API，而 Dredd 确保我们的工作方向正确。Dredd 于 2017 年由 Apiary 发布，成为该类工具的第一个工具 ([http://mng.bz/5maq](http://mng.bz/5maq))，自那时起它一直是每个
    API 开发者必备的工具包的一部分。
- en: In this section, we’ll learn how Dredd works by using it to validate the implementation
    of the orders API. We’ll start by first running a basic test suite against the
    API, and then we’ll explore more advanced features of the framework.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用 Dredd 验证订单 API 的实现来学习 Dredd 的工作原理。我们首先将运行一个基本的测试套件对 API 进行测试，然后我们将探索框架的更多高级功能。
- en: 12.2.1 What is Dredd?
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 什么是 Dredd？
- en: Before we start working with Dredd, let’s take a moment to understand what Dredd
    is and how it works. Dredd is an API testing framework. As shown in figure 12.1,
    Dredd works by parsing the API specification and discovering the available URL
    paths and the HTTP methods they accept.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 Dredd 之前，让我们花一点时间来了解 Dredd 是什么以及它是如何工作的。Dredd 是一个 API 测试框架。如图 12.1 所示，Dredd
    通过解析 API 规范并发现可用的 URL 路径以及它们接受的 HTTP 方法来工作。
- en: '![](../Images/12-01.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-01.png)'
- en: Figure 12.1 Dredd works by parsing the API specification, discovering the available
    endpoints, and launching tests for each endpoint.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 Dredd 通过解析 API 规范，发现可用的端点，并为每个端点启动测试来工作。
- en: To test the API, Dredd sends requests to each of the endpoints defined in the
    API specification with the expected payloads, if any, as well as any query parameters
    accepted by the endpoint. Finally, it checks whether the responses the API receives
    conform to the schemas declared in the API specification and whether they carry
    the expected status codes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 API，Dredd 会向 API 规范中定义的每个端点发送请求，如果有的话，还包括预期的有效载荷以及端点接受的任何查询参数。最后，它检查 API
    收到的响应是否符合 API 规范中声明的模式，以及它们是否携带预期的状态码。
- en: Now that we understand how Dredd works, let’s start using it! The next section
    explains how to install Dredd.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Dredd 的工作原理，让我们开始使用它！下一节将解释如何安装 Dredd。
- en: 12.2.2 Installing and running Dredd’s default test suite
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 安装和运行 Dredd 的默认测试套件
- en: 'In this section, we install Dredd and run its default test suite against the
    orders API. `cd` into ch12/orders and run `pipenv` `shell` to activate the environment.
    Dredd is an npm package, which means you need to have a Node.js runtime available
    in your machine, as well as a package management tool for JavaScript, such as
    npm or Yarn. To install Dredd with npm, run the following command from your ch12/orders
    directory:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装 Dredd 并运行其默认测试套件对订单 API 进行测试。在 ch12/orders 目录下使用 `cd` 命令进入，然后运行 `pipenv
    shell` 来激活环境。Dredd 是一个 npm 包，这意味着您需要在您的机器上有一个可用的 Node.js 运行时，以及一个 JavaScript 的包管理工具，例如
    npm 或 Yarn。要从 npm 安装 Dredd，请在 ch12/orders 目录下运行以下命令：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will install Dredd under a folder called node_modules/. Once the installation
    is complete, we can start using Dredd to test the API. Dredd comes with a CLI
    that is available under the following directory: node_modules/.bin/dredd. The
    Dredd CLI exposes optional arguments that give us great flexibility in how we
    want to run our tests. We’ll make use of some of those arguments later in this
    section. For now, let’s execute the simplest Dredd command to run a test:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在名为 node_modules/ 的文件夹下安装 Dredd。一旦安装完成，我们就可以开始使用 Dredd 来测试 API。Dredd 随附一个
    CLI，位于以下目录：node_modules/.bin/dredd。Dredd CLI 提供了可选的参数，这使我们能够在运行测试时具有很大的灵活性。我们将在本节后面使用其中的一些参数。现在，让我们执行最简单的
    Dredd 命令来运行测试：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first argument for the Dredd CLI is the path to the API specification file,
    while the second argument represents the base URL of the API server. With the
    `--server` option, we tell Dredd which command needs to be used to start the orders
    API server. If you run this command now, you’ll get a few warnings from Dredd
    with the following message (the ellipsis omits the path to the API specification
    file, which will be different in your machine):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Dredd CLI的第一个参数是API规范文件的路径，第二个参数表示API服务器的基准URL。使用`--server`选项，我们告诉Dredd需要使用哪个命令来启动订单API服务器。如果你现在运行此命令，你将得到Dredd的一些警告，如下所示（省略号省略了API规范文件的路径，它将在你的机器上有所不同）：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Dredd is complaining because we haven’t provided an example of the URL parameter
    `order_id`, which is required in some of the URL paths. Dredd complains about
    the missing example because it’s unable to generate random values from the specification.
    To address Dredd’s complaint, we add an example of the `order_id` parameter in
    each URL where it’s used. For example, for the `/orders/{order_id}` URL path,
    we make the modification shown in listing 12.1 (the ellipses represent omitted
    code). The `/orders/{order_id}/pay` and the `/orders/{order_id}/cancel` URLs also
    contain descriptions of the `order_id` parameter, so add examples to them as well.
    Dredd will use the exact value provided in the examples to test the API.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Dredd正在抱怨，因为我们没有提供URL参数`order_id`的示例，该参数在一些URL路径中是必需的。Dredd抱怨缺少示例，因为它无法从规范中生成随机值。为了解决Dredd的抱怨，我们在每个使用`order_id`参数的URL中添加了该参数的示例。例如，对于`/orders/{order_id}`
    URL路径，我们进行了如图12.1所示的修改（省略号表示省略的代码）。`/orders/{order_id}/pay`和`/orders/{order_id}/cancel`
    URL也包含了`order_id`参数的描述，因此也要为它们添加示例。Dredd将使用示例中提供的确切值来测试API。
- en: Listing 12.1 Adding examples for the `order_id` URL path parameter
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.1 为`order_id` URL路径参数添加示例
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① We add an example for the order_id URL parameter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们为order_id URL参数添加了一个示例。
- en: 'Once we’ve added examples for the `order_id` parameter, we can run the Dredd
    CLI again. This time, the tests suite runs without problems, and you’ll get a
    result like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为`order_id`参数添加了示例，我们就可以再次运行Dredd CLI。这次，测试套件运行没有问题，你将得到如下结果：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This summary tells us that Dredd ran 18 tests, of which 7 passed and 11 failed.
    The full outcome of the test is too long to reproduce here, but if you scroll
    up in the terminal, you’ll see that the failing tests are on endpoints that target
    specific resources:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个总结告诉我们，Dredd运行了18个测试，其中7个通过，11个失败。测试的完整结果太长，无法在此重现，但如果你在终端中向上滚动，你会看到失败的测试是在针对特定资源的端点上：
- en: GET, PUT, and DELETE `/orders/{order_id}`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET、PUT和DELETE `/orders/{order_id}`
- en: POST `/orders/{order_id}/pay`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/orders/{order_id}/pay`
- en: POST `/orders/{order_id}/cancel`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST `/orders/{order_id}/cancel`
- en: Dredd runs three tests for each of those endpoints, and it expects to obtain
    one successful response per endpoint. However, in the previous execution, Dredd
    only obtained 404 responses, which means the server couldn’t find the resources
    Dredd requested. Dredd is using the ID we provided as an example in listing 12.1
    when testing those endpoints. To address this problem, we could add a hardcoded
    order with that ID to our in-memory list of orders (we’d add it to the database
    if we were using one for the tests). As we’ll see in the next section, however,
    a better approach is to use Dredd hooks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Dredd为每个这些端点运行三个测试，并期望每个端点获得一个成功的响应。然而，在上一次执行中，Dredd只获得了404响应，这意味着服务器找不到Dredd请求的资源。在测试这些端点时，Dredd使用列表12.1中提供的示例ID。为了解决这个问题，我们可以在内存中的订单列表中添加一个具有该ID的硬编码订单（如果我们使用数据库进行测试，我们会将其添加到数据库中）。然而，正如我们将在下一节中看到的，更好的方法是使用Dredd钩子。
- en: There’s also a failing test for the POST `/orders` endpoint in which Dredd expects
    a 422 response. The failed tests for 422 responses happen because Dredd doesn’t
    know how to create tests that generate those responses, and Dredd hooks will also
    help us address this problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个针对POST `/orders`端点的失败测试，其中Dredd期望得到422响应。422响应的失败测试发生是因为Dredd不知道如何创建生成这些响应的测试，而Dredd钩子也将帮助我们解决这个问题。
- en: 12.2.3 Customizing Dredd’s test suite with hooks
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 使用钩子自定义Dredd的测试套件
- en: Dredd’s default behavior can be limited. As we’ve seen in section 12.2.1, Dredd
    doesn’t know how to handle endpoints with URL path parameters, such as `order_id`
    in the `/orders/{order_id}` URL. Dredd doesn’t know how to produce a random resource
    ID, and if we provide an example, it expects the sample ID to be present in the
    system during the execution of the test suite. This expectation is unhelpful,
    since it means our API is only testable when it’s in a certain state—when certain
    resources or fixtures have been loaded into the database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Dredd 的默认行为可以受到限制。正如我们在 12.2.1 节中看到的，Dredd 不知道如何处理带有 URL 路径参数的端点，例如 `/orders/{order_id}`
    URL 中的 `order_id`。Dredd 不知道如何生成随机资源 ID，并且如果我们提供一个示例，它期望样本 ID 在测试套件执行期间存在于系统中。这种期望是无用的，因为它意味着我们的
    API 只有在它处于某种状态时才能进行测试——当某些资源或 fixtures 已加载到数据库中时。
- en: DEFINITION In software testing, *fixtures* are the preconditions required to
    run a test. Typically, fixtures are data that we load into a database for testing,
    but they can also include configuration, directories and files, or infrastructure
    resources.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 在软件测试中，**fixtures** 是运行测试所需的先决条件。通常，fixtures 是我们为测试而加载到数据库中的数据，但它们也可以包括配置、目录和文件，或基础设施资源。'
- en: Instead of using fixtures, we can take a better approach by using Dredd hooks.
    This section explains what Dredd hooks are and how we use them. Dredd hooks are
    scripts that allow us to customize Dredd’s behavior during the execution of the
    test suite. Using Dredd hooks, we can create resources for use during the test,
    save their IDs, and clean them up after finishing the test.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 fixtures 相比，我们可以通过使用 Dredd 钩子采取更好的方法。本节解释了 Dredd 钩子是什么以及我们如何使用它们。Dredd 钩子是脚本，允许我们在测试套件执行期间自定义
    Dredd 的行为。使用 Dredd 钩子，我们可以在测试期间创建资源，保存它们的 ID，并在测试完成后清理它们。
- en: 'Dredd hooks allow us to trigger actions before and after the whole test suite,
    and before and after each endpoint-specific test. They are useful for stateful
    tests that involve creating resources and performing operations on them. For example,
    we can use hooks to place an order using the POST `/orders` endpoint, save the
    ID of the order, and reuse the ID to perform operations on the order, such as
    payments and cancellations, with other endpoints. Using this approach, we can
    test that the POST `/orders` endpoint fulfills its job of creating a resource,
    and we can test other endpoints with a real resource. As illustrated in figures
    12.2, 12.3, and 12.4, we’ll create the following hooks with these steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Dredd 钩子允许我们在整个测试套件之前和之后，以及在每个端点特定测试之前和之后触发操作。对于涉及创建资源并对它们执行操作的**有状态测试**非常有用。例如，我们可以使用钩子通过
    POST `/orders` 端点下单，保存订单的 ID，并使用该 ID 对订单执行操作，例如支付和取消，与其他端点一起使用。使用这种方法，我们可以测试 POST
    `/orders` 端点是否完成了创建资源的任务，并且我们可以使用真实资源测试其他端点。如图 12.2、12.3 和 12.4 所示，我们将按照以下步骤创建以下钩子：
- en: After the POST `/orders` test, we use a hook to save the ID returned by the
    server for the newly created order.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 POST `/orders` 测试之后，我们使用钩子保存服务器为新创建的订单返回的 ID。
- en: Before the GET, PUT, and DELETE `/orders/{order_id}` tests, we use hooks to
    tell Dredd to use the ID from the order created at point (1). These endpoints
    are used to retrieve the details of the order (GET), to update the order (PUT),
    and to remove the order from the server (DELETE). Therefore, after running the
    DELETE `/orders/{order_id}` test, the order will no longer exist in the server.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行 GET、PUT 和 DELETE `/orders/{order_id}` 测试之前，我们使用钩子来告诉 Dredd 使用在点 (1) 创建的订单的
    ID。这些端点用于检索订单的详细信息（GET），更新订单（PUT），以及从服务器中删除订单（DELETE）。因此，在运行 DELETE `/orders/{order_id}`
    测试后，订单将不再存在于服务器上。
- en: Before the POST `/orders/{order_id}/pay` and the POST `/orders/` `{order_` `id}/cancel`
    endpoints, we use hooks to create new orders for use in these tests. We won’t
    be able to reuse the ID from point (1), since the DELETE `/orders/` `{order_id}`
    test from point (2) deletes the order from the server.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 POST `/orders/{order_id}/pay` 和 POST `/orders/{order_id}/cancel` 端点之前，我们使用钩子创建新的订单以供这些测试使用。由于点
    (2) 的 DELETE `/orders/{order_id}` 测试已从服务器中删除订单，因此我们无法重用点 (1) 的 ID。
- en: 'For the 422 responses, we need a strategy that generates a 422 response from
    the server. We’ll use two approaches: for the POST `/orders` endpoint, we’ll send
    an invalid payload, while for the remaining endpoints, we’ll modify the order’s
    URI and include an invalid identifier.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 422 响应，我们需要一种从服务器生成 422 响应的策略。我们将使用两种方法：对于 POST `/orders` 端点，我们将发送一个无效的有效负载，而对于其他端点，我们将修改订单的
    URI 并包含一个无效的标识符。
- en: '![](../Images/12-02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-02.png)'
- en: Figure 12.2 After the POST `/orders` endpoint test, the `save_created_order()`hook
    saves the ID from the server response body in the `response_stash`. The `before_get_order()`,
    `before_put_order()`, and `before_delete_order()` hooks use the ID from `response_stash`
    to form their resource URLs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 在 POST `/orders` 端点测试之后，`save_created_order()` 钩子将服务器响应体中的 ID 保存到 `response_stash`
    中。`before_get_order()`、`before_put_order()` 和 `before_delete_order()` 钩子使用 `response_stash`
    中的 ID 来形成它们的资源 URL。
- en: '![](../Images/12-03.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图12-03](../Images/12-03.png)'
- en: Figure 12.3 Before executing the test, the `before_pay_order()` and the `before_cancel_
    order()` hooks use the POST `/orders` endpoint to place a new order and use the
    ID from the response payload form their resource URLs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 在执行测试之前，`before_pay_order()` 和 `before_cancel_order()` 钩子使用 POST `/orders`
    端点创建一个新订单，并使用响应有效载荷中的 ID 从它们的资源 URL 中获取。
- en: '![](../Images/12-04.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图12-04](../Images/12-04.png)'
- en: Figure 12.4 The `fail_create_order()` and the `fail_target_specific_order()`
    hooks inject invalid payloads and invalid order identifiers to trigger a 422 response
    from the server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 `fail_create_order()` 和 `fail_target_specific_order()` 钩子注入无效的有效载荷和无效的订单标识符，以触发服务器返回的
    422 响应。
- en: Using Dredd hooks to save the ID of a created resource
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Dredd 钩子保存创建的资源 ID
- en: Now that we know what we want to do, let’s write our hooks! First, if you haven’t
    done it yet, `cd` into ch12/orders and activate the virtual environment by running
    `pipenv` `shell`. Create a file called orders/hooks.py, where we’ll write our
    hooks. Although Dredd is an npm package, we can write our hooks in Python by using
    the `dredd-hooks` library. In section 12.1, we set up the environments for this
    chapter, so `dredd-hooks` has already been installed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道我们想要做什么，让我们编写我们的钩子！首先，如果您还没有这样做，请使用 `cd` 命令进入 ch12/orders 目录，并通过运行 `pipenv
    shell` 激活虚拟环境。创建一个名为 orders/hooks.py 的文件，我们将在这里编写我们的钩子。尽管 Dredd 是一个 npm 包，但我们可以通过使用
    `dredd-hooks` 库在 Python 中编写我们的钩子。在第 12.1 节中，我们为这一章设置了环境，因此 `dredd-hooks` 已经被安装。
- en: To understand how Dredd hooks work, let’s look at one of them in detail. Listing
    12.2 shows the implementation of an after hook for the POST `/orders` endpoint.
    This code goes into the orders/hooks.py file. We first declare a variable called
    `response_ stash`, which we’ll use to store data from the POST `/orders` request.
    `dredd-hooks` provides decorator functions, such as `dredd_hooks.before``()` and
    `dredd_hooks.after``()`, that allow us to bind a function to a specific operation.
    `dredd-hooks`’ decorators accept an argument, which represents the path to the
    specific operation that we want to bind the hook to. As you can see in figure
    12.5, in Dredd, an operation is defined as a URL endpoint with its response status
    code and its content-encoding format. In listing 12.2, we bind the `save_created_order()`
    hook to the 201 response of the POST `/orders` endpoint.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Dredd 钩子是如何工作的，让我们详细看看其中一个。列表 12.2 展示了 POST `/orders` 端点的后钩子实现。这段代码放入 orders/hooks.py
    文件中。我们首先声明一个名为 `response_stash` 的变量，我们将使用它来存储 POST `/orders` 请求中的数据。`dredd-hooks`
    提供了装饰器函数，如 `dredd_hooks.before()` 和 `dredd_hooks.after()`，允许我们将函数绑定到特定的操作。`dredd-hooks`
    的装饰器接受一个参数，它代表我们想要绑定钩子的特定操作的路径。如图 12.5 所示，在 Dredd 中，一个操作被定义为具有其响应状态码和内容编码格式的 URL
    端点。在列表 12.2 中，我们将 `save_created_order()` 钩子绑定到 POST `/orders` 端点的 201 响应。
- en: '![](../Images/12-05.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图12-05](../Images/12-05.png)'
- en: Figure 12.5 To form the path for a specific operation in a Dredd hook, you use
    the URL path with the operation’s summary, response status code, and content encoding
    of the response.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 在 Dredd 钩子中形成特定操作的路径时，您使用操作摘要的 URL 路径、响应状态码和响应的内容编码。
- en: 'Defining operation paths in Dredd hooks When defining the path for an operation
    using `dredd-hooks`, you can’t use HTTP methods as part of the operation path;
    that is, the following syntax won’t work: `/orders` `>` `post` `>` `201` `>` `application/json`.
    Instead, we use other properties of the POST endpoint, such as `summary` or `operationId`,
    as in the following example: `/orders` `>` `Creates` `an` `order` `>` `201` `>`
    `application/json`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dredd 钩子中定义操作路径 当使用 `dredd-hooks` 定义操作的路径时，您不能将 HTTP 方法作为操作路径的一部分使用；也就是说，以下语法将不起作用：`/orders`
    `>` `post` `>` `201` `>` `application/json`。相反，我们使用 POST 端点的其他属性，如 `summary` 或
    `operationId`，如下例所示：`/orders` `>` `Creates` `an` `order` `>` `201` `>` `application/json`。
- en: Dredd hooks take an argument that represents the transaction Dredd performed
    during the test. The argument comes in the form of a dictionary. In listing 12.2,
    we name the hook’s argument `transaction`. Since our goal in the `save_created_
    order()` hook is to fetch the ID of the created order, we inspect the payload
    returned by the POST `/orders` endpoint, which can be found under `transaction['real']
    ['body']`. Since our API returns JSON payloads, we load its contents using Python’s
    `json` library. Once we get hold of the order’s ID, we save it for later use in
    our global state dictionary, which we named `response_stash`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Dredd hooks 接收一个参数，表示 Dredd 在测试期间执行的事务。该参数以字典的形式出现。在列表 12.2 中，我们命名 hook 的参数为
    `transaction`。由于我们在 `save_created_order()` hook 中的目标是获取创建的订单的 ID，我们检查 POST `/orders`
    端点返回的有效载荷，该有效载荷可以在 `transaction['real']['body']` 下找到。由于我们的 API 返回 JSON 有效载荷，我们使用
    Python 的 `json` 库加载其内容。一旦我们获取到订单的 ID，我们就将其保存到用于以后在全局状态字典中，我们将其命名为 `response_stash`。
- en: Listing 12.2 Implementation of an after hook for the POST `/orders` endpoint
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2 实现 POST `/orders` 端点的 after hook
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① We import the dredd_hooks library.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入 dredd_hooks 库。
- en: ② We create a global object to store and manage the state of the test suite.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们创建一个全局对象来存储和管理测试套件的状态。
- en: ③ We create a hook to be triggered after the POST /orders endpoint test.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们创建一个在 POST /orders 端点测试之后被触发的 hook。
- en: ④ We access the response payload from the POST /orders endpoint.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们从 POST /orders 端点访问响应有效载荷。
- en: ⑤ We load the response using Python’s json library and retrieve the order’s
    ID.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们使用 Python 的 json 库加载响应并检索订单的 ID。
- en: ⑥ We store the order ID in our global response_stash object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们将订单 ID 存储在我们的全局 response_stash 对象中。
- en: Using hooks to make Dredd use custom URLs
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 hooks 使 Dredd 使用自定义 URL
- en: Now that we know how to save the ID of the order created in a POST request,
    let’s see how we use the ID to form the order’s resource URL. Listing 12.3 shows
    how we build hooks for the order resource endpoints. The code shown in listing
    12.3 goes into the orders/hooks.py file. The code from listing 12.2 is omitted
    using ellipses, while the new additions are shown in bold.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何保存 POST 请求中创建的订单的 ID，让我们看看我们如何使用该 ID 来形成订单的资源 URL。列表 12.3 展示了如何为订单资源端点构建
    hooks。列表 12.3 中显示的代码放入了 orders/hooks.py 文件。列表 12.2 中的代码使用省略号省略，而新的添加内容以粗体显示。
- en: To specify which URL Dredd should use when testing the `/orders/{order_id}`
    path, we need to modify the transaction payload. In particular, we need to modify
    the transaction’s `fullPath` and its `request`’s `uri` properties and make sure
    they point to the right URL. To form the URL, we access the order’s ID from the
    `response_stash` dictionary.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定 Dredd 在测试 `/orders/{order_id}` 路径时应该使用的 URL，我们需要修改事务有效载荷。特别是，我们需要修改事务的 `fullPath`
    和其 `request` 的 `uri` 属性，并确保它们指向正确的 URL。为了形成 URL，我们从 `response_stash` 字典中访问订单的
    ID。
- en: Listing 12.3 Using before hooks to tell Dredd which URL to use
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3 使用 before hooks 告诉 Dredd 使用哪个 URL
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① We create a hook to be triggered before the GET /orders/{order_id} endpoint
    test.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们创建一个在 GET /orders/{order_id} 端点测试之前被触发的 hook。
- en: ② We change the GET /orders/{order_id} endpoint test’s URL to include the ID
    of the order we created earlier.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们更改 GET /orders/{order_id} 端点测试的 URL，以包含我们之前创建的订单的 ID。
- en: Using Dredd hooks to create resources before a test
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Dredd hooks 在测试前创建资源
- en: The DELETE `/orders/{order_id}` endpoint deletes the order from the database,
    so we can’t use the same order ID to test the `/orders/{order_id}/pay` and `/orders/{order_id}/cancel`
    endpoints. Instead, we’ll use hooks to create new orders before testing those
    endpoints. Listing 12.4 shows how we accomplish that. The code in listing 12.4
    goes into the orders/hooks.py file. The new code is shown in bold, while the code
    from previous listings is omitted with ellipses.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE `/orders/{order_id}` 端点从数据库中删除订单，因此我们无法使用相同的订单 ID 来测试 `/orders/{order_id}/pay`
    和 `/orders/{order_id}/cancel` 端点。相反，我们将在测试这些端点之前使用 hooks 来创建新的订单。列表 12.4 展示了如何完成这个任务。列表
    12.4 中的代码放入了 orders/hooks.py 文件。新的代码以粗体显示，而之前列表中的代码使用省略号省略。
- en: To create new orders, we’ll call the POST `/orders` endpoint using the `requests`
    library, which makes it easy to make HTTP requests. To launch a POST request,
    we use `requests`’ `post()` function, passing in the target URL for the request
    and the JSON payload required to create an order. In this case, we hardcode the
    server base URL to http://127.0.0.1:8000, but you may want to make this value
    configurable if you want to be able to run the test suite in different environments.
    Once we’ve created the order, we fetch its ID from the response payload and use
    the ID to modify the `transaction`’s `fullPath` and its `request`’s `uri` properties.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的订单，我们将使用`requests`库调用POST `/orders`端点，这使得发送HTTP请求变得容易。要启动一个POST请求，我们使用`requests`的`post()`函数，传入请求的目标URL和创建订单所需的JSON有效负载。在这种情况下，我们硬编码服务器基本URL为http://127.0.0.1:8000，但如果你想在不同的环境中运行测试套件，你可能希望使这个值可配置。一旦我们创建了订单，我们就从响应有效负载中获取其ID，并使用ID来修改`transaction`的`fullPath`属性及其`request`的`uri`属性。
- en: Listing 12.4 Using before hooks to create resources before a test
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.4 使用before钩子在测试前创建资源
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① We import the requests library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入requests库。
- en: ② We place a new order.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们放置一个新的订单。
- en: ③ We fetch the newly created order’s ID.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们获取新创建订单的ID。
- en: ④ We change the POST /orders/{order_id}/pay endpoint test’s URL by to include
    the ID of the order we created earlier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们通过将之前创建的订单ID包含在URL中来更改POST /orders/{order_id}/pay端点测试的URL。
- en: Using hooks to generate 422 responses
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用钩子生成422响应
- en: Some of the endpoints in the orders API accept request payloads or URL path
    parameters. If an API client sends an invalid payload or uses an invalid URL path
    parameter, the API responds with a 422 response. As we saw earlier, Dredd doesn’t
    know how to generate 422 responses from the server, so we’ll create hooks for
    that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 订单API中的一些端点接受请求有效负载或URL路径参数。如果API客户端发送无效的有效负载或使用无效的URL路径参数，API将响应一个422状态码。如我们之前所见，Dredd不知道如何从服务器生成422响应，因此我们将为这种情况创建钩子。
- en: 'As you can see in listing 12.5, we only need two functions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在列表12.5中看到的，我们只需要两个函数：
- en: '`fail_create_order()` intercepts the request for the POST `/orders` endpoint
    before it reaches the server, and it modifies its payload with an invalid value
    for the `size` property.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail_create_order()`在请求到达服务器之前拦截对POST `/orders`端点的请求，并修改其有效负载中的`size`属性为无效值。'
- en: '`fail_target_specific_order()` modifies the order’s URI with an invalid identifier.
    Since we know that Dredd fires this test using the example ID we provided in the
    API specification, we simply need to replace that ID with an invalid value. The
    type of the `order_id` path parameter is a UUID, so by replacing it with an integer,
    the server will respond with a 422 status code.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail_target_specific_order()`通过使用无效标识符修改订单的URI。由于我们知道Dredd使用我们在API规范中提供的示例ID来触发这个测试，我们只需将那个ID替换为无效值。`order_id`路径参数的类型是UUID，所以通过将其替换为整数，服务器将响应422状态码。'
- en: These hooks are a good opportunity to test how the server behaves with different
    types of payloads and parameters, and if you need to, you can create specific
    tests for each endpoint for more comprehensive test coverage.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些钩子是测试服务器对不同类型有效负载和参数的行为的好机会，如果你需要，你可以为每个端点创建特定的测试以获得更全面的测试覆盖率。
- en: Listing 12.5 Generating 422 responses with Dredd hooks
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.5 使用Dredd钩子生成422响应
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running Dredd with custom hooks
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义钩子运行Dredd
- en: 'Now that we have Dredd hooks to make sure that each URL is correctly formed,
    we can run the Dredd test suite again. The following command shows how to run
    Dredd using a hooks file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了Dredd钩子来确保每个URL都是正确形成的，我们可以再次运行Dredd测试套件。以下命令显示了如何使用钩子文件运行Dredd：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we simply need to pass the path to our hooks file using the
    `--hookfiles` flag. We also need to specify the language in which the hooks are
    written by using the `--language` flag. If you run the command now, you’ll see
    now that all tests pass.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只需使用`--hookfiles`标志传递我们钩子文件的路径。我们还需要使用`--language`标志指定钩子编写的语言。如果你现在运行这个命令，你会看到所有测试都通过了。
- en: 12.2.4 Using Dredd in your API testing strategy
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 在你的API测试策略中使用Dredd
- en: Dredd is a fantastic tool for testing API implementations, but its test suite
    is limited. Dredd only tests the happy path of each endpoint. For example, to
    test the POST `/orders` endpoint, Dredd sends only a valid payload to the endpoint
    and expects it to be processed correctly. It doesn’t send malformed payloads,
    so by using Dredd alone, we don’t know how the server reacts in those situations.
    This is fine when we’re in the early stage development of our service and we don’t
    want to be carried away by the API layer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Dredd 是一个用于测试 API 实现的出色工具，但其测试套件有限。Dredd 只测试每个端点的成功路径。例如，为了测试 `/orders` 端点的
    POST 请求，Dredd 只向端点发送有效的有效载荷并期望它被正确处理。它不会发送格式错误的载荷，因此仅使用 Dredd，我们不知道服务器在这些情况下会如何反应。在我们服务的早期开发阶段，我们不想被
    API 层面所吸引时，这是可以接受的。
- en: 'However, before we release our code, we must ensure it works as expected in
    all situations, and to run tests that go beyond the happy path, we need to use
    a different library: `schemathesis`. We’ll learn about Schemathesis in section
    12.4, but before we do that, we need to understand the core approach to testing
    that Schemathesis uses: property-based testing. That’s the topic of our next section,
    so move on to learn more about it!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们发布代码之前，我们必须确保它在所有情况下都能按预期工作，并且为了运行超出成功路径的测试，我们需要使用不同的库：`schemathesis`。我们将在第
    12.4 节中了解 Schemathesis，但在我们这样做之前，我们需要了解 Schemathesis 所使用的核心测试方法：基于属性的测试。这就是我们下一节的主题，所以继续学习更多关于它的内容！
- en: 12.3 Introduction to property-based testing
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 基于属性的测试简介
- en: This section explains what property-based testing is, how it works, and how
    it helps us write more exhaustive tests for our APIs. Along the way, you’ll also
    lean about Python’s excellent property-based testing library, `hypothesis`. As
    you’ll see, property-based testing helps us create robust test suites for APIs,
    allowing us to easily generate hundreds of test cases with multiple combinations
    of properties and types. This section paves the way for the upcoming sections
    of this chapter, where we’ll learn about Schemathesis, an API testing framework
    that uses property-based testing.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了什么是基于属性的测试，它是如何工作的，以及它是如何帮助我们为我们的 API 编写更全面的测试的。在这个过程中，你还将了解 Python 的出色基于属性的测试库
    `hypothesis`。正如你将看到的，基于属性的测试帮助我们为 API 创建健壮的测试套件，使我们能够轻松地生成具有多个属性和类型组合的数百个测试用例。本节为本章即将到来的部分铺平了道路，我们将学习
    Schemathesis，这是一个使用基于属性的测试的 API 测试框架。
- en: 12.3.1 What is property-based testing?
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 什么是基于属性的测试？
- en: As you can see in figure 12.6, property-based testing is a testing strategy
    in which we feed test data to our code and design our tests to make claims about
    the properties of the result of running our code.[¹](#pgfId-1081073) Typically,
    a property-based framework generates test cases for us given a set of conditions
    that we define.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在图 12.6 中可以看到的，基于属性的测试是一种测试策略，其中我们向我们的代码提供测试数据，并设计我们的测试来对我们代码运行结果的属性提出主张。[¹](#pgfId-1081073)
    通常，基于属性的框架会根据我们定义的一组条件为我们生成测试用例。
- en: '![](../Images/12-06.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-06.png)'
- en: Figure 12.6 In property-based testing, we use a framework to generate test cases
    for our functions, and we make assertions on the result of running our code on
    such cases.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 在基于属性的测试中，我们使用一个框架为我们生成函数的测试用例，并对我们在这些情况下运行代码的结果提出断言。
- en: DEFINITION Property-based testing is an approach to testing in which we make
    claims about the properties of the return value of our functions or methods. Instead
    of manually writing lots of different tests with various inputs, we let a framework
    generate the inputs for us, and we define how we expect our code to handle them.
    In Python, an excellent library for property-based testing is Hypothesis ([https://github.com/HypothesisWorks/hypothesis](https://github.com/HypothesisWorks/hypothesis)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 基于属性的测试是一种测试方法，其中我们对我们函数或方法的返回值的属性提出主张。我们不是手动编写大量具有各种输入的不同测试，而是让框架为我们生成输入，并定义我们期望我们的代码如何处理它们。在
    Python 中，一个出色的基于属性的测试库是 Hypothesis ([https://github.com/HypothesisWorks/hypothesis](https://github.com/HypothesisWorks/hypothesis))。
- en: 12.3.2 The traditional approach to API testing
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 API 测试的传统方法
- en: 'Let’s say we want to test our POST `/orders` endpoint to ensure it only accepts
    valid payloads. As you can see from the OpenAPI specification for the orders API
    under the ch012/orders/oas.yaml file, a valid payload for the POST `/orders` endpoint
    contains a key named `order`, which represents an array of ordered items. Each
    item has two required keys: `product` and `size`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要测试我们的 POST `/orders` 端点以确保它只接受有效的有效负载。正如您从 ch012/orders/oas.yaml 文件中订单
    API 的 OpenAPI 规范中可以看到，POST `/orders` 端点的有效有效负载包含一个名为 `order` 的键，它表示一个有序项的数组。每个项目有两个必需的键：`product`
    和 `size`。
- en: Listing 12.6 Schema for the POST `/orders` endpoint’s request payload
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.6 POST `/orders` 端点的请求有效负载模式
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In a traditional approach, we’d write various payloads manually, then submit
    them to the POST `/orders` endpoint and write the expected result for each payload.
    Listing 12.7 illustrates how we test the POST `/orders` endpoint with two different
    payloads. If you want to try out the code in listing 12.7, create a file called
    orders/test.py and run the tests with the following command: `pytest` `test.py`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统方法中，我们会手动编写各种有效负载，然后将它们提交到 POST `/orders` 端点，并为每个有效负载编写预期的结果。列表 12.7 展示了如何使用两种不同的有效负载测试
    POST `/orders` 端点。如果您想尝试列表 12.7 中的代码，请创建一个名为 orders/test.py 的文件，并使用以下命令运行测试：`pytest
    test.py`。
- en: 'In listing 12.7, we define two test cases: one with an invalid payload missing
    the required `size` property of an order item and another with a valid payload.
    In both cases, we use FastAPI’s test client to send the payloads to our API server,
    and we test the server’s behavior by checking the status code from the response.
    We expect the response for an invalid payload to carry the 422 status code (Unprocessable
    Entity), and the response for the valid payload to carry the 201 status code (Created).
    FastAPI uses pydantic to validate our payloads, and it automatically generates
    a 422 response for malformed payloads. Therefore, this test serves to validate
    that our pydantic models are correctly implemented.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 12.7 中，我们定义了两个测试用例：一个缺少订单项必需的 `size` 属性的无效有效负载，另一个是有效有效负载。在两种情况下，我们使用 FastAPI
    的测试客户端将有效负载发送到我们的 API 服务器，并通过检查响应的状态码来测试服务器的行为。我们期望无效有效负载的响应携带 422 状态码（不可处理实体），而有效有效负载的响应携带
    201 状态码（已创建）。FastAPI 使用 pydantic 验证我们的有效负载，并且它会自动为格式错误的有效负载生成 422 响应。因此，这个测试旨在验证我们的
    pydantic 模型是否正确实现。
- en: Listing 12.7 Testing the POST `/orders` endpoint with different payloads
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.7 使用不同有效负载测试 POST `/orders` 端点
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① We import FastAPI’s TestClient class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们导入 FastAPI 的 TestClient 类。
- en: ② We instantiate the test client.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们实例化测试客户端。
- en: ③ We create a test.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们创建一个测试。
- en: ④ We define a bad payload for the POST /orders endpoint.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们为 POST /orders 端点定义一个无效的有效负载。
- en: ⑤ We test the payload.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们测试有效负载。
- en: ⑥ We confirm that the response status code is 422.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们确认响应状态码是 422。
- en: ⑦ We define a valid payload for the POST /orders endpoint.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们为 POST /orders 端点定义一个有效的有效负载。
- en: ⑧ We confirm that the response status code is 201.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们确认响应状态码是 201。
- en: 12.3.3 Property-based testing with Hypothesis
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.3 使用 Hypothesis 进行基于属性的测试
- en: 'The testing strategy in listing 12.7, where we write all the test cases manually,
    is a common approach to API testing. The problem with this approach is that it’s
    quite limited unless we’re willing to spend many hours writing exhaustive test
    suites. The test suite in listing 12.7 is far from complete: it’s not testing
    what happens if the `size` property contains an invalid value, or if the `quantity`
    property is present with a negative value, or if the list of order items is empty.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.7 中所示的传统测试策略，即手动编写所有测试用例，是 API 测试中的一种常见方法。这种方法的问题在于，除非我们愿意花费大量时间编写详尽的测试套件，否则它相当有限。列表
    12.7 中的测试套件远非完整：它没有测试如果 `size` 属性包含无效值，或者如果 `quantity` 属性具有负值，或者如果订单项列表为空时会发生什么。
- en: For a more comprehensive approach to API testing, we want to be able to use
    a framework that can generate all possible types of payloads and test them against
    our API server. This is exactly what property-based testing allows us to do. In
    Python, we can run property-based tests with the help of the excellent `hypothesis`
    library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更全面地测试 API，我们希望使用一个能够生成所有可能类型的有效负载并对其 API 服务器进行测试的框架。这正是基于属性的测试允许我们做到的。在 Python
    中，我们可以借助出色的 `hypothesis` 库运行基于属性的测试。
- en: 'Hypothesis uses the concept of strategy to generate test data. For example,
    if we want to generate random integers, we use Hypothesis’s `integers()` strategy,
    and if we want to generate text data, we use Hypothesis’s `text()` strategy. Hypothesis’s
    strategies expose a method called `example()` that you can use to get an idea
    of the values they produce. You can get a feeling of how Hypothesis’s strategies
    work by playing with them in a Python shell (since Hypothesis produces random
    values, you’ll see different results in your shell):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设使用策略的概念来生成测试数据。例如，如果我们想生成随机整数，我们使用假设的`integers()`策略，如果我们想生成文本数据，我们使用假设的`text()`策略。假设的策略公开了一个名为`example()`的方法，您可以使用它来了解它们产生的值。您可以通过在Python
    shell中（由于假设产生随机值，您将在shell中看到不同的结果）玩弄它们来获得假设策略的工作感觉：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see in figure 12.7, Hypothesis also allows us to combine various
    strategies using the `pipe` operator (`|`). For example, we can define a strategy
    that produces either integers or text:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如图12.7所示，假设还允许我们使用`pipe`运算符（`|`）组合各种策略。例如，我们可以定义一个生成整数或文本的策略：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/12-07.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-07.png)'
- en: Figure 12.7 We can combine various Hypothesis strategies into one. The resulting
    strategy will produce a value from any of the combined strategies at random.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 我们可以将各种假设策略组合成一个。结果策略将随机从任何组合策略中产生一个值。
- en: 'To test the POST `/orders` endpoint with Hypothesis, we want to define a strategy
    that produces dictionaries with random values. To work with dictionaries, we can
    use either Hypothesis’s `dictionaries()` or `fixed_dictionaries``()` strategies.
    For example, if we want to generate a dictionary with two keys, such as `product`
    and `size`, where each key can be either an integer or a text, we’d use the following
    declaration:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用假设测试POST `/orders`端点，我们想要定义一个生成具有随机值的字典的策略。为了处理字典，我们可以使用假设的`dictionaries()`或`fixed_dictionaries()`策略。例如，如果我们想生成一个包含两个键的字典，例如`product`和`size`，其中每个键可以是整数或文本，我们将使用以下声明：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 12.3.4 Using Hypothesis to test a REST API endpoint
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.4 使用假设来测试REST API端点
- en: 'Let’s put all of this together to create an actual test for `the` POST `/orders`
    endpoint. First, let’s define a strategy for all the values that a property in
    our payload can take. We’ll keep it simple for illustration purposes and assume
    properties can only be null, Booleans, text, or integers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有这些内容组合起来，为`the` POST `/orders`端点创建一个实际的测试。首先，让我们定义一个策略，用于我们负载中属性可以采取的所有值。为了说明目的，我们将保持简单，并假设属性只能是null、布尔值、文本或整数：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let’s define a strategy for the schema that represents an order item.
    To keep it simple, we use a fixed dictionary with valid keys, that is, `product`,
    `size`, and `quantity`. Since the `size` property can only take on values from
    an enumeration whose choices are `small`, `medium`, or `big`, we define a strategy
    that allows Hypothesis to choose a value either from that enumeration or from
    the `values_strategy` strategy that we defined earlier:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个表示订单项的模式的策略。为了简化，我们使用一个具有有效键的固定字典，即`product`、`size`和`quantity`。由于`size`属性只能取自一个枚举值，其选择为`small`、`medium`或`big`，我们定义一个策略，允许假设从该枚举值或我们之前定义的`values_strategy`策略中选择一个值：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, as you can see in figure 12.8, we put all of this together in a strategy
    for the `CreateOrderSchema` schema. From listing 12.4, we know that `CreateOrderSchema`
    requires a property called `order`, whose value is a list of order items. Using
    Hypothesis, we can define a strategy that generates payloads to test the `CreateOrderSchema`
    schema like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如图12.8所示，我们将所有这些内容整合成一个针对`CreateOrderSchema`模式的策略。从列表12.4中，我们知道`CreateOrderSchema`需要一个名为`order`的属性，其值是一个订单项的列表。使用假设，我们可以定义一个策略来生成用于测试`CreateOrderSchema`模式的负载，如下所示：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](../Images/12-08.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-08.png)'
- en: Figure 12.8 By combining Hypothesis’s `fixed_dictionaries()` strategy with the
    `lists()` strategy and the `values_strategy`, we can produce payloads that resemble
    the `CreateOrderSchema` schema.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 通过结合假设的`fixed_dictionaries()`策略与`lists()`策略和`values_strategy`，我们可以生成类似于`CreateOrderSchema`模式的负载。
- en: We’re now ready to rewrite our test suite from listing 12.6 into a more generic
    and comprehensive test for the POST `/orders` endpoint. Listing 12.7 shows how
    we inject Hypothesis strategies into a test function. The code in listing 12.7
    goes into the orders/test.py file. I’ve omitted the definitions of some variables
    in listing 12.7, such as `values_strategy` and `order_item_strategy`, since we
    already came across them in the previous examples.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将列表 12.6 中的测试套件重写为一个更通用和全面的 POST `/orders` 端点测试。列表 12.7 展示了如何将假设策略注入到测试函数中。列表
    12.7 中的代码位于 orders/test.py 文件中。我在列表 12.7 中省略了一些变量的定义，例如 `values_strategy` 和 `order_item_strategy`，因为我们已经在之前的示例中遇到过它们。
- en: The testing strategy in listing 12.8 uses the `jsonschema` library to validate
    the payloads generated by Hypothesis. To validate payloads with the `jsonschema`
    library, we first load the OpenAPI specification for the orders API, which lives
    under ch012/ orders/oas.yaml. We read the file contents using `pathlib`’s `Path().read_text()`
    method, and we parse them using Python’s `yaml` library. To check whether a payload
    is valid, we create a utility function called `is_valid_payload()`, which returns
    `True` if the payload is valid and, otherwise, returns `False`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.8 中的测试策略使用 `jsonschema` 库验证 Hypothesis 生成的有效载荷。为了使用 `jsonschema` 库验证有效载荷，我们首先加载
    orders API 的 OpenAPI 规范，它位于 ch012/orders/oas.yaml 下。我们使用 `pathlib` 的 `Path().read_text()`
    方法读取文件内容，并使用 Python 的 `yaml` 库进行解析。为了检查有效载荷是否有效，我们创建了一个名为 `is_valid_payload()`
    的实用函数，如果有效载荷有效则返回 `True`，否则返回 `False`。
- en: 'We validate the payload using `jsonschema`’s `validate()` function, which requires
    two arguments: the payload that we want to validate and the schema that we want
    to validate against. Since `CreateOrderSchema` contains a reference to another
    schema within the API specification, namely, the `OrderItemSchema` schema, we
    also provide a resolver, which `jsonschema` can use to resolve references to other
    schemas within the document. `jsonschema`’s `validate()` function raises a `ValidationError`
    if the payload is invalid, so we call it within a try/except block, and we return
    `True` or `False` depending on the result.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `jsonschema` 的 `validate()` 函数验证有效载荷，该函数需要两个参数：我们想要验证的有效载荷和我们想要验证的架构。由于
    `CreateOrderSchema` 包含对 API 规范中另一个架构的引用，即 `OrderItemSchema` 架构，我们还提供了一个解析器，`jsonschema`
    可以使用它来解析文档中其他架构的引用。如果有效载荷无效，`jsonschema` 的 `validate()` 函数会引发 `ValidationError`，因此我们在
    try/except 块中调用它，并根据结果返回 `True` 或 `False`。
- en: To inject data into our test functions, Hypothesis provides the `given()` decorator,
    which takes a Hypothesis strategy as an argument and uses it to feed test cases
    to our test function. If the payloads are valid, we expect our API to return a
    response with the 201 status code, while for bad payloads we expect a 422 status
    code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据注入我们的测试函数中，Hypothesis 提供了 `given()` 装饰器，它接受一个 Hypothesis 策略作为参数，并使用它将测试用例提供给我们的测试函数。如果有效载荷有效，我们期望我们的
    API 返回一个状态码为 201 的响应，而对于无效的有效载荷，我们期望一个 422 状态码。
- en: Listing 12.8 Using `hypothesis` to run property-based tests against an API
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.8 使用 `hypothesis` 运行针对 API 的基于属性的测试
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ① We load the API specification.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们加载 API 规范。
- en: ② Pointer to the CreateOrderSchema schema
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ② 指向 CreateOrderSchema 架构的指针
- en: ③ Helper function to determine whether a payload is valid
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 用于确定有效载荷是否有效的辅助函数
- en: ④ We validate a payload with jsonschema’s validate() function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们使用 jsonschema 的 validate() 函数验证有效载荷。
- en: ⑤ We instantiate the test client.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们实例化了测试客户端。
- en: ⑥ We feed the hypothesis strategies into our test function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们将假设策略输入到我们的测试函数中。
- en: ⑦ We capture each test case through the payload argument.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们通过有效载荷参数捕获每个测试用例。
- en: ⑧ We send the payload to the POST /orders endpoint.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们将有效载荷发送到 POST /orders 端点。
- en: ⑨ We assert the expected status code depending on whether the payload is valid.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 根据有效载荷是否有效，我们断言预期的状态码。
- en: 'As it turns out, Hypothesis is very suitable for generating datasets based
    on JSON Schema schemas, and there’s already a library that translates schemas
    into Hypothesis strategies, so you don’t have to do it yourself: `hypothesis-jsonschema`
    ([https://github.com/Zac-HD/hypothesis-jsonschema](https://github.com/Zac-HD/hypothesis-jsonschema)).
    I strongly encourage you to look at this library before trying to generate your
    own Hypothesis strategies for testing web APIs. Now that we understand what property-based
    testing is and how Hypothesis works, we’re ready to learn about Schemathesis,
    which is the topic of our next section!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Hypothesis非常适合根据JSON Schema模式生成数据集，并且已经有一个库可以将模式转换为Hypothesis策略，因此你不必自己来做这件事：`hypothesis-jsonschema`
    ([https://github.com/Zac-HD/hypothesis-jsonschema](https://github.com/Zac-HD/hypothesis-jsonschema))。我强烈建议你在尝试为测试Web
    API生成自己的Hypothesis策略之前查看这个库。现在我们了解了基于属性的测试是什么以及Hypothesis是如何工作的，我们就准备好学习Schemathesis了，这是我们下一节的主题！
- en: 12.4 Testing REST APIs with Schemathesis
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 使用Schemathesis测试REST API
- en: This section introduces Schemathesis and explains how it works and how we use
    it to test REST APIs. Schemathesis is an API testing framework that uses property-based
    testing to validate our APIs. It uses the `hypothesis` library under the hood,
    and thanks to its approach, it’s capable of running a more exhaustive test suite
    than Dredd. Once you’re getting ready to release your APIs to production, I recommend
    you test them with Schemathesis to make sure you cover all edge cases.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了Schemathesis，并解释了它是如何工作的以及我们如何使用它来测试REST API。Schemathesis是一个API测试框架，它使用基于属性的测试来验证我们的API。它底层使用`hypothesis`库，并且得益于其方法，它能够运行比Dredd更全面的测试套件。一旦你准备将API发布到生产环境，我建议你使用Schemathesis来测试它们，以确保你覆盖了所有边缘情况。
- en: 12.4.1 Running Schemathesis’s default test suite
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.1 运行Schemathesis的默认测试套件
- en: 'In this section, we’ll get familiar with Schemathesis by running its default
    test suite. Since we already installed our dependencies in section 12.1, all we
    need to do is `cd` into the orders folder and activate our environment by running
    `pipenv` `shell`. In contrast with Dredd, Schemathesis requires you to have your
    API server running before you run your test suite. You can start the server by
    opening a new terminal window and running the server there or by starting the
    server and pushing it to the background with the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过运行其默认测试套件来熟悉Schemathesis。由于我们在12.1节中已经安装了依赖项，我们只需要`cd`到orders文件夹并运行`pipenv
    shell`来激活我们的环境。与Dredd不同，Schemathesis要求你在运行测试套件之前启动你的API服务器。你可以通过在新终端窗口中打开并运行服务器，或者通过以下命令启动服务器并将其推送到后台来启动服务器：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `&` symbol pushes the process to the background. Then you can run Schemathesis
    with the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`符号将进程推送到后台。然后你可以使用以下命令运行Schemathesis：'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Hypothesis, the library that Schemathesis uses to generate test cases, creates
    a folder called .hypothesis/ where it caches some of its tests. In my experience,
    Hypothesis’s cache sometimes causes misleading results in subsequent test executions,
    so until this is fixed, my recommendation is to avoid caching the tests. We set
    the `--hypothesis-database` flag to `none` so that Schemathesis doesn’t cache
    test cases.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Hypothesis，Schemathesis用来生成测试用例的库，创建了一个名为.hypothesis/的文件夹，其中缓存了一些测试。根据我的经验，Hypothesis的缓存有时会导致后续测试执行中的误导性结果，所以直到这个问题得到修复之前，我的建议是避免缓存测试。我们设置`--hypothesis-database`标志为`none`，这样Schemathesis就不会缓存测试用例。
- en: After executing the command, you’ll see that Schemathesis runs around 700 tests
    against the API, testing all possible combinations of parameters, types, and formats.
    All tests should pass correctly. Once Schemathesis has finished, you can bring
    the Uvicorn process to the foreground by running the `fg` command, and stop it
    if you wish. (I’m sure know you know, but remember that to stop a process you
    use the Ctrl-C key combination).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，你会看到Schemathesis针对API运行了大约700个测试，测试所有可能的参数、类型和格式的组合。所有测试都应该正确通过。一旦Schemathesis完成，你可以通过运行`fg`命令将Uvicorn进程带到前台，如果你希望停止它的话。（我确信你知道，但请记住，要停止进程，你需要使用Ctrl-C键组合）。
- en: 12.4.2 Using links to enhance Schemathesis’ test suite
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4.2 使用链接增强Schemathesis的测试套件
- en: 'The test suite we just ran with Schemathesis has one major limitation: it doesn’t
    test whether the POST `/orders` endpoint is creating orders correctly nor if we
    can perform the expected operations, such as payments and cancellations, on an
    order. It’s simply launching independent and unrelated requests to each of the
    endpoints in the orders API. To check whether we are creating resources correctly,
    we need to enhance our API specification with links. As you can see in figure
    12.9, in the OpenAPI standard, links are declarations that allow us to describe
    the relationships between different endpoints.[²](#pgfId-1081343)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用 Schemathesis 运行的测试套件有一个主要限制：它没有测试 POST `/orders` 端点是否正确创建订单，也没有测试我们是否可以在订单上执行预期的操作，例如支付和取消。它只是向订单
    API 中的每个端点发送独立且无关的请求。为了检查我们是否正确创建了资源，我们需要通过链接增强我们的 API 规范。正如您在图 12.9 中所见，在 OpenAPI
    标准 中，链接是声明，允许我们描述不同端点之间的关系。[²](#pgfId-1081343)
- en: '![](../Images/12-09.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-09.png)'
- en: Figure 12.9 In OpenAPI, we can use links to describe the relationships between
    endpoints. For example, the POST `/orders` response contains an `id` property
    that we can use to replace the `order_id` parameter in the `/orders/{order_id}`
    URL.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 在 OpenAPI 中，我们可以使用链接来描述端点之间的关系。例如，POST `/orders` 的响应包含一个 `id` 属性，我们可以使用它来替换
    `/orders/{order_id}` URL 中的 `order_id` 参数。
- en: For example, using links, we can specify that the POST `/orders` endpoint returns
    a payload with an ID, and that we can use that ID to form the resource URL of
    the order just created under the GET `/orders/{order_id}` endpoint. We use operation
    IDs to describe the relationships between our endpoints. As we learned in chapter
    5 (section 5.3), operation IDs are unique identifiers for each endpoint in the
    API. Listing 12.9 shows how we enhance the orders API with a link that describes
    the relationship between the POST `/orders` endpoint and the GET `/orders/{order_id}`
    endpoint. For the full list of links, please see the ch12/orders/oas_with_links.yaml
    file in the GitHub repository for this book. Ellipses are used to hide parts of
    the code that are not relevant to the example, and newly added code is in bold.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用链接，我们可以指定 POST `/orders` 端点返回一个包含 ID 的有效负载，并且我们可以使用该 ID 来形成在 GET `/orders/{order_id}`
    端点下刚刚创建的订单的资源 URL。我们使用操作 ID 来描述端点之间的关系。正如我们在第 5 章（5.3 节）中学到的，操作 ID 是 API 中每个端点的唯一标识符。列表
    12.9 展示了我们是如何通过一个描述 POST `/orders` 端点和 GET `/orders/{order_id}` 端点之间关系的链接来增强订单
    API 的。有关链接的完整列表，请参阅本书 GitHub 仓库中的 ch12/orders/oas_with_links.yaml 文件。省略号用于隐藏与示例无关的代码部分，新添加的代码以粗体显示。
- en: In listing 12.9, we name the link between the POST `/orders` and the GET `/order/{order_id}`
    endpoints `GetOrder`. `GetOrder`’s `operationId` property identifies the endpoint
    this link refers to (`getOrder`). The GET `/order/{order_id}` endpoint has an
    URL parameter named `order_id`, and `GetOrder`’s `parameters` property tells us
    that the response body from the POST `/orders` endpoint contains an `id` property,
    which we can use to replace `order_id` in the GET `/order/{order_id}` endpoint.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 12.9 中，我们将 POST `/orders` 和 GET `/order/{order_id}` 端点之间的链接命名为 `GetOrder`。`GetOrder`
    的 `operationId` 属性标识了这个链接所引用的端点（`getOrder`）。GET `/order/{order_id}` 端点有一个名为 `order_id`
    的 URL 参数，而 `GetOrder` 的 `parameters` 属性告诉我们，POST `/orders` 端点的响应体包含一个 `id` 属性，我们可以使用它来替换
    GET `/order/{order_id}` 端点中的 `order_id`。
- en: Listing 12.9 Adding links to create relationships between endpoints in OpenAPI
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.9 在 OpenAPI 中添加链接以在端点之间创建关系的示例
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① We add links to the POST /orders endpoint.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们为 POST /orders 端点添加了链接。
- en: ② We define a link with the GET /orders/{order_id} endpoint.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们使用 GET /orders/{order_id} 端点定义了一个链接。
- en: ③ The order_id URL parameter in the getOrder endpoint can be replaced with the
    response payload’s id property.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 在 `getOrder` 端点中，可以将 `order_id` URL 参数替换为响应有效负载的 `id` 属性。
- en: ④ We explain how this link works.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们将解释这个链接是如何工作的。
- en: 'We can now run Schemathesis and take advantage of our links by running the
    following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行 Schemathesis 并通过以下命令利用我们的链接：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `--stateful=links` flag instructs Schemathesis to look for links in our
    documentation and use them to run tests on the resources created through the POST
    `/orders` endpoint. If you run Schemathesis now, you’ll see that it runs well
    over a thousand tests against the API. Since Schemathesis generates random tests,
    the exact number of tests cases may differ from time to time. Listing 12.10 shows
    the output of the Schemathesis test suite after running it with the `--stateful`
    parameter set to `links`. The listing omits the first few lines of the test suite
    as they contain only system-specific metadata. Notice that some of the tests appear
    nested within the POST `/orders` endpoint (the lines starting with the `->` symbol).
    Nested tests are tests that leverage links from our API documentation. If the
    tests on the POST `/orders` endpoint’s links pass, we can rest assured that our
    resources are being created correctly.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`--stateful=links` 标志指示 Schemathesis 在我们的文档中查找链接，并使用它们通过 POST `/orders` 端点创建的资源运行测试。如果你现在运行
    Schemathesis，你会看到它针对 API 运行超过一千个测试。由于 Schemathesis 生成随机测试，测试用例的确切数量可能因时而异。列表 12.10
    展示了使用 `--stateful` 参数设置为 `links` 运行 Schemathesis 测试套件后的输出。列表省略了测试套件的前几行，因为它们只包含系统特定的元数据。请注意，一些测试似乎嵌套在
    POST `/orders` 端点内部（以 `->` 符号开始的行）。嵌套测试是利用我们 API 文档中的链接进行的测试。如果 POST `/orders`
    端点的链接测试通过，我们可以确信我们的资源正在正确创建。'
- en: Listing 12.10 Output of a Schemathesis test suite
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.10 Schemathesis 测试套件的输出
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ① The server’s base URL
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ① 服务器的基准 URL
- en: ② The version of OpenAPI used by our server
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们服务器使用的 OpenAPI 版本
- en: ③ Number of processes running the test suite in parallel
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 并行运行测试套件的进程数量
- en: ④ Number of operations defined in the API specification
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ④ API 规范中定义的操作数量
- en: ⑤ Test for the GET /orders endpoint
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 测试 GET /orders 端点
- en: ⑥ Test for the GET /orders/{order_id} endpoint linked to the POST /orders endpoint
    test
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 测试与 POST /orders 端点关联的 GET /orders/{order_id} 端点
- en: ⑦ The test suite runs 1,200 tests, and all of them pass.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 测试套件运行了 1,200 个测试，并且全部通过。
- en: 'The output from the previous test says that our API passed all checks in the
    `not_a_` `server_error` category. By default, Schemathesis only checks that the
    API doesn’t raise server errors, but it can be configured to also verify that
    our API uses the right status codes, content types, headers, and schemas as documented
    in the API specification. To apply all these checks, we use the `--checks` flag
    and we set it to `all`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个测试的输出表明，我们的 API 在 `not_a_` `server_error` 类别中通过了所有检查。默认情况下，Schemathesis 只检查
    API 不会引发服务器错误，但它可以被配置为验证我们的 API 是否使用 API 规范中记录的正确状态码、内容类型、头和模式。要应用所有这些检查，我们使用
    `--checks` 标志并将其设置为 `all`：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, this time Schemathesis runs over a thousand test cases per
    check:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这次 Schemathesis 每次检查运行超过一千个测试用例：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In some cases, Schemathesis may complain that it takes too long to generate
    test cases. You can suppress that warning by using the `--hypothesis-suppress-health-check=too_slow`
    flag. By running the whole set of Schemathesis checks against your API, you can
    be certain that it works as expected and complies with the API specification.
    If you’d like to extend the tests with additional custom payloads or scenarios,
    you can do that as well. Since `schemathesis` is a Python library, it’s very easy
    to add additional custom tests. Check the documentation for examples on how to
    do that ([http://mng.bz/69Q5](http://mng.bz/69Q5)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Schemathesis 可能会抱怨生成测试用例花费的时间太长。你可以通过使用 `--hypothesis-suppress-health-check=too_slow`
    标志来抑制该警告。通过针对你的 API 运行整个 Schemathesis 检查集，你可以确信它按预期工作并符合 API 规范。如果你想要通过额外的自定义有效载荷或场景扩展测试，你也可以这样做。由于
    `schemathesis` 是一个 Python 库，添加额外的自定义测试非常容易。请查看文档以获取如何做到这一点的示例（[http://mng.bz/69Q5](http://mng.bz/69Q5)）。
- en: This concludes our journey through testing REST APIs. It’s now time to move
    on to the world of GraphQL API testing, which is the topic of the next section!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们通过测试 REST API 的旅程结束。现在是时候进入 GraphQL API 测试的世界了，这是下一节的主题！
- en: 12.5 Testing GraphQL APIs
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 测试 GraphQL API
- en: This section explains how we test and validate GraphQL APIs so that we can ensure
    they work as expected before we release them to production. We’ll use the products
    API, which we implemented in chapter 10, as a guiding example. To work through
    the examples in this section, `cd` into ch12/products and activate the environment
    by running `pipenv` `shell`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何测试和验证 GraphQL API，以确保在将它们发布到生产环境之前它们按预期工作。我们将使用在第 10 章中实现的商品 API 作为指导示例。为了完成本节中的示例，请使用
    `cd` 命令进入 ch12/products 目录，并通过运行 `pipenv shell` 激活环境。
- en: In sections 12.2 and 12.4, we learned about Dredd and Schemathesis, which automatically
    generate tests for REST APIs based on the API specification. For GraphQL, there’s
    less support for automatic test generation. In particular, Dredd doesn’t support
    GraphQL APIs, while Schemathesis only provides partial support. However, this
    is an active area of development, so expect to see increasing support for automatic
    GraphQL testing in the future.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 12.2 节和第 12.4 节中，我们学习了 Dredd 和 Schemathesis，它们可以根据 API 规范自动生成 REST API 的测试。对于
    GraphQL，自动测试生成的支持较少。特别是，Dredd 不支持 GraphQL API，而 Schemathesis 只提供部分支持。然而，这是一个活跃的开发领域，因此预计未来将看到对自动
    GraphQL 测试的支持不断增加。
- en: 12.5.1 Testing GraphQL APIs with Schemathesis
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.1 使用 Schemathesis 测试 GraphQL API
- en: This section explains how we use Schemathesis to test and validate a GraphQL
    API. As we explained in section 12.4, Schemathesis is an API testing framework
    that uses an approach known as property-based testing to validate our APIs. Schemathesis
    can be used to test both REST and GraphQL APIs. In both cases, as you can see
    in figure 12.10, Schemathesis looks at the API specification to learn about its
    endpoints and schemas, and to decide which tests to run.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何使用 Schemathesis 测试和验证 GraphQL API。正如我们在第 12.4 节中解释的那样，Schemathesis 是一个
    API 测试框架，它使用一种称为基于属性的测试方法来验证我们的 API。Schemathesis 可以用于测试 REST 和 GraphQL API。在两种情况下，如图
    12.10 所示，Schemathesis 会查看 API 规范以了解其端点和模式，并决定要运行哪些测试。
- en: '![](../Images/12-10.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-10.png)'
- en: Figure 12.10 Schemathesis parses a GraphQL API specification in search of available
    operations and generates query documents with both valid and invalid parameters
    and selection sets to test the server’s response.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 Schemathesis 解析 GraphQL API 规范以查找可用操作，并生成包含有效和无效参数以及选择集的查询文档来测试服务器的响应。
- en: 'To generate tests for a GraphQL API, Schemathesis uses `hypothesis-graphql`
    ([http://mng.bz/o5Pj](http://mng.bz/o5Pj)), a library that generates Hypothesis
    strategies from a GraphQL schema. Before we run our test, we need to start the
    GraphQL API server. You can do that in a different terminal window, or you can
    run the process in the background with the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 GraphQL API 生成测试，Schemathesis 使用 `hypothesis-graphql` ([http://mng.bz/o5Pj](http://mng.bz/o5Pj))，这是一个从
    GraphQL 模式生成 Hypothesis 策略的库。在我们运行测试之前，我们需要启动 GraphQL API 服务器。您可以在不同的终端窗口中这样做，或者您可以使用以下命令在后台运行进程：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `&` symbol pushes the Uvicorn process to the background. To test a GraphQL
    API with Schemathesis, we simply need to give it the URL where our API specification
    is hosted. In our case, the GraphQL API is hosted under the following URL: http://127.0.0.1:8000/graphql.
    Armed with this information, we can now run our tests:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`&` 符号将 Uvicorn 进程推送到后台。要使用 Schemathesis 测试 GraphQL API，我们只需提供我们的 API 规范托管的位置的
    URL。在我们的例子中，GraphQL API 托管在以下 URL 下：http://127.0.0.1:8000/graphql。有了这些信息，我们现在可以运行我们的测试：'
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `--hypothesis-deadline=None` flag instructs Schemathesis to avoid timing
    the requests. This is useful in cases where our queries may be slow, which sometimes
    happens with GraphQL APIs. The following shows the output of the test suite, omitting
    the first few lines that contain platform-specific metadata. As you can see, Schemathesis
    tests all of the queries and mutations exposed by the products API, generating
    a very solid battery of tests: 1,100 test cases!'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`--hypothesis-deadline=None` 标志指示 Schemathesis 避免对请求进行计时。这在我们的查询可能很慢的情况下很有用，有时
    GraphQL API 就会发生这种情况。以下显示了测试套件的输出，省略了包含平台特定元数据的前几行。如图所示，Schemathesis 测试了商品 API
    所公开的所有查询和突变，生成了一套非常坚实的测试：1,100 个测试用例！'
- en: Listing 12.11 Output of a Schemathesis test suite for a GraphQL API
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.11 Schemathesis 测试套件对 GraphQL API 的输出
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After running the Schemathesis test suite against the products API, we can be
    certain that our queries and mutations work as expected. You can further customize
    your tests to make sure the application works correctly under certain conditions.
    To learn how to add custom tests cases, check out Schemathesis’ excellent documentation
    ([https://schemathesis.readthedocs.io/en/stable/](https://schemathesis.readthedocs.io/en/stable/)).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在对产品 API 运行 Schemathesis 测试套件后，我们可以确信我们的查询和突变按预期工作。你可以进一步自定义你的测试，以确保应用程序在特定条件下正确运行。要了解如何添加自定义测试用例，请查看
    Schemathesis 的优秀文档（[https://schemathesis.readthedocs.io/en/stable/](https://schemathesis.readthedocs.io/en/stable/))。
- en: 12.6 Designing your API testing strategy
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.6 设计你的 API 测试策略
- en: You’ve learned a lot in this chapter. You’ve learned to use frameworks such
    as Dredd and Schemathesis, which run automated test suites against your APIs based
    on the API documentation. You’ve also learned about property-based testing and
    how to use Hypothesis to automatically generate test cases to test your REST and
    GraphQL APIs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中学到了很多。你学会了如何使用 Dredd 和 Schemathesis 等框架，这些框架根据 API 文档对 API 运行自动测试套件。你还了解了基于属性的测试以及如何使用
    Hypothesis 自动生成测试用例来测试你的 REST 和 GraphQL API。
- en: 'As we saw in section 12.2, Dredd runs a simple test suite against your APIs.
    Dredd only tests the happy path: it makes sure your API accepts the expected payloads
    and responds with the expected payloads. It doesn’t test what happens when the
    wrong payloads are sent to your server.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 12.2 节中看到的，Dredd 对你的 API 运行一个简单的测试套件。Dredd 只测试快乐路径：它确保你的 API 接受预期的有效载荷并响应预期的有效载荷。它不测试当错误的有效载荷发送到你的服务器时会发生什么。
- en: Dredd’s testing strategy is useful in the early development stage of your API,
    when you want to be able to focus on the overall functionality of your application
    rather than get bogged down with specific corner cases of your API integration.
    However, before you release your APIs to production, you want to make sure your
    APIs are tested with Schemathesis. Schemathesis runs a more comprehensive test
    suite, which ensures that your API works exactly as expected.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Dredd 的测试策略在 API 的早期开发阶段非常有用，当你想要专注于应用程序的整体功能而不是陷入 API 集成的特定边缘情况时。然而，在你将 API
    发布到生产之前，你想要确保你的 API 已经用 Schemathesis 进行了测试。Schemathesis 运行一个更全面的测试套件，确保你的 API
    精确地按预期工作。
- en: I recommend you run Dredd and Schemathesis locally during development, and also
    in your continuous integration (CI) server before releasing your code. For an
    example of how you can incorporate Dredd and Schemathesis into your CI server,
    check out my talk, “API Development Workflows for Successful Integrations,” at
    Manning’s API Conference (August 3 2021, [https://youtu.be/SUKqmEX_uwg](https://youtu.be/SUKqmEX_uwg)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在开发过程中本地运行 Dredd 和 Schemathesis，并在发布代码之前在你的持续集成（CI）服务器上运行。关于如何将 Dredd 和
    Schemathesis 集成到你的 CI 服务器中的示例，请查看我在 Manning 的 API 会议上的演讲，“API 开发工作流程以实现成功集成”（2021
    年 8 月 3 日，[https://youtu.be/SUKqmEX_uwg](https://youtu.be/SUKqmEX_uwg))。
- en: Some of the technologies and skills that you’ve learned in this chapter are
    still very new and experimental, so you’ve got an edge in your team and in the
    job market. Use your new powers wisely!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中学到的一些技术和技能仍然非常新颖和实验性，所以你在团队和就业市场上具有优势。明智地使用你的新力量！
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Dredd and Schemathesis are API testing tools that automatically generate validation
    tests for APIs from the documentation. This helps you to avoid the effort of writing
    tests manually and to focus on building your APIs and services.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dredd 和 Schemathesis 是 API 测试工具，可以从文档中自动生成 API 的验证测试。这有助于你避免手动编写测试的努力，并专注于构建你的
    API 和服务。
- en: Dredd is a REST API testing framework. It runs a basic test suite against your
    API without covering edge cases, and therefore it’s convenient in the early stages
    of your API cycle.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dredd 是一个 REST API 测试框架。它对你的 API 运行一个基本的测试套件，不涵盖边缘情况，因此在 API 周期的早期阶段非常方便。
- en: You can customize Dredd’s behavior by adding Dredd hooks to your tests. Although
    Dredd is an npm package, you can write your hooks in Python. Dredd hooks are useful
    for saving information from one test for reuse in another test, and for creating
    or deleting resources before and after each test.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过向你的测试中添加 Dredd 钩子来自定义 Dredd 的行为。尽管 Dredd 是一个 npm 包，但你可以用 Python 编写你的钩子。Dredd
    钩子对于从一次测试中保存信息以供另一次测试重用，以及在每次测试前后创建或删除资源非常有用。
- en: Schemathesis is a more generic API test framework that runs an exhaustive test
    suite against your APIs. Before releasing your APIs to production, you want to
    make sure you’ve tested them with Schemathesis. You can use Schemathesis to test
    both REST and GraphQL APIs.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Schemathesis是一个更通用的API测试框架，它会对您的API运行详尽的测试套件。在将API发布到生产环境之前，您想要确保已经使用Schemathesis测试了它们。您可以使用Schemathesis来测试REST和GraphQL
    API。
- en: To test that your POST endpoints are creating resources correctly, you can enrich
    your OpenAPI specification with links and instruct Schemathesis to use them in
    its test suite. Links are properties that describe the relationship between different
    operations in an OpenAPI specification.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了测试您的POST端点是否正确创建资源，您可以通过添加链接来丰富您的OpenAPI规范，并指导Schemathesis在测试套件中使用它们。链接是描述OpenAPI规范中不同操作之间关系的属性。
- en: Property-based testing is an approach in which you let a framework generate
    random test cases, and you validate the behavior of your code by making assertions
    about the properties of the test result. This approach saves you the time of having
    to write test cases manually. In Python, you can run property-based tests with
    the excellent `hypothesis` library.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于属性的测试是一种方法，其中您让框架生成随机测试用例，并通过对测试结果属性进行断言来验证您代码的行为。这种方法可以节省您手动编写测试用例的时间。在Python中，您可以使用出色的`hypothesis`库运行基于属性的测试。
- en: '* * *'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ See the excellent article by David R. MacIver for a more detailed explanation
    of what property-based testing is: “What is Property Based Testing?,” [https://hypothesis.works/articles/what-is-property-based-testing/](https://hypothesis.works/articles/what-is-property-based-testing/).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 关于基于属性的测试的更详细解释，请参阅David R. MacIver的优秀文章：“什么是基于属性的测试？”，[https://hypothesis.works/articles/what-is-property-based-testing/](https://hypothesis.works/articles/what-is-property-based-testing/)。
- en: ² For a good explanation of how links work and how you leverage them in your
    API documentation, see [https://swagger.io/docs/specification/links/](https://swagger.io/docs/specification/links/).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ² 为了了解链接如何工作以及如何在您的API文档中利用它们，请参阅[https://swagger.io/docs/specification/links/](https://swagger.io/docs/specification/links/)。
