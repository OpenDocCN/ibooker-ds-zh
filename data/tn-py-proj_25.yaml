- en: Appendix. Using argparse
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录。使用 argparse
- en: '| Often, getting the right data into your program is a real chore. The `argparse`
    module makes it much easier to validate arguments from users and to generate useful
    error messages when they provide bad input. It’s like your program’s “bouncer,”
    only allowing the right kinds of values into the program. Defining the arguments
    properly with `argparse` is the crucial first step to making the programs in this
    book work.For instance, chapter 1 discusses a very flexible program that can extend
    warm salutations to an optionally named entity, such as the “World” or “Universe”:
    | ![](../Images/A-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 通常，将正确数据输入到你的程序中是一项真正的苦差事。`argparse` 模块使得验证用户输入的参数以及在他们提供错误输入时生成有用的错误信息变得容易得多。它就像你程序的“保安”，只允许正确的值进入程序。使用
    `argparse` 正确定义参数是使本书中的程序正常工作的关键第一步。例如，第1章讨论了一个非常灵活的程序，它可以向一个可选命名的实体（如“世界”或“宇宙”）发出热情的问候：|
    ![](../Images/A-unnumb-1.png)  |'
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① When the program runs with no input values, it will use “World” for the entity
    to greet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ① 当程序在没有输入值的情况下运行时，它将使用“World”作为问候的实体。
- en: ② The program can take an optional --name value to override the default.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ② 程序可以接受一个可选的 --name 值来覆盖默认值。
- en: 'The program will respond to the `-h` and `--help` flags with helpful documentation:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将对 `-h` 和 `--help` 标志做出有助的文档响应：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① The argument to the program is -h, which is the “short” flag to ask for help.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ① 程序的参数是 -h，这是请求帮助的“短”标志。
- en: ② This line shows a summary of all the options the program accepts. The square
    brackets [] around the arguments show that they are optional.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这一行显示了程序接受的所有选项的摘要。括号 [] 中的参数表明它们是可选的。
- en: ③ This is the description of the program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 这是程序的描述。
- en: ④ We can use either the “short” name -h or the “long” name --help to ask the
    program for help on how to run it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 我们可以使用“短”名 -h 或“长”名 --help 来请求程序关于如何运行的帮助。
- en: ⑤ The optional “name” parameter also has short and long names of -n and --name.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 可选的“name”参数也有短名 -n 和长名 --name。
- en: 'All of this is created by just two lines of code in the hello.py program:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过 hello.py 程序中的两行代码实现：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ① The parser will parse the arguments for us. If the user provides unknown arguments
    or the wrong number of arguments, the program will halt with a usage statement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ① 解析器将为我们解析参数。如果用户提供了未知参数或错误的参数数量，程序将显示用法语句并停止运行。
- en: ② The only argument to this program is an optional --name value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ② 此程序唯一的参数是一个可选的 --name 值。
- en: Note You do not need to define the `-h` or `--help` flags. Those are generated
    automatically by `argparse`. In fact, you should never try to use those for other
    values because they are almost universal options that most users will expect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您不需要定义 `-h` 或 `--help` 标志。这些是由 `argparse` 自动生成的。实际上，您永远不应该尝试使用这些值，因为它们几乎是通用的选项，大多数用户都会期望。
- en: The `argparse` module helps us define a parser for the arguments and generates
    help messages, saving us loads of time and making our programs look professional.
    Every program in this book is tested on different inputs, so you’ll really understand
    how to use this module by the end. I recommend you look over the `argparse` documentation
    ([https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse` 模块帮助我们定义参数解析器并生成帮助信息，节省了我们大量时间，并使我们的程序看起来更专业。本书中的每个程序都在不同的输入上进行测试，所以你将真正理解如何使用此模块。我建议你查看
    `argparse` 文档 ([https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html))。'
- en: Now let’s dig further into what this module can do for us. In this appendix,
    you will
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步探讨这个模块能为我们做什么。在本附录中，你将
- en: Learn how to use `argparse` to handle positional parameters, options, and flags
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 `argparse` 处理位置参数、选项和标志
- en: Set default values for options
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为选项设置默认值
- en: Use `type` to force the user to provide values like numbers or files
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `type` 强制用户提供数值或文件等值
- en: Use `choices` to restrict the values for an option
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `choices` 限制选项的值
- en: A.1 Types of arguments
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 参数类型
- en: 'Command-line arguments can be classified as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数可以按以下方式分类：
- en: '*Positional arguments* --The order and number of the arguments is what determines
    their meaning. Some programs might expect, for instance, a filename as the first
    argument and an output directory as the second. Positional arguments are generally
    required (not optional) arguments. Making them optional is difficult--how would
    you write a program that accepts two or three arguments where the second and third
    ones are independent and optional? In the first version of hello.py in chapter
    1, the name to greet was provided as a positional argument.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*位置参数* ——参数的顺序和数量决定了它们的含义。一些程序可能期望，例如，第一个参数是文件名，第二个参数是输出目录。位置参数通常是必需的（非可选）参数。使它们成为可选的是困难的——你将如何编写一个接受两个或三个参数的程序，其中第二个和第三个参数是独立的和可选的？在第一章hello.py的第一个版本中，问候的名称作为位置参数提供。'
- en: '*Named options* --Most command-line programs define a *short* name like `-n`
    (one dash and a single character) and a *long* name like `--name` (two dashes
    and a word) followed by some value, like the name in the hello.py program. Named
    options allow arguments to be provided in any order--their *position* is not relevant.
    This makes them the right choice when the user is not required to provide them
    (they are *options*, after all). It’s good to provide reasonable default values
    for options. When we changed the required positional `name` argument of hello.py
    to the optional `--name` argument, we used “World” for the default so that the
    program could run with no input from the user. Note that some other languages,
    like Java, might define long names with a single dash, like `-jar`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*命名选项* ——大多数命令行程序定义一个*短*名称，如`-n`（一个短横线和单个字符），以及一个*长*名称，如`--name`（两个短横线和单词），后面跟一些值，如hello.py程序中的名称。命名选项允许以任何顺序提供参数——它们的*位置*并不重要。这使得它们在用户不需要提供它们时成为正确的选择（毕竟它们是*选项*）。为选项提供合理的默认值是很好的。当我们将hello.py中必需的位置`name`参数更改为可选的`--name`参数时，我们使用了“World”作为默认值，这样程序就可以在没有用户输入的情况下运行。请注意，某些其他语言，如Java，可能使用单个短横线定义长名称，如`-jar`。'
- en: '*Flags* --A Boolean value like “yes”/“no” or `True`/`False` is indicated by
    something that starts off looking like a named option, but there is no value after
    the name; for example, the `-d` or `--debug` flag to turn on debugging. Typically
    the presence of the flag indicates a `True` value for the argument, and its absence
    would mean `False`, so `--debug` turns *on* debugging, whereas its absence means
    it is off.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标志* ——类似于“是”/“否”或`True`/`False`的布尔值，通过看起来像命名选项的东西表示，但名称后面没有值；例如，用于开启调试的`-d`或`--debug`标志。通常，标志的存在表示参数的值为`True`，其不存在则表示`False`，所以`--debug`会开启*调试*，而其不存在则表示关闭。'
- en: A.2 Using a template to start a program
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 使用模板启动程序
- en: It’s not easy to remember all the syntax for defining parameters using `argparse`,
    so I’ve created a way for you to write new programs from a template that includes
    this plus some other structure that will make your programs easier to read and
    run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 记住使用`argparse`定义参数的所有语法并不容易，所以我为你创建了一种方法，让你可以从一个模板开始编写新程序，该模板包括这些以及其他一些将使你的程序更容易阅读和运行的结构。
- en: 'One way to start a new program is to use the new.py program. From the top level
    of the repository, you can execute this command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新程序的一种方法是通过使用new.py程序。从存储库的顶层，你可以执行以下命令：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you could copy the template:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以复制模板：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The resulting program will be identical no matter how you create it, and it
    will have examples of how to declare each of the argument types outlined in the
    previous section. Additionally, you can use `argparse` to validate the input,
    such as making sure that one argument is a number while another argument is a
    file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的程序将与你创建它的方式无关，并且它将包含如何声明上一节中概述的每种参数类型的示例。此外，你可以使用`argparse`来验证输入，例如确保一个参数是数字，而另一个参数是文件。
- en: 'Let’s look at the help generated by our new program:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们新程序生成的帮助信息：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Every program should respond to -h and --help with a help message.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ① 每个程序都应该对-h和--help做出响应，显示帮助信息。
- en: ② This a brief summary of the options that are described in greater detail below.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这是对下面更详细描述的选项的简要总结。
- en: ③ This is the description of the entire program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 这是整个程序的描述。
- en: ④ This program defines one positional parameter, but you could have many more.
    You’ll see how to define those shortly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 该程序定义了一个位置参数，但你可以有更多。你很快就会看到如何定义这些参数。
- en: ⑤ Optional arguments can be left out, so you should provide reasonable default
    values for them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 可选参数可以省略，因此你应该为它们提供合理的默认值。
- en: ⑥ The -h and --help arguments are always present when you use argparse; you
    do not need to define them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 当您使用 argparse 时，`-h` 和 `--help` 参数总是存在的；您不需要定义它们。
- en: ⑦ The -a or --arg option accepts some text, which is often called a “string.”
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ `-a` 或 `--arg` 选项接受一些文本，这通常被称为“字符串”。
- en: ⑧ The -i or --int option must be an integer value. If the user provides “one”
    or “4.2,” these will be rejected.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ `-i` 或 `--int` 选项必须是一个整数值。如果用户提供了“one”或“4.2”，这些将被拒绝。
- en: ⑨ The -f or --file option must be a valid, readable file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ `-f` 或 `--file` 选项必须是一个有效、可读的文件。
- en: ⑩ The -o or --on is a flag. Notice how the -f FILE description specifies that
    a “FILE” value should follow the -f, but for this flag no value follows the option.
    The flag is either present or absent, and so it’s either True or False, respectively.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ `-o` 或 `--on` 是一个标志。注意 `-f FILE` 描述指定“FILE”值应跟在 `-f` 之后，但对此标志没有值跟随选项。标志要么存在，要么不存在，因此它分别对应于布尔值
    True 或 False。
- en: A.3 Using argparse
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 使用 argparse
- en: 'The code to generate the preceding usage is found in a function, called `get_args()`,
    that looks like the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 生成前面用法的代码位于一个名为 `get_args()` 的函数中，其代码如下：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You are welcome to put this code wherever you like, but defining and validating
    the arguments can sometimes get rather long. I like to separate this code out
    into a function I call `get_args()`, and I always define this function first in
    my program. That way I can see it immediately when I’m reading the source code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此代码放在您喜欢的任何地方，但定义和验证参数有时可能会相当长。我喜欢将此代码分离到一个我称为 `get_args()` 的函数中，并且我总是在程序中首先定义此函数。这样，当我阅读源代码时，我就可以立即看到它。
- en: 'The `get_args()` function is defined like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_args()` 函数定义如下：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ① The def keyword defines a new function, and the arguments to the function
    are listed in the parentheses. Even though the get_args() function takes no arguments,
    the parentheses are still required.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ① `def` 关键字定义了一个新函数，函数的参数列在括号中。即使 `get_args()` 函数没有参数，括号仍然是必需的。
- en: ② The triple-quoted line after the function def is the “docstring,” which serves
    as a bit of documentation for the function. Docstrings are not required, but they
    are good style, and Pylint will complain if you leave them out.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ② 函数定义之后的三个引号行是“文档字符串”，它作为函数的一点点文档。文档字符串不是必需的，但它们是良好的风格，如果遗漏了它们，Pylint 会提出警告。
- en: A.3.1 Creating the parser
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.1 创建解析器
- en: 'The following snippet creates a `parser` that will deal with the arguments
    from the command line. To “parse” here means to derive some meaning from the order
    and syntax of the bits of text provided as arguments:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段创建了一个`parser`，该`parser`将处理命令行中的参数。在这里，“解析”意味着从提供的作为参数的文本片段的顺序和语法中推导出一些含义：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Call the argparse.ArgumentParser() function to create a new parser.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ① 调用 `argparse.ArgumentParser()` 函数来创建一个新的解析器。
- en: ② A short summary of your program’s purpose.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ② 您程序的用途的简要总结。
- en: ③ The formatter_class argument tells argparse to show the default values in
    usage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ③ `formatter_class` 参数告诉 `argparse` 在用法中显示默认值。
- en: You should read the documentation for `argparse` to see all the other options
    you can use to define a `parser` or the parameters. In the REPL, you can start
    with `help(argparse)`, or you could look up the docs on the internet at [https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读 `argparse` 的文档，以查看您可以使用来定义 `parser` 或参数的所有其他选项。在 REPL 中，您可以从 `help(argparse)`
    开始，或者您可以在互联网上查找[https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)上的文档。
- en: A.3.2 Creating a positional parameter
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.2 创建位置参数
- en: 'The following line will create a new *positional* parameter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将创建一个新的 *位置* 参数：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ① The lack of leading dashes makes this a positional parameter, not the name
    “positional.”
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ① 缺少前导破折号使得这是一个位置参数，而不是名为“位置”的参数。
- en: ② Provide a hint to the user about the data type. By default, all arguments
    are strings.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ② 向用户提供数据类型的提示。默认情况下，所有参数都是字符串。
- en: ③ A brief description of the parameter for the usage
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 参数用法的简要描述
- en: Remember that the parameter is not positional because the *name* is “positional.”
    That’s just there to remind you that it *is* a positional parameter. `argparse`
    interprets the string `'positional'` as a positional parameter *because the name
    does not start with any dashes*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，参数不是位置参数，因为其 *名称* 是“位置”。那只是为了提醒你它 *确实是* 一个位置参数。`argparse` 将字符串 `'positional'`
    解释为位置参数，因为其 *名称* 没有以任何破折号开头。
- en: A.3.3 Creating an optional string parameter
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.3 创建可选字符串参数
- en: The following line creates an *optional* parameter with a short name of `-a`
    and a long name of `--arg`. It will be a `str` with a default value of `''` (the
    empty string).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个短名称为`-a`和长名称为`--arg`的*可选*参数。它将是一个默认值为`''`（空字符串）的`str`。
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① The short name
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ① 简短名称
- en: ② The long name
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ② 长名称
- en: ③ Brief description for the usage
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 用作使用的简要描述
- en: ④ Type hint for usage
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 用作使用说明的类型提示
- en: ⑤ The actual Python data type (note the lack of quotes around str)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 实际的Python数据类型（注意`str`周围没有引号）
- en: ⑥ The default value
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 默认值
- en: Note You can leave out either the short or long name in your own programs, but
    it’s good form to provide both. Most of the tests in this book will test your
    programs using both short and long option names.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在自己的程序中省略短名称或长名称，但提供两者是良好的做法。本书中的大多数测试都将使用短名称和长名称选项来测试你的程序。
- en: If you wanted to make this a required, named parameter, you would remove the
    `default` and add `required=True`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将其作为一个必需的命名参数，你应该移除`default`并添加`required=True`。
- en: A.3.4 Creating an optional numeric parameter
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.4 创建可选数字参数
- en: The following line creates an option called `-i` or `--int` that accepts an
    `int` (integer) with a default value of `0`. If the user provides anything that
    cannot be interpreted as an integer, the `argparse` module will stop processing
    the arguments and will print an error message and a short usage statement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`-i`或`--int`的选项，它接受一个默认值为`0`的`int`（整数）。如果用户提供的任何内容都不能被解释为整数，`argparse`模块将停止处理参数，并打印一条错误消息和简短的使用说明。
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① The short name
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ① 简短名称
- en: ② The long name
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ② 长名称
- en: ③ A brief description for the usage statement
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用说明的简要描述
- en: ④ A type hint for the usage statement
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 用作使用说明的类型提示
- en: ⑤ A Python data type that the string must be converted to. You can also use
    float for a floating point value (a number with a fractional component like 3.14).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 必须将字符串转换为的Python数据类型。你也可以使用`float`来表示浮点值（带有小数部分的数字，如3.14）。
- en: ⑥ The default value
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 默认值
- en: One of the big reasons to define numeric arguments in this way is that `argparse`
    will convert the input to the correct type. All values coming from the command
    are strings, and it’s the job of the program to convert each value to an actual
    numeric value. If you tell `argparse` that the option should be `type=int`, it
    will have already been converted to an actual `int` value when you ask the `parser`
    for the value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方式下定义数字参数的一个主要原因是`argparse`会将输入转换为正确的类型。所有来自命令行的值都是字符串，程序的任务是将每个值转换为实际的数值。如果你告诉`argparse`该选项应该是`type=int`，那么当你从`parser`请求值时，它已经转换成了实际的`int`值。
- en: If the value provided by the user cannot be converted to an `int`, the value
    will be rejected. Note that you can also use `type=float` to accept and convert
    the input to a floating-point value. That saves you a lot of time and effort.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户提供的值不能转换为`int`，该值将被拒绝。请注意，你也可以使用`type=float`来接受并转换输入为浮点值。这可以节省你大量的时间和精力。
- en: A.3.5 Creating an optional file parameter
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.5 创建可选文件参数
- en: The following line creates an option called `-f` or `--file` that will only
    accept a valid, readable file. This argument alone is worth the price of admission,
    as it will save you oodles of time validating the input from your user. Note that
    pretty much every exercise that has a file as input will have tests that pass
    *invalid* file arguments to ensure that your program rejects them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`-f`或`--file`的选项，它只接受有效的、可读的文件。这个参数本身就物有所值，因为它将为你节省大量验证用户输入的时间。请注意，几乎每个有文件作为输入的练习都将有测试，这些测试会传递*无效*的文件参数以确保你的程序拒绝它们。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① The short name
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ① 简短名称
- en: ② The long name
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ② 长名称
- en: ③ A brief usage statement
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 简短的使用说明
- en: ④ A type suggestion
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 类型建议
- en: ⑤ Says that the argument must name a readable ('r') file
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 表示该参数必须命名一个可读的（'r'）文件
- en: ⑥ The default value
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 默认值
- en: 'The person running the program is responsible for providing the location of
    the file. For instance, if you created the foo.py program in the top level of
    the repository, there will be a README.md file there. We could use that as the
    input to our program, and it would be accepted as a valid argument:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序的人负责提供文件的地址。例如，如果你在存储库的顶层创建了foo.py程序，那里将有一个README.md文件。我们可以将其用作程序的输入，并且它将被接受为有效的参数：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we provide a bogus `--file` argument, like “blargh,” we will get an error
    message:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供一个无效的`--file`参数，如“blargh”，我们将得到一个错误消息：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A.3.6 Creating a flag option
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.6 创建标志选项
- en: The flag option is slightly different in that it does not take a value like
    a string or integer. Flags are either present or not, and they *usually* indicate
    that some idea is `True` or `False`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 标志选项略有不同，因为它不接收像字符串或整数这样的值。标志要么存在，要么不存在，并且它们通常表示某个想法是 `True` 或 `False`。
- en: You’ve already seen the `-h` and `--help` flags. They are not followed by any
    values. They either are present, in which case the program should print a “usage”
    statement, or they are absent, in which case the program should not. For all the
    exercises in this book, I use flags to indicate a `True` value when they are present
    and `False` otherwise, which we can represent using `action='store_true'`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 `-h` 和 `--help` 标志。它们后面没有跟随任何值。它们要么存在，在这种情况下程序应该打印一个“用法”语句，要么不存在，在这种情况下程序不应该打印。在本书的所有练习中，我使用标志来表示当它们存在时为
    `True` 值，否则为 `False`，我们可以使用 `action='store_true'` 来表示。
- en: 'For instance, new.py shows an example of this kind of a flag called `-o` or
    `--on`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，new.py 展示了这种名为 `-o` 或 `--on` 的标志的示例：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Short name
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ① 短名称
- en: ② Long name
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ② 长名称
- en: ③ Brief usage statement
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 简要使用说明
- en: ④ What to do when this flag is present. When it is present, we use the value
    True for on. The default value will be False when the flag is not present.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 当此标志存在时应该做什么。当它存在时，我们为 `on` 使用 True 值。当标志不存在时，默认值将是 False。
- en: It’s not always the case that a “flag” like this should be interpreted as `True`
    when present. You could instead use `action='store_false'`, in which case `on`
    would be `False` when the flag is present, and the default value would be `True`.
    You could also store one or more constant values when the flag is present.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有像这样的“标志”都应该在存在时解释为 `True`。你可以使用 `action='store_false'` 来代替，在这种情况下，当标志存在时，`on`
    将是 `False`，默认值将是 `True`。你还可以在标志存在时存储一个或多个常量值。
- en: Read the `argparse` documentation for the various ways you can define this parameter.
    For the purposes of this book, we will only use a flag to turn “on” some behavior.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 `argparse` 文档，了解你可以定义此参数的各种方式。就本书的目的而言，我们将仅使用标志来开启某些行为。
- en: A.3.7 Returning from get_args
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.3.7 从 get_args 返回
- en: 'The final statement in `get_args()` is `return`, which returns the result of
    having the `parser` object parse the arguments. That is, the code that calls `get_args()`
    will receive the result of this expression:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_args()` 函数中的最后一个语句是 `return`，它返回 `parser` 对象解析参数的结果。也就是说，调用 `get_args()`
    的代码将接收到这个表达式的结果：'
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This expression could fail because `argparse` finds that the user provided invalid
    arguments, such as a string value when it expected a `float` or perhaps a misspelled
    filename. If the parsing succeeds, we will be able to access all the values the
    user provided from inside our program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式可能会失败，因为 `argparse` 发现用户提供了无效的参数，例如当它期望一个 `float` 值时提供了一个字符串值，或者可能是一个拼写错误的文件名。如果解析成功，我们将能够从我们的程序内部访问用户提供的所有值。
- en: Additionally, the values of the arguments will be of the *types* that we indicated.
    That is, if we indicated that the `--int` argument should be an `int`, then when
    we ask for `args.int`, it will already be an `int`. If we define a file argument,
    we’ll get an *open file handle*. That may not seem impressive now, but it’s really
    enormously helpful.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，参数的值将是我们在其中指定的 *类型*。也就是说，如果我们指定 `--int` 参数应该是一个 `int`，那么当我们请求 `args.int`
    时，它已经是一个 `int`。如果我们定义一个文件参数，我们将得到一个 *打开的文件句柄*。这可能现在看起来并不令人印象深刻，但它实际上非常有帮助。
- en: 'If you refer to the foo.py program we generated, you’ll see that the `main()`
    function calls `get_args()`, so the `return` from `get_args()` goes back to `main()`.
    From there, we can access all the values we just defined using the names of the
    positional parameters or the long names of the optional parameters:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考我们生成的 foo.py 程序，你会看到 `main()` 函数调用了 `get_args()`，因此 `get_args()` 的 `return`
    将返回到 `main()`。从那里，我们可以使用位置参数的名称或可选参数的长名称来访问我们刚刚定义的所有值：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A.4 Examples using argparse
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 使用 argparse 的示例
- en: Many of the program tests in this book can be satisfied by learning how to use
    `argparse` effectively to validate the arguments to your programs. I think of
    the command line as the boundary of your program, and you need to be judicious
    about what you let into your program. You should always expect and defend against
    every argument being wrong.[1](#pgfId-1021182) Our hello.py program in chapter
    1 is an example of a single, positional argument and then a single, optional argument.
    Let’s look at some more examples of how you can use `argparse`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多程序测试可以通过学习如何有效地使用`argparse`来验证程序的参数来满足。我认为命令行是程序的边界，你需要明智地决定允许什么进入你的程序。你应该始终预期并防御每个参数可能出错的情况。[1](#pgfId-1021182)
    第一章的hello.py程序是一个单位置参数和一个单可选参数的例子。让我们看看更多关于如何使用`argparse`的例子。
- en: A.4.1 A single positional argument
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.1 单个位置参数
- en: 'This is the first version of chapter 1’s hello.py program, which requires a
    single argument specifying the name to greet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一章hello.py程序的第一版，它需要一个参数来指定问候的名字：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ① The name parameter does not start with dashes, so this is a positional parameter.
    The metavar will show up in the help to let the user know what this argument is
    supposed to be.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ① 名称参数不以连字符开头，因此这是一个位置参数。metavar将在帮助信息中显示，以使用户知道这个参数应该是什么。
- en: ② Whatever is provided as the first positional argument to the program will
    be available in the args.name slot.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ② 程序的第一个位置参数提供的任何内容都将可在`args.name`槽中访问。
- en: 'This program will not print the “Hello” line if it’s not provided exactly one
    argument. If given nothing, it will print a brief usage statement about the proper
    way to invoke the program:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序没有接收到恰好一个参数，它将不会打印“Hello”行。如果没有提供任何参数，它将打印一条简短的用法说明，关于如何正确调用程序的方法：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we provide more than one argument, it complains again. Here “Emily” and
    “Bronte” are two arguments because spaces separate arguments on the command line.
    The program complains about getting a second argument that has not been defined:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供多个参数，它将再次抱怨。这里“Emily”和“Bronte”是两个参数，因为命令行上的参数由空格分隔。程序抱怨收到了一个未定义的第二个参数：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Only when we give the program exactly one argument will it run:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当我们向程序提供一个参数时，它才会运行：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While it may seem like overkill to use `argparse` for such a simple program,
    it shows that `argparse` can do quite a bit of error checking and validation of
    arguments for us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`argparse`来处理这样一个简单的程序可能显得有些过度，但它表明`argparse`可以为我们做大量的错误检查和参数验证。
- en: A.4.2 Two different positional arguments
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.2 两个不同的位置参数
- en: 'Imagine you want two *different* positional arguments, like the *color* and
    *size* of an item to order. The color should be a `str`, and the size should be
    an `int` value. When you define them positionally, the order in which you declare
    them is the order in which the user must supply the arguments. Here we define
    `color` first, and then `size`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要两个不同的位置参数，比如要订购的物品的*颜色*和*大小*。颜色应该是一个`str`类型，大小应该是一个`int`类型的值。当你按位置定义它们时，你声明它们的顺序就是用户必须提供参数的顺序。在这里，我们首先定义`color`，然后是`size`：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① This will be the first of the positional arguments because it is defined first.
    Notice that metavar has been set to 'color' instead of 'str' as it’s more descriptive
    of the kind of string we expect--one that describes the “color” of the garment.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这将是第一个位置参数，因为它首先被定义。注意，metavar已被设置为'color'而不是'str'，因为它更能描述我们期望的字符串类型——一个描述服装“颜色”的字符串。
- en: ② This will be the second of the positional arguments. Here metavar='size',
    which could be a number like 4 or a string like 'small', so it’s still ambiguous.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这将是第二个位置参数。这里metavar='size'，它可以是像4这样的数字，也可以是像'small'这样的字符串，所以它仍然是不确定的。
- en: ③ The “color” argument is accessed via the name of the color parameter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 通过颜色参数的名称访问“color”参数。
- en: ④ The “size” argument is accessed via the name of the size parameter.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 通过大小参数的名称访问“size”参数。
- en: 'Again, the user must provide exactly two positional arguments. Entering no
    arguments triggers a short usage statement:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，用户必须提供恰好两个位置参数。不输入任何参数将触发一条简短的用法说明：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just entering one argument won’t cut it either. We are told that “size” is
    missing:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 只输入一个参数也不行。我们被告知“size”缺失：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we give it two strings, like “blue” for the color and “small” for the size,
    the size value will be rejected because it needs to be an integer value:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供两个字符串，比如“blue”用于颜色和“small”用于大小，大小值将被拒绝，因为它需要是一个整数值：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| If we give it two arguments, the second of which can be interpreted as an
    `int`, all is well:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '| 如果我们给出两个参数，第二个参数可以解释为 `int`，那么一切正常：'
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Remember that *all* the arguments coming from the command line are strings.
    The command line doesn’t require quotes around `blue` or the `4` to make them
    strings the way that Python does. On the command line, everything is a string,
    and all arguments are passed to Python as strings. | ![](../Images/A-unnumb-2.png)  |
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，来自命令行的所有参数都是字符串。命令行不需要像 Python 那样在 `blue` 或 `4` 周围加上引号来将它们转换为字符串。在命令行中，一切都是字符串，所有参数都以字符串的形式传递给
    Python。 | ![图片](../Images/A-unnumb-2.png)  |
- en: 'When we tell `argparse` that the second argument needs to be an `int`, `argparse`
    will attempt to convert the string `''4''` to the integer `4`. If you provide
    `4.1`, that will be rejected too:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们告诉 `argparse` 第二个参数需要是一个 `int` 时，`argparse` 将尝试将字符串 `'4'` 转换为整数 `4`。如果你提供
    `4.1`，它也会被拒绝：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| ![](../Images/A-unnumb-3.png)  | Positional arguments require the user to
    remember the correct order of the arguments. If we mistakenly switch around `str`
    and `int` arguments, `argparse` will detect invalid values:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '| ![图片](../Images/A-unnumb-3.png)  | 位置参数要求用户记住参数的正确顺序。如果我们错误地将 `str` 和 `int`
    参数调换顺序，`argparse` 将检测到无效值：'
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Imagine, however, a case of two strings or two numbers that represent two *different*
    values, like a car’s make and model or a person’s height and weight. How could
    you detect that the arguments are reversed?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，想象一下，有两个字符串或两个数字代表两个 *不同* 的值的情况，比如汽车的制造商和型号，或者一个人的身高和体重。你如何检测参数是否被反转？
- en: Generally speaking, I only ever create programs that take exactly one positional
    argument or one or more *of the same thing*, like a list of files to process.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，我只创建接受恰好一个位置参数或一个或多个相同参数的程序，比如要处理的文件列表。
- en: A.4.3 Restricting values using the choices option
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.3 使用选择选项限制值
- en: 'In our previous example, there was nothing stopping the user from providing
    *two integer values*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，没有任何阻止用户提供 *两个整数值* 的东西：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `1` is a string. It may look like a number to you, but it is actually the
    *character* `'1'`. That is a valid string value, so our program accepts it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`1` 是一个字符串。它可能看起来像数字，但实际上它是 *字符* `''1''`。这是一个有效的字符串值，所以我们的程序接受它。'
- en: 'Our program would also accept a “size” of `-4`, which clearly is not a valid
    size:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序也会接受“size”为 `-4`，这显然不是一个有效的尺寸：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How can we ensure that the user provides both a valid `color` and `size`? Let’s
    say we only offer shirts in primary colors. We can pass in a `list` of valid values
    using the `choices` option.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保用户提供了有效的 `color` 和 `size`？假设我们只提供原色衬衫。我们可以使用 `choices` 选项传递一个有效值的列表。
- en: 'In the following example, we restrict the `color` to “red,” “yellow,” or “blue.”
    Additionally, we can use `range(1,` `11)` to generate a list of numbers from 1
    to 10 (11 isn’t included!) as the valid sizes for our shirts:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将 `color` 限制为“red”、“yellow”或“blue”。此外，我们可以使用 `range(1,` `11)` 生成一个从
    1 到 10 的数字列表（不包括 11！）作为衬衫的有效尺寸：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① The choices option takes a list of values. argparse stops the program if the
    user fails to supply one of these.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ① 选择选项接受一个值列表。如果用户未能提供这些值之一，argparse 将停止程序。
- en: ② The user must choose from the numbers 1-10 or argparse will stop with an error.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ② 用户必须从 1-10 的数字中选择，否则 argparse 将因错误而停止。
- en: ③ If our program makes it to this point, we know that args.color will definitely
    be one of those values and that args.size is an integer value in the range of
    1-10\. The program will never get to this point unless both arguments are valid.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果我们的程序到达这个点，我们知道 `args.color` 一定是这些值之一，而 `args.size` 是一个介于 1-10 之间的整数值。除非两个参数都有效，否则程序永远不会到达这个点。
- en: 'Any value not present in the list will be rejected, and the user will be shown
    the valid choices. Again, no value is rejected:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中没有的任何值都将被拒绝，并且用户将看到有效的选择。再次强调，没有值被拒绝：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we provide “purple,” it will be rejected because it is not in the `choices`
    we defined. The error message that `argparse` produces tells the user the problem
    (“invalid choice”) and even lists the acceptable colors:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供“purple”，它将被拒绝，因为它不在我们定义的 `choices` 中。`argparse` 生成的错误信息会告诉用户问题（“无效选择”），并列出可接受的颜色：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](../Images/A-unnumb-4.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/A-unnumb-4.png)'
- en: 'Likewise with a negative `size` argument:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于负的 `size` 参数：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Only when both arguments are valid may we continue:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当两个参数都有效时，我们才能继续：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That’s really quite a bit of error checking and feedback that you never have
    to write. The best code is code you don’t write!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是非常多的错误检查和反馈，你永远不需要编写。最好的代码是你不需要编写的代码！
- en: A.4.4 Two of the same positional arguments
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.4 同一位置参数的两个
- en: 'If we were writing a program that adds two numbers, we could define them as
    two positional arguments, like `number1` and `number2`. But since they are the
    same kinds of arguments (two numbers that we will add), it might make more sense
    to use the `nargs` option to tell `argparse` that you want exactly two of a thing:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写一个加法两个数字的程序，我们可以将它们定义为两个位置参数，如`number1`和`number2`。但由于它们是相同类型的参数（我们将要相加的两个数字），使用`nargs`选项告诉`argparse`你想要恰好两个这样的参数可能更有意义：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ① The nargs=2 will require exactly two values.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ① `nargs=2`将要求恰好两个值。
- en: ② Each value must be parsable as an integer value, or the program will error
    out.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ② 每个值都必须可以被解析为整数值，否则程序将出错。
- en: ③ Since we defined that there are exactly two values for numbers, we can copy
    them into two variables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 由于我们定义了数字恰好有两个值，我们可以将它们复制到两个变量中。
- en: ④ Because these are actual int values, the result of + will be numeric addition
    and not string concatenation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 因为这些是实际的整数值，所以加号（+）的结果将是数值相加而不是字符串连接。
- en: 'The help indicates we want two numbers:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助信息表明我们想要两个数字：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When we provide two good integer values, we get their sum:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提供两个良好的整数值时，我们得到它们的和：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| Notice that `argparse` converts the `n1` and `n2` values to actual integer
    values. If you change the `type=int` to `type=str`, you’ll see that the program
    will print `35` instead of `8` because the `+` operator in Python both adds numbers
    and concatenates strings!'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '| 注意，`argparse`将`n1`和`n2`的值转换为实际的整数值。如果你将`type=int`改为`type=str`，你会发现程序将打印`35`而不是`8`，因为Python中的`+`运算符既用于加法也用于字符串连接！'
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| ![](../Images/A-unnumb-5.png)  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/A-unnumb-5.png)  |'
- en: A.4.5 One or more of the same positional arguments
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.5 同一位置参数的一个或多个
- en: 'You could expand your two-number adding program into one that sums as many
    numbers as you provide. When you want *one or more* of some argument, you can
    use `nargs=''+''`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将你的两个数字加法程序扩展成一个可以累加你提供的任意多个数字的程序。当你想要某个参数的“一个或多个”值时，你可以使用`nargs='+'`：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ① The + will make nargs accept one or more values.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ① 加号（+）将使nargs接受一个或多个值。
- en: ② The int means that all the values must be integer values.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ② `int`表示所有值都必须是整数值。
- en: ③ numbers will be a list with at least one element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 数字将是一个至少包含一个元素的列表。
- en: ④ Don’t worry if you don’t understand this line. You will by the end of the
    book.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果你不理解这一行，不要担心。你会在书的结尾理解它。
- en: 'Note that this will mean `args.numbers` is always a `list`. Even if the user
    provides just one argument, `args.numbers` will be a `list` containing that one
    value:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这意味着`args.numbers`始终是一个`list`。即使用户只提供一个参数，`args.numbers`也将是一个包含该单个值的`list`：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can also use `nargs='*'` to indicate *zero* or more of an argument, and
    `nargs='?'` means *zero or one* of the argument.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`nargs='*'`来表示参数可以有零个或多个，而`nargs='?'`表示参数可以有零个或一个。
- en: A.4.6 File arguments
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.6 文件参数
- en: So far you’ve seen how you can specify that an argument should be of a `type`
    like `str` (which is the default), `int`, or `float`. There are also many exercises
    that require a file as input, and for that you can use the `type` of `argparse.FileType('r')`
    to indicate that the argument must be a *file* that is *readable* (the `'r'` part).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何指定一个参数应该是`str`（默认类型）、`int`或`float`等类型。还有很多需要文件作为输入的练习，对于这些，你可以使用`argparse.FileType('r')`的`type`来表示参数必须是一个*可读*的*文件*（`'r'`部分）。
- en: If, additionally, you want to require that the file be *text* (as opposed to
    a *binary* file), you would add a `'t'`. These options will make more sense after
    you’ve read chapter 5.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还想要求文件必须是*文本*（而不是二进制文件），你可以添加一个`'t'`。这些选项在你阅读第5章后会有更多的意义。
- en: 'Here is an implementation in Python of the command `cat` `-n`, where `cat`
    will *concatenate* a readable text file, and the `-n` says to *number* the lines
    of output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个Python中实现`cat -n`命令的示例，其中`cat`将*连接*一个可读的文本文件，而`-n`表示要*编号*输出行：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ① The argument will be rejected if it does not name a valid, readable text file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果参数没有命名一个有效、可读的文本文件，它将被拒绝。
- en: ② The value of args.file is an open file handle that we can directly read. Again,
    don’t worry if you don’t understand this code. We’ll talk all about file handles
    in the chapters.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ② `args.file`的值是一个打开的文件句柄，我们可以直接读取。再次提醒，如果你不理解这段代码，不要担心。我们将在章节中详细讨论文件句柄。
- en: 'When we define an argument as `type=int`, we get back an actual `int` value.
    Here, we define the `file` argument as a `FileType`, so we receive an *open file
    handle*. If we had defined the `file` argument as a string, we would have to manually
    check if it were a file and then use `open()` to get a file handle:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个参数定义为`type=int`时，我们会得到一个实际的`int`值。在这里，我们将`file`参数定义为`FileType`，因此我们收到一个*打开的文件句柄*。如果我们把`file`参数定义为字符串，我们就必须手动检查它是否是一个文件，然后使用`open()`来获取文件句柄：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ① Intercept the arguments.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ① 截获参数。
- en: ② Check if the file argument is not a file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ② 检查文件参数是否不是一个文件。
- en: ③ Print an error message and exit the program with a non-zero value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 打印错误信息并以非零值退出程序。
- en: ④ Replace the file with an open file handle.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将文件替换为打开的文件句柄。
- en: With the `FileType` definition, you don’t have to write any of this code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FileType`定义，你不需要编写任何这样的代码。
- en: You can also use `argparse.FileType('w')` to indicate that you want the name
    of a file that can be opened for *writing* (the `'w'`). You can pass additional
    arguments specifying how to open the file, like the encoding. See the documentation
    for more information.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`argparse.FileType('w')`来表示你想要一个可以打开用于*写入*的文件名（`'w'`）。你可以传递额外的参数来指定如何打开文件，例如编码。有关更多信息，请参阅文档。
- en: A.4.7 Manually checking arguments
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.7 手动检查参数
- en: It’s also possible to manually validate arguments before we `return` from `get_args()`.
    For instance, we can define that `--int` should be an `int`, but how can we require
    that it must be between 1 and 10?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从`get_args()`返回之前，也可以手动验证参数。例如，我们可以定义`--int`应该是一个`int`，但如何要求它必须在1到10之间呢？
- en: 'One fairly simple way to do this is to manually check the value. If there is
    a problem, you can use the `parser.error()` function to halt execution of the
    program, print an error message along with the short usage statement, and then
    exit with an error value:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一种相当简单的方法是手动检查值。如果有问题，你可以使用`parser.error()`函数来停止程序的执行，打印错误信息以及简短的用法说明，然后以错误值退出：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ① Parse the arguments.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ① 解析参数。
- en: ② Check if the args.int value is not between 1 and 10.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ② 检查`args.int`的值是否不在1到10之间。
- en: ③ Call parser.error() with an error message. The error message and the brief
    usage statement will be shown to the user, and the program will immediately exit
    with a non-zero value to indicate an error.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用错误信息调用`parser.error()`。错误信息和简短的用法说明将显示给用户，程序将立即以非零值退出以指示错误。
- en: ④ If we get here, everything was OK, and the program will continue as normal.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果我们到达这里，一切正常，程序将继续按正常方式运行。
- en: 'If we provide a good `--val`, all is well:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供一个好的`--val`，一切都会顺利：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we run this program with a value like `20`, we get an error message:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用类似`20`这样的值运行这个程序，我们会得到一个错误信息：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It’s not possible to tell here, but the `parser.error()` also caused the program
    to exit with a non-zero status. In the command-line world, an exit status of `0`
    indicates “zero errors,” so anything not `0` is considered an error. You may not
    realize yet just how wonderful that is, but trust me. It is.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里无法判断，但`parser.error()`也会导致程序以非零状态退出。在命令行世界中，退出状态为`0`表示“没有错误”，所以任何不是`0`的都视为错误。你可能还没有意识到这有多么美妙，但请相信我，确实如此。
- en: A.4.8 Automatic help
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.8 自动帮助
- en: When you define a program’s parameters using `argparse`, the `-h` and `--help`
    flags will be reserved for generating help documentation. You do not need to add
    these, nor are you allowed to use these flags for other purposes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`argparse`定义程序参数时，`-h`和`--help`标志将被保留用于生成帮助文档。你不需要添加这些，也不允许将这些标志用于其他目的。
- en: '| I think of this documentation as being like a door into your program. Doors
    are how we get into buildings and cars and such. Have you ever come across a door
    that you can’t figure out how to open? Or one that requires a “PUSH” sign when
    clearly the handle is designed to “pull”? The book *The Design of Everyday Things*
    by Don Norman (Basic Books, 2013) uses the term *affordances* to describe the
    interfaces that objects present to us that do or do not inherently describe how
    we should use them. | ![](../Images/A-unnumb-6.png)  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 我认为这份文档就像是你程序的入口。门是我们进入建筑物和汽车等地方的方式。你有没有遇到过不知道如何打开的门？或者一个明明把手是设计用来“拉”的，却需要“推”的标志？唐·诺曼（Don
    Norman）在《日常事物的设计》（The Design of Everyday Things，Basic Books，2013）一书中使用“affordances”这个术语来描述对象向我们展示的界面，这些界面或描述了我们应该如何使用它们，或不描述。|
    ![](../Images/A-unnumb-6.png)  |'
- en: The usage statement of your program is like the handle of the door. It should
    let users know exactly how to use it. When I encounter a program I’ve never used,
    I either run it with no arguments or with `-h` or `--help`. I *expect* to see
    some sort of usage statement. The only alternative would be to open the source
    code itself and study how to make the program run and how I can alter it, and
    this is a truly unacceptable way to write and distribute software!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您程序的用法说明就像门把手一样。它应该让用户确切地知道如何使用它。当我遇到一个我从未使用过的程序时，我会要么不带参数运行它，要么使用`-h`或`--help`。我*期望*看到某种用法说明。唯一的替代方案是打开源代码本身并研究如何运行程序以及如何修改它，而这绝对是一种不可接受的软件编写和分发方式！
- en: 'When you start creating a new program with `new.py` `foo.py`, this is the help
    that will be generated:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`new.py`或`foo.py`开始创建一个新的程序时，这将生成的帮助信息是：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Without writing a single line of code, you have
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要写一行代码，您就有
- en: An executable Python program
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可执行的Python程序
- en: A variety of command-line arguments
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种命令行参数
- en: A standard and useful help message
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标准且有用的帮助信息
- en: This is the “handle” to your program, and you don’t have to write a single line
    of code to get it!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您程序的“把手”，您不需要写一行代码就能得到它！
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Positional parameters typically are required parameters. If you have two or
    more positional parameters representing different ideas, it would be better to
    make them named options.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数通常是必需参数。如果您有两个或更多代表不同概念的参数，最好将它们设置为命名选项。
- en: Optional parameters can be named, like `--file` `fox.txt` where `fox.txt` is
    the value for the `--file` option. It is recommended that you always define a
    default value for options.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数可以命名，例如`--file` `fox.txt`，其中`fox.txt`是`--file`选项的值。建议您始终为选项定义一个默认值。
- en: '`argparse` can enforce many argument types, including numbers like `int` and
    `float`, or even files.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argparse`可以强制执行许多参数类型，包括像`int`和`float`这样的数字，甚至是文件。'
- en: Flags like `--help` do not have an associated value. They are (usually) considered
    `True` if present and `False` if not.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像这样的`--help`标志没有关联的值。如果存在，它们通常被认为是`True`；如果不存在，则是`False`。
- en: The `-h` and `--help` flags are reserved for use by `argparse`. If you use `argparse`,
    your program will automatically respond to these flags with a usage statement.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h`和`--help`标志是为`argparse`保留的。如果您使用`argparse`，您的程序将自动对这些标志做出响应，显示用法说明。'
- en: '* * *'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1 I always think of the kid who will type “fart” for every input.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 1 我总是想象那个会为每个输入都输入“放屁”的孩子。
