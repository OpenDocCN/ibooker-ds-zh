- en: Appendix A. JavaScript syntax introduced in ES6
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录A. ES6中引入的JavaScript语法
- en: In this appendix, I cover JavaScript syntax introduced in ES6 as it applies
    to Node.js. I start with variable definitions and the new style of `String` interpolation.
    Then I talk about arrow functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我介绍了ES6中引入的JavaScript语法，这些语法适用于Node.js。我从变量定义和新的`String`插值风格开始。然后我讨论了箭头函数。
- en: A.1\. New in ES6
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1\. ES6中的新特性
- en: Since 2015, ECMAScript 6 has offered new syntax and conventions for developing
    with JavaScript. For that reason, this book covers some of the ES6 keywords and
    formats you’ll use. *Keywords* are terms that have a reserved meaning in JavaScript
    and are used to provide the syntax and interpretability of your code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自2015年以来，ECMAScript 6为使用JavaScript进行开发提供了新的语法和约定。因此，本书涵盖了您将使用的一些ES6关键字和格式。*关键字*是具有JavaScript中保留意义的术语，用于提供代码的语法和可解释性。
- en: A.1.1\. The let keyword
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.1\. `let`关键字
- en: You’re probably used to declaring variables with the `var` keyword. With ES6,
    it’s more appropriate to use the `let` keyword to define variables as they apply
    to a specific scoped block. Until a variable is defined within a particular block
    of code, you can’t access it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经习惯了使用`var`关键字声明变量。在ES6中，使用`let`关键字定义变量更为合适，因为它们适用于特定的作用域块。直到在特定代码块中定义了变量，您才能访问它。
- en: A `let` variable defined in an `if` block can’t be accessed outside the block,
    for example, whereas a `var` variable is scoped to the function within which it’s
    defined, as shown in the next listing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块中定义的`let`变量不能在块外访问，例如，而`var`变量的作用域限于定义它的函数内，如下面的列表所示。
- en: Listing A.1\. Example use of the `let` keyword
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.1\. `let`关键字的示例用法
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because `let` variables are scoped to code blocks beyond functions, they could
    be global variables to a module or an entire application. As a result, `let` gives
    variable definition more security and is preferred to `var`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`let`变量的作用域限于函数之外的代码块，它们可以是模块或整个应用程序的全局变量。因此，`let`提供了更多的变量定义安全性，并且比`var`更受欢迎。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When using `"use strict";` you can’t redefine the same `let` variable, whereas
    you can with var.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`"use strict";`时，您不能重新定义相同的`let`变量，而可以使用`var`。
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A.1.2\. The const variable
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.2\. 常量变量
- en: A `const` variable can’t be reassigned. Typically, you should use this keyword
    in place of `let` for variables whose values you don’t expect to manipulate in
    your code. This guideline can also apply to loading libraries or modules in Node.js,
    as you see in [unit 1](../Text/kindle_split_014.html#part01). If you try to reassign
    a `const` variable, you get a `Duplicate Declaration Error`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`变量不能重新赋值。通常，您应该使用此关键字代替`let`，对于您不期望在代码中操作的变量。此指南也适用于在Node.js中加载库或模块，如[单元1](../Text/kindle_split_014.html#part01)中所示。如果您尝试重新赋值`const`变量，则会得到“重复声明错误”。'
- en: The code in the next listing crashes because a new `let` variable is being declared
    with the name of an existing constant.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的代码会崩溃，因为正在使用现有常量的名称声明一个新的`let`变量。
- en: Listing A.2\. Example use of the `const` variable
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.2\. `const`变量的示例用法
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A.1.3\. String interpolation
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.3\. 字符串插值
- en: Until ES6, to print or log a variable’s value within a string, you had to append
    the string around the variable, as shown in the following listing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前，要在字符串中打印或记录变量的值，您必须将字符串附加到变量周围，如下面的列表所示。
- en: Listing A.3\. Example of string concatenation
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.3\. 字符串连接示例
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With ES6, you can use backticks (`` ` ``) and `${}` to interpolate variables
    into a string, as shown in the next listing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，您可以使用反引号（`` ` ``）和`${}`将变量插值到字符串中，如下面的列表所示。
- en: Listing A.4\. Interpolating strings with backticks
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.4\. 使用反引号插值字符串
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The resulting code is cleaner, easier to read, and easier to edit.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的代码更简洁、更易于阅读和编辑。
- en: A.1.4\. Arrow functions
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.1.4\. 箭头函数
- en: Arrow functions are one way that ES6 is making code more succinct and easier
    to read. With the => arrow symbol and a change in the conventional function syntax,
    you can turn a multiline function into one line. Take the example in the following
    listing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是ES6使代码更简洁、更易于阅读的一种方式。使用 => 箭头符号和函数语法的改变，您可以将多行函数转换为单行。以下列表中的示例展示了这一点。
- en: Listing A.5\. Defining a function with the `function` keyword
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.5\. 使用`function`关键字定义函数
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can rewrite this code as shown in the next listing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此代码重写为以下列表所示。
- en: Listing A.6\. Defining an arrow function
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.6\. 定义箭头函数
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: More important, arrow functions in ES6 preserve the `this` variable from its
    outer scope, as shown in the following listing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，ES6 中的箭头函数保留了其外部作用域的 `this` 变量，如下一个列表所示。
- en: Listing A.7\. Example use of the `this` keyword within functions
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.7\. 函数内 `this` 关键字的示例用法
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, `dog.printNameAfterTime()` prints `My name is undefined` because
    `this .name` is out of the `setTimeout` function scope despite the assumption
    that `this` refers to the `dog` object. With arrow functions, however, `this`
    persists within the `setTimeout` function, as shown in the next listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`dog.printNameAfterTime()` 打印 `My name is undefined`，因为 `this .name`
    超出了 `setTimeout` 函数的作用域，尽管假设 `this` 指的是 `dog` 对象。然而，使用箭头函数时，`this` 在 `setTimeout`
    函数中保持不变，如下一个列表所示。
- en: Listing A.8\. Example use of the `this` keyword with arrow functions
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.8\. 使用箭头函数的 `this` 关键字的示例
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now you can print `My name is Sparky`, and the code is more compact!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以打印 `My name is Sparky`，代码更加紧凑！
- en: To succeed with Node.js, you need to succeed with JavaScript in general. Because
    Node.js requires sufficient knowledge of some core JavaScript and programming
    concepts, this lesson reviews what you need to know to get started. If you haven’t
    had much experience with JavaScript, I recommend reading *Secrets of the JavaScript
    Ninja, Second Edition* by John Resig and Bear Bibeault (Manning, 2016).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Node.js 中取得成功，你需要在 JavaScript 方面取得成功。因为 Node.js 需要足够的对一些核心 JavaScript 和编程概念的了解，所以本课回顾了你需要知道的内容才能开始。如果你在
    JavaScript 方面没有太多经验，我建议阅读 John Resig 和 Bear Bibeault 所著的 *《JavaScript忍者秘籍，第二版》*（Manning,
    2016）。
- en: A.2\. REPL
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2\. REPL
- en: When you have Node.js installed, your first stop in running your code is in
    the Read-Evaluate-Print Loop (REPL). This interactive environment is similar to
    the console window in a Chrome web browser. In REPL, you’re able to run any JavaScript
    code. You can al so require Node.js modules to test aspects of your application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装了 Node.js 后，运行你的代码的第一个地方是 Read-Evaluate-Print Loop (REPL)。这个交互式环境类似于 Chrome
    网络浏览器中的控制台窗口。在 REPL 中，你可以运行任何 JavaScript 代码。你还可以引入 Node.js 模块来测试应用程序的各个方面。
- en: A.2.1\. Running JavaScript in REPL
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.1\. 在 REPL 中运行 JavaScript
- en: To start REPL, navigate to any terminal window on your computer and enter `node`.
    This command immediately returns a prompt (`>`), after which you may enter any
    JavaScript statements. You can think of REPL as a running Node.js application
    that responds to your commands instantaneously. That is, you don’t need to write
    your JavaScript code in a separate file and then run it; you can type that JavaScript
    code directly in the REPL window. Try defining a couple of variables, as shown
    in the next listing. You’ll notice that with each JavaScript statement you run,
    REPL outputs the return value of that statement. For variable assignment, the
    return value is `undefined`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 REPL，请导航到你的电脑上的任何终端窗口，并输入 `node`。此命令立即返回一个提示符（`>`），之后你可以输入任何 JavaScript
    语句。你可以把 REPL 看作是一个运行中的 Node.js 应用程序，它会即时响应你的命令。也就是说，你不需要在单独的文件中编写你的 JavaScript
    代码然后运行它；你可以在 REPL 窗口中直接输入那段 JavaScript 代码。尝试定义几个变量，如下一个列表所示。你会注意到，每运行一个 JavaScript
    语句，REPL 就会输出该语句的返回值。对于变量赋值，返回值是 `undefined`。
- en: Listing A.9\. Defining variables in REPL
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.9\. 在 REPL 中定义变量
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now perform some operation on these variables. You can concatenate the two values,
    for example, as shown in the following listing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对这些变量执行一些操作。例如，你可以将两个值连接起来，如下面的列表所示。
- en: Listing A.10\. Concatenating variables in REPL
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.10\. 在 REPL 中连接变量
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There’s no limit to the ways you can use the REPL environment to behave like
    any Node.js application you’ve used or seen before. You can also use the tab key
    to autocomplete variable or function names and list object properties. If you
    defined a string by the variable name `sentence`, for example, but you’re unsure
    what functions you can call on that string, you can add a dot (`.`) to the end
    of the variable name and press Tab to list that variable’s available functions
    and properties, as shown in the next listing.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 REPL 环境的任何方式来模拟你使用或见过的任何 Node.js 应用程序。你还可以使用制表键来自动完成变量或函数名，并列出对象属性。例如，如果你通过变量名
    `sentence` 定义了一个字符串，但你不确定可以调用该字符串的哪些函数，你可以在变量名末尾添加一个点（`.`）并按 Tab 键来列出该变量的可用函数和属性，如下一个列表所示。
- en: Listing A.11\. Listing variable properties in REPL
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 A.11\. 在 REPL 中列出变量属性
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can find additional REPL commands in [lesson 1](../Text/kindle_split_012.html#ch01).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第 1 课](../Text/kindle_split_012.html#ch01)中找到额外的 REPL 命令。
- en: A.2.2\. Using REPL in application development
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: A.2.2\. 在应用程序开发中使用REPL
- en: One other useful way to use REPL is through the `repl` module within your Node.js
    application code. As you build more custom modules in your project, you’ll notice
    that it’s tedious to load all those files into REPL to test the functionality
    of the code you’ve written. If you wrote a module called multiply.js (listing
    A.12) that contains a function to multiply two numbers, you’d need to require
    that module into REPL by entering `require("./multiply")` along with every other
    module you created. What’s more, you’d need to enter these lines for every new
    REPL session.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REPL的另一种有用方式是通过Node.js应用程序代码中的`repl`模块。随着您在项目中构建更多的自定义模块，您会注意到将所有这些文件加载到REPL中以测试您所编写代码的功能是繁琐的。如果您编写了一个名为multiply.js（列表A.12）的模块，该模块包含一个用于乘以两个数字的函数，您需要通过输入`require("./multiply")`将此模块导入REPL，以及您创建的每个其他模块。更重要的是，您需要为每个新的REPL会话输入这些行。
- en: Listing A.12\. Creating a single-function module in multiply.js
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.12\. 在multiply.js中创建单函数模块
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Instead of requiring your modules into each REPL session, you could bring REPL
    into your modules. Listing A.13 shows how you could use the `repl` module within
    your project. You can create a module within your project directory called customRepl.js
    that requires all the modules you want to test at the same time. This file shows
    the `repl` module being required and then a REPL server starting. Like a Node.js
    HTTP server, this REPL server has a context within which you can load custom variables.
    After the REPL server is started, add a `name` variable and your `multiply` module.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必在每个REPL会话中导入模块，您可以将REPL带入您的模块中。列表A.13展示了您如何在项目中使用`repl`模块。您可以在项目目录中创建一个名为customRepl.js的模块，同时导入您想要测试的所有模块。此文件显示了`repl`模块被导入，然后启动了一个REPL服务器。就像Node.js
    HTTP服务器一样，这个REPL服务器有一个上下文，您可以在其中加载自定义变量。REPL服务器启动后，添加一个`name`变量和您的`multiply`模块。
- en: Listing A.13\. Using the `repl` module in customRepl.js
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表A.13\. 在customRepl.js中使用`repl`模块
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All you need to do now is navigate to your project directory in terminal and
    enter `node customRepl`. You’ll see the REPL prompt, only this time, the context
    of your REPL session contains all the modules you want to test. This technique
    comes in handy when you want to test creating or modifying records in your database
    without having to copy and paste the code to require your database configurations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您只需在终端导航到您的项目目录，并输入`node customRepl`。您将看到REPL提示，但这次，您的REPL会话的上下文包含您想要测试的所有模块。当您想要测试在数据库中创建或修改记录，而不必复制和粘贴代码来导入数据库配置时，这种技术非常有用。
- en: Summary
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This appendix provided an overview of the JavaScript keywords and syntax you
    should be aware of in this book. With ES6 now widely used in the development community,
    it’s important to start writing code that reflects the latest and greatest JavaScript
    changes. The more familiar you get with using REPL and JavaScript commands, the
    easier it will be to develop your applications quickly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录概述了您在本书中应了解的JavaScript关键字和语法。随着ES6现在在开发社区中得到广泛应用，开始编写反映最新和最伟大JavaScript变化的代码变得非常重要。您对使用REPL和JavaScript命令越熟悉，开发应用程序就会越容易。
