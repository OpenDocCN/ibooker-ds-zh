- en: Chapter 7\. The rise of graph databases
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. 图数据库的兴起
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Introducing connected data and how it’s related to graphs and graph databases
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍连接数据及其与图和图数据库的关系
- en: Learning how graph databases differ from relational databases
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习图数据库与关系数据库的不同之处
- en: Discovering the graph database Neo4j
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现图数据库Neo4j
- en: Applying the data science process to a recommender engine project with the graph
    database Neo4j
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据科学流程应用于使用图数据库Neo4j的推荐引擎项目
- en: Where on one hand we’re producing data at mass scale, prompting the likes of
    Google, Amazon, and Facebook to come up with intelligent ways to deal with this,
    on the other hand we’re faced with data that’s becoming more interconnected than
    ever. Graphs and networks are pervasive in our lives. By presenting several motivating
    examples, we hope to teach the reader how to recognize a graph problem when it
    reveals itself. In this chapter we’ll look at how to leverage those connections
    for all they’re worth using a graph database, and demonstrate how to use Neo4j,
    a popular graph database.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们在大规模地产生数据，促使谷歌、亚马逊和Facebook等公司想出智能的方法来处理这个问题，另一方面，我们面临着比以往任何时候都更加互联的数据。图和网络在我们的生活中无处不在。通过展示几个激励性的例子，我们希望教会读者如何在数据揭示自身时识别图问题。在本章中，我们将探讨如何利用图数据库中的这些连接，充分利用其价值，并演示如何使用流行的图数据库Neo4j。
- en: 7.1\. Introducing connected data and graph databases
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 介绍连接数据和图数据库
- en: Let’s start by familiarizing ourselves with the concept of connected data and
    its representation as graph data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先熟悉一下连接数据及其作为图数据表示的概念。
- en: '***Connected data*** —As the name indicates, connected data is characterized
    by the fact that the data at hand has a relationship that makes it connected.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***连接数据*** —正如其名所示，连接数据的特点是手头的数据具有使其连接的关系。'
- en: '***Graphs*** —Often referred to in the same sentence as connected data. Graphs
    are well suited to represent the connectivity of data in a meaningful way.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***图*** —经常与连接数据一起在同一个句子中提到。图非常适合以有意义的方式表示数据的连接性。'
- en: '***Graph databases*** —Introduced in [chapter 6](kindle_split_014.xhtml#ch06).
    The reason this subject is meriting particular attention is because, besides the
    fact that data is increasing in size, it’s also becoming more interconnected.
    Not much effort is needed to come up with well-known examples of connected data.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***图数据库*** —在第6章中介绍。这个主题值得特别注意的原因是，除了数据量不断增加之外，它还变得更加互联。不需要太多努力就能找到连接数据的知名例子。'
- en: 'A prominent example of data that takes a network form is social media data.
    Social media allows us to share and exchange data in networks, thereby generating
    a great amount of connected data. We can illustrate this with a simple example.
    Let’s assume we have two people in our data, User1 and User2\. Furthermore, we
    know the first name and the last name of User1 (first name: Paul and last name:
    Beun) and User2 (first name: Jelme and last name: Ragnar). A natural way of representing
    this could be by drawing it out on a whiteboard, as shown in [figure 7.1](#ch07fig01).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以网络形式存在的一个突出例子是社交媒体数据。社交媒体使我们能够在网络中分享和交换数据，从而生成大量连接数据。我们可以用一个简单的例子来说明这一点。假设我们的数据中有两个人，User1和User2。此外，我们还知道User1（名字：Paul，姓氏：Beun）和User2（名字：Jelme和姓氏：Ragnar）的名字和姓氏。表示这种关系的一种自然方式是在白板上绘制出来，如图[图7.1](#ch07fig01)所示。
- en: 'Figure 7.1\. A simple connected data example: two entities or nodes (User1,
    User2), each with properties (first name, last name), connected by a relationship
    (knows)'
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 一个简单的连接数据示例：两个实体或节点（User1，User2），每个实体或节点都有属性（名字，姓氏），通过一个关系（认识）连接
- en: '![](Images/07fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig01.jpg)'
- en: 'The terminology of [figure 7.1](#ch07fig01) is described below:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面描述了[图7.1](#ch07fig01)的术语：
- en: '***Entities*** —We have two entities that represent people (User1 and User2).
    These entities have the properties “name” and “lastname”.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***实体*** —我们有两个实体代表人物（User1和User2）。这些实体具有“name”和“lastname”属性。'
- en: '***Properties*** —The properties are defined by key-value pairs. From this
    graph we can also infer that User1 with the “*name*” property Paul knows User2
    with the “*name*” property Jelme.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***属性*** —属性由键值对定义。从这个图中，我们还可以推断出具有“*name*”属性Paul的User1认识具有“*name*”属性Jelme的User2。'
- en: '***Relationships*** —This is the relationship between Paul and Jelme. Note
    that the relationship has a direction: it’s Paul who “*knows*” Jelme and not the
    other way around. User1 and User2 both represent people and could therefore be
    grouped.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***关系*** —这是保罗和Jelme之间的关系。请注意，关系有一个方向：是保罗“*认识*”Jelme，而不是反过来。User1和User2都代表人物，因此可以被分组。'
- en: '***Labels*** —In a graph database, one can group nodes by using labels. User1
    and User2 could in this case both be labeled as “User”.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***标签*** —在图数据库中，可以通过标签对节点进行分组。在这种情况下，User1和User2都可以被标记为“User”。'
- en: 'Connected data often contains many more entities and connections. In [figure
    7.2](#ch07fig02) we can see a more extensive graph. Two more entities are included:
    Country1 with the name Cambodia and Country2 with the name Sweden. Two more relationships
    exist: “Has_been_in” and “Is_born_in”. In the previous graph, only the entities
    included a property, now the relationships also contain a property. Such graphs
    are known as property graphs. The relationship connecting the nodes User1 and
    Country1 is of the type “Has_been_in” and has as a property “Date” which represents
    a data value. Similarly, User2 is connected to Country2 but through a different
    type of relationship, which is of the type “Is_born_in”. Note that the types of
    relationships provide us a context of the relationships between nodes. Nodes can
    have multiple relationships.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 连接数据通常包含更多的实体和连接。在[图7.2](#ch07fig02)中，我们可以看到一个更广泛的图。包括了两个更多的实体：名为柬埔寨的Country1和名为瑞典的Country2。存在两个更多的关系：“Has_been_in”和“Is_born_in”。在前一个图中，只有包含属性的实体，现在关系也包含了属性。这种图被称为属性图。连接节点User1和Country1的关系类型为“Has_been_in”，并具有一个表示数据值的属性“Date”。同样，User2连接到Country2，但通过不同类型的关系，即“Is_born_in”类型的关系。请注意，关系的类型为我们提供了节点之间关系的环境。节点可以有多个关系。
- en: Figure 7.2\. A more complicated connected data example where two more entities
    have been included (Country1 and Country2) and two new relationships (“Has_been_in”
    and “Is_born_in”)
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 包含了两个更多实体（Country1和Country2）和两个新关系（“Has_been_in”和“Is_born_in”）的更复杂的连接数据示例
- en: '![](Images/07fig02_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig02_alt.jpg)'
- en: 'This kind of representation of our data gives us an intuitive way to store
    connected data. To explore our data we need to traverse through the graph following
    predefined paths to find the patterns we’re searching for. What if one would like
    to know where Paul has been? Translated into graph database terminology, we’d
    like to find the pattern “Paul has been in.” To answer this, we’d start at the
    node with the name “Paul” and traverse to Cambodia via the relationship “Has_been_in”.
    Hence a graph traversal, which corresponds to a database query, would be the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示我们数据的方式为我们存储连接数据提供了一种直观的方法。为了探索我们的数据，我们需要沿着预定义的路径遍历图以找到我们正在寻找的模式。如果有人想知道保罗去过哪里？用图数据库术语来说，我们想找到“保罗去过”的模式。为了回答这个问题，我们会从名为“保罗”的节点开始，通过“Has_been_in”关系遍历到柬埔寨。因此，一个图遍历，对应于数据库查询，会是以下这样的：
- en: '**1**.  *A starting node*—In this case the node with name property “Paul”'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  *起始节点*—在这种情况下，具有名称属性“Paul”的节点'
- en: '**2**.  *A traversal path*—In this case a path starting at node Paul and going
    to Cambodia'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  *遍历路径*—在这种情况下，从节点保罗开始到柬埔寨的路径'
- en: '**3**.  *End node*—Country node with name property “Cambodia”'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  *结束节点*—具有名称属性“柬埔寨”的国家节点'
- en: To better understand how graph databases deal with connected data, it’s appropriate
    to expand a bit more on graphs in general. Graphs are extensively studied in the
    domains of computer science and mathematics in a field called graph theory. Graph
    theory is the study of graphs, where graphs represent the mathematical structures
    used to model pairwise relations between objects, as shown in [figure 7.3](#ch07fig03).
    What makes them so appealing is that they have a structure that lends itself to
    visualizing connected data. A graph is defined by vertices (also known as nodes
    in the graph database world) and edges (also known as relationships). These concepts
    form the basic fundamentals on which graph data structures are based.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解图数据库如何处理连接数据，适当地对图的一般概念进行更多扩展是合适的。图在计算机科学和数学的图论领域中得到了广泛的研究。图论是研究图的一门学科，其中图代表用于模型化对象之间成对关系的数学结构，如图[图7.3](#ch07fig03)所示。它们之所以如此吸引人，是因为它们具有适合可视化连接数据的结构。图由顶点（在图数据库世界中也称为节点）和边（也称为关系）定义。这些概念构成了图数据结构的基本基础。
- en: Figure 7.3\. At its core a graph consists of nodes (also known as vertices)
    and edges (that connect the vertices), as known from the mathematical definition
    of a graph. These collections of objects represent the graph.
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3。从数学定义的图来看，图的核心由节点（也称为顶点）和边（连接顶点的边）组成。这些对象的集合代表了图。
- en: '![](Images/07fig03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3](Images/07fig03.jpg)'
- en: 'Compared to other data structures, a distinctive feature of connected data
    is its nonlinear nature: any entity can be connected to any other via a variety
    of relationship types and intermediate entities and paths. In graphs, you can
    make a subdivision between directed and undirected graphs. The edges of a directed
    graph have—how could it be otherwise—a direction. Although one could argue that
    every problem could somehow be represented as a graph problem, it’s important
    to understand when it’s ideal to do so and when it’s not.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数据结构相比，连接数据的独特特征是其非线性性质：任何实体都可以通过各种关系类型、中间实体和路径与其他任何实体相连。在图中，你可以区分有向图和无向图。有向图的边有——怎么可能不是这样——方向。尽管有人可能会争辩说每个问题都可以以某种方式表示为图问题，但了解何时这样做是理想的，何时不是，是很重要的。
- en: 7.1.1\. Why and when should I use a graph database?
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1。我应该在何时以及为什么使用图数据库？
- en: 'The quest of determining which graph database one should use could be an involved
    process to undertake. One important aspect in this decision making process is
    finding the right representation for your data. Since the early 1970s the most
    common type of database one had to rely on was a relational one. Later, others
    emerged, such as the hierarchical database (for example, IMS), and the graph database’s
    closest relative: the network database (for example, IDMS). But during the last
    decades the landscape has become much more diverse, giving end-users more choice
    depending on their specific needs. Considering the recent development of the data
    that’s becoming available, two characteristics are well suited to be highlighted
    here. The first one is the size of the data and the other the complexity of the
    data, as shown in [figure 7.4](#ch07fig04).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 确定应该使用哪种图数据库的过程可能是一个复杂的过程。在这个决策过程中，一个重要的方面是找到适合您数据的确切表示。自从20世纪70年代初以来，人们必须依赖的最常见的数据库类型是关系型数据库。后来，其他类型出现了，例如层次数据库（例如，IMS），以及图数据库最接近的亲属：网络数据库（例如，IDMS）。但在过去几十年里，这个领域变得更加多样化，为最终用户提供了更多选择，这取决于他们的具体需求。考虑到最近可用的数据的发展，有两个特点在这里值得强调。第一个是数据的大小，另一个是数据的复杂性，如图7.4所示。
- en: Figure 7.4\. This figure illustrates the positioning of graph databases on a
    two dimensional space where one dimension represents the size of the data one
    is dealing with, and the other dimension represents the complexity in terms of
    how connected the data is. When relational databases can no longer cope with the
    complexity of a data set because of its connectedness, but not its size, graph
    databases may be your best option.
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4。此图说明了图数据库在二维空间中的定位，其中一条维度代表处理的数据的大小，另一条维度代表数据的复杂性。当关系数据库由于数据的连接性而无法处理数据集的复杂性，但不是其大小时，图数据库可能是你的最佳选择。
- en: '![](Images/07fig04_alt.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4](Images/07fig04_alt.jpg)'
- en: As [figure 7.4](#ch07fig04) indicates, we’ll need to rely on a graph database
    when the data is complex but still small. Though “small” is a relative thing here,
    we’re still talking hundreds of millions of nodes. Handling complexity is the
    main asset of a graph database and the ultimate “why” you’d use it. To explain
    what kind of *complexity* is meant here, first think about how a traditional relational
    database works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如图7.4所示，当数据复杂但仍然较小时，我们需要依赖图数据库。虽然这里的“小”是一个相对的概念，但我们仍在谈论数亿个节点。处理复杂性是图数据库的主要优势，也是你使用它的最终“原因”。为了解释这里所说的“复杂性”是什么，首先考虑一下传统的数据库是如何工作的。
- en: Contrary to what the name of relational databases indicates, not much is relational
    about them except that the foreign keys and primary keys are what relate tables.
    In contrast, relationships in graph databases are first-class citizens. Through
    this aspect, they lend themselves well to modeling and querying connected data.
    A relational database would rather strive for minimizing data redundancy. This
    process is known as database normalization, where a table is decomposed into smaller
    (less redundant) tables while maintaining all the information intact. In a normalized
    database one needs to conduct changes of an attribute in only one table. The aim
    of this process is to isolate data changes in one table. Relational database management
    systems (RDBMS) are a good choice as a database for data that fits nicely into
    a tabular format. The relationships in the data can be expressed by joining the
    tables. Their fit starts to downgrade when the joins become more complicated,
    especially when they become many-to-many joins. Query time will also increase
    when your data size starts increasing, and maintaining the database will be more
    of a challenge. These factors will hamper the performance of your database. Graph
    databases, on the other hand, inherently store data as nodes and relationships.
    Although graph databases are classified as a NoSQL type of database, a trend to
    present them as a category in their own right exists. One seeks the justification
    for this by noting that the other types of NoSQL databases are aggregation-oriented,
    while graph databases aren’t.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系型数据库的名称所暗示的相反，它们之间并没有多少关系，除了外键和主键是连接表的关系。相比之下，图数据库中的关系是一等公民。通过这一方面，它们非常适合建模和查询关联数据。关系型数据库更倾向于努力最小化数据冗余。这个过程被称为数据库规范化，其中表被分解成更小（更少冗余）的表，同时保持所有信息完整。在规范化的数据库中，只需要在一个表中执行属性的变化。这个过程的目标是将数据变化隔离在一个表中。关系型数据库管理系统（RDBMS）是作为适合表格格式的数据的数据库的一个好选择。数据中的关系可以通过连接表来表示。当连接变得更为复杂时，尤其是成为多对多连接时，它们的适用性开始下降。当你的数据量开始增加时，查询时间也会增加，维护数据库将更具挑战性。这些因素将阻碍数据库的性能。另一方面，图数据库本质上以节点和关系存储数据。尽管图数据库被归类为NoSQL类型数据库，但将它们作为一个独立类别呈现的趋势正在出现。人们通过注意到其他类型的NoSQL数据库是面向聚合的，而图数据库则不是来寻求这种分类的合理性。
- en: A relational database might, for example, have a table representing “people”
    and their properties. Any person is related to other people through kinship (and
    friendship, and so on); each row might represent a person, but connecting them
    to other rows in the people table would be an immensely difficult job. Do you
    add a variable that holds the unique identifier of the first child and an extra
    one to hold the ID of the second child? Where do you stop? Tenth child?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个关系型数据库可能有一个表示“人”及其属性的表。任何人都通过血缘关系（以及友谊等）与其他人相关联；每一行可能代表一个人，但将它们连接到“人”表中的其他行将是一项极其困难的工作。你是否添加一个变量来持有第一个孩子的唯一标识符，并添加另一个来持有第二个孩子的ID？你在哪里停止？第十个孩子？
- en: 'An alternative would be to use an intermediate table for child-parent relationships,
    but you’ll need a separate one for other relationship types like friendship. In
    this last case you don’t get column proliferation but table proliferation: one
    relationship table for each type of relationship. Even if you somehow succeed
    in modeling the data in such a way that all family relations are present, you’ll
    need difficult queries to get the answer to simple questions such as “I would
    like the grandsons of John McBain.” First you need to find John McBain’s children.
    Once you find his children, you need to find theirs. By the time you have found
    all the grandsons, you have hit the “people” table three times:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用中间表来表示父子关系，但你将需要一个单独的表来表示其他关系类型，如友谊。在这种情况下，你不会得到列的激增，但会得到表的激增：每种关系类型一个关系表。即使你设法以这种方式建模数据，使得所有家庭关系都存在，你也需要复杂的查询来回答简单的问题，例如“我想知道John
    McBain的孙子们。”首先，你需要找到John McBain的孩子。一旦找到他的孩子，你需要找到他们的孩子。当你找到所有孙子时，你已经击中了“人”表三次：
- en: '**1**.  Find McBain and fetch his children.'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  找到McBain并获取他的孩子。'
- en: '**2**.  Look up the children with the IDs you got and get the IDs of their
    children.'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  查找您获得的ID对应的儿童，并获取他们孩子的ID。'
- en: '**3**.  Find the grandsons of McBain.'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  找到McBain的孙子们。'
- en: '[Figure 7.5](#ch07fig05) shows the recursive lookups in a relation database
    necessary to get from John McBain to his grandsons if everything is in a single
    table.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.5](#ch07fig05) 展示了在关系数据库中递归查找的必要步骤，以便从约翰·麦克拜恩找到他的孙子们，如果所有内容都在一个表中。'
- en: 'Figure 7.5\. Recursive lookup version 1: all data in one table'
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5\. 递归查找版本1：所有数据在一个表中
- en: '![](Images/07fig05_alt.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig05_alt.jpg)'
- en: '[Figure 7.6](#ch07fig06) is another way to model the data: the parent-child
    relationship is a separate table.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.6](#ch07fig06) 是另一种建模数据的方式：父子关系是一个单独的表。'
- en: 'Figure 7.6\. Recursive lookup version 2: using a parent-child relationship
    table'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6\. 递归查找版本2：使用父子关系表
- en: '![](Images/07fig06_alt.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig06_alt.jpg)'
- en: Recursive lookups such as these are inefficient, to say the least.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 至少可以说，这种递归查找是不高效的。
- en: Graph databases shine when this type of *complexity* arises. Let’s look at the
    most popular among them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现这种*复杂性*时，图数据库表现出色。让我们看看其中最受欢迎的。
- en: '7.2\. Introducing Neo4j: a graph database'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 介绍Neo4j：一个图数据库
- en: Connected data is generally stored in graph databases. These databases are specifically
    designed to cope with the structure of connected data. The landscape of available
    graph databases is rather diverse these days. The three most-known ones in order
    of decreasing popularity are Neo4j, OrientDb, and Titan. To showcase our case
    study we’ll choose the most popular one at the moment of writing (see [http://db-engines.com/en/ranking/graph+dbms](http://db-engines.com/en/ranking/graph+dbms),
    September 2015).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 连接数据通常存储在图数据库中。这些数据库专门设计来处理连接数据的结构。如今可用的图数据库种类繁多。按流行度递减的顺序，最知名的三个是Neo4j、OrientDb和Titan。为了展示我们的案例研究，我们将选择在撰写本文时的最受欢迎的一个（参见[http://db-engines.com/en/ranking/graph+dbms](http://db-engines.com/en/ranking/graph+dbms)，2015年9月）。
- en: Neo4j is a graph database that stores the data in a graph containing nodes and
    relationships (both are allowed to contain properties). This type of graph database
    is known as a property graph and is well suited for storing connected data. It
    has a flexible schema that will give us freedom to change our data structure if
    needed, providing us the ability to add new data and new relationships if needed.
    It’s an open source project, mature technology, easy to install, user-friendly,
    and well documented. Neo4j also has a browser-based interface that facilitates
    the creation of graphs for visualization purposes. To follow along, this would
    be the right moment to install Neo4j. Neo4j can be downloaded from [http://neo4j.com/download/](http://neo4j.com/download/).
    All necessary steps for a successful installation are summarized in [appendix
    C](kindle_split_020.xhtml#app03).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j是一个图数据库，它将数据存储在包含节点和关系的图中（两者都可以包含属性）。这种类型的图数据库被称为属性图，非常适合存储连接数据。它具有灵活的模式，如果需要，将给我们改变数据结构的自由，提供我们添加新数据和新的关系的能力。它是一个开源项目，成熟的技术，易于安装，用户友好，并且有良好的文档。Neo4j还有一个基于浏览器的界面，便于创建用于可视化的图。为了跟上，现在安装Neo4j将是正确的时机。Neo4j可以从[http://neo4j.com/download/](http://neo4j.com/download/)下载。成功安装的所有必要步骤总结在[附录C](kindle_split_020.xhtml#app03)中。
- en: 'Now let’s introduce the four basic structures in Neo4j:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们介绍Neo4j中的四个基本结构：
- en: '***Nodes*** —Represent entities such as documents, users, recipes, and so on.
    Certain properties could be assigned to nodes.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***节点*** —代表实体，如文档、用户、食谱等。可以分配给节点某些属性。'
- en: '***Relationships*** —Exist between the different nodes. They can be accessed
    either stand-alone or through the nodes they’re attached to. Relationships can
    also contain properties, hence the name property graph model. Every relationship
    has a name and a direction, which together provide semantic context for the nodes
    connected by the relationship.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***关系*** —存在于不同的节点之间。它们可以通过独立访问或通过它们所附加的节点来访问。关系也可以包含属性，因此得名属性图模型。每个关系都有一个名称和方向，这两个属性共同为通过关系连接的节点提供语义上下文。'
- en: '***Properties*** —Both nodes and relationships can have properties. Properties
    are defined by key-value pairs.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***属性*** —节点和关系都可以有属性。属性由键值对定义。'
- en: '***Labels*** —Can be used to group similar nodes to facilitate faster traversal
    through graphs.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***标签*** —可以用来将相似的节点分组，以便更快地遍历图。'
- en: Before conducting an analysis, a good habit is to design your database carefully
    so it fits the queries you’d like to run down the road when performing your analysis.
    Graph databases have the pleasant characteristic that they’re whiteboard friendly.
    If one tries to draw the problem setting on a whiteboard, this drawing will closely
    resemble the database design for the defined problem. Therefore, such a whiteboard
    drawing would then be a good starting point to design our database.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据分析之前，一个好的习惯是仔细设计你的数据库，以便它适合你在分析过程中想要运行的查询。图数据库有一个令人愉悦的特性，即它们适合在白板上绘制。如果尝试在白板上绘制问题设置，这个绘制将非常接近定义问题的数据库设计。因此，这样的白板绘制将是一个很好的起点，用于设计我们的数据库。
- en: Now how to retrieve the data? To explore our data, we need to traverse through
    the graph following predefined paths to find the patterns we’re searching for.
    The Neo4j browser is an ideal environment to create and play around with your
    connected data until you get to the right kind of representation for optimal queries,
    as shown in [figure 7.7](#ch07fig07). The flexible schema of the graph database
    suits us well here. In this browser you can retrieve your data in rows or as a
    graph. Neo4j has its own query language to ease the creation and query capabilities
    of graphs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如何检索数据？为了探索我们的数据，我们需要通过预定义的路径在图中遍历，以找到我们正在寻找的模式。Neo4j浏览器是一个理想的环境，可以创建和操作你的连接数据，直到你得到适合最佳查询的表示，如图7.7所示。图数据库的灵活模式非常适合这里。在这个浏览器中，你可以以行或图的形式检索你的数据。Neo4j有自己的查询语言，以简化图创建和查询功能。
- en: Figure 7.7\. Neo4j 2.2.5 interface with resolved query from the chapter case
    study
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.7\. Neo4j 2.2.5界面，已解析章节案例研究中的查询
- en: '![](Images/07fig07_alt.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig07_alt.jpg)'
- en: Cypher is a highly expressive language that shares enough with SQL to enhance
    the learning process of the language. In the following section, we’ll create our
    own data using Cypher and insert it into Neo4j. Then we can play around with the
    data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher是一种高度表达的语言，与SQL有足够的相似性，可以增强语言的学习过程。在下一节中，我们将使用Cypher创建自己的数据并将其插入Neo4j。然后我们可以围绕这些数据进行操作。
- en: '7.2.1\. Cypher: a graph query language'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. Cypher：图查询语言
- en: Let’s introduce Cypher and its basic syntax for graph operations. The idea of
    this section is to present enough about Cypher to get us started using the Neo4j
    browser. At the end of this section you should be able to create your own connected
    data using Cypher in the Neo4j browser and run basic queries to retrieve the results
    of the query. For a more extensive introduction to Cypher you can visit [http://neo4j.com/docs/stable/cypher-query-lang.html](http://neo4j.com/docs/stable/cypher-query-lang.html).
    We’ll start by drawing a simple social graph accompanied by a basic query to retrieve
    a predefined pattern as an example. In the next step we’ll draw a more complex
    graph that will allow us to use more complicated queries in Cypher. This will
    help us to get acquainted with Cypher and move us down the path to bringing our
    use case into reality. Moreover, we’ll show how to create our own simulated connected
    data using Cypher.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍Cypher及其基本的图操作语法。本节的目标是介绍足够多的关于Cypher的内容，以便我们能够开始使用Neo4j浏览器。在本节结束时，你应该能够使用Cypher在Neo4j浏览器中创建自己的连接数据，并运行基本的查询以检索查询结果。要获取Cypher的更详细介绍，请访问[http://neo4j.com/docs/stable/cypher-query-lang.html](http://neo4j.com/docs/stable/cypher-query-lang.html)。我们将从绘制一个简单的社交图并附带一个基本查询以检索预定义模式为例开始。在下一步中，我们将绘制一个更复杂的图，这将允许我们在Cypher中使用更复杂的查询。这将帮助我们熟悉Cypher，并使我们能够将我们的用例带入现实。此外，我们将展示如何使用Cypher创建我们自己的模拟连接数据。
- en: '[Figure 7.8](#ch07fig08) shows a simple social graph of two nodes, connected
    by a relationship of type “knows”. The nodes have both the properties “name” and
    “lastname”.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.8](#ch07fig08) 展示了两个节点之间的简单社交图，这两个节点通过“认识”类型的关系连接。节点同时具有“姓名”和“姓氏”属性。'
- en: Figure 7.8\. An example of a simple social graph with two users and one relationship
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.8\. 具有两个用户和一个关系的简单社交图示例
- en: '![](Images/07fig08.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig08.jpg)'
- en: Now, if we’d like to find out the following pattern, “Who does Paul know?” we’d
    query this using Cypher. To find a pattern in Cypher, we’ll start with a `Match`
    clause. In this query we’ll start searching at the node User with the name property
    “Paul”. Note how the node is enclosed within parentheses, as shown in the code
    snippet below, and the relationship is enclosed by square brackets. Relationships
    are named with a colon (:) prefix, and the direction is described using arrows.
    The placeholder p2 will contain all the User nodes having the relationship of
    type “knows” as an inbound relationship. With the return clause we can retrieve
    the results of the query.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想找出以下模式，“保罗认识谁？”我们可以使用Cypher进行查询。在Cypher中查找模式时，我们将从`Match`子句开始。在这个查询中，我们将从具有名称属性“Paul”的节点User开始搜索。注意节点被括号包围，如以下代码片段所示，关系被方括号包围。关系以冒号（:）前缀命名，方向使用箭头描述。占位符p2将包含所有具有类型“knows”关系作为入边关系的User节点。通过`return`子句，我们可以检索查询结果。
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the close relationship of how we have formulated our question verbally
    and the way the graph database translates this into a traversal. In Neo4j, this
    impressive expressiveness is made possible by its graph query language, Cypher.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何用口头方式表达问题与图数据库如何将其转换为遍历之间的紧密关系。在Neo4j中，这种令人印象深刻的表达能力是通过其图查询语言Cypher实现的。
- en: To make the examples more interesting, let’s assume that our data is represented
    by the graph in [figure 7.9](#ch07fig09).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使示例更有趣，让我们假设我们的数据由[图7.9](#ch07fig09)中的图形表示。
- en: Figure 7.9\. A more complicated connected data example with several interconnected
    nodes of different types
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.9. 一个更复杂的连接数据示例，包含不同类型节点的多个相互连接的节点
- en: '![](Images/07fig09_alt.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片7.9的替代文本](Images/07fig09_alt.jpg)'
- en: We can insert the connected data in [figure 7.9](#ch07fig09) into Neo4j by using
    Cypher. We can write Cypher commands directly in the browser-based interface of
    Neo4j, or alternatively through a Python driver (see [http://neo4j.com/developer/python/](http://neo4j.com/developer/python/)
    for an overview). This is a good way to get a hands-on feeling with connected
    data and graph databases.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Cypher将[图7.9](#ch07fig09)中的连接数据插入到Neo4j中。我们可以在Neo4j基于浏览器的界面中直接编写Cypher命令，或者通过Python驱动程序（参见[http://neo4j.com/developer/python/](http://neo4j.com/developer/python/)以获取概述）。这是了解连接数据和图数据库的好方法。
- en: To write an appropriate create statement in Cypher, first we should have a good
    understanding of which data we’d like to store as nodes and which as relationships,
    what their properties should be, and whether labels would be useful. The first
    decision is to decide which data should be regarded as nodes and which as relationships
    to provide a semantic context for these nodes. In [figure 7.9](#ch07fig09) we’ve
    chosen to represent the users and countries they have been in as nodes. Data that
    provides information about a specific node, for example a name that’s associated
    with a node, can be represented as a property. All data that provides context
    about two or more nodes will be considered as a relationship. Nodes that share
    common features, for example Cambodia and Sweden are both countries, will also
    be grouped through labels. In [figure 7.9](#ch07fig09) this is already done.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Cypher中编写适当的创建语句，首先我们应该很好地理解我们想将哪些数据存储为节点，哪些作为关系，它们的属性应该是什么，以及标签是否有用。第一个决定是决定哪些数据应被视为节点，哪些作为关系，为这些节点提供语义上下文。在[图7.9](#ch07fig09)中，我们选择将用户和他们访问过的国家表示为节点。提供特定节点信息的数据，例如与节点关联的名称，可以表示为属性。所有提供两个或多个节点上下文的数据都将被视为关系。具有共同特征的节点，例如柬埔寨和瑞典都是国家，也将通过标签分组。在[图7.9](#ch07fig09)中，这已经完成。
- en: In the following listing we demonstrate how the different objects could be encoded
    in Cypher through one big create statement. *Be aware that Cypher is case sensitive*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们演示了如何通过一个大的创建语句在Cypher中编码不同的对象。*请注意，Cypher区分大小写*。
- en: Listing 7.1\. Cypher data creation statement
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1. Cypher数据创建语句
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Running this create statement in one go has the advantage that the success of
    this execution will ensure us that the graph database has been successfully created.
    If an error exists, the graph won’t be created.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性运行这个创建语句的优点是，这个执行的成败将确保我们图数据库已成功创建。如果存在错误，图将不会被创建。
- en: 'In a real scenario, one should also define indexes and constraints to ensure
    a fast lookup and not search the entire database. We haven’t done this here because
    our simulated data set is small. However, this can be easily done using Cypher.
    Consult the Cypher documentation to find out more about indexes and constraints
    ([http://neo4j.com/docs/stable/cypherdoc-labels-constraints-and-indexes.html](http://neo4j.com/docs/stable/cypherdoc-labels-constraints-and-indexes.html)).
    Now that we’ve created our data, we can query it. The following query will return
    all nodes and relationships in the database:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际场景中，还应该定义索引和约束以确保快速查找，而不是搜索整个数据库。我们没有在这里这样做，因为我们的模拟数据集很小。然而，这可以通过Cypher轻松完成。查阅Cypher文档以了解更多关于索引和约束的信息（[http://neo4j.com/docs/stable/cypherdoc-labels-constraints-and-indexes.html](http://neo4j.com/docs/stable/cypherdoc-labels-constraints-and-indexes.html)）。现在我们已经创建了数据，我们可以查询它。以下查询将返回数据库中的所有节点和关系：
- en: '![](Images/201fig01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/201fig01.jpg)'
- en: '[Figure 7.10](#ch07fig10) shows the database that we’ve created. We can compare
    this graph with the graph we’ve envisioned on our whiteboard. On our whiteboard
    we grouped nodes of people in a label “User” and nodes of countries in a label
    “Country”. Although the nodes in this figure aren’t represented by their labels,
    the labels are present in our database. Besides that, we also miss a node (Hobby)
    and a relationship of type “Loves”. These can be easily added through a merge
    statement that will create the node and relationship if they don’t exist already:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.10](#ch07fig10)显示了我们所创建的数据库。我们可以将这个图与我们白板上构思的图进行比较。在我们的白板上，我们将人的节点分组为“用户”标签，将国家的节点分组为“国家”标签。尽管这个图中的节点没有用它们的标签表示，但标签确实存在于我们的数据库中。此外，我们还缺少一个节点（爱好）和类型为“喜爱”的关系。这些可以通过一个合并语句轻松添加，如果它们还不存在的话：'
- en: Figure 7.10\. The graph drawn in [figure 7.9](#ch07fig09) now has been created
    in the Neo4j web interface. The nodes aren’t represented by their labels but by
    their names. We can infer from the graph that we’re missing the label *Hobby*
    with the name *Traveling*. The reason for this is because we have forgotten to
    include this node and its corresponding relationship in the create statement.
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10\. [图7.9](#ch07fig09)中绘制的图现在已经在Neo4j网络界面中创建。节点不是通过它们的标签，而是通过它们的名称来表示。我们可以从图中推断出我们缺少名为*Traveling*的*爱好*标签。原因是我们在创建语句中忘记包含这个节点及其对应的关系。
- en: '![](Images/07fig10_alt.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig10_alt.jpg)'
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can ask many questions here. For example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提出很多问题。例如：
- en: 'Question 1: Which countries has Annelies visited? The Cypher code to create
    the answer (shown in [figure 7.11](#ch07fig11)) is'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题1：安奈莉丝访问过哪些国家？创建答案的Cypher代码（如图7.11所示）是
- en: 'Figure 7.11\. Results of question 1: Which countries has Annelies visited?
    We can see the three countries Annelies has been in, using the row presentation
    of Neo4j. The traversal took only 97 milliseconds.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11\. 问题1的结果：安奈莉丝访问过哪些国家？我们可以通过Neo4j的行表示看到安奈莉丝曾去过三个国家。这次遍历只用了97毫秒。
- en: '![](Images/07fig11_alt.jpg)'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/07fig11_alt.jpg)'
- en: '[PRE3]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Question 2: Who has been where? The Cypher code (explained in [figure 7.12](#ch07fig12))
    is'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题2：人在哪里？Cypher代码（如图7.12所示）是
- en: Figure 7.12\. Who has been where? Query buildup explained.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.12\. 人在哪里？查询构建解释。
- en: '![](Images/07fig12.jpg)'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](Images/07fig12.jpg)'
- en: '[PRE4]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we run this query we get the answer shown in [figure 7.13](#ch07fig13).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个查询时，我们得到[图7.13](#ch07fig13)中显示的答案。
- en: 'Figure 7.13\. Results of question 2: Who has been where? The results of our
    traversal are now shown in the graph representation of Neo4j. Now we can see that
    Paul, in addition to Annelies, has also been to Cambodia.'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.13\. 问题2的结果：人在哪里？我们的遍历结果现在以Neo4j的图表示形式显示。现在我们可以看到，除了安奈莉丝之外，保罗也去过柬埔寨。
- en: '![](Images/07fig13.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig13.jpg)'
- en: 'In question 2 we have chosen not to specify a start node. Therefore, Cypher
    will go to all nodes present in the database to find those with an outgoing relationship
    of type “Has_been_in”. One should avoid not specifying a starting node since,
    depending on the size of your database, such a query could take a long time to
    converge. Playing around with the data to obtain the right graph database also
    means a lot of data deletion. Cypher has a delete statement suitable for deleting
    small amounts of data. The following query demonstrates how to delete all nodes
    and relationships in the database:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题 2 中，我们没有指定起始节点。因此，Cypher 将遍历数据库中所有存在的节点，以找到具有类型“Has_been_in”的出向关系的节点。应该避免不指定起始节点，因为，根据数据库的大小，这样的查询可能需要很长时间才能收敛。在数据上玩来玩去以获得正确的图数据库也意味着大量的数据删除。Cypher
    有一个适合删除少量数据的删除语句。以下查询演示了如何删除数据库中的所有节点和关系：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we’re acquainted with connected data and have basic knowledge of how
    it’s managed in a graph database, we can go a step further and look into real,
    live applications of connected data. A social graph, for example, can be used
    to find clusters of tightly connected nodes inside the graph communities. People
    in a cluster who don’t know each other can then be introduced to each other. The
    concept of searching for tightly connected nodes, nodes that have a significant
    amount of features in common, is a widely used concept. In the next section we’ll
    use this idea, where the aim will be to find clusters inside an ingredient network.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了连接数据，并了解了如何在图数据库中管理它，我们可以更进一步，看看连接数据的实际应用。例如，社交图可以用来在图社区内找到紧密连接的节点簇。簇中彼此不认识的人可以相互介绍。寻找紧密连接的节点，即具有大量共同特征的节点，是一个广泛使用的概念。在下一节中，我们将使用这个想法，目标是找到成分网络内的簇。
- en: '7.3\. Connected data example: a recipe recommendation engine'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 连接数据示例：食谱推荐引擎
- en: One of the most popular use cases for graph databases is the development of
    recommender engines. Recommender engines became widely adopted through their promise
    to create relevant content. Living in an era with such abundance in data can be
    overwhelming to many consumers. Enterprises saw the clear need to be inventive
    in how to attract customers through personalized content, thereby using the strengths
    of recommender engines.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据库最流行的用例之一是推荐引擎的开发。推荐引擎因其承诺创建相关内容而得到广泛应用。生活在这样一个数据丰富的时代，对许多消费者来说可能会感到不知所措。企业看到了通过个性化内容吸引客户的明确需求，因此利用推荐引擎的优势。
- en: In our case study we’ll recommend recipes based on the dish preferences of users
    and a network of ingredients. During data preparation we’ll use Elasticsearch
    to quicken the process and allow for more focus on the actual graph database.
    Its main purpose here will be to replace the ingredients list of the “dirty” downloaded
    data with the ingredients from our own “clean” list.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例研究中，我们将根据用户的菜品偏好和成分网络推荐食谱。在数据准备过程中，我们将使用 Elasticsearch 来加速流程，并使我们能够更多地关注实际的图数据库。在这里，它的主要目的将是用我们自己的“干净”列表中的成分替换“脏”下载数据的成分列表。
- en: If you skipped ahead to this chapter, it might be good to at least read [appendix
    A](kindle_split_018.xhtml#app01) on installing Elasticsearch so you have it running
    on your computer. You can always download the index we’ll use from the Manning
    download page for this chapter and paste it into your local Elasticsearch data
    directory if you don’t feel like bothering with the [chapter 6](kindle_split_014.xhtml#ch06)
    case study.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跳过了前面的章节直接来到这里，至少应该阅读[附录 A](kindle_split_018.xhtml#app01)关于安装 Elasticsearch
    的内容，这样您就可以在您的电脑上运行它。如果您不想处理[第 6 章](kindle_split_014.xhtml#ch06)的案例研究，您可以从本章的下载页面下载我们将使用的索引，并将其粘贴到您本地的
    Elasticsearch 数据目录中。
- en: 'You can download the following information from the Manning website for this
    chapter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 Manning 网站下载本章的相关信息：
- en: Three .py code files and their .ipynb counterparts
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 三个 .py 代码文件及其 .ipynb 对应文件
- en: '***Data Preparation Part 1*** —Will upload the data to Elasticsearch (alternatively
    you can paste the downloadable index in your local Elasticsearch data folder)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***数据准备第 1 部分*** — 将数据上传到 Elasticsearch（或者您可以将可下载的索引粘贴到您本地的 Elasticsearch 数据文件夹中）'
- en: '***Data Preparation Part 2*** —Will move the data from Elasticsearch to Neo4j'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***数据准备第 2 部分*** — 将数据从 Elasticsearch 移动到 Neo4j'
- en: Exploration & Recommender System
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索与推荐系统
- en: Three data files
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 三个数据文件
- en: '***Ingredients (.txt)*** —Self-compiled ingredients file'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***食材 (.txt)*** —自行编译的食材文件'
- en: '***Recipes (.json)*** —Contains all the ingredients'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***食谱 (.json)*** —包含所有食材'
- en: '***Elasticsearch index (.zip)*** —Contains the “gastronomical” Elasticsearch
    index you can use to skip data preparation part 1'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Elasticsearch索引 (.zip)*** —包含“美食”Elasticsearch索引，您可以使用它跳过数据准备的第一部分'
- en: Now that we have everything we need, let’s look at the research goal and the
    steps we need to take to achieve it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的东西，让我们看看研究目标和我们需要采取的步骤来实现它。
- en: '7.3.1\. Step 1: Setting the research goal'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1\. 第1步：设定研究目标
- en: Let’s look at what’s to come when we follow the data science process ([figure
    7.14](#ch07fig14)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看遵循数据科学流程（[图7.14](#ch07fig14)）时会出现什么情况。
- en: Figure 7.14\. Data science process overview applied to connected data recommender
    model
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.14\. 将数据科学流程概述应用于连接数据推荐模型
- en: '![](Images/07fig14_alt.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig14_alt.jpg)'
- en: Our primary goal is to set up a recommender engine that would help users of
    a cooking website find the right recipe. A user gets to like several recipes and
    we’ll base our dish recommendations on the ingredients’ overlap in a recipes network.
    This is a simple and intuitive approach, yet already yields fairly accurate results.
    Let’s look at the three data elements we require.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标是建立一个推荐引擎，帮助烹饪网站的用户找到合适的食谱。用户可以喜欢几个食谱，我们将根据食谱网络中食材的重叠来制定菜肴推荐。这是一个简单直观的方法，但已经产生了相当准确的结果。让我们看看我们需要的三个数据元素。
- en: '7.3.2\. Step 2: Data retrieval'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 第2步：数据检索
- en: 'For this exercise we require three types of data:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，我们需要三种类型的数据：
- en: Recipes and their respective ingredients
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食谱及其相应的食材
- en: A list of distinct ingredients we like to model
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要建模的不同食材列表
- en: At least one user and his preference for certain dishes
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少一个用户及其对某些菜肴的偏好
- en: As always, we can divide this into internally available or created data and
    externally acquired data.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们可以将其分为内部可用或创建的数据和外部获取的数据。
- en: '***Internal data*** —We don’t have any *user preferences* or ingredients lying
    around, but these are the smallest part of our data and easily created. A few
    manually input preferences should be enough to create a recommendation. The user
    gets more interesting and accurate results the more feedback he gives. We’ll input
    user preferences later in the case study. A *list of ingredients* can be manually
    compiled and will remain relevant for years to come, so feel free to use the list
    in the downloadable material for any purpose, commercially or otherwise.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***内部数据*** —我们没有任何*用户偏好*或食材，但这些只是我们数据的一小部分，并且很容易创建。一些手动输入的偏好应该足以创建一个推荐。用户给出的反馈越多，他得到的结果就越有趣、越准确。我们将在案例研究中稍后输入用户偏好。*食材列表*可以手动编制，并将在未来几年内保持相关性，因此请随意使用下载材料中的列表，无论是商业用途还是其他用途。'
- en: '***External data*** —*Recipes* are a different matter. Thousands of ingredients
    exist, but these can be combined into millions of dishes. We are in luck, however,
    because a pretty big list is freely available at [https://github.com/fictivekin/openrecipes](https://github.com/fictivekin/openrecipes).
    Many thanks to Fictive Kin for this valuable data set with more than a hundred
    thousand recipes. Sure there are duplicates in here, but they won’t hurt our use
    case that badly.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***外部数据*** —*食谱*是另一回事。有成千上万的食材存在，但它们可以组合成数百万道菜肴。然而，我们很幸运，因为有一个相当大的列表在[https://github.com/fictivekin/openrecipes](https://github.com/fictivekin/openrecipes)上免费提供。非常感谢Fictive
    Kin为我们提供了这个包含超过十万道食谱的宝贵数据集。当然，这里有一些重复项，但它们对我们的用例影响不大。'
- en: 'We now have two data files at our disposal: a list of 800+ ingredients (ingredients.txt)
    and more than a hundred thousand recipes in the recipes.json file. A sample of
    the ingredients list can be seen in the following listing.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有可用的两个数据文件：一个包含800多个食材的列表（ingredients.txt）和超过十万道食谱的recipes.json文件。以下是一个食材列表的示例。
- en: Listing 7.2\. Ingredients list text file sample
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2\. 食材列表文本文件示例
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The “openrecipes” JSON file contains more than a hundred thousand recipes with
    multiple properties such as publish date, source location, preparation time, description,
    and so on. We’re only interested in the name and ingredients list. A sample recipe
    is shown in the following listing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: “openrecipes” JSON文件包含超过十万道食谱，具有多个属性，如发布日期、来源位置、准备时间、描述等。我们只对名称和食材列表感兴趣。以下是一个示例食谱。
- en: Listing 7.3\. A sample JSON recipe
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3\. 一个示例JSON食谱
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because we’re dealing with text data here, the problem is two-fold: first,
    preparing the textual data as described in the text mining chapter. Then, once
    the data is thoroughly cleansed, it can be used to produce recipe recommendations
    based on a network of ingredients. This chapter doesn’t focus on the text data
    preparation because this is described elsewhere, so we’ll allow ourselves the
    luxury of a shortcut during the upcoming data preparation.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这里我们处理的是文本数据，问题有两个方面：首先，按照文本挖掘章节中描述的准备工作准备文本数据。然后，一旦数据被彻底清理，就可以用来根据成分网络生成食谱推荐。本章不专注于文本数据准备，因为这部分在其他地方已有描述，所以我们将允许自己在即将到来的数据准备阶段使用捷径。
- en: '7.3.3\. Step 3: Data preparation'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. 第 3 步：数据准备
- en: We now have two data files at our disposal, and we need to combine them into
    one graph database. The “dirty” recipes data poses a problem that we can address
    using our clean ingredients list and the use of the search engine and NoSQL database
    Elasticsearch. We already relied on Elasticsearch in a previous chapter and now
    it will clean the recipe data for us implicitly when it creates an index. We can
    then search this data to link each ingredient to every recipe in which it occurs.
    We could clean the text data using pure Python, as we did in the text mining chapter,
    but this shows it’s good to be aware of the strong points of each NoSQL database;
    don’t pin yourself to a single technology, but use them together to the benefit
    of the project.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两组数据文件可供使用，我们需要将它们合并成一个图数据库。未清理的食谱数据存在一个问题，我们可以通过使用我们的清洁成分列表和搜索引擎以及 NoSQL
    数据库 Elasticsearch 来解决。我们已经在之前的章节中依赖过 Elasticsearch，现在它将在创建索引时隐式地清理食谱数据。然后我们可以搜索这些数据，将每个成分与其出现的每个食谱联系起来。我们可以像在文本挖掘章节中做的那样，使用纯
    Python 清理文本数据，但这表明了解每个 NoSQL 数据库的强点是很好的；不要局限于单一技术，而是将它们结合起来，以利于项目。
- en: Let’s start by entering our recipe data into Elasticsearch. If you don’t understand
    what’s happening, please check the case study of [chapter 6](kindle_split_014.xhtml#ch06)
    again and it should become clear. Make sure to turn on your local Elasticsearch
    instance and activate a Python environment with the Elasticsearch module installed
    before running the code snippet in the following listing. It’s recommended not
    to run this code “as is” in Ipython (or Jupyter) because it prints every recipe
    key to the screen and your browser can handle only so much output. Either turn
    off the print statements or run in another Python IDE. The code in this snippet
    can be found in “Data Preparation Part 1.py”.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将我们的食谱数据输入到 Elasticsearch 开始。如果你不明白发生了什么，请再次查看第 6 章的案例研究[kindle_split_014.xhtml#ch06]，它应该会变得清晰。确保在运行以下列表中的代码片段之前，打开你的本地
    Elasticsearch 实例并激活一个已安装 Elasticsearch 模块的 Python 环境。建议不要直接在 Ipython（或 Jupyter）中运行此代码，因为它会将每个食谱键打印到屏幕上，而你的浏览器只能处理这么多输出。要么关闭打印语句，要么在另一个
    Python IDE 中运行。此代码片段中的代码可以在“Data Preparation Part 1.py”中找到。
- en: Listing 7.4\. Importing recipe data into Elasticsearch
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 将食谱数据导入 Elasticsearch
- en: '![](Images/ch07ex04-0.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex04-0.jpg)'
- en: '![](Images/ch07ex04-1.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch07ex04-1.jpg)'
- en: 'If everything went well, we now have an Elasticsearch index by the name “gastronomical”
    populated by thousands of recipes. Notice we allowed for duplicates of the same
    recipe by not assigning the name of the recipe to be the document key. If, for
    instance, a recipe is called “lasagna” then this can be a salmon lasagna, beef
    lasagna, chicken lasagna, or any other type. No single recipe is selected as the
    prototype lasagna; they are all uploaded to Elasticsearch under the same name:
    “lasagna”. This is a choice, so feel free to decide otherwise. It will have a
    significant impact, as we’ll see later on. The door is now open for a systematic
    upload to our local graph database. Make sure your local graph database instance
    is turned on when applying the following code. Our username for this database
    is the default Neo4j and the password is Neo4ja; make sure to adjust this for
    your local setup. For this we’ll also require a Neo4j-specific Python library
    called py2neo. If you haven’t already, now would be the time to install it to
    your virtual environment using `pip install py2neo` or `conda install py2neo`
    when using Anaconda. Again, be advised this code will crash your browser when
    run directly in Ipython or Jupiter. The code in this listing can be found in “Data
    Preparation Part 2.py”.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们现在已经有一个名为“gastronomical”的Elasticsearch索引，其中包含数千个食谱。请注意，我们没有将食谱名称指定为文档键，因此允许了相同食谱的重复。例如，如果食谱名称为“lasagna”，那么这可能是一个三文鱼lasagna、牛肉lasagna、鸡肉lasagna或任何其他类型的lasagna。没有单个食谱被选为原型lasagna；它们都使用相同的名称“lasagna”上传到Elasticsearch。这是一个选择，所以请随意决定是否不同。这将产生重大影响，正如我们稍后将会看到的。现在，我们可以系统地上传到我们的本地图数据库。在应用以下代码时，请确保您的本地图数据库实例已开启。我们在这个数据库上的用户名是默认的Neo4j，密码是Neo4ja；请确保根据您的本地设置进行调整。为此，我们还需要一个名为py2neo的特定于Neo4j的Python库。如果您还没有安装，现在就是时候使用`pip
    install py2neo`或使用Anaconda时使用`conda install py2neo`将其安装到您的虚拟环境中。再次提醒，直接在Ipython或Jupiter中运行此代码将导致浏览器崩溃。此列表中的代码可以在“Data
    Preparation Part 2.py”中找到。
- en: Listing 7.5\. Using the Elasticsearch index to fill the graph database
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5. 使用Elasticsearch索引填充图数据库
- en: '![](Images/ch07ex05-0.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch07ex05-0.jpg)'
- en: '![](Images/ch07ex05-1.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch07ex05-1.jpg)'
- en: Great, we’re now the proud owner of a graph database filled with recipes! It’s
    time for connected data exploration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们现在自豪地拥有了一个充满食谱的图数据库！现在是时候进行连接数据探索了。
- en: '7.3.4\. Step 4: Data exploration'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.4. 步骤4：数据探索
- en: Now that we have our data where we want it, we can manually explore it using
    the Neo4j interface at http://localhost:7474/browser/.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据放在了我们想要的位置，我们可以使用Neo4j界面在http://localhost:7474/browser/上手动探索它。
- en: Nothing stops you from running your Cypher code in this environment, but Cypher
    can also be executed via the py2neo library. One interesting question we can pose
    is which ingredients are occurring the most over all recipes? What are we most
    likely to get into our digestive system if we randomly selected and ate dishes
    from this database?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个环境中运行您的Cypher代码没有任何阻碍，但Cypher也可以通过py2neo库来执行。我们可以提出一个有趣的问题：在所有食谱中，哪些成分出现的频率最高？如果我们随机选择并食用这个数据库中的菜肴，我们最有可能摄入消化系统的是什么？
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The query is created in Cypher and says: for all the recipes and their ingredients,
    count the number of relations per ingredient and return the ten ingredients with
    the most relations and their respective counts. The results are shown in [figure
    7.15](#ch07fig15).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是用Cypher创建的，内容如下：对于所有食谱及其成分，计算每个成分的关系数量，并返回关系数量最多的十个成分及其相应的计数。结果如图7.15所示。
- en: Figure 7.15\. Top 10 ingredients that occur in the most recipes
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.15. 在最多食谱中出现的最常见前10个成分
- en: '![](Images/07fig15.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig15.jpg)'
- en: 'Most of the top 10 list in [figure 7.15](#ch07fig15) shouldn’t come as a surprise.
    With salt proudly at the top of our list, we shouldn’t be shocked to find vascular
    diseases as the number one killer in most western countries. Another interesting
    question that comes to mind now is from a different perspective: which recipes
    require the most ingredients?'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15中的前10名列表中的大多数内容可能不会令人惊讶。鉴于盐在我们的列表中高居榜首，我们不应该对在大多数西方国家血管疾病成为头号杀手感到震惊。现在，另一个有趣的问题浮现在脑海中：从不同角度来看，哪些食谱需要最多的成分？
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The query is almost the same as before, but instead of returning the ingredients,
    we demand the recipes. The result is [figure 7.16](#ch07fig16).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 查询几乎与之前相同，但我们不是返回成分，而是要求食谱。结果如图7.16所示。
- en: Figure 7.16\. Top 10 dishes that can be created with the greatest diversity
    of ingredients
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.16. 可以使用最多不同成分制作的前10道菜
- en: '![](Images/07fig16.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片7.16](Images/07fig16.jpg)'
- en: Now this might be a surprising sight. Spaghetti Bolognese hardly sounds like
    the type of dish that would require 59 ingredients. Let’s take a closer look at
    the ingredients listed for Spaghetti Bolognese.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这可能是一个令人惊讶的景象。意大利面肉酱听起来几乎不像需要59种配料的菜品。让我们仔细看看为意大利面肉酱列出的配料。
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Cypher query merely lists the ingredients linked to Spaghetti Bolognese.
    [Figure 7.17](#ch07fig17) shows the result in the Neo4j web interface.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher查询只是列出了与意大利面肉酱链接的配料。[图7.17](#ch07fig17)显示了在Neo4j网络界面中的结果。
- en: Figure 7.17\. Spaghetti Bolognese possible ingredients
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.17\. 意大利面肉酱可能的配料
- en: '![](Images/07fig17_alt.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片7.17](Images/07fig17_alt.jpg)'
- en: Let’s remind ourselves of the remark we made when indexing the data in Elasticsearch.
    A quick Elasticsearch search on Spaghetti Bolognese shows us it occurs multiple
    times, and all these instances were used to link ingredients to Spaghetti Bolognese
    as a recipe. We don’t have to look at Spaghetti Bolognese as a single recipe but
    more as a collection of ways people create their own “Spaghetti Bolognese.” This
    makes for an interesting way to look at this data. People can create their version
    of the dish with ketchup, red wine, and chicken or they might even add soup. With
    “Spaghetti Bolognese” as a dish being so open to interpretation, no wonder so
    many people love it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回忆一下在Elasticsearch中索引数据时我们做出的评论。对意大利面肉酱的快速Elasticsearch搜索显示它出现了多次，所有这些实例都被用来将配料与意大利面肉酱作为食谱链接起来。我们不必将意大利面肉酱视为单一的食谱，而更多地将其视为人们创造自己的“意大利面肉酱”的方式集合。这为查看这些数据提供了一种有趣的方法。人们可以用番茄酱、红酒和鸡肉来制作自己的版本，甚至可能加入汤。由于“意大利面肉酱”这道菜如此开放，难怪这么多人喜欢它。
- en: The Spaghetti Bolognese story was an interesting distraction but not what we
    came for. It’s time to recommend dishes to our gourmand “Ragnar”.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面肉酱故事是一个有趣的分心点，但并非我们此行的目的。现在是时候向我们的美食家“Ragnar”推荐菜品了。
- en: '7.3.5\. Step 5: Data modeling'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.5\. 第5步：数据建模
- en: 'With our knowledge of the data slightly enriched, we get to the goal of this
    exercise: the recommendations.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对数据的了解略有丰富之后，我们达到了这个练习的目标：推荐。
- en: For this we introduce a user we call “Ragnar,” who likes a couple of dishes.
    This new information needs to be absorbed by our graph database before we can
    expect it to suggest new dishes. Therefore, let’s now create Ragnar’s user node
    with a few recipe preferences.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们引入了一个我们称之为“Ragnar”的用户，他喜欢几道菜品。在我们期望它建议新菜品之前，我们需要让我们的图数据库吸收这些新信息。因此，现在让我们创建Ragnar的用户节点和一些食谱偏好。
- en: Listing 7.6\. Creating a user node who likes certain recipes in the Neo4j graph
    database
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6\. 在Neo4j图数据库中创建喜欢某些食谱的用户节点
- en: '![](Images/ch07ex06-0.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片7.18](Images/ch07ex06-0.jpg)'
- en: '![](Images/ch07ex06-1.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片7.6](Images/ch07ex06-1.jpg)'
- en: In [listing 7.6](#ch07ex06) our food connoisseur Ragnar is added to the database
    along with his preference for a few dishes. If we select Ragnar in the Neo4j interface,
    we get [figure 7.18](#ch07fig18). The Cypher query for this is
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表7.6](#ch07ex06)中，我们的美食家Ragnar及其对几道菜品的偏好被添加到数据库中。如果我们选择Ragnar在Neo4j界面中，我们会得到[图7.18](#ch07fig18)。这个Cypher查询如下：
- en: Figure 7.18\. The user Ragnar likes several dishes
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.18\. 用户Ragnar喜欢几道菜品
- en: '![](Images/07fig18.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片7.18](Images/07fig18.jpg)'
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'No surprises in [figure 7.18](#ch07fig18): many people like Spaghetti Bolognese,
    and so does our Scandinavian gastronomist Ragnar.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.18](#ch07fig18) 中没有惊喜：很多人喜欢意大利面肉酱，我们的斯堪的纳维亚美食家Ragnar也是如此。'
- en: For the simple recommendation engine we like to build, all that’s left for us
    to do is ask the graph database to give us the nearest dishes in terms of ingredients.
    Again, this is a basic approach to recommender systems because it doesn’t take
    into account factors such as
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想要构建的简单推荐引擎，我们剩下要做的就是请求图数据库给出基于配料的最近似菜品。这再次是一个基本的推荐系统方法，因为它没有考虑到诸如
- en: Dislike of an ingredient or a dish.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对某种配料或菜品的厌恶。
- en: The amount of like or dislike. A score out of 10 instead of a binary like or
    don’t like could make a difference.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 喜欢或不喜欢程度。10分制的评分而不是简单的喜欢或不喜欢可能更有区别。
- en: The amount of the ingredient that is present in the dish.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜品中某种配料的含量。
- en: The threshold for a certain ingredient to become apparent in its taste. Certain
    ingredients, such as spicy pepper, will represent a bigger impact for a smaller
    dose than other ingredients would.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某种配料在味道中显现的阈值。某些配料，如辣椒，在较小剂量下对味道的影响比其他配料要大。
- en: Food allergies. While this will be implicitly modeled in the like or dislike
    of dishes with certain ingredients, a food allergy can be so important that a
    single mistake can be fatal. Avoidance of allergens should overwrite the entire
    recommendation system.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食物过敏。虽然这将在带有某些成分的菜肴的喜欢或不喜欢中隐式建模，但食物过敏可能非常重要，以至于一次错误可能导致致命。应避免过敏原，以覆盖整个推荐系统。
- en: Many more things for you to ponder about.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多的事情值得你思考。
- en: It might come as a bit of a surprise, but a single Cypher command will suffice.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有些惊讶，但一个单一的Cypher命令就足够了。
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First all recipes that Ragnar likes are collected. Then their ingredients are
    used to fetch all the other dishes that share them. The ingredients are then counted
    for each connected dish and ranked from many common ingredients to few. Only the
    top 20 dishes are kept; this results in the table of [figure 7.19](#ch07fig19).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先收集Ragnar喜欢的所有食谱。然后使用它们的成分来检索共享这些成分的所有其他菜肴。接着对每个关联菜肴的成分进行计数并按从许多常见成分到较少成分的顺序进行排名。只保留前20道菜肴；这导致了[图7.19](#ch07fig19)的表格。
- en: Figure 7.19\. Output of the recipe recommendation; top 20 dishes the user may
    love
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.19\. 食谱推荐的输出；用户可能喜欢的顶级20道菜肴
- en: '![](Images/07fig19_alt.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig19_alt.jpg)'
- en: From [figure 7.19](#ch07fig19) we can deduce it’s time for Ragnar to try Spaghetti
    and Meatballs, a dish made immortally famous by the Disney animation *Lady and
    the Tramp*. This does sound like a great recommendation for somebody so fond of
    dishes containing pasta and meatballs, but as we can see by the ingredient count,
    many more ingredients back up this suggestion. To give us a small hint of what’s
    behind it, we can show the preferred dishes, the top recommendations, and a few
    of their overlapping ingredients in a single summary graph image.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图7.19](#ch07fig19)我们可以推断，是时候让Ragnar尝试意大利面和肉丸了，这是一道由迪士尼动画电影《小姐与流浪汉》使不朽的菜肴。这听起来确实是为那些喜欢含有面条和肉丸的菜肴的人的一个很好的推荐，但正如我们可以通过成分计数看到的那样，还有更多成分支持这个建议。为了给我们一点提示，我们可以通过一个总结的图形图像展示偏好的菜肴、顶级推荐以及它们重叠的一些成分。
- en: '7.3.6\. Step 6: Presentation'
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.6\. 步骤6：展示
- en: The Neo4j web interface allows us to run the model and retrieve a nice-looking
    graph that summarizes part of the logic behind the recommendations. It shows how
    recommended dishes are linked to preferred dishes via the ingredients. This is
    shown in [figure 7.20](#ch07fig20) and is the final output for our case study.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j的Web界面允许我们运行模型并检索一个漂亮的图形，该图形总结了推荐背后的部分逻辑。它显示了推荐菜肴如何通过成分与偏好菜肴相连接。这显示在[图7.20](#ch07fig20)中，并且是我们案例研究的最终输出。
- en: Figure 7.20\. Interconnectedness of user-preferred dishes and top 10 recommended
    dishes via a sub-selection of their overlapping ingredients
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.20\. 用户偏好的菜肴与基于重叠成分子集推荐的顶级10道菜肴之间的相互关联
- en: '![](Images/07fig20_alt.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig20_alt.jpg)'
- en: With this beautiful graph image we can conclude our chapter in the knowledge
    that Ragnar has a few tasty dishes to look forward to. Don’t forget to try the
    recommendation system for yourself by inserting your own preferences.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这张美丽的图形图像，我们可以得出结论，Ragnar有一些美味的菜肴可以期待。别忘了亲自尝试推荐系统，通过插入你自己的偏好来体验。
- en: 7.4\. Summary
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. 总结
- en: In this chapter you learned
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了
- en: Graph databases are especially useful when encountering data in which relationships
    between entities are as important as the entities themselves. Compared to the
    other NoSQL databases, they can handle the biggest complexity but the least data.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库在遇到实体之间的关系与实体本身一样重要的数据时特别有用。与其他NoSQL数据库相比，它们可以处理最大的复杂性，但数据量最少。
- en: 'Graph data structures consist of two main components:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形数据结构由两个主要组件组成：
- en: '***Nodes*** —These are the entities themselves. In our case study, these are
    recipes and ingredients.'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***节点*** —这些是实体本身。在我们的案例研究中，这些是食谱和成分。'
- en: '***Edges*** —The relationships between entities. Relationships, like nodes,
    can be of all kinds of types (for example “contains,” “likes,” “has been to”)
    and can have their own specific properties such as names, weights, or other measures.'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***边*** —实体之间的关系。关系，像节点一样，可以是各种类型（例如“包含”、“喜欢”、“去过”）并且可以有自己的特定属性，如名称、权重或其他度量。'
- en: We looked at Neo4j, currently the most popular graph database. For instruction
    on how to install it, you can consult [appendix B](kindle_split_019.xhtml#app02).
    We looked into adding data to Neo4j, querying it using Cypher, and how to access
    its web interface.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们研究了目前最受欢迎的图数据库Neo4j。有关如何安装它的说明，您可以参考[附录B](kindle_split_019.xhtml#app02)。我们还研究了如何向Neo4j添加数据，如何使用Cypher查询它，以及如何访问其Web界面。
- en: Cypher is the Neo4j database-specific query language, and we looked at a few
    examples. We also used it in the case study as part of our dishes recommender
    system.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher是Neo4j数据库特定的查询语言，我们查看了一些示例。我们还在案例研究中将其作为我们菜谱推荐系统的一部分使用。
- en: In the chapter’s case study we made use of Elasticsearch to clean a huge recipe
    data dump. We then converted this data to a Neo4j database with recipes and ingredients.
    The goal of the case study was to recommend dishes to people based on previously
    shown interest in other dishes. For this we made use of the connectedness of recipes
    via their ingredients. The py2neo library enabled us to communicate with a Neo4j
    server from Python.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章的案例研究中，我们使用了Elasticsearch来清理大量的食谱数据。然后我们将这些数据转换成包含食谱和成分的Neo4j数据库。案例研究的目标是根据用户之前对其他菜谱的兴趣来推荐菜谱。为此，我们利用了通过成分连接的食谱。py2neo库使我们能够从Python与Neo4j服务器进行通信。
- en: It turns out the graph database is not only useful for implementing a recommendation
    system but also for data exploration. One of the things we found out is the diversity
    (ingredient-wise) of Spaghetti Bolognese recipes out there.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果表明，图数据库不仅对实现推荐系统很有用，而且对于数据探索也非常有用。我们发现的一件事是，Spaghetti Bolognese食谱的多样性（从成分角度来看）。
- en: We used the Neo4j web interface to create a visual representation of how we
    get from dish preferences to dish recommendations via the ingredient nodes.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Neo4j的Web界面来创建了一个可视化表示，展示了我们如何通过成分节点从菜谱偏好到菜谱推荐的转换过程。
