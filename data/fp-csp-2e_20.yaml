- en: 16 Working with asynchronous computations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 使用异步计算
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using `Task` to represent asynchronous computations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Task` 来表示异步计算
- en: Composing asynchronous operations sequentially and in parallel
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序和并行地组合异步操作
- en: Working with asynchronous sequences
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与异步序列一起工作
- en: In today’s world of distributed applications, many operations are performed
    asynchronously. A program can begin some operation that takes a relatively long
    time, such as requesting data from another application, but it doesn’t sit idle,
    waiting for that operation to complete. Instead, it goes on to do other work and
    resumes the operation once the data has been received.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今分布式应用程序的世界中，许多操作都是异步执行的。一个程序可以开始一些相对耗时的操作，例如从另一个应用程序请求数据，但它不会空闲等待该操作完成。相反，它会继续做其他工作，一旦收到数据就恢复操作。
- en: Asynchrony certainly is the bread and butter of today’s programmer. I waited
    until this late in the book to deal with it because it adds a level of complexity
    that I wanted to postpone in order to make the ideas presented so far more approachable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作无疑是当今程序员的日常工作。我之所以等到本书的后期才处理这个问题，是因为它增加了一个我希望推迟以使之前提出的思想更易于理解的复杂性层次。
- en: Asynchronous operations are represented in C# using `Task`, and in this chapter,
    you’ll see that `Task<T>` is not so different from other containers such as `Option<T>`,
    `Try<T>`, and so on. While `Task<T>` represents a single value that is delivered
    asynchronously, `IAsyncEnumerable<T>` is a recent addition to the language that
    is used to represent a sequence of values delivered asynchronously. I’ll discuss
    this in the second part of this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，异步操作使用 `Task` 来表示，在本章中，你将看到 `Task<T>` 与其他容器（如 `Option<T>`、`Try<T>` 等）并没有太大的不同。虽然
    `Task<T>` 表示一个异步交付的单个值，但 `IAsyncEnumerable<T>` 是语言中最近添加的一个用于表示异步交付值序列的新增功能。我将在本章的第二部分讨论这一点。
- en: 16.1 Asynchronous computations
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 异步计算
- en: 'In this section, I’ll start by introducing the need for asynchrony and how
    we can use `Task` to model the asynchronous delivery of a value. You’ll then see
    that `Task<T>` is just another container for a `T` and, therefore, supports operations
    like `Map` and `Bind`. We’ll then address some frequently recurring concerns when
    working with `Task`s: combining several asynchronous operations, handling failure,
    performing multiple retries, and running tasks in parallel.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将首先介绍异步的需求以及我们如何使用 `Task` 来模拟值的异步交付。然后你会看到 `Task<T>` 只是 `T` 的另一个容器，因此支持像
    `Map` 和 `Bind` 这样的操作。然后我们将讨论与 `Task` 一起工作时经常出现的一些常见问题：组合多个异步操作、处理失败、执行多次重试以及并行运行任务。
- en: '`Task` and `ValueTask`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 和 `ValueTask`'
- en: The BCL also includes `ValueTask`, which is a value type and is otherwise similar
    to `Task` in terms of usage. It is recommended that an asynchronous method return
    `ValueTask` rather than `Task` when
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: BCL 还包括 `ValueTask`，它是一个值类型，在用法上与 `Task` 类似。建议在以下情况下异步方法返回 `ValueTask` 而不是 `Task`：
- en: It’s called on a hot path, so performance is critical.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在热点路径上被调用，因此性能至关重要。
- en: It can involve asynchrony, but often completes synchronously; for example, methods
    that read from a file or a remote API and cache the retrieved data.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能涉及异步操作，但通常同步完成；例如，从文件或远程 API 读取并缓存检索到的数据的方法。
- en: In such cases, using `ValueTask` is more efficient because you’re not allocating
    a `Task` on the heap. For the purposes of this chapter, when you find a mention
    of `Task`, the idea also holds for `ValueTask`. To learn more about `ValueTask`
    and how it differs from `Task`, head to [https://youtu.be/fj-LVS8hqIE](https://youtu.be/fj-LVS8hqIE)
    to hear about it from its creator Stephen Toub.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用 `ValueTask` 更有效率，因为你没有在堆上分配 `Task`。在本章的目的上，当你发现提到 `Task` 时，这个想法也适用于
    `ValueTask`。要了解更多关于 `ValueTask` 以及它与 `Task` 的区别，请访问 [https://youtu.be/fj-LVS8hqIE](https://youtu.be/fj-LVS8hqIE)，听听其创造者
    Stephen Toub 的介绍。
- en: 16.1.1 The need for asynchrony
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.1 异步的需求
- en: Some operations take longer than others—massively longer! Whereas the time required
    to perform a typical computer instruction is in the order of nanoseconds, I/O
    operations such as reading from the filesystem or making a network request are
    in the order of milliseconds or even seconds.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有些操作比其他操作耗时更长——长得多！典型的计算机指令执行所需的时间在纳秒级别，而像从文件系统读取或发起网络请求这样的 I/O 操作所需的时间在毫秒或甚至秒级别。
- en: 'To get a better grasp of how big the difference is, let’s scale things up to
    something more human: if an in-memory instruction such as adding two numbers were
    to take about a second, then a typical I/O operation would take months or years.
    And, as in real life, you can wait a few seconds at the water cooler while your
    cup is filled, but you wouldn’t wait around at the bank for weeks while your mortgage
    application is processed. Instead, you’d file your application, go back to your
    daily life, and expect to be notified of the result at some point in the future.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解差异有多大，让我们将事物放大到更符合人类的情况：如果一个内存中的指令，比如加法运算，需要大约一秒钟，那么典型的I/O操作将需要数月或数年。在现实生活中，你可以在水冷却器旁等待几秒钟，直到你的杯子被填满，但你不会在银行等待数周，直到你的抵押贷款申请被处理。相反，你会提交你的申请，回到你的日常生活中，并期待在未来的某个时刻收到结果通知。
- en: '![](Images/CH16_UN01_Buonanno2.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH16_UN01_Buonanno2.png)'
- en: Figure 16.1 When an operation can be performed quickly, we’re happy to wait
    for the operation to complete, ceasing other work. This is the way synchronous
    code works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 当一个操作可以快速完成时，我们愿意等待操作完成，停止其他工作。这就是同步代码的工作方式。
- en: '![](Images/CH16_UN02_Buonanno2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH16_UN02_Buonanno2.png)'
- en: Figure 16.2 When we initiate an operation that takes a long time to complete,
    we then go on to do other work, expecting to be notified when the operation is
    complete. This is how asynchronous code works.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 当我们发起一个需要很长时间才能完成的操作时，我们继续做其他工作，期待在操作完成时得到通知。这就是异步代码的工作方式。
- en: 'This is the idea behind asynchronous computations: kick off an operation that
    takes a long time, move on to doing other work, and then come back once the operation
    completes.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是异步计算背后的思想：启动一个耗时较长的操作，继续做其他工作，然后在操作完成时返回。
- en: 16.1.2 Representing asynchronous operations with Task
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.2 使用Task表示异步操作
- en: 'The main tool for working with asynchronous computations since C# 4 is the
    *Task-based Asynchronous Pattern*. I assume you’re already familiar with it to
    some extent; if not, you’ll find ample documentation online. In a nutshell, here’s
    what it consists of:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自从C# 4以来，处理异步计算的主要工具是基于任务的异步模式（TAP）。我假设你已经在某种程度上熟悉它；如果不是，你可以在网上找到大量的文档。简而言之，它包括以下内容：
- en: Use `Task` and `Task<T>` to represent asynchronous operations.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Task`和`Task<T>`来表示异步操作。
- en: Use the `await` keyword to await the `Task`, which frees the current thread
    to do other work while the asynchronous operation completes.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`await`关键字等待`Task`，这样就可以在异步操作完成的同时释放当前线程去做其他工作。
- en: For instance, in section 15.1, we discussed a program that fetches FX rates
    from the web. The following listing shows the code that actually performs the
    web request, which I previously omitted.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第15.1节中，我们讨论了一个从网络获取外汇汇率的程序。下面的列表显示了执行网络请求的实际代码，我之前省略了它。
- en: Listing 16.1 Blocking the current thread while a network call completes
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.1 在网络调用完成时阻塞当前线程
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Calling `Result` blocks the thread until the operation completes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用`Result`会阻塞线程直到操作完成。
- en: Let’s go through the code in `GetRate`, which performs the remote API call.
    We call `UriFor` to compute the URI needed to retrieve the desired FX rate and
    then use an `HttpClient` to perform the API query.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`GetRate`的代码来了解远程API调用。我们调用`UriFor`来计算检索所需外汇汇率的URI，然后使用`HttpClient`执行API查询。
- en: When calling `Result` on the resulting `Task`, the current thread pauses and
    waits for the response to be received from the remote API. It then deserializes
    the response body into the appropriate type and extracts the requested rate.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当在结果`Task`上调用`Result`时，当前线程会暂停并等待从远程API接收响应。然后它将响应体反序列化为适当的类型，并提取所需的汇率。
- en: Blocking until the response is received is OK for a simple console application,
    but it would be unacceptable for most real-world applications, whether client
    or server. There’s no need to block a thread while waiting for a network call
    to complete.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待响应到达时阻塞是简单的控制台应用程序可以接受的，但对于大多数现实世界的应用程序来说，无论是客户端还是服务器，这都是不可接受的。在等待网络调用完成时没有必要阻塞线程。
- en: You can refactor `GetRate` to perform the request asynchronously, as the following
    listing shows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`GetRate`重构为异步执行请求，如下面的列表所示。
- en: Listing 16.2 Using `Task` to represent an asynchronous operation
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.2 使用`Task`表示异步操作
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The method has the `async` modifier and returns a `Task`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 该方法具有`async`修饰符并返回一个`Task`。
- en: ❷ By convention, the method name has the `Async` suffix.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按照惯例，方法名带有`Async`后缀。
- en: ❸ `await` frees the current thread until the operation completes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `await` 会在操作完成之前释放当前线程。
- en: 'Notice the changes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意变化：
- en: The method now returns not a `decimal` but a `Task<decimal>`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法现在返回的不是 `decimal`，而是一个 `Task<decimal>`。
- en: '`await` suspends the current context (freeing the thread to do other work),
    which is resumed when the asynchronous operation has completed and its result
    is available.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`await` 暂停当前上下文（释放线程以执行其他工作），当异步操作完成且其结果可用时，上下文会恢复。'
- en: You have to mark a method `async` when you use `await` in its body.[¹](#pgfId-1154402)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在方法体中使用 `await` 时，必须标记方法为 `async`。[¹](#pgfId-1154402)
- en: By convention, `Task`-returning methods are named with the `Async` suffix.[²](#pgfId-1154406)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照惯例，返回 `Task` 的方法以 `Async` 后缀命名。[²](#pgfId-1154406)
- en: So far, no surprises. Now let’s look at `Task<T>` from a more functional point
    of view.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有惊喜。现在让我们从更函数式的方法来看 `Task<T>`。
- en: 16.1.3 Task as a container for a future value
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.3 将 `Task` 作为未来值的容器
- en: Given the perspective we’ve been building in this book, it’s natural to look
    at `Task<T>` as just another container of `T`. If `Option<T>` can be seen as a
    box that *may* contain a `T` and `Func<T>` as a container that can be run to get
    a `T`, then `Task<T>` can be seen as a container within which a `T` will materialize
    at some point in the future. So `Task<T>` is a construct that adds the effect
    of asynchrony.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们在本书中构建的视角来看，将 `Task<T>` 视为 `T` 的另一个容器是很自然的。如果 `Option<T>` 可以被视为可能包含 `T` 的盒子，而
    `Func<T>` 可以被视为可以运行以获取 `T` 的容器，那么 `Task<T>` 可以被视为一个容器，其中 `T` 将在未来的某个时刻实现。因此，`Task<T>`
    是一个添加异步效应的构造。
- en: NOTE Again, there’s a vexing dichotomy between the non-generic `Task` and the
    generic `Task<T>`, respectively representing asynchronous operations that yield
    `void` and a `T`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：再次强调，非泛型的 `Task` 和泛型的 `Task<T>` 之间存在令人烦恼的二分法，分别代表产生 `void` 和 `T` 的异步操作。
- en: In this chapter, I’ll always use a return value (at least `Unit`), so even if
    I write `Task` for brevity, you should take it to mean `Task<T>`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将始终使用一个返回值（至少是 `Unit`），所以即使我为了简洁而写 `Task`，你也应该将其理解为 `Task<T>`。
- en: To put this idea of `Task` as a container into code, I’ve defined its `Return`,
    `Map`, and `Bind` functions. These functions effectively make `Task<T>` a monad
    over `T`, and their implementation is shown in the following listing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `Task` 作为容器的想法放入代码中，我定义了它的 `Return`、`Map` 和 `Bind` 函数。这些函数有效地使 `Task<T>`
    成为 `T` 上的单子，它们的实现如下所示。
- en: Listing 16.3 `Map` and `Bind` can be defined trivially in terms of `await`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.3 以 `await` 的方式定义 `Map` 和 `Bind`
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I’ll use `Async` as the `Return` function for `Task`, which lifts a `T` into
    a `Task<T>`. It’s just a shorthand for .NET’s `Task.FromResult` method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 `Async` 作为 `Task` 的 `Return` 函数，它将 `T` 提升到 `Task<T>`。这仅仅是 .NET 的 `Task.FromResult`
    方法的简写。
- en: 'Notice how easy it is to define `Map` and `Bind` with the `await` keyword.
    Why is it so easy? Remember, `Map` *extracts* the inner value(s) from a container,
    applies the given function, and wraps the result back up into a container. But
    this unwrapping and wrapping is exactly what the `await` language feature does:
    it extracts the `Task`’s inner value (the value the operation returns when it
    completes), and when a method contains an `await`, its result is automatically
    wrapped in a `Task`.[³](#pgfId-1154441) All that’s left for `Map` to do is to
    apply the given function to the awaited value.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何轻松地使用 `await` 关键字来定义 `Map` 和 `Bind`。为什么这么容易呢？记住，`Map` 会从容器中提取内部值（值），应用给定的函数，并将结果重新包装回容器中。但正是这种解包和包装正是
    `await` 语言特性所做的事情：它提取 `Task` 的内部值（操作完成时返回的值），当方法中包含 `await` 时，其结果会自动包装在一个 `Task`
    中。[³](#pgfId-1154441) 对于 `Map` 来说，剩下的就是将给定的函数应用到等待的值上。
- en: '`Bind` is similar. It awaits the given `Task<T>`, and when this completes,
    the resulting `T` can be supplied to the bound function. This in turn returns
    a `Task<R>`, which must also be awaited before the desired result of type `R`
    is obtained.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind` 类似。它等待给定的 `Task<T>`，当它完成时，结果 `T` 可以提供给绑定的函数。这反过来又返回一个 `Task<R>`，在获得所需的结果类型
    `R` 之前，也必须等待它。'
- en: I’ve implemented the LINQ query pattern for `Task` along the same lines, so
    you can rewrite the `GetRateAsync` function using a LINQ comprehension as the
    next listing shows.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我按照同样的方式实现了 `Task` 的 LINQ 查询模式，因此你可以使用 LINQ 简述重写 `GetRateAsync` 函数，如下所示。
- en: Listing 16.4 Using LINQ comprehensions with `Task`s
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.4 使用 `Task` 的 LINQ 简述
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the LINQ comprehension in listing 16.4, the `from` clause takes the inner
    value of the `Task` and binds it to the variable `body` (more generally, when
    you see a clause like `from s in m`, you can read it as, “extract the inner value
    of `m` and call it `s`, then . . . ”); this is exactly what `await` does. The
    difference is that `await` is specific to `Task`, whereas LINQ comprehensions
    can be used with any monad.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表16.4的LINQ表达式中，`from`子句取`Task`的内部值并将其绑定到变量`body`（更普遍地，当你看到像`from s in m`这样的子句时，你可以将其读作，“提取`m`的内部值并将其称为`s`，然后……”）；这正是`await`所做的。区别在于`await`是针对`Task`的，而LINQ表达式可以与任何单子一起使用。
- en: Compare this with listing 16.2, and you’ll see that it performs the same operations.
    Also, notice that the `async` modifier is gone because the method body does not
    include the `await` operator.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与列表16.2进行比较，你会发现它执行了相同的操作。此外，请注意，`async`修饰符已消失，因为方法体不包含`await`运算符。
- en: Of course, once you’ve implemented `Bind`/`SelectMany`, you can use it to combine
    several asynchronous operations. The following listing demonstrates this; for
    best performance, instead of `GetStringAsync`, it uses `GetStreamAsync`, which
    yields a stream that can be consumed asynchronously by the deserializer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦你实现了`Bind`/`SelectMany`，你就可以用它来组合多个异步操作。以下列表演示了这一点；为了获得最佳性能，它使用`GetStreamAsync`而不是`GetStringAsync`，`GetStreamAsync`产生一个可以由反序列化器异步消耗的流。
- en: Listing 16.5 Using LINQ comprehensions to chain asynchronous operations
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.5 使用LINQ表达式链式执行异步操作
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the version that leverages asynchrony the most and avoids storing the
    response in memory (which would be inefficient when handling large payloads).
    Note that two `from` clauses are required, given that we now have two asynchronous
    operations (corresponding to two occurrences of the `await` operator if we weren’t
    using a LINQ comprehension).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是利用异步性最多且避免在内存中存储响应（在处理大型有效负载时这将是不高效的）的版本。请注意，需要两个`from`子句，因为我们现在有两个异步操作（如果未使用LINQ表达式，则对应于两个`await`运算符的出现）。
- en: Lazy vs. asynchronous computations
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性与异步计算的比较
- en: Lazy and asynchronous computations both allow you to write code that “runs in
    the future.” That is, at a certain point, your program defines what to do with
    a value `T` returned by a lazy computation `Func<T>` or an asynchronous computation
    `Task<T>`, but those instructions are then executed at a later point.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性和异步计算都允许你编写“在未来运行”的代码。也就是说，在某个时刻，你的程序定义了如何处理由惰性计算`Func<T>`或异步计算`Task<T>`返回的值`T`，但那些指令随后在稍后的时间执行。
- en: There are also important differences between the two. From the point of view
    of the code that defines the computation
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个之间也有重要的区别。从定义计算的代码的角度来看
- en: Creating a lazy computation (like a `Func`, `Try`, `StatefulComputation`, and
    so on) doesn’t start the computation. In fact, it does nothing (no side effects).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个惰性计算（如`Func`、`Try`、`StatefulComputation`等）不会开始计算。实际上，它什么也不做（没有副作用）。
- en: Creating a `Task` kicks off an asynchronous computation.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`Task`启动一个异步计算。
- en: From the point of view of the code consuming the computed result
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从消耗计算结果的代码的角度来看
- en: The code consuming a lazy value “decides” when to run the computation, obtaining
    the computed value.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗惰性值的代码“决定”何时运行计算，获取计算值。
- en: The code consuming an asynchronous value has no control over when it will receive
    the computed value.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗异步值的代码无法控制何时将接收到计算值。
- en: 16.1.4 Handling failure
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.4 处理失败
- en: I mentioned that you can think of `Task<T>` as a construct that adds the effect
    of asynchrony. In fact, it also captures error handling. Because asynchronous
    operations are, most frequently, I/O operations, there’s a high chance of something
    going wrong. Fortunately, `Task<T>` also has error handling via the `Status` and
    `Exception` properties.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到你可以将`Task<T>`视为一个添加异步效果的构造。事实上，它还捕获错误处理。因为异步操作通常是I/O操作，所以出错的可能性很高。幸运的是，`Task<T>`也通过`Status`和`Exception`属性提供错误处理。
- en: This is important. Imagine that you have a synchronous computation and are using
    `Exceptional<T>` to model a computation that may fail. If you now want to make
    the computation asynchronous, you don’t need a `Task<Exceptional<T>>` but only
    a `Task<T>`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要。想象一下，你有一个同步计算，并使用`Exceptional<T>`来模拟可能失败的计算。如果你现在想使计算异步，你不需要`Task<Exceptional<T>>`，只需要`Task<T>`。
- en: To see some examples of how various asynchronous computations can be composed,
    let’s look at some slightly more complex variations on the scenario of retrieving
    exchange rates.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看如何组合各种异步计算的一些示例，让我们看看检索汇率场景的一些稍微复杂的变化。
- en: 'Imagine that your company has purchased a subscription to CurrencyLayer, a
    company providing good quality exchange rate data (that is, data with a short
    delay compared to the market) via an API. If, for some reason, a call to CurrencyLayer’s
    API fails, you want to fall back to RatesAPI, which is what we’ve been using so
    far. First, assume you define two classes encapsulating access to the APIs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你的公司已经购买了CurrencyLayer的订阅，这是一家通过API提供高质量汇率数据的公司（即，与市场相比延迟较短的 数据）。如果由于某种原因，调用CurrencyLayer的API失败，你希望回退到RatesAPI，这是我们迄今为止一直在使用的。首先，假设你定义了两个封装API访问的类：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`CurrencyLayer` is implemented along the same lines as `RatesApi`, but it’s
    adapted to CurrencyLayer’s API, which returns data with a different structure.
    The interesting part is combining the two calls to `GetRateAsync`. For this kind
    of task, you can use the `OrElse` function, which takes a task and a fallback
    to use in case the task fails (the idea is similar to the `OrElse` function defined
    for `Option` in chapter 14):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrencyLayer`的实现与`RatesApi`类似，但它被调整为适应CurrencyLayer的API，该API返回具有不同结构的数据。有趣的部分是结合两次对`GetRateAsync`的调用。对于这类任务，你可以使用`OrElse`函数，它接受一个任务和一个在任务失败时使用的回退（这个想法与第14章中为`Option`定义的`OrElse`函数类似）：'
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Flattens a `Task<Task<T>>` into a `Task<T>`
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将`Task<Task<T>>`扁平化为`Task<T>`
- en: 'Notice that `OrElse` assumes that a `Task` either fails or succeeds. In reality,
    C# `Task`s also support cancellation, but this feature is rarely used and complicates
    the API, so I won’t deal with cancellation here. You can use `OrElse` as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`OrElse`假设`Task`要么失败要么成功。在现实中，C#的`Task`也支持取消，但这个特性很少使用，并且会使API变得复杂，所以在这里我不会处理取消。你可以如下使用`OrElse`：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The result is a new `Task` that produces the value returned by CurrencyLayer
    if the operation is successful and, otherwise, the value returned by RatesAPI.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新的`Task`，如果操作成功，则返回CurrencyLayer返回的值，否则返回RatesAPI返回的值。
- en: 'There is, of course, always the possibility that both calls fail—if, say, the
    network is down. So we also need a function to specify what to do when a task
    fails. I’ll call it `Recover`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，总是有可能两个调用都失败——比如说，网络断开。因此，我们还需要一个函数来指定任务失败时要执行的操作。我将称之为`Recover`：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can use `Recover` as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以如下使用`Recover`：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Recover` is something you’d typically use at the end of a workflow to specify
    what to do if an error occurs somewhere along the way. You can use `Recover` in
    the same way you’d use `Match` for things like `Option` or `Either`. But `Match`
    works synchronously; a `Task` doesn’t have anything to match on because its status
    isn’t available until some point in the future, so technically, `Recover` is more
    like `Map` for the faulted case (you can confirm this by looking at its signature).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recover`通常在工作流的末尾使用，以指定如果在某个地方发生错误时要执行的操作。你可以像使用`Match`处理`Option`或`Either`一样使用`Recover`。但是`Match`是同步的；`Task`没有可以匹配的内容，因为其状态直到未来某个时刻才可用，所以技术上`Recover`更像是故障情况下的`Map`（你可以通过查看其签名来确认这一点）。'
- en: 'It’s also reasonable to define an overload of `Map` that takes a handler for
    both the success and failure cases:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个同时处理成功和失败情况的`Map`的重载也是合理的：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This could then be used as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以如下使用：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 16.1.5 An HTTP API for currency conversion
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.5 货币转换的HTTP API
- en: 'Let’s put it all together by writing an API endpoint that allows clients to
    convert an amount from one currency to another. A sample interaction with this
    API is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一个允许客户端将一种货币的金额转换为另一种货币的API端点来将这些内容全部组合起来。与该API的示例交互如下：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can call the API on a route such as “convert/1000/USD/to/EUR” to find out
    how many Euros are equivalent to 1,000 US Dollars. Here’s the implementation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用类似“convert/1000/USD/to/EUR”的API来找出1,000美元相当于多少欧元。以下是实现方式：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Fall back to a secondary API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 回退到二级API。
- en: ❷ Performs the rate conversion.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行汇率转换。
- en: ❸ Specify what to do in case of failure
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在失败的情况下指定要执行的操作
- en: When the application gets a request, it calls the CurrencyLayer API to get the
    relevant rate. If this fails, it calls RatesAPI. Once it has a rate, it uses it
    to calculate the equivalent amount in the target currency. Finally, it maps a
    successful result to a 200 and failure to a 500.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序收到请求时，它调用CurrencyLayer API以获取相关汇率。如果失败，它调用RatesAPI。一旦它有了汇率，它就使用它来计算目标货币中的等价金额。最后，它将成功的结果映射到200，失败映射到500。
- en: 'You may remember from chapter 8 that once you’re in the elevated world, you
    should stay in it for as long as possible. This is all the more true of `Task`:
    being in the world of `Task` means writing code that runs in the future, so leaving
    the elevated world in this case means blocking the thread and waiting for the
    future to catch up. We hardly ever want to do that.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得在第8章中提到，一旦你进入了特权世界，你应该尽可能长时间地留在那里。对于`Task`来说，这一点尤其正确：处于`Task`的世界意味着编写将在未来运行的代码，因此在这种情况下离开特权世界意味着阻塞线程并等待未来追上。我们几乎从不希望这样做。
- en: 'Note that the method handling the request returns a `Task<IResult>`: ASP.NET
    sends the response to the client when the `Task` has run to completion, and you
    don’t need to worry about when this will take place. You *never* need to leave
    the elevated world of `Task` in this case.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，处理请求的方法返回一个`Task<IResult>`：ASP.NET在`Task`运行完成时向客户端发送响应，你不需要担心这将在何时发生。在这种情况下，你*永远*不需要离开`Task`的特权世界。
- en: 16.1.6 If it fails, try a few more times
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.6 如果失败，尝试更多几次
- en: 'When remote operations (such as a call to an HTTP API) fail, the reasons for
    failure are often transient: maybe there’s a glitch in connectivity, or the remote
    server is being restarted. In other words, an operation that fails once may succeed
    if you retry a few seconds or minutes later.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当远程操作（如对HTTP API的调用）失败时，失败的原因通常是瞬时的：可能是有连接故障，或者远程服务器正在重启。换句话说，一次失败的操作，如果在几秒或几分钟后再尝试可能会成功。
- en: The need to retry when an operation fails is a common requirement when dealing
    with third-party APIs over whose health you have no control. The following listing
    shows one simple and elegant solution that performs an asynchronous operation,
    retrying for a specified number of times if it fails.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作失败时需要重试的需求，在处理你无法控制的第三方API时是一个常见的要求。以下列表展示了一个简单而优雅的解决方案，它执行异步操作，如果失败则重试指定次数。
- en: Listing 16.6 Retrying with exponential backoff
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.6 使用指数退避重试
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Last attempt
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 最后一次尝试
- en: ❷ If the attempt fails, wait for a while and then retry.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果尝试失败，等待一段时间然后重试。
- en: 'To use it, simply wrap the function performing the remote operation in an invocation
    to the `Retry` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，只需将执行远程操作的功能包装在`Retry`函数的调用中：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This specifies that the operation should be retried at most 10 times, with an
    initial delay of one second between attempts. The last argument is the operation
    to perform, specified lazily because invoking the function kicks off the task.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了操作最多重试10次，尝试之间的初始延迟为1秒。最后一个参数是要执行的操作，它以懒加载的方式指定，因为调用函数会启动任务。
- en: 'Notice that `Retry` is recursive: if the operation fails, it waits for the
    specified interval and then retries the same operation, decreasing the number
    of retries left and doubling the interval to wait the next time around (a retry
    strategy known as *exponential backoff*).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Retry`是递归的：如果操作失败，它将等待指定的间隔，然后重试相同的操作，减少剩余的重试次数，并将等待的间隔加倍（一种称为*指数退避*的重试策略）。
- en: 16.1.7 Running asynchronous operations in parallel
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.7 并行运行异步操作
- en: Because `Task` is used to represent operations that take time, it’s only natural
    that you may want to execute them in parallel when possible.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Task`用于表示耗时操作，所以当你可能时并行执行它们是很自然的。
- en: 'Imagine you want to check prices offered by different airlines. Assume you
    have several classes encapsulating access to the airlines'' APIs, each implementing
    the `Airline` interface:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想检查不同航空公司提供的价格。假设你有一些封装访问航空公司API的类，每个类都实现了`Airline`接口：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`BestFare` gets you the cheapest flight available on a given route and date.
    The flight details are queried via a remote API, so naturally the results are
    wrapped in a `Task`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`BestFare`可以为你获取给定路线和日期上最便宜的航班。航班详情通过远程API查询，因此结果自然被封装在`Task`中。'
- en: 'Now imagine for a second that we’re back in the 90s, and you’re interested
    in touring Europe on a shoestring. You’d need to look at the only two low-cost
    airlines on the market: EasyJet and Ryanair. You could then find the best price
    offered between two airports on a given date like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，如果我们回到了90年代，你想要用最少的钱环游欧洲。你需要查看市场上仅有的两家低成本航空公司：EasyJet 和 Ryanair。然后你可以找到在给定日期两个机场之间提供的最佳价格，如下所示：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This works, but it’s not optimal. Because LINQ queries are monadic, `easyjet.BestFare`
    will only be called after `ryanair.BestFare` has completed (you’ll see why in
    a moment). But why wait? After all, the two calls are completely independent,
    so there’s no reason we can’t make the two calls in parallel.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实可行，但并非最佳方案。因为 LINQ 查询是单子（monadic）的，`easyjet.BestFare` 将仅在 `ryanair.BestFare`
    完成后调用（你很快就会明白原因）。但为什么要等待呢？毕竟，这两个调用是完全独立的，所以我们没有理由不能并行执行这两个调用。
- en: You may remember from chapter 10 that when you have independent computations,
    you can use applicatives. The following listing shows `Apply` defined for `Task`,
    which again is implemented rather trivially in terms of `await`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得第10章中提到的，当你有独立的计算时，你可以使用应用（applicatives）。下面的列表展示了为 `Task` 定义的 `Apply`，它再次在
    `await` 的层面上被相当简单实现。
- en: Listing 16.7 Implementation of `Apply` for `Task`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.7 `Apply` 对 `Task` 的实现
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As with other containers, the important overload is the first one (where a unary
    function is wrapped in a container), and overloads for greater arities can be
    defined by just currying that function. As with `Map` and `Bind`, the implementation
    simply uses the `await` keyword to reference the `Task`’s inner value. `Apply`
    awaits the wrapped function, awaits the wrapped argument, and applies the function
    to the argument. The result is wrapped in a task automatically as a result of
    using `await`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他容器一样，重要的重载是第一个（其中一元函数被封装在容器中），而更多参数的重载可以通过对函数进行柯里化（currying）来定义。就像 `Map`
    和 `Bind` 一样，实现只是简单地使用 `await` 关键字来引用 `Task` 的内部值。`Apply` 等待封装的函数，等待封装的参数，并将函数应用于参数。结果自动封装在一个任务中，这是使用
    `await` 的结果。
- en: The following listing shows how you can use `Apply` to find the cheaper fare
    more efficiently.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何使用 `Apply` 更高效地找到更便宜的票价。
- en: Listing 16.8 Performing two `Task`s in parallel with `Apply`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.8 使用 `Apply` 并行执行两个 `Task`
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this version, the two calls to `BestFare` are kicked off independently, so
    they run in parallel. The total time needed for `BestFareA` to complete is determined
    by the time required for the longer of the API calls to complete—not their sum.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，对 `BestFare` 的两次调用是独立启动的，因此它们并行运行。`BestFareA` 完成所需的总时间由API调用所需时间较长的一方决定——而不是它们的总和。
- en: To get a better understanding of why `Apply` runs the task in parallel, while
    `Bind` does so sequentially, have a look at the following listing, which shows
    `Bind` and `Apply` side by side.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解为什么 `Apply` 会并行运行任务，而 `Bind` 会顺序运行，请查看以下列表，它展示了 `Bind` 和 `Apply` 并列的情况。
- en: Listing 16.9 `Bind` runs tasks sequentially, `Apply` in parallel
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.9 `Bind` 顺序运行任务，`Apply` 并行运行
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Bind` first awaits the given `Task<T>` and only then evaluates the function
    starting the second task. It runs the tasks sequentially and can’t do otherwise
    because a value for `T` is required in order to create the second task.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind` 首先等待给定的 `Task<T>` 完成，然后才评估启动第二个任务的函数。它顺序运行任务，并且不能做其他事，因为需要 `T` 的值来创建第二个任务。'
- en: '`Apply`, on the other hand, takes two `Task`s, meaning that both tasks have
    been started. With this in mind, let’s revisit this code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Apply` 接受两个 `Task`，这意味着两个任务都已经启动。考虑到这一点，让我们重新审视这段代码：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you call `Apply` the first time (with the Ryanair task), it *immediately*
    returns a new `Task` without waiting for the Ryanair task to complete (that’s
    the behavior of the `await` inside `Apply`). Then the program immediately goes
    on to create the EasyJet task. As a result, both tasks run in parallel. In other
    words, the difference in behavior between `Bind` and `Apply` is dictated by their
    signatures:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次调用 `Apply`（使用 Ryanair 任务）时，它会*立即*返回一个新的 `Task`，而不等待 Ryanair 任务完成（这是 `Apply`
    内部 `await` 的行为）。然后程序立即继续创建 EasyJet 任务。因此，两个任务并行运行。换句话说，`Bind` 和 `Apply` 之间的行为差异是由它们的签名决定的：
- en: With `Bind`, the first `Task` must be awaited in order to create the second
    task, so it should be used when the creation of a `Task` depends on the return
    value of another.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Bind` 时，必须等待第一个 `Task` 完成，才能创建第二个任务，因此它应该在创建 `Task` 依赖于另一个返回值时使用。
- en: With `Apply`, both tasks are provided by the caller, so you should use it when
    the tasks can be started independently.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Apply` 时，两个任务都由调用者提供，因此你应该在任务可以独立启动时使用它。
- en: 'What if you have not two, but a long list of low-cost airlines to compare,
    as is the case today? To tackle this more complex scenario, we’ll need a new tool:
    `Traverse`, which we’ll see in section 17.1\. But first, we’ll conclude this chapter
    by looking at sequences of asynchronous values.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有不止两家，而是一长串低成本航空公司要比较，就像今天这样呢？为了应对这个更复杂的场景，我们需要一个新的工具：`Traverse`，我们将在第 17.1
    节中看到。但首先，我们将通过查看异步值的序列来结束这一章。
- en: 16.2 Async streams
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 异步流
- en: '`Task<T>` is good for modeling operations that take some time to deliver a
    single `T`, allowing you to write asynchronous code without excessive complexity.
    However, we often have operations that return not a single `T`, but several `T`''s,
    which can be delivered individually or in batches with a relatively long time
    between items or batches. Here are some examples:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task<T>` 适用于建模需要一些时间才能交付单个 `T` 的操作，允许你编写异步代码而不增加过多的复杂性。然而，我们经常有返回的不是单个 `T`，而是多个
    `T` 的操作，这些 `T` 可以单独或批量交付，项目或批量之间有相对较长的时间间隔。以下是一些例子：'
- en: '*Retrieving several pages from a paginated API.* Each page is retrieved with
    a single asynchronous operation and includes a certain number of resources, but
    you need to retrieve several pages in order to retrieve all the resources you
    require.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从分页 API 中检索多页内容。* 每页通过单个异步操作检索，包含一定数量的资源，但你需要检索多页才能获取所需的所有资源。'
- en: '*Reading a file.* Instead of reading the whole content of a file into memory,
    you can read it line by line asynchronously; this allows you to start processing
    the lines read so far while the rest of the file is still being read.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*读取文件。* 你可以异步逐行读取文件内容，而不是将整个文件内容读入内存；这允许你在文件的其他部分仍在读取时开始处理已读取的行。'
- en: '*Retrieving data from a cloud-hosted DB.*'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从云托管数据库中检索数据。*'
- en: As with any long-running operation, we don’t want to wait while the requested
    values are delivered. Instead, we want the calling thread to be freed as soon
    as the async request is kicked off, as figure 16.3 shows.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何长时间运行的操作一样，我们不希望等待请求的值被交付。相反，我们希望在异步请求启动后立即释放调用线程，如图 16.3 所示。
- en: '![](Images/CH16_F01_Buonanno2.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH16_F01_Buonanno2.png)'
- en: Figure 16.3 An asynchronous sequence. The consumer of information asks for some
    data, which is returned asynchronously by the producer of information with a non-negligible
    delay between the produced values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 异步序列。信息消费者请求一些数据，信息生产者以非微不足道的延迟异步返回这些数据。
- en: We can model such scenarios as *async streams*—streams of values that are delivered
    asynchronously. These are represented with the `IAsyncEnumerable<T>` interface,
    and C# 8 introduced dedicated syntax to create and consume `IAsyncEnumerable`s.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此类场景建模为 *异步流*——异步交付的值流。这些值通过 `IAsyncEnumerable<T>` 接口表示，C# 8 引入了用于创建和消费
    `IAsyncEnumerable` 的专用语法。
- en: '`IAsyncEnumerable` is like `Task` (in that it provides asynchrony) and like
    `IEnumerable` (in that it provides aggregation). It combines both effects, if
    you like. Table 16.1 shows the relationship between these different abstractions.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`IAsyncEnumerable` 类似于 `Task`（因为它提供了异步性）和 `IEnumerable`（因为它提供了聚合）。如果你愿意，它结合了这两种效果。表
    16.1 展示了这些不同抽象之间的关系。'
- en: Table 16.1 How `IAsyncEnumerable` compares with other abstractions
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16.1 `IAsyncEnumerable` 与其他抽象的比较
- en: '|  | Synchronous | Asynchronous |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  | 同步 | 异步 |'
- en: '| **Single value** | `T` | `Task<T>` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **单个值** | `T` | `Task<T>` |'
- en: '| **Multiple values** | `IEnumerable<T>` | `IAsyncEnumerable<T>` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **多个值** | `IEnumerable<T>` | `IAsyncEnumerable<T>` |'
- en: So, you may ask, “How is `IAsyncEnumerable<T>` different from `Task<IEnumerable<T>>`?”
    Crucially, with `Task<IEnumerable<T>>`, you have to wait for the enclosing `Task`
    to complete before you can consume the resulting `T`’s. With `IAsyncEnumerable<T>`,
    on the other hand, you can start consuming the incoming `T`'s as soon as they
    are received without waiting for the end of the stream. Let’s explore some concrete
    scenarios.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能会问，“`IAsyncEnumerable<T>` 与 `Task<IEnumerable<T>>` 有何不同？”关键在于，使用 `Task<IEnumerable<T>>`
    时，你必须等待包含的 `Task` 完成，才能消费得到的 `T`。而使用 `IAsyncEnumerable<T>`，另一方面，你可以在接收到 `T` 后立即开始消费，无需等待流的结束。让我们探讨一些具体的场景。
- en: 16.2.1 Reading from a file as an async stream
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.1 将文件作为异步流读取
- en: 'Imagine you’re working in e-commerce and have to keep track of how many items
    are available in the warehouse for each product. The logistics side of the business
    uses an obsolete protocol: stock deliveries to the warehouse are recorded as comma-separated
    values in a CSV file, which is uploaded at the end of each day. You have to write
    a process that reads from the CSV file (each line represents delivery of stock
    of a particular product) and updates the e-commerce DB accordingly.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在电子商务领域工作，需要跟踪每个产品在仓库中的可用库存数量。业务的物流方面使用了一个过时的协议：仓库的库存配送记录为逗号分隔值（CSV）文件，每天结束时上传。你必须编写一个从CSV文件中读取（每一行代表特定产品的库存配送）并相应更新电子商务数据库的过程。
- en: Because reading from a file is relatively slow, it’s natural to model this as
    an asynchronous operation; furthermore, you can read the contents of the file
    line by line. This is more efficient than storing the entire contents of a large
    file into memory. Hence, you can use an `IAsyncEnumerable` as the following listing
    demonstrates.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从文件中读取相对较慢，将其建模为异步操作是自然的；此外，你可以逐行读取文件内容。这比将大文件的全部内容存储在内存中更有效。因此，你可以使用`IAsyncEnumerable`，如下面的列表所示。
- en: Listing 16.10 Reading the contents of a file as an async stream of strings
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.10 将文件内容作为异步字符串流读取
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that to generate an `IAsyncEnumerable`, you use `yield return` (like
    you do with `IEnumerable`) in combination with `await`. In fact, every time you
    have an asynchronous operation (a method that returns a `Task<T>` as is the case
    with `ReadLineAsync` here) that needs to be called repeatedly, you can consider
    using an `IAsyncEnumerable<T>`. Now that we have an async stream of strings, we
    can use each line to populate a data object (I’ll call this `Delivery`), and use
    it to update the DB:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了生成一个`IAsyncEnumerable`，你需要结合使用`yield return`（就像使用`IEnumerable`一样）和`await`。实际上，每次你有一个需要重复调用的异步操作（返回`Task<T>`的方法，例如这里的`ReadLineAsync`）时，你可以考虑使用`IAsyncEnumerable<T>`。现在我们有了字符串的异步流，我们可以使用每一行来填充一个数据对象（我将称之为`Delivery`），并使用它来更新数据库：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Models a delivery
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模拟一个配送
- en: ❷ Populates a `Delivery` from a line from the file
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从文件中的一行填充一个`Delivery`
- en: ❸ Updates the DB with information from the delivery
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用配送信息更新数据库
- en: 'With these building blocks in place, we can write the program that updates
    the DB with the values from the CSV file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些构建块就绪之后，我们可以编写一个程序，使用CSV文件中的值来更新数据库：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Consumes the stream of lines from the CSV file
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 消费CSV文件的行流
- en: ❷ Parses each line into a `Delivery`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将每一行解析为`Delivery`
- en: ❸ Saves the `Delivery` to the DB
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将`Delivery`保存到数据库中
- en: Notice that here we consume the values in the `IAsyncEnumerable` with `await
    foreach`. This is similar to how you consume the elements of an `IEnumerable`
    with `foreach`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里我们使用`await foreach`来消费`IAsyncEnumerable`中的值。这与使用`foreach`消费`IEnumerable`中的元素类似。
- en: 16.2.2 Consuming async streams functionally
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.2 函数式消费异步流
- en: I hope that you’re now thinking, “But we never want to use `foreach` to explicitly
    loop over the elements in a collection; instead, we want to use `Map` or a LINQ
    comprehension to transform each line into a `Delivery` and `ForEach` to update
    the DB!”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你现在正在想，“但我们绝不想使用`foreach`来显式地遍历集合中的元素；相反，我们想使用`Map`或LINQ表达式来将每一行转换为`Delivery`，并使用`ForEach`来更新数据库！”
- en: And, of course, you would be right to think that because that’s the approach
    I’ve been following throughout the book. The only catch is that the relevant extension
    methods on `IAsyncEnumerable` must be imported by referencing the `System .Interactive.Async`
    package. Once you have this reference in place, you can rewrite the program as
    the following listing shows.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，你可能会认为这是我在整本书中一直在遵循的方法。唯一的缺点是，必须在`IAsyncEnumerable`上的相关扩展方法通过引用`System.Interactive.Async`包来导入。一旦设置了此引用，你就可以像以下列表所示那样重写程序。 '
- en: Listing 16.11 Leveraging the extension methods in `System.Interactive.Async`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16.11 利用`System.Interactive.Async`中的扩展方法
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Extensions on `IAsyncEnumerable` are in this namespace.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `IAsyncEnumerable`的扩展在这个命名空间中。
- en: ❷ Performs a side effect for each element in the stream
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对流中的每个元素执行副作用
- en: ❸ Applies a function to each element in the stream
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对流中的每个元素应用一个函数
- en: Here we use a LINQ comprehension to transform each asynchronously delivered
    string into a `Delivery` and `ForEachAsync` to update the DB. Why is it called
    `ForEachAsync` instead of just `ForEach`? Because it completes only when all values
    in the stream have been processed, it returns a `Task`, and the convention is
    to use the `Async` suffix for `Task`-returning operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 LINQ 理解将每个异步传递的字符串转换为 `Delivery`，并使用 `ForEachAsync` 来更新数据库。为什么它被称为
    `ForEachAsync` 而不是仅仅 `ForEach`？因为它仅在流中的所有值都已被处理时完成，它返回一个 `Task`，并且对于返回 `Task`
    的操作，惯例是使用 `Async` 后缀。
- en: 'Notice that I’ve defined `UpdateDb` to be synchronous. In practice, you would
    probably make this operation asynchronous as well; in which case, it would return
    a `Task` rather than `void`. You would then need to modify the program as follows,
    using `ForEachAwaitAsync` rather than `ForEachAsync`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经将 `UpdateDb` 定义为同步的。在实际操作中，你可能会将此操作也异步化；在这种情况下，它将返回一个 `Task` 而不是 `void`。然后你需要按以下方式修改程序，使用
    `ForEachAwaitAsync` 而不是 `ForEachAsync`：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 16.2.3 Consuming data from several streams
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.3 从多个流中消费数据
- en: So far, you’ve seen how to define an async stream and how to consume its values
    using `Select` for data transformations (whether directly or through a LINQ comprehension
    with a single `from` clause) and `ForEachAsync` or `ForEachAwaitAsync` to perform
    side effects. Next, we’ll look at using a LINQ comprehension with multiple `from`
    clauses. As you know from section 10.4, this resolves to `SelectMany`, which is
    essentially `Bind`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何定义异步流以及如何使用 `Select`（无论是直接使用还是通过包含单个 `from` 子句的 LINQ 理解）来消费其值进行数据转换（直接或通过
    LINQ 理解），以及使用 `ForEachAsync` 或 `ForEachAwaitAsync` 来执行副作用。接下来，我们将探讨使用包含多个 `from`
    子句的 LINQ 理解。正如你在第 10.4 节中了解到的，这相当于 `SelectMany`，本质上就是 `Bind`。
- en: 'Imagine your client has not one but several warehouses. They all upload their
    respective CSV files into a directory at the end of the day, so your program needs
    to change to process multiple files. The change is quite simple. Instead of taking
    a path to a file, `ReadDeliveries` can take the directory path and process all
    files present in that directory:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的客户不仅有，而且有几个仓库。他们都会在一天结束时将各自的 CSV 文件上传到目录中，因此你的程序需要更改以处理多个文件。这个更改相当简单。不是获取文件路径，`ReadDeliveries`
    可以获取目录路径并处理该目录中存在的所有文件：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That’s it! A one-line change. `EnumerateFiles` yields an `IEnumerable<string>`.
    This needs to be promoted to an `IAsyncEnumerable<string>` so that it can be used
    in a LINQ comprehension with the streams generated by processing each file. Note
    that the files will be processed sequentially; therefore, the resulting stream
    will have all the deliveries from the first file before moving on to the second
    file, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！只需一行更改。`EnumerateFiles` 返回一个 `IEnumerable<string>`。这需要提升为 `IAsyncEnumerable<string>`，以便可以在处理每个文件生成的流中使用
    LINQ 理解。请注意，文件将按顺序处理；因此，结果流将在移动到第二个文件之前包含来自第一个文件的所有交付，依此类推。
- en: 16.2.4 Aggregation and sorting with async streams
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.4 使用异步流进行聚合和排序
- en: Async streams are powerful in that they enable you to start consuming the values
    in the stream before the stream has ended. In our example, this means that you
    can start updating the DB while the CSV file is still being read. In some scenarios,
    this can give you huge gains in efficiency.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 异步流非常强大，因为它们允许你在流结束之前开始消费流中的值。在我们的例子中，这意味着你可以在读取 CSV 文件的同时开始更新数据库。在某些场景中，这可以给你带来巨大的效率提升。
- en: 'Now imagine that the warehouse receives several deliveries throughout the day,
    potentially including several deliveries of the same product, so the CSV file
    may include several entries for the same product ID. If this is the case, you
    want to perform a single DB update for that product. Your code would then need
    to change as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，仓库在一天中会收到几批货物，可能包括几个相同产品的交付，因此 CSV 文件可能包含几个相同产品 ID 的条目。如果是这种情况，你希望对该产品执行单个数据库更新。然后你的代码需要按以下方式更改：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The gist here is that you are grouping the elements in the stream by their product
    IDs; this is done with `GroupBy`, just as you would do with `IEnumerable`. Within
    each grouping, you then take the sum of all quantities to create a single `Delivery`
    for each product. But notice that you cannot use `Sum` like you would on `IEnumerable`;
    instead, you have to use `SumAsync`, which returns a `Task` (because you have
    to wait until you receive all items before you can compute their sum).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键点是你在流中按产品ID对元素进行分组；这是通过`GroupBy`完成的，就像你会用`IEnumerable`做的那样。在每个分组内部，然后计算所有数量的总和以创建每个产品的单个`Delivery`。但请注意，你不能像在`IEnumerable`上使用`Sum`那样使用`Sum`；相反，你必须使用`SumAsync`，它返回一个`Task`（因为你必须等待接收所有项目，然后才能计算它们的总和）。
- en: As a result, although the code is correct, you’ll notice that we’ve effectively
    lost some of the gains of asynchrony. We need to wait until all elements are received
    to compute their sum or any other aggregate operation. Therefore, in this case,
    `IAsyncEnumerable` ends up being no better than `Task<IEnumerable>`. This is also
    the case if you want the values to be sorted.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管代码是正确的，但你可能会注意到我们实际上失去了一些异步操作的优势。我们需要等待所有元素接收完毕才能计算它们的总和或其他聚合操作。因此，在这种情况下，`IAsyncEnumerable`最终并不比`Task<IEnumerable>`更好。如果你想要排序的值，情况也是如此。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: '`Task<T>` represents a computation that asynchronously delivers a `T`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task<T>`表示一个异步交付`T`的计算。'
- en: '`Task`s should be used when the underlying operation may have significant latency,
    such as most I/O operations.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在底层操作可能具有显著延迟的情况下使用`Task`，例如大多数I/O操作。
- en: '`Task`-returning functions can be composed with `Map`, `Bind`, and several
    other combinators to specify error handling or multiple retries.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`Task`的函数可以用`Map`、`Bind`和其他几个组合子来组合，以指定错误处理或多次重试。
- en: If `Task`s are independent, they can be run in parallel. You can use `Task`
    as an applicative, and composing several `Task`s with `Apply` runs them in parallel.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Task`是独立的，它们可以并行运行。你可以将`Task`用作应用，并通过`Apply`组合几个`Task`来并行运行它们。
- en: '`IAsyncEnumerable<T>` represents a sequence of `T`’s that are delivered asynchronously.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IAsyncEnumerable<T>`表示一个异步交付的`T`序列。'
- en: Use the extension methods in `System.Interactive.Async` to work with `IAsyncEnumerable`;
    this also includes the implementation of the LINQ query pattern.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`System.Interactive.Async`中的扩展方法来处理`IAsyncEnumerable`；这也包括LINQ查询模式的实现。
- en: Keep in mind that some operations on async streams, such as sorting and aggregation,
    require all elements in the stream, therefore losing some of the efficiency gained
    by using an async stream.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，一些异步流的操作，如排序和聚合，需要流中的所有元素，因此会失去使用异步流获得的某些效率。
- en: '* * *'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ This is a bit of a shame as `async` adds noise, especially when used in lambdas.
    Strictly speaking, it’s not needed: it’s possible to design the language syntax
    without `async`; however, it was added to enable backward compatibility back when
    `await` was first added to the language.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 这有点遗憾，因为`async`增加了噪声，尤其是在lambda中使用时。严格来说，这不是必需的：可以设计不使用`async`的语言语法；然而，它被添加是为了使语言与最初添加到语言中的`await`保持向后兼容。
- en: '² I have strong feelings *against* this naming convention. It was proposed
    by Microsoft in the early days of `async`. For one thing, you don’t name methods
    that return a string with a special `-Str` suffix, do you? So why would you with
    `Task`? The idea behind the convention was, I believe, to facilitate disambiguation
    in APIs that expose both synchronous and asynchronous variants of the same operation.
    But this leads to bad design: if there’s a reason for a method to be asynchronous,
    then using the synchronous variant is suboptimal. An API should encourage doing
    the right thing by only exposing the asynchronous version. If both versions are
    exposed, then, if anything, the synchronous version should be labeled with the
    `-Sync` suffix, which would stick out like an eyesore. Good design makes it easy
    to do the right thing, so forcing longer, noisier names for the asynchronous version
    is bad design. Unfortunately, this convention has become widespread enough to
    be considered the standard.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ²我对这种命名约定有强烈的反对意见。这是微软在`async`的早期提出的。一方面，你不会给返回字符串的方法加上特殊的`-Str`后缀，对吧？那么为什么要在`Task`上这样做呢？我认为这种约定的背后想法是，为了在同时公开相同操作的同步和异步版本的API中方便区分。但这导致了糟糕的设计：如果一个方法应该是异步的，那么使用同步版本是不理想的。API应该通过只公开异步版本来鼓励做正确的事情。如果两种版本都公开了，那么，如果有什么不同的话，同步版本应该带有`-Sync`后缀，这将像眼中钉一样突出。好的设计使得做正确的事情变得容易，所以强迫异步版本使用更长、更嘈杂的名称是糟糕的设计。不幸的是，这种约定已经足够普及，以至于被认为是标准。
- en: ³ `await` works not only with `Task` but any *awaitable* (any value for which
    a `GetAwaiter` [instance or extension] method returning an `INotifyCompletion`
    is defined).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`不仅与`Task`一起使用，还可以与任何*可等待的*（任何定义了返回`INotifyCompletion`的`GetAwaiter` [实例或扩展]方法的值）一起使用。'
