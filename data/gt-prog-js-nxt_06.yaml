- en: Unit 4\. Modules
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四单元：模块
- en: 'Until recently, most front-end applications followed the same paradigm for
    using libraries: *exposing globals*. For example, if someone wanted to use jQuery
    ([https://jquery.com](https://jquery.com)) in a project, they would need to go
    to jQuery’s website, download either jquery.js or jquery.min.js, add it to their
    projects’s js or vendor folder, and then include a `<script>` tag importing the
    library into their application. This was not ideal, because it required modules
    to export themselves using global variables that could potentially collide with
    other global variables. It also required dependencies to be included before any
    library that relied on them or there would be an error.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，大多数前端应用程序都遵循相同的库使用范式：*暴露全局变量*。例如，如果有人想在项目中使用jQuery([https://jquery.com](https://jquery.com))，他们需要访问jQuery的网站，下载jquery.js或jquery.min.js，将其添加到项目的js或vendor文件夹中，然后通过一个`<script>`标签将库导入到他们的应用程序中。这并不理想，因为它要求模块使用可能与其他全局变量冲突的全局变量来导出自己。这也要求在依赖于它们的任何库之前包含依赖项，否则会出现错误。
- en: Modules solve these problems by allowing scripts to be included by a module
    loader. The modules themselves can specify and load their dependencies, and thus
    relieve the application author from having to manage them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通过允许模块加载器包含脚本来解决这些问题。模块本身可以指定和加载它们的依赖项，从而减轻应用程序作者管理它们的负担。
- en: Modules allow for dividing large amounts of code into small, cohesive units.
    Each module is contained in its own file. Anything in the file that isn’t exported
    is private, without needing to be wrapped in an immediately invoked function expression
    (IIFE) to create a private scope. Because the code inside a module doesn’t attach
    anything to the global namespace, any code outside of the module must explicitly
    import what it needs from the module in order to gain a reference to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 模块允许将大量代码分成小而紧密的单元。每个模块都包含在其自己的文件中。文件中任何未导出的内容都是私有的，无需用立即调用的函数表达式（IIFE）包裹以创建私有作用域。因为模块内部的代码不会将任何内容附加到全局命名空间，所以模块外部的任何代码都必须明确从模块中导入它需要的部分，以便获得对其的引用。
- en: Using modules makes your code easy to reason about, because you know exactly
    where every value came from. You either defined it directly in your module, or
    you imported it from somewhere else, so you don’t ever find yourself looking at
    a variable and wondering where it was defined. You also don’t have to worry about
    what parts of your module are being used elsewhere. If the value isn’t exported,
    it’s private, and if the value is exported, it’s likely used by something else.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块使你的代码易于推理，因为你确切地知道每个值来自哪里。你要么直接在你的模块中定义它，要么从其他地方导入它，因此你永远不会发现自己看着一个变量而不知道它在哪里定义。你也不必担心你的模块的哪些部分在其他地方被使用。如果值没有被导出，它是私有的，如果值被导出，它很可能被其他东西使用。
- en: Just like breaking your code into many small functions, breaking your application
    into many small modules will make your program easy to reason about and keep it
    maintainable as it grows in complexity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就像将你的代码拆分成许多小的函数一样，将你的应用程序拆分成许多小的模块会使你的程序易于推理，并随着复杂性的增加而保持可维护性。
- en: We’ll start this unit by looking at how to create your own modules. Then we’ll
    take a look at various ways of importing and combining modules. Finally, you’ll
    wrap up the unit by creating a hangman game and seeing how much cleaner your code
    can be when using modules.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个单元开始，看看如何创建你自己的模块。然后我们将探讨导入和组合模块的各种方法。最后，你将通过创建一个猜谜游戏来结束这个单元，看看使用模块可以使你的代码多么整洁。
- en: Lesson 20\. Creating modules
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第20课：创建模块
- en: After reading [lesson 20](kindle_split_032_split_000.xhtml#ch20), you will
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读第20课[课后](kindle_split_032_split_000.xhtml#ch20)后，你将
- en: Understand what a module is
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解什么是模块
- en: Know how JavaScript behaves in modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解JavaScript在模块中的行为
- en: Create modules and export values
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模块并导出值
- en: 'Before you learn how to create and use ES2015 modules, let’s define what a
    module in JavaScript is. At its most basic, a module is a JavaScript file that
    has its own scope and rules, and may import or export values to be used by other
    modules. A module isn’t an object: it has no data type, and you can’t store one
    in a variable. It’s simply a tool to break apart, encapsulate, and organize your
    code.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何创建和使用ES2015模块之前，让我们定义一下JavaScript中的模块是什么。在最基本的情况下，一个模块是一个具有自己的作用域和规则的JavaScript文件，它可以导入或导出值供其他模块使用。模块不是一个对象：它没有数据类型，你不能将其存储在变量中。它只是一个用来拆分、封装和组织代码的工具。
- en: Modules are a great way to separate your logic into cohesive units and share
    logic across files without the cumbersome use of global variables. They also allow
    you to import only what’s needed, keeping the cognitive load down and making maintenance
    easier.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是分离你的逻辑到紧密单元并跨文件共享逻辑的好方法，而不必使用全局变量那么繁琐。它们还允许你只导入所需的，降低认知负荷，并使维护更容易。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Imagine you’re writing a large application. Would you use a single file for
    the entirety of the code or break it up into several smaller files? How would
    you make the various components of your application communicate and share resources
    across files?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个大型应用程序。你会使用一个文件来编写全部代码，还是会将其拆分成几个较小的文件？你将如何使应用程序的各个组件在文件之间进行通信和共享资源？
- en: '|  |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 20.1\. Module rules
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.1. 模块规则
- en: The rules of JavaScript are slightly different inside a module. The code is
    always executed in strict mode, so you never need to add `"use strict";`. The
    whole reason the `use strict` string became popular was to allow scripts to opt-in
    to strict mode. This is because if browsers flipped a switch and started running
    everything in strict mode, many legacy applications would break. Having to opt-in
    to strict mode was a way to preserve backward compatibility and prevent breaking
    the web. But modules are a completely new context, so there’s no need to make
    them backward-compatible. Because of this, it was decided that modules would always
    be in strict mode.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内部，JavaScript 的规则略有不同。代码始终在严格模式下执行，因此你永远不需要添加 `"use strict";`。`use strict`
    字符串变得流行的原因是允许脚本选择加入严格模式。这是因为如果浏览器切换到一个开关，开始以严格模式运行一切，许多遗留应用程序将会崩溃。选择加入严格模式是一种保留向后兼容性和防止破坏网络的方式。但模块是一个全新的上下文，因此没有必要使它们向后兼容。正因为如此，决定模块始终在严格模式下运行。
- en: 'Another difference is what the `this` refers to at the root context. In normal
    JavaScript, `this` will default to the global object (`window` in the browser)
    at the root level. In an ES2015 module though, it will be `undefined`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不同之处在于根上下文中 `this` 的引用。在常规JavaScript中，`this` 在根级别将默认为全局对象（在浏览器中为 `window`）。但在ES2015模块中，它将是
    `undefined`：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* obj**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* obj**'
- en: '***2* undefined**'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* undefined**'
- en: The value returned from `obj.foo()` is `obj`, just like it would be outside
    of a module. But outside of a module, `bar()` would return `window` or the global
    object because it’s invoked without a context. In a module, though, `bar()` being
    invoked without a context would return `undefined`. Additionally, any reference
    to `this` at the root level inside a module would also be `undefined` instead
    of `window`, like it would outside of a module.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `obj.foo()` 返回的值是 `obj`，就像在模块外一样。但在模块外，`bar()` 会返回 `window` 或全局对象，因为它是在没有上下文的情况下调用的。然而，在模块中，如果没有上下文调用
    `bar()`，它将返回 `undefined`。此外，模块内部根级别对 `this` 的任何引用也将是 `undefined`，而不是 `window`，就像在模块外一样。
- en: 'Normally in JavaScript, any variable defined at the root scope is automatically
    set as a global variable. Many JavaScript developers in the past would define
    their variables inside of an IIFE (immediately invoked function expression) to
    prevent the variables from becoming global. You also learned in the first unit
    of this book that in ES2015 you can now use a simple block `{}` to add a scope
    and prevent variables from becoming global. But in a module, variables defined
    are never global. You can imagine your entire module is running inside of a block
    `{}` or IIFE. This is because modules are designed to expose only what they explicitly
    export to the rest of the world. You can still attach values to the global object
    inside of a module, though:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，通常情况下，在根作用域中定义的任何变量都会自动设置为全局变量。许多过去的JavaScript开发者会在立即调用的函数表达式（IIFE）内部定义它们的变量，以防止变量成为全局变量。你也在本书的第一单元中了解到，在ES2015中，你现在可以使用简单的代码块
    `{}` 来添加作用域，并防止变量成为全局变量。但在模块中，定义的变量永远不会是全局的。你可以想象你的整个模块都在一个代码块 `{}` 或 IIFE 内运行。这是因为模块被设计成只向外界显式导出内容。尽管如此，你仍然可以在模块内部将值附加到全局对象上：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In most cases, though, setting globals from a module would be a bad practice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，从模块设置全局变量是一种不良做法。
- en: Now that you know the rules of how code works in modules, let’s take a look
    at making some in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了模块中代码的工作规则，让我们在下一节中看看如何创建一些模块。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 20.1**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 20.1**'
- en: '**[Q1:](kindle_split_032_split_001.xhtml#ch20qa2q0a1)**'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_032_split_001.xhtml#ch20qa2q0a1)**'
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Inside of a module, if you were to call `obj.foo` like the following, what would
    be the result?
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块内部，如果你像以下这样调用`obj.foo`，结果会是什么？
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 20.1 answer**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 20.1 答案**'
- en: '**[A1:](kindle_split_032_split_001.xhtml#ch20qa1q1)**'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_032_split_001.xhtml#ch20qa1q1)**'
- en: ''
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It would be `undefined` because you set the context to `this` at the root level
    and in a module `this` is `undefined` at the root level.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它会是`undefined`，因为你将上下文设置为根级别的`this`，而在模块中根级别的`this`是`undefined`。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 20.2\. Creating modules
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.2\. 创建模块
- en: 'Imagine you’re writing an application and you want a reusable function that
    can log statistics to a database. You want this function to be used all over the
    place. You would probably just set it as a global function like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在编写一个应用程序，并且你想要一个可重用的函数，该函数可以将统计数据记录到数据库中。你希望这个函数到处都可以使用。你可能只是将其设置为一个全局函数，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are several reasons why global variables are a bad practice, but for
    many years in JavaScript, we didn’t have a choice. But now with modules, you could
    put this function in a module and share it across your application without making
    it a global:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因说明全局变量是一种不良实践，但在许多年里，在JavaScript中我们没有选择。但现在有了模块，你可以将这个函数放在一个模块中，并在你的应用程序中共享它，而无需将其设置为全局：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By putting the keyword `export` in front of your function, you’re saying that
    this module exports the `logStats` function. You also specify that this is the
    *default* export; more on that in a bit.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在函数前加上`export`关键字，你是在说这个模块导出了`logStats`函数。你还指定这是默认导出；稍后会更详细地介绍这一点。
- en: 'Now say your `logStats` function needs a helper function. The `logStats` function
    needs access to the helper, but you don’t want to expose it to anything else.
    Again, without modules you would now have to resort to wrapping everything in
    a private context to prevent leaking global values:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你的`logStats`函数需要一个辅助函数。`logStats`函数需要访问这个辅助函数，但你不想将其暴露给其他任何东西。如果没有模块，你现在将不得不求助于将一切包裹在私有上下文中，以防止全局值的泄露：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But within a module, everything is already in its own scope and thus already
    protected from leaking values (unless explicitly exported or set as globals):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 但在模块内部，一切都已经在其自己的作用域中，因此已经保护了值不会泄露（除非明确导出或设置为全局）：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you create a module, you’re generally focusing on a specific task. When
    you want to create a reusable piece of self-contained code, you can put it in
    a module (a separate file) and only expose what’s needed while keeping most of
    the details of the module private. Often your module will only export a single
    value. In that case, it makes sense to export the single value as the default
    value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个模块时，你通常专注于一个特定的任务。当你想要创建一个可重用的自包含代码块时，你可以将其放入一个模块（一个单独的文件）中，只暴露所需的部分，同时保持模块的大部分细节是私有的。通常你的模块只会导出一个单一值。在这种情况下，将单一值作为默认值导出是有意义的：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The function expression is completely normal; it’s just prefixed with the statement
    `export default`. The syntax is `export default <expression>`. The value evaluated
    from the expression ends up being what’s exported. So if you just wanted to export
    the number `5`, you could do this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式是完全正常的；它只是被`export default`语句所前缀。语法是`export default <expression>`。从表达式评估出的值最终成为导出的值。所以如果你只想导出数字`5`，你可以这样做：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you were to think of a module as a function, the default export would be
    analogous to the `return` value from the function. A function can return only
    one value and a module can only have one default export. But a module isn’t limited
    to a single default export: it can export several values, but only one can be
    the default. All other exports will be *named* exports. Going back to your currency
    function, if you wanted to export it by name, all you would need to do is remove
    the `default` keyword:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将模块想象成一个函数，默认导出将与函数的`return`值类似。一个函数只能返回一个值，一个模块也只能有一个默认导出。但模块并不局限于单个默认导出：它可以导出多个值，但只能有一个是默认的。所有其他导出都将被命名为导出。回到你的货币函数，如果你想按名称导出它，你只需要移除`default`关键字：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since you removed the `default` keyword, the function is exported by name. But
    notice you don’t specify what name. The name gets automatically picked up and
    exported as `currency`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你移除了`default`关键字，函数通过名称导出。但请注意，你没有指定名称。名称会自动被选中并作为`currency`导出。
- en: 'The syntax is `export <declaration>`. Did you spot the difference? With a default
    export, you’re exporting an expression, which evaluates to a value: the value
    that’s exported. But with a named export, you’re exporting a declaration. A function
    declaration, variable declaration, or even a class declaration always has a name,
    and that’s the name by which the value is exported. You can export as many declarations
    as you want with this syntax.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是 `export <declaration>`。你注意到区别了吗？使用默认导出时，你导出一个表达式，该表达式计算出一个值：导出的值。但使用命名导出时，你导出一个声明。一个函数声明、变量声明，甚至是一个类声明总是有一个名称，这就是导出值所使用的名称。你可以使用这种语法导出任意数量的声明。
- en: 'There’s an alternate syntax for named exports like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于命名导出，还有一个类似的语法：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This does the same thing but with a different syntax. The syntax is `export
    { binding1, binding2, ... }`. You can specify one name or a comma-separated list
    of as many as you want. When you export a value this way, you must use a name
    that points to a value (a binding). You can’t export a raw value this way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的功能相同，但使用了不同的语法。语法是 `export { binding1, binding2, ... }`。你可以指定一个名称或一个以逗号分隔的名称列表，数量不限。当你以这种方式导出一个值时，你必须使用一个指向值的名称（一个绑定）。你不能以这种方式导出一个原始值：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* OK**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* OK**'
- en: '***2* Syntax Error**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Syntax Error**'
- en: 'The benefit of this syntax is that it allows you to specify an alternate name
    to use for the export. Say internally you’re referring to a value as `formattedCurrentUsername`
    but you want to export it simply as `username`. You could do so like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的优点是它允许你指定一个用于导出的备用名称。比如说，在内部你将一个值称为 `formattedCurrentUsername`，但你想简单地将其导出为
    `username`。你可以这样做：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The syntax for this is `export { originalName as exportedName }`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的格式是 `export { originalName as exportedName }`。
- en: 'When exporting multiple values, you can either export them using individual
    export statements for each value as you declare them, or you can use one export
    statement and list all the names you want to export:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当导出多个值时，你可以为每个值使用单独的导出语句，就像你声明它们时一样，或者你可以使用一个导出语句并列出你想要导出的所有名称：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is equivalent to
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Whichever you decide is personal preference, although the majority of developers
    seem to prefer the first example.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你决定哪种方式，都是个人喜好，尽管大多数开发者似乎更喜欢第一个例子。
- en: 'The same thing works for variable declarations as it does for functions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这与函数声明一样适用于变量声明：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Exported as the name one**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Exported as the name one**'
- en: '***2* Exported as the name two**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Exported as the name two**'
- en: '***3* Invalid. No way to infer name.**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Invalid. No way to infer name.**'
- en: 'The export statement must be at the top level, meaning you can’t conditionally
    export values. By top level, I mean at the root of most of the body of code in
    the file, not inside the body of a block, `if` statement, function, and so on:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 导出语句必须位于顶层，这意味着你不能有条件地导出值。这里的顶层指的是文件主体代码的根部，而不是在代码块、`if` 语句、函数等内部：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Top level, valid**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Top level, valid**'
- en: '***2* Not top level, invalid**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Not top level, invalid**'
- en: 'This is by design: modules are meant to be statically analyzable and thus must
    always export and import the same way unconditionally. If a value were allowed
    to be exported in a function or `if` statement, that would mean that sometimes
    a value could be exported and sometimes not. Modules are designed to always have
    their exports executed, so they must be at the root level.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由设计决定的：模块旨在是静态可分析的，因此必须无条件地始终以相同的方式导出和导入。如果允许在函数或 `if` 语句中导出一个值，那么有时可以导出一个值，有时则不行。模块设计为始终执行其导出，因此它们必须位于顶层。
- en: Now when creating a module that exports multiple values, you may ask, should
    one of these be the default and the rest be named, or should all be named? There’s
    no cut-and-dry answer to that question. It really depends on how you’re designing
    your module. I would say as a rule of thumb, if everything you’re exporting is
    at the same level of importance, than use all named exports and no default. But
    if you have one thing that stands out as the main export and everything else sort
    of enhances or revolves around that main export, then it should be the default
    and everything else should be named exports. If you find yourself in a situation
    where you want to have several named exports but also two or more default exports,
    then your module is probably doing too much and should be broken down into smaller
    modules. We’ll cover techniques for breaking big modules into smaller modules
    in the next lesson.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当创建一个导出多个值的模块时，你可能想知道，其中之一是否应该是默认导出，其余的应该是命名导出，还是所有都应该命名为导出？这个问题没有一刀切的答案。这实际上取决于你如何设计你的模块。我可以说，作为一个经验法则，如果你导出的所有内容都是同等重要的，那么使用所有命名导出而没有默认导出。但是，如果你有一项内容作为主要导出，而其他所有内容都似乎增强或围绕这个主要导出，那么它应该是默认导出，其余的应该是命名导出。如果你发现自己处于想要有多个命名导出但又有两个或更多默认导出的情况，那么你的模块可能做得太多，应该分解成更小的模块。我们将在下一课中介绍将大模块分解成小模块的技术。
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 20.2**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 20.2**'
- en: '**[Q1:](kindle_split_032_split_002.xhtml#ch20qa4q0a1)**'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_032_split_002.xhtml#ch20qa4q0a1)**'
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following snippet there are two functions. Alter the code to make the
    function `ajax` the default export and export `setAjaxDefaults` by name.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下代码片段中，有两个函数。修改代码，使函数 `ajax` 成为默认导出，并通过名称导出 `setAjaxDefaults`。
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 20.2 answer**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 20.2 答案**'
- en: '**[A1:](kindle_split_032_split_002.xhtml#ch20qa3q1)**'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_032_split_002.xhtml#ch20qa3q1)**'
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 20.3\. When does a JavaScript file become a module?
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 20.3\. 当一个JavaScript文件成为模块时？
- en: 'If a module is just a file, what determines if a given JavaScript file is a
    module or not? The WHATWG (Web Hypertext Application Technology Working Group),
    the organization responsible for specifications for the web-specific JavaScript
    environment, has proposed a new script type module. Basically, when using a script
    tag, instead of using `type="javascript"` you would specify `type="module"` and
    the JavaScript loader used by browsers would know to execute this file as a module:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块只是一个文件，什么决定了给定的JavaScript文件是模块还是不是？负责制定特定于Web的JavaScript环境规范的WHATWG（Web
    Hypertext Application Technology Working Group）提出了一个新的脚本类型模块。基本上，当使用脚本标签时，你将指定
    `type="module"` 而不是 `type="javascript"`，浏览器使用的JavaScript加载器就会知道将此文件作为模块执行：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This wouldn’t work in Node.js, though, since it doesn’t use script tags or
    HTML. So there’s another proposal for inferring that a file is a module by whether
    or not it exports a value. To specify that a file is a module when it doesn’t
    export a value, you would use a named export without actually exporting anything:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Node.js中这不起作用，因为Node.js不使用脚本标签或HTML。因此，有一个提议，通过是否导出值来推断文件是否为模块。要指定当文件不导出值时它是模块，你会使用一个没有实际导出任何内容的命名导出：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* An empty export to signify this file is a module**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个空的导出，表示此文件是一个模块**'
- en: Don’t confuse this with exporting an object. This is the named export syntax
    where you would normally list your exports by name between the braces. Without
    naming anything, nothing gets exported, but with the proposal, it would identify
    the file as a module. If this proposal fails, the Node.js team plans to use the
    alternate file extension .mjs to specify the file is a module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将此与导出对象混淆。这是命名导出语法，你通常会通过括号列出你的导出名称。如果没有命名任何内容，则不会导出任何内容，但根据提议，它将识别该文件为模块。如果这个提议失败，Node.js团队计划使用替代文件扩展名
    .mjs 来指定文件是模块。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Further reading**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '[https://blog.whatwg.org/js-modules](https://blog.whatwg.org/js-modules)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blog.whatwg.org/js-modules](https://blog.whatwg.org/js-modules)'
- en: '[https://github.com/bmeck/UnambiguousJavaScriptGrammar](https://github.com/bmeck/UnambiguousJavaScriptGrammar)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/bmeck/UnambiguousJavaScriptGrammar](https://github.com/bmeck/UnambiguousJavaScriptGrammar)'
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this lesson, you learned to teach you how to create modules.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何创建模块。
- en: Exporting a declaration creates a named export.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出一个声明创建一个命名导出。
- en: Named exports can also be listed in braces.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名导出也可以在括号中列出。
- en: Named exports listed in braces can be exported using alternate names.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列在括号中的命名导出可以使用不同的名称导出。
- en: There can be several named exports, but only one default.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以有多个命名导出，但只能有一个默认导出。
- en: Export statements must be declared at the top (root) level.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出语句必须在顶层（根）级别声明。
- en: The keyword `this` is undefined at the root level.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根级别，关键字`this`是未定义的。
- en: Modules default to being in strict mode.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块默认处于严格模式。
- en: 'Let’s see if you got this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了：
- en: '**[Q20.1](kindle_split_050_split_014.xhtml#app01qa14q0a1)**'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q20.1](kindle_split_050_split_014.xhtml#app01qa14q0a1)**'
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create a module called luck_numbery.js. Give it an internal variable (not exported)
    called `luckyNumber`. Export a function called `guessLuckyNumber` as the default
    export that accepts a parameter called `guess`, checks to see if the guess is
    the same as `luckyNumber`, and returns `true` or `false` indicating if they made
    a correct guess.
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个名为luck_numbery.js的模块。给它一个内部变量（未导出），称为`luckyNumber`。导出一个名为`guessLuckyNumber`的默认导出函数，该函数接受一个名为`guess`的参数，检查猜测是否与`luckyNumber`相同，并返回`true`或`false`以指示是否猜对了。
- en: Lesson 21\. Using modules
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第21课\. 使用模块
- en: After reading [lesson 21](kindle_split_033_split_000.xhtml#ch21), you will
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第21课](kindle_split_033_split_000.xhtml#ch21)之后，你将
- en: Understand how to specify the location of a module you intend to use
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何指定你打算使用的模块的位置
- en: Understand all the various ways of importing values from modules
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解从模块中导入值的所有不同方式
- en: Understand how to import modules for side effects
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何导入模块以产生副作用
- en: Understand the order of execution of code when importing modules
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解导入模块时代码执行的顺序
- en: Be able to break apart large modules into smaller ones
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够将大型模块分解成更小的模块
- en: Modules are a great way to separate your logic into cohesive units and share
    logic across files without the cumbersome use of global variables. They also allow
    you to import only what is needed, keeping the cognitive load down and making
    maintenance easier. In the previous lesson you learned what a module is and the
    basics of how to create a module and export values. In this lesson we’ll look
    at using other modules, the various ways of importing values, and how to break
    apart and organize your code using modules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是分离你的逻辑到紧密单元并跨文件共享逻辑的好方法，而不必使用全局变量带来的繁琐。它们还允许你只导入所需的模块，降低认知负荷，并使维护更容易。在上一课中，你学习了什么是模块以及如何创建模块和导出值的基础知识。在本课中，我们将探讨使用其他模块、导入值的不同方式以及如何使用模块分解和组织你的代码。
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Imagine that you’re writing a web application and you need to use a few third-party
    open source libraries. The problem is that two of those libraries both expose
    themselves using the same global variable. How would you make the two libraries
    work together?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个Web应用程序，并且需要使用几个第三方开源库。问题是其中两个库都使用相同的全局变量暴露自己。你将如何使这两个库协同工作？
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 21.1\. Specifying a module’s location
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.1\. 指定模块的位置
- en: 'You import code from other module files using the `import` statement, which
    is made up of two key pieces, the *what* and the *where*. When you use the `import`
    statement, you must specify *what* (variables/values) you’re importing, and from
    *where* (the module file) you’re importing them. This is in contrast to including
    multiple files by using several `<script>` tags and communicating or sharing values
    across files by using global variables. The basic syntax is `import X from Y`
    where `X` specifies what you’re importing and `Y` specifies where the module is.
    A simple import statement may look like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`import`语句从其他模块文件导入代码，该语句由两个关键部分组成，即*what*和*where*。当你使用`import`语句时，你必须指定*what*（变量/值）你正在导入，以及*from
    where*（模块文件）你正在从哪里导入它们。这与使用多个`<script>`标签包含多个文件，并通过使用全局变量在文件之间通信或共享值的方式形成对比。基本语法是`import
    X from Y`，其中`X`指定了你正在导入的内容，`Y`指定了模块的位置。一个简单的导入语句可能看起来像这样：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then when you specify where or from what module you’re importing, you have
    to use a string literal value. The following is not valid:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后当你指定从哪里或从哪个模块导入时，你必须使用字符串字面量值。以下是不合法的：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Invalid because myModule is a variable, not a string literal**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 无效，因为myModule是一个变量，而不是一个字符串字面量**'
- en: You can’t use a variable to define where (`from`) the module is, even if that
    variable points to a string. You must use a string literal. This again is because
    all imports and exports in JavaScript are designed to be statically analyzable.
    All of your imports will be executed before any other code in the current file.
    JavaScript will scan your file, figure out all the imports, execute those files
    first, and then run your current file with the correct values imported. This means
    you couldn’t import based on a variable because that variable wouldn’t be defined
    yet!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用变量来定义模块的位置（`from`），即使该变量指向一个字符串。你必须使用字符串字面量。这再次是因为JavaScript中所有的导入和导出都是为了静态分析而设计的。你所有的导入都将先于当前文件中的任何其他代码执行。JavaScript将扫描你的文件，找出所有的导入，首先执行这些文件，然后使用导入的正确值运行你的当前文件。这意味着你不能基于变量导入，因为那个变量还没有定义！
- en: 'Other than using a string to determine where a module is, there aren’t any
    other rules set forth by JavaScript. There will be what are called *loaders* for
    each JavaScript environment (mainly the browser and Node.js), and those loaders
    will define what the string actually looks like. Loaders for the web and Node.js
    are still being figured out. Today, most people using ES6 modules are doing so
    using something such as Browserify or Webpack. Both of these tools treat a file
    path such as ./file or ./file.js as relative to the current file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用字符串来确定模块的位置之外，JavaScript没有规定其他规则。对于每个JavaScript环境（主要是浏览器和Node.js），都会有所谓的*加载器*，这些加载器将定义字符串的实际样子。Web和Node.js的加载器仍在开发中。今天，大多数使用ES6模块的人都在使用像Browserify或Webpack这样的工具。这两个工具都将文件路径，如`./file`或`./file.js`视为相对于当前文件：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Both are equivalent, specifying the relative path to the file.**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这两种方式都是等效的，指定了文件的相对路径。**'
- en: The file extension is optional and most people omit it. Without a file extension,
    the path could also be a directory containing an index.js.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 文件扩展名是可选的，大多数人省略它。没有文件扩展名，路径也可以是一个包含`index.js`的目录。
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Matches both ./src/file.js and ./src/file/index.js**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 匹配 ./src/file.js 和 ./src/file/index.js**'
- en: '***2* Matches only ./src/file.js**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 仅匹配 ./src/file.js**'
- en: Specifying a name without a path such as jquery would indicate that this is
    an installed module that should be looked for in the node_modules directory.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一个没有路径的名称，例如`jquery`，表示这是一个已安装的模块，应该在`node_modules`目录中查找。
- en: Now that you know how to specify where the module is, let’s take a look at how
    to specify *what* you want to import from it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何指定模块的位置，让我们看看如何指定你想要从它导入的内容。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 21.1**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.1**'
- en: '**[Q1:](kindle_split_033_split_001.xhtml#ch21qa2q0a1)**'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_033_split_001.xhtml#ch21qa2q0a1)**'
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Where would the presumed loader most likely look for the module files for the
    following imports:'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设的加载器最有可能在以下导入中查找模块文件：
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 21.1 answer**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.1 答案**'
- en: '**[A1:](kindle_split_033_split_001.xhtml#ch21qa1q1)**'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_033_split_001.xhtml#ch21qa1q1)**'
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From the file ./jquery.js or **.**/jquery/index.js relative to current file.
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从相对于当前文件的`./jquery.js`或`**.**/jquery/index.js`文件。
- en: From the `main` field specified in node_modules/lodash/package.json.
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`node_modules/lodash/package.json`中指定的`main`字段。
- en: From the file ./my/file.js or ./my/file/index.js relative to current file.
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从相对于当前文件的`./my/file.js`或`./my/file/index.js`文件。
- en: From either ./file.js or ./file/index.js relative to the `main` field specified
    in node_modules/my/package.json.
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从相对于`node_modules/my/package.json`中指定的`main`字段的`./file.js`或`./file/index.js`。
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 21.2\. Importing values from modules
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.2\. 从模块中导入值
- en: 'In the previous lesson you created a module for formatting currency strings.
    It had a single `default` export of a function to achieve this like so:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一课中，你创建了一个用于格式化货币字符串的模块。它有一个单独的`default`导出，用于实现此功能，如下所示：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s say you put this module in the location ./utils/format/currency.js and
    want to import the `currency` function to format some currencies in the shopping
    cart system you’re building. You could do so using the following `import` statement:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将这个模块放在`./utils/format/currency.js`的位置，并想导入`currency`函数来格式化你正在构建的购物车系统中的某些货币。你可以使用以下`import`语句来完成：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* You’re importing the default value.**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你正在导入默认值。**'
- en: 'Notice how the name of the function was `currency` but you imported using the
    name `formatCurrency`. When you say `import <name>` you’re deciding what name
    to use, just like when you use `var <name>`, `const <name>`, or `let <name>`,
    only instead of assigning a value using the equals sign, you’re importing a value
    from another file, a module. You can use any name you want when importing the
    default value from a module, as you can see in the following silly example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数的名称是 `currency`，但你使用 `formatCurrency` 名称导入。当你说 `import <name>` 时，你是在决定使用什么名称，就像你使用
    `var <name>`、`const <name>` 或 `let <name>` 一样，只是你用等号分配值，而不是从另一个文件、一个模块中导入值。当你从模块中导入默认值时，你可以使用任何你想要的名称，如下面的愚蠢示例所示：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The previous two examples would behave exactly the same, assuming there were
    no changes to the ./utils/format/currency module they were importing from. Remember
    the analogy from the previous lesson: If you were to think of a module as a function,
    the default export would be analogous to the `return` value from the function.
    If we continue to use this analogy, importing the default value would be like
    assigning the `return` value of a function to a variable:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例的行为将完全相同，假设它们导入的 ./utils/format/currency 模块没有发生变化。记住上一课中的类比：如果你把模块想象成一个函数，默认导出就相当于函数的
    `return` 值。如果我们继续使用这个类比，导入默认值就像将函数的 `return` 值分配给一个变量：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice how the `getValue` function returned a variable called `value`, and it
    didn’t matter if you assigned that to a matching named variable, or a variable
    with a completely different name such as `whatchamacallit`. This is because the
    function only returns a single value, and you’re merely capturing that value and
    deciding on a name to store it. This is the same when you import a default value
    from a module. The module can only export a single default value, and it only
    exports the value, so when you import it, you specify any name you want for storing
    that value.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `getValue` 函数返回了一个名为 `value` 的变量，并且将这个值分配给一个匹配的命名变量，或者一个完全不同的变量名，比如 `whatchamacallit`，都没有关系。这是因为该函数只返回一个值，而你只是捕获这个值并决定一个名称来存储它。当你从模块中导入默认值时也是这样。模块只能导出一个默认值，并且它只导出值，所以当你导入它时，你可以指定任何你想要的名称来存储这个值。
- en: 'Now as you learned in the previous lesson, in addition to a single default
    export, a module can also have one or more named exports. As the name implies,
    with these the name does matter. One of the syntaxes you learned in the previous
    lesson for named exports was the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在上一课中学到了，除了单个默认导出之外，一个模块还可以有一个或多个命名导出。正如其名所示，在这些情况下，名称确实很重要。你在上一课中学到的命名导出的语法之一如下：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Conveniently, the syntax to import these is similar:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 便利的是，导入这些值的语法类似：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here the names `currency` and `number` must match the names they were exported
    as. But you can specify a different name to assign them to:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`currency` 和 `number` 名称必须与它们导出的名称相匹配。但你可以指定不同的名称来分配给它们：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Specified to import number but assign it to the name formatter**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 指定导入 number 但将其分配给格式化器名称**'
- en: 'This is handy if you’re importing named values from multiple modules that export
    using the same name. Say, for example, that you’re importing a function called
    `fold` from a functional tools module, but also importing a function called `fold`
    from an origami module. You could use `as` to map one or both of the imports to
    a different name to avoid naming conflicts:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这在从多个使用相同名称导出的模块中导入命名值时很有用。比如说，如果你从一个功能工具模块中导入名为 `fold` 的函数，同时也从折纸模块中导入名为 `fold`
    的函数。你可以使用 `as` 来将一个或两个导入映射到不同的名称，以避免命名冲突：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* fold is imported under the name reduce to avoid conflict with the other
    imported value.**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 fold 导入为 reduce 名称以避免与其他导入值冲突。**'
- en: 'If you want to import all of the named exports from a module, you can do so
    using the asterisk like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从模块中导入所有命名导出，你可以使用星号这样做：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* A new object named format is created and assigned all the values from
    the module.**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建了一个名为 format 的新对象，并分配了模块中的所有值。**'
- en: This will create a new object with properties correlating to all the named exports
    from the module. This is handy if you need to import all values a module exports,
    possibly for introspection or testing, but normally you should only import what
    you’re going to use. Even if you happen to be using everything that a module exports,
    it doesn’t necessarily mean that you’ll continue to use everything from that module
    as it grows.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新对象，其属性与模块中所有命名导出相关联。如果你需要导入模块导出的所有值，可能用于内省或测试，但通常你应该只导入你将要使用的值。即使你碰巧使用了模块导出的所有内容，这也不一定意味着你将继续使用该模块的所有内容，因为它会不断增长。
- en: Imagine, for example, that the format module only exported the format functions
    `currency` and `date`, and you need both for your product module, so you import
    them all using the asterisk. But later as you’re building your application, you
    continue to add new format functions to your format module. You don’t need these
    new functions in your product module, but since you were importing using the asterisk,
    you’re going to continue to get them all, not just the ones you’re using. Some
    situations may require you to import everything, but as a general rule, you should
    be explicit in what you import by specifying each value by name.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果格式模块只导出了 `currency` 和 `date` 格式函数，而你需要这两个函数来构建你的产品模块，所以你使用星号导入它们。但后来在构建你的应用程序时，你继续向格式模块添加新的格式函数。你不需要这些新函数在你的产品模块中，但由于你使用星号导入，你将继续获得所有这些函数，而不仅仅是那些你正在使用的函数。某些情况下可能需要导入所有内容，但作为一般规则，你应该通过指定每个值的名字来明确指定你导入的内容。
- en: 'When importing all values using the asterisk, this doesn’t include the default
    export, just the named exports. You can combine importing the default and named
    exports from a module by separating them with a comma:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用星号导入所有值时，这不包括默认导出，只包括命名导出。你可以通过逗号分隔来组合从模块导入默认导出和命名导出：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* The default value gets named App and all the named exports are set as
    properties of a newly created object called parts.**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 默认值被命名为 App，所有命名导出都被设置为名为 parts 的新创建对象上的属性。**'
- en: '***2* The default value gets named autoFormat and the value exported by the
    name number gets named numberFormat.**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 默认值被命名为 autoFormat，而按名称导出的值被命名为 numberFormat。**'
- en: Once you import a value from a module, it doesn’t create a binding like when
    declaring a variable. In the next section we’ll look at how that works.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从模块中导入一个值，它不会创建像声明变量时的绑定。在下一节中，我们将探讨它是如何工作的。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.2**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.2**'
- en: '**[Q1:](kindle_split_033_split_002.xhtml#ch21qa4q0a1)**'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_033_split_002.xhtml#ch21qa4q0a1)**'
- en: ''
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the following `import` statement, which is the default import and which is
    the named import?
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在下面的 `import` 语句中，哪个是默认导入，哪个是命名导入？
- en: ''
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.2 answer**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.2 答案**'
- en: '**[A1:](kindle_split_033_split_002.xhtml#ch21qa3q1)**'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_033_split_002.xhtml#ch21qa3q1)**'
- en: ''
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`lodash` is the default import and `toPairs` is the named import.'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`lodash` 是默认导入，`toPairs` 是命名导入。'
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.3\. How imported values are bound
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.3\. 导入值的绑定方式
- en: 'Both default and named imports create read-only values, meaning you can’t reassign
    a value once it’s imported:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 默认导入和命名导入都创建只读值，这意味着一旦导入，就不能重新分配值：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Error: ajax is read only**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 错误：ajax 只读**'
- en: But named imports, unlike default imports, are bound directly to the variables
    that were exported. This means that if the variable changes in the file (module)
    that exported it, it will also change in the file that imported it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但与默认导入不同，命名导入直接绑定到导出的变量。这意味着如果导出它的文件（模块）中的变量发生变化，导入它的文件中的变量也会发生变化。
- en: 'Let’s imagine a module that exports a variable named `title` that has an initial
    value but also exports a function called `setTitle` that allows you to change
    the title like so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个导出一个名为 `title` 的变量的模块，该变量有一个初始值，同时也导出一个名为 `setTitle` 的函数，允许你像这样更改标题：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you were to import both, you couldn’t directly change the value of `title`
    via assignment, but you could indirectly change the value of `title` by calling
    `setTitle`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入这两个值，你不能直接通过赋值更改 `title` 的值，但你可以通过调用 `setTitle` 来间接更改 `title` 的值：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* “Java”**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* “Java”**'
- en: '***2* “Script”**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* “脚本”**'
- en: This is very different from how you’re used to retrieving values in JavaScript.
    Normally when you retrieve a value in JavaScript—either from a function call or
    destructuring or some other expression—and you assign it to a variable, you’re
    retrieving the value, and creating a new binding pointing to that value. But when
    you import values from modules, you’re importing not just the value but also the
    binding. This is why the module can internally change the value and your imported
    variable will reflect the change.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你在 JavaScript 中通常检索值的方式非常不同。通常当你从函数调用、解构或其他表达式中检索值并将其赋给变量时，你正在检索该值，并创建一个指向该值的新绑定。但是当你从模块中导入值时，你导入的不仅是值，还有绑定。这就是为什么模块可以内部更改值，而你导入的变量将反映这种变化。
- en: Once the value changes, it not only changes in the current file and the file
    that exported the value, but it also changes in all files that imported that value.
    On top of that, there’s no notification that the value changed. There’s no event
    broadcasting the change. It changes silently, so take care when changing values
    that you’ve exported.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦值发生变化，它不仅会在当前文件和导出值的文件中变化，还会在导入该值的所有文件中变化。除此之外，没有通知值已更改。没有事件广播更改。它默默地改变，所以在更改导出的值时要小心。
- en: In the next section, you’ll learn how and why you would import a module without
    importing any values at all.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习为什么以及如何导入一个模块而不导入任何值。
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.3**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.3**'
- en: '**[Q1:](kindle_split_033_split_003.xhtml#ch21qa6q0a1)**'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_033_split_003.xhtml#ch21qa6q0a1)**'
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are five bindings in the following snippet. Which ones can be reassigned
    values in the shown context?
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在以下片段中有五个绑定。在所示上下文中，哪些可以重新赋值？
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.3 answer**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.3 答案**'
- en: '**[A1:](kindle_split_033_split_003.xhtml#ch21qa5q1)**'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_033_split_003.xhtml#ch21qa5q1)**'
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Only d and e.
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有 d 和 e。
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.4\. Importing side effects
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.4\. 引入副作用
- en: Sometimes you just want to import a module for side effects, meaning you want
    the code in the module to execute, but you don’t need a reference to use any values
    from that module. An example of this would be a module that contains the code
    that sets up Google Analytics. You wouldn’t need any values from such a module;
    you just need to execute so it can set itself up.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你只想导入一个模块以产生副作用，这意味着你希望模块中的代码执行，但你不需要引用来使用该模块中的任何值。一个例子是包含设置 Google Analytics
    代码的模块。你不需要从这样的模块中获取任何值；你只需要执行，以便它可以设置自己。
- en: 'You can import a module for side effects like so:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样导入一个模块以产生副作用：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It’s just like any other import; you omit any default or named values and you
    omit the keyword `from` as well. When you import a file for side effects, all
    of the code from the module you import will execute before any of the code in
    the file from which you imported it. This is regardless of where the import happens:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像任何其他导入一样；你省略任何默认或命名的值，也省略了关键字 `from`。当你为了副作用导入一个文件时，你导入的模块中的所有代码都会在你导入的文件中的任何代码之前执行。这无论导入发生在哪里：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the previous example, all of the code in the module my_script is executed
    before the `setup()` function is executed, even though it’s imported afterward.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，模块 my_script 中的所有代码在 `setup()` 函数执行之前就已经执行了，即使它是后来导入的。
- en: In the next section we’ll take a look at organizing and grouping smaller modules
    into bigger modules.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何将较小的模块组织并分组到较大的模块中。
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.4**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.4**'
- en: '**[Q1:](kindle_split_033_split_004.xhtml#ch21qa8q0a1)**'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_033_split_004.xhtml#ch21qa8q0a1)**'
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume the module log_b contains the statement `console.log('B')`. After running
    the following code, what will be the order of the output?
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设模块 log_b 包含语句 `console.log('B')`。在运行以下代码后，输出的顺序将是什么？
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.4 answer**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.4 答案**'
- en: '**[A1:](kindle_split_033_split_004.xhtml#ch21qa7q1)**'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_033_split_004.xhtml#ch21qa7q1)**'
- en: ''
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: B, A, C
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: B, A, C
- en: '|  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 21.5\. Breaking apart and organizing modules
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 21.5\. 分解和组织模块
- en: Sometimes a module will grow too big, and it may make sense to break it apart
    into smaller modules. But you may have a large code base that’s already using
    this module all over the place. You want to refactor this module into smaller,
    more focused modules, but you don’t want to have to refactor your entire application
    because of it. Let’s explore how you can take a module that’s already in use and
    break it down into smaller chunks without having any effect on the rest of your
    application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个模块会变得太大，可能需要将其分解成更小的模块。但你可能有一个已经大量使用该模块的大型代码库。你想要将这个模块重构为更小、更专注的模块，但你不希望因为这一点而不得不重构整个应用程序。让我们探讨如何将一个已经使用的模块分解成更小的块，而不会对应用程序的其他部分产生影响。
- en: Let’s assume you have a format module. It starts off small with just a few format
    functions, but as the application grows, you continue to need new formatters for
    different needs. Some formatters share logic, while others need their own helper
    functions. Keeping all of this in a single module has grown too complex. For brevity
    let’s assume four formatters, as shown in the following listing; in a real application,
    it could be many more.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个格式模块。它最初很小，只有几个格式化函数，但随着应用程序的增长，你继续需要为不同的需求创建新的格式化器。一些格式化器共享逻辑，而其他格式化器需要它们自己的辅助函数。将所有这些放在一个模块中已经变得过于复杂。为了简洁起见，让我们假设有四个格式化器，如下面的列表所示；在实际应用程序中，可能还有更多。
- en: Listing 21.1\. src/format.js
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.1\. src/format.js
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now let’s assume many modules are using these, such as the following product
    module.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设许多模块正在使用这些模块，例如以下产品模块。
- en: Listing 21.2\. src/product.js
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.2\. src/product.js
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This product module is just one of many that are using formatters. You want
    to refactor your format module in a way that won’t break this one or any others.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个产品模块只是使用格式器的许多模块之一。你想要以不会破坏这个模块或任何其他模块的方式重构你的格式模块。
- en: Break the module into two separate modules, one for numbers and one for dates,
    and group them in a format folder.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块分解成两个独立的模块，一个用于数字，一个用于日期，并将它们分组在格式文件夹中。
- en: Here’s the date format module.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是日期格式模块。
- en: Listing 21.3\. src/format/date.js
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.3\. src/format/date.js
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: And here’s the number format module.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是数字格式模块。
- en: Listing 21.4\. src/format/number.js
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.4\. src/format/number.js
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You’ve nicely broken your large format module into smaller, more focused, modules.
    But to make use of these, you would have to refactor all of the other modules,
    like the product module, that are importing values. You want to prevent that.
    Create another index module inside the format module that imports the values from
    the more focused modules and exports them, as shown in the next listing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经很好地将大型模块分解成更小、更专注的模块。但为了使用这些模块，你必须重构所有其他导入值的模块，比如产品模块。你想要避免这种情况。在格式模块内部创建另一个索引模块，从更专注的模块中导入值并导出它们，如下面的列表所示。
- en: Listing 21.5\. src/format/index.js
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.5\. src/format/index.js
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is great because now when other modules try to import from ./src/format,
    it will actually import from ./src/format/index.js if ./src/format.js isn’t found.
    This means you no longer need to refactor any of the other modules. This is a
    great argument for omitting the file extension when specifying module paths in
    your imports, because if you had specified the file extension, this refactoring
    would have been much more painful.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为现在当其他模块尝试从 ./src/format 导入时，如果找不到 ./src/format.js，它实际上会从 ./src/format/index.js
    导入。这意味着你不再需要重构任何其他模块。这是省略在导入模块路径时指定文件扩展名的绝佳论据，因为如果你指定了文件扩展名，这次重构将会痛苦得多。
- en: This type of organization is so common that there’s actually a syntax directly
    for it. The src/format/index.js module could be written like so.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组织方式非常常见，实际上有一个直接用于它的语法。src/format/index.js 模块可以写成如下所示。
- en: Listing 21.6\. src/format/index.js
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.6\. src/format/index.js
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If your only use for a value you’re importing is to turn around and export it,
    you can skip a step and export it directly from that module! Now, the format module
    is always supposed to export all the values from all the more focused formatters,
    right? Well instead of having to list all the names and then come back and add
    names for any new formatters you add in the future, you can export them all like
    so.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导入一个值只是为了将其导出，你可以跳过一步，直接从该模块导出！现在，格式模块总是应该导出所有更专注格式化器的值，对吧？嗯，与其列出所有名称然后回来添加任何未来添加的新格式化器的名称，不如可以这样导出所有值。
- en: Listing 21.7\. src/format/index.js
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 21.7\. src/format/index.js
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Cool! With this simple facade type module, you’ve successfully and quite elegantly
    broken your large module into much smaller and more focused modules, and you did
    it seamlessly in a way that’s opaque to the rest of the application!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过这个简单的外观类型模块，你成功且优雅地将大型模块分解成更小、更专注的模块，而且你以对应用程序其余部分透明的方式无缝地做到了这一点！
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 21.5**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 21.5**'
- en: '**[Q1:](kindle_split_033_split_005.xhtml#ch21qa10q0a1)**'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](kindle_split_033_split_005.xhtml#ch21qa10q0a1)**'
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assume you are going to add another module at ./src/format/word and update the
    index file to export all of the word formatters.
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你将在 ./src/format/word 添加另一个模块，并更新索引文件以导出所有单词格式化器。
- en: '|  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 21.5 answer**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 21.5 答案**'
- en: '**[A1:](kindle_split_033_split_005.xhtml#ch21qa9q1)**'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[A1:](kindle_split_033_split_005.xhtml#ch21qa9q1)**'
- en: ''
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: In this lesson, you learned how to use and organize modules.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何使用和组织模块。
- en: Default imports can be set using any name.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认导入可以使用任何名称进行设置。
- en: Named imports are listed in braces, similar to how they’re exported.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名导入以大括号列出，类似于它们的导出方式。
- en: Named imports must specify the correct name.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名导入必须指定正确的名称。
- en: Named imports can use alternate names via `as` after specifying the correct
    name.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名导入可以在指定正确名称后通过 `as` 使用别名。
- en: You can import all named values using an `*`.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `*` 导入所有命名值。
- en: Named imports are direct bindings (not just references) to the exported variables.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名导入是直接绑定（不仅仅是引用）到导出的变量。
- en: Default imports aren’t direct bindings but are still read-only.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认导入不是直接绑定，但仍然是只读的。
- en: Values can be exported directly from other modules.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值可以直接从其他模块导出。
- en: 'Let’s see if you got this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这些：
- en: '**[Q21.1](kindle_split_050_split_015.xhtml#app01qa15q0a1)**'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q21.1](kindle_split_050_split_015.xhtml#app01qa15q0a1)**'
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make a module that imports the luck_numbery.js from the previous lesson and
    attempts to guess the lucky number and log how many attempts it made before guessing
    the correct number.
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个模块，从上一课导入 luck_numbery.js，并尝试猜测幸运数字，并记录在猜对数字之前它尝试了多少次。
- en: 'Lesson 22\. Capstone: Hangman game'
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第22课：综合项目：猜字游戏
- en: In this capstone you’re going to build a hangman game. The game will incorporate
    a status message, letter slots for the word, and buttons for guessing letters
    ([figure 22.1](kindle_split_034_split_000.xhtml#ch22fig01)).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合项目中，你将构建一个猜字游戏。游戏将包含状态信息、单词的字母槽和猜测字母的按钮（[图22.1](kindle_split_034_split_000.xhtml#ch22fig01)）。
- en: 'You’ll start your project using the start folder included in the code accompanying
    this book. If at anytime you get stuck, you can also check out the final folder
    with the completed game. The start folder is a project already set up to use Babel
    and Browserify (see [lessons 1](kindle_split_009_split_000.xhtml#ch01)–[3](kindle_split_011_split_000.xhtml#ch03));
    you just need to run `npm install` to get set up. If you haven’t read [lessons
    1](kindle_split_009_split_000.xhtml#ch01)–[3](kindle_split_011_split_000.xhtml#ch03),
    you should before doing this capstone. There’s also an included index.html file:
    this is where the game will run. It already includes all the HTML and CSS it needs;
    you just need to open it in a browser once you bundle your JavaScript files. The
    src folder is where you’ll put all your JavaScript files, and the dest folder
    is where the bundled JavaScript file will go after you run `npm run build`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用本书附带代码中的 start 文件夹开始你的项目。如果你在任何时候遇到困难，你还可以查看包含完成游戏的最终文件夹。start 文件夹是一个已经设置好以使用
    Babel 和 Browserify 的项目（见[第1课](kindle_split_009_split_000.xhtml#ch01)–[第3课](kindle_split_011_split_000.xhtml#ch03)）；你只需要运行
    `npm install` 来设置。如果你还没有阅读[第1课](kindle_split_009_split_000.xhtml#ch01)–[第3课](kindle_split_011_split_000.xhtml#ch03)，你应该在完成这个综合项目之前先阅读。还有一个包含的
    index.html 文件：这是游戏将运行的地方。它已经包含了所需的全部 HTML 和 CSS；你只需要在捆绑你的 JavaScript 文件后，在浏览器中打开它。src
    文件夹是放置你所有 JavaScript 文件的地方，dest 文件夹是在你运行 `npm run build` 后捆绑的 JavaScript 文件将放置的地方。
- en: Figure 22.1\. A hangman game
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图22.1. 猜字游戏
- en: '![](Images/22fig01.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/22fig01.jpg)'
- en: 22.1\. Planning
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1. 规划
- en: You’re going to break your game into several modules, so it makes sense to start
    by identifying what modules you’re going to break the game into. Before you can
    start the game, you’ll need a random word. It makes sense to create a module for
    generating random words. Second, you’ll need to keep track of the status of your
    game—whether the game was won, lost, and so on. So you’ll need a status module
    as well. There will be three parts of the UI that need to be displayed to the
    user. First is a representation of the game’s status; call this *status-display*.
    You’ll also need to show the letter slots for the word the player is guessing;
    call this *letter-slots*. The third UI element you’ll need will be buttons for
    each letter of the alphabet so the player can make their guesses. Call this module
    *keyboard*. Finally, you’ll need the glue that puts all these modules together
    to create the actual game. There won’t be much glue so you’ll just do this in
    the *index*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把你的游戏分成几个模块，所以首先确定你要把游戏分成哪些模块是有意义的。在你开始游戏之前，你需要一个随机单词。创建一个用于生成随机单词的模块是有意义的。其次，你需要跟踪你的游戏状态——游戏是否获胜、失败等等。所以你还需要一个状态模块。用户界面需要显示三个部分。首先是游戏状态的表示；称之为
    *status-display*。你还需要显示玩家猜测的单词的字母槽；称之为 *letter-slots*。第三个 UI 元素是你需要的字母按钮模块，以便玩家可以进行猜测。称之为
    *keyboard*。最后，你需要将这些模块粘合在一起以创建实际的游戏。粘合剂不会很多，所以你只需在 *index* 中完成。
- en: 22.2\. The words module
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.2\. 单词模块
- en: Start with a simple function that just returns an array of words.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个简单的函数开始，该函数仅返回一个单词数组。
- en: Listing 22.1\. src/words.js
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.1\. src/words.js
- en: '[PRE52]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* The function accepts a callback as a parameter.**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 函数接受一个回调作为参数。**'
- en: '***2* Invoke the callback with your array of words.**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 使用你的单词数组调用回调函数。**'
- en: Instead of returning an array of words, you use a callback to pass back an array
    of words. In its current state, that might not make sense, but this will allow
    rewriting the `getWords` function later to use an AJAX request to get words from
    an API or some external resource.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你不是返回一个单词数组，而是使用回调函数来返回一个单词数组。在其当前状态下，这可能没有意义，但这将允许稍后重写 `getWords` 函数，以使用 AJAX
    请求从 API 或其他外部资源获取单词。
- en: Now that you have your words, you need a function that will return a random
    word, as shown in the following listing.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了你的单词，你需要一个函数来返回一个随机单词，如下所示。
- en: Listing 22.2\. src/words.js
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.2\. src/words.js
- en: '[PRE53]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Pass a cb to getWords.**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 将 cb 传递给 getWords。**'
- en: '***2* Get a random word from the words array.**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 从单词数组中获取一个随机单词。**'
- en: '***3* Invoke the callback given to getRandomWord with your random word.**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* 使用你的随机单词调用 getRandomWord 传递给它的回调函数。**'
- en: This is it for your words module. You only exported the `getRandomWord` function
    from the module because the rest of the game won’t need an array of words, just
    a single random word at a time. Also since you only exported a single function,
    you set it as the default export. Next you’ll build the status module.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的单词模块的全部内容。你只从模块中导出了 `getRandomWord` 函数，因为游戏的其他部分不需要单词数组，只需要一次一个随机单词。此外，因为你只导出了一个函数，所以将其设置为默认导出。接下来，你将构建状态模块。
- en: 22.3\. The status module
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.3\. 状态模块
- en: 'There are four statuses that you’ll use for the game: how many guesses are
    remaining, whether or not the player has won, whether or not the player has lost,
    and whether or not the game is still in play (when they still have guesses remaining
    and they haven’t won or lost). The random word along with the player’s guesses
    will be needed to determine any of these statuses, so you’ll export a function
    for each one that accepts the current word and guesses as parameters.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，你将使用四种状态：剩余多少次猜测、玩家是否获胜、玩家是否失败，以及游戏是否仍在进行（当他们还有剩余猜测且未获胜或失败时）。为了确定这些状态，需要随机单词以及玩家的猜测，因此你需要为每个状态导出一个函数，该函数接受当前单词和猜测作为参数。
- en: Listing 22.3\. src/status.js
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.3\. src/status.js
- en: '[PRE54]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* You don’t need to export this because nothing else should need it.**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1* 你不需要导出这个函数，因为其他东西不应该需要它。**'
- en: '***2* Find all the letters that have been guessed and aren’t in the word.**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2* 找出所有被猜测但不在单词中的字母。**'
- en: '***3* Determine if all the letters in the word have been guessed.**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3* 确定单词中的所有字母是否都被猜测。**'
- en: '***4* If the game hasn’t been won and there are no guesses yet it’s game over.**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4* 如果游戏未获胜且没有猜测，则游戏结束。**'
- en: '***5* As long as there are guesses and the game hasn’t been won or lost, the
    player is still playing.**'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 只要还有猜测，游戏还没有被赢得或输掉，玩家仍在玩游戏。**'
- en: Notice how you didn’t export the `MAX_INCORRECT_GUESSES` constant. This is because
    nothing else will use it, and you should only export what’s needed by other modules
    and nothing more to keep the API surface as small as possible, which will make
    future changes and debugging easier. The other four functions will all be used
    by other modules to make the game work, so you export all of them. That doesn’t
    mean you should always export every function, though. If one of these functions
    used a helper function to determine its value, you wouldn’t export such a helper
    function because it wouldn’t need to be used elsewhere.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你没有导出`MAX_INCORRECT_GUESSES`常量。这是因为没有其他东西会使用它，你应该只导出其他模块所需的内容，而不是更多，以使API表面尽可能小，这将使未来的更改和调试更容易。其他四个函数都将被其他模块使用以使游戏工作，所以你导出所有这些函数。但这并不意味着你应该总是导出每个函数。如果这些函数中的任何一个使用了辅助函数来确定其值，你就不会导出这样的辅助函数，因为它不需要在其他地方使用。
- en: You may be asking yourself, why pass around the `word` and `guesses` as function
    arguments? Why not just import them? You could do that and it would work. But
    doing so would tightly couple all the individual modules to the main game logic
    (where the word and guesses get stored), which would make them much harder to
    isolate and test. In this small game you won’t be adding any tests, but it’s still
    a good practice.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，为什么要把`word`和`guesses`作为函数参数传递？为什么不直接导入它们？你可以这样做，并且它将工作。但是这样做会将所有单个模块紧密耦合到主游戏逻辑（单词和猜测存储的地方），这将使它们更难隔离和测试。在这个小型游戏中，你不会添加任何测试，但这仍然是一个好习惯。
- en: 'Next we’ll focus on the three UI elements: the status display, the letter slots,
    and the keyboard.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将关注三个UI元素：状态显示、字母槽位和键盘。
- en: 22.4\. The game’s interface modules
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.4. 游戏界面模块
- en: 'As we said before, you have three pieces of UI: the status display that will
    show how many guesses are left or if the game is over or won, the letter slots,
    and the keyboard. You could make a single UI module that exports each one; that
    wouldn’t be wrong, but I would prefer to put each into its own module. They don’t
    share any logic or have anything else that would suggest they belong together
    other than all being parts of the UI, so I think this makes the most sense. I
    would prefer a few simple modules over a single more complicated one, and if you
    later decided to add more pieces of UI, it would further suggest that each one
    should be its own module.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，你有三个UI部分：将显示剩余猜测次数或游戏是否结束或赢得游戏的状况显示，字母槽位和键盘。你可以创建一个单独的UI模块来导出每一个；这并不错，但我更愿意将每个部分放入它自己的模块中。它们没有共享任何逻辑或任何其他表明它们应该在一起的东西，除了都是UI的一部分，所以我认为这样做最有意义。我更愿意有几个简单的模块而不是一个更复杂的模块，如果你后来决定添加更多的UI部分，这也会进一步表明每个部分都应该是一个单独的模块。
- en: Each UI module will export a single function that returns the HTML (as a string)
    representing that part of the game’s interface. All the UI modules will require
    the player’s guesses, while the status display and letter slots will also require
    the current random word. So they’ll also accept them as parameters similar to
    the status module.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 每个UI模块将导出一个函数，该函数返回表示游戏界面部分的HTML（作为字符串）。所有UI模块都将需要玩家的猜测，而状态显示和字母槽位还需要当前随机单词。因此，它们也将接受与状态模块类似的参数。
- en: OK, so you have a simple API that each UI module will adhere to. It will export
    a single function (you’ll make it a default export) and that function will accept
    the data it needs and return a string of HTML. Start with the status display module.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以你有一个简单的API，每个UI模块都将遵循。它将导出一个函数（你将使其成为默认导出），该函数将接受所需的数据并返回一个HTML字符串。从状态显示模块开始。
- en: Listing 22.4\. /src/status_display.js
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表22.4. /src/status_display.js
- en: '[PRE55]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Import all values into a single status object.**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将所有值导入到一个单独的状态对象中。**'
- en: '***2* Invoke the imported functions from the generated status object.**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从生成的状态对象中调用导入的函数。**'
- en: The status display will need most of the status functions, so instead of individually
    importing them, import everything from the status module and group it all together
    into a generated `status` object. You then can invoke any of the functions directly
    from the created `status` object.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 状态显示将需要大多数状态函数，所以不是单独导入它们，而是从状态模块导入所有内容，并将它们全部组合成一个生成的`status`对象。然后你可以直接从创建的`status`对象中调用任何函数。
- en: Other than that, this module is pretty simple. It just generates a message determined
    by the status of the game. Next you’ll build the letter slots module.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个模块之外，这个模块相当简单。它只是根据游戏状态生成一条消息。接下来，你将构建字母槽模块。
- en: Listing 22.5\. /src/letter_slots.js
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.5\. /src/letter_slots.js
- en: '[PRE56]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This module is simple as well: you generate a bunch of spans corresponding
    to each letter in the word. The span will either be empty or reveal the letter,
    depending on whether the player has guessed that letter or not. Again you export
    our one default function as planned. Now do the final bit of UI, the keyboard
    module, as shown in the next listing.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块也很简单：你生成与单词中的每个字母对应的多个 span。span 要么为空，要么揭示字母，这取决于玩家是否猜对了那个字母。再次按照计划导出我们的一个默认函数。现在完成最后的
    UI 部分，即键盘模块，如下列所示。
- en: Listing 22.6\. /src/keyboard.js
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.6\. /src/keyboard.js
- en: '[PRE57]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* A quick way to get an array of all the letters in the alphabet**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取所有字母表字母数组的快捷方式**'
- en: '***2* You want the first 13 letters in the first row and the last 13 in the
    last row.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你想要第一行的前 13 个字母和最后一行的最后 13 个字母。**'
- en: '***3* If the letter was guessed, you don’t want to give them the option to
    guess it again, so use a span.**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果字母已被猜中，你不想让他们再次猜测，所以使用 span。**'
- en: '***4* If the letter wasn’t guessed, you used a button to allow them to select
    it.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果字母未被猜中，你使用按钮允许他们选择它。**'
- en: '***5* Map each letter into a button or span depending on whether the letter
    was guessed.**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 根据字母是否被猜中，将每个字母映射到按钮或 span。**'
- en: 'This module is also pretty simple: it generates a list of all the letters in
    the alphabet, making the letters that haven’t been guessed yet as buttons and
    the letters that have been guessed as spans.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块也很简单：它生成所有字母表中的字母列表，将尚未被猜中的字母作为按钮，将已被猜中的字母作为 span。
- en: That’s all the UI you’ll need. In the next section you’ll put it all together
    and create a working game.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是你需要的所有 UI。在下一节中，你将把它们全部组合起来，创建一个可工作的游戏。
- en: 22.5\. The index
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.5\. 索引
- en: The index is the entry point of your application. Here you’ll orchestrate all
    the individual modules, creating a functional game. First import everything you’re
    going to need, as shown in the next listing.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是应用程序的入口点。在这里，你将协调所有单个模块，创建一个功能游戏。首先，像下一个列表中所示，导入你需要的所有内容。
- en: Listing 22.7\. /src/index.js
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.7\. /src/index.js
- en: '[PRE58]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You import the default function from the words module as well as all the UI
    modules. But you only need the `isStillPlaying` function from the status module
    to determine if you should still interact with the player.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你还从单词模块导入默认函数以及所有 UI 模块。但你只需要从状态模块中导入 `isStillPlaying` 函数，以确定你是否应该继续与玩家交互。
- en: In the next listing you just need to make a function that renders the actual
    game.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，你只需要创建一个渲染实际游戏的函数。
- en: Listing 22.8\. /src/index.js
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.8\. /src/index.js
- en: '[PRE59]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here you invoke each of the UI functions you imported and use `innerHTML`^([[1](kindle_split_034_split_005.xhtml#ch22fn01)])
    to insert them into your web page where needed. You don’t need any other logic
    for the interface because each UI module handles that itself using the word and
    guesses. So the only other things you need to do are get a random word, listen
    for button clicks, and add each guess to a list of guesses, as the following listing
    shows.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你调用导入的每个 UI 函数，并使用 `innerHTML`^([[1](kindle_split_034_split_005.xhtml#ch22fn01)])
    将它们插入到网页的所需位置。你不需要任何其他界面逻辑，因为每个 UI 模块都会自己处理单词和猜测。所以你唯一需要做的事情就是获取一个随机单词，监听按钮点击，并将每个猜测添加到猜测列表中，如下列所示。
- en: ¹
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 [https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)
- en: Listing 22.9\. /src/index.js
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 22.9\. /src/index.js
- en: '[PRE60]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* First you need to get a random word.**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 首先，你需要获取一个随机单词。**'
- en: '***2* You also need a place to store the player’s guesses.**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你还需要一个地方来存储玩家的猜测。**'
- en: '***3* Use event delegation to listen to all click events.**'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用事件委托来监听所有点击事件。**'
- en: '***4* If the game is still in play and the player clicked a button...**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果游戏仍在进行中且玩家点击了按钮...**'
- en: '***5* ...add the letter the player guessed to your array.**'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* ...将玩家猜中的字母添加到你的数组中。**'
- en: '***6* Redraw the game.**'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 重新绘制游戏。**'
- en: '***7* Draw the initial game UI.**'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 绘制初始游戏用户界面。**'
- en: After you get a random word, you start listening for button clicks using event
    delegation.^([[2](kindle_split_034_split_005.xhtml#ch22fn02)]) Every time the
    player makes a guess, the entire UI is destroyed and recreated. This could be
    optimized, but for this small game it’s OK and makes the game much simpler. Event
    delegation allows you to add the click event listener once without needing to
    reregister it every time the UI is rebuilt.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在你得到一个随机单词后，你开始使用事件委托来监听按钮点击。[^2](kindle_split_034_split_005.xhtml#ch22fn02)
    每当玩家做出猜测时，整个UI都会被销毁并重新创建。这可以优化，但对于这个小型游戏来说，这是可以接受的，并且使游戏变得更加简单。事件委托允许你在UI重建时无需重新注册即可一次性添加点击事件监听器。
- en: ²
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See: [https://davidwalsh.name/event-delegate](https://davidwalsh.name/event-delegate)'
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参考：[https://davidwalsh.name/event-delegate](https://davidwalsh.name/event-delegate)
- en: You now have a working game. You can build the game using `npm run build` in
    your terminal and then open `index.html` in your browser!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个可以工作的游戏了。你可以在终端中使用`npm run build`来构建游戏，然后在浏览器中打开`index.html`！
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this capstone you created a hangman game. You started by making a word module
    for generating the random word used for your game. You then worked on the status
    and interface components of the game. You finally put all the pieces together
    in the index file. You’re currently only using three random words, which doesn’t
    make it very hard to guess. Feel free to update the game with a longer list of
    words or use an API. You can also take this game further by adding a Play Again
    button to restart the game once it’s over.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个综合项目中，你创建了一个猜字游戏。你首先制作了一个单词模块，用于生成游戏中使用的随机单词。然后，你着手处理游戏的状态和界面组件。最后，你在索引文件中将所有部件组合在一起。目前你只使用了三个随机单词，这并不使游戏变得很难猜。你可以自由地更新游戏，使用更长的单词列表或使用API。你还可以通过添加“再玩一次”按钮来进一步改进游戏，以便游戏结束后可以重新开始。
