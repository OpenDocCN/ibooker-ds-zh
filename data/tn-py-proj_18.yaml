- en: 17 Mad Libs:Using regular expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17 Mad Libs：使用正则表达式
- en: '| When I was a wee lad, we used to play at Mad Libs for hours and hours. This
    was before computers, mind you, before televisions or radio or even paper! No,
    scratch that, we had paper. Anyway, point is we only had Mad Libs to play, and
    we loved it! And now you must play! | ![](../Images/17-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 当我还是个小男孩时，我们经常玩好几个小时的游戏《疯狂填空》。请注意，这是在电脑、电视、收音机或甚至纸张出现之前。不，别误会，我们确实有纸张。无论如何，重点是当时我们只有《疯狂填空》可以玩，我们非常喜欢它！现在你也必须玩！
    | ![](../Images/17-unnumb-1.png)  |'
- en: In this chapter, we’ll write a program called mad.py that will read a file given
    as a positional argument and find all the placeholders in angle brackets, like
    `<verb>` or `<adjective>`. For each placeholder, we’ll prompt the user for the
    part of speech being requested, like “Give me a verb” and “Give me an adjective.”
    (Notice that you’ll need to use the correct article, just as in chapter 2.) Each
    value from the user will then replace the placeholder in the text, so if the user
    says “drive” for the verb, then `<verb>` in the text will be replaced with `drive`.
    When all the placeholders have been replaced with inputs from the user, we’ll
    print out the new text.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写一个名为 mad.py 的程序，该程序将读取作为位置参数给出的文件，并找到所有尖括号中的占位符，如 `<verb>` 或 `<adjective>`。对于每个占位符，我们将提示用户请求的词性，例如“给我一个动词”和“给我一个形容词”。（请注意，你需要使用正确的冠词，就像在第
    2 章中一样。）然后，用户提供的每个值将替换文本中的占位符，所以如果用户说“drive”作为动词，那么文本中的 `<verb>` 将被替换为 `drive`。当所有占位符都被用户输入替换后，我们将打印出新的文本。
- en: 'There is a 17_mad_libs/inputs directory with some sample files you can use,
    but I also encourage you to create your own. For instance, here is a version of
    the “fox” text:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 17_mad_libs/inputs 目录中有一个包含一些示例文件的目录，你可以使用这些文件，但我也鼓励你创建自己的。例如，这里是一个“狐狸”文本的版本：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the program is run with this file as the input, it will ask for each of
    the placeholders and then print the silliness:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序以该文件作为输入运行时，它将询问每个占位符，然后打印出愚蠢的内容：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By default, this is an interactive program that will use the `input()` prompt
    to ask the user for their answers, but for testing purposes we will have an `-i`
    or `--inputs` option so the test suite can pass in all the answers and bypass
    the interactive `input()` calls:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这是一个交互式程序，将使用 `input()` 提示来询问用户的答案，但为了测试目的，我们将有一个 `-i` 或 `--inputs` 选项，以便测试套件可以传递所有答案并绕过交互式
    `input()` 调用：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this exercise, you will
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将
- en: Learn to use `sys.exit()` to halt your program and indicate an error status
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用 `sys.exit()` 来停止你的程序并指示错误状态
- en: Learn about greedy matching with regular expressions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用正则表达式进行贪婪匹配
- en: Use `re.findall()` to find all matches for a regex
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `re.findall()` 找到所有正则表达式的匹配项
- en: Use `re.sub()` to replace found patterns with new text
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `re.sub()` 将找到的模式替换为新文本
- en: Explore ways to write the solution without using regular expressions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索不使用正则表达式编写解决方案的方法
- en: 17.1 Writing mad.py
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1 编写 mad.py
- en: To start off, create the program mad.py in the 17_mad_libs directory using new.py
    or by copying template/template.py to 17_mad_libs/mad.py. You would also do well
    to define the positional `file` argument as a readable text file using `type=argparse
    .FileType('rt')`. The `-i` or `--inputs` option should use `nargs='*'` to define
    a `list` of zero or more `str` values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 17_mad_libs 目录中创建程序 mad.py，使用 new.py 或将模板/template.py 复制到 17_mad_libs/mad.py。你还应该定义位置参数
    `file` 为可读文本文件，使用 `type=argparse.FileType('rt')`。`-i` 或 `--inputs` 选项应使用 `nargs='*'`
    来定义零个或多个 `str` 值的列表。
- en: 'After this, your program should be able to produce a usage statement when given
    no arguments or the `-h` or `--help` flag:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当没有提供参数或提供 `-h` 或 `--help` 标志时，你的程序应该能够生成用法说明：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the given `file` argument does not exist, the program should error out:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的 `file` 参数不存在，程序应该报错：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the text of the file contains no `<>` placeholders, the program should print
    a message and exit with an error value (something other than `0`). Note that this
    error does not need to print a usage statement, so you don’t have to use `parser.error()`
    as in previous exercises:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件的文本中没有 `<>` 占位符，程序应该打印一条消息并退出，返回错误值（非 `0`）。请注意，这个错误不需要打印用法说明，因此你不需要像以前练习中那样使用
    `parser.error()`：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Figure 17.1 shows a string diagram to help you visualize the program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 显示了一个字符串图，帮助你可视化程序。
- en: '![](../Images/17-1.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/17-1.png)'
- en: Figure 17.1 The Mad Libs program must have an input file. It may also have a
    list of strings for the substitutions or it will interactively ask the user for
    the values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1 Mad Libs程序必须有一个输入文件。它也可能有一个用于替换的字符串列表，或者它会交互式地询问用户输入值。
- en: 17.1.1 Using regular expressions to find the pointy bits
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.1 使用正则表达式查找尖角部分
- en: 'We’ve talked before about the possible dangers of reading an entire file into
    memory. Because we’ll be parsing the text to find all the `<...>` bits in this
    program, we’ll really need to read the whole file at once. We can do this by chaining
    the appropriate functions like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过将整个文件读入内存可能存在的风险。由于我们将在程序中解析文本以查找所有 `<...>` 段落，我们确实需要一次性读取整个文件。我们可以通过链式调用适当的函数来实现这一点：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We’re looking for patterns of text inside angle brackets, so let’s use a regular
    expression. We can find a literal `<` character like so (see figure 17.2):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找角括号内的文本模式，所以让我们使用正则表达式。我们可以找到这样的字面量 `<` 字符（见图17.2）：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](../Images/17-2.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-2.png)'
- en: Figure 17.2 Matching a literal less-than sign
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2 匹配一个字面量的小于号
- en: 'Now let’s find that bracket’s mate. The `.` in a regular expression means “anything,”
    and we can add a `+` after it to mean “one or more.” I’ll capture the match so
    it’s easier to see:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来找到那个括号的配对。正则表达式中的 `.` 表示“任何东西”，我们可以在它后面添加一个 `+` 来表示“一个或多个”。我将捕获这个匹配，以便更容易看到：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown in figure 17.3, that matched all the way to the end of the string instead
    of stopping at the first available `>`. It’s common when you use `*` or `+` for
    zero, one, or more for the regex engine to be “greedy” on the *or more* part.
    The pattern matches beyond where we wanted, but it is technically matching exactly
    what we described. Remember that `.` means *anything*, and a right angle bracket
    (or greater-than sign) is “anything.” It matches as many characters as possible
    until it finds the last right angle bracket to stop at, which is why this pattern
    is called “greedy.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如图17.3所示，它匹配到了字符串的末尾，而不是在第一个可用的 `>` 处停止。当你使用 `*` 或 `+` 来表示零、一或多个时，正则表达式引擎通常会在“或更多”部分上“贪婪”。模式匹配超出了我们想要的范围，但从技术上讲，它确实匹配了我们描述的内容。记住，`.`
    表示 *任何东西*，而右角括号（或大于号）也是“任何东西”。它尽可能多地匹配字符，直到找到最后一个右角括号停止，这就是为什么这个模式被称为“贪婪”。
- en: '![](../Images/17-3.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-3.png)'
- en: Figure 17.3 The plus sign to match one or more is a greedy match, matching as
    many characters as possible.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3 匹配一个或多个的加号是一个贪婪匹配，匹配尽可能多的字符。
- en: 'We can make the regex “non-greedy” by changing `+` to `+?` so that it matches
    the shortest possible string (see figure 17.4):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `+` 改为 `+?` 来使正则表达式“非贪婪”，这样它就会匹配可能的最短字符串（见图17.4）：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/17-4.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-4.png)'
- en: Figure 17.4 The question mark after the plus sign makes the regex stop at the
    shortest possible match.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4 加号后面的问号使得正则表达式在可能的最短匹配处停止。
- en: 'Rather than using `.` for “anything,” it would be more accurate to say that
    we want to match one or more of anything *that is not either of the angle brackets*.
    The character class `[<>]` would match either bracket. We can negate (or complement)
    the class by putting a caret (`^`) as the first character, so we have `[^<>]`
    (see figure 17.5). That will match anything that is not a left or right angle
    bracket:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用 `.` 来表示“任何东西”，更准确的说法是我们想要匹配一个或多个不是任意一个角括号的“任何东西”。字符类 `[<>]` 会匹配任一括号。我们可以通过将一个撇号（`^`）作为类的第一个字符来取反（或补全）这个类，所以我们有
    `[^<>]`（见图17.5）。这将匹配任何不是左括号或右括号的字符：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/17-5.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-5.png)'
- en: Figure 17.5 A negated character class to match anything other than the angle
    brackets
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5 用于匹配除角括号之外任何内容的取反字符类
- en: 'Why do we have both brackets inside the negated class? Wouldn’t the right bracket
    be enough? Well, I’m guarding against *unbalanced* brackets. With only the right
    bracket, it would match this text (see figure 17.6):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在取反的类中同时使用两个括号？难道右括号就足够了吗？嗯，我是为了防止*不平衡*的括号。只有右括号的话，它会匹配这段文本（见图17.6）：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../Images/17-6.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-6.png)'
- en: Figure 17.6 This regex leaves open the possibility of matching unbalanced brackets.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.6 这个正则表达式留下了匹配不平衡括号的可能性。
- en: 'But with *both* brackets in the negated class, it finds the correct, balanced
    pair (see figure 17.7):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在取反的类中同时使用两个括号，它找到了正确的、平衡的配对（见图17.7）：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](../Images/17-7.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-7.png)'
- en: Figure 17.7 This regex finds the correctly balanced brackets and contained text.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.7 这个正则表达式找到了正确平衡的括号和包含的文本。
- en: 'We’ll add two sets of parentheses `()`. The first will capture the *entire*
    placeholder pattern (see figure 17.8):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加两组括号`()`。第一组将捕获整个占位符模式（见图17.8）：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../Images/17-8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-8.png)'
- en: Figure 17.8 The outer parentheses capture the brackets and text.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.8 外层括号捕获了方括号和文本。
- en: 'The other is for the string *inside* the `<>` (see figure 17.9):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组是为了捕获`<>`内的字符串（见图17.9）：
- en: '![](../Images/17-9.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-9.png)'
- en: Figure 17.9 The inner parentheses capture just the text.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.9 内层括号只捕获文本。
- en: 'There is a very handy function called `re.findall()` that will return all matching
    text groups as a `list` of `tuple` values:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常方便的函数叫做`re.findall()`，它将返回所有匹配的文本组作为一个包含`tuple`值的`list`：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that the capture groups are returned in the order of their opening parentheses,
    so the entire placeholder is the first member of each `tuple`, and the contained
    text is the second. We can iterate over this `list`, *unpacking* each `tuple`
    into variables (see figure 17.10):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，捕获组是按照它们打开括号的顺序返回的，所以整个占位符是每个`tuple`的第一个成员，包含的文本是第二个。我们可以遍历这个`list`，将每个`tuple`解包到变量中（见图17.10）：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../Images/17-10.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-10.png)'
- en: Figure 17.10 Since the list contains 2-tuples, we can unpack them into two variables
    in the `for` loop.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.10 由于列表包含2元组，我们可以在`for`循环中将它们解包成两个变量。
- en: You should insert the correct article (“a” or “an,” as you did in chapter 2)
    to use as the prompt for `input()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该插入正确的冠词（“a”或“an”，就像你在第2章中做的那样）作为`input()`的提示。
- en: 17.1.2 Halting and printing errors
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.2 停止和打印错误
- en: 'If we find there are no placeholders in the text, we need to print an error
    message. It’s common to print error messages to `STDERR` (standard error), and
    the `print()` function allows us to specify a `file` argument. We’ll use `sys.stderr`,
    just as we did in chapter 9\. To do that, we need to import that module:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在文本中找不到占位符，我们需要打印一条错误信息。将错误信息打印到`STDERR`（标准错误）是很常见的，而`print()`函数允许我们指定一个`file`参数。我们将使用`sys.stderr`，就像我们在第9章中做的那样。为了做到这一点，我们需要导入该模块：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You may recall that `sys.stderr` is like an already open file handle, so there’s
    no need to `open()` it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，`sys.stderr`就像一个已经打开的文件句柄，所以没有必要调用`open()`：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If there really are no placeholders, we should exit the program with an error
    value to indicate to the operating system that the program failed to run properly.
    The normal exit value for a program is `0`, as in “zero errors,” so we need to
    exit with some `int` value that is *not* `0`. I always use `1`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实没有占位符，我们应该以错误值退出程序，以向操作系统指示程序未能正常运行。程序的正常退出值是`0`，表示“零错误”，因此我们需要退出时使用一个不是`0`的`int`值。我总是使用`1`：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: One of the tests checks whether your program can detect missing placeholders
    and if your program exits correctly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个测试检查你的程序是否可以检测到缺失的占位符，以及你的程序是否正确退出。
- en: 'You can also call `sys.exit()` with a string value, in which case the string
    will be printed to `sys.stderr` and the program will exit with the value `1`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用字符串值调用`sys.exit()`，在这种情况下，字符串将被打印到`sys.stderr`，并且程序将以值`1`退出：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 17.1.3 Getting the values
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.3 获取值
- en: For each one of the parts of speech in the text, we need a value that will come
    either from the `--inputs` argument or directly from the user. If we have nothing
    for `--inputs`, we can use the `input()` function to get an answer from the user.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本中的每一个词性部分，我们需要一个值，这个值要么来自`--inputs`参数，要么直接来自用户。如果我们没有`--inputs`，我们可以使用`input()`函数从用户那里获取答案。
- en: 'The `input()` function takes a `str` value to use as a prompt:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()`函数接受一个`str`值作为提示：'
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And it returns a `str` value of whatever the user typed before pressing the
    Return key:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回用户在按下回车键之前输入的`str`值：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If, however, we have values for the inputs, we can use those and not bother
    with the `input()` function. I’m only making you handle the `--inputs` option
    for testing purposes. You can safely assume that you will always have the same
    number of inputs as you have placeholders (see figure 17.11).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们有输入值，我们可以使用这些值而不必使用`input()`函数。我之所以让你处理`--inputs`选项，是为了测试目的。你可以安全地假设你将始终有与占位符相同数量的输入（见图17.11）。
- en: '![](../Images/17-11.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/17-11.png)'
- en: Figure 17.11 If given inputs from the command line, they will match up with
    the placeholders in the text.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.11 如果从命令行提供输入，它们将与文本中的占位符匹配。
- en: 'For instance, you might have the following as the `--inputs` option to your
    program for the fox.txt example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能将以下内容作为fox.txt示例程序的`--inputs`选项：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You need to remove and return the first string, “surly,” from `inputs`. The
    `list.pop()` method is what you need, but it wants to remove the *last* element
    by default:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从`inputs`中移除并返回第一个字符串，“surly”，你需要使用`list.pop()`方法，但默认情况下它会移除*最后一个*元素：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `list.pop()` method takes an optional argument to indicate the index of
    the element you want to remove. Can you figure out how to make that work? Be sure
    to read `help(list.pop)` if you’re stuck.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.pop()`方法可以接受一个可选参数，以指示你想要移除的元素的索引。你能想出如何让它工作吗？如果你卡住了，请务必阅读`help(list.pop)`。'
- en: 17.1.4 Substituting the text
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.4 替换文本
- en: 'When you have values for each of the placeholders, you will need to substitute
    them into the text. I suggest you look into the `re.sub()` (substitute) function,
    which will replace any text matching a given regular expression with some other
    value. I definitely recommend you read `help(re.sub)`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有每个占位符的值时，你需要将它们替换到文本中。我建议你查看`re.sub()`（替换）函数，它将替换与给定正则表达式匹配的任何文本为其他值。我确实建议你阅读`help(re.sub)`：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I don’t want to give away the ending, but you will need to use a pattern similar
    to the preceding to replace each `<placeholder>` with each `value`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想泄露结局，但你将需要使用类似于前面的模式来将每个`<placeholder>`替换为每个`value`。
- en: Note that it’s not a requirement that you use the `re.sub()` function to solve
    this. I challenge you, in fact, to try writing a solution that does not use the
    `re` module at all. Now go write the program, and use the tests to guide you!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用`re.sub()`函数解决问题不是强制性的。实际上，我向你挑战，尝试编写一个完全不使用`re`模块的解决方案。现在去编写程序，并使用测试来指导你！
- en: 17.2 Solution
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2 解决方案
- en: Are you getting more comfortable with regular expressions? I know they are complicated,
    but really understanding them will help you more than you might expect.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否对正则表达式越来越熟悉了？我知道它们很复杂，但真正理解它们将比你想象的更有帮助。
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① The file argument should be a readable text file.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ① 文件参数应该是一个可读的文本文件。
- en: ② The --inputs option may have zero or more strings.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ② --inputs选项可以有零个或多个字符串。
- en: ③ Open and read the input file, stripping off the trailing newline.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 打开并读取输入文件，去除尾随换行符。
- en: ④ Use a regex to find all matches for a left angle bracket, followed by one
    or more of anything that is not a left or right angle bracket, followed by a right
    angle bracket. Use two capture groups to capture the entire expression and the
    text inside the brackets.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用正则表达式找到所有匹配左尖括号、后跟一个或多个不是左尖括号或右尖括号的任何字符、然后是右尖括号的匹配项。使用两个捕获组来捕获整个表达式和括号内的文本。
- en: ⑤ Check if there are no placeholders.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 检查是否存在占位符。
- en: ⑥ Print a message to STDERR that the specified file contains no placeholders,
    and exit the program with a non-zero status to indicate an error to the operating
    system.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 向STDERR打印消息，指出指定的文件不包含占位符，并以非零状态退出程序，向操作系统指示错误。
- en: ⑦ Create a string template for the prompt to ask for input() from the user.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 创建一个字符串模板，用于提示用户输入。
- en: ⑧ Iterate through the blanks, unpacking each tuple into variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 遍历空格，将每个元组解包到变量中。
- en: '⑨ Choose the correct article based on the first letter of the name of the part
    of speech (pos): “an” for those starting with a vowel and “a” otherwise.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 根据名词短语的第一个字母选择正确的冠词：“an”用于以元音字母开头的那些，否则用“a”。
- en: ⑩ If there are inputs, remove the first one for the answer; otherwise, use input()
    to prompt the user for a value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 如果有输入，移除第一个用于答案；否则，使用input()提示用户输入一个值。
- en: ⑪ Replace the current placeholder text with the answer from the user. Use count=1
    to ensure that only the first value is replaced. Overwrite the existing value
    of text so that all the placeholders will be replaced by the end of the loop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 将当前占位符文本替换为用户的答案。使用count=1确保只替换第一个值。覆盖现有的文本值，以便在循环结束时所有占位符都将被替换。
- en: ⑫ Print the resulting text to STDOUT.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 将结果文本打印到STDOUT。
- en: 17.3 Discussion
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3 讨论
- en: We start off by defining our arguments well. The input `file` should be declared
    using `type=argparse.FileType('rt')` so that `argparse` will verify that the argument
    is a readable text file. The `--inputs` are optional, so we can use `nargs='*'`
    to indicate zero or more strings. If no inputs are provided, the default value
    will be `None`, so be sure you don’t assume it’s a `list` and try doing list operations
    on a `None`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义好我们的参数。输入 `file` 应该使用 `type=argparse.FileType('rt')` 声明，这样 `argparse`
    将验证该参数是否为可读文本文件。`--inputs` 是可选的，因此我们可以使用 `nargs='*'` 来表示零个或多个字符串。如果没有提供输入，默认值将是
    `None`，所以请确保你不要假设它是一个 `list` 并尝试在 `None` 上执行列表操作。
- en: 17.3.1 Substituting with regular expressions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3.1 使用正则表达式进行替换
- en: 'There is a subtle bug waiting for you in using `re.sub()`. Suppose we have
    replaced the first `<adjective>` with “blue” so that we have this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `re.sub()` 时，有一个微小的错误在等待着你。假设我们已将第一个 `<adjective>` 替换为“blue”，所以我们有这个：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we want to replace `<noun>` with “dog,” so we try this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想将 `<noun>` 替换为“dog”，所以我们尝试这样做：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s check on the value of `text` now:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下 `text` 的值：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since there were two instances of the string `<noun>`, both got replaced with
    “dog,” as shown in figure 17.12.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串 `<noun>` 有两个实例，它们都被替换成了“dog”，如图 17.12 所示。
- en: '![](../Images/17-12.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/17-12.png)'
- en: Figure 17.12 The `re.sub()` function will replace all matches.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.12 `re.sub()` 函数将替换所有匹配项。
- en: 'We must use `count=1` to ensure that only the first occurrence is changed (see
    figure 17.13):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `count=1` 来确保只更改第一个出现（见图 17.13）：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](../Images/17-13.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/17-13.png)'
- en: Figure 17.13 Use the `count` option to `re.sub()` to limit the number of replacements.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.13 使用 `count` 选项限制 `re.sub()` 的替换次数。
- en: Now we can keep moving on to replace the other placeholders.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续替换其他占位符。
- en: 17.3.2 Finding the placeholders without regular expressions
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.3.2 不使用正则表达式查找占位符
- en: I trust the explanation of the regex solution earlier in the chapter was sufficient.
    I find that solution fairly elegant, but it is certainly possible to solve this
    without using regexes. Here is how I might solve it manually.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信本章前面关于正则表达式解决方案的解释是充分的。我发现那个解决方案相当优雅，但当然可以不使用正则表达式来解决这个问题。下面是我可能手动解决它的方法。
- en: First I need a way to search the text for `<...>`. I start off by writing a
    test that helps me imagine what I might give to my function and what I might expect
    in return for both good and bad values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我需要一个方法来搜索文本中的 `<...>`。我开始编写一个测试，帮助我想象我可能给我的函数提供什么，以及对于好值和坏值我可能期望得到什么结果。
- en: 'I decide to return `None` when the pattern is missing and to return a tuple
    of `(start,` `stop)` indices when the pattern is present:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式缺失时，我决定返回 `None`，当模式存在时，返回 `(start, stop)` 索引的元组：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① There is no text, so it should return None.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ① 没有文本，因此它应该返回 None。
- en: ② There are angle brackets, but they lack any text inside, so this should return
    None.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ② 有角度括号，但它们内部没有任何文本，因此应该返回 None。
- en: ③ The pattern should be found at the beginning of a string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 模式应该位于字符串的开头。
- en: ④ The pattern should be found further into the string.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 模式应该位于字符串的更深处。
- en: 'Now I need to write the code that will satisfy that test. Here is what I wrote:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我需要编写满足那个测试的代码。这是我写的：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① Find the index of the left bracket if one is found in the text.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果在文本中找到了左括号，则找到其索引。
- en: ② Find the index of the right bracket if one is found starting two positions
    after the left.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果在左括号后两个位置找到了右括号，则找到其索引。
- en: ③ If both brackets were found, return a tuple of their start and stop positions;
    otherwise, return None.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果找到了两个括号，则返回它们的起始和结束位置；否则，返回 None。
- en: 'This function works well enough to pass the given tests, but it is not quite
    correct because it will return a region that contains unbalanced brackets:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数工作得足够好，可以通过给定的测试，但它并不完全正确，因为它将返回一个包含不平衡括号的区域：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That may seem unlikely, but I chose angle brackets to make you think of HTML
    tags like `<head>` and `<img>`. HTML is notorious for being incorrect, maybe because
    it was hand generated by a human who messed up a tag or because some tool that
    generated the HTML had a bug. The point is that most web browsers have to be fairly
    relaxed in parsing HTML, and it would not be unexpected to see a malformed tag
    like `<<head>` instead of the correct `<head>`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不太可能，但我选择角度括号让你想到像 `<head>` 和 `<img>` 这样的 HTML 标签。HTML 以其不正确而闻名，可能是因为它是手工生成的，有人弄错了标签，或者是因为生成
    HTML 的工具有错误。关键是大多数网络浏览器在解析 HTML 时必须相当宽松，看到像 `<<head>` 这样的不正确标签而不是正确的 `<head>`
    并不令人意外。
- en: The regex version, on the other hand, specifically guards against matching unbalanced
    brackets by using the class `[^<>]` to define text that cannot contain any angle
    brackets. I could write a version of `find_brackets()` that finds only balanced
    brackets, but, honestly, it’s just not worth it. This function points out that
    one of the strengths of the regex engine is that it can find a partial match (the
    first left bracket), see that it’s unable to make a complete match, and start
    over (at the next left bracket). Writing this myself would be tedious and, frankly,
    not that interesting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，正则表达式版本专门通过使用类 `[^<>]` 来定义不能包含任何尖括号的文本，以防止匹配不平衡的括号。我可以编写一个 `find_brackets()`
    的版本，它只找到平衡的括号，但老实说，这并不值得。这个函数指出，正则表达式引擎的一个优点是它可以找到一个部分匹配（第一个左括号），看到它无法完成匹配，然后重新开始（在下一个左括号处）。自己编写这将是乏味的，而且坦白说，并不那么有趣。
- en: Still, this function works for all the given test inputs. Note that it only
    returns one set of brackets at a time. I will alter the text after I find each
    set of brackets, which will likely change the start and stop positions of any
    following brackets, so it’s best to handle one set at a time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这个函数适用于所有给定的测试输入。注意，它一次只返回一组括号。在我找到每一组括号之后，我将更改文本，这可能会改变任何后续括号的开头和结尾位置，因此最好一次处理一组。
- en: 'Here is how I would incorporate it into the `main()` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何将其集成到 `main()` 函数中的：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ① Create a variable to track whether we find placeholders. Assume the worst.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个变量来跟踪我们是否找到了占位符。假设最坏的情况。
- en: ② Create a template for the input() prompt.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个用于 input() 提示的模板。
- en: ③ Start an infinite loop. The while loop will continue as long as it has a “truthy”
    value, which True will always be.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 开始一个无限循环。while 循环将一直继续，只要它有一个“真值”，True 总是会是。
- en: ④ Call the find_brackets() function with the current value of text.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用当前文本的值调用 find_brackets() 函数。
- en: ⑤ If the return is None, this will be “falsey.”
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果返回值为 None，这将是一个“假值”。
- en: ⑥ If there are no brackets found, break out of the while loop.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果没有找到括号，则跳出 while 循环。
- en: ⑦ Now that we know we have found some brackets, unpack their start and stop
    values.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 现在我们知道我们已经找到了一些括号，解包它们的开始和结束值。
- en: ⑧ Find the entire <placeholder> value by using a string slice with the start
    and stop values, adding 1 to the stop to include that index.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 使用带有开始和结束值的字符串切片以及将停止值加 1（包括该索引）来找到整个 `<placeholder>` 值。
- en: ⑨ The “part of speech” is the bit inside, so this will extract “adjective” from
    “<adjective>.”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ “词性”是里面的部分，所以这将从 “<adjective>” 中提取“形容词”。
- en: ⑩ Choose the correct article for the part of speech.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 为词性选择正确的冠词。
- en: ⑪ Get the answer from the inputs or from an input() call.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 从输入或从 input() 调用中获取答案。
- en: ⑫ Overwrite the text using a string slice up to the start, the answer, and then
    the rest of the text from the stop.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 使用字符串切片覆盖文本，直到开始，然后是答案，最后是停止后的剩余文本。
- en: ⑬ Note that we saw a placeholder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 注意我们已经看到了一个占位符。
- en: ⑭ The loop exits when no more placeholders are found. Now that we’re done, check
    if we ever saw placeholders.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 当找不到更多占位符时，循环退出。现在我们已经完成了，检查我们是否看到了占位符。
- en: ⑮ If we did see a placeholder, print the new value of the text with the substitution(s).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 如果我们看到了占位符，则打印带有替换的新文本值。
- en: ⑯ If we never saw a placeholder, print an error message to STDERR and exit with
    a non-zero value to indicate an error.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 如果我们从未看到占位符，则向 STDERR 打印错误消息并退出，非零值表示错误。
- en: 17.4 Going further
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.4 进一步学习
- en: Extend your code to find all the HTML tags enclosed in `<...>` and `</...>`
    in a web page you download from the internet.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展你的代码以找到从互联网下载的网页中所有 `<...>` 和 `</...>` 包围的 HTML 标签。
- en: Write a program that will look for unbalanced open/close pairs for parentheses
    `()`, square brackets `[]`, and curly brackets `{}`. Create input files that have
    balanced and unbalanced text, and write tests that verify your program identifies
    both.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个程序，该程序将查找括号 `()`、方括号 `[]` 和花括号 `{}` 的不平衡的开放/关闭对。创建具有平衡和不平衡文本的输入文件，并编写测试以验证程序能够识别两者。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Regular expressions are almost like functions where we *describe* the patterns
    we want to find. The regex engine will do the work of trying to find the patterns,
    handling mismatches and starting over to find the pattern in the text.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式几乎像是函数，我们 *描述* 我们想要找到的模式。正则表达式引擎将执行尝试找到模式的工作，处理不匹配并重新开始以在文本中找到模式。
- en: Regex patterns with `*` or `+` are “greedy” in that they match as many characters
    as possible. Adding a `?` after them makes them “non-greedy” so that they match
    as *few* characters as possible.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `*` 或 `+` 的正则表达式模式是“贪婪”的，这意味着它们尽可能多地匹配字符。在它们后面添加一个 `?` 使它们变为“非贪婪”的，这样它们就尽可能少地匹配字符。
- en: The `re.findall()` function will return a `list` of all the matching strings
    or capture groups for a given pattern.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re.findall()` 函数将返回一个包含所有匹配字符串或给定模式的捕获组的 `list`。'
- en: The `re.sub()` function will substitute a pattern in some text with new text.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re.sub()` 函数将用新文本替换某些文本中的模式。'
- en: You can halt your program at any time using the `sys.exit()` function. If it’s
    given no arguments, the default exit value will be `0` to indicate no errors.
    If you wish to indicate there was an error, use any non-zero value such as `1`.
    Or use a string value, which will be printed to `STDERR`, and a non-zero exit
    value will be used automatically.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `sys.exit()` 函数在任何时候停止您的程序。如果没有提供任何参数，默认退出值将是 `0`，表示没有错误。如果您想表示发生了错误，可以使用任何非零值，例如
    `1`。或者使用字符串值，它将被打印到 `STDERR`，并且将自动使用非零退出值。
