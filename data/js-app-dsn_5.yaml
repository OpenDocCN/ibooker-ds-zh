- en: Appendix D. JavaScript code quality guide
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 D. JavaScript 代码质量指南
- en: This style guide aims to provide the ground rules for an application’s JavaScript
    code, so it’s highly readable and consistent across different developers on a
    team. The focus is put on quality and coherence across different pieces of your
    application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本风格指南旨在为应用程序的 JavaScript 代码提供基本规则，以便它易于阅读且在不同开发者之间保持一致。重点是确保应用程序不同部分的质量和连贯性。
- en: D.1\. Module organization
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.1\. 模块组织
- en: This style guide assumes you’re using a module system such as CommonJS,^([[1](#app04fn01)])
    AMD,^([[2](#app04fn02)]) ES6 Modules,^([[3](#app04fn03)]) or any other kind of
    module system. For a comprehensive introduction to module systems head over to
    [chapter 5](kindle_split_017.html#ch05); I’ll wait.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本风格指南假设你正在使用模块系统，例如 CommonJS,^([[1](#app04fn01)]) AMD,^([[2](#app04fn02)]) ES6
    Modules,^([[3](#app04fn03)]) 或任何其他类型的模块系统。要全面了解模块系统，请参阅第 5 章（kindle_split_017.html#ch05）；我会等待。
- en: ¹ The CommonJS module specification hosts a wiki page at [http://bevacqua.io/bf/commonjs](http://bevacqua.io/bf/commonjs).
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ CommonJS 模块规范在[http://bevacqua.io/bf/commonjs](http://bevacqua.io/bf/commonjs)上托管一个维基页面。
- en: ² RequireJS has a comprehensive article on the purpose of AMD at [http://bevacqua.io/bf/amd](http://bevacqua.io/bf/amd).
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² RequireJS 在[http://bevacqua.io/bf/amd](http://bevacqua.io/bf/amd)上有一篇关于 AMD
    目的的综合文章。
- en: ³ Getting started with ES6 is much easier these days! See [http://bevacqua.io/bf/es6-intro](http://bevacqua.io/bf/es6-intro).
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 现在，开始使用 ES6 要容易得多！请参阅[http://bevacqua.io/bf/es6-intro](http://bevacqua.io/bf/es6-intro)。
- en: Module systems provide individual scoping, avoid leaks to the global project,
    and improve code base organization by automating dependency graph generation,
    instead of having to resort to manually creating tens of <script> tags.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统提供单独的作用域，避免全局项目的泄漏，并通过自动化依赖图生成来改进代码库的组织，而不是需要手动创建数十个 `<script>` 标签。
- en: Module systems also provide Dependency Injection patterns, which are crucial
    when it comes to testing individual components in isolation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统还提供了依赖注入模式，这在单独测试组件时至关重要。
- en: D.1.1\. Strict mode
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.1.1\. 严格模式
- en: Always put `"use strict"`;^([[4](#app04fn04)]) at the top of your modules. Strict
    mode allows you to catch nonsensical behavior, discourages poor practices, and
    is faster because it allows compilers to make certain assumptions about your code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在模块顶部放置 `"use strict"`;^([[4](#app04fn04)])。严格模式允许你捕获无意义的操作，阻止不良实践，并且由于它允许编译器对你的代码做出某些假设，因此运行速度更快。
- en: ⁴ The Mozilla Developer Network (MDN) has a great article explaining Strict
    Mode in JavaScript at [http://bevacqua.io/bf/strict](http://bevacqua.io/bf/strict).
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ Mozilla 开发者网络（MDN）有一篇很好的文章解释了 JavaScript 中的严格模式，请参阅[http://bevacqua.io/bf/strict](http://bevacqua.io/bf/strict)。
- en: D.1.2\. Spacing
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.1.2\. 缩进
- en: 'Spacing must be consistent across every file in the application. To this end,
    using Editor-Config is highly encouraged. EditorConfig works by dropping an `.editorconfig`^([[5](#app04fn05)])
    file in your project root, and then you should install the EditorConfig plugin
    for your favorite text editor. Here are the defaults I suggest to get started
    with JavaScript indentation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中每个文件中的缩进必须保持一致。为此，强烈建议使用 Editor-Config。EditorConfig 通过在项目根目录中放置一个 `.editorconfig`^([[5](#app04fn05)])
    文件来实现，然后你应该为你的首选文本编辑器安装 EditorConfig 插件。以下是我建议的用于开始 JavaScript 缩进的默认设置：
- en: ⁵ Learn more about EditorConfig at [http://bevacqua.io/bf/editorconfig](http://bevacqua.io/bf/editorconfig).
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 在[http://bevacqua.io/bf/editorconfig](http://bevacqua.io/bf/editorconfig)上了解更多关于
    EditorConfig 的信息。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: EditorConfig can take care of indentation transparently, and everyone can consistently
    produce the right amount of tabs or spaces by pressing the tab key. Settling for
    either tabs or spaces is up to the particularities of a project, but I recommend
    using two spaces for indentation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: EditorConfig 可以透明地处理缩进，并且每个人都可以通过按 Tab 键来一致地产生正确数量的制表符或空格。选择制表符或空格取决于项目的特定情况，但我建议使用两个空格进行缩进。
- en: Spacing doesn’t only entail tabbing, but also the spaces before, after, and
    in between arguments of a function declaration. This kind of spacing is typically
    highly difficult to get right, and it’ll be hard for most teams to even arrive
    at a scheme that will satisfy everyone.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进不仅涉及制表符，还包括函数声明中参数之前、之后和之间的空格。这种类型的缩进通常很难正确设置，而且对于大多数团队来说，甚至很难达成一个能满足所有人的方案。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Try to keep these differences to a minimum, but don’t put much thought into
    it either.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量将这些差异降到最低，但也不必过分考虑。
- en: Where possible, improve readability by keeping lines below the 80-character
    mark.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，通过保持行宽在80个字符以下来提高可读性。
- en: D.1.3\. Semicolons
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.1.3\. 分号
- en: Automatic Semicolon Insertion (ASI) isn’t a feature. Don’t rely on it.^([[6](#app04fn06)])
    It’s super complicated^([[7](#app04fn07)]) and there’s no practical reason to
    burden all of the developers in a team for not possessing the frivolous knowledge
    of how ASI works. Avoid headaches; avoid ASI. Always add semicolons where needed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自动分号插入（ASI）不是一个特性。不要依赖它.^([[6](#app04fn06)]) 它非常复杂^([[7](#app04fn07)])，并且没有实际的理由让团队中的所有开发者都承担起了解ASI工作原理这种琐碎知识的负担。避免头疼；避免使用ASI。始终在需要的地方添加分号。
- en: ⁶ Ben Alman has good advice about why you should use semicolons instead of omitting
    them at [http://bevacqua.io/bf/semicolons](http://bevacqua.io/bf/semicolons).
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶ Ben Alman在[http://bevacqua.io/bf/semicolons](http://bevacqua.io/bf/semicolons)上提供了关于为什么你应该使用分号而不是省略它们的良好建议。
- en: ⁷ A guide to the inner workings of automatic semicolon insertion (ASI) is available
    at [http://bevacqua.io/bf/asi](http://bevacqua.io/bf/asi).
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷ 自动分号插入（ASI）内部工作原理的指南可以在[http://bevacqua.io/bf/asi](http://bevacqua.io/bf/asi)找到。
- en: D.1.4\. Linting
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.1.4\. 代码检查
- en: 'Given that JavaScript doesn’t require a compilation step that would take care
    of undeclared variables, linting is almost a necessity. Again, don’t use a linter
    that’s super-opinionated about how the code should be styled, like `jslint`^([[8](#app04fn08)])
    is. Instead use something more lenient, like `jshint`^([[9](#app04fn09)]) or `eslint`^([[10](#app04fn10)]).
    Here are a few tips when using JSHint:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript不需要编译步骤来处理未声明的变量，因此代码检查几乎是必需的。再次强调，不要使用像`jslint`^([[8](#app04fn08)])那样对代码风格有强烈偏见的代码检查器。相反，使用更宽容的工具，如`jshint`^([[9](#app04fn09)])或`eslint`^([[10](#app04fn10)]）。以下是在使用JSHint时的一些提示：
- en: ⁸ JSLint, the original JavaScript linter, can still be used online today at
    [http://bevacqua.io/bf/jslint](http://bevacqua.io/bf/jslint).
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ JSLint，最初的JavaScript代码检查器，今天仍然可以在线使用[http://bevacqua.io/bf/jslint](http://bevacqua.io/bf/jslint)。
- en: ⁹ JSHint is a modern alternative that’s popularly observed in build processes.
    Find it at [http://bevacqua.io/bf/jshint](http://bevacqua.io/bf/jshint).
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ JSHint是一个现代替代品，在构建过程中被广泛观察。可以在[http://bevacqua.io/bf/jshint](http://bevacqua.io/bf/jshint)找到。
- en: ^(10) ESLint is yet another lint tooling effort, aiming to be less concerned
    about style checking. Find it at [http://bevacqua.io/bf/eslint](http://bevacqua.io/bf/eslint).
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(10) ESLint是另一个代码检查工具，旨在减少对样式检查的关注。可以在[http://bevacqua.io/bf/eslint](http://bevacqua.io/bf/eslint)找到它。
- en: Declare a `.jshintignore` file and include `node_modules`, `bower_components`,
    and so on.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个`.jshintignore`文件，并包括`node_modules`、`bower_components`等。
- en: 'You can use a .jshintrc file like the one below to keep your rules together:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用以下类似文件来保持你的规则在一起：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By no means are these rules the ones you should stick to, but it’s important
    to find the sweet spot between not linting at all, and not being super-obnoxious
    about coding style. If left unchecked, you may succumb to common mistakes such
    as missing semicolons or improperly closing string quotes, but if you go overboard
    you may find that your team spends more time taking care of code style than writing
    meaningful code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则绝对不是你应该坚持的规则，但找到不进行代码检查和过于关注编码风格之间的平衡是很重要的。如果放任不管，你可能会陷入常见的错误，比如遗漏分号或错误地关闭字符串引号，但如果做得太过分，你可能会发现团队花更多的时间处理代码风格而不是编写有意义的代码。
- en: D.2\. Strings
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2\. 字符串
- en: Strings should always be quoted using the same quotation mark. Use `'` or `"`
    consistently throughout your code base. Ensure the team is using the same quotation
    mark in every portion of JavaScript that’s authored.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串应该始终使用相同的引号进行引用。在整个代码库中一致地使用`'`或`"`。确保团队在编写JavaScript代码的每个部分都使用相同的引号。
- en: Bad Strings
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 差劲的字符串
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Good Strings
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优秀的字符串
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Usually you’ll be a happier JavaScript developer if you hack together a parameter-replacing
    method such as `util.format` in Node.^([[11](#app04fn11)]) That way it’ll be far
    easier to format your strings, and the code looks cleaner too.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你在Node中创建一个参数替换方法，比如`util.format`，你会成为一个更快乐的JavaScript开发者.^([[11](#app04fn11)])
    这样做会使字符串格式化变得容易得多，代码看起来也更整洁。
- en: ^(11) The documentation for Node’s util.format can be found at [http://bevacqua.io/bf/util.format](http://bevacqua.io/bf/util.format).
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^(11) Node的util.format文档可以在[http://bevacqua.io/bf/util.format](http://bevacqua.io/bf/util.format)找到。
- en: Better Strings
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更好的字符串
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can implement something similar using the following piece of code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码片段实现类似的功能：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To declare multiline strings, particularly when talking about HTML snippets,
    it’s sometimes best to use an array as a buffer and then join its parts. The string
    concatenating style may be faster but it’s also much harder to keep track of:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明多行字符串，尤其是当谈论HTML片段时，有时最好使用数组作为缓冲区，然后连接其部分。字符串连接样式可能更快，但跟踪起来也更困难：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the array builder style, you can also push parts of the snippet and then
    join everything together at the end. This is what string templating engines such
    as Jade^([[12](#app04fn12)]) prefer to do.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组构建器样式，您也可以推送片段的部分，然后在最后将所有内容连接在一起。这是Jade^([12](#app04fn12)))等字符串模板引擎喜欢做的事情。
- en: ^(12) Learn more about templating in Jade by visiting their GitHub repository
    at [http://bevacqua.io/bf/jade](http://bevacqua.io/bf/jade).
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([12](#app12)) 通过访问他们的GitHub仓库[http://bevacqua.io/bf/jade](http://bevacqua.io/bf/jade)了解更多关于Jade模板的信息。
- en: D.2.1\. Variable declaration
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.2.1. 变量声明
- en: Always declare variables in a consistent manner, and at the top of their scope.
    Keeping variable declarations to one-per-line is encouraged. Comma-first, a single
    `var` statement, multiple `var` statements, it’s all fine, but be consistent across
    the project. Ensure that everyone on your team follows the style guide, for consistency.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总是以一致的方式声明变量，并在它们的范围内顶部。鼓励将变量声明保持为一行一个。逗号优先，单个`var`语句，多个`var`语句，这些都行，但要在整个项目中保持一致。确保团队中的每个人都遵循样式指南，以确保一致性。
- en: Inconsistent declaration
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不一致的声明
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: or
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the following example is okay not only because of its style, but also
    because the statements are consistent with each other.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下示例不仅因为其风格，还因为其陈述之间的一致性而可行。
- en: Consistent Declarations
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一致的声明
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Variable declarations not immediately assigned a value can share the same line
    of code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没有立即赋值的变量声明可以共享同一行代码。
- en: Acceptable declaration
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可接受的声明
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: D.3\. Conditionals
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3. 条件语句
- en: Brackets are enforced. This, together with a reasonable spacing strategy, will
    help you avoid mistakes such as Apple’s SSL/TLS bug.^([[13](#app04fn13)])
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 强制使用括号。这，加上合理的间距策略，将帮助您避免像苹果的SSL/TLS错误^([13](#app04fn13)))这样的错误。
- en: ^(13) A detailed report on Apple’s “GOTO Fail” bug can be found at [http://bevacqua.io/bf/gotofail](http://bevacqua.io/bf/gotofail).
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([13](#app13)) 关于苹果“GOTO Fail”错误的详细报告可以在[http://bevacqua.io/bf/gotofail](http://bevacqua.io/bf/gotofail)找到。
- en: Bad conditionals
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不良的条件语句
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Good conditionals
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 良好的条件语句
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Avoid using `==` and `!=` operators; always favor === and `!==`. These operators
    are called the “strict equality operators,” whereas their counterparts will attempt
    to cast the operands^([[14](#app04fn14)]) into the same value type. If possible,
    try to keep even single-statement conditionals in a multiline format.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`==`和`!=`运算符；始终优先使用`===`和`!==`。这些运算符被称为“严格相等运算符”，而它们的对应物将尝试将操作数^([14](#app04fn14)))转换为相同的值类型。如果可能，尽量将单行条件语句也保持在多行格式中。
- en: ^(14) Equality operators have a dedicated page on MDN at [http://bevacqua.io/bf/equality](http://bevacqua.io/bf/equality).
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([14](#app14)) 相等运算符在MDN上有一个专门的页面[http://bevacqua.io/bf/equality](http://bevacqua.io/bf/equality)。
- en: Bad coercing equality
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不良的强制转换相等
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Good strict equality
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 良好的严格相等
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: D.3.1\. Ternary operators
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.3.1. 三元运算符
- en: Ternary operators are fine for clear-cut conditionals, but unacceptable for
    confusing choices. As a rule, if you can’t eye-parse it as fast as your brain
    can interpret the text that declares the ternary operator, chances are it’s probably
    too complicated for its own good.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符适用于清晰的条件语句，但不适用于令人困惑的选择。一般来说，如果你不能像你的大脑一样快速地通过眼睛解析它，那么它可能过于复杂，不利于其自身。
- en: jQuery is a prime example of a code base that’s filled with nasty ternary operators.^([[15](#app04fn15)])
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是代码库中充满糟糕三元运算符的一个典型例子^([15](#app04fn15))。
- en: ^(15) A few examples of ternary operator misuse in jQuery can be found at [http://bevacqua.io/bf/jquery-ternary](http://bevacqua.io/bf/jquery-ternary).
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([15](#app15)) 可以在[http://bevacqua.io/bf/jquery-ternary](http://bevacqua.io/bf/jquery-ternary)找到一些jQuery中三元运算符误用的例子。
- en: Bad ternary operators
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不良的三元运算符
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Good ternary operators
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 良好的三元运算符
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In cases that may prove confusing, use `if` and `else` statements instead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能引起混淆的情况下，使用`if`和`else`语句。
- en: D.3.2\. Functions
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.3.2. 函数
- en: When declaring a function always use the function declaration form^([[16](#app04fn16)])
    instead of function expressions.^([[17](#app04fn17)]) If you try to use your function
    expressions before they’re assigned to a variable, you’ll get an error. In contrast,
    function declarations are hoisted^([[18](#app04fn18)]) to the top of the scope,
    meaning they’ll work regardless of where you place them in your code. You can
    learn all the details about hoisting in [chapter 5](kindle_split_017.html#ch05).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明函数时，始终使用函数声明形式^([[16](#app04fn16))) 而不是函数表达式.^([[17](#app04fn17))) 如果你在将函数表达式赋值给变量之前尝试使用它们，你会得到一个错误。相比之下，函数声明会被提升^([[18](#app04fn18)))
    到作用域的顶部，这意味着无论你在代码中放置它们的位置如何，它们都会正常工作。你可以在第 5 章 [kindle_split_017.html#ch05] 中了解关于提升的所有细节。
- en: ^(16) StackOverflow has an answer that covers function declarations at [http://bevacqua.io/bf/fn-declaration](http://bevacqua.io/bf/fn-declaration).
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (16) StackOverflow 有一个涵盖函数声明的答案，链接为 [http://bevacqua.io/bf/fn-declaration](http://bevacqua.io/bf/fn-declaration)。
- en: ^(17) You can find a concise definition of function expressions on MDN at [http://bevacqua.io/bf/fn-expr](http://bevacqua.io/bf/fn-expr).
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (17) 你可以在 MDN 上找到函数表达式的简洁定义，链接为 [http://bevacqua.io/bf/fn-expr](http://bevacqua.io/bf/fn-expr)。
- en: ^(18) Variable hoisting is explained in the code samples found at [http://bevacqua.io/bf/hoisting](http://bevacqua.io/bf/hoisting).
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (18) 变量提升的解释可以在 [http://bevacqua.io/bf/hoisting](http://bevacqua.io/bf/hoisting)
    找到的代码示例中找到。
- en: Using expressions is bad
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用表达式是坏的
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using declarations is good
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用声明是好的
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That being said, there’s nothing wrong with function expressions that curry
    another function.^([[19](#app04fn19)])
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，将函数表达式应用于另一个函数并没有什么错误.^([[19](#app04fn19)))
- en: ^(19) John Resig explains how to partially apply functions on his blog at [http://bevacqua.io/bf/partial-application](http://bevacqua.io/bf/partial-application).
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (19) 约翰·雷西格在他的博客上解释了如何在 [http://bevacqua.io/bf/partial-application](http://bevacqua.io/bf/partial-application)
    上部分应用函数。
- en: Currying is good
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Currying 是好的
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Keep in mind that function declarations will be hoisted^([[20](#app04fn20)])
    to the top of the scope, so it doesn’t matter what order they’re declared in.
    That being said, you should always keep them at the top level in a scope, and
    always avoid placing them inside conditional statements.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，函数声明将被提升^([[20](#app04fn20))) 到作用域的顶部，所以它们的声明顺序并不重要。然而，你应该始终将它们保持在作用域的顶层，并且始终避免在条件语句中放置它们。
- en: ^(20) Variable hoisting is explained in the code samples found at [http://bevacqua.io/bf/hoisting](http://bevacqua.io/bf/hoisting).
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (20) 变量提升的解释可以在 [http://bevacqua.io/bf/hoisting](http://bevacqua.io/bf/hoisting)
    找到的代码示例中找到。
- en: Bad functions
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 差的函数
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Good functions
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 好的函数
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you need a “no-op” method, you can use either `Function.prototype`, or `function
    noop () {}`. Ideally a single reference to `noop` is used throughout the application.
    Whenever you have to manipulate the `arguments` object, or other array-likes,
    cast them to an array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个“无操作”方法，你可以使用 `Function.prototype` 或 `function noop () {}`。理想情况下，在整个应用程序中只使用一个
    `noop` 引用。每次你必须操作 `arguments` 对象或其他类似数组的对象时，都要将它们转换为数组。
- en: Bad array-like loop
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 差的数组循环
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Good array-like loop
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 好的数组循环
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: However, be aware that there’s a substantial performance hit^([[21](#app04fn21)])
    in V8 environments when using this approach on `arguments.` If performance is
    a major concern, avoid casting `arguments` with `slice` and use a `for` loop instead.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在 V8 环境中使用这种方法在 `arguments.` 上会有显著的性能影响^([[21](#app04fn21)))。如果性能是一个主要问题，请避免使用
    `slice` 将 `arguments` 转换为数组，而改用 `for` 循环。
- en: ^(21) See a great article on optimizing manipulation of function arguments at
    [http://bevacqua.io/bf/arguments](http://bevacqua.io/bf/arguments).
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (21) 请参阅一篇关于优化函数参数操作的精彩文章，链接为 [http://bevacqua.io/bf/arguments](http://bevacqua.io/bf/arguments)。
- en: Bad arguments accessor
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 差的参数访问器
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Better arguments accessor
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更好的参数访问器
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Never declare functions inside of loops.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在循环中声明函数。
- en: Bad inline functions
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 差的内联函数
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: or
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Better extract the function
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更好地提取函数
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Or even better, use `.forEach`, which doesn’t have the same caveats as declaring
    functions in `for` loops.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好，使用 `.forEach`，它没有在 `for` 循环中声明函数的相同限制。
- en: Even better, functional arrays with foreach
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更好，使用 foreach 的函数数组
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Named function vs anonymous
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命名函数与匿名函数
- en: Whenever a method is nontrivial, make the effort to use a named function expression
    rather than an anonymous function. This makes it easier to pinpoint the root cause
    of an exception when analyzing stack traces.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个方法不是微不足道的，都要努力使用命名的函数表达式而不是匿名函数。这使你在分析堆栈跟踪时更容易找到异常的根本原因。
- en: Bad, anonymous functions
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 差的，匿名函数
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Good, named function
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 好的，有命名的函数
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Avoid keeping indentation levels from raising more than necessary by using guard
    clauses instead of flowing `if` statements.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用保护子句而不是流动的 `if` 语句来避免不必要的缩进级别增加。
- en: Bad
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 差
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: or
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Good
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 好
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: or
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: D.3.3\. Prototypes
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.3.3\. 原型
- en: Hacking the prototype of native types should be avoided at all costs; use methods
    instead. If you must extend the functionality in a native type, try using `poser`^([[22](#app04fn22)])
    instead. Poser provides out-of-context native type references that you can safely
    build upon and extend.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应尽量避免修改本地类型的原型；使用方法代替。如果你必须扩展本地类型的功能，尝试使用 `poser`^([[22](#app04fn22)]) 代替。Poser
    提供了上下文无关的本地类型引用，你可以安全地构建和扩展。
- en: ^(22) Poser provides out-of-context native type references that you can safely
    build upon and extend. For more information, see [http://bevacqua.io/bf/poser](http://bevacqua.io/bf/poser).
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([22](#app04fn22)) Poser 提供了上下文无关的本地类型引用，你可以安全地构建和扩展。更多信息，请参阅 [http://bevacqua.io/bf/poser](http://bevacqua.io/bf/poser)。
- en: Bad
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 差
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Good
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 好
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Avoid prototypical inheritance models unless you have a good performance reason
    to justify yourself:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有充分的性能理由来证明自己，否则请避免使用典型继承模型：
- en: They are way more verbose than using plain objects.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们比使用普通对象更冗长。
- en: They cause headaches when creating `new` objects.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建 `new` 对象时会引起头痛。
- en: They need a closure to hide valuable private state of instances.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们需要一个闭包来隐藏实例的宝贵私有状态。
- en: Just use plain objects instead.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只使用普通对象即可。
- en: D.3.4\. Object literals
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.3.4\. 对象字面量
- en: 'Instantiate using the Egyptian notation `{}`. Use factories instead of constructors.
    Here’s a proposed pattern for you to implement objects in general:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用埃及符号 `{}` 来实例化。用工厂方法代替构造函数。以下是一个供你实现对象的通用模式：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: D.3.5\. Array literals
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.3.5\. 数组字面量
- en: Instantiate using the square bracketed notation `[]`. If you have to declare
    a fixed-dimension array for performance reasons, then it’s fine to use the `new
    Array(length)` notation instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号符号 `[]` 来实例化。如果你因为性能原因必须声明一个固定维度的数组，那么使用 `new Array(length)` 符号也是可以的。
- en: Arrays in JavaScript have a rich API that you should take advantage of. You
    can start with array manipulation basics^([[23](#app04fn23)]) and then move on
    to more advanced use cases. For example, you could use the `.forEach` method to
    iterate over all of the items in a collection.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的数组拥有丰富的 API，你应该充分利用。你可以从数组操作的基础知识^([[23](#app04fn23)]) 开始，然后过渡到更高级的使用场景。例如，你可以使用
    `.forEach` 方法遍历集合中的所有项目。
- en: ^(23) An introductory article on JavaScript arrays is available on my blog at
    [http://bevacqua.io/bf/arrays](http://bevacqua.io/bf/arrays).
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([23](#app04fn23)) 一篇关于 JavaScript 数组的介绍性文章在我的博客上可读：[http://bevacqua.io/bf/arrays](http://bevacqua.io/bf/arrays)。
- en: 'The following list shows basic operations you can perform on arrays:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了你可以对数组执行的基本操作：
- en: Use `.push` to insert items at the end of a collection or `.shift` to insert
    them at the beginning.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.push` 来在集合末尾插入项目，或使用 `.shift` 来在开头插入项目。
- en: Use `.pop` to get the last item and remove it from the collection at the same
    time or use `.unshift` to do the same for the first item.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.pop` 来获取最后一个项目并从集合中移除，或者使用 `.unshift` 来对第一个项目执行相同的操作。
- en: Master `.splice` to remove items by index, or to insert items at a specific
    index, or to do both at the same time!
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精通 `.splice` 以通过索引删除项目，或在特定索引处插入项目，或同时执行这两项操作！
- en: 'Also learn about and use the functional collection manipulation methods! These
    can save you a ton of time that you’d otherwise spend doing the operations by
    hand. Here are a few examples of things you can do:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还要了解并使用函数式集合操作方法！这些方法可以节省你大量时间，否则你将不得不手动执行这些操作。以下是一些你可以做的例子：
- en: Use `.filter` to discard uninteresting values.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.filter` 来丢弃不感兴趣的价值。
- en: Use .`map` to transpolate array values into something else.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.map` 来将数组值转换成其他东西。
- en: Use `.reduce` to iterate over an array and produce a single result.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.reduce` 来遍历数组并生成一个单一的结果。
- en: Use `.some` and `.every` to assert whether all array items meet a condition.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.some` 和 `.every` 来断言所有数组项目是否满足某个条件。
- en: Use `.sort` to arrange the elements in a collection.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.sort` 来排列集合中的元素。
- en: Use `.reverse` to invert the order in the array.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.reverse` 来反转数组中的顺序。
- en: The Mozilla Developer Network (MDN) has thoroughly documented all of these methods
    and more at [https://developer.mozilla.org/](https://developer.mozilla.org/).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla 开发者网络 (MDN) 在 [https://developer.mozilla.org/](https://developer.mozilla.org/)
    对所有这些方法以及更多方法进行了详尽的文档记录。
- en: D.4\. Regular expressions
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.4\. 正则表达式
- en: Keep regular expressions in variables; don’t use them inline. This will vastly
    improve readability.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将正则表达式保存在变量中；不要内联使用。这将大大提高可读性。
- en: Bad regular expressions
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不良的正则表达式
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Good regular expressions
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 良好的正则表达式
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Also, learn to write regular expressions^([[24](#app04fn24)]) and what they
    do. Then you can also visualize them online.^([[25](#app04fn25)])
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，学习编写正则表达式^([[24](#app04fn24)])以及它们的作用。然后你还可以在线可视化它们^([[25](#app04fn25)])。
- en: ^(24) There’s an introductory article on regular expressions on my blog at [http://bevacqua.io/bf/regex](http://bevacqua.io/bf/regex).
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（24）在我的博客上有一篇关于正则表达式的入门文章，请参阅[http://bevacqua.io/bf/regex](http://bevacqua.io/bf/regex)。
- en: ^(25) Regexper lets you visualize how any regular expression works at [http://bevacqua.io/bf/regexper](http://bevacqua.io/bf/regexper).
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（25）Regexper允许你可视化任何正则表达式的工作方式，请参阅[http://bevacqua.io/bf/regexper](http://bevacqua.io/bf/regexper)。
- en: D.4.1\. Debugging statements
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.4.1\. 调试语句
- en: Preferably put your `console` statements into a service that can easily be disabled
    in production. Alternatively, don’t ship any `console.log` printing statements
    to production distributions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将你的`console`语句放入一个可以在生产中轻松禁用的服务中。或者，不要将任何`console.log`打印语句发送到生产分发。
- en: D.4.2\. Comments
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.4.2\. 注释
- en: Comments aren’t meant to explain what the code does. Good code is supposed to
    be self-explanatory. If you’re thinking of writing a comment to explain what a
    piece of code does, chances are you need to change the code itself. The exception
    to that rule is explaining what a regular expression does. Good comments are supposed
    to explain why code does something that may not seem to have a clear-cut purpose.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注释不是用来解释代码做了什么的。好的代码应该是自我解释的。如果你正在考虑写一个注释来解释一段代码做了什么，那么你可能需要改变代码本身。这个规则的例外是解释正则表达式做了什么。好的注释应该解释代码为什么做了可能没有明确目的的事情。
- en: Bad comments
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不良的注释
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Good comments
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 良好的注释
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: or
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Commenting out entire blocks of code should be avoided entirely; that’s why
    you have version control systems in place!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 完全注释掉代码块应该完全避免；这就是为什么你设置了版本控制系统的原因！
- en: D.4.3\. Variable naming
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.4.3\. 变量命名
- en: 'Variables must have meaningful names so that you don’t have to resort to commenting
    what a piece of functionality does. Instead, try to be expressive while succinct,
    and use meaningful variable names:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 变量必须有有意义的名称，这样你就不必求助于注释来解释某个功能片段做了什么。相反，尽量做到表达清晰、简洁，并使用有意义的变量名：
- en: Bad naming
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不良的命名
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Good naming
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 良好的命名
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: D.4.4\. Polyfills
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.4.4\. Polyfills
- en: A polyfill is a piece of code that transparently enables your application to
    use modern features in older browsers. Where possible use the native browser implementation
    and include a polyfill that provides that same behavior^([[26](#app04fn26)]) to
    unsupported browsers. This makes the code easier to work with and less involved
    in hackery to make things just work.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Polyfill是一段代码，它透明地使你的应用程序能够在旧浏览器中使用现代功能。尽可能使用原生浏览器实现，并为不支持该功能的浏览器包含一个提供相同行为的polyfill^([[26](#app04fn26)))。这使得代码更容易处理，并且减少了为了使事情正常工作而进行的黑客行为。
- en: ^(26) Remy Sharp concisely explains what a polyfill is at [http://bevacqua.io/bf/polyfill](http://bevacqua.io/bf/polyfill).
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（26）Remy Sharp简洁地解释了什么是polyfill，请参阅[http://bevacqua.io/bf/polyfill](http://bevacqua.io/bf/polyfill)。
- en: If you can’t patch a piece of functionality with a polyfill, then wrap all uses
    of the patching code^([[27](#app04fn27)]) in a globally available implementation
    that’s accessible from anywhere in the application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不能用polyfill修复某个功能片段，那么请将所有修补代码的使用包裹在一个全局可访问的实现中，该实现可以从应用程序的任何地方访问^([[27](#app04fn27)))。
- en: ^(27) I’ve written an article on developing high quality modules that touches
    on the implementation-wrapping subject at [http://bevacqua.io/bf/hq-modules](http://bevacqua.io/bf/hq-modules).
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（27）我写了一篇关于开发高质量模块的文章，其中涉及实现包装的主题，请参阅[http://bevacqua.io/bf/hq-modules](http://bevacqua.io/bf/hq-modules)。
- en: D.4.5\. Everyday tricks
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: D.4.5\. 每日技巧
- en: Creating default values
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建默认值
- en: Use `||` to define a default value. If the left-hand value is falsy^([[28](#app04fn28)])
    then the right-hand value will be used.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`||`来定义默认值。如果左边的值是假值^([[28](#app04fn28)))，则将使用右边的值。
- en: ^(28) In JavaScript, falsy values are treated as false in conditional statements.
    Falsy values are ‘’, `null`, `undefined`, and `0`. For more information, see [http://bevacqua.io/bf/casting](http://bevacqua.io/bf/casting).
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^（28）在JavaScript中，在条件语句中，假值被视为false。假值包括‘’，`null`，`undefined`和`0`。更多信息，请参阅[http://bevacqua.io/bf/casting](http://bevacqua.io/bf/casting)。
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using bind to partially apply functions
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用bind部分应用函数
- en: 'Use `.bind` to partially apply^([[29](#app04fn29)]) functions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.bind`来部分应用^([29](#app04fn29))函数：
- en: ^(29) John Resig, of jQuery fame, has an interesting article on partial JavaScript
    functions at [http://bevacqua.io/bf/partial-application](http://bevacqua.io/bf/partial-application).
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([29](#app04fn29)) 以jQuery闻名的John Resig在[http://bevacqua.io/bf/partial-application](http://bevacqua.io/bf/partial-application)上发表了一篇关于部分JavaScript函数的有趣文章。
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Array.prototype.slice.call to cast array-like objects to arrays
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`Array.prototype.slice.call`将类数组对象转换为数组
- en: 'Use `Array.prototype.slice.call` to cast array-like objects to true arrays:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Array.prototype.slice.call`将类数组对象转换为真正的数组：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Event emitters on all things
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 所有事物的事件发射器
- en: 'Use event emitters^([[30](#app04fn30)]) on all the things! This pattern helps
    you to decouple implementations from messaging between different objects or application
    layers:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有事物上使用事件发射器^([30](#app04fn30))！这种模式有助于您将实现与不同对象或应用层之间的消息传递解耦：
- en: ^(30) Contra provides an easy-to-use event emitter implementation at [http://bevacqua.io/bf/contra.emitter](http://bevacqua.io/bf/contra.emitter).
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([30](#app04fn30)) Contra提供了一个易于使用的事件发射器实现[http://bevacqua.io/bf/contra.emitter](http://bevacqua.io/bf/contra.emitter)。
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Function.prototype as a no-op
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`Function.prototype`作为无操作'
- en: Use `Function.prototype` as a “no-op:”
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '将`Function.prototype`用作“无操作”： '
- en: '[PRE51]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
