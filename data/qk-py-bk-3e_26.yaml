- en: Chapter 23\. Saving data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第23章。保存数据
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Storing data in relational databases
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关系型数据库中存储数据
- en: Using the Python DB-API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python DB-API
- en: Accessing databases through an Object Relational Mapper (ORM)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过对象关系映射器（ORM）访问数据库
- en: Understanding NoSQL databases and how they differ from relational databases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解NoSQL数据库以及它们与关系型数据库的不同之处
- en: When you have data and have it cleaned, it’s likely that you’ll want to store
    it. You’ll not only want to store it, but also be able to get at it in the future
    with as little hassle as possible. The need to store and retrieve significant
    amounts of data usually calls for some sort of database. Relational databases
    such as PostgreSQL, MySQL, and SQL Server have been established favorites for
    data storage for decades, and they can still be great options for many use cases.
    In recent years, NoSQL databases, including MongoDB and Redis, have found favor
    and can be very useful for a variety of use cases. A detailed discussion of databases
    would take several books, so in this chapter I look at some scenarios to show
    how you can access both SQL and NoSQL databases with Python.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有数据并且已经清理完毕，你很可能会想要存储它。你不仅想要存储它，还希望将来能够尽可能少地麻烦地访问它。存储和检索大量数据通常需要某种类型的数据库。关系型数据库，如PostgreSQL、MySQL和SQL
    Server，几十年来一直是数据存储的流行选择，并且对于许多用例来说仍然是很好的选择。近年来，NoSQL数据库，包括MongoDB和Redis，已经受到青睐，并且对于各种用例非常有用。详细讨论数据库需要几本书的内容，所以在本章中，我将探讨一些场景，以展示如何使用Python访问SQL和NoSQL数据库。
- en: 23.1\. Relational databases
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.1. 关系型数据库
- en: Relational databases have long been a standard for storing and manipulating
    data. They’re a mature technology and a ubiquitous one. Python can connect with
    a number relational databases, but I don’t have the time or the inclination to
    go through the specifics of each one in this book. Instead, because Python handles
    databases in a mostly consistent way, I illustrate the basics with one of them—sqlite3—and
    then discuss some differences and considerations in choosing and using a relational
    database for data storages.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库长期以来一直是存储和操作数据的标准。它们是一项成熟且普遍的技术。Python可以连接到多种关系型数据库，但我没有时间或意愿在这本书中详细介绍每一种。相反，由于Python以基本一致的方式处理数据库，我将以sqlite3为例来展示基础知识，并讨论选择和使用关系型数据库进行数据存储的一些差异和考虑因素。
- en: 23.1.1\. The Python Database API
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.1.1. Python数据库API
- en: As I mention, Python handles SQL database access very similarly across several
    database implementations because of PEP-249 ([www.python.org/dev/peps/pep-0249/](http://www.python.org/dev/peps/pep-0249/)),
    which specifies some common practices for connecting to SQL databases. Commonly
    called the Database API or DB-API, it was created to encourage “code that is generally
    more portable across databases, and a broader reach of database connectivity.”
    Thanks to the DB-API, the examples of SQLite that you see in this chapter are
    quite similar to what you’d use for PostgreSQL, MySQL, or several other databases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，由于PEP-249 ([www.python.org/dev/peps/pep-0249/](http://www.python.org/dev/peps/pep-0249/))，Python在多个数据库实现中处理SQL数据库访问的方式非常相似，该PEP指定了连接到SQL数据库的一些常见做法。通常被称为数据库API或DB-API，它的创建是为了鼓励“代码在数据库之间更具可移植性，以及更广泛的数据库连接范围。”多亏了DB-API，本章中展示的SQLite示例与用于PostgreSQL、MySQL或几个其他数据库的示例非常相似。
- en: '23.2\. SQLite: Using the sqlite3 database'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.2. SQLite：使用sqlite3数据库
- en: 'Although Python has modules for many databases, in the following examples I
    look at sqlite3\. Although it’s not suited for large, high-traffic applications,
    sqlite3 has two advantages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python有许多数据库模块，但在以下示例中，我将探讨sqlite3。尽管它不适合大型、高流量应用，但sqlite3有两个优点：
- en: Because it’s part of the standard library, it can be used anywhere you need
    a database without worrying about adding dependencies.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是标准库的一部分，你可以在需要数据库的任何地方使用它，而无需担心添加依赖项。
- en: sqlite3 stores all of its records in a local file, so it doesn’t need both a
    client and server, which would be the case for PostgreSQL, MySQL, and other larger
    databases.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sqlite3将所有记录存储在本地文件中，因此它不需要客户端和服务器，这对于PostgreSQL、MySQL和其他大型数据库来说是必需的。
- en: These features make sqlite3 a handy option for both smaller applications and
    quick prototypes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性使得sqlite3成为小型应用和快速原型的一个便捷选择。
- en: 'To use a sqlite3 database, the first thing you need is a `Connection` object.
    Getting a `Connection` object requires only calling the `connect` function with
    the name of file that will be used to store the data:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用sqlite3数据库，你需要的第一件事是获取一个`Connection`对象。获取`Connection`对象只需要调用`connect`函数并传入用于存储数据的文件名：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It’s also possible to hold the data in memory by using `":memory:"` as the filename.
    For storing Python integers, strings, and floats, nothing more is needed. If you
    want sqlite3 to automatically convert query results for some columns into other
    types, it’s useful to include the `detect_types` parameter set to `sqlite3.PARSE_DECLTYPES
    |sqlite3.PARSE_COLNAMES`, which directs the `Connection` object to parse the name
    and types of columns in queries and attempts to match them with converters you’ve
    already defined.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`":memory:"`作为文件名来在内存中保存数据。对于存储Python整数、字符串和浮点数，不需要更多。如果你希望sqlite3自动将某些列的查询结果转换为其他类型，包含`detect_types`参数设置为`sqlite3.PARSE_DECLTYPES
    |sqlite3.PARSE_COLNAMES`是有用的，这会指导`Connection`对象解析查询中的列名和类型，并尝试将它们与您已定义的转换器相匹配。
- en: 'The second step is creating a `Cursor object` from the connection:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是从连接创建一个`Cursor对象`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point, you’re able to make queries against the database. In the current
    situation, because the database has no tables or records yet, you first need to
    create a table and insert a couple of records:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你能够对数据库进行查询。在当前情况下，由于数据库还没有表或记录，你首先需要创建一个表并插入几条记录：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The last `insert` query illustrates the preferred way to make a query with variables.
    Rather than constructing the query string, it’s more secure to use a `?` for each
    variable and then pass the variables as a tuple parameter to the `execute` method.
    The advantage is that you don’t need to worry about incorrectly escaping a value;
    sqlite3 takes care of it for you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个`insert`查询说明了使用变量进行查询的首选方式。与其构建查询字符串，不如为每个变量使用`?`，然后将变量作为元组参数传递给`execute`方法。这样做的好处是，你不需要担心值被错误地转义；sqlite3会为你处理。
- en: 'You can also use variable names prefixed with `:` in the query and pass in
    a corresponding dictionary with the values to be inserted:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在查询中使用以`:`为前缀的变量名，并传递一个包含要插入值的相应字典：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After a table is populated, you can query the data by using SQL commands, again
    using either `?` for variable binding or names and dictionaries:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 表被填充后，你可以使用SQL命令查询数据，再次使用`?`进行变量绑定或使用名称和字典：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In addition to the `fetchall` method, the `fetchone` method gets one row of
    the result, and `fetchmany` returns an arbitrary number of rows. For convenience,
    it’s also possible to iterate over a cursor object’s rows similarly to iterating
    over a file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`fetchall`方法外，`fetchone`方法获取结果中的一行，而`fetchmany`返回任意数量的行。为了方便，也可以像迭代文件一样迭代游标对象的行：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, by default, sqlite3 doesn’t immediately commit transactions. This
    fact means that you have the option of rolling back a transaction if it fails,
    but it also means that you need to use the `Connection` object’s `commit` method
    to ensure that any changes made have been saved. Doing so before you close a connection
    to a database is a particularly good idea because the `close` method doesn’t automatically
    commit any active transactions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，默认情况下，sqlite3不会立即提交事务。这个事实意味着如果你的事务失败，你可以选择回滚事务，但也意味着你需要使用`Connection`对象的`commit`方法来确保所做的任何更改都已保存。在关闭数据库连接之前这样做尤其是个好主意，因为`close`方法不会自动提交任何活动事务：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Table 23.1](#ch23table01) gives an overview of the most common operations
    on an sqlite3 database.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[表23.1](#ch23table01)概述了sqlite3数据库上最常见的操作。'
- en: Table 23.1\. Common sqlite3 database operations
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表23.1\. 常见的sqlite3数据库操作
- en: '| Operation | sqlite3 command |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | sqlite3命令 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create a connection to a database. | conn = sqlite3.connect(filename) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 创建到数据库的连接。 | conn = sqlite3.connect(filename) |'
- en: '| Create a cursor for a connection. | Cursor = conn.cursor() |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 为连接创建一个游标。 | Cursor = conn.cursor() |'
- en: '| Execute a query with the cursor. | cursor.execute(query) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 使用游标执行查询。 | cursor.execute(query) |'
- en: '| Return the results of a query. | cursor.fetchall(),cursor.fetchmany(num_rows),
    cursor.fetchone()'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '| 返回查询的结果。 | cursor.fetchall(),cursor.fetchmany(num_rows), cursor.fetchone()'
- en: 'for row in cursor:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in cursor:'
- en: '.... |'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '.... |'
- en: '| Commit a transaction to a database. | conn.commit() |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 向数据库提交事务。 | conn.commit() |'
- en: '| Close a connection. | conn.close() |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 关闭连接。 | conn.close() |'
- en: These operations usually are all you need to manipulate an sqlite3 database.
    Of course, several options let you control their precise behavior; see the Python
    documentation for more information.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作通常是你需要操作 sqlite3 数据库的全部。当然，有几个选项可以让你控制它们的精确行为；有关更多信息，请参阅 Python 文档。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Creating and modifying Tables'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：创建和修改表
- en: Using sqlite3, write the code that creates a database table for the Illinois
    weather data you loaded from a flat file in [section 21.2](kindle_split_034.html#ch21lev1sec2).
    Suppose that you have similar data for more states and want to store more information
    about the states themselves. How could you modify your database to use a related
    table to store the state information?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 sqlite3，编写创建数据库表的代码，用于存储从 [第 21.2 节](kindle_split_034.html#ch21lev1sec2)
    中加载的伊利诺伊州天气数据。假设你还有更多州的数据，并想存储更多关于各州本身的信息。你如何修改数据库以使用相关表来存储州信息？
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 23.3\. Using MySQL, PostgreSQL, and other relational databases
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.3. 使用 MySQL、PostgreSQL 和其他关系型数据库
- en: 'As I mentioned earlier in this chapter, several other SQL databases have client
    libraries that follow the DB-API. As a result, accessing those databases in Python
    is quite similar, but there are a couple of differences to look out for:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我在本章前面提到的，几个其他 SQL 数据库也有遵循 DB-API 的客户端库。因此，在 Python 中访问这些数据库相当相似，但也有一些差异需要注意：
- en: Unlike SQLite, those databases require a database server that the client connects
    to and that may or may not be on a different machine, so the connection requires
    more parameters—usually including host, account name, and password.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 SQLite 不同，这些数据库需要客户端连接的数据库服务器，而这个服务器可能位于不同的机器上，因此连接需要更多的参数——通常包括主机、账户名称和密码。
- en: The way in which parameters are interpolated into queries, such as `"select
    * from test where name like :name"`, could use a different format—something like
    `?, %s 5(name)s`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数插入查询的方式，例如 `"select * from test where name like :name"`，可能使用不同的格式——类似于 `?,
    %s 5(name)s`。
- en: These changes aren’t huge, but they tend to keep code from being completely
    portable across different databases.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化并不大，但它们往往使代码在不同数据库之间完全不可移植。
- en: 23.4\. Making database handling easier with an ORM
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.4. 使用 ORM 使数据库处理更简单
- en: 'There are a few problems with the DB-API database client libraries mentioned
    earlier in this chapter and their requirement to write raw SQL:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面提到的 DB-API 数据库客户端库及其要求编写原始 SQL 存在一些问题：
- en: Different SQL databases have implemented SQL in subtly different ways, so the
    same SQL statements won’t always work if you move from one database to another,
    as you might want to do if, say, you do local development against sqlite3 and
    then want to use MySQL or PostgreSQL in production. Also, as mentioned earlier,
    the different implementations have different ways of doing things like passing
    parameters into queries.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的 SQL 数据库以微妙不同的方式实现了 SQL，因此当你从一个数据库切换到另一个数据库时，相同的 SQL 语句可能不会总是工作，比如，如果你在本地开发中使用
    sqlite3，然后想在生产中使用 MySQL 或 PostgreSQL。此外，如前所述，不同的实现有不同的方法来处理诸如将参数传递到查询中这样的操作。
- en: The second drawback is the need to use raw SQL statements. Including SQL statements
    in your code can make your code more difficult to maintain, particularly if you
    have a lot of them. In that case, some of the statements will be boilerplate and
    routine; others will be complex and tricky; and all of them need to be tested,
    which can get cumbersome.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个缺点是需要使用原始 SQL 语句。在代码中包含 SQL 语句可以使代码更难维护，尤其是如果你有很多这样的语句。在这种情况下，其中一些将是样板和常规的；其他将是复杂和棘手的；而且所有这些都需要测试，这可能会变得繁琐。
- en: 'The need to write SQL means that you need to think in at least two languages:
    Python and a specific SQL variant. In plenty of cases, it’s worth these hassles
    to use raw SQL, but in many other cases, it isn’t.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要编写 SQL 的需求意味着你需要至少用两种语言进行思考：Python 和特定的 SQL 变体。在许多情况下，使用原始 SQL 是值得这些麻烦的，但在许多其他情况下则不然。
- en: Given those issues, people wanted a way to handle databases in Python that was
    easier to manage and didn’t require anything more than writing regular Python
    code. The solution is an Object Relational Mapper (ORM), which converts, or maps,
    relational database types and structures to objects in Python. Two of the most
    common ORMs in the Python world are the Django ORM and SQLAlchemy, although of
    course there are many others. The Django ORM is rather tightly integrated with
    the Django web framework and usually isn’t used outside it. Because I’m not delving
    into Django in this book, I won’t discuss the Django ORM other than to note that
    it’s the default choice for Django applications and a good one, with fully developed
    tools and generous community support.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些问题，人们想要一种在Python中处理数据库的方法，这种方法更容易管理，并且不需要编写除常规Python代码之外的内容。解决方案是一个对象关系映射器（ORM），它将关系数据库的类型和结构转换为Python中的对象。Python世界中最常见的ORM是Django
    ORM和SQLAlchemy，尽管当然还有许多其他ORM。Django ORM与Django Web框架紧密集成，通常不会在它之外使用。因为我在这本书中不会深入探讨Django，所以除了指出它是Django应用程序的默认选择，并且是一个很好的选择，拥有完善的工具和丰富的社区支持外，我不会讨论Django
    ORM。
- en: 23.4.1\. SQLAlchemy
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.4.1. SQLAlchemy
- en: SQLAlchemy is the other big-name ORM in the Python space. SQLAlchemy’s goal
    is to automate redundant database tasks and provide Python object-based interfaces
    to the data while still allowing the developer control of the database and access
    to the underlying SQL. In this section, I look at some basic examples of storing
    data into a relational database and then retrieving it with SQLAlchemy.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy是Python空间中另一个知名的ORM。SQLAlchemy的目标是自动化冗余的数据库任务，在允许开发者控制数据库和访问底层SQL的同时，提供基于Python对象的数据接口。在本节中，我将查看一些使用SQLAlchemy将数据存储到关系数据库并检索它的基本示例。
- en: 'You can install SQLAlchemy in your environment with `pip`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pip`在你的环境中安装SQLAlchemy：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In working with SQLAlchemy and its related tools from this point, it will be
    more convenient to have two shell windows open in the same virtual environment:
    one for Python and one for your system’s command line.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在从这个点开始使用SQLAlchemy及其相关工具时，在同一虚拟环境中打开两个shell窗口会更方便：一个用于Python，另一个用于你的系统命令行。
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'SQLAlchemy offers several ways to interact with database and its tables. Although
    an ORM lets you write SQL statements if you want or need to, the strength of an
    ORM is doing what the name suggests: mapping the relational database tables and
    columns to Python objects.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy提供了多种与数据库及其表交互的方式。尽管ORM允许你在需要或想要的时候编写SQL语句，但ORM的强大之处在于它所暗示的功能：将关系数据库的表和列映射到Python对象。
- en: 'Use SQLAlchemy to replicate what you did in [section 23.2](#ch23lev1sec2):
    Create a table, add three rows, query the table, and update one row. You need
    to do a bit more setup to use the ORM, but in larger projects, this effort is
    more than worth it.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy来复制你在[第23.2节](#ch23lev1sec2)中做的事情：创建一个表，添加三行数据，查询表，并更新一行。你需要进行一些额外的设置来使用ORM，但在大型项目中，这种努力是非常值得的。
- en: 'First, you need to import the components you need to connect to the database
    and map a table to Python objects. From the base `sqlalchemy` package, you need
    the `create_engine` and `select` methods and the `MetaData` and `Table` classes.
    But because you need to specify the schema information when you create the `table`
    object, you also need to import the `Column` class and the classes for the data
    type of each column—in this case, `Integer` and `String`. From the `sqlalchemy.orm`
    subpackage, you also need the `sessionmaker` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要导入连接到数据库并将表映射到Python对象所需的组件。从基础`sqlalchemy`包中，你需要`create_engine`和`select`方法以及`MetaData`和`Table`类。但由于你需要在创建`table`对象时指定模式信息，因此你还需要导入`Column`类以及每个列的数据类型类——在这种情况下，`Integer`和`String`。从`sqlalchemy.orm`子包中，你还需要`sessionmaker`函数：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now you can think about connecting to the database:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以考虑连接到数据库：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To create and connect, you need to create a database engine appropriate for
    your database; then you need a `MetaData` object, which is a container for managing
    tables and their schemas. Create a `Table` object called `data`, giving the table’s
    name in the database, the `MetaData` object you just created, and the column you
    want to create, as well as their data types. Finally, you use the `sessionmaker`
    function to create a `Session` class for your engine and use that class to instantiate
    a session object. At this point, you’re connected to the database, and the last
    step is to use the `create_all` method to create the table.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和连接，您需要为您的数据库创建一个合适的数据库引擎；然后您需要一个 `MetaData` 对象，它是一个用于管理表及其模式的容器。创建一个名为 `data`
    的 `Table` 对象，指定数据库中的表名、您刚刚创建的 `MetaData` 对象以及您想要创建的列及其数据类型。最后，您使用 `sessionmaker`
    函数为您引擎创建一个 `Session` 类，并使用该类实例化会话对象。此时，您已连接到数据库，最后一步是使用 `create_all` 方法创建表。
- en: 'When the table is created, the next step is inserting some records. Again,
    you have many options for doing this in SQLAlchemy, but you’ll be fairly explicit
    in this example. Create an `insert` object, which you then execute:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当表创建完成后，下一步是插入一些记录。在 SQLAlchemy 中，您有多种方法可以做到这一点，但在这个例子中您将非常明确。创建一个 `insert`
    对象，然后执行它：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, you use the `insert()` method to create an `insert` object, also specifying
    the fields and values you want to insert. `people_ins` is the `insert` object,
    and you use the `str()` function to show that behind the scenes, you created the
    correct SQL command. Then you use the session object’s `execute` method to perform
    the insertion and the `commit` method to commit it to the database:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您使用 `insert()` 方法创建一个 `insert` 对象，并指定您想要插入的字段和值。`people_ins` 是 `insert`
    对象，您使用 `str()` 函数来显示在幕后您创建了正确的 SQL 命令。然后您使用会话对象的 `execute` 方法执行插入，并使用 `commit`
    方法将其提交到数据库：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can streamline things a bit and perform multiple inserts by passing in
    a list of dictionaries of the field names and values for each insert:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递一个包含每个插入的字段名称和值的字典列表来简化操作，并执行多个插入：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also use the `select()` method with a `where()` method to find a particular
    record. In the example, you’re looking for any records in which the `name` column
    equals `''Jill''`. Note that the `where` expression uses `people.c.name`, with
    the `c` indicating that `name` is a column in the people table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `select()` 方法与 `where()` 方法结合使用，以查找特定的记录。在示例中，您正在寻找任何 `name` 列等于 `'Jill'`
    的记录。请注意，`where` 表达式使用 `people.c.name`，其中 `c` 表示 `name` 是 `people` 表中的一列：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, you can combine an `update()` method with the `where()` method to update
    just one row.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以将 `update()` 方法与 `where()` 方法结合使用，以更新单行。
- en: Mapping table objects to classes
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将表对象映射到类
- en: 'So far, you’ve used table objects directly, but it’s also possible to use SQLAlchemy
    to map a table directly to a class. This technique has the advantage that the
    columns are mapped directly to class attributes. For illustration, make a class
    `People`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您直接使用了表对象，但也可以使用 SQLAlchemy 将表直接映射到类。这种技术的优点是列直接映射到类属性。为了说明，创建一个名为 `People`
    的类：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inserts can be done just by creating an instance of the mapped class and adding
    it to the session:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 插入可以通过创建映射类的实例并将其添加到会话中来实现：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Updates are also fairly straightforward. You retrieve the record you want to
    update, change the values on the mapped instance, and then add the updated record
    to the session to be written back to the database:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作也非常直接。您检索要更新的记录，更改映射实例中的值，然后将更新后的记录添加到会话中以写回数据库：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Deleting is similar to updating; you fetch the record to be deleted and then
    use the session’s `delete()` method to delete it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作与更新类似；您检索要删除的记录，然后使用会话的 `delete()` 方法将其删除：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Using SQLAlchemy does take a bit more setup than just using raw SQL, but it
    also has some real benefits. For one thing, using the ORM means that you don’t
    need to worry about any subtle differences in the SQL supported by different databases.
    The example works equally well with sqlite3, MySQL, and PostgreSQL without making
    any changes in the code other than giving the string to the create engine and
    making sure that the correct database driver is available.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQLAlchemy 比直接使用原始 SQL 需要更多的设置，但它也有一些真正的优点。首先，使用 ORM 意味着您不需要担心不同数据库支持的 SQL
    之间的细微差异。示例在 sqlite3、MySQL 和 PostgreSQL 上都能正常工作，无需在代码中进行任何更改，只需将字符串传递给创建引擎并确保正确的数据库驱动程序可用。
- en: Another advantage is that the interaction with the data can happen through Python
    objects, which may be more accessible to coders who lack SQL experience. Instead
    of constructing SQL statements, they can use Python objects and their methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是，可以通过Python对象与数据交互，这可能对缺乏SQL经验的程序员来说更容易访问。他们不需要构造SQL语句，而是可以使用Python对象及其方法。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Try this: Using an ORM'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这样做：使用ORM
- en: Using the database from earlier, write an SQLAlchemy class to map to the data
    table, and use it to read the records from the table.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的数据库，编写一个SQLAlchemy类来映射数据表，并使用它来读取表中的记录。
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 23.4.2\. Using Alembic for database schema changes
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 23.4.2\. 使用Alembic进行数据库模式更改
- en: In the course of developing code that uses a relational database it’s quite
    common, if not universal, to have to change the structure or schema of the database
    after you’ve started work. Fields need to be added, or their types need to be
    changed, and so on. It’s possible, of course, to manually make the changes to
    both the database tables and to the code for the ORM that accesses them, but that
    approach has some drawbacks. For one thing, such changes are difficult to roll
    back if you need to, and it’s hard to keep track of the configuration of the database
    that goes with a particular version of your code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发使用关系型数据库的代码过程中，在开始工作后更改数据库的结构或模式是很常见，如果不是普遍现象。需要添加字段，或者更改它们的类型，等等。当然，可以手动更改数据库表和访问它们的ORM代码，但这种方法有一些缺点。首先，如果需要，这样的更改很难回滚，而且很难跟踪与代码特定版本相对应的数据库配置。
- en: The solution is to use a database migration tool to help you make the changes
    and track them. Migrations are written as code and should include code both to
    apply the needed changes and to reverse them. Then the changes can be tracked
    and applied or reversed in the correct sequence. As a result, you can reliably
    upgrade or downgrade your database to any of the states it was in over the course
    of development.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用数据库迁移工具来帮助你进行更改并跟踪它们。迁移以代码的形式编写，应包括应用所需更改的代码以及撤销它们的代码。然后，可以跟踪并按正确顺序应用或撤销更改。因此，你可以可靠地将数据库升级或降级到开发过程中的任何状态。
- en: 'As an example, this section looks briefly at Alembic, a popular lightweight
    migration tool for SQLAlchemy. To start, switch to the system command-line window
    in your project directory, install Alembic, and create a generic environment by
    using `alemic init`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，本节简要介绍了Alembic，这是一个流行的轻量级迁移工具，用于SQLAlchemy。首先，切换到项目目录中的系统命令行窗口，安装Alembic，并使用`alemic
    init`创建一个通用环境：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code creates the file structure you need to use Alembic for data migrations.
    There’s an alembic.ini file that you need to edit in at least one place. The `squalchemy.url`
    line needs to be updated to match your current situation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了你使用Alembic进行数据迁移所需文件结构。有一个需要至少在一个地方编辑的alembic.ini文件。`squalchemy.url`行需要更新以匹配你的当前情况：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Change the line to
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将行更改为
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because you’re using a local sqlite file, you don’t need a username or password.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你使用的是本地sqlite文件，因此不需要用户名或密码。
- en: 'The next step is creating a revision by using Alembic’s revision command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用Alembic的修订命令创建修订：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code creates a revision script, 384ead9efdfd_create_a_test_address_table.py,
    in the alembic/versions directory. This file looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在alembic/versions目录中创建了一个修订脚本，文件名为384ead9efdfd_create_a_test_address_table.py。此文件看起来如下：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see that the file contains the revision ID and date in the header. It
    also contains a `down_revision` variable to guide the rollback of each version.
    If you make a second revision, its `down_revision` variable should contain this
    revision’s ID.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，文件在标题中包含修订ID和日期。它还包含一个`down_revision`变量，用于指导每个版本的回滚。如果你进行第二次修订，其`down_revision`变量应包含此修订的ID。
- en: 'To perform the revision, update the revision script to supply both the code
    describing how to perform the revision in the `upgrade()` method and the code
    to reverse it in the `downgrade()` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行修订，更新修订脚本以提供在`upgrade()`方法中执行修订的代码以及在`downgrade()`方法中撤销它的代码：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When this code is created, you can apply the upgrade. But first, switch back
    to the Python shell window to see what tables you have in your database:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码创建后，可以应用升级。但首先，切换回Python外壳窗口以查看你的数据库中有哪些表：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you might expect, you have only the one table you created earlier. Now you
    can run Alembic’s `upgrade` command to apply the upgrade and add a new table.
    Switch over to your system command line, and run
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预期的，你只有你之前创建的那个表。现在你可以运行 Alembic 的 `upgrade` 命令来应用升级并添加一个新表。切换到你的系统命令行，并运行
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you pop back to Python and check, you see that the database has two additional
    tables:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到 Python 并检查，你会看到数据库增加了两个额外的表：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first new table, `'alembic version'`, is created by Alembic to help track
    which version your database is currently on (for reference for future upgrades
    and downgrades). The second new table, `'address'`, is the table you added through
    your upgrade and is ready to use.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个新表，`'alembic version'`，是由 Alembic 创建的，以帮助跟踪你的数据库当前处于哪个版本（供未来的升级和降级参考）。第二个新表，`'address'`，是你通过升级添加的表，已经准备好使用。
- en: 'If you want to roll back the state of the database to what it was before, all
    you need to do is run Alembic’s `downgrade` command in the system window. You
    give the downgrade command `-1` to tell Alembic that you want to downgrade by
    one version:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将数据库的状态回滚到之前的状态，你只需要在系统窗口中运行 Alembic 的 `downgrade` 命令。你给出降级命令 `-1` 来告诉
    Alembic 你想要降级一个版本：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now if you check in your Python session, you’ll be back to where you started
    except that the version tracking table remains:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你在你的 Python 会话中检查，你会回到你开始的地方，除了版本跟踪表仍然存在：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you want to, of course, you can run the upgrade again to put the table back,
    add further revisions, make upgrades, and so on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，当然可以再次运行升级命令，将表恢复，添加更多修订，进行升级等等。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try this: Modifying a database with Alembic'
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 尝试这个：使用 Alembic 修改数据库
- en: Experiment with creating an Alembic upgrade that adds a state table to your
    database, with columns for ID, state name, and abbreviation. Upgrade and downgrade.
    What other changes would be needed if you were going to use the state table along
    with the existing data table?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个 Alembic 升级，向你的数据库添加一个状态表，包含 ID、状态名称和缩写。升级和降级。如果你打算使用状态表和现有的数据表，还需要进行哪些其他更改？
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 23.5\. NoSQL databases
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.5\. NoSQL 数据库
- en: In spite of their longstanding popularity, relational databases aren’t the only
    ways to think about storing data. Although relational databases are all about
    normalizing data within related tables, other approaches look at data differently.
    Quite commonly, these types of databases are referred to as *NoSQL* databases,
    because they usually don’t adhere to the row/column/table structure that SQL was
    created to describe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管关系型数据库长期以来一直很受欢迎，但它们并不是存储数据的唯一方式。虽然关系型数据库主要关注在相关表中规范化数据，但其他方法看待数据的方式不同。这些类型的数据库通常被称为
    *NoSQL* 数据库，因为它们通常不遵循 SQL 创建用来描述的行/列/表结构。
- en: 'Rather than handle data as collections of rows, columns, and tables, NoSQL
    databases can look at the data they store as key-value pairs, as indexed documents,
    and even as graphs. Many NoSQL databases are available, all with somewhat different
    ways of handling data. In general, they’re less likely to be strictly normalized,
    which can make retrieving information faster and easier. As examples, in this
    chapter I look at using Python to access two common NoSQL databases: Redis and
    MongoDB. What follows barely scratches the surface of what you can do with NoSQL
    databases and Python, but it should give you a basic idea of the possibilities.
    If you’re already familiar with Redis or MongoDB, you’ll see a little of how the
    Python client libraries work, and if you’re new to NoSQL databases, you’ll at
    least get an idea of how databases like these work.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与将数据作为行、列和表的集合来处理不同，NoSQL 数据库可以将它们存储的数据视为键值对、索引文档，甚至作为图。许多 NoSQL 数据库都可用，它们处理数据的方式各有不同。一般来说，它们不太可能严格规范化，这可以使检索信息更快、更容易。作为例子，在本章中，我将探讨使用
    Python 访问两个常见的 NoSQL 数据库：Redis 和 MongoDB。以下内容只是触及了你可以用 NoSQL 数据库和 Python 做的事情的表面，但它应该能给你一个基本的概念。如果你已经熟悉
    Redis 或 MongoDB，你会看到 Python 客户端库的一些工作方式，如果你是 NoSQL 数据库的新手，你至少会得到这些数据库如何工作的一个概念。
- en: 23.6\. key:value stores with Redis
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.6\. 使用 Redis 的键值存储
- en: Redis is an in-memory networked key:value store. Because the values are in memory,
    lookups can be quite fast, and the fact that it’s designed to be accessed over
    the network makes it useful in a variety of situations. Redis is commonly used
    for caching, as a message broker, and for quick lookups of information. In fact,
    the name (which comes from Remote Dictionary Server) is an excellent way to think
    of it; it behaves much like a Python dictionary translated to a network service.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个内存中的网络键值存储。因为值在内存中，所以查找可以非常快，而且它设计为可以通过网络访问，这使得它在各种情况下都很有用。Redis 通常用于缓存、作为消息代理以及快速查找信息。实际上，这个名字（来源于远程字典服务器）是一个很好的思考方式；它表现得就像一个翻译成网络服务的
    Python 字典。
- en: The following example gives you an idea of how Redis works with Python. If you’re
    familiar with the Redis command-line interface or have used a Redis client for
    another language, these short examples should get you well on your way to using
    Redis with Python. If Redis is new to you, the following gives you an idea of
    how it works; you can explore more at [https://redis.io](https://redis.io).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 Redis 与 Python 的工作方式。如果你熟悉 Redis 命令行界面或使用过其他语言的 Redis 客户端，这些简短的示例应该能帮助你开始使用
    Redis 与 Python。如果你对 Redis 是新手，以下示例为你提供了它的工作方式；你可以在 [https://redis.io](https://redis.io)
    上探索更多。
- en: Although several Python clients are available for Redis, at this writing the
    way to go (according to the Redis website) is one called redis-py. You can install
    it with `pip install redis`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有多个 Python 客户端可用于 Redis，但根据 Redis 网站的说法，目前的方法是使用一个名为 redis-py 的客户端。你可以使用 `pip
    install redis` 命令来安装它。
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Running a Redis server**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行 Redis 服务器**'
- en: To experiment, you need to have a Redis server running. Although you could use
    cloud-based Redis services, for experimentation your best choices are using a
    Docker instance or installing a server on a machine.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行实验，你需要有一个正在运行的 Redis 服务器。虽然你可以使用基于云的 Redis 服务，但对于实验来说，你的最佳选择是使用 Docker 实例或在机器上安装服务器。
- en: If you have Docker installed, using the Redis Docker instance is probably the
    quickest and easiest way to get a server up and running. You should be able to
    launch a Redis instance from the command line with a command like `> docker run
    -p 6379:6379 redis`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了 Docker，使用 Redis Docker 实例可能是启动和运行服务器最快、最简单的方式。你应该可以使用类似 `> docker run
    -p 6379:6379 redis` 的命令从命令行启动一个 Redis 实例。
- en: On Linux systems, it should be fairly easy to install Redis by using the system
    package manager, and on Mac systems, `brew install redis` should work. On Windows
    systems, you should check the [https://redis.io](https://redis.io) website or
    search online for the current options for running Redis on Windows. When Redis
    is installed, you may need to look online for instructions to make sure that the
    Redis server is running.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统上，使用系统包管理器安装 Redis 应该相当简单，在 Mac 系统上，`brew install redis` 应该有效。在 Windows
    系统上，你应该检查 [https://redis.io](https://redis.io) 网站，或在网上搜索 Windows 上运行 Redis 的当前选项。当
    Redis 安装完成后，你可能需要在网上查找说明，以确保 Redis 服务器正在运行。
- en: '|  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'When you get a server running, the following are examples of simple Redis interactions
    with Python. First, you need to import the Redis library and create a Redis connection
    object:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动一个服务器后，以下是一些简单的 Redis 与 Python 交互的示例。首先，你需要导入 Redis 库并创建一个 Redis 连接对象：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can use several connection options when creating a Redis connection, including
    the host, port, and password or SSH certificate. If the server is running on localhost
    on the default port of 6379, no options are needed. When you have the connection,
    you can use it to access the key:value store.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Redis 连接时，你可以使用多个连接选项，包括主机、端口、密码或 SSH 证书。如果服务器在本地主机的默认端口 6379 上运行，则不需要任何选项。当你有了连接，你可以使用它来访问键值存储。
- en: 'One of the first things you might do is use the `keys()` method to get a list
    of the keys in the database, which returns a list of keys currently stored (if
    any). Then you can set some keys of different types and try some ways to retrieve
    their values:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会做的第一件事是使用 `keys()` 方法来获取数据库中的键列表，该方法返回当前存储的键列表（如果有）。然后你可以设置不同类型的键，并尝试一些方法来检索它们的值：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These examples show how you can get a list of the keys in the Redis database,
    how to set a key with a value, and how to set a key with a `counter` variable
    and increment it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了如何获取 Redis 数据库中的键列表，如何设置带有值的键，以及如何设置带有 `counter` 变量的键并对其进行递增。
- en: 'These examples deal with storing arrays or lists:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例涉及存储数组或列表：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you start the key, `"words"` isn’t in the database, but the act of adding
    or pushing a value to the end (from the right, the `r` in `rpush`) creates the
    key, makes an empty list as its value, and then appends the value `'one'`. Using
    `rpush` again adds another word to the end. To retrieve the values in the list,
    you can use the `lrange()` function, giving the key and both a starting index
    and an ending index, with `-1` indicating the end of the list.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始键时，`"words"` 不在数据库中，但将值添加到末尾（从右到左，`r` 在 `rpush` 中）会创建键，将其值设为空列表，然后追加值 `'one'`。再次使用
    `rpush` 会将另一个单词添加到末尾。要检索列表中的值，你可以使用 `lrange()` 函数，提供键以及起始索引和结束索引，其中 `-1` 表示列表的末尾。
- en: Also note that you can add to the beginning, or left side, of the list with
    `lpush()`. You can use `lindex()` to retrieve a single value in the same way as
    `lranger()`, except that you give it the index of the value you want.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，你可以使用 `lpush()` 在列表的开头或左侧添加元素。你可以使用 `lindex()` 以与 `lrange()` 相同的方式检索单个值，只是你需要提供你想要值的索引。
- en: Expiration of values
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 值的过期
- en: 'One feature of Redis that makes it particularly useful for caching is the ability
    to set an expiration for a key-value pair. After that time has elapsed, the key
    and value are removed. This technique is particularly useful for using Redis as
    a cache. You can set the timeout value in seconds when you set the value for a
    key:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 的一个特性是能够为键值对设置过期时间。在这段时间过去后，键和值会被移除。这种技术特别适用于将 Redis 作为缓存使用。当你为键设置值时，你可以设置超时值（以秒为单位）：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, you set the expiration of `"timed"` to 10 seconds. Then, as you
    use the `pttl()` method, you can see the time remaining before expiration in milliseconds.
    When the value expires, both the key and value are automatically removed from
    the database. This feature and the fine-grained control of it that Redis offers
    are really useful. For simple caches, you may not need to write much more code
    to have your problem solved.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将 `"timed"` 的过期时间设置为 10 秒。然后，当你使用 `pttl()` 方法时，你可以看到在过期前剩余的时间（以毫秒为单位）。当值过期时，键和值都会自动从数据库中删除。这个特性和
    Redis 提供的对其的精细控制功能非常有用。对于简单的缓存，你可能不需要编写更多的代码就能解决问题。
- en: It’s worth noting that Redis holds its data in memory, so keep in mind that
    the data isn’t persistent; if the server crashes, some data is likely to be lost.
    To mitigate the possibility of data loss, Redis has options to manage persistence—everything
    from writing every change to disk as it occurs to making periodic snapshots at
    predetermined times to not saving to disk at all. You can also use the Python
    client’s `save()` and `bgsave()` methods to programmatically force a snapshot
    to be saved, either blocking until the save is complete with `save()` or saving
    in the background in the case of `bgsave()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Redis 将其数据存储在内存中，所以请记住，数据不是持久的；如果服务器崩溃，一些数据可能会丢失。为了减轻数据丢失的可能性，Redis 提供了管理持久性的选项——从每次更改发生时将更改写入磁盘，到在预定时间进行定期快照，甚至完全不保存到磁盘。你还可以使用
    Python 客户端的 `save()` 和 `bgsave()` 方法来程序性地强制保存快照，要么使用 `save()` 阻塞直到保存完成，要么在 `bgsave()`
    的情况下在后台保存。
- en: In this chapter, I’ve only touched on a small part of what Redis can do, as
    well as its data types and the ways it can manipulate them. If you’re interested
    in finding out more, several sources of documentation are available online, including
    at [https://redislabs.com](https://redislabs.com) and [https://redis-py.readthedocs.io](https://redis-py.readthedocs.io).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我仅简要介绍了 Redis 可以做什么，以及它的数据类型和它可以如何操作它们。如果你有兴趣了解更多，网上有多个文档来源可供参考，包括 [https://redislabs.com](https://redislabs.com)
    和 [https://redis-py.readthedocs.io](https://redis-py.readthedocs.io)。
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Uses of Key:Value stores'
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：键值存储的用途
- en: What sorts of data and applications would benefit most from a key:value store
    like Redis?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些类型的数据和应用会从像 Redis 这样的键值存储中受益最多？
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 23.7\. Documents in MongoDB
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 23.7\. MongoDB 中的文档
- en: Another popular NoSQL database is MongoDB, which is sometimes called a document-based
    database because it isn’t organized in rows and columns but instead stores documents.
    MongoDB is designed to scale across many nodes in multiple clusters while potentially
    handling billions of documents. In the case of MongoDB, a document is stored in
    a format called BSON (Binary JSON), so a document consists of key-value pairs
    and looks like a JSON object or Python dictionary. The following examples give
    you a taste of how you can use Python to interact with MongoDB collections and
    documents, but a word of warning is appropriate. In situations requiring scale
    and distribution of data, high insert rates, complex and unstable schemas, and
    so on, MongoDB is an excellent choice. However, MongoDB isn’t the best choice
    in many situations, so be sure to investigate your needs and options thoroughly
    before choosing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的 NoSQL 数据库是 MongoDB，有时被称为基于文档的数据库，因为它不是按行和列组织，而是存储文档。MongoDB 设计为可以跨多个集群的多个节点进行扩展，同时可以处理数十亿个文档。在
    MongoDB 的情况下，文档以称为 BSON（Binary JSON）的格式存储，因此文档由键值对组成，看起来像 JSON 对象或 Python 字典。以下示例展示了你可以如何使用
    Python 与 MongoDB 集合和文档交互，但有一个警告是适当的。在需要数据规模和分布、高插入率、复杂和不稳定的模式等情况，MongoDB 是一个很好的选择。然而，MongoDB
    在许多情况下并不是最佳选择，所以在选择之前，务必彻底调查你的需求和选项。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Running a MongoDB server**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行 MongoDB 服务器**'
- en: As with Redis, if you want to experiment with MongoDB, you need to have access
    to a MongoDB server. Numerous cloud-hosted Mongo services are available, but again,
    if you’re just experimenting, you’ll probably be better off running a Docker instance
    or installing on a server you own.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Redis 类似，如果你想尝试 MongoDB，你需要访问一个 MongoDB 服务器。有许多云托管 MongoDB 服务可用，但如果你只是进行实验，运行一个
    Docker 实例或在你自己的服务器上安装可能更好。
- en: As is the case with Redis, the easiest solution is to run a Docker instance.
    All you need to do if you have Docker is enter `> docker run -p 27017:27017 mongo`
    at the command line. On a Linux system, your package manager should do the job,
    and the Mac’s `brew install mongodb` will do it. On Windows systems, check on
    [www.mongodb.com](http://www.mongodb.com) for the Windows version and installation
    instructions. As with Redis, search online for any instructions on how to configure
    and start the server.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Redis 类似，最简单的解决方案是运行一个 Docker 实例。如果你有 Docker，只需在命令行中输入 `> docker run -p 27017:27017
    mongo` 即可。在 Linux 系统上，你的包管理器应该会完成这项工作，Mac 的 `brew install mongodb` 也会这样做。在 Windows
    系统上，请访问 [www.mongodb.com](http://www.mongodb.com) 查找 Windows 版本和安装说明。与 Redis 类似，在网上搜索有关如何配置和启动服务器的任何说明。
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As is the case with Redis, several Python client libraries connect to MongoDB
    databases. To give you an idea of how they work, look at pymongo. The first step
    in using pymongo is installing it, which you can do with pip:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Redis 类似，有几个 Python 客户端库连接到 MongoDB 数据库。为了让你了解它们的工作方式，看看 pymongo。使用 pymongo
    的第一步是安装它，你可以使用 pip 来完成：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you have pymongo installed, you can connect to a MongoDB server by creating
    an instance of MongoClient and specifying the usual connection details:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装了 pymongo 后，你可以通过创建 MongoClient 的实例并指定常规连接详情来连接到 MongoDB 服务器：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* host=’localhost’ and port=27017 are defaults and don’t need to be specified.**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 主机=’localhost’ 和端口=27017 是默认值，不需要指定。**'
- en: MongoDB is organized in terms of a database which contains collections, each
    of which can contain documents. Databases and collections don’t need to be created
    before you try to access them, however. If they don’t exist, they’re created as
    you insert into them, or they simply return no results if you try to retrieve
    records from them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是按数据库组织的，其中包含集合，每个集合可以包含文档。然而，在尝试访问它们之前，不需要创建数据库和集合。如果它们不存在，当你向它们插入数据时，它们会被创建，或者如果你尝试从它们检索记录，它们会简单地返回无结果。
- en: 'To test the client, make a sample document, which can be a Python dictionary:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试客户端，创建一个示例文档，它可以是 Python 字典：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Selects a database (which hasn’t been created yet)**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 选择一个数据库（尚未创建）**'
- en: '***2* Selects a collection in the database (also not yet created)**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 选择数据库中的集合（也尚未创建）**'
- en: '***3* Searches for first item; doesn’t throw exception even though neither
    collection nor database exists yet**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 搜索第一个项目；即使集合或数据库尚未存在，也不会抛出异常**'
- en: 'Here, you connect to a database and a collection of documents. In this case,
    they don’t exist, but they’ll be created as you access them. Note that no exceptions
    were raised even though the database and collection didn’t exist. When you asked
    for a list of the collections, however, you got an empty list because nothing
    has been stored in your collection. To store a document, use the collection’s
    `insert()` method, which returns the document’s unique `ObjectId` if the operation
    is successful:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将连接到一个数据库和一组文档。在这种情况下，它们尚不存在，但当你访问它们时将会被创建。请注意，即使数据库和集合不存在，也没有抛出任何异常。然而，当你请求集合列表时，你得到了一个空列表，因为你的集合中还没有存储任何内容。要存储文档，请使用集合的
    `insert()` 方法，如果操作成功，它将返回文档的唯一 `ObjectId`：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Unique ObjectId**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 唯一的ObjectId**'
- en: 'Now that you’ve stored a document in the `docs` collection, it shows up when
    you ask for the collection names in your database. When the document is stored
    in the collection, you can query for it, update it, replace it, and delete it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将文档存储在 `docs` 集合中，当你请求数据库中的集合名称时，它就会出现。当文档存储在集合中时，你可以查询它、更新它、替换它和删除它：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Retrieves first record**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取第一条记录**'
- en: '***2* Retrieves record matching specification—in this case, ObjectId**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取与指定条件匹配的记录——在这种情况下，ObjectId**'
- en: '***3* Updates record according to contents of $set object**'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 根据set对象的内 容更新记录**'
- en: '***4* Replaces record with new object**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 用新对象替换记录**'
- en: '***5* Deletes record matching specification**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 删除与指定条件匹配的记录**'
- en: 'First, notice that MongoDB matches according to dictionaries of the fields
    and their values to match. Dictionaries are also used to indicate operators, such
    as `$lt` (less than) and `$gt` (greater than), as well as commands such as `$set`
    for the update. The other thing to notice is that even though the record has been
    deleted and the collection is now empty, it still exists unless it’s specifically
    dropped:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，MongoDB根据字段及其值的字典进行匹配。字典还用于表示运算符，如 `$lt`（小于）和 `$gt`（大于），以及更新时使用的命令，如
    `$set`。另一件要注意的事情是，即使记录已被删除且集合现在是空的，除非它被明确删除，否则它仍然存在：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: MongoDB can do many other things, of course. In addition to operating on one
    record, versions of the same commands cover multiple records, such as `find_many`
    and `update_many`. MongoDB also supports indexing to improve performances and
    has several methods to group, count, and aggregate data, as well as a built in
    map-reduce method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，MongoDB可以做很多事情。除了操作单个记录外，同一命令的版本还覆盖了多个记录，如 `find_many` 和 `update_many`。MongoDB还支持索引以提高性能，并具有几个用于分组、计数和聚合数据的方法，以及内置的map-reduce方法。
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Quick Check: Uses of MONGODB'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：MONGODB的使用
- en: Thinking back over the various data samples you’ve seen so far and other types
    of data in your experience, which do you think would be well suited to being stored
    in a database like MongoDB? Would others clearly not be suited, and if so, why
    not?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下你迄今为止看到的各个数据样本以及你经验中的其他类型的数据，你认为哪些适合存储在像MongoDB这样的数据库中？哪些显然不适合，为什么？
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lab 23: Create a database'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'Lab 23: 创建数据库'
- en: Choose one of the datasets I’ve discussed in the past few chapters, and decide
    which type of database would be best for storing that data. Create that database,
    and write the code to load the data into it. Then choose the two most common and/or
    likely types of search criteria, and write the code to retrieve both single and
    multiple matching records.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 选择我在过去几章中讨论过的数据集之一，并决定哪种类型的数据库最适合存储该数据。创建该数据库，并编写代码将数据加载到其中。然后选择两种最常见和/或可能使用的搜索条件类型，并编写代码以检索单个和多个匹配的记录。
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Python has a Database API (DB-API) that provides a generally consistent interface
    for clients of several relational databases.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python有一个数据库API（DB-API），它为几个关系数据库的客户提供了一个一致的接口。
- en: Using an Object Relational Mapper (ORM) can make database code even more standard
    across databases.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象关系映射器（ORM）可以使数据库代码在数据库之间更加标准化。
- en: Using an ORM also lets you access relational databases through Python code and
    objects rather than SQL queries.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象关系映射器（ORM）还可以让你通过Python代码和对象而不是SQL查询来访问关系数据库。
- en: Tools such as Alembic work with ORMs to use code to make reversible changes
    to a relational database schema.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具如Alembic与ORM一起工作，使用代码对关系数据库模式进行可逆更改。
- en: Key:value stores such as Redis provide quick in-memory data access.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如Redis这样的键值存储提供快速内存数据访问。
- en: MongoDB provides scalability without the strict structure of relational databases.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 提供了无需关系数据库严格结构的可扩展性。
