- en: 10 Solving chemistry problems with quantum computers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 使用量子计算机解决化学问题
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Solving chemistry simulations with quantum computers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用量子计算机解决化学模拟问题
- en: Implementing the `Exp` operation and the Trotter–Suzuki method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Exp操作和Trotter-Suzuki方法
- en: Creating programs for phase estimation, decomposition, and so on
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于相位估计、分解等程序的代码
- en: 'In chapter 9, we used a number of new Q# features like user-defined types (UDTs)
    and running programs from Python hosts to help us write a quantum program that
    could estimate phases. As we will see in this chapter, phase estimation is commonly
    used in quantum algorithms to build up larger and more complex programs. In this
    chapter, we’ll look at our first practical application area: chemistry.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第9章中，我们使用了许多新的Q#特性，如用户定义类型（UDTs）和从Python宿主运行程序，帮助我们编写一个可以估计相位的量子程序。正如我们将在本章中看到的，相位估计在量子算法中通常用于构建更大、更复杂的程序。在本章中，我们将探讨我们的第一个实际应用领域：化学。
- en: 10.1 Real chemistry applications for quantum computing
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 量子计算的真实化学应用
- en: So far in this book, we’ve learned how to use quantum devices to do everything
    from chat with our friend Eve to help decide the fate of kings. In this chapter,
    though, we’ll get the chance to do something a bit more *practical*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们学习了如何使用量子设备从与我们的朋友伊夫聊天到帮助决定国王的命运。然而，在本章中，我们将有机会做一些更*实用*的事情。
- en: Note Now that we have what we need to solve harder problems with quantum computers,
    this chapter’s scenario is a little more complicated than most of our earlier
    games and scenarios. Don’t worry if things don’t make sense off the bat. Take
    your time and read things more slowly; we promise it will be worth your while!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：现在我们有了使用量子计算机解决更难问题的工具，本章的场景比我们之前的大部分游戏和场景都要复杂。如果一开始事情没有弄明白，请不要担心。花点时间慢慢阅读；我们保证这会值得你的付出！
- en: As it turns out, our quantum chemist friend Marie has hit the limit of what
    her classical computer can do to help her model different chemical systems. The
    problems that Marie solves with computational chemistry techniques can help to
    combat climate change, understand new materials, and improve energy usage across
    industries; if we can help her by using Q#, that could have quite a lot of practical
    applications. Fortunately, by using what we learned about estimating phases in
    chapter 9, we can do just that, so let’s jump in!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们的量子化学家朋友玛丽已经达到了她的经典计算机所能帮助她模拟不同化学系统的极限。玛丽使用计算化学技术解决的问题可以帮助对抗气候变化、理解新材料以及改善整个行业的能源使用；如果我们能通过使用Q#来帮助她，那么这可能会带来相当多的实际应用。幸运的是，通过使用我们在第9章中学到的关于估计相位的知识，我们能够做到这一点，所以让我们开始吧！
- en: Better tasting through chemistry
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过化学提升口感
- en: 'Any candy maker can tell you the difference that temperature makes: cook sugar
    to the “soft crack” stage, and we get taffy; but if we add a bit more energy,
    we can make any number of other delightful confections ranging from toffee to
    caramels. Everything about sugar—its taste, how it looks, and how it pulls—changes
    depending on the energy we pour into it via a saucepan. To no small degree, if
    we understand how the shape of sugar molecules changes as we add energy to a sweet
    melting pot, we understand sugar itself.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何糖果制造商都可以告诉你温度的影响：将糖煮至“软裂”阶段，我们得到太妃糖；但如果我们添加更多能量，我们可以制作从太妃糖到焦糖的各种美味甜点。关于糖的一切——它的味道、外观以及它的拉丝效果——都取决于我们通过锅子注入的能量。在很大程度上，如果我们理解了在甜的熔化锅中添加能量时糖分子形状的变化，我们就理解了糖本身。
- en: We see this effect not just with candy but throughout our lives. Water, steam,
    and ice are differentiated by understanding what shapes H2O can take—what shapes
    it can arrange itself in—as a function of energy. In many cases, we want to understand
    how the molecule arranges itself as a function of energy based on simulations
    rather than experiments. In this chapter, we’ll build on the techniques from the
    previous several chapters, showing how we can simulate the energy of chemical
    systems so that we can understand them as keenly as a candy maker understands
    their craft and use these chemical systems to make our lives better—maybe even
    a little sweeter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅在糖果上看到这种效果，在我们的生活中也随处可见。水、蒸汽和冰通过理解H2O可以采取的形状——作为能量的函数，它可以排列成什么形状——来区分。在许多情况下，我们希望通过模拟而不是实验来理解分子如何根据能量排列。在本章中，我们将基于前几章的技术，展示我们如何模拟化学系统的能量，以便我们能够像糖果制造商理解他们的工艺一样敏锐地理解它们，并利用这些化学系统使我们的生活变得更好——也许甚至更甜一些。
- en: To get a feel for how this works, we agree with Marie that we will start by
    looking at *molecular hydrogen*, or H2, as it is a simple enough chemical system
    that we can compare what we learn from our quantum program with what classical
    modeling tools can simulate. That way, as we use the same techniques to study
    molecules that are larger than can be simulated classically, we have a great test
    case we can fall back on to make sure everything is correct.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这是如何工作的，我们与玛丽达成一致，我们将首先查看 *分子氢*，或 H2，因为它是一个足够简单的化学系统，我们可以将我们从量子程序中学到的知识与我们能够用经典建模工具模拟的知识进行比较。这样，当我们使用相同的技巧来研究大于经典模拟能力的分子时，我们有一个很好的测试案例可以回退以确保一切正确。
- en: The simulation within the simulation
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟中的模拟
- en: 'In this chapter, our work with Marie involves two different kinds of simulation:
    using a classical computer to simulate a quantum computer, and using a quantum
    computer to simulate a different kind of quantum system. We’ll often want to do
    both, in that it’s helpful in building quantum chemistry applications to use a
    classical computer to simulate how a quantum computer simulates a quantum chemical
    system. That way, when we run our quantum simulation on actual quantum hardware,
    we can be assured that it works correctly.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们与玛丽合作的工作涉及两种不同类型的模拟：使用经典计算机模拟量子计算机，以及使用量子计算机模拟另一种类型的量子系统。我们经常需要同时进行这两种模拟，因为在构建量子化学应用时，使用经典计算机来模拟量子计算机如何模拟量子化学系统是有帮助的。这样，当我们运行我们的量子模拟在实际量子硬件上时，我们可以确信它是正确的。
- en: 'As shown in figure 10.1, Marie will start things off by using her expertise
    in quantum chemistry to describe a problem that she’s interested in solving with
    a quantum computer: in this case, understanding the structure of H2\. For the
    most part, these problems consist of learning properties of a special kind of
    matrix called a *Hamiltonian*. Once we get a Hamiltonian from Marie, we can then
    write a quantum operation much like the one shown in listing 10.1 to simulate
    it and learn things about it that Marie can use to understand how different chemicals
    behave. Throughout the rest of this chapter, we’ll develop the concepts and understanding
    that we need to implement the steps in figure 10.1.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 10.1 所示，玛丽将利用她在量子化学方面的专业知识，描述一个她希望用量子计算机解决的问题：在这种情况下，理解 H2 的结构。大部分这类问题都涉及学习一种特殊矩阵的性质，称为
    *哈密顿量*。一旦我们从玛丽那里得到哈密顿量，我们就可以编写一个类似于列表 10.1 中所示的量子操作来模拟它，并了解玛丽可以用它来理解不同化学物质的行为。在本章的其余部分，我们将开发我们需要实现图
    10.1 中步骤的概念和理解。
- en: '![](../Images/10-1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1](../Images/10-1.png)'
- en: Figure 10.1 Overview of the steps we’ll develop in this chapter to help Marie
    learn her molecule’s ground state energy image
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 本章我们将开发的步骤概述，以帮助玛丽学习其分子的基态能量图像
- en: 'We’ll implement the following steps in this chapter for our Hamiltonian simulation
    algorithm:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现以下步骤以用于我们的哈密顿量模拟算法：
- en: Collaborate with Marie to figure out which Hamiltonian describes the energy
    levels in the system she is interested in and an approximation of the ground (or
    lowest energy) state.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与玛丽合作，找出描述她感兴趣的系统中能级和基态（或最低能量态）近似的哈密顿量。
- en: Prepare that approximation of the ground state, and use the `Exp` operation
    in Q# to implement evolution of the quantum system for each term of the Hamiltonian.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备基态的近似，并使用 Q# 中的 `Exp` 操作来实现哈密顿量每一项的量子系统的演化。
- en: Using the Trotter–Suzuki decomposition implemented in the Q# function `DecomposedIntoTimeStepsCA`,
    simulate evolving our system under the action of all the terms of the Hamiltonian
    at once by breaking the evolution into small steps.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Q# 函数 `DecomposedIntoTimeStepsCA` 中实现的 Trotter–Suzuki 分解，通过将演化分解成小步骤，一次性模拟系统在哈密顿量所有项的作用下的演化。
- en: After simulating the evolution of the system under the Hamiltonian, use phase
    estimation to learn about the change in phase of our quantum device.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟系统在哈密顿量下的演化后，使用相估计来了解我们量子设备相的变化。
- en: Make a final correction to the phase we estimate for the system, after which
    we have the energy of the ground state for H2.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在估计系统相之后进行最终校正，之后我们就有 H2 的基态能量。
- en: The following listing shows these steps translated into code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了将这些步骤转换为代码的过程。
- en: Listing 10.1 Q# code that estimates the ground state energy of H2
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 估计 H2 基态能量的 Q# 代码
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Without further ado, then, let’s dive into the first quantum concept we need
    to help Marie: energy.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，无需多言，让我们深入探讨第一个需要帮助玛丽理解的量子概念：能量。
- en: 10.2 Many paths lead to quantum mechanics
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 多条路径通向量子力学
- en: 'Thus far, we’ve learned about quantum mechanics using the language of computing:
    bits, qubits, instructions, devices, functions, and operations. Marie’s way of
    thinking about quantum mechanics is very different, though (figure 10.2). For
    her, quantum mechanics is a physical theory that tells her how subatomic particles
    like electrons behave. Thinking in terms of physics and chemistry, quantum mechanics
    is a theory about the *stuff* that everything around us is made of.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用计算语言（比特、量子比特、指令、设备、函数和操作）来了解量子力学。然而，玛丽对量子力学的思考方式却非常不同（图10.2）。对她来说，量子力学是一种物理理论，它告诉她亚原子粒子（如电子）是如何行为的。从物理和化学的角度思考，量子力学是关于我们周围所有物质构成的**物质**的理论。
- en: '![](../Images/10-2.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-2.png)'
- en: Figure 10.2 Thinking about quantum mechanics in two very different ways
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 以两种非常不同的方式思考量子力学
- en: The two ways of thinking meet when it comes time to simulate how physical systems
    like molecules behave. We can use quantum computers to simulate how other quantum
    systems evolve and change over time. That is, quantum computing isn’t about only
    physics or chemistry; it can also help us understand scientific problems like
    the ones Marie runs into.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到模拟像分子这样的物理系统行为时，两种思维方式相遇了。我们可以使用量子计算机来模拟其他量子系统随时间如何演变和变化。也就是说，量子计算不仅仅是关于物理或化学；它还可以帮助我们理解玛丽遇到的科学问题。
- en: Information is the core of how we think about quantum computation, but to the
    physics and chemistry way of thinking, quantum mechanics relies heavily on the
    concept of *energy*. Energy tells us how physical systems as varied as balls and
    compasses are affected by the world around them, giving us a consistent way to
    understand each of these different systems. In figure 10.3, we can see how the
    state of a ball on a hill and the state of a compass can both be described in
    the same way using the concept of energy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 信息是我们思考量子计算的核心，但对于物理和化学的思维方式来说，量子力学在很大程度上依赖于**能量**的概念。能量告诉我们物理系统（如球和指南针）如何受到周围世界的影响，为我们提供了一个理解这些不同系统的统一方式。在图10.3中，我们可以看到如何使用能量的概念以相同的方式描述山顶上球的状况和指南针的状态。
- en: '![](../Images/10-3.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-3.png)'
- en: Figure 10.3 Using energy to understand how different physical systems are affected
    by their environments. A ball at a top of a hill and a compass pointing south
    are examples of higher-energy systems than a ball in a valley or a compass pointing
    north.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 利用能量来理解不同物理系统如何受到其环境的影响。山顶上的球和指向南方的指南针是比山谷中的球或指向北方的指南针具有更高能量的系统的例子。
- en: As it turns out, energy doesn’t just apply to classical systems like balls and
    compasses. Indeed, we can understand how *quantum* systems like electrons and
    nuclei behave by understanding the energy of different configurations. In quantum
    mechanics, energy is described by a special kind of matrix called a Hamiltonian.
    Any matrix that is its own adjoint can be used as a Hamiltonian, and Hamiltonians
    are *not* operations themselves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，能量不仅适用于像球和指南针这样的经典系统。确实，我们可以通过理解不同配置的能量来理解像电子和原子核这样的**量子系统**的行为。在量子力学中，能量由一种特殊的矩阵来描述，称为哈密顿量。任何其自身伴随矩阵的矩阵都可以用作哈密顿量，而哈密顿量本身**不是**操作。
- en: 'Recall from chapters 8 and 9 that the *adjoint* of a matrix *A* is its conjugate
    transpose, *A*^†. This concept is closely related to the `Adjoint` keyword in
    Q#: if an operation `op` can be simulated by the unitary matrix *U*, then the
    operation `Adjoint op` can be simulated by *U*^†.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从第8章和第9章回顾，矩阵 *A* 的 **伴随矩阵**是其共轭转置，记作 *A*†。这个概念与Q#中的`Adjoint`关键字密切相关：如果一个操作
    `op` 可以通过单位矩阵 *U* 来模拟，那么操作 `Adjoint op` 可以通过 *U*† 来模拟。
- en: In this chapter, we’ll learn all the tools and techniques to figure out the
    energies of quantum systems for which we have a Hamiltonian. Often the process
    to get the Hamiltonians for systems is a collaboration, but once we have them
    and a few more pieces of information, we can estimate the energy of that system.
    This process is called *Hamiltonian simulation* and is critical to many different
    applications of quantum computing, including chemistry.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习所有工具和技术来找出具有哈密顿量的量子系统的能量。通常，获取系统哈密顿量的过程是一个合作过程，但一旦我们有了它们以及一些更多信息，我们就可以估算该系统的能量。这个过程被称为*哈密顿量模拟*，对于量子计算在许多不同应用中都是至关重要的，包括化学。
- en: 'Tip We’ve seen a few examples of Hamiltonians in previous chapters: all of
    the Pauli matrices (*x*, *y*, and *z*) are examples of Hamiltonians as well as
    being unitary matrices. Not all unitary matrices can be used as Hamiltonians,
    though! Most of the examples in this chapter take some more work before we can
    apply them as quantum operations.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：我们在前面的章节中看到了几个哈密顿量的例子：所有的泡利矩阵（*x*，*y*和*z*）都是哈密顿量的例子，同时也是单位矩阵。但并非所有单位矩阵都可以用作哈密顿量！本章中的大多数例子在我们可以将它们作为量子操作应用之前都需要做一些额外的工作。
- en: Marie is interested in understanding the energy of the bonds in her chemicals.
    So it makes sense to come up with a Hamiltonian that describes her molecule; then
    we can help estimate the energy she is interested in. In chemistry, this energy
    is often called the *ground state energy*, and the corresponding state is known
    as the *ground state* (or minimum energy state).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽对了解她化学物质中键的能量感兴趣。因此，提出一个描述她的分子的哈密顿量是有意义的；然后我们可以帮助她估算她感兴趣的能量。在化学中，这种能量通常被称为*基态能量*，相应的状态被称为*基态*（或最低能量状态）。
- en: Once we have a Hamiltonian, the next step is to figure out how to construct
    the operations that will simulate how the quantum system changes in time as described
    by the Hamiltonian. In the next section, we’ll learn how to describe the evolution
    of a quantum system under a Hamiltonian.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了哈密顿量，下一步就是弄清楚如何构建操作来模拟量子系统随时间的变化，正如哈密顿量所描述的那样。在下一节中，我们将学习如何描述在哈密顿量下量子系统的演化。
- en: Then, with operators in hand that represent the Hamiltonian, the next challenge
    is to figure out how to simulate the Hamiltonians on our quantum device. There
    probably won’t be just a single operation built into the physical device that
    will do exactly what we need, so we must find a way to decompose our operations
    for our Hamiltonian in terms of what our device can provide. In section 10.4,
    we’ll cover how we can take any operations and express them in terms of Pauli
    operations, which are commonly available as hardware instructions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有了代表哈密顿量的算子在手，下一个挑战是如何在我们的量子设备上模拟哈密顿量。物理设备中可能不会内置一个能够完全满足我们需求的单一操作，因此我们必须找到一种方法，将我们的哈密顿量操作分解为我们的设备可以提供的形式。在第10.4节中，我们将介绍如何将任何操作表示为泡利操作，这些操作通常作为硬件指令可用。
- en: Once we have our Hamiltonian expressed as a sum of Pauli matrices, how do we
    simulate all of them on our system? Likely we will have multiple terms that all
    sum together to represent the action of the Hamiltonian, and they don’t necessarily
    commute. In section 10.6, we will learn how to use the Trotter–Suzuki method to
    apply a little of each term in the operation to simulate evolving under the entire
    thing at once. Then we will have evolved our quantum system in a way that represents
    Marie’s Hamiltonian!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将我们的哈密顿量表示为泡利矩阵的和，我们如何在我们的系统中模拟所有这些呢？很可能会有一系列项相加来表示哈密顿量的作用，而这些项不一定是对易的。在第10.6节中，我们将学习如何使用Trotter-Suzuki方法将操作中的每一项稍微应用一次来模拟整个系统的演化。然后我们将以代表玛丽哈密顿量的方式演化我们的量子系统！
- en: Finally, to work out the energy of the system described by the Hamiltonian we
    found, we can use phase estimation to help Marie. In section 10.7, we’ll get to
    use the algorithm we learned in chapter 9 to explore the phase applied to our
    qubits by simulating the Hamiltonian. Let’s get to it!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了计算由我们找到的哈密顿量描述的系统的能量，我们可以使用相位估计来帮助玛丽。在第10.7节中，我们将使用在第9章中学到的算法来模拟哈密顿量对我们的量子比特施加的相位。让我们开始吧！
- en: 10.3 Using Hamiltonians to describe how quantum systems evolve in time
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 使用哈密顿量描述量子系统随时间演化的过程
- en: Figure 10.4 shows a tracker for the steps to simulate another quantum system
    with our quantum computer. To use a Hamiltonian to describe the energy of a physical
    or chemical system, we need to look at its eigenstates and their eigenvalues.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4显示了一个用于模拟我们量子计算机上的另一个量子系统的步骤跟踪器。为了使用哈密顿量来描述物理或化学系统的能量，我们需要查看其本征态及其本征值。
- en: '![](../Images/10-4.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4](../Images/10-4.png)'
- en: Figure 10.4 We are starting here by learning about Marie’s H2 molecule and which
    Hamiltonian describes its evolution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 我们从这里开始学习关于玛丽（Marie）的H2分子以及描述其演化的哈密顿量。
- en: Remember from chapter 9 that if a state |*Ψ*〉 is an eigenstate of an operation
    `op`, then applying `op` to a register in the state |*Ψ*〉 at most applies a global
    phase to |*Ψ*〉. This phase is called the *eigenvalue* or *eigenphase* corresponding
    to that eigenstate. Like all other global phases, this eigenphase cannot be directly
    observed, but we can use the `Controlled` functor that we learned about in chapter
    9 to turn that phase into a local phase.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 记住第9章的内容，如果一个状态|*Ψ*〉是操作`op`的本征态，那么将`op`应用于处于状态|*Ψ*〉的寄存器最多只对|*Ψ*〉应用一个全局相位。这个相位被称为对应于该本征态的*本征值*或*本征相位*。像所有其他全局相位一样，这个本征相位不能直接观察到，但我们可以使用第9章中我们了解到的`Controlled`函子将这个相位转换为局部相位。
- en: 'Each eigenstate of a Hamiltonian is a state of constant energy; just like quantum
    operations don’t do anything to eigenstates, a system that is in an eigenstate
    of its Hamiltonian will stay at that energy over time. The other property of eigenstates
    that we saw in chapter 9 still holds here as well: the phase of each eigenstate
    evolves in time.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 哈密顿量的每个本征态是一个恒定能量的状态；就像量子操作对本征态不做任何事情一样，处于其哈密顿量本征态的系统将随时间保持在那个能量上。我们在第9章中看到的本征态的另一个性质在这里同样适用：每个本征态的相位随时间演化。
- en: The observation that the phases of eigenstates evolve in time is the content
    of Schrödinger’s equation, one of the most important equations in all of quantum
    physics. Schrödinger’s equation tells us that as a quantum system evolves, each
    eigenstate of a Hamiltonian accumulates a phase proportional to its energy. Using
    math, we can write Schrödinger’s equation as shown in figure 10.5.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到本征态的相位随时间演化是薛定谔方程的内容，这是量子物理中最重要方程之一。薛定谔方程告诉我们，随着量子系统的演化，哈密顿量的每个本征态都会积累与其能量成比例的相位。使用数学，我们可以将薛定谔方程写成如图10.5所示的形式。
- en: '![](../Images/10-5.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5](../Images/10-5.png)'
- en: Figure 10.5 Schrödinger’s equation, written out in mathematical notation
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 薛定谔方程，用数学符号表示
- en: The real experts were the friends we made along the way
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在旅途中结识的真正专家是我们的朋友。
- en: How can it be that this is chapter 10, and we’re seeing the most important equation
    in quantum physics for the first time? Developing quantum applications may be
    closely connected to quantum physics, but it’s not the same thing, and we don’t
    need to be a physics expert to write quantum applications—we can be, if we’re
    interested, but we don’t have to be. Schrödinger’s equation only enters the picture
    here because we need it to understand how quantum computers may be used for practical
    impact.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么可能这是第10章，而我们第一次看到量子物理中最重要的方程？开发量子应用可能与量子物理密切相关，但这不是同一件事，我们不需要成为物理专家就能编写量子应用——如果我们感兴趣，我们可以，但不必。薛定谔方程之所以出现在这里，是因为我们需要它来理解量子计算机如何用于实际影响。
- en: Just like our friend Marie is an expert in quantum chemistry and not quantum
    computing, we don’t need to know everything to do something awesome. That’s what
    friends are for!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的朋友玛丽是量子化学专家而不是量子计算专家一样，我们不需要知道所有事情就能做些了不起的事情。这就是朋友的作用！
- en: Tip Schrödinger’s equation relates how phases of different states evolve in
    time to the energy of those states. Since global phases are unobservable, and
    since eigenstates of Hamiltonians only acquire global phases as they evolve, Schrödinger’s
    equation tells us that eigenstates of Hamiltonians don’t evolve in time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：薛定谔方程将不同状态的相位随时间的演化与这些状态的能量联系起来。由于全局相位是不可观测的，并且由于哈密顿量的本征态只有在演化过程中才会获得全局相位，薛定谔方程告诉我们哈密顿量的本征态不会随时间演化。
- en: Schrödinger’s equation is most critical for us in this chapter because it relates
    the energy of a system to phase, a very helpful connection given that in chapter
    9, we learned how to do phase estimation! There are other ways Schrödinger’s equation
    is useful, one being another way to look at implementing operations on quantum
    systems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，薛定谔方程对我们来说至关重要，因为它将系统的能量与相位联系起来，这是一个非常有用的联系，因为我们在第 9 章中学习了如何进行相位估计！薛定谔方程还有其他有用的方式，其中一种是通过另一种方式来看待在量子系统上实施操作。
- en: One way to implement the rotations we’ve seen so far in the book is to set up
    the right Hamiltonian and then—wait. The time derivative (*∂*/*∂**t*) in Schrödinger’s
    equation tells us that the way the state of our qubits rotate is entirely described
    by the energy associated with each state. For example, Schrödinger’s equation
    tells us that if our Hamiltonian is *H* = *ωZ* for some number *ω*, if we want
    to rotate by an angle *θ* about the *Z*-axis, we can let our qubit evolve for
    time *t* = *θ* / *ω*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实现书中所见的旋转的一种方法是为它们设置正确的哈密顿量，然后——等等。薛定谔方程中的时间导数 (*∂*/*∂**t*) 告诉我们，我们量子比特的状态旋转方式完全由每个状态的能量描述。例如，薛定谔方程告诉我们，如果我们的哈密顿量
    *H* = *ωZ* 对于某个数 *ω*，如果我们想绕 *Z*-轴旋转一个角度 *θ*，我们可以让我们的量子比特演化时间 *t* = *θ* / *ω*。
- en: 'Exercise 10.1: Rotations all around'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.1：全方位旋转
- en: Try writing other rotations shown earlier in the book (e.g., `Rx` and `Ry`)
    as Hamiltonians.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将书中早些时候展示的其他旋转（例如，`Rx` 和 `Ry`）写成哈密顿量。
- en: Exercise solutions
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 练习解答
- en: 'All solutions for exercises in this book can be found in the companion code
    repo: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).
    Just go to the folder for the chapter you are in and open the Jupyter notebook
    with the name that mentions exercise solutions.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所有练习的解答都可以在配套代码仓库中找到：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。只需进入你所在章节的文件夹，然后打开提及练习解答的
    Jupyter 笔记本。
- en: Listing 10.2 shows a simple Q# operation that simulates evolving under the Hamiltonian
    *H* = *ω**Z*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 展示了一个简单的 Q# 操作，它模拟在哈密顿量 *H* = *ω**Z* 下演化。
- en: Note In practice, much of the challenge of building a quantum computer is ensuring
    that qubits *don’t* evolve except as instructed by a quantum program. It wouldn’t
    be very useful if walking away from our quantum device for a moment meant that
    all our qubits were in totally different states when we got back. This is part
    of why, as quantum developers, we tend to think at the level of instructions sent
    to a device—that is, quantum operations—and not directly in terms of Hamiltonians.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在实践中，构建量子计算机的许多挑战在于确保量子比特不会按照量子程序的指令之外的方式演化。如果我们离开我们的量子设备一会儿，而当我们回来时所有量子比特都处于完全不同的状态，那就没什么用了。这也是为什么作为量子开发者，我们倾向于在指令层面思考——即量子操作——而不是直接用哈密顿量来思考。
- en: Switching gears for a moment and temporarily thinking in terms of Hamiltonians
    gives us a bit of what we need to start making progress on the problem Marie asked
    us to help with. After all, the problems Marie works with are much easier to describe
    in that language. For example, in chapter 9, we saw how we can learn about the
    phase applied by rotations like the one Dagonet hid from Lancelot. We can also
    express Dagonet’s and Lancelot’s game in terms of Hamiltonians, though. Suppose
    that Dagonet was hiding the rotation angle 2.1*π*; then, since his rotation was
    about the *Z*-axis, we could also describe that hidden rotation as a hidden Hamiltonian
    *H* = –2.1*π* *z*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时转换一下思路，从哈密顿量的角度思考，这让我们对解决玛丽请求我们帮助的问题有了些许进展。毕竟，玛丽处理的问题用那种语言描述起来更容易。例如，在第 9
    章中，我们看到了如何了解像 Dagonet 从兰斯洛特那里隐藏的旋转所施加的相位。我们也可以用哈密顿量的方式表达 Dagonet 和兰斯洛特的比赛。假设 Dagonet
    隐藏的旋转角度是 2.1*π*；那么，由于他的旋转是关于 *Z*-轴的，我们也可以将这个隐藏的旋转描述为隐藏的哈密顿量 *H* = –2.1*π* *z*。
- en: Note We need the − sign due to the − sign in Schrödinger’s equation. Getting
    this wrong is about as common in quantum programming as off-by-one errors in other
    languages, so don’t stress out if you forget once or twice, or if you forget that
    pesky minus sign almost every time. You’re still doing great.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们需要减号（-）是因为薛定谔方程中的减号。在量子编程中，犯这样的错误就像在其他语言中犯“减一”错误一样常见，所以如果你偶尔忘记一次或两次，或者几乎每次都忘记那个讨厌的减号，请不要担心。你仍然做得很好。
- en: Using this kind of description, Lancelot’s scale corresponds to how long he
    lets his qubits evolve under Dagonet’s hidden Hamiltonian. While thinking in terms
    of a game makes it easier to write quantum programs to learn Dagonet’s hidden
    rotation, thinking in terms of a Hamiltonian makes it easier to map to the kinds
    of physical concepts that Marie is concerned with, such as field strengths and
    time. The only tricky part is that we need to multiply the angle for `Rz` by `2.0`,
    as `Rz` multiplies its angle by –1 / 2 by convention in Q#. Since Schrödinger’s
    equation tells us that the angle needs a minus sign, the `2.0` gives us the angle
    we need to match figure 10.5.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种描述，兰斯洛特的尺度对应于他在达戈内特的隐藏哈密顿量下让量子比特演化的时间长度。虽然从游戏的角度思考使得编写学习达戈内特隐藏旋转的量子程序变得容易，但用哈密顿量的角度思考则更容易映射到玛丽关心的物理概念，例如场强和时间。唯一棘手的部分是我们需要将
    `Rz` 的角度乘以 `2.0`，因为在 Q# 中，按照惯例 `Rz` 会将其角度乘以 -1/2。由于薛定谔方程告诉我们角度需要一个负号，所以 `2.0`
    给出了我们需要的角度，以匹配图 10.5。
- en: Listing 10.2 Evolving under the Hamiltonian *H* = *ω**z*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.2 在哈密顿量 *H* = *ω**z* 下演化
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Operation that simulates evolution under *H* = *ω**Z* using Q#
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Q# 模拟 *H* = *ω**Z* 下演化的操作
- en: ❷ *ω* says how large energies described the Hamiltonian are. This plays the
    role of Dagonet’s hidden angle from chapter 9!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ *ω* 表示哈密顿量描述的能量的大小。这扮演了第 9 章中达戈内特隐藏角度的角色！
- en: ❸ How long we want to simulate the Hamiltonian. This is analogous to Lancelot’s
    scale from chapter 9.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们想要模拟哈密顿量的时间长度。这与第 9 章中兰斯洛特的尺度类似。
- en: ❹ The actual simulation is just one line, since rotations about the *Z*-axis
    are built into Q#.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 实际的模拟只是一行，因为绕 *Z*-轴的旋转已经内置到 Q# 中。
- en: Since Schrödinger’s equation tells us that evolving Hamiltonians rotates quantum
    systems according to their energy, if we can *simulate* the Hamiltonian that Marie
    gives us, then we can play exactly the same phase estimation game as in chapter
    9 to learn the energy levels of that Hamiltonian.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于薛定谔方程告诉我们演化的哈密顿量会根据其能量旋转量子系统，如果我们能够 *模拟* 玛丽给出的哈密顿量，那么我们可以玩与第 9 章中完全相同的相位估计游戏来学习该哈密顿量的能级。
- en: 'Deep dive: Hamiltonians are the one thing I can control'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：哈密顿量是我唯一能控制的东西
- en: When we first introduced quantum operations like `H`, `X`, and `Z`, you may
    have wondered how we would implement them on a real quantum device. Using the
    concept of a Hamiltonian, we can revisit that question and explore how intrinsic
    quantum operations work on hardware.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次介绍像 `H`、`X` 和 `Z` 这样的量子操作时，你可能想知道我们如何在真实量子设备上实现它们。使用哈密顿量的概念，我们可以重新审视这个问题，并探索内在量子操作在硬件上的工作方式。
- en: When a magnetic field is applied to a physical system with a magnetic dipole
    (e.g., an electron spin), the Hamiltonian for that system includes a term that
    describes how the system interacts with the magnetic field. Typically, we write
    this as term as *H* = γ*BZ*, where *B* is the strength of that magnetic field
    and γ is a number that describes how strongly that system responds to magnetic
    fields. Thus, to apply an `Rz` rotation in quantum hardware that uses electron
    spins to implement qubits, we can turn on a magnetic field and just wait the right
    length of time. Similar effects can be used to implement other Hamiltonian terms
    or control the Hamiltonian for other quantum devices.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个磁场被施加到一个具有磁偶极子（例如，电子自旋）的物理系统上时，该系统的哈密顿量包括一个描述系统如何与磁场相互作用的项。通常，我们将其写成 *H*
    = γ*BZ*，其中 *B* 是该磁场的强度，γ 是一个描述该系统对磁场的响应强度的数字。因此，为了在量子硬件上应用 `Rz` 旋转，我们可以打开一个磁场，然后等待正确的时间长度。类似的效果可以用来实现其他哈密顿量项或控制其他量子设备的哈密顿量。
- en: The same principle is used in other quantum technologies as well, such as nuclear
    magnetic resonance (NMR) imaging, where good classical algorithms have been developed
    to build effective Hamiltonians by *pulsing* magnetic fields at the right frequency
    or building complex shaped pulses to apply a quantum operation. Traditionally,
    in NMR and in quantum computing more generally, pulse-design algorithms are given
    whimsical acronyms as names, such as GRAPE, CRAB, D-MORPH, and even ACRONYM. Regardless
    of whimsy, though, these algorithms let us use classical computers to design quantum
    operations, given control Hamiltonians like *H* = γ*BZ*. If you’re interested
    in learning more, the original GRAPE paper lays out a lot of the optimal control
    theory that has been used ever since.^a
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原理也应用于其他量子技术，例如核磁共振成像（NMR），在那里已经开发出有效的经典算法，通过在正确的频率下脉冲磁场或构建复杂形状的脉冲来应用量子操作。在NMR和量子计算更广泛的应用中，脉冲设计算法通常被赋予一些有趣的缩写作为名称，如GRAPE、CRAB、D-MORPH，甚至ACRONYM。然而，不管多么有趣，这些算法都让我们能够使用经典计算机来设计量子操作，给定控制哈密顿量如*H*
    = γ*BZ*。如果你对了解更多感兴趣，原始的GRAPE论文概述了自那时以来一直使用的许多最优控制理论.^a
- en: In practice, this isn’t the complete story, of course. Not only is there a lot
    more to designing control pulses, but for fault-tolerant quantum computers, the
    intrinsic operations that we work with as quantum developers don’t directly map
    to physical operations in the same way as on near-term hardware. Rather, these
    low-level hardware operations are used to build error-correcting codes such that
    a single intrinsic operation may decompose into many different pulses being applied
    across our device.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这当然不是完整的故事。设计控制脉冲还有很多内容，而且对于容错量子计算机来说，我们作为量子开发者所使用的内在操作并不直接映射到近期能硬件中的物理操作。相反，这些低级硬件操作被用来构建纠错码，这样单个内在操作可能会分解成许多不同的脉冲，这些脉冲被应用到我们的设备上。
- en: '^a Navin Khaneja et al., “Optimal Control of Coupled Spin Dynamics: Design
    of NMR Pulse Sequences by Gradient Ascent Algorithms,” Journal of Magnetic Resonance
    172, no. 2 (2005): 296, [https://www.sciencedirect.com/science/article/abs/pii/S1090780704003696](https://www.sciencedirect.com/science/article/abs/pii/S1090780704003696).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ^a Navin Khaneja等人，“耦合自旋动力学最优控制：通过梯度上升算法设计NMR脉冲序列”，《磁共振杂志》172卷第2期（2005年）：296页，[https://www.sciencedirect.com/science/article/abs/pii/S1090780704003696](https://www.sciencedirect.com/science/article/abs/pii/S1090780704003696).
- en: Suppose that instead of *H* = *ω**Z*, Marie asks if we can simulate *H* = *ω**X*.
    Fortunately, Q# provides rotations about the *X*-axis as well, so we can modify
    the call to `Rz` in listing 10.2 with a call to `Rx`. Unfortunately, not every
    Hamiltonian Marie is interested in is as simple as *H* = *ω**Z* or *H* = *ω**X*,
    so let’s look at what quantum development techniques we can use to simulate Hamiltonians
    that are a bit more difficult.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Marie不是询问我们能否模拟*H* = *ω**Z*，而是询问我们能否模拟*H* = *ω**X*。幸运的是，Q#也提供了关于*X*-轴的旋转，因此我们可以通过调用`Rx`来修改列表10.2中的`Rz`调用。不幸的是，Marie感兴趣的不是像*H*
    = *ω**Z*或*H* = *ω**X*那样简单的哈密顿量，所以让我们看看我们可以使用哪些量子开发技术来模拟稍微复杂一些的哈密顿量。
- en: These aren’t the Hamiltonians we are looking for
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是我们寻找的哈密顿量
- en: 'It is likely that when we start talking to Marie, she will also be working
    on describing Hamiltonians for her system in her simulation and modeling software.
    However, these are probably *fermionic Hamiltonians*, which are different from
    the kind we are using here to describe how quantum devices change in time. As
    part of the workflow for our collaboration with Marie, we likely need to use some
    tools like NWChem ([https://nwchemgit.github.io](https://nwchemgit.github.io))
    to convert between a Hamiltonian that describes how a chemical changes in time
    and how qubits change in time. It’s out of scope for this book to look at these
    methods in detail, but there are great software tools that can help with this.
    Check out the Quantum Development Kit documentation for details if you’re interested:
    [https://docs.microsoft.com/azure/quantum/user-guide/libraries/ chemistry/](https://docs.microsoft.com/azure/quantum/user-guide/libraries/chemistry/).
    This isn’t a big deal for now, just a handy tip for when you are talking to your
    collaborators!'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能当我们开始与玛丽交谈时，她也会在她的模拟和建模软件中描述她系统的哈密顿量。然而，这些可能是费米子哈密顿量，与我们用来描述量子设备随时间变化的哈密顿量不同。作为与我们与玛丽合作的流程的一部分，我们可能需要使用一些工具，如
    NWChem ([https://nwchemgit.github.io](https://nwchemgit.github.io))，在描述化学随时间变化和量子比特随时间变化的哈密顿量之间进行转换。本书的范围不包括对这些方法的详细探讨，但有一些优秀的软件工具可以帮助完成这项工作。如果您对此感兴趣，请查看量子开发套件文档以获取详细信息：[https://docs.microsoft.com/azure/quantum/user-guide/libraries/chemistry/](https://docs.microsoft.com/azure/quantum/user-guide/libraries/chemistry/)。目前这并不是什么大问题，只是当您与您的合作者交谈时的一个实用提示！
- en: 10.4 Rotating around arbitrary axes with Pauli operations
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 使用泡利算子绕任意轴旋转
- en: Moving up in complexity, perhaps Marie is interested in something that takes
    more than a single-qubit Hamiltonian to describe (figure 10.6). If she gives us
    a Hamiltonian like *H* = *ω**X* ⊗ *X*, what can we do to simulate it? Fortunately,
    what we learned about rotations in part 1 of this book is still useful for that
    kind of two-qubit Hamiltonian, as we can think of it as describing another kind
    of rotation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂性上升的过程中，也许玛丽对需要比单个量子比特哈密顿量更多来描述的东西感兴趣（图 10.6）。如果她给我们一个如 *H* = *ω**X* ⊗ *X*
    的哈密顿量，我们能做些什么来模拟它？幸运的是，我们在本书第一部分学到的关于旋转的知识对于这种双量子比特哈密顿量仍然有用，因为我们可以将它视为描述另一种类型的旋转。
- en: '![](../Images/10-4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-4.png)'
- en: Figure 10.6 In step 2, we look at how to decompose our Hamiltonian into generalized
    rotations that are easier to simulate.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 在步骤 2 中，我们看看如何将我们的哈密顿量分解成更易于模拟的广义旋转。
- en: Note In the previous section, we saw that rotations like `Rx`, `Ry`, and `Rz`
    correspond to Hamiltonians like *X*, *Y*, and *Z*, respectively. We can think
    of two-qubit Hamiltonians like *X* ⊗ *X* as specifying an axis in much the same
    way. It turns out there are 15 possible orthogonal rotation axes for a two-qubit
    register, as opposed to the 3 dimensions we get for a single-qubit register. So
    to draw something as a picture, we’d need 13 more dimensions than paper normally
    has, making it somewhat difficult to illustrate!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在上一节中，我们了解到旋转如 `Rx`、`Ry` 和 `Rz` 分别对应于哈密顿量如 *X*、*Y* 和 *Z*。我们可以将类似 *X* ⊗ *X*
    的双量子比特哈密顿量视为以类似的方式指定一个轴。实际上，对于双量子比特寄存器，有 15 个可能的正交旋转轴，而单量子比特寄存器只能得到 3 个维度。因此，为了绘制一个图像，我们需要比通常的纸张多
    13 个维度，这使得说明变得有些困难！
- en: This rotation doesn’t look like any of the built-in (that is, intrinsic) instructions
    we’ve seen so far, so it might seem like we’re stuck. As it turns out, though,
    we can still simulate this Hamiltonian using *single*-qubit rotations like `Rx`,
    as long as we use some two-qubit operations on either side. In this section, we’ll
    see how that works and how Q# makes it easy to automate applying multiple-qubit
    rotations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种旋转看起来不像我们之前见过的任何内置（即内在）指令，所以我们可能觉得我们陷入了困境。然而，实际上，只要我们在两侧使用一些双量子比特操作，我们仍然可以使用
    `Rx` 这样的单量子比特旋转来模拟这个哈密顿量。在本节中，我们将看到这是如何工作的，以及 Q# 如何使自动化应用多量子比特旋转变得容易。
- en: By way of getting started, let’s look at some of the ways we can change what
    quantum operations do by surrounding them with other operations. We can always
    use math to reason about things, as we saw in chapter 9, but fortunately Q# also
    provides some nice testing functions and operations that can help us. For example,
    in chapter 9, we saw that surrounding a `CNOT` operation with `H` operations gives
    us a `CNOT` going in the other direction. Let’s see how we can check that using
    Q#!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了入门，让我们看看我们可以通过围绕其他操作来改变量子操作的方式。我们总是可以使用数学来推理事物，就像我们在第9章中看到的那样，但幸运的是，Q#也提供了一些很好的测试函数和操作，可以帮助我们。例如，在第9章中，我们看到将`CNOT`操作与`H`操作包围起来可以给我们一个方向相反的`CNOT`。让我们看看我们如何使用Q#来检查这一点！
- en: Tip Recall that the `within`/`apply` block in listing 10.3 applies the shoes-and-socks
    principle that we first learned about in chapter 9\. Most of the code examples
    in this section use `within`/`apply` blocks to help keep track of our shoes-and-socks
    thinking.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：回想一下列表10.3中的`within`/`apply`块应用了我们在第9章首次了解的鞋袜原则。本节中的大多数代码示例都使用`within`/`apply`块来帮助我们跟踪鞋袜思维。
- en: Listing 10.3 Changing the control and target of a `CNOT`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 更改`CNOT`的控制和目标
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The operations and functions in the Microsoft.Quantum.Diagnostics namespace
    help with testing and debugging quantum programs and can be very useful to make
    sure programs work as intended.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Microsoft.Quantum.Diagnostics命名空间中的操作和函数有助于测试和调试量子程序，并且对于确保程序按预期工作非常有用。
- en: ❷ To compare the two ways of writing a CNOT operation, we need each to be callable
    as an operation that takes an array of qubits representing a quantum register.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为了比较两种编写CNOT操作的方式，我们需要每种方式都能作为一个操作，该操作接受一个表示量子寄存器的qubit数组。
- en: ❸ To check the equivalence that we first saw in chapter 7, we can write a second
    operation that reverses the control and target of a CNOT operation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为了检查我们在第7章首次看到的等价性，我们可以编写第二个操作，该操作反转CNOT操作的控制和目标。
- en: ❹ The first input specifies how large a register each operation acts on, and
    the second and third inputs represent the operations being compared. If the operations
    do anything different whatsoever, the assertion fails and the quantum program
    ends.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 第一个输入指定了每个操作作用在寄存器上的大小，第二个和第三个输入代表正在比较的操作。如果操作有任何不同之处，断言失败，量子程序结束。
- en: ❺ If we see the message “Woohoo!”, we can safely conclude that the two operations
    cannot be distinguished from each other by looking at what they do to the states
    of quantum registers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果我们看到消息“Woohoo!”，我们可以安全地得出结论，这两个操作在观察它们对量子寄存器状态的影响时是无法区分的。
- en: Note Assertions like `AssertOperationsEqualReferenced` only make sense when
    run on a simulator, as running them requires violating the no-cloning theorem.
    On actual hardware, these kinds of assertions would be stripped out, just as running
    Python with the `-O` command-line argument disables the `assert` keyword. That
    means Q# assertions give us a way to cheat *safely*, since quantum programs using
    assertions do the same thing regardless of whether we cheat.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：像`AssertOperationsEqualReferenced`这样的断言只有在模拟器上运行时才有意义，因为运行它们需要违反不可克隆定理。在实际硬件上，这些类型的断言会被移除，就像使用带有`-O`命令行参数的Python禁用`assert`关键字一样。这意味着Q#断言为我们提供了一种安全作弊的方法，因为使用断言的量子程序无论我们是否作弊都会做同样的事情。
- en: 'Exercise 10.2: Verifying CNOT identities'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.2：验证CNOT恒等式
- en: Use QuTiP to verify that the two operations `ApplyCNOT` and `ApplyCNOTTheOtherWay`
    can be simulated by the same unitary matrix and thus do the exact same thing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用QuTiP验证两个操作`ApplyCNOT`和`ApplyCNOTTheOtherWay`可以由相同的幺正矩阵模拟，因此它们确实做同样的事情。
- en: 'Exercise 10.3: Three CNOTs make a SWAP'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.3：三个CNOT实现一个SWAP
- en: 'Just as we can use three classical `XOR` instructions to implement an in-place
    classical swap, we can use three `CNOT` operations to do the same thing as a single
    `SWAP` operation. The following Q# snippet does the same thing as `SWAP(left,
    right)`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以使用三个经典的`XOR`指令来实现就地经典交换一样，我们也可以使用三个`CNOT`操作来完成单个`SWAP`操作。以下Q#代码片段与`SWAP(left,
    right)`做同样的事情：
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Double-check that this is the same as `SWAP(left, right)` by using `AssertOperationsEqualReferenced`
    and by using QuTiP.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`AssertOperationsEqualReferenced`和QuTiP来双重检查这确实与`SWAP(left, right)`相同。
- en: '*Extra credit*: `SWAP(left, right)` is the same as `SWAP(right, left)`, so
    the previous snippet should work even if we start with `CNOT(right, left)` instead.
    Double-check that!'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*额外加分*：`SWAP(left, right)`与`SWAP(right, left)`相同，因此前面的代码片段即使以`CNOT(right, left)`开始也能正常工作。请再次检查！'
- en: 'Deep dive: The Choi–Jamiłkowski isomorphism'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：Choi–Jamiłkowski同构
- en: The `AssertOperationsEqualReferenced` operation in listing 10.3 works using
    a neat piece of mathematics called the *Choi–Jamiłkowski isomorphism*, which says
    any operation that can be simulated using a unitary matrix is perfectly equivalent
    to a particular state called its *Choi state*. This means a simulator can effectively
    find the entire truth table for any adjointable operation (that is, any operation
    that has `is Adj` in its signature) by finding its Choi state. The `AssertOperationsEqualReferenced`
    operation uses this concept to prepare a register of qubits in the Choi state
    for each of the operations passed as inputs. On a simulator, it’s easy to cheat
    and check whether two states are the same even though the no-cloning theorem tells
    us we can’t do that on an actual device.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3中的`AssertOperationsEqualReferenced`操作使用了一种称为*Choi–Jamiłkowski同构*的巧妙数学方法，它表明任何可以用幺正矩阵模拟的操作与一个特定状态（称为其*Choi状态*）完全等价。这意味着模拟器可以通过找到其Choi状态来有效地找到任何可逆操作（即任何在其签名中有`is
    Adj`的操作）的整个真值表。`AssertOperationsEqualReferenced`操作使用这个概念为每个作为输入传递的操作准备一个处于Choi状态的量子比特寄存器。在模拟器上，很容易作弊并检查两个状态是否相同，尽管克隆定理告诉我们我们实际上不能在真实设备上这样做。
- en: When writing unit tests and other checks that quantum programs are correct,
    this can be a powerful technique for making use of classical simulators while
    still preventing cheating on actual hardware.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写单元测试和其他检查量子程序是否正确时，这可以是一种强大的技术，可以在使用经典模拟器的同时防止在真实硬件上作弊。
- en: When we run `CheckThatThisWorks` either in Jupyter Notebook (as we saw in chapter
    7) or at the command line, we should see the message `"Woohoo!"` telling us that
    our Q# program ran past the call to `AssertOperationsEqualReferenced`. Since that
    assertion only passes if the two operations that we give it do exactly the same
    thing for all possible inputs, we know that the equivalence we learned about in
    chapter 7 works.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Jupyter Notebook（如我们在第7章中看到的）或命令行中运行`CheckThatThisWorks`时，我们应该看到消息`"Woohoo!"`，告诉我们我们的Q#程序已经通过了`AssertOperationsEqualReferenced`调用。由于该断言只有在我们给出的两个操作对所有可能的输入都执行完全相同操作时才会通过，因此我们知道我们在第7章中学到的等价性是有效的。
- en: We can use the same logic to check how two-qubit operations like `CNOT` transform
    other operations. For example, transforming a call to `X` with calls to `CNOT`
    does the same thing as calling `X` multiple times, as demonstrated in the next
    listing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的逻辑来检查双量子比特操作（如`CNOT`）如何转换其他操作。例如，通过调用`CNOT`转换`X`调用与多次调用`X`具有相同的效果，如下一列表所示。
- en: Listing 10.4 Applying `X` on each qubit in a register
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.4 在寄存器中的每个量子比特上应用`X`
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Operation representing a single call to X with CNOTs, using a within/apply
    block
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表示单个X操作调用并使用CNOTs，使用内部/应用块
- en: ❷ For the “socks” part of the within/apply block, we can write the CNOT calls
    we need by using ApplyToEachCA together with the partial application technique
    we learned in chapter 7.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于/应用块中的“袜子”部分，我们可以通过使用ApplyToEachCA与我们在第7章中学到的部分应用技术来编写所需的CNOT调用。
- en: ❸ This part of our call to ApplyToEachCA says to apply a CNOT operation controlled
    on the first qubit of a register to each element of an array of qubits.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们在调用ApplyToEachCA的这一部分中，指示将控制于寄存器第一个量子比特的CNOT操作应用于量子比特数组中的每个元素。
- en: ❹ Uses Rest to pick out all but the first (that is, the 0th) element of the
    register array
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用Rest选择寄存器数组中除了第一个（即0th）元素之外的所有元素
- en: '❺ The “shoes” part of our within/apply block is a bit simpler: just an X operation
    on the same qubit we used as a control for our sequence of CNOT calls.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们在/应用块中的“鞋子”部分稍微简单一些：只是对用作我们CNOT调用序列控制器的相同量子比特执行X操作。
- en: ❻ This time, instead of writing our own operation to compare to, we compare
    to an X operation on each qubit in a register by using partial application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 这次，我们不是编写自己的操作进行比较，而是通过部分应用，将寄存器中每个量子比特的X操作进行比较。
- en: 'Exercise 10.4: Unitary equivalence'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.4：幺正等价
- en: Using QuTiP, check that when run on two-qubit registers, the two programs in
    listing 10.4 can be simulated by the same unitary matrix and thus do the same
    thing to their input registers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用QuTiP，检查当在双量子比特寄存器上运行时，列表10.4中的两个程序可以通过相同的幺正矩阵进行模拟，因此对它们的输入寄存器执行相同操作。
- en: 'Exercise 10.5: Program equivalence'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.5：程序等价
- en: Try modifying listing 10.4 to see if both programs are equivalent when applied
    to more than two qubits.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改列表10.4，看看当应用于超过两个量子比特时，这两个程序是否等效。
- en: '*Note*: It can be pretty expensive to use `AssertOperationsEqualReferenced`
    for more than a few qubits.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意*：对于超过几个量子比特，使用 `AssertOperationsEqualReferenced` 可能相当昂贵。'
- en: We can also build up other interesting kinds of operations by using the `within`/
    `apply` concept. In particular, transforming a rotation with `CNOT` operations
    the same way as listing 10.4 lets us implement the kinds of multiple-qubit rotations
    that Marie asked for at the beginning of this section. Using the `DumpMachine`
    and `DumpRegister` features that we learned about in chapter 9, we can see that
    just as `Rx` applies an *X*-axis rotation between |0〉 and |1〉, we can implement
    a (*X* ⊗ *X*)-axis rotation between |00〉 and |11〉.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 `within`/ `apply` 概念来构建其他有趣的操作类型。特别是，通过使用与列表 10.4 相同的方式应用 `CNOT` 操作来转换旋转，我们可以实现
    Marie 在本节开头所要求的多量子比特旋转类型。使用我们在第 9 章中学到的 `DumpMachine` 和 `DumpRegister` 功能，我们可以看到，正如
    `Rx` 在 |0〉 和 |1〉 之间应用 *X*-轴旋转一样，我们也可以实现 |00〉 和 |11〉 之间的 (*X* ⊗ *X*)-轴旋转。
- en: Listing 10.5 Creating a a multi-qubit `Rx` operation
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.5 创建一个多量子比特 `Rx` 操作
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ For simplicity, we’ve specialized to the two-qubit case in this listing, but
    we can use an ApplyToEachCA call the same way to work with registers of more than
    two qubits.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为了简单起见，我们在本列表中专门针对双量子比特情况，但我们可以使用相同的 ApplyToEachCA 调用来处理超过两个量子比特的寄存器。
- en: ❷ Instead of applying an X operation to the control qubit, we want to apply
    an X rotation about an arbitrary angle to the control qubit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们不想对控制量子比特应用 X 操作，而是想对控制量子比特应用一个任意角度的 X 旋转。
- en: ❸ To check what our new ApplyRotationAboutXX operation does, we start by asking
    our target machine for a two-qubit register with a “using” statement.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为了检查我们新的 ApplyRotationAboutXX 操作的作用，我们首先通过一个“using”语句向我们的目标机器请求一个双量子比特寄存器。
- en: ❹ We then apply our new rotation about the (*X* ⊗ *X*)-axis to our new register
    to see what it does.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 然后，我们将新的旋转应用于我们的新寄存器，以查看它会产生什么效果。
- en: ❺ When run on a simulator, DumpMachine prints out the full state of the simulator,
    letting us check how our new rotation operation transformed the state of our register.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当在模拟器上运行时，DumpMachine 会打印出模拟器的完整状态，让我们检查我们的新旋转操作如何转换了我们的寄存器状态。
- en: ❻ As usual, before releasing our register back to the target machine, we need
    to reset all of our qubits back into the |0〉 state.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 与往常一样，在我们将寄存器释放回目标机器之前，我们需要将所有量子比特重置回 |0〉 状态。
- en: 'Exercise 10.6: Predicting ApplyRotationAboutXX'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.6：预测 ApplyRotationAboutXX
- en: Try preparing the register in states other than |00〉 before calling `ApplyRotationAboutXX`.
    Does the operation do what you expected?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `ApplyRotationAboutXX` 之前，尝试将寄存器准备在 |00〉 状态之外。这个操作是否如您预期的那样工作？
- en: '*Hint*: Recall from part 1 of the book that we can prepare a copy of the |1〉
    state by applying an `X` operation and that we can prepare |+〉 by applying an
    `H` operation.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示*：回想一下本书的第一部分，我们可以通过应用一个 `X` 操作来准备 |1〉 状态的副本，并且我们可以通过应用一个 `H` 操作来准备 |+〉。'
- en: Your output from listing 10.5 may look slightly different than figure 10.6,
    as the IQ# kernel for Jupyter Notebook supports multiple different ways to label
    qubit states.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您从列表 10.5 中的输出可能看起来与图 10.6 略有不同，因为 Jupyter Notebook 的 IQ# 内核支持多种不同的方式来标记量子比特状态。
- en: '![](../Images/10-7.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-7.png)'
- en: Figure 10.7 Output from running listing 10.5 in a Jupyter Notebook. We can see
    from the output of `DumpMachine` in `DumpXXRotation`, which shows our resulting
    state is a superposition between |00〉 and |11〉.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 在 Jupyter Notebook 中运行列表 10.5 的输出。我们可以从 `DumpMachine` 在 `DumpXXRotation`
    中的输出中看到，我们的结果状态是 |00〉 和 |11〉 之间的叠加。
- en: Tip By default, IQ# uses the “little-endian” convention, useful for arithmetic
    problems like the ones we’ll see in chapter 12\. To label qubit states using bit
    strings like the ones we’ve seen so far in the book, run `%config dump.basisStateLabelingConvention
    = "Bitstring"` from a new Jupyter Notebook cell.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：默认情况下，IQ# 使用“小端”约定，这对于我们在第 12 章中将要看到的算术问题很有用。要使用与本书中迄今为止所见的类似位字符串来标记量子比特状态，请在新的
    Jupyter Notebook 单元中运行 `%config dump.basisStateLabelingConvention = "Bitstring"`。
- en: 'Exercise 10.7: Rx v. rotation about *X* ⊗ *X*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.7：Rx 与 *X* ⊗ *X* 的旋转
- en: Try using `DumpMachine` to explore how the `Rx` operation acts on a single qubit,
    and compare to the two-qubit rotation about the (*X* ⊗ *X*)-axis that we implemented
    in listing 10.5\. How are the two rotation operations similar, and how do they
    differ? Compare rotating about the (*X* ⊗ *X*)-axis with applying an `Rx` operation
    to each qubit in a two-qubit register.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用 `DumpMachine` 来探索 `Rx` 操作如何作用于单个量子比特，并将其与我们实现的关于 (*X* ⊗ *X*)-轴的二维量子比特旋转进行比较。这两个旋转操作有哪些相似之处，又有哪些不同之处？比较围绕
    (*X* ⊗ *X*)-轴的旋转与对二维量子寄存器中每个量子比特应用 `Rx` 操作。
- en: In general, *any* rotation about an axis given by a tensor product of Pauli
    matrices (such as *X* ⊗ *X*, *Y* ⊗ *Z* or *Z* ⊗ *Z* ⊗ *Z*) can be implemented
    by applying a single-qubit rotation transformed by a sequence of operations like
    `CNOT` and `H`. Finding what the right transformation is, however, can be a bit
    annoying, so Q# provides a nice built-in operation called `Exp` to help.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何围绕由泡利矩阵的张量积给出的轴（如 *X* ⊗ *X*，*Y* ⊗ *Z* 或 *Z* ⊗ *Z* ⊗ *Z*）的旋转都可以通过应用单个量子比特旋转和一系列操作（如
    `CNOT` 和 `H`）来实现。然而，找到正确的转换可能有点麻烦，所以 Q# 提供了一个名为 `Exp` 的内置操作来帮助。
- en: Listing 10.6 Using `Exp` to figure out how to transform state
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.6 使用 `Exp` 来找出如何转换状态
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Warning The conventions used by `Exp` and `Rx` to denote angles differ by a
    factor of –1 / 2\. When using the `Exp` operation and single-qubit rotation operations
    in the same program, make sure to double-check all of your angles!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：`Exp` 和 `Rx` 用于表示角度的约定相差一个因子 -1/2。当在同一个程序中使用 `Exp` 操作和单个量子比特旋转操作时，务必仔细检查所有角度！
- en: Using `Exp`, it’s easy to simulate the Hamiltonian *H* = *ω**X* ⊗ *X* or any
    other Hamiltonian made up of tensor products of Pauli matrices (figure 10.8).
    As shown in the following listing, in Q#, we can specify (*X* ⊗ *X*) by the Q#
    value `[PauliX, PauliX]`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Exp`，模拟哈密顿量 *H* = *ω**X* ⊗ *X* 或由泡利矩阵的张量积组成的任何其他哈密顿量（如图 10.8 所示）变得非常容易。正如以下列表所示，在
    Q# 中，我们可以通过 Q# 值 `[PauliX, PauliX]` 来指定 (*X* ⊗ *X*)。
- en: '![](../Images/10-8.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-8.png)'
- en: Figure 10.8 In step 3, we look at how to use the `Exp` operation to program
    the generalized rotations that represent the Hamiltonian we are trying to simulate.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 在第 3 步中，我们看看如何使用 `Exp` 操作来编程表示我们试图模拟的哈密顿量的广义旋转。
- en: Listing 10.7 Using `Exp` to simulate evolving under *X* ⊗ *X*
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 使用 `Exp` 来模拟在 *X* ⊗ *X* 下演化
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Using what we’ve learned so far, we can write an operation to simulate evolving
    under a Hamiltonian proportional to (*X* ⊗ *X*), just as the operation we wrote
    in listing 10.2 simulated evolving under a Hamiltonian proportional to *Z*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用我们迄今为止学到的知识，我们可以编写一个操作来模拟在 (*X* ⊗ *X*) 成比例的哈密顿量下演化，就像我们在列表 10.2 中编写的操作模拟在成比例的
    *Z* 哈密顿量下演化一样。
- en: '❷ Parameter representing the strength of the Hamiltonian: how large the energies
    described by our Hamiltonian are'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 表示哈密顿量强度的参数：我们的哈密顿量描述的能量有多大
- en: ❸ Parameter that describes how long to simulate evolution (analogous to Lancelot’s
    scale parameter from chapter 9)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 描述模拟演化时间（类似于第 9 章中 Lancelot 的尺度参数）
- en: ❹ Asks for a rotation about the (*X* ⊗ *X*)-axis using the Exp operation provided
    by the Microsoft.Quantum.Intrinsic namespace
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用 Microsoft.Quantum.Intrinsic 命名空间提供的 Exp 操作请求围绕 (*X* ⊗ *X*)-轴的旋转
- en: '*Z* ⊗ *Z* is *not* just two *Z* rotations'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*Z* ⊗ *Z* 并不仅仅是两个 *Z* 旋转'
- en: 'It may be tempting to think that we can implement a two-qubit rotation about
    *Z* ⊗ *Z* by rotating the first qubit about *Z* and then rotating the second qubit
    about *Z*. These turn out to be very different operations, however:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会让人想当然地认为我们可以通过先围绕 *Z* 旋转第一个量子比特，然后围绕 *Z* 旋转第二个量子比特来实现关于 *Z* ⊗ *Z* 的二维量子比特旋转。然而，这些操作却非常不同：
- en: '![](../Images/equation_10-1K.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_10-1K.png)'
- en: One way to think of it is that a rotation about *Z* ⊗ *Z* is only sensitive
    to the *parity* of each computational basis state, so |00〉 and |11〉 are each rotated
    by the same phase.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样理解，围绕 *Z* ⊗ *Z* 的旋转只对每个计算基态的 *奇偶性* 敏感，所以 |00〉 和 |11〉 都以相同的相位旋转。
- en: Now that we have the `Exp` operation at our disposal, it’s pretty easy to use
    it to write an operation that simulates each term in the Hamiltonian that Marie
    gives us.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `Exp` 操作，用它来编写一个模拟玛丽给出的哈密顿量中每个项的操作变得非常容易。
- en: 'Listing 10.8 operations.qs: simulating the evolution of a single term'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 operations.qs：模拟单个项的演化
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Index to look up which of the Hamiltonians Marie gave us. Each corresponds
    to a different bond length.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 查找玛丽给我们提供的哈密顿量索引。每个对应不同的键长。
- en: ❷ Term of Marie’s Hamiltonian under which we want to simulate evolution
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们想要在Marie的哈密顿量下模拟演化的项
- en: '❸ How long to simulate evolution: that is, how long a simulation step to take'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 模拟演化的时长：也就是说，模拟步骤的时长
- en: ❹ Gets the term from the Hamiltonian by using idxTerm together with the H2Terms
    function provided in the code repository for this book
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 通过使用idxTerm与代码库中提供的H2Terms函数一起从哈密顿量中获取项
- en: ❺ Gets the coefficient of that term by using the H2Coeff function, also provided
    in the samples repository for this book
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 通过使用H2Coeff函数（也提供在本书的样本库中）来获取该项的系数
- en: ❻ Simulates evolution under that term using Exp to do a rotation scaled by the
    simulation step size, just like the EvolveUnderXX operation from listing 10.7
    did
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用Exp进行旋转，旋转的幅度由模拟步长决定，就像列表10.7中的EvolveUnderXX操作一样，来模拟该项下的演化
- en: ❼ Since not all terms affect all qubits, we can use the RestrictedToSubregisterCA
    operation provided with Q# to apply our call to Exp to only a subset of the input.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 由于并非所有项都会影响所有量子比特，我们可以使用Q#提供的`RestrictedToSubregisterCA`操作来仅将我们的Exp调用应用于输入的子集。
- en: In the next section, we’ll see how to use this to simulate evolution under Marie’s
    entire Hamiltonian.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用这个方法来模拟在Marie的整个哈密顿量下的演化。
- en: 10.5 Making the change we want to see in the system
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 在系统中实现我们想要看到的变化
- en: Now that we have learned to describe how a quantum device can change in time
    using the concept of a Hamiltonian, a very natural question is, how do we implement
    the particular Hamiltonian we want to simulate? Most quantum devices have some
    operations that are easy for them to do. For instance, we saw in the previous
    section that it’s straightforward to simulate evolution under any Hamiltonian
    that is given by a tensor product of Pauli matrices. That said, the Hamiltonian
    we (and Marie) are interested in is likely *not* a built-in operation but rather
    something that isn’t directly available on our quantum computer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用哈密顿量的概念来描述量子设备随时间的变化，一个非常自然的问题就是，我们如何实现我们想要模拟的特定哈密顿量？大多数量子设备都有一些它们容易执行的操作。例如，我们在上一节中看到，模拟任何由泡利矩阵张量积给出的哈密顿量的演化是直接的。话虽如此，我们（以及Marie）感兴趣的是哈密顿量可能**不是**内置操作，而是一种在我们量子计算机上不可直接获得的东西。
- en: Tip Usually it easy for devices to implement some of the Pauli operators and
    maybe a few other operations. The game then becomes figuring out how to transform
    the operation we *want* into operations the device can easily do.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：通常设备很容易实现一些泡利算符以及可能的一些其他操作。那么游戏就变成了如何将我们*想要*的操作转换成设备可以轻松执行的操作。'
- en: If there is no easy button to simulate evolution under our Hamiltonian, how
    can we implement a simulation of a particular Hamiltonian that we can apply to
    the qubits in our device?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有简单的按钮来模拟我们的哈密顿量下的演化，我们如何实现一个特定的哈密顿量模拟，我们可以将其应用于我们设备中的量子比特？
- en: Let’s break it down. Literally. We learned all the way back in chapter 2 that
    we can describe a vector as a linear combination of *basis* vectors or directions.
    It turns out that we can do the same thing with matrices, and a really convenient
    basis to do so is the Pauli operators.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解。字面意义上来说。我们早在第2章就学到了，我们可以将一个向量描述为基向量或方向的线性组合。结果是我们也可以用矩阵来做同样的事情，而一个做这件事非常方便的基是泡利算符。
- en: Pauli matrix refresher
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 泡利矩阵复习
- en: 'If you need a refresher on what the Pauli matrices are, no worries, we’ve got
    you covered:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要复习泡利矩阵是什么，不用担心，我们已经为你准备好了：
- en: '![](../Images/equation_10-2K.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![方程10-2K](../Images/equation_10-2K.png)'
- en: Just as we can describe any direction on a map with north and west, we can describe
    any matrix as a linear combination of Pauli matrices. For example,
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以用北和西来描述地图上的任何方向一样，我们也可以用泡利矩阵的线性组合来描述任何矩阵。例如，
- en: '![](../Images/equation_10-3.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![方程10-3](../Images/equation_10-3.png)'
- en: Similarly,
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，
- en: '![](../Images/equation_10-4.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![方程10-4](../Images/equation_10-4.png)'
- en: 'The same holds for matrices acting on multiple qubits:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作用于多个量子比特的矩阵，情况也是一样的：
- en: '![](../Images/equation_10-5.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![方程10-5](../Images/equation_10-5.png)'
- en: 'Exercise 10.8: Verifying identities'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.8：验证恒等式
- en: Use QuTiP to verify the previous equations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用QuTiP验证前面的方程。
- en: '*Hint*: You can use `qt.qeye(2)` to get a copy of 1, `qt.sigmax()` to get a
    copy of *X*, and so forth. To compute tensor products like *X* ⊗ *X*, you can
    use `qt.tensor`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：你可以使用`qt.qeye(2)`来获取1的副本，`qt.sigmax()`来获取X的副本，以此类推。要计算如*X* ⊗ *X*这样的张量积，你可以使用`qt.tensor`。'
- en: This is good news because we can then write the Hamiltonian we want to simulate
    as a linear combination of Pauli matrices. In the previous section, we saw that
    we can use `Exp` to easily simulate Hamiltonians that are made up only of tensor
    products of Pauli matrices. This makes the Pauli basis very convenient, as it’s
    likely the workflow from Marie’s chemistry tools will already output the Hamiltonian
    for our quantum device in the Pauli basis.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好消息，因为这样我们就可以将我们想要模拟的哈密顿量写成泡利矩阵的线性组合。在上一节中，我们看到了我们可以使用 `Exp` 来轻松模拟仅由泡利矩阵的张量积组成的哈密顿量。这使得泡利基非常方便，因为它很可能是玛丽化学工具的工作流程已经以泡利基的形式输出了我们量子设备的哈密顿量。
- en: 'Let’s look at the representation of the Hamiltonian that Marie wants us to
    simulate, using the Pauli basis to expand it. Using her chemistry modeling skills,
    Marie can helpfully tell us that the Hamiltonian we need to simulate with our
    qubits is given by the equation below, where each of *a*, *b*[0], ..., and *b*[4]
    is a real number that depends on the bond length at which she wants to simulate
    H[2]:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看玛丽想要我们模拟的哈密顿量的表示，使用泡利基来展开它。利用她的化学建模技能，玛丽可以方便地告诉我们，我们需要用我们的量子位模拟的哈密顿量由以下方程给出，其中每个*a*、*b*[0]、...和*b*[4]都是实数，这些实数取决于她想要模拟H[2]的键长：
- en: '![](../Images/equation_10-6.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/equation_10-6.png)'
- en: 'Tip All the terms and coefficients Marie is using are from the paper “Scalable
    Quantum Simulation of Molecular Energies.”^([1](#pgfId-1020265)) The exact coefficients
    depend on the length of the bond between the hydrogen atoms, but all of these
    constants are helpfully typed in for you in the code repo for the book: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 提示玛丽所使用的所有项和系数都来自论文“可扩展的分子能量量子模拟。”^([1](#pgfId-1020265))。确切的系数取决于氢原子之间的键长，但所有这些常数都已经在代码库中方便地为您输入：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp)。
- en: With this representation of Marie’s Hamiltonian in hand, it’s time to figure
    out how to actually *use* it. There are six terms to this Hamiltonian, so which
    term should we apply first? Does the order matter? Unfortunately, the order in
    which the terms are used often does matter when simulating the evolution of a
    system under a Hamiltonian. In the next section, we’ll learn about a method that
    allows us to break the evolution of the system into little steps to simulate evolution
    under all the terms at once.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有玛丽哈密顿量的这种表示后，现在是时候弄清楚如何实际*使用*它了。这个哈密顿量有六个项，那么我们应该先应用哪个项？顺序重要吗？不幸的是，在模拟系统在哈密顿量下的演化时，项的使用顺序通常很重要。在下一节中，我们将学习一种方法，它允许我们将系统的演化分解成小步骤，以同时模拟所有项的演化。
- en: 10.6 Going through (very small) changes
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6经历（非常小的）变化
- en: At this point, it’s helpful to take a step back and assess where we are in helping
    Marie. We’ve seen how to break arbitrary Hamiltonians into sums of Pauli matrices
    and how to use the `Exp` operation to simulate evolution under each term in that
    sum. To simulate arbitrary Hamiltonians, all that’s left is to combine those simulations
    to simulate the entire Hamiltonian (figure 10.9). To do that, we can use one more
    quantum computing trick called the *Trotter–Suzuki decomposition*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，退一步评估我们在帮助玛丽方面所处的位置是有帮助的。我们已经看到了如何将任意哈密顿量分解为泡利矩阵的和，以及如何使用`Exp`操作来模拟该和中每个项的演化。要模拟任意哈密顿量，剩下的只是将这些模拟组合起来，以模拟整个哈密顿量（图10.9）。为此，我们可以使用另一个名为*
    Trotter-Suzuki分解*的量子计算技巧。
- en: '![](../Images/10-9.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-9.png)'
- en: Figure 10.9 In this section, we explore how to use the *Trotter–Suzuki decomposition*
    to simulate the action of the total Hamiltonian by breaking it into much smaller
    evolutions of each term from step 3.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9在本节中，我们探讨如何使用* Trotter-Suzuki分解*通过将其分解为从步骤3开始的每个项的更小的演化来模拟总哈密顿量的作用。
- en: Before getting into the details of the Trotter–Suzuki decomposition, though,
    let’s go back to the map analogy that we’ve used throughout the book to break
    down linear algebra concepts (discussed in appendix C).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨Trotter-Suzuki分解的细节之前，让我们回到我们在整本书中用来分解线性代数概念的映射类比（附录C中讨论）。
- en: Suppose that we’re exploring downtown Phoenix and decide to see what it feels
    like to go northeast throughout the city. If we start by going north several blocks
    and then go east several blocks, the route we trace on a map won’t look much like
    a diagonal line. On the other hand, if we switch between going north and east
    each block, we’ll trace out something much closer to a path that looks like it
    came out of the map of Minneapolis that appears in appendix C. That is, we can
    simulate the way we might walk through Minneapolis even if we’re stuck in Phoenix
    by quickly switching which way we walk; see figure 10.10.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在探索凤凰城的市中心，并决定体验一下在整个城市中向东北方向行走的感受。如果我们先向北走几个街区，然后向东走几个街区，我们在地图上留下的路线不会看起来像一条对角线。另一方面，如果我们每走一个街区就在北和东之间切换，我们留下的路线将更接近于看起来像是来自附录C中出现的明尼阿波利斯地图的路径。也就是说，即使我们被困在凤凰城，我们也可以通过快速切换行走方向来模拟我们在明尼阿波利斯行走的方式；参见图10.10。
- en: '![](../Images/10-10.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-10.png)'
- en: Figure 10.10 If we’re in downtown Phoenix, we can still simulate how we might
    walk through downtown Minneapolis by rapidly alternating directions. Ideally,
    we would just travel diagonally to our destination, but given the street layout
    we can approximate the diagonal by making short zigzags. Photo by davecito.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 如果我们在凤凰城的市中心，我们仍然可以通过快速交替方向来模拟我们在明尼阿波利斯市中心行走的方式。理想情况下，我们只会以对角线的方式到达目的地，但考虑到街道布局，我们可以通过做出短的之字形来近似对角线。照片由davecito拍摄。
- en: In the previous section, we saw that just like states, the different terms in
    a Hamiltonian can be thought of as directions on a high-dimensional map. Tensor
    products of Pauli matrices, such as *Z* ⊗ 𝟙 and *X* ⊗ *Z*, play a role similar
    to the cardinal directions or axes of a map. When we try to simulate Marie’s Hamiltonian,
    though, that doesn’t point along a single axis, but along a kind of diagonal in
    that higher-dimensional space. That’s where the Trotter–Suzuki decomposition comes
    in.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到，就像状态一样，哈密顿量中的不同项可以被视为高维地图上的方向。泡利矩阵的张量积，例如 *Z* ⊗ 𝟙 和 *X* ⊗ *Z*，在地图上的基本方向或轴上扮演着类似的角色。然而，当我们尝试模拟玛丽的哈密顿量时，它并不指向一个单一轴，而是在更高维空间中沿着一种斜线。这就是Trotter–Suzuki分解发挥作用的地方。
- en: Just as our path looks more diagonal when we quickly switch which direction
    we walk, we can rapidly switch between simulating different Hamiltonian terms.
    As illustrated in figure 10.11, the Trotter–Suzuki decomposition tells us that
    when we rapidly switch this way, we approximately evolve under the sum of the
    different terms that we’re simulating.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们快速切换行走方向时路径看起来更像是对角线一样，我们可以在模拟不同的哈密顿量项之间快速切换。如图10.11所示，Trotter–Suzuki分解告诉我们，当我们这样快速切换时，我们近似地经历了我们模拟的不同项的总和。
- en: '![](../Images/10-11.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10-11.png)'
- en: Figure 10.11 Using the Trotter–Suzuki decomposition to approximate evolving
    under two Hamiltonian terms at once. Just like the map analogy earlier, if we
    want to apply the effect of two Hamiltonians as quickly as possible, we should
    alternate evolving a little under each until we reach the full evolution.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 使用Trotter–Suzuki分解同时近似演化两个哈密顿量项。就像之前的地图类比一样，如果我们想尽可能快地应用两个哈密顿量的效果，我们应该交替地在每个项下进行一点演化，直到达到完整的演化。
- en: We could in principle write this in Q# as a `for` loop. In pseudocode, we might
    have something like the following.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原则上可以用Q#编写一个`for`循环。在伪代码中，我们可能会有以下内容。
- en: Listing 10.9 Simulating a Hamiltonian using Trotter–Suzuki
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.9 使用Trotter–Suzuki分解模拟哈密顿量
- en: '[PRE9]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Since this is pseudocode, let’s not worry about types for a moment. This operation
    won’t compile without types, but that’s fine for now.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于这是伪代码，我们暂时不必担心类型。没有类型，这个操作将无法编译，但现在这没关系。
- en: ❷ For each step into which we want to divide our simulation (think of city blocks
    in Phoenix or pixels on a screen), we need to do a bit of each Hamiltonian term.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于我们想要将模拟分割成多少步（想想凤凰城的街区或屏幕上的像素），我们需要对每个哈密顿量项做一点工作。
- en: ❸ Within each timestep, we can loop over every term we need to simulate, and
    simulate each for one step.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在每个时间步内，我们可以遍历我们需要模拟的每个项，并对每个项进行一步模拟。
- en: 'Fortunately, Q# provides a standard library function that does precisely this
    for us: `DecomposedIntoTimeStepsCA`. In listing 10.10, we show how calling `DecomposedIntoTimeStepsCA`
    makes it easy to use the Trotter–Suzuki decomposition to simulate evolution under
    Marie’s Hamiltonian. The `DecomposedIntoTimeStepsCA` function supports higher-order
    Trotter–Suzuki decompositions than the first-order approximation we’ve explored
    so far in this chapter (represented by a `trotterOrder` of 1). In some cases,
    this feature can be useful to help increase the accuracy of our simulation, but
    a `trotterOrder` of 1 works fine for our purposes.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Q#提供了一个标准库函数，可以为我们精确地完成这项工作：`DecomposedIntoTimeStepsCA`。在列表10.10中，我们展示了如何调用`DecomposedIntoTimeStepsCA`，这使得使用Trotter-Suzuki分解来模拟Marie的哈密顿量下的演化变得容易。`DecomposedIntoTimeStepsCA`函数支持比本章中我们探索过的第一阶近似（由`trotterOrder`为1表示）更高阶的Trotter-Suzuki分解。在某些情况下，这个特性可能有助于提高我们模拟的精度，但对我们来说，`trotterOrder`为1已经足够好。
- en: 'Listing 10.10 operations.qs: using `DecomposedIntoTimeStepsCA`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.10 operations.qs：使用`DecomposedIntoTimeStepsCA`
- en: '[PRE10]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ EvolveUnderHamiltonian applies the appropriate Hamiltonian based on the coefficients
    for the desired bond length of the H[2] molecule Marie asked us to help with.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ EvolveUnderHamiltonian根据Marie要求我们帮助其调整的H[2]分子所需键长的系数，应用适当的哈密顿量。
- en: ❷ Step size that represents how long we want to simulate Hamiltonian evolution
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 表示我们想要模拟哈密顿量演化多长时间的步长
- en: ❸ In some cases, a trotterOrder >1 can be useful to help increase the accuracy
    of our simulation, but a trotterOrder of 1 works fine for our purposes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在某些情况下，trotterOrder >1 可以有助于提高我们模拟的精度，但对我们来说，trotterOrder为1已经足够好。
- en: ❹ Partial application can fix the idxBondLength input to EvolveUnderHamiltonianTerm,
    leaving the idxTerm, stepSize, and qubits arguments blank.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 部分应用可以将EvolveUnderHamiltonianTerm的idxBondLength输入固定下来，而将idxTerm、stepSize和qubits参数留空。
- en: ❺ This function outputs an operation that can be used to automatically simulate
    evolution under the entire Hamiltonian, using the operation that simulates each
    term one by one, so we can go on and apply it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 此函数输出一个操作，可以用来自动模拟整个哈密顿量下的演化，使用模拟每个项的操作逐一进行，这样我们就可以继续应用它。
- en: 10.7 Putting it all together
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.7 整合一切
- en: Now that we have a better idea about what Hamiltonians are and how we can simulate
    evolution under them to understand how quantum systems change in time, we’re ready
    to put together a program that will help Marie solve her question (figure 10.12).
    As a reminder, Marie is a chemist who studies the ground state energies (aka lowest
    possible energies) of different chemicals. She has asked us to help figure out
    the ground state energies for the H[2] molecule with our quantum device. Because
    the hydrogen atoms that make up H[2] molecules are also quantum systems, it is
    much easier to simulate the behavior of H[2] with qubits than a classical computer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对哈密顿量是什么以及我们如何模拟其下的演化来理解量子系统随时间的变化有了更好的了解，我们准备编写一个程序来帮助Marie解决她的问题（图10.12）。作为提醒，Marie是一位化学家，研究不同化学物质的基态能量（即最低可能的能量）。她要求我们用我们的量子设备帮助确定H[2]分子的基态能量。由于组成H[2]分子的氢原子也是量子系统，使用量子比特模拟H[2]的行为比使用经典计算机要容易得多。
- en: '![](../Images/10-12.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图10-12](../Images/10-12.png)'
- en: Figure 10.12 The last step to help Marie simulate her H[2] molecule is to use
    phase estimation to read the ground state energy.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 最后一步是帮助Marie模拟她的H[2]分子，即使用相估计来读取基态能量。
- en: Tip Quantum computers are so well suited to simulating the behavior of other
    quantum systems that this was arguably the first application ever proposed for
    quantum computing!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：量子计算机非常适合模拟其他量子系统的行为，这可能是量子计算首次被提出的应用！
- en: Figure 10.13 is a reminder of all the steps and techniques we have learned in
    this chapter to simulate the evolution of Marie’s H[2] molecule in our quantum
    device.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13是本章中我们学习到的所有步骤和技术，用于在我们的量子设备中模拟Marie的H[2]分子的演化。
- en: '![](../Images/10-13.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图10-13](../Images/10-13.png)'
- en: Figure 10.13 Overview of the steps developed in this chapter to help Marie learn
    her molecule’s ground state energy
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13本章开发的步骤概述，以帮助Marie学习其分子的基态能量
- en: So, being quantum developers, we can collaborate with Marie to simulate the
    evolution of the H[2] molecule in time and calculate the ground state energy,
    thanks to Schrödinger’s equation. The key point to remember is that the possible
    energy levels of the H[2] molecule correspond to the different *eigenstates* of
    the Hamiltonian.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为量子开发者，我们可以与玛丽合作模拟H[2]分子随时间演化的过程，并计算基态能量，这要归功于薛定谔方程。需要记住的关键点是H[2]分子的可能能级对应于哈密顿量的不同*本征态*。
- en: 'Suppose that our qubits are in an eigenstate of the Hamiltonian. Then, simulating
    evolution under that Hamiltonian won’t change the state of our qubit register,
    *except* to apply a global phase that is proportional to the energy of that state.
    That energy tells us exactly what we need to solve Marie’s problem, but global
    phases are unobservable. Fortunately, in chapter 9, we learned from Lancelot’s
    and Dagonet’s game how to turn global phases into something we can learn with
    phase estimation—here is a great place to apply it! Summarizing, the steps to
    collaborate with Marie and solve her problem are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的量子比特处于哈密顿量的本征态。那么，在那种哈密顿量下模拟演化不会改变我们的量子寄存器的状态，*除了*应用一个与该状态能量成比例的全局相位。这种能量告诉我们需要解决玛丽问题的确切信息，但全局相位是不可观测的。幸运的是，在第9章中，我们从Lancelot和Dagonet的游戏中学习了如何将全局相位转化为我们可以通过相估计学习的东西——这里是一个很好的应用它的地方！总结来说，与玛丽合作并解决她问题的步骤如下：
- en: Prepare the initial state that Marie gives us. In this case, she helpfully tells
    us to prepare |10〉.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备玛丽给我们的初始状态。在这种情况下，她很有帮助地告诉我们准备|10〉。
- en: Break the Hamiltonian representing the system into little steps that can be
    simulated sequentially to represent the entire operation.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表示系统的哈密顿量分解成可以顺序模拟的小步骤，以表示整个操作。
- en: Apply each step representing the Hamiltonian to our initial state.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代表哈密顿量的每个步骤应用到我们的初始状态上。
- en: Use a phase-estimation algorithm to learn about the accumulated global phase
    on our quantum state, which will be proportional to the energy.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相估计算法来了解我们量子状态上累积的全局相位，这将与能量成正比。
- en: We have the skills and code from the previous sections in this chapter to pull
    this all together, so let’s give it a go.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个章节的前几节中有了技能和代码，可以将所有这些内容整合起来，所以让我们试试看。
- en: Starting with the Q# file (here called operations.qs to match what we’ve seen
    in previous chapters), we can open some namespaces to utilize premade functions
    and operations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从Q#文件（在这里称为 operations.qs 以匹配我们之前章节中看到的）开始，我们可以打开一些命名空间来利用预制的函数和操作。
- en: 'Listing 10.11 operations.qs: namespaces needed from the QDK'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.11 operations.qs：从QDK需要的命名空间
- en: '[PRE11]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ We have seen Microsoft.Quantum.Intrinsic and Microsoft.Quantum.Canon before;
    they have the basic utilities/helper functions and operations we need.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们之前已经见过 Microsoft.Quantum.Intrinsic 和 Microsoft.Quantum.Canon；它们包含我们需要的基本实用工具/辅助函数和操作。
- en: ❷ Microsoft.Quantum.Simulation is a namespace for the QDK that has, as we might
    expect, utilities for simulating systems.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Microsoft.Quantum.Simulation 是一个QDK的命名空间，正如我们可能预期的，它包含用于模拟系统的实用工具。
- en: ❸ Microsoft.Quantum.Characterization has easy-to-use implementations of the
    phase-estimation algorithms that we developed in chapter 9.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Microsoft.Quantum.Characterization 包含了我们第9章中开发的相估计算法的易于使用的实现。
- en: 'Next, we need to add the data Marie has about her molecule. All of this is
    typed out for you in the sample file in the GitHub repo for this book: [https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp/blob/master/ch10/operations.qs](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp/blob/master/ch10/operations.qs).
    The functions `H2BondLengths`, `H2Coeff`, and `H2IdentityCoeff` are what we need
    (they are kind of long to reproduce here in the text).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加玛丽关于她的分子的数据。所有这些都在GitHub仓库中这本书的示例文件中打印出来：[https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp/blob/master/ch10/operations.qs](https://github.com/crazy4pi314/learn-qc-with-python-and-qsharp/blob/master/ch10/operations.qs)。`H2BondLengths`、`H2Coeff`和`H2IdentityCoeff`是我们需要的函数（它们在这里的文字中复现起来有点长）。
- en: Once we have all the coefficient data from Marie in our file, we need the actual
    terms/structure for the Hamiltonian that we will use with those coefficients we
    just added. The following listing shows an outline of a function that returns
    terms of Marie’s Hamiltonian expressed as Pauli operators, as well as an operation
    that will prepare our two-qubit register in the right state for this algorithm.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在文件中获得了玛丽的所有系数数据，我们就需要使用这些刚刚添加的系数的实际哈密顿量项/结构。以下列表显示了一个函数的概要，该函数返回以Pauli算子表示的玛丽的哈密顿量项，以及一个将我们的双量子比特寄存器准备为适合此算法的正确状态的运算。
- en: 'Listing 10.12 operations.qs: function that returns terms from the Hamiltonian'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.12 operations.qs：从哈密顿量返回项的函数
- en: '[PRE12]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ The H2Terms function makes it easy to construct the terms of Marie’s Hamiltonian.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ H2Terms函数使得构建玛丽的哈密顿量项变得容易。
- en: ❷ This function is really just a hard-coded list of tuples that describe the
    Hamiltonian’s terms. This first tuple says that the first term of the Hamiltonian
    is the PauliZ operation on the zeroth qubit.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个函数实际上只是一个硬编码的元组列表，描述了哈密顿量的项。这个第一个元组表示哈密顿量的第一项是对零比特的PauliZ操作。
- en: ❸ Applies PauliZ to both the zeroth and the first qubit
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将PauliZ应用于零比特和第一个量子比特
- en: ❹ We also need a way to prepare our qubits for the algorithm. Following Marie’s
    advice, we put the first qubit in the |1〉 state, leaving the rest of the input
    qubits in the |0〉 state.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们还需要一种方法来为算法准备我们的量子比特。遵循玛丽的建议，我们将第一个量子比特置于|1〉状态，其余的输入量子比特保持在|0〉状态。
- en: 'To take care of steps 2 and 3 of our quantum algorithm, we need the operations
    we defined earlier: `EvolveUnderHamiltonianTerm` and `EvolveUnderHamiltonian`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理我们的量子算法的步骤2和3，我们需要之前定义的操作：`EvolveUnderHamiltonianTerm`和`EvolveUnderHamiltonian`。
- en: Global phases and the Controlled functor
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 全局相位和Controlled函子
- en: Just as we saw in chapter 9, applying `EvolveUnderHamiltonian` doesn’t do anything
    to qubits prepared in an eigenstate of Marie’s Hamiltonian—indeed, that’s the
    whole point! In chapter 9, we were able to solve this by using the `Controlled`
    functor to turn the global phase resulting from applying Dagonet’s operation on
    a qubit prepared in an eigenstate into a local phase that can be observed, and
    then using phase kickback to apply that phase to a control qubit. The `EstimateEnergy`
    operation provided by the Quantum Development Kit uses the exact same trick to
    learn what would otherwise be a global phase of our `EvolveUnderHamiltonian` operation.
    This means it’s *critical* that our operation supports the `Controlled` functor
    by adding `is Ctl` to the signature for each operation that we pass to `EstimateEnergy`
    as part of helping Marie.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第9章中看到的，应用`EvolveUnderHamiltonian`对玛丽哈密顿量的本征态准备好的量子比特没有任何作用——这确实是整个目的！在第9章中，我们能够通过使用`Controlled`函子将应用在准备为本征态的量子比特上的Dagonet操作产生的全局相位转换为可观察的局部相位，然后使用相位回弹将该相位应用到控制量子比特上来解决这个问题。量子开发工具包提供的`EstimateEnergy`操作使用完全相同的技巧来学习我们`EvolveUnderHamiltonian`操作中原本可能的全局相位。这意味着我们的操作通过向传递给`EstimateEnergy`的操作的签名中添加`is
    Ctl`来支持`Controlled`函子，这对于帮助玛丽来说是至关重要的。
- en: Finally, we can use the `EstimateEnergy` operation provided with the Quantum
    Development Kit to automate the application of the Trotter–Suzuki steps and the
    phase-estimation step. We can also use a built-in phase estimation operation that
    implements a better version of the phase-estimation algorithm we learned about
    in chapter 9\. For example, the `Microsoft.Quantum.Simulation` library has an
    operation called `EstimateEnergy` that uses phase estimation to estimate an eigenstate’s
    energy. It takes a specification for the number of qubits (`nQubits`), an operation
    to prepare our desired initial state (`PrepareInitialState`), how to apply our
    Hamiltonian (`trotterStep`), and what algorithm we want to use to estimate the
    phase resulting from applying our Hamiltonian. Let’s check it out in action.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用量子开发工具包提供的`EstimateEnergy`操作来自动应用Trotter-Suzuki步骤和相位估计步骤。我们还可以使用内置的相位估计操作，该操作实现了一个比我们在第9章中学到的相位估计算法更好的版本。例如，`Microsoft.Quantum.Simulation`库中有一个名为`EstimateEnergy`的操作，它使用相位估计来估计本征态的能量。它需要一个量子比特数量的规范（`nQubits`），一个准备我们所需初始状态的运算（`PrepareInitialState`），如何应用我们的哈密顿量（`trotterStep`），以及我们想要用于估计应用哈密顿量产生的相位的算法。让我们看看它的实际应用。
- en: 'Listing 10.13 operations.qs: Q# operation that estimates the ground state energy
    of H[2]'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.13 operations.qs：估计H[2]基态能量的Q#操作
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ This is it! The operation EstimateH2Energy takes the index of the molecule
    bond length and returns the energy of its ground state or lowest energy state.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这就是全部！操作 EstimateH2Energy 接收分子键长的索引，并返回其基态或最低能量态的能量。
- en: ❷ Defines that we need two qubits to simulate this system
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义我们需要两个量子位来模拟这个系统。
- en: ❸ Sets a scale parameter for the Trotter–Suzuki steps that apply the terms of
    our Hamiltonian to our qubits
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为应用我们哈密顿量项到量子位上的 Trotter–Suzuki 步设置一个比例参数。
- en: ❹ Builds off of ApplyHamiltonian and gives a convenient name for the operation
    that applies the terms of our Hamiltonian with our parameters
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 基于 ApplyHamiltonian 构建操作，并为应用我们哈密顿量项的操作提供了一个方便的名称。
- en: ❺ We have built into the Microsoft.Quantum.Simulation library an operation that
    estimates the phase resulting from applying our Hamiltonian, which we know represents
    the energy of the system.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 我们在 Microsoft.Quantum.Simulation 库中内置了一个操作，用于估计应用我们的哈密顿量产生的相位，我们知道这代表系统的能量。
- en: ❻ To make sure the units are right for the returned energy, we have to divide
    by the trotter step size and add the energy from the identity term in the Hamiltonian.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 为了确保返回的能量单位正确，我们必须除以 trotter 步长，并加上哈密顿量中恒等项的能量。
- en: Now to actually run the algorithm! Since the ground state energy is a function
    of the molecule bond length, we can use a Python host to run the Q# algorithm
    and then plot the results as a function of the bond length.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正运行算法！由于基态能量是分子键长的函数，我们可以使用 Python 主机来运行 Q# 算法，然后将结果作为键长的函数绘制出来。
- en: 'Listing 10.14 host.py: setup of the Python simulation'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.14 host.py：Python 模拟的设置。
- en: '[PRE14]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Imports the Python package for Q# and then imports the Q# namespace (HamiltonianSimulation)
    from our operations.qs file. The qsharp Python package makes Q# namespaces available
    as regular import statements.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 Q# 的 Python 包，然后从我们的 operations.qs 文件中导入 Q# 命名空间（HamiltonianSimulation）。qsharp
    Python 包使得 Q# 命名空间可以作为常规导入语句使用。
- en: ❷ To make things easier, pulls the list of bond lengths we can simulate for
    H[2] from the Q# function H2BondLengths
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为了简化操作，从 Q# 函数 H2BondLengths 中提取我们可以模拟的 H[2] 的键长列表。
- en: ❸ The estimate_energy function is a Python wrapper for the EstimateH2Energy
    Q# operation but runs it a few times to make sure the energy estimate is minimized.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ estimate_energy 函数是 EstimateH2Energy Q# 操作的 Python 包装器，但运行了几次以确保能量估计最小化。
- en: Why do we need to run EstimateH2Energy multiple times?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要多次运行 EstimateH2Energy？
- en: The state |01〉 that Marie gave us isn’t actually an eigenstate of any H[2] Hamiltonian,
    but something she computed using a quantum chemistry approximation known as *Hartree–Fock
    theory*. Since quantum chemistry is her area of expertise, she can help by providing
    approximations like that.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Marie 给我们的状态 |01〉实际上不是任何 H[2] 哈密顿量的本征态，而是她使用一种称为 *Hartree–Fock 理论* 的量子化学近似方法计算出来的。由于量子化学是她的专业领域，她可以通过提供这样的近似来帮助我们。
- en: In practice, this means when we run phase estimation using the tools provided
    by the `Microsoft.Quantum.Characterization` namespace, we aren’t learning the
    energy of a particular eigenstate; instead, we’re randomly projecting onto *an*
    eigenstate and learning its energy. Since our initial state is a pretty good approximation,
    most of the time, we’ll project onto the lowest-energy state of Marie’s Hamiltonian
    (that is, the ground state), but we can get unlucky and correctly learn the energy
    of the wrong eigenstate. Since we’re looking for the smallest energy, running
    multiple times and taking the minimum makes it much more probable that we’ll learn
    the energy we want.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着当我们使用 `Microsoft.Quantum.Characterization` 命名空间提供的工具运行相位估计时，我们并不是在学习特定本征态的能量；相反，我们是在随机投影到
    *某个* 本征态并学习其能量。由于我们的初始状态是一个相当好的近似，大多数情况下，我们会投影到 Marie 哈密顿量的最低能量态（即基态），但我们可能会不幸地正确学习到错误本征态的能量。由于我们正在寻找最小的能量，多次运行并取最小值使得我们更有可能学习到我们想要的能量。
- en: With everything set up in the Python host, all that’s left is to write and run
    the main function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 主机中设置好一切之后，剩下的就是编写和运行主函数。
- en: 'Listing 10.15 host.py: the main program for our simulation'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.15 host.py：我们模拟的主程序。
- en: '[PRE15]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Running host.py as a script plots the estimated ground state energies from
    the quantum algorithm in Q#.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 host.py 作为脚本运行会绘制出 Q# 量子算法估计的基态能量。
- en: ❷ Directly generates the list of estimated energies for each H2 molecule bond
    length
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 直接生成每个 H2 分子键长的估计能量列表。
- en: ❸ Sets up the data and style for the plot
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置图表的数据和样式。
- en: ❹ Calling plt.show() should pop up or return an image of the plot!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 调用plt.show()应该弹出或返回一个图像的图！
- en: Figure 10.14 shows a sample of what running `python host.py` should output.
    This plot shows the results of our simulations for various Hamiltonians for different
    bond lengths of the H[2] molecule. We can see that the energy of the lowest state
    is much higher when the bond length is short and kind of levels off as the bonds
    get longer. The lowest energy possible should occur around a bond length of approximately
    0.75 Å. If we look it up, the stable (that is, equilibrium) bond length for hydrogen
    is 0.74 Å! So yeah, it turns out Marie’s molecule is pretty well known, but we
    can see how we could follow this process not only for other chemicals but also
    for simulating other quantum systems.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14展示了运行`python host.py`应该输出的示例。这个图显示了我们对H[2]分子不同键长度的各种哈密顿量的模拟结果。我们可以看到，当键长较短时，最低能级的能量要高得多，并且随着键长的增加而趋于平稳。理论上，最低能量应出现在大约0.75
    Å的键长处。如果我们查阅资料，氢气的稳定（即平衡）键长为0.74 Å！所以，玛丽分子的确是相当知名的，但我们可以看到，我们可以如何不仅对其他化学物质，而且对模拟其他量子系统进行这个过程。
- en: '![](../Images/10-14.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10-14.png)'
- en: Figure 10.14 A sample of the plot that running host.py should produce. The exact
    data will likely vary, but in general we should see that the minimum ground state
    energy happens at about 0.75 Å on the horizontal axis, which is then the bond
    length with the lowest energy.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 运行host.py应该生成的图的一个示例。具体数据可能会有所不同，但总的来说，我们应该看到最小基态能量发生在水平轴上的大约0.75 Å处，这将是具有最低能量的键长。
- en: 'Congratulations: we have implemented our first practical application for a
    quantum computer! Of course, the actual chemical we used here is fairly simple,
    but this process holds for most other quantum systems we might want to simulate.
    In the next two chapters, we’ll explore two other applications of quantum computers:
    unstructured searching with Grover’s algorithm and factoring numbers with Shor’s
    algorithm.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜：我们已经实现了量子计算机的第一个实际应用！当然，我们这里使用的实际化学物质相当简单，但这个过程适用于我们可能想要模拟的大多数其他量子系统。在接下来的两章中，我们将探讨量子计算机的另外两种应用：使用Grover算法进行无结构搜索和使用Shor算法分解数字。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: One of the most exciting applications of quantum computing is to help us understand
    the properties of quantum mechanical systems such as chemical interactions.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子计算最令人兴奋的应用之一是帮助我们理解量子力学系统的性质，例如化学相互作用。
- en: We can think about quantum mechanics in many different ways. Using Python and
    Q#, we’ve thought about quantum mechanics as a kind of computation, but chemists
    and physicists may think of quantum mechanics as a set of rules describing how
    physical systems interact and behave.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从许多不同的角度来思考量子力学。使用Python和Q#，我们把量子力学看作是一种计算，但化学家和物理学家可能会把量子力学看作是一套规则，描述物理系统如何相互作用和表现。
- en: Physicists and chemists use a special kind of matrix called a *Hamiltonian*
    to predict how quantum mechanical systems change in time. If we can simulate a
    Hamiltonian on a quantum computer, then we can simulate physical systems described
    by those matrices.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理学家和化学家使用一种特殊的矩阵，称为哈密顿量，来预测量子力学系统随时间的变化。如果我们能在量子计算机上模拟哈密顿量，那么我们就可以模拟由这些矩阵描述的物理系统。
- en: An important special case of a Hamiltonian is a tensor product of Pauli matrices.
    These Hamiltonians describe a kind of generalization of the rotations we’ve seen
    throughout the book and can be simulated using the Q# `Exp` operation.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈密顿量的一个重要特殊情况是泡利矩阵的张量积。这些哈密顿量描述了我们在整本书中看到的所有旋转的一种推广，可以使用Q#的`Exp`操作来模拟。
- en: More complicated Hamiltonians can be broken down into sums of simpler Hamiltonians,
    allowing us to simulate each part of a Hamiltonian at a time.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更复杂的哈密顿量可以被分解为更简单哈密顿量的和，这使得我们可以一次模拟哈密顿量的一个部分。
- en: If we quickly alternate between the parts of a Hamiltonian we simulate, we can
    get a better approximation of simulating the full Hamiltonian. This is similar
    to how quickly alternating between walking north and west looks a bit like walking
    diagonally northwest when we zoom out.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们快速地在哈密顿量的不同部分之间交替模拟，我们可以得到模拟完整哈密顿量的更好近似。这类似于当我们放大时，快速在北和西之间交替行走看起来有点像西北对角线行走。
- en: Using chemical models (such as we may get from chemist friends), we can write
    and simulate Hamiltonians for quantum chemistry. Combining this simulation with
    phase estimation lets us learn the energy structure for different chemicals, helping
    us predict their behavior.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用化学模型（例如我们可以从化学家朋友那里获得），我们可以编写和模拟量子化学的哈密顿量。将这种模拟与相位估计相结合，使我们能够学习不同化学品的能量结构，帮助我们预测它们的行为。
- en: '* * *'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)P. J. J. O’Malley et al., “Scalable Quantum Simulation of Molecular Energies”
    (2015), [https://arxiv.org/abs/ 1512.06860](https://arxiv.org/abs/1512.06860).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: (1.) P. J. J. O’Malley 等人，“可扩展的分子能量量子模拟”（2015），[https://arxiv.org/abs/1512.06860](https://arxiv.org/abs/1512.06860)。
