- en: 11 Building with Gradle and Maven
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 使用Gradle和Maven构建
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why build tools matter for a well-grounded developer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么构建工具对扎实的开发者很重要
- en: Maven
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: Gradle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle
- en: The JDK ships with a compiler to turn Java source code into class files, as
    we saw in chapter 4\. Despite that fact, few projects of any size rely just on
    `javac`. Let’s start by looking at why a well-grounded developer should invest
    in familiarity with this layer of tooling.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: JDK附带了一个编译器，可以将Java源代码转换为类文件，正如我们在第4章中看到的。尽管如此，很少有项目仅依赖于`javac`。让我们首先看看为什么扎实的开发者应该投资于熟悉这一层工具。
- en: 11.1 Why build tools matter for a well-grounded developer
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 为什么构建工具对扎实的开发者很重要
- en: 'Build tools are the norm for the following reasons:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 构建工具之所以成为规范，有以下原因：
- en: Automating tedious operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化繁琐操作
- en: Managing dependencies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: Ensuring consistency between developers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保开发者之间的一致性
- en: 'Although many options exist, two choices dominate the landscape today: Maven
    and Gradle. Understanding what these tools aim to solve, digging below the surface
    of how they get their job done, and understanding the differences between them—and
    how to extend them—will pay off for the well-grounded developer.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在许多选项，但今天有两个选择主导着这个领域：Maven和Gradle。了解这些工具旨在解决的问题，深入了解它们如何完成任务，以及了解它们之间的差异——以及如何扩展它们——对于扎实的开发者来说将是有益的。
- en: 11.1.1 Automating tedious operations
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 自动化繁琐操作
- en: '`javac` can turn any Java source file into a class file, but there’s more to
    building a typical Java project than that. Just getting all the files properly
    listed to the compiler could be tedious in a large project if done by hand. Build
    tools provide defaults for finding code and let you easily configure if you have
    a nonstandard layout instead.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`javac`可以将任何Java源文件转换为类文件，但构建一个典型的Java项目不仅仅是这样。如果手动进行，仅将所有文件正确列出给编译器在大型项目中可能就是一项繁琐的工作。构建工具提供了查找代码的默认设置，并允许你轻松配置，如果你有一个非标准布局的话。'
- en: 'The conventional layout popularized by Maven, and used by default by Gradle
    as well, looks like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Maven推广的常规布局，以及Gradle默认使用的布局，看起来是这样的：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ main and test separate our production code from our test code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ main和test将我们的生产代码与测试代码分开。
- en: ❷ Multiple languages easily coexist within one project with this structure.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用这种结构，一个项目中可以轻松地共存多种语言。
- en: ❸ Further directory structure typically mirrors your package hierarchy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 进一步的目录结构通常反映了你的包层次结构。
- en: As you can see, testing is baked all the way into the layout of our code. Java’s
    come a long way since the time when folks used to ask whether they really needed
    to write tests for their code. The build tools have been a key part in making
    testing available in a consistent manner everywhere.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，测试已经完全融入到我们的代码布局中。自从人们问是否真的需要为他们的代码编写测试以来，Java已经走了很长的路。构建工具在使测试以一致的方式在所有地方可用方面发挥了关键作用。
- en: Note You probably already know about how to unit test in Java with JUnit or
    another library. We will discuss other forms of testing in chapter 14.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能已经知道如何在Java中使用JUnit或其他库进行单元测试。我们将在第14章中讨论其他形式的测试。
- en: Although compiling to class files is the start of a Java program’s existence,
    generally, it isn’t the end of the line. Fortunately, build tools also provide
    support for packaging your class files into a JAR or other format for easier distribution.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将代码编译成类文件是Java程序存在的起点，但通常并不是终点。幸运的是，构建工具还提供了将你的类文件打包成JAR或其他格式以方便分发支持。
- en: 11.1.2 Managing dependencies
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 管理依赖项
- en: In the early days of Java, if you wanted to use a library, you had to find its
    JAR somewhere, download the file, and put it into the classpath for your application.
    This caused several problems—in particular, the lack of a central, authoritative
    source for all libraries meant that a treasure hunt was sometimes necessary to
    find the JARs for less-common dependencies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的早期，如果你想要使用一个库，你必须找到它的JAR文件，下载文件，并将其放入应用程序的类路径中。这导致了一些问题——特别是，所有库缺乏一个中心、权威的来源，有时需要寻宝才能找到不太常见的依赖项的JAR文件。
- en: That obviously wasn’t ideal, and so Maven (among other projects) gave the Java
    ecosystem repositories where tools could find and install dependencies for us.
    Maven Central remains to this day one of the most commonly used registries for
    Java dependencies on the internet. Others also exist—public registries such as
    those hosted by Google or those shared on GitHub, and private installations via
    products such as Artifactory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这并不理想，因此Maven（以及其他项目）为Java生态系统提供了仓库，工具可以在其中为我们找到和安装依赖关系。Maven Central至今仍然是互联网上最常用的Java依赖关系注册表之一。其他也存在——如由Google托管或GitHub上共享的公共注册表，以及通过Artifactory等产品进行的私有安装。
- en: Downloading all that code can be time-consuming, too, so build tools have standardized
    on a few ways of reducing the pain by sharing artifacts between projects. With
    a local repository to cache, if a second project needs the same library, you don’t
    need to download it again, as shown in figure 11.1\. This approach also saves
    disk space, of course, but the single source of artifacts is the real win here.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下载所有这些代码可能也会很耗时，因此构建工具已经通过在项目之间共享工件来标准化了几种减少痛苦的方法。如果有第二个项目需要相同的库，由于有一个本地仓库来缓存，你就不需要再次下载它，如图11.1所示。当然，这种方法也可以节省磁盘空间，但这里真正的胜利在于单一来源的工件。
- en: '![](../Images/CH11_F01_Evans2.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 Maven的本地仓库不仅帮助在线查找依赖关系，而且能够高效地本地管理依赖关系](../Images/CH11_F01_Evans2.png)'
- en: Figure 11.1 Maven’s local repository helping not only to find dependencies online
    but to manage them efficiently locally
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 Maven的本地仓库帮助不仅在线查找依赖关系，而且能够高效地本地管理依赖关系
- en: Note You might be wondering where modules fit in this dependency landscape.
    Modularized libraries are shipped as JAR files with the addition of the `module-info.class`
    file, as we saw in chapter 2\. A modularized JAR can be downloaded from the standard
    repositories. The real differences come into play when you start compiling and
    running with modules, not in the packaging and distribution.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能想知道模块在这个依赖图中是如何定位的。模块化的库以带有`module-info.class`文件的JAR文件的形式发货，正如我们在第2章中看到的。可以从标准仓库下载模块化的JAR文件。真正的区别在于你开始使用模块编译和运行时，而不是在打包和分发时。
- en: More than just providing a central place to find and download dependencies,
    though, registries opened the door for better management of *transitive dependencies*.
    In Java, we commonly see this situation when a library that our project uses itself
    depends on *another* library. We actually already met transitive dependency of
    modules in chapter 2, but the problem existed long before Java modules. In fact,
    before modules, the problem was significantly worse.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了提供一个中心位置来查找和下载依赖关系之外，注册表还为更好地管理*传递依赖关系*打开了大门。在Java中，我们通常在项目使用的库本身依赖于*另一个*库时看到这种情况。实际上，我们在第2章中已经遇到了模块的传递依赖关系，但这个问题在Java模块出现之前就已经存在了。事实上，在模块出现之前，这个问题要严重得多。
- en: Recall that JAR files are just a zipped file—they don’t have any metadata that
    describes the dependencies of the JAR. This means that the dependencies of a JAR
    are just the union of all of the dependencies of all the classes in the JAR.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，JAR文件只是一个压缩文件——它们没有任何描述JAR依赖关系的元数据。这意味着JAR的依赖关系只是JAR中所有类依赖关系的并集。
- en: 'To make matters worse, the class file format does not describe which version
    of a class is needed to satisfy the dependency—all we have is a symbolic descriptor
    of the class or method name that the class requires to link (as we saw in chapter
    4). This implies the following two things:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，类文件格式没有描述需要哪个版本的类来满足依赖关系——我们只有类或方法名符号描述，该类需要链接（正如我们在第4章中看到的）。这暗示了以下两点：
- en: An external source of dependency information is required.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要外部依赖关系信息来源。
- en: As projects get larger, the transitive dependency graph will get increasingly
    complex.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着项目规模的扩大，传递依赖关系图将变得越来越复杂。
- en: With the explosion of open source libraries and frameworks to support developers,
    the typical tree of transitive dependencies in a real project has only gotten
    larger and larger.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开源库和框架的爆炸式增长，以支持开发者，真实项目中传递依赖关系的典型树状结构已经变得越来越大。
- en: One potential bit of good news is that the situation for the JVM ecosystem is
    somewhat better than it is for, say, JavaScript. JavaScript lacks a rich, central
    runtime library that is guaranteed to be always present, so a lot of basic capabilities
    have to be managed as external dependencies. This introduces problems such as
    multiple incompatible libraries that each provide a version of a common feature
    and a fragile ecosystem where mistakes and hostile attacks can have a disproportionate
    impact on the commons (e.g., the “left-pad” incident from 2016 [see [http://mng.bz/5Q64](http://mng.bz/5Q64)]).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个潜在的利好消息是，JVM生态系统的状况比JavaScript的情况要好一些。JavaScript缺乏一个丰富、集中的运行时库，该库保证始终存在，因此许多基本功能必须作为外部依赖来管理。这引入了问题，如多个不兼容的库各自提供相同功能的版本，以及一个脆弱的生态系统，其中错误和敌意攻击可能对公共部分产生不成比例的影响（例如，2016年的“left-pad”事件[见[http://mng.bz/5Q64](http://mng.bz/5Q64)]）。
- en: Java, on the other hand, has a runtime library (the JRE) that contains a lot
    of commonly needed classes, and this is available in every Java environment. However,
    a real production application will require capabilities beyond those in the JRE
    and will almost always have too many layers of dependencies to comfortably manage
    manually. The only solution is to automate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Java有一个运行时库（JRE），其中包含许多常用的类，并且这个库在每一个Java环境中都是可用的。然而，一个真正的生产应用程序将需要超出JRE的功能，并且几乎总是有太多的依赖层，难以手动管理。唯一的解决方案是自动化。
- en: A conflict emerges
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突出现
- en: This automation is a boon for developers building on the rich ecosystem of open
    source code available, but upgrading dependencies often reveals problems as well.
    For instance, figure 11.2 shows a dependency tree that might set us up for trouble.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动化对于在丰富的开源代码生态系统中构建的开发者来说是一个福音，但升级依赖通常也会揭示问题。例如，图11.2显示了一个可能让我们陷入麻烦的依赖树。
- en: '![](../Images/CH11_F02_Evans2.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F02_Evans2.png)'
- en: Figure 11.2 Conflicting transitive dependencies
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 冲突的传递依赖
- en: We’ve asked explicitly for version 2.0 of `lib-a`, but our dependency `lib-b`
    has asked for the older version 1.0\. This is known as a *dependency conflict*,
    and depending on how it is resolved, it can cause a variety of other problems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们明确要求了`lib-a`的2.0版本，但我们的依赖`lib-b`却要求使用较老的1.0版本。这被称为*依赖冲突*，并且根据如何解决，它可能会引起各种其他问题。
- en: 'What types of breakage can result from mismatched library versions? This depends
    on the nature of the changes between the versions. Changes fall into a few categories,
    shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不匹配的库版本可能导致哪些类型的破坏？这取决于版本之间变化的本性。变化可以分为几个类别，如下所示：
- en: Stable APIs where only the behavior changes between versions
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稳定的API，其中只有行为在版本之间发生变化
- en: Added APIs where new classes or methods appear between versions
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在版本之间出现新类或方法时添加的API
- en: Changed APIs where method signatures or interfaces extended changes between
    versions
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在版本之间扩展方法签名或接口时更改的API
- en: Removed APIs where classes or methods are removed between versions
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在版本之间删除类或方法时移除的API
- en: In the case of a) or b), you may not even notice which version of the dependency
    your build tool has chosen. The most common case of c) is a change to the signature
    of a method between library versions. In our previous example, if `lib-a` 2.0
    altered the signature of a method that `lib-b` relied upon, when `lib-b` tried
    to call that method, it would receive a `NoSuchMethodError` exception.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在a)或b)的情况下，你可能甚至都不会注意到你的构建工具选择了哪个版本的依赖。c)中最常见的案例是方法签名在库版本之间的变化。在我们的上一个例子中，如果`lib-a`
    2.0改变了`lib-b`所依赖的方法的签名，当`lib-b`尝试调用该方法时，它会收到一个`NoSuchMethodError`异常。
- en: Removed methods in case d) would result in the same sorts of `NoSuchMethodError`.
    This includes “renaming” a method, which at the bytecode level isn’t any different
    from removing a method and adding a new one that just happens to have the same
    implementation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在d)中删除的方法将导致相同的`NoSuchMethodError`。这包括“重命名”一个方法，在字节码级别上并不与删除一个方法并添加一个新方法有任何不同，只是新方法恰好有相同的实现。
- en: Classes are also prone to d) on deletion or renaming and will cause a `NoClassDefFoundError`.
    It’s also possible that removal of interfaces from a class could land you with
    an ugly `ClassCastException`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类在删除或重命名时也容易发生d)冲突，并会导致`NoClassDefFoundError`错误。还有可能，从一个类中删除接口可能会导致一个难看的`ClassCastException`。
- en: This list of issues with conflicting transitive dependencies is by no means
    exhaustive. It all boils down to *what* actually changes between two versions
    of the same package.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于冲突传递依赖的问题列表绝不是详尽的。所有这些都归结于同一软件包的两个版本之间实际发生了什么变化。
- en: In fact, communicating about the nature of changes between versions is a common
    problem across languages. One of the most broadly adopted approaches to handling
    the problem is *semantic versioning* (see [https://semver.org/](https://semver.org/)).
    Semantic versioning gives us a vocabulary for stating the requirements of our
    transitive dependencies, which in turn allows the machines to help us sort them
    out.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，关于版本之间变化性质的沟通是跨语言的一个常见问题。处理这个问题的最广泛采用的方法之一是 *语义版本化*（见 [https://semver.org/](https://semver.org/)）。语义版本化为我们提供了声明传递依赖要求的一套词汇，反过来又允许机器帮助我们整理它们。
- en: 'When using semantic versioning, keep in mind the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用语义版本化时，请记住以下几点：
- en: '*MAJOR* version increments (1.x -> 2.x) on breaking changes to your API, like
    cases c) and d) above.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要* 版本增量（1.x -> 2.x）是对 API 的破坏性更改，如上述 c) 和 d) 的情况。'
- en: '*MINOR* version increments (1.1 -> 1.2) on backward-compatible additions like
    case b).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*次要* 版本增量（1.1 -> 1.2）是对向后兼容的添加，如案例 b）。'
- en: '*PATCH* increments on bug fixes (1.1.0 -> 1.1.1).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*修补* 版本是对错误修复的增量（1.1.0 -> 1.1.1）。'
- en: Though not foolproof, it at least gives an expectation as to what level of changes
    come with a version update and is broadly used in open source.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是万无一失，但它至少提供了一个关于版本更新带来的变化级别的预期，并且在开源项目中广泛使用。
- en: Having gotten a taste of why dependency management isn’t easy, rest assured
    that both Maven and Gradle provide tooling to help. Later in the chapter, we’ll
    look in detail at what each tool provides to unravel problems when you hit dependency
    conflicts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝到了依赖管理不容易的原因之后，请放心，Maven 和 Gradle 都提供了工具来帮助。在本章的后面部分，我们将详细探讨每个工具提供的内容，以解决当你遇到依赖冲突时的问题。
- en: 11.1.3 Ensuring consistency between developers
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 确保开发人员之间的一致性
- en: As projects grow in volume of code and developers involved, they often get more
    complex and harder to work with. Your build tooling can lessen this pain, though.
    Built-in features like ensuring everyone is compiling and running the same tests
    are a start. But we should consider many additions beyond the basics as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目代码量和参与开发者的增加，它们通常变得更加复杂，更难处理。虽然你的构建工具可以减轻这种痛苦，但内置功能，如确保每个人都在编译和运行相同的测试，是一个开始。但我们也应该考虑许多超出基本功能的添加。
- en: Tests are good, but how certain are you that *all* your code is tested? Code
    coverage tools are key for detecting what code is hit by your tests and what isn’t.
    Although arguments swirl on the internet about the right target for code coverage,
    the line-level output coverage tools provide can save you from missing a test
    for that one extra special conditional.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是好的，但你有多确定 *所有* 你的代码都经过了测试？代码覆盖率工具对于检测你的测试击中了哪些代码以及哪些没有击中至关重要。尽管互联网上关于代码覆盖率正确目标的争论不断，但行级输出覆盖率工具可以帮助你避免遗漏那个额外的特殊条件测试。
- en: Java as a language also lends itself well to a variety of static analysis tools.
    From detecting common patterns (i.e., overriding `equals` without overriding `hashCode`)
    to sniffing out unused variables, static analysis lets a computer validate aspects
    of the code that are legal but will bite you in production.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种语言，Java 也非常适合各种静态分析工具。从检测常见模式（例如，没有重写 `hashCode` 就重写 `equals`）到嗅探未使用的变量，静态分析可以让计算机验证代码的合法方面，但在生产中可能会给你带来麻烦。
- en: Beyond the realms of correctness, though, are style and formatting tools. Ever
    fought with someone about where the curly braces should go in a statement? How
    to indent your code? Agreeing once to a set of rules, even if they aren’t all
    perfectly to your taste, lets you focus forever after in the project on the actual
    work instead of nitpicking details about how the code looks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了正确性之外，还有样式和格式化工具。你是否曾与某人争论过在语句中花括号应该放在哪里？如何缩进代码？一旦同意了一套规则，即使它们并不完全符合你的口味，也让你在项目上永远专注于实际工作，而不是纠结于代码的外观细节。
- en: Last and certainly not least, your build tool is a pivotal central point for
    providing custom functionality. Are there special setup or operational commands
    folks need to run periodically for your project? Validations your project should
    run after a build but before you deploy? All of these are excellent to consider
    wiring into the build tooling so they’re available to everyone working with the
    code. Both Maven and Gradle provide many ways to extend them for your own logic
    and needs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，您的构建工具是提供自定义功能的关键中心点。对于您的项目，人们是否需要定期运行特殊的设置或操作命令？在部署之前但在构建之后，项目应该运行哪些验证？所有这些都非常适合考虑将其集成到构建工具中，以便所有与代码一起工作的人都可以使用。Maven
    和 Gradle 都提供了许多扩展它们以适应您自己的逻辑和需求的方法。
- en: 'Hopefully you’re now convinced that build tools aren’t just something to set
    up once on a project but are worth the investment in understanding. Let’s start
    by taking a look at one of the most common: Maven.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在已经相信，构建工具不仅仅是项目上的一次性设置，理解它们是值得投资的。让我们先从最常见的一个开始：Maven。
- en: 11.2 Maven
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 Maven
- en: Early in Java history, the Ant framework was the default build tool. With tasks
    described in XML, it allowed a more Java-centric way to script builds than tools
    like Make. But Ant lacked structure around how to configure your build—-what the
    steps were, how they related, how dependencies were managed. Maven addressed many
    of these gaps with its concept of a standardized *build lifecycle* and a consistent
    approach to handling dependencies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 早期，Ant 框架是默认的构建工具。通过 XML 描述的任务，它允许比 Make 等工具更以 Java 为中心的脚本构建方式。但 Ant
    缺乏关于如何配置您的构建的结构——步骤是什么，它们如何相关联，如何管理依赖关系。Maven 通过其标准化的 *构建生命周期* 和处理依赖关系的一致方法解决了许多这些差距。
- en: 11.2.1 The build lifecycle
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 构建生命周期
- en: 'Maven is an opinionated tool. One of the biggest areas where these opinions
    show is in its build lifecycles. Rather than users defining their own tasks and
    determining their order, Maven has a *default lifecycle* encompassing the usual
    steps, known as *phases*, that you’d expect in a build. Though not comprehensive,
    the following phases capture the high points in the default lifecycle:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 是一个有偏见的工具。这些偏见在构建生命周期中表现得尤为明显。与用户定义自己的任务并确定它们的顺序不同，Maven 有一个包含通常步骤的 *默认生命周期*，这些步骤被称为
    *阶段*，您在构建中会期望看到这些阶段。虽然不是全面的，但以下阶段捕捉了默认生命周期的要点：
- en: '*Validate*—Check project configuration is correct and can build'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证*—检查项目配置是否正确且可以构建'
- en: '*Compile*—Compile the source code'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译*—编译源代码'
- en: '*Test*—Run unit tests'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试*—运行单元测试'
- en: '*Package*—Generate artifacts such as JAR files'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*打包*—生成如 JAR 文件等工件'
- en: '*Verify*—Run integration tests'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证*—运行集成测试'
- en: '*Install*—Install package to the local repository'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装*—将包安装到本地仓库'
- en: '*Deploy*—Make package result available to others, typically run from a CI environment'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部署*—使包结果可供他人使用，通常在 CI 环境中运行'
- en: Chances are that these map to most of the steps you’ll take from source code
    to a deployed application or library. This is a major bonus to Maven’s opinionated
    approach—any Maven project will share this same lifecycle. Your knowledge of how
    to run builds is more transportable than it used to be.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤很可能对应于您从源代码到已部署的应用程序或库所采取的大部分步骤。这是 Maven 预设方法的一个主要优势——任何 Maven 项目都将共享这个相同的生命周期。您对如何运行构建的知识比以前更易于迁移。
- en: The phases are well-defined in Maven, but every project needs something special
    in the details. In Maven’s model, various *plugins* attach *goals* to these phases.
    A goal is a concrete task, with the implementation of how to execute it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 中的阶段定义得很好，但每个项目在细节上都需要一些特殊的东西。在 Maven 的模型中，各种 *插件* 将 *目标* 绑定到这些阶段。目标是一个具体的任务，包括如何执行它的实现。
- en: Beyond the default lifecycle, Maven also includes the *clean* and *site* lifecycles.
    The *clean* lifecycle is intended for cleanup (e.g., removing intermediate build
    results), whereas the *site* lifecycle is meant for documentation generation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认的生命周期之外，Maven 还包括 *清理* 和 *站点* 生命周期。*清理* 生命周期旨在进行清理（例如，删除中间构建结果），而 *站点* 生命周期旨在生成文档。
- en: We’ll look closer at hooking into a lifecycle later when we discuss extending
    Maven, but if you truly need to redefine the universe, Maven does support authoring
    fully custom lifecycles. This is a very advanced topic, however, and beyond the
    scope of this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在讨论扩展 Maven 时更详细地探讨如何挂钩生命周期，但如果您确实需要重新定义整个宇宙，Maven 支持编写完全自定义的生命周期。然而，这是一个非常高级的话题，超出了本书的范围。
- en: 11.2.2 Commands/POM intro
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 命令/POM 简介
- en: Maven is a project of the Apache Software Foundation and is open source. Installation
    instructions can be found on the project website at [https://maven.apache.org/install.html](https://maven.apache.org/install.html).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 是 Apache 软件基金会的一个项目，并且是开源的。安装说明可以在项目网站上找到，网址为 [https://maven.apache.org/install.html](https://maven.apache.org/install.html)。
- en: 'Typically, Maven is installed globally on a developer’s workstation, and it
    works on any not-ancient JVM (JDK 7 or higher). Once installed, invoking it gets
    us this output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Maven 被安装在开发工作站的全球范围内，并且可以在任何非古老 JVM（JDK 7 或更高版本）上运行。一旦安装，调用它将给我们以下输出：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of particular interest is the message that `No goals have been specified for
    this build.` This indicates that Maven doesn’t know anything about our project.
    We provide that information in the `pom.xml` file, which is the center of the
    universe for a Maven project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是消息“此构建未指定任何目标。”这表明 Maven 对我们的项目一无所知。我们通过 `pom.xml` 文件提供这些信息，这是 Maven
    项目的宇宙中心。
- en: Note POM stands for Project Object Model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，POM 代表项目对象模型。
- en: 'Although a full-blown `pom.xml` file can be intimidatingly long and complex,
    you can get started with much less. For example, a more-or-less minimal `pom.xml`
    file looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管完整的 `pom.xml` 文件可能非常长且复杂，但您可以用更少的配置开始。例如，一个更接近最小化的 `pom.xml` 文件看起来像这样：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Identifying our project
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别我们的项目
- en: ❷ The Maven plugins default to Java 1.6\. We obviously want a newer version.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Maven 插件默认使用 Java 1.6。显然，我们希望使用更新的版本。
- en: 'Our `pom.xml` file declares two particularly important fields: the `groupId`
    and the `artifactId`. These fields combine with a version to form the *GAV coordinates*
    (group, artifact, version), which uniquely, globally identifies a specific release
    of your package. `groupId` typically specifies the company, organization, or open
    source project responsible for the library, whereas `artifactId` is the name for
    the specific library. GAV coordinates are often expressed with each part separated
    by a colon (`:`), such as `org.apache.commons:collections4:4.4` or `com.google.guava:guava:30.1-jre`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `pom.xml` 文件声明了两个特别重要的字段：`groupId` 和 `artifactId`。这些字段与一个版本号结合，形成 *GAV 坐标*（组，构件，版本），它唯一地、全局地标识了您包的特定版本。`groupId`
    通常指定负责库的公司、组织或开源项目，而 `artifactId` 是特定库的名称。GAV 坐标通常用冒号（`:`）分隔每个部分来表示，例如 `org.apache.commons:collections4:4.4`
    或 `com.google.guava:guava:30.1-jre`。
- en: These coordinates are important not just for configuring your project locally.
    Coordinates act as the address for dependencies, so our build tooling can find
    them. The following sections will dig into the mechanics of how we express those
    dependencies in more detail.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标不仅对本地配置项目很重要。坐标作为依赖项的地址，因此我们的构建工具可以找到它们。以下章节将深入探讨我们如何更详细地表达这些依赖项的机制。
- en: 'Much like Maven standardized the build lifecycle, it also popularized the standard
    layout we saw earlier in section 11.1.1 and shown next. If you follow these conventions,
    you don’t have to tell Maven anything about your project for it to be able to
    compile:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Maven 标准化了构建生命周期一样，它也普及了我们之前在 11.1.1 节中看到的标准布局，并将在下面展示。如果您遵循这些约定，就不需要告诉 Maven
    任何关于您项目的信息，它就能进行编译：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the parallel structures—`src/main/java` and `src/test/java`— with the
    same directories mapping to our package hierarchy. This convention keeps the test
    code separate from the main app code, which simplifies the process of packaging
    our main code for deployment, excluding the test code, which users of a package
    won’t typically want or use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到平行结构——`src/main/java` 和 `src/test/java`——相同的目录映射到我们的包层次结构。这个约定将测试代码与主应用程序代码分开，这简化了打包主代码以部署的过程，排除了用户通常不需要或使用的测试代码。
- en: Other standard directories exist beyond these two. For instance, `src/main/
    resources` is the typical location for additional non-code files to include in
    a JAR. See the documentation at [http://mng.bz/6XoG](http://mng.bz/6XoG) for a
    full listing of the Maven standard layout.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个之外，还存在其他标准目录。例如，`src/main/resources` 是包含在 JAR 文件中的额外非代码文件的典型位置。有关 Maven
    标准布局的完整列表，请参阅文档 [http://mng.bz/6XoG](http://mng.bz/6XoG)。
- en: While you’re getting used to Maven, it’s a good idea to stick to the conventions,
    standard layouts, and other defaults that Maven provides. As we mentioned, it’s
    an opinionated tool, so it’s better to stay within the guardrails it provides
    while you’re learning. Experienced Maven developers can (and do) stray outside
    the conventions and break the rules, but let’s not try to run before we walk.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你还在适应 Maven 时，坚持使用 Maven 提供的约定、标准布局和其他默认设置是个好主意。正如我们提到的，它是一个有偏见的工具，所以在学习过程中最好遵守它提供的规则。经验丰富的
    Maven 开发者可以（并且确实）打破常规和规则，但让我们先学会走路再尝试跑步。
- en: 11.2.3 Building
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 构建
- en: We saw previously that just running `mvn` on the command line warns us that
    we need to choose a lifecycle phase or goal to actually take action. Most often
    we’ll want to run a phase, which may include many goals.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，在命令行上运行 `mvn` 会警告我们需要选择一个生命周期阶段或目标才能实际执行操作。大多数情况下，我们都会想运行一个阶段，这可能包括许多目标。
- en: 'The simplest place to get started is compiling our code by requesting the `compile`
    phase like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 开始的最简单方式是通过请求 `compile` 阶段来编译我们的代码，如下所示：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Although we don’t have resources in our project, the maven-resources-plugin
    from the default lifecycle checks for us.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尽管我们的项目中没有资源，但默认生命周期中的 maven-resources-plugin 会为我们检查。
- en: ❷ Our actual compilation is provided by maven-compiler-plugin.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们的实际编译是由 maven-compiler-plugin 提供的。
- en: Maven defaults our output to the `target` directory. After our `mvn compile`,
    we can find the class files under `target/classes`. Close inspection will reveal
    we only built the code under our `main` directory. If we want to compile our tests,
    you can use the `test-compile` phase.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 默认将输出目录设置为 `target`。在执行 `mvn compile` 后，我们可以在 `target/classes` 下找到类文件。仔细检查会发现我们只编译了
    `main` 目录下的代码。如果我们想编译测试代码，可以使用 `test-compile` 阶段。
- en: The default lifecycle includes more than just compilation. For instance, `mvn
    package` for the previous project will result in a JAR file at `target/example-1.0-SNAPSHOT.jar`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的生命周期不仅包括编译。例如，对于前面的项目，`mvn package` 将在 `target/example-1.0-SNAPSHOT.jar`
    生成一个 JAR 文件。
- en: Although we can use this JAR as a library, if we try to run it via `java -jar
    target/ example-1.0-SNAPSHOT.jar`, we’ll find that Java complains it can’t find
    a main class. To see how we start growing our Maven build, let’s change it so
    the produced JAR is a runnable application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将这个 JAR 作为库使用，但如果尝试通过 `java -jar target/ example-1.0-SNAPSHOT.jar` 运行它，我们会发现
    Java 抱怨找不到主类。为了了解我们如何开始构建 Maven 项目，让我们将其修改为生成的 JAR 是一个可运行的应用程序。
- en: 11.2.4 Controlling the manifest
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 控制清单
- en: 'The JAR Maven produced from `mvn package` was missing a *manifest* to tell
    the JVM where to look for a `main` method on startup. Fortunately, Maven ships
    with a plugin for constructing JARs that knows how to write the manifest. The
    plugin exposes configuration via our `pom.xml` after the `properties` element
    and still inside the `project` element as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 从 `mvn package` 生成的 JAR 缺少一个 *清单* 来告诉 JVM 在启动时在哪里查找 `main` 方法。幸运的是，Maven
    随带一个构建 JAR 的插件，该插件知道如何编写清单。该插件通过我们的 `pom.xml` 中的 `properties` 元素之后，仍然在 `project`
    元素内部公开配置，如下所示：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ maven-jar-plugin is the plugin name. You can spot this easily in the output
    when running the mvn package command.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ maven-jar-plugin 是插件名称。在运行 mvn package 命令的输出中可以轻松找到它。
- en: ❷ Each plugin has its own specialized configuration element with different child
    elements and attributes supported.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个插件都有自己的专用配置元素，具有不同的子元素和属性支持。
- en: ❸ <manifest> configures the resulting JAR’s manifest contents.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `<manifest>` 配置生成的 JAR 的清单内容。
- en: ❹ Configures our automatic module name
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 配置我们的自动模块名称
- en: Adding this section sets up the main class so the `java` launcher knows how
    to directly execute the JAR. We have also added an automatic module name—this
    is to be good citizens in the modular world. As we discussed back in chapter 2,
    even if the code we’re writing is not modular (as in this case), it still makes
    sense to provide an explicit automatic module name so modular applications can
    more easily use our code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个部分设置主类，这样 `java` 启动器就知道如何直接执行 JAR。我们还添加了一个自动模块名称——这是为了在模块化世界中成为好公民。正如我们在第
    2 章中讨论的，即使我们编写的代码不是模块化的（就像这个例子一样），提供显式的自动模块名称仍然是有意义的，这样模块化应用程序就可以更容易地使用我们的代码。
- en: This pattern of setting configuration under a `plugin` element is very standard
    in Maven. To simplify things, most default plugins will kindly warn if you use
    an unsupported or unexpected configuration property, although the details may
    vary by plugin.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `plugin` 元素下设置配置的模式在 Maven 中非常标准。为了简化问题，大多数默认插件会友好地警告你使用不受支持或意外的配置属性，尽管具体细节可能因插件而异。
- en: 11.2.5 Adding another language
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5 添加另一种语言
- en: As we discussed in chapter 8, an advantage of the JVM as a platform is the ability
    to use multiple languages within the same project. This may be useful when a specific
    language has better facilities for a given part of your application, or even to
    allow gradual conversion of an application from one language to another.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 8 章中讨论的，JVM 作为平台的一个优点是能够在同一个项目中使用多种语言。当特定语言在应用程序的某个部分有更好的功能时，这可能很有用，甚至可以允许应用程序从一种语言逐渐转换为另一种语言。
- en: 'Let’s take a look at how we would configure our simple Maven project to build
    some classes from Kotlin instead of Java. Our standard layout is fortunately already
    set to allow for easy adding languages, as shown next:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何配置我们的简单 Maven 项目，以便从 Kotlin 而不是 Java 构建一些类。幸运的是，我们的标准布局已经设置为允许轻松添加语言，如下所示：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ We keep our Kotlin code in its own subdirectory so it’s easy to tell what
    paths use which compiler to produce class files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将 Kotlin 代码保存在自己的子目录中，这样就可以轻松地知道哪些路径使用哪个编译器来生成类文件。
- en: ❷ Packages can mix between the languages, because the resulting class files
    don’t have direct knowledge of what language they were generated from.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包可以在语言之间混合，因为生成的类文件没有直接了解它们是从哪种语言生成的知识。
- en: Unlike Java, Maven by default doesn’t know how to compile Kotlin so we need
    to add `kotlin-maven-plugin` in our `pom.xml`. We recommend consulting the Kotlin
    documentation at [https://kotlinlang.org/docs/maven.html](https://kotlinlang.org/docs/maven.html)
    for the most up-to-date usage, but we’ll demonstrate here so you can know what
    to expect.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 不同，Maven 默认不知道如何编译 Kotlin，因此我们需要在 `pom.xml` 中添加 `kotlin-maven-plugin`。我们建议您查阅
    Kotlin 文档 [https://kotlinlang.org/docs/maven.html](https://kotlinlang.org/docs/maven.html)，以获取最新的使用方法，但我们将在此处演示，以便您知道可以期待什么。
- en: 'If a project is fully written in Kotlin, compilation only needs the plugin
    added and attached to the `compile` goal as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个项目完全用 Kotlin 编写，编译只需要添加并附加到 `compile` 目标的插件，如下所示：
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Current version of Kotlin, as of when this chapter was written.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当本章编写时的 Kotlin 当前版本。
- en: ❷ Adds this plugin to the goals for compiling main and test code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将此插件添加到编译主代码和测试代码的目标中。
- en: 'The situation gets more complex when mixing Kotlin and Java. Maven’s default
    `maven-compiler-plugin`, which compiles Java for us, needs to be overridden to
    let Kotlin compile first, as shown next, or our Java code will be unable to use
    the Kotlin classes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当混合 Kotlin 和 Java 时，情况变得更加复杂。为我们编译 Java 的 Maven 默认 `maven-compiler-plugin` 需要被覆盖，以便
    Kotlin 首先编译，如下所示，否则我们的 Java 代码将无法使用 Kotlin 类：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Adds the kotlin-maven-plugin mostly as before, making sure now it’s aware
    of both Java and Kotlin paths
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 主要添加 kotlin-maven-plugin 与之前类似，确保现在它知道 Java 和 Kotlin 路径
- en: ❷ The Kotlin compiler needs to know about both our Kotlin and Java code locations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Kotlin 编译器需要知道我们的 Kotlin 和 Java 代码位置。
- en: ❸ Disables the maven-compiler-plugin defaults for building Java because these
    force it to run first
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 禁用 maven-compiler-plugin 的默认值以构建 Java，因为这些默认值会强制它首先运行
- en: ❹ Reapplies the maven-compiler-plugin to the compile and test-compile phases.
    These will now be added after the kotlin-maven-plugin.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 重新应用 maven-compiler-plugin 到编译和测试编译阶段。现在这些将在 kotlin-maven-plugin 之后添加。
- en: Note The above overrides may get complicated when using Maven features like
    parent projects, where additional POM definitions might come into conflict. We’ll
    see some tactics soon for debugging when these issues arise.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当使用 Maven 功能如父项目时，上述覆盖可能会变得复杂，其中可能存在额外的 POM 定义冲突。当出现这些问题时，我们将很快看到一些调试策略。
- en: 'Your project will need a dependency on at least the Kotlin standard library,
    so we add that explicitly like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目至少需要一个对 Kotlin 标准库的依赖，因此我们明确添加如下：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this in place, our multilingual project builds and runs as before.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置之后，我们的多语言项目可以像以前一样构建和运行。
- en: 11.2.6 Testing
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.6 测试
- en: 'Once your code builds, a smart next step is to test it. Maven integrates testing
    deeply into its lifecycle. In fact, where compilation of your main code is only
    a single phase, Maven supports two separate phases of testing out of the box:
    `test` and `integration-test`. `test` is used for typical unit testing, whereas
    the `integration-test` phase runs after construction of artifacts such as JARs,
    with the intent of performing end-to-end validation on your final outputs.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码构建完成，下一步就是对其进行测试。Maven将测试深度集成到其生命周期中。实际上，主代码的编译只有一个阶段，而Maven支持开箱即用的两个独立的测试阶段：`test`和`integration-test`。`test`用于典型单元测试，而`integration-test`阶段在构建JAR等工件之后运行，目的是对最终输出进行端到端验证。
- en: Note Integration tests may also be run with JUnit because, despite the name,
    JUnit is a very capable test runner for more than just unit testing. Do not fall
    into the trap of thinking that any test executed by JUnit is automatically a unit
    test! We’ll examine the different types of tests in detail in chapter 13.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，集成测试也可以使用JUnit运行，因为尽管名称如此，JUnit是一个非常强大的测试运行器，不仅限于单元测试。不要陷入这样的陷阱，认为JUnit执行的任何测试都是自动的单元测试！我们将在第13章中详细检查不同类型的测试。
- en: Almost any project will benefit from some testing. As you might expect from
    Maven’s opinionated stance, testing happens (by default) using the near ubiquitous
    framework JUnit. Other frameworks are just a plugin away.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何项目都将从一些测试中受益。正如你所期望的，Maven有自己的一套观点，测试默认使用几乎无处不在的框架JUnit。其他框架只需一个插件即可。
- en: 'Although the standard plugins know about running JUnit, we still must declare
    the library as a dependency so Maven knows how to compile our tests. You can add
    a library with a snippet like the following under the `<project>` element:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管标准插件知道如何运行JUnit，我们仍然必须将其作为依赖项声明，以便Maven知道如何编译我们的测试。你可以在`<project>`元素下添加如下片段来添加库：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ <scope> indicates this library is needed only for the test-compile phase.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `<scope>`表示这个库只需要在测试编译阶段使用。
- en: 'With that in place, we can try to run our unit tests. Depending on your version
    of Maven, even the most recent versions may give us this odd result:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以尝试运行我们的单元测试。根据你的Maven版本，即使是最新版本也可能给出这个奇怪的结果：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Maven’s default for running JUnit tests is the maven-surefire-plugin.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Maven运行JUnit测试的默认插件是maven-surefire-plugin。
- en: ❷ No tests were run? That’s not right!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 没有运行测试？这显然是不对的！
- en: 'For compatibility reasons, the plugin `maven-surefire-plugin` that is installed
    by default, even as late as Maven 3.8.4, isn’t aware of JUnit 5\. We’ll dig more
    into these conversion issues in chapter 13, but in the meantime, let’s just bump
    our version of the plugin to something more recent, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于兼容性原因，默认安装的插件`maven-surefire-plugin`，即使是在Maven 3.8.4这样的较晚版本，也不了解JUnit 5。我们将在第13章中更深入地探讨这些转换问题，但在此期间，让我们将插件的版本提升到更近期的版本，如下所示：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Moving later than 2.12, the plugins understand JUnit 5 directly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果在2.12之后移动，插件将直接理解JUnit 5。
- en: 'With that in place we see the following more reassuring outcome:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们看到以下更令人放心的结果：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'By default, the Surefire plugin runs all unit tests in the standard location,
    `src/test/*`, during the `test` phase. If we want to take advantage of the `integration-test`
    phase, it’s recommended to use a separate plugin, such as `maven-failsafe-plugin`.
    Failsafe is maintained by the same folks who make `maven-surefire-plugin` and
    specifically targets the integration testing case. We add the plugin in our `<build><plugins>`
    section we previously used for configuring our manifest as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Surefire插件在`test`阶段运行标准位置的所有单元测试，即`src/test/*`。如果我们想利用`integration-test`阶段，建议使用单独的插件，例如`maven-failsafe-plugin`。Failsafe由制作`maven-surefire-plugin`的同一群人维护，并专门针对集成测试案例。我们在之前用于配置清单的`<build><plugins>`部分添加了插件，如下所示：
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Failsafe treats the following filename patterns as integration tests, although
    it can be reconfigured:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Failsafe将以下文件名模式视为集成测试，尽管它可以被重新配置：
- en: '`**/IT*.java`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**/IT*.java`'
- en: '`**/*IT.java`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**/*IT.java`'
- en: '`**/*ITCase.java`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**/*ITCase.java`'
- en: Because it’s part of the same suite of plugins, Surefire is also aware of this
    convention and excludes these tests from the `test` phase.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它属于同一套插件，Surefire也了解这个约定，并将这些测试排除在`test`阶段之外。
- en: 'It’s recommended to run integration tests via `mvn verify`, as shown next,
    rather than `mvn integration-test`. `verify` includes `post-integration-test`,
    which is the typical location for plugins to attach any post-test cleanup work
    if any is needed:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过 `mvn verify` 运行集成测试，如下所示，而不是 `mvn integration-test`。`verify` 包括 `post-integration-test`，这是插件附加任何后测试清理工作的典型位置：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 11.2.7 Dependency management
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.7 依赖管理
- en: A key feature Maven brought to the ecosystem was a standard format for expressing
    dependency management information via the `pom.xml` file. Maven also established
    a central repository for libraries. Maven can walk your `pom.xml` and the `pom.xml`
    files from your dependencies to determine the entire set of *transitive dependencies*
    your application requires.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 带给生态系统的关键特性是通过 `pom.xml` 文件以标准格式表达依赖管理信息。Maven 还建立了一个库的中央仓库。Maven 可以遍历
    `pom.xml` 和依赖项的 `pom.xml` 文件，以确定应用程序所需的整个传递依赖项集。
- en: The process of walking the tree and finding all the necessary libraries is called
    *dependency resolution*. Though critical for managing modern applications, the
    process does have its sharp edges.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历树并找到所有必要库的过程称为 *依赖解析*。虽然对于管理现代应用程序至关重要，但这个过程确实有其锋利的边缘。
- en: To see where the problems arise, let’s revisit the project setup we saw earlier
    in section 11.1.2\. Recall that the project’s dependencies have resulted in a
    tree that looks like that shown in figure 11.3.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解问题出现在哪里，让我们回顾一下在 11.1.2 节中看到的早期项目设置。回想一下，项目的依赖项导致了一个看起来像图 11.3 所示的树。
- en: '![](../Images/CH11_F03_Evans2.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F03_Evans2.png)'
- en: Figure 11.3 Conflicting transitive dependencies where a dependency requests
    an older version
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 请求较旧版本的冲突传递依赖
- en: Here we’ve asked explicitly for version 2.0 of `lib-a`, but our dependency `lib-b`
    has asked for the older version 1.0\. Maven’s dependency resolution algorithm
    favors the version of a library closest to the root. The end result of the configuration
    shown in figure 11.3 is that we will use `lib-a` 2.0 in our application. As we
    outlined in section 11.1.2, this may work fine or be disastrously broken.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确请求了 `lib-a` 的 2.0 版本，但我们的依赖项 `lib-b` 请求了较旧的 1.0 版本。Maven 的依赖解析算法倾向于选择离根最近的库版本。图
    11.3 所示配置的最终结果是，我们将在应用程序中使用 `lib-a` 2.0 版本。正如我们在 11.1.2 节中概述的，这可能会工作得很好，也可能导致灾难性的错误。
- en: Another common scenario that can also cause problems is when the reverse occurs
    and the dependency that is closest to the root is *older* than the one expected
    as a transitive dependency, as depicted in figure 11.4.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能导致问题的常见场景是，当发生反向情况，即离根最近的依赖项比预期的传递依赖项更旧，如图 11.4 所示。
- en: '![](../Images/CH11_F04_Evans2.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F04_Evans2.png)'
- en: Figure 11.4 Conflicting transitive dependencies where a dependency asks for
    a newer version
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 冲突的传递依赖，其中依赖项请求更高版本
- en: In this case, it’s entirely possible that `lib-d` is relying on an API in `lib-c`
    that didn’t exist in version 3.0, so adding a dependency on `lib-d` to a project
    that is already using `lib-c` will result in runtime exceptions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`lib-d` 可能依赖于 `lib-c` 中不存在于 3.0 版本的 API，因此将 `lib-d` 的依赖项添加到已经使用 `lib-c`
    的项目中将导致运行时异常。
- en: Note Given those possibilities, we recommended any package your code directly
    interacts with should be declared explicitly in your `pom.xml`. If you don’t,
    and instead rely upon transitive dependency, updating your direct dependency could
    result in unexpected build breakage.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：鉴于这些可能性，我们建议任何与代码直接交互的包都应在您的 `pom.xml` 中明确声明。如果您不这样做，而是依赖于传递依赖项，更新直接依赖项可能会导致意外的构建中断。
- en: 'Before we can solve our dependency problems, it’s important to know what our
    dependencies are. Maven has us covered with the `mvn dependency:tree` command,
    shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够解决依赖问题之前，了解我们的依赖项非常重要。Maven 通过 `mvn dependency:tree` 命令为我们提供了支持，如下所示：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The tree from this command shows us our direct dependencies on JUnit from the
    `pom` `.xml` file at the first level of nesting, followed by JUnit’s own transitive
    dependencies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令生成的树显示了我们直接依赖于 `pom.xml` 文件中的 JUnit，这是在嵌套的第一层，然后是 JUnit 自己的传递依赖项。
- en: 'JUnit comes with a slim set of dependencies, so to explore transitive dependency
    issues further, let’s imagine that our team wants to use two internal libraries
    at our company to get support for doing custom assertions. These are both built
    using the `assertj` library, but unfortunately different versions, as shown next:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 有一组很小的依赖项，为了进一步探索传递依赖问题，让我们假设我们的团队想要使用我们公司内的两个内部库来支持执行自定义断言。这两个库都是使用 `assertj`
    库构建的，但不幸的是，版本不同，如下所示：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Our first helper library brings assertj-core with version 3.21.0.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的第一辅助库带来了版本 3.21.0 的 assertj-core。
- en: ❷ Our second helper library wants assertj-core with version 2.9.1.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们的第二个辅助库需要 assertj-core 版本 2.9.1。
- en: The best possible approach is finding newer versions of our dependencies that
    can all agree on their dependencies. As internal libraries, this is obviously
    a possibility. Even in the broader world of open source, it’s often possible.
    Having said that, sometimes libraries lose their maintainers and fall out of date,
    so it is entirely possible to get stuck in a situation where it’s difficult to
    get the update we desire.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳方法是在我们的依赖项中找到更新的版本，它们都可以就其依赖项达成一致。作为内部库，这显然是可能的。即使在更广泛的开源世界中，这也通常是可能的。话虽如此，有时库会失去其维护者而变得过时，因此完全有可能陷入难以获得我们所需更新的情况。
- en: This leaves us looking for other ways to deal with the conflict. Two main approaches
    come into play if we can’t find a natural resolution. Be aware that both of these
    solutions require finding *some* compatible version that will satisfy your dependencies.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们寻找其他处理冲突的方法。如果我们找不到自然的解决方案，两种主要方法就会发挥作用。请注意，这两种解决方案都需要找到某种兼容版本，以满足你的依赖项。
- en: 'If one of your dependencies specifies a version that everyone could agree on,
    but it isn’t being chosen by Maven’s resolution algorithm, you can tell Maven
    to exclude parts of the tree when resolving. If both of our helper libraries can
    work fine with the newer `assertj-core`, we can just ignore the older one brought
    by the second library, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的某个依赖项指定了一个大家都能同意的版本，但这个版本没有被 Maven 的解析算法选中，你可以告诉 Maven 在解析时排除树的部分。如果我们的两个辅助库都可以与较新的
    `assertj-core` 正常工作，我们就可以忽略第二个库带来的旧版本，如下所示：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Excludes the second-test-helper obsolete version of assertj-core
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 排除第二测试辅助库的过时版本 assertj-core
- en: ❷ Lets the transitive dependency from first-test-helper proceed normally
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许来自第一测试辅助库的传递依赖正常进行
- en: 'In the worst case, perhaps neither library expresses the compatible version.
    To handle this, we specify the precise version as a direct dependency in our project,
    as shown in the following code sample. By its resolution rules, Maven will choose
    that version because it is closer to the project root. Although this convinces
    the tool to do what we want, we are taking on the risk of runtime errors from
    mixing libraries versions, so it is important to test the interactions thoroughly:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，也许两个库都没有表达兼容的版本。为了处理这种情况，我们指定精确版本作为项目中的直接依赖项，如下面的代码示例所示。根据其解析规则，Maven
    将选择该版本，因为它更接近项目根。虽然这说服了工具按照我们的意愿行事，但我们承担了混合库版本运行时错误的危险，因此彻底测试交互非常重要：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Our dependencies will ask for assertj-core at a different version.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的依赖项将请求不同版本的 assertj-core。
- en: ❷ Our dependencies will ask for assertj-core at a different version.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们的依赖项将请求不同版本的 assertj-core。
- en: ❸ But we force resolution on assertj-core to the precise version we want.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 但我们强制将 assertj-core 的解析版本精确到我们想要的版本。
- en: Finally, it’s worth noting that the `maven-enforcer-plugin` can be configured
    to fail the build if any mismatched dependencies are found so we can avoid relying
    on bad runtime behavior to surface problems. (See [http://mng.bz/o2WN](http://mng.bz/o2WN).)
    These build failures can then be addressed using the techniques we’ve discussed
    earlier.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，`maven-enforcer-plugin` 可以配置为在发现任何不匹配的依赖项时失败构建，这样我们就可以避免依赖于不良的运行时行为来暴露问题。（见
    [http://mng.bz/o2WN](http://mng.bz/o2WN)。）然后我们可以使用我们之前讨论的技术来解决这些构建失败。
- en: 11.2.8 Reviewing
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.8 审查
- en: Our build process is an excellent spot to hook in additional tooling and checks.
    One key bit of information is code coverage, which informs us what parts of our
    code our tests execute.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建过程是挂钩额外工具和检查的绝佳位置。一条关键信息是代码覆盖率，它告诉我们我们的测试执行了代码的哪些部分。
- en: A leading option for code coverage in the Java ecosystem is JaCoCo ([http://mng.bz/nNjv](http://mng.bz/nNjv)).
    JaCoCo can be configured to enforce certain coverage levels during testing and
    will output reports that tell you what is and isn’t covered.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Java生态系统中的代码覆盖率领先选项是JaCoCo ([http://mng.bz/nNjv](http://mng.bz/nNjv))。JaCoCo可以配置为在测试期间强制执行某些覆盖率级别，并将输出报告告诉你哪些被覆盖了，哪些没有被覆盖。
- en: 'Enabling JaCoCo requires only adding a plugin to the `<build><plugins>` section
    of your `pom.xml` file. It doesn’t enable itself by default, so you have to tell
    it when it should execute. In this example we’ve bound it to the `test` phase
    like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 启用JaCoCo只需要在`pom.xml`文件的`<build><plugins>`部分添加一个插件。它默认不会启用，所以你必须告诉它何时执行。在这个例子中，我们将其绑定到`test`阶段，如下所示：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ JaCoCo needs to start running early in the process. This adds it to the initialize
    phase.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ JaCoCo需要在过程早期开始运行。这将其添加到初始化阶段。
- en: ❷ Tells JaCoCo to report during the test phase
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 告诉JaCoCo在测试阶段报告
- en: This produces reports on all of your classes in `target/site/jacoco` by default,
    as shown in figure 11.5, with a full HTML version at `index.html` to be explored.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将在`target/site/jacoco`目录中生成关于你所有类的报告，如图11.5所示，完整的HTML版本在`index.html`中供探索。
- en: '![](../Images/CH11_F05_Evans2.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F05_Evans2.png)'
- en: Figure 11.5 JaCoCo coverage report page
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 JaCoCo覆盖率报告页面
- en: 11.2.9 Moving beyond Java 8
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.9 超越Java 8
- en: 'In chapter 1, we noted the following series of modules that belonged with Java
    Enterprise Edition but were present in the core JDK. These were deprecated with
    JDK 9 and removed with JDK 11 but remain available as external libraries:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，我们提到了以下一系列属于Java企业版但存在于核心JDK中的模块。这些模块在JDK 9中被弃用，在JDK 11中被移除，但作为外部库仍然可用：
- en: '`java.activation` (JAF)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.activation` (JAF)'
- en: '`java.corba` (CORBA)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.corba` (CORBA)'
- en: '`java.transaction` (JTA)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.transaction` (JTA)'
- en: '`java.xml.bind` (JAXB)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.bind` (JAXB)'
- en: '`java.xml.ws` (JAX-WS, plus some related technologies)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.ws` (JAX-WS，以及一些相关技术)'
- en: '`java.xml.ws.annotation` (Common Annotations)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.ws.annotation` (通用注解)'
- en: 'If your project relies on any of these modules, your build might break when
    you move to a more recent JDK. Fortunately a few simple dependency additions in
    your `pom.xml`, shown here, address the issue:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目依赖于这些模块中的任何一个，当你迁移到更近期的JDK时，你的构建可能会中断。幸运的是，在`pom.xml`中添加几个简单的依赖项可以解决这个问题，如下所示：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ java.activation (JAF)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `java.activation` (JAF)
- en: ❷ java.corba (CORBA)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `java.corba` (CORBA)
- en: ❸ java.transaction (JTA)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `java.transaction` (JTA)
- en: ❹ java.xml.bind (JAXB)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ `java.xml.bind` (JAXB)
- en: ❺ java.xml.ws (JAX-WS, plus some related technologies)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ `java.xml.ws` (JAX-WS，以及一些相关技术)
- en: ❻ java.xml.ws.annotation (Common Annotations)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ `java.xml.ws.annotation` (通用注解)
- en: 11.2.10 Multirelease JARs in Maven
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.10 Maven中的多版本JAR
- en: A feature that arrived in JDK 9 was the ability to package JARs that target
    different code for different JDKs. This allows us to take advantage of new features
    in the platform, while still supporting clients of our code on older versions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: JDK 9中引入的一个特性是能够打包针对不同JDK的不同代码的JAR文件。这允许我们利用平台的新特性，同时仍然支持我们代码的旧版本客户端。
- en: 'In chapter 2, we examined the feature and hand-crafted the specific JAR format
    necessary to enable this capability. The layout places versioned directories under
    `META-INF/versions` within the JAR where the JVM from 9 onward will check for
    newer versions of a given class during loading, as shown next:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我们检查了特征并手工制作了必要的特定JAR格式，以启用此功能。布局将版本化的目录放置在JAR文件中的`META-INF/versions`下，从JVM
    9开始，在加载过程中将检查给定类的较新版本，如下所示：
- en: '[PRE22]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Within this structure, the classes in `wgjd2ed` will have a class file version
    representing the oldest JVM the JAR may be used with. (In our later example, this
    will be JDK 8.) Classes under `META-INF/versions/11`, though, may be compiled
    with a newer JDK and have a newer class file version. Because older JDKs ignore
    the `META-INF/versions` directory (and those from 9 onward understand what versions
    they’re allowed to use), we can mix newer code in a JAR while still having everything
    work on an older JVM. This is exactly the sort of tedious process that Maven was
    built to automate.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，`wgjd2ed`中的类将有一个表示JAR可能使用的最老JVM的类文件版本。（在我们的后续示例中，这将是在JDK 8。）然而，在`META-INF/versions/11`下的类可以使用较新的JDK进行编译，并具有较新的类文件版本。因为较老的JDK忽略了`META-INF/versions`目录（以及从9开始的JDK理解它们允许使用哪些版本），我们可以在JAR中混合较新的代码，同时仍然在较老的JVM上正常工作。这正是Maven被构建来自动化的繁琐过程。
- en: 'Although the output format in our JAR is all that really matters to enable
    the multirelease feature, we’ll mimic the structure in our code layout for clarity.
    As shown here, the code in `src` is the baseline functionality that will be seen
    by any JDK by default. The code under `versions` optionally replaces specific
    classes with an alternate implementation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的 JAR 中的输出格式对于启用多版本功能至关重要，但我们将模仿代码布局中的结构以提高清晰度。如下所示，`src` 中的代码是任何 JDK 默认将看到的基线功能。`versions`
    下的代码可选地用替代实现替换特定类：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Maven’s defaults will find and compile our code in `src/main`, but we have
    two complications we need to sort out:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 的默认设置将在 `src/main` 中找到并编译我们的代码，但我们有两个需要解决的复杂问题：
- en: Maven needs to *also* find our code in the `versions` directory.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven 还需要 *同样* 在 `versions` 目录中找到我们的代码。
- en: Further, Maven needs to compile that source targeted to a different JDK than
    the main project.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，Maven 需要针对与主项目不同的 JDK 编译该源代码。
- en: Both of these goals can be accomplished by configuring the `maven-compiler-plugin`
    that builds our Java class files. We introduce two separate `<execution>` steps
    in the next code snippet—one to compile the base code targeting JDK 8, and then
    a second pass to compile the versioned code targeting JDK 11.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个目标都可以通过配置构建我们的 Java 类文件的 `maven-compiler-plugin` 来实现。在下一个代码片段中，我们引入了两个单独的
    `<execution>` 步骤——一个用于编译针对 JDK 8 的基本代码，然后是第二个步骤，用于编译针对 JDK 11 的版本化代码。
- en: Note We must compile using a JDK version at least as new as the latest version
    you’re targeting. However, we’ll explicitly instruct some build steps to target
    a lower version than the compiler is capable of.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们必须使用至少与您要针对的最新版本一样新的 JDK 版本进行编译。然而，我们将明确指示一些构建步骤针对比编译器能够处理的更低版本。
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Execution step to compile for JDK 8
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 编译针对 JDK 8 的执行步骤
- en: ❷ We’ll compile with JDK 11, so we target this step’s output to JDK 8.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将使用 JDK 11 进行编译，因此我们将此步骤的输出针对 JDK 8。
- en: ❸ Second execution step for targeting JDK 11
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 针对JDK 11的第二个执行步骤
- en: ❹ Tells Maven about our alternate location for the version-specific code
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 告诉 Maven 关于版本特定代码的替代位置
- en: ❺ Setting release and multiReleaseOutput tells Maven which JDK this versioned
    code is intended for and asks it to put the classes at the correct multirelease
    location in output.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 设置发布和 multiReleaseOutput 告诉 Maven 这个版本化代码打算针对哪个 JDK，并要求它将类放在输出中的正确多版本位置。
- en: 'This gets our JAR built and packaged with the right layout. There’s one more
    step, and that’s marking the manifest as multirelease. This is configured in the
    `maven-jar-plugin`, as shown here, close to where we made our application JAR
    executable in section 11.2.4:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建我们的 JAR 并以正确的布局打包。还有一步，那就是将清单标记为多版本发布。这配置在 `maven-jar-plugin` 中，如下所示，接近我们在第
    11.2.4 节中使应用程序 JAR 可执行的位置：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Attribute to mark the JAR as multirelease
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标记 JAR 为多版本
- en: 'With that we can execute our code against different JDKs and see it behave
    as expected. In the case of our sample app, the base implementation for JDK 8
    will output an additional version message, as illustrated here, so we can see
    it’s working:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们可以针对不同的 JDK 执行我们的代码并查看其行为是否符合预期。在我们的示例应用程序中，针对 JDK 8 的基本实现将输出一个额外的版本信息，如下所示，因此我们可以看到它正在工作：
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The path to using new features in the JDK without abandoning older clients is
    all set!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新 JDK 功能而无需放弃旧客户端的路径已经设置好了！
- en: 11.2.11 Maven and modules
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.11 Maven 和模块
- en: In chapter 2, we examined the JDK’s new module system in detail. Let’s look
    at how it influences our build scripting. We’ll start looking at a simple library
    that exposes one of its packages publicly while hiding the other.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，我们详细研究了 JDK 的新模块系统。让我们看看它如何影响我们的构建脚本。我们将从一个简单的库开始，该库公开其一个包，同时隐藏另一个包。
- en: A modular library
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块化库
- en: 'Modular projects vary slightly in their code layout from the strict Maven standard.
    The `main` directory instead reflects the name of the module, as shown here:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化项目在代码布局上与严格的Maven标准略有不同。`main`目录反映了模块的名称，如下所示：
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Our modular code directory
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的模块化代码目录
- en: ❷ A class we intend to keep private
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们打算保持私有的一个类
- en: ❸ A class we intend to share publicly through our module
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们打算通过我们的模块公开分享的班级
- en: 'Having made that change, we have to inform Maven of this new location to look
    for source code to compile as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 进行了此更改后，我们必须通知 Maven 新的位置以查找要编译的源代码，如下所示：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final piece to making our library modular is the addition of a `module-info.java`
    at the root of our code (alongside the `com` directory). This will name our module,
    and declare what we allow access to, as shown here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的库成为模块化的最后一部分是在我们的代码根目录中添加一个`module-info.java`文件（与`com`目录并列）。这将命名我们的模块，并声明我们允许访问的内容，如下所示：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Everything else about this simple library remains the same, and if we `mvn package`,
    we’ll get a JAR file in `target`. Before we proceed further, we can also put this
    library into the local Maven cache via `mvn install`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的库的其他所有内容都保持不变，如果我们执行`mvn package`，我们将在`target`目录中得到一个JAR文件。在进一步操作之前，我们也可以通过`mvn
    install`将这个库放入本地Maven缓存中。
- en: Note The JDK’s module system is about access control at build and runtime, *not*
    packaging. A modular library can be shared as a plain old JAR file, just with
    the additional `module-info.class` included to tell modular applications how to
    interact with it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：JDK的模块系统是关于构建和运行时的访问控制，*不是*打包。一个模块化库可以作为一个普通的JAR文件共享，只是额外包含`module-info.class`来告诉模块化应用程序如何与之交互。
- en: Now that we have a modular library, let’s build a modular application to consume
    it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模块化库，让我们构建一个模块化应用程序来使用它。
- en: A modular application
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块化应用程序
- en: 'Our modular application gets a similar layout to what we used for the library,
    as shown next:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块化应用程序的布局与我们所用的库类似，如下所示：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our `module-info.java` for the application declares our name, and states that
    we require the package exported by our library as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序的`module-info.java`声明了我们的名称，并声明我们需要的包是由我们的库导出的，如下所示：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This by itself doesn’t tell Maven where to find our library JAR, though, so
    we include it as a normal `<dependency>` like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅此并不能告诉Maven在哪里找到我们的库JAR文件，因此我们将其作为正常的`<dependency>`包含，如下所示：
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Our library from the prior section, installed into the local Maven repository
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们上一节中的库已安装到本地Maven仓库中
- en: When we’re compiling and subsequently running, it’s important that this dependency
    be placed on the module path instead of the classpath. How does Maven accomplish
    this? Fortunately, recent versions of the `maven-compiler-plugin` are smart enough
    to notice that 1) our application has a `module-info.java`, so it’s modular; and
    2) the dependency includes `module-info.class`, so it, too, is a module. As long
    as you are on a recent version of `maven-compiler-plugin` (3.8 worked great at
    the time of writing), Maven figures it out for you.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在编译并随后运行时，将这个依赖项放在模块路径上而不是类路径上是很重要的。Maven是如何完成这个任务的？幸运的是，最近的`maven-compiler-plugin`版本足够智能，能够注意到1)我们的应用程序有一个`module-info.java`，所以它是模块化的；2)
    依赖项包括`module-info.class`，因此它也是一个模块。只要您使用的是`maven-compiler-plugin`的较新版本（在写作时3.8版本表现良好），Maven就会为您解决这个问题。
- en: 'Our application code is perfectly normal Java, and we can use the modular library’s
    functionality as intended, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序代码是完美的Java代码，我们可以按照预期使用模块化库的功能，如下所示：
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ import from the module, just like any other package.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从模块中导入，就像任何其他包一样。
- en: ❷ Uses the class from our module to get a message
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用我们模块中的类来获取消息
- en: 'You may remember that we had another package in our library that we didn’t
    provide access to. What happens if we modify our application to try and pull that
    in, like so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在我们的库中还有一个我们没有提供访问权限的包。如果我们修改我们的应用程序来尝试拉取它，会发生什么，如下所示：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ com.wellgrounded.modlib.hidden was not listed in the library’s exports.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `com.wellgrounded.modlib.hidden`没有被列入库的导出列表中。
- en: 'Compiling this will give us the following error straight away:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 编译这个将会立即给出以下错误：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ javac and the module system won’t even let us try to touch things that aren’t
    exported!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ javac和模块系统甚至不允许我们尝试接触未导出的内容！
- en: Maven’s tooling has come a long way since the release of modules in JDK 9\.
    All the standard scenarios are well covered with a minimum of additional configuration
    required.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 自从JDK 9中模块发布以来，Maven的工具已经取得了很大的进步。所有标准场景都得到了很好的覆盖，并且只需要最少的额外配置。
- en: Before we go, though, let’s take one brief tangent. Throughout this section,
    `module-info.class` was frequently the signal to Maven that it should start applying
    modular rules. But modules are an *opt-in* feature in the JDK to preserve compatibility
    with the vast quantities of premodular code out there.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开之前，让我们稍微偏离一下主题。在整个这一节中，`module-info.class`经常是Maven应该开始应用模块化规则的信号。但是，模块是JDK中的一个*可选*功能，以保持与大量预模块化代码的兼容性。
- en: What happens if we build the same application using our modular library, but
    the application doesn’t mark itself to use modules by including the `module-info.java`
    file? In that case, the library—although it is modular—will be included via the
    classpath. This places it in the unnamed module along with the application’s own
    code, and all those access restrictions we defined in the library are effectively
    ignored. A sample application is included in the supplement alongside the modular
    one that uses our library by classpath so you can see more clearly how opting
    into or out of modules works.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用我们的模块化库构建相同的应用程序，但应用程序没有通过包含`module-info.java`文件来标记自己使用模块，会发生什么？在这种情况下，尽管库是模块化的，但它将通过类路径包含。这会将它放置在未命名的模块中，与应用程序自己的代码一起，并且我们定义在库中的所有访问限制都将被有效地忽略。一个示例应用程序包含在补充材料中，与使用我们的库通过类路径使用的模块化应用程序一起，这样你可以更清楚地看到选择进入或退出模块的工作方式。
- en: With that, our tour of Maven’s default features is done. But what do we do if
    we need to extend the system beyond the admittedly vast array of plugins we can
    find online?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们对Maven默认功能的探索就结束了。但如果我们需要扩展系统，而实际上我们可以在网上找到的插件种类繁多，我们该怎么办呢？
- en: 11.2.12 Authoring Maven plugins
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.12 编写Maven插件
- en: Even the most basic defaults in Maven are supplied as plugins, and there’s no
    reason you can’t write one, too, when we need to do more. As we’ve seen, referencing
    a plugin is a lot like pulling in a dependent library. It isn’t surprising, then,
    that we implement our Maven plugins as separate JAR files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是Maven中最基本的默认设置也是作为插件提供的，而且没有理由我们不能在需要的时候编写一个。正如我们所看到的，引用一个插件与引入一个依赖库非常相似。因此，我们将Maven插件作为单独的JAR文件实现，这并不令人惊讶。
- en: 'For our example, we start with a `pom.xml` file. Much of the boilerplate is
    similar to before with a couple small additions, shown here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们从`pom.xml`文件开始。大部分模板代码与之前相似，只是增加了一些小的修改，如下所示：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Lets Maven know we intend to build a plugin package
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 让Maven知道我们打算构建一个插件包
- en: ❷ -SNAPSHOT is a typical suffix added to not-yet-released versions of a library.
    This shows up when pulling in the library because you must specify the full string
    1.0-SNAPSHOT, for example, when asking for the dependency.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `-SNAPSHOT`是添加到尚未发布的库版本的一个典型后缀。当你引入库时，这会显示出来，因为你必须指定完整的字符串，例如，当请求依赖项时，必须指定1.0-SNAPSHOT。
- en: ❸ Maven API dependencies our implementation will need
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们实现所需的大纲Maven API依赖项
- en: 'That gets us set to start adding code. Placing a Java file in the standard
    layout location, we implement what is called a `Mojo`—effectively a Maven *goal*,
    as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们准备好开始添加代码。将Java文件放置在标准布局位置，我们实现了一个称为`Mojo`的东西——实际上是一个Maven *目标*，如下所示：
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Our class extends `AbstractMojo` and tells Maven via the `@Mojo` annotation
    what our goal name is. The body of the method takes care of whatever job we want.
    In this case, we simply log some text, but you have the full Java language and
    ecosystem available at this point to implement your goal.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类扩展了`AbstractMojo`，并通过`@Mojo`注解告诉Maven我们的目标名称。方法体负责我们想要的任何工作。在这种情况下，我们只是记录一些文本，但此时你拥有完整的Java语言和生态系统来实施你的目标。
- en: 'To test the plugin in another project, we need to `mvn install` it, which will
    place our JAR into the local caching repository. Once there, we can pull our plugin
    into another project just like all the other “real” plugins we’ve seen already
    in this chapter, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要在另一个项目中测试插件，我们需要执行`mvn install`，这将把我们的JAR文件放入本地缓存库。一旦在那里，我们就可以像本章中已经看到的所有其他“真实”插件一样，将我们的插件拉入另一个项目，如下所示：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ References to our plugin coordinates by groupId and artifactId
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过groupId和artifactId引用我们的插件坐标
- en: ❷ Binds our goal to the compile phase
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将我们的目标绑定到编译阶段
- en: 'With this in place, we can see our plugin in action when we compile, as shown
    here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以在编译时看到我们的插件在行动，如下所示：
- en: '[PRE39]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Our plugin running as part of the compile phase
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们插件作为编译阶段的一部分运行
- en: It’s worth noting that if we simply include the plugin without the `<executions>`
    element, we won’t see our plugin show up anywhere in our project. Custom plugins
    must declare their desired phase in the lifecycle via the `pom.xml` file.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果我们只是包含插件而没有`<executions>`元素，我们不会在我们的项目中看到我们的插件出现在任何地方。自定义插件必须通过`pom.xml`文件在生命周期中声明它们希望的阶段。
- en: Visibility into the lifecycle and what goals are bound to what phases can be
    difficult, but fortunately there’s a plugin to help with that. `buildplan-maven-plugin`
    brings clarity to your current tasks.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 了解生命周期以及哪些目标绑定到哪些阶段可能会很困难，但幸运的是，有一个插件可以帮助我们。`buildplan-maven-plugin`为你的当前任务提供了清晰度。
- en: 'Although it can be included in a `pom.xml` like any other plugin, a useful
    alternative to avoid repetition is putting it in your user’s `~/.m2/settings.xml`
    file, as shown next. `settings.xml` files are similar to `pom.xml` files in Maven,
    but they are not associated to any specific project:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它像任何其他插件一样可以包含在`pom.xml`中，但为了避免重复，一个有用的替代方案是将它放入用户自己的`~/.m2/settings.xml`文件中，如下所示。`settings.xml`文件与Maven中的`pom.xml`文件类似，但它们与任何特定项目无关：
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once there, you can invoke it in any project building with Maven like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，你就可以像这样在任何使用Maven构建的项目中调用它：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note If you don’t want to add a plugin to your `pom.xml` *or* your `settings.xml`,
    you can just ask Maven to a run a command using the fully qualified plugin name!
    In our previous example, we can just say `mvn fr.jcgay.maven .plugins:buildplan-maven-plugin:list`
    and Maven will download the plugin and run it once. This is great for uncommon
    tasks or experimentation. Maven’s documentation for authoring plugins (see [http://mng.bz/v6dx](http://mng.bz/v6dx))
    is thorough and well maintained, so do take a look when starting to implement
    your own plugins.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你不想在`pom.xml`或`settings.xml`中添加插件，你可以直接使用完全限定的插件名称来请求Maven运行命令！在我们的上一个例子中，我们可以说`mvn
    fr.jcgay.maven .plugins:buildplan-maven-plugin:list`，Maven将下载插件并运行它一次。这对于不常见的任务或实验来说非常棒。Maven关于编写插件的文档（见[http://mng.bz/v6dx](http://mng.bz/v6dx)）非常详尽且维护良好，所以当你开始实现自己的插件时，请务必查看。
- en: Maven remains among the most common build tools for Java and has been hugely
    influential. However, not everyone loves its strongly opinionated stance. Gradle
    is the most popular alternative, so let’s see how it tackles the same problem
    space.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Maven仍然是Java中最常见的构建工具之一，并且具有巨大的影响力。然而，并不是每个人都喜欢它的强烈立场。Gradle是最受欢迎的替代方案，让我们看看它是如何处理相同的问题空间的。
- en: 11.3 Gradle
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 Gradle
- en: Gradle came onto the scene after Maven and is compatible with much of the dependency
    management infrastructure Maven pioneered. It supports the familiar standard directory
    layout and provides a default build lifecycle for JVM projects, but unlike Maven,
    all of these features are fully customizable.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle在Maven之后出现，与Maven开创的许多依赖管理基础设施兼容。它支持熟悉的标准目录布局，并为JVM项目提供默认的构建生命周期，但与Maven不同，所有这些功能都是完全可定制的。
- en: Instead of XML, Gradle uses a declarative domain-specific language (DSL) on
    top of an actual programming language (either Kotlin or Groovy). This typically
    results in concise build logic for simple cases and a lot of flexibility when
    things get more complex.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 与XML不同，Gradle在Kotlin或Groovy等实际编程语言之上使用声明性的领域特定语言（DSL）。这通常会导致简单情况下的简洁构建逻辑，并在事情变得更加复杂时提供很多灵活性。
- en: Gradle also includes a number of performance features for avoiding unnecessary
    work and processing tasks incrementally. This often provides faster builds and
    higher scalability. Let’s get our feet wet by seeing how to run Gradle commands.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle还包括一些性能特性，用于避免不必要的操作并增量处理任务。这通常提供了更快的构建和更高的可伸缩性。让我们通过查看如何运行Gradle命令来试试水。
- en: 11.3.1 Installing Gradle
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 安装Gradle
- en: 'Gradle can be installed from its website ([https://gradle.org/install](https://gradle.org/install)).
    Recent versions rely on having only JVM version 8 or greater. Once installed,
    you can run it at the command line, and it will default to displaying help, as
    shown here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle可以从其网站([https://gradle.org/install](https://gradle.org/install))安装。最新版本依赖于JVM版本8或更高。一旦安装，你可以在命令行中运行它，默认情况下会显示帮助，如下所示：
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This makes it easy to get started, but having a single global Gradle version
    isn’t ideal. It is common for a developer to build multiple different projects
    that could each have different versions of Gradle.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得开始变得容易，但只有一个全局Gradle版本并不理想。对于开发者来说，构建多个不同项目是很常见的，每个项目可能需要不同版本的Gradle。
- en: To handle this, Gradle introduces the idea of a *wrapper*. The `gradle wrapper`
    task will capture a specific version of Gradle locally into your project. This
    is then accessed via the `./gradlew` or `gradlew.bat` commands. It’s considered
    good practice to use the `gradlew` wrappers to avoid version incompatibilities
    so you may find yourself rarely actually running `gradle` itself directly.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，Gradle引入了*包装器*的概念。`gradle wrapper`任务将捕获Gradle的特定版本并本地化到你的项目中。然后可以通过`./gradlew`或`gradlew.bat`命令访问它。使用`gradlew`包装器被认为是一种良好的实践，以避免版本不兼容，因此你可能很少直接运行`gradle`。
- en: Note It’s recommended that you include the `gradle` and `gradlew*` results of
    the wrapper in source control but exclude the local caching of `.gradle`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 建议您将包装器的 `gradle` 和 `gradlew*` 结果包含在源代码控制中，但排除 `.gradle` 的本地缓存。
- en: With the wrappers committed, anyone downloading your project gets the properly
    versioned build tooling without any additional installs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交了包装器之后，任何下载您的项目的人都可以获得正确版本化的构建工具，而无需进行任何额外的安装。
- en: 11.3.2 Tasks
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 任务
- en: Gradle’s key concept is the *task*. A task defines a piece of work that can
    be invoked. Tasks can depend on other tasks, be configured via scripting, and
    added through Gradle’s plugin system. These resemble Maven’s goals but are conceptually
    more like functions. They have well-defined inputs and outputs and can be composed
    and chained. Whereas Maven goals must be associated to a given phase of the build
    life-cycle, Gradle tasks may be invoked and used in whatever fashion is convenient
    for you.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 的关键概念是 *任务*。任务定义了一项可以调用的工作。任务可以依赖于其他任务，可以通过脚本进行配置，并通过 Gradle 的插件系统添加。这些类似于
    Maven 的目标，但在概念上更像函数。它们有明确定义的输入和输出，可以组合和链接。而 Maven 的目标必须与构建生命周期的某个特定阶段相关联，Gradle
    的任务可以以您方便的方式调用和使用。
- en: 'Gradle provides excellent introspection features. Key among these is the `./gradlew
    tasks` meta-task, which lists currently available tasks in your project. Before
    you’ve even declared anything, running `tasks` will present the following task
    list:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 提供了出色的内省功能。其中最重要的是 `./gradlew tasks` 元任务，它列出了项目中当前可用的任务。在您声明任何内容之前，运行
    `tasks` 将显示以下任务列表：
- en: '[PRE43]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Providing the `--dry-run` flag to any task will display the tasks Gradle would
    have run, without performing the actions. This is useful for understanding the
    flow of your build system or debugging misbehaving plugins or custom tasks.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 向任何任务提供 `--dry-run` 标志将显示 Gradle 将要运行的任务，而不会执行这些操作。这对于理解您的构建系统流程或调试行为异常的插件或自定义任务非常有用。
- en: 11.3.3 What’s in a script?
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.3 脚本中有什么？
- en: The heart of a Gradle build is its *buildscript*. This is a key difference between
    Gradle and Maven—not only is the format different but the entire philosophy is
    different, too. Maven POM files are XML-based, whereas in Gradle, the buildscript
    is an executable script written in a programming language—what’s often referred
    to as a *domain-specific language* or DSL. Modern versions of Gradle support both
    Groovy and Kotlin.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 构建的核心是其 *构建脚本*。这是 Gradle 与 Maven 之间的一个关键区别——不仅格式不同，整个哲学也不同。Maven POM
    文件是基于 XML 的，而在 Gradle 中，构建脚本是用编程语言编写的可执行脚本——通常被称为 *领域特定语言* 或 DSL。Gradle 的现代版本支持
    Groovy 和 Kotlin。
- en: Groovy vs. Kotlin
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 与 Kotlin 的比较
- en: 'Gradle’s DSL approach started out with Groovy. As we learned when we met it
    briefly in chapter 8, Groovy is a dynamic language on the JVM, and it fits nicely
    with the goal of flexibility and concise build scripting. Since Gradle 5.0, however,
    another option has been available: Kotlin, which we covered in detail in chapter
    9.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 的 DSL 方法最初是基于 Groovy 的。正如我们在第 8 章简要介绍时所了解到的，Groovy 是 JVM 上的动态语言，并且它与灵活性和简洁的构建脚本目标非常契合。然而，自
    Gradle 5.0 以来，另一个选项也已可用：Kotlin，我们在第 9 章中对其进行了详细讨论。
- en: Note Kotlin buildscripts use the extension `.gradle.kts` instead of `.gradle`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Kotlin 构建脚本使用扩展名 `.gradle.kts` 而不是 `.gradle`。
- en: This makes a lot of sense because Kotlin is now the dominant language for Android
    development, where Gradle is the platform’s official build tool. Sharing the same
    language across all parts of your project can be a great simplifying factor.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有意义，因为 Kotlin 现在是 Android 开发的主导语言，而 Gradle 是该平台的官方构建工具。在整个项目的各个部分使用相同的语言可以是一个很好的简化因素。
- en: For our purposes, Kotlin is also more like Java than Groovy. Narrowing this
    language gap means that if you’re new to the Gradle ecosystem, it might make sense
    to write your buildscript with Kotlin if you are coding in Java.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的而言，Kotlin 更像 Java 而不是 Groovy。缩小这种语言差距意味着，如果您是 Gradle 生态系统的初学者，如果您正在用
    Java 编码，那么使用 Kotlin 编写构建脚本可能是有意义的。
- en: Groovy remains a prominent and very viable option, but we’re going to double
    down on our Kotlin experience and use it for all of our following examples. Anything
    we show in this chapter can be expressed similarly in a Groovy buildscript with
    identical Gradle behavior. The Gradle documentation shows both DSL for all its
    examples.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 仍然是一个突出且非常有前景的选择，但我们将加大 Kotlin 经验的投入，并使用它来展示我们接下来的所有示例。我们在这个章节中展示的任何内容都可以用具有相同
    Gradle 行为的 Groovy 构建脚本以类似的方式表达。Gradle 文档展示了所有示例的 DSL。
- en: 11.3.4 Using plugins
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.4 使用插件
- en: Gradle uses plugins to define everything about the tasks we use. As we saw earlier,
    listing tasks in a blank Gradle project doesn’t say anything about building, testing,
    or deploying. All of that comes from plugins.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle使用插件来定义我们使用的所有任务。正如我们之前看到的，在空Gradle项目中列出任务不会说明构建、测试或部署。所有这些都来自插件。
- en: 'Numerous plugins ship with Gradle itself, so using them requires only a declaration
    in your `build.gradle.kts`. A key one is the `base` plugin, shown here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle本身附带了许多插件，因此使用它们只需要在`build.gradle.kts`中进行声明。其中一个关键插件是`base`插件，如下所示：
- en: '[PRE44]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A look at our tasks after including the `base` plugin reveals some common build
    life-cycle tasks that we might expect, as shown next:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含`base`插件后查看我们的任务，可以揭示一些我们可能期望的常见构建生命周期任务，如下所示：
- en: '[PRE45]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With that in place, let’s get building a Gradle project for our code.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们开始构建我们的Gradle项目。
- en: 11.3.5 Building
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.5 构建
- en: Although Gradle allows for customization to your heart’s content, it defaults
    to expecting the same code layout that Maven established and popularized. For
    many (perhaps even most) projects, it doesn’t make sense to change this layout,
    although it is possible to do so.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Gradle允许你随心所欲地进行自定义，但它默认期望与Maven建立和普及的相同代码布局。对于许多（也许甚至大多数）项目来说，改变这种布局没有意义，尽管这样做是可能的。
- en: 'Let’s start with a basic Java library. To do this, we create the following
    source tree:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的Java库开始。为此，我们创建以下源代码树：
- en: '[PRE46]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ These files were automatically created by the Gradle wrapper command.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这些文件是由Gradle包装命令自动创建的。
- en: 'The `base` plugin doesn’t know anything about Java, so we need a plugin with
    more awareness. For our use case of a plain Java JAR, we’ll use Gradle’s `java-library`
    plugin, shown next. This plugin builds on all the necessary parts from `base`—in
    practice, you’ll rarely see the `base` plugin alone in a Gradle build. That’s
    because plugins can apply other plugins to build off of them, like composition
    in object-oriented programming:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`base`插件对Java一无所知，因此我们需要一个更了解Java的插件。对于我们的纯Java JAR用例，我们将使用Gradle的`java-library`插件，如下所示。此插件基于`base`的所有必要部分构建——在实践中，你很少在Gradle构建中看到单独的`base`插件。这是因为插件可以应用其他插件来构建在其之上，就像面向对象编程中的组合一样：'
- en: '[PRE47]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Backticks (not apostrophes) are used around plugin names when they include
    special characters such as - here.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在插件名称周围使用反引号（不是撇号），当它们包含特殊字符时，例如这里。
- en: 'This yields a growing set of tasks in our build section, as shown here:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的构建部分生成越来越多的任务，如下所示：
- en: '[PRE48]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In Gradle’s terminology, `assemble` is the task that will compile and package
    up a JAR file. A dry run shows all of the steps, some of which the default tasks
    list doesn’t show:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle术语中，`assemble`是编译并打包JAR文件的任务。一个干燥运行会显示所有步骤，其中一些默认任务列表没有显示：
- en: '[PRE49]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Running `./gradlew assemble` generates output in the `build` directory as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`./gradlew assemble`会在`build`目录生成以下输出：
- en: '[PRE50]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Making an application
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 制作应用程序
- en: A plain JAR is a good start, but eventually you want to run an application.
    This takes more configuration, but again the pieces are available by default.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 纯JAR是一个好的开始，但最终你想要运行一个应用程序。这需要更多的配置，但默认情况下这些组件都是可用的。
- en: 'We’ll change up our plugins and tell Gradle what the main class is for our
    application. We also can see several of the nice features that Kotlin brings in
    just this brief snippet:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改插件，并告诉Gradle我们的应用程序的主类是什么。我们还可以看到Kotlin在这个简短的片段中带来的几个优秀特性：
- en: '[PRE51]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Kotlin’s optional parentheses when the final argument is a lambda
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Kotlin在最终参数是lambda表达式时可选的括号
- en: ❷ Plugin that knows how to compile and run a Java app
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 知道如何编译和运行Java应用的插件
- en: ❸ Task for assembling a JAR with a modified manifest
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 组装修改后的清单的JAR文件的任务
- en: ❹ Kotlin uses to syntax to declare a hash map in place (aka a hash literal).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Kotlin使用to语法在原地声明一个哈希映射（也称为哈希字面量）。
- en: Building with `./gradlew build` gets us the same JAR output as before, but if
    we execute `java -jar build/libs/wellgrounded.jar`, our test program will run.
    Alternatively, the `application` plugin also supports `./gradlew run` to directly
    load and execute your main class for you.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`./gradlew build`构建会得到与之前相同的JAR输出，但如果我们执行`java -jar build/libs/wellgrounded.jar`，我们的测试程序将会运行。或者，`application`插件也支持`./gradlew
    run`来直接加载并执行你的主类。
- en: Note The `application` plugin requires only that `mainClass` be set, but excluding
    the `tasks.jar` configuration will yield a JAR that `./gradlew run` knows how
    to start but `java -jar` doesn’t. Definitely not recommended!
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`application` 插件只需要设置 `mainClass`，但排除 `tasks.jar` 配置将导致一个 `./gradlew run`
    能够启动但 `java -jar` 无法启动的 JAR 文件。绝对不推荐这样做！
- en: 'We now have the pieces we need to examine another key feature of Gradle: its
    ability to avoid work and reduce our build times.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了检查 Gradle 另一个关键功能的必要组件：它避免工作并减少我们的构建时间的能力。
- en: 11.3.6 Work avoidance
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.6 避免工作
- en: To run builds as fast as possible, Gradle tries to avoid repeating unnecessary
    work. One strategy for this is incremental build. Every task in Gradle declares
    its inputs and outputs. Gradle uses this information to check whether anything
    has changed since the last time the build ran. If there is no change, Gradle skips
    the task and reuses its outputs from the previous build.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能快地运行构建，Gradle 尝试避免重复不必要的操作。为此，一种策略是增量构建。Gradle 中的每个任务都声明其输入和输出。Gradle 使用这些信息来检查自上次构建运行以来是否有任何变化。如果没有变化，Gradle
    将跳过该任务并重用之前构建的输出。
- en: Note You shouldn’t regularly run `clean` when using Gradle, because Gradle will
    ensure that the necessary—and only the necessary—work is done to produce the build
    results.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在使用 Gradle 时，您不应该定期运行 `clean`，因为 Gradle 将确保只完成必要的——并且仅是必要的工作来生成构建结果。
- en: 'We can see this with our application build by taking a look at the build times
    after one full run (forced clean) and a second run, shown here:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看一次完整运行（强制清洁）和第二次运行（如下所示）后的构建时间来看到这一点：
- en: '[PRE52]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Incremental build can only reuse outputs from the last execution of a task
    in the same location on this computer. Gradle does even better: the Build Cache
    allows reusing task outputs from any earlier build—or even a build run elsewhere.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 增量构建只能重用同一台计算机上同一位置的任务的最后一次执行的输出。Gradle 做得更好：构建缓存允许重用任何先前构建的任务输出——甚至是从其他地方运行的构建。
- en: 'This feature can be enabled in your project via a property with the `--build-cache`
    command-line flag. We can see that even the following `clean` build is faster
    because it can reuse cached outputs from the prior execution:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过带有 `--build-cache` 命令行标志的属性在项目中启用此功能。我们可以看到，即使是下面的 `clean` 构建也更快，因为它可以重用先前执行中的缓存输出：
- en: '[PRE53]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Performance is a key feature of Gradle in keeping your project build times down
    even as the size of your code grows. Other abilities exist that we won’t have
    time to cover, such as incremental Java compilation, the Gradle Daemon, and parallel
    task and test execution.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 性能是 Gradle 的一个关键特性，它可以帮助您在代码规模扩大的同时保持项目构建时间的低效。其他一些我们不会涉及的能力包括增量 Java 编译、Gradle
    守护进程以及并行任务和测试执行。
- en: No person is an island. Similarly, few applications get far without pulling
    in other library dependencies. This is a major subject in Gradle and a point of
    considerable difference from Maven.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人是一座孤岛。同样，很少有应用程序在没有引入其他库依赖项的情况下能走得很远。这是 Gradle 的一个主要主题，也是与 Maven 有相当差异的一个点。
- en: 11.3.7 Dependencies in Gradle
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.7 Gradle 中的依赖项
- en: 'To start introducing dependencies, we must first tell Gradle which repositories
    it can download from. There are built-in functions for `mavenCentral` (shown next)
    and `google`. You can use more detailed APIs to configure other repositories,
    including your own private instances:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始引入依赖项，我们必须首先告诉 Gradle 它可以从哪些仓库下载。对于 `mavenCentral`（如下所示）和 `google` 有内置函数。您可以使用更详细的
    API 来配置其他仓库，包括您自己的私有实例：
- en: '[PRE54]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can then introduce our dependencies via the standard coordinate format popularized
    by Maven. Much like Maven had the `<scope>` element to control where a given dependency
    was used, Gradle expresses this through *dependency configurations*. Each configuration
    tracks a particular set of dependencies. Your plugins define which configurations
    are available, and you add to a configuration’s list with a function call. For
    example, to pull the SLF4J library ([http://www.slf4j.org/](http://www.slf4j.org/))
    to help with logging, we’d use the following configurations:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 Maven 流行的标准坐标格式来引入我们的依赖项。与 Maven 有 `<scope>` 元素来控制给定依赖项的使用位置类似，Gradle
    通过 *依赖配置* 来表达这一点。每个配置跟踪一组特定的依赖项。您的插件定义了哪些配置可用，您可以通过函数调用向配置列表中添加。例如，为了拉取 SLF4J
    库 ([http://www.slf4j.org/](http://www.slf4j.org/)) 以帮助进行日志记录，我们会使用以下配置：
- en: '[PRE55]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this example, our code directly calls classes and methods in `slf4j-api`,
    so it is included via the `implementation` configuration. This makes it available
    during compilation and running the application. Our application should never directly
    call methods in `slf4j-simple`, though—that’s done strictly through the `slf4j-api`—so
    requesting `slf4j-simple` as `runtimeOnly` ensures that code isn’t available during
    compilation, preventing us from misusing the library. This achieves the same purpose
    as the `<scope>` element with dependencies in Maven.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们的代码直接调用 `slf4j-api` 中的类和方法，因此它通过 `implementation` 配置被包含进来。这使得它在编译和运行应用程序时可用。尽管如此，我们的应用程序绝不应该直接调用
    `slf4j-simple` 中的方法——这是严格通过 `slf4j-api` 来做的——因此请求 `slf4j-simple` 作为 `runtimeOnly`
    确保代码在编译期间不可用，从而防止我们误用库。这实现了与 Maven 中依赖项的 `<scope>` 元素相同的目的。
- en: 'The distinction between dependencies we use directly and those just needed
    in our classpath at runtime isn’t the only way to distinguish differences between
    dependencies. For library authors in particular, there is also a distinction between
    libraries that we use and those that are part of our public API. If a dependency
    is part of the public API of a project, we can mark it with `api`. In the following
    example, we’re declaring that Guava is part of the public API of our project:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的依赖项与我们类路径在运行时仅需要的依赖项之间的区别并不是区分依赖项差异的唯一方式。特别是对于库的作者来说，我们使用的库和作为我们公共 API
    部分的库之间也有区别。如果一个依赖项是项目公共 API 的一部分，我们可以用 `api` 来标记它。在以下示例中，我们声明 Guava 是我们项目公共 API
    的一部分：
- en: '[PRE56]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Configurations can extend one another, much like deriving from a base class.
    Gradle applies this feature in many areas. For example when creating classpaths,
    Gradle uses a `compileClasspath` and `runtimeClassPath`, which extends `implementation`
    and `runtimeOnly`. You aren’t meant to directly add to the `*Classpath` configurations—the
    dependencies we add to their base configurations build up the resulting classpath
    configuration, as shown in figure 11.6.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可以相互扩展，就像从基类派生一样。Gradle 在许多领域应用了这一特性。例如，在创建类路径时，Gradle 使用 `compileClasspath`
    和 `runtimeClassPath`，它们扩展了 `implementation` 和 `runtimeOnly`。你不应该直接向 `*Classpath`
    配置添加内容——我们添加到其基配置的依赖项将构建结果类路径配置，如图 11.6 所示。
- en: '![](../Images/CH11_F06_Evans2.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F06_Evans2.png)'
- en: Figure 11.6 Hierarchy of Gradle configurations
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 Gradle 配置层次结构
- en: Table 11.1 shows some primary configurations available when using the Java plugin
    that ships with Gradle, along with an indication of what other configurations
    each extends from. A full list is available in the Java plugin documentation at
    [http://mng.bz/445B](http://mng.bz/445B).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 展示了在使用 Gradle 伴随的 Java 插件时可用的一些主要配置，以及每个配置扩展了哪些其他配置。完整的列表可在 Java 插件文档中找到，网址为
    [http://mng.bz/445B](http://mng.bz/445B)。
- en: Note Version 7 of Gradle removed a number of long-standing deprecated configurations,
    for instance, `compile` and `runtime`. If you’re reading around the internet,
    you may still find reference to these but should move to the newer options, `implementation`
    (or `api`) and `runtimeOnly`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Gradle 7.0 版本移除了一些长期废弃的配置，例如 `compile` 和 `runtime`。如果你在网上浏览，可能会找到对这些配置的引用，但应转向较新的选项，即
    `implementation`（或 `api`）和 `runtimeOnly`。
- en: Table 11.1 Typical Gradle dependency configurations
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1 典型的 Gradle 依赖项配置
- en: '| Name | Purpose | Extends |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 目的 | 扩展 |'
- en: '| --- | --- | --- |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `api` | Primary dependencies that are part of the project’s external, public
    API |  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `api` | 作为项目外部公共 API 部分的依赖项 |  |'
- en: '| `implementation` | Primary dependencies used during compiling and running
    |  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `implementation` | 编译和运行期间使用的主要依赖项 |  |'
- en: '| `compileOnly` | Dependencies needed only during compilation |  |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `compileOnly` | 仅在编译期间需要的依赖项 |  |'
- en: '| `compileClasspath` | Configuration Gradle uses to look up compilation classpath
    | `compileOnly`, `implementation` |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `compileClasspath` | Gradle 用于查找编译类路径的配置 | `compileOnly`, `implementation`
    |'
- en: '| `runtimeOnly` | Dependencies needed only during runtime |  |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `runtimeOnly` | 仅在运行时需要的依赖项 |  |'
- en: '| `runtimeClasspath` | Configuration Gradle uses to look up runtime classpath
    | `runtimeOnly`, `implementation` |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| `runtimeClasspath` | Gradle 用于查找运行时类路径的配置 | `runtimeOnly`, `implementation`
    |'
- en: '| `testImplementation` | Dependencies used during compiling and running tests
    | `implementation` |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| `testImplementation` | 编译和运行测试期间使用的依赖项 | `implementation` |'
- en: '| `testCompileOnly` | Dependencies needed only during compilation of tests
    |  |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `testCompileOnly` | 仅在测试编译期间需要的依赖项 |  |'
- en: '| `testCompileClasspath` | Configuration Gradle uses to look up test compilation
    classpath | `testCompileOnly`, `testImplementation` |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `testCompileClasspath` | Gradle用于查找测试编译类路径的配置 | `testCompileOnly`, `testImplementation`
    |'
- en: '| `testRuntimeOnly` | Dependencies needed only during runtime | `runtimeOnly`
    |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `testRuntimeOnly` | 仅在运行时需要的依赖项 | `runtimeOnly` |'
- en: '| `testRuntimeClasspath` | Configuration Gradle uses to look up test runtime
    classpath | `testRuntimeOnly`, `testImplementation` |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `testRuntimeClasspath` | Gradle用于查找测试运行时类路径的配置 | `testRuntimeOnly`, `testImplementation`
    |'
- en: '| `archives` | List of output JARs from our project |  |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `archives` | 我们项目输出的JAR列表 |  |'
- en: Like Maven, Gradle uses the package information to create a transitive dependency
    tree. However, Gradle’s default algorithm for handling version conflicts differs
    from Maven’s “closest-to-the-root-wins” approach. When resolving, Gradle walks
    the full dependency tree to determine all the requested versions for any given
    package. From the full set of requested versions, Gradle will then default to
    the *highest* available version.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 与Maven一样，Gradle使用包信息来创建传递依赖树。然而，Gradle处理版本冲突的默认算法与Maven的“最接近根的获胜”方法不同。在解析时，Gradle会遍历整个依赖树以确定任何给定包的所有请求版本。从请求版本的完整集合中，Gradle将默认选择可用的*最高*版本。
- en: This approach avoids some unexpected behavior in Maven’s approach—for instance,
    changes in the ordering/depth of packages could result in different resolution.
    Gradle can also use additional information such as rich version constraints to
    customize the resolution process. Even further, if Gradle can’t satisfy the defined
    constraints, it will fail the build with a clear message rather than choose a
    version that may be problematic.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法避免了Maven方法中的一些意外行为——例如，包的顺序/深度的变化可能会导致不同的解析。Gradle还可以使用额外的信息，如丰富的版本约束来定制解析过程。更进一步，如果Gradle无法满足定义的约束，它将使用清晰的错误信息来失败构建，而不是选择可能存在问题的版本。
- en: 'Given this, Gradle provides rich APIs to override and control its resolution
    behavior. It also has solid introspecting tools built in to pull back the curtains
    when something goes wrong. A key command when transitive dependency problems rear
    their ugly head is `./gradlew dependencies`, shown here:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Gradle提供了丰富的API来覆盖和控制其解析行为。它还内置了强大的内省工具，当出现问题时会揭开面纱。当传递依赖问题出现时，一个关键的命令是`./gradlew
    dependencies`，如下所示：
- en: '[PRE57]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In a large project, this output can be overwhelming, so `dependencyInsight`
    lets you focus on the specific dependency you care about like this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型项目中，此输出可能令人不知所措，因此`dependencyInsight`允许你关注你关心的特定依赖项，如下所示：
- en: '[PRE58]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Dependency conflicts can be hard to resolve. The best approach, if possible,
    is to use the dependency tools in Gradle to find mismatches and upgrade to mutually
    compatible versions. Ah, to live in a world where that were always possible!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖冲突可能难以解决。如果可能的话，最佳方法是使用Gradle中的依赖工具来查找不匹配并升级到相互兼容的版本。啊，要是能生活在一个这样的世界里，那该多好啊！
- en: Let’s revisit the example we had previously where two versions of an internal
    helper library were bringing in `assertj` at incompatible major versions. In that
    case, `first-test-helper` was dependent on `assertj-core` 3.21.0, whereas `second-test-helper`
    wanted 2.9.1.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前提到的例子，其中两个版本的内部辅助库引入了不兼容的主版本号的`assertj`。在这种情况下，`first-test-helper`依赖于`assertj-core`
    3.21.0，而`second-test-helper`想要2.9.1。
- en: 'Gradle’s `constraints` provides a mechanism to inform the resolution process
    how we’d like it to choose versions, as shown here:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的`constraints`提供了一种机制，告诉解析过程我们希望如何选择版本，如下所示：
- en: '[PRE59]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ All dependencies just ask for what they want as before.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有依赖项仍然像以前一样请求它们想要的。
- en: ❷ Gradle will respect this constraint or fail the resolution.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Gradle将尊重此约束或失败解析。
- en: ❸ It’s good practice to use because for documenting why we’re intervening because
    Gradle’s tooling can use that text, versus comments in the script, which are useful
    only to human readers.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用这种做法是良好的实践，因为它可以记录我们干预的原因，Gradle的工具可以使用这些文本，而脚本中的注释仅对人类读者有用。
- en: 'If you really need to get precise, you can set a version using `strictly`,
    which will override any other resolution, as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要精确，可以使用`strictly`设置版本，这将覆盖任何其他解析，如下所示：
- en: '[PRE60]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ All dependencies just ask for what they want as before.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有依赖项仍然像以前一样请求它们想要的。
- en: ❷ Forces version 3.1.0\. This won’t match 3.1 or any other related version.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 强制版本为3.1.0。这不会匹配3.1或任何其他相关版本。
- en: 'If these mechanisms aren’t enough or a library simply has an error in its listed
    dependencies, you can also ask Gradle to just ignore a given group or artifact
    via `exclude` as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些机制不够或者一个库在其列出的依赖项中存在错误，你也可以要求Gradle通过`exclude`忽略特定的组或工件，如下所示：
- en: '[PRE61]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ Dependency from first-test-helper will be chosen.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将选择来自first-test-helper的依赖项。
- en: ❷ Gradle will ignore the org.assertj dependencies from the second helper.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Gradle将忽略第二个辅助工具中的org.assertj依赖。
- en: This is a more drastic option, though, and as written here applies only to the
    dependency that we apply the `exclude` to. If we can find a solution using `constraints`,
    we’ll be better off in the long run.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更激进的选项，但在这里所写的内容仅适用于我们应用了`exclude`的依赖项。如果我们能找到一个使用`constraints`的解决方案，从长远来看我们会更好。
- en: As we’ve mentioned in prior sections, manually forcing dependency versions is
    a last resort and deserves special attention to ensure you aren’t getting runtime
    exceptions. A robust test suite can be critical to save time when ensuring your
    mix of libraries works together smoothly.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前章节中提到的，手动强制依赖版本是一个最后的手段，并且需要特别注意以确保不会出现运行时异常。一个健壮的测试套件在确保你的库组合能够顺利协同工作时可以非常关键。
- en: 11.3.8 Adding Kotlin
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.8 添加 Kotlin
- en: As we’ve discussed in both chapter 8 and the Maven section of this chapter,
    the ability to add another language to a project is a huge benefit of running
    on the JVM.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第8章和本章的Maven部分所讨论的，能够在项目中添加另一种语言是一个在JVM上运行的大好处。
- en: 'Adding Kotlin shows off the benefits of Gradle’s scripted approach over Maven’s
    more static XML-based configuration. Following the standard multilingual layout
    from our original code yields this:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 添加Kotlin展示了Gradle脚本方法相对于Maven更静态的基于XML配置的优势。遵循我们原始代码的标准多语言布局产生以下结果：
- en: '[PRE62]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ❶ Our additional Kotlin code appears under the kotlin subdirectories.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们额外的Kotlin代码位于kotlin子目录下。
- en: 'We enable Kotlin support via a Gradle plugin in our `build.gradle.kts` like
    this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`build.gradle.kts`中添加Gradle插件来启用Kotlin支持，如下所示：
- en: '[PRE63]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And that’s it. Because of Gradle’s flexibility, the plugin is able to alter
    the build order and add the necessary `kotlin-stdlib` dependencies without us
    having to take additional steps.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。由于Gradle的灵活性，插件能够改变构建顺序并添加必要的`kotlin-stdlib`依赖，而无需我们采取额外的步骤。
- en: 11.3.9 Testing
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.9 测试
- en: 'The `assemble` task we first discussed will compile and package your main code,
    but we need to compile and run our tests as well. The `build` task is configured
    by default for just that, as shown here:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的`assemble`任务将编译和打包你的主代码，但我们需要编译和运行测试。默认情况下，`build`任务就是为此配置的，如下所示：
- en: '[PRE64]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We’ll add a test case using the standard locations as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用标准位置添加一个测试用例，如下所示：
- en: '[PRE65]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next up, we need to add our test framework to the right dependency configuration
    to make it available to our code. We also let Gradle know that it should use JUnit
    when running the test tasks, as shown next:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的测试框架添加到正确的依赖配置中，使其对我们的代码可用。我们还让Gradle知道，在运行测试任务时应该使用JUnit，如下所示：
- en: '[PRE66]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `testImplementation` configuration makes `org.junit.jupiter` available when
    building and executing test—but not main—code. When we next run the `./gradlew
    build`, you’ll see that it’s downloading the library into our local cache if it
    wasn’t already there.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`testImplementation`配置使得`org.junit.jupiter`在构建和执行测试代码时可用——但不包括主代码。当我们再次运行`./gradlew
    build`时，你会看到如果它还没有在本地缓存中，它将下载库。'
- en: Full listings with stack traces, including an HTML-based report, are generated
    under `build/reports/test`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 包括基于HTML的报告在内的完整列表和堆栈跟踪生成在`build/reports/test`下。
- en: 11.3.10 Automating static analysis
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.10 自动化静态分析
- en: 'The build is a great place to add functionality to protect your project. One
    type of check beyond unit testing is static analysis. There are several tools
    in this category, but SpotBugs ([https://spotbugs.github.io/](https://spotbugs.github.io/))
    (the successor to FindBugs) is an easy one to get started with. Note that most
    of these tools have plugins for Maven as well as Gradle, so the treatment shown
    here is just to give you a taste of the possibilities:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 构建是一个添加功能以保护项目的绝佳地方。除了单元测试之外，还有一种检查方式是静态分析。这个类别中有几个工具，但SpotBugs ([https://spotbugs.github.io/](https://spotbugs.github.io/))（FindBugs的继任者）是一个容易上手的选择。请注意，这些工具中的大多数都有Maven和Gradle的插件，所以这里展示的处理方法只是为了给你一个可能性的尝鲜：
- en: '[PRE67]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we deliberately introduce a problem in our code (e.g., implementing `equals`
    on a class without also overriding `hashCode`), a typical `./gradlew check` will
    let us know there’s a problem, as illustrated here:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们故意在我们的代码中引入问题（例如，在一个类上实现`equals`而不重写`hashCode`），典型的`./gradlew check`将让我们知道存在问题，如下所示：
- en: '[PRE68]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'As with unit testing failures, report files are under `build/reports/spotbugs`.
    Out of the box, SpotBugs may generate only an XML file, which, although nice for
    computers, is less useful to most people. We can configure the plugin to emit
    HTML for us as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 就像单元测试失败一样，报告文件位于`build/reports/spotbugs`下。默认情况下，SpotBugs可能只生成一个XML文件，虽然对计算机来说很好，但对大多数人来说不太有用。我们可以配置插件以生成以下HTML：
- en: '[PRE69]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ❶ tasks.withType looks up tasks for us in a typesafe manner.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `tasks.withType`以类型安全的方式为我们查找任务。
- en: ❷ configureEach runs the block as if we had written tasks.spotbugsMain { } and
    then tasks.spotbugsTest { } with the same code.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `configureEach`运行块，就像我们编写了`tasks.spotbugsMain { }`和`tasks.spotbugsTest { }`具有相同代码一样。
- en: ❸ The remaining configuration is taken from the project’s README on GitHub ([http://mng.bz/Qvdm](http://mng.bz/Qvdm)).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 剩余的配置来自GitHub上项目的README（[http://mng.bz/Qvdm](http://mng.bz/Qvdm)）。
- en: 11.3.11 Moving beyond Java 8
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.11 超越Java 8
- en: 'In chapter 1, we noted the following series of modules that belonged with Java
    Enterprise Edition but were present in the core JDK. These were deprecated with
    JDK 9 and removed with JDK 11 but remain available as external libraries:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，我们提到了以下一系列属于Java企业版但存在于核心JDK中的模块。这些模块在JDK 9中被弃用，在JDK 11中被移除，但作为外部库仍然可用：
- en: '`java.activation` (JAF)'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.activation` (JAF)'
- en: '`java.corba` (CORBA)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.corba` (CORBA)'
- en: '`java.transaction` (JTA)'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.transaction` (JTA)'
- en: '`java.xml.bind` (JAXB)'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.bind` (JAXB)'
- en: '`java.xml.ws` (JAX-WS, plus some related technologies)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.ws` (JAX-WS，以及一些相关技术)'
- en: '`java.xml.ws.annotation` (Common Annotations)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.xml.ws.annotation` (通用注解)'
- en: 'If your project relies on any of these modules, your build might break when
    you move to a more recent JDK. Fortunately, you can add the following simple dependencies
    in your `build.gradle.kts` to address the issue:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目依赖于这些模块中的任何一个，当你迁移到更近期的JDK时，你的构建可能会中断。幸运的是，你可以在`build.gradle.kts`中添加以下简单的依赖关系来解决此问题：
- en: '[PRE70]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 11.3.12 Using Gradle with modules
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.12 使用Gradle与模块
- en: Like Maven, Gradle supports the JDK module system fully. Let’s break down what
    we need to alter to use our modular projects with Gradle.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 与Maven一样，Gradle完全支持JDK模块系统。让我们分解一下我们需要更改的内容，以便使用Gradle使用我们的模块化项目。
- en: A modular library
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块化库
- en: 'A modular library typically has two major structural differences: the change
    from using main to the module name in the directory under `src`, and the addition
    of a `module-info.java` file at the root of our module, as shown next:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块化库通常有两个主要结构差异：从使用`main`到在`src`目录下使用模块名称，以及在模块根目录中添加一个`module-info.java`文件，如下所示：
- en: '[PRE71]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ❶ The directory name aligned with our module
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 目录名称与我们的模块对齐
- en: ❷ We intend to keep this package hidden.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们打算保持此包隐藏。
- en: ❸ This package will be exported for use outside this module.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此包将导出以供此模块外使用。
- en: ❹ The module-info.java declarations for this module
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此模块的`module-info.java`声明
- en: 'Gradle doesn’t automatically find our altered source location, so we need to
    give it a hint in `build.gradle.kts` where to look as follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle不会自动找到我们更改的源位置，因此我们需要在`build.gradle.kts`中给出提示，如下所示：
- en: '[PRE72]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `module-info.java` file contains the typical declarations that we saw demonstrated
    earlier in this chapter and in chapter 2\. We’ll name our module and select one,
    but not both, of our packages to export like this:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`module-info.java`文件包含我们在本章和第2章中早期展示的典型声明。我们将命名我们的模块，并选择一个，而不是两个，的包导出如下：'
- en: '[PRE73]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That’s all that’s required to make our library consumable as a module. Next
    we’ll use the library from a modular app.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使我们的库作为模块可消费所需的所有内容。接下来，我们将从模块化应用程序中使用该库。
- en: A modular application
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块化应用程序
- en: When we set out to test our modular application under Maven, the simplest way
    to share the library we’d created with our app was to install it to the local
    Maven repository. This is also supported from Gradle via the `maven-publish` plugin,
    but we have another option that is worth understanding the mechanics of.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始使用Maven测试我们的模块化应用程序时，与我们的应用程序共享我们创建的库的最简单方法是将其安装到本地Maven仓库。这也通过`maven-publish`插件从Gradle支持，但我们还有一个值得了解其工作原理的选项。
- en: 'Our modular application has a standard layout as shown next. For ease of testing,
    we’ll make sure the top-level directories live next to each other:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块化应用程序的标准布局如下所示。为了便于测试，我们将确保顶级目录相邻：
- en: '[PRE74]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ❶ The mod-lib library source is at the same level as our mod-app application.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ mod-lib库源代码与我们的mod-app应用程序处于同一级别。
- en: ❷ The directory name is aligned with the module name.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 目录名与模块名对齐。
- en: ❸ We use module-info.java to declare this a modularized application.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们使用`module-info.java`来声明这是一个模块化应用程序。
- en: 'Our `module-info.java` file tells our name and module requirements, as shown
    here:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`module-info.java`文件显示了我们的名称和模块要求，如下所示：
- en: '[PRE75]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ❶ Our module name
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的模块名称
- en: ❷ Our requirement on our library’s exported packages
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们对库导出包的要求
- en: 'For testing our local library, rather than installing it, we’ll refer to it
    locally for the moment, as shown in the next code snippet. This can be accomplished
    using the `files` function in the spot where we’d previously have given the GAV
    coordinates for our dependency. This obviously won’t work once we’re ready to
    start sharing and deploying, but it’s a quick move to get our local testing started:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试我们的本地库，而不是安装它，我们暂时将其本地引用，如下所示的下一段代码。这可以通过在之前提供依赖项GAV坐标的位置使用`files`函数来实现。显然，一旦我们准备好开始共享和部署，这就不适用了，但这是一个快速开始本地测试的方法：
- en: '[PRE76]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next up, current versions of Gradle require a hint that we want it to sniff
    out which dependencies are modular to properly put them on the module path instead
    of the classpath as follows. This may become a default eventually, but at the
    time of this writing (Gradle 7.3) it remains an opt-in:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当前版本的Gradle需要我们提供一个提示，表示我们希望它检测哪些依赖项是模块化的，以便正确地将它们放在模块路径上而不是类路径上，如下所示。这最终可能成为默认设置，但在此写作时（Gradle
    7.3），它仍然是一个可选设置：
- en: '[PRE77]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Last and most mundanely, like our library, we need to let Gradle know about
    our non-Maven standard file location as follows:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，也是最平凡的，就像我们的库一样，我们需要让Gradle知道我们的非Maven标准文件位置，如下所示：
- en: '[PRE78]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'With all this in place, `./gradlew build run` has the expected result. If we
    attempt to use a package from the library that isn’t exported, we confront the
    error at compilation time as shown here:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备就绪后，`./gradlew build run`会产生预期的结果。如果我们尝试使用未导出的库包，我们将在编译时遇到如下错误：
- en: '[PRE79]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: JLink
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: JLink
- en: A capability we saw in chapter 2 that modules unlock is the ability to create
    a streamlined environment for an application to work in, with only the dependencies
    it requires. This is possible because the module system gives us concrete guarantees
    about which modules our code uses, so tooling can construct the necessary, minimal
    set of modules.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中我们看到的模块解锁的能力之一是，可以为应用程序创建一个仅包含其所需依赖项的精简环境。这是可能的，因为模块系统为我们提供了关于我们的代码使用哪些模块的明确保证，因此工具可以构建必要的、最小的模块集。
- en: Note JLink can work only with fully modularized applications. If an application
    is still loading some code via the classpath, JLink can’t succeed in making a
    safe, complete image.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 注意JLink只能与完全模块化的应用程序一起工作。如果一个应用程序仍然通过类路径加载一些代码，JLink将无法成功创建一个安全、完整的镜像。
- en: This feature is most evident through the `jlink` tool. For a modular application,
    JLink can produce a fully functioning JVM image that can be run without depending
    on a system-installed JVM.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能通过`jlink`工具最为明显。对于模块化应用程序，JLink可以生成一个完全功能的JVM镜像，可以在不依赖于系统安装的JVM的情况下运行。
- en: Let’s revisit the application from chapter 2 that we demonstrated JLink with
    to see how Gradle plugins streamline the management. The sample application, available
    in the supplement, uses JDK classes to attach to all the running JVM processes
    on a machine and display various information about them.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下第二章中我们使用JLink演示的应用程序，看看Gradle插件如何简化管理。该示例应用程序可在补充材料中找到，它使用JDK类连接到机器上所有正在运行的JVM进程，并显示有关它们的各种信息。
- en: 'In the modular application we’re going to package, an important bit to review
    is the application’s own `module-info.java` declarations. As shown next, these
    tell us what JLink will need to pull into it’s custom image for our build to work:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们要打包的模块化应用程序中，一个重要的审查点是应用程序自己的`module-info.java`声明。如下所示，这些声明告诉我们JLink需要将其拉入自定义镜像以使我们的构建工作：
- en: '[PRE80]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '❶ Red flag: note the jdk.internal package that we’re reaching into!'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 警示标志：注意我们正在访问的`jdk.internal`包！
- en: 'Before we even get started with JLink, moving from hand-compiling to our Gradle
    build takes a little extra configuration. We need to apply the same modularization
    changes explained in the preceding section as a start as follows. But even once
    those are in place, we can’t compile successfully:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用JLink之前，从手动编译到Gradle构建需要一些额外的配置。我们需要将前面章节中解释的相同模块化更改作为起点应用，如下所示。但即使这些更改到位，我们也无法成功编译：
- en: '[PRE81]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The module system is letting us know that we’re breaking the rules by trying
    to use classes that are in `jdk.internal.jvmstat`. Our module, `wgjd.discovery`
    is not included in the `jdk.internal.jvmstat` list of allowed modules. Understanding
    the rules and the risks we’re taking, we can use `--add-exports` to force our
    module into the list. This is done via a compiler flag, and looks like this in
    our Gradle configuration:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 模块系统让我们知道，我们正在试图使用`jdk.internal.jvmstat`中的类，这是违反规则的。我们的模块`wgjd.discovery`不包括在允许的`jdk.internal.jvmstat`模块列表中。了解规则和我们所承担的风险后，我们可以使用`--add-exports`来强制我们的模块进入列表。这是通过编译器标志完成的，并在我们的Gradle配置中看起来如下所示：
- en: '[PRE82]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: With that we get a clean compile and we can turn to using JLink to package it
    up. The plugin with the most mindshare today is `org.beryx.jlink`, known in the
    documentation as “The Badass JLink Plugin” ([https://badass-jlink-plugin.beryx.org](https://badass-jlink-plugin.beryx.org)).
    We add it to our Gradle project with a plugin line.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就得到了干净的编译，我们可以转向使用JLink来打包它。目前最具影响力的插件是`org.beryx.jlink`，在文档中被称为“坏小子JLink插件”([https://badass-jlink-plugin.beryx.org](https://badass-jlink-plugin.beryx.org))。我们通过插件行将其添加到我们的Gradle项目中。
- en: '[PRE83]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ❶ This plugin automatically applies application for us, so we don’t need to
    repeat that declaration.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此插件会自动为我们应用，因此我们不需要重复该声明。
- en: 'After adding that, we’ll see a `jlink` task in our list, which we can run straight
    away. The result will show up in the `build/image` directory like this:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加之后，我们将在列表中看到`jlink`任务，我们可以立即运行它。结果将显示在`build/image`目录中，如下所示：
- en: '[PRE84]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `build/image/bin/java` is our custom JVM with only our application’s module
    dependencies available to it. You can run it just like you would your normal `java`
    command from the terminal as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`build/image/bin/java`是我们定制的JVM，它只对我们的应用程序模块依赖项可用。您可以从终端像运行正常的`java`命令一样运行它，如下所示：'
- en: '[PRE85]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We can pass `build/image/bin/java` our module to start up, but the plugin has
    neatly generated a startup script at `build/image/bin/gradle-jlink` (named after
    our project and shown next) that we can use instead. But not all is well with
    our newly minted image:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的模块传递给`build/image/bin/java`以启动，但插件已经为我们干净利落地生成了一个启动脚本，位于`build/image/bin/gradle-jlink`（以我们的项目命名，如下所示），我们可以使用它代替。但我们的新铸造镜像并非一切顺利：
- en: '[PRE86]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This isn’t an entirely unfamiliar error message—it’s another flavor of the
    same access issue we solved with the compiler options earlier. Apparently we need
    to inform the application startup of our module-cheating needs as well. Fortunately,
    the plugin has extensive configuration for the parameters both to run `jlink`
    and for the resulting scripts created for us, as shown here:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是完全陌生的错误消息——这是我们在早期通过编译器选项解决的相同访问问题的另一种风味。显然，我们需要通知应用程序启动我们的模块欺骗需求。幸运的是，插件为我们提供了广泛的配置，包括运行`jlink`和为我们创建的脚本，如下所示：
- en: '[PRE87]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'With that addition, the startup script gets everything running as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此功能后，启动脚本将按以下方式运行一切：
- en: '[PRE88]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'It’s worth noting that the image we generated here defaults to targeting the
    same operating system that JLink is running on, as illustrated in the next code
    sample. However, that isn’t required—cross-platform support is available. The
    primary requirement is that you have the files from the target platform’s JDK
    installation available. These are easily available from sources such as the Eclipse
    Adoptium website at [https://adoptium.net/](https://adoptium.net/):'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在这里生成的镜像默认针对的是JLink正在运行的相同操作系统，如下一个代码示例所示。然而，这并不是必需的——跨平台支持是可用的。主要要求是您有目标平台JDK安装的文件可用。这些文件可以从Eclipse
    Adoptium网站等来源轻松获得：[https://adoptium.net/](https://adoptium.net/)：
- en: '[PRE89]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: ❶ Builds an image based on whatever the local JDK is
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 基于本地JDK构建镜像
- en: ❷ Builds an image pointed to a Linux JDK we’ve downloaded
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构建指向我们已下载的Linux JDK的镜像
- en: Once you start targeting specific platforms, the plugin will put additional
    directories in the `build/image` results. Obviously, you’ll have to take those
    results to a matching system to test them.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始针对特定平台，插件将在`build/image`结果中放置额外的目录。显然，您必须将这些结果带到匹配的系统中去测试它们。
- en: A final roadblock that may come up in trying to use JLink is its restrictions
    around automatically named modules. Although the feature to just add a name into
    the JAR manifest and get some basic ability to participate in the modular world
    is great for migrations, JLink sadly doesn’t support it.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用JLink时可能会遇到的一个最终障碍是其对自动命名模块的限制。虽然将名称添加到JAR清单中并获得参与模块化世界的基本能力对于迁移来说是个不错的功能，但遗憾的是，JLink不支持它。
- en: The Badass JLink Plugin, though, has you covered. It will repackage any automatically
    named modules into a proper module that JLink can consume. The documentation (found
    at [http://mng.bz/XZ2Y](http://mng.bz/XZ2Y)) gives full coverage to this feature,
    which may be the difference between JLink working or not, depending on your application’s
    dependencies.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Badass JLink Plugin可以解决您的问题。它将重新打包任何自动命名的模块，使其成为JLink可以消费的正确模块。文档（可在[http://mng.bz/XZ2Y](http://mng.bz/XZ2Y)找到）对此功能进行了全面介绍，这可能是JLink是否工作以及根据您的应用程序依赖项的不同而有所区别的关键。
- en: 11.3.13 Customizing
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.13 自定义
- en: One of Gradle’s biggest strengths is its open-ended flexibility. Without pulling
    in plugins, it doesn’t even have a concept of a build lifecycle. You can add tasks
    and reconfigure existing tasks with few restrictions. There’s no need to keep
    a `scripts` directory around in your project with random tooling—your custom needs
    can be integrated right into your day-to-day build and testing tool.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle最大的优势之一是其开放式的灵活性。不引入插件，它甚至没有构建生命周期的概念。您可以添加任务，并重新配置现有任务，几乎没有限制。不需要在项目中保留`scripts`目录以及随机的工具——您的自定义需求可以直接集成到您的日常构建和测试工具中。
- en: Custom tasks
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义任务
- en: 'Defining a custom task can be done directly in your `build.gradle.kts` file
    like this:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义任务可以直接在您的`build.gradle.kts`文件中这样做：
- en: '[PRE90]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Running this will produce the following output:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将产生以下输出：
- en: '[PRE91]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `println("configuring")` line is run during setup of the task, but the
    contents of the `doLast` block happens when the task actually ran. We can confirm
    this by doing a dry-run on our task as follows:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`println("configuring")`这一行在任务设置期间运行，但`doLast`块的内容是在任务实际运行时发生的。我们可以通过以下方式对任务进行dry-run来确认这一点：'
- en: '[PRE92]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Tasks can be configured to depend on other tasks, as shown next:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置任务以依赖于其他任务，如下所示：
- en: '[PRE93]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This technique applies equally well to tasks you didn’t author—you can look
    them up and add your task as a dependency like so:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术同样适用于您没有编写的任务——您可以查找它们，并将您的任务作为依赖项添加，如下所示：
- en: '[PRE94]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'It’s extremely powerful to be able to write custom tasks directly in your build
    file. However, putting them in `build.gradle.kts` has a few rather severe limitations:
    they cannot be easily shared between projects, and they aren’t easy to write automated
    tests against. Gradle plugins are built to address just those issues.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 能够直接在构建文件中编写自定义任务非常强大。然而，将它们放在`build.gradle.kts`中确实有几个相当严重的限制：它们不能很容易地在项目之间共享，而且编写针对它们的自动化测试也不容易。Gradle插件就是为了解决这些问题而构建的。
- en: Creating custom plugins
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义插件
- en: Gradle plugins are implemented as JVM code. They can be provided directly in
    your project as source files, or they can be pulled in through libraries. Many
    plugins have been written in Groovy, the original scripting language supported
    by Gradle, but you can do it in any JVM language. For the largest compatibility
    and to minimize issues with specific language idioms, if you plan to share your
    plugin, writing it in Java is a good idea.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle插件作为JVM代码实现。它们可以直接作为源文件提供到您的项目中，或者通过库来引入。许多插件是用Groovy编写的，这是Gradle最初支持的脚本语言，但您可以使用任何JVM语言。如果您打算分享您的插件，用Java编写是一个好主意，以实现最大的兼容性和最小化特定语言习惯用法的问题。
- en: 'Plugins can be coded directly in your buildscript, and we’ll demonstrate the
    main APIs using that technique. When you’re ready to share, you can pull the code
    into its own separate project. Here is an equivalent to our earlier `wellgrounded`
    task:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 插件可以直接在您的构建脚本中编码，我们将使用该技术演示主要API。当您准备好分享时，可以将代码拉入其自己的独立项目。以下是我们之前`wellgrounded`任务的等效代码：
- en: '[PRE95]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: ❶ Derives from Plugin
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 继承自Plugin
- en: ❷ Uses familiar project-level API and task implementation
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用熟悉的project-level API和任务实现
- en: ❸ Use apply to actually use the plugin—it isn’t automatically invoked like our
    earlier task definition.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用`apply`来实际使用插件——它不像我们之前的任务定义那样自动调用。
- en: 'Apart from sharing, authoring tasks as plugins allows us more ability to customize
    configuration. The standard Gradle object representing our `Project` has a specific
    place where plugin configurations live under an `extensions` property. We can
    add to these extensions with our own `Extension` objects as follows:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 除了共享之外，将作者任务作为插件可以让我们有更多的能力来自定义配置。代表我们的`Project`的标准Gradle对象在`extensions`属性下有一个特定的位置来存放插件配置。我们可以通过以下方式添加自己的`Extension`对象来扩展这些扩展：
- en: '[PRE96]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: All the power of our programming language is available within our plugins.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编程语言的所有功能都在我们的插件中可用。
- en: 'If you extract a plugin to another library, you can include it in your build
    through the same mechanism we saw earlier for including the SpotBugs plugin, as
    shown here:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将插件提取到另一个库中，你可以通过我们之前看到的包括SpotBugs插件的方式，通过相同的机制将插件包含在你的构建中，如下所示：
- en: '[PRE97]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Summary
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Build tools are central to how Java software is constructed in the real world.
    They automate tedious operations, help with dependency management, ensure that
    developers are doing their work consistently, and, critically, ensure that the
    same project built on different machines gets the same results.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具在现实世界中构建Java软件的方式中起着核心作用。它们自动化繁琐的操作，帮助管理依赖关系，确保开发者工作的一致性，并且，关键的是，确保在不同机器上构建的相同项目得到相同的结果。
- en: Maven and Gradle are the two most common build tools in the Java ecosystem,
    and most tasks can be accomplished in either.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven和Gradle是Java生态系统中最常用的两个构建工具，大多数任务都可以在这两个工具中完成。
- en: Maven takes an approach of configuration via XML combined with plugins written
    in JVM code.
  id: totrans-553
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven采用了一种通过XML进行配置并结合使用JVM代码编写的插件的方法。
- en: Gradle provides a declarative build language using an actual programming language
    (Kotlin or Groovy), resulting in concise build logic for simple cases and flexibility
    for complex use cases.
  id: totrans-554
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle提供了一个使用实际编程语言（Kotlin或Groovy）的声明式构建语言，对于简单情况，这导致了简洁的构建逻辑，对于复杂用例，则提供了灵活性。
- en: Dealing with conflicting dependencies is a major topic whatever your build tool.
    Both Maven and Gradle give you ways to handle conflicting library versions. Gradle
    provides a number of more advanced features for dealing with common dependency
    management issues.
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理冲突的依赖关系是无论你的构建工具是什么都是一个主要话题。Maven和Gradle都为你提供了处理库版本冲突的方法。Gradle提供了更多高级功能来处理常见的依赖关系管理问题。
- en: Gradle offers features for work avoidance such as incremental builds, resulting
    in faster builds.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle提供了诸如增量构建等避免工作的功能，从而实现了更快的构建。
- en: Modules, as seen in chapter 2, require some changes to our build scripting and
    source code layout, but these are well supported by the tooling.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块，如第2章所述，需要对我们的构建脚本和源代码布局进行一些修改，但这些修改得到了工具的良好支持。
